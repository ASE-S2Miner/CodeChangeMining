[{"original_method":"/**\n   * <p>Inspection tool ID is a descriptive name to be used in \"suppress\" comments and annotations.\n   * <p>It must satisfy {@link #VALID_ID_PATTERN} regexp pattern.\n   * <p>If not defined {@link #getShortName()} is used as tool ID.\n   *\n   * @return inspection tool ID.\n   */\n  @Pattern(VALID_ID_PATTERN)\n  @NonNls\n  @NotNull\n  public String getID() {\n    return getShortName();\n  }","id":72000,"modified_method":"/**\n   * <p>Inspection tool ID is a descriptive name to be used in \"suppress\" comments and annotations.\n   * <p>It must satisfy {@link #VALID_ID_PATTERN} regexp pattern.\n   * <p>If not defined {@link #getShortName()} is used as tool ID.\n   *\n   * @return inspection tool ID.\n   */\n  @Pattern(VALID_ID_PATTERN)\n  @NonNls\n  @NotNull\n  public String getID() {\n    if (myNameProvider instanceof LocalDefaultNameProvider) {\n      final String id = ((LocalDefaultNameProvider)myNameProvider).getID();\n      if (id != null) {\n        return id;\n      }\n    }\n    return getShortName();\n  }","commit_id":"1eef8f0897613bd03f3fa417c65a408c9b9cb88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\t\tprotected DefinitionsFactory createDefinitionsFactory(TilesApplicationContext applicationContext,\n\t\t\t\tTilesRequestContextFactory contextFactory, LocaleResolver resolver) {\n\t\t\tif (definitionsFactoryClass != null) {\n\t\t\t\treturn BeanUtils.instantiate(definitionsFactoryClass);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn super.createDefinitionsFactory(applicationContext, contextFactory, resolver);\n\t\t\t}\n\t\t}","id":72001,"modified_method":"@Override\n\t\tprotected DefinitionsFactory createDefinitionsFactory(TilesApplicationContext applicationContext,\n\t\t\t\tTilesRequestContextFactory contextFactory, LocaleResolver resolver) {\n\t\t\tif (definitionsFactoryClass != null) {\n\t\t\t\tDefinitionsFactory factory = BeanUtils.instantiate(definitionsFactoryClass);\n\t\t\t\tif (factory instanceof TilesApplicationContextAware) {\n\t\t\t\t\t((TilesApplicationContextAware) factory).setApplicationContext(applicationContext);\n\t\t\t\t}\n\t\t\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(factory);\n\t\t\t\tif (bw.isWritableProperty(\"localeResolver\")) {\n\t\t\t\t\tbw.setPropertyValue(\"localeResolver\", resolver);\n\t\t\t\t}\n\t\t\t\tif (bw.isWritableProperty(\"definitionDAO\")) {\n\t\t\t\t\tbw.setPropertyValue(\"definitionDAO\",\n\t\t\t\t\t\t\tcreateLocaleDefinitionDao(applicationContext, contextFactory, resolver));\n\t\t\t\t}\n\t\t\t\tif (factory instanceof Refreshable) {\n\t\t\t\t\t((Refreshable) factory).refresh();\n\t\t\t\t}\n\t\t\t\treturn factory;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn super.createDefinitionsFactory(applicationContext, contextFactory, resolver);\n\t\t\t}\n\t\t}","commit_id":"8ce4037af231ca902c9c0392b666a02a5c30377a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Plugin addPlugin(String groupId, String artifactId) {\n\t\tif (m_model.getBuild() == null) {\n\t\t\tm_model.setBuild(new Build());\n\t\t}\n\t\t\n\t\tPlugin plugin = new Plugin();\n\t\tplugin.setGroupId(groupId);\n\t\tplugin.setArtifactId(artifactId);\n\t\tm_model.getBuild().addPlugin(plugin);\n\t\t\n\t\treturn plugin;\n\t}","id":72002,"modified_method":"public Plugin addPlugin(String groupId, String artifactId) {\n\t\tif (m_model.getBuild() == null) {\n\t\t\tm_model.setBuild(new Build());\n\t\t}\n\t\t\n\t\tPlugin plugin = getPlugin(groupId, artifactId);\n\t\tif (plugin == null) {\n\t\t    plugin = new Plugin();\n\t\t    plugin.setGroupId(groupId);\n\t\t    plugin.setArtifactId(artifactId);\n\t\t    m_model.getBuild().addPlugin(plugin);\n\t\t}\n\t\treturn plugin;\n\t}","commit_id":"6dd2426ff672c1b0dd080a0f74083e04507e9080","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SourceType(String typeName) {\n\t\tm_typeName = typeName;\n\t}","id":72003,"modified_method":"public SourceType(String typeName) {\n\t\tm_typeName = typeName;\n\t}","commit_id":"6dd2426ff672c1b0dd080a0f74083e04507e9080","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static SourceType get(String typeName) {\n\t\treturn new SourceType(typeName);\n\t}","id":72004,"modified_method":"public static SourceType get(String typeName) {\n        try {\n            Class typeClass = Configuration.get().getClass(\"sourceType.\"+typeName+\".class\", SourceType.class);\n            return (SourceType)(new Reflector()).newInstance(typeClass, new Object[] { typeName });\n        } catch (ReflectorException e) {\n            throw new RuntimeException(\"could not construct instance for sourceType \"+typeName, e);\n        }\n\t}","commit_id":"6dd2426ff672c1b0dd080a0f74083e04507e9080","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void renderForm(StringBuilder buf, int index, String prefix, String name, TunnelPoolSettings in, TunnelPoolSettings out) {\n\n        buf.append(\"<tr><th colspan=\\\"3\\\"><a name=\\\"\").append(prefix).append(\"\\\">\");\n        buf.append(name).append(\"<\/a><\/th><\/tr>\\n\");\n        if (in.getLength() <= 0 ||\n            in.getLength() + in.getLengthVariance() <= 0 ||\n            out.getLength() <= 0 ||\n            out.getLength() + out.getLengthVariance() <= 0)\n            buf.append(\"<tr><th colspan=\\\"3\\\"><font color=\\\"red\\\">\" + _(\"ANONYMITY WARNING - Settings include 0-hop tunnels.\") + \"<\/font><\/th><\/tr>\");\n        else if (in.getLength() <= 1 ||\n            in.getLength() + in.getLengthVariance() <= 1 ||\n            out.getLength() <= 1 ||\n            out.getLength() + out.getLengthVariance() <= 1)\n            buf.append(\"<tr><th colspan=\\\"3\\\"><font color=\\\"red\\\">\" + _(\"ANONYMITY WARNING - Settings include 1-hop tunnels.\") + \"<\/font><\/th><\/tr>\");\n        if (in.getLength() + Math.abs(in.getLengthVariance()) >= WARN_LENGTH ||\n            out.getLength() + Math.abs(out.getLengthVariance()) >= WARN_LENGTH)\n            buf.append(\"<tr><th colspan=\\\"3\\\"><font color=\\\"red\\\">\" + _(\"PERFORMANCE WARNING - Settings include very long tunnels.\") + \"<\/font><\/th><\/tr>\");\n        if (in.getTotalQuantity() >= WARN_QUANTITY ||\n            out.getTotalQuantity() >= WARN_QUANTITY)\n            buf.append(\"<tr><th colspan=\\\"3\\\"><font color=\\\"red\\\">\" + _(\"PERFORMANCE WARNING - Settings include high tunnel quantities.\") + \"<\/font><\/th><\/tr>\");\n\n        buf.append(\"<tr><th><\/th><th><img src=\\\"/themes/console/images/inbound.png\\\" alt=\\\"Inbound\\\" title=\\\"Inbound Tunnels\\\">&nbsp;&nbsp;\" + _(\"Inbound\") + \"<\/th><th><img src=\\\"/themes/console/images/outbound.png\\\" alt=\\\"Outbound Tunnels\\\" title=\\\"Outbound\\\">&nbsp;&nbsp;\" + _(\"Outbound\") + \"<\/th><\/tr>\\n\");\n\n//        buf.append(\"<tr><th><\/th><th>Inbound<\/th><th>Outbound<\/th><\/tr>\\n\");\n        \n        // tunnel depth\n        buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Length\") + \":<\/td>\\n\");\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".depthInbound\\\">\\n\");\n        int now = in.getLength();\n        renderOptions(buf, 0, MAX_LENGTH, now, \"\", HOP);\n        if (now > MAX_LENGTH)\n            renderOptions(buf, now, now, now, \"\", HOP);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".depthOutbound\\\">\\n\");\n        now = out.getLength();\n        renderOptions(buf, 0, MAX_LENGTH, now, \"\", HOP);\n        if (now > MAX_LENGTH)\n            renderOptions(buf, now, now, now, \"\", HOP);\n        buf.append(\"<\/select><\/td>\\n\");\n        buf.append(\"<\/tr>\\n\");\n\n        // tunnel depth variance\n        buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Randomization\") + \":<\/td>\\n\");\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".varianceInbound\\\">\\n\");\n        now = in.getLengthVariance();\n        renderOptions(buf, 0, 0, now, \"\", HOP);\n        renderOptions(buf, 1, MAX_VARIANCE, now, \"+ 0-\", HOP);\n        renderOptions(buf, MIN_NEG_VARIANCE, -1, now, \"+/- 0\", HOP);\n        if (now > MAX_VARIANCE)\n            renderOptions(buf, now, now, now, \"+ 0-\", HOP);\n        else if (now < MIN_NEG_VARIANCE)\n            renderOptions(buf, now, now, now, \"+/- 0\", HOP);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".varianceOutbound\\\">\\n\");\n        now = out.getLengthVariance();\n        renderOptions(buf, 0, 0, now, \"\", HOP);\n        renderOptions(buf, 1, MAX_VARIANCE, now, \"+ 0-\", HOP);\n        renderOptions(buf, MIN_NEG_VARIANCE, -1, now, \"+/- 0\", HOP);\n        if (now > MAX_VARIANCE)\n            renderOptions(buf, now, now, now, \"+ 0-\", HOP);\n        else if (now < MIN_NEG_VARIANCE)\n            renderOptions(buf, now, now, now, \"+/- 0\", HOP);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        // tunnel quantity\n        buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Quantity\") + \":<\/td>\\n\");\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".quantityInbound\\\">\\n\");\n        now = in.getQuantity();\n        renderOptions(buf, 1, MAX_QUANTITY, now, \"\", TUNNEL);\n        if (now > MAX_QUANTITY)\n            renderOptions(buf, now, now, now, \"\", TUNNEL);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".quantityOutbound\\\">\\n\");\n        now = out.getQuantity();\n        renderOptions(buf, 1, MAX_QUANTITY, now, \"\", TUNNEL);\n        if (now > MAX_QUANTITY)\n            renderOptions(buf, now, now, now, \"\", TUNNEL);\n        buf.append(\"<\/select><\/td>\\n\");\n        buf.append(\"<\/tr>\\n\");\n\n        // tunnel backup quantity\n        buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Backup quantity\") + \":<\/td>\\n\");\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".backupInbound\\\">\\n\");\n        now = in.getBackupQuantity();\n        renderOptions(buf, 0, MAX_BACKUP_QUANTITY, now, \"\", TUNNEL);\n        if (now > MAX_BACKUP_QUANTITY)\n            renderOptions(buf, now, now, now, \"\", TUNNEL);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".backupOutbound\\\">\\n\");\n        now = out.getBackupQuantity();\n        renderOptions(buf, 0, MAX_BACKUP_QUANTITY, now, \"\", TUNNEL);\n        if (now > MAX_BACKUP_QUANTITY)\n            renderOptions(buf, now, now, now, \"\", TUNNEL);\n        buf.append(\"<\/select><\/td>\\n\");\n        buf.append(\"<\/tr>\\n\");\n\n        // custom options\n        // There is no facility to set these, either in ConfigTunnelsHandler or\n        // TunnelPoolOptions, so make the boxes readonly.\n        // And let's not display them at all unless they have contents, which should be rare.\n        Properties props = in.getUnknownOptions();\n        if (!props.isEmpty()) {\n            buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Inbound options\") + \":<\/td>\\n\" +\n                       \"<td colspan=\\\"2\\\" align=\\\"center\\\"><input name=\\\"\").append(index);\n            buf.append(\".inboundOptions\\\" type=\\\"text\\\" size=\\\"32\\\" disabled=\\\"disabled\\\" \" +\n                       \"value=\\\"\");\n            for (Iterator iter = props.keySet().iterator(); iter.hasNext(); ) {\n                String prop = (String)iter.next();\n                String val = props.getProperty(prop);\n                buf.append(prop).append('=').append(val).append(' ');\n            }\n            buf.append(\"\\\"><\/td><\/tr>\\n\");\n        }\n        props = out.getUnknownOptions();\n        if (!props.isEmpty()) {\n            buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Outbound options\") + \":<\/td>\\n\" +\n                       \"<td colspan=\\\"2\\\" align=\\\"center\\\"><input name=\\\"\").append(index);\n            buf.append(\".outboundOptions\\\" type=\\\"text\\\" size=\\\"32\\\" disabled=\\\"disabled\\\" \" +\n                       \"value=\\\"\");\n            for (Iterator iter = props.keySet().iterator(); iter.hasNext(); ) {\n                String prop = (String)iter.next();\n                String val = props.getProperty(prop);\n                buf.append(prop).append('=').append(val).append(' ');\n            }\n            buf.append(\"\\\"><\/td><\/tr>\\n\");\n        }\n//        buf.append(\"<tr><td colspan=\\\"3\\\"><br><\/td><\/tr>\\n\");\n    }","id":72005,"modified_method":"private void renderForm(StringBuilder buf, int index, String prefix, String name, TunnelPoolSettings in, TunnelPoolSettings out) {\n\n        boolean advanced = _context.getBooleanProperty(PROP_ADVANCED);\n\n        buf.append(\"<tr><th colspan=\\\"3\\\"><a name=\\\"\").append(prefix).append(\"\\\">\");\n        buf.append(name).append(\"<\/a><\/th><\/tr>\\n\");\n        if (in.getLength() <= 0 ||\n            in.getLength() + in.getLengthVariance() <= 0 ||\n            out.getLength() <= 0 ||\n            out.getLength() + out.getLengthVariance() <= 0)\n            buf.append(\"<tr><th colspan=\\\"3\\\"><font color=\\\"red\\\">\" + _(\"ANONYMITY WARNING - Settings include 0-hop tunnels.\") + \"<\/font><\/th><\/tr>\");\n        else if (in.getLength() <= 1 ||\n            in.getLength() + in.getLengthVariance() <= 1 ||\n            out.getLength() <= 1 ||\n            out.getLength() + out.getLengthVariance() <= 1)\n            buf.append(\"<tr><th colspan=\\\"3\\\"><font color=\\\"red\\\">\" + _(\"ANONYMITY WARNING - Settings include 1-hop tunnels.\") + \"<\/font><\/th><\/tr>\");\n        if (in.getLength() + Math.abs(in.getLengthVariance()) >= WARN_LENGTH ||\n            out.getLength() + Math.abs(out.getLengthVariance()) >= WARN_LENGTH)\n            buf.append(\"<tr><th colspan=\\\"3\\\"><font color=\\\"red\\\">\" + _(\"PERFORMANCE WARNING - Settings include very long tunnels.\") + \"<\/font><\/th><\/tr>\");\n        if (in.getTotalQuantity() >= WARN_QUANTITY ||\n            out.getTotalQuantity() >= WARN_QUANTITY)\n            buf.append(\"<tr><th colspan=\\\"3\\\"><font color=\\\"red\\\">\" + _(\"PERFORMANCE WARNING - Settings include high tunnel quantities.\") + \"<\/font><\/th><\/tr>\");\n\n        buf.append(\"<tr><th><\/th><th><img src=\\\"/themes/console/images/inbound.png\\\" alt=\\\"Inbound\\\" title=\\\"Inbound Tunnels\\\">&nbsp;&nbsp;\" + _(\"Inbound\") + \"<\/th><th><img src=\\\"/themes/console/images/outbound.png\\\" alt=\\\"Outbound Tunnels\\\" title=\\\"Outbound\\\">&nbsp;&nbsp;\" + _(\"Outbound\") + \"<\/th><\/tr>\\n\");\n\n//        buf.append(\"<tr><th><\/th><th>Inbound<\/th><th>Outbound<\/th><\/tr>\\n\");\n        \n        // tunnel depth\n        int maxLength = advanced ? MAX_ADVANCED_LENGTH : MAX_LENGTH;\n        buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Length\") + \":<\/td>\\n\");\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".depthInbound\\\">\\n\");\n        int now = in.getLength();\n        renderOptions(buf, 0, maxLength, now, \"\", HOP);\n        if (now > maxLength)\n            renderOptions(buf, now, now, now, \"\", HOP);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".depthOutbound\\\">\\n\");\n        now = out.getLength();\n        renderOptions(buf, 0, maxLength, now, \"\", HOP);\n        if (now > maxLength)\n            renderOptions(buf, now, now, now, \"\", HOP);\n        buf.append(\"<\/select><\/td>\\n\");\n        buf.append(\"<\/tr>\\n\");\n\n        // tunnel depth variance\n        buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Randomization\") + \":<\/td>\\n\");\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".varianceInbound\\\">\\n\");\n        now = in.getLengthVariance();\n        renderOptions(buf, 0, 0, now, \"\", HOP);\n        renderOptions(buf, 1, MAX_VARIANCE, now, \"+ 0-\", HOP);\n        renderOptions(buf, MIN_NEG_VARIANCE, -1, now, \"+/- 0\", HOP);\n        if (now > MAX_VARIANCE)\n            renderOptions(buf, now, now, now, \"+ 0-\", HOP);\n        else if (now < MIN_NEG_VARIANCE)\n            renderOptions(buf, now, now, now, \"+/- 0\", HOP);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".varianceOutbound\\\">\\n\");\n        now = out.getLengthVariance();\n        renderOptions(buf, 0, 0, now, \"\", HOP);\n        renderOptions(buf, 1, MAX_VARIANCE, now, \"+ 0-\", HOP);\n        renderOptions(buf, MIN_NEG_VARIANCE, -1, now, \"+/- 0\", HOP);\n        if (now > MAX_VARIANCE)\n            renderOptions(buf, now, now, now, \"+ 0-\", HOP);\n        else if (now < MIN_NEG_VARIANCE)\n            renderOptions(buf, now, now, now, \"+/- 0\", HOP);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        // tunnel quantity\n        int maxQuantity = advanced ? MAX_ADVANCED_QUANTITY : MAX_QUANTITY;\n        buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Quantity\") + \":<\/td>\\n\");\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".quantityInbound\\\">\\n\");\n        now = in.getQuantity();\n        renderOptions(buf, 1, maxQuantity, now, \"\", TUNNEL);\n        if (now > maxQuantity)\n            renderOptions(buf, now, now, now, \"\", TUNNEL);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".quantityOutbound\\\">\\n\");\n        now = out.getQuantity();\n        renderOptions(buf, 1, maxQuantity, now, \"\", TUNNEL);\n        if (now > maxQuantity)\n            renderOptions(buf, now, now, now, \"\", TUNNEL);\n        buf.append(\"<\/select><\/td>\\n\");\n        buf.append(\"<\/tr>\\n\");\n\n        // tunnel backup quantity\n        int maxBQuantity = advanced ? MAX_ADVANCED_BACKUP_QUANTITY : MAX_BACKUP_QUANTITY;\n        buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Backup quantity\") + \":<\/td>\\n\");\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".backupInbound\\\">\\n\");\n        now = in.getBackupQuantity();\n        renderOptions(buf, 0, maxBQuantity, now, \"\", TUNNEL);\n        if (now > maxBQuantity)\n            renderOptions(buf, now, now, now, \"\", TUNNEL);\n        buf.append(\"<\/select><\/td>\\n\");\n\n        buf.append(\"<td align=\\\"center\\\"><select name=\\\"\").append(index).append(\".backupOutbound\\\">\\n\");\n        now = out.getBackupQuantity();\n        renderOptions(buf, 0, maxBQuantity, now, \"\", TUNNEL);\n        if (now > maxBQuantity)\n            renderOptions(buf, now, now, now, \"\", TUNNEL);\n        buf.append(\"<\/select><\/td>\\n\");\n        buf.append(\"<\/tr>\\n\");\n\n        // custom options\n        // There is no facility to set these, either in ConfigTunnelsHandler or\n        // TunnelPoolOptions, so make the boxes readonly.\n        // And let's not display them at all unless they have contents, which should be rare.\n        Properties props = in.getUnknownOptions();\n        if (!props.isEmpty()) {\n            buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Inbound options\") + \":<\/td>\\n\" +\n                       \"<td colspan=\\\"2\\\" align=\\\"center\\\"><input name=\\\"\").append(index);\n            buf.append(\".inboundOptions\\\" type=\\\"text\\\" size=\\\"32\\\" disabled=\\\"disabled\\\" \" +\n                       \"value=\\\"\");\n            for (Iterator iter = props.keySet().iterator(); iter.hasNext(); ) {\n                String prop = (String)iter.next();\n                String val = props.getProperty(prop);\n                buf.append(prop).append('=').append(val).append(' ');\n            }\n            buf.append(\"\\\"><\/td><\/tr>\\n\");\n        }\n        props = out.getUnknownOptions();\n        if (!props.isEmpty()) {\n            buf.append(\"<tr><td align=\\\"right\\\" class=\\\"mediumtags\\\">\" + _(\"Outbound options\") + \":<\/td>\\n\" +\n                       \"<td colspan=\\\"2\\\" align=\\\"center\\\"><input name=\\\"\").append(index);\n            buf.append(\".outboundOptions\\\" type=\\\"text\\\" size=\\\"32\\\" disabled=\\\"disabled\\\" \" +\n                       \"value=\\\"\");\n            for (Iterator iter = props.keySet().iterator(); iter.hasNext(); ) {\n                String prop = (String)iter.next();\n                String val = props.getProperty(prop);\n                buf.append(prop).append('=').append(val).append(' ');\n            }\n            buf.append(\"\\\"><\/td><\/tr>\\n\");\n        }\n//        buf.append(\"<tr><td colspan=\\\"3\\\"><br><\/td><\/tr>\\n\");\n    }","commit_id":"66f7505baa8012dcc8652865d1a978afd2ba79c9","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Test\n  public void TestDataSetUsage() throws IOException, TimeoutException, InterruptedException {\n    ApplicationManager appManager = deployApplication(PurchaseAnalyticsApp.class);\n\n    FlowManager purchaseAnalyticsFlow = appManager.startFlow(\"PurchaseAnalyticsFlow\");\n    //FlowManager generatedPurchaseAnalyticsFlow = appManager.startFlow(\"GeneratedPurchaseAnalyticsFlow\");\n\n    StreamWriter s1 = appManager.getStreamWriter(\"transactionStream\");\n    s1.send(\"1|{\\\"customer\\\":\\\"alex\\\",\\\"product\\\":\\\"FisherPrice\\\",\\\"quantity\\\":10,\\\"price\\\":\\\"100\\\",\\\"purchaseTime\\\":\\\"129308132\\\"}\");\n\n\n  }","id":72006,"modified_method":"@Test\n  public void TestDataSetUsage() throws IOException, TimeoutException, InterruptedException {\n    ApplicationManager appManager = deployApplication(PurchaseAnalyticsApp.class);\n\n    //FlowManager purchaseAnalyticsFlow = appManager.startFlow(\"PurchaseAnalyticsFlow\");\n    FlowManager generatedPurchaseAnalyticsFlow = appManager.startFlow(\"GeneratedPurchaseAnalyticsFlow\");\n\n    //StreamWriter s1 = appManager.getStreamWriter(\"transactionStream\");\n    //s1.send(\"1|{\\\"customer\\\":\\\"alex\\\",\\\"product\\\":\\\"FisherPrice\\\",\\\"quantity\\\":10,\\\"price\\\":\\\"100\\\",\\\"purchaseTime\\\":\\\"129308132\\\"}\");\n\n\n  }","commit_id":"355804b449fcbb3402456c7d9532048233caca5c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void initialize(FlowletContext context) throws FlowletException {\n    this.context = context;\n  }","id":72007,"modified_method":"@Override\n  public void initialize(FlowletContext context) throws FlowletException {\n    this.context = context;\n    customers = new ArrayList<Customer>();\n    products = new ArrayList<Product>();\n  }","commit_id":"355804b449fcbb3402456c7d9532048233caca5c","url":"https://github.com/caskdata/cdap"},{"original_method":"public void generate() throws Exception {\n    outCustomer.emit(this.generateCustomer());\n    Thread.sleep(100);\n    outProduct.emit(this.generateProduct());\n  }","id":72008,"modified_method":"/**\n   * Generates customers, products and purchase in accordance with the randomly generated \"inventory\"\n   *\n   * @throws Exception\n   */\n  public void generate() throws Exception {\n\n    // Generate a customer\n    if (customers.size() < stopLimitCustomers) {\n      outCustomer.emit(this.generateCustomer());\n      Thread.sleep(generationLatency);\n    }\n\n    if (products.size() < stopLimitProducts) {\n      // Generate products\n      for (int i = 0; i <= productRate; i++) {\n        outProduct.emit(this.generateProduct());\n        Thread.sleep(generationLatency);\n      }\n\n      // Generate purchases\n      for (int i = 0; i <= purchaseRate; i++) {\n        outPurchase.emit(this.generatedPurchase());\n        Thread.sleep(generationLatency);\n      }\n    }\n  }","commit_id":"355804b449fcbb3402456c7d9532048233caca5c","url":"https://github.com/caskdata/cdap"},{"original_method":"String getCurrentValue() {\n      return currentValue;\n    }","id":72009,"modified_method":"List<String> getCurrentValues() {\n      return currentValues;\n    }","commit_id":"3872511bfc0fadbbe02a7970ca0e891e9741e43a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSimpleQueueMessages() throws Exception {\n    jmsProvider = new MockJmsProvider(\"dynamicQueues/CDAP.QUEUE\");\n    jmsSource.setJmsProvider(jmsProvider);\n    jmsSource.setSessionAcknowledgeMode(sessionAckMode);\n\n\n    jmsSource.initialize(new MockRealtimeContext());\n\n    ConnectionFactory connectionFactory = jmsProvider.getConnectionFactory();\n    QueueConnection queueConn = null;\n    try {\n      queueConn = (QueueConnection) connectionFactory.createConnection();\n      Queue queueDestination = (Queue) jmsProvider.getDestination();\n\n      // Let's start the Connection\n      queueConn.start();\n      sendMessage(queueConn, queueDestination, \"Queue:\" + queueDestination.getQueueName());\n\n      // Verify if it is valid\n      verifyEmittedText(jmsSource, 5, 4000);\n\n    } finally {\n      if (queueConn != null) {\n        try {\n          queueConn.close();\n        } catch (JMSException e) {\n          LOG.error(\"Exception when closing Queue connection.\");\n        }\n      }\n    }\n  }","id":72010,"modified_method":"@Test\n  public void testSimpleQueueMessages() throws Exception {\n    jmsProvider = new MockJmsProvider(\"dynamicQueues/CDAP.QUEUE\");\n    jmsSource.setJmsProvider(jmsProvider);\n    jmsSource.setSessionAcknowledgeMode(sessionAckMode);\n    jmsSource.initialize(new MockRealtimeContext());\n\n    ConnectionFactory connectionFactory = jmsProvider.getConnectionFactory();\n    QueueConnection queueConn = null;\n    try {\n      queueConn = (QueueConnection) connectionFactory.createConnection();\n      Queue queueDestination = (Queue) jmsProvider.getDestination();\n\n      // Let's start the Connection\n      queueConn.start();\n      sendMessage(queueConn, queueDestination, \"Queue:\" + queueDestination.getQueueName());\n\n      // Verify if it is valid\n      verifyEmittedText(jmsSource);\n\n    } finally {\n      if (queueConn != null) {\n        try {\n          queueConn.close();\n        } catch (JMSException e) {\n          LOG.error(\"Exception when closing Queue connection.\");\n        }\n      }\n    }\n  }","commit_id":"3872511bfc0fadbbe02a7970ca0e891e9741e43a","url":"https://github.com/caskdata/cdap"},{"original_method":"private void verifyEmittedText(JmsSource source, int numTries, long sleepMilis) {\n    // Lets verify from JMS source\n    MockEmitter emitter = new MockEmitter();\n    SourceState sourceState = new SourceState();\n    source.poll(emitter, sourceState);\n\n    int i = 1;\n    while (i < numTries) {\n      if (emitter.getCurrentValue() == null) {\n        try {\n          Thread.sleep(sleepMilis);\n        } catch (InterruptedException e) {\n          // no-op\n        }\n        source.poll(emitter, sourceState);\n        i++;\n      } else {\n        break;\n      }\n    }\n    String emitterValue = emitter.getCurrentValue();\n    Assert.assertEquals(originalMessage, emitterValue);\n\n    System.out.println(\"Getting JMS Message in emitter with value: \" + emitterValue);\n  }","id":72011,"modified_method":"private void verifyEmittedText(JmsSource source) {\n    // Lets verify from JMS source\n    MockEmitter emitter = new MockEmitter();\n    SourceState sourceState = new SourceState();\n    source.poll(emitter, sourceState);\n\n    for (String val : emitter.getCurrentValues()) {\n      Assert.assertEquals(originalMessage, val);\n\n      System.out.println(\"Getting JMS Message in emitter with value: \" + val);\n    }\n  }","commit_id":"3872511bfc0fadbbe02a7970ca0e891e9741e43a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSimpleTopicMessages() throws Exception {\n    jmsProvider = new MockJmsProvider(\"dynamicTopics/CDAP.TOPIC\");\n    jmsSource.setJmsProvider(jmsProvider);\n    jmsSource.setSessionAcknowledgeMode(sessionAckMode);\n\n    jmsSource.initialize(new MockRealtimeContext());\n\n    ConnectionFactory connectionFactory = jmsProvider.getConnectionFactory();\n    TopicConnection topicConn = null;\n    try {\n      topicConn = (TopicConnection) connectionFactory.createConnection();\n\n      Topic topicDestination = (Topic) jmsProvider.getDestination();\n\n      // Let's start the Connection\n      topicConn.start();\n      sendMessage(topicConn, topicDestination, \"Topic:\" + topicDestination.getTopicName());\n\n      // Verify if it is valid\n      verifyEmittedText(jmsSource, 5, 4000);\n    } finally {\n      if (topicConn != null) {\n        try {\n          topicConn.close();\n        } catch (JMSException e) {\n          LOG.error(\"Exception when closing Topic connection.\");\n        }\n      }\n    }\n\n  }","id":72012,"modified_method":"@Test\n  public void testSimpleTopicMessages() throws Exception {\n    jmsProvider = new MockJmsProvider(\"dynamicTopics/CDAP.TOPIC\");\n    jmsSource.setJmsProvider(jmsProvider);\n    jmsSource.setSessionAcknowledgeMode(sessionAckMode);\n    jmsSource.initialize(new MockRealtimeContext());\n\n    ConnectionFactory connectionFactory = jmsProvider.getConnectionFactory();\n    TopicConnection topicConn = null;\n    try {\n      topicConn = (TopicConnection) connectionFactory.createConnection();\n\n      Topic topicDestination = (Topic) jmsProvider.getDestination();\n\n      // Let's start the Connection\n      topicConn.start();\n      sendMessage(topicConn, topicDestination, \"Topic:\" + topicDestination.getTopicName());\n\n      // Verify if it is valid\n      verifyEmittedText(jmsSource);\n    } finally {\n      if (topicConn != null) {\n        try {\n          topicConn.close();\n        } catch (JMSException e) {\n          LOG.error(\"Exception when closing Topic connection.\");\n        }\n      }\n    }\n\n  }","commit_id":"3872511bfc0fadbbe02a7970ca0e891e9741e43a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Emit objects to the next stage.\n     *\n     * @param value data object.\n     */\n    @Override\n    public void emit(String value) {\n      currentValue = value;\n    }","id":72013,"modified_method":"/**\n     * Emit objects to the next stage.\n     *\n     * @param value data object.\n     */\n    @Override\n    public void emit(String value) {\n      currentValues.add(value);\n    }","commit_id":"3872511bfc0fadbbe02a7970ca0e891e9741e43a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Nullable\n  @Override\n  public SourceState poll(Emitter<String> writer, SourceState currentState) {\n    // Try to get message from Queue\n    Message message = null;\n    try {\n      message = consumer.receive(JMS_CONSUMER_TIMEOUT_MS);\n    } catch (JMSException e) {\n      LOG.warn(\"Exception when trying to receive message from JMS consumer: {}\", CDAP_JMS_SOURCE_NAME);\n    }\n    if (message == null) {\n      return currentState;\n    }\n\n    String text;\n    try {\n      if (message instanceof TextMessage) {\n        TextMessage textMessage = (TextMessage) message;\n        text = textMessage.getText();\n        LOG.trace(\"Process JMS TextMessage : \", text);\n      } else if (message instanceof BytesMessage) {\n        BytesMessage bytesMessage = (BytesMessage) message;\n        int bodyLength = (int) bytesMessage.getBodyLength();\n        byte[] data = new byte[bodyLength];\n        int bytesRead = bytesMessage.readBytes(data);\n        if (bytesRead != bodyLength) {\n          LOG.warn(\"Number of bytes read {} not same as expected {}\", bytesRead, bodyLength);\n        }\n        text = new String(data).intern();\n        LOG.trace(\"Processing JMS ByteMessage : {}\", text);\n      } else {\n        // Different kind of messages, just get String for now\n        // TODO Process different kind of JMS messages\n        text = message.toString();\n        LOG.trace(\"Processing JMS message : \", text);\n      }\n    }  catch (JMSException e) {\n      LOG.error(\"Unable to read text from a JMS Message.\");\n      return currentState;\n    }\n\n    writer.emit(text);\n\n    return new SourceState(currentState.getState());\n  }","id":72014,"modified_method":"@Nullable\n  @Override\n  public SourceState poll(Emitter<String> writer, SourceState currentState) {\n    // Try to get message from Queue\n    Message message = null;\n\n    int count = 0;\n    do {\n      try {\n        message = consumer.receive(JMS_CONSUMER_TIMEOUT_MS);\n      } catch (JMSException e) {\n        LOG.warn(\"Exception when trying to receive message from JMS consumer: {}\", CDAP_JMS_SOURCE_NAME);\n      }\n      if (message != null) {\n        String text;\n        try {\n          if (message instanceof TextMessage) {\n            TextMessage textMessage = (TextMessage) message;\n            text = textMessage.getText();\n            LOG.trace(\"Process JMS TextMessage : \", text);\n          } else if (message instanceof BytesMessage) {\n            BytesMessage bytesMessage = (BytesMessage) message;\n            int bodyLength = (int) bytesMessage.getBodyLength();\n            byte[] data = new byte[bodyLength];\n            int bytesRead = bytesMessage.readBytes(data);\n            if (bytesRead != bodyLength) {\n              LOG.warn(\"Number of bytes read {} not same as expected {}\", bytesRead, bodyLength);\n            }\n            text = new String(data).intern();\n            LOG.trace(\"Processing JMS ByteMessage : {}\", text);\n          } else {\n            // Different kind of messages, just get String for now\n            // TODO Process different kind of JMS messages\n            text = message.toString();\n            LOG.trace(\"Processing JMS message : \", text);\n          }\n        } catch (JMSException e) {\n          LOG.error(\"Unable to read text from a JMS Message.\");\n          continue;\n        }\n\n        writer.emit(text);\n        count++;\n      }\n    } while (message != null && count < messagesToReceive);\n\n    return new SourceState(currentState.getState());\n  }","commit_id":"3872511bfc0fadbbe02a7970ca0e891e9741e43a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Initialize the Source.\n   *\n   * @param context {@link RealtimeContext}\n   */\n  public void initialize(RealtimeContext context) throws Exception {\n    super.initialize(context);\n\n    // Bootstrap the JMS consumer\n    initializeJMSConnection();\n  }","id":72015,"modified_method":"/**\n   * Initialize the Source.\n   *\n   * @param context {@link RealtimeContext}\n   */\n  public void initialize(RealtimeContext context) throws Exception {\n    super.initialize(context);\n\n    if (context.getRuntimeArguments().get(JMS_MESSAGES_TO_RECEIVE) != null) {\n      messagesToReceive = Integer.valueOf(context.getRuntimeArguments().get(JMS_MESSAGES_TO_RECEIVE));\n    }\n\n    // Bootstrap the JMS consumer\n    initializeJMSConnection();\n  }","commit_id":"3872511bfc0fadbbe02a7970ca0e891e9741e43a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n    public void testAbandonsReplacementAfterNumFailures() throws Exception {\n        app.subscribe(null, ServiceReplacer.ENTITY_REPLACEMENT_FAILED, eventListener);\n        \n        Predicate<FailingEntity> whetherToFail = new Predicate<FailingEntity>() {\n            private final AtomicInteger counter = new AtomicInteger(0);\n            @Override public boolean apply(FailingEntity input) {\n                return counter.incrementAndGet() >= 2;\n            }\n        };\n        \n        Function<Entity,Void> failureCallback = new Function<Entity,Void>() {\n            @Override public Void apply(Entity input) {\n                ((EntityInternal)input).emit(HASensors.ENTITY_FAILED, new FailureDescriptor(input, \"simulate failure\"));\n                return null;\n            }\n        };\n        \n        final DynamicCluster cluster = app.createAndManageChild(EntitySpec.create(DynamicCluster.class)\n                .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(FailingEntity.class)\n                        .configure(FailingEntity.FAIL_ON_START_CONDITION, whetherToFail)\n                        .configure(FailingEntity.EXEC_ON_FAILURE, failureCallback))\n                .configure(DynamicCluster.INITIAL_SIZE, 1)\n                .configure(DynamicCluster.QUARANTINE_FAILED_ENTITIES, true));\n        app.start(ImmutableList.<Location>of(loc));\n        \n        ServiceReplacer policy = new ServiceReplacer(new ConfigBag()\n                .configure(ServiceReplacer.FAILURE_SENSOR_TO_MONITOR, HASensors.ENTITY_FAILED)\n                .configure(ServiceReplacer.FAIL_ON_NUM_RECURRING_FAILURES, 2));\n        cluster.addPolicy(policy);\n        \n        Set<Entity> initialMembers = ImmutableSet.copyOf(cluster.getMembers());\n        TestEntity e1 = (TestEntity) Iterables.get(initialMembers, 0);\n\n        e1.emit(HASensors.ENTITY_FAILED, new FailureDescriptor(e1, \"simulate failure\"));\n        \n        // There is a race in ServiceReplacer.onReplacementFailed and isRepeatedlyFailingTooMuch because they are called in different threads.\n        // We might still be recording the latest failure while checking the number of previous failures, so we might get an extra\n        // attempt to replace the node.\n        // But make sure it hasn't gone crazy.\n        Runnable assertion = new Runnable() {\n            @Override public void run() {\n                Iterable<Entity> members = Iterables.filter(managementContext.getEntityManager().getEntities(), Predicates.instanceOf(FailingEntity.class));\n                int numMembers = Iterables.size(members);\n                assertTrue(numMembers >= 3 && numMembers <= 10, \"numMembers=\"+numMembers);\n            }};\n        Asserts.succeedsEventually(assertion);\n        Asserts.succeedsContinually(MutableMap.of(\"timeout\", 50), assertion);\n\n        // e2 failed to start, so it won't have called stop on e1\n        Iterable<FailingEntity> members = Iterables.filter(managementContext.getEntityManager().getEntities(), FailingEntity.class);\n        for (FailingEntity en : members) {\n            assertEquals(en.getCallHistory(), ImmutableList.of(\"start\"));\n        }\n    }","id":72016,"modified_method":"/**\n     * If we keep on getting failure reports, never managing to replace the failed node, then don't keep trying\n     * (i.e. avoid infinite loop).\n     * \n     * TODO This code + configuration needs some work; it's not testing quite the scenarios that I\n     * was thinking of!\n     * I saw problem where a node failed, and the replacements failed, and we ended up trying thousands of times.\n     * (describing this scenario is made more complex by me having temporarily disabled the cluster from \n     * removing failed members, for debugging purposes!)\n     * Imagine these two scenarios:\n     * <ol>\n     *   <li>Entity fails during call to start().\n     *       Here, the cluster removes it as a member (either unmanages it or puts it in quarantine)\n     *       So the ENTITY_FAILED is ignored because the entity is not a member at that point.\n     *   <li>Entity returns from start(), but quickly goes to service-down.\n     *       Here we'll keep trying to replace that entity. Depending how long that takes, we'll either \n     *       enter a horrible infinite loop, or we'll just provision a huge number of VMs over a long \n     *       time period.\n     *       Unfortunately this scenario is not catered for in the code yet.\n     * <\/ol>\n     */\n    @Test(groups=\"Integration\") // because takes 1.2 seconds\n    public void testAbandonsReplacementAfterNumFailures() throws Exception {\n        app.subscribe(null, ServiceReplacer.ENTITY_REPLACEMENT_FAILED, eventListener);\n        \n        Predicate<FailingEntity> whetherToFail = new Predicate<FailingEntity>() {\n            private final AtomicInteger counter = new AtomicInteger(0);\n            @Override public boolean apply(FailingEntity input) {\n                return counter.incrementAndGet() >= 11;\n            }\n        };\n        final DynamicCluster cluster = app.createAndManageChild(EntitySpec.create(DynamicCluster.class)\n                .configure(DynamicCluster.MEMBER_SPEC, EntitySpec.create(FailingEntity.class)\n                        .configure(FailingEntity.FAIL_ON_START_CONDITION, whetherToFail))\n                .configure(DynamicCluster.INITIAL_SIZE, 10)\n                .configure(DynamicCluster.QUARANTINE_FAILED_ENTITIES, true));\n        app.start(ImmutableList.<Location>of(loc));\n        \n        ServiceReplacer policy = new ServiceReplacer(new ConfigBag()\n                .configure(ServiceReplacer.FAILURE_SENSOR_TO_MONITOR, HASensors.ENTITY_FAILED)\n                .configure(ServiceReplacer.FAIL_ON_NUM_RECURRING_FAILURES, 3));\n        cluster.addPolicy(policy);\n\n        final Set<Entity> initialMembers = ImmutableSet.copyOf(cluster.getMembers());\n        for (int i = 0; i < 5; i++) {\n            final int counter = i+1;\n            EntityInternal entity = (EntityInternal) Iterables.get(initialMembers, i);\n            entity.emit(HASensors.ENTITY_FAILED, new FailureDescriptor(entity, \"simulate failure\"));\n            if (i <= 3) {\n                Asserts.succeedsEventually(MutableMap.of(\"timeout\", 3000), new Runnable() {\n                    @Override public void run() {\n                        Set<FailingEntity> all = ImmutableSet.copyOf(Iterables.filter(managementContext.getEntityManager().getEntities(), FailingEntity.class));\n                        Set<FailingEntity> replacements = Sets.difference(all, initialMembers);\n                        Set<?> replacementMembers = Sets.intersection(ImmutableSet.of(cluster.getMembers()), replacements);\n                        assertTrue(replacementMembers.isEmpty());\n                        assertEquals(replacements.size(), counter);\n                    }});\n            } else {\n                Asserts.succeedsContinually(new Runnable() {\n                    @Override public void run() {\n                        Set<FailingEntity> all = ImmutableSet.copyOf(Iterables.filter(managementContext.getEntityManager().getEntities(), FailingEntity.class));\n                        Set<FailingEntity> replacements = Sets.difference(all, initialMembers);\n                        assertEquals(replacements.size(), 4);\n                    }});\n            }\n        }\n    }","commit_id":"1de8a4a23ca4eb3ae19d5603263ba0a914400705","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static void removeRange(TreeElement start, TreeElement end) {\n    if (start == null) return;\n    if(start == end) return;\n    final CompositeElement parent = start.getTreeParent();\n    final TreeElement startPrev = start.getTreePrev();\n    final TreeElement endPrev = end != null ? end.getTreePrev() : null;\n    if (parent != null){\n      if (start == parent.getFirstChildNode()){\n        parent.firstChild = end;\n      }\n      if (end == null){\n        parent.lastChild = startPrev;\n      }\n    }\n    if (startPrev != null){\n      startPrev.setTreeNext(end);\n    }\n    if (end != null){\n      end.setTreePrev(startPrev);\n    }\n\n    start.setTreePrev(null);\n    if (endPrev != null){\n      endPrev.setTreeNext(null);\n    }\n    if (parent != null){\n      for(TreeElement element = start; element != end; element = element.getTreeNext()){\n        if(element instanceof CompositeElement)\n          element.setTreeParent(null);\n      }\n    }\n\n    if (DebugUtil.CHECK){\n      if (parent != null){\n        DebugUtil.checkTreeStructure(parent);\n      }\n      DebugUtil.checkTreeStructure(start);\n    }\n  }","id":72017,"modified_method":"public static void removeRange(TreeElement start, TreeElement end) {\n    if (start == null) return;\n    if(start == end) return;\n    final CompositeElement parent = start.getTreeParent();\n    final TreeElement startPrev = start.getTreePrev();\n    final TreeElement endPrev = end != null ? end.getTreePrev() : null;\n    if (parent != null){\n      if (start == parent.getFirstChildNode()){\n        parent.firstChild = end;\n      }\n      if (end == null){\n        parent.lastChild = startPrev;\n      }\n    }\n    if (startPrev != null){\n      startPrev.setTreeNext(end);\n    }\n    if (end != null){\n      end.setTreePrev(startPrev);\n    }\n\n    start.setTreePrev(null);\n    if (parent != null){\n      for(TreeElement element = start; element != end; element = element.getTreeNext()){\n        element.setTreeParent(null);\n      }\n    }\n    if (endPrev != null){\n      endPrev.setTreeNext(null);\n    }\n\n    if (DebugUtil.CHECK){\n      if (parent != null){\n        DebugUtil.checkTreeStructure(parent);\n      }\n      DebugUtil.checkTreeStructure(start);\n    }\n  }","commit_id":"598713268ce808dabcaaf18d1e49dc2eee5978d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void removeRange(TreeElement start, TreeElement end) {\n    if (start == null) return;\n    if(start == end) return;\n    final CompositeElement parent = start.getTreeParent();\n    final TreeElement startPrev = start.getTreePrev();\n    final TreeElement endPrev = end != null ? end.getTreePrev() : null;\n    if (parent != null){\n      if (start == parent.getFirstChildNode()){\n        parent.firstChild = end;\n      }\n      if (end == null){\n        parent.lastChild = startPrev;\n      }\n    }\n    if (startPrev != null){\n      startPrev.setTreeNext(end);\n    }\n    if (end != null){\n      end.setTreePrev(startPrev);\n    }\n\n    start.setTreePrev(null);\n    if (parent != null){\n      for(TreeElement element = start; element != end; element = element.getTreeNext()){\n        element.setTreeParent(null);\n      }\n    }\n    if (endPrev != null){\n      endPrev.setTreeNext(null);\n    }\n\n    if (DebugUtil.CHECK){\n      if (parent != null){\n        DebugUtil.checkTreeStructure(parent);\n      }\n      DebugUtil.checkTreeStructure(start);\n    }\n  }","id":72018,"modified_method":"public static void removeRange(TreeElement start, TreeElement end) {\n    if (start == null) return;\n    if(start == end) return;\n    final CompositeElement parent = start.getTreeParent();\n    final TreeElement startPrev = start.getTreePrev();\n    final TreeElement endPrev = end != null ? end.getTreePrev() : null;\n    LOG.assertTrue(end == null || end.getTreeParent() == parent, \"Trying to remove non-child\");\n\n    if (parent != null){\n      if (start == parent.getFirstChildNode()){\n        parent.firstChild = end;\n      }\n      if (end == null){\n        parent.lastChild = startPrev;\n      }\n    }\n    if (startPrev != null){\n      startPrev.setTreeNext(end);\n    }\n    if (end != null){\n      end.setTreePrev(startPrev);\n    }\n\n    start.setTreePrev(null);\n    if (parent != null){\n      for(TreeElement element = start; element != end; element = element.getTreeNext()){\n        element.setTreeParent(null);\n      }\n    }\n    if (endPrev != null){\n      endPrev.setTreeNext(null);\n    }\n\n    if (DebugUtil.CHECK){\n      if (parent != null){\n        DebugUtil.checkTreeStructure(parent);\n      }\n      DebugUtil.checkTreeStructure(start);\n    }\n  }","commit_id":"9f6b769899363a3366ba2b5dc394f25a7c352a2f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void insertBefore(final TreeElement anchor, TreeElement firstNew) {\n    final TreeElement anchorPrev = anchor.getTreePrev();\n    if(anchorPrev == null){\n      removeRange(firstNew, null);\n      final CompositeElement parent = anchor.getTreeParent();\n      if(parent != null) parent.firstChild = firstNew;\n      while(true){\n        final TreeElement treeNext = firstNew.getTreeNext();\n        LOG.assertTrue(treeNext != anchor, \"Attempt to create cycle\");\n        if(firstNew instanceof CompositeElement){\n          firstNew.setTreeParent(parent);\n        }\n        if(treeNext == null) break;\n        firstNew = treeNext;\n      }\n      anchor.setTreePrev(firstNew);\n      firstNew.setTreeNext(anchor);\n    }\n    else insertAfter(anchorPrev, firstNew);\n\n    if (DebugUtil.CHECK){\n      DebugUtil.checkTreeStructure(anchor);\n    }\n  }","id":72019,"modified_method":"public static void insertBefore(final TreeElement anchor, TreeElement firstNew) {\n    final TreeElement anchorPrev = anchor.getTreePrev();\n    if(anchorPrev == null){\n      removeRange(firstNew, null);\n      final CompositeElement parent = anchor.getTreeParent();\n      if(parent != null) parent.firstChild = firstNew;\n      while(true){\n        final TreeElement treeNext = firstNew.getTreeNext();\n        LOG.assertTrue(treeNext != anchor, \"Attempt to create cycle\");\n        firstNew.setTreeParent(parent);\n        if(treeNext == null) break;\n        firstNew = treeNext;\n      }\n      anchor.setTreePrev(firstNew);\n      firstNew.setTreeNext(anchor);\n    }\n    else insertAfter(anchorPrev, firstNew);\n\n    if (DebugUtil.CHECK){\n      DebugUtil.checkTreeStructure(anchor);\n    }\n  }","commit_id":"9f6b769899363a3366ba2b5dc394f25a7c352a2f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addChildren(CompositeElement parent, TreeElement first) {\n    final TreeElement lastChild = parent.lastChild;\n    if (lastChild == null){\n      parent.firstChild = first;\n      first.setTreePrev(null);\n      while(true){\n        final TreeElement treeNext = first.getTreeNext();\n        if(first instanceof CompositeElement) first.setTreeParent(parent);\n        if(treeNext == null) break;\n        first = treeNext;\n      }\n      parent.lastChild = first;\n      first.setTreeParent(parent);\n    }\n    else insertAfter(lastChild, first);\n    if (DebugUtil.CHECK){\n      DebugUtil.checkTreeStructure(parent);\n    }\n  }","id":72020,"modified_method":"public static void addChildren(CompositeElement parent, TreeElement first) {\n    final TreeElement lastChild = parent.lastChild;\n    if (lastChild == null){\n      parent.firstChild = first;\n      first.setTreePrev(null);\n      while(true){\n        final TreeElement treeNext = first.getTreeNext();\n        first.setTreeParent(parent);\n        if(treeNext == null) break;\n        first = treeNext;\n      }\n      parent.lastChild = first;\n      first.setTreeParent(parent);\n    }\n    else insertAfter(lastChild, first);\n    if (DebugUtil.CHECK){\n      DebugUtil.checkTreeStructure(parent);\n    }\n  }","commit_id":"9f6b769899363a3366ba2b5dc394f25a7c352a2f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void insertAfter(final TreeElement anchor, TreeElement firstNew) {\n    removeRange(firstNew, null);\n    final CompositeElement parent = anchor.getTreeParent();\n    final TreeElement treeNext = anchor.getTreeNext();\n    firstNew.setTreePrev(anchor);\n    anchor.setTreeNext(firstNew);\n    while(true){\n      final TreeElement next = firstNew.getTreeNext();\n      LOG.assertTrue(next != anchor, \"Attempt to create cycle\");\n      if(firstNew instanceof CompositeElement){\n        firstNew.setTreeParent(parent);\n      }\n      if(next == null) break;\n      firstNew = next;\n    }\n\n    if(treeNext == null){\n      if(parent != null){\n        firstNew.setTreeParent(parent);\n        parent.lastChild = firstNew;\n      }\n    }\n    else{\n      firstNew.setTreeNext(treeNext);\n      treeNext.setTreePrev(firstNew);\n    }\n    if (DebugUtil.CHECK){\n      DebugUtil.checkTreeStructure(anchor);\n    }\n  }","id":72021,"modified_method":"public static void insertAfter(final TreeElement anchor, TreeElement firstNew) {\n    removeRange(firstNew, null);\n    final CompositeElement parent = anchor.getTreeParent();\n    final TreeElement treeNext = anchor.getTreeNext();\n    firstNew.setTreePrev(anchor);\n    anchor.setTreeNext(firstNew);\n    while(true){\n      final TreeElement next = firstNew.getTreeNext();\n      LOG.assertTrue(next != anchor, \"Attempt to create cycle\");\n      firstNew.setTreeParent(parent);\n      if(next == null) break;\n      firstNew = next;\n    }\n\n    if(treeNext == null){\n      if(parent != null){\n        firstNew.setTreeParent(parent);\n        parent.lastChild = firstNew;\n      }\n    }\n    else{\n      firstNew.setTreeNext(treeNext);\n      treeNext.setTreePrev(firstNew);\n    }\n    if (DebugUtil.CHECK){\n      DebugUtil.checkTreeStructure(anchor);\n    }\n  }","commit_id":"9f6b769899363a3366ba2b5dc394f25a7c352a2f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void typeFrame(\n\t\tLiferaySelenium liferaySelenium, String locator, String value) {\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tString titleAttribute = liferaySelenium.getAttribute(\n\t\t\tlocator + \"@title\");\n\n\t\tint x = titleAttribute.indexOf(\",\");\n\t\tint y = titleAttribute.indexOf(\",\", x + 1);\n\n\t\tif (y == -1) {\n\t\t\ty = titleAttribute.length();\n\t\t}\n\n\t\tsb.append(titleAttribute.substring(x + 1, y));\n\n\t\tsb.append(\".setHTML(\\\"\");\n\t\tsb.append(HtmlUtil.escapeJS(value.replace(\"\\\\\", \"\\\\\\\\\")));\n\t\tsb.append(\"\\\")\");\n\n\t\tliferaySelenium.runScript(sb.toString());\n\t}","id":72022,"modified_method":"public static void typeFrame(\n\t\tLiferaySelenium liferaySelenium, String locator, String value) {\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tString idAttribute = liferaySelenium.getAttribute(locator + \"@id\");\n\n\t\tint x = idAttribute.indexOf(\"cke__\");\n\t\tint y = idAttribute.indexOf(\"cke__\", x + 1);\n\n\t\tif (y == -1) {\n\t\t\ty = idAttribute.length();\n\t\t}\n\n\t\tsb.append(idAttribute.substring(x + 4, y));\n\n\t\tsb.append(\".setHTML(\\\"\");\n\t\tsb.append(HtmlUtil.escapeJS(value.replace(\"\\\\\", \"\\\\\\\\\")));\n\t\tsb.append(\"\\\")\");\n\n\t\tliferaySelenium.runScript(sb.toString());\n\t}","commit_id":"c60d78d097c2e7f98e53e94e58e70e9e85fb96a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void typeFrame(\n\t\tLiferaySelenium liferaySelenium, String locator, String value) {\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tString titleAttribute = liferaySelenium.getAttribute(\n\t\t\tlocator + \"@title\");\n\n\t\tint x = titleAttribute.indexOf(\",\");\n\t\tint y = titleAttribute.indexOf(\",\", x + 1);\n\n\t\tif (y == -1) {\n\t\t\ty = titleAttribute.length();\n\t\t}\n\n\t\tsb.append(titleAttribute.substring(x + 1, y));\n\n\t\tsb.append(\".setHTML(\\\"\");\n\t\tsb.append(HtmlUtil.escapeJS(value.replace(\"\\\\\", \"\\\\\\\\\")));\n\t\tsb.append(\"\\\")\");\n\n\t\tliferaySelenium.runScript(sb.toString());\n\t}","id":72023,"modified_method":"public static void typeFrame(\n\t\tLiferaySelenium liferaySelenium, String locator, String value) {\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tString idAttribute = liferaySelenium.getAttribute(locator + \"@id\");\n\n\t\tint x = idAttribute.indexOf(\"cke__\");\n\t\tint y = idAttribute.indexOf(\"cke__\", x + 1);\n\n\t\tif (y == -1) {\n\t\t\ty = idAttribute.length();\n\t\t}\n\n\t\tsb.append(idAttribute.substring(x + 4, y));\n\n\t\tsb.append(\".setHTML(\\\"\");\n\t\tsb.append(HtmlUtil.escapeJS(value.replace(\"\\\\\", \"\\\\\\\\\")));\n\t\tsb.append(\"\\\")\");\n\n\t\tliferaySelenium.runScript(sb.toString());\n\t}","commit_id":"f7ed68ad3a83e74483dc629222d4b065fa5a05f1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void populateParams(\n\t\tString friendlyURLPath, Map<String, String[]> params) {\n\n\t\taddParam(params, \"p_p_id\", _PORTLET_ID);\n\t\taddParam(params, \"p_p_lifecycle\", \"0\");\n\t\taddParam(params, \"p_p_state\", WindowState.NORMAL);\n\t\taddParam(params, \"p_p_mode\", PortletMode.VIEW);\n\n\t\tint x = friendlyURLPath.indexOf(\"/\", 1);\n\t\tint y = friendlyURLPath.length();\n\n\t\tif ((x + 1) == y) {\n\t\t\taddParam(params, \"struts_action\", \"/blogs/view\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tString type = friendlyURLPath.substring(x + 1, y);\n\n\t\tif (type.equals(\"rss\")) {\n\t\t\taddParam(params, \"p_p_lifecycle\", \"1\");\n\t\t\taddParam(params, \"p_p_state\", LiferayWindowState.EXCLUSIVE);\n\n\t\t\taddParam(params, \"struts_action\", \"/blogs/rss\");\n\t\t}\n\t\telse if (type.startsWith(\"trackback/\")) {\n\t\t\taddParam(params, \"p_p_lifecycle\", \"1\");\n\t\t\taddParam(params, \"p_p_state\", LiferayWindowState.EXCLUSIVE);\n\n\t\t\taddParam(params, \"struts_action\", \"/blogs/trackback\");\n\n\t\t\tx = type.indexOf(\"/\");\n\n\t\t\ttype = type.substring(x + 1);\n\n\t\t\taddParam(params, getEntryIdParam(type), type);\n\t\t}\n\t\telse {\n\t\t\taddParam(params, \"struts_action\", \"/blogs/view_entry\");\n\n\t\t\taddParam(params, getEntryIdParam(type), type);\n\t\t}\n\t}","id":72024,"modified_method":"public void populateParams(\n\t\tString friendlyURLPath, Map<String, String[]> params) {\n\n\t\taddParam(params, \"p_p_id\", _PORTLET_ID);\n\t\taddParam(params, \"p_p_lifecycle\", \"0\");\n\t\taddParam(params, \"p_p_mode\", PortletMode.VIEW);\n\n\t\tint x = friendlyURLPath.indexOf(\"/\", 1);\n\t\tint y = friendlyURLPath.indexOf(\"/\", x + 1);\n\n\t\tif (y == -1) {\n\t\t\ty = friendlyURLPath.length();\n\t\t}\n\n\t\tif ((x + 1) == friendlyURLPath.length()) {\n\t\t\taddParam(params, \"struts_action\", \"/blogs/view\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tString type = friendlyURLPath.substring(x + 1, y);\n\n\t\tif (type.equals(\"rss\")) {\n\t\t\taddParam(params, \"p_p_lifecycle\", \"1\");\n\t\t\taddParam(params, \"p_p_state\", LiferayWindowState.EXCLUSIVE);\n\n\t\t\taddParam(params, \"struts_action\", \"/blogs/rss\");\n\t\t}\n\t\telse if (type.equals(\"trackback\")) {\n\t\t\taddParam(params, \"p_p_lifecycle\", \"1\");\n\t\t\taddParam(params, \"p_p_state\", LiferayWindowState.EXCLUSIVE);\n\n\t\t\taddParam(params, \"struts_action\", \"/blogs/trackback\");\n\n\t\t\ttype = friendlyURLPath.substring(y + 1);\n\n\t\t\taddParam(params, getEntryIdParam(type), type);\n\t\t}\n\t\telse {\n\t\t\taddParam(params, \"struts_action\", \"/blogs/view_entry\");\n\n\t\t\taddParam(params, getEntryIdParam(type), type);\n\t\t}\n\n\t\tif (friendlyURLPath.indexOf(\"maximized\", x) != -1) {\n\t\t\taddParam(params, \"p_p_state\", WindowState.MAXIMIZED);\n\t\t}\n\t}","commit_id":"557dd9919bfc490eafe0e75faa3868fc0a278e18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String buildPath(LiferayPortletURL portletURL) {\n\t\tString friendlyURLPath = null;\n\n\t\tString strutsAction = GetterUtil.getString(\n\t\t\tportletURL.getParameter(\"struts_action\"));\n\n\t\tif (strutsAction.equals(\"/blogs/rss\")) {\n\t\t\tfriendlyURLPath = \"/blogs/rss\";\n\t\t}\n\t\telse if (strutsAction.equals(\"/blogs/view_entry\")) {\n\t\t\tString entryId = portletURL.getParameter(\"entryId\");\n\n\t\t\tString urlTitle = portletURL.getParameter(\"urlTitle\");\n\n\t\t\tif (Validator.isNotNull(entryId)) {\n\t\t\t\tfriendlyURLPath = \"/blogs/\" + entryId;\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"entryId\");\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(urlTitle)) {\n\t\t\t\tfriendlyURLPath = \"/blogs/\" + urlTitle;\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"urlTitle\");\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(friendlyURLPath)) {\n\t\t\tportletURL.addParameterIncludedInPath(\"p_p_id\");\n\n\t\t\tportletURL.addParameterIncludedInPath(\"struts_action\");\n\t\t}\n\n\t\treturn friendlyURLPath;\n\t}","id":72025,"modified_method":"public String buildPath(LiferayPortletURL portletURL) {\n\t\tString friendlyURLPath = null;\n\n\t\tString strutsAction = GetterUtil.getString(\n\t\t\tportletURL.getParameter(\"struts_action\"));\n\n\t\tif (strutsAction.equals(\"/blogs/rss\")) {\n\t\t\tfriendlyURLPath = \"/blogs/rss\";\n\t\t}\n\t\telse if (strutsAction.equals(\"/blogs/view_entry\")) {\n\t\t\tString entryId = portletURL.getParameter(\"entryId\");\n\n\t\t\tString urlTitle = portletURL.getParameter(\"urlTitle\");\n\n\t\t\tif (Validator.isNotNull(entryId)) {\n\t\t\t\tfriendlyURLPath = \"/blogs/\" + entryId;\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"entryId\");\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(urlTitle)) {\n\t\t\t\tfriendlyURLPath = \"/blogs/\" + urlTitle;\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"urlTitle\");\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(friendlyURLPath)) {\n\t\t\tportletURL.addParameterIncludedInPath(\"p_p_id\");\n\n\t\t\tportletURL.addParameterIncludedInPath(\"struts_action\");\n\n\t\t\tWindowState windowState = portletURL.getWindowState();\n\n\t\t\tif (windowState.equals(WindowState.MAXIMIZED)) {\n\t\t\t\tfriendlyURLPath += StringPool.SLASH + windowState;\n\t\t\t}\n\t\t}\n\n\t\treturn friendlyURLPath;\n\t}","commit_id":"557dd9919bfc490eafe0e75faa3868fc0a278e18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tBlogsEntry entry = null;\n\t\t\tString oldUrlTitle = StringPool.BLANK;\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tObject[] returnValue = updateEntry(actionRequest);\n\n\t\t\t\tentry = (BlogsEntry)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteEntry(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\t\t\tboolean updateRedirect = false;\n\n\t\t\tif ((entry != null) && (Validator.isNotNull(oldUrlTitle)) &&\n\t\t\t\t(redirect.endsWith(\"/blogs/\" + oldUrlTitle) ||\n\t\t\t\t redirect.indexOf(\"/blogs/\" + oldUrlTitle + \"?\") != -1)) {\n\n\t\t\t\tint pos = redirect.indexOf(\"?\");\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\tpos = redirect.length();\n\t\t\t\t}\n\n\t\t\t\tString newRedirect = redirect.substring(\n\t\t\t\t\t0, pos - oldUrlTitle.length());\n\n\t\t\t\tnewRedirect += entry.getUrlTitle();\n\n\t\t\t\tif (pos < redirect.length()) {\n\t\t\t\t\tnewRedirect +=\n\t\t\t\t\t\t\"?\" + redirect.substring(pos + 1, redirect.length());\n\t\t\t\t}\n\n\t\t\t\tredirect = newRedirect;\n\t\t\t\tupdateRedirect = true;\n\t\t\t}\n\n\t\t\tif ((entry != null) && entry.isDraft()) {\n\t\t\t\tJSONObject jsonObj = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObj.put(\"entryId\", entry.getEntryId());\n\t\t\t\tjsonObj.put(\"redirect\", redirect);\n\t\t\t\tjsonObj.put(\"updateRedirect\", updateRedirect);\n\n\t\t\t\tHttpServletResponse response =\n\t\t\t\t\tPortalUtil.getHttpServletResponse(actionResponse);\n\t\t\t\tInputStream is = new ByteArrayInputStream(\n\t\t\t\t\tjsonObj.toString().getBytes());\n\t\t\t\tString contentType = ContentTypes.TEXT_JAVASCRIPT;\n\n\t\t\t\tServletResponseUtil.sendFile(\n\t\t\t\t\tresponse, null, is, contentType);\n\n\t\t\t\tsetForward(actionRequest, ActionConstants.COMMON_NULL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(\n\t\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t\t\tthemeDisplay.getLayoutTypePortlet();\n\n\t\t\t\tif (layoutTypePortlet.hasPortletId(\n\t\t\t\t\t\tportletConfig.getPortletName())) {\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tactionResponse.sendRedirect(redirect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchEntryException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.blogs.error\");\n\t\t\t}\n\t\t\telse if (e instanceof EntryContentException ||\n\t\t\t\t\t e instanceof EntryDisplayDateException ||\n\t\t\t\t\t e instanceof EntryTitleException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t}\n\t\t\telse if (e instanceof TagsEntryException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":72026,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tBlogsEntry entry = null;\n\t\t\tString oldUrlTitle = StringPool.BLANK;\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tObject[] returnValue = updateEntry(actionRequest);\n\n\t\t\t\tentry = (BlogsEntry)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteEntry(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\t\t\tboolean updateRedirect = false;\n\n\t\t\tif (redirect.indexOf(\n\t\t\t\t\t\"/blogs/\" + oldUrlTitle + \"/maximized\") != -1) {\n\n\t\t\t\toldUrlTitle += \"/maximized\";\n\t\t\t}\n\n\t\t\tif ((entry != null) && (Validator.isNotNull(oldUrlTitle)) &&\n\t\t\t\t(redirect.endsWith(\"/blogs/\" + oldUrlTitle) ||\n\t\t\t\t redirect.indexOf(\"/blogs/\" + oldUrlTitle + \"?\") != -1)) {\n\n\t\t\t\tint pos = redirect.indexOf(\"?\");\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\tpos = redirect.length();\n\t\t\t\t}\n\n\t\t\t\tString newRedirect = redirect.substring(\n\t\t\t\t\t0, pos - oldUrlTitle.length());\n\n\t\t\t\tnewRedirect += entry.getUrlTitle();\n\n\t\t\t\tif (oldUrlTitle.indexOf(\"/maximized\") != -1) {\n\t\t\t\t\tnewRedirect += \"/maximized\";\n\t\t\t\t}\n\n\t\t\t\tif (pos < redirect.length()) {\n\t\t\t\t\tnewRedirect +=\n\t\t\t\t\t\t\"?\" + redirect.substring(pos + 1, redirect.length());\n\t\t\t\t}\n\n\t\t\t\tredirect = newRedirect;\n\t\t\t\tupdateRedirect = true;\n\t\t\t}\n\n\t\t\tif ((entry != null) && entry.isDraft()) {\n\t\t\t\tJSONObject jsonObj = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObj.put(\"entryId\", entry.getEntryId());\n\t\t\t\tjsonObj.put(\"redirect\", redirect);\n\t\t\t\tjsonObj.put(\"updateRedirect\", updateRedirect);\n\n\t\t\t\tHttpServletResponse response =\n\t\t\t\t\tPortalUtil.getHttpServletResponse(actionResponse);\n\t\t\t\tInputStream is = new ByteArrayInputStream(\n\t\t\t\t\tjsonObj.toString().getBytes());\n\t\t\t\tString contentType = ContentTypes.TEXT_JAVASCRIPT;\n\n\t\t\t\tServletResponseUtil.sendFile(\n\t\t\t\t\tresponse, null, is, contentType);\n\n\t\t\t\tsetForward(actionRequest, ActionConstants.COMMON_NULL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(\n\t\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t\t\tthemeDisplay.getLayoutTypePortlet();\n\n\t\t\t\tif (layoutTypePortlet.hasPortletId(\n\t\t\t\t\t\tportletConfig.getPortletName())) {\n\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tactionResponse.sendRedirect(redirect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchEntryException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.blogs.error\");\n\t\t\t}\n\t\t\telse if (e instanceof EntryContentException ||\n\t\t\t\t\t e instanceof EntryDisplayDateException ||\n\t\t\t\t\t e instanceof EntryTitleException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t}\n\t\t\telse if (e instanceof TagsEntryException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"557dd9919bfc490eafe0e75faa3868fc0a278e18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String buildPath(LiferayPortletURL portletURL) {\n\t\tString friendlyURLPath = null;\n\n\t\tif (!portletURL.getWindowState().equals(WindowState.MAXIMIZED)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString tabs1 = GetterUtil.getString(portletURL.getParameter(\"tabs1\"));\n\t\tString tabs2 = GetterUtil.getString(portletURL.getParameter(\"tabs2\"));\n\n\t\tif (Validator.isNotNull(tabs2)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString strutsAction = GetterUtil.getString(\n\t\t\tportletURL.getParameter(\"struts_action\"));\n\n\t\tif (strutsAction.equals(\"/message_boards/search\")) {\n\t\t\tfriendlyURLPath = \"/message_boards/search\";\n\t\t}\n\t\telse if (strutsAction.equals(\"/message_boards/view\")) {\n\t\t\tString categoryId = GetterUtil.getString(\n\t\t\t\tportletURL.getParameter(\"categoryId\"));\n\n\t\t\tif (Validator.isNotNull(categoryId) && !categoryId.equals(\"0\")) {\n\t\t\t\tfriendlyURLPath = \"/message_boards/category/\" + categoryId;\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"categoryId\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPath = \"/message_boards\";\n\n\t\t\t\tif (Validator.isNotNull(tabs1)) {\n\t\t\t\t\tfriendlyURLPath += \"/\";\n\n\t\t\t\t\tif (!tabs1.equals(\"categories\")) {\n\t\t\t\t\t\tfriendlyURLPath += tabs1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"tabs1\");\n\n\t\t\t\tif (categoryId.equals(\"0\")) {\n\t\t\t\t\tportletURL.addParameterIncludedInPath(\"categoryId\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strutsAction.equals(\"/message_boards/view_message\")) {\n\t\t\tString messageId = portletURL.getParameter(\"messageId\");\n\n\t\t\tif (Validator.isNotNull(messageId)) {\n\t\t\t\tfriendlyURLPath = \"/message_boards/message/\" + messageId;\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"messageId\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Struts action \" + strutsAction +\n\t\t\t\t\t\t\" does not have a friendly URL path \");\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(friendlyURLPath)) {\n\t\t\tportletURL.addParameterIncludedInPath(\"p_p_id\");\n\n\t\t\tportletURL.addParameterIncludedInPath(\"struts_action\");\n\t\t}\n\n\t\treturn friendlyURLPath;\n\t}","id":72027,"modified_method":"public String buildPath(LiferayPortletURL portletURL) {\n\t\tString friendlyURLPath = null;\n\n\t\tString tabs1 = GetterUtil.getString(portletURL.getParameter(\"tabs1\"));\n\t\tString tabs2 = GetterUtil.getString(portletURL.getParameter(\"tabs2\"));\n\n\t\tif (Validator.isNotNull(tabs2)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString strutsAction = GetterUtil.getString(\n\t\t\tportletURL.getParameter(\"struts_action\"));\n\n\t\tif (strutsAction.equals(\"/message_boards/search\")) {\n\t\t\tfriendlyURLPath = \"/message_boards/search\";\n\t\t}\n\t\telse if (strutsAction.equals(\"/message_boards/view\")) {\n\t\t\tString categoryId = GetterUtil.getString(\n\t\t\t\tportletURL.getParameter(\"categoryId\"));\n\n\t\t\tif (Validator.isNotNull(categoryId) && !categoryId.equals(\"0\")) {\n\t\t\t\tfriendlyURLPath = \"/message_boards/category/\" + categoryId;\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"categoryId\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPath = \"/message_boards\";\n\n\t\t\t\tif (Validator.isNotNull(tabs1) && !tabs1.equals(\"categories\")) {\n\t\t\t\t\tfriendlyURLPath += StringPool.SLASH + tabs1;\n\t\t\t\t}\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"tabs1\");\n\n\t\t\t\tif (categoryId.equals(\"0\")) {\n\t\t\t\t\tportletURL.addParameterIncludedInPath(\"categoryId\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strutsAction.equals(\"/message_boards/view_message\")) {\n\t\t\tString messageId = portletURL.getParameter(\"messageId\");\n\n\t\t\tif (Validator.isNotNull(messageId)) {\n\t\t\t\tfriendlyURLPath = \"/message_boards/message/\" + messageId;\n\n\t\t\t\tportletURL.addParameterIncludedInPath(\"messageId\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Struts action \" + strutsAction +\n\t\t\t\t\t\t\" does not have a friendly URL path \");\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(friendlyURLPath)) {\n\t\t\tWindowState windowState = portletURL.getWindowState();\n\n\t\t\tif (windowState.equals(WindowState.MAXIMIZED)) {\n\t\t\t\tfriendlyURLPath += StringPool.SLASH + windowState;\n\t\t\t}\n\n\t\t\tportletURL.addParameterIncludedInPath(\"p_p_id\");\n\n\t\t\tportletURL.addParameterIncludedInPath(\"struts_action\");\n\t\t}\n\n\t\treturn friendlyURLPath;\n\t}","commit_id":"557dd9919bfc490eafe0e75faa3868fc0a278e18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void populateParams(\n\t\tString friendlyURLPath, Map<String, String[]> params) {\n\n\t\taddParam(params, \"p_p_id\", _PORTLET_ID);\n\t\taddParam(params, \"p_p_lifecycle\", \"0\");\n\t\t//addParam(params, \"p_p_state\", WindowState.MAXIMIZED);\n\t\taddParam(params, \"p_p_mode\", PortletMode.VIEW);\n\n\t\tint x = friendlyURLPath.indexOf(\"/\", 1);\n\n\t\tif ((x + 1) == friendlyURLPath.length()) {\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/view\");\n\t\t\taddParam(\n\t\t\t\tparams, \"categoryId\",\n\t\t\t\tMBCategoryImpl.DEFAULT_PARENT_CATEGORY_ID);\n\n\t\t\treturn;\n\t\t}\n\n\t\tint y = friendlyURLPath.indexOf(\"/\", x + 1);\n\n\t\tif (y == -1) {\n\t\t\ty = friendlyURLPath.length();\n\t\t}\n\n\t\tString type = friendlyURLPath.substring(x + 1, y);\n\n\t\tif (type.equals(\"category\")) {\n\t\t\tString categoryId =\n\t\t\t\tfriendlyURLPath.substring(y + 1, friendlyURLPath.length());\n\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/view\");\n\t\t\taddParam(params, \"categoryId\", categoryId);\n\t\t}\n\t\telse if (type.equals(\"message\")) {\n\t\t\tString messageId =\n\t\t\t\tfriendlyURLPath.substring(y + 1, friendlyURLPath.length());\n\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/view_message\");\n\t\t\taddParam(params, \"messageId\", messageId);\n\t\t}\n\t\telse if (type.equals(\"my_posts\") || type.equals(\"my_subscriptions\") ||\n\t\t\t\t type.equals(\"recent_posts\") || type.equals(\"statistics\") ||\n\t\t\t\t type.equals(\"banned_users\")) {\n\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/view\");\n\t\t\taddParam(params, \"tabs1\", type);\n\t\t}\n\t\telse if (type.equals(\"search\")) {\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/search\");\n\t\t\taddParam(params, \"tabs1\", \"category\");\n\t\t}\n\t}","id":72028,"modified_method":"public void populateParams(\n\t\tString friendlyURLPath, Map<String, String[]> params) {\n\n\t\taddParam(params, \"p_p_id\", _PORTLET_ID);\n\t\taddParam(params, \"p_p_lifecycle\", \"0\");\n\t\taddParam(params, \"p_p_mode\", PortletMode.VIEW);\n\n\t\tint x = friendlyURLPath.indexOf(\"/\", 1);\n\n\t\tif ((x + 1) == friendlyURLPath.length()) {\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/view\");\n\t\t\taddParam(\n\t\t\t\tparams, \"categoryId\",\n\t\t\t\tMBCategoryImpl.DEFAULT_PARENT_CATEGORY_ID);\n\n\t\t\treturn;\n\t\t}\n\n\t\tint y = friendlyURLPath.indexOf(\"/\", x + 1);\n\n\t\tif (y == -1) {\n\t\t\ty = friendlyURLPath.length();\n\t\t}\n\n\t\tint z = friendlyURLPath.indexOf(\"/\", y + 1);\n\n\t\tif (z == -1) {\n\t\t\tz = friendlyURLPath.length();\n\t\t}\n\n\t\tString type = friendlyURLPath.substring(x + 1, y);\n\n\t\tif (type.equals(\"category\")) {\n\t\t\tString categoryId =\n\t\t\t\tfriendlyURLPath.substring(y + 1, z);\n\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/view\");\n\t\t\taddParam(params, \"categoryId\", categoryId);\n\t\t}\n\t\telse if (type.equals(\"message\")) {\n\t\t\tString messageId =\n\t\t\t\tfriendlyURLPath.substring(y + 1, z);\n\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/view_message\");\n\t\t\taddParam(params, \"messageId\", messageId);\n\t\t}\n\t\telse if (type.equals(\"my_posts\") || type.equals(\"my_subscriptions\") ||\n\t\t\t\t type.equals(\"recent_posts\") || type.equals(\"statistics\") ||\n\t\t\t\t type.equals(\"banned_users\")) {\n\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/view\");\n\t\t\taddParam(params, \"tabs1\", type);\n\t\t}\n\t\telse if (type.equals(\"search\")) {\n\t\t\taddParam(params, \"struts_action\", \"/message_boards/search\");\n\t\t\taddParam(params, \"tabs1\", \"category\");\n\t\t}\n\n\t\tif (friendlyURLPath.indexOf(\"maximized\", x) != -1) {\n\t\t\taddParam(params, \"p_p_state\", WindowState.MAXIMIZED);\n\t\t}\n\t}","commit_id":"557dd9919bfc490eafe0e75faa3868fc0a278e18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  protected Color getHashColor() {\n    if (invertLineColor && !ComparatorUtil.equalsNullable(UIUtil.getTreeSelectionForeground(), UIUtil.getTreeForeground())) {\n      final Color c = UIUtil.getTreeSelectionForeground();\n      if (c != null) {\n        return c.darker();\n      }\n    }\n    return super.getHashColor();\n  }","id":72029,"modified_method":"@Override\n  protected Color getHashColor() {\n    //if (invertLineColor && !ComparatorUtil.equalsNullable(UIUtil.getTreeSelectionForeground(), UIUtil.getTreeForeground())) {\n    //  final Color c = UIUtil.getTreeSelectionForeground();\n    //  if (c != null) {\n    //    return c.darker();\n    //  }\n    //}\n    return super.getHashColor();\n  }","commit_id":"5bb01403b6cbda2ec24679088a19884c0d5cd9e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintHorizontalPartOfLeg(final Graphics g,\n                                          final Rectangle clipBounds,\n                                          final Insets insets,\n                                          final Rectangle bounds,\n                                          final TreePath path,\n                                          final int row,\n                                          final boolean isExpanded,\n                                          final boolean hasBeenExpanded,\n                                          final boolean isLeaf) {\n    if (!shouldPaintLines()) return;\n    if (!UIUtil.isUnderAquaBasedLookAndFeel() && !UIUtil.isUnderDarcula() && !UIUtil.isUnderIntelliJLaF()) {\n      if (UIUtil.isUnderAlloyIDEALookAndFeel()) {\n        invertLineColor = tree.getSelectionModel().isRowSelected(row) && tree.hasFocus();\n      }\n      super.paintHorizontalPartOfLeg(g, clipBounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n      invertLineColor = false;\n    }\n  }","id":72030,"modified_method":"@Override\n  protected void paintHorizontalPartOfLeg(final Graphics g,\n                                          final Rectangle clipBounds,\n                                          final Insets insets,\n                                          final Rectangle bounds,\n                                          final TreePath path,\n                                          final int row,\n                                          final boolean isExpanded,\n                                          final boolean hasBeenExpanded,\n                                          final boolean isLeaf) {\n    if (shouldPaintLines()) {\n      super.paintHorizontalPartOfLeg(g, clipBounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);\n    }\n  }","commit_id":"5bb01403b6cbda2ec24679088a19884c0d5cd9e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintVerticalPartOfLeg(final Graphics g, final Rectangle clipBounds, final Insets insets, final TreePath path) {\n    if (!UIUtil.isUnderAquaBasedLookAndFeel() && !UIUtil.isUnderDarcula() && !UIUtil.isUnderIntelliJLaF() && shouldPaintLines()) {\n      invertLineColor = UIUtil.isUnderAlloyIDEALookAndFeel() && tree.hasFocus() && tree.getSelectionModel().isPathSelected(path);\n      super.paintVerticalPartOfLeg(g, clipBounds, insets, path);\n      invertLineColor = false;\n    }\n  }","id":72031,"modified_method":"@Override\n  protected void paintVerticalPartOfLeg(final Graphics g, final Rectangle clipBounds, final Insets insets, final TreePath path) {\n    if (shouldPaintLines()) {\n      super.paintVerticalPartOfLeg(g, clipBounds, insets, path);\n    }\n  }","commit_id":"5bb01403b6cbda2ec24679088a19884c0d5cd9e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintVerticalLine(Graphics g, JComponent c, int x, int top, int bottom) {\n    if (!shouldPaintLines()) return;\n    if (tree.hasFocus() && UIUtil.isUnderAlloyIDEALookAndFeel()) {\n      int y0, y1 = top;\n      while (y1 < bottom) {\n        y0 = y1;\n        final int row = tree.getRowForPath(tree.getClosestPathForLocation(x, y0 + 1));\n        invertLineColor = tree.isRowSelected(row);\n        g.setColor(getHashColor());\n        final Rectangle bounds = tree.getRowBounds(row);\n        y1 = bounds.y + bounds.height;\n        super.paintVerticalLine(g, c, x, y0, Math.min(bottom, y1));\n      }\n      invertLineColor = false;\n    } else {\n      super.paintVerticalLine(g, c, x, top, bottom);\n    }\n  }","id":72032,"modified_method":"@Override\n  protected void paintVerticalLine(Graphics g, JComponent c, int x, int top, int bottom) {\n    if (shouldPaintLines()) {\n      super.paintVerticalLine(g, c, x, top, bottom);\n    }\n  }","commit_id":"5bb01403b6cbda2ec24679088a19884c0d5cd9e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean shouldPaintLines() {\n    return myForceDontPaintLines || !\"None\".equals(tree.getClientProperty(\"JTree.lineStyle\"));\n  }","id":72033,"modified_method":"private boolean shouldPaintLines() {\n    if (UIUtil.isUnderAquaBasedLookAndFeel() || UIUtil.isUnderDarcula() || UIUtil.isUnderIntelliJLaF()) {\n      return false;\n    }\n    return myForceDontPaintLines || !\"None\".equals(tree.getClientProperty(\"JTree.lineStyle\"));\n  }","commit_id":"5bb01403b6cbda2ec24679088a19884c0d5cd9e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.staxmapper.XMLElementWriter#writeContent(org.jboss.staxmapper.XMLExtendedStreamWriter, java.lang.Object)\n     */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUri(), false);\n        ModelNode model = context.getModelNode();\n        if (model.isDefined()) {\n            this.writeOptional(writer, Attribute.DEFAULT_STACK, model, ModelKeys.DEFAULT_STACK);\n            for (Property property: model.get(ModelKeys.STACK).asPropertyList()) {\n                writer.writeStartElement(Element.STACK.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                ModelNode stack = property.getValue();\n                this.writeProtocol(writer, stack.get(ModelKeys.TRANSPORT), Element.TRANSPORT);\n                for (ModelNode protocol: stack.get(ModelKeys.PROTOCOL).asList()) {\n                    this.writeProtocol(writer, protocol, Element.PROTOCOL);\n                }\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","id":72034,"modified_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.staxmapper.XMLElementWriter#writeContent(org.jboss.staxmapper.XMLExtendedStreamWriter, java.lang.Object)\n     */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUri(), false);\n        ModelNode model = context.getModelNode();\n        if (model.isDefined()) {\n            this.writeOptional(writer, Attribute.DEFAULT_STACK, model, ModelKeys.DEFAULT_STACK);\n            for (Property property: model.get(ModelKeys.STACK).asPropertyList()) {\n                writer.writeStartElement(Element.STACK.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                ModelNode stack = property.getValue();\n                this.writeProtocol(writer, stack.get(ModelKeys.TRANSPORT), Element.TRANSPORT);\n                if (stack.hasDefined(ModelKeys.PROTOCOL)) {\n                    for (ModelNode protocol: stack.get(ModelKeys.PROTOCOL).asList()) {\n                        this.writeProtocol(writer, protocol, Element.PROTOCOL);\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","commit_id":"4a0f333b4000b84d73f3e98dac49e46272427639","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeProtocol(XMLExtendedStreamWriter writer, ModelNode protocol, Element element) throws XMLStreamException {\n        writer.writeStartElement(element.getLocalName());\n        this.writeRequired(writer, Attribute.TYPE, protocol, ModelKeys.TYPE);\n        this.writeOptional(writer, Attribute.SOCKET_BINDING, protocol, ModelKeys.SOCKET_BINDING);\n        this.writeOptional(writer, Attribute.DIAGNOSTICS_SOCKET_BINDING, protocol, ModelKeys.DIAGNOSTICS_SOCKET_BINDING);\n        this.writeOptional(writer, Attribute.DEFAULT_EXECUTOR, protocol, ModelKeys.DEFAULT_EXECUTOR);\n        this.writeOptional(writer, Attribute.OOB_EXECUTOR, protocol, ModelKeys.OOB_EXECUTOR);\n        this.writeOptional(writer, Attribute.TIMER_EXECUTOR, protocol, ModelKeys.TIMER_EXECUTOR);\n        this.writeOptional(writer, Attribute.THREAD_FACTORY, protocol, ModelKeys.THREAD_FACTORY);\n        if (protocol.has(ModelKeys.PROPERTY)) {\n            for (Property property: protocol.get(ModelKeys.PROPERTY).asPropertyList()) {\n                writer.writeStartElement(Element.PROPERTY.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                writer.writeCharacters(property.getValue().asString());\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","id":72035,"modified_method":"private void writeProtocol(XMLExtendedStreamWriter writer, ModelNode protocol, Element element) throws XMLStreamException {\n        writer.writeStartElement(element.getLocalName());\n        this.writeRequired(writer, Attribute.TYPE, protocol, ModelKeys.TYPE);\n        this.writeOptional(writer, Attribute.SHARED, protocol, ModelKeys.SHARED);\n        this.writeOptional(writer, Attribute.SOCKET_BINDING, protocol, ModelKeys.SOCKET_BINDING);\n        this.writeOptional(writer, Attribute.DIAGNOSTICS_SOCKET_BINDING, protocol, ModelKeys.DIAGNOSTICS_SOCKET_BINDING);\n        this.writeOptional(writer, Attribute.DEFAULT_EXECUTOR, protocol, ModelKeys.DEFAULT_EXECUTOR);\n        this.writeOptional(writer, Attribute.OOB_EXECUTOR, protocol, ModelKeys.OOB_EXECUTOR);\n        this.writeOptional(writer, Attribute.TIMER_EXECUTOR, protocol, ModelKeys.TIMER_EXECUTOR);\n        this.writeOptional(writer, Attribute.THREAD_FACTORY, protocol, ModelKeys.THREAD_FACTORY);\n        if (protocol.has(ModelKeys.PROPERTY)) {\n            for (Property property: protocol.get(ModelKeys.PROPERTY).asPropertyList()) {\n                writer.writeStartElement(Element.PROPERTY.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), property.getName());\n                writer.writeCharacters(property.getValue().asString());\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","commit_id":"4a0f333b4000b84d73f3e98dac49e46272427639","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseProtocol(XMLExtendedStreamReader reader, ModelNode protocol, Class<? extends Protocol> targetClass) throws XMLStreamException {\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case TYPE: {\n                    try {\n                        this.getClass().getClassLoader().loadClass(org.jgroups.conf.ProtocolConfiguration.protocol_prefix + '.' + value).asSubclass(targetClass).newInstance();\n                        protocol.get(ModelKeys.TYPE).set(value);\n                    } catch (Exception e) {\n                        throw ParseUtils.invalidAttributeValue(reader, i);\n                    }\n                    break;\n                }\n                case SOCKET_BINDING: {\n                    protocol.get(ModelKeys.SOCKET_BINDING).set(value);\n                    break;\n                }\n                case DIAGNOSTICS_SOCKET_BINDING: {\n                    protocol.get(ModelKeys.DIAGNOSTICS_SOCKET_BINDING).set(value);\n                    break;\n                }\n                case DEFAULT_EXECUTOR: {\n                    protocol.get(ModelKeys.DEFAULT_EXECUTOR).set(value);\n                    break;\n                }\n                case OOB_EXECUTOR: {\n                    protocol.get(ModelKeys.OOB_EXECUTOR).set(value);\n                    break;\n                }\n                case TIMER_EXECUTOR: {\n                    protocol.get(ModelKeys.TIMER_EXECUTOR).set(value);\n                    break;\n                }\n                case THREAD_FACTORY: {\n                    protocol.get(ModelKeys.THREAD_FACTORY).set(value);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n\n        if (!protocol.hasDefined(ModelKeys.TYPE)) {\n            throw ParseUtils.missingRequired(reader, Collections.singleton(Attribute.TYPE));\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            if (Element.forName(reader.getLocalName()) != Element.PROPERTY) {\n                throw ParseUtils.unexpectedElement(reader);\n            }\n            int attributes = reader.getAttributeCount();\n            String property = null;\n            for (int i = 0; i < attributes; i++) {\n                String value = reader.getAttributeValue(i);\n                Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NAME: {\n                        property = value;\n                        break;\n                    }\n                    default: {\n                        throw ParseUtils.unexpectedAttribute(reader, i);\n                    }\n                }\n            }\n            if (property == null) {\n                throw ParseUtils.missingRequired(reader, Collections.singleton(Attribute.NAME));\n            }\n            String value = reader.getElementText();\n            protocol.get(ModelKeys.PROPERTY).add(property, value);\n        }\n    }","id":72036,"modified_method":"private void parseProtocol(XMLExtendedStreamReader reader, ModelNode protocol, Class<? extends Protocol> targetClass) throws XMLStreamException {\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            String value = reader.getAttributeValue(i);\n            Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case TYPE: {\n                    try {\n                        this.getClass().getClassLoader().loadClass(org.jgroups.conf.ProtocolConfiguration.protocol_prefix + '.' + value).asSubclass(targetClass).newInstance();\n                        protocol.get(ModelKeys.TYPE).set(value);\n                    } catch (Exception e) {\n                        throw ParseUtils.invalidAttributeValue(reader, i);\n                    }\n                    break;\n                }\n                case SHARED: {\n                    protocol.get(ModelKeys.SHARED).set(Boolean.parseBoolean(value));\n                    break;\n                }\n                case SOCKET_BINDING: {\n                    protocol.get(ModelKeys.SOCKET_BINDING).set(value);\n                    break;\n                }\n                case DIAGNOSTICS_SOCKET_BINDING: {\n                    protocol.get(ModelKeys.DIAGNOSTICS_SOCKET_BINDING).set(value);\n                    break;\n                }\n                case DEFAULT_EXECUTOR: {\n                    protocol.get(ModelKeys.DEFAULT_EXECUTOR).set(value);\n                    break;\n                }\n                case OOB_EXECUTOR: {\n                    protocol.get(ModelKeys.OOB_EXECUTOR).set(value);\n                    break;\n                }\n                case TIMER_EXECUTOR: {\n                    protocol.get(ModelKeys.TIMER_EXECUTOR).set(value);\n                    break;\n                }\n                case THREAD_FACTORY: {\n                    protocol.get(ModelKeys.THREAD_FACTORY).set(value);\n                    break;\n                }\n                default: {\n                    throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n        }\n\n        if (!protocol.hasDefined(ModelKeys.TYPE)) {\n            throw ParseUtils.missingRequired(reader, Collections.singleton(Attribute.TYPE));\n        }\n\n        while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n            if (Element.forName(reader.getLocalName()) != Element.PROPERTY) {\n                throw ParseUtils.unexpectedElement(reader);\n            }\n            int attributes = reader.getAttributeCount();\n            String property = null;\n            for (int i = 0; i < attributes; i++) {\n                String value = reader.getAttributeValue(i);\n                Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NAME: {\n                        property = value;\n                        break;\n                    }\n                    default: {\n                        throw ParseUtils.unexpectedAttribute(reader, i);\n                    }\n                }\n            }\n            if (property == null) {\n                throw ParseUtils.missingRequired(reader, Collections.singleton(Attribute.NAME));\n            }\n            String value = reader.getElementText();\n            protocol.get(ModelKeys.PROPERTY).add(property, value);\n        }\n    }","commit_id":"4a0f333b4000b84d73f3e98dac49e46272427639","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void populate(ModelNode source, ModelNode target) {\n        target.get(ModelKeys.TRANSPORT).set(source.require(ModelKeys.TRANSPORT));\n        ModelNode protocols = target.get(ModelKeys.PROTOCOL);\n        for (ModelNode protocol : source.require(ModelKeys.PROTOCOL).asList()) {\n            protocols.add(protocol);\n        }\n    }","id":72037,"modified_method":"private static void populate(ModelNode source, ModelNode target) {\n        target.get(ModelKeys.TRANSPORT).set(source.require(ModelKeys.TRANSPORT));\n        if (source.hasDefined(ModelKeys.PROTOCOL)) {\n            ModelNode protocols = target.get(ModelKeys.PROTOCOL);\n            for (ModelNode protocol : source.get(ModelKeys.PROTOCOL).asList()) {\n                protocols.add(protocol);\n            }\n        }\n    }","commit_id":"4a0f333b4000b84d73f3e98dac49e46272427639","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        final String nodeIdentifier = operation.hasDefined(NODE_IDENTIFIER) ? operation.get(NODE_IDENTIFIER).asString() : \"1\";\n        final ModelNode processId = operation.require(PROCESS_ID);\n        final String varDirPathRef = operation.hasDefined(RELATIVE_TO) ? operation.get(RELATIVE_TO).asString() : \"jboss.server.data.dir\";\n        final String varDirPath = operation.hasDefined(PATH) ? operation.get(PATH).asString() : \"var\";\n        final int maxPorts = 10;\n\n        if (ROOT_LOGGER.isDebugEnabled()) {\n            ROOT_LOGGER.debugf(\"nodeIdentifier=%s\\n\", nodeIdentifier);\n            ROOT_LOGGER.debugf(\"varDirPathRef=%s, varDirPath=%s\\n\", varDirPathRef, varDirPath);\n\n        }\n\n        // Configure the core configuration.\n        String socketBindingName = null;\n        final CoreEnvironmentService coreEnvironmentService = new CoreEnvironmentService(nodeIdentifier, varDirPath);\n        if (processId.hasDefined(ProcessIdType.UUID.getName())) {\n            // Use the UUID based id\n            UuidProcessId id = new UuidProcessId();\n            coreEnvironmentService.setProcessImplementation(id);\n        } else if (processId.hasDefined(ProcessIdType.SOCKET.getName())) {\n            // Use the socket process id\n            coreEnvironmentService.setProcessImplementationClassName(ProcessIdType.SOCKET.getClazz());\n            ModelNode socket = processId.get(ProcessIdType.SOCKET.getName());\n            socketBindingName = socket.require(BINDING).asString();\n            if (socket.hasDefined(SOCKET_PROCESS_ID_MAX_PORTS)) {\n                int ports = socket.get(SOCKET_PROCESS_ID_MAX_PORTS).asInt(maxPorts);\n                coreEnvironmentService.setSocketProcessIdMaxPorts(ports);\n            }\n        } else {\n            // Default to UUID implementation\n            UuidProcessId id = new UuidProcessId();\n            coreEnvironmentService.setProcessImplementation(id);\n        }\n        ServiceBuilder<?> coreEnvBuilder = context.getServiceTarget().addService(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT, coreEnvironmentService);\n        if (socketBindingName != null) {\n            // Add a dependency on the socket id binding\n            ServiceName bindingName = SocketBinding.JBOSS_BINDING_NAME.append(socketBindingName);\n            coreEnvBuilder.addDependency(bindingName, SocketBinding.class, coreEnvironmentService.getSocketProcessBindingInjector());\n        }\n        ServiceController<String> varDirRPS = RelativePathService.addService(INTERNAL_CORE_ENV_VAR_PATH, varDirPath, varDirPathRef, context.getServiceTarget());\n        controllers.add(varDirRPS);\n        controllers.add(coreEnvBuilder.addDependency(varDirRPS.getName(), String.class, coreEnvironmentService.getPathInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install());\n    }","id":72038,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode recoveryEnvModel,\n                                  ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> controllers) throws OperationFailedException {\n\n        final String nodeIdentifier = operation.hasDefined(NODE_IDENTIFIER) ? operation.get(NODE_IDENTIFIER).asString() : \"1\";\n        final ModelNode processId = operation.hasDefined(PROCESS_ID) ? operation.get(PROCESS_ID) : new ModelNode();\n        final String varDirPathRef = operation.hasDefined(RELATIVE_TO) ? operation.get(RELATIVE_TO).asString() : \"jboss.server.data.dir\";\n        final String varDirPath = operation.hasDefined(PATH) ? operation.get(PATH).asString() : \"var\";\n        final int maxPorts = 10;\n\n        if (ROOT_LOGGER.isDebugEnabled()) {\n            ROOT_LOGGER.debugf(\"nodeIdentifier=%s\\n\", nodeIdentifier);\n            ROOT_LOGGER.debugf(\"varDirPathRef=%s, varDirPath=%s\\n\", varDirPathRef, varDirPath);\n\n        }\n\n        // Configure the core configuration.\n        String socketBindingName = null;\n        final CoreEnvironmentService coreEnvironmentService = new CoreEnvironmentService(nodeIdentifier, varDirPath);\n        if (processId.hasDefined(ProcessIdType.UUID.getName())) {\n            // Use the UUID based id\n            UuidProcessId id = new UuidProcessId();\n            coreEnvironmentService.setProcessImplementation(id);\n        } else if (processId.hasDefined(ProcessIdType.SOCKET.getName())) {\n            // Use the socket process id\n            coreEnvironmentService.setProcessImplementationClassName(ProcessIdType.SOCKET.getClazz());\n            ModelNode socket = processId.get(ProcessIdType.SOCKET.getName());\n            socketBindingName = socket.require(BINDING).asString();\n            if (socket.hasDefined(SOCKET_PROCESS_ID_MAX_PORTS)) {\n                int ports = socket.get(SOCKET_PROCESS_ID_MAX_PORTS).asInt(maxPorts);\n                coreEnvironmentService.setSocketProcessIdMaxPorts(ports);\n            }\n        } else {\n            // Default to UUID implementation\n            UuidProcessId id = new UuidProcessId();\n            coreEnvironmentService.setProcessImplementation(id);\n        }\n        ServiceBuilder<?> coreEnvBuilder = context.getServiceTarget().addService(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT, coreEnvironmentService);\n        if (socketBindingName != null) {\n            // Add a dependency on the socket id binding\n            ServiceName bindingName = SocketBinding.JBOSS_BINDING_NAME.append(socketBindingName);\n            coreEnvBuilder.addDependency(bindingName, SocketBinding.class, coreEnvironmentService.getSocketProcessBindingInjector());\n        }\n        ServiceController<String> varDirRPS = RelativePathService.addService(INTERNAL_CORE_ENV_VAR_PATH, varDirPath, varDirPathRef, context.getServiceTarget());\n        controllers.add(varDirRPS);\n        controllers.add(coreEnvBuilder.addDependency(varDirRPS.getName(), String.class, coreEnvironmentService.getPathInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install());\n    }","commit_id":"4c364a39e2b5eccfbcd84ae28e09452512e9bd48","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseCoordinatorEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n            final ModelNode env = parentAddress.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            env.add(COORDINATOR_ENVIRONMENT, COORDINATOR_ENVIRONMENT);\n            env.protect();\n\n            operation.get(OP_ADDR).set(env);\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case ENABLE_STATISTICS:\n                        operation.get(ENABLE_STATISTICS).set(value);\n                        break;\n                    case ENABLE_TSM_STATUS:\n                        operation.get(ENABLE_TSM_STATUS).set(value);\n                        break;\n                    case DEFAULT_TIMEOUT:\n                        operation.get(DEFAULT_TIMEOUT).set(value);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // Handle elements\n            requireNoContent(reader);\n            list.add(operation);\n        }","id":72039,"modified_method":"static void parseCoordinatorEnvironmentElement(final XMLExtendedStreamReader reader, final ModelNode operation) throws XMLStreamException {\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case ENABLE_STATISTICS:\n                        operation.get(ENABLE_STATISTICS).set(value);\n                        break;\n                    case ENABLE_TSM_STATUS:\n                        operation.get(ENABLE_TSM_STATUS).set(value);\n                        break;\n                    case DEFAULT_TIMEOUT:\n                        operation.get(DEFAULT_TIMEOUT).set(value);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // Handle elements\n            requireNoContent(reader);\n\n        }","commit_id":"4c364a39e2b5eccfbcd84ae28e09452512e9bd48","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseRecoveryEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n            final ModelNode recoveryEnvAddress = parentAddress.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            recoveryEnvAddress.add(RECOVERY_ENVIRONMENT, RECOVERY_ENVIRONMENT);\n            recoveryEnvAddress.protect();\n\n            operation.get(OP_ADDR).set(recoveryEnvAddress);\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case BINDING:\n                        operation.get(BINDING).set(value);\n                        break;\n                    case STATUS_BINDING:\n                        operation.get(STATUS_BINDING).set(value);\n                        break;\n                    case RECOVERY_LISTENER:\n                        operation.get(RECOVERY_LISTENER).set(value);\n                        break;\n                    default:\n                        unexpectedAttribute(reader, i);\n                }\n            }\n            if(! operation.hasDefined(BINDING)) {\n                throw missingRequired(reader, Collections.singleton(Attribute.BINDING));\n            }\n            // Handle elements\n            requireNoContent(reader);\n            list.add(operation);\n        }","id":72040,"modified_method":"static void parseRecoveryEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n            final ModelNode recoveryEnvAddress = parentAddress.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            recoveryEnvAddress.add(CONFIGURATION, RECOVERY_ENVIRONMENT);\n            recoveryEnvAddress.protect();\n\n            operation.get(OP_ADDR).set(recoveryEnvAddress);\n\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case BINDING:\n                        operation.get(BINDING).set(value);\n                        break;\n                    case STATUS_BINDING:\n                        operation.get(STATUS_BINDING).set(value);\n                        break;\n                    case RECOVERY_LISTENER:\n                        operation.get(RECOVERY_LISTENER).set(value);\n                        break;\n                    default:\n                        unexpectedAttribute(reader, i);\n                }\n            }\n            if(! operation.hasDefined(BINDING)) {\n                throw missingRequired(reader, Collections.singleton(Attribute.BINDING));\n            }\n            // Handle elements\n            requireNoContent(reader);\n            list.add(operation);\n        }","commit_id":"4c364a39e2b5eccfbcd84ae28e09452512e9bd48","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * Handle the core-environment element and children\n         * @param reader\n         * @return ModelNode for the core-environment\n         * @throws XMLStreamException\n         */\n        static void parseCoreEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n            final ModelNode env = parentAddress.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            env.add(CORE_ENVIRONMENT, CORE_ENVIRONMENT);\n            env.protect();\n\n            operation.get(OP_ADDR).set(env);\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NODE_IDENTIFIER:\n                        operation.get(NODE_IDENTIFIER).set(value);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // elements\n            final EnumSet<Element> required = EnumSet.of(Element.PROCESS_ID);\n            final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                final Element element = Element.forName(reader.getLocalName());\n                required.remove(element);\n                switch (element) {\n                  case PROCESS_ID : {\n                      if (!encountered.add(element)) {\n                          throw duplicateNamedElement(reader, reader.getLocalName());\n                      }\n                    ModelNode processId = parseProcessIdEnvironmentElement(reader);\n                    operation.get(CommonAttributes.PROCESS_ID).set(processId);\n\n                    break;\n                  }\n                  default:\n                     throw unexpectedElement(reader);\n                }\n            }\n            if (! required.isEmpty()) {\n                throw missingRequired(reader, required);\n            }\n            list.add(operation);\n        }","id":72041,"modified_method":"/**\n         * Handle the core-environment element and children\n         * @param reader\n         * @return ModelNode for the core-environment\n         * @throws XMLStreamException\n         */\n        static void parseCoreEnvironmentElement(final XMLExtendedStreamReader reader, final List<ModelNode> list, final ModelNode parentAddress) throws XMLStreamException {\n            final ModelNode env = parentAddress.clone();\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            env.add(CONFIGURATION, CORE_ENVIRONMENT);\n            env.protect();\n\n            operation.get(OP_ADDR).set(env);\n            final int count = reader.getAttributeCount();\n            for (int i = 0; i < count; i ++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NODE_IDENTIFIER:\n                        operation.get(NODE_IDENTIFIER).set(value);\n                        break;\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n            // elements\n            final EnumSet<Element> required = EnumSet.of(Element.PROCESS_ID);\n            final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                final Element element = Element.forName(reader.getLocalName());\n                required.remove(element);\n                switch (element) {\n                  case PROCESS_ID : {\n                      if (!encountered.add(element)) {\n                          throw duplicateNamedElement(reader, reader.getLocalName());\n                      }\n                    ModelNode processId = parseProcessIdEnvironmentElement(reader);\n                    operation.get(CommonAttributes.PROCESS_ID).set(processId);\n\n                    break;\n                  }\n                  default:\n                     throw unexpectedElement(reader);\n                }\n            }\n            if (! required.isEmpty()) {\n                throw missingRequired(reader, required);\n            }\n            list.add(operation);\n        }","commit_id":"4c364a39e2b5eccfbcd84ae28e09452512e9bd48","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n            // no attributes\n            if (reader.getAttributeCount() > 0) {\n                throw unexpectedAttribute(reader, 0);\n            }\n\n            final ModelNode address = new ModelNode();\n            address.add(ModelDescriptionConstants.SUBSYSTEM, SUBSYSTEM_NAME);\n            address.protect();\n\n            final ModelNode subsystem = new ModelNode();\n            subsystem.get(OP).set(ADD);\n            subsystem.get(OP_ADDR).set(address);\n\n            list.add(subsystem);\n\n            //Object store is always required\n            final ModelNode objectStoreNode = address.clone();\n            final ModelNode objectStoreOperation = new ModelNode();\n            objectStoreOperation.get(OP).set(ADD);\n            objectStoreNode.add(OBJECT_STORE, OBJECT_STORE);\n            objectStoreNode.protect();\n            objectStoreOperation.get(OP_ADDR).set(objectStoreNode);\n\n\n            // elements\n            final EnumSet<Element> required = EnumSet.of(Element.RECOVERY_ENVIRONMENT, Element.CORE_ENVIRONMENT);\n            final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                switch (Namespace.forUri(reader.getNamespaceURI())) {\n                    case TRANSACTIONS_1_0: {\n                        final Element element = Element.forName(reader.getLocalName());\n                        required.remove(element);\n                        if (! encountered.add(element)) {\n                            throw unexpectedElement(reader);\n                        }\n                        switch (element) {\n                            case RECOVERY_ENVIRONMENT: {\n                                parseRecoveryEnvironmentElement(reader, list, address);\n                                break;\n                            }\n                            case CORE_ENVIRONMENT: {\n                                parseCoreEnvironmentElement(reader, list, address);\n                                break;\n                            }\n                            case COORDINATOR_ENVIRONMENT: {\n                                parseCoordinatorEnvironmentElement(reader, list, address);\n                                break;\n                            }\n                            case OBJECT_STORE: {\n                                parseObjectStoreEnvironmentElementAndEnrichOperation(reader, objectStoreOperation);\n                                break;\n                            }\n                            default: {\n                                throw unexpectedElement(reader);\n                            }\n                        }\n                        break;\n                    }\n                    default: {\n                        throw unexpectedElement(reader);\n                    }\n                }\n            }\n            list.add(objectStoreOperation);\n            if (! required.isEmpty()) {\n                throw missingRequiredElement(reader, required);\n            }\n        }","id":72042,"modified_method":"/** {@inheritDoc} */\n        @Override\n        public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n            // no attributes\n            if (reader.getAttributeCount() > 0) {\n                throw unexpectedAttribute(reader, 0);\n            }\n\n            final ModelNode address = new ModelNode();\n            address.add(ModelDescriptionConstants.SUBSYSTEM, SUBSYSTEM_NAME);\n            address.protect();\n\n            final ModelNode subsystem = new ModelNode();\n            subsystem.get(OP).set(ADD);\n            subsystem.get(OP_ADDR).set(address);\n\n            list.add(subsystem);\n\n            //Object store is always required\n            final ModelNode objectStoreNode = address.clone();\n            final ModelNode objectStoreOperation = new ModelNode();\n            objectStoreOperation.get(OP).set(ADD);\n            objectStoreNode.add(CONFIGURATION, OBJECT_STORE);\n            objectStoreNode.protect();\n            objectStoreOperation.get(OP_ADDR).set(objectStoreNode);\n\n            final ModelNode coordinatorNode = address.clone();\n            final ModelNode coordinatorOperatrion = new ModelNode();\n            coordinatorOperatrion.get(OP).set(ADD);\n            coordinatorNode.add(CONFIGURATION, COORDINATOR_ENVIRONMENT);\n            coordinatorNode.protect();\n            coordinatorOperatrion.get(OP_ADDR).set(coordinatorNode);\n\n\n            // elements\n            final EnumSet<Element> required = EnumSet.of(Element.RECOVERY_ENVIRONMENT, Element.CORE_ENVIRONMENT);\n            final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                switch (Namespace.forUri(reader.getNamespaceURI())) {\n                    case TRANSACTIONS_1_0: {\n                        final Element element = Element.forName(reader.getLocalName());\n                        required.remove(element);\n                        if (! encountered.add(element)) {\n                            throw unexpectedElement(reader);\n                        }\n                        switch (element) {\n                            case RECOVERY_ENVIRONMENT: {\n                                parseRecoveryEnvironmentElement(reader, list, address);\n                                break;\n                            }\n                            case CORE_ENVIRONMENT: {\n                                parseCoreEnvironmentElement(reader, list, address);\n                                break;\n                            }\n                            case COORDINATOR_ENVIRONMENT: {\n                                parseCoordinatorEnvironmentElement(reader, coordinatorOperatrion);\n                                break;\n                            }\n                            case OBJECT_STORE: {\n                                parseObjectStoreEnvironmentElementAndEnrichOperation(reader, objectStoreOperation);\n                                break;\n                            }\n                            default: {\n                                throw unexpectedElement(reader);\n                            }\n                        }\n                        break;\n                    }\n                    default: {\n                        throw unexpectedElement(reader);\n                    }\n                }\n            }\n            list.add(objectStoreOperation);\n            list.add(coordinatorOperatrion);\n            if (! required.isEmpty()) {\n                throw missingRequiredElement(reader, required);\n            }\n        }","commit_id":"4c364a39e2b5eccfbcd84ae28e09452512e9bd48","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(ExtensionContext context) {\n        ROOT_LOGGER.debug(\"Initializing Transactions Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(TransactionSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, TransactionSubsystemAdd.INSTANCE, TransactionSubsystemProviders.SUBSYSTEM_ADD, false);\n        registration.registerOperationHandler(DESCRIBE, TransactionDescribeHandler.INSTANCE, TransactionDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n\n        final ManagementResourceRegistration recoveryEnv = registration.registerSubModel(PathElement.pathElement(RECOVERY_ENVIRONMENT),\n                TransactionSubsystemProviders.RECOVERY_ENVIRONMENT_DESC);\n        recoveryEnv.registerOperationHandler(ADD, RecoveryEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_RECOVERY_ENVIRONMENT_DESC, false);\n        recoveryEnv.registerOperationHandler(REMOVE, RecoveryEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_RECOVERY_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration coreEnv = registration.registerSubModel(PathElement.pathElement(CORE_ENVIRONMENT),\n                TransactionSubsystemProviders.CORE_ENVIRONMENT_DESC);\n        coreEnv.registerOperationHandler(ADD, CoreEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_CORE_ENVIRONMENT_DESC, false);\n        coreEnv.registerOperationHandler(REMOVE, CoreEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_CORE_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration coordinatorEnv = registration.registerSubModel(PathElement.pathElement(COORDINATOR_ENVIRONMENT),\n                TransactionSubsystemProviders.COORDINATOR_ENVIRONMENT_DESC);\n        coordinatorEnv.registerOperationHandler(ADD, CoordinatorEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_COORDINATOR_ENVIRONMENT_DESC, false);\n        coordinatorEnv.registerOperationHandler(REMOVE, CoordinatorEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_COORDINATOR_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration objectStore = registration.registerSubModel(PathElement.pathElement(OBJECT_STORE),\n                TransactionSubsystemProviders.OBJECT_STORE_DESC);\n        objectStore.registerOperationHandler(ADD, ObjectStoreAdd.INSTANCE, TransactionSubsystemProviders.ADD_OBJECT_STORE_DESC, false);\n        objectStore.registerOperationHandler(REMOVE, ObjectStoreRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_OBJECT_STORE_DESC, false);\n\n        for (TxStatsHandler.TxStat stat : EnumSet.allOf(TxStatsHandler.TxStat.class)) {\n            registration.registerMetric(stat.toString(), TxStatsHandler.INSTANCE);\n        }\n        subsystem.registerXMLElementWriter(parser);\n    }","id":72043,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(ExtensionContext context) {\n        ROOT_LOGGER.debug(\"Initializing Transactions Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(TransactionSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, TransactionSubsystemAdd.INSTANCE, TransactionSubsystemProviders.SUBSYSTEM_ADD, false);\n        registration.registerOperationHandler(DESCRIBE, TransactionDescribeHandler.INSTANCE, TransactionDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n\n        final ManagementResourceRegistration recoveryEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, RECOVERY_ENVIRONMENT),\n                TransactionSubsystemProviders.RECOVERY_ENVIRONMENT_DESC);\n        recoveryEnv.registerOperationHandler(ADD, RecoveryEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_RECOVERY_ENVIRONMENT_DESC, false);\n        recoveryEnv.registerOperationHandler(REMOVE, RecoveryEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_RECOVERY_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration coreEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, CORE_ENVIRONMENT),\n                TransactionSubsystemProviders.CORE_ENVIRONMENT_DESC);\n        coreEnv.registerOperationHandler(ADD, CoreEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_CORE_ENVIRONMENT_DESC, false);\n        coreEnv.registerOperationHandler(REMOVE, CoreEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_CORE_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration coordinatorEnv = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, COORDINATOR_ENVIRONMENT),\n                TransactionSubsystemProviders.COORDINATOR_ENVIRONMENT_DESC);\n        coordinatorEnv.registerOperationHandler(ADD, CoordinatorEnvironmentAdd.INSTANCE, TransactionSubsystemProviders.ADD_COORDINATOR_ENVIRONMENT_DESC, false);\n        coordinatorEnv.registerOperationHandler(REMOVE, CoordinatorEnvironmentRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_COORDINATOR_ENVIRONMENT_DESC, false);\n\n        final ManagementResourceRegistration objectStore = registration.registerSubModel(PathElement.pathElement(CONFIGURATION, OBJECT_STORE),\n                TransactionSubsystemProviders.OBJECT_STORE_DESC);\n        objectStore.registerOperationHandler(ADD, ObjectStoreAdd.INSTANCE, TransactionSubsystemProviders.ADD_OBJECT_STORE_DESC, false);\n        objectStore.registerOperationHandler(REMOVE, ObjectStoreRemove.INSTANCE, TransactionSubsystemProviders.REMOVE_OBJECT_STORE_DESC, false);\n\n        for (TxStatsHandler.TxStat stat : EnumSet.allOf(TxStatsHandler.TxStat.class)) {\n            registration.registerMetric(stat.toString(), TxStatsHandler.INSTANCE);\n        }\n        subsystem.registerXMLElementWriter(parser);\n    }","commit_id":"4c364a39e2b5eccfbcd84ae28e09452512e9bd48","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n            context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n            ModelNode node = context.getModelNode();\n\n            if (hasDefined(node, CORE_ENVIRONMENT) && node.get(CORE_ENVIRONMENT).asPropertyList().size() != 0) {\n                writer.writeStartElement(Element.CORE_ENVIRONMENT.getLocalName());\n                final ModelNode core = node.get(CORE_ENVIRONMENT).asPropertyList().get(0).getValue();\n                if (hasDefined(core, NODE_IDENTIFIER)) {\n                    writeAttribute(writer, Attribute.NODE_IDENTIFIER, core.get(NODE_IDENTIFIER));\n                }\n                if (hasDefined(core, PROCESS_ID)) {\n                    writeProcessId(writer, core.get(PROCESS_ID));\n                }\n                writer.writeEndElement();\n            }\n            if (hasDefined(node, RECOVERY_ENVIRONMENT) && node.get(RECOVERY_ENVIRONMENT).asPropertyList().size() != 0) {\n                writer.writeStartElement(Element.RECOVERY_ENVIRONMENT.getLocalName());\n                final ModelNode env = node.get(RECOVERY_ENVIRONMENT).asPropertyList().get(0).getValue();\n                if (hasDefined(env, BINDING)) {\n                    writeAttribute(writer, Attribute.BINDING, env.get(BINDING));\n                }\n                if (hasDefined(env, STATUS_BINDING)) {\n                    writeAttribute(writer, Attribute.STATUS_BINDING, env.get(STATUS_BINDING));\n                }\n                if (hasDefined(env, RECOVERY_LISTENER)) {\n                    writeAttribute(writer, Attribute.RECOVERY_LISTENER, env.get(RECOVERY_LISTENER));\n                }\n                writer.writeEndElement();\n            }\n            if (hasDefined(node, COORDINATOR_ENVIRONMENT) && node.get(COORDINATOR_ENVIRONMENT).asPropertyList().size() != 0) {\n                writer.writeStartElement(Element.COORDINATOR_ENVIRONMENT.getLocalName());\n                final ModelNode env = node.get(COORDINATOR_ENVIRONMENT).asPropertyList().get(0).getValue();\n                if (hasDefined(env, ENABLE_STATISTICS)) {\n                    writeAttribute(writer, Attribute.ENABLE_STATISTICS, env.get(ENABLE_STATISTICS));\n                }\n                if (hasDefined(env, ENABLE_TSM_STATUS)) {\n                    writeAttribute(writer, Attribute.ENABLE_TSM_STATUS, env.get(ENABLE_TSM_STATUS));\n                }\n                if (hasDefined(env, DEFAULT_TIMEOUT)) {\n                    writeAttribute(writer, Attribute.DEFAULT_TIMEOUT, env.get(DEFAULT_TIMEOUT));\n                }\n                writer.writeEndElement();\n            }\n            if (hasDefined(node, OBJECT_STORE) && node.get(OBJECT_STORE).asPropertyList().size() != 0) {\n                writer.writeStartElement(Element.OBJECT_STORE.getLocalName());\n                final ModelNode env = node.get(OBJECT_STORE).asPropertyList().get(0).getValue();\n                if (hasDefined(env, RELATIVE_TO)) {\n                    writeAttribute(writer, Attribute.RELATIVE_TO, env.get(RELATIVE_TO));\n                }\n                if (hasDefined(env, PATH)) {\n                    writeAttribute(writer, Attribute.PATH, env.get(PATH));\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n        }","id":72044,"modified_method":"/** {@inheritDoc} */\n        @Override\n        public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n            context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n            ModelNode node = context.getModelNode();\n\n            if (hasDefined(node, CONFIGURATION)) {\n                List<Property> configurations = node.get(CONFIGURATION).asPropertyList();\n                for (Property config : configurations) {\n                    if (config.getName().equals(CORE_ENVIRONMENT) &&\n                            config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.CORE_ENVIRONMENT.getLocalName());\n                        final ModelNode core = config.getValue();\n                        if (hasDefined(core, NODE_IDENTIFIER)) {\n                            writeAttribute(writer, Attribute.NODE_IDENTIFIER, core.get(NODE_IDENTIFIER));\n                        }\n                        if (hasDefined(core, PROCESS_ID)) {\n                            writeProcessId(writer, core.get(PROCESS_ID));\n                        }\n                        writer.writeEndElement();\n                    }\n                    if (config.getName().equals(RECOVERY_ENVIRONMENT) && config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.RECOVERY_ENVIRONMENT.getLocalName());\n                        final ModelNode env = config.getValue();\n                        if (hasDefined(env, BINDING)) {\n                            writeAttribute(writer, Attribute.BINDING, env.get(BINDING));\n                        }\n                        if (hasDefined(env, STATUS_BINDING)) {\n                            writeAttribute(writer, Attribute.STATUS_BINDING, env.get(STATUS_BINDING));\n                        }\n                        if (hasDefined(env, RECOVERY_LISTENER)) {\n                            writeAttribute(writer, Attribute.RECOVERY_LISTENER, env.get(RECOVERY_LISTENER));\n                        }\n                        writer.writeEndElement();\n                    }\n                    if (config.getName().equals(COORDINATOR_ENVIRONMENT) && config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.COORDINATOR_ENVIRONMENT.getLocalName());\n                        final ModelNode env = config.getValue();\n                        if (hasDefined(env, ENABLE_STATISTICS)) {\n                            writeAttribute(writer, Attribute.ENABLE_STATISTICS, env.get(ENABLE_STATISTICS));\n                        }\n                        if (hasDefined(env, ENABLE_TSM_STATUS)) {\n                            writeAttribute(writer, Attribute.ENABLE_TSM_STATUS, env.get(ENABLE_TSM_STATUS));\n                        }\n                        if (hasDefined(env, DEFAULT_TIMEOUT)) {\n                            writeAttribute(writer, Attribute.DEFAULT_TIMEOUT, env.get(DEFAULT_TIMEOUT));\n                        }\n                        writer.writeEndElement();\n                    }\n                    if (config.getName().equals(OBJECT_STORE) && config.getValue().isDefined()) {\n                        writer.writeStartElement(Element.OBJECT_STORE.getLocalName());\n                        final ModelNode env = config.getValue();\n                        if (hasDefined(env, RELATIVE_TO)) {\n                            writeAttribute(writer, Attribute.RELATIVE_TO, env.get(RELATIVE_TO));\n                        }\n                        if (hasDefined(env, PATH)) {\n                            writeAttribute(writer, Attribute.PATH, env.get(PATH));\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n            }\n\n            writer.writeEndElement();\n        }","commit_id":"4c364a39e2b5eccfbcd84ae28e09452512e9bd48","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public MappingManager getMappingManager(String securityDomain) {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":72045,"modified_method":"/** {@inheritDoc} */\n    public MappingManager getMappingManager(String securityDomain) {\n        MappingManager mm = null;\n        try {\n            mm = mappingMgrMap.get(securityDomain);\n            if (mm == null) {\n                mm = (MappingManager) lookUpJNDI(securityDomain + \"/mappingMgr\");\n                mappingMgrMap.put(securityDomain, mm);\n            }\n        } catch (Exception e) {\n            log.trace(\"Exception getting MappingManager for domain=\" + securityDomain, e);\n        }\n        return mm;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public IdentityTrustManager getIdentityTrustManager(String securityDomain) {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":72046,"modified_method":"/** {@inheritDoc} */\n    public IdentityTrustManager getIdentityTrustManager(String securityDomain) {\n        IdentityTrustManager itm = null;\n        try {\n            itm = idmMgrMap.get(securityDomain);\n            if (itm == null) {\n                itm = (IdentityTrustManager) lookUpJNDI(securityDomain + \"/identityTrustMgr\");\n                idmMgrMap.put(securityDomain, itm);\n            }\n        } catch (Exception e) {\n            log.trace(\"Exception getting IdentityTrustManager for domain=\" + securityDomain, e);\n        }\n        return itm;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public AuditManager getAuditManager(String securityDomain) {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":72047,"modified_method":"/** {@inheritDoc} */\n    public AuditManager getAuditManager(String securityDomain) {\n        AuditManager am = null;\n        try {\n            am = auditMgrMap.get(securityDomain);\n            if (am == null) {\n                am = (AuditManager) lookUpJNDI(securityDomain + \"/auditMgr\");\n                auditMgrMap.put(securityDomain, am);\n            }\n        } catch (Exception e) {\n            log.trace(\"Exception getting AuditManager for domain=\" + securityDomain, e);\n        }\n        return am;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates a {@code SecurityDomainContext}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code SecurityDomainContext}\n     * @throws Exception if an error occurs during creation\n     */\n    public SecurityDomainContext createSecurityDomainContext(String securityDomain) throws Exception {\n        log.debug(\"Creating SDC for domain=\" + securityDomain);\n        AuthenticationManager am = createAuthenticationManager(securityDomain);\n        // TODO create auth cache and set it in am\n\n        // set DeepCopySubject option if supported\n        if (deepCopySubjectMode) {\n            setDeepCopySubjectMode(am);\n        }\n\n        // TODO set auth cache\n        SecurityDomainContext securityDomainContext = new SecurityDomainContext(am, null);\n\n        securityDomainContext.setAuthorizationManager(createAuthorizationManager(securityDomain));\n        return securityDomainContext;\n    }","id":72048,"modified_method":"/**\n     * Creates a {@code SecurityDomainContext}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code SecurityDomainContext}\n     * @throws Exception if an error occurs during creation\n     */\n    public SecurityDomainContext createSecurityDomainContext(String securityDomain) throws Exception {\n        log.debug(\"Creating SDC for domain=\" + securityDomain);\n        AuthenticationManager am = createAuthenticationManager(securityDomain);\n        // TODO create auth cache and set it in am\n\n        // set DeepCopySubject option if supported\n        if (deepCopySubjectMode) {\n            setDeepCopySubjectMode(am);\n        }\n\n        // TODO set auth cache\n        SecurityDomainContext securityDomainContext = new SecurityDomainContext(am, null);\n\n        securityDomainContext.setAuthorizationManager(createAuthorizationManager(securityDomain));\n        securityDomainContext.setAuditMgr(createAuditManager(securityDomain));\n        securityDomainContext.setIdentityTrustMgr(createIdentityTrustManager(securityDomain));\n        securityDomainContext.setMappingMgr(createMappingManager(securityDomain));\n        return securityDomainContext;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public AuthorizationManager getAuthorizationManager(String securityDomain) {\n        AuthorizationManager am = null;\n        try {\n            am = this.authzMgrMap.get(securityDomain);\n            if (am == null) {\n                am = (AuthorizationManager) lookUpJNDI(securityDomain + \"/authorizationMgr\");\n                this.authzMgrMap.put(securityDomain, am);\n            }\n        } catch (Exception e) {\n            log.trace(\"Exception getting AuthorizationManager for domain=\", e);\n        }\n        return am;\n    }","id":72049,"modified_method":"/** {@inheritDoc} */\n    public AuthorizationManager getAuthorizationManager(String securityDomain) {\n        AuthorizationManager am = null;\n        try {\n            am = authzMgrMap.get(securityDomain);\n            if (am == null) {\n                am = (AuthorizationManager) lookUpJNDI(securityDomain + \"/authorizationMgr\");\n                authzMgrMap.put(securityDomain, am);\n            }\n        } catch (Exception e) {\n            log.trace(\"Exception getting AuthorizationManager for domain=\", e);\n        }\n        return am;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Object lookup(String name) throws NamingException {\n        Object binding = null;\n        if (name == null || name.length() == 0)\n            throw new InvalidNameException(\"name cannot be null or empty\");\n\n        if (name.equals(ACTIVE_SUBJECT))\n            binding = getSubject();\n        else if (name.equals(AUTHENTICATION_MGR))\n            binding = getAuthenticationManager();\n        else if (name.equals(REALM_MAPPING))\n            binding = getRealmMapping();\n        else if (name.equals(AUTHORIZATION_MGR))\n            binding = getAuthorizationManager();\n        else if (name.equals(AUDIT_MGR))\n            binding = this.getAuditMgr();\n        else if (name.equals(MAPPING_MGR))\n            binding = this.getMappingMgr();\n        else if (name.equals(IDENTITY_TRUST_MGR))\n            binding = this.getIdentityTrustMgr();\n        else if (name.equals(AUTH_CACHE))\n            binding = authenticationCache;\n        else if (name.equals(DOMAIN_CONTEXT))\n            binding = this;\n\n        return binding;\n    }","id":72050,"modified_method":"public Object lookup(String name) throws NamingException {\n        Object binding = null;\n        if (name == null || name.length() == 0)\n            throw new InvalidNameException(\"name cannot be null or empty\");\n\n        if (name.equals(ACTIVE_SUBJECT))\n            binding = getSubject();\n        else if (name.equals(AUTHENTICATION_MGR))\n            binding = getAuthenticationManager();\n        else if (name.equals(REALM_MAPPING))\n            binding = getRealmMapping();\n        else if (name.equals(AUTHORIZATION_MGR))\n            binding = getAuthorizationManager();\n        else if (name.equals(AUDIT_MGR))\n            binding = getAuditMgr();\n        else if (name.equals(MAPPING_MGR))\n            binding = getMappingMgr();\n        else if (name.equals(IDENTITY_TRUST_MGR))\n            binding = getIdentityTrustMgr();\n        else if (name.equals(AUTH_CACHE))\n            binding = authenticationCache;\n        else if (name.equals(DOMAIN_CONTEXT))\n            binding = this;\n\n        return binding;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n\n        log.debug(\"Initializing Security Extension\");\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ModelNodeRegistration registration = subsystem.registerSubsystemModel(new DescriptionProvider() {\n            @Override\n            public ModelNode getModelDescription(Locale locale) {\n                return SecuritySubsystemDescriptions.getSubsystemRoot(locale);\n            }\n        });\n        registration.registerOperationHandler(ADD, SecuritySubsystemAdd.INSTANCE, SecuritySubsystemAdd.INSTANCE,\n                false);\n\n        final ModelNodeRegistration jaas = registration.registerSubModel(PathElement.pathElement(CommonAttributes.JAAS_APPLICATION_POLICY), new DescriptionProvider() {\n            @Override\n            public ModelNode getModelDescription(Locale locale) {\n                return SecuritySubsystemDescriptions.getJaasApplicationPolicy(locale);\n            }\n        });\n        jaas.registerOperationHandler(JaasApplicationPolicyAdd.OPERATION_NAME, JaasApplicationPolicyAdd.INSTANCE, JaasApplicationPolicyAdd.INSTANCE, false);\n        jaas.registerOperationHandler(JaasApplicationPolicyRemove.OPERATION_NAME, JaasApplicationPolicyRemove.INSTANCE, JaasApplicationPolicyRemove.INSTANCE, false);\n        registration.registerOperationHandler(DESCRIBE, SecurityDescribeHandler.INSTANCE, SecurityDescribeHandler.INSTANCE, false);\n        subsystem.registerXMLElementWriter(PARSER);\n    }","id":72051,"modified_method":"@Override\n    public void initialize(ExtensionContext context) {\n        log.debug(\"Initializing Security Extension\");\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ModelNodeRegistration registration = subsystem.registerSubsystemModel(SecuritySubsystemDescriptions.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, SecuritySubsystemAdd.INSTANCE, SecuritySubsystemDescriptions.SUBSYSTEM_ADD,\n                false);\n        registration.registerOperationHandler(DESCRIBE, SecurityDescribeHandler.INSTANCE,\n                SecuritySubsystemDescriptions.SUBSYSTEM_DESCRIBE, false);\n\n        // security domains\n        final ModelNodeRegistration securityDomain = registration.registerSubModel(PathElement\n                .pathElement(CommonAttributes.SECURITY_DOMAIN), SecuritySubsystemDescriptions.SECURITY_DOMAIN);\n        securityDomain.registerOperationHandler(SecurityDomainAdd.OPERATION_NAME, SecurityDomainAdd.INSTANCE,\n                SecuritySubsystemDescriptions.SECURITY_DOMAIN_ADD, false);\n        securityDomain.registerOperationHandler(SecurityDomainRemove.OPERATION_NAME, SecurityDomainRemove.INSTANCE,\n                SecuritySubsystemDescriptions.SECURITY_DOMAIN_REMOVE, false);\n\n        subsystem.registerXMLElementWriter(PARSER);\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void start(StartContext context) throws StartException {\n        if (log.isDebugEnabled())\n            log.debug(\"Starting SecurityManagementService\");\n        // set properties of JNDIBasedSecurityManagement\n        JNDIBasedSecurityManagement securityManagement = JNDIBasedSecurityManagement.getInstance();\n        securityManagement.setAuthenticationManagerClassName(authenticationManagerClassName);\n        securityManagement.setDeepCopySubjectMode(deepCopySubjectMode);\n        securityManagement.setCallbackHandlerClassName(callbackHandlerClassName);\n        securityManagement.setAuthorizationManagerClassName(authorizationManagerClassName);\n        this.securityManagement = securityManagement;\n    }","id":72052,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void start(StartContext context) throws StartException {\n        if (log.isDebugEnabled())\n            log.debug(\"Starting SecurityManagementService\");\n        // set properties of JNDIBasedSecurityManagement\n        JNDIBasedSecurityManagement securityManagement = JNDIBasedSecurityManagement.getInstance();\n        securityManagement.setAuthenticationManagerClassName(authenticationManagerClassName);\n        securityManagement.setDeepCopySubjectMode(deepCopySubjectMode);\n        securityManagement.setCallbackHandlerClassName(callbackHandlerClassName);\n        securityManagement.setAuthorizationManagerClassName(authorizationManagerClassName);\n        securityManagement.setAuditManagerClassName(auditManagerClassName);\n        securityManagement.setIdentityTrustManagerClassName(identityTrustManagerClassName);\n        securityManagement.setMappingManagerClassName(mappingManagerClassName);\n        this.securityManagement = securityManagement;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"public SecurityManagementService(String authenticationManagerClassName, boolean deepCopySubjectMode,\n            String callbackHandlerClassName, String authorizationManagerClassName) {\n        this.authenticationManagerClassName = authenticationManagerClassName;\n        this.deepCopySubjectMode = deepCopySubjectMode;\n        this.callbackHandlerClassName = callbackHandlerClassName;\n        this.authorizationManagerClassName = authorizationManagerClassName;\n    }","id":72053,"modified_method":"public SecurityManagementService(String authenticationManagerClassName, boolean deepCopySubjectMode,\n            String callbackHandlerClassName, String authorizationManagerClassName, String auditManagerClassName,\n            String identityTrustManagerClassName, String mappingManagerClassName) {\n        this.authenticationManagerClassName = authenticationManagerClassName;\n        this.deepCopySubjectMode = deepCopySubjectMode;\n        this.callbackHandlerClassName = callbackHandlerClassName;\n        this.authorizationManagerClassName = authorizationManagerClassName;\n        this.auditManagerClassName = auditManagerClassName;\n        this.identityTrustManagerClassName = identityTrustManagerClassName;\n        this.mappingManagerClassName = mappingManagerClassName;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Cancellable execute(OperationContext context, ModelNode operation, ResultHandler resultHandler) {\n        // Create the compensating operation\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(operation.require(OP_ADDR));\n\n        String authManagerClassName = \"default\";\n        String callbackHandlerClassName = \"default\";\n        boolean deepCopySubject = DEFAULT_DEEP_COPY_OPERATION_MODE;\n        String subjectFactoryClassName = \"default\";\n\n        final ModelNode subModel = context.getSubModel();\n        if (operation.hasDefined(AUTHENTICATION_MANAGER_CLASS_NAME)) {\n            authManagerClassName = operation.get(AUTHENTICATION_MANAGER_CLASS_NAME).asString();\n            subModel.get(AUTHENTICATION_MANAGER_CLASS_NAME).set(authManagerClassName);\n        }\n        if (operation.hasDefined(DEEP_COPY_SUBJECT_MODE)) {\n            deepCopySubject = operation.get(DEEP_COPY_SUBJECT_MODE).asBoolean();\n            subModel.get(DEEP_COPY_SUBJECT_MODE).set(deepCopySubject);\n        }\n        if (operation.hasDefined(DEFAULT_CALLBACK_HANDLER_CLASS_NAME)) {\n            callbackHandlerClassName = operation.get(DEFAULT_CALLBACK_HANDLER_CLASS_NAME).asString();\n            subModel.get(DEFAULT_CALLBACK_HANDLER_CLASS_NAME).set(callbackHandlerClassName);\n        }\n        if (operation.hasDefined(SUBJECT_FACTORY_CLASS_NAME)) {\n            subjectFactoryClassName = operation.get(SUBJECT_FACTORY_CLASS_NAME).asString();\n            subModel.get(SUBJECT_FACTORY_CLASS_NAME).set(SUBJECT_FACTORY_CLASS_NAME);\n        }\n        subModel.get(JAAS_APPLICATION_POLICY).setEmptyObject();\n\n        if (context instanceof BootOperationContext) {\n            final BootOperationContext updateContext = (BootOperationContext) context;\n\n            updateContext.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_MODULE, new SecurityDependencyProcessor());\n\n            final ServiceTarget target = updateContext.getServiceTarget();\n\n            // add bootstrap service\n            final SecurityBootstrapService bootstrapService = new SecurityBootstrapService();\n            target.addService(SecurityBootstrapService.SERVICE_NAME, bootstrapService)\n                    .setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n            // add service to bind SecurityDomainObjectFactory to JNDI\n            final Reference reference = SecurityDomainObjectFactory.createReference(\"JSM\");\n            final JaasBinderService binderService = new JaasBinderService(Values.immediateValue(reference));\n            target.addService(JaasBinderService.SERVICE_NAME, binderService)\n                    .addDependency(JavaContextService.SERVICE_NAME, Context.class, binderService.getContextInjector())\n                    .setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n            // add security management service\n            if (\"default\".equals(authManagerClassName)) {\n                authManagerClassName = AUTHENTICATION_MANAGER;\n            }\n            if (\"default\".equals(callbackHandlerClassName)) {\n                callbackHandlerClassName = CALLBACK_HANDLER;\n            }\n\n            final SecurityManagementService securityManagementService = new SecurityManagementService(\n                    authManagerClassName, deepCopySubject, callbackHandlerClassName, AUTHORIZATION_MANAGER);\n            target.addService(SecurityManagementService.SERVICE_NAME, securityManagementService)\n                    .setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n            // add subject factory service\n            if (\"default\".equals(subjectFactoryClassName))\n                subjectFactoryClassName = SUBJECT_FACTORY;\n\n            final SubjectFactoryService subjectFactoryService = new SubjectFactoryService(subjectFactoryClassName);\n            target.addService(SubjectFactoryService.SERVICE_NAME, subjectFactoryService).addDependency(\n                    SecurityManagementService.SERVICE_NAME, ISecurityManagement.class,\n                    subjectFactoryService.getSecurityManagementInjector()).setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n            // add jaas configuration service\n            Configuration loginConfig = XMLLoginConfigImpl.getInstance();\n            final JaasConfigurationService jaasConfigurationService = new JaasConfigurationService(loginConfig);\n            target.addService(JaasConfigurationService.SERVICE_NAME, jaasConfigurationService).setInitialMode(\n                    ServiceController.Mode.ACTIVE).install();\n        }\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","id":72054,"modified_method":"@Override\n    public Cancellable execute(OperationContext context, ModelNode operation, ResultHandler resultHandler) {\n        // Create the compensating operation\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(operation.require(OP_ADDR));\n\n        String authenticationManagerClassName = \"default\";\n        String callbackHandlerClassName = \"default\";\n        boolean deepCopySubject = DEFAULT_DEEP_COPY_OPERATION_MODE;\n        String subjectFactoryClassName = \"default\";\n        String authorizationManagerClassName = \"default\";\n        String auditManagerClassName = \"default\";\n        String identityTrustManagerClassName = \"default\";\n        String mappingManagerClassName = \"default\";\n\n        final ModelNode subModel = context.getSubModel();\n        if (operation.hasDefined(AUTHENTICATION_MANAGER_CLASS_NAME)) {\n            authenticationManagerClassName = operation.get(AUTHENTICATION_MANAGER_CLASS_NAME).asString();\n            subModel.get(AUTHENTICATION_MANAGER_CLASS_NAME).set(authenticationManagerClassName);\n        }\n        if (operation.hasDefined(DEEP_COPY_SUBJECT_MODE)) {\n            deepCopySubject = operation.get(DEEP_COPY_SUBJECT_MODE).asBoolean();\n            subModel.get(DEEP_COPY_SUBJECT_MODE).set(deepCopySubject);\n        }\n        if (operation.hasDefined(DEFAULT_CALLBACK_HANDLER_CLASS_NAME)) {\n            callbackHandlerClassName = operation.get(DEFAULT_CALLBACK_HANDLER_CLASS_NAME).asString();\n            subModel.get(DEFAULT_CALLBACK_HANDLER_CLASS_NAME).set(callbackHandlerClassName);\n        }\n        if (operation.hasDefined(SUBJECT_FACTORY_CLASS_NAME)) {\n            subjectFactoryClassName = operation.get(SUBJECT_FACTORY_CLASS_NAME).asString();\n            subModel.get(SUBJECT_FACTORY_CLASS_NAME).set(subjectFactoryClassName);\n        }\n        if (operation.hasDefined(AUTHORIZATION_MANAGER_CLASS_NAME)) {\n            authorizationManagerClassName = operation.get(AUTHORIZATION_MANAGER_CLASS_NAME).asString();\n            subModel.get(AUTHORIZATION_MANAGER_CLASS_NAME).set(authorizationManagerClassName);\n        }\n        if (operation.hasDefined(AUDIT_MANAGER_CLASS_NAME)) {\n            auditManagerClassName = operation.get(AUDIT_MANAGER_CLASS_NAME).asString();\n            subModel.get(AUDIT_MANAGER_CLASS_NAME).set(auditManagerClassName);\n        }\n        if (operation.hasDefined(IDENTITY_TRUST_MANAGER_CLASS_NAME)) {\n            identityTrustManagerClassName = operation.get(IDENTITY_TRUST_MANAGER_CLASS_NAME).asString();\n            subModel.get(IDENTITY_TRUST_MANAGER_CLASS_NAME).set(identityTrustManagerClassName);\n        }\n        if (operation.hasDefined(MAPPING_MANAGER_CLASS_NAME)) {\n            mappingManagerClassName = operation.get(MAPPING_MANAGER_CLASS_NAME).asString();\n            subModel.get(MAPPING_MANAGER_CLASS_NAME).set(mappingManagerClassName);\n        }\n        subModel.get(SECURITY_DOMAIN).setEmptyObject();\n\n        if (context instanceof BootOperationContext) {\n            final BootOperationContext updateContext = (BootOperationContext) context;\n\n            updateContext.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_MODULE,\n                    new SecurityDependencyProcessor());\n\n            final ServiceTarget target = updateContext.getServiceTarget();\n\n            // add bootstrap service\n            final SecurityBootstrapService bootstrapService = new SecurityBootstrapService();\n            target.addService(SecurityBootstrapService.SERVICE_NAME, bootstrapService).setInitialMode(\n                    ServiceController.Mode.ACTIVE).install();\n\n            // add service to bind SecurityDomainObjectFactory to JNDI\n            final Reference reference = SecurityDomainObjectFactory.createReference(\"JSM\");\n            final JaasBinderService binderService = new JaasBinderService(Values.immediateValue(reference));\n            target.addService(JaasBinderService.SERVICE_NAME, binderService).addDependency(JavaContextService.SERVICE_NAME,\n                    Context.class, binderService.getContextInjector()).setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n            // add security management service\n            if (\"default\".equals(authenticationManagerClassName)) {\n                authenticationManagerClassName = AUTHENTICATION_MANAGER;\n            }\n            if (\"default\".equals(callbackHandlerClassName)) {\n                callbackHandlerClassName = CALLBACK_HANDLER;\n            }\n            if (\"default\".equals(authorizationManagerClassName)) {\n                authorizationManagerClassName = AUTHORIZATION_MANAGER;\n            }\n            if (\"default\".equals(auditManagerClassName)) {\n                auditManagerClassName = AUDIT_MANAGER;\n            }\n            if (\"default\".equals(identityTrustManagerClassName)) {\n                identityTrustManagerClassName = IDENTITY_TRUST_MANAGER;\n            }\n            if (\"default\".equals(mappingManagerClassName)) {\n                mappingManagerClassName = MAPPING_MANAGER;\n            }\n\n            final SecurityManagementService securityManagementService = new SecurityManagementService(\n                    authenticationManagerClassName, deepCopySubject, callbackHandlerClassName, authorizationManagerClassName,\n                    auditManagerClassName, identityTrustManagerClassName, mappingManagerClassName);\n            target.addService(SecurityManagementService.SERVICE_NAME, securityManagementService).setInitialMode(\n                    ServiceController.Mode.ACTIVE).install();\n\n            // add subject factory service\n            if (\"default\".equals(subjectFactoryClassName))\n                subjectFactoryClassName = SUBJECT_FACTORY;\n\n            final SubjectFactoryService subjectFactoryService = new SubjectFactoryService(subjectFactoryClassName);\n            target.addService(SubjectFactoryService.SERVICE_NAME, subjectFactoryService).addDependency(\n                    SecurityManagementService.SERVICE_NAME, ISecurityManagement.class,\n                    subjectFactoryService.getSecurityManagementInjector()).setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install();\n\n            // add jaas configuration service\n            Configuration loginConfig = XMLLoginConfigImpl.getInstance();\n            final JaasConfigurationService jaasConfigurationService = new JaasConfigurationService(loginConfig);\n            target.addService(JaasConfigurationService.SERVICE_NAME, jaasConfigurationService).setInitialMode(\n                    ServiceController.Mode.ACTIVE).install();\n        }\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private SecuritySubsystemAdd() {\n        // Private to ensure a singleton.\n    }","id":72055,"modified_method":"/** Private to ensure singleton. */\n    private SecuritySubsystemAdd() {\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n\n        if (isNonStandard(node, AUTHENTICATION_MANAGER_CLASS_NAME)\n                || (node.hasDefined(DEEP_COPY_SUBJECT_MODE) && node.get(DEEP_COPY_SUBJECT_MODE).asBoolean())\n                || isNonStandard(node, DEFAULT_CALLBACK_HANDLER_CLASS_NAME)) {\n            writer.writeEmptyElement(Element.SECURITY_MANAGEMENT.getLocalName());\n            if (isNonStandard(node, AUTHENTICATION_MANAGER_CLASS_NAME)) {\n                writeAttribute(writer, Attribute.AUTHENTICATION_MANAGER_CLASS_NAME, node.get(AUTHENTICATION_MANAGER_CLASS_NAME));\n            }\n            if (node.hasDefined(DEEP_COPY_SUBJECT_MODE) && node.get(DEEP_COPY_SUBJECT_MODE).asBoolean()) {\n                writeAttribute(writer, Attribute.DEEP_COPY_SUBJECT_MODE, node.get(DEEP_COPY_SUBJECT_MODE));\n            }\n            if (isNonStandard(node, DEFAULT_CALLBACK_HANDLER_CLASS_NAME)) {\n                writeAttribute(writer, Attribute.DEFAULT_CALLBACK_HANDLER_CLASS_NAME,\n                        node.get(DEFAULT_CALLBACK_HANDLER_CLASS_NAME));\n            }\n        }\n\n        if (isNonStandard(node, SUBJECT_FACTORY_CLASS_NAME)) {\n            writer.writeEmptyElement(Element.SUBJECT_FACTORY.getLocalName());\n            writeAttribute(writer, Attribute.SUBJECT_FACTORY_CLASS_NAME,\n                    node.get(SUBJECT_FACTORY_CLASS_NAME));\n        }\n\n        if (node.hasDefined(JAAS_APPLICATION_POLICY) && node.get(JAAS_APPLICATION_POLICY).asInt() > 0) {\n\n            writer.writeStartElement(Element.JAAS.getLocalName());\n            for (Property policy : node.get(JAAS_APPLICATION_POLICY).asPropertyList()) {\n                writer.writeStartElement(Element.APPLICATION_POLICY.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), policy.getName());\n                ModelNode policyDetails = policy.getValue();\n                if (policyDetails.hasDefined(Attribute.EXTENDS.getLocalName())) {\n                    writer.writeAttribute(Attribute.EXTENDS.getLocalName(), policyDetails.get(Attribute.EXTENDS.getLocalName()).asString());\n                }\n                writeApplicationPolicyContent(writer, policyDetails);\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n        }\n\n        writer.writeEndElement();\n    }","id":72056,"modified_method":"@Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n\n        if (isNonStandard(node, AUTHENTICATION_MANAGER_CLASS_NAME)\n                || (node.hasDefined(DEEP_COPY_SUBJECT_MODE) && node.get(DEEP_COPY_SUBJECT_MODE).asBoolean())\n                || isNonStandard(node, DEFAULT_CALLBACK_HANDLER_CLASS_NAME)\n                || isNonStandard(node, AUTHORIZATION_MANAGER_CLASS_NAME) || isNonStandard(node, AUDIT_MANAGER_CLASS_NAME)\n                || isNonStandard(node, IDENTITY_TRUST_MANAGER_CLASS_NAME) || isNonStandard(node, MAPPING_MANAGER_CLASS_NAME)) {\n            writer.writeEmptyElement(Element.SECURITY_MANAGEMENT.getLocalName());\n            if (isNonStandard(node, AUTHENTICATION_MANAGER_CLASS_NAME)) {\n                writeAttribute(writer, Attribute.AUTHENTICATION_MANAGER_CLASS_NAME, node.get(AUTHENTICATION_MANAGER_CLASS_NAME));\n            }\n            if (node.hasDefined(DEEP_COPY_SUBJECT_MODE) && node.get(DEEP_COPY_SUBJECT_MODE).asBoolean()) {\n                writeAttribute(writer, Attribute.DEEP_COPY_SUBJECT_MODE, node.get(DEEP_COPY_SUBJECT_MODE));\n            }\n            if (isNonStandard(node, DEFAULT_CALLBACK_HANDLER_CLASS_NAME)) {\n                writeAttribute(writer, Attribute.DEFAULT_CALLBACK_HANDLER_CLASS_NAME, node\n                        .get(DEFAULT_CALLBACK_HANDLER_CLASS_NAME));\n            }\n            if (isNonStandard(node, AUTHORIZATION_MANAGER_CLASS_NAME)) {\n                writeAttribute(writer, Attribute.AUTHORIZATION_MANAGER_CLASS_NAME, node.get(AUTHORIZATION_MANAGER_CLASS_NAME));\n            }\n            if (isNonStandard(node, AUDIT_MANAGER_CLASS_NAME)) {\n                writeAttribute(writer, Attribute.AUDIT_MANAGER_CLASS_NAME, node.get(AUDIT_MANAGER_CLASS_NAME));\n            }\n            if (isNonStandard(node, IDENTITY_TRUST_MANAGER_CLASS_NAME)) {\n                writeAttribute(writer, Attribute.IDENTITY_TRUST_MANAGER_CLASS_NAME, node.get(IDENTITY_TRUST_MANAGER_CLASS_NAME));\n            }\n            if (isNonStandard(node, MAPPING_MANAGER_CLASS_NAME)) {\n                writeAttribute(writer, Attribute.MAPPING_MANAGER_CLASS_NAME, node.get(MAPPING_MANAGER_CLASS_NAME));\n            }\n        }\n\n        if (isNonStandard(node, SUBJECT_FACTORY_CLASS_NAME)) {\n            writer.writeEmptyElement(Element.SUBJECT_FACTORY.getLocalName());\n            writeAttribute(writer, Attribute.SUBJECT_FACTORY_CLASS_NAME, node.get(SUBJECT_FACTORY_CLASS_NAME));\n        }\n\n        if (node.hasDefined(SECURITY_DOMAIN) && node.get(SECURITY_DOMAIN).asInt() > 0) {\n            writer.writeStartElement(Element.JAAS.getLocalName());\n            for (Property policy : node.get(SECURITY_DOMAIN).asPropertyList()) {\n                writer.writeStartElement(Element.SECURITY_DOMAIN.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), policy.getName());\n                ModelNode policyDetails = policy.getValue();\n                if (policyDetails.hasDefined(Attribute.EXTENDS.getLocalName())) {\n                    writer.writeAttribute(Attribute.EXTENDS.getLocalName(), policyDetails.get(Attribute.EXTENDS.getLocalName())\n                            .asString());\n                }\n                writeSecurityDomainContent(writer, policyDetails);\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n        }\n        writer.writeEndElement();\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeApplicationPolicyContent(XMLExtendedStreamWriter writer, ModelNode policyDetails) throws XMLStreamException {\n        Set<String> keys = new HashSet<String>(policyDetails.keys());\n        keys.remove(Attribute.NAME.getLocalName());\n        keys.remove(Attribute.EXTENDS.getLocalName());\n\n        for (String key : keys) {\n            Element element = Element.forName(key);\n            switch (element) {\n                case AUTHENTICATION: {\n                    writeAuthentication(writer, policyDetails.get(Element.AUTHENTICATION.getLocalName()));\n                    break;\n                }\n                case AUTHORIZATION:\n                case ACL:\n                case AUDIT:\n                case IDENTITY_TRUST:\n                case MAPPING:\n                case AUTHENTICATION_JASPI: {\n                    throw new UnsupportedOperationException(\"NYI: full marshalling of application policy\");\n                }\n                default:\n                    throw new IllegalStateException(\"Unexpected field \" + element.getLocalName());\n            }\n        }\n    }","id":72057,"modified_method":"private void writeAuthenticationJaspi(XMLExtendedStreamWriter writer, ModelNode modelNode) throws XMLStreamException {\n        if (modelNode.isDefined() && modelNode.asInt() > 0) {\n            writer.writeStartElement(Element.AUTHENTICATION_JASPI.getLocalName());\n            ModelNode moduleStack = modelNode.get(Element.LOGIN_MODULE_STACK.getLocalName());\n            writeLoginModuleStack(writer, moduleStack);\n            ModelNode authModule = modelNode.get(Element.AUTH_MODULE.getLocalName());\n            writeAuthModule(writer, authModule);\n            writer.writeEndElement();\n        }\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseCommonModule(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {\n\n        EnumSet<Attribute> required = EnumSet.of(Attribute.CODE, Attribute.FLAG);\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            required.remove(attribute);\n            switch (attribute) {\n                case CODE: {\n                    node.get(Attribute.CODE.getLocalName()).set(value);\n                    break;\n                }\n                case FLAG: {\n                    // TODO validate\n                    node.get(Attribute.FLAG.getLocalName()).set(value);\n                    break;\n                }\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n\n        if (required.size() > 0) {\n            throw missingRequired(reader, required);\n        }\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case SECURITY_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case MODULE_OPTION: {\n                            parseModuleOption(reader, node.get(MODULE_OPTIONS));\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n    }","id":72058,"modified_method":"private void parseAuthModule(XMLExtendedStreamReader reader, ModelNode op) throws XMLStreamException {\n        EnumSet<Attribute> required = EnumSet.of(Attribute.CODE);\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            required.remove(attribute);\n            switch (attribute) {\n                case CODE: {\n                    op.get(Attribute.CODE.getLocalName()).set(value);\n                    break;\n                }\n                case LOGIN_MODULE_STACK_REF: {\n                    op.get(Attribute.LOGIN_MODULE_STACK_REF.getLocalName()).set(value);\n                    break;\n                }\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n\n        if (required.size() > 0) {\n            throw missingRequired(reader, required);\n        }\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case SECURITY_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case MODULE_OPTION: {\n                            parseModuleOption(reader, op.get(MODULE_OPTIONS));\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeAuthentication(XMLExtendedStreamWriter writer, ModelNode modelNode) throws XMLStreamException {\n        if (modelNode.isDefined() && modelNode.asInt() > 0) {\n            writer.writeStartElement(Element.AUTHENTICATION.getLocalName());\n            for (ModelNode loginModule : modelNode.asList()) {\n                writer.writeStartElement(Element.LOGIN_MODULE.getLocalName());\n                writeCommonModule(writer, loginModule);\n            }\n            writer.writeEndElement();\n        }\n\n    }","id":72059,"modified_method":"private void writeAuthentication(XMLExtendedStreamWriter writer, ModelNode modelNode) throws XMLStreamException {\n        if (modelNode.isDefined() && modelNode.asInt() > 0) {\n            writer.writeStartElement(Element.AUTHENTICATION.getLocalName());\n            for (ModelNode loginModule : modelNode.asList()) {\n                writer.writeStartElement(Element.LOGIN_MODULE.getLocalName());\n                writeCommonModule(writer, loginModule, Element.AUTHENTICATION);\n            }\n            writer.writeEndElement();\n        }\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeCommonModule(XMLExtendedStreamWriter writer, ModelNode module) throws XMLStreamException {\n        writer.writeAttribute(Attribute.CODE.getLocalName(), module.require(Attribute.CODE.getLocalName()).asString());\n        writer.writeAttribute(Attribute.FLAG.getLocalName(), module.require(Attribute.FLAG.getLocalName()).asString());\n        if (module.hasDefined(MODULE_OPTIONS) && module.get(MODULE_OPTIONS).asInt() > 0) {\n            writeModuleOptions(writer, module.get(MODULE_OPTIONS));\n        }\n        writer.writeEndElement();\n    }","id":72060,"modified_method":"private void writeCommonModule(XMLExtendedStreamWriter writer, ModelNode module, Element type) throws XMLStreamException {\n        // check map for known modules\n        String code = module.require(Attribute.CODE.getLocalName()).asString();\n        code = getCode(code, type);\n        writer.writeAttribute(Attribute.CODE.getLocalName(), code);\n        if (module.hasDefined(Attribute.FLAG.getLocalName()))\n            writer.writeAttribute(Attribute.FLAG.getLocalName(), module.get(Attribute.FLAG.getLocalName()).asString());\n        if (module.hasDefined(Attribute.TYPE.getLocalName()))\n            writer.writeAttribute(Attribute.TYPE.getLocalName(), module.get(Attribute.TYPE.getLocalName()).asString());\n        if (module.hasDefined(Attribute.LOGIN_MODULE_STACK_REF.getLocalName()))\n            writer.writeAttribute(Attribute.LOGIN_MODULE_STACK_REF.getLocalName(), module.get(\n                    Attribute.LOGIN_MODULE_STACK_REF.getLocalName()).asString());\n        if (module.hasDefined(MODULE_OPTIONS) && module.get(MODULE_OPTIONS).asInt() > 0) {\n            writeModuleOptions(writer, module.get(MODULE_OPTIONS));\n        }\n        writer.writeEndElement();\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private List<ModelNode> parseJaas(final XMLExtendedStreamReader reader, final ModelNode parentAddress) throws XMLStreamException {\n        // no attributes\n        requireNoAttributes(reader);\n\n        List<ModelNode> list = new ArrayList<ModelNode>();\n\n        final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case SECURITY_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    if (!visited.add(element)) {\n                        throw unexpectedElement(reader);\n                    }\n                    switch (element) {\n                        case APPLICATION_POLICY: {\n                            list.add(parseApplicationPolicy(reader, parentAddress));\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n        return list;\n    }","id":72061,"modified_method":"private List<ModelNode> parseJaas(final XMLExtendedStreamReader reader, final ModelNode parentAddress)\n            throws XMLStreamException {\n        requireNoAttributes(reader);\n\n        List<ModelNode> list = new ArrayList<ModelNode>();\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case SECURITY_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case SECURITY_DOMAIN: {\n                            list.add(parseSecurityDomain(reader, parentAddress));\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n        return list;\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseSecurityManagement(final XMLExtendedStreamReader reader, final ModelNode operation) throws XMLStreamException {\n        // read attributes\n        String authenticationManagerClassName = null;\n        boolean deepCopySubjectMode = false;\n        String defaultCallbackHandlerClassName = null;\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case AUTHENTICATION_MANAGER_CLASS_NAME: {\n                    authenticationManagerClassName = value;\n                    break;\n                }\n                case DEEP_COPY_SUBJECT_MODE: {\n                    deepCopySubjectMode = Boolean.parseBoolean(value);\n                    break;\n                }\n                case DEFAULT_CALLBACK_HANDLER_CLASS_NAME: {\n                    defaultCallbackHandlerClassName = value;\n                    break;\n                }\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        requireNoContent(reader);\n\n        if (authenticationManagerClassName == null) {\n            operation.get(AUTHENTICATION_MANAGER_CLASS_NAME).set(authenticationManagerClassName);\n        }\n\n        if (defaultCallbackHandlerClassName == null) {\n            operation.get(DEFAULT_CALLBACK_HANDLER_CLASS_NAME).set(defaultCallbackHandlerClassName);\n        }\n\n        if (deepCopySubjectMode) {\n            operation.get(DEEP_COPY_SUBJECT_MODE).set(deepCopySubjectMode);\n        }\n    }","id":72062,"modified_method":"private void parseSecurityManagement(final XMLExtendedStreamReader reader, final ModelNode operation)\n            throws XMLStreamException {\n        String authenticationManagerClassName = null;\n        boolean deepCopySubjectMode = false;\n        String defaultCallbackHandlerClassName = null;\n        String authorizationManagerClassName = null;\n        String auditManagerClassName = null;\n        String identityTrustManagerClassName = null;\n        String mappingManagerClassName = null;\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case AUTHENTICATION_MANAGER_CLASS_NAME: {\n                    authenticationManagerClassName = value;\n                    break;\n                }\n                case DEEP_COPY_SUBJECT_MODE: {\n                    deepCopySubjectMode = Boolean.parseBoolean(value);\n                    break;\n                }\n                case DEFAULT_CALLBACK_HANDLER_CLASS_NAME: {\n                    defaultCallbackHandlerClassName = value;\n                    break;\n                }\n                case AUTHORIZATION_MANAGER_CLASS_NAME: {\n                    authorizationManagerClassName = value;\n                    break;\n                }\n                case AUDIT_MANAGER_CLASS_NAME: {\n                    auditManagerClassName = value;\n                    break;\n                }\n                case IDENTITY_TRUST_MANAGER_CLASS_NAME: {\n                    identityTrustManagerClassName = value;\n                    break;\n                }\n                case MAPPING_MANAGER_CLASS_NAME: {\n                    mappingManagerClassName = value;\n                    break;\n                }\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n        requireNoContent(reader);\n\n        if (authenticationManagerClassName != null) {\n            operation.get(AUTHENTICATION_MANAGER_CLASS_NAME).set(authenticationManagerClassName);\n        }\n        if (defaultCallbackHandlerClassName != null) {\n            operation.get(DEFAULT_CALLBACK_HANDLER_CLASS_NAME).set(defaultCallbackHandlerClassName);\n        }\n        if (deepCopySubjectMode) {\n            operation.get(DEEP_COPY_SUBJECT_MODE).set(deepCopySubjectMode);\n        }\n        if (authorizationManagerClassName != null) {\n            operation.get(AUTHORIZATION_MANAGER_CLASS_NAME).set(authorizationManagerClassName);\n        }\n        if (auditManagerClassName != null) {\n            operation.get(AUDIT_MANAGER_CLASS_NAME).set(auditManagerClassName);\n        }\n        if (identityTrustManagerClassName != null) {\n            operation.get(IDENTITY_TRUST_MANAGER_CLASS_NAME).set(identityTrustManagerClassName);\n        }\n        if (mappingManagerClassName != null) {\n            operation.get(MAPPING_MANAGER_CLASS_NAME).set(mappingManagerClassName);\n        }\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseAuthentication(XMLExtendedStreamReader reader, ModelNode op) throws XMLStreamException {\n\n        requireNoAttributes(reader);\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case SECURITY_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case LOGIN_MODULE: {\n                            parseCommonModule(reader, op.add());\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n    }","id":72063,"modified_method":"private void parseAuthenticationJaspi(XMLExtendedStreamReader reader, ModelNode op) throws XMLStreamException {\n        requireNoAttributes(reader);\n        final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case SECURITY_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    if (!visited.add(element)) {\n                        throw unexpectedElement(reader);\n                    }\n                    switch (element) {\n                        case LOGIN_MODULE_STACK: {\n                            parseLoginModuleStack(reader, op.get(Element.LOGIN_MODULE_STACK.getLocalName()));\n                            break;\n                        }\n                        case AUTH_MODULE: {\n                            parseAuthModule(reader, op.get(Element.AUTH_MODULE.getLocalName()));\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ModelNode parseApplicationPolicy(XMLExtendedStreamReader reader, ModelNode parentAddress) throws XMLStreamException {\n\n        ModelNode op = new ModelNode();\n        op.get(OP).set(ADD);\n        ModelNode address = op.get(OP_ADDR);\n\n        EnumSet<Attribute> required = EnumSet.of(Attribute.NAME);\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            required.remove(attribute);\n            switch (attribute) {\n                case NAME: {\n                    address.set(parentAddress).add(JAAS_APPLICATION_POLICY, value);\n                    break;\n                }\n                case EXTENDS: {\n                    op.get(attribute.getLocalName()).set(value);\n                    break;\n                }\n                default:\n                    throw unexpectedAttribute(reader, i);\n            }\n        }\n\n        if (required.size() > 0) {\n            throw missingRequired(reader, required);\n        }\n\n        final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case SECURITY_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    if (!visited.add(element)) {\n                        throw unexpectedElement(reader);\n                    }\n                    switch (element) {\n                        case AUTHENTICATION: {\n                            parseAuthentication(reader, op.get(Element.AUTHENTICATION.getLocalName()));\n                            break;\n                        }\n                        case AUTHORIZATION: {\n                            visited.remove(element); // this one is unbounded\n                            // for now fall through to NYI exception\n                        }\n                        case ACL:\n                        case AUDIT:\n                        case IDENTITY_TRUST:\n                        case MAPPING:\n                        case AUTHENTICATION_JASPI: {\n                            throw new UnsupportedOperationException(\"NYI: full parsing of application policy\");\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n        return op;\n    }","id":72064,"modified_method":"private void parseAuthorization(XMLExtendedStreamReader reader, ModelNode op) throws XMLStreamException {\n        requireNoAttributes(reader);\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case SECURITY_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case POLICY_MODULE: {\n                            EnumSet<Attribute> required = EnumSet.of(Attribute.CODE, Attribute.FLAG);\n                            EnumSet<Attribute> notAllowed = EnumSet.of(Attribute.TYPE);\n                            parseCommonModule(reader, op.add(), required, notAllowed, Element.AUTHORIZATION);\n                            break;\n                        }\n                        default: {\n                            throw unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"e64afea6553f93b5f04b0459bc0999fb394094b1","url":"https://github.com/wildfly/wildfly"},{"original_method":"public List<MediaType> getConsumeMime() {\n        if (parent == null) {\n            if (consumesTypes != null) {\n                return JAXRSUtils.parseMediaTypes(consumesTypes);\n            }\n            return JAXRSUtils.getConsumeTypes(\n                 AnnotationUtils.getClassAnnotation(getServiceClass(), Consumes.class));\n        } else {\n            return parent.getConsumeMime();\n        }\n    }","id":72065,"modified_method":"public List<MediaType> getConsumeMime() {\n        if (consumesTypes != null) {\n            return JAXRSUtils.parseMediaTypes(consumesTypes);\n        }\n        Consumes consumes = AnnotationUtils.getClassAnnotation(getServiceClass(), Consumes.class);\n        if (consumes != null || parent == null) {\n            return JAXRSUtils.getConsumeTypes(consumes);\n        } else {\n            return parent.getConsumeMime();\n        }\n    }","commit_id":"f4db015fc658d5d86a0539259cad8b38d863ade1","url":"https://github.com/apache/cxf"},{"original_method":"public List<MediaType> getProduceMime() {\n        if (parent == null) {\n            if (producesTypes != null) {\n                return JAXRSUtils.parseMediaTypes(producesTypes);\n            }\n            return JAXRSUtils.getProduceTypes(\n                 AnnotationUtils.getClassAnnotation(getServiceClass(), Produces.class));\n        } else {\n            return parent.getProduceMime();\n        }\n    }","id":72066,"modified_method":"public List<MediaType> getProduceMime() {\n        if (producesTypes != null) {\n            return JAXRSUtils.parseMediaTypes(producesTypes);\n        }\n        Produces produces = AnnotationUtils.getClassAnnotation(getServiceClass(), Produces.class);\n        if (produces != null || parent == null) {\n            return JAXRSUtils.getProduceTypes(produces);\n        } else {\n            return parent.getProduceMime();\n        }\n    }","commit_id":"f4db015fc658d5d86a0539259cad8b38d863ade1","url":"https://github.com/apache/cxf"},{"original_method":"private void initWidgetGlobal(final V view) {\n    isGlobal = null != AnnotationUtils.getClassAnnotation(view, WidgetGlobal.class);\n  }","id":72067,"modified_method":"private void initWidgetGlobal(final V view) {\n    WidgetScope scopeAnnotation = AnnotationUtils.getClassAnnotation(view, WidgetScope.class);\n    if (scopeAnnotation != null) {\n      isGlobal = ImmutableSet.copyOf(scopeAnnotation.value()).contains(\"GLOBAL\");\n    }\n  }","commit_id":"d4176679d0944757b447ca0213cd9de0dfc413ab","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Returns a method based on the criteria.\n     * @param base the object that owns the method\n     * @param property the name of the method\n     * @param paramTypes the parameter types to use\n     * @param paramValues the parameter values\n     * @return the method specified\n     * @throws MethodNotFoundException\n     */\n    /*\n     * This class duplicates code in javax.el.Util. When making changes keep\n     * the code in sync.\n     */\n    @SuppressWarnings(\"null\")\n    public static Method getMethod(Object base, Object property,\n            Class<?>[] paramTypes, Object[] paramValues)\n            throws MethodNotFoundException {\n        if (base == null || property == null) {\n            throw new MethodNotFoundException(MessageFactory.get(\n                    \"error.method.notfound\", base, property,\n                    paramString(paramTypes)));\n        }\n\n        String methodName = (property instanceof String) ? (String) property\n                : property.toString();\n\n        int paramCount;\n        if (paramTypes == null) {\n            paramCount = 0;\n        } else {\n            paramCount = paramTypes.length;\n        }\n\n        Method[] methods = base.getClass().getMethods();\n        Map<Method,Integer> candidates = new HashMap<>();\n\n        for (Method m : methods) {\n            if (!m.getName().equals(methodName)) {\n                // Method name doesn't match\n                continue;\n            }\n\n            Class<?>[] mParamTypes = m.getParameterTypes();\n            int mParamCount;\n            if (mParamTypes == null) {\n                mParamCount = 0;\n            } else {\n                mParamCount = mParamTypes.length;\n            }\n\n            // Check the number of parameters\n            if (!(paramCount == mParamCount ||\n                    (m.isVarArgs() && paramCount >= mParamCount))) {\n                // Method has wrong number of parameters\n                continue;\n            }\n\n            // Check the parameters match\n            int exactMatch = 0;\n            boolean noMatch = false;\n            for (int i = 0; i < mParamCount; i++) {\n                // Can't be null\n                if (mParamTypes[i].equals(paramTypes[i])) {\n                    exactMatch++;\n                } else if (i == (mParamCount - 1) && m.isVarArgs()) {\n                    Class<?> varType = mParamTypes[i].getComponentType();\n                    for (int j = i; j < paramCount; j++) {\n                        if (!isAssignableFrom(paramTypes[j], varType)) {\n                            if (paramValues == null) {\n                                noMatch = true;\n                                break;\n                            } else {\n                                if (!isCoercibleFrom(paramValues[j], varType)) {\n                                    noMatch = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // Don't treat a varArgs match as an exact match, it can\n                        // lead to a varArgs method matching when the result\n                        // should be ambiguous\n                    }\n                } else if (!isAssignableFrom(paramTypes[i], mParamTypes[i])) {\n                    if (paramValues == null) {\n                        noMatch = true;\n                        break;\n                    } else {\n                        if (!isCoercibleFrom(paramValues[i], mParamTypes[i])) {\n                            noMatch = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (noMatch) {\n                continue;\n            }\n\n            // If a method is found where every parameter matches exactly,\n            // return it\n            if (exactMatch == paramCount) {\n                return getMethod(base.getClass(), m);\n            }\n\n            candidates.put(m, Integer.valueOf(exactMatch));\n        }\n\n        // Look for the method that has the highest number of parameters where\n        // the type matches exactly\n        int bestMatch = 0;\n        Method match = null;\n        boolean multiple = false;\n        for (Map.Entry<Method, Integer> entry : candidates.entrySet()) {\n            if (entry.getValue().intValue() > bestMatch ||\n                    match == null) {\n                bestMatch = entry.getValue().intValue();\n                match = entry.getKey();\n                multiple = false;\n            } else if (entry.getValue().intValue() == bestMatch) {\n                multiple = true;\n            }\n        }\n        if (multiple) {\n            if (bestMatch == paramCount - 1) {\n                // Only one parameter is not an exact match - try using the\n                // super class\n                match = resolveAmbiguousMethod(candidates.keySet(), paramTypes);\n            } else {\n                match = null;\n            }\n\n            if (match == null) {\n                // If multiple methods have the same matching number of parameters\n                // the match is ambiguous so throw an exception\n                throw new MethodNotFoundException(MessageFactory.get(\n                        \"error.method.ambiguous\", base, property,\n                        paramString(paramTypes)));\n                }\n        }\n\n        // Handle case where no match at all was found\n        if (match == null) {\n            throw new MethodNotFoundException(MessageFactory.get(\n                        \"error.method.notfound\", base, property,\n                        paramString(paramTypes)));\n        }\n\n        return getMethod(base.getClass(), match);\n    }","id":72068,"modified_method":"/**\n     * Returns a method based on the criteria.\n     * @param base the object that owns the method\n     * @param property the name of the method\n     * @param paramTypes the parameter types to use\n     * @param paramValues the parameter values\n     * @return the method specified\n     * @throws MethodNotFoundException\n     */\n    /*\n     * This class duplicates code in javax.el.Util. When making changes keep\n     * the code in sync.\n     */\n    @SuppressWarnings(\"null\")\n    public static Method getMethod(Object base, Object property,\n            Class<?>[] paramTypes, Object[] paramValues)\n            throws MethodNotFoundException {\n        if (base == null || property == null) {\n            throw new MethodNotFoundException(MessageFactory.get(\n                    \"error.method.notfound\", base, property,\n                    paramString(paramTypes)));\n        }\n\n        String methodName = (property instanceof String) ? (String) property\n                : property.toString();\n\n        int paramCount;\n        if (paramTypes == null) {\n            paramCount = 0;\n        } else {\n            paramCount = paramTypes.length;\n        }\n\n        Method[] methods = base.getClass().getMethods();\n        Map<Method,MatchResult> candidates = new HashMap<>();\n\n        for (Method m : methods) {\n            if (!m.getName().equals(methodName)) {\n                // Method name doesn't match\n                continue;\n            }\n\n            Class<?>[] mParamTypes = m.getParameterTypes();\n            int mParamCount;\n            if (mParamTypes == null) {\n                mParamCount = 0;\n            } else {\n                mParamCount = mParamTypes.length;\n            }\n\n            // Check the number of parameters\n            if (!(paramCount == mParamCount ||\n                    (m.isVarArgs() && paramCount >= mParamCount))) {\n                // Method has wrong number of parameters\n                continue;\n            }\n\n            // Check the parameters match\n            int exactMatch = 0;\n            int assignableMatch = 0;\n            int coercibleMatch = 0;\n            boolean noMatch = false;\n            for (int i = 0; i < mParamCount; i++) {\n                // Can't be null\n                if (mParamTypes[i].equals(paramTypes[i])) {\n                    exactMatch++;\n                } else if (i == (mParamCount - 1) && m.isVarArgs()) {\n                    Class<?> varType = mParamTypes[i].getComponentType();\n                    for (int j = i; j < paramCount; j++) {\n                        if (isAssignableFrom(paramTypes[j], varType)) {\n                            assignableMatch++;\n                        } else {\n                            if (paramValues == null) {\n                                noMatch = true;\n                                break;\n                            } else {\n                                if (isCoercibleFrom(paramValues[j], varType)) {\n                                    coercibleMatch++;\n                                } else {\n                                    noMatch = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // Don't treat a varArgs match as an exact match, it can\n                        // lead to a varArgs method matching when the result\n                        // should be ambiguous\n                    }\n                } else if (isAssignableFrom(paramTypes[i], mParamTypes[i])) {\n                    assignableMatch++;\n                } else {\n                    if (paramValues == null) {\n                        noMatch = true;\n                        break;\n                    } else {\n                        if (isCoercibleFrom(paramValues[i], mParamTypes[i])) {\n                            coercibleMatch++;\n                        } else {\n                            noMatch = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (noMatch) {\n                continue;\n            }\n\n            // If a method is found where every parameter matches exactly,\n            // return it\n            if (exactMatch == paramCount) {\n                return getMethod(base.getClass(), m);\n            }\n\n            candidates.put(m, new MatchResult(exactMatch, assignableMatch, coercibleMatch));\n        }\n\n        // Look for the method that has the highest number of parameters where\n        // the type matches exactly\n        MatchResult bestMatch = new MatchResult(0, 0, 0);\n        Method match = null;\n        boolean multiple = false;\n        for (Map.Entry<Method, MatchResult> entry : candidates.entrySet()) {\n            int cmp = entry.getValue().compareTo(bestMatch);\n            if (cmp > 0 || match == null) {\n                bestMatch = entry.getValue();\n                match = entry.getKey();\n                multiple = false;\n            } else if (cmp == 0) {\n                multiple = true;\n            }\n        }\n        if (multiple) {\n            if (bestMatch.getExact() == paramCount - 1) {\n                // Only one parameter is not an exact match - try using the\n                // super class\n                match = resolveAmbiguousMethod(candidates.keySet(), paramTypes);\n            } else {\n                match = null;\n            }\n\n            if (match == null) {\n                // If multiple methods have the same matching number of parameters\n                // the match is ambiguous so throw an exception\n                throw new MethodNotFoundException(MessageFactory.get(\n                        \"error.method.ambiguous\", base, property,\n                        paramString(paramTypes)));\n                }\n        }\n\n        // Handle case where no match at all was found\n        if (match == null) {\n            throw new MethodNotFoundException(MessageFactory.get(\n                        \"error.method.notfound\", base, property,\n                        paramString(paramTypes)));\n        }\n\n        return getMethod(base.getClass(), match);\n    }","commit_id":"66642e9ca0674b13843b72e202593e3e58fc2894","url":"https://github.com/apache/tomcat"},{"original_method":"@SuppressWarnings(\"null\")\n    private static Wrapper findWrapper(Class<?> clazz, List<Wrapper> wrappers,\n            String name, Class<?>[] paramTypes, Object[] paramValues) {\n\n        Map<Wrapper,Integer> candidates = new HashMap<>();\n\n        int paramCount;\n        if (paramTypes == null) {\n            paramCount = 0;\n        } else {\n            paramCount = paramTypes.length;\n        }\n\n        for (Wrapper w : wrappers) {\n            Class<?>[] mParamTypes = w.getParameterTypes();\n            int mParamCount;\n            if (mParamTypes == null) {\n                mParamCount = 0;\n            } else {\n                mParamCount = mParamTypes.length;\n            }\n\n            // Check the number of parameters\n            if (!(paramCount == mParamCount ||\n                    (w.isVarArgs() && paramCount >= mParamCount))) {\n                // Method has wrong number of parameters\n                continue;\n            }\n\n            // Check the parameters match\n            int exactMatch = 0;\n            boolean noMatch = false;\n            for (int i = 0; i < mParamCount; i++) {\n                // Can't be null\n                if (mParamTypes[i].equals(paramTypes[i])) {\n                    exactMatch++;\n                } else if (i == (mParamCount - 1) && w.isVarArgs()) {\n                    Class<?> varType = mParamTypes[i].getComponentType();\n                    for (int j = i; j < paramCount; j++) {\n                        if (!isAssignableFrom(paramTypes[j], varType)) {\n                            if (paramValues == null) {\n                                noMatch = true;\n                                break;\n                            } else {\n                                if (!isCoercibleFrom(paramValues[j], varType)) {\n                                    noMatch = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // Don't treat a varArgs match as an exact match, it can\n                        // lead to a varArgs method matching when the result\n                        // should be ambiguous\n                    }\n                } else if (!isAssignableFrom(paramTypes[i], mParamTypes[i])) {\n                    if (paramValues == null) {\n                        noMatch = true;\n                        break;\n                    } else {\n                        if (!isCoercibleFrom(paramValues[i], mParamTypes[i])) {\n                            noMatch = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (noMatch) {\n                continue;\n            }\n\n            // If a method is found where every parameter matches exactly,\n            // return it\n            if (exactMatch == paramCount) {\n                return w;\n            }\n\n            candidates.put(w, Integer.valueOf(exactMatch));\n        }\n\n        // Look for the method that has the highest number of parameters where\n        // the type matches exactly\n        int bestMatch = 0;\n        Wrapper match = null;\n        boolean multiple = false;\n        for (Map.Entry<Wrapper, Integer> entry : candidates.entrySet()) {\n            if (entry.getValue().intValue() > bestMatch ||\n                    match == null) {\n                bestMatch = entry.getValue().intValue();\n                match = entry.getKey();\n                multiple = false;\n            } else if (entry.getValue().intValue() == bestMatch) {\n                multiple = true;\n            }\n        }\n        if (multiple) {\n            if (bestMatch == paramCount - 1) {\n                // Only one parameter is not an exact match - try using the\n                // super class\n                match = resolveAmbiguousWrapper(candidates.keySet(), paramTypes);\n            } else {\n                match = null;\n            }\n\n            if (match == null) {\n                // If multiple methods have the same matching number of parameters\n                // the match is ambiguous so throw an exception\n                throw new MethodNotFoundException(message(\n                        null, \"util.method.ambiguous\", clazz, name,\n                        paramString(paramTypes)));\n                }\n        }\n\n        // Handle case where no match at all was found\n        if (match == null) {\n            throw new MethodNotFoundException(message(\n                        null, \"util.method.notfound\", clazz, name,\n                        paramString(paramTypes)));\n        }\n\n        return match;\n    }","id":72069,"modified_method":"@SuppressWarnings(\"null\")\n    private static Wrapper findWrapper(Class<?> clazz, List<Wrapper> wrappers,\n            String name, Class<?>[] paramTypes, Object[] paramValues) {\n\n        Map<Wrapper,MatchResult> candidates = new HashMap<>();\n\n        int paramCount;\n        if (paramTypes == null) {\n            paramCount = 0;\n        } else {\n            paramCount = paramTypes.length;\n        }\n\n        for (Wrapper w : wrappers) {\n            Class<?>[] mParamTypes = w.getParameterTypes();\n            int mParamCount;\n            if (mParamTypes == null) {\n                mParamCount = 0;\n            } else {\n                mParamCount = mParamTypes.length;\n            }\n\n            // Check the number of parameters\n            if (!(paramCount == mParamCount ||\n                    (w.isVarArgs() && paramCount >= mParamCount))) {\n                // Method has wrong number of parameters\n                continue;\n            }\n\n            // Check the parameters match\n            int exactMatch = 0;\n            int assignableMatch = 0;\n            int coercibleMatch = 0;\n            boolean noMatch = false;\n            for (int i = 0; i < mParamCount; i++) {\n                // Can't be null\n                if (mParamTypes[i].equals(paramTypes[i])) {\n                    exactMatch++;\n                } else if (i == (mParamCount - 1) && w.isVarArgs()) {\n                    Class<?> varType = mParamTypes[i].getComponentType();\n                    for (int j = i; j < paramCount; j++) {\n                        if (isAssignableFrom(paramTypes[j], varType)) {\n                            assignableMatch++;\n                        } else {\n                            if (paramValues == null) {\n                                noMatch = true;\n                                break;\n                            } else {\n                                if (isCoercibleFrom(paramValues[j], varType)) {\n                                    coercibleMatch++;\n                                } else {\n                                    noMatch = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // Don't treat a varArgs match as an exact match, it can\n                        // lead to a varArgs method matching when the result\n                        // should be ambiguous\n                    }\n                } else if (isAssignableFrom(paramTypes[i], mParamTypes[i])) {\n                    assignableMatch++;\n                } else {\n                    if (paramValues == null) {\n                        noMatch = true;\n                        break;\n                    } else {\n                        if (isCoercibleFrom(paramValues[i], mParamTypes[i])) {\n                            coercibleMatch++;\n                        } else {\n                            noMatch = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (noMatch) {\n                continue;\n            }\n\n            // If a method is found where every parameter matches exactly,\n            // return it\n            if (exactMatch == paramCount) {\n                return w;\n            }\n\n            candidates.put(w, new MatchResult(exactMatch, assignableMatch, coercibleMatch));\n        }\n\n        // Look for the method that has the highest number of parameters where\n        // the type matches exactly\n        MatchResult bestMatch = new MatchResult(0, 0, 0);\n        Wrapper match = null;\n        boolean multiple = false;\n        for (Map.Entry<Wrapper, MatchResult> entry : candidates.entrySet()) {\n            int cmp = entry.getValue().compareTo(bestMatch);\n            if (cmp > 0 || match == null) {\n                bestMatch = entry.getValue();\n                match = entry.getKey();\n                multiple = false;\n            } else if (cmp == 0) {\n                multiple = true;\n            }\n        }\n        if (multiple) {\n            if (bestMatch.getExact() == paramCount - 1) {\n                // Only one parameter is not an exact match - try using the\n                // super class\n                match = resolveAmbiguousWrapper(candidates.keySet(), paramTypes);\n            } else {\n                match = null;\n            }\n\n            if (match == null) {\n                // If multiple methods have the same matching number of parameters\n                // the match is ambiguous so throw an exception\n                throw new MethodNotFoundException(message(\n                        null, \"util.method.ambiguous\", clazz, name,\n                        paramString(paramTypes)));\n                }\n        }\n\n        // Handle case where no match at all was found\n        if (match == null) {\n            throw new MethodNotFoundException(message(\n                        null, \"util.method.notfound\", clazz, name,\n                        paramString(paramTypes)));\n        }\n\n        return match;\n    }","commit_id":"66642e9ca0674b13843b72e202593e3e58fc2894","url":"https://github.com/apache/tomcat"},{"original_method":"protected void processKeyEvent(final KeyEvent e) {\n    if (e.getID() == KeyEvent.KEY_PRESSED) {\n      if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n        if (myLastLocation != null) {\n          myEditor.getMainProcessor().stopCurrentProcessor();\n          processComponentInsert(getComponentToInsert(), myLastLocation);\n        }\n      }\n      else {\n        myLastLocation = moveDropLocation(myEditor, myLastLocation, new ComponentItemDragObject(getComponentToInsert()), e);\n      }\n    }\n  }","id":72070,"modified_method":"protected void processKeyEvent(final KeyEvent e) {\n    if (e.getID() == KeyEvent.KEY_PRESSED) {\n      if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n        if (myLastLocation != null) {\n          myEditor.getMainProcessor().stopCurrentProcessor();\n          processComponentInsert(getComponentToInsert(), myLastLocation);\n        }\n      }\n      else {\n        ComponentItem componentToInsert = getComponentToInsert();\n        if (componentToInsert == null) {\n          cancelOperation();\n        }\n        else {\n          myLastLocation = moveDropLocation(myEditor, myLastLocation, new ComponentItemDragObject(componentToInsert), e);\n        }\n      }\n    }\n  }","commit_id":"d57b1ae5cb0f715ff0a307800859ee43af5c5f12","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void processMouseEvent(final MouseEvent e){\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n      final ComponentItem componentItem = getComponentToInsert();\n      if (componentItem != null) {\n        processComponentInsert(e.getPoint(), null, componentItem);\n      }\n    }\n    else if (e.getID() == MouseEvent.MOUSE_MOVED) {\n      myLastLocation = myGridInsertProcessor.processDragEvent(e.getPoint(), getComponentToInsert());\n      if (myLastLocation.canDrop(getComponentToInsert())) {\n        setCursor(FormEditingUtil.getCopyDropCursor());\n      }\n      else {\n        setCursor(FormEditingUtil.getMoveNoDropCursor());\n      }\n    }\n  }","id":72071,"modified_method":"protected void processMouseEvent(final MouseEvent e){\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n      final ComponentItem componentItem = getComponentToInsert();\n      if (componentItem != null) {\n        processComponentInsert(e.getPoint(), null, componentItem);\n      }\n    }\n    else if (e.getID() == MouseEvent.MOUSE_MOVED) {\n      final ComponentItem componentToInsert = getComponentToInsert();\n      if (componentToInsert != null) {\n        myLastLocation = myGridInsertProcessor.processDragEvent(e.getPoint(), componentToInsert);\n        if (myLastLocation.canDrop(getComponentToInsert())) {\n          setCursor(FormEditingUtil.getCopyDropCursor());\n        }\n        else {\n          setCursor(FormEditingUtil.getMoveNoDropCursor());\n        }\n      }\n    }\n  }","commit_id":"b8c0c4d5f6852afa24f1643a0b5eb2fa8b67919a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Must be overridden by concrete subclasses\n     * @param tracker                         rod data\n     * @param ref                             reference context\n     * @param GLs                             genotype likelihoods\n     * @param log10AlleleFrequencyPriors      priors\n     * @param log10AlleleFrequencyPosteriors  array (pre-allocated) to store results\n     */\n    protected abstract void getLog10PNonRef(RefMetaDataTracker tracker,\n                                            ReferenceContext ref,\n                                            Map<String, Genotype> GLs,\n                                            double[] log10AlleleFrequencyPriors,\n                                            double[] log10AlleleFrequencyPosteriors);","id":72072,"modified_method":"/**\n     * Must be overridden by concrete subclasses\n     * @param tracker                         rod data\n     * @param ref                             reference context\n     * @param GLs                             genotype likelihoods\n     * @param Alleles                       Alleles corresponding to GLs\n     * @param log10AlleleFrequencyPriors      priors\n     * @param log10AlleleFrequencyPosteriors  array (pre-allocated) to store results\n     */\n    protected abstract void getLog10PNonRef(RefMetaDataTracker tracker,\n                                            ReferenceContext ref,\n                                            Map<String, Genotype> GLs,  Set<Allele> Alleles,\n                                            double[] log10AlleleFrequencyPriors,\n                                            double[] log10AlleleFrequencyPosteriors);","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int gdaN2GoldStandard(Map<String, Genotype> GLs,\n                                 double[] log10AlleleFrequencyPriors,\n                                 double[] log10AlleleFrequencyPosteriors) {\n        int numSamples = GLs.size();\n        int numChr = 2*numSamples;\n\n        double[][] logYMatrix = new double[1+numSamples][1+numChr];\n\n        for (int i=0; i <=numSamples; i++)\n            for (int j=0; j <=numChr; j++)\n                logYMatrix[i][j] = Double.NEGATIVE_INFINITY;\n\n        //YMatrix[0][0] = 1.0;\n        logYMatrix[0][0] = 0.0;\n        int j=0;\n\n        for ( Map.Entry<String, Genotype> sample : GLs.entrySet() ) {\n            j++;\n\n            if ( !sample.getValue().hasLikelihoods() )\n                continue;\n\n            //double[] genotypeLikelihoods = MathUtils.normalizeFromLog10(GLs.get(sample).getLikelihoods());\n            double[] genotypeLikelihoods = sample.getValue().getLikelihoods().getAsVector();\n            //double logDenominator = Math.log10(2.0*j*(2.0*j-1));\n            double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n\n            // special treatment for k=0: iteration reduces to:\n            //YMatrix[j][0] = YMatrix[j-1][0]*genotypeLikelihoods[GenotypeType.AA.ordinal()];\n            logYMatrix[j][0] = logYMatrix[j-1][0] + genotypeLikelihoods[GenotypeType.AA.ordinal()];\n\n            for (int k=1; k <= 2*j; k++ ) {\n\n                //double num = (2.0*j-k)*(2.0*j-k-1)*YMatrix[j-1][k] * genotypeLikelihoods[GenotypeType.AA.ordinal()];\n                double logNumerator[];\n                logNumerator = new double[3];\n                if (k < 2*j-1)\n                    logNumerator[0] = MathUtils.log10Cache[2*j-k] + MathUtils.log10Cache[2*j-k-1] + logYMatrix[j-1][k] +\n                            genotypeLikelihoods[GenotypeType.AA.ordinal()];\n                else\n                    logNumerator[0] = Double.NEGATIVE_INFINITY;\n\n\n                if (k < 2*j)\n                    logNumerator[1] = MathUtils.log10Cache[2*k] + MathUtils.log10Cache[2*j-k]+ logYMatrix[j-1][k-1] +\n                            genotypeLikelihoods[GenotypeType.AB.ordinal()];\n                else\n                    logNumerator[1] = Double.NEGATIVE_INFINITY;\n\n                if (k > 1)\n                    logNumerator[2] = MathUtils.log10Cache[k] + MathUtils.log10Cache[k-1] + logYMatrix[j-1][k-2] +\n                            genotypeLikelihoods[GenotypeType.BB.ordinal()];\n                else\n                    logNumerator[2] = Double.NEGATIVE_INFINITY;\n\n                double logNum = MathUtils.softMax(logNumerator);\n\n                //YMatrix[j][k] = num/den;\n                logYMatrix[j][k] = logNum - logDenominator;\n            }\n\n        }\n\n        for (int k=0; k <= numChr; k++)\n            log10AlleleFrequencyPosteriors[k] = logYMatrix[j][k] + log10AlleleFrequencyPriors[k];\n\n        return numChr;\n    }","id":72073,"modified_method":"public int gdaN2GoldStandard(Map<String, Genotype> GLs,\n                                 double[] log10AlleleFrequencyPriors,\n                                 double[] log10AlleleFrequencyPosteriors, int idxAA, int idxAB, int idxBB) {\n        int numSamples = GLs.size();\n        int numChr = 2*numSamples;\n\n        double[][] logYMatrix = new double[1+numSamples][1+numChr];\n\n        for (int i=0; i <=numSamples; i++)\n            for (int j=0; j <=numChr; j++)\n                logYMatrix[i][j] = Double.NEGATIVE_INFINITY;\n\n         //YMatrix[0][0] = 1.0;\n        logYMatrix[0][0] = 0.0;\n        int j=0;\n\n        for ( Map.Entry<String, Genotype> sample : GLs.entrySet() ) {\n            j++;\n\n            if ( !sample.getValue().hasLikelihoods() )\n                continue;\n\n            //double[] genotypeLikelihoods = MathUtils.normalizeFromLog10(GLs.get(sample).getLikelihoods());\n            double[] genotypeLikelihoods = sample.getValue().getLikelihoods().getAsVector();\n            //double logDenominator = Math.log10(2.0*j*(2.0*j-1));\n            double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n\n            // special treatment for k=0: iteration reduces to:\n            //YMatrix[j][0] = YMatrix[j-1][0]*genotypeLikelihoods[GenotypeType.AA.ordinal()];\n            logYMatrix[j][0] = logYMatrix[j-1][0] + genotypeLikelihoods[idxAA];\n\n            for (int k=1; k <= 2*j; k++ ) {\n\n                //double num = (2.0*j-k)*(2.0*j-k-1)*YMatrix[j-1][k] * genotypeLikelihoods[GenotypeType.AA.ordinal()];\n                double logNumerator[];\n                logNumerator = new double[3];\n                if (k < 2*j-1)\n                    logNumerator[0] = MathUtils.log10Cache[2*j-k] + MathUtils.log10Cache[2*j-k-1] + logYMatrix[j-1][k] +\n                            genotypeLikelihoods[idxAA];\n                else\n                    logNumerator[0] = Double.NEGATIVE_INFINITY;\n\n\n                if (k < 2*j)\n                    logNumerator[1] = MathUtils.log10Cache[2*k] + MathUtils.log10Cache[2*j-k]+ logYMatrix[j-1][k-1] +\n                            genotypeLikelihoods[idxAB];\n                else\n                    logNumerator[1] = Double.NEGATIVE_INFINITY;\n\n                if (k > 1)\n                    logNumerator[2] = MathUtils.log10Cache[k] + MathUtils.log10Cache[k-1] + logYMatrix[j-1][k-2] +\n                            genotypeLikelihoods[idxBB];\n                else\n                    logNumerator[2] = Double.NEGATIVE_INFINITY;\n\n                double logNum = MathUtils.softMax(logNumerator);\n\n                //YMatrix[j][k] = num/den;\n                logYMatrix[j][k] = logNum - logDenominator;\n            }\n\n        }\n\n        for (int k=0; k <= numChr; k++)\n            log10AlleleFrequencyPosteriors[k] = logYMatrix[j][k] + log10AlleleFrequencyPriors[k];\n\n        return numChr;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int linearExact(Map<String, Genotype> GLs,\n                           double[] log10AlleleFrequencyPriors,\n                           double[] log10AlleleFrequencyPosteriors) {\n        final int numSamples = GLs.size();\n        final int numChr = 2*numSamples;\n        final double[][] genotypeLikelihoods = getGLs(GLs);\n\n        final ExactACCache logY = new ExactACCache(numSamples+1);\n        logY.getkMinus0()[0] = 0.0; // the zero case\n\n        double maxLog10L = Double.NEGATIVE_INFINITY;\n        boolean done = false;\n        int lastK = -1;\n\n        for (int k=0; k <= numChr && ! done; k++ ) {\n            final double[] kMinus0 = logY.getkMinus0();\n\n            if ( k == 0 ) { // special case for k = 0\n                for ( int j=1; j <= numSamples; j++ ) {\n                    kMinus0[j] = kMinus0[j-1] + genotypeLikelihoods[j][GenotypeType.AA.ordinal()];\n                }\n            } else { // k > 0\n                final double[] kMinus1 = logY.getkMinus1();\n                final double[] kMinus2 = logY.getkMinus2();\n\n                for ( int j=1; j <= numSamples; j++ ) {\n                    final double[] gl = genotypeLikelihoods[j];\n                    final double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n\n                    double aa = Double.NEGATIVE_INFINITY;\n                    double ab = Double.NEGATIVE_INFINITY;\n                    if (k < 2*j-1)\n                        aa = MathUtils.log10Cache[2*j-k] + MathUtils.log10Cache[2*j-k-1] + kMinus0[j-1] + gl[GenotypeType.AA.ordinal()];\n\n                    if (k < 2*j)\n                        ab = MathUtils.log10Cache[2*k] + MathUtils.log10Cache[2*j-k]+ kMinus1[j-1] + gl[GenotypeType.AB.ordinal()];\n\n                    double log10Max;\n                    if (k > 1) {\n                        final double bb = MathUtils.log10Cache[k] + MathUtils.log10Cache[k-1] + kMinus2[j-1] + gl[GenotypeType.BB.ordinal()];\n                        log10Max = approximateLog10SumLog10(aa, ab, bb);\n                    } else {\n                        // we know we aren't considering the BB case, so we can use an optimized log10 function\n                        log10Max = approximateLog10SumLog10(aa, ab);\n                    }\n\n                    // finally, update the L(j,k) value\n                    kMinus0[j] = log10Max - logDenominator;\n                }\n            }\n\n            // update the posteriors vector\n            final double log10LofK = kMinus0[numSamples];\n            log10AlleleFrequencyPosteriors[k] = log10LofK + log10AlleleFrequencyPriors[k];\n\n            // can we abort early?\n            lastK = k;\n            maxLog10L = Math.max(maxLog10L, log10LofK);\n            if ( log10LofK < maxLog10L - MAX_LOG10_ERROR_TO_STOP_EARLY ) {\n                if ( DEBUG ) System.out.printf(\"  *** breaking early k=%d log10L=%.2f maxLog10L=%.2f%n\", k, log10LofK, maxLog10L);\n                done = true;\n            }\n\n            logY.rotate();\n        }\n\n        return lastK;\n    }","id":72074,"modified_method":"public int linearExact(Map<String, Genotype> GLs,\n                           double[] log10AlleleFrequencyPriors,\n                           double[] log10AlleleFrequencyPosteriors, int idxAA, int idxAB, int idxBB) {\n        final int numSamples = GLs.size();\n        final int numChr = 2*numSamples;\n        final double[][] genotypeLikelihoods = getGLs(GLs);\n\n        final ExactACCache logY = new ExactACCache(numSamples+1);\n        logY.getkMinus0()[0] = 0.0; // the zero case\n\n        double maxLog10L = Double.NEGATIVE_INFINITY;\n        boolean done = false;\n        int lastK = -1;\n\n        for (int k=0; k <= numChr && ! done; k++ ) {\n            final double[] kMinus0 = logY.getkMinus0();\n\n            if ( k == 0 ) { // special case for k = 0\n                for ( int j=1; j <= numSamples; j++ ) {\n                    kMinus0[j] = kMinus0[j-1] + genotypeLikelihoods[j][idxAA];\n                }\n            } else { // k > 0\n                final double[] kMinus1 = logY.getkMinus1();\n                final double[] kMinus2 = logY.getkMinus2();\n\n                for ( int j=1; j <= numSamples; j++ ) {\n                    final double[] gl = genotypeLikelihoods[j];\n                    final double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n\n                    double aa = Double.NEGATIVE_INFINITY;\n                    double ab = Double.NEGATIVE_INFINITY;\n                    if (k < 2*j-1)\n                        aa = MathUtils.log10Cache[2*j-k] + MathUtils.log10Cache[2*j-k-1] + kMinus0[j-1] + gl[idxAA];\n\n                    if (k < 2*j)\n                        ab = MathUtils.log10Cache[2*k] + MathUtils.log10Cache[2*j-k]+ kMinus1[j-1] + gl[idxAB];\n\n                    double log10Max;\n                    if (k > 1) {\n                        final double bb = MathUtils.log10Cache[k] + MathUtils.log10Cache[k-1] + kMinus2[j-1] + gl[idxBB];\n                        log10Max = approximateLog10SumLog10(aa, ab, bb);\n                    } else {\n                        // we know we aren't considering the BB case, so we can use an optimized log10 function\n                        log10Max = approximateLog10SumLog10(aa, ab);\n                    }\n\n                    // finally, update the L(j,k) value\n                    kMinus0[j] = log10Max - logDenominator;\n                }\n            }\n\n            // update the posteriors vector\n            final double log10LofK = kMinus0[numSamples];\n            log10AlleleFrequencyPosteriors[k] = log10LofK + log10AlleleFrequencyPriors[k];\n\n            // can we abort early?\n            lastK = k;\n            maxLog10L = Math.max(maxLog10L, log10LofK);\n            if ( log10LofK < maxLog10L - MAX_LOG10_ERROR_TO_STOP_EARLY ) {\n                if ( DEBUG ) System.out.printf(\"  *** breaking early k=%d log10L=%.2f maxLog10L=%.2f%n\", k, log10LofK, maxLog10L);\n                done = true;\n            }\n\n            logY.rotate();\n        }\n\n        return lastK;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Can be overridden by concrete subclasses\n     * @param vc                   variant context with genotype likelihoods\n     * @param log10AlleleFrequencyPosteriors    allele frequency results\n     * @param AFofMaxLikelihood    allele frequency of max likelihood\n     *\n     * @return calls\n     */\n    public Map<String, Genotype> assignGenotypes(VariantContext vc,\n                                                 double[] log10AlleleFrequencyPosteriors,\n                                                 int AFofMaxLikelihood) {\n        if ( !vc.isVariant() )\n            throw new UserException(\"The VCF record passed in does not contain an ALT allele at \" + vc.getChr() + \":\" + vc.getStart());\n\n        Allele refAllele = vc.getReference();\n        Allele altAllele = vc.getAlternateAllele(0);\n\n        Map<String, Genotype> GLs = vc.getGenotypes();\n        double[][] pathMetricArray = new double[GLs.size()+1][AFofMaxLikelihood+1];\n        int[][] tracebackArray = new int[GLs.size()+1][AFofMaxLikelihood+1];\n\n        ArrayList<String> sampleIndices = new ArrayList<String>();\n        int sampleIdx = 0;\n\n        // todo - optimize initialization\n        for (int k=0; k <= AFofMaxLikelihood; k++)\n            for (int j=0; j <= GLs.size(); j++)\n                pathMetricArray[j][k] = -1e30;\n\n        pathMetricArray[0][0] = 0.0;\n\n        if (SIMPLE_GREEDY_GENOTYPER) {\n            sampleIndices.addAll(GLs.keySet());\n            sampleIdx = GLs.size();\n        }\n        else {\n\n            for ( Map.Entry<String, Genotype> sample : GLs.entrySet() ) {\n                if ( !sample.getValue().hasLikelihoods() )\n                    continue;\n\n                double[] likelihoods = sample.getValue().getLikelihoods().getAsVector();\n                sampleIndices.add(sample.getKey());\n\n                for (int k=0; k <= AFofMaxLikelihood; k++) {\n\n                    double bestMetric = pathMetricArray[sampleIdx][k] + likelihoods[0];\n                    int bestIndex = k;\n\n                    if (k>0) {\n                        double m2 =  pathMetricArray[sampleIdx][k-1] + likelihoods[1];\n                        if (m2 > bestMetric) {\n                            bestMetric = m2;\n                            bestIndex  = k-1;\n                        }\n                    }\n\n                    if (k>1) {\n                        double m2 =  pathMetricArray[sampleIdx][k-2] + likelihoods[2];\n                        if (m2 > bestMetric) {\n                            bestMetric = m2;\n                            bestIndex  = k-2;\n                        }\n                    }\n\n                    pathMetricArray[sampleIdx+1][k] = bestMetric;\n                    tracebackArray[sampleIdx+1][k] = bestIndex;\n                }\n                sampleIdx++;\n            }\n        }\n\n        HashMap<String, Genotype> calls = new HashMap<String, Genotype>();\n\n        int startIdx = AFofMaxLikelihood;\n        for (int k = sampleIdx; k > 0; k--) {\n            int bestGTguess;\n            String sample = sampleIndices.get(k-1);\n            Genotype g = GLs.get(sample);\n            if ( !g.hasLikelihoods() )\n                continue;\n\n            if (SIMPLE_GREEDY_GENOTYPER)\n                bestGTguess = Utils.findIndexOfMaxEntry(g.getLikelihoods().getAsVector());\n            else {\n                int newIdx = tracebackArray[k][startIdx];\n                bestGTguess = startIdx - newIdx;\n                startIdx = newIdx;\n            }\n\n            ArrayList<Allele> myAlleles = new ArrayList<Allele>();\n\n            double qual;\n            double[] likelihoods = g.getLikelihoods().getAsVector();\n\n            if (bestGTguess == 0) {\n                myAlleles.add(refAllele);\n                myAlleles.add(refAllele);\n                qual = likelihoods[0] - Math.max(likelihoods[1], likelihoods[2]);\n            } else if(bestGTguess == 1) {\n                myAlleles.add(refAllele);\n                myAlleles.add(altAllele);\n                qual = likelihoods[1] - Math.max(likelihoods[0], likelihoods[2]);\n\n            }  else {\n                myAlleles.add(altAllele);\n                myAlleles.add(altAllele);\n                qual = likelihoods[2] - Math.max(likelihoods[1], likelihoods[0]);\n            }\n\n\n            if (qual < 0) {\n                // QUAL can be negative if the chosen genotype is not the most likely one individually.\n                // In this case, we compute the actual genotype probability and QUAL is the likelihood of it not being the chosen on\n                double[] normalized = MathUtils.normalizeFromLog10(likelihoods);\n                double chosenGenotype = normalized[bestGTguess];\n                qual = -1.0 * Math.log10(1.0 - chosenGenotype);\n            }\n\n            calls.put(sample, new Genotype(sample, myAlleles, qual, null, g.getAttributes(), false));\n\n        }\n\n        return calls;\n    }","id":72075,"modified_method":"/**\n     * Can be overridden by concrete subclasses\n     * @param vc                   variant context with genotype likelihoods\n     * @param log10AlleleFrequencyPosteriors    allele frequency results\n     * @param AFofMaxLikelihood    allele frequency of max likelihood\n     *\n     * @return calls\n     */\n    public Map<String, Genotype> assignGenotypes(VariantContext vc,\n                                                 double[] log10AlleleFrequencyPosteriors,\n                                                 int AFofMaxLikelihood) {\n        if ( !vc.isVariant() )\n            throw new UserException(\"The VCF record passed in does not contain an ALT allele at \" + vc.getChr() + \":\" + vc.getStart());\n\n        boolean multiAllelicRecord = false;\n\n        if (vc.getAlternateAlleles().size() > 1)\n            multiAllelicRecord = true;\n\n        Map<String, Genotype> GLs = vc.getGenotypes();\n        double[][] pathMetricArray = new double[GLs.size()+1][AFofMaxLikelihood+1];\n        int[][] tracebackArray = new int[GLs.size()+1][AFofMaxLikelihood+1];\n\n        ArrayList<String> sampleIndices = new ArrayList<String>();\n        int sampleIdx = 0;\n\n        // todo - optimize initialization\n        for (int k=0; k <= AFofMaxLikelihood; k++)\n            for (int j=0; j <= GLs.size(); j++)\n                pathMetricArray[j][k] = -1e30;\n\n        pathMetricArray[0][0] = 0.0;\n\n        // todo = can't deal with optimal dynamic programming solution with multiallelic records\n        if (SIMPLE_GREEDY_GENOTYPER || multiAllelicRecord) {\n            sampleIndices.addAll(GLs.keySet());\n            sampleIdx = GLs.size();\n        }\n        else {\n\n            for ( Map.Entry<String, Genotype> sample : GLs.entrySet() ) {\n                if ( !sample.getValue().hasLikelihoods() )\n                    continue;\n\n                double[] likelihoods = sample.getValue().getLikelihoods().getAsVector();\n                sampleIndices.add(sample.getKey());\n\n                for (int k=0; k <= AFofMaxLikelihood; k++) {\n\n                    double bestMetric = pathMetricArray[sampleIdx][k] + likelihoods[0];\n                    int bestIndex = k;\n\n                    if (k>0) {\n                        double m2 =  pathMetricArray[sampleIdx][k-1] + likelihoods[1];\n                        if (m2 > bestMetric) {\n                            bestMetric = m2;\n                            bestIndex  = k-1;\n                        }\n                    }\n\n                    if (k>1) {\n                        double m2 =  pathMetricArray[sampleIdx][k-2] + likelihoods[2];\n                        if (m2 > bestMetric) {\n                            bestMetric = m2;\n                            bestIndex  = k-2;\n                        }\n                    }\n\n                    pathMetricArray[sampleIdx+1][k] = bestMetric;\n                    tracebackArray[sampleIdx+1][k] = bestIndex;\n                }\n                sampleIdx++;\n            }\n        }\n\n        HashMap<String, Genotype> calls = new HashMap<String, Genotype>();\n\n        int startIdx = AFofMaxLikelihood;\n        for (int k = sampleIdx; k > 0; k--) {\n            int bestGTguess;\n            String sample = sampleIndices.get(k-1);\n            Genotype g = GLs.get(sample);\n            if ( !g.hasLikelihoods() )\n                continue;\n\n            if (SIMPLE_GREEDY_GENOTYPER || multiAllelicRecord)\n                bestGTguess = Utils.findIndexOfMaxEntry(g.getLikelihoods().getAsVector());\n            else {\n                int newIdx = tracebackArray[k][startIdx];\n                bestGTguess = startIdx - newIdx;\n                startIdx = newIdx;\n            }\n\n            ArrayList<Allele> myAlleles = new ArrayList<Allele>();\n\n            double qual = Double.NEGATIVE_INFINITY;\n            double[] likelihoods = g.getLikelihoods().getAsVector();\n /*           System.out.format(\"Sample: %s GL:\",sample);\n            for (int i=0; i < likelihoods.length; i++)\n                System.out.format(\"%1.4f \",likelihoods[i]);\n    */\n\n            for (int i=0; i < likelihoods.length; i++) {\n                if (i==bestGTguess)\n                    continue;\n                if (likelihoods[i] >= qual)\n                    qual = likelihoods[i];\n            }\n            // qual contains now max(likelihoods[k]) for all k != bestGTguess\n            qual = likelihoods[bestGTguess] - qual;\n\n            // likelihoods are stored row-wise in upper triangular matrix. IE\n            // for 2 alleles they have ordering AA,AB,BB\n            // for 3 alleles they are ordered AA,AB,AC,BB,BC,CC\n            // Get now alleles corresponding to best index\n            int kk=0;\n            boolean done = false;\n            for (int i=0; i < vc.getNAlleles(); i++) {\n                for (int j=i; j < vc.getNAlleles(); j++){\n                    if (kk++ == bestGTguess) {\n                        if (i==0)\n                            myAlleles.add(vc.getReference());\n                        else\n                            myAlleles.add(vc.getAlternateAllele(i-1));\n\n                        if (j==0)\n                            myAlleles.add(vc.getReference());\n                        else\n                            myAlleles.add(vc.getAlternateAllele(j-1));\n                        done = true;\n                        break;\n                    }\n\n                }\n                if (done)\n                    break;\n            }\n\n            if (qual < 0) {\n                // QUAL can be negative if the chosen genotype is not the most likely one individually.\n                // In this case, we compute the actual genotype probability and QUAL is the likelihood of it not being the chosen on\n                double[] normalized = MathUtils.normalizeFromLog10(likelihoods);\n                double chosenGenotype = normalized[bestGTguess];\n                qual = -1.0 * Math.log10(1.0 - chosenGenotype);\n            }\n //System.out.println(myAlleles.toString());\n            calls.put(sample, new Genotype(sample, myAlleles, qual, null, g.getAttributes(), false));\n\n        }\n\n        return calls;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void getLog10PNonRef(RefMetaDataTracker tracker,\n                                ReferenceContext ref,\n                                Map<String, Genotype> GLs,\n                                double[] log10AlleleFrequencyPriors,\n                                double[] log10AlleleFrequencyPosteriors) {\n        // todo -- REMOVE ME AFTER TESTING\n        // todo -- REMOVE ME AFTER TESTING\n        // todo -- REMOVE ME AFTER TESTING\n        double[] gsPosteriors;\n        if ( COMPARE_TO_GS ) // due to annoying special values in incoming array, we have to clone up here\n            gsPosteriors = log10AlleleFrequencyPosteriors.clone();\n\n        // todo -- remove me after testing\n        if ( N_CYCLES > 1 ) {\n            for ( int i = 0; i < N_CYCLES; i++) {\n                timerGS.restart();\n                linearExact(GLs, log10AlleleFrequencyPriors, log10AlleleFrequencyPosteriors.clone());\n                timerGS.stop();\n\n                timerExpt.restart();\n                linearExactBanded(GLs, log10AlleleFrequencyPriors, log10AlleleFrequencyPosteriors.clone());\n                timerExpt.stop();\n            }\n\n            System.out.printf(\"good = %.2f, expt = %.2f, delta = %.2f%n\",\n                    timerGS.getElapsedTime(), timerExpt.getElapsedTime(), timerExpt.getElapsedTime()-timerGS.getElapsedTime());\n        }\n\n        int lastK = -1;\n        switch ( calcToUse ) {\n            case N2_GOLD_STANDARD:\n                lastK = gdaN2GoldStandard(GLs, log10AlleleFrequencyPriors, log10AlleleFrequencyPosteriors);\n                break;\n            case LINEAR_EXPERIMENTAL:\n                lastK = linearExact(GLs, log10AlleleFrequencyPriors, log10AlleleFrequencyPosteriors);\n                break;\n        }\n\n        // todo -- REMOVE ME AFTER TESTING\n        // todo -- REMOVE ME AFTER TESTING\n        // todo -- REMOVE ME AFTER TESTING\n        if ( COMPARE_TO_GS ) {\n            gdaN2GoldStandard(GLs, log10AlleleFrequencyPriors, gsPosteriors);\n\n            double log10thisPVar = Math.log10(MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors)[0]);\n            double log10gsPVar = Math.log10(MathUtils.normalizeFromLog10(gsPosteriors)[0]);\n            boolean eq = (log10thisPVar == Double.NEGATIVE_INFINITY && log10gsPVar == Double.NEGATIVE_INFINITY) || MathUtils.compareDoubles(log10thisPVar, log10gsPVar, 1e-4) == 0;\n\n            if ( ! eq || PRINT_LIKELIHOODS ) {\n                System.out.printf(\"----------------------------------------%n\");\n                for (int k=0; k < log10AlleleFrequencyPosteriors.length; k++) {\n                    double x = log10AlleleFrequencyPosteriors[k];\n                    System.out.printf(\"  %d\\t%.2f\\t%.2f\\t%b%n\", k,\n                            x < -1e10 ? Double.NEGATIVE_INFINITY : x, gsPosteriors[k],\n                            log10AlleleFrequencyPosteriors[k] == gsPosteriors[k]);\n                }\n                System.out.printf(\"MAD_AC\\t%d\\t%d\\t%.2f\\t%.2f\\t%.6f%n\",\n                        ref.getLocus().getStart(), lastK, log10thisPVar, log10gsPVar, log10thisPVar - log10gsPVar);\n            }\n        }\n\n    }","id":72076,"modified_method":"public void getLog10PNonRef(RefMetaDataTracker tracker,\n                                ReferenceContext ref,\n                                Map<String, Genotype> GLs, Set<Allele>alleles,\n                                double[] log10AlleleFrequencyPriors,\n                                double[] log10AlleleFrequencyPosteriors) {\n        // todo -- REMOVE ME AFTER TESTING\n        // todo -- REMOVE ME AFTER TESTING\n        // todo -- REMOVE ME AFTER TESTING\n        double[] gsPosteriors;\n        if ( COMPARE_TO_GS ) // due to annoying special values in incoming array, we have to clone up here\n            gsPosteriors = log10AlleleFrequencyPosteriors.clone();\n\n        int idxAA = GenotypeType.AA.ordinal();\n        int idxAB = GenotypeType.AB.ordinal();\n        int idxBB = GenotypeType.BB.ordinal();\n\n        // todo -- remove me after testing\n        if ( N_CYCLES > 1 ) {\n            for ( int i = 0; i < N_CYCLES; i++) {\n                timerGS.restart();\n                linearExact(GLs, log10AlleleFrequencyPriors, log10AlleleFrequencyPosteriors.clone(), idxAA, idxAB, idxBB);\n                timerGS.stop();\n\n                timerExpt.restart();\n                linearExactBanded(GLs, log10AlleleFrequencyPriors, log10AlleleFrequencyPosteriors.clone());\n                timerExpt.stop();\n            }\n\n            System.out.printf(\"good = %.2f, expt = %.2f, delta = %.2f%n\",\n                    timerGS.getElapsedTime(), timerExpt.getElapsedTime(), timerExpt.getElapsedTime()-timerGS.getElapsedTime());\n        }\n\n        int lastK = -1;\n\n        int numAlleles = alleles.size();\n\n        int idxDiag = numAlleles;\n        int incr = numAlleles - 1;\n\n        double[][] posteriorCache = new double[numAlleles-1][];\n        double[] bestAFguess = new double[numAlleles-1];\n\n        for (int k=1; k < numAlleles; k++) {\n            // multi-allelic approximation, part 1: Ideally\n            // for each alt allele compute marginal (suboptimal) posteriors -\n            // compute indices for AA,AB,BB for current allele - genotype likelihoods are a linear vector that can be thought of\n            // as a row-wise upper triangular matrix of likelihoods.\n            // So, for example, with 2 alt alleles, likelihoods have AA,AB,AC,BB,BC,CC.\n            // 3 alt alleles: AA,AB,AC,AD BB BC BD CC CD DD\n\n            idxAA = 0;\n            idxAB = k;\n            // yy is always element on the diagonal.\n            // 2 alleles: BBelement 2\n            // 3 alleles: BB element  3. CC element 5\n            // 4 alleles:\n            idxBB = idxDiag;\n            idxDiag += incr--;\n\n            // todo - possible cleanup\n            switch ( calcToUse ) {\n                case N2_GOLD_STANDARD:\n                    lastK = gdaN2GoldStandard(GLs, log10AlleleFrequencyPriors, log10AlleleFrequencyPosteriors, idxAA, idxAB, idxBB);\n                    break;\n                case LINEAR_EXPERIMENTAL:\n                    lastK = linearExact(GLs, log10AlleleFrequencyPriors, log10AlleleFrequencyPosteriors, idxAA, idxAB, idxBB);\n                    break;\n            }\n            if (numAlleles > 2) {\n                posteriorCache[k-1] = log10AlleleFrequencyPosteriors.clone();\n                bestAFguess[k-1] = (double)MathUtils.maxElementIndex(log10AlleleFrequencyPosteriors);\n            }\n        }\n\n        if (numAlleles > 2) {\n            // multiallelic approximation, part 2:\n            // report posteriors for allele that has highest estimated AC\n            int mostLikelyAlleleIdx = MathUtils.maxElementIndex(bestAFguess);\n            for (int k=0; k < log10AlleleFrequencyPosteriors.length-1; k++)\n                log10AlleleFrequencyPosteriors[k] = (posteriorCache[mostLikelyAlleleIdx][k]);\n\n        }\n        // todo -- REMOVE ME AFTER TESTING\n        // todo -- REMOVE ME AFTER TESTING\n        // todo -- REMOVE ME AFTER TESTING\n        if ( COMPARE_TO_GS ) {\n            gdaN2GoldStandard(GLs, log10AlleleFrequencyPriors, gsPosteriors, idxAA, idxAB, idxBB);\n\n            double log10thisPVar = Math.log10(MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors)[0]);\n            double log10gsPVar = Math.log10(MathUtils.normalizeFromLog10(gsPosteriors)[0]);\n            boolean eq = (log10thisPVar == Double.NEGATIVE_INFINITY && log10gsPVar == Double.NEGATIVE_INFINITY) || MathUtils.compareDoubles(log10thisPVar, log10gsPVar, 1e-4) == 0;\n\n            if ( ! eq || PRINT_LIKELIHOODS ) {\n                System.out.printf(\"----------------------------------------%n\");\n                for (int k=0; k < log10AlleleFrequencyPosteriors.length; k++) {\n                    double x = log10AlleleFrequencyPosteriors[k];\n                    System.out.printf(\"  %d\\t%.2f\\t%.2f\\t%b%n\", k,\n                            x < -1e10 ? Double.NEGATIVE_INFINITY : x, gsPosteriors[k],\n                            log10AlleleFrequencyPosteriors[k] == gsPosteriors[k]);\n                }\n                System.out.printf(\"MAD_AC\\t%d\\t%d\\t%.2f\\t%.2f\\t%.6f%n\",\n                        ref.getLocus().getStart(), lastK, log10thisPVar, log10gsPVar, log10thisPVar - log10gsPVar);\n            }\n        }\n\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Must be overridden by concrete subclasses\n     *\n     * @param tracker              rod data\n     * @param ref                  reference context\n     * @param contexts             stratified alignment contexts\n     * @param contextType          stratified context type\n     * @param priors               priors to use for GLs\n     * @param GLs                  hash of sample->GL to fill in\n     * @param alternateAlleleToUse the alternate allele to use, null if not set\n     *\n     * @param useBAQedPileup\n     * @return genotype likelihoods per sample for AA, AB, BB\n     */\n    public abstract Allele getLikelihoods(RefMetaDataTracker tracker,\n                                          ReferenceContext ref,\n                                          Map<String, AlignmentContext> contexts,\n                                          AlignmentContextUtils.ReadOrientation contextType,\n                                          GenotypePriors priors,\n                                          Map<String, BiallelicGenotypeLikelihoods> GLs,\n                                          Allele alternateAlleleToUse, boolean useBAQedPileup);","id":72077,"modified_method":"/**\n     * Must be overridden by concrete subclasses\n     *\n     * @param tracker              rod data\n     * @param ref                  reference context\n     * @param contexts             stratified alignment contexts\n     * @param contextType          stratified context type\n     * @param priors               priors to use for GLs\n     * @param GLs                  hash of sample->GL to fill in\n     * @param alternateAlleleToUse the alternate allele to use, null if not set\n     *\n     * @param useBAQedPileup\n     * @return genotype likelihoods per sample for AA, AB, BB\n     */\n    public abstract Allele getLikelihoods(RefMetaDataTracker tracker,\n                                          ReferenceContext ref,\n                                          Map<String, AlignmentContext> contexts,\n                                          AlignmentContextUtils.ReadOrientation contextType,\n                                          GenotypePriors priors,\n                                          Map<String, MultiallelicGenotypeLikelihoods> GLs,\n                                          Allele alternateAlleleToUse, boolean useBAQedPileup);","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void getLog10PNonRef(RefMetaDataTracker tracker,\n                                   ReferenceContext ref,\n                                   Map<String, Genotype> GLs,\n                                   double[] log10AlleleFrequencyPriors,\n                                   double[] log10AlleleFrequencyPosteriors) {\n        initializeAFMatrix(GLs);\n\n        // first, calculate for AF=0 (no change to matrix)\n        log10AlleleFrequencyPosteriors[0] = AFMatrix.getLikelihoodsOfFrequency() + log10AlleleFrequencyPriors[0];\n        double maxLikelihoodSeen = log10AlleleFrequencyPosteriors[0];\n\n        int maxAlleleFrequencyToTest = AFMatrix.getSamples().size() * 2;\n\n        // for each minor allele frequency, calculate log10PofDgivenAFi\n        for (int i = 1; i <= maxAlleleFrequencyToTest; i++) {\n            // add one more alternate allele\n            AFMatrix.incrementFrequency();\n\n            // calculate new likelihoods\n            log10AlleleFrequencyPosteriors[i] = AFMatrix.getLikelihoodsOfFrequency() + log10AlleleFrequencyPriors[i];\n\n            // an optimization to speed up the calculation: if we are beyond the local maximum such\n            //  that subsequent likelihoods won't factor into the confidence score, just quit\n            if ( maxLikelihoodSeen - log10AlleleFrequencyPosteriors[i] > LOG10_OPTIMIZATION_EPSILON )\n                return;\n\n            if ( log10AlleleFrequencyPosteriors[i] > maxLikelihoodSeen )\n                maxLikelihoodSeen = log10AlleleFrequencyPosteriors[i];\n        }\n    }","id":72078,"modified_method":"protected void getLog10PNonRef(RefMetaDataTracker tracker,\n                                   ReferenceContext ref,\n                                   Map<String, Genotype> GLs, Set<Allele>alleles,\n                                   double[] log10AlleleFrequencyPriors,\n                                   double[] log10AlleleFrequencyPosteriors) {\n        initializeAFMatrix(GLs);\n\n        // first, calculate for AF=0 (no change to matrix)\n        log10AlleleFrequencyPosteriors[0] = AFMatrix.getLikelihoodsOfFrequency() + log10AlleleFrequencyPriors[0];\n        double maxLikelihoodSeen = log10AlleleFrequencyPosteriors[0];\n\n        int maxAlleleFrequencyToTest = AFMatrix.getSamples().size() * 2;\n\n        // for each minor allele frequency, calculate log10PofDgivenAFi\n        for (int i = 1; i <= maxAlleleFrequencyToTest; i++) {\n            // add one more alternate allele\n            AFMatrix.incrementFrequency();\n\n            // calculate new likelihoods\n            log10AlleleFrequencyPosteriors[i] = AFMatrix.getLikelihoodsOfFrequency() + log10AlleleFrequencyPriors[i];\n\n            // an optimization to speed up the calculation: if we are beyond the local maximum such\n            //  that subsequent likelihoods won't factor into the confidence score, just quit\n            if ( maxLikelihoodSeen - log10AlleleFrequencyPosteriors[i] > LOG10_OPTIMIZATION_EPSILON )\n                return;\n\n            if ( log10AlleleFrequencyPosteriors[i] > maxLikelihoodSeen )\n                maxLikelihoodSeen = log10AlleleFrequencyPosteriors[i];\n        }\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Allele getLikelihoods(RefMetaDataTracker tracker,\n                                 ReferenceContext ref,\n                                 Map<String, AlignmentContext> contexts,\n                                 AlignmentContextUtils.ReadOrientation contextType,\n                                 GenotypePriors priors,\n                                 Map<String, BiallelicGenotypeLikelihoods> GLs,\n                                 Allele alternateAlleleToUse,\n                                 boolean useBAQedPileup) {\n\n        if ( tracker == null )\n            return null;\n\n\n        GenomeLoc loc = ref.getLocus();\n        Allele refAllele, altAllele;\n        VariantContext vc = null;\n\n        if (!ref.getLocus().equals(lastSiteVisited)) {\n            // starting a new site: clear allele list\n            alleleList.clear();\n            lastSiteVisited = ref.getLocus();\n            indelLikelihoodMap.clear();\n            haplotypeMap.clear();\n\n            if (getAlleleListFromVCF) {\n\n                 for( final VariantContext vc_input : tracker.getVariantContexts(ref, \"alleles\", null, ref.getLocus(), false, false) ) {\n                     if( vc_input != null && ! vc_input.isFiltered() && vc_input.isIndel() && ref.getLocus().getStart() == vc_input.getStart()) {\n                         vc = vc_input;\n                         break;\n                     }\n                 }\n                 // ignore places where we don't have a variant\n                 if ( vc == null )\n                     return null;\n\n\n                 if (!vc.isIndel())\n                     return null;\n\n                alleleList.clear();\n                for (Allele a : vc.getAlleles())\n                    alleleList.add(a);\n\n            }\n            else {\n                alleleList = computeConsensusAlleles(ref,contexts, contextType);\n                if (alleleList.isEmpty())\n                    return null;\n            }\n        }\n        // protect against having an indel too close to the edge of a contig\n        if (loc.getStart() <= HAPLOTYPE_SIZE)\n            return null;\n\n        // check if there is enough reference window to create haplotypes (can be an issue at end of contigs)\n        if (ref.getWindow().getStop() < loc.getStop()+HAPLOTYPE_SIZE)\n            return null;\n        if ( !(priors instanceof DiploidIndelGenotypePriors) )\n            throw new StingException(\"Only diploid-based Indel priors are supported in the DINDEL GL model\");\n\n        if (alleleList.isEmpty())\n            return null;\n        \n        refAllele = alleleList.get(0);\n        altAllele = alleleList.get(1);\n        int eventLength = altAllele.getBaseString().length() - refAllele.getBaseString().length();\n        // assume only one alt allele for now\n\n        //List<Haplotype> haplotypesInVC;\n\n        int hsize = (int)ref.getWindow().size()-Math.abs(eventLength)-1;\n        int numPrefBases= ref.getLocus().getStart()-ref.getWindow().getStart()+1;\n\n        if (useOldWrongHorribleHackedUpLikelihoodModel) {\n            numPrefBases = 20;\n            hsize=80;\n        }\n        if (DEBUG)\n            System.out.format(\"hsize: %d eventLength: %d refSize: %d, locStart: %d numpr: %d\\n\",hsize,eventLength,\n                    (int)ref.getWindow().size(), loc.getStart(), numPrefBases);\n\n        haplotypeMap = Haplotype.makeHaplotypeListFromAlleles( alleleList, loc.getStart(),\n            ref, hsize, numPrefBases);\n\n        // For each sample, get genotype likelihoods based on pileup\n        // compute prior likelihoods on haplotypes, and initialize haplotype likelihood matrix with them.\n        // initialize the GenotypeLikelihoods\n        GLs.clear();\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null ) {\n                double[] genotypeLikelihoods;\n                if (useOldWrongHorribleHackedUpLikelihoodModel)\n                    genotypeLikelihoods = model.computeReadHaplotypeLikelihoods( pileup, haplotypeMap);\n                else\n                    genotypeLikelihoods = pairModel.computeReadHaplotypeLikelihoods( pileup, haplotypeMap, ref, HAPLOTYPE_SIZE, eventLength, indelLikelihoodMap);\n\n\n\n                GLs.put(sample.getKey(), new BiallelicGenotypeLikelihoods(sample.getKey(),\n                        refAllele,\n                        altAllele,\n                        genotypeLikelihoods[0],\n                        genotypeLikelihoods[1],\n                        genotypeLikelihoods[2],\n                        getFilteredDepth(pileup)));\n                if (DEBUG)\n                    System.out.format(\"Sample:%s GL:%4.2f %4.2f %4.2f\\n\",sample.getKey(), genotypeLikelihoods[0],genotypeLikelihoods[1], genotypeLikelihoods[2]);\n            }\n        }\n\n        return refAllele;\n    }","id":72079,"modified_method":"public Allele getLikelihoods(RefMetaDataTracker tracker,\n                                 ReferenceContext ref,\n                                 Map<String, AlignmentContext> contexts,\n                                 AlignmentContextUtils.ReadOrientation contextType,\n                                 GenotypePriors priors,\n                                 Map<String, MultiallelicGenotypeLikelihoods> GLs,\n                                 Allele alternateAlleleToUse,\n                                 boolean useBAQedPileup) {\n\n        if ( tracker == null )\n            return null;\n\n\n        GenomeLoc loc = ref.getLocus();\n        Allele refAllele, altAllele;\n        VariantContext vc = null;\n\n        if (!ref.getLocus().equals(lastSiteVisited)) {\n            // starting a new site: clear allele list\n            alleleList.clear();\n            lastSiteVisited = ref.getLocus();\n            indelLikelihoodMap.set(new HashMap<PileupElement,LinkedHashMap<Allele,Double>>());\n            haplotypeMap.clear();\n\n            if (getAlleleListFromVCF) {\n                 EnumSet<VariantContext.Type> allowableTypes = EnumSet.of(VariantContext.Type.INDEL);\n                 allowableTypes.add(VariantContext.Type.MIXED);\n                 for( final VariantContext vc_input : tracker.getVariantContexts(ref, \"alleles\",\n                         allowableTypes, ref.getLocus(), false, false) ) {\n                      if( vc_input != null && ref.getLocus().getStart() == vc_input.getStart()) {\n                         vc = vc_input;\n                         break;\n                     }\n                 }\n                 // ignore places where we don't have a variant\n                 if ( vc == null )\n                     return null;\n\n                alleleList.clear();\n                for (Allele a : vc.getAlleles())\n                    alleleList.add(a);\n\n            }\n            else {\n                alleleList = computeConsensusAlleles(ref,contexts, contextType);\n                if (alleleList.isEmpty())\n                    return null;\n            }\n        }\n        // protect against having an indel too close to the edge of a contig\n        if (loc.getStart() <= HAPLOTYPE_SIZE)\n            return null;\n\n        // check if there is enough reference window to create haplotypes (can be an issue at end of contigs)\n        if (ref.getWindow().getStop() < loc.getStop()+HAPLOTYPE_SIZE)\n            return null;\n        if ( !(priors instanceof DiploidIndelGenotypePriors) )\n            throw new StingException(\"Only diploid-based Indel priors are supported in the DINDEL GL model\");\n\n        if (alleleList.isEmpty())\n            return null;\n        \n        refAllele = alleleList.get(0);\n        altAllele = alleleList.get(1);\n\n        // look for alt allele that has biggest length distance to ref allele\n        int maxLenDiff = 0;\n        for (Allele a: alleleList) {\n            if(a.isNonReference())  {\n                int lenDiff = Math.abs(a.getBaseString().length() - refAllele.getBaseString().length());\n                if (lenDiff > maxLenDiff) {\n                    maxLenDiff = lenDiff;\n                    altAllele = a;\n                }\n            }\n        }\n        int eventLength = altAllele.getBaseString().length() - refAllele.getBaseString().length();\n        int hsize = (int)ref.getWindow().size()-Math.abs(eventLength)-1;\n        int numPrefBases= ref.getLocus().getStart()-ref.getWindow().getStart()+1;\n\n        if (useOldWrongHorribleHackedUpLikelihoodModel) {\n            numPrefBases = 20;\n            hsize=80;\n        }\n        if (DEBUG)\n            System.out.format(\"hsize: %d eventLength: %d refSize: %d, locStart: %d numpr: %d\\n\",hsize,eventLength,\n                    (int)ref.getWindow().size(), loc.getStart(), numPrefBases);\n\n        haplotypeMap = Haplotype.makeHaplotypeListFromAlleles( alleleList, loc.getStart(),\n            ref, hsize, numPrefBases);\n\n        // For each sample, get genotype likelihoods based on pileup\n        // compute prior likelihoods on haplotypes, and initialize haplotype likelihood matrix with them.\n        // initialize the GenotypeLikelihoods\n        GLs.clear();\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null ) {\n                double[] genotypeLikelihoods;\n                if (useOldWrongHorribleHackedUpLikelihoodModel)\n                   genotypeLikelihoods = model.computeReadHaplotypeLikelihoods( pileup, haplotypeMap);\n                else\n                    genotypeLikelihoods = pairModel.computeReadHaplotypeLikelihoods( pileup, haplotypeMap, ref, eventLength, getIndelLikelihoodMap());\n\n\n\n                // which genotype likelihoods correspond to two most likely alleles? By convention, likelihood vector is lexically ordered, for example\n                // for 3 alleles it's 00 01 02 11 12 22\n                 GLs.put(sample.getKey(), new MultiallelicGenotypeLikelihoods(sample.getKey(),\n                        alleleList,\n                        genotypeLikelihoods,\n                        getFilteredDepth(pileup)));\n\n                if (DEBUG) {\n                    System.out.format(\"Sample:%s Alleles:%s GL:\",sample.getKey(), alleleList.toString());\n                    for (int k=0; k < genotypeLikelihoods.length; k++)\n                        System.out.format(\"%1.4f \",genotypeLikelihoods[k]);\n                    System.out.println();\n                }\n            }\n        }\n\n        return refAllele;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected IndelGenotypeLikelihoodsCalculationModel(UnifiedArgumentCollection UAC, Logger logger) {\n        super(UAC, logger);\n        if (UAC.GSA_PRODUCTION_ONLY == false) {\n            pairModel = new PairHMMIndelErrorModel(UAC.INDEL_GAP_OPEN_PENALTY,UAC.INDEL_GAP_CONTINUATION_PENALTY,\n                    UAC.OUTPUT_DEBUG_INDEL_INFO, UAC.DO_CONTEXT_DEPENDENT_PENALTIES, UAC.dovit, UAC.GET_GAP_PENALTIES_FROM_DATA, UAC.INDEL_RECAL_FILE);\n            useOldWrongHorribleHackedUpLikelihoodModel = false;\n        }\n        else {\n            useOldWrongHorribleHackedUpLikelihoodModel = true;\n            double INSERTION_START_PROBABILITY = 1e-3;\n\n            double INSERTION_END_PROBABILITY = 0.5;\n\n            double ALPHA_DELETION_PROBABILITY = 1e-3;\n\n\n            model = new HaplotypeIndelErrorModel(3, INSERTION_START_PROBABILITY,\n                    INSERTION_END_PROBABILITY,ALPHA_DELETION_PROBABILITY,UAC.INDEL_HAPLOTYPE_SIZE, false, UAC.OUTPUT_DEBUG_INDEL_INFO);\n        }\n\n        pairModel = new PairHMMIndelErrorModel(UAC.INDEL_GAP_OPEN_PENALTY,UAC.INDEL_GAP_CONTINUATION_PENALTY,\n                    UAC.OUTPUT_DEBUG_INDEL_INFO, UAC.DO_CONTEXT_DEPENDENT_PENALTIES, UAC.dovit, UAC.GET_GAP_PENALTIES_FROM_DATA, UAC.INDEL_RECAL_FILE);\n        alleleList = new ArrayList<Allele>();\n        getAlleleListFromVCF = UAC.GenotypingMode == GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES;\n        minIndelCountForGenotyping = UAC.MIN_INDEL_COUNT_FOR_GENOTYPING;\n        HAPLOTYPE_SIZE = UAC.INDEL_HAPLOTYPE_SIZE;\n        DEBUG = UAC.OUTPUT_DEBUG_INDEL_INFO;\n\n        indelLikelihoodMap = new HashMap<PileupElement,LinkedHashMap<Allele,Double>>();\n        haplotypeMap = new LinkedHashMap<Allele,Haplotype>();\n\n    }","id":72080,"modified_method":"protected IndelGenotypeLikelihoodsCalculationModel(UnifiedArgumentCollection UAC, Logger logger) {\n        super(UAC, logger);\n        if (UAC.GSA_PRODUCTION_ONLY == false) {\n            pairModel = new PairHMMIndelErrorModel(UAC.INDEL_GAP_OPEN_PENALTY,UAC.INDEL_GAP_CONTINUATION_PENALTY,\n                    UAC.OUTPUT_DEBUG_INDEL_INFO, UAC.DO_CONTEXT_DEPENDENT_PENALTIES, UAC.dovit, UAC.GET_GAP_PENALTIES_FROM_DATA, UAC.INDEL_RECAL_FILE);\n            useOldWrongHorribleHackedUpLikelihoodModel = false;\n        }\n        else {\n            useOldWrongHorribleHackedUpLikelihoodModel = true;\n            double INSERTION_START_PROBABILITY = 1e-3;\n\n            double INSERTION_END_PROBABILITY = 0.5;\n\n            double ALPHA_DELETION_PROBABILITY = 1e-3;\n\n\n            model = new HaplotypeIndelErrorModel(3, INSERTION_START_PROBABILITY,\n                    INSERTION_END_PROBABILITY,ALPHA_DELETION_PROBABILITY,UAC.INDEL_HAPLOTYPE_SIZE, false, UAC.OUTPUT_DEBUG_INDEL_INFO);\n        }\n\n        pairModel = new PairHMMIndelErrorModel(UAC.INDEL_GAP_OPEN_PENALTY,UAC.INDEL_GAP_CONTINUATION_PENALTY,\n                    UAC.OUTPUT_DEBUG_INDEL_INFO, UAC.DO_CONTEXT_DEPENDENT_PENALTIES, UAC.dovit, UAC.GET_GAP_PENALTIES_FROM_DATA, UAC.INDEL_RECAL_FILE);\n        alleleList = new ArrayList<Allele>();\n        getAlleleListFromVCF = UAC.GenotypingMode == GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES;\n        minIndelCountForGenotyping = UAC.MIN_INDEL_COUNT_FOR_GENOTYPING;\n        HAPLOTYPE_SIZE = UAC.INDEL_HAPLOTYPE_SIZE;\n        DEBUG = UAC.OUTPUT_DEBUG_INDEL_INFO;\n\n        haplotypeMap = new LinkedHashMap<Allele,Haplotype>();\n\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public MultiallelicGenotypeLikelihoods(String sample,\n                                         ArrayList<Allele> A,\n                                         double[] log10AALikelihoods, int depth) {\n         this.sample = sample;\n         this.alleleList = A;\n         this.GLs = log10AALikelihoods;\n         this.depth = depth;\n     }","id":72081,"modified_method":"public MultiallelicGenotypeLikelihoods(String sample,\n                                         ArrayList<Allele> A,\n                                         double[] log10Likelihoods, int depth) {\n        /* Check for consistency between likelihood vector and number of alleles */\n        int numAlleles = A.size();\n        if (log10Likelihoods.length != numAlleles*(numAlleles+1)/2)\n            throw new StingException((\"BUG: Incorrect length of GL vector when creating MultiallelicGenotypeLikelihoods object!\"));\n\n         this.sample = sample;\n         this.alleleList = A;\n         this.GLs = log10Likelihoods;\n         this.depth = depth;\n     }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public synchronized double[] computeReadHaplotypeLikelihoods(ReadBackedPileup pileup, LinkedHashMap<Allele,Haplotype> haplotypeMap,\n                                                                   ReferenceContext ref, int haplotypeSize, int eventLength,\n                                                                   HashMap<PileupElement, LinkedHashMap<Allele,Double>> indelLikelihoodMap){\n\n        int numHaplotypes = haplotypeMap.size();\n        double[][] haplotypeLikehoodMatrix = new double[numHaplotypes][numHaplotypes];\n        double readLikelihoods[][] = new double[pileup.getReads().size()][numHaplotypes];\n        int readIdx=0;\n\n        LinkedHashMap<Allele,double[]> gapOpenProbabilityMap = new LinkedHashMap<Allele,double[]>();\n        LinkedHashMap<Allele,double[]> gapContProbabilityMap = new LinkedHashMap<Allele,double[]>();\n\n        if (DEBUG) {\n            System.out.println(\"Reference bases:\");\n            System.out.println(new String(ref.getBases()));\n        }\n\n        if (doContextDependentPenalties && !getGapPenaltiesFromFile)   {\n            // will context dependent probabilities based on homopolymer run. Probabilities are filled based on total complete haplotypes.\n\n\n            for (Allele a: haplotypeMap.keySet()) {\n                Haplotype haplotype = haplotypeMap.get(a);\n                byte[] haplotypeBases = haplotype.getBasesAsBytes();\n                double[] contextLogGapOpenProbabilities = new double[haplotypeBases.length];\n                double[] contextLogGapContinuationProbabilities = new double[haplotypeBases.length];\n\n                // get homopolymer length profile for current haplotype\n                int[] hrunProfile = new int[haplotypeBases.length];\n                getContextHomopolymerLength(haplotypeBases,hrunProfile);\n                if (DEBUG) {\n                    System.out.println(\"Haplotype bases:\");\n                    System.out.println(new String(haplotypeBases));\n                    for (int i=0; i < hrunProfile.length; i++)\n                        System.out.format(\"%d\",hrunProfile[i]);\n                    System.out.println();\n                }\n                fillGapProbabilities(hrunProfile, contextLogGapOpenProbabilities, contextLogGapContinuationProbabilities);\n\n                gapOpenProbabilityMap.put(a,contextLogGapOpenProbabilities);\n                gapContProbabilityMap.put(a,contextLogGapContinuationProbabilities);\n\n            }\n        }\n        for (PileupElement p: pileup) {\n\n            // check if we've already computed likelihoods for this pileup element (i.e. for this read at this location)\n            if (indelLikelihoodMap.containsKey(p)) {\n                HashMap<Allele,Double> el =  indelLikelihoodMap.get(p);\n                int j=0;\n                for (Allele a: haplotypeMap.keySet()) {\n                    readLikelihoods[readIdx][j++] = el.get(a);\n                }\n            }\n            else {\n                //System.out.format(\"%d %s\\n\",p.getRead().getAlignmentStart(), p.getRead().getClass().getName());\n                GATKSAMRecord read = ReadUtils.hardClipAdaptorSequence(p.getRead());\n                if (read == null)\n                    continue;\n\n                if(ReadUtils.is454Read(read) && !getGapPenaltiesFromFile) {\n                    continue;\n                }\n\n                double[] recalQuals = null;\n\n /*\n                if (getGapPenaltiesFromFile) {\n                    RecalDataManager.parseSAMRecord( read, RAC );\n\n\n                    recalQuals = new double[read.getReadLength()];\n\n                    //compute all covariate values for this read\n                    final Comparable[][] covariateValues_offset_x_covar =\n                            RecalDataManager.computeCovariates((GATKSAMRecord) read, requestedCovariates);\n                    // For each base in the read\n                    for( int offset = 0; offset < read.getReadLength(); offset++ ) {\n\n                        final Object[] fullCovariateKey = covariateValues_offset_x_covar[offset];\n\n                        Byte qualityScore = (Byte) qualityScoreByFullCovariateKey.get(fullCovariateKey);\n                        if(qualityScore == null)\n                        {\n                            qualityScore = performSequentialQualityCalculation( fullCovariateKey );\n                            qualityScoreByFullCovariateKey.put(qualityScore, fullCovariateKey);\n                        }\n\n                        recalQuals[offset] = -((double)qualityScore)/10.0;\n                    }\n\n                    // for each read/haplotype combination, compute likelihoods, ie -10*log10(Pr(R | Hi))\n                    // = sum_j(-10*log10(Pr(R_j | Hi) since reads are assumed to be independent\n                    if (DEBUG)  {\n                        System.out.format(\"\\n\\nStarting read:%s S:%d US:%d E:%d UE:%d C:%s\\n\",read.getReadName(),\n                                read.getAlignmentStart(),\n                                read.getUnclippedStart(), read.getAlignmentEnd(), read.getUnclippedEnd(),\n                                read.getCigarString());\n\n                        byte[] bases = read.getReadBases();\n                        for (int k = 0; k < recalQuals.length; k++) {\n                            System.out.format(\"%c\",bases[k]);\n                        }\n                        System.out.println();\n\n                        for (int k = 0; k < recalQuals.length; k++) {\n                            System.out.format(\"%.0f \",recalQuals[k]);\n                        }\n                        System.out.println();\n                    }\n                }        */\n                // get bases of candidate haplotypes that overlap with reads\n                final int trailingBases = 3;\n\n                long readStart = read.getUnclippedStart();\n                long readEnd = read.getUnclippedEnd();\n\n                int numStartSoftClippedBases, numEndSoftClippedBases;\n\n                // see if we want to use soft clipped bases. Aligners may soft clip all bases at insertions because they don't match,\n                // but they're actually consistent with the insertion!\n                // Rule: if a read starts in interval [eventStart-eventLength,eventStart+1] and we are at an insertion, we'll use all soft clipped bases at the beginning.\n                // Conversely, if a read ends at [eventStart,eventStart+eventLength] we'll use all soft clipped bases in the end of the read.\n                long eventStartPos = ref.getLocus().getStart();\n\n                // compute total number of clipped bases (soft or hard clipped)\n                numStartSoftClippedBases = read.getAlignmentStart()- read.getUnclippedStart();\n                numEndSoftClippedBases = read.getUnclippedEnd()- read.getAlignmentEnd();\n\n                // check for hard clips (never consider these bases):\n    /*            Cigar c = read.getCigar();\n                CigarElement first = c.getCigarElement(0);\n                CigarElement last = c.getCigarElement(c.numCigarElements()-1);\n                int numStartHardClippedBases = 0, numEndHardClippedBases = 0;\n\n                if (first.getOperator() == CigarOperator.H) {\n                    numStartHardClippedBases = first.getLength();\n                }\n\n                if (last.getOperator() == CigarOperator.H) {\n                    numEndHardClippedBases = last.getLength();\n                }\n\n                // correct for hard clips\n                numStartSoftClippedBases -= numStartHardClippedBases;\n                numEndSoftClippedBases -= numEndHardClippedBases;\n                readStart += numStartHardClippedBases;\n                readEnd -= numEndHardClippedBases;\n      */\n                // remove soft clips if necessary\n                if ((read.getAlignmentStart()>=eventStartPos-eventLength && read.getAlignmentStart() <= eventStartPos+1) ||\n                        (read.getAlignmentEnd() >= eventStartPos && read.getAlignmentEnd() <= eventStartPos + eventLength)) {\n                    numStartSoftClippedBases = 0;\n                    numEndSoftClippedBases = 0;\n                }\n\n\n\n                byte[] unclippedReadBases, unclippedReadQuals;\n\n                int numStartClippedBases = numStartSoftClippedBases;\n                int numEndClippedBases = numEndSoftClippedBases;\n                unclippedReadBases = read.getReadBases();\n                unclippedReadQuals = read.getBaseQualities();\n\n                // Do a stricter base clipping than provided by CIGAR string, since this one may be too conservative,\n                // and may leave a string of Q2 bases still hanging off the reads.\n                for (int i=numStartSoftClippedBases; i < unclippedReadBases.length; i++) {\n                    if (unclippedReadQuals[i] < BASE_QUAL_THRESHOLD)\n                        numStartClippedBases++;\n                    else\n                        break;\n\n                }\n                for (int i=unclippedReadBases.length-numEndSoftClippedBases-1; i >= 0; i-- ){\n                    if (unclippedReadQuals[i] < BASE_QUAL_THRESHOLD)\n                        numEndClippedBases++;\n                    else\n                        break;\n                }\n\n                int extraOffset = Math.abs(eventLength);\n\n                long start = Math.max(readStart + numStartClippedBases - trailingBases - ReadUtils.getFirstInsertionOffset(read)-extraOffset, 0);\n                long stop =  readEnd -numEndClippedBases  + trailingBases + ReadUtils.getLastInsertionOffset(read)+extraOffset;\n\n                // Variables start and stop are coordinates (inclusive) where we want to get the haplotype from.\n                int readLength = read.getReadLength()-numStartSoftClippedBases-numEndSoftClippedBases;\n                // check if start of read will be before start of reference context\n                if (start < ref.getWindow().getStart())// read starts before haplotype: read will have to be cut\n                    start = ref.getWindow().getStart();\n\n                // check also if end of read will go beyond reference context\n                if (stop > ref.getWindow().getStop())\n                    stop = ref.getWindow().getStop();\n\n                // if there's an insertion in the read, the read stop position will be less than start + read legnth,\n                // but we want to compute likelihoods in the whole region that a read might overlap\n                if (stop <= start + readLength) {\n                    stop = start + readLength-1;\n                }\n\n                // ok, we now figured out total number of clipped bases on both ends.\n                // Figure out where we want to place the haplotype to score read against\n                if (DEBUG)\n                    System.out.format(\"numStartClippedBases: %d numEndClippedBases: %d WinStart:%d WinStop:%d start: %d stop: %d readLength: %d\\n\",\n                            numStartClippedBases, numEndClippedBases, ref.getWindow().getStart(), ref.getWindow().getStop(), start, stop, read.getReadLength());\n\n\n\n                LinkedHashMap<Allele,Double> readEl = new LinkedHashMap<Allele,Double>();\n\n                if (numStartClippedBases + numEndClippedBases >= unclippedReadBases.length) {\n                    if (DEBUG)\n                        System.out.println(\"BAD READ!!\");\n\n                    int j=0;\n                    for (Allele a: haplotypeMap.keySet()) {\n                        readEl.put(a,0.0);\n                        readLikelihoods[readIdx][j++] = 0.0;\n                    }\n\n                }\n                else {\n                    byte[] readBases = Arrays.copyOfRange(unclippedReadBases,numStartClippedBases,\n                            unclippedReadBases.length-numEndClippedBases);\n\n                    byte[] readQuals = Arrays.copyOfRange(unclippedReadQuals,numStartClippedBases,\n                            unclippedReadBases.length-numEndClippedBases);\n\n                    double[] recalCDP = null;\n                    if (getGapPenaltiesFromFile) {\n                        recalCDP = Arrays.copyOfRange(recalQuals,numStartClippedBases,\n                                unclippedReadBases.length-numEndClippedBases);\n\n                    }\n\n                    if (DEBUG) {\n                        System.out.println(\"Read bases:\");\n                        System.out.println(new String(readBases));\n                    }\n\n                    int j=0;\n                    for (Allele a: haplotypeMap.keySet()) {\n\n\n                        Haplotype haplotype = haplotypeMap.get(a);\n                        if (stop > haplotype.getStopPosition())\n                            stop = haplotype.getStopPosition();\n\n                        if (start < haplotype.getStartPosition())\n                            start = haplotype.getStartPosition();\n\n                        // cut haplotype bases\n                        long indStart = start - haplotype.getStartPosition();\n                        long indStop =  stop - haplotype.getStartPosition();\n\n                        byte[] haplotypeBases = Arrays.copyOfRange(haplotype.getBasesAsBytes(),\n                                (int)indStart, (int)indStop);\n\n                        if (DEBUG) {\n                            System.out.println(\"Haplotype to test:\");\n                            System.out.println(new String(haplotypeBases));\n                        }\n\n                        Double readLikelihood = 0.0;\n                        if (useAffineGapModel) {\n\n                            double[] currentContextGOP = null;\n                            double[] currentContextGCP = null;\n\n                            if (doContextDependentPenalties) {\n\n                               if (getGapPenaltiesFromFile) {\n                                   readLikelihood = computeReadLikelihoodGivenHaplotypeAffineGaps(haplotypeBases, readBases, readQuals, recalCDP, null);\n\n                               }  else {\n                                   currentContextGOP = Arrays.copyOfRange(gapOpenProbabilityMap.get(a), (int)indStart, (int)indStop);\n                                   currentContextGCP = Arrays.copyOfRange(gapContProbabilityMap.get(a), (int)indStart, (int)indStop);\n                                   readLikelihood = computeReadLikelihoodGivenHaplotypeAffineGaps(haplotypeBases, readBases, readQuals, currentContextGOP, currentContextGCP);\n                               }\n                            }\n\n                        }\n                        else\n                            readLikelihood = computeReadLikelihoodGivenHaplotype(haplotypeBases, readBases, readQuals);\n\n                        readEl.put(a,readLikelihood);\n                        readLikelihoods[readIdx][j++] = readLikelihood;\n                    }\n                }\n                indelLikelihoodMap.put(p,readEl);\n            }\n            readIdx++;\n        }\n\n        if (DEBUG) {\n            System.out.println(\"\\nLikelihood summary\");\n            for (readIdx=0; readIdx < pileup.getReads().size(); readIdx++) {\n                System.out.format(\"Read Index: %d \",readIdx);\n                for (int i=0; i < readLikelihoods[readIdx].length; i++)\n                    System.out.format(\"L%d: %f \",i,readLikelihoods[readIdx][i]);\n                System.out.println();\n            }\n\n        }\n        for (int i=0; i < numHaplotypes; i++) {\n            for (int j=i; j < numHaplotypes; j++){\n                // combine likelihoods of haplotypeLikelihoods[i], haplotypeLikelihoods[j]\n                // L(Hi, Hj) = sum_reads ( Pr(R|Hi)/2 + Pr(R|Hj)/2)\n                //readLikelihoods[k][j] has log10(Pr(R_k) | H[j] )\n                double[] readLikelihood = new double[2]; // diploid sample\n                for (readIdx=0; readIdx < pileup.getReads().size(); readIdx++) {\n\n                    // Compute log10(10^x1/2 + 10^x2/2) = log10(10^x1+10^x2)-log10(2)\n                    // First term is approximated by Jacobian log with table lookup.\n                    if (Double.isInfinite(readLikelihoods[readIdx][i]) && Double.isInfinite(readLikelihoods[readIdx][j]))\n                        continue;\n                    haplotypeLikehoodMatrix[i][j] += ( MathUtils.softMax(readLikelihoods[readIdx][i],\n                            readLikelihoods[readIdx][j]) + LOG_ONE_HALF);\n\n                }\n\n\n            }\n        }\n\n        return getHaplotypeLikelihoods(haplotypeLikehoodMatrix);\n\n    }","id":72082,"modified_method":"public synchronized double[] computeReadHaplotypeLikelihoods(ReadBackedPileup pileup, LinkedHashMap<Allele,Haplotype> haplotypeMap,\n                                                                   ReferenceContext ref, int eventLength,\n                                                                   HashMap<PileupElement, LinkedHashMap<Allele,Double>> indelLikelihoodMap){\n\n        int numHaplotypes = haplotypeMap.size();\n        double[][] haplotypeLikehoodMatrix = new double[numHaplotypes][numHaplotypes];\n        double readLikelihoods[][] = new double[pileup.getReads().size()][numHaplotypes];\n        int readIdx=0;\n\n        LinkedHashMap<Allele,double[]> gapOpenProbabilityMap = new LinkedHashMap<Allele,double[]>();\n        LinkedHashMap<Allele,double[]> gapContProbabilityMap = new LinkedHashMap<Allele,double[]>();\n\n        if (DEBUG) {\n            System.out.println(\"Reference bases:\");\n            System.out.println(new String(ref.getBases()));\n        }\n\n        if (doContextDependentPenalties && !getGapPenaltiesFromFile)   {\n            // will context dependent probabilities based on homopolymer run. Probabilities are filled based on total complete haplotypes.\n\n\n            for (Allele a: haplotypeMap.keySet()) {\n                Haplotype haplotype = haplotypeMap.get(a);\n                byte[] haplotypeBases = haplotype.getBasesAsBytes();\n                double[] contextLogGapOpenProbabilities = new double[haplotypeBases.length];\n                double[] contextLogGapContinuationProbabilities = new double[haplotypeBases.length];\n\n                // get homopolymer length profile for current haplotype\n                int[] hrunProfile = new int[haplotypeBases.length];\n                getContextHomopolymerLength(haplotypeBases,hrunProfile);\n                if (DEBUG) {\n                    System.out.println(\"Haplotype bases:\");\n                    System.out.println(new String(haplotypeBases));\n                    for (int i=0; i < hrunProfile.length; i++)\n                        System.out.format(\"%d\",hrunProfile[i]);\n                    System.out.println();\n                }\n                fillGapProbabilities(hrunProfile, contextLogGapOpenProbabilities, contextLogGapContinuationProbabilities);\n\n                gapOpenProbabilityMap.put(a,contextLogGapOpenProbabilities);\n                gapContProbabilityMap.put(a,contextLogGapContinuationProbabilities);\n\n            }\n        }\n        for (PileupElement p: pileup) {\n\n            // check if we've already computed likelihoods for this pileup element (i.e. for this read at this location)\n            if (indelLikelihoodMap.containsKey(p)) {\n                HashMap<Allele,Double> el =  indelLikelihoodMap.get(p);\n                int j=0;\n                for (Allele a: haplotypeMap.keySet()) {\n                    readLikelihoods[readIdx][j++] = el.get(a);\n                }\n            }\n            else {\n                //System.out.format(\"%d %s\\n\",p.getRead().getAlignmentStart(), p.getRead().getClass().getName());\n                GATKSAMRecord read = ReadUtils.hardClipAdaptorSequence(p.getRead());\n                if (read == null)\n                    continue;\n\n                if(ReadUtils.is454Read(read) && !getGapPenaltiesFromFile) {\n                    continue;\n                }\n\n                double[] recalQuals = null;\n\n /*\n                if (getGapPenaltiesFromFile) {\n                    RecalDataManager.parseSAMRecord( read, RAC );\n\n\n                    recalQuals = new double[read.getReadLength()];\n\n                    //compute all covariate values for this read\n                    final Comparable[][] covariateValues_offset_x_covar =\n                            RecalDataManager.computeCovariates((GATKSAMRecord) read, requestedCovariates);\n                    // For each base in the read\n                    for( int offset = 0; offset < read.getReadLength(); offset++ ) {\n\n                        final Object[] fullCovariateKey = covariateValues_offset_x_covar[offset];\n\n                        Byte qualityScore = (Byte) qualityScoreByFullCovariateKey.get(fullCovariateKey);\n                        if(qualityScore == null)\n                        {\n                            qualityScore = performSequentialQualityCalculation( fullCovariateKey );\n                            qualityScoreByFullCovariateKey.put(qualityScore, fullCovariateKey);\n                        }\n\n                        recalQuals[offset] = -((double)qualityScore)/10.0;\n                    }\n\n                    // for each read/haplotype combination, compute likelihoods, ie -10*log10(Pr(R | Hi))\n                    // = sum_j(-10*log10(Pr(R_j | Hi) since reads are assumed to be independent\n                    if (DEBUG)  {\n                        System.out.format(\"\\n\\nStarting read:%s S:%d US:%d E:%d UE:%d C:%s\\n\",read.getReadName(),\n                                read.getAlignmentStart(),\n                                read.getUnclippedStart(), read.getAlignmentEnd(), read.getUnclippedEnd(),\n                                read.getCigarString());\n\n                        byte[] bases = read.getReadBases();\n                        for (int k = 0; k < recalQuals.length; k++) {\n                            System.out.format(\"%c\",bases[k]);\n                        }\n                        System.out.println();\n\n                        for (int k = 0; k < recalQuals.length; k++) {\n                            System.out.format(\"%.0f \",recalQuals[k]);\n                        }\n                        System.out.println();\n                    }\n                }        */\n                // get bases of candidate haplotypes that overlap with reads\n                final int trailingBases = 3;\n\n                long readStart = read.getUnclippedStart();\n                long readEnd = read.getUnclippedEnd();\n\n                int numStartSoftClippedBases, numEndSoftClippedBases;\n\n                // see if we want to use soft clipped bases. Aligners may soft clip all bases at insertions because they don't match,\n                // but they're actually consistent with the insertion!\n                // Rule: if a read starts in interval [eventStart-eventLength,eventStart+1] and we are at an insertion, we'll use all soft clipped bases at the beginning.\n                // Conversely, if a read ends at [eventStart,eventStart+eventLength] we'll use all soft clipped bases in the end of the read.\n                long eventStartPos = ref.getLocus().getStart();\n\n                // compute total number of clipped bases (soft or hard clipped)\n                numStartSoftClippedBases = read.getAlignmentStart()- read.getUnclippedStart();\n                numEndSoftClippedBases = read.getUnclippedEnd()- read.getAlignmentEnd();\n\n                // check for hard clips (never consider these bases):\n    /*            Cigar c = read.getCigar();\n                CigarElement first = c.getCigarElement(0);\n                CigarElement last = c.getCigarElement(c.numCigarElements()-1);\n                int numStartHardClippedBases = 0, numEndHardClippedBases = 0;\n\n                if (first.getOperator() == CigarOperator.H) {\n                    numStartHardClippedBases = first.getLength();\n                }\n\n                if (last.getOperator() == CigarOperator.H) {\n                    numEndHardClippedBases = last.getLength();\n                }\n\n                // correct for hard clips\n                numStartSoftClippedBases -= numStartHardClippedBases;\n                numEndSoftClippedBases -= numEndHardClippedBases;\n                readStart += numStartHardClippedBases;\n                readEnd -= numEndHardClippedBases;\n      */\n                // remove soft clips if necessary\n                if ((read.getAlignmentStart()>=eventStartPos-eventLength && read.getAlignmentStart() <= eventStartPos+1) ||\n                        (read.getAlignmentEnd() >= eventStartPos && read.getAlignmentEnd() <= eventStartPos + eventLength)) {\n                    numStartSoftClippedBases = 0;\n                    numEndSoftClippedBases = 0;\n                }\n\n\n\n                byte[] unclippedReadBases, unclippedReadQuals;\n\n                int numStartClippedBases = numStartSoftClippedBases;\n                int numEndClippedBases = numEndSoftClippedBases;\n                unclippedReadBases = read.getReadBases();\n                unclippedReadQuals = read.getBaseQualities();\n\n                // Do a stricter base clipping than provided by CIGAR string, since this one may be too conservative,\n                // and may leave a string of Q2 bases still hanging off the reads.\n                for (int i=numStartSoftClippedBases; i < unclippedReadBases.length; i++) {\n                    if (unclippedReadQuals[i] < BASE_QUAL_THRESHOLD)\n                        numStartClippedBases++;\n                    else\n                        break;\n\n                }\n                for (int i=unclippedReadBases.length-numEndSoftClippedBases-1; i >= 0; i-- ){\n                    if (unclippedReadQuals[i] < BASE_QUAL_THRESHOLD)\n                        numEndClippedBases++;\n                    else\n                        break;\n                }\n\n                int extraOffset = Math.abs(eventLength);\n\n                long start = Math.max(readStart + numStartClippedBases - trailingBases - ReadUtils.getFirstInsertionOffset(read)-extraOffset, 0);\n                long stop =  readEnd -numEndClippedBases  + trailingBases + ReadUtils.getLastInsertionOffset(read)+extraOffset;\n\n                // Variables start and stop are coordinates (inclusive) where we want to get the haplotype from.\n                int readLength = read.getReadLength()-numStartSoftClippedBases-numEndSoftClippedBases;\n                // check if start of read will be before start of reference context\n                if (start < ref.getWindow().getStart())// read starts before haplotype: read will have to be cut\n                    start = ref.getWindow().getStart();\n\n                // check also if end of read will go beyond reference context\n                if (stop > ref.getWindow().getStop())\n                    stop = ref.getWindow().getStop();\n\n                // if there's an insertion in the read, the read stop position will be less than start + read legnth,\n                // but we want to compute likelihoods in the whole region that a read might overlap\n                if (stop <= start + readLength) {\n                    stop = start + readLength-1;\n                }\n\n                // ok, we now figured out total number of clipped bases on both ends.\n                // Figure out where we want to place the haplotype to score read against\n                if (DEBUG)\n                    System.out.format(\"numStartClippedBases: %d numEndClippedBases: %d WinStart:%d WinStop:%d start: %d stop: %d readLength: %d\\n\",\n                            numStartClippedBases, numEndClippedBases, ref.getWindow().getStart(), ref.getWindow().getStop(), start, stop, read.getReadLength());\n\n\n\n                LinkedHashMap<Allele,Double> readEl = new LinkedHashMap<Allele,Double>();\n\n                if (numStartClippedBases + numEndClippedBases >= unclippedReadBases.length) {\n                    if (DEBUG)\n                        System.out.println(\"BAD READ!!\");\n\n                    int j=0;\n                    for (Allele a: haplotypeMap.keySet()) {\n                        readEl.put(a,0.0);\n                        readLikelihoods[readIdx][j++] = 0.0;\n                    }\n\n                }\n                else {\n                    byte[] readBases = Arrays.copyOfRange(unclippedReadBases,numStartClippedBases,\n                            unclippedReadBases.length-numEndClippedBases);\n\n                    byte[] readQuals = Arrays.copyOfRange(unclippedReadQuals,numStartClippedBases,\n                            unclippedReadBases.length-numEndClippedBases);\n\n                    double[] recalCDP = null;\n                    if (getGapPenaltiesFromFile) {\n                        recalCDP = Arrays.copyOfRange(recalQuals,numStartClippedBases,\n                                unclippedReadBases.length-numEndClippedBases);\n\n                    }\n\n                    if (DEBUG) {\n                        System.out.println(\"Read bases:\");\n                        System.out.println(new String(readBases));\n                    }\n\n                    int j=0;\n                    for (Allele a: haplotypeMap.keySet()) {\n\n\n                        Haplotype haplotype = haplotypeMap.get(a);\n                        if (stop > haplotype.getStopPosition())\n                            stop = haplotype.getStopPosition();\n\n                        if (start < haplotype.getStartPosition())\n                            start = haplotype.getStartPosition();\n\n                        // cut haplotype bases\n                        long indStart = start - haplotype.getStartPosition();\n                        long indStop =  stop - haplotype.getStartPosition();\n\n                        byte[] haplotypeBases = Arrays.copyOfRange(haplotype.getBasesAsBytes(),\n                                (int)indStart, (int)indStop);\n\n                        if (DEBUG) {\n                            System.out.println(\"Haplotype to test:\");\n                            System.out.println(new String(haplotypeBases));\n                        }\n\n                        Double readLikelihood = 0.0;\n                        if (useAffineGapModel) {\n\n                            double[] currentContextGOP = null;\n                            double[] currentContextGCP = null;\n\n                            if (doContextDependentPenalties) {\n\n                               if (getGapPenaltiesFromFile) {\n                                   readLikelihood = computeReadLikelihoodGivenHaplotypeAffineGaps(haplotypeBases, readBases, readQuals, recalCDP, null);\n\n                               }  else {\n                                   currentContextGOP = Arrays.copyOfRange(gapOpenProbabilityMap.get(a), (int)indStart, (int)indStop);\n                                   currentContextGCP = Arrays.copyOfRange(gapContProbabilityMap.get(a), (int)indStart, (int)indStop);\n                                   readLikelihood = computeReadLikelihoodGivenHaplotypeAffineGaps(haplotypeBases, readBases, readQuals, currentContextGOP, currentContextGCP);\n                               }\n                            }\n\n                        }\n                        else\n                            readLikelihood = computeReadLikelihoodGivenHaplotype(haplotypeBases, readBases, readQuals);\n\n                        readEl.put(a,readLikelihood);\n                        readLikelihoods[readIdx][j++] = readLikelihood;\n                    }\n                }\n                indelLikelihoodMap.put(p,readEl);\n            }\n            readIdx++;\n        }\n\n        if (DEBUG) {\n            System.out.println(\"\\nLikelihood summary\");\n            for (readIdx=0; readIdx < pileup.getReads().size(); readIdx++) {\n                System.out.format(\"Read Index: %d \",readIdx);\n                for (int i=0; i < readLikelihoods[readIdx].length; i++)\n                    System.out.format(\"L%d: %f \",i,readLikelihoods[readIdx][i]);\n                System.out.println();\n            }\n\n        }\n        for (int i=0; i < numHaplotypes; i++) {\n            for (int j=i; j < numHaplotypes; j++){\n                // combine likelihoods of haplotypeLikelihoods[i], haplotypeLikelihoods[j]\n                // L(Hi, Hj) = sum_reads ( Pr(R|Hi)/2 + Pr(R|Hj)/2)\n                //readLikelihoods[k][j] has log10(Pr(R_k) | H[j] )\n                 for (readIdx=0; readIdx < pileup.getReads().size(); readIdx++) {\n\n                    // Compute log10(10^x1/2 + 10^x2/2) = log10(10^x1+10^x2)-log10(2)\n                    // First term is approximated by Jacobian log with table lookup.\n                    if (Double.isInfinite(readLikelihoods[readIdx][i]) && Double.isInfinite(readLikelihoods[readIdx][j]))\n                        continue;\n                    haplotypeLikehoodMatrix[i][j] += ( MathUtils.softMax(readLikelihoods[readIdx][i],\n                            readLikelihoods[readIdx][j]) + LOG_ONE_HALF);\n\n                }\n\n\n            }\n        }\n\n        return getHaplotypeLikelihoods(haplotypeLikehoodMatrix);\n\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Allele getLikelihoods(RefMetaDataTracker tracker,\n                                 ReferenceContext ref,\n                                 Map<String, AlignmentContext> contexts,\n                                 AlignmentContextUtils.ReadOrientation contextType,\n                                 GenotypePriors priors,\n                                 Map<String, BiallelicGenotypeLikelihoods> GLs,\n                                 Allele alternateAlleleToUse,\n                                 boolean useBAQedPileup) {\n\n        if ( !(priors instanceof DiploidSNPGenotypePriors) )\n            throw new StingException(\"Only diploid-based SNP priors are supported in the SNP GL model\");\n\n        byte refBase = ref.getBase();\n        Allele refAllele = Allele.create(refBase, true);\n\n        // find the alternate allele with the largest sum of quality scores\n        if ( alternateAlleleToUse != null ) {\n            bestAlternateAllele = alternateAlleleToUse.getBases()[0];\n        } else if ( useAlleleFromVCF ) {\n            VariantContext vc = getSNPVCFromAllelesRod(tracker, ref, true, logger);\n\n            // ignore places where we don't have a variant\n            if ( vc == null )\n                return null;\n\n            if ( !vc.isBiallelic() ) {\n                // for multi-allelic sites go back to the reads and find the most likely alternate allele\n                initializeBestAlternateAllele(refBase, contexts, useBAQedPileup);\n            } else {\n                bestAlternateAllele = vc.getAlternateAllele(0).getBases()[0];\n            }\n        } else {\n            initializeBestAlternateAllele(refBase, contexts, useBAQedPileup);\n        }\n\n        // if there are no non-ref bases...\n        if ( bestAlternateAllele == null ) {\n            // if we only want variants, then we don't need to calculate genotype likelihoods\n            if ( UAC.OutputMode == UnifiedGenotyperEngine.OUTPUT_MODE.EMIT_VARIANTS_ONLY )\n                return refAllele;\n\n            // otherwise, choose any alternate allele (it doesn't really matter)\n            bestAlternateAllele = (byte)(refBase != 'A' ? 'A' : 'C');\n        }\n\n        Allele altAllele = Allele.create(bestAlternateAllele, false);\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            ReadBackedPileup pileup = AlignmentContextUtils.stratify(sample.getValue(), contextType).getBasePileup();\n            if( useBAQedPileup ) { pileup = createBAQedPileup( pileup ); }\n\n            // create the GenotypeLikelihoods object\n            DiploidSNPGenotypeLikelihoods GL = new DiploidSNPGenotypeLikelihoods((DiploidSNPGenotypePriors)priors, UAC.PCR_error);\n            int nGoodBases = GL.add(pileup, true, true, UAC.MIN_BASE_QUALTY_SCORE);\n            if ( nGoodBases == 0 )\n                continue;\n\n            double[] likelihoods = GL.getLikelihoods();\n\n            DiploidGenotype refGenotype = DiploidGenotype.createHomGenotype(refBase);\n            DiploidGenotype hetGenotype = DiploidGenotype.createDiploidGenotype(refBase, bestAlternateAllele);\n            DiploidGenotype homGenotype = DiploidGenotype.createHomGenotype(bestAlternateAllele);\n            GLs.put(sample.getKey(), new BiallelicGenotypeLikelihoods(sample.getKey(),\n                    refAllele,\n                    altAllele,\n                    likelihoods[refGenotype.ordinal()],\n                    likelihoods[hetGenotype.ordinal()],\n                    likelihoods[homGenotype.ordinal()],\n                    getFilteredDepth(pileup)));\n        }\n\n        return refAllele;\n    }","id":72083,"modified_method":"public Allele getLikelihoods(RefMetaDataTracker tracker,\n                                 ReferenceContext ref,\n                                 Map<String, AlignmentContext> contexts,\n                                 AlignmentContextUtils.ReadOrientation contextType,\n                                 GenotypePriors priors,\n                                 Map<String, MultiallelicGenotypeLikelihoods> GLs,\n                                 Allele alternateAlleleToUse,\n                                 boolean useBAQedPileup) {\n\n        if ( !(priors instanceof DiploidSNPGenotypePriors) )\n            throw new StingException(\"Only diploid-based SNP priors are supported in the SNP GL model\");\n\n        byte refBase = ref.getBase();\n        Allele refAllele = Allele.create(refBase, true);\n\n        // find the alternate allele with the largest sum of quality scores\n        if ( alternateAlleleToUse != null ) {\n            bestAlternateAllele = alternateAlleleToUse.getBases()[0];\n        } else if ( useAlleleFromVCF ) {\n            VariantContext vc = getSNPVCFromAllelesRod(tracker, ref, true, logger);\n\n            // ignore places where we don't have a variant\n            if ( vc == null )\n                return null;\n\n            if ( !vc.isBiallelic() ) {\n                // for multi-allelic sites go back to the reads and find the most likely alternate allele\n                initializeBestAlternateAllele(refBase, contexts, useBAQedPileup);\n            } else {\n                bestAlternateAllele = vc.getAlternateAllele(0).getBases()[0];\n            }\n        } else {\n            initializeBestAlternateAllele(refBase, contexts, useBAQedPileup);\n        }\n\n        // if there are no non-ref bases...\n        if ( bestAlternateAllele == null ) {\n            // if we only want variants, then we don't need to calculate genotype likelihoods\n            if ( UAC.OutputMode == UnifiedGenotyperEngine.OUTPUT_MODE.EMIT_VARIANTS_ONLY )\n                return refAllele;\n\n            // otherwise, choose any alternate allele (it doesn't really matter)\n            bestAlternateAllele = (byte)(refBase != 'A' ? 'A' : 'C');\n        }\n\n        Allele altAllele = Allele.create(bestAlternateAllele, false);\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            ReadBackedPileup pileup = AlignmentContextUtils.stratify(sample.getValue(), contextType).getBasePileup();\n            if( useBAQedPileup ) { pileup = createBAQedPileup( pileup ); }\n\n            // create the GenotypeLikelihoods object\n            DiploidSNPGenotypeLikelihoods GL = new DiploidSNPGenotypeLikelihoods((DiploidSNPGenotypePriors)priors, UAC.PCR_error);\n            int nGoodBases = GL.add(pileup, true, true, UAC.MIN_BASE_QUALTY_SCORE);\n            if ( nGoodBases == 0 )\n                continue;\n\n            double[] likelihoods = GL.getLikelihoods();\n\n            DiploidGenotype refGenotype = DiploidGenotype.createHomGenotype(refBase);\n            DiploidGenotype hetGenotype = DiploidGenotype.createDiploidGenotype(refBase, bestAlternateAllele);\n            DiploidGenotype homGenotype = DiploidGenotype.createHomGenotype(bestAlternateAllele);\n            ArrayList<Allele> aList = new ArrayList<Allele>();\n            aList.add(refAllele);\n            aList.add(altAllele);\n            double[] dlike = new double[]{likelihoods[refGenotype.ordinal()],likelihoods[hetGenotype.ordinal()],likelihoods[homGenotype.ordinal()]} ;\n            GLs.put(sample.getKey(), new MultiallelicGenotypeLikelihoods(sample.getKey(),\n                    aList,  dlike, getFilteredDepth(pileup)));\n        }\n\n        return refAllele;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean generateExtendedEvents() { return UAC.GLmodel != GenotypeLikelihoodsCalculationModel.Model.SNP; }","id":72084,"modified_method":"public boolean generateExtendedEvents() {\n        return (UAC.GLmodel != GenotypeLikelihoodsCalculationModel.Model.SNP && UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES);\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantContext createVariantContextFromLikelihoods(ReferenceContext refContext, Allele refAllele, Map<String, BiallelicGenotypeLikelihoods> GLs) {\n        // no-call everyone for now\n        List<Allele> noCall = new ArrayList<Allele>();\n        noCall.add(Allele.NO_CALL);\n\n        Set<Allele> alleles = new HashSet<Allele>();\n        alleles.add(refAllele);\n        boolean addedAltAllele = false;\n\n        HashMap<String, Genotype> genotypes = new HashMap<String, Genotype>();\n        for ( BiallelicGenotypeLikelihoods GL : GLs.values() ) {\n            if ( !addedAltAllele ) {\n                addedAltAllele = true;\n                alleles.add(GL.getAlleleA());\n                alleles.add(GL.getAlleleB());\n            }\n\n            HashMap<String, Object> attributes = new HashMap<String, Object>();\n            //GenotypeLikelihoods likelihoods = new GenotypeLikelihoods(GL.getLikelihoods());\n            GenotypeLikelihoods likelihoods = GenotypeLikelihoods.fromLog10Likelihoods(GL.getLikelihoods());\n            attributes.put(VCFConstants.DEPTH_KEY, GL.getDepth());\n            attributes.put(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, likelihoods);\n\n            genotypes.put(GL.getSample(), new Genotype(GL.getSample(), noCall, Genotype.NO_NEG_LOG_10PERROR, null, attributes, false));\n        }\n\n        GenomeLoc loc = refContext.getLocus();\n        int endLoc = calculateEndPos(alleles, refAllele, loc);\n\n        return new VariantContext(\"UG_call\",\n                loc.getContig(),\n                loc.getStart(),\n                endLoc,\n                alleles,\n                genotypes,\n                VariantContext.NO_NEG_LOG_10PERROR,\n                null,\n                null);\n    }","id":72085,"modified_method":"private VariantContext createVariantContextFromLikelihoods(ReferenceContext refContext, Allele refAllele, Map<String, MultiallelicGenotypeLikelihoods> GLs) {\n        // no-call everyone for now\n        List<Allele> noCall = new ArrayList<Allele>();\n        noCall.add(Allele.NO_CALL);\n\n        Set<Allele> alleles = new LinkedHashSet<Allele>();\n        alleles.add(refAllele);\n        boolean addedAltAlleles = false;\n\n        HashMap<String, Genotype> genotypes = new HashMap<String, Genotype>();\n        for ( MultiallelicGenotypeLikelihoods GL : GLs.values() ) {\n            if ( !addedAltAlleles ) {\n                addedAltAlleles = true;\n                // ordering important to maintain consistency\n                for (Allele a: GL.getAlleles()) {\n                    alleles.add(a);\n                }\n            }\n\n            HashMap<String, Object> attributes = new HashMap<String, Object>();\n            //GenotypeLikelihoods likelihoods = new GenotypeLikelihoods(GL.getLikelihoods());\n            GenotypeLikelihoods likelihoods = GenotypeLikelihoods.fromLog10Likelihoods(GL.getLikelihoods());\n            attributes.put(VCFConstants.DEPTH_KEY, GL.getDepth());\n            attributes.put(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, likelihoods);\n\n            genotypes.put(GL.getSample(), new Genotype(GL.getSample(), noCall, Genotype.NO_NEG_LOG_10PERROR, null, attributes, false));\n        }\n\n        GenomeLoc loc = refContext.getLocus();\n        int endLoc = calculateEndPos(alleles, refAllele, loc);\n\n        return new VariantContext(\"UG_call\",\n                loc.getContig(),\n                loc.getStart(),\n                endLoc,\n                alleles,\n                genotypes,\n                VariantContext.NO_NEG_LOG_10PERROR,\n                null,\n                null);\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute full calls at a given locus. Entry point for engine calls from the UnifiedGenotyper.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateLikelihoodsAndGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        if ( UAC.COVERAGE_AT_WHICH_TO_ABORT > 0 && rawContext.size() > UAC.COVERAGE_AT_WHICH_TO_ABORT )\n            return null;\n\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel( rawContext );\n        if( model == null ) {\n            return (UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ? generateEmptyContext(tracker, refContext, null, rawContext) : null);\n        }\n\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        if ( stratifiedContexts == null ) {\n            return (UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ? generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext) : null);\n        }\n        \n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, null, true, model);\n\n        if ( vc == null )\n            return null;\n\n        return calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc, model);\n    }","id":72086,"modified_method":"/**\n     * Compute full calls at a given locus. Entry point for engine calls from the UnifiedGenotyper.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateLikelihoodsAndGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        if ( UAC.COVERAGE_AT_WHICH_TO_ABORT > 0 && rawContext.size() > UAC.COVERAGE_AT_WHICH_TO_ABORT )\n            return null;\n\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel(tracker, refContext, rawContext );\n        if( model == null ) {\n            return (UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ? generateEmptyContext(tracker, refContext, null, rawContext) : null);\n        }\n\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        if ( stratifiedContexts == null ) {\n            return (UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ? generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext) : null);\n        }\n        \n        VariantContext vc = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, null, true, model);\n\n        if ( vc == null )\n            return null;\n\n        return calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc, model);\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute genotypes at a given locus. Entry point for engine calls from UGCallVariants.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @param vc         the GL-annotated variant context\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, VariantContext vc) {\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel( rawContext );\n        if( model == null ) {\n            return null;\n        }\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        return calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc, model);\n    }","id":72087,"modified_method":"/**\n     * Compute genotypes at a given locus. Entry point for engine calls from UGCallVariants.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @param vc         the GL-annotated variant context\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, VariantContext vc) {\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel(tracker, refContext, rawContext );\n        if( model == null ) {\n            return null;\n        }\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        return calculateGenotypes(tracker, refContext, rawContext, stratifiedContexts, vc, model);\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( afcm.get() == null ) {\n            log10AlleleFrequencyPosteriors.set(new double[N+1]);\n            afcm.set(getAlleleFrequencyCalculationObject(N, logger, verboseWriter, UAC));\n        }\n\n        // estimate our confidence in a reference call and return\n        if ( vc.getNSamples() == 0 )\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ?\n                    estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), false, 1.0) :\n                    generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext));\n\n        // 'zero' out the AFs (so that we don't have to worry if not all samples have reads at this position)\n        clearAFarray(log10AlleleFrequencyPosteriors.get());\n        afcm.get().getLog10PNonRef(tracker, refContext, vc.getGenotypes(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n\n        // find the most likely frequency\n        int bestAFguess = MathUtils.maxElementIndex(log10AlleleFrequencyPosteriors.get());\n\n        // calculate p(f>0)\n        double[] normalizedPosteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get());\n        double sum = 0.0;\n        for (int i = 1; i <= N; i++)\n            sum += normalizedPosteriors[i];\n        double PofF = Math.min(sum, 1.0); // deal with precision errors\n\n        double phredScaledConfidence;\n        if ( bestAFguess != 0 || UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(normalizedPosteriors[0]);\n            if ( Double.isInfinite(phredScaledConfidence) )\n                phredScaledConfidence = -10.0 * log10AlleleFrequencyPosteriors.get()[0];\n        } else {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PofF);\n            if ( Double.isInfinite(phredScaledConfidence) ) {\n                sum = 0.0;\n                for (int i = 1; i <= N; i++) {\n                    if ( log10AlleleFrequencyPosteriors.get()[i] == AlleleFrequencyCalculationModel.VALUE_NOT_CALCULATED )\n                        break;\n                    sum += log10AlleleFrequencyPosteriors.get()[i];\n                }\n                phredScaledConfidence = (MathUtils.compareDoubles(sum, 0.0) == 0 ? 0 : -10.0 * sum);\n            }\n        }\n\n        // return a null call if we don't pass the confidence cutoff or the most likely allele frequency is zero\n        if ( UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES && !passesEmitThreshold(phredScaledConfidence, bestAFguess) ) {\n            // technically, at this point our confidence in a reference call isn't accurately estimated\n            //  because it didn't take into account samples with no data, so let's get a better estimate\n            return estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), true, 1.0 - PofF);\n        }\n\n        // create the genotypes\n        Map<String, Genotype> genotypes = afcm.get().assignGenotypes(vc, log10AlleleFrequencyPosteriors.get(), bestAFguess);\n\n        // print out stats if we have a writer\n        if ( verboseWriter != null )\n            printVerboseData(refContext.getLocus().toString(), vc, PofF, phredScaledConfidence, normalizedPosteriors, model);\n\n        // *** note that calculating strand bias involves overwriting data structures, so we do that last\n        HashMap<String, Object> attributes = new HashMap<String, Object>();\n\n        // if the site was downsampled, record that fact\n        if ( rawContext.hasPileupBeenDownsampled() )\n            attributes.put(VCFConstants.DOWNSAMPLED_KEY, true);\n\n\n        if ( !UAC.NO_SLOD && bestAFguess != 0 ) {\n            final boolean DEBUG_SLOD = false;\n\n            // the overall lod\n            VariantContext vcOverall = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(tracker, refContext, vcOverall.getGenotypes(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //double overallLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double overallLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            if ( DEBUG_SLOD ) System.out.println(\"overallLog10PofF=\" + overallLog10PofF);\n\n            // the forward lod\n            VariantContext vcForward = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.FORWARD, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(tracker, refContext, vcForward.getGenotypes(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //double[] normalizedLog10Posteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get(), true);\n            double forwardLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double forwardLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            if ( DEBUG_SLOD ) System.out.println(\"forwardLog10PofNull=\" + forwardLog10PofNull + \", forwardLog10PofF=\" + forwardLog10PofF);\n\n            // the reverse lod\n            VariantContext vcReverse = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.REVERSE, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(tracker, refContext, vcReverse.getGenotypes(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //normalizedLog10Posteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get(), true);\n            double reverseLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double reverseLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            if ( DEBUG_SLOD ) System.out.println(\"reverseLog10PofNull=\" + reverseLog10PofNull + \", reverseLog10PofF=\" + reverseLog10PofF);\n\n            double forwardLod = forwardLog10PofF + reverseLog10PofNull - overallLog10PofF;\n            double reverseLod = reverseLog10PofF + forwardLog10PofNull - overallLog10PofF;\n            if ( DEBUG_SLOD ) System.out.println(\"forward lod=\" + forwardLod + \", reverse lod=\" + reverseLod);\n\n            // strand score is max bias between forward and reverse strands\n            double strandScore = Math.max(forwardLod, reverseLod);\n            // rescale by a factor of 10\n            strandScore *= 10.0;\n            //logger.debug(String.format(\"SLOD=%f\", strandScore));\n\n            attributes.put(\"SB\", strandScore);\n        }\n\n        GenomeLoc loc = refContext.getLocus();\n\n        int endLoc = calculateEndPos(vc.getAlleles(), vc.getReference(), loc);\n\n        Set<Allele> myAlleles = vc.getAlleles();\n        // strip out the alternate allele if it's a ref call\n        if ( bestAFguess == 0 && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.DISCOVERY ) {\n            myAlleles = new HashSet<Allele>(1);\n            myAlleles.add(vc.getReference());\n        }\n        VariantContext vcCall = new VariantContext(\"UG_call\", loc.getContig(), loc.getStart(), endLoc,\n                myAlleles, genotypes, phredScaledConfidence/10.0, passesCallThreshold(phredScaledConfidence) ? null : filter, attributes);\n\n        if ( annotationEngine != null ) {\n            // first off, we want to use the *unfiltered* and *unBAQed* context for the annotations\n            ReadBackedPileup pileup = null;\n            if (rawContext.hasExtendedEventPileup())\n                pileup = rawContext.getExtendedEventPileup();\n            else if (rawContext.hasBasePileup())\n                pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n\n            Collection<VariantContext> variantContexts = annotationEngine.annotateContext(tracker, refContext, stratifiedContexts, vcCall);\n            vcCall = variantContexts.iterator().next(); // we know the collection will always have exactly 1 element.\n        }\n\n        VariantCallContext call = new VariantCallContext(vcCall, confidentlyCalled(phredScaledConfidence, PofF));\n        call.setRefBase(refContext.getBase());\n        return call;\n    }","id":72088,"modified_method":"private VariantCallContext calculateGenotypes(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( afcm.get() == null ) {\n            log10AlleleFrequencyPosteriors.set(new double[N+1]);\n            afcm.set(getAlleleFrequencyCalculationObject(N, logger, verboseWriter, UAC));\n        }\n\n        // estimate our confidence in a reference call and return\n        if ( vc.getNSamples() == 0 )\n            return (UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES ?\n                    estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), false, 1.0) :\n                    generateEmptyContext(tracker, refContext, stratifiedContexts, rawContext));\n\n        // 'zero' out the AFs (so that we don't have to worry if not all samples have reads at this position)\n        clearAFarray(log10AlleleFrequencyPosteriors.get());\n        afcm.get().getLog10PNonRef(tracker, refContext, vc.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n\n        // find the most likely frequency\n        int bestAFguess = MathUtils.maxElementIndex(log10AlleleFrequencyPosteriors.get());\n\n        // calculate p(f>0)\n        double[] normalizedPosteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get());\n        double sum = 0.0;\n        for (int i = 1; i <= N; i++)\n            sum += normalizedPosteriors[i];\n        double PofF = Math.min(sum, 1.0); // deal with precision errors\n\n        double phredScaledConfidence;\n        if ( bestAFguess != 0 || UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(normalizedPosteriors[0]);\n            if ( Double.isInfinite(phredScaledConfidence) )\n                phredScaledConfidence = -10.0 * log10AlleleFrequencyPosteriors.get()[0];\n        } else {\n            phredScaledConfidence = QualityUtils.phredScaleErrorRate(PofF);\n            if ( Double.isInfinite(phredScaledConfidence) ) {\n                sum = 0.0;\n                for (int i = 1; i <= N; i++) {\n                    if ( log10AlleleFrequencyPosteriors.get()[i] == AlleleFrequencyCalculationModel.VALUE_NOT_CALCULATED )\n                        break;\n                    sum += log10AlleleFrequencyPosteriors.get()[i];\n                }\n                phredScaledConfidence = (MathUtils.compareDoubles(sum, 0.0) == 0 ? 0 : -10.0 * sum);\n            }\n        }\n\n        // return a null call if we don't pass the confidence cutoff or the most likely allele frequency is zero\n        if ( UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES && !passesEmitThreshold(phredScaledConfidence, bestAFguess) ) {\n            // technically, at this point our confidence in a reference call isn't accurately estimated\n            //  because it didn't take into account samples with no data, so let's get a better estimate\n            return estimateReferenceConfidence(vc, stratifiedContexts, getGenotypePriors(model).getHeterozygosity(), true, 1.0 - PofF);\n        }\n\n        // create the genotypes\n        Map<String, Genotype> genotypes = afcm.get().assignGenotypes(vc, log10AlleleFrequencyPosteriors.get(), bestAFguess);\n\n        // print out stats if we have a writer\n        if ( verboseWriter != null )\n            printVerboseData(refContext.getLocus().toString(), vc, PofF, phredScaledConfidence, normalizedPosteriors, model);\n\n        // *** note that calculating strand bias involves overwriting data structures, so we do that last\n        HashMap<String, Object> attributes = new HashMap<String, Object>();\n\n        // if the site was downsampled, record that fact\n        if ( rawContext.hasPileupBeenDownsampled() )\n            attributes.put(VCFConstants.DOWNSAMPLED_KEY, true);\n\n\n        if ( !UAC.NO_SLOD && bestAFguess != 0 ) {\n            final boolean DEBUG_SLOD = false;\n\n            // the overall lod\n            VariantContext vcOverall = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(tracker, refContext, vcOverall.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //double overallLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double overallLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            if ( DEBUG_SLOD ) System.out.println(\"overallLog10PofF=\" + overallLog10PofF);\n\n            // the forward lod\n            VariantContext vcForward = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.FORWARD, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(tracker, refContext, vcForward.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //double[] normalizedLog10Posteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get(), true);\n            double forwardLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double forwardLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            if ( DEBUG_SLOD ) System.out.println(\"forwardLog10PofNull=\" + forwardLog10PofNull + \", forwardLog10PofF=\" + forwardLog10PofF);\n\n            // the reverse lod\n            VariantContext vcReverse = calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.REVERSE, vc.getAlternateAllele(0), false, model);\n            clearAFarray(log10AlleleFrequencyPosteriors.get());\n            afcm.get().getLog10PNonRef(tracker, refContext, vcReverse.getGenotypes(), vc.getAlleles(), getAlleleFrequencyPriors(model), log10AlleleFrequencyPosteriors.get());\n            //normalizedLog10Posteriors = MathUtils.normalizeFromLog10(log10AlleleFrequencyPosteriors.get(), true);\n            double reverseLog10PofNull = log10AlleleFrequencyPosteriors.get()[0];\n            double reverseLog10PofF = MathUtils.log10sumLog10(log10AlleleFrequencyPosteriors.get(), 1);\n            if ( DEBUG_SLOD ) System.out.println(\"reverseLog10PofNull=\" + reverseLog10PofNull + \", reverseLog10PofF=\" + reverseLog10PofF);\n\n            double forwardLod = forwardLog10PofF + reverseLog10PofNull - overallLog10PofF;\n            double reverseLod = reverseLog10PofF + forwardLog10PofNull - overallLog10PofF;\n            if ( DEBUG_SLOD ) System.out.println(\"forward lod=\" + forwardLod + \", reverse lod=\" + reverseLod);\n\n            // strand score is max bias between forward and reverse strands\n            double strandScore = Math.max(forwardLod, reverseLod);\n            // rescale by a factor of 10\n            strandScore *= 10.0;\n            //logger.debug(String.format(\"SLOD=%f\", strandScore));\n\n            attributes.put(\"SB\", strandScore);\n        }\n\n        GenomeLoc loc = refContext.getLocus();\n\n        int endLoc = calculateEndPos(vc.getAlleles(), vc.getReference(), loc);\n\n        Set<Allele> myAlleles = vc.getAlleles();\n        // strip out the alternate allele if it's a ref call\n        if ( bestAFguess == 0 && UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.DISCOVERY ) {\n            myAlleles = new HashSet<Allele>(1);\n            myAlleles.add(vc.getReference());\n        }\n        VariantContext vcCall = new VariantContext(\"UG_call\", loc.getContig(), loc.getStart(), endLoc,\n                myAlleles, genotypes, phredScaledConfidence/10.0, passesCallThreshold(phredScaledConfidence) ? null : filter, attributes);\n\n        if ( annotationEngine != null ) {\n            // first off, we want to use the *unfiltered* and *unBAQed* context for the annotations\n            ReadBackedPileup pileup = null;\n            if (rawContext.hasExtendedEventPileup())\n                pileup = rawContext.getExtendedEventPileup();\n            else if (rawContext.hasBasePileup())\n                pileup = rawContext.getBasePileup();\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n\n            Collection<VariantContext> variantContexts = annotationEngine.annotateContext(tracker, refContext, stratifiedContexts, vcCall);\n            vcCall = variantContexts.iterator().next(); // we know the collection will always have exactly 1 element.\n        }\n\n        VariantCallContext call = new VariantCallContext(vcCall, confidentlyCalled(phredScaledConfidence, PofF));\n        call.setRefBase(refContext.getBase());\n        return call;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, Map<String, AlignmentContext> stratifiedContexts, AlignmentContextUtils.ReadOrientation type, Allele alternateAlleleToUse, boolean useBAQedPileup, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( glcm.get() == null ) {\n            glcm.set(getGenotypeLikelihoodsCalculationObject(logger, UAC));\n        }\n\n        Map<String, BiallelicGenotypeLikelihoods> GLs = new HashMap<String, BiallelicGenotypeLikelihoods>();\n\n        Allele refAllele = glcm.get().get(model).getLikelihoods(tracker, refContext, stratifiedContexts, type, getGenotypePriors(model), GLs, alternateAlleleToUse, useBAQedPileup && BAQEnabledOnCMDLine);\n\n        if ( refAllele != null )\n            return createVariantContextFromLikelihoods(refContext, refAllele, GLs);\n        else\n            return null;\n    }","id":72089,"modified_method":"private VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, Map<String, AlignmentContext> stratifiedContexts, AlignmentContextUtils.ReadOrientation type, Allele alternateAlleleToUse, boolean useBAQedPileup, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( glcm.get() == null ) {\n            glcm.set(getGenotypeLikelihoodsCalculationObject(logger, UAC));\n        }\n\n        Map<String, MultiallelicGenotypeLikelihoods> GLs = new HashMap<String, MultiallelicGenotypeLikelihoods>();\n\n        Allele refAllele = glcm.get().get(model).getLikelihoods(tracker, refContext, stratifiedContexts, type, getGenotypePriors(model), GLs, alternateAlleleToUse, useBAQedPileup && BAQEnabledOnCMDLine);\n\n        if ( refAllele != null )\n            return createVariantContextFromLikelihoods(refContext, refAllele, GLs);\n        else\n            return null;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute GLs at a given locus. Entry point for engine calls from UGCalcLikelihoods.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantContext object\n     */\n    public VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel( rawContext );\n        if( model == null )\n            return null;\n\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        if ( stratifiedContexts == null )\n            return null;\n\n        return calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, null, true, model);\n    }","id":72090,"modified_method":"/**\n     * Compute GLs at a given locus. Entry point for engine calls from UGCalcLikelihoods.\n     *\n     * @param tracker    the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantContext object\n     */\n    public VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        final GenotypeLikelihoodsCalculationModel.Model model = getCurrentGLModel( tracker, refContext, rawContext );\n        if( model == null )\n            return null;\n\n        Map<String, AlignmentContext> stratifiedContexts = getFilteredAndStratifiedContexts(UAC, refContext, rawContext, model);\n        if ( stratifiedContexts == null )\n            return null;\n\n        return calculateLikelihoods(tracker, refContext, stratifiedContexts, AlignmentContextUtils.ReadOrientation.COMPLETE, null, true, model);\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void computeAlleleFrequencyPriors(int N, final double[] priors, final GenotypeLikelihoodsCalculationModel.Model model) {\n        // calculate the allele frequency priors for 1-N\n        double sum = 0.0;\n        double heterozygosity;\n\n        if (model == GenotypeLikelihoodsCalculationModel.Model.INDEL)\n            heterozygosity = UAC.INDEL_HETEROZYGOSITY;\n        else\n            heterozygosity = UAC.heterozygosity;\n        \n        for (int i = 1; i <= N; i++) {\n            double value = heterozygosity / (double)i;\n            priors[i] = Math.log10(value);\n            sum += value;\n        }\n\n        // null frequency for AF=0 is (1 - sum(all other frequencies))\n        priors[0] = Math.log10(1.0 - sum);\n    }","id":72091,"modified_method":"private GenotypeLikelihoodsCalculationModel.Model getCurrentGLModel(final RefMetaDataTracker tracker, final ReferenceContext refContext,\n                                                                        final AlignmentContext rawContext ) {\n        if (rawContext.hasExtendedEventPileup() ) {\n            // todo - remove this code\n            if ((UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL) &&\n                   (UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) )\n                return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n        }\n        else {\n            // no extended event pileup\n            // if we're genotyping given alleles and we have a requested SNP at this position, do SNP\n            if (UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) {\n                VariantContext vcInput = SNPGenotypeLikelihoodsCalculationModel.getSNPVCFromAllelesRod(tracker, refContext, false, logger);\n                if (vcInput == null)\n                    return null;\n\n                if (vcInput.isSNP() &&  ( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.SNP))\n                    return GenotypeLikelihoodsCalculationModel.Model.SNP;\n                else if ((vcInput.isIndel() || vcInput.isMixed()) && (UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL))\n                    return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n            }   else {\n                // todo - this assumes SNP's take priority when BOTH is selected, should do a smarter way once extended events are removed\n                if( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.SNP)\n                    return GenotypeLikelihoodsCalculationModel.Model.SNP;\n                else if (UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL)\n                    return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n                }\n        }\n        return null;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Map<String, AlignmentContext> getFilteredAndStratifiedContexts(UnifiedArgumentCollection UAC, ReferenceContext refContext, AlignmentContext rawContext, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        Map<String, AlignmentContext> stratifiedContexts = null;\n\n        if ( model == GenotypeLikelihoodsCalculationModel.Model.INDEL ) {\n\n            ReadBackedExtendedEventPileup rawPileup = rawContext.getExtendedEventPileup();\n\n            // filter the context based on min mapping quality\n            ReadBackedExtendedEventPileup pileup = rawPileup.getMappingFilteredPileup(UAC.MIN_MAPPING_QUALTY_SCORE);\n\n            // don't call when there is no coverage\n            if ( pileup.size() == 0 && !(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) )\n                return null;\n\n            // stratify the AlignmentContext and cut by sample\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n\n        } else if ( model == GenotypeLikelihoodsCalculationModel.Model.SNP ) {\n\n            if ( !BaseUtils.isRegularBase( refContext.getBase() ) )\n                return null;\n\n            // stratify the AlignmentContext and cut by sample\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(rawContext.getBasePileup(), UAC.ASSUME_SINGLE_SAMPLE);\n\n            if( !(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) ) {\n                int numDeletions = 0;\n                for( final PileupElement p : rawContext.getBasePileup() ) {\n                    if( p.isDeletion() ) { numDeletions++; }\n                }\n                if( ((double) numDeletions) / ((double) rawContext.getBasePileup().size()) > UAC.MAX_DELETION_FRACTION ) {\n                    return null;\n                }\n            }\n        }\n\n        return stratifiedContexts;\n    }","id":72092,"modified_method":"private Map<String, AlignmentContext> getFilteredAndStratifiedContexts(UnifiedArgumentCollection UAC, ReferenceContext refContext, AlignmentContext rawContext, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        Map<String, AlignmentContext> stratifiedContexts = null;\n\n        if ( model == GenotypeLikelihoodsCalculationModel.Model.INDEL ) {\n\n            if (UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) {\n                // regular pileup in this case\n                ReadBackedPileup pileup = rawContext.getBasePileup() .getMappingFilteredPileup(UAC.MIN_MAPPING_QUALTY_SCORE);\n\n                // don't call when there is no coverage\n                if ( pileup.size() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                    return null;\n\n                // stratify the AlignmentContext and cut by sample\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n\n            } else {\n                // todo - tmp will get rid of extended events so this wont be needed\n                if (!rawContext.hasExtendedEventPileup())\n                    return null;\n                ReadBackedExtendedEventPileup rawPileup = rawContext.getExtendedEventPileup();\n\n                // filter the context based on min mapping quality\n                ReadBackedExtendedEventPileup pileup = rawPileup.getMappingFilteredPileup(UAC.MIN_MAPPING_QUALTY_SCORE);\n\n                // don't call when there is no coverage\n                if ( pileup.size() == 0 && UAC.OutputMode != OUTPUT_MODE.EMIT_ALL_SITES  )\n                    return null;\n\n                // stratify the AlignmentContext and cut by sample\n                stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(pileup, UAC.ASSUME_SINGLE_SAMPLE);\n            }\n        } else if ( model == GenotypeLikelihoodsCalculationModel.Model.SNP ) {\n\n            if ( !BaseUtils.isRegularBase( refContext.getBase() ) )\n                return null;\n\n            // stratify the AlignmentContext and cut by sample\n            stratifiedContexts = AlignmentContextUtils.splitContextBySampleName(rawContext.getBasePileup(), UAC.ASSUME_SINGLE_SAMPLE);\n\n            if( !(UAC.OutputMode == OUTPUT_MODE.EMIT_ALL_SITES && UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) ) {\n                int numDeletions = 0;\n                for( final PileupElement p : rawContext.getBasePileup() ) {\n                    if( p.isDeletion() ) { numDeletions++; }\n                }\n                if( ((double) numDeletions) / ((double) rawContext.getBasePileup().size()) > UAC.MAX_DELETION_FRACTION ) {\n                    return null;\n                }\n            }\n        }\n\n        return stratifiedContexts;\n    }","commit_id":"a8faacda4e57d4cfea2b6f6539a7f924c5d3fab1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Must be overridden by concrete subclasses\n     *\n     * @param tracker              rod data\n     * @param ref                  reference context\n     * @param contexts             stratified alignment contexts\n     * @param contextType          stratified context type\n     * @param priors               priors to use for GLs\n     * @param GLs                  hash of sample->GL to fill in\n     * @param alternateAlleleToUse the alternate allele to use, null if not set\n     * @param useBAQedPileup       should we use the BAQed pileup or the raw one?\n     * @return genotype likelihoods per sample for AA, AB, BB\n     */\n    public abstract Allele getLikelihoods(RefMetaDataTracker tracker,\n                                          ReferenceContext ref,\n                                          Map<String, AlignmentContext> contexts,\n                                          AlignmentContextUtils.ReadOrientation contextType,\n                                          GenotypePriors priors,\n                                          Map<String, MultiallelicGenotypeLikelihoods> GLs,\n                                          Allele alternateAlleleToUse,\n                                          boolean useBAQedPileup);","id":72093,"modified_method":"/**\n     * Must be overridden by concrete subclasses\n     *\n     * @param tracker              rod data\n     * @param ref                  reference context\n     * @param contexts             stratified alignment contexts\n     * @param contextType          stratified context type\n     * @param priors               priors to use for GLs\n     * @param alternateAlleleToUse the alternate allele to use, null if not set\n     * @param useBAQedPileup       should we use the BAQed pileup or the raw one?\n     * @return variant context where genotypes are no-called but with GLs\n     */\n    public abstract VariantContext getLikelihoods(RefMetaDataTracker tracker,\n                                                  ReferenceContext ref,\n                                                  Map<String, AlignmentContext> contexts,\n                                                  AlignmentContextUtils.ReadOrientation contextType,\n                                                  GenotypePriors priors,\n                                                  Allele alternateAlleleToUse,\n                                                  boolean useBAQedPileup);","commit_id":"e47a113c9f18bc75564091554517a297ff9e2ca1","url":"https://github.com/broadgsa/gatk"},{"original_method":"private ArrayList<Allele> computeConsensusAlleles(ReferenceContext ref,\n                                                      Map<String, AlignmentContext> contexts,\n                                                      AlignmentContextUtils.ReadOrientation contextType) {\n        Allele refAllele=null, altAllele=null;\n        GenomeLoc loc = ref.getLocus();\n        ArrayList<Allele> aList = new ArrayList<Allele>();\n\n        HashMap<String,Integer> consensusIndelStrings = new HashMap<String,Integer>();\n\n        int insCount = 0, delCount = 0;\n        // quick check of total number of indels in pileup\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            final ReadBackedExtendedEventPileup indelPileup = context.getExtendedEventPileup();\n            insCount += indelPileup.getNumberOfInsertions();\n            delCount += indelPileup.getNumberOfDeletions();\n        }\n\n        if (insCount < minIndelCountForGenotyping && delCount < minIndelCountForGenotyping)\n            return aList;\n        \n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            // todo -- warning, can be duplicating expensive partition here\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            final ReadBackedExtendedEventPileup indelPileup = context.getExtendedEventPileup();\n\n\n\n\n            for ( ExtendedEventPileupElement p : indelPileup.toExtendedIterable() ) {\n                //SAMRecord read = p.getRead();\n                 GATKSAMRecord read = ReadUtils.hardClipAdaptorSequence(p.getRead());\n                if (read == null)\n                    continue;     \n                if(ReadUtils.is454Read(read)) {\n                    continue;\n                }\n\n/*                if (DEBUG && p.isIndel()) {\n                    System.out.format(\"Read: %s, cigar: %s, aln start: %d, aln end: %d, p.len:%d, Type:%s, EventBases:%s\\n\",\n                            read.getReadName(),read.getCigar().toString(),read.getAlignmentStart(),read.getAlignmentEnd(),\n                            p.getEventLength(),p.getType().toString(), p.getEventBases());\n                }\n   */\n\n                String indelString = p.getEventBases();\n                if (p.isInsertion()) {\n                    boolean foundKey = false;\n                    if (read.getAlignmentEnd() == loc.getStart()) {\n                        // first corner condition: a read has an insertion at the end, and we're right at the insertion.\n                        // In this case, the read could have any of the inserted bases and we need to build a consensus\n                        for (String s : consensusIndelStrings.keySet()) {\n                            int cnt = consensusIndelStrings.get(s);\n                            if (s.startsWith(indelString)){\n                                // case 1: current insertion is prefix of indel in hash map\n                                consensusIndelStrings.put(s,cnt+1);\n                                foundKey = true;\n                                break;\n                            }\n                            else if (indelString.startsWith(s)) {\n                                // case 2: indel stored in hash table is prefix of current insertion\n                                // In this case, new bases are new key.\n                                consensusIndelStrings.remove(s);\n                                consensusIndelStrings.put(indelString,cnt+1);\n                                foundKey = true;\n                                break;\n                            }\n                        }\n                        if (!foundKey)\n                            // none of the above: event bases not supported by previous table, so add new key\n                            consensusIndelStrings.put(indelString,1);\n\n                    }\n                    else if (read.getAlignmentStart() == loc.getStart()+1) {\n                        // opposite corner condition: read will start at current locus with an insertion\n                        for (String s : consensusIndelStrings.keySet()) {\n                            int cnt = consensusIndelStrings.get(s);\n                            if (s.endsWith(indelString)){\n                                // case 1: current insertion is suffix of indel in hash map\n                                consensusIndelStrings.put(s,cnt+1);\n                                foundKey = true;\n                                break;\n                            }\n                            else if (indelString.endsWith(s)) {\n                                // case 2: indel stored in hash table is suffix of current insertion\n                                // In this case, new bases are new key.\n\n                                consensusIndelStrings.remove(s);\n                                consensusIndelStrings.put(indelString,cnt+1);\n                                foundKey = true;\n                                break;\n                            }\n                        }\n                        if (!foundKey)\n                            // none of the above: event bases not supported by previous table, so add new key\n                            consensusIndelStrings.put(indelString,1);\n\n                    }\n                    else {\n                        // normal case: insertion somewhere in the middle of a read: add count to hash map\n                        int cnt = consensusIndelStrings.containsKey(indelString)? consensusIndelStrings.get(indelString):0;\n                        consensusIndelStrings.put(indelString,cnt+1);\n                    }\n\n                }\n                else if (p.isDeletion()) {\n                    indelString = String.format(\"D%d\",p.getEventLength());\n                    int cnt = consensusIndelStrings.containsKey(indelString)? consensusIndelStrings.get(indelString):0;\n                    consensusIndelStrings.put(indelString,cnt+1);\n\n                }\n            }\n\n/*            if (DEBUG) {\n                int icount = indelPileup.getNumberOfInsertions();\n                int dcount = indelPileup.getNumberOfDeletions();\n                if (icount + dcount > 0)\n                {\n                    List<Pair<String,Integer>> eventStrings = indelPileup.getEventStringsWithCounts(ref.getBases());\n                    System.out.format(\"#ins: %d, #del:%d\\n\", insCount, delCount);\n\n                    for (int i=0 ; i < eventStrings.size() ; i++ ) {\n                        System.out.format(\"%s:%d,\",eventStrings.get(i).first,eventStrings.get(i).second);\n                        //                int k=0;\n                    }\n                    System.out.println();\n                }\n            }             */\n        }\n\n        int maxAlleleCnt = 0;\n        String bestAltAllele = \"\";\n        for (String s : consensusIndelStrings.keySet()) {\n            int curCnt = consensusIndelStrings.get(s);\n            if (curCnt > maxAlleleCnt) {\n                maxAlleleCnt = curCnt;\n                bestAltAllele = s;\n            }\n//            if (DEBUG)\n//                System.out.format(\"Key:%s, number: %d\\n\",s,consensusIndelStrings.get(s)  );\n        }         //gdebug-\n\n        if (maxAlleleCnt <  minIndelCountForGenotyping)\n            return aList;\n\n        if (bestAltAllele.startsWith(\"D\")) {\n            // get deletion length\n            int dLen = Integer.valueOf(bestAltAllele.substring(1));\n            // get ref bases of accurate deletion\n            int startIdxInReference = (int)(1+loc.getStart()-ref.getWindow().getStart());\n\n            //System.out.println(new String(ref.getBases()));\n            byte[] refBases = Arrays.copyOfRange(ref.getBases(),startIdxInReference,startIdxInReference+dLen);\n\n            if (Allele.acceptableAlleleBases(refBases)) {\n                refAllele = Allele.create(refBases,true);\n                altAllele = Allele.create(Allele.NULL_ALLELE_STRING, false);\n            }\n        }\n        else {\n            // insertion case\n            if (Allele.acceptableAlleleBases(bestAltAllele))  {\n                refAllele = Allele.create(Allele.NULL_ALLELE_STRING, true);\n                altAllele = Allele.create(bestAltAllele, false);\n            }\n        }\n        if (refAllele != null && altAllele != null) {\n            aList.add(0,refAllele);\n            aList.add(1,altAllele);\n        }\n        return aList;\n\n    }","id":72094,"modified_method":"private ArrayList<Allele> computeConsensusAlleles(ReferenceContext ref,\n                                                      Map<String, AlignmentContext> contexts,\n                                                      AlignmentContextUtils.ReadOrientation contextType) {\n        Allele refAllele=null, altAllele=null;\n        GenomeLoc loc = ref.getLocus();\n        ArrayList<Allele> aList = new ArrayList<Allele>();\n\n        HashMap<String,Integer> consensusIndelStrings = new HashMap<String,Integer>();\n\n        int insCount = 0, delCount = 0;\n        // quick check of total number of indels in pileup\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            final ReadBackedExtendedEventPileup indelPileup = context.getExtendedEventPileup();\n            insCount += indelPileup.getNumberOfInsertions();\n            delCount += indelPileup.getNumberOfDeletions();\n        }\n\n        if (insCount < minIndelCountForGenotyping && delCount < minIndelCountForGenotyping)\n            return aList;\n        \n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            // todo -- warning, can be duplicating expensive partition here\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            final ReadBackedExtendedEventPileup indelPileup = context.getExtendedEventPileup();\n\n\n\n\n            for ( ExtendedEventPileupElement p : indelPileup.toExtendedIterable() ) {\n                //SAMRecord read = p.getRead();\n                 GATKSAMRecord read = ReadUtils.hardClipAdaptorSequence(p.getRead());\n                if (read == null)\n                    continue;     \n                if(ReadUtils.is454Read(read)) {\n                    continue;\n                }\n\n/*                if (DEBUG && p.isIndel()) {\n                    System.out.format(\"Read: %s, cigar: %s, aln start: %d, aln end: %d, p.len:%d, Type:%s, EventBases:%s\\n\",\n                            read.getReadName(),read.getCigar().toString(),read.getAlignmentStart(),read.getAlignmentEnd(),\n                            p.getEventLength(),p.getType().toString(), p.getEventBases());\n                }\n   */\n\n                String indelString = p.getEventBases();\n                if (p.isInsertion()) {\n                    boolean foundKey = false;\n                    if (read.getAlignmentEnd() == loc.getStart()) {\n                        // first corner condition: a read has an insertion at the end, and we're right at the insertion.\n                        // In this case, the read could have any of the inserted bases and we need to build a consensus\n                        for (String s : consensusIndelStrings.keySet()) {\n                            int cnt = consensusIndelStrings.get(s);\n                            if (s.startsWith(indelString)){\n                                // case 1: current insertion is prefix of indel in hash map\n                                consensusIndelStrings.put(s,cnt+1);\n                                foundKey = true;\n                                break;\n                            }\n                            else if (indelString.startsWith(s)) {\n                                // case 2: indel stored in hash table is prefix of current insertion\n                                // In this case, new bases are new key.\n                                consensusIndelStrings.remove(s);\n                                consensusIndelStrings.put(indelString,cnt+1);\n                                foundKey = true;\n                                break;\n                            }\n                        }\n                        if (!foundKey)\n                            // none of the above: event bases not supported by previous table, so add new key\n                            consensusIndelStrings.put(indelString,1);\n\n                    }\n                    else if (read.getAlignmentStart() == loc.getStart()+1) {\n                        // opposite corner condition: read will start at current locus with an insertion\n                        for (String s : consensusIndelStrings.keySet()) {\n                            int cnt = consensusIndelStrings.get(s);\n                            if (s.endsWith(indelString)){\n                                // case 1: current insertion is suffix of indel in hash map\n                                consensusIndelStrings.put(s,cnt+1);\n                                foundKey = true;\n                                break;\n                            }\n                            else if (indelString.endsWith(s)) {\n                                // case 2: indel stored in hash table is suffix of current insertion\n                                // In this case, new bases are new key.\n\n                                consensusIndelStrings.remove(s);\n                                consensusIndelStrings.put(indelString,cnt+1);\n                                foundKey = true;\n                                break;\n                            }\n                        }\n                        if (!foundKey)\n                            // none of the above: event bases not supported by previous table, so add new key\n                            consensusIndelStrings.put(indelString,1);\n\n                    }\n                    else {\n                        // normal case: insertion somewhere in the middle of a read: add count to hash map\n                        int cnt = consensusIndelStrings.containsKey(indelString)? consensusIndelStrings.get(indelString):0;\n                        consensusIndelStrings.put(indelString,cnt+1);\n                    }\n\n                }\n                else if (p.isDeletion()) {\n                    indelString = String.format(\"D%d\",p.getEventLength());\n                    int cnt = consensusIndelStrings.containsKey(indelString)? consensusIndelStrings.get(indelString):0;\n                    consensusIndelStrings.put(indelString,cnt+1);\n\n                }\n            }\n\n/*            if (DEBUG) {\n                int icount = indelPileup.getNumberOfInsertions();\n                int dcount = indelPileup.getNumberOfDeletions();\n                if (icount + dcount > 0)\n                {\n                    List<Pair<String,Integer>> eventStrings = indelPileup.getEventStringsWithCounts(ref.getBases());\n                    System.out.format(\"#ins: %d, #del:%d\\n\", insCount, delCount);\n\n                    for (int i=0 ; i < eventStrings.size() ; i++ ) {\n                        System.out.format(\"%s:%d,\",eventStrings.get(i).first,eventStrings.get(i).second);\n                        //                int k=0;\n                    }\n                    System.out.println();\n                }\n            }             */\n        }\n\n        int maxAlleleCnt = 0;\n        String bestAltAllele = \"\";\n        for (String s : consensusIndelStrings.keySet()) {\n            int curCnt = consensusIndelStrings.get(s);\n            if (curCnt > maxAlleleCnt) {\n                maxAlleleCnt = curCnt;\n                bestAltAllele = s;\n            }\n//            if (DEBUG)\n//                System.out.format(\"Key:%s, number: %d\\n\",s,consensusIndelStrings.get(s)  );\n        }         //gdebug-\n\n        if (maxAlleleCnt <  minIndelCountForGenotyping)\n            return aList;\n\n        if (bestAltAllele.startsWith(\"D\")) {\n            // get deletion length\n            int dLen = Integer.valueOf(bestAltAllele.substring(1));\n            // get ref bases of accurate deletion\n            int startIdxInReference = 1+loc.getStart()-ref.getWindow().getStart();\n\n            //System.out.println(new String(ref.getBases()));\n            byte[] refBases = Arrays.copyOfRange(ref.getBases(),startIdxInReference,startIdxInReference+dLen);\n\n            if (Allele.acceptableAlleleBases(refBases)) {\n                refAllele = Allele.create(refBases,true);\n                altAllele = Allele.create(Allele.NULL_ALLELE_STRING, false);\n            }\n        }\n        else {\n            // insertion case\n            if (Allele.acceptableAlleleBases(bestAltAllele))  {\n                refAllele = Allele.create(Allele.NULL_ALLELE_STRING, true);\n                altAllele = Allele.create(bestAltAllele, false);\n            }\n        }\n        if (refAllele != null && altAllele != null) {\n            aList.add(0,refAllele);\n            aList.add(1,altAllele);\n        }\n        return aList;\n\n    }","commit_id":"e47a113c9f18bc75564091554517a297ff9e2ca1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Allele getLikelihoods(RefMetaDataTracker tracker,\n                                 ReferenceContext ref,\n                                 Map<String, AlignmentContext> contexts,\n                                 AlignmentContextUtils.ReadOrientation contextType,\n                                 GenotypePriors priors,\n                                 Map<String, MultiallelicGenotypeLikelihoods> GLs,\n                                 Allele alternateAlleleToUse,\n                                 boolean useBAQedPileup) {\n\n        if ( tracker == null )\n            return null;\n\n\n        GenomeLoc loc = ref.getLocus();\n        Allele refAllele, altAllele;\n        VariantContext vc = null;\n\n        if (!ref.getLocus().equals(lastSiteVisited)) {\n            // starting a new site: clear allele list\n            alleleList.clear();\n            lastSiteVisited = ref.getLocus();\n            indelLikelihoodMap.set(new HashMap<PileupElement,LinkedHashMap<Allele,Double>>());\n            haplotypeMap.clear();\n\n            if (getAlleleListFromVCF) {\n                 for( final VariantContext vc_input : tracker.getValues(UAC.alleles, loc) ) {\n                      if( vc_input != null &&\n                              allowableTypes.contains(vc_input.getType()) &&\n                              ref.getLocus().getStart() == vc_input.getStart()) {\n                         vc = vc_input;\n                         break;\n                     }\n                 }\n                 // ignore places where we don't have a variant\n                 if ( vc == null )\n                     return null;\n\n                alleleList.clear();\n                if (ignoreSNPAllelesWhenGenotypingIndels) {\n                    // if there's an allele that has same length as the reference (i.e. a SNP or MNP), ignore it and don't genotype it\n                    for (Allele a : vc.getAlleles())\n                        if (a.isNonReference() && a.getBases().length == vc.getReference().getBases().length)\n                            continue;\n                        else\n                            alleleList.add(a);\n\n                }\n                else {\n                    for (Allele a : vc.getAlleles())\n                        alleleList.add(a);\n                }\n\n            }\n            else {\n                alleleList = computeConsensusAlleles(ref,contexts, contextType);\n                if (alleleList.isEmpty())\n                    return null;\n            }\n        }\n        // protect against having an indel too close to the edge of a contig\n        if (loc.getStart() <= HAPLOTYPE_SIZE)\n            return null;\n\n        // check if there is enough reference window to create haplotypes (can be an issue at end of contigs)\n        if (ref.getWindow().getStop() < loc.getStop()+HAPLOTYPE_SIZE)\n            return null;\n        if ( !(priors instanceof DiploidIndelGenotypePriors) )\n            throw new StingException(\"Only diploid-based Indel priors are supported in the DINDEL GL model\");\n\n        if (alleleList.isEmpty())\n            return null;\n        \n        refAllele = alleleList.get(0);\n        altAllele = alleleList.get(1);\n\n        // look for alt allele that has biggest length distance to ref allele\n        int maxLenDiff = 0;\n        for (Allele a: alleleList) {\n            if(a.isNonReference())  {\n                int lenDiff = Math.abs(a.getBaseString().length() - refAllele.getBaseString().length());\n                if (lenDiff > maxLenDiff) {\n                    maxLenDiff = lenDiff;\n                    altAllele = a;\n                }\n            }\n        }\n\n        final int eventLength = altAllele.getBaseString().length() - refAllele.getBaseString().length();\n        final int hsize = (int)ref.getWindow().size()-Math.abs(eventLength)-1;\n        final int numPrefBases= ref.getLocus().getStart()-ref.getWindow().getStart()+1;\n\n        if (hsize <=0) {\n            logger.warn(String.format(\"Warning: event at location %s can't be genotyped, skipping\",loc.toString()));\n            return null;\n        }\n        haplotypeMap = Haplotype.makeHaplotypeListFromAlleles(alleleList, loc.getStart(),\n                ref, hsize, numPrefBases);\n\n        // For each sample, get genotype likelihoods based on pileup\n        // compute prior likelihoods on haplotypes, and initialize haplotype likelihood matrix with them.\n        // initialize the GenotypeLikelihoods\n        GLs.clear();\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null ) {\n                final double[] genotypeLikelihoods = pairModel.computeReadHaplotypeLikelihoods( pileup, haplotypeMap, ref, eventLength, getIndelLikelihoodMap());\n\n                GLs.put(sample.getKey(), new MultiallelicGenotypeLikelihoods(sample.getKey(),\n                        alleleList,\n                        genotypeLikelihoods,\n                        getFilteredDepth(pileup)));\n\n                if (DEBUG) {\n                    System.out.format(\"Sample:%s Alleles:%s GL:\",sample.getKey(), alleleList.toString());\n                    for (int k=0; k < genotypeLikelihoods.length; k++)\n                        System.out.format(\"%1.4f \",genotypeLikelihoods[k]);\n                    System.out.println();\n                }\n            }\n        }\n\n        return refAllele;\n    }","id":72095,"modified_method":"public VariantContext getLikelihoods(RefMetaDataTracker tracker,\n                                         ReferenceContext ref,\n                                         Map<String, AlignmentContext> contexts,\n                                         AlignmentContextUtils.ReadOrientation contextType,\n                                         GenotypePriors priors,\n                                         Allele alternateAlleleToUse,\n                                         boolean useBAQedPileup) {\n\n        if ( tracker == null )\n            return null;\n\n        GenomeLoc loc = ref.getLocus();\n        Allele refAllele, altAllele;\n        VariantContext vc = null;\n\n        if (!ref.getLocus().equals(lastSiteVisited)) {\n            // starting a new site: clear allele list\n            alleleList.clear();\n            lastSiteVisited = ref.getLocus();\n            indelLikelihoodMap.set(new HashMap<PileupElement,LinkedHashMap<Allele,Double>>());\n            haplotypeMap.clear();\n\n            if (getAlleleListFromVCF) {\n                 for( final VariantContext vc_input : tracker.getValues(UAC.alleles, loc) ) {\n                      if( vc_input != null &&\n                              allowableTypes.contains(vc_input.getType()) &&\n                              ref.getLocus().getStart() == vc_input.getStart()) {\n                         vc = vc_input;\n                         break;\n                     }\n                 }\n                 // ignore places where we don't have a variant\n                 if ( vc == null )\n                     return null;\n\n                alleleList.clear();\n                if (ignoreSNPAllelesWhenGenotypingIndels) {\n                    // if there's an allele that has same length as the reference (i.e. a SNP or MNP), ignore it and don't genotype it\n                    for (Allele a : vc.getAlleles())\n                        if (a.isNonReference() && a.getBases().length == vc.getReference().getBases().length)\n                            continue;\n                        else\n                            alleleList.add(a);\n\n                }\n                else {\n                    for (Allele a : vc.getAlleles())\n                        alleleList.add(a);\n                }\n\n            }\n            else {\n                alleleList = computeConsensusAlleles(ref,contexts, contextType);\n                if (alleleList.isEmpty())\n                    return null;\n            }\n        }\n        // protect against having an indel too close to the edge of a contig\n        if (loc.getStart() <= HAPLOTYPE_SIZE)\n            return null;\n\n        // check if there is enough reference window to create haplotypes (can be an issue at end of contigs)\n        if (ref.getWindow().getStop() < loc.getStop()+HAPLOTYPE_SIZE)\n            return null;\n        if ( !(priors instanceof DiploidIndelGenotypePriors) )\n            throw new StingException(\"Only diploid-based Indel priors are supported in the DINDEL GL model\");\n\n        if (alleleList.isEmpty())\n            return null;\n        \n        refAllele = alleleList.get(0);\n        altAllele = alleleList.get(1);\n\n        // look for alt allele that has biggest length distance to ref allele\n        int maxLenDiff = 0;\n        for (Allele a: alleleList) {\n            if(a.isNonReference())  {\n                int lenDiff = Math.abs(a.getBaseString().length() - refAllele.getBaseString().length());\n                if (lenDiff > maxLenDiff) {\n                    maxLenDiff = lenDiff;\n                    altAllele = a;\n                }\n            }\n        }\n\n        final int eventLength = altAllele.getBaseString().length() - refAllele.getBaseString().length();\n        final int hsize = (int)ref.getWindow().size()-Math.abs(eventLength)-1;\n        final int numPrefBases= ref.getLocus().getStart()-ref.getWindow().getStart()+1;\n\n        if (hsize <=0) {\n            logger.warn(String.format(\"Warning: event at location %s can't be genotyped, skipping\",loc.toString()));\n            return null;\n        }\n        haplotypeMap = Haplotype.makeHaplotypeListFromAlleles(alleleList, loc.getStart(),\n                ref, hsize, numPrefBases);\n\n        // start making the VariantContext\n        final int endLoc = calculateEndPos(alleleList, refAllele, loc);\n        final VariantContextBuilder builder = new VariantContextBuilder(\"UG_call\", loc.getContig(), loc.getStart(), endLoc, alleleList).referenceBaseForIndel(ref.getBase());\n\n        // create the genotypes; no-call everyone for now\n        GenotypesContext genotypes = GenotypesContext.create();\n        final List<Allele> noCall = new ArrayList<Allele>();\n        noCall.add(Allele.NO_CALL);\n\n        // For each sample, get genotype likelihoods based on pileup\n        // compute prior likelihoods on haplotypes, and initialize haplotype likelihood matrix with them.\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            AlignmentContext context = AlignmentContextUtils.stratify(sample.getValue(), contextType);\n\n            ReadBackedPileup pileup = null;\n            if (context.hasExtendedEventPileup())\n                pileup = context.getExtendedEventPileup();\n            else if (context.hasBasePileup())\n                pileup = context.getBasePileup();\n\n            if (pileup != null ) {\n                final double[] genotypeLikelihoods = pairModel.computeReadHaplotypeLikelihoods( pileup, haplotypeMap, ref, eventLength, getIndelLikelihoodMap());\n                GenotypeLikelihoods likelihoods = GenotypeLikelihoods.fromLog10Likelihoods(genotypeLikelihoods);\n\n                HashMap<String, Object> attributes = new HashMap<String, Object>();\n                attributes.put(VCFConstants.DEPTH_KEY, getFilteredDepth(pileup));\n                attributes.put(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, likelihoods);\n                genotypes.add(new Genotype(sample.getKey(), noCall, Genotype.NO_LOG10_PERROR, null, attributes, false));\n\n                if (DEBUG) {\n                    System.out.format(\"Sample:%s Alleles:%s GL:\",sample.getKey(), alleleList.toString());\n                    for (int k=0; k < genotypeLikelihoods.length; k++)\n                        System.out.format(\"%1.4f \",genotypeLikelihoods[k]);\n                    System.out.println();\n                }\n            }\n        }\n\n        return builder.genotypes(genotypes).make();\n    }","commit_id":"e47a113c9f18bc75564091554517a297ff9e2ca1","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void initializeBestAlternateAllele(byte ref, Map<String, AlignmentContext> contexts, boolean useBAQedPileup) {\n        int[] qualCounts = new int[4];\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            // calculate the sum of quality scores for each base\n            ReadBackedPileup pileup = useBAQedPileup ? createBAQedPileup( sample.getValue().getBasePileup() ) : sample.getValue().getBasePileup();\n            for ( PileupElement p : pileup ) {\n                // ignore deletions\n                if ( p.isDeletion() || (! p.isReducedRead() && p.getQual() < UAC.MIN_BASE_QUALTY_SCORE ))\n                    continue;\n\n                final int index = BaseUtils.simpleBaseToBaseIndex(p.getBase());\n                if ( index >= 0 ) {\n                    qualCounts[index] += p.getQual();\n                }\n            }\n        }\n\n        // set the non-ref base with maximum quality score sum\n        int maxCount = 0;\n        bestAlternateAllele = null;\n        for ( byte altAllele : BaseUtils.BASES ) {\n            if ( altAllele == ref )\n                continue;\n            int index = BaseUtils.simpleBaseToBaseIndex(altAllele);\n            if ( qualCounts[index] > maxCount ) {\n                maxCount = qualCounts[index];\n                bestAlternateAllele = altAllele;\n            }\n        }\n    }","id":72096,"modified_method":"protected void determineAlternateAlleles(boolean[] allelesToUse, byte ref, Map<String, AlignmentContext> contexts, boolean useBAQedPileup) {\n        int[] qualCounts = new int[4];\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            // calculate the sum of quality scores for each base\n            ReadBackedPileup pileup = useBAQedPileup ? createBAQedPileup( sample.getValue().getBasePileup() ) : sample.getValue().getBasePileup();\n            for ( PileupElement p : pileup ) {\n                // ignore deletions\n                if ( p.isDeletion() || (!p.isReducedRead() && p.getQual() < UAC.MIN_BASE_QUALTY_SCORE) )\n                    continue;\n\n                final int index = BaseUtils.simpleBaseToBaseIndex(p.getBase());\n                if ( index >= 0 ) {\n                    qualCounts[index] += p.getQual();\n                }\n            }\n        }\n\n        if ( ALLOW_MULTIPLE_ALLELES ) {\n            for ( byte altAllele : BaseUtils.BASES ) {\n                if ( altAllele == ref )\n                    continue;\n                int index = BaseUtils.simpleBaseToBaseIndex(altAllele);\n                if ( qualCounts[index] >= MIN_QUAL_SUM_FOR_ALT_ALLELE ) {\n                    allelesToUse[index] = true;\n                }\n            }\n        } else {\n            // set the non-ref base which has the maximum quality score sum\n            int maxCount = 0;\n            int indexOfMax = 0;\n            for ( byte altAllele : BaseUtils.BASES ) {\n                if ( altAllele == ref )\n                    continue;\n                int index = BaseUtils.simpleBaseToBaseIndex(altAllele);\n                if ( qualCounts[index] > maxCount ) {\n                    maxCount = qualCounts[index];\n                    indexOfMax = index;\n                }\n            }\n\n            if ( maxCount > 0 )\n                allelesToUse[indexOfMax] = true;\n        }\n    }","commit_id":"e47a113c9f18bc75564091554517a297ff9e2ca1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Allele getLikelihoods(RefMetaDataTracker tracker,\n                                 ReferenceContext ref,\n                                 Map<String, AlignmentContext> contexts,\n                                 AlignmentContextUtils.ReadOrientation contextType,\n                                 GenotypePriors priors,\n                                 Map<String, MultiallelicGenotypeLikelihoods> GLs,\n                                 Allele alternateAlleleToUse,\n                                 boolean useBAQedPileup) {\n\n        if ( !(priors instanceof DiploidSNPGenotypePriors) )\n            throw new StingException(\"Only diploid-based SNP priors are supported in the SNP GL model\");\n\n        byte refBase = ref.getBase();\n        Allele refAllele = Allele.create(refBase, true);\n\n        // find the alternate allele with the largest sum of quality scores\n        if ( alternateAlleleToUse != null ) {\n            bestAlternateAllele = alternateAlleleToUse.getBases()[0];\n        } else if ( useAlleleFromVCF ) {\n            VariantContext vc = UnifiedGenotyperEngine.getVCFromAllelesRod(tracker, ref, ref.getLocus(), true, logger, UAC.alleles);\n\n            // ignore places where we don't have a variant\n            if ( vc == null )\n                return null;\n\n            if ( !vc.isBiallelic() ) {\n                // for multi-allelic sites go back to the reads and find the most likely alternate allele\n                initializeBestAlternateAllele(refBase, contexts, useBAQedPileup);\n            } else {\n                bestAlternateAllele = vc.getAlternateAllele(0).getBases()[0];\n            }\n        } else {\n            initializeBestAlternateAllele(refBase, contexts, useBAQedPileup);\n        }\n\n        // if there are no non-ref bases...\n        if ( bestAlternateAllele == null ) {\n            // if we only want variants, then we don't need to calculate genotype likelihoods\n            if ( UAC.OutputMode == UnifiedGenotyperEngine.OUTPUT_MODE.EMIT_VARIANTS_ONLY )\n                return refAllele;\n\n            // otherwise, choose any alternate allele (it doesn't really matter)\n            bestAlternateAllele = (byte)(refBase != 'A' ? 'A' : 'C');\n        }\n\n        Allele altAllele = Allele.create(bestAlternateAllele, false);\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            ReadBackedPileup pileup = AlignmentContextUtils.stratify(sample.getValue(), contextType).getBasePileup();\n            if( useBAQedPileup ) { pileup = createBAQedPileup( pileup ); }\n\n            // create the GenotypeLikelihoods object\n            DiploidSNPGenotypeLikelihoods GL = new DiploidSNPGenotypeLikelihoods((DiploidSNPGenotypePriors)priors, UAC.PCR_error);\n            int nGoodBases = GL.add(pileup, true, true, UAC.MIN_BASE_QUALTY_SCORE);\n            if ( nGoodBases == 0 )\n                continue;\n\n            double[] likelihoods = GL.getLikelihoods();\n\n            DiploidGenotype refGenotype = DiploidGenotype.createHomGenotype(refBase);\n            DiploidGenotype hetGenotype = DiploidGenotype.createDiploidGenotype(refBase, bestAlternateAllele);\n            DiploidGenotype homGenotype = DiploidGenotype.createHomGenotype(bestAlternateAllele);\n            ArrayList<Allele> aList = new ArrayList<Allele>();\n            aList.add(refAllele);\n            aList.add(altAllele);\n            double[] dlike = new double[]{likelihoods[refGenotype.ordinal()],likelihoods[hetGenotype.ordinal()],likelihoods[homGenotype.ordinal()]} ;\n\n            // normalize in log space so that max element is zero.\n            GLs.put(sample.getKey(), new MultiallelicGenotypeLikelihoods(sample.getKey(),\n                    aList,  MathUtils.normalizeFromLog10(dlike, false, true), getFilteredDepth(pileup)));\n        }\n\n        return refAllele;\n    }","id":72097,"modified_method":"public VariantContext getLikelihoods(RefMetaDataTracker tracker,\n                                         ReferenceContext ref,\n                                         Map<String, AlignmentContext> contexts,\n                                         AlignmentContextUtils.ReadOrientation contextType,\n                                         GenotypePriors priors,\n                                         Allele alternateAlleleToUse,\n                                         boolean useBAQedPileup) {\n\n        if ( !(priors instanceof DiploidSNPGenotypePriors) )\n            throw new StingException(\"Only diploid-based SNP priors are supported in the SNP GL model\");\n\n        final boolean[] basesToUse = new boolean[4];\n        final byte refBase = ref.getBase();\n        final int indexOfRefBase = BaseUtils.simpleBaseToBaseIndex(refBase);\n\n        // start making the VariantContext\n        final GenomeLoc loc = ref.getLocus();\n        final List<Allele> alleles = new ArrayList<Allele>();\n        alleles.add(Allele.create(refBase, true));\n        final VariantContextBuilder builder = new VariantContextBuilder(\"UG_call\", loc.getContig(), loc.getStart(), loc.getStop(), alleles);\n\n        // find the alternate allele(s) that we should be using\n        if ( alternateAlleleToUse != null ) {\n            basesToUse[BaseUtils.simpleBaseToBaseIndex(alternateAlleleToUse.getBases()[0])] = true;\n        } else if ( useAlleleFromVCF ) {\n            final VariantContext vc = UnifiedGenotyperEngine.getVCFromAllelesRod(tracker, ref, ref.getLocus(), true, logger, UAC.alleles);\n\n            // ignore places where we don't have a SNP\n            if ( vc == null || !vc.isSNP() )\n                return null;\n\n            for ( Allele allele : vc.getAlternateAlleles() )\n                basesToUse[BaseUtils.simpleBaseToBaseIndex(allele.getBases()[0])] = true;\n        } else {\n\n            determineAlternateAlleles(basesToUse, refBase, contexts, useBAQedPileup);\n\n            // how many alternate alleles are we using?\n            int alleleCounter = countSetBits(basesToUse);\n\n            // if there are no non-ref alleles...\n            if ( alleleCounter == 0 ) {\n                // if we only want variants, then we don't need to calculate genotype likelihoods\n                if ( UAC.OutputMode == UnifiedGenotyperEngine.OUTPUT_MODE.EMIT_VARIANTS_ONLY )\n                    return builder.make();\n\n                // otherwise, choose any alternate allele (it doesn't really matter)\n                basesToUse[indexOfRefBase == 0 ? 1 : 0] = true;\n             }\n        }\n\n        // create the alternate alleles and the allele ordering (the ordering is crucial for the GLs)\n        final int numAltAlleles = countSetBits(basesToUse);\n        final int[] alleleOrdering = new int[numAltAlleles + 1];\n        alleleOrdering[0] = indexOfRefBase;\n        int alleleOrderingIndex = 1;\n        int numLikelihoods = 1;\n        for ( int i = 0; i < 4; i++ ) {\n            if ( i != indexOfRefBase && basesToUse[i] ) {\n                alleles.add(Allele.create(BaseUtils.baseIndexToSimpleBase(i), false));\n                alleleOrdering[alleleOrderingIndex++] = i;\n                numLikelihoods += alleleOrderingIndex;\n            }\n        }\n        builder.alleles(alleles);\n\n        // create the genotypes; no-call everyone for now\n        GenotypesContext genotypes = GenotypesContext.create();\n        final List<Allele> noCall = new ArrayList<Allele>();\n        noCall.add(Allele.NO_CALL);\n\n        for ( Map.Entry<String, AlignmentContext> sample : contexts.entrySet() ) {\n            ReadBackedPileup pileup = AlignmentContextUtils.stratify(sample.getValue(), contextType).getBasePileup();\n            if ( useBAQedPileup )\n                pileup = createBAQedPileup( pileup );\n\n            // create the GenotypeLikelihoods object\n            final DiploidSNPGenotypeLikelihoods GL = new DiploidSNPGenotypeLikelihoods((DiploidSNPGenotypePriors)priors, UAC.PCR_error);\n            final int nGoodBases = GL.add(pileup, true, true, UAC.MIN_BASE_QUALTY_SCORE);\n            if ( nGoodBases == 0 )\n                continue;\n\n            final double[] allLikelihoods = GL.getLikelihoods();\n            final double[] myLikelihoods = new double[numLikelihoods];\n\n            int myLikelihoodsIndex = 0;\n            for ( int i = 0; i <= numAltAlleles; i++ ) {\n                for ( int j = i; j <= numAltAlleles; j++ ) {\n                    myLikelihoods[myLikelihoodsIndex++] = allLikelihoods[DiploidGenotype.createDiploidGenotype(alleleOrdering[i], alleleOrdering[j]).ordinal()];\n                }\n            }\n\n            // normalize in log space so that max element is zero.\n            GenotypeLikelihoods likelihoods = GenotypeLikelihoods.fromLog10Likelihoods(MathUtils.normalizeFromLog10(myLikelihoods, false, true));\n\n            HashMap<String, Object> attributes = new HashMap<String, Object>();\n            attributes.put(VCFConstants.DEPTH_KEY, getFilteredDepth(pileup));\n            attributes.put(VCFConstants.PHRED_GENOTYPE_LIKELIHOODS_KEY, likelihoods);\n            genotypes.add(new Genotype(sample.getKey(), noCall, Genotype.NO_LOG10_PERROR, null, attributes, false));\n        }\n\n        return builder.genotypes(genotypes).make();\n    }","commit_id":"e47a113c9f18bc75564091554517a297ff9e2ca1","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected SNPGenotypeLikelihoodsCalculationModel(UnifiedArgumentCollection UAC, Logger logger) {\n        super(UAC, logger);\n        useAlleleFromVCF = UAC.GenotypingMode == GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES;\n    }","id":72098,"modified_method":"protected SNPGenotypeLikelihoodsCalculationModel(UnifiedArgumentCollection UAC, Logger logger) {\n        super(UAC, logger);\n        ALLOW_MULTIPLE_ALLELES = UAC.MULTI_ALLELIC;\n        useAlleleFromVCF = UAC.GenotypingMode == GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES;\n    }","commit_id":"e47a113c9f18bc75564091554517a297ff9e2ca1","url":"https://github.com/broadgsa/gatk"},{"original_method":"private VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, Map<String, AlignmentContext> stratifiedContexts, AlignmentContextUtils.ReadOrientation type, Allele alternateAlleleToUse, boolean useBAQedPileup, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( glcm.get() == null ) {\n            glcm.set(getGenotypeLikelihoodsCalculationObject(logger, UAC));\n        }\n\n        Map<String, MultiallelicGenotypeLikelihoods> GLs = new HashMap<String, MultiallelicGenotypeLikelihoods>();\n\n        Allele refAllele = glcm.get().get(model).getLikelihoods(tracker, refContext, stratifiedContexts, type, getGenotypePriors(model), GLs, alternateAlleleToUse, useBAQedPileup && BAQEnabledOnCMDLine);\n\n        if ( refAllele != null )\n            return createVariantContextFromLikelihoods(refContext, refAllele, GLs);\n        else\n            return null;\n    }","id":72099,"modified_method":"private VariantContext calculateLikelihoods(RefMetaDataTracker tracker, ReferenceContext refContext, Map<String, AlignmentContext> stratifiedContexts, AlignmentContextUtils.ReadOrientation type, Allele alternateAlleleToUse, boolean useBAQedPileup, final GenotypeLikelihoodsCalculationModel.Model model) {\n\n        // initialize the data for this thread if that hasn't been done yet\n        if ( glcm.get() == null ) {\n            glcm.set(getGenotypeLikelihoodsCalculationObject(logger, UAC));\n        }\n\n        return glcm.get().get(model).getLikelihoods(tracker, refContext, stratifiedContexts, type, getGenotypePriors(model), alternateAlleleToUse, useBAQedPileup && BAQEnabledOnCMDLine);\n    }","commit_id":"e47a113c9f18bc75564091554517a297ff9e2ca1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.msc.service.Service#stop(org.jboss.msc.service.StopContext)\n     */\n    @Override\n    public void stop(StopContext context) {\n        this.service.stop();\n        // remove from registry\n        this.groupMembershipNotifierRegistry.getValue().unregisterGroupMembershipNotifier(this.service.getGroupName());\n    }","id":72100,"modified_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.msc.service.Service#stop(org.jboss.msc.service.StopContext)\n     */\n    @Override\n    public void stop(StopContext context) {\n        this.service.stop();\n        // remove from registry\n        final GroupMembershipNotifierRegistry registry = this.groupMembershipNotifierRegistry.getOptionalValue();\n        if (registry != null) {\n            registry.unregisterGroupMembershipNotifier(this.service.getGroupName());\n        }\n    }","commit_id":"600e99876282c9d57e3c439c47ae10f8adb0cdcf","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.msc.service.Service#start(org.jboss.msc.service.StartContext)\n     */\n    @Override\n    public void start(StartContext context) throws StartException {\n        this.service = new CoreGroupCommunicationService();\n        this.service.setChannel(this.channel.getValue());\n        this.service.setScopeId(this.scope);\n\n        try {\n            this.service.start();\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n        // add it to the registry\n        this.groupMembershipNotifierRegistry.getValue().registerGroupMembershipNotifier(this.service);\n    }","id":72101,"modified_method":"/**\n     * {@inheritDoc}\n     * @see org.jboss.msc.service.Service#start(org.jboss.msc.service.StartContext)\n     */\n    @Override\n    public void start(StartContext context) throws StartException {\n        this.service = new CoreGroupCommunicationService();\n        this.service.setChannel(this.channel.getValue());\n        this.service.setScopeId(this.scope);\n\n        try {\n            this.service.start();\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n        // add it to the registry\n        final GroupMembershipNotifierRegistry registry = this.groupMembershipNotifierRegistry.getOptionalValue();\n        if (registry != null) {\n            registry.registerGroupMembershipNotifier(this.service);\n        }\n    }","commit_id":"600e99876282c9d57e3c439c47ae10f8adb0cdcf","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addRemoteInvocationServices(final OperationContext context, final List<ServiceController<?>> newControllers, final boolean appclient) {\n\n        // Add the tccl based client context selector\n        final TCCLBasedEJBClientContextSelector tcclBasedClientContextSelector = new TCCLBasedEJBClientContextSelector();\n        context.getServiceTarget().addService(TCCLBasedEJBClientContextSelector.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                tcclBasedClientContextSelector).install();\n\n        //add the default EjbClientContext\n        //TODO: This should be managed\n        final DefaultEjbClientContextService clientContextService = new DefaultEjbClientContextService();\n        final ServiceBuilder<EJBClientContext> clientContextServiceBuilder = context.getServiceTarget().addService(DefaultEjbClientContextService.DEFAULT_SERVICE_NAME,\n                clientContextService).addDependency(TCCLBasedEJBClientContextSelector.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                TCCLBasedEJBClientContextSelector.class, clientContextService.getTCCLBasedEJBClientContextSelectorInjector());\n\n        if (!appclient) {\n            // get the node name\n            final String nodeName = SecurityActions.getSystemProperty(ServerEnvironment.NODE_NAME);\n            //the default spec compliant EJB reciever\n            final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n            newControllers.add(context.getServiceTarget().addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n                    .install());\n\n            //the receiver for invocations that allow pass by reference\n            final LocalEjbReceiver byReferenceLocalEjbReceiver = new LocalEjbReceiver(nodeName, true);\n            newControllers.add(context.getServiceTarget().addService(LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME, byReferenceLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byReferenceLocalEjbReceiver.getDeploymentRepository())\n                    .install());\n\n            clientContextService.addReceiver(clientContextServiceBuilder, LocalEjbReceiver.BY_VALUE_SERVICE_NAME);\n        }\n\n        newControllers.add(clientContextServiceBuilder.install());\n    }","id":72102,"modified_method":"private void addRemoteInvocationServices(final OperationContext context, final List<ServiceController<?>> newControllers, final boolean appclient) {\n\n        // Add the tccl based client context selector\n        final TCCLBasedEJBClientContextSelector tcclBasedClientContextSelector = new TCCLBasedEJBClientContextSelector();\n        context.getServiceTarget().addService(TCCLBasedEJBClientContextSelector.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                tcclBasedClientContextSelector).install();\n\n        //add the default EjbClientContext\n        //TODO: This should be managed\n        final DefaultEjbClientContextService clientContextService = new DefaultEjbClientContextService();\n        final ServiceBuilder<EJBClientContext> clientContextServiceBuilder = context.getServiceTarget().addService(DefaultEjbClientContextService.DEFAULT_SERVICE_NAME,\n                clientContextService).addDependency(TCCLBasedEJBClientContextSelector.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                TCCLBasedEJBClientContextSelector.class, clientContextService.getTCCLBasedEJBClientContextSelectorInjector());\n\n        if (!appclient) {\n            // get the node name\n            final String nodeName = SecurityActions.getSystemProperty(ServerEnvironment.NODE_NAME);\n            //the default spec compliant EJB reciever\n            final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n            newControllers.add(context.getServiceTarget().addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(GroupMembershipNotifierRegistryService.SERVICE_NAME, GroupMembershipNotifierRegistry.class, byValueLocalEjbReceiver.getClusterRegistryInjector())\n                    .install());\n\n            //the receiver for invocations that allow pass by reference\n            final LocalEjbReceiver byReferenceLocalEjbReceiver = new LocalEjbReceiver(nodeName, true);\n            newControllers.add(context.getServiceTarget().addService(LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME, byReferenceLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byReferenceLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(GroupMembershipNotifierRegistryService.SERVICE_NAME, GroupMembershipNotifierRegistry.class, byReferenceLocalEjbReceiver.getClusterRegistryInjector())\n                    .install());\n\n            clientContextService.addReceiver(clientContextServiceBuilder, LocalEjbReceiver.BY_VALUE_SERVICE_NAME);\n        }\n\n        newControllers.add(clientContextServiceBuilder.install());\n    }","commit_id":"600e99876282c9d57e3c439c47ae10f8adb0cdcf","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests that invocations on a stateful session bean work after a session is created and the stateful\n     * session bean really acts as a stateful bean\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSFSBInvocation() throws Exception {\n        // open a session for the SFSB\n        final SessionID sessionID = EJBClient.createSession(APP_NAME, MODULE_NAME, CounterBean.class.getSimpleName(), \"\");\n        final StatefulEJBLocator<Counter> locator = new StatefulEJBLocator<Counter>(Counter.class, APP_NAME, MODULE_NAME, CounterBean.class.getSimpleName(), \"\", sessionID);\n        final Counter counter = EJBClient.createProxy(locator);\n        Assert.assertNotNull(\"Received a null proxy\", counter);\n        // invoke the bean\n        final int initialCount = counter.getCount();\n        logger.info(\"Got initial count \" + initialCount);\n        Assert.assertEquals(\"Unexpected initial count from stateful bean\", 0, initialCount);\n        final int NUM_TIMES = 50;\n        for (int i = 1; i <= NUM_TIMES; i++) {\n            final int count = counter.incrementAndGetCount();\n            logger.info(\"Got next count \" + count);\n            Assert.assertEquals(\"Unexpected count after increment\", i, count);\n        }\n        final int finalCount = counter.getCount();\n        logger.info(\"Got final count \" + finalCount);\n        Assert.assertEquals(\"Unexpected final count\", NUM_TIMES, finalCount);\n    }","id":72103,"modified_method":"/**\n     * Tests that invocations on a stateful session bean work after a session is created and the stateful\n     * session bean really acts as a stateful bean\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSFSBInvocation() throws Exception {\n        final StatefulEJBLocator<Counter> locator = EJBClient.createSession(Counter.class, APP_NAME, MODULE_NAME, CounterBean.class.getSimpleName(), \"\");\n        final Counter counter = EJBClient.createProxy(locator);\n        Assert.assertNotNull(\"Received a null proxy\", counter);\n        // invoke the bean\n        final int initialCount = counter.getCount();\n        logger.info(\"Got initial count \" + initialCount);\n        Assert.assertEquals(\"Unexpected initial count from stateful bean\", 0, initialCount);\n        final int NUM_TIMES = 50;\n        for (int i = 1; i <= NUM_TIMES; i++) {\n            final int count = counter.incrementAndGetCount();\n            logger.info(\"Got next count \" + count);\n            Assert.assertEquals(\"Unexpected count after increment\", i, count);\n        }\n        final int finalCount = counter.getCount();\n        logger.info(\"Got final count \" + finalCount);\n        Assert.assertEquals(\"Unexpected final count\", NUM_TIMES, finalCount);\n    }","commit_id":"600e99876282c9d57e3c439c47ae10f8adb0cdcf","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests that invocation on a stateful session bean fails, if a session hasn't been created\n     *\n     * @throws Exception\n     */\n    @Test\n    @Ignore(\"No longer appropriate, since a proxy can no longer be created without a session, for a SFSB. \" +\n            \"Need to think if there's a different way to test this. Else just remove this test\")\n    public void testSFSBAccessFailureWithoutSession() throws Exception {\n        // create a locator without a session\n        final StatefulEJBLocator<Counter> locator = new StatefulEJBLocator<Counter>(Counter.class, APP_NAME, MODULE_NAME, CounterBean.class.getSimpleName(), \"\", null);\n        final Counter counter = EJBClient.createProxy(locator);\n        Assert.assertNotNull(\"Received a null proxy\", counter);\n        // invoke the bean without creating a session\n        try {\n            final int initialCount = counter.getCount();\n            Assert.fail(\"Expected a EJBException for calling a stateful session bean without creating a session\");\n        } catch (EJBException ejbe) {\n            // expected\n            logger.info(\"Received the expected exception\", ejbe);\n\n        }\n    }","id":72104,"modified_method":"/**\n     * Tests that invocation on a stateful session bean fails, if a session hasn't been created\n     *\n     * @throws Exception\n     */\n    @Test\n    @Ignore(\"No longer appropriate, since a proxy can no longer be created without a session, for a SFSB. \" +\n            \"Need to think if there's a different way to test this. Else just remove this test\")\n    public void testSFSBAccessFailureWithoutSession() throws Exception {\n        // create a locator without a session\n        final StatefulEJBLocator<Counter> locator = new StatefulEJBLocator<Counter>(Counter.class, APP_NAME, MODULE_NAME, CounterBean.class.getSimpleName(), \"\", null, Affinity.NONE);\n        final Counter counter = EJBClient.createProxy(locator);\n        Assert.assertNotNull(\"Received a null proxy\", counter);\n        // invoke the bean without creating a session\n        try {\n            final int initialCount = counter.getCount();\n            Assert.fail(\"Expected a EJBException for calling a stateful session bean without creating a session\");\n        } catch (EJBException ejbe) {\n            // expected\n            logger.info(\"Received the expected exception\", ejbe);\n\n        }\n    }","commit_id":"600e99876282c9d57e3c439c47ae10f8adb0cdcf","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void addDependencies(ServiceTarget target, ServiceBuilder<?> builder) {\n        ServiceName baseServiceName = EmbeddedCacheManagerService.getServiceName(null);\n        ServiceName serviceName = ServiceName.parse((this.cacheName != null) ? this.cacheName : DEFAULT_BACKING_CACHE);\n        if (!baseServiceName.isParentOf(serviceName)) {\n            serviceName = baseServiceName.append(serviceName);\n        }\n        if (serviceName.length() < 4) {\n            serviceName = serviceName.append(CacheContainer.DEFAULT_CACHE_NAME);\n        }\n        String container = serviceName.getParent().getSimpleName();\n        // install the GroupCommunicationService\n        final CoreGroupCommunicationServiceService groupCommunicationService = new CoreGroupCommunicationServiceService(SCOPE_ID);\n        groupCommunicationService.build(target, container).setInitialMode(ServiceController.Mode.ON_DEMAND)\n                .addDependency(GroupMembershipNotifierRegistryService.SERVICE_NAME, GroupMembershipNotifierRegistry.class, groupCommunicationService.getGroupMembershipNotifierRegistryInjector())\n                .install();\n        new SharedLocalYieldingClusterLockManagerService(container).build(target).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        builder.addDependency(serviceName, Cache.class, this.groupCache);\n        builder.addDependency(SharedLocalYieldingClusterLockManagerService.getServiceName(container), SharedLocalYieldingClusterLockManager.class, this.lockManager);\n    }","id":72105,"modified_method":"@Override\n    public void addDependencies(ServiceTarget target, ServiceBuilder<?> builder) {\n        ServiceName baseServiceName = EmbeddedCacheManagerService.getServiceName(null);\n        ServiceName serviceName = ServiceName.parse((this.cacheName != null) ? this.cacheName : DEFAULT_BACKING_CACHE);\n        if (!baseServiceName.isParentOf(serviceName)) {\n            serviceName = baseServiceName.append(serviceName);\n        }\n        if (serviceName.length() < 4) {\n            serviceName = serviceName.append(CacheContainer.DEFAULT_CACHE_NAME);\n        }\n        String container = serviceName.getParent().getSimpleName();\n        // install the GroupCommunicationService\n        final CoreGroupCommunicationServiceService groupCommunicationService = new CoreGroupCommunicationServiceService(SCOPE_ID);\n        groupCommunicationService.build(target, container).setInitialMode(ServiceController.Mode.ON_DEMAND)\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, GroupMembershipNotifierRegistryService.SERVICE_NAME, GroupMembershipNotifierRegistry.class, groupCommunicationService.getGroupMembershipNotifierRegistryInjector())\n                .install();\n        new SharedLocalYieldingClusterLockManagerService(container).build(target).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        builder.addDependency(serviceName, Cache.class, this.groupCache);\n        builder.addDependency(SharedLocalYieldingClusterLockManagerService.getServiceName(container), SharedLocalYieldingClusterLockManager.class, this.lockManager);\n    }","commit_id":"600e99876282c9d57e3c439c47ae10f8adb0cdcf","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(final StartContext context) throws StartException {\n\n        deploymentRepository.getValue().addListener(deploymentListener);\n    }","id":72106,"modified_method":"@Override\n    public void start(final StartContext context) throws StartException {\n\n        deploymentRepository.getValue().addListener(deploymentListener);\n        // register ourselves as a listener to new cluster formations/removal\n        this.clusterRegistry.getValue().addListener(this);\n    }","commit_id":"600e99876282c9d57e3c439c47ae10f8adb0cdcf","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void stop(final StopContext context) {\n        for (EJBReceiverContext ctx : contexts) {\n            ctx.close();\n        }\n        this.contexts.clear();\n        deploymentRepository.getValue().removeListener(deploymentListener);\n    }","id":72107,"modified_method":"@Override\n    public void stop(final StopContext context) {\n        for (EJBReceiverContext ctx : contexts) {\n            ctx.close();\n        }\n        this.contexts.clear();\n        deploymentRepository.getValue().removeListener(deploymentListener);\n        // remove ourselves from cluster creation/removal event notifications\n        this.clusterRegistry.getValue().removeListener(this);\n    }","commit_id":"600e99876282c9d57e3c439c47ae10f8adb0cdcf","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addRemoteInvocationServices(final OperationContext context, final List<ServiceController<?>> newControllers,\n                                             final ModelNode ejbSubsystemModel, final boolean appclient) throws OperationFailedException {\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        // Add the tccl based client context selector\n        final TCCLEJBClientContextSelectorService tcclBasedClientContextSelector = new TCCLEJBClientContextSelectorService();\n        context.getServiceTarget().addService(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                tcclBasedClientContextSelector).install();\n\n        // EJB client context selector will be locked on the server if it's not application client container\n        final boolean lockEJBClientContextSelector = appclient ? false : true;\n        //add the default EjbClientContext\n        //TODO: This should be managed\n        final DefaultEjbClientContextService clientContextService = new DefaultEjbClientContextService(lockEJBClientContextSelector);\n        final ServiceBuilder<EJBClientContext> clientContextServiceBuilder = context.getServiceTarget().addService(DefaultEjbClientContextService.DEFAULT_SERVICE_NAME,\n                clientContextService).addDependency(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                TCCLEJBClientContextSelectorService.class, clientContextService.getTCCLBasedEJBClientContextSelectorInjector());\n\n        if (!appclient) {\n            // get the node name\n            final String nodeName = SecurityActions.getSystemProperty(ServerEnvironment.NODE_NAME);\n            //the default spec compliant EJB receiver\n            final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n            newControllers.add(serviceTarget.addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(ClusteredBackingCacheEntryStoreSourceService.CLIENT_MAPPING_REGISTRY_COLLECTOR_SERVICE_NAME, RegistryCollector.class, byValueLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byValueLocalEjbReceiver.getEndpointInjector())\n                    .addDependency(EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byValueLocalEjbReceiver.getEJBRemoteConnectorServiceInjector())\n                    .install());\n\n            //the receiver for invocations that allow pass by reference\n            final LocalEjbReceiver byReferenceLocalEjbReceiver = new LocalEjbReceiver(nodeName, true);\n            newControllers.add(serviceTarget.addService(LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME, byReferenceLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byReferenceLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(ClusteredBackingCacheEntryStoreSourceService.CLIENT_MAPPING_REGISTRY_COLLECTOR_SERVICE_NAME, RegistryCollector.class, byReferenceLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byReferenceLocalEjbReceiver.getEndpointInjector())\n                    .addDependency(EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byReferenceLocalEjbReceiver.getEJBRemoteConnectorServiceInjector())\n                    .install());\n\n            // setup the default local ejb receiver service\n            EJBRemoteInvocationPassByValueWriteHandler.INSTANCE.updateDefaultLocalEJBReceiverService(context, ejbSubsystemModel, newControllers);\n            // add the default local ejb receiver to the client context\n            clientContextServiceBuilder.addDependency(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, LocalEjbReceiver.class, clientContextService.getDefaultLocalEJBReceiverInjector());\n        }\n        // install the default EJB client context service\n        newControllers.add(clientContextServiceBuilder.install());\n    }","id":72108,"modified_method":"private void addRemoteInvocationServices(final OperationContext context, final List<ServiceController<?>> newControllers,\n                                             final ModelNode ejbSubsystemModel, final boolean appclient) throws OperationFailedException {\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        // Add the tccl based client context selector\n        final TCCLEJBClientContextSelectorService tcclBasedClientContextSelector = new TCCLEJBClientContextSelectorService();\n        context.getServiceTarget().addService(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                tcclBasedClientContextSelector).install();\n\n        // EJB client context selector will be locked on the server if it's not application client container\n        final boolean lockEJBClientContextSelector = appclient ? false : true;\n        //add the default EjbClientContext\n        //TODO: This should be managed\n        final DefaultEjbClientContextService clientContextService = new DefaultEjbClientContextService(lockEJBClientContextSelector);\n        final ServiceBuilder<EJBClientContext> clientContextServiceBuilder = context.getServiceTarget().addService(DefaultEjbClientContextService.DEFAULT_SERVICE_NAME,\n                clientContextService).addDependency(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                TCCLEJBClientContextSelectorService.class, clientContextService.getTCCLBasedEJBClientContextSelectorInjector());\n\n        if (!appclient) {\n            // get the node name\n            final String nodeName = SecurityActions.getSystemProperty(ServerEnvironment.NODE_NAME);\n            //the default spec compliant EJB receiver\n            final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n            newControllers.add(serviceTarget.addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(ClusteredBackingCacheEntryStoreSourceService.CLIENT_MAPPING_REGISTRY_COLLECTOR_SERVICE_NAME, RegistryCollector.class, byValueLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .addDependency(ServiceBuilder.DependencyType.OPTIONAL, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byValueLocalEjbReceiver.getEndpointInjector())\n                    .addDependency(ServiceBuilder.DependencyType.OPTIONAL, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byValueLocalEjbReceiver.getEJBRemoteConnectorServiceInjector())\n                    .install());\n\n            //the receiver for invocations that allow pass by reference\n            final LocalEjbReceiver byReferenceLocalEjbReceiver = new LocalEjbReceiver(nodeName, true);\n            newControllers.add(serviceTarget.addService(LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME, byReferenceLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byReferenceLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(ClusteredBackingCacheEntryStoreSourceService.CLIENT_MAPPING_REGISTRY_COLLECTOR_SERVICE_NAME, RegistryCollector.class, byReferenceLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .addDependency(ServiceBuilder.DependencyType.OPTIONAL, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byReferenceLocalEjbReceiver.getEndpointInjector())\n                    .addDependency(ServiceBuilder.DependencyType.OPTIONAL, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byReferenceLocalEjbReceiver.getEJBRemoteConnectorServiceInjector())\n                    .install());\n\n            // setup the default local ejb receiver service\n            EJBRemoteInvocationPassByValueWriteHandler.INSTANCE.updateDefaultLocalEJBReceiverService(context, ejbSubsystemModel, newControllers);\n            // add the default local ejb receiver to the client context\n            clientContextServiceBuilder.addDependency(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, LocalEjbReceiver.class, clientContextService.getDefaultLocalEJBReceiverInjector());\n        }\n        // install the default EJB client context service\n        newControllers.add(clientContextServiceBuilder.install());\n    }","commit_id":"12be390955ef4840aadd9676e68e5210876df185","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addClusterNodes(final EJBClientContext ejbClientContext, final String clusterName, final Map<String, List<ClientMapping>> addedNodes) {\n        if (addedNodes == null || addedNodes.isEmpty()) {\n            return;\n        }\n        final SocketBinding ejbRemoteConnectorSocketBinding = this.ejbRemoteConnectorServiceValue.getValue().getEJBRemoteConnectorSocketBinding();\n        final InetAddress bindAddress = ejbRemoteConnectorSocketBinding.getAddress();\n        final ClusterContext clusterContext = ejbClientContext.getOrCreateClusterContext(clusterName);\n        // add the nodes to the cluster context\n        for (Map.Entry<String, List<ClientMapping>> entry : addedNodes.entrySet()) {\n            final String addedNodeName = entry.getKey();\n            // if the current node is being added, then let the local receiver handle it\n            if (LocalEjbReceiver.this.getNodeName().equals(addedNodeName)) {\n                clusterContext.addClusterNodes(new LocalClusterNodeManager());\n                continue;\n            }\n            // if the EJB client context is the default server level EJB client context\n            // which can only handle local receiver and no remote receivers (due to lack of configurations\n            // to connect to them), then skip that context\n            if (this.isLocalOnlyEJBClientContext(ejbClientContext)) {\n                logger.debug(\"Skipping cluster node additions to EJB client context \" + ejbClientContext + \" since it can only handle local node\");\n                continue;\n            }\n            // find a matching client mapping for our bind address\n            final List<ClientMapping> clientMappings = entry.getValue();\n            ClientMapping resolvedClientMapping = null;\n            for (final ClientMapping clientMapping : clientMappings) {\n                final InetAddress sourceNetworkAddress = clientMapping.getSourceNetworkAddress();\n                final int netMask = clientMapping.getSourceNetworkMaskBits();\n                final boolean match = NetworkUtil.belongsToNetwork(bindAddress, sourceNetworkAddress, (byte) (netMask & 0xff));\n                if (match) {\n                    resolvedClientMapping = clientMapping;\n                    logger.debug(\"Client mapping \" + clientMapping + \" matches client address \" + bindAddress);\n                    break;\n                }\n            }\n            if (resolvedClientMapping == null) {\n                EjbLogger.ROOT_LOGGER.cannotAddClusterNodeDueToUnresolvableClientMapping(addedNodeName, clusterName, bindAddress);\n                continue;\n            }\n            final ClusterNodeManager remotingClusterNodeManager = new RemotingConnectionClusterNodeManager(clusterContext, this.endpointInjectedValue.getValue(), addedNodeName, resolvedClientMapping.getDestinationAddress(), resolvedClientMapping.getDestinationPort());\n            clusterContext.addClusterNodes(remotingClusterNodeManager);\n        }\n\n    }","id":72109,"modified_method":"private void addClusterNodes(final EJBClientContext ejbClientContext, final String clusterName, final Map<String, List<ClientMapping>> addedNodes) {\n        if (addedNodes == null || addedNodes.isEmpty()) {\n            return;\n        }\n        final EJBRemoteConnectorService ejbRemoteConnectorService = this.ejbRemoteConnectorServiceValue.getOptionalValue();\n        final Endpoint endpoint = this.endpointInjectedValue.getOptionalValue();\n        if(ejbRemoteConnectorService == null || endpoint == null) {\n            return;\n        }\n        final SocketBinding ejbRemoteConnectorSocketBinding = ejbRemoteConnectorService.getEJBRemoteConnectorSocketBinding();\n        final InetAddress bindAddress = ejbRemoteConnectorSocketBinding.getAddress();\n        final ClusterContext clusterContext = ejbClientContext.getOrCreateClusterContext(clusterName);\n        // add the nodes to the cluster context\n        for (Map.Entry<String, List<ClientMapping>> entry : addedNodes.entrySet()) {\n            final String addedNodeName = entry.getKey();\n            // if the current node is being added, then let the local receiver handle it\n            if (LocalEjbReceiver.this.getNodeName().equals(addedNodeName)) {\n                clusterContext.addClusterNodes(new LocalClusterNodeManager());\n                continue;\n            }\n            // if the EJB client context is the default server level EJB client context\n            // which can only handle local receiver and no remote receivers (due to lack of configurations\n            // to connect to them), then skip that context\n            if (this.isLocalOnlyEJBClientContext(ejbClientContext)) {\n                logger.debug(\"Skipping cluster node additions to EJB client context \" + ejbClientContext + \" since it can only handle local node\");\n                continue;\n            }\n            // find a matching client mapping for our bind address\n            final List<ClientMapping> clientMappings = entry.getValue();\n            ClientMapping resolvedClientMapping = null;\n            for (final ClientMapping clientMapping : clientMappings) {\n                final InetAddress sourceNetworkAddress = clientMapping.getSourceNetworkAddress();\n                final int netMask = clientMapping.getSourceNetworkMaskBits();\n                final boolean match = NetworkUtil.belongsToNetwork(bindAddress, sourceNetworkAddress, (byte) (netMask & 0xff));\n                if (match) {\n                    resolvedClientMapping = clientMapping;\n                    logger.debug(\"Client mapping \" + clientMapping + \" matches client address \" + bindAddress);\n                    break;\n                }\n            }\n            if (resolvedClientMapping == null) {\n                EjbLogger.ROOT_LOGGER.cannotAddClusterNodeDueToUnresolvableClientMapping(addedNodeName, clusterName, bindAddress);\n                continue;\n            }\n            final ClusterNodeManager remotingClusterNodeManager = new RemotingConnectionClusterNodeManager(clusterContext, endpoint, addedNodeName, resolvedClientMapping.getDestinationAddress(), resolvedClientMapping.getDestinationPort());\n            clusterContext.addClusterNodes(remotingClusterNodeManager);\n        }\n\n    }","commit_id":"12be390955ef4840aadd9676e68e5210876df185","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final EJBClientContext clientContext = EJBClientContext.create();\n        // register the default local EJB receiver\n        clientContext.registerEJBReceiver(this.defaultLocalEJBReceiver.getValue());\n        this.context = clientContext;\n        if (this.lockSelectorOnStart) {\n            // lock the EJB client context selector\n            AccessController.doPrivileged(new LockSelectorAction());\n        }\n\n        // the EJBClientContext selector is set to TCCLEJBClientContextSelector and is *locked* once\n        // (in a static block of this service) so that restarting this service will not cause failures related\n        // to resetting the selector. The TCCLEJBClientContextSelector is backed by a TCCLEJBClientContextSelectorService\n        // which is what we set here during the service start, so that the selector has the correct service to return the\n        // EJBClientContext. @see https://issues.jboss.org/browse/AS7-2998 for details\n        TCCLEJBClientContextSelector.INSTANCE.setTCCLEJBClientContextService(this.tcclEJBClientContextSelector.getValue());\n\n    }","id":72110,"modified_method":"@Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final EJBClientContext clientContext = EJBClientContext.create();\n        // register the default local EJB receiver (if present - app clients don't have local EJB receivers)\n        final LocalEjbReceiver localEjbReceiver = this.defaultLocalEJBReceiver.getOptionalValue();\n        if (localEjbReceiver != null) {\n            clientContext.registerEJBReceiver(localEjbReceiver);\n        }\n        this.context = clientContext;\n        if (this.lockSelectorOnStart) {\n            // lock the EJB client context selector\n            AccessController.doPrivileged(new LockSelectorAction());\n        }\n\n        // the EJBClientContext selector is set to TCCLEJBClientContextSelector and is *locked* once\n        // (in a static block of this service) so that restarting this service will not cause failures related\n        // to resetting the selector. The TCCLEJBClientContextSelector is backed by a TCCLEJBClientContextSelectorService\n        // which is what we set here during the service start, so that the selector has the correct service to return the\n        // EJBClientContext. @see https://issues.jboss.org/browse/AS7-2998 for details\n        TCCLEJBClientContextSelector.INSTANCE.setTCCLEJBClientContextService(this.tcclEJBClientContextSelector.getValue());\n\n    }","commit_id":"a562784d3362f4ab50adf2fef325c654865f1e12","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected Collection<HighlightInfo> doHighlighting() {\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    Document document = myEditor.getDocument();\n    GeneralHighlightingPass action1 = new GeneralHighlightingPass(myProject, myFile, document, 0, myFile.getTextLength(), false, true);\n    action1.doCollectInformation(new MockProgressInidicator());\n    Collection<HighlightInfo> highlights1 = action1.getHighlights();\n\n    PostHighlightingPass action2 = new PostHighlightingPass(myProject, myFile, myEditor, 0, myFile.getTextLength(), false);\n    action2.doCollectInformation(new MockProgressInidicator());\n    Collection<HighlightInfo> highlights2 = action2.getHighlights();\n    \n    Collection<HighlightInfo> highlights3 = null;\n    \n    if (doInspections()) {\n      LocalInspectionsPass inspectionsPass = new LocalInspectionsPass(myProject, myFile, myEditor.getDocument(), 0, myFile.getTextLength());\n      inspectionsPass.doCollectInformation(new MockProgressInidicator());\n      highlights3 = inspectionsPass.getHighlights();\n    }\n\n    ArrayList<HighlightInfo> list = new ArrayList<HighlightInfo>();\n    for (HighlightInfo info : highlights1) {\n      list.add(info);\n    }\n\n    for (HighlightInfo info : highlights2) {\n      list.add(info);\n    }\n    \n    if (highlights3 != null) {\n      for (HighlightInfo info : highlights3) {\n        list.add(info);\n      }\n    }\n\n    boolean isToLaunchExternal = true;\n    for (HighlightInfo info : list) {\n      if (info.getSeverity() == HighlightSeverity.ERROR) {\n        isToLaunchExternal = false;\n        break;\n      }\n    }\n\n    if (isToLaunchExternal) {\n      ExternalToolPass action3 = new ExternalToolPass(myFile, myEditor);\n      action3.doCollectInformation(new MockProgressInidicator());\n\n      highlights3 = action3.getHighlights();\n      for (HighlightInfo info : highlights3) {\n        list.add(info);\n      }\n    }\n\n\n    return list;\n  }","id":72111,"modified_method":"protected Collection<HighlightInfo> doHighlighting() {\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    Document document = myEditor.getDocument();\n    GeneralHighlightingPass action1 = new GeneralHighlightingPass(myProject, myFile, document, 0, myFile.getTextLength(), false, true);\n    action1.doCollectInformation(new MockProgressInidicator());\n    Collection<HighlightInfo> highlights1 = action1.getHighlights();\n\n    PostHighlightingPass action2 = new PostHighlightingPass(myProject, myFile, myEditor, 0, myFile.getTextLength(), false);\n    action2.doCollectInformation(new MockProgressInidicator());\n    Collection<HighlightInfo> highlights2 = action2.getHighlights();\n    \n    Collection<HighlightInfo> highlights3 = null;\n    \n    if (doInspections()) {\n      LocalInspectionsPass inspectionsPass = new LocalInspectionsPass(myProject, myFile, myEditor.getDocument(), 0, myFile.getTextLength());\n      inspectionsPass.doCollectInformation(new MockProgressInidicator());\n      highlights3 = inspectionsPass.getHighlights();\n    }\n\n    ArrayList<HighlightInfo> list = new ArrayList<HighlightInfo>();\n    for (HighlightInfo info : highlights1) {\n      list.add(info);\n    }\n\n    for (HighlightInfo info : highlights2) {\n      list.add(info);\n    }\n    \n    if (highlights3 != null) {\n      for (HighlightInfo info : highlights3) {\n        list.add(info);\n      }\n    }\n\n    boolean isToLaunchExternal = true;\n    for (HighlightInfo info : list) {\n      if (info.getSeverity() == HighlightSeverity.ERROR) {\n        isToLaunchExternal = false;\n        break;\n      }\n    }\n\n    if (isToLaunchExternal && doExternalValidation()) {\n      ExternalToolPass action3 = new ExternalToolPass(myFile, myEditor);\n      action3.doCollectInformation(new MockProgressInidicator());\n\n      highlights3 = action3.getHighlights();\n      for (HighlightInfo info : highlights3) {\n        list.add(info);\n      }\n    }\n\n\n    return list;\n  }","commit_id":"351af0d4afd36c2a3f39acdc2b0cb6f3c1f969e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] get(final PsiElement context, CompletionContext completionContext) {\n      final XmlTag parentOfType = PsiTreeUtil.getParentOfType(context, XmlTag.class);\n      if (parentOfType != null) {\n        final XmlElementDescriptor descriptor = parentOfType.getDescriptor();\n        final List<String> results = new ArrayList<String>();\n\n        if (descriptor != null) {\n          final XmlNSDescriptor nsDescriptor = descriptor.getNSDescriptor();\n          final XmlFile descriptorFile = nsDescriptor != null ? nsDescriptor.getDescriptorFile():null;\n\n          if (descriptorFile != null) {\n            final PsiElementProcessor processor = new PsiElementProcessor() {\n              public boolean execute(final PsiElement element) {\n                if (element instanceof XmlEntityDecl) {\n                  final XmlEntityDecl xmlEntityDecl = (XmlEntityDecl)element;\n                  if (xmlEntityDecl.isInternalReference()) results.add(xmlEntityDecl.getName());\n                }\n                return true;\n              }\n            };\n  \n            XmlUtil.processXmlElements(\n              descriptorFile,\n              processor,\n              true\n            );\n  \n            return results.toArray(new Object[results.size()]);\n          }\n        }\n      }\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }","id":72112,"modified_method":"public Object[] get(final PsiElement context, CompletionContext completionContext) {\n      final XmlTag parentOfType = PsiTreeUtil.getParentOfType(context, XmlTag.class);\n      if (parentOfType != null) {\n        final XmlElementDescriptor descriptor = parentOfType.getDescriptor();\n        final List<String> results = new ArrayList<String>();\n\n        final XmlNSDescriptor nsDescriptor = descriptor != null ? descriptor.getNSDescriptor():null;\n        final XmlFile containingFile = (XmlFile)parentOfType.getContainingFile();\n        XmlFile descriptorFile = nsDescriptor != null ?\n                                       nsDescriptor.getDescriptorFile():\n                                       containingFile.getDocument().getProlog().getDoctype() != null ? containingFile:null;\n        if (nsDescriptor != null && descriptorFile.getName().equals(containingFile.getName() + \".dtd\")) {\n          descriptorFile = containingFile;\n        }\n\n        if (descriptorFile != null) {\n          final PsiElementProcessor processor = new PsiElementProcessor() {\n            public boolean execute(final PsiElement element) {\n              if (element instanceof XmlEntityDecl) {\n                final XmlEntityDecl xmlEntityDecl = (XmlEntityDecl)element;\n                if (xmlEntityDecl.isInternalReference()) results.add(xmlEntityDecl.getName());\n              }\n              return true;\n            }\n          };\n\n          XmlUtil.processXmlElements(\n            descriptorFile,\n            processor,\n            true\n          );\n\n          return results.toArray(new Object[results.size()]);\n        }\n      }\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }","commit_id":"351af0d4afd36c2a3f39acdc2b0cb6f3c1f969e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private XmlNSDescriptor getNsDescriptorFormDocType(final XmlDoctype doctype, final XmlFile containingFile) {\n    XmlNSDescriptor descr = null;\n    if (doctype.getMarkupDecl() != null){\n      descr = (XmlNSDescriptor)doctype.getMarkupDecl().getMetaData();\n    }\n    if (doctype.getDtdUri() != null){\n      final XmlFile xmlFile = XmlUtil.findXmlFile(containingFile, doctype.getDtdUri());\n      final XmlNSDescriptor descr1 = xmlFile == null ? null : (XmlNSDescriptor)xmlFile.getDocument().getMetaData();\n      if (descr != null && descr1 != null){\n        descr = new XmlNSDescriptorSequence(new XmlNSDescriptor[]{descr, descr1});\n      }\n      else if (descr1 != null) {\n        descr = descr1;\n      }\n    }\n    return descr;\n  }","id":72113,"modified_method":"private XmlNSDescriptor getNsDescriptorFormDocType(final XmlDoctype doctype, final XmlFile containingFile) {\n    XmlNSDescriptor descr = null;\n    if (doctype.getMarkupDecl() != null){\n      descr = (XmlNSDescriptor)doctype.getMarkupDecl().getMetaData();\n      final XmlElementDescriptor[] rootElementsDescriptors = descr.getRootElementsDescriptors(this);\n      if (rootElementsDescriptors.length == 0) descr = null;\n    }\n    \n    if (doctype.getDtdUri() != null){\n      final XmlFile xmlFile = XmlUtil.findXmlFile(containingFile, doctype.getDtdUri());\n      final XmlNSDescriptor descr1 = xmlFile == null ? null : (XmlNSDescriptor)xmlFile.getDocument().getMetaData();\n      if (descr != null && descr1 != null){\n        descr = new XmlNSDescriptorSequence(new XmlNSDescriptor[]{descr, descr1});\n      }\n      else if (descr1 != null) {\n        descr = descr1;\n      }\n    }\n    return descr;\n  }","commit_id":"351af0d4afd36c2a3f39acdc2b0cb6f3c1f969e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] get(final PsiElement context, CompletionContext completionContext) {\n      final XmlTag parentOfType = PsiTreeUtil.getParentOfType(context, XmlTag.class);\n      if (parentOfType != null) {\n        final XmlElementDescriptor descriptor = parentOfType.getDescriptor();\n        final List<String> results = new ArrayList<String>();\n\n        if (descriptor != null) {\n          final XmlFile descriptorFile = descriptor.getNSDescriptor().getDescriptorFile();\n\n          // skip content of embedded dtd, its content will be inserted by word completion\n          if (descriptorFile != null && !descriptorFile.equals(parentOfType.getContainingFile())) {\n            final PsiElementProcessor processor = new PsiElementProcessor() {\n              public boolean execute(final PsiElement element) {\n                if (element instanceof XmlEntityDecl) {\n                  final XmlEntityDecl xmlEntityDecl = (XmlEntityDecl)element;\n                  if (xmlEntityDecl.isInternalReference()) results.add(xmlEntityDecl.getName());\n                }\n                return true;\n              }\n            };\n  \n            XmlUtil.processXmlElements(\n              descriptorFile,\n              processor,\n              true\n            );\n  \n            return results.toArray(new Object[results.size()]);\n          }\n        }\n      }\n      return new Object[0];\n    }","id":72114,"modified_method":"public Object[] get(final PsiElement context, CompletionContext completionContext) {\n      final XmlTag parentOfType = PsiTreeUtil.getParentOfType(context, XmlTag.class);\n      if (parentOfType != null) {\n        final XmlElementDescriptor descriptor = parentOfType.getDescriptor();\n        final List<String> results = new ArrayList<String>();\n\n        if (descriptor != null) {\n          final XmlNSDescriptor nsDescriptor = descriptor.getNSDescriptor();\n          final XmlFile descriptorFile = nsDescriptor != null ? nsDescriptor.getDescriptorFile():null;\n\n          // skip content of embedded dtd, its content will be inserted by word completion\n          if (descriptorFile != null && !descriptorFile.equals(parentOfType.getContainingFile())) {\n            final PsiElementProcessor processor = new PsiElementProcessor() {\n              public boolean execute(final PsiElement element) {\n                if (element instanceof XmlEntityDecl) {\n                  final XmlEntityDecl xmlEntityDecl = (XmlEntityDecl)element;\n                  if (xmlEntityDecl.isInternalReference()) results.add(xmlEntityDecl.getName());\n                }\n                return true;\n              }\n            };\n  \n            XmlUtil.processXmlElements(\n              descriptorFile,\n              processor,\n              true\n            );\n  \n            return results.toArray(new Object[results.size()]);\n          }\n        }\n      }\n      return new Object[0];\n    }","commit_id":"7c8cb2722df17521db9df640b9fd467d0a5a4e58","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean moveTags(MoveInfo info, XmlTag moved, XmlTag target, boolean down) {\n    if (target.getParent() == moved) {\n      // we are going to jump into our own children\n      // this can mean that target computed incorrectly\n      XmlTag next = down ? PsiTreeUtil.getNextSiblingOfType(moved, XmlTag.class) :\n                           PsiTreeUtil.getPrevSiblingOfType(moved, XmlTag.class);\n      if (next == null) return info.prohibitMove();\n      info.toMove = new LineRange(moved);\n      info.toMove2 = new LineRange(next);\n      return true;\n    }\n    else if (moved.getParent() == target) {\n      return false;\n    }\n\n    LineRange targetRange = new LineRange(target);\n    if (targetRange.contains(info.toMove2)) {\n      // we are going to jump into sibling tag\n      XmlElementDescriptor descriptor = moved.getDescriptor();\n      if (descriptor == null) return false;\n      XmlFile descriptorFile = descriptor.getNSDescriptor().getDescriptorFile();\n      if (descriptorFile == null || XmlDocumentImpl.isAutoGeneratedSchema(descriptorFile)) return false;\n      if (!TagNameReference.couldContain(target, moved)) {\n        info.toMove = new LineRange(moved);\n        info.toMove2 = targetRange;\n        return true;\n      }\n    }\n\n    return false;\n  }","id":72115,"modified_method":"private static boolean moveTags(MoveInfo info, XmlTag moved, XmlTag target, boolean down) {\n    if (target.getParent() == moved) {\n      // we are going to jump into our own children\n      // this can mean that target computed incorrectly\n      XmlTag next = down ? PsiTreeUtil.getNextSiblingOfType(moved, XmlTag.class) :\n                           PsiTreeUtil.getPrevSiblingOfType(moved, XmlTag.class);\n      if (next == null) return info.prohibitMove();\n      info.toMove = new LineRange(moved);\n      info.toMove2 = new LineRange(next);\n      return true;\n    }\n    else if (moved.getParent() == target) {\n      return false;\n    }\n\n    LineRange targetRange = new LineRange(target);\n    if (targetRange.contains(info.toMove2)) {\n      // we are going to jump into sibling tag\n      XmlElementDescriptor descriptor = moved.getDescriptor();\n      if (descriptor == null) return false;\n      XmlNSDescriptor nsDescriptor = descriptor.getNSDescriptor();\n      if (nsDescriptor == null) return false;\n      XmlFile descriptorFile = nsDescriptor.getDescriptorFile();\n      if (descriptorFile == null || XmlDocumentImpl.isAutoGeneratedSchema(descriptorFile)) return false;\n      if (!TagNameReference.couldContain(target, moved)) {\n        info.toMove = new LineRange(moved);\n        info.toMove2 = targetRange;\n        return true;\n      }\n    }\n\n    return false;\n  }","commit_id":"09be802d0b52b39027a9f20e08a90087d3634392","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CachedMethodResult\n   public String getProjectUrl(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION\n            || activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         return projectUrl(version.getProject().getSlug());\n      }\n      return \"\";\n   }","id":72116,"modified_method":"@CachedMethodResult\n   public String getProjectUrl(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n\n      if (isTranslationUpdateActivity(activity.getActionType())\n            || activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         return urlUtil.projectUrl(version.getProject().getSlug());\n      }\n      return \"\";\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getDocumentUrl(Activity activity)\n   {\n      String url = \"\";\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n\n         url = editorDocumentUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(),\n               tft.getTextFlow().getLocale(), tft.getTextFlow().getDocument().getDocId());\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n\n         url = editorDocumentUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(),\n               document.getSourceLocaleId(), tft.getTextFlow().getDocument().getDocId());\n      }\n      return url;\n   }","id":72117,"modified_method":"@CachedMethodResult\n   public String getDocumentUrl(Activity activity)\n   {\n      String url = \"\";\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n\n      if (isTranslationUpdateActivity(activity.getActionType()))\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n\n         url = urlUtil.editorDocumentUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(),\n               tft.getTextFlow().getLocale(), tft.getTextFlow().getDocument().getDocId());\n      }\n      else if(activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         url = urlUtil.sourceFilesUrl(version.getProject().getSlug(), version.getSlug());\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n\n         url = urlUtil.editorDocumentUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(),\n               document.getSourceLocaleId(), tft.getTextFlow().getDocument().getDocId());\n      }\n      return url;\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getTrimmedContent(Activity activity)\n   {\n      String wrappedContent = \"\";\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION)\n      {\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n         wrappedContent = tft.getContents().get(0);\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n         wrappedContent = tft.getContents().get(0);\n      }\n\n      return trimString(wrappedContent);\n   }","id":72118,"modified_method":"@CachedMethodResult\n   public String getTrimmedContent(Activity activity)\n   {\n      String wrappedContent = \"\";\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n\n      if (isTranslationUpdateActivity(activity.getActionType()))\n      {\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n         wrappedContent = tft.getContents().get(0);\n      }\n      else if(activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT)\n      {\n         //not supported for upload source action\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n         wrappedContent = tft.getContents().get(0);\n      }\n\n      return trimString(wrappedContent);\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getVersionUrl(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      String url = \"\";\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION\n            || activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         url = versionUrl(version.getProject().getSlug(), version.getSlug());\n      }\n\n      return url;\n   }","id":72119,"modified_method":"@CachedMethodResult\n   public String getVersionUrl(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      String url = \"\";\n\n      if (isTranslationUpdateActivity(activity.getActionType())\n            || activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         url = urlUtil.versionUrl(version.getProject().getSlug(), version.getSlug());\n      }\n\n      return url;\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getVersionName(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      String name = \"\";\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION\n            || activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         name = version.getSlug();\n      }\n\n      return name;\n   }","id":72120,"modified_method":"@CachedMethodResult\n   public String getVersionName(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      String name = \"\";\n\n      if (isTranslationUpdateActivity(activity.getActionType())\n            || activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         name = version.getSlug();\n      }\n      return name;\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getLanguageName(Activity activity)\n   {\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n      String name = \"\";\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION)\n      {\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n         name = tft.getLocaleId().getId();\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n         name = tft.getLocaleId().getId();\n      }\n\n      return name;\n   }","id":72121,"modified_method":"@CachedMethodResult\n   public String getLanguageName(Activity activity)\n   {\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n      String name = \"\";\n\n      if (isTranslationUpdateActivity(activity.getActionType()))\n      {\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n         name = tft.getLocaleId().getId();\n      }\n      else if(activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT)\n      {\n         // not supported for upload source action\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n         name = tft.getLocaleId().getId();\n      }\n\n      return name;\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getProjectName(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION\n            || activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         return version.getProject().getName();\n      }\n      return \"\";\n   }","id":72122,"modified_method":"@CachedMethodResult\n   public String getProjectName(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n\n      if (isTranslationUpdateActivity(activity.getActionType())\n            || activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         return version.getProject().getName();\n      }\n      return \"\";\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getLanguageUrl(Activity activity)\n   {\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n      String url = \"\";\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION)\n      {\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n         url = languageUrl(tft.getLocaleId());\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n         url = languageUrl(tft.getLocaleId());\n      }\n\n      return url;\n   }","id":72123,"modified_method":"@CachedMethodResult\n   public String getDocumentListUrl(Activity activity)\n   {\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n      String url = \"\";\n\n      if (isTranslationUpdateActivity(activity.getActionType()))\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n         \n         url = urlUtil.editorDocumentListUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(), tft.getTextFlow().getLocale());\n      }\n      else if(activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT)\n      {\n         // not supported for upload source action\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n         \n         url = urlUtil.editorDocumentListUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(), tft.getTextFlow().getLocale());\n      }\n      return url;\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getDocumentName(Activity activity)\n   {\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n      String docName = \"\";\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION)\n      {\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n         docName = tft.getTextFlow().getDocument().getName();\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HDocument document = (HDocument) lastTarget;\n         docName = document.getName();\n      }\n      return docName;\n   }","id":72124,"modified_method":"@CachedMethodResult\n   public String getDocumentName(Activity activity)\n   {\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n      String docName = \"\";\n\n      if (isTranslationUpdateActivity(activity.getActionType()))\n      {\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n         docName = tft.getTextFlow().getDocument().getName();\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HDocument document = (HDocument) lastTarget;\n         docName = document.getName();\n      }\n      return docName;\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@CachedMethodResult\n   public String getEditorUrl(Activity activity)\n   {\n      String url = \"\";\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n\n      if (activity.getActionType() == ActivityType.UPDATE_TRANSLATION\n            || activity.getActionType() == ActivityType.REVIEWED_TRANSLATION)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n\n         url = editorTransUnitUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(),\n               tft.getTextFlow().getLocale(), tft.getTextFlow().getDocument().getDocId(), tft.getTextFlow().getId());\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT\n            || activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n\n         url = editorTransUnitUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(),\n               document.getSourceLocaleId(), tft.getTextFlow().getDocument().getDocId(), tft.getTextFlow().getId());\n      }\n\n      return url;\n   }","id":72125,"modified_method":"@CachedMethodResult\n   public String getEditorUrl(Activity activity)\n   {\n      String url = \"\";\n      Object context = getEntity(activity.getContextType(), activity.getContextId());\n      Object lastTarget = getEntity(activity.getLastTargetType(), activity.getLastTargetId());\n\n      if (isTranslationUpdateActivity(activity.getActionType()))\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HTextFlowTarget tft = (HTextFlowTarget) lastTarget;\n\n         url = urlUtil.editorTransUnitUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(),\n               tft.getTextFlow().getLocale(), tft.getTextFlow().getDocument().getDocId(), tft.getTextFlow().getId());\n      }\n      else if(activity.getActionType() == ActivityType.UPLOAD_SOURCE_DOCUMENT)\n      {\n         // not supported for upload source action\n      }\n      else if (activity.getActionType() == ActivityType.UPLOAD_TRANSLATION_DOCUMENT)\n      {\n         HProjectIteration version = (HProjectIteration) context;\n         HDocument document = (HDocument) lastTarget;\n         HTextFlowTarget tft = documentDAO.getLastTranslatedTarget(document.getId());\n\n         url = urlUtil.editorTransUnitUrl(version.getProject().getSlug(), version.getSlug(), tft.getLocaleId(),\n               document.getSourceLocaleId(), tft.getTextFlow().getDocument().getDocId(), tft.getTextFlow().getId());\n      }\n      \n\n      return url;\n   }","commit_id":"4579297f16584480878a0e2f8d52ec35d2cd3ff3","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Set<SModelDescriptor> getImplicitlyImportedModelsFor(SModelDescriptor sm) {\n    Set<SModelDescriptor> result = new LinkedHashSet<SModelDescriptor>(super.getImplicitlyImportedModelsFor(sm));\n    result.add(getSourceLanguage().getStructureModelDescriptor());\n    if (getSourceLanguage().getConstraintsModelDescriptor() != null) {\n      result.add(getSourceLanguage().getConstraintsModelDescriptor());\n    }\n\n    for (Language langauge : getSourceLanguage().getExtendedLanguages()) {\n      result.add(langauge.getStructureModelDescriptor());\n      if (langauge.getConstraintsModelDescriptor() != null) {\n        result.add(langauge.getConstraintsModelDescriptor());\n      }\n    }\n\n    for (Language language : sm.getSModel().getLanguages(getScope())) {\n      result.add(language.getStructureModelDescriptor());\n    }\n\n    return result;\n  }","id":72126,"modified_method":"public Set<SModelDescriptor> getImplicitlyImportedModelsFor(SModelDescriptor sm) {\n    Set<SModelDescriptor> result = new LinkedHashSet<SModelDescriptor>(super.getImplicitlyImportedModelsFor(sm));\n    result.add(getSourceLanguage().getStructureModelDescriptor());\n    if (getSourceLanguage().getConstraintsModelDescriptor() != null) {\n      result.add(getSourceLanguage().getConstraintsModelDescriptor());\n    }\n\n    for (Language langauge : getSourceLanguage().getExtendedLanguages()) {\n      SModelDescriptor structure = langauge.getStructureModelDescriptor();\n      if (structure != null) {\n        result.add(structure);\n      }\n      if (langauge.getConstraintsModelDescriptor() != null) {\n        result.add(langauge.getConstraintsModelDescriptor());\n      }\n    }\n\n    for (Language language : sm.getSModel().getLanguages(getScope())) {\n      if (language.getStructureModelDescriptor() != null) {\n        result.add(language.getStructureModelDescriptor());\n      }\n    }\n\n    return result;\n  }","commit_id":"29f44495330f88e163d191543efa769d3a1b6f24","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SConcept getConcept(String id) {\n    synchronized (myConcepts) {\n      if (!myConcepts.containsKey(id)) {\n        String langName = NameUtil.namespaceFromConceptFQName(id);\n        IModule module = MPSModuleRepository.getInstance().getModuleByFqName(langName);\n        if (!(module instanceof Language)) {\n          LOG.error(\"Can't find language for concept \" + id, new Throwable());\n        } else {\n          Language lang = (Language) module;\n          SModel strucModel = lang.getStructureModelDescriptor().getSModel();\n          for (SNode root : strucModel.roots()) {\n            myConcepts.put(id, new SConceptNodeAdapter(langName + \".\" + root.getProperty(SNodeUtil.property_INamedConcept_name)));\n          }\n\n          SConcept concept = myConcepts.get(id);\n          if (concept == null) {\n            LOG.error(\"Creating a concept descriptor for a concept not yet loaded \" + id, new Throwable());\n          }\n        }\n        myConcepts.put(id, new SConceptNodeAdapter(id));\n      }\n      return myConcepts.get(id);\n    }\n  }","id":72127,"modified_method":"public SConcept getConcept(String id) {\n    synchronized (myConcepts) {\n      if (!myConcepts.containsKey(id)) {\n        String langName = NameUtil.namespaceFromConceptFQName(id);\n        IModule module = MPSModuleRepository.getInstance().getModuleByFqName(langName);\n        if (!(module instanceof Language)) {\n          assert myConcepts.get(id) == null : \"trying to add the second descriptor of a concept\";\n          myConcepts.put(id, new SConceptNodeAdapter(id));\n        } else {\n          Language lang = (Language) module;\n          SModelDescriptor smd = lang.getStructureModelDescriptor();\n          if (smd == null) {\n            assert myConcepts.get(id) == null : \"trying to add the second descriptor of a concept\";\n            SConceptNodeAdapter adapter = new SConceptNodeAdapter(id);\n            myConcepts.put(id, adapter);\n            return adapter;\n          }\n\n          SModel sm = smd.getSModel();\n          for (SNode root : sm.roots()) {\n            //do not change existing concept descriptor (required for == correctness)\n            if (myConcepts.get(id) != null) continue;\n\n            myConcepts.put(id, new SConceptNodeAdapter(langName + \".\" + root.getProperty(SNodeUtil.property_INamedConcept_name)));\n          }\n\n          SConcept concept = myConcepts.get(id);\n          if (concept == null) {\n            LOG.error(\"Creating a concept descriptor for a concept not yet loaded \" + id, new Throwable());\n          }\n        }\n        myConcepts.put(id, new SConceptNodeAdapter(id));\n      }\n      return myConcepts.get(id);\n    }\n  }","commit_id":"6e49e757239ad5e5e74f30a6691736dd127e8eed","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void addBuiltInImports() {\n    SLanguage base = MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L), \"jetbrains.mps.console.base\");\n    Collection<SLanguage> baseAndExtensions = new SLanguageHierarchy(LanguageRegistry.getInstance(myProject.getRepository()), Collections.singleton(base)).getExtending();\n    SModelInternal modelInternal = ((SModelInternal) myModel);\n    for (SLanguage l : CollectionSequence.fromCollection(baseAndExtensions)) {\n      modelInternal.addLanguage(l);\n      Language sourceLangModule = (Language) l.getSourceModule();\n      if (sourceLangModule == null) {\n        continue;\n      }\n      modelInternal.addModelImport(sourceLangModule.getStructureModelDescriptor().getReference(), false);\n      ((AbstractModule) myModel.getModule()).addDependency(sourceLangModule.getModuleReference(), false);\n    }\n    modelInternal.addDevKit(PersistenceFacade.getInstance().createModuleReference(\"fbc25dd2-5da4-483a-8b19-70928e1b62d7(jetbrains.mps.devkit.general-purpose)\"));\n  }","id":72128,"modified_method":"protected void addBuiltInImports() {\n    SLanguage base = MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L), \"jetbrains.mps.console.base\");\n    Collection<SLanguage> baseAndExtensions = new SLanguageHierarchy(LanguageRegistry.getInstance(myProject.getRepository()), Collections.singleton(base)).getExtending();\n    SModelInternal modelInternal = ((SModelInternal) myModel);\n    for (SLanguage l : CollectionSequence.fromCollection(baseAndExtensions)) {\n      modelInternal.addLanguage(l);\n      Language sourceLangModule = (Language) l.getSourceModule();\n      if (sourceLangModule == null) {\n        continue;\n      }\n      SModel structureModel = sourceLangModule.getStructureModelDescriptor();\n      if (structureModel == null) {\n        continue;\n      }\n      modelInternal.addModelImport(structureModel.getReference(), false);\n      ((AbstractModule) myModel.getModule()).addDependency(sourceLangModule.getModuleReference(), false);\n    }\n    modelInternal.addDevKit(PersistenceFacade.getInstance().createModuleReference(\"fbc25dd2-5da4-483a-8b19-70928e1b62d7(jetbrains.mps.devkit.general-purpose)\"));\n  }","commit_id":"ced47d2ee9428526727afc4630587bf0fcba7ca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n    public void testWSA() throws Exception {\n        env.put(ToolConstants.CFG_OUTPUTFILE, output.getPath() + \"/add_numbers.wsdl\");\n        env.put(ToolConstants.CFG_CLASSNAME, \"org.apache.cxf.tools.fortest.AddNumbersImpl\");\n        env.put(ToolConstants.CFG_VERBOSE, ToolConstants.CFG_VERBOSE);\n        try {\n            processor.setEnvironment(env);\n            processor.process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        File wsdlFile = new File(output, \"add_numbers.wsdl\");\n        assertTrue(\"Generate Wsdl Fail\", wsdlFile.exists());\n        URI expectedFile = getClass().getResource(\"expected/add_numbers_expected.wsdl\").toURI();\n        assertWsdlEquals(new File(expectedFile), wsdlFile);\n    }","id":72129,"modified_method":"@Test\n    public void testWSA() throws Exception {\n        env.put(ToolConstants.CFG_OUTPUTFILE, output.getPath() + \"/add_numbers.wsdl\");\n        env.put(ToolConstants.CFG_CLASSNAME, \"org.apache.cxf.tools.fortest.AddNumbersImpl\");\n        env.put(ToolConstants.CFG_VERBOSE, ToolConstants.CFG_VERBOSE);\n        try {\n            processor.setEnvironment(env);\n            processor.process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        File wsdlFile = new File(output, \"add_numbers.wsdl\");\n        assertTrue(\"Generate Wsdl Fail\", wsdlFile.exists());\n        //To test there is wsam:action generated for the \n        String wsdlString = getStringFromFile(wsdlFile);\n        assertTrue(\"The wsaAction is not generated for NOActionAnotation method\", wsdlString\n            .indexOf(\"http://fortest.tools.cxf.apache.org/AddNumbersImpl/addNumbers2Request\") > -1);\n        assertTrue(\"The wsaAction is not generated for NOActionAnotation method\", wsdlString\n            .indexOf(\"http://fortest.tools.cxf.apache.org/AddNumbersImpl/addNumbers2Response\") > -1);\n        URI expectedFile = getClass().getResource(\"expected/add_numbers_expected.wsdl\").toURI();\n        assertWsdlEquals(new File(expectedFile), wsdlFile);\n    }","commit_id":"9c56f0f05043d114429906c6868b2acb626f9f18","url":"https://github.com/apache/cxf"},{"original_method":"private void buildWSAActions(OperationInfo operation, Method method) {\n        //nothing\n        if (method == null) {\n            return;\n        }\n\n        Action action = method.getAnnotation(Action.class);\n        if (action == null) {\n            return;\n        }\n        MessageInfo input = operation.getInput();\n        if (!StringUtils.isEmpty(action.input())) {\n            input.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, action.input());\n            input.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, action.input());\n        } else {\n            input.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, \n                                        computeAction(operation, \"Request\"));\n        }\n        \n        MessageInfo output = operation.getOutput();\n        if (output != null && !StringUtils.isEmpty(action.output())) {\n            output.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, action.output());\n            output.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, action.output());\n        } else if (output != null) {\n            output.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, \n                                         computeAction(operation, \"Response\"));            \n        }\n        \n        FaultAction[] faultActions = action.fault();\n        if (faultActions != null \n            && faultActions.length > 0 \n            && operation.getFaults() != null) {\n            for (FaultAction faultAction : faultActions) {                \n                FaultInfo faultInfo = getFaultInfo(operation, faultAction.className());\n                faultInfo.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, \n                                                faultAction.value());\n                faultInfo.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, \n                                                faultAction.value());\n                if (operation.isUnwrappedCapable()) {\n                    faultInfo = getFaultInfo(operation.getUnwrappedOperation(), faultAction.className());\n                    faultInfo.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, \n                                                    faultAction.value());\n                    faultInfo.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, \n                                                    faultAction.value());\n                }\n            }\n        } \n        for (FaultInfo fi : operation.getFaults()) {\n            if (fi.getExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME) == null) {\n                String f = \"/Fault/\" + fi.getName().getLocalPart();\n                fi.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, \n                                         computeAction(operation, f));\n                if (operation.isUnwrappedCapable()) {\n                    fi = operation.getUnwrappedOperation().getFault(fi.getName());\n                    fi.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, \n                                             computeAction(operation, f));\n                }                \n            }\n        }\n    }","id":72130,"modified_method":"private void buildWSAActions(OperationInfo operation, Method method) {\n        //nothing\n        if (method == null) {\n            return;\n        }\n\n        Action action = method.getAnnotation(Action.class);\n        Addressing addressing = method.getDeclaringClass().getAnnotation(Addressing.class);\n        if (action == null && addressing == null) {\n            return;\n        }\n        if (action == null && addressing != null) {\n            operation.getInput().addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                                       computeAction(operation, \"Request\"));\n            operation.getOutput().addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                                       computeAction(operation, \"Response\"));\n\n        } else {\n            MessageInfo input = operation.getInput();\n            if (!StringUtils.isEmpty(action.input())) {\n                input.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, action.input());\n            } else {\n                input.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, computeAction(operation,\n                                                                                             \"Request\"));\n            }\n\n            MessageInfo output = operation.getOutput();\n            if (output != null && !StringUtils.isEmpty(action.output())) {\n                output.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, action.output());\n            } else if (output != null) {\n                output.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, computeAction(operation,\n                                                                                              \"Response\"));\n            }\n\n            FaultAction[] faultActions = action.fault();\n            if (faultActions != null && faultActions.length > 0 && operation.getFaults() != null) {\n                for (FaultAction faultAction : faultActions) {\n                    FaultInfo faultInfo = getFaultInfo(operation, faultAction.className());\n                    faultInfo.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, faultAction.value());\n                    faultInfo.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, faultAction.value());\n                    if (operation.isUnwrappedCapable()) {\n                        faultInfo = getFaultInfo(operation.getUnwrappedOperation(), faultAction.className());\n                        faultInfo.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, faultAction\n                            .value());\n                        faultInfo.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, faultAction\n                            .value());\n                    }\n                }\n            }\n        }\n        for (FaultInfo fi : operation.getFaults()) {\n            if (fi.getExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME) == null) {\n                String f = \"/Fault/\" + fi.getName().getLocalPart();\n                fi.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, \n                                         computeAction(operation, f));\n                if (operation.isUnwrappedCapable()) {\n                    fi = operation.getUnwrappedOperation().getFault(fi.getName());\n                    fi.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, \n                                             computeAction(operation, f));\n                }                \n            }\n        }\n    }","commit_id":"9c56f0f05043d114429906c6868b2acb626f9f18","url":"https://github.com/apache/cxf"},{"original_method":"private void buildWSAActions(OperationInfo operation, Method method) {\n        //nothing\n        if (method == null) {\n            return;\n        }\n\n        Action action = method.getAnnotation(Action.class);\n        Addressing addressing = method.getDeclaringClass().getAnnotation(Addressing.class);\n        if (action == null && addressing == null) {\n            return;\n        }\n        WebMethod wm = method.getAnnotation(WebMethod.class);\n        String inputAction = \"\";\n        if (action != null) {\n            inputAction = action.input();\n        }\n        if (wm != null && StringUtils.isEmpty(inputAction)) {\n            inputAction = wm.action();\n        }\n        if (StringUtils.isEmpty(inputAction)) {\n            inputAction = computeAction(operation, \"Request\");\n        }\n        if (action == null && addressing != null) {\n            operation.getInput().addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                                       inputAction);\n            operation.getInput().addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME,\n                                                       inputAction);\n            operation.getOutput().addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                                       computeAction(operation, \"Response\"));\n            operation.getOutput().addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME,\n                                                        computeAction(operation, \"Response\"));\n\n        } else {\n            MessageInfo input = operation.getInput();\n            input.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, inputAction);\n            if (!StringUtils.isEmpty(action.input())) {\n                input.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, inputAction);\n            }\n\n            MessageInfo output = operation.getOutput();\n            if (output != null && !StringUtils.isEmpty(action.output())) {\n                output.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, action.output());\n                output.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, action.output());\n            } else if (output != null) {\n                output.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, computeAction(operation,\n                                                                                              \"Response\"));\n            }\n\n            FaultAction[] faultActions = action.fault();\n            if (faultActions != null && faultActions.length > 0 && operation.getFaults() != null) {\n                for (FaultAction faultAction : faultActions) {\n                    FaultInfo faultInfo = getFaultInfo(operation, faultAction.className());\n                    if (!StringUtils.isEmpty(faultAction.value())) {\n                        faultInfo.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, faultAction\n                            .value());\n                        faultInfo.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, faultAction\n                            .value());\n                    }\n                    if (operation.isUnwrappedCapable()) {\n                        faultInfo = getFaultInfo(operation.getUnwrappedOperation(), faultAction.className());\n                        if (!StringUtils.isEmpty(faultAction.value())) {\n                            faultInfo.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, faultAction\n                                .value());\n                            faultInfo.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, faultAction\n                                .value());\n                        }\n                    }\n                }\n            }\n        }\n        for (FaultInfo fi : operation.getFaults()) {\n            if (fi.getExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME) == null) {\n                String f = \"/Fault/\" + fi.getName().getLocalPart();\n                fi.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                         computeAction(operation, f));\n                if (operation.isUnwrappedCapable()) {\n                    fi = operation.getUnwrappedOperation().getFault(fi.getName());\n                    fi.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                             computeAction(operation, f));\n                }\n            }\n        }\n    }","id":72131,"modified_method":"private void buildWSAActions(OperationInfo operation, Method method) {\n        //nothing\n        if (method == null) {\n            return;\n        }\n\n        Action action = method.getAnnotation(Action.class);\n        Addressing addressing = method.getDeclaringClass().getAnnotation(Addressing.class);\n        if (action == null && addressing == null) {\n            return;\n        }\n        WebMethod wm = method.getAnnotation(WebMethod.class);\n        String inputAction = \"\";\n        if (action != null) {\n            inputAction = action.input();\n        }\n        if (wm != null && StringUtils.isEmpty(inputAction)) {\n            inputAction = wm.action();\n        }\n        if (StringUtils.isEmpty(inputAction)) {\n            inputAction = computeAction(operation, \"Request\");\n        }\n        if (action == null && addressing != null) {\n            operation.getInput().addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                                       inputAction);\n            operation.getInput().addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME,\n                                                       inputAction);\n            if (operation.getOutput() != null) {\n                operation.getOutput().addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                                            computeAction(operation, \"Response\"));\n                operation.getOutput().addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME,\n                                                            computeAction(operation, \"Response\"));\n            }\n\n        } else {\n            MessageInfo input = operation.getInput();\n            input.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, inputAction);\n            if (!StringUtils.isEmpty(action.input())) {\n                input.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, inputAction);\n            }\n\n            MessageInfo output = operation.getOutput();\n            if (output != null && !StringUtils.isEmpty(action.output())) {\n                output.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, action.output());\n                output.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, action.output());\n            } else if (output != null) {\n                output.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, computeAction(operation,\n                                                                                              \"Response\"));\n            }\n\n            FaultAction[] faultActions = action.fault();\n            if (faultActions != null && faultActions.length > 0 && operation.getFaults() != null) {\n                for (FaultAction faultAction : faultActions) {\n                    FaultInfo faultInfo = getFaultInfo(operation, faultAction.className());\n                    if (!StringUtils.isEmpty(faultAction.value())) {\n                        faultInfo.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, faultAction\n                            .value());\n                        faultInfo.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, faultAction\n                            .value());\n                    }\n                    if (operation.isUnwrappedCapable()) {\n                        faultInfo = getFaultInfo(operation.getUnwrappedOperation(), faultAction.className());\n                        if (!StringUtils.isEmpty(faultAction.value())) {\n                            faultInfo.addExtensionAttribute(JAXWSAConstants.WSAW_ACTION_QNAME, faultAction\n                                .value());\n                            faultInfo.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME, faultAction\n                                .value());\n                        }\n                    }\n                }\n            }\n        }\n        for (FaultInfo fi : operation.getFaults()) {\n            if (fi.getExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME) == null) {\n                String f = \"/Fault/\" + fi.getName().getLocalPart();\n                fi.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                         computeAction(operation, f));\n                if (operation.isUnwrappedCapable()) {\n                    fi = operation.getUnwrappedOperation().getFault(fi.getName());\n                    fi.addExtensionAttribute(JAXWSAConstants.WSAM_ACTION_QNAME,\n                                             computeAction(operation, f));\n                }\n            }\n        }\n    }","commit_id":"7b78b8b49f5ee85231b9a966689f2fff9531782c","url":"https://github.com/apache/cxf"},{"original_method":"private void moveCaretInsideBracesIfAny() throws IncorrectOperationException {\n    int caretOffset = myEditor.getCaretModel().getOffset();\n    final CharSequence chars = myEditor.getDocument().getCharsSequence();\n    caretOffset = CharArrayUtil.shiftBackward(chars, caretOffset - 1, \" \\t\") + 1;\n    if (CharArrayUtil.regionMatches(chars, caretOffset - \"{}\".length(), \"{}\")) {\n      commit();\n      final CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(myProject);\n      final boolean old = settings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE;\n      settings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE = false;\n      PsiElement elt = PsiTreeUtil.getParentOfType(myPsiFile.findElementAt(caretOffset - 1), PsiCodeBlock.class);\n      reformat(elt);\n      settings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE = old;\n      myEditor.getCaretModel().moveToOffset(caretOffset - 1);\n    }\n  }","id":72132,"modified_method":"private void moveCaretInsideBracesIfAny() throws IncorrectOperationException {\n    int caretOffset = myEditor.getCaretModel().getOffset();\n    final CharSequence chars = myEditor.getDocument().getCharsSequence();\n    caretOffset = CharArrayUtil.shiftBackward(chars, caretOffset - 1, \" \\t\") + 1;\n    if (CharArrayUtil.regionMatches(chars, caretOffset - \"{}\".length(), \"{}\") ||\n        CharArrayUtil.regionMatches(chars, caretOffset - \"{\\n}\".length(), \"{\\n}\")) {\n      commit();\n      final CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(myProject);\n      final boolean old = settings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE;\n      settings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE = false;\n      PsiElement elt = PsiTreeUtil.getParentOfType(myPsiFile.findElementAt(caretOffset - 1), PsiCodeBlock.class);\n      reformat(elt);\n      settings.KEEP_SIMPLE_BLOCKS_IN_ONE_LINE = old;\n      myEditor.getCaretModel().moveToOffset(caretOffset - 1);\n    }\n  }","commit_id":"cf389f4fc1fcf0f567f7fc0894ee32a3f4ebf8b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void uncommentLine(int line) {\n    Commenter commenter = myCommenters[line - myStartLine];\n    if (commenter == null) commenter = findCommenter(line);\n    if (commenter == null) return;\n\n    final int startOffset = myStartOffsets[line - myStartLine];\n    final int endOffset = myEndOffsets[line - myStartLine];\n    if (startOffset == endOffset) {\n      return;\n    }\n    String prefix = commenter.getLineCommentPrefix();\n    if (prefix != null) {\n      CharSequence chars = myDocument.getCharsSequence();\n      assert CharArrayUtil.regionMatches(chars, startOffset, prefix);\n      int position = 0;//text.indexOf(prefix);\n      myDocument.deleteString(position + startOffset , position + startOffset + prefix.length());\n      return;\n    }\n    String text = myDocument.getCharsSequence().subSequence(startOffset, endOffset).toString();\n\n    prefix = commenter.getBlockCommentPrefix();\n    final String suffix = commenter.getBlockCommentSuffix();\n    if (prefix == null || suffix == null) {\n      return;\n    }\n\n    IntArrayList prefixes = new IntArrayList();\n    IntArrayList suffixes = new IntArrayList();\n    for (int position = 0; position < text.length();) {\n      int prefixPos = text.indexOf(prefix, position);\n      if (prefixPos == -1) {\n        break;\n      }\n      prefixes.add(prefixPos);\n      position = prefixPos + prefix.length();\n      int suffixPos = text.indexOf(suffix, position);\n      if (suffixPos == -1) {\n        suffixPos = text.length() - suffix.length();\n      }\n      suffixes.add(suffixPos);\n      position = suffixPos + suffix.length();\n    }\n\n    assert prefixes.size() == suffixes.size();\n\n    for (int i = prefixes.size() - 1; i >= 0; i--) {\n      uncommentRange(startOffset + prefixes.get(i), Math.min(startOffset + suffixes.get(i) + suffix.length(), endOffset), commenter);\n    }\n  }","id":72133,"modified_method":"private void uncommentLine(int line) {\n    Commenter commenter = myCommenters[line - myStartLine];\n    if (commenter == null) commenter = findCommenter(line);\n    if (commenter == null) return;\n\n    final int startOffset = myStartOffsets[line - myStartLine];\n    final int endOffset = myEndOffsets[line - myStartLine];\n    if (startOffset == endOffset) {\n      return;\n    }\n    String prefix = commenter.getLineCommentPrefix();\n    if (prefix != null) {\n      CharSequence chars = myDocument.getCharsSequence();\n      boolean skipNewLine = false;\n      boolean commented = CharArrayUtil.regionMatches(chars, startOffset, prefix) ||\n                          (skipNewLine = (prefix.endsWith(\" \") && CharArrayUtil.regionMatches(chars, startOffset, prefix.trim() + \"\\n\")));\n      assert commented;\n      int position = 0;//text.indexOf(prefix);\n      myDocument.deleteString(position + startOffset , position + startOffset + (skipNewLine? prefix.trim().length():prefix.length()));\n      return;\n    }\n    String text = myDocument.getCharsSequence().subSequence(startOffset, endOffset).toString();\n\n    prefix = commenter.getBlockCommentPrefix();\n    final String suffix = commenter.getBlockCommentSuffix();\n    if (prefix == null || suffix == null) {\n      return;\n    }\n\n    IntArrayList prefixes = new IntArrayList();\n    IntArrayList suffixes = new IntArrayList();\n    for (int position = 0; position < text.length();) {\n      int prefixPos = text.indexOf(prefix, position);\n      if (prefixPos == -1) {\n        break;\n      }\n      prefixes.add(prefixPos);\n      position = prefixPos + prefix.length();\n      int suffixPos = text.indexOf(suffix, position);\n      if (suffixPos == -1) {\n        suffixPos = text.length() - suffix.length();\n      }\n      suffixes.add(suffixPos);\n      position = suffixPos + suffix.length();\n    }\n\n    assert prefixes.size() == suffixes.size();\n\n    for (int i = prefixes.size() - 1; i >= 0; i--) {\n      uncommentRange(startOffset + prefixes.get(i), Math.min(startOffset + suffixes.get(i) + suffix.length(), endOffset), commenter);\n    }\n  }","commit_id":"6d4bf491878d9aef49af1209ecc77231fb8ce09f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isLineCommented(final int line, final CharSequence chars, final Commenter commenter) {\n    String prefix = commenter.getLineCommentPrefix();\n    int lineStart = myDocument.getLineStartOffset(line);\n    lineStart = CharArrayUtil.shiftForward(chars, lineStart, \" \\t\");\n    boolean commented;\n    if (prefix != null) {\n      commented = CharArrayUtil.regionMatches(chars, lineStart, prefix);\n      if (commented) {\n        myStartOffsets[line - myStartLine] = lineStart;\n        myEndOffsets[line - myStartLine] = -1;\n      }\n    }\n    else {\n      prefix = commenter.getBlockCommentPrefix();\n      String suffix = commenter.getBlockCommentSuffix();\n      final int textLength = myDocument.getTextLength();\n      int lineEnd = myDocument.getLineEndOffset(line);\n      if (lineEnd == textLength) {\n        final int shifted = CharArrayUtil.shiftBackward(chars, textLength - 1, \" \\t\");\n        if (shifted < textLength - 1) lineEnd = shifted;\n      }\n      else {\n        lineEnd = CharArrayUtil.shiftBackward(chars, lineEnd, \" \\t\");\n      }\n      commented = (lineStart == lineEnd && myStartLine != myEndLine) || (CharArrayUtil.regionMatches(chars, lineStart, prefix) &&\n                                                                   CharArrayUtil.regionMatches(chars, lineEnd - suffix.length(), suffix));\n      if (commented) {\n        myStartOffsets[line - myStartLine] = lineStart;\n        myEndOffsets[line - myStartLine] = lineEnd;\n      }\n    }\n    return commented;\n  }","id":72134,"modified_method":"private boolean isLineCommented(final int line, final CharSequence chars, final Commenter commenter) {\n    String prefix = commenter.getLineCommentPrefix();\n    int lineStart = myDocument.getLineStartOffset(line);\n    lineStart = CharArrayUtil.shiftForward(chars, lineStart, \" \\t\");\n    boolean commented;\n    if (prefix != null) {\n      commented = CharArrayUtil.regionMatches(chars, lineStart, prefix) ||\n                  prefix.endsWith(\" \") && CharArrayUtil.regionMatches(chars, lineStart, prefix.trim()+\"\\n\");\n      if (commented) {\n        myStartOffsets[line - myStartLine] = lineStart;\n        myEndOffsets[line - myStartLine] = -1;\n      }\n    }\n    else {\n      prefix = commenter.getBlockCommentPrefix();\n      String suffix = commenter.getBlockCommentSuffix();\n      final int textLength = myDocument.getTextLength();\n      int lineEnd = myDocument.getLineEndOffset(line);\n      if (lineEnd == textLength) {\n        final int shifted = CharArrayUtil.shiftBackward(chars, textLength - 1, \" \\t\");\n        if (shifted < textLength - 1) lineEnd = shifted;\n      }\n      else {\n        lineEnd = CharArrayUtil.shiftBackward(chars, lineEnd, \" \\t\");\n      }\n      commented = (lineStart == lineEnd && myStartLine != myEndLine) || (CharArrayUtil.regionMatches(chars, lineStart, prefix) &&\n                                                                   CharArrayUtil.regionMatches(chars, lineEnd - suffix.length(), suffix));\n      if (commented) {\n        myStartOffsets[line - myStartLine] = lineStart;\n        myEndOffsets[line - myStartLine] = lineEnd;\n      }\n    }\n    return commented;\n  }","commit_id":"6d4bf491878d9aef49af1209ecc77231fb8ce09f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void escape(Document document, RangeMarker range) {\n    String prefix = getBlockCommentPrefix();\n    String suffix = getBlockCommentSuffix();\n\n    int start = range.getStartOffset();\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), start, prefix)) {\n      start += prefix.length();\n    }\n    int end = range.getEndOffset();\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), end - suffix.length(), suffix)) {\n      end -= suffix.length();\n    }\n    if (start >= end) return;\n\n    for (int i = end - DOUBLE_DASH.length(); i >= start; i--) {\n      if (CharArrayUtil.regionMatches(document.getCharsSequence(), i, DOUBLE_DASH) &&\n          !CharArrayUtil.regionMatches(document.getCharsSequence(), i, suffix) &&\n          !CharArrayUtil.regionMatches(document.getCharsSequence(), i - 2, prefix)) {\n        document.replaceString(i, i + DOUBLE_DASH.length(), ESCAPED_DOUBLE_DASH);\n      }\n    }\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), start, GT)) {\n      document.replaceString(start, start + GT.length(), ESCAPED_GT);\n    }\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), range.getStartOffset(), prefix + \"-\")) {\n      document.insertString(start, \" \");\n    }\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), range.getEndOffset() - suffix.length() - 1, \"-\" + suffix)) {\n      document.insertString(range.getEndOffset() - suffix.length(), \" \");\n    }\n  }","id":72135,"modified_method":"@Override\n  public void escape(Document document, RangeMarker range) {\n    String prefix = getBlockCommentPrefix();\n    String suffix = getBlockCommentSuffix();\n\n    int start = range.getStartOffset();\n    int prefixStart = start = CharArrayUtil.shiftForward(document.getCharsSequence(), start, \" \\t\\n\");\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), prefixStart, prefix)) {\n      start += prefix.length();\n    }\n    int end = range.getEndOffset();\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), end - suffix.length(), suffix)) {\n      end -= suffix.length();\n    }\n    if (start >= end) return;\n\n    for (int i = end - DOUBLE_DASH.length(); i >= start; i--) {\n      if (CharArrayUtil.regionMatches(document.getCharsSequence(), i, DOUBLE_DASH) &&\n          !CharArrayUtil.regionMatches(document.getCharsSequence(), i, suffix) &&\n          !CharArrayUtil.regionMatches(document.getCharsSequence(), i - 2, prefix)) {\n        document.replaceString(i, i + DOUBLE_DASH.length(), ESCAPED_DOUBLE_DASH);\n      }\n    }\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), start, GT)) {\n      document.replaceString(start, start + GT.length(), ESCAPED_GT);\n    }\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), prefixStart, prefix + \"-\")) {\n      document.insertString(start, \" \");\n    }\n    if (CharArrayUtil.regionMatches(document.getCharsSequence(), range.getEndOffset() - suffix.length() - 1, \"-\" + suffix)) {\n      document.insertString(range.getEndOffset() - suffix.length(), \" \");\n    }\n  }","commit_id":"71a8df5a54ef92b9b265c7877ef34d6738508474","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n    public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {\r\n        Card card = game.getCard(sourceId);\r\n        if (card != null && filter.match(card, game) && card.getSpellAbility().isInUseableZone(game, card, false)) {\r\n            if (anyPlayer) {\r\n                Player controller = game.getPlayer(source.getControllerId());\r\n                if (controller != null) {\r\n                    return controller.getInRange().contains(card.getOwnerId());\r\n                }\r\n            } else {\r\n                return card.getOwnerId().equals(source.getControllerId());\r\n            }\r\n        }\r\n        return false;\r\n    }","id":72136,"modified_method":"@Override\r\n    public boolean applies(UUID affectedSpellId, Ability source, UUID affectedControllerId, Game game) {\r\n        if (anyPlayer || source.getControllerId().equals(affectedControllerId)) {\r\n            Card card = game.getCard(affectedSpellId);\r\n            return card != null && filter.match(card, game);\r\n        }\r\n        return false;\r\n    }","commit_id":"484a4fe0f6f6207f7030f8b4d7650d694aeb2df2","url":"https://github.com/magefree/mage"},{"original_method":"/**\r\n     * \r\n     */\r\n\r\n    @Test\r\n    //@Ignore\r\n    public void testDoubleStrikeTrampleVersusIndestructibleGod() {\r\n        /**\r\n         * Heliod, God of the Sun\r\n         * Legendary Enchantment Creature \u2014 God 5/6, 3W\r\n         * Indestructible\r\n         * As long as your devotion to white is less than five, Heliod isn't a creature. (Each {W} in the mana costs of permanents you control counts toward your devotion to white.)\r\n         * Other creatures you control have vigilance.\r\n         * {2}{W}{W}: Put a 2/1 white Cleric enchantment creature token onto the battlefield.\r\n         */\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Heliod, God of the Sun\");\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Terra Eternal\"); // only for devotion\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Terra Eternal\"); // only for devotion \r\n\r\n        /* Primeval Titan\r\n         * Creature \u2014 Giant 6/6, 4GG\r\n         * Trample\r\n         * Whenever Primeval Titan enters the battlefield or attacks, you may search your library for up to two land cards, put them onto the battlefield tapped, then shuffle your library.\r\n         */\r\n        addCard(Zone.BATTLEFIELD, playerB, \"Primeval Titan\");\r\n        addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 3);\r\n        // {W}{W}{2}\r\n        // If Leyline of Sanctity is in your opening hand, you may begin the game with it on the battlefield.\r\n        // You have hexproof.\r\n        addCard(Zone.HAND, playerA, \"Leyline of Sanctity\", 1);\r\n        // Enchantment - Aura {W}{2}\r\n        // Enchant creature\r\n        // Enchanted creature has double strike.\r\n        addCard(Zone.HAND, playerB, \"Battle Mastery\");\r\n\r\n\r\n        castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Battle Mastery\",\"Primeval Titan\");\r\n        attack(2, playerB, \"Primeval Titan\");\r\n        block(2,playerA,\"Heliod, God of the Sun\",\"Primeval Titan\");\r\n        setStopAt(2, PhaseStep.END_TURN);\r\n        execute();\r\n\r\n        // creature is blocked\r\n        // blocker does not die and second strike can trample through for 6\r\n        assertLife(playerA, 14);\r\n        assertLife(playerB, 20);\r\n\r\n        assertPermanentCount(playerB, \"Battle Mastery\", 1);\r\n        // no creatures dies\r\n        assertPermanentCount(playerA, \"Heliod, God of the Sun\", 1);\r\n        assertPowerToughness(playerA, \"Heliod, God of the Sun\", 5, 6);\r\n        assertPermanentCount(playerB, \"Primeval Titan\", 1);\r\n        assertPowerToughness(playerB, \"Primeval Titan\", 6,6);\r\n        \r\n    }","id":72137,"modified_method":"/**\r\n     * \r\n     */\r\n\r\n    @Test\r\n    //@Ignore\r\n    public void testDoubleStrikeTrampleVersusIndestructibleGod() {\r\n        /**\r\n         * Heliod, God of the Sun\r\n         * Legendary Enchantment Creature \u2014 God 5/6, 3W\r\n         * Indestructible\r\n         * As long as your devotion to white is less than five, Heliod isn't a creature. (Each {W} in the mana costs of permanents you control counts toward your devotion to white.)\r\n         * Other creatures you control have vigilance.\r\n         * {2}{W}{W}: Put a 2/1 white Cleric enchantment creature token onto the battlefield.\r\n         */\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Heliod, God of the Sun\");\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Terra Eternal\"); // only for devotion\r\n        addCard(Zone.BATTLEFIELD, playerA, \"Terra Eternal\"); // only for devotion \r\n\r\n        /* Primeval Titan\r\n         * Creature \u2014 Giant 6/6, 4GG\r\n         * Trample\r\n         * Whenever Primeval Titan enters the battlefield or attacks, you may search your library for up to two land cards, put them onto the battlefield tapped, then shuffle your library.\r\n         */\r\n        addCard(Zone.BATTLEFIELD, playerB, \"Primeval Titan\");\r\n        addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 3);\r\n        // {W}{W}{2}\r\n        // If Leyline of Sanctity is in your opening hand, you may begin the game with it on the battlefield.\r\n        // You have hexproof.\r\n        addCard(Zone.HAND, playerA, \"Leyline of Sanctity\", 1);\r\n        // Enchantment - Aura {W}{2}\r\n        // Enchant creature\r\n        // Enchanted creature has double strike.\r\n        addCard(Zone.HAND, playerB, \"Battle Mastery\");\r\n\r\n\r\n        castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Battle Mastery\",\"Primeval Titan\");\r\n        attack(2, playerB, \"Primeval Titan\");\r\n        block(2,playerA,\"Heliod, God of the Sun\",\"Primeval Titan\");\r\n        setStopAt(2, PhaseStep.END_TURN);\r\n        execute();\r\n\r\n        // creature is blocked\r\n        // blocker does not die and second strike can trample through for 6\r\n        assertLife(playerA, 14);\r\n        assertLife(playerB, 20);\r\n\r\n        assertPermanentCount(playerA, \"Leyline of Sanctity\", 1);\r\n        assertPermanentCount(playerB, \"Battle Mastery\", 1);\r\n        // no creatures dies\r\n        assertPermanentCount(playerA, \"Heliod, God of the Sun\", 1);\r\n        assertPowerToughness(playerA, \"Heliod, God of the Sun\", 5, 6);\r\n        assertPermanentCount(playerB, \"Primeval Titan\", 1);\r\n        assertPowerToughness(playerB, \"Primeval Titan\", 6,6);\r\n        \r\n    }","commit_id":"484a4fe0f6f6207f7030f8b4d7650d694aeb2df2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, event.getTargetId(), source.getSourceId(), source.getControllerId(), event.getAmount(), false);\n        if (!game.replaceEvent(preventEvent)) {\n            if (amount == -1) {\n                // define once\n                amount = source.getManaCostsToPay().getX();\n            }\n            int prevented;\n            if (event.getAmount() >= this.amount) {\n                int damage = amount;\n                event.setAmount(event.getAmount() - amount);\n                this.used = true;\n                game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, event.getTargetId(), source.getSourceId(), source.getControllerId(), damage));\n                prevented = damage;\n            } else {\n                int damage = event.getAmount();\n                event.setAmount(0);\n                amount -= damage;\n                game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, event.getTargetId(), source.getSourceId(), source.getControllerId(), damage));\n                prevented = damage;\n            }\n\n            // deal damage now\n            if (prevented > 0) {\n                UUID redirectTo = source.getTargets().get(1).getFirstTarget();\n                Permanent permanent = game.getPermanent(redirectTo);\n                if (permanent != null) {\n                    game.informPlayers(\"Dealing \" + prevented + \" to \" + permanent.getName() + \" instead\");\n                    // keep the original source id as it is redirecting\n                    permanent.damage(prevented, event.getSourceId(), game, false, true);\n                }\n                Player player = game.getPlayer(redirectTo);\n                if (player != null) {\n                    game.informPlayers(\"Dealing \" + prevented + \" to \" + player.getName() + \" instead\");\n                    // keep the original source id as it is redirecting\n                    player.damage(prevented, event.getSourceId(), game, false, true);\n                }\n            }\n        }\n        return false;\n    }","id":72138,"modified_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        /*\n        If damage is dealt to multiple permanents you control, or is dealt to you and at least\n        one permanent you control, you choose which of that damage to prevent if the chosen value\n        for X won't prevent all the damage. For example, if 3 damage would be dealt to you and to\n        each of two creatures you control, and Divine Deflection will prevent the next 3 damage,\n        you might choose to prevent the next 2 damage it would deal to you and the next 1 damage\n        it would deal to one of the creatures, among other choices. You don't decide until the\n        point at which the damage would be dealt.\n        TODO: Support to select which damage to prevent\n        */\n\n        PreventionEffectData preventionData = preventDamageAction(event, source, game);\n        /*\n        Divine Deflection's effect is not a redirection effect. If it prevents damage,\n        Divine Deflection (not the original source) deals damage to the targeted creature\n        or player as part of that prevention effect. Divine Deflection is the source of\n        the new damage, so the characteristics of the original source (such as its color,\n        or whether it had lifelink or deathtouch) don't affect this damage. The new damage\n        is not combat damage, even if the prevented damage was. Since you control the source\n        of the new damage, if you targeted an opponent with Divine Deflection, you may\n        have Divine Deflection deal its damage to a planeswalker that opponent controls.\n        */\n        // deal damage now\n        int prevented = preventionData.getPreventedDamage();\n        if (prevented > 0) {\n            UUID dealDamageTo = source.getFirstTarget();\n            /*\n          \tWhether the targeted creature or player is still a legal target is not checked after\n            Divine Deflection resolves. For example, if a creature targeted by Divine Deflection\n            gains shroud after Divine Deflection resolves, Divine Deflection can still deal damage\n            to that creature.\n            */\n\n            Permanent permanent = game.getPermanent(dealDamageTo);\n            if (permanent != null) {\n                game.informPlayers(\"Dealing \" + prevented + \" to \" + permanent.getName() + \" instead\");\n                permanent.damage(prevented, source.getSourceId(), game, false, true);\n            }\n            Player player = game.getPlayer(dealDamageTo);\n            if (player != null) {\n                game.informPlayers(\"Dealing \" + prevented + \" to \" + player.getName() + \" instead\");\n                player.damage(prevented, source.getSourceId(), game, false, true);\n            }\n        }\n        return false;\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"public DivineDeflection(UUID ownerId) {\n        super(ownerId, 18, \"Divine Deflection\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{X}{W}\");\n        this.expansionSetCode = \"AVR\";\n\n        this.color.setWhite(true);\n\n        // Prevent the next X damage that would be dealt to you and/or permanents you control this turn. If damage is prevented this way, Divine Deflection deals that much damage to target creature or player.\n        this.getSpellAbility().addEffect(new DivineDeflectionPreventDamageTargetEffect(Duration.EndOfTurn));\n        this.getSpellAbility().addTarget(new TargetSource());\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());\n    }","id":72139,"modified_method":"public DivineDeflection(UUID ownerId) {\n        super(ownerId, 18, \"Divine Deflection\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{X}{W}\");\n        this.expansionSetCode = \"AVR\";\n\n        this.color.setWhite(true);\n\n        // Prevent the next X damage that would be dealt to you and/or permanents you control this turn. If damage is prevented this way, Divine Deflection deals that much damage to target creature or player.\n        this.getSpellAbility().addEffect(new DivineDeflectionPreventDamageTargetEffect(Duration.EndOfTurn));\n        this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"public DivineDeflectionPreventDamageTargetEffect(Duration duration) {\n        super(duration);\n        staticText = \"Prevent the next X damage that would be dealt to you and/or permanents you control this turn. If damage is prevented this way, {this} deals that much damage to target creature or player\";\n    }","id":72140,"modified_method":"public DivineDeflectionPreventDamageTargetEffect(Duration duration) {\n        super(duration, Integer.MIN_VALUE, false, true);\n        staticText = \"Prevent the next X damage that would be dealt to you and/or permanents you control this turn. If damage is prevented this way, {this} deals that much damage to target creature or player\";\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean applies(GameEvent event, Ability source, Game game) {\n        if (!this.used && super.applies(event, source, game)) {\n\n            // check source\n            MageObject object = game.getObject(event.getSourceId());\n            if (object == null) {\n                game.informPlayers(\"Couldn't find source of damage\");\n                return false;\n            }\n\n            if (!object.getId().equals(source.getFirstTarget())) {\n                return false;\n            }\n\n            // check target\n            //   check permanent first\n            Permanent permanent = game.getPermanent(event.getTargetId());\n            if (permanent != null) {\n                if (permanent.getControllerId().equals(source.getControllerId())) {\n                    // it's your permanent\n                    return true;\n                }\n            }\n            //   check player\n            if (source.getControllerId().equals(event.getTargetId())) {\n                // it is you\n                return true;\n            }\n        }\n        return false;\n    }","id":72141,"modified_method":"@Override\n    public boolean applies(GameEvent event, Ability source, Game game) {\n        if (!this.used && super.applies(event, source, game)) {\n            if (amountToPrevent == Integer.MIN_VALUE) {\n                amountToPrevent = source.getManaCostsToPay().getX();\n            }\n            //   check permanent first\n            Permanent permanent = game.getPermanent(event.getTargetId());\n            if (permanent != null) {\n                if (permanent.getControllerId().equals(source.getControllerId())) {\n                    return true;\n                }\n            }\n            //   check player\n            if (source.getControllerId().equals(event.getTargetId())) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"public DivineDeflectionPreventDamageTargetEffect(final DivineDeflectionPreventDamageTargetEffect effect) {\n        super(effect);\n        this.amount = effect.amount;\n    }","id":72142,"modified_method":"public DivineDeflectionPreventDamageTargetEffect(final DivineDeflectionPreventDamageTargetEffect effect) {\n        super(effect);\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        if (FatefulHourCondition.getInstance().apply(game, source)) {\n            ChoiceColor choice = (ChoiceColor) source.getChoices().get(0);\n            FilterCard filter = new FilterCard();\n            filter.add(new ColorPredicate(choice.getColor()));\n            filter.setMessage(choice.getChoice());\n\n            Ability ability = new ProtectionAbility(filter) ;\n            game.addEffect(new GainAbilityControlledEffect(ability, Duration.EndOfTurn), source);\n        }\n        else {\n            game.addEffect(new GainProtectionFromColorTargetEffect(Duration.EndOfTurn), source);\n        }\n        return true;\n    }","id":72143,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            if (FatefulHourCondition.getInstance().apply(game, source)) {\n                ChoiceColor choice = new ChoiceColor();\n                while (!choice.isChosen()) {\n                    controller.choose(Outcome.Protect, choice, game);\n                    if (!controller.isInGame()) {\n                        return false;\n                    }\n                }\n                FilterCard filter = new FilterCard();\n                filter.add(new ColorPredicate(choice.getColor()));\n                filter.setMessage(choice.getChoice());\n\n                Ability ability = new ProtectionAbility(filter) ;\n                game.addEffect(new GainAbilityControlledEffect(ability, Duration.EndOfTurn), source);\n                game.addEffect(new GainAbilityControllerEffect(ability, Duration.EndOfTurn), source);\n            }\n            else {\n                game.addEffect(new GainProtectionFromColorTargetEffect(Duration.EndOfTurn), source);\n            }\n            return true;\n\n        }\n        return false;\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"public FaithsShieldEffect() {\n        super(Outcome.Protect);\n        staticText = \"Target permanent you control gains protection from the color of your choice until end of turn\\nFateful hour - If you have 5 or less life, instead you and each permanent you control gain protection from the color of your choice until end of turn\";\n    }","id":72144,"modified_method":"public FaithsShieldEffect() {\n        super(Outcome.Protect);\n        staticText = \"Target permanent you control gains protection from the color of your choice until end of turn.\"\n                 + \"<br/><br/><i>Fateful hour<\/i> - If you have 5 or less life, instead you and each permanent you control gain protection from the color of your choice until end of turn\";\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        if (!this.used && super.applies(event, source, game)) {\r\n\r\n            \r\n            MageObject object = game.getObject(event.getSourceId());\r\n            if (object == null) {\r\n                game.informPlayers(\"Couldn't find source of damage\");\r\n                return false;\r\n            }\r\n\r\n            if (!object.getId().equals(source.getFirstTarget())) {\r\n                return false;\r\n            }\r\n\r\n            Player player = game.getPlayer(event.getTargetId());\r\n            if (player != null) {\r\n                if (player.getId().equals(source.getControllerId())) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":72145,"modified_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        if (!this.used && super.applies(event, source, game) && event.getTargetId().equals(source.getControllerId())) {\r\n            if (event.getSourceId().equals(getTargetPointer().getFirst(game, source))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"public InterventionPactPreventDamageEffect() {\r\n        super(Duration.EndOfTurn);\r\n        staticText = \"The next time a source of your choice would deal damage to you this turn, prevent that damage. You gain life equal to the damage prevented this way\";\r\n    }","id":72146,"modified_method":"public InterventionPactPreventDamageEffect() {\r\n        super(Duration.EndOfTurn, Integer.MAX_VALUE, false, false);\r\n        staticText = \"The next time a source of your choice would deal damage to you this turn, prevent that damage. You gain life equal to the damage prevented this way\";\r\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"public InterventionPact(UUID ownerId) {\r\n        super(ownerId, 8, \"Intervention Pact\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{0}\");\r\n        this.expansionSetCode = \"FUT\";\r\n\r\n        this.color.setWhite(true);\r\n        \r\n        // The next time a source of your choice would deal damage to you this turn, prevent that damage. You gain life equal to the damage prevented this way.\r\n        this.getSpellAbility().addEffect(new InterventionPactPreventDamageEffect());\r\n        this.getSpellAbility().addTarget(new TargetSource());\r\n        // At the beginning of your next upkeep, pay {1}{W}{W}. If you don't, you lose the game.\r\n        this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new PactDelayedTriggeredAbility(new ManaCostsImpl(\"{1}{W}{W}\")), false));\r\n    }","id":72147,"modified_method":"public InterventionPact(UUID ownerId) {\r\n        super(ownerId, 8, \"Intervention Pact\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{0}\");\r\n        this.expansionSetCode = \"FUT\";\r\n\r\n        this.color.setWhite(true);\r\n        \r\n        // The next time a source of your choice would deal damage to you this turn, prevent that damage. You gain life equal to the damage prevented this way.\r\n        this.getSpellAbility().addEffect(new InterventionPactEffect());\r\n        // At the beginning of your next upkeep, pay {1}{W}{W}. If you don't, you lose the game.\r\n        this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new PactDelayedTriggeredAbility(new ManaCostsImpl(\"{1}{W}{W}\")), false));\r\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        PreventionEffectData preventEffectData = preventDamageAction(event, source, game);\r\n        if (preventEffectData.getPreventedDamage() > 0) {\r\n            Player player = game .getPlayer(source.getControllerId());\r\n            if(player != null){\r\n                player.gainLife(preventEffectData.getPreventedDamage(), game);\r\n            }\r\n        }\r\n        return false;\r\n    }","id":72148,"modified_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        PreventionEffectData preventEffectData = preventDamageAction(event, source, game);\r\n        if (preventEffectData.getPreventedDamage() > 0) {\r\n            used = true;\r\n            Player player = game .getPlayer(source.getControllerId());\r\n            if(player != null){\r\n                player.gainLife(preventEffectData.getPreventedDamage(), game);\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"95de1b1e30b6dc654a45544986bd99d394cf9413","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        Player player = game.getPlayer(event.getPlayerId());\r\n        return player != null && game.isOpponent(player, source.getControllerId());\r\n    }","id":72149,"modified_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        // this won't work correctly if coop formats are supported someday\r\n        return event.getPlayerId().equals(source.getSourceId());\r\n    }","commit_id":"7526d46cf0c7d2971f46e5236e1add46cc0b66b7","url":"https://github.com/magefree/mage"},{"original_method":"public DoomwakeGiant(UUID ownerId) {\r\n        super(ownerId, 66, \"Doomwake Giant\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, \"{4}{B}\");\r\n        this.expansionSetCode = \"JOU\";\r\n        this.subtype.add(\"Giant\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(6);\r\n\r\n        // Constellation - When Doomwake Giant or another enchantment enters the battlefield under your control, creatures your opponents control get -1/-1 until end of turn.\r\n        this.addAbility(new ConstellationAbility(new BoostAllEffect(-1,-1, Duration.EndOfTurn, filter, false)));\r\n    }","id":72150,"modified_method":"public DoomwakeGiant(UUID ownerId) {\r\n        super(ownerId, 66, \"Doomwake Giant\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, \"{4}{B}\");\r\n        this.expansionSetCode = \"JOU\";\r\n        this.subtype.add(\"Giant\");\r\n\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(6);\r\n\r\n        // Constellation - When Doomwake Giant or another enchantment enters the battlefield under your control, creatures your opponents control get -1/-1 until end of turn.\r\n        this.addAbility(new ConstellationAbility(new BoostAllEffect(-1,-1, Duration.EndOfTurn, filter, false)));\r\n    }","commit_id":"7526d46cf0c7d2971f46e5236e1add46cc0b66b7","url":"https://github.com/magefree/mage"},{"original_method":"public void subscribe(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong resourcePrimKey = ParamUtil.getLong(\n\t\t\tactionRequest, \"resourcePrimKey\");\n\n\t\tArticleServiceUtil.subscribe(\n\t\t\tthemeDisplay.getScopeGroupId(), resourcePrimKey);\n\t}","id":72151,"modified_method":"public void subscribe(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong resourcePrimKey = ParamUtil.getLong(\n\t\t\tactionRequest, \"resourcePrimKey\");\n\n\t\tif (resourcePrimKey <= 0) {\n\t\t\tArticleServiceUtil.subscribe(themeDisplay.getScopeGroupId());\n\t\t}\n\t\telse {\n\t\t\tArticleServiceUtil.subscribeArticle(resourcePrimKey);\n\t\t}\n\t}","commit_id":"5a4666d1fb73639a273aa2788f52210635df5506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void unsubscribe(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong resourcePrimKey = ParamUtil.getLong(\n\t\t\tactionRequest, \"resourcePrimKey\");\n\n\t\tArticleServiceUtil.unsubscribe(\n\t\t\tthemeDisplay.getScopeGroupId(), resourcePrimKey);\n\t}","id":72152,"modified_method":"public void unsubscribe(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong resourcePrimKey = ParamUtil.getLong(\n\t\t\tactionRequest, \"resourcePrimKey\");\n\n\t\tif (resourcePrimKey <= 0) {\n\t\t\tArticleServiceUtil.unsubscribe(themeDisplay.getScopeGroupId());\n\t\t}\n\t\telse {\n\t\t\tArticleServiceUtil.unsubscribeArticle(resourcePrimKey);\n\t\t}\n\t}","commit_id":"5a4666d1fb73639a273aa2788f52210635df5506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void unsubscribe(long groupId, long userId, long resourcePrimKey)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (resourcePrimKey <= 0) {\n\t\t\tsubscriptionLocalService.deleteSubscription(\n\t\t\t\tuserId, Article.class.getName(), groupId);\n\t\t}\n\t\telse {\n\t\t\tsubscriptionLocalService.deleteSubscription(\n\t\t\t\tuserId, Article.class.getName(), resourcePrimKey);\n\t\t}\n\t}","id":72153,"modified_method":"public void unsubscribe(long groupId, long userId)\n\t\tthrows PortalException, SystemException {\n\n\t\tsubscriptionLocalService.deleteSubscription(\n\t\t\tuserId, Article.class.getName(), groupId);\n\t}","commit_id":"5a4666d1fb73639a273aa2788f52210635df5506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void subscribe(long groupId, long userId, long resourcePrimKey)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (resourcePrimKey <= 0) {\n\t\t\tsubscriptionLocalService.addSubscription(\n\t\t\t\tuserId, Article.class.getName(), groupId);\n\t\t}\n\t\telse {\n\t\t\tsubscriptionLocalService.addSubscription(\n\t\t\t\tuserId, Article.class.getName(), resourcePrimKey);\n\t\t}\n\t}","id":72154,"modified_method":"public void subscribe(long groupId, long userId)\n\t\tthrows PortalException, SystemException {\n\n\t\tsubscriptionLocalService.addSubscription(\n\t\t\tuserId, Article.class.getName(), groupId);\n\t}","commit_id":"5a4666d1fb73639a273aa2788f52210635df5506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void subscribe(long groupId, long resourcePrimKey)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (resourcePrimKey <= 0) {\n\t\t\tAdminPermission.check(\n\t\t\t\tgetPermissionChecker(), groupId, ActionKeys.SUBSCRIBE);\n\t\t}\n\t\telse {\n\t\t\tArticlePermission.check(\n\t\t\t\tgetPermissionChecker(), resourcePrimKey, ActionKeys.SUBSCRIBE);\n\t\t}\n\n\t\tarticleLocalService.subscribe(groupId, getUserId(), resourcePrimKey);\n\t}","id":72155,"modified_method":"public void subscribe(long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tAdminPermission.check(\n\t\t\tgetPermissionChecker(), groupId, ActionKeys.SUBSCRIBE);\n\n\t\tarticleLocalService.subscribe(groupId, getUserId());\n\t}","commit_id":"5a4666d1fb73639a273aa2788f52210635df5506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void unsubscribe(long groupId, long resourcePrimKey)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (resourcePrimKey <= 0) {\n\t\t\tAdminPermission.check(\n\t\t\t\tgetPermissionChecker(), groupId, ActionKeys.SUBSCRIBE);\n\t\t}\n\t\telse {\n\t\t\tArticlePermission.check(\n\t\t\t\tgetPermissionChecker(), resourcePrimKey, ActionKeys.SUBSCRIBE);\n\t\t}\n\n\t\tarticleLocalService.unsubscribe(groupId, getUserId(), resourcePrimKey);\n\t}","id":72156,"modified_method":"public void unsubscribe(long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tAdminPermission.check(\n\t\t\tgetPermissionChecker(), groupId, ActionKeys.SUBSCRIBE);\n\n\t\tarticleLocalService.unsubscribe(groupId, getUserId());\n\t}","commit_id":"5a4666d1fb73639a273aa2788f52210635df5506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void clearUpdateListeners() {\n\t\tbroker.getBrokerPool().getNotificationService().unsubscribe(updateListener);\n\t\tupdateListener = null;\n\t}","id":72157,"modified_method":"protected void clearUpdateListeners() {\n\t\tif (updateListener != null)\n\t\t\tbroker.getBrokerPool().getNotificationService().unsubscribe(updateListener);\n\t\tupdateListener = null;\n\t}","commit_id":"2279edc7098c34cbda8bb504c624432d648ead2f","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n  protected void setUpJdk() {    \n    flexSdkRootPath = getTestDataPath() + \"/sdk/\" + getFlexVersion();\n    doSetupFlexSdk(myModule, flexSdkRootPath, true, getFlexVersion() + \".0\");\n  }","id":72158,"modified_method":"@Override\n  protected void setUpJdk() {\n    final String flexVersion = getFlexVersion();\n    flexSdkRootPath = getTestDataPath() + \"/sdk/\" + flexVersion;\n    doSetupFlexSdk(myModule, flexSdkRootPath, true, flexVersion + \".\" + (flexVersion.equals(\"4.1\") ? \"16076\" : \"20967\"));\n  }","commit_id":"cc9a50dc42fa5c282b003de52daa4e9c573a18e9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void reset() {\n    files.clear();\n    freeIndices.resetQuick();\n    fileDocumentManagerListener.unsubscribe();\n  }","id":72159,"modified_method":"public void reset() {\n    files.clear();\n    freeIndices.resetQuick();\n    if (fileDocumentManagerListener != null) {\n      fileDocumentManagerListener.unsubscribe();\n    }\n  }","commit_id":"cc9a50dc42fa5c282b003de52daa4e9c573a18e9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/** Returns the prefix of URL to represent this build. */\n\tprivate String getCWRURLPrefix() {\n\t\tint val = (_wapp.getSubversion(0) << 16)\n\t\t\t  + (_wapp.getSubversion(1) << 8)\n\t\t\t  + _wapp.getSubversion(2);\n\t\ttry {\n\t\t\tval ^= Integer.parseInt(_wapp.getBuild());\n\t\t} catch (Throwable ex) { //ignore it\n\t\t}\n\t\tval += WebApps.getEdition().hashCode();\n\t\tif (val < 0) val = -val;\n\t\treturn Integer.toString(val % 100000000);\n\t\t\t//FF 8-char boundary: http://code.google.com/intl/de/speed/page-speed/docs/caching.html\n\t}","id":72160,"modified_method":"/** Returns the prefix of URL to represent this build. */\n\tprivate String getCWRURLPrefix() {\n\t\treturn Integer.toHexString(\n\t\t\t_wapp.getVersion().hashCode() \n\t\t\t^ _wapp.getBuild().hashCode()\n\t\t\t^ WebApps.getEdition().hashCode());\n\t\t\t//FF 8-char boundary: http://code.google.com/intl/de/speed/page-speed/docs/caching.html\n\t}","commit_id":"f7318ae3563a2df5f616ff7b034830a190651ec5","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the prefix of URL to represent this build. */\n\tprivate String getCWRURLPrefix() {\n\t\tint val = (_wapp.getSubversion(0) << 16)\n\t\t\t  + (_wapp.getSubversion(1) << 8)\n\t\t\t  + _wapp.getSubversion(2);\n\t\ttry {\n\t\t\tval ^= Integer.parseInt(_wapp.getBuild());\n\t\t} catch (Throwable ex) { //ignore it\n\t\t}\n\t\tif (val < 0) val = -val;\n\t\treturn Integer.toString(val % 100000000);\n\t\t\t//FF 8-char boundary: http://code.google.com/intl/de/speed/page-speed/docs/caching.html\n\t}","id":72161,"modified_method":"/** Returns the prefix of URL to represent this build. */\n\tprivate String getCWRURLPrefix() {\n\t\treturn Integer.toHexString(\n\t\t\t_wapp.getVersion().hashCode() \n\t\t\t^ _wapp.getBuild().hashCode()\n\t\t\t^ WebApps.getEdition().hashCode());\n\t\t\t//FF 8-char boundary: http://code.google.com/intl/de/speed/page-speed/docs/caching.html\n\t}","commit_id":"7b7abc6d12a078f58a007c69dbf6645d0587e5d4","url":"https://github.com/zkoss/zk"},{"original_method":"private Query createRangeQuery(Class<?> cls, String name, Object value,\n                                   ConditionType type) {\n        if (String.class.isAssignableFrom(cls) || Number.class.isAssignableFrom(cls)) {\n            // If needed, long and double can be supported too\n            // Also, perhaps Strings may optionally be compared with string comparators \n            Integer intValue = Integer.valueOf(value.toString());\n            Integer min = type == ConditionType.LESS_THAN || type == ConditionType.LESS_OR_EQUALS ? null : intValue;\n            Integer max = type == ConditionType.GREATER_THAN || type == ConditionType.GREATER_OR_EQUALS \n                ? null : intValue;\n            boolean minInclusive = \n                type == ConditionType.GREATER_OR_EQUALS || type == ConditionType.EQUALS;\n            boolean maxInclusive =\n                type == ConditionType.LESS_OR_EQUALS || type == ConditionType.EQUALS;\n            Query query = NumericRangeQuery.newIntRange(name, min, max, \n                                                        minInclusive, maxInclusive);\n            return query;\n        } else if (Date.class.isAssignableFrom(cls)) {\n            // This code has not been tested - most likely needs to be fixed  \n            // Resolution should be configurable ?\n            String luceneDateValue = DateTools.dateToString((Date)value, Resolution.MILLISECOND);\n            String expression = null;\n            if (type == ConditionType.LESS_THAN) {\n                // what is the base date here ?\n                expression = \"[\" + \"\"\n                    + \" TO \" + luceneDateValue + \"]\";    \n            } else {\n                expression = \"[\" + luceneDateValue + \" TO \" \n                    + DateTools.dateToString(new Date(), Resolution.MILLISECOND) + \"]\";\n            }\n            return parseExpression(name, expression);\n        } else {\n            return null;\n        }\n    }","id":72162,"modified_method":"private Query createRangeQuery(Class<?> cls, String name, Object value,\n                                   ConditionType type) {\n        if (String.class.isAssignableFrom(cls) || Number.class.isAssignableFrom(cls)) {\n            // If needed, long and double can be supported too\n            // Also, perhaps Strings may optionally be compared with string comparators \n            Integer intValue = Integer.valueOf(value.toString());\n            Integer min = type == ConditionType.LESS_THAN || type == ConditionType.LESS_OR_EQUALS ? null : intValue;\n            Integer max = type == ConditionType.GREATER_THAN || type == ConditionType.GREATER_OR_EQUALS \n                ? null : intValue;\n            boolean minInclusive = \n                type == ConditionType.GREATER_OR_EQUALS || type == ConditionType.EQUALS;\n            boolean maxInclusive =\n                type == ConditionType.LESS_OR_EQUALS || type == ConditionType.EQUALS;\n            Query query = NumericRangeQuery.newIntRange(name, min, max, \n                                                        minInclusive, maxInclusive);\n            return query;\n        } else if (Date.class.isAssignableFrom(cls)) {\n            // This code has not been tested - most likely needs to be fixed  \n            // Resolution should be configurable ?\n            final Date date = SearchUtils.timestampFromString(value.toString());           \n            final String luceneDateValue = (date != null) \n                ? DateTools.dateToString(date, Resolution.MILLISECOND) : value.toString();\n                \n            if (type == ConditionType.LESS_THAN) {\n                return TermRangeQuery.newStringRange(name, \"\", luceneDateValue, true, false);\n            } else {\n                return TermRangeQuery.newStringRange(name, luceneDateValue, \n                    DateTools.dateToString(new Date(), Resolution.MILLISECOND), true, false);\n            }\n        } else {\n            return null;\n        }\n    }","commit_id":"16cff265ea0002e225b1bdbbaa6b5a621e0a182b","url":"https://github.com/apache/cxf"},{"original_method":"private static Field getField(final LuceneDocumentMetadata documentMetadata, \n                                  final String name, final String value) { \n        final Class< ? > type = documentMetadata.getFieldType(name);\n        \n        if (type != null) {\n            if (Number.class.isAssignableFrom(type)) {\n                if (Double.class.isAssignableFrom(type)) {\n                    return new DoubleField(name, Double.valueOf(value), Store.YES);\n                } else if (Float.class.isAssignableFrom(type)) {\n                    return new FloatField(name, Float.valueOf(value), Store.YES);\n                } else if (Long.class.isAssignableFrom(type)) {\n                    return new LongField(name, Long.valueOf(value), Store.YES);\n                } else if (Integer.class.isAssignableFrom(type)) {\n                    return new IntField(name, Integer.valueOf(value), Store.YES);\n                }\n            } else if (Date.class.isAssignableFrom(type)) {\n                return new StringField(name, value, Store.YES);\n            }                \n        }\n        \n        return new StringField(name, value, Store.YES);\n    }","id":72163,"modified_method":"private static Field getField(final LuceneDocumentMetadata documentMetadata, \n                                  final String name, final String value) { \n        final Class< ? > type = documentMetadata.getFieldType(name);\n        \n        if (type != null) {\n            if (Number.class.isAssignableFrom(type)) {\n                if (Double.class.isAssignableFrom(type)) {\n                    return new DoubleField(name, Double.valueOf(value), Store.YES);\n                } else if (Float.class.isAssignableFrom(type)) {\n                    return new FloatField(name, Float.valueOf(value), Store.YES);\n                } else if (Long.class.isAssignableFrom(type)) {\n                    return new LongField(name, Long.valueOf(value), Store.YES);\n                } else if (Integer.class.isAssignableFrom(type)) {\n                    return new IntField(name, Integer.valueOf(value), Store.YES);\n                }\n            } else if (Date.class.isAssignableFrom(type)) {\n                final Date date = SearchUtils.timestampFromString(value);                \n                Field field = null;\n                \n                if (date != null) {\n                    field = new StringField(name, DateTools.dateToString(date, Resolution.MILLISECOND), \n                        Store.YES);\n                } else {\n                    field = new StringField(name, value, Store.YES); \n                }\n                \n                return field;\n            }                \n        }\n        \n        return new StringField(name, value, Store.YES);\n    }","commit_id":"16cff265ea0002e225b1bdbbaa6b5a621e0a182b","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testExtractedTextContentMatchesTypesAndSearchCriteria() throws Exception {\n        final LuceneDocumentMetadata documentMetadata = new LuceneDocumentMetadata(\"contents\")\n            .withField(\"modified\", Date.class);\n        \n        final Document document = extractor.extract(\n            getClass().getResourceAsStream(\"/files/testPDF.pdf\"), documentMetadata);\n        assertNotNull(\"Document should not be null\", document);\n        \n        writer.addDocument(document);\n        writer.commit();\n\n        assertEquals(1, getHits(\"modified==2007-09-15T09:02:31Z\").length);\n    }","id":72164,"modified_method":"@Test\n    public void testExtractedTextContentMatchesTypesAndSearchCriteria() throws Exception {\n        final LuceneDocumentMetadata documentMetadata = new LuceneDocumentMetadata(\"contents\")\n            .withField(\"modified\", Date.class);\n        \n        final Document document = extractor.extract(\n            getClass().getResourceAsStream(\"/files/testPDF.pdf\"), documentMetadata);\n        assertNotNull(\"Document should not be null\", document);\n        \n        writer.addDocument(document);\n        writer.commit();\n\n        assertEquals(1, getHits(\"modified=gt=2007-09-14T09:02:31\", documentMetadata.getFieldTypes()).length);\n        assertEquals(0, getHits(\"modified=gt=2007-09-16T09:02:31\", documentMetadata.getFieldTypes()).length);\n        assertEquals(0, getHits(\"modified=lt=2007-09-01T09:02:31\", documentMetadata.getFieldTypes()).length);\n    }","commit_id":"16cff265ea0002e225b1bdbbaa6b5a621e0a182b","url":"https://github.com/apache/cxf"},{"original_method":"private ScoreDoc[] getHits(final String expression) throws IOException {\n        IndexReader reader = DirectoryReader.open(directory);\n        IndexSearcher searcher = new IndexSearcher(reader);        \n\n        try {\n            LuceneQueryVisitor<SearchBean> visitor = new LuceneQueryVisitor<SearchBean>(\"ct\", \"contents\");\n            visitor.visit(parser.parse(expression));\n    \n            ScoreDoc[] hits = searcher.search(visitor.getQuery(), null, 1000).scoreDocs;\n            assertNotNull(hits);\n            \n            return hits;            \n        } finally {\n            reader.close();\n        }\n    }","id":72165,"modified_method":"private ScoreDoc[] getHits(final String expression) throws IOException {\n        return getHits(expression, new HashMap<String, Class<?>>());\n    }","commit_id":"16cff265ea0002e225b1bdbbaa6b5a621e0a182b","url":"https://github.com/apache/cxf"},{"original_method":"public String getOuterAttrs() {\n\t\tfinal StringBuffer sb =\n\t\t\tnew StringBuffer(64).append(super.getOuterAttrs());\n\n\t\tappendAsapAttr(sb, Events.ON_CHANGE);\n\t\tappendAsapAttr(sb, Events.ON_CHANGING);\n\t\tappendAsapAttr(sb, Events.ON_FOCUS);\n\t\tappendAsapAttr(sb, Events.ON_BLUR);\n\t\tappendAsapAttr(sb, Events.ON_SELECTION);\n\t\tappendAsapAttr(sb, Events.ON_OK);\n\n\t\tif (_constr != null) {\n\t\t\tString serverValid = null;\n\t\t\tif (_constr instanceof CustomConstraint) {\n\t\t\t\tserverValid = \"custom\";\n\t\t\t\t\t//validate-at-server is required and no client validation\n\t\t\t} else if (_constr instanceof ClientConstraint) {\n\t\t\t\tfinal ClientConstraint cc = (ClientConstraint)_constr;\n\t\t\t\tHTMLs.appendAttribute(sb, \"z.valid\",\n\t\t\t\t\ttoJavaScript(cc.getClientValidation()));\n\t\t\t\tHTMLs.appendAttribute(sb, \"z.ermg\", cc.getErrorMessage(this));\n\t\t\t\tif (!cc.isClientComplete())\n\t\t\t\t\tserverValid = \"both\";\n\t\t\t\t\t//validate-at-server is required after the client validation\n\t\t\t} else {\n\t\t\t\tserverValid = \"both\";\n\t\t\t}\n\t\t\tHTMLs.appendAttribute(sb, \"z.srvald\", serverValid);\n\t\t}\n\t\treturn sb.toString();\n\t}","id":72166,"modified_method":"public String getOuterAttrs() {\n\t\tfinal StringBuffer sb =\n\t\t\tnew StringBuffer(64).append(super.getOuterAttrs());\n\n\t\tappendAsapAttr(sb, Events.ON_CHANGE);\n\t\tappendAsapAttr(sb, Events.ON_CHANGING);\n\t\tappendAsapAttr(sb, Events.ON_FOCUS);\n\t\tappendAsapAttr(sb, Events.ON_BLUR);\n\t\tappendAsapAttr(sb, Events.ON_SELECTION);\n\t\tappendAsapAttr(sb, Events.ON_OK);\n\n\t\tString serverValid = null;\n\t\tif (_constr != null) {\n\t\t\tif (_constr instanceof CustomConstraint) {\n\t\t\t\tserverValid = \"custom\";\n\t\t\t\t\t//validate-at-server is required and no client validation\n\t\t\t} else if (_constr instanceof ClientConstraint) {\n\t\t\t\tfinal ClientConstraint cc = (ClientConstraint)_constr;\n\t\t\t\tHTMLs.appendAttribute(sb, \"z.valid\",\n\t\t\t\t\ttoJavaScript(cc.getClientValidation()));\n\t\t\t\tHTMLs.appendAttribute(sb, \"z.ermg\", cc.getErrorMessage(this));\n\t\t\t\tif (!cc.isClientComplete())\n\t\t\t\t\tserverValid = \"both\";\n\t\t\t\t\t//validate-at-server is required after the client validation\n\t\t\t} else {\n\t\t\t\tserverValid = \"both\";\n\t\t\t}\n\t\t}\n\n\t\tif (serverValid == null && shallServerFormat())\n\t\t\tserverValid = \"fmt\";\n\t\tHTMLs.appendAttribute(sb, \"z.srvald\", serverValid);\n\n\t\treturn sb.toString();\n\t}","commit_id":"b1c3ccfeeea9c94b8f475dad78e6a1538aae3d83","url":"https://github.com/zkoss/zk"},{"original_method":"private WrongValueException outOfRangeValue(Component comp) {\n\t\tfinal String errmsg = getErrorMessage(comp);\n\t\treturn errmsg != null ? new WrongValueException(comp, errmsg):\n\t\t\tnew WrongValueException(comp, MZul.OUT_OF_RANGE,\n\t\t\t\tnew Object[] {dateToString(comp, _beg), dateToString(comp, _end)});\n\t}","id":72167,"modified_method":"private WrongValueException outOfRangeValue(Component comp) {\n\t\tfinal String errmsg = getErrorMessage(comp);\n\t\tif (errmsg != null)\n\t\t\treturn new WrongValueException(comp, errmsg);\n\n\t\tfinal String s =\n\t\t\t_beg != null ? _end != null ?\n\t\t\t\t\tdateToString(comp, _beg) + \" ~ \" + dateToString(comp, _end):\n\t\t\t\t\t\">= \" + dateToString(comp, _beg):\n\t\t\t\t\t\"<= \" + dateToString(comp, _end);\n\t\treturn new WrongValueException(comp, MZul.OUT_OF_RANGE, s);\n\t}","commit_id":"b1c3ccfeeea9c94b8f475dad78e6a1538aae3d83","url":"https://github.com/zkoss/zk"},{"original_method":"private WrongValueException outOfRangeValue(Component comp) {\r\n\t\tfinal String errmsg = getErrorMessage(comp);\r\n\t\treturn errmsg != null ? new WrongValueException(comp, errmsg)\r\n\t\t\t\t: new WrongValueException(comp, MZul.OUT_OF_RANGE,\r\n\t\t\t\t\t\tnew Object[] { _min.toString(), _max.toString() });\r\n\t}","id":72168,"modified_method":"private WrongValueException outOfRangeValue(Component comp) {\r\n\t\tfinal String errmsg = getErrorMessage(comp);\r\n\t\tif (errmsg != null)\r\n\t\t\treturn new WrongValueException(comp, errmsg);\r\n\r\n\t\tfinal String s =\r\n\t\t\t_min != null ? _max != null ?\r\n\t\t\t\t_min + \" ~ \" + _max: \">= \" + _min: \"<= \" + _max;\r\n\t\treturn new WrongValueException(comp, MZul.OUT_OF_RANGE, s);\r\n\t}","commit_id":"b1c3ccfeeea9c94b8f475dad78e6a1538aae3d83","url":"https://github.com/zkoss/zk"},{"original_method":"@Override\n        public String toString(final Date value) {\n            return DateTools.dateToString(value, Resolution.MILLISECOND);\n        }","id":72169,"modified_method":"@Override\n        public String toString(final Date value) {\n            return value != null ? DateTools.dateToString(value, Resolution.MILLISECOND) : null;\n        }","commit_id":"32caf7feff3b8730d797f428be5d0d80148be062","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n            JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();\n            \n            final Map< String, Object > properties = new HashMap< String, Object >();        \n            properties.put(\"search.query.parameter.name\", \"$filter\");\n            properties.put(\"search.parser\", new FiqlParser< SearchBean >(SearchBean.class));\n            \n            sf.setResourceClasses(BookCatalog.class);\n            sf.setResourceProvider(BookCatalog.class, new SingletonResourceProvider(new BookCatalog()));\n            sf.setAddress(\"http://localhost:\" + PORT + \"/\");\n            sf.setProperties(properties);\n            sf.setProvider(new MultipartProvider());\n            sf.setProvider(new SearchContextProvider());\n            sf.setProvider(new JacksonJsonProvider());\n            \n            sf.create();\n        }","id":72170,"modified_method":"protected void run() {\n            JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();\n            \n            final Map< String, Object > properties = new HashMap< String, Object >();        \n            properties.put(\"search.query.parameter.name\", \"$filter\");\n            properties.put(\"search.parser\", new FiqlParser< SearchBean >(SearchBean.class));\n            properties.put(SearchUtils.DATE_FORMAT_PROPERTY, \"yyyy/MM/dd\");\n            \n            sf.setResourceClasses(BookCatalog.class);\n            sf.setResourceProvider(BookCatalog.class, new SingletonResourceProvider(new BookCatalog()));\n            sf.setAddress(\"http://localhost:\" + PORT + \"/\");\n            sf.setProperties(properties);\n            sf.setProvider(new MultipartProvider());\n            sf.setProvider(new SearchContextProvider());\n            sf.setProvider(new JacksonJsonProvider());\n            \n            sf.create();\n        }","commit_id":"32caf7feff3b8730d797f428be5d0d80148be062","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUploadIndexAndSearchPdfFile() {\n        final WebClient wc = createWebClient(\"/catalog\").type(MediaType.MULTIPART_FORM_DATA);\n        \n        final ContentDisposition disposition = new ContentDisposition(\"attachment;filename=testPDF.pdf\");\n        final Attachment attachment = new Attachment(\"root\", \n            getClass().getResourceAsStream(\"/files/testPDF.pdf\"), disposition);\n        wc.post(new MultipartBody(attachment));\n        \n        final Collection<ScoreDoc> hits = search(\"modified=le=2007-09-16\");        \n        assertEquals(hits.size(), 1);\n    }","id":72171,"modified_method":"@Test\n    public void testUploadIndexAndSearchPdfFile() {\n        final WebClient wc = createWebClient(\"/catalog\").type(MediaType.MULTIPART_FORM_DATA);\n        \n        final ContentDisposition disposition = new ContentDisposition(\"attachment;filename=testPDF.pdf\");\n        final Attachment attachment = new Attachment(\"root\", \n            getClass().getResourceAsStream(\"/files/testPDF.pdf\"), disposition);\n        wc.post(new MultipartBody(attachment));\n        \n        final Collection<ScoreDoc> hits = search(\"modified=le=2007-09-16T09:00:00\");        \n        assertEquals(hits.size(), 1);\n    }","commit_id":"32caf7feff3b8730d797f428be5d0d80148be062","url":"https://github.com/apache/cxf"},{"original_method":"private static ExtensionContext initializeDomainRegistry(final ModelNodeRegistration root, final ExtensibleConfigurationPersister configurationPersister,\n            final DeploymentRepository deploymentRepo, final FileRepository fileRepository, final boolean isMaster, DomainModelImpl model) {\n        // Global operations\n\n        root.registerOperationHandler(GlobalOperationHandlers.ResolveAddressOperationHandler.OPERATION_NAME, GlobalOperationHandlers.RESOLVE, GlobalOperationHandlers.RESOLVE, false, OperationEntry.EntryType.PRIVATE);\n        root.registerOperationHandler(READ_RESOURCE_OPERATION, new ReadResourceHandler(model), CommonProviders.READ_RESOURCE_PROVIDER, true);\n        root.registerOperationHandler(READ_ATTRIBUTE_OPERATION, GlobalOperationHandlers.READ_ATTRIBUTE, CommonProviders.READ_ATTRIBUTE_PROVIDER, true);\n        root.registerOperationHandler(READ_RESOURCE_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_RESOURCE_DESCRIPTION, CommonProviders.READ_RESOURCE_DESCRIPTION_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_NAMES_OPERATION, new ReadChildrenNamesHandler(model), CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_TYPES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_TYPES, CommonProviders.READ_CHILDREN_TYPES_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_RESOURCES_OPERATION, new GlobalOperationHandlers.ReadChildrenResourcesOperationHandler(), CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_OPERATION_NAMES_OPERATION, GlobalOperationHandlers.READ_OPERATION_NAMES, CommonProviders.READ_OPERATION_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_OPERATION_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_OPERATION_DESCRIPTION, CommonProviders.READ_OPERATION_PROVIDER, true);\n        root.registerOperationHandler(WRITE_ATTRIBUTE_OPERATION, GlobalOperationHandlers.WRITE_ATTRIBUTE, CommonProviders.WRITE_ATTRIBUTE_PROVIDER, true);\n\n        // Other root resource operations\n        root.registerOperationHandler(NamespaceAddHandler.OPERATION_NAME, NamespaceAddHandler.INSTANCE, NamespaceAddHandler.INSTANCE, false);\n        root.registerOperationHandler(NamespaceRemoveHandler.OPERATION_NAME, NamespaceRemoveHandler.INSTANCE, NamespaceRemoveHandler.INSTANCE, false);\n        root.registerOperationHandler(SchemaLocationAddHandler.OPERATION_NAME, SchemaLocationAddHandler.INSTANCE, SchemaLocationAddHandler.INSTANCE, false);\n        root.registerOperationHandler(SchemaLocationRemoveHandler.OPERATION_NAME, SchemaLocationRemoveHandler.INSTANCE, SchemaLocationRemoveHandler.INSTANCE, false);\n        root.registerOperationHandler(SystemPropertyAddHandler.OPERATION_NAME, SystemPropertyAddHandler.INSTANCE, SystemPropertyAddHandler.INSTANCE, false);\n        root.registerOperationHandler(SystemPropertyRemoveHandler.OPERATION_NAME, SystemPropertyRemoveHandler.INSTANCE, SystemPropertyRemoveHandler.INSTANCE, false);\n        DeploymentUploadBytesHandler dubh = new DeploymentUploadBytesHandler(isMaster ? deploymentRepo: null);\n        root.registerOperationHandler(DeploymentUploadBytesHandler.OPERATION_NAME, dubh, dubh);\n        DeploymentUploadURLHandler duuh = new DeploymentUploadURLHandler(isMaster ? deploymentRepo: null);\n        root.registerOperationHandler(DeploymentUploadURLHandler.OPERATION_NAME, duuh, duuh);\n        DeploymentUploadStreamAttachmentHandler dush = new DeploymentUploadStreamAttachmentHandler(isMaster ? deploymentRepo: null);\n        root.registerOperationHandler(DeploymentUploadStreamAttachmentHandler.OPERATION_NAME, dush, dush);\n        DeploymentFullReplaceHandler dfrh = new DeploymentFullReplaceHandler(deploymentRepo, isMaster);\n        root.registerOperationHandler(DeploymentFullReplaceHandler.OPERATION_NAME, dfrh, dfrh);\n\n        final ModelNodeRegistration interfaces = root.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.NAMED_INTERFACE_PROVIDER);\n        interfaces.registerOperationHandler(ADD, InterfaceAddHandler.NAMED_INSTANCE, InterfaceAddHandler.NAMED_INSTANCE, false);\n        interfaces.registerOperationHandler(REMOVE, InterfaceAddHandler.NAMED_INSTANCE, InterfaceAddHandler.NAMED_INSTANCE, false);\n\n        final ModelNodeRegistration profile = root.registerSubModel(PathElement.pathElement(PROFILE), DomainDescriptionProviders.PROFILE);\n        profile.registerOperationHandler(ADD, ProfileAddHandler.INSTANCE, DomainDescriptionProviders.PROFILE_ADD, false);\n        profile.registerOperationHandler(REMOVE, ProfileRemoveHandler.INSTANCE, DomainDescriptionProviders.PROFILE_REMOVE, false);\n        profile.registerOperationHandler(DESCRIBE, ProfileDescribeHandler.INSTANCE, DomainDescriptionProviders.PROFILE_DESCRIBE, false);\n\n        final ModelNodeRegistration paths = root.registerSubModel(PathElement.pathElement(PATH), DomainDescriptionProviders.PATH_DESCRIPTION);\n        paths.registerOperationHandler(ADD, PathAddHandler.NAMED_INSTANCE, DomainDescriptionProviders.PATH_ADD, false);\n        paths.registerOperationHandler(REMOVE, PathRemoveHandler.INSTANCE, DomainDescriptionProviders.PATH_REMOVE, false);\n\n        final ModelNodeRegistration socketBindingGroup = root.registerSubModel(PathElement.pathElement(SOCKET_BINDING_GROUP), DomainDescriptionProviders.SOCKET_BINDING_GROUP);\n        socketBindingGroup.registerOperationHandler(ADD, SocketBindingGroupAddHandler.INSTANCE, DomainDescriptionProviders.SOCKET_BINDING_GROUP, false);\n        // TODO remove\n        final ModelNodeRegistration socketBindings = socketBindingGroup.registerSubModel(PathElement.pathElement(SOCKET_BINDING), DomainDescriptionProviders.SOCKET_BINDING);\n        socketBindings.registerOperationHandler(ADD, SocketBindingAddHandler.INSTANCE, DomainDescriptionProviders.SOCKET_BINDING_ADD, false);\n        socketBindings.registerOperationHandler(REMOVE, SocketBindingRemoveHandler.INSTANCE, DomainDescriptionProviders.SOCKET_BINDING_REMOVE, false);\n\n        final ModelNodeRegistration serverGroups = root.registerSubModel(PathElement.pathElement(SERVER_GROUP), DomainDescriptionProviders.SERVER_GROUP);\n        serverGroups.registerOperationHandler(ADD, ServerGroupAddHandler.INSTANCE, DomainDescriptionProviders.SERVER_GROUP_ADD, false);\n        serverGroups.registerOperationHandler(REMOVE, ServerGroupRemoveHandler.INSTANCE, DomainDescriptionProviders.SERVER_GROUP_REMOVE, false);\n        serverGroups.registerReadWriteAttribute(SOCKET_BINDING_GROUP, null, WriteAttributeHandlers.WriteAttributeOperationHandler.INSTANCE, Storage.CONFIGURATION);\n        serverGroups.registerReadWriteAttribute(SOCKET_BINDING_PORT_OFFSET, null, new WriteAttributeHandlers.IntRangeValidatingHandler(1), Storage.CONFIGURATION);\n        final ModelNodeRegistration groupVMs = serverGroups.registerSubModel(PathElement.pathElement(JVM), CommonProviders.JVM_PROVIDER);\n        JVMHandlers.register(groupVMs);\n        final ModelNodeRegistration serverGroupDeployments = serverGroups.registerSubModel(PathElement.pathElement(DEPLOYMENT), DomainDescriptionProviders.SERVER_GROUP_DEPLOYMENT);\n        ServerGroupDeploymentAddHandler sgdah = new ServerGroupDeploymentAddHandler(fileRepository);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentAddHandler.OPERATION_NAME, sgdah, sgdah);\n        ServerGroupDeploymentReplaceHandler sgdrh = new ServerGroupDeploymentReplaceHandler(fileRepository);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentReplaceHandler.OPERATION_NAME, sgdrh, sgdrh);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentDeployHandler.OPERATION_NAME, ServerGroupDeploymentDeployHandler.INSTANCE, ServerGroupDeploymentDeployHandler.INSTANCE);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentRedeployHandler.OPERATION_NAME, ServerGroupDeploymentRedeployHandler.INSTANCE, ServerGroupDeploymentRedeployHandler.INSTANCE);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentUndeployHandler.OPERATION_NAME, ServerGroupDeploymentUndeployHandler.INSTANCE, ServerGroupDeploymentUndeployHandler.INSTANCE);\n        serverGroupDeployments.registerOperationHandler(DeploymentRemoveHandler.OPERATION_NAME, DeploymentRemoveHandler.INSTANCE, DeploymentRemoveHandler.INSTANCE);\n\n        // Root Deployments\n        final ModelNodeRegistration deployments = root.registerSubModel(PathElement.pathElement(DEPLOYMENT), ServerDescriptionProviders.DEPLOYMENT_PROVIDER);\n        DeploymentAddHandler dah = new DeploymentAddHandler(deploymentRepo, isMaster);\n        deployments.registerOperationHandler(DeploymentAddHandler.OPERATION_NAME, dah, dah);\n        deployments.registerOperationHandler(DeploymentRemoveHandler.OPERATION_NAME, DeploymentRemoveHandler.INSTANCE, DeploymentRemoveHandler.INSTANCE);\n\n        // Extensions\n        final ModelNodeRegistration extensions = root.registerSubModel(PathElement.pathElement(EXTENSION), CommonProviders.EXTENSION_PROVIDER);\n        final ExtensionContext extensionContext = new ExtensionContextImpl(profile, deployments, configurationPersister);\n        final ExtensionAddHandler addExtensionHandler = new ExtensionAddHandler(extensionContext);\n        extensions.registerOperationHandler(ExtensionAddHandler.OPERATION_NAME, addExtensionHandler, addExtensionHandler, false);\n        extensions.registerOperationHandler(ExtensionRemoveHandler.OPERATION_NAME, ExtensionRemoveHandler.INSTANCE, ExtensionRemoveHandler.INSTANCE, false);\n\n        return extensionContext;\n    }","id":72172,"modified_method":"private static ExtensionContext initializeDomainRegistry(final ModelNodeRegistration root, final ExtensibleConfigurationPersister configurationPersister,\n            final DeploymentRepository deploymentRepo, final FileRepository fileRepository, final boolean isMaster, DomainModelImpl model) {\n        // Global operations\n\n        root.registerOperationHandler(GlobalOperationHandlers.ResolveAddressOperationHandler.OPERATION_NAME, GlobalOperationHandlers.RESOLVE, GlobalOperationHandlers.RESOLVE, false, OperationEntry.EntryType.PRIVATE);\n        root.registerOperationHandler(READ_RESOURCE_OPERATION, new ReadResourceHandler(model), CommonProviders.READ_RESOURCE_PROVIDER, true);\n        root.registerOperationHandler(READ_ATTRIBUTE_OPERATION, GlobalOperationHandlers.READ_ATTRIBUTE, CommonProviders.READ_ATTRIBUTE_PROVIDER, true);\n        root.registerOperationHandler(READ_RESOURCE_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_RESOURCE_DESCRIPTION, CommonProviders.READ_RESOURCE_DESCRIPTION_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_NAMES_OPERATION, new ReadChildrenNamesHandler(model), CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_TYPES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_TYPES, CommonProviders.READ_CHILDREN_TYPES_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_RESOURCES_OPERATION, new GlobalOperationHandlers.ReadChildrenResourcesOperationHandler(), CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_OPERATION_NAMES_OPERATION, GlobalOperationHandlers.READ_OPERATION_NAMES, CommonProviders.READ_OPERATION_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_OPERATION_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_OPERATION_DESCRIPTION, CommonProviders.READ_OPERATION_PROVIDER, true);\n        root.registerOperationHandler(WRITE_ATTRIBUTE_OPERATION, GlobalOperationHandlers.WRITE_ATTRIBUTE, CommonProviders.WRITE_ATTRIBUTE_PROVIDER, true);\n\n        // Other root resource operations\n        root.registerOperationHandler(NamespaceAddHandler.OPERATION_NAME, NamespaceAddHandler.INSTANCE, NamespaceAddHandler.INSTANCE, false);\n        root.registerOperationHandler(NamespaceRemoveHandler.OPERATION_NAME, NamespaceRemoveHandler.INSTANCE, NamespaceRemoveHandler.INSTANCE, false);\n        root.registerOperationHandler(SchemaLocationAddHandler.OPERATION_NAME, SchemaLocationAddHandler.INSTANCE, SchemaLocationAddHandler.INSTANCE, false);\n        root.registerOperationHandler(SchemaLocationRemoveHandler.OPERATION_NAME, SchemaLocationRemoveHandler.INSTANCE, SchemaLocationRemoveHandler.INSTANCE, false);\n        root.registerOperationHandler(SystemPropertyAddHandler.OPERATION_NAME, SystemPropertyAddHandler.INSTANCE, SystemPropertyAddHandler.INSTANCE, false);\n        root.registerOperationHandler(SystemPropertyRemoveHandler.OPERATION_NAME, SystemPropertyRemoveHandler.INSTANCE, SystemPropertyRemoveHandler.INSTANCE, false);\n        DeploymentUploadBytesHandler dubh = new DeploymentUploadBytesHandler(isMaster ? deploymentRepo: null);\n        root.registerOperationHandler(DeploymentUploadBytesHandler.OPERATION_NAME, dubh, dubh);\n        DeploymentUploadURLHandler duuh = new DeploymentUploadURLHandler(isMaster ? deploymentRepo: null);\n        root.registerOperationHandler(DeploymentUploadURLHandler.OPERATION_NAME, duuh, duuh);\n        DeploymentUploadStreamAttachmentHandler dush = new DeploymentUploadStreamAttachmentHandler(isMaster ? deploymentRepo: null);\n        root.registerOperationHandler(DeploymentUploadStreamAttachmentHandler.OPERATION_NAME, dush, dush);\n        DeploymentFullReplaceHandler dfrh = new DeploymentFullReplaceHandler(deploymentRepo, isMaster);\n        root.registerOperationHandler(DeploymentFullReplaceHandler.OPERATION_NAME, dfrh, dfrh);\n\n        final ModelNodeRegistration interfaces = root.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.NAMED_INTERFACE_PROVIDER);\n        interfaces.registerOperationHandler(ADD, InterfaceAddHandler.NAMED_INSTANCE, InterfaceAddHandler.NAMED_INSTANCE, false);\n        interfaces.registerOperationHandler(REMOVE, InterfaceAddHandler.NAMED_INSTANCE, InterfaceAddHandler.NAMED_INSTANCE, false);\n\n        final ModelNodeRegistration profile = root.registerSubModel(PathElement.pathElement(PROFILE), DomainDescriptionProviders.PROFILE);\n        profile.registerOperationHandler(ADD, ProfileAddHandler.INSTANCE, DomainDescriptionProviders.PROFILE_ADD, false);\n        profile.registerOperationHandler(REMOVE, ProfileRemoveHandler.INSTANCE, DomainDescriptionProviders.PROFILE_REMOVE, false);\n        profile.registerOperationHandler(DESCRIBE, ProfileDescribeHandler.INSTANCE, DomainDescriptionProviders.PROFILE_DESCRIBE, false);\n\n        final ModelNodeRegistration paths = root.registerSubModel(PathElement.pathElement(PATH), DomainDescriptionProviders.PATH_DESCRIPTION);\n        paths.registerOperationHandler(ADD, PathAddHandler.NAMED_INSTANCE, DomainDescriptionProviders.PATH_ADD, false);\n        paths.registerOperationHandler(REMOVE, PathRemoveHandler.INSTANCE, DomainDescriptionProviders.PATH_REMOVE, false);\n\n        final ModelNodeRegistration socketBindingGroup = root.registerSubModel(PathElement.pathElement(SOCKET_BINDING_GROUP), DomainDescriptionProviders.SOCKET_BINDING_GROUP);\n        socketBindingGroup.registerOperationHandler(ADD, SocketBindingGroupAddHandler.INSTANCE, DomainDescriptionProviders.SOCKET_BINDING_GROUP_ADD, false);\n        socketBindingGroup.registerOperationHandler(REMOVE, SocketBindingGroupRemoveHandler.INSTANCE, DomainDescriptionProviders.SOCKET_BINDING_GROUP_REMOVE, false);\n        socketBindingGroup.registerReadWriteAttribute(PORT_OFFSET, null, new IntRangeValidatingHandler(0, 65535, true, true), AttributeAccess.Storage.CONFIGURATION);\n        socketBindingGroup.registerReadWriteAttribute(DEFAULT_INTERFACE, null, new StringLengthValidatingHandler(1, false, true), AttributeAccess.Storage.CONFIGURATION);\n        final ModelNodeRegistration socketBindings = socketBindingGroup.registerSubModel(PathElement.pathElement(SOCKET_BINDING), DomainDescriptionProviders.SOCKET_BINDING);\n        socketBindings.registerOperationHandler(ADD, SocketBindingAddHandler.INSTANCE, DomainDescriptionProviders.SOCKET_BINDING_ADD, false);\n        socketBindings.registerOperationHandler(REMOVE, SocketBindingRemoveHandler.INSTANCE, DomainDescriptionProviders.SOCKET_BINDING_REMOVE, false);\n        socketBindings.registerReadWriteAttribute(INTERFACE, null, new StringLengthValidatingHandler(1, true, true), AttributeAccess.Storage.CONFIGURATION);\n        socketBindings.registerReadWriteAttribute(PORT, null, new IntRangeValidatingHandler(0, 65535, false, true), AttributeAccess.Storage.CONFIGURATION);\n        socketBindings.registerReadWriteAttribute(FIXED_PORT, null, new ModelTypeValidatingHandler(ModelType.BOOLEAN, true, true), AttributeAccess.Storage.CONFIGURATION);\n        socketBindings.registerReadWriteAttribute(MULTICAST_ADDRESS, null, new InetAddressValidatingHandler(true, true), AttributeAccess.Storage.CONFIGURATION);\n        socketBindings.registerReadWriteAttribute(MULTICAST_PORT, null, new IntRangeValidatingHandler(0, 65535, true, true), AttributeAccess.Storage.CONFIGURATION);\n\n        final ModelNodeRegistration serverGroups = root.registerSubModel(PathElement.pathElement(SERVER_GROUP), DomainDescriptionProviders.SERVER_GROUP);\n        serverGroups.registerOperationHandler(ADD, ServerGroupAddHandler.INSTANCE, DomainDescriptionProviders.SERVER_GROUP_ADD, false);\n        serverGroups.registerOperationHandler(REMOVE, ServerGroupRemoveHandler.INSTANCE, DomainDescriptionProviders.SERVER_GROUP_REMOVE, false);\n        serverGroups.registerReadWriteAttribute(SOCKET_BINDING_GROUP, null, WriteAttributeHandlers.WriteAttributeOperationHandler.INSTANCE, Storage.CONFIGURATION);\n        serverGroups.registerReadWriteAttribute(SOCKET_BINDING_PORT_OFFSET, null, new WriteAttributeHandlers.IntRangeValidatingHandler(1), Storage.CONFIGURATION);\n        final ModelNodeRegistration groupVMs = serverGroups.registerSubModel(PathElement.pathElement(JVM), CommonProviders.JVM_PROVIDER);\n        JVMHandlers.register(groupVMs);\n        final ModelNodeRegistration serverGroupDeployments = serverGroups.registerSubModel(PathElement.pathElement(DEPLOYMENT), DomainDescriptionProviders.SERVER_GROUP_DEPLOYMENT);\n        ServerGroupDeploymentAddHandler sgdah = new ServerGroupDeploymentAddHandler(fileRepository);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentAddHandler.OPERATION_NAME, sgdah, sgdah);\n        ServerGroupDeploymentReplaceHandler sgdrh = new ServerGroupDeploymentReplaceHandler(fileRepository);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentReplaceHandler.OPERATION_NAME, sgdrh, sgdrh);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentDeployHandler.OPERATION_NAME, ServerGroupDeploymentDeployHandler.INSTANCE, ServerGroupDeploymentDeployHandler.INSTANCE);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentRedeployHandler.OPERATION_NAME, ServerGroupDeploymentRedeployHandler.INSTANCE, ServerGroupDeploymentRedeployHandler.INSTANCE);\n        serverGroupDeployments.registerOperationHandler(ServerGroupDeploymentUndeployHandler.OPERATION_NAME, ServerGroupDeploymentUndeployHandler.INSTANCE, ServerGroupDeploymentUndeployHandler.INSTANCE);\n        serverGroupDeployments.registerOperationHandler(DeploymentRemoveHandler.OPERATION_NAME, DeploymentRemoveHandler.INSTANCE, DeploymentRemoveHandler.INSTANCE);\n\n        // Root Deployments\n        final ModelNodeRegistration deployments = root.registerSubModel(PathElement.pathElement(DEPLOYMENT), ServerDescriptionProviders.DEPLOYMENT_PROVIDER);\n        DeploymentAddHandler dah = new DeploymentAddHandler(deploymentRepo, isMaster);\n        deployments.registerOperationHandler(DeploymentAddHandler.OPERATION_NAME, dah, dah);\n        deployments.registerOperationHandler(DeploymentRemoveHandler.OPERATION_NAME, DeploymentRemoveHandler.INSTANCE, DeploymentRemoveHandler.INSTANCE);\n\n        // Extensions\n        final ModelNodeRegistration extensions = root.registerSubModel(PathElement.pathElement(EXTENSION), CommonProviders.EXTENSION_PROVIDER);\n        final ExtensionContext extensionContext = new ExtensionContextImpl(profile, deployments, configurationPersister);\n        final ExtensionAddHandler addExtensionHandler = new ExtensionAddHandler(extensionContext);\n        extensions.registerOperationHandler(ExtensionAddHandler.OPERATION_NAME, addExtensionHandler, addExtensionHandler, false);\n        extensions.registerOperationHandler(ExtensionRemoveHandler.OPERATION_NAME, ExtensionRemoveHandler.INSTANCE, ExtensionRemoveHandler.INSTANCE, false);\n\n        return extensionContext;\n    }","commit_id":"9f26805fe7d2cfacb32b6dfb0c08bc4e9e943509","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addSocketBindings(List<ModelNode> updates, int portOffSet, String bindingRef) {\n        final Set<String> processed = new HashSet<String>();\n        final Map<String, ModelNode> groups = new LinkedHashMap<String, ModelNode>();\n        if(domainModel.hasDefined(SOCKET_BINDING_GROUP)) {\n            for (Property prop : domainModel.get(SOCKET_BINDING_GROUP).asPropertyList()) {\n                ModelNode node = prop.getValue().clone();\n                if (portOffSet > 0) {\n                    node.get(PORT_OFFSET).set(portOffSet);\n                }\n                groups.put(prop.getName(), node);\n            }\n        }\n        final ModelNode group = groups.get(bindingRef);\n        if(group == null) {\n            throw new IllegalArgumentException(\"undefined socket binding group \" + bindingRef);\n        }\n        final ModelNode groupAddress = pathAddress(PathElement.pathElement(SOCKET_BINDING_GROUP, bindingRef));\n        final ModelNode groupAdd = SocketBindingGroupAddHandler.getOperation(groupAddress, group);\n        groupAdd.get(PORT_OFFSET).set(portOffSet);\n        updates.add(groupAdd);\n        mergeBindingGroups(updates, groups, bindingRef, group, processed, group.get(INTERFACE));\n    }","id":72173,"modified_method":"private void addSocketBindings(List<ModelNode> updates, int portOffSet, String bindingRef) {\n        final Set<String> processed = new HashSet<String>();\n        final Map<String, ModelNode> groups = new LinkedHashMap<String, ModelNode>();\n        if(domainModel.hasDefined(SOCKET_BINDING_GROUP)) {\n            for (Property prop : domainModel.get(SOCKET_BINDING_GROUP).asPropertyList()) {\n                ModelNode node = prop.getValue().clone();\n                if (portOffSet > 0) {\n                    node.get(PORT_OFFSET).set(portOffSet);\n                }\n                groups.put(prop.getName(), node);\n            }\n        }\n        final ModelNode group = groups.get(bindingRef);\n        if(group == null) {\n            throw new IllegalArgumentException(\"undefined socket binding group \" + bindingRef);\n        }\n        final ModelNode groupAddress = pathAddress(PathElement.pathElement(SOCKET_BINDING_GROUP, bindingRef));\n        final ModelNode groupAdd = BindingGroupAddHandler.getOperation(groupAddress, group);\n        groupAdd.get(PORT_OFFSET).set(portOffSet);\n        updates.add(groupAdd);\n        mergeBindingGroups(updates, groups, bindingRef, group, processed, group.get(INTERFACE));\n    }","commit_id":"9f26805fe7d2cfacb32b6dfb0c08bc4e9e943509","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void initOperations(final ModelNodeRegistration root, final DeploymentRepository deploymentRepository, final ExtensibleConfigurationPersister extensibleConfigurationPersister) {\n        // Build up the core model registry\n        root.registerReadWriteAttribute(NAME, null, new StringLengthValidatingHandler(1), AttributeAccess.Storage.CONFIGURATION);\n        // Global operations\n        root.registerOperationHandler(GlobalOperationHandlers.ResolveAddressOperationHandler.OPERATION_NAME, GlobalOperationHandlers.RESOLVE, GlobalOperationHandlers.RESOLVE, false, OperationEntry.EntryType.PRIVATE);\n        root.registerOperationHandler(READ_RESOURCE_OPERATION, ServerOperationHandlers.SERVER_READ_RESOURCE_HANDLER, CommonProviders.READ_RESOURCE_PROVIDER, true);\n        root.registerOperationHandler(READ_ATTRIBUTE_OPERATION, ServerOperationHandlers.SERVER_READ_ATTRIBUTE_HANDLER, CommonProviders.READ_ATTRIBUTE_PROVIDER, true);\n        root.registerOperationHandler(READ_RESOURCE_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_RESOURCE_DESCRIPTION, CommonProviders.READ_RESOURCE_DESCRIPTION_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_NAMES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_NAMES, CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_TYPES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_TYPES, CommonProviders.READ_CHILDREN_TYPES_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_RESOURCES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_RESOURCES, CommonProviders.READ_CHILDREN_RESOURCES_PROVIDER, true);\n        root.registerOperationHandler(READ_OPERATION_NAMES_OPERATION, GlobalOperationHandlers.READ_OPERATION_NAMES, CommonProviders.READ_OPERATION_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_OPERATION_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_OPERATION_DESCRIPTION, CommonProviders.READ_OPERATION_PROVIDER, true);\n        root.registerOperationHandler(WRITE_ATTRIBUTE_OPERATION, ServerOperationHandlers.SERVER_WRITE_ATTRIBUTE_HANDLER, CommonProviders.WRITE_ATTRIBUTE_PROVIDER, true);\n        // Other root resource operations\n        root.registerOperationHandler(NamespaceAddHandler.OPERATION_NAME, NamespaceAddHandler.INSTANCE, NamespaceAddHandler.INSTANCE, false);\n        root.registerOperationHandler(NamespaceRemoveHandler.OPERATION_NAME, NamespaceRemoveHandler.INSTANCE, NamespaceRemoveHandler.INSTANCE, false);\n        root.registerOperationHandler(SchemaLocationAddHandler.OPERATION_NAME, SchemaLocationAddHandler.INSTANCE, SchemaLocationAddHandler.INSTANCE, false);\n        root.registerOperationHandler(SchemaLocationRemoveHandler.OPERATION_NAME, SchemaLocationRemoveHandler.INSTANCE, SchemaLocationRemoveHandler.INSTANCE, false);\n        root.registerOperationHandler(SystemPropertyAddHandler.OPERATION_NAME, SystemPropertyAddHandler.INSTANCE, SystemPropertyAddHandler.INSTANCE, false);\n        root.registerOperationHandler(SystemPropertyRemoveHandler.OPERATION_NAME, SystemPropertyRemoveHandler.INSTANCE, SystemPropertyRemoveHandler.INSTANCE, false);\n        DeploymentUploadBytesHandler dubh = new DeploymentUploadBytesHandler(deploymentRepository);\n        root.registerOperationHandler(DeploymentUploadBytesHandler.OPERATION_NAME, dubh, dubh, false);\n        DeploymentUploadURLHandler duuh = new DeploymentUploadURLHandler(deploymentRepository);\n        root.registerOperationHandler(DeploymentUploadURLHandler.OPERATION_NAME, duuh, duuh, false);\n        DeploymentUploadStreamAttachmentHandler dush = new DeploymentUploadStreamAttachmentHandler(deploymentRepository);\n        root.registerOperationHandler(DeploymentUploadStreamAttachmentHandler.OPERATION_NAME, dush, dush, false);\n        root.registerOperationHandler(DeploymentReplaceHandler.OPERATION_NAME, DeploymentReplaceHandler.INSTANCE, DeploymentReplaceHandler.INSTANCE, false);\n        DeploymentFullReplaceHandler dfrh = new DeploymentFullReplaceHandler(deploymentRepository);\n        root.registerOperationHandler(DeploymentFullReplaceHandler.OPERATION_NAME, dfrh, dfrh, false);\n//        root.registerOperationHandler(ServerCompositeOperationHandler.OPERATION_NAME, ServerCompositeOperationHandler.INSTANCE, ServerCompositeOperationHandler.INSTANCE, false);\n\n        // Runtime operations\n        root.registerOperationHandler(ServerReloadHandler.OPERATION_NAME, ServerReloadHandler.INSTANCE, ServerReloadHandler.INSTANCE, false);\n\n        // Management API protocols\n        ModelNodeRegistration managementNative = root.registerSubModel(PathElement.pathElement(MANAGEMENT_INTERFACES, NATIVE_INTERFACE), CommonProviders.MANAGEMENT_PROVIDER);\n        managementNative.registerOperationHandler(NativeManagementAddHandler.OPERATION_NAME, NativeManagementAddHandler.INSTANCE, NativeManagementAddHandler.INSTANCE, false);\n\n        ModelNodeRegistration managementHttp = root.registerSubModel(PathElement.pathElement(MANAGEMENT_INTERFACES, HTTP_INTERFACE), CommonProviders.MANAGEMENT_PROVIDER);\n        managementHttp.registerOperationHandler(HttpManagementAddHandler.OPERATION_NAME, HttpManagementAddHandler.INSTANCE, HttpManagementAddHandler.INSTANCE, false);\n        // root.registerReadWriteAttribute(ModelDescriptionConstants.MANAGEMENT_INTERFACES, GlobalOperationHandlers.READ_ATTRIBUTE, ManagementSocketAddHandler.INSTANCE);\n\n        // Paths\n        ModelNodeRegistration paths = root.registerSubModel(PathElement.pathElement(PATH), CommonProviders.SPECIFIED_PATH_PROVIDER);\n        paths.registerOperationHandler(SpecifiedPathAddHandler.OPERATION_NAME, SpecifiedPathAddHandler.INSTANCE, SpecifiedPathAddHandler.INSTANCE, false);\n        paths.registerOperationHandler(SpecifiedPathRemoveHandler.OPERATION_NAME, SpecifiedPathRemoveHandler.INSTANCE, SpecifiedPathRemoveHandler.INSTANCE, false);\n\n        // Interfaces\n        ModelNodeRegistration interfaces = root.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        interfaces.registerOperationHandler(SpecifiedInterfaceAddHandler.OPERATION_NAME, SpecifiedInterfaceAddHandler.INSTANCE, SpecifiedInterfaceAddHandler.INSTANCE, false);\n        interfaces.registerOperationHandler(SpecifiedInterfaceRemoveHandler.OPERATION_NAME, SpecifiedInterfaceRemoveHandler.INSTANCE, SpecifiedInterfaceRemoveHandler.INSTANCE, false);\n\n        // Sockets\n        ModelNodeRegistration socketGroup = root.registerSubModel(PathElement.pathElement(SOCKET_BINDING_GROUP), ServerDescriptionProviders.SOCKET_BINDING_GROUP_PROVIDER);\n        socketGroup.registerOperationHandler(SocketBindingGroupAddHandler.OPERATION_NAME, SocketBindingGroupAddHandler.INSTANCE, SocketBindingGroupAddHandler.INSTANCE, false);\n        socketGroup.registerOperationHandler(SocketBindingGroupRemoveHandler.OPERATION_NAME, SocketBindingGroupRemoveHandler.INSTANCE, SocketBindingGroupRemoveHandler.INSTANCE, false);\n        ModelNodeRegistration socketBinding = socketGroup.registerSubModel(PathElement.pathElement(SOCKET_BINDING), CommonProviders.SOCKET_BINDING_PROVIDER);\n        socketBinding.registerOperationHandler(ServerSocketBindingAddHandler.OPERATION_NAME, ServerSocketBindingAddHandler.INSTANCE, ServerSocketBindingAddHandler.INSTANCE, false);\n        socketBinding.registerOperationHandler(ServerSocketBindingRemoveHandler.OPERATION_NAME, ServerSocketBindingRemoveHandler.INSTANCE, ServerSocketBindingRemoveHandler.INSTANCE, false);\n\n        // Deployments\n        ModelNodeRegistration deployments = root.registerSubModel(PathElement.pathElement(DEPLOYMENT), ServerDescriptionProviders.DEPLOYMENT_PROVIDER);\n        DeploymentAddHandler dah = new DeploymentAddHandler(deploymentRepository);\n        deployments.registerOperationHandler(DeploymentAddHandler.OPERATION_NAME, dah, dah, false);\n        deployments.registerOperationHandler(DeploymentRemoveHandler.OPERATION_NAME, DeploymentRemoveHandler.INSTANCE, DeploymentRemoveHandler.INSTANCE, false);\n        deployments.registerOperationHandler(DeploymentDeployHandler.OPERATION_NAME, DeploymentDeployHandler.INSTANCE, DeploymentDeployHandler.INSTANCE, false);\n        deployments.registerOperationHandler(DeploymentUndeployHandler.OPERATION_NAME, DeploymentUndeployHandler.INSTANCE, DeploymentUndeployHandler.INSTANCE, false);\n        deployments.registerOperationHandler(DeploymentRedeployHandler.OPERATION_NAME, DeploymentRedeployHandler.INSTANCE, DeploymentRedeployHandler.INSTANCE, false);\n\n        // Extensions\n        ModelNodeRegistration extensions = root.registerSubModel(PathElement.pathElement(EXTENSION), CommonProviders.EXTENSION_PROVIDER);\n        ExtensionContext extensionContext = new ExtensionContextImpl(root, deployments, extensibleConfigurationPersister);\n        ExtensionAddHandler addExtensionHandler = new ExtensionAddHandler(extensionContext);\n        extensions.registerOperationHandler(ExtensionAddHandler.OPERATION_NAME, addExtensionHandler, addExtensionHandler, false);\n        extensions.registerOperationHandler(ExtensionRemoveHandler.OPERATION_NAME, ExtensionRemoveHandler.INSTANCE, ExtensionRemoveHandler.INSTANCE, false);\n\n    }","id":72174,"modified_method":"public static void initOperations(final ModelNodeRegistration root, final DeploymentRepository deploymentRepository, final ExtensibleConfigurationPersister extensibleConfigurationPersister) {\n        // Build up the core model registry\n        root.registerReadWriteAttribute(NAME, null, new StringLengthValidatingHandler(1), AttributeAccess.Storage.CONFIGURATION);\n        // Global operations\n        root.registerOperationHandler(GlobalOperationHandlers.ResolveAddressOperationHandler.OPERATION_NAME, GlobalOperationHandlers.RESOLVE, GlobalOperationHandlers.RESOLVE, false, OperationEntry.EntryType.PRIVATE);\n        root.registerOperationHandler(READ_RESOURCE_OPERATION, ServerOperationHandlers.SERVER_READ_RESOURCE_HANDLER, CommonProviders.READ_RESOURCE_PROVIDER, true);\n        root.registerOperationHandler(READ_ATTRIBUTE_OPERATION, ServerOperationHandlers.SERVER_READ_ATTRIBUTE_HANDLER, CommonProviders.READ_ATTRIBUTE_PROVIDER, true);\n        root.registerOperationHandler(READ_RESOURCE_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_RESOURCE_DESCRIPTION, CommonProviders.READ_RESOURCE_DESCRIPTION_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_NAMES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_NAMES, CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_TYPES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_TYPES, CommonProviders.READ_CHILDREN_TYPES_PROVIDER, true);\n        root.registerOperationHandler(READ_CHILDREN_RESOURCES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_RESOURCES, CommonProviders.READ_CHILDREN_RESOURCES_PROVIDER, true);\n        root.registerOperationHandler(READ_OPERATION_NAMES_OPERATION, GlobalOperationHandlers.READ_OPERATION_NAMES, CommonProviders.READ_OPERATION_NAMES_PROVIDER, true);\n        root.registerOperationHandler(READ_OPERATION_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_OPERATION_DESCRIPTION, CommonProviders.READ_OPERATION_PROVIDER, true);\n        root.registerOperationHandler(WRITE_ATTRIBUTE_OPERATION, ServerOperationHandlers.SERVER_WRITE_ATTRIBUTE_HANDLER, CommonProviders.WRITE_ATTRIBUTE_PROVIDER, true);\n        // Other root resource operations\n        root.registerOperationHandler(NamespaceAddHandler.OPERATION_NAME, NamespaceAddHandler.INSTANCE, NamespaceAddHandler.INSTANCE, false);\n        root.registerOperationHandler(NamespaceRemoveHandler.OPERATION_NAME, NamespaceRemoveHandler.INSTANCE, NamespaceRemoveHandler.INSTANCE, false);\n        root.registerOperationHandler(SchemaLocationAddHandler.OPERATION_NAME, SchemaLocationAddHandler.INSTANCE, SchemaLocationAddHandler.INSTANCE, false);\n        root.registerOperationHandler(SchemaLocationRemoveHandler.OPERATION_NAME, SchemaLocationRemoveHandler.INSTANCE, SchemaLocationRemoveHandler.INSTANCE, false);\n        root.registerOperationHandler(SystemPropertyAddHandler.OPERATION_NAME, SystemPropertyAddHandler.INSTANCE, SystemPropertyAddHandler.INSTANCE, false);\n        root.registerOperationHandler(SystemPropertyRemoveHandler.OPERATION_NAME, SystemPropertyRemoveHandler.INSTANCE, SystemPropertyRemoveHandler.INSTANCE, false);\n        DeploymentUploadBytesHandler dubh = new DeploymentUploadBytesHandler(deploymentRepository);\n        root.registerOperationHandler(DeploymentUploadBytesHandler.OPERATION_NAME, dubh, dubh, false);\n        DeploymentUploadURLHandler duuh = new DeploymentUploadURLHandler(deploymentRepository);\n        root.registerOperationHandler(DeploymentUploadURLHandler.OPERATION_NAME, duuh, duuh, false);\n        DeploymentUploadStreamAttachmentHandler dush = new DeploymentUploadStreamAttachmentHandler(deploymentRepository);\n        root.registerOperationHandler(DeploymentUploadStreamAttachmentHandler.OPERATION_NAME, dush, dush, false);\n        root.registerOperationHandler(DeploymentReplaceHandler.OPERATION_NAME, DeploymentReplaceHandler.INSTANCE, DeploymentReplaceHandler.INSTANCE, false);\n        DeploymentFullReplaceHandler dfrh = new DeploymentFullReplaceHandler(deploymentRepository);\n        root.registerOperationHandler(DeploymentFullReplaceHandler.OPERATION_NAME, dfrh, dfrh, false);\n//        root.registerOperationHandler(ServerCompositeOperationHandler.OPERATION_NAME, ServerCompositeOperationHandler.INSTANCE, ServerCompositeOperationHandler.INSTANCE, false);\n\n        // Runtime operations\n        root.registerOperationHandler(ServerReloadHandler.OPERATION_NAME, ServerReloadHandler.INSTANCE, ServerReloadHandler.INSTANCE, false);\n\n        // Management API protocols\n        ModelNodeRegistration managementNative = root.registerSubModel(PathElement.pathElement(MANAGEMENT_INTERFACES, NATIVE_INTERFACE), CommonProviders.MANAGEMENT_PROVIDER);\n        managementNative.registerOperationHandler(NativeManagementAddHandler.OPERATION_NAME, NativeManagementAddHandler.INSTANCE, NativeManagementAddHandler.INSTANCE, false);\n\n        ModelNodeRegistration managementHttp = root.registerSubModel(PathElement.pathElement(MANAGEMENT_INTERFACES, HTTP_INTERFACE), CommonProviders.MANAGEMENT_PROVIDER);\n        managementHttp.registerOperationHandler(HttpManagementAddHandler.OPERATION_NAME, HttpManagementAddHandler.INSTANCE, HttpManagementAddHandler.INSTANCE, false);\n        // root.registerReadWriteAttribute(ModelDescriptionConstants.MANAGEMENT_INTERFACES, GlobalOperationHandlers.READ_ATTRIBUTE, ManagementSocketAddHandler.INSTANCE);\n\n        // Paths\n        ModelNodeRegistration paths = root.registerSubModel(PathElement.pathElement(PATH), CommonProviders.SPECIFIED_PATH_PROVIDER);\n        paths.registerOperationHandler(SpecifiedPathAddHandler.OPERATION_NAME, SpecifiedPathAddHandler.INSTANCE, SpecifiedPathAddHandler.INSTANCE, false);\n        paths.registerOperationHandler(SpecifiedPathRemoveHandler.OPERATION_NAME, SpecifiedPathRemoveHandler.INSTANCE, SpecifiedPathRemoveHandler.INSTANCE, false);\n\n        // Interfaces\n        ModelNodeRegistration interfaces = root.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        interfaces.registerOperationHandler(SpecifiedInterfaceAddHandler.OPERATION_NAME, SpecifiedInterfaceAddHandler.INSTANCE, SpecifiedInterfaceAddHandler.INSTANCE, false);\n        interfaces.registerOperationHandler(SpecifiedInterfaceRemoveHandler.OPERATION_NAME, SpecifiedInterfaceRemoveHandler.INSTANCE, SpecifiedInterfaceRemoveHandler.INSTANCE, false);\n\n        // Sockets\n        ModelNodeRegistration socketGroup = root.registerSubModel(PathElement.pathElement(SOCKET_BINDING_GROUP), ServerDescriptionProviders.SOCKET_BINDING_GROUP_PROVIDER);\n        socketGroup.registerOperationHandler(BindingGroupAddHandler.OPERATION_NAME, BindingGroupAddHandler.INSTANCE, BindingGroupAddHandler.INSTANCE, false);\n        socketGroup.registerOperationHandler(BindingGroupRemoveHandler.OPERATION_NAME, BindingGroupRemoveHandler.INSTANCE, BindingGroupRemoveHandler.INSTANCE, false);\n        socketGroup.registerReadWriteAttribute(PORT_OFFSET, null, BindingGroupPortOffsetHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        socketGroup.registerReadWriteAttribute(DEFAULT_INTERFACE, null, BindingGroupDefaultInterfaceHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        ModelNodeRegistration socketBinding = socketGroup.registerSubModel(PathElement.pathElement(SOCKET_BINDING), CommonProviders.SOCKET_BINDING_PROVIDER);\n        socketBinding.registerOperationHandler(BindingAddHandler.OPERATION_NAME, BindingAddHandler.INSTANCE, BindingAddHandler.INSTANCE, false);\n        socketBinding.registerOperationHandler(BindingRemoveHandler.OPERATION_NAME, BindingRemoveHandler.INSTANCE, BindingRemoveHandler.INSTANCE, false);\n        socketBinding.registerReadWriteAttribute(INTERFACE, null, BindingInterfaceHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        socketBinding.registerReadWriteAttribute(PORT, null, BindingPortHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        socketBinding.registerReadWriteAttribute(FIXED_PORT, null, BindingFixedPortHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        socketBinding.registerReadWriteAttribute(MULTICAST_ADDRESS, null, BindingMulticastAddressHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n        socketBinding.registerReadWriteAttribute(MULTICAST_PORT, null, BindingPortHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n\n        // Deployments\n        ModelNodeRegistration deployments = root.registerSubModel(PathElement.pathElement(DEPLOYMENT), ServerDescriptionProviders.DEPLOYMENT_PROVIDER);\n        DeploymentAddHandler dah = new DeploymentAddHandler(deploymentRepository);\n        deployments.registerOperationHandler(DeploymentAddHandler.OPERATION_NAME, dah, dah, false);\n        deployments.registerOperationHandler(DeploymentRemoveHandler.OPERATION_NAME, DeploymentRemoveHandler.INSTANCE, DeploymentRemoveHandler.INSTANCE, false);\n        deployments.registerOperationHandler(DeploymentDeployHandler.OPERATION_NAME, DeploymentDeployHandler.INSTANCE, DeploymentDeployHandler.INSTANCE, false);\n        deployments.registerOperationHandler(DeploymentUndeployHandler.OPERATION_NAME, DeploymentUndeployHandler.INSTANCE, DeploymentUndeployHandler.INSTANCE, false);\n        deployments.registerOperationHandler(DeploymentRedeployHandler.OPERATION_NAME, DeploymentRedeployHandler.INSTANCE, DeploymentRedeployHandler.INSTANCE, false);\n\n        // Extensions\n        ModelNodeRegistration extensions = root.registerSubModel(PathElement.pathElement(EXTENSION), CommonProviders.EXTENSION_PROVIDER);\n        ExtensionContext extensionContext = new ExtensionContextImpl(root, deployments, extensibleConfigurationPersister);\n        ExtensionAddHandler addExtensionHandler = new ExtensionAddHandler(extensionContext);\n        extensions.registerOperationHandler(ExtensionAddHandler.OPERATION_NAME, addExtensionHandler, addExtensionHandler, false);\n        extensions.registerOperationHandler(ExtensionRemoveHandler.OPERATION_NAME, ExtensionRemoveHandler.INSTANCE, ExtensionRemoveHandler.INSTANCE, false);\n\n    }","commit_id":"9f26805fe7d2cfacb32b6dfb0c08bc4e9e943509","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected WriteAttributeOperationHandler(ParameterValidator validator) {\n            this.validator = validator;\n        }","id":72175,"modified_method":"/**\n         * Creates a WriteAttributeOperationHandler that users the given {@code valueValidator}\n         * to validate values before applying them to the model.\n         */\n        protected WriteAttributeOperationHandler(ParameterValidator valueValidator) {\n            this.valueValidator = valueValidator;\n        }","commit_id":"9f26805fe7d2cfacb32b6dfb0c08bc4e9e943509","url":"https://github.com/wildfly/wildfly"},{"original_method":"private WriteAttributeOperationHandler() {\n            this(null);\n        }","id":72176,"modified_method":"/**\n         * Creates a WriteAttributeOperationHandler that doesn't validate values.\n         */\n        protected WriteAttributeOperationHandler() {\n            this(null);\n        }","commit_id":"9f26805fe7d2cfacb32b6dfb0c08bc4e9e943509","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n\n            final String name = operation.require(NAME).asString();\n            // Don't require VALUE. Let validateValue decide if it's bothered\n            // by and undefined value\n            final ModelNode value = operation.get(VALUE);\n\n            validateValue(name, value);\n\n            context.getSubModel().get(name).set(value);\n            // FIXME there should be a compensating operation generated\n            resultHandler.handleResultComplete();\n            return new BasicOperationResult();\n        }","id":72177,"modified_method":"@Override\n        public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n\n            final String name = operation.require(NAME).asString();\n            // Don't require VALUE. Let validateValue decide if it's bothered\n            // by and undefined value\n            final ModelNode value = operation.get(VALUE);\n\n            validateValue(name, value);\n\n            final ModelNode submodel = context.getSubModel();\n            final ModelNode currentValue = submodel.get(name).clone();\n\n            final ModelNode compensating = Util.getEmptyOperation(operation.require(OP).asString(), operation.require(OP_ADDR));\n            compensating.get(NAME).set(name);\n            compensating.get(VALUE).set(currentValue);\n\n            submodel.get(name).set(value);\n\n            modelChanged(context, operation, resultHandler, name, value, currentValue);\n\n            return new BasicOperationResult(compensating);\n        }","commit_id":"9f26805fe7d2cfacb32b6dfb0c08bc4e9e943509","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void validateValue(String name, ModelNode value) throws OperationFailedException {\n            if (validator != null) {\n                validator.validateParameter(name, value);\n            }\n        }","id":72178,"modified_method":"/**\n         * If a validator was passed to the constructor, uses it to validate the value.\n         * Subclasses can alter this behavior.\n         */\n        protected void validateValue(String name, ModelNode value) throws OperationFailedException {\n            if (valueValidator != null) {\n                valueValidator.validateParameter(name, value);\n            }\n        }","commit_id":"9f26805fe7d2cfacb32b6dfb0c08bc4e9e943509","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public Cancellable execute(NewOperationContext updateContext, ModelNode operation, ResultHandler resultHandler) {\n        final ModelNode config = operation.get(CommonAttributes.CONTAINER_CONFIG);\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        if(updateContext instanceof NewBootOperationContext) {\n            final NewBootOperationContext ctx = (NewBootOperationContext) updateContext;\n\n            final String defaultHost = operation.has(CommonAttributes.DEFAULT_HOST) ?\n                    operation.get(CommonAttributes.DEFAULT_HOST).asString() : DEFAULT_HOST;\n\n            final NewSharedWebMetaDataBuilder sharedWebBuilder = new NewSharedWebMetaDataBuilder(config.clone());\n            final NewSharedTldsMetaDataBuilder sharedTldsBuilder = new NewSharedTldsMetaDataBuilder(config.clone());\n\n            ctx.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR_DEPLOYMENT_INIT, new WarDeploymentInitializingProcessor());\n            ctx.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR, new WarStructureDeploymentProcessor(sharedWebBuilder.create(), sharedTldsBuilder.create()));\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT, new WebParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT_FRAGMENT, new WebFragmentParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JBOSS_WEB_DEPLOYMENT, new JBossWebParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_TLD_DEPLOYMENT, new TldParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WAR_MODULE, new WarClassloadingDependencyProcessor());\n            ctx.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_ANNOTATION_WAR, new WarAnnotationDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_SERVLET_INIT_DEPLOYMENT, new ServletContainerInitializerDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_METADATA, new WarMetaDataProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_DEPLOYMENT, new WarDeploymentProcessor(defaultHost));\n        }\n\n        updateContext.getSubModel().get(CommonAttributes.CONTAINER_CONFIG).set(config);\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","id":72179,"modified_method":"/** {@inheritDoc} */\n    public Cancellable execute(NewOperationContext updateContext, ModelNode operation, ResultHandler resultHandler) {\n        final ModelNode config = operation.get(CommonAttributes.CONTAINER_CONFIG);\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        if(updateContext instanceof NewBootOperationContext) {\n            final NewBootOperationContext ctx = (NewBootOperationContext) updateContext;\n\n            final String defaultHost = operation.has(CommonAttributes.DEFAULT_HOST) ?\n                    operation.get(CommonAttributes.DEFAULT_HOST).asString() : DEFAULT_HOST;\n\n            final NewSharedWebMetaDataBuilder sharedWebBuilder = new NewSharedWebMetaDataBuilder(config.clone());\n            final NewSharedTldsMetaDataBuilder sharedTldsBuilder = new NewSharedTldsMetaDataBuilder(config.clone());\n\n            ctx.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR_DEPLOYMENT_INIT, new WarDeploymentInitializingProcessor());\n            ctx.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR, new WarStructureDeploymentProcessor(sharedWebBuilder.create(), sharedTldsBuilder.create()));\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT, new WebParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT_FRAGMENT, new WebFragmentParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JBOSS_WEB_DEPLOYMENT, new JBossWebParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_TLD_DEPLOYMENT, new TldParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WAR_MODULE, new WarClassloadingDependencyProcessor());\n            ctx.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_ANNOTATION_WAR, new WarAnnotationDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_SERVLET_INIT_DEPLOYMENT, new ServletContainerInitializerDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_METADATA, new WarMetaDataProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_DEPLOYMENT, new WarDeploymentProcessor(defaultHost));\n        }\n\n        final ModelNode subModel = updateContext.getSubModel();\n        subModel.get(CommonAttributes.CONTAINER_CONFIG).set(config);\n        subModel.get(CommonAttributes.CONNECTOR).setEmptyList();\n        subModel.get(CommonAttributes.VIRTUAL_SERVER).setEmptyList();\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","commit_id":"66e88a1661c71eedd28337dc0da3fce1e0b9bbb0","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n\t * Get private signing key for a publisher. \n\t * If I am the publisher, return signing key;\n\t * otherwise, return null.\n\t * @param publisher publisher public key digest\n\t * @return private signing key or null\n\t */\n\t@Override\n\tpublic Key getSigningKey(PublisherPublicKeyDigest publisher) {\n\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.FINER) )\n\t\t\tLog.finer(Log.FAC_KEYS, \"getSigningKey: retrieving key: \" + publisher);\n\t\tif (null == publisher)\n\t\t\treturn null;\n\t\treturn _privateKeyCache.getPrivateKey(publisher.digest());\n\t}","id":72180,"modified_method":"/**\n\t * Get private signing key for a publisher. \n\t * If I am the publisher, return signing key;\n\t * otherwise, return null.\n\t * @param publisher publisher public key digest\n\t * @return private signing key or null\n\t */\n\t@Override\n\tpublic Key getSigningKey(PublisherPublicKeyDigest publisher) {\n\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.FINER) )\n\t\t\tLog.finer(Log.FAC_KEYS, \"getSigningKey: retrieving key: \" + publisher);\n\t\tif (null == publisher)\n\t\t\treturn null;\n\t\tKey key = _privateKeyCache.getPrivateKey(publisher.digest());\n\t\tif (null == key) {  // Maybe its symmetric and we don't have it yet...\n\t\t\ttry {\n\t\t\t\tkey = readSymmetricKey(publisher, null, null, null);\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn key;\n\t}","commit_id":"89f37b43a83e129e15891a8c340edffd0252d27a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Get key for a publisher, given a key locator.\n\t * Times out after timeout amount of time elapsed \n\t * @param publisherID publisher public key digest\n\t * @param keyLocator key locator\n\t * @param timeout timeout value\n\t * @return public key\n\t */\n\t@Override\n\tpublic Key getVerificationKey(\n\t\t\tPublisherPublicKeyDigest desiredKeyID, KeyLocator keyLocator, String type, String fileName,\n\t\t\tString password, long timeout) throws IOException {\t\t\n\t\t\n\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.FINER))\n\t\t\tLog.finer(Log.FAC_KEYS, \"getVerificationKey: retrieving key: \" + desiredKeyID + \" located at: \" + keyLocator);\n\t\tif (null == keyLocator) {\n\t\t\t// Presumably this means that the key is a symmetric key\n\t\t\tKey key = getSecureKeyCache().getPrivateKey(desiredKeyID.digest());\n\t\t\tif (null == key) {\n\t\t\t\t// We don't have it - try reading it in from a keystore\n\t\t\t\tif (null == type) {\n\t\t\t\t\ttype = UserConfiguration.defaultSymmetricKeystoreType();\n\t\t\t\t}\n\t\t\t\tif (null == fileName) {\n\t\t\t\t\tfileName = _keyStoreFileName + \"-\" + digestToKeyStoreSuffix(SystemConfiguration.KEYSTORE_NAMING_VERSION, desiredKeyID);\n\t\t\t\t}\n\t\t\t\tchar[] pwd;\n\t\t\t\tif (null == password)\n\t\t\t\t\tpwd = _password;\n\t\t\t\telse\n\t\t\t\t\tpwd = password.toCharArray();\n\t\t\t\ttry {\n\t\t\t\t\tKeyStoreInfo ksi = loadKeyStore(_keyStoreDirectory, type, fileName, pwd);\n\t\t\t\t\tloadValuesFromKeystore(ksi, pwd);\n\t\t\t\t\tkey = getSecureKeyCache().getPrivateKey(desiredKeyID.digest());\n\t\t\t\t} catch (ConfigurationException e) {\n\t\t\t\t\tthrow new IOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn key;\n\t\t}\n\t\t// this will try local caches, the locator itself, and if it \n\t\t// has to, will go to the network. The result will be stored in the cache.\n\t\t// All this tells us is that the key matches the publisher. For whether\n\t\t// or not we should trust it for some reason, we have to get fancy.\n\t\treturn (Key)getPublicKeyCache().getPublicKey(desiredKeyID, keyLocator, timeout, handle());\n\t}","id":72181,"modified_method":"/**\n\t * Get key for a publisher, given a key locator.\n\t * Times out after timeout amount of time elapsed \n\t * @param publisherID publisher public key digest\n\t * @param keyLocator key locator\n\t * @param timeout timeout value\n\t * @return public key\n\t */\n\t@Override\n\tpublic Key getVerificationKey(\n\t\t\tPublisherPublicKeyDigest desiredKeyID, KeyLocator keyLocator, String type, String fileName,\n\t\t\tString password, long timeout) throws IOException {\t\t\n\t\t\n\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.FINER))\n\t\t\tLog.finer(Log.FAC_KEYS, \"getVerificationKey: retrieving key: \" + desiredKeyID + \" located at: \" + keyLocator);\n\t\tif (null == keyLocator) {\n\t\t\t// Presumably this means that the key is a symmetric key\n\t\t\tKey key = getSecureKeyCache().getPrivateKey(desiredKeyID.digest());\n\t\t\tif (null == key) {\n\t\t\t\t// We don't have it - try reading it in from a keystore\n\t\t\t\tkey = readSymmetricKey(desiredKeyID, type, fileName, password);\n\t\t\t}\n\t\t\treturn key;\n\t\t}\n\t\t// this will try local caches, the locator itself, and if it \n\t\t// has to, will go to the network. The result will be stored in the cache.\n\t\t// All this tells us is that the key matches the publisher. For whether\n\t\t// or not we should trust it for some reason, we have to get fancy.\n\t\treturn (Key)getPublicKeyCache().getPublicKey(desiredKeyID, keyLocator, timeout, handle());\n\t}","commit_id":"89f37b43a83e129e15891a8c340edffd0252d27a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static boolean parseArguments(String[] args, int i, Usage u, String[] okArgs) {\n\t\tif (null == okArgs)\n\t\t\tokArgs = defaultOkArgs;\n\t\tif (i == 0 && args[0].startsWith(\"[\")) {\n\t\t\t_extraUsage = args[0];\n\t\t\treturn true;\n\t\t} else if (args[i].equals(\"-h\") || args[i].equals(\"-help\")) {\n\t\t\tu.usage(_extraUsage);\n\t\t}\n\n\t\tboolean argOK = false;\n\t\tfor (String okArg : okArgs) {\n\t\t\tif (args[i].equals(okArg)) {\n\t\t\t\targOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (argOK) {\n\t\t\tif (args[i].equals(\"-unversioned\")) {\n\t\t\t\tCommonParameters.unversioned = true;\n\t\t\t} else if (args[i].equals(\"-timeout\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tCommonParameters.timeout = Integer.parseInt(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t} else if (args[i].equals(\"-log\")) {\n\t\t\t\tLevel level = null;\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlevel = Level.parse(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\tLog.setLevel(Log.FAC_ALL, level);\n\t\t\t} else if (args[i].equals(\"-v\")) {\n\t\t\t\tCommonParameters.verbose = true;\n\t\t\t} else if (args[i].equals(\"-as\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\tCommonSecurity.setUser(args[++i]);\n\t\t\t} else if (args[i].equals(\"-ac\")) {\n\t\t\t\tCommonSecurity.setAccessControl();\n\t\t\t}\n\t\t\tCommonParameters.startArg = i;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":72182,"modified_method":"public static boolean parseArguments(String[] args, int i, Usage u, String[] okArgs) {\n\t\tif (null == okArgs)\n\t\t\tokArgs = defaultOkArgs;\n\t\tif (i == 0 && args[0].startsWith(\"[\")) {\n\t\t\t_extraUsage = args[0];\n\t\t\treturn true;\n\t\t} else if (args[i].equals(\"-h\") || args[i].equals(\"-help\")) {\n\t\t\tu.usage(_extraUsage);\n\t\t}\n\n\t\tboolean argOK = false;\n\t\tfor (String okArg : okArgs) {\n\t\t\tif (args[i].equals(okArg)) {\n\t\t\t\targOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (argOK) {\n\t\t\tif (args[i].equals(\"-unversioned\")) {\n\t\t\t\tCommonParameters.unversioned = true;\n\t\t\t} else if (args[i].equals(\"-timeout\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tCommonParameters.timeout = Integer.parseInt(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t} else if (args[i].equals(\"-log\")) {\n\t\t\t\tLevel level = null;\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlevel = Level.parse(args[++i]);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\tLog.setLevel(Log.FAC_ALL, level);\n\t\t\t} else if (args[i].equals(\"-v\")) {\n\t\t\t\tCommonParameters.verbose = true;\n\t\t\t} else if (args[i].equals(\"-as\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\tCommonSecurity.setUser(args[++i]);\n\t\t\t} else if (args[i].equals(\"-ac\")) {\n\t\t\t\tCommonSecurity.setAccessControl();\n\t\t\t} else if (args[i].equals(\"-sk\")) {\n\t\t\t\tif (args.length < (i + 2)) {\n\t\t\t\t\tu.usage(_extraUsage);\n\t\t\t\t}\n\t\t\t\tCommonParameters.publisher = KeyManager.keyStoreToDigest(SystemConfiguration.KEYSTORE_NAMING_VERSION, \n\t\t\t\t\t\t\targs[++i]);\n\t\t\t}\n\t\t\tCommonParameters.startArg = i;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"89f37b43a83e129e15891a8c340edffd0252d27a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected CCNTime doPut(CCNHandle handle, String fileName,\n\t\t\tContentName nodeName) throws IOException, InvalidKeyException, ConfigurationException {\n\t\tInputStream is;\n\t\tif (CommonParameters.verbose)\n\t\t\tSystem.out.printf(\"filename %s\\n\", fileName);\n\t\tif (fileName.startsWith(\"http://\")) {\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.printf(\"filename is http\\n\");\n\t\t\tis = new URL(fileName).openStream();\n\t\t} else {\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.printf(\"filename is file\\n\");\n\t\t\tFile theFile = new File(fileName);\n\n\t\t\tif (!theFile.exists()) {\n\t\t\t\tSystem.out.println(\"No such file: \" + theFile.getName());\n\t\t\t\tusage(CommonArguments.getExtraUsage());\n\t\t\t}\n\t\t\tis = new FileInputStream(theFile);\n\t\t}\n\n\t\tCCNOutputStream ostream;\n\n\t\t// Use file stream in both cases to match behavior. CCNOutputStream doesn't do\n\t\t// versioning and neither it nor CCNVersionedOutputStream add headers.\n\t\tif (CommonParameters.rawMode) {\n\t\t\tif (CommonParameters.unversioned)\n\t\t\t\tostream = new CCNOutputStream(nodeName, handle);\n\t\t\telse\n\t\t\t\tostream = new CCNFileOutputStream(nodeName, handle);\n\t\t} else {\n\t\t\tif (CommonParameters.unversioned)\n\t\t\t\tostream = new RepositoryOutputStream(nodeName, handle, CommonParameters.local);\n\t\t\telse\n\t\t\t\tostream = new RepositoryFileOutputStream(nodeName, handle, CommonParameters.local);\n\t\t}\n\t\tif (CommonParameters.timeout != null)\n\t\t\tostream.setTimeout(CommonParameters.timeout);\n\t\tdo_write(ostream, is);\n\n\t\treturn ostream.getVersion();\n\t}","id":72183,"modified_method":"protected CCNTime doPut(CCNHandle handle, String fileName,\n\t\t\tContentName nodeName) throws IOException, InvalidKeyException, ConfigurationException {\n\t\tInputStream is;\n\t\tif (CommonParameters.verbose)\n\t\t\tSystem.out.printf(\"filename %s\\n\", fileName);\n\t\tif (fileName.startsWith(\"http://\")) {\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.printf(\"filename is http\\n\");\n\t\t\tis = new URL(fileName).openStream();\n\t\t} else {\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.printf(\"filename is file\\n\");\n\t\t\tFile theFile = new File(fileName);\n\n\t\t\tif (!theFile.exists()) {\n\t\t\t\tSystem.out.println(\"No such file: \" + theFile.getName());\n\t\t\t\tusage(CommonArguments.getExtraUsage());\n\t\t\t}\n\t\t\tis = new FileInputStream(theFile);\n\t\t}\n\n\t\tCCNOutputStream ostream;\n\n\t\t// Use file stream in both cases to match behavior. CCNOutputStream doesn't do\n\t\t// versioning and neither it nor CCNVersionedOutputStream add headers.\n\t\tif (CommonParameters.rawMode) {\n\t\t\tif (CommonParameters.unversioned)\n\t\t\t\tostream = new CCNOutputStream(nodeName, CommonParameters.publisher, handle);\n\t\t\telse\n\t\t\t\tostream = new CCNFileOutputStream(nodeName, CommonParameters.publisher, handle);\n\t\t} else {\n\t\t\tif (CommonParameters.unversioned)\n\t\t\t\tostream = new RepositoryOutputStream(nodeName, CommonParameters.publisher, handle, \n\t\t\t\t\t\tCommonParameters.local);\n\t\t\telse\n\t\t\t\tostream = new RepositoryFileOutputStream(nodeName, CommonParameters.publisher, handle, \n\t\t\t\t\t\tCommonParameters.local);\n\t\t}\n\t\tif (CommonParameters.timeout != null)\n\t\t\tostream.setTimeout(CommonParameters.timeout);\n\t\tdo_write(ostream, is);\n\n\t\treturn ostream.getVersion();\n\t}","commit_id":"89f37b43a83e129e15891a8c340edffd0252d27a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tLog.setDefaultLevel(Level.WARNING);\n\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tif (!CommonArguments.parseArguments(args, i, u)) {\n\t\t\t\tif (i >= args.length - 3) {\n\t\t\t\t\tCommonParameters.startArg = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tu.usage(CommonArguments.getExtraUsage());\n\t\t\t}\n\t\t\ti = CommonParameters.startArg;\n\t\t}\n\n\t\tif (args.length < CommonParameters.startArg + 2) {\n\t\t\tu.usage(CommonArguments.getExtraUsage());\n\t\t}\n\n\t\ttry {\n\t\t\tint readsize = 1024; // make an argument for testing...\n\t\t\t// If we get one file name, put as the specific name given.\n\t\t\t// If we get more than one, put underneath the first as parent.\n\t\t\t// Ideally want to use newVersion to get latest version. Start\n\t\t\t// with random version.\n\t\t\tContentName argName = ContentName.fromURI(args[CommonParameters.startArg]);\n\n\t\t\tCCNHandle handle = CCNHandle.open();\n\n\t\t\tFile theFile = new File(args[CommonParameters.startArg + 1]);\n\t\t\tif (theFile.exists()) {\n\t\t\t\tSystem.out.println(\"Overwriting file: \" + args[CommonParameters.startArg + 1]);\n\t\t\t}\n\t\t\tFileOutputStream output = new FileOutputStream(theFile);\n\n\t\t\tlong starttime = System.currentTimeMillis();\n\t\t\tCCNInputStream input;\n\t\t\tif (CommonParameters.unversioned)\n\t\t\t\tinput = new CCNInputStream(argName, handle);\n\t\t\telse\n\t\t\t\tinput = new CCNFileInputStream(argName, handle);\n\t\t\tif (CommonParameters.timeout != null) {\n\t\t\t\tinput.setTimeout(CommonParameters.timeout);\n\t\t\t}\n\t\t\tbyte [] buffer = new byte[readsize];\n\n\t\t\tint readcount = 0;\n\t\t\tlong readtotal = 0;\n\t\t\t//while (!input.eof()) {\n\t\t\twhile ((readcount = input.read(buffer)) != -1){\n\t\t\t\t//readcount = input.read(buffer);\n\t\t\t\treadtotal += readcount;\n\t\t\t\toutput.write(buffer, 0, readcount);\n\t\t\t\toutput.flush();\n\t\t\t}\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.println(\"ccngetfile took: \"+(System.currentTimeMillis() - starttime)+\"ms\");\n\t\t\tSystem.out.println(\"Retrieved content \" + args[CommonParameters.startArg + 1] + \" got \" + readtotal + \" bytes.\");\n\t\t\tSystem.exit(0);\n\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in ccngetfile: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedContentNameStringException e) {\n\t\t\tSystem.out.println(\"Malformed name: \" + args[CommonParameters.startArg] + \" \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot write file or read content. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\t}","id":72184,"modified_method":"/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tLog.setDefaultLevel(Level.WARNING);\n\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tif (!CommonArguments.parseArguments(args, i, u, okArgs)) {\n\t\t\t\tif (i >= args.length - 3) {\n\t\t\t\t\tCommonParameters.startArg = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tu.usage(CommonArguments.getExtraUsage());\n\t\t\t}\n\t\t\ti = CommonParameters.startArg;\n\t\t}\n\n\t\tif (args.length < CommonParameters.startArg + 2) {\n\t\t\tu.usage(CommonArguments.getExtraUsage());\n\t\t}\n\n\t\ttry {\n\t\t\tint readsize = 1024; // make an argument for testing...\n\t\t\t// If we get one file name, put as the specific name given.\n\t\t\t// If we get more than one, put underneath the first as parent.\n\t\t\t// Ideally want to use newVersion to get latest version. Start\n\t\t\t// with random version.\n\t\t\tContentName argName = ContentName.fromURI(args[CommonParameters.startArg]);\n\n\t\t\tCCNHandle handle = CCNHandle.open();\n\n\t\t\tFile theFile = new File(args[CommonParameters.startArg + 1]);\n\t\t\tif (theFile.exists()) {\n\t\t\t\tSystem.out.println(\"Overwriting file: \" + args[CommonParameters.startArg + 1]);\n\t\t\t}\n\t\t\tFileOutputStream output = new FileOutputStream(theFile);\n\n\t\t\tlong starttime = System.currentTimeMillis();\n\t\t\tCCNInputStream input;\n\t\t\tif (CommonParameters.unversioned)\n\t\t\t\tinput = new CCNInputStream(argName, handle);\n\t\t\telse\n\t\t\t\tinput = new CCNFileInputStream(argName, handle);\n\t\t\tif (CommonParameters.timeout != null) {\n\t\t\t\tinput.setTimeout(CommonParameters.timeout);\n\t\t\t}\n\t\t\tbyte [] buffer = new byte[readsize];\n\n\t\t\tint readcount = 0;\n\t\t\tlong readtotal = 0;\n\t\t\t//while (!input.eof()) {\n\t\t\twhile ((readcount = input.read(buffer)) != -1){\n\t\t\t\t//readcount = input.read(buffer);\n\t\t\t\treadtotal += readcount;\n\t\t\t\toutput.write(buffer, 0, readcount);\n\t\t\t\toutput.flush();\n\t\t\t}\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.println(\"ccngetfile took: \"+(System.currentTimeMillis() - starttime)+\"ms\");\n\t\t\tSystem.out.println(\"Retrieved content \" + args[CommonParameters.startArg + 1] + \" got \" + readtotal + \" bytes.\");\n\t\t\tSystem.exit(0);\n\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in ccngetfile: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedContentNameStringException e) {\n\t\t\tSystem.out.println(\"Malformed name: \" + args[CommonParameters.startArg] + \" \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot write file or read content. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\t}","commit_id":"89f37b43a83e129e15891a8c340edffd0252d27a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tLog.setDefaultLevel(Level.WARNING);\n\t\tUsage u = new ccngetmeta();\n\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tif (!CommonArguments.parseArguments(args, i, u)) {\n\t\t\t\tif (i >= args.length - 3) {\n\t\t\t\t\tCommonParameters.startArg = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tu.usage(CommonArguments.getExtraUsage());\n\t\t\t}\n\t\t\ti = CommonParameters.startArg;\n\t\t}\n\n\t\tif (args.length != CommonParameters.startArg + 3) {\n\t\t\tu.usage(CommonArguments.getExtraUsage());\n\t\t}\n\n\t\ttry {\n\t\t\tint readsize = 1024; // make an argument for testing...\n\n\t\t\tCCNHandle handle = CCNHandle.open();\n\n\t\t\tString metaArg = args[CommonParameters.startArg + 1];\n\t\t\tif (!metaArg.startsWith(\"/\"))\n\t\t\t\tmetaArg = \"/\" + metaArg;\n\t\t\tContentName fileName = MetadataProfile.getLatestVersion(ContentName.fromURI(args[CommonParameters.startArg]),\n\t\t\t\t\tContentName.fromNative(metaArg), CommonParameters.timeout, handle);\n\n\t\t\tif (fileName == null) {\n\t\t\t\t//This base content does not exist...  cannot get metadata associated with the base name.\n\t\t\t\tSystem.out.println(\"File \" + args[CommonParameters.startArg] + \" does not exist\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\n\t\t\tif (VersioningProfile.hasTerminalVersion(fileName)) {\n\t\t\t\t//MetadataProfile has found a terminal version...  we have something to get!\n\t\t\t} else {\n\t\t\t\t//MetadataProfile could not find a terminal version...  nothing to get\n\t\t\t\tSystem.out.println(\"File \" + fileName + \" does not exist...  exiting\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\n\t\t\tFile theFile = new File(args[CommonParameters.startArg + 2]);\n\t\t\tif (theFile.exists()) {\n\t\t\t\tSystem.out.println(\"Overwriting file: \" + args[CommonParameters.startArg + 1]);\n\t\t\t}\n\t\t\tFileOutputStream output = new FileOutputStream(theFile);\n\n\t\t\tlong starttime = System.currentTimeMillis();\n\t\t\tCCNInputStream input;\n\t\t\tif (CommonParameters.unversioned)\n\t\t\t\tinput = new CCNInputStream(fileName, handle);\n\t\t\telse\n\t\t\t\tinput = new CCNFileInputStream(fileName, handle);\n\t\t\tif (CommonParameters.timeout != null) {\n\t\t\t\tinput.setTimeout(CommonParameters.timeout);\n\t\t\t}\n\t\t\tbyte [] buffer = new byte[readsize];\n\n\t\t\tint readcount = 0;\n\t\t\tlong readtotal = 0;\n\t\t\t//while (!input.eof()) {\n\t\t\twhile ((readcount = input.read(buffer)) != -1){\n\t\t\t\t//readcount = input.read(buffer);\n\t\t\t\treadtotal += readcount;\n\t\t\t\toutput.write(buffer, 0, readcount);\n\t\t\t\toutput.flush();\n\t\t\t}\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.println(\"ccngetfile took: \"+(System.currentTimeMillis() - starttime)+\"ms\");\n\t\t\tSystem.out.println(\"Retrieved content \" + args[CommonParameters.startArg + 1] + \" got \" + readtotal + \" bytes.\");\n\t\t\tSystem.exit(0);\n\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in ccngetfile: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedContentNameStringException e) {\n\t\t\tSystem.out.println(\"Malformed name: \" + args[CommonParameters.startArg] + \" \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot write file or read content. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\t}","id":72185,"modified_method":"/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tLog.setDefaultLevel(Level.WARNING);\n\t\tUsage u = new ccngetmeta();\n\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tif (!CommonArguments.parseArguments(args, i, u, okArgs)) {\n\t\t\t\tif (i >= args.length - 3) {\n\t\t\t\t\tCommonParameters.startArg = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tu.usage(CommonArguments.getExtraUsage());\n\t\t\t}\n\t\t\ti = CommonParameters.startArg;\n\t\t}\n\n\t\tif (args.length != CommonParameters.startArg + 3) {\n\t\t\tu.usage(CommonArguments.getExtraUsage());\n\t\t}\n\n\t\ttry {\n\t\t\tint readsize = 1024; // make an argument for testing...\n\n\t\t\tCCNHandle handle = CCNHandle.open();\n\n\t\t\tString metaArg = args[CommonParameters.startArg + 1];\n\t\t\tif (!metaArg.startsWith(\"/\"))\n\t\t\t\tmetaArg = \"/\" + metaArg;\n\t\t\tContentName fileName = MetadataProfile.getLatestVersion(ContentName.fromURI(args[CommonParameters.startArg]),\n\t\t\t\t\tContentName.fromNative(metaArg), CommonParameters.timeout, handle);\n\n\t\t\tif (fileName == null) {\n\t\t\t\t//This base content does not exist...  cannot get metadata associated with the base name.\n\t\t\t\tSystem.out.println(\"File \" + args[CommonParameters.startArg] + \" does not exist\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\n\t\t\tif (VersioningProfile.hasTerminalVersion(fileName)) {\n\t\t\t\t//MetadataProfile has found a terminal version...  we have something to get!\n\t\t\t} else {\n\t\t\t\t//MetadataProfile could not find a terminal version...  nothing to get\n\t\t\t\tSystem.out.println(\"File \" + fileName + \" does not exist...  exiting\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\n\t\t\tFile theFile = new File(args[CommonParameters.startArg + 2]);\n\t\t\tif (theFile.exists()) {\n\t\t\t\tSystem.out.println(\"Overwriting file: \" + args[CommonParameters.startArg + 1]);\n\t\t\t}\n\t\t\tFileOutputStream output = new FileOutputStream(theFile);\n\n\t\t\tlong starttime = System.currentTimeMillis();\n\t\t\tCCNInputStream input;\n\t\t\tif (CommonParameters.unversioned)\n\t\t\t\tinput = new CCNInputStream(fileName, handle);\n\t\t\telse\n\t\t\t\tinput = new CCNFileInputStream(fileName, handle);\n\t\t\tif (CommonParameters.timeout != null) {\n\t\t\t\tinput.setTimeout(CommonParameters.timeout);\n\t\t\t}\n\t\t\tbyte [] buffer = new byte[readsize];\n\n\t\t\tint readcount = 0;\n\t\t\tlong readtotal = 0;\n\t\t\t//while (!input.eof()) {\n\t\t\twhile ((readcount = input.read(buffer)) != -1){\n\t\t\t\t//readcount = input.read(buffer);\n\t\t\t\treadtotal += readcount;\n\t\t\t\toutput.write(buffer, 0, readcount);\n\t\t\t\toutput.flush();\n\t\t\t}\n\t\t\tif (CommonParameters.verbose)\n\t\t\t\tSystem.out.println(\"ccngetfile took: \"+(System.currentTimeMillis() - starttime)+\"ms\");\n\t\t\tSystem.out.println(\"Retrieved content \" + args[CommonParameters.startArg + 1] + \" got \" + readtotal + \" bytes.\");\n\t\t\tSystem.exit(0);\n\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in ccngetfile: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedContentNameStringException e) {\n\t\t\tSystem.out.println(\"Malformed name: \" + args[CommonParameters.startArg] + \" \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot write file or read content. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\t}","commit_id":"89f37b43a83e129e15891a8c340edffd0252d27a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * @param args\n\t */\n\tpublic void doimport(String[] args) {\n\t\tLog.setDefaultLevel(Level.WARNING);\n\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tif (!CommonArguments.parseArguments(args, i, ccnrepoimport)) {\n\t\t\t\tif (i >= args.length - 2) {\n\t\t\t\t\tCommonParameters.startArg = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusage(CommonArguments.getExtraUsage());\n\t\t\t}\n\t\t\ti = CommonParameters.startArg;\n\t\t}\n\n\t\tif (CommonParameters.startArg > args.length - 2) {\n\t\t\tusage(CommonArguments.getExtraUsage());\n\t\t}\n\n\t\ttry {\n\n\t\t\tFile repoDir = new File(args[CommonParameters.startArg]);\n\t\t\tif (!repoDir.exists()) {\n\t\t\t\tSystem.out.println(\"Repo at: \" + args[CommonParameters.startArg] + \" does not exist\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\n\t\t\tFile repoImportDir = new File(repoDir, LogStructRepoStoreProfile.REPO_IMPORT_DIR);\n\t\t\trepoImportDir.mkdir();\n\n\t\t\tFile theFile = new File(args[CommonParameters.startArg + 1]);\n\t\t\tif (!theFile.exists()) {\n\t\t\t\tSystem.out.println(\"File: \" + args[CommonParameters.startArg + 1] + \" does not exist\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\n\t\t\tFile importFile;\n\t\t\tString importName;\n\t\t\tint test = 0;\n\t\t\twhile (true) {\n\t\t\t\ttest++;\n\t\t\t\timportName = importFileName + test;\n\t\t\t\timportFile = new File(repoImportDir, importName);\n\t\t\t\tif (!importFile.exists()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFileInputStream fis = new FileInputStream(theFile);\n\t\t\tFileOutputStream fos = new FileOutputStream(importFile);\n\t\t\tbyte[] buf = new byte[8192];\n\t\t\twhile (fis.available() > 0) {\n\t\t\t\tint len = fis.available() > buf.length ? buf.length : fis.available();\n\t\t\t\tfis.read(buf, 0, len);\n\t\t\t\tfos.write(buf, 0, len);\n\t\t\t}\n\t\t\tfis.close();\n\t\t\tfos.close();\n\n\t\t\tCCNHandle handle = CCNHandle.open();\n\n\t\t\tlong starttime = System.currentTimeMillis();\n\n\t\t\tboolean result = RepositoryBulkImport.bulkImport(handle, importName, timeout);\n\t\t\tSystem.out.println(\"Bulk import of \" + theFile + (result ? \" succeeded\" : \" failed\"));\n\t\t\tSystem.out.println(\"ccnrepoimport took: \"+(System.currentTimeMillis() - starttime)+\" ms\");\n\t\t\tSystem.exit(0);\n\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in ccnrepoimport: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot import file. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\t}","id":72186,"modified_method":"/**\n\t * @param args\n\t */\n\tpublic void doimport(String[] args) {\n\t\tLog.setDefaultLevel(Level.WARNING);\n\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tif (!CommonArguments.parseArguments(args, i, ccnrepoimport, okArgs)) {\n\t\t\t\tif (i >= args.length - 2) {\n\t\t\t\t\tCommonParameters.startArg = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusage(CommonArguments.getExtraUsage());\n\t\t\t}\n\t\t\ti = CommonParameters.startArg;\n\t\t}\n\n\t\tif (CommonParameters.startArg > args.length - 2) {\n\t\t\tusage(CommonArguments.getExtraUsage());\n\t\t}\n\n\t\ttry {\n\n\t\t\tFile repoDir = new File(args[CommonParameters.startArg]);\n\t\t\tif (!repoDir.exists()) {\n\t\t\t\tSystem.out.println(\"Repo at: \" + args[CommonParameters.startArg] + \" does not exist\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\n\t\t\tFile repoImportDir = new File(repoDir, LogStructRepoStoreProfile.REPO_IMPORT_DIR);\n\t\t\trepoImportDir.mkdir();\n\n\t\t\tFile theFile = new File(args[CommonParameters.startArg + 1]);\n\t\t\tif (!theFile.exists()) {\n\t\t\t\tSystem.out.println(\"File: \" + args[CommonParameters.startArg + 1] + \" does not exist\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\n\t\t\tFile importFile;\n\t\t\tString importName;\n\t\t\tint test = 0;\n\t\t\twhile (true) {\n\t\t\t\ttest++;\n\t\t\t\timportName = importFileName + test;\n\t\t\t\timportFile = new File(repoImportDir, importName);\n\t\t\t\tif (!importFile.exists()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFileInputStream fis = new FileInputStream(theFile);\n\t\t\tFileOutputStream fos = new FileOutputStream(importFile);\n\t\t\tbyte[] buf = new byte[8192];\n\t\t\twhile (fis.available() > 0) {\n\t\t\t\tint len = fis.available() > buf.length ? buf.length : fis.available();\n\t\t\t\tfis.read(buf, 0, len);\n\t\t\t\tfos.write(buf, 0, len);\n\t\t\t}\n\t\t\tfis.close();\n\t\t\tfos.close();\n\n\t\t\tCCNHandle handle = CCNHandle.open();\n\n\t\t\tlong starttime = System.currentTimeMillis();\n\n\t\t\tboolean result = RepositoryBulkImport.bulkImport(handle, importName, timeout);\n\t\t\tSystem.out.println(\"Bulk import of \" + theFile + (result ? \" succeeded\" : \" failed\"));\n\t\t\tSystem.out.println(\"ccnrepoimport took: \"+(System.currentTimeMillis() - starttime)+\" ms\");\n\t\t\tSystem.exit(0);\n\n\t\t} catch (ConfigurationException e) {\n\t\t\tSystem.out.println(\"Configuration exception in ccnrepoimport: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Cannot import file. \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.exit(1);\n\t}","commit_id":"89f37b43a83e129e15891a8c340edffd0252d27a","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public String get(String productContentTypeId) {\n        return getProductContentAsText(product, productContentTypeId, locale, mimeTypeId, product.getDelegator(), dispatcher);\n    }","id":72187,"modified_method":"public String get(String productContentTypeId) {\n    \tif (this.product == null) {\n    \t\tDebug.logWarning(\"Tried to get ProductContent for type [\" + productContentTypeId + \"] but the product field in the ProductContentWrapper is null\", module);\n    \t\treturn null;\n    \t}\n        return getProductContentAsText(this.product, productContentTypeId, locale, mimeTypeId, this.product.getDelegator(), dispatcher);\n    }","commit_id":"9e5d24e9f3b07892d241ccb5ed607400ddece31d","url":"https://github.com/apache/ofbiz"},{"original_method":"public Writer getWriter(final Writer out, Map args) {\n        final Environment env = Environment.getCurrentEnvironment();\n        //final Map templateCtx = (Map) FreeMarkerWorker.getWrappedObject(\"context\", env);\n        //final Map templateCtx = new HashMap();\n        final LocalDispatcher dispatcher = (LocalDispatcher) FreeMarkerWorker.getWrappedObject(\"dispatcher\", env);\n        final GenericDelegator delegator = (GenericDelegator) FreeMarkerWorker.getWrappedObject(\"delegator\", env);\n        final HttpServletRequest request = (HttpServletRequest) FreeMarkerWorker.getWrappedObject(\"request\", env);\n        final HttpServletResponse response = (HttpServletResponse) FreeMarkerWorker.getWrappedObject(\"response\", env);\n        final Map templateRoot = FreeMarkerWorker.createEnvironmentMap(env);\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, contentId(0):\" + templateRoot.get(\"contentId\"), module);\n        FreeMarkerWorker.getSiteParameters(request, templateRoot);\n        final Map savedValuesUp = new HashMap();\n        FreeMarkerWorker.saveContextValues(templateRoot, upSaveKeyNames, savedValuesUp);\n        FreeMarkerWorker.overrideWithArgs(templateRoot, args);\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, contentId(2):\" + templateRoot.get(\"contentId\"), module);\n        // not used yet: final GenericValue userLogin = (GenericValue) FreeMarkerWorker.getWrappedObject(\"userLogin\", env);\n        // not used yet: List trail = (List)templateRoot.get(\"globalNodeTrail\");\n        //if (Debug.infoOn()) Debug.logInfo(\"in Render(0), globalNodeTrail .\" + trail , module);\n        // not used yet: String contentAssocPredicateId = (String)templateRoot.get(\"contentAssocPredicateId\");\n        // not used yet: String strNullThruDatesOnly = (String)templateRoot.get(\"nullThruDatesOnly\");\n        // not used yet: Boolean nullThruDatesOnly = (strNullThruDatesOnly != null && strNullThruDatesOnly.equalsIgnoreCase(\"true\")) ? Boolean.TRUE :Boolean.FALSE;\n        final String thisContentId =  (String)templateRoot.get(\"contentId\");\n        final String xmlEscape =  (String)templateRoot.get(\"xmlEscape\");\n        final boolean directAssocMode = UtilValidate.isNotEmpty(thisContentId) ? true : false;\n        if (Debug.infoOn()) Debug.logInfo(\"in Render(0), directAssocMode .\" + directAssocMode , module);\n        /*\n        if (Debug.infoOn()) Debug.logInfo(\"in Render(0), thisSubContentId .\" + thisSubContentId , module);\n        String thisSubContentId =  (String)templateRoot.get(\"subContentId\");\n        GenericValue val = null;\n        try {\n            val = FreeMarkerWorker.getCurrentContent(delegator, trail, userLogin, templateRoot, nullThruDatesOnly, contentAssocPredicateId);\n        } catch(GeneralException e) {\n            throw new RuntimeException(\"Error getting current content. \" + e.toString());\n        }\n        final GenericValue view = val;\n\n        String dataResourceId = null;\n        String subContentIdSub = null;\n        if (view != null) {\n            try {\n                dataResourceId = (String) view.get(\"drDataResourceId\");\n            } catch (Exception e) {\n                dataResourceId = (String) view.get(\"dataResourceId\");\n            }\n            subContentIdSub = (String) view.get(\"contentId\");\n        }\n        // This order is taken so that the dataResourceType can be overridden in the transform arguments.\n        String subDataResourceTypeId = (String)templateRoot.get(\"subDataResourceTypeId\");\n        if (UtilValidate.isEmpty(subDataResourceTypeId)) {\n            try {\n                subDataResourceTypeId = (String) view.get(\"drDataResourceTypeId\");\n            } catch (Exception e) {\n                // view may be \"Content\"\n            }\n            // TODO: If this value is still empty then it is probably necessary to get a value from\n            // the parent context. But it will already have one and it is the same context that is\n            // being passed.\n        }\n        String mimeTypeId = FreeMarkerWorker.getMimeTypeId(delegator, view, templateRoot);\n        templateRoot.put(\"drDataResourceId\", dataResourceId);\n        templateRoot.put(\"mimeTypeId\", mimeTypeId);\n        templateRoot.put(\"dataResourceId\", dataResourceId);\n        templateRoot.put(\"subContentId\", subContentIdSub);\n        templateRoot.put(\"subDataResourceTypeId\", subDataResourceTypeId);\n        */\n\n        final Map savedValues = new HashMap();\n\n        return new Writer(out) {\n\n            public void write(char cbuf[], int off, int len) {\n            }\n\n            public void flush() throws IOException {\n                out.flush();\n            }\n\n            public void close() throws IOException {\n                List globalNodeTrail = (List)templateRoot.get(\"globalNodeTrail\");\n                if (Debug.infoOn()) Debug.logInfo(\"Render close, globalNodeTrail(2a):\" + ContentWorker.nodeTrailToCsv(globalNodeTrail), \"\");\n                renderSubContent();\n                //if (Debug.infoOn()) Debug.logInfo(\"in Render(2), globalNodeTrail .\" + getWrapped(env, \"globalNodeTrail\") , module);\n            }\n\n            public void renderSubContent() throws IOException {\n                String mimeTypeId = (String) templateRoot.get(\"mimeTypeId\");\n                Object localeObject = templateRoot.get(\"locale\");\n                Locale locale = null;\n                if (localeObject == null) {\n                    locale = UtilHttp.getLocale(request);\n                } else {\n                    locale = UtilMisc.ensureLocale(localeObject);\n                }\n\n                //TemplateHashModel dataRoot = env.getDataModel();\n                // Timestamp fromDate = UtilDateTime.nowTimestamp();\n                // List passedGlobalNodeTrail = (List)templateRoot.get(\"globalNodeTrail\");\n                String editRequestName = (String)templateRoot.get(\"editRequestName\");\n                 if (Debug.infoOn()) Debug.logInfo(\"in Render(3), editRequestName .\" + editRequestName , module);\n                 /*\n                GenericValue thisView = null;\n                if (view != null) {\n                    thisView = view;\n                } else if (passedGlobalNodeTrail.size() > 0) {\n                    Map map = (Map)passedGlobalNodeTrail.get(passedGlobalNodeTrail.size() - 1);\n                    if (Debug.infoOn()) Debug.logInfo(\"in Render(3), map .\" + map , module);\n                    if (map != null)\n                        thisView = (GenericValue)map.get(\"value\");\n                }\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, subContentId:\" + templateRoot.get(\"subContentId\"), module);\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, contentId:\" + templateRoot.get(\"contentId\"), module);\n                */\n\n                if (UtilValidate.isNotEmpty(editRequestName)) {\n                    String editStyle = getEditStyle();\n                    openEditWrap(out, editStyle);\n                }\n\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, contentId(2):\" + templateRoot.get(\"contentId\"), module);\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, subContentId(2):\" + templateRoot.get(\"subContentId\"), module);\n                FreeMarkerWorker.saveContextValues(templateRoot, saveKeyNames, savedValues);\n                //if (thisView != null) {\n                    try {\n                        String txt = ContentWorker.renderContentAsText(dispatcher, delegator, thisContentId, templateRoot, locale, mimeTypeId, true);\n                        if (\"true\".equals(xmlEscape)) {\n                            txt = UtilFormatOut.encodeXmlValue(txt);\n                        }\n                        \n                        out.write(txt);\n                        \n                        // if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, after renderContentAsTextCache:\", module);\n                    } catch (GeneralException e) {\n                        String errMsg = \"Error rendering thisContentId:\" + thisContentId + \" msg:\" + e.toString();\n                        Debug.logError(e, errMsg, module);\n                        // just log a message and don't return anything: throw new IOException();\n                    }\n                //}\n                FreeMarkerWorker.reloadValues(templateRoot, savedValuesUp, env);\n                FreeMarkerWorker.reloadValues(templateRoot, savedValues, env);\n                if (UtilValidate.isNotEmpty(editRequestName)) {\n                    closeEditWrap(out, editRequestName);\n                }\n\n                //if (Debug.infoOn()) Debug.logInfo(\"in Render(4), globalNodeTrail .\" + getWrapped(env, \"globalNodeTrail\") , module);\n            }\n\n            public void openEditWrap(Writer out, String editStyle) throws IOException {\n                String divStr = \"<div class=\\\"\" + editStyle + \"\\\">\";\n                out.write(divStr);\n            }\n\n            public void closeEditWrap(Writer out, String editRequestName) throws IOException {\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, contentId(3):\" + templateRoot.get(\"contentId\"), module);\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, subContentId(3):\" + templateRoot.get(\"subContentId\"), module);\n                StringBuffer sb = new StringBuffer();\n                String fullRequest = editRequestName;\n                String contentId = null;\n                contentId = (String)templateRoot.get(\"subContentId\");\n                String delim = \"?\";\n                if (UtilValidate.isNotEmpty(contentId)) {\n                    fullRequest += delim + \"contentId=\" + contentId;\n                    delim = \"&\";\n                }\n              \n                WidgetWorker.appendOfbizUrl(sb, fullRequest, request, response);\n                String url = sb.toString();\n                String link = \"<a href=\\\"\" + url + \"\\\">Edit<\/a>\";\n                out.write(link);\n                String divStr = \"<\/div>\";\n                out.write(divStr);\n            }\n\n            public String getEditStyle() {\n                String editStyle = (String)templateRoot.get(\"editStyle\");\n                if (UtilValidate.isEmpty(editStyle)) {\n                    editStyle = UtilProperties.getPropertyValue(\"content\", \"defaultEditStyle\");\n                }\n                if (UtilValidate.isEmpty(editStyle)) {\n                    editStyle = \"buttontext\";\n                }\n                return editStyle; \n            }\n        };\n    }","id":72188,"modified_method":"public Writer getWriter(final Writer out, Map args) {\n        final Environment env = Environment.getCurrentEnvironment();\n        //final Map templateCtx = (Map) FreeMarkerWorker.getWrappedObject(\"context\", env);\n        //final Map templateCtx = new HashMap();\n        final LocalDispatcher dispatcher = (LocalDispatcher) FreeMarkerWorker.getWrappedObject(\"dispatcher\", env);\n        final GenericDelegator delegator = (GenericDelegator) FreeMarkerWorker.getWrappedObject(\"delegator\", env);\n        final HttpServletRequest request = (HttpServletRequest) FreeMarkerWorker.getWrappedObject(\"request\", env);\n        final HttpServletResponse response = (HttpServletResponse) FreeMarkerWorker.getWrappedObject(\"response\", env);\n        final Map templateRoot = FreeMarkerWorker.createEnvironmentMap(env);\n        if (Debug.verboseOn()) Debug.logVerbose(\"in RenderSubContent, contentId(0):\" + templateRoot.get(\"contentId\"), module);\n        FreeMarkerWorker.getSiteParameters(request, templateRoot);\n        final Map savedValuesUp = new HashMap();\n        FreeMarkerWorker.saveContextValues(templateRoot, upSaveKeyNames, savedValuesUp);\n        FreeMarkerWorker.overrideWithArgs(templateRoot, args);\n        if (Debug.verboseOn()) Debug.logVerbose(\"in RenderSubContent, contentId(2):\" + templateRoot.get(\"contentId\"), module);\n        // not used yet: final GenericValue userLogin = (GenericValue) FreeMarkerWorker.getWrappedObject(\"userLogin\", env);\n        // not used yet: List trail = (List)templateRoot.get(\"globalNodeTrail\");\n        //if (Debug.infoOn()) Debug.logInfo(\"in Render(0), globalNodeTrail .\" + trail , module);\n        // not used yet: String contentAssocPredicateId = (String)templateRoot.get(\"contentAssocPredicateId\");\n        // not used yet: String strNullThruDatesOnly = (String)templateRoot.get(\"nullThruDatesOnly\");\n        // not used yet: Boolean nullThruDatesOnly = (strNullThruDatesOnly != null && strNullThruDatesOnly.equalsIgnoreCase(\"true\")) ? Boolean.TRUE :Boolean.FALSE;\n        final String thisContentId =  (String)templateRoot.get(\"contentId\");\n        final String xmlEscape =  (String)templateRoot.get(\"xmlEscape\");\n        final boolean directAssocMode = UtilValidate.isNotEmpty(thisContentId) ? true : false;\n        if (Debug.verboseOn()) Debug.logVerbose(\"in Render(0), directAssocMode .\" + directAssocMode , module);\n        /*\n        if (Debug.infoOn()) Debug.logInfo(\"in Render(0), thisSubContentId .\" + thisSubContentId , module);\n        String thisSubContentId =  (String)templateRoot.get(\"subContentId\");\n        GenericValue val = null;\n        try {\n            val = FreeMarkerWorker.getCurrentContent(delegator, trail, userLogin, templateRoot, nullThruDatesOnly, contentAssocPredicateId);\n        } catch(GeneralException e) {\n            throw new RuntimeException(\"Error getting current content. \" + e.toString());\n        }\n        final GenericValue view = val;\n\n        String dataResourceId = null;\n        String subContentIdSub = null;\n        if (view != null) {\n            try {\n                dataResourceId = (String) view.get(\"drDataResourceId\");\n            } catch (Exception e) {\n                dataResourceId = (String) view.get(\"dataResourceId\");\n            }\n            subContentIdSub = (String) view.get(\"contentId\");\n        }\n        // This order is taken so that the dataResourceType can be overridden in the transform arguments.\n        String subDataResourceTypeId = (String)templateRoot.get(\"subDataResourceTypeId\");\n        if (UtilValidate.isEmpty(subDataResourceTypeId)) {\n            try {\n                subDataResourceTypeId = (String) view.get(\"drDataResourceTypeId\");\n            } catch (Exception e) {\n                // view may be \"Content\"\n            }\n            // TODO: If this value is still empty then it is probably necessary to get a value from\n            // the parent context. But it will already have one and it is the same context that is\n            // being passed.\n        }\n        String mimeTypeId = FreeMarkerWorker.getMimeTypeId(delegator, view, templateRoot);\n        templateRoot.put(\"drDataResourceId\", dataResourceId);\n        templateRoot.put(\"mimeTypeId\", mimeTypeId);\n        templateRoot.put(\"dataResourceId\", dataResourceId);\n        templateRoot.put(\"subContentId\", subContentIdSub);\n        templateRoot.put(\"subDataResourceTypeId\", subDataResourceTypeId);\n        */\n\n        final Map savedValues = new HashMap();\n\n        return new Writer(out) {\n\n            public void write(char cbuf[], int off, int len) {\n            }\n\n            public void flush() throws IOException {\n                out.flush();\n            }\n\n            public void close() throws IOException {\n                List globalNodeTrail = (List)templateRoot.get(\"globalNodeTrail\");\n                if (Debug.verboseOn()) Debug.logVerbose(\"Render close, globalNodeTrail(2a):\" + ContentWorker.nodeTrailToCsv(globalNodeTrail), \"\");\n                renderSubContent();\n                //if (Debug.verboseOn()) Debug.logVerbose(\"in Render(2), globalNodeTrail .\" + getWrapped(env, \"globalNodeTrail\") , module);\n            }\n\n            public void renderSubContent() throws IOException {\n                String mimeTypeId = (String) templateRoot.get(\"mimeTypeId\");\n                Object localeObject = templateRoot.get(\"locale\");\n                Locale locale = null;\n                if (localeObject == null) {\n                    locale = UtilHttp.getLocale(request);\n                } else {\n                    locale = UtilMisc.ensureLocale(localeObject);\n                }\n\n                //TemplateHashModel dataRoot = env.getDataModel();\n                // Timestamp fromDate = UtilDateTime.nowTimestamp();\n                // List passedGlobalNodeTrail = (List)templateRoot.get(\"globalNodeTrail\");\n                String editRequestName = (String)templateRoot.get(\"editRequestName\");\n                 if (Debug.verboseOn()) Debug.logVerbose(\"in Render(3), editRequestName .\" + editRequestName , module);\n                 /*\n                GenericValue thisView = null;\n                if (view != null) {\n                    thisView = view;\n                } else if (passedGlobalNodeTrail.size() > 0) {\n                    Map map = (Map)passedGlobalNodeTrail.get(passedGlobalNodeTrail.size() - 1);\n                    if (Debug.infoOn()) Debug.logInfo(\"in Render(3), map .\" + map , module);\n                    if (map != null)\n                        thisView = (GenericValue)map.get(\"value\");\n                }\n                if (Debug.verboseOn()) Debug.logVerbose(\"in RenderSubContent, subContentId:\" + templateRoot.get(\"subContentId\"), module);\n                if (Debug.verboseOn()) Debug.logVerbose(\"in RenderSubContent, contentId:\" + templateRoot.get(\"contentId\"), module);\n                */\n\n                if (UtilValidate.isNotEmpty(editRequestName)) {\n                    String editStyle = getEditStyle();\n                    openEditWrap(out, editStyle);\n                }\n\n                if (Debug.verboseOn()) Debug.logVerbose(\"in RenderSubContent, contentId(2):\" + templateRoot.get(\"contentId\"), module);\n                if (Debug.verboseOn()) Debug.logVerbose(\"in RenderSubContent, subContentId(2):\" + templateRoot.get(\"subContentId\"), module);\n                FreeMarkerWorker.saveContextValues(templateRoot, saveKeyNames, savedValues);\n                //if (thisView != null) {\n                    try {\n                        String txt = ContentWorker.renderContentAsText(dispatcher, delegator, thisContentId, templateRoot, locale, mimeTypeId, true);\n                        if (\"true\".equals(xmlEscape)) {\n                            txt = UtilFormatOut.encodeXmlValue(txt);\n                        }\n                        \n                        out.write(txt);\n                        \n                        // if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, after renderContentAsTextCache:\", module);\n                    } catch (GeneralException e) {\n                        String errMsg = \"Error rendering thisContentId:\" + thisContentId + \" msg:\" + e.toString();\n                        Debug.logError(e, errMsg, module);\n                        // just log a message and don't return anything: throw new IOException();\n                    }\n                //}\n                FreeMarkerWorker.reloadValues(templateRoot, savedValuesUp, env);\n                FreeMarkerWorker.reloadValues(templateRoot, savedValues, env);\n                if (UtilValidate.isNotEmpty(editRequestName)) {\n                    closeEditWrap(out, editRequestName);\n                }\n\n                //if (Debug.infoOn()) Debug.logInfo(\"in Render(4), globalNodeTrail .\" + getWrapped(env, \"globalNodeTrail\") , module);\n            }\n\n            public void openEditWrap(Writer out, String editStyle) throws IOException {\n                String divStr = \"<div class=\\\"\" + editStyle + \"\\\">\";\n                out.write(divStr);\n            }\n\n            public void closeEditWrap(Writer out, String editRequestName) throws IOException {\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, contentId(3):\" + templateRoot.get(\"contentId\"), module);\n                if (Debug.infoOn()) Debug.logInfo(\"in RenderSubContent, subContentId(3):\" + templateRoot.get(\"subContentId\"), module);\n                StringBuffer sb = new StringBuffer();\n                String fullRequest = editRequestName;\n                String contentId = null;\n                contentId = (String)templateRoot.get(\"subContentId\");\n                String delim = \"?\";\n                if (UtilValidate.isNotEmpty(contentId)) {\n                    fullRequest += delim + \"contentId=\" + contentId;\n                    delim = \"&\";\n                }\n              \n                WidgetWorker.appendOfbizUrl(sb, fullRequest, request, response);\n                String url = sb.toString();\n                String link = \"<a href=\\\"\" + url + \"\\\">Edit<\/a>\";\n                out.write(link);\n                String divStr = \"<\/div>\";\n                out.write(divStr);\n            }\n\n            public String getEditStyle() {\n                String editStyle = (String)templateRoot.get(\"editStyle\");\n                if (UtilValidate.isEmpty(editStyle)) {\n                    editStyle = UtilProperties.getPropertyValue(\"content\", \"defaultEditStyle\");\n                }\n                if (UtilValidate.isEmpty(editStyle)) {\n                    editStyle = \"buttontext\";\n                }\n                return editStyle; \n            }\n        };\n    }","commit_id":"9e5d24e9f3b07892d241ccb5ed607400ddece31d","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map upsRateInquireByPostalCode(DispatchContext dctx, Map context) {\n\n        GenericDelegator delegator = dctx.getDelegator();\n        \n        // prepare the data\n        String serviceConfigProps = (String) context.get(\"serviceConfigProps\");\n        String upsRateInquireMode = (String) context.get(\"upsRateInquireMode\");\n        String productStoreId = (String) context.get(\"productStoreId\");\n        String carrierRoleTypeId = (String) context.get(\"carrierRoleTypeId\");\n        String carrierPartyId = (String) context.get(\"carrierPartyId\");\n        String shipmentMethodTypeId = (String) context.get(\"shipmentMethodTypeId\");\n       // String shippingContactMechId = (String) context.get(\"shippingContactMechId\");\n        String shippingPostalCode = (String) context.get(\"shippingPostalCode\");\n        String shippingCountryCode = (String) context.get(\"shippingCountryCode\");\n        List packageWeights = (List) context.get(\"packageWeights\");\n        List shippableItemInfo = (List) context.get(\"shippableItemInfo\");\n        Double shippableTotal = (Double) context.get(\"shippableTotal\");\n        Double shippableQuantity = (Double) context.get(\"shippableQuantity\");\n        Double shippableWeight = (Double) context.get(\"shippableWeight\");\n        String isResidentialAddress = (String)context.get(\"isResidentialAddress\");\n        if (shippableTotal == null) {\n            shippableTotal = new Double(0.00);\n        }\n        if (shippableQuantity == null) {\n            shippableQuantity = new Double(0.00);\n        }\n        if (shippableWeight == null) {\n            shippableWeight = new Double(0.00);\n        }\n        if (serviceConfigProps == null) {\n            serviceConfigProps = \"shipment.properties\";\n        }\n        if (upsRateInquireMode == null || !\"Shop\".equals(upsRateInquireMode)) {\n            // can be either Rate || Shop\n            Debug.logWarning(\"No upsRateInquireMode set, defaulting to 'Rate'\", module);\n            upsRateInquireMode = \"Rate\";\n        }\n        \n        // grab the pickup type; if none is defined we will assume daily pickup\n        String pickupType = UtilProperties.getPropertyValue(serviceConfigProps, \"shipment.ups.shipper.pickup.type\", \"01\");\n        \n        // locate the ship-from address based on the product store's default facility\n        GenericValue productStore = ProductStoreWorker.getProductStore(productStoreId, delegator);\n        \n        GenericValue shipFromAddress = null;\n        if (productStore != null && productStore.get(\"inventoryFacilityId\") != null) {\n            List shipLocs = null;\n            try {\n                shipLocs = delegator.findByAnd(\"FacilityContactMechPurpose\", UtilMisc.toMap(\"facilityId\",\n                        productStore.getString(\"inventoryFacilityId\"), \"contactMechPurposeTypeId\",\n                        \"SHIP_ORIG_LOCATION\"), UtilMisc.toList(\"-fromDate\"));\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n            }\n            if (shipLocs != null) {\n                shipLocs = EntityUtil.filterByDate(shipLocs);\n                GenericValue purp =  EntityUtil.getFirst(shipLocs);\n                if (purp != null) {\n                    try {\n                        shipFromAddress = delegator.findByPrimaryKey(\"PostalAddress\", UtilMisc.toMap(\"contactMechId\", purp.getString(\"contactMechId\")));\n                    } catch (GenericEntityException e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            }\n        }\n        if (shipFromAddress == null) {\n            return ServiceUtil.returnError(\"Unable to determine ship-from address\");\n        }\n\n        // obtain the ship-to address\n        /*GenericValue shipToAddress = null;\n        if (shippingContactMechId != null) {\n            try {\n                shipToAddress = delegator.findByPrimaryKey(\"PostalAddress\", UtilMisc.toMap(\"contactMechId\", shippingContactMechId));\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n            }\n        }\n        if (shipToAddress == null) {\n            return ServiceUtil.returnError(\"Unable to determine ship-to address\");\n        }*/\n\n        // locate the service code\n        String serviceCode = null;\n        if (!\"Shop\".equals(upsRateInquireMode)) {\n            // locate the CarrierShipmentMethod record\n            GenericValue carrierShipmentMethod = null;\n            try {\n                carrierShipmentMethod = delegator.findByPrimaryKey(\"CarrierShipmentMethod\", UtilMisc.toMap(\"shipmentMethodTypeId\",\n                        shipmentMethodTypeId, \"partyId\", carrierPartyId, \"roleTypeId\", carrierRoleTypeId));\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n            }\n            if (carrierShipmentMethod == null) {\n                return ServiceUtil.returnError(\"Unable to locate the shipping method requested\");\n            }\n\n            // service code is 'carrierServiceCode'\n            serviceCode = carrierShipmentMethod.getString(\"carrierServiceCode\");\n            \n        }\n        \n        // prepare the XML Document\n        Document rateRequestDoc = UtilXml.makeEmptyXmlDocument(\"RatingServiceSelectionRequest\");\n        Element rateRequestElement = rateRequestDoc.getDocumentElement();\n        rateRequestElement.setAttribute(\"xml:lang\", \"en-US\");\n        \n        // XML request header\n        Element requestElement = UtilXml.addChildElement(rateRequestElement, \"Request\", rateRequestDoc);\n        Element transactionReferenceElement = UtilXml.addChildElement(requestElement, \"TransactionReference\", rateRequestDoc);\n        UtilXml.addChildElementValue(transactionReferenceElement, \"CustomerContext\", \"Rating and Service\", rateRequestDoc);\n        UtilXml.addChildElementValue(transactionReferenceElement, \"XpciVersion\", \"1.0001\", rateRequestDoc);\n\n        // RequestAction is always Rate, but RequestOption can be Rate to get a single rate or Shop for all shipping methods\n        UtilXml.addChildElementValue(requestElement, \"RequestAction\", \"Rate\", rateRequestDoc);\n        UtilXml.addChildElementValue(requestElement, \"RequestOption\", upsRateInquireMode, rateRequestDoc);\n\n        // set the pickup type\n        Element pickupElement = UtilXml.addChildElement(rateRequestElement, \"PickupType\", rateRequestDoc);\n        UtilXml.addChildElementValue(pickupElement, \"Code\", pickupType, rateRequestDoc);\n\n        // shipment info\n        Element shipmentElement = UtilXml.addChildElement(rateRequestElement, \"Shipment\", rateRequestDoc);\n\n        // shipper info - (sub of shipment)\n        Element shipperElement = UtilXml.addChildElement(shipmentElement, \"Shipper\", rateRequestDoc);\n        Element shipperAddrElement = UtilXml.addChildElement(shipperElement, \"Address\", rateRequestDoc);\n        UtilXml.addChildElementValue(shipperAddrElement, \"PostalCode\", shipFromAddress.getString(\"postalCode\"), rateRequestDoc);\n\n        // ship-to info - (sub of shipment)\n        Element shiptoElement = UtilXml.addChildElement(shipmentElement, \"ShipTo\", rateRequestDoc);\n        Element shiptoAddrElement = UtilXml.addChildElement(shiptoElement, \"Address\", rateRequestDoc);\n        UtilXml.addChildElementValue(shiptoAddrElement, \"PostalCode\", shippingPostalCode, rateRequestDoc);\n        if (shippingCountryCode != null && !shippingCountryCode.equals(\"\")) {\n            UtilXml.addChildElementValue(shiptoAddrElement, \"CountryCode\", shippingCountryCode, rateRequestDoc);\n        }\n        \n        if (isResidentialAddress != null && isResidentialAddress.equals(\"Y\")) {\n            UtilXml.addChildElement(shiptoAddrElement, \"ResidentialAddress\", rateRequestDoc);\n        }\n        // requested service (code) - not used when in Shop mode\n        if (serviceCode != null) {\n            Element serviceElement = UtilXml.addChildElement(shipmentElement, \"Service\", rateRequestDoc);\n            UtilXml.addChildElementValue(serviceElement, \"Code\", serviceCode, rateRequestDoc);\n        }\n\n        // package info\n        String maxWeightStr = UtilProperties.getPropertyValue(serviceConfigProps, \"shipment.ups.max.estimate.weight\", \"99\");\n        double maxWeight = 99;\n        try {\n            maxWeight = Double.parseDouble(maxWeightStr);\n        } catch (NumberFormatException e) {\n            maxWeight = 99;\n        }\n        String minWeightStr = UtilProperties.getPropertyValue(serviceConfigProps, \"shipment.ups.min.estimate.weight\", \".1\");\n        double minWeight = .1;\n        try {\n            minWeight = Double.parseDouble(minWeightStr);\n        } catch (NumberFormatException e) {\n            minWeight = .1;\n        }\n        \n        // Passing in a list of package weights overrides the calculation of same via shippableItemInfo\n        if (UtilValidate.isEmpty(packageWeights)) {           \n                        \n            splitEstimatePackages(rateRequestDoc, shipmentElement, shippableItemInfo, maxWeight, minWeight);\n        } else {\n            Iterator i = packageWeights.iterator();\n            while (i.hasNext()) {\n                Double packageWeight = (Double) i.next();\n                addPackageElement(rateRequestDoc,  shipmentElement, packageWeight);\n            }\n        }\n\n        // service options\n        UtilXml.addChildElement(shipmentElement, \"ShipmentServiceOptions\", rateRequestDoc);\n\n        String rateRequestString = null;\n        try {\n            rateRequestString = UtilXml.writeXmlDocument(rateRequestDoc);\n        } catch (IOException e) {\n            String ioeErrMsg = \"Error writing the RatingServiceSelectionRequest XML Document to a String: \" + e.toString();\n            Debug.logError(e, ioeErrMsg, module);\n            return ServiceUtil.returnError(ioeErrMsg);\n        }\n        \n        // create AccessRequest XML doc\n        Document accessRequestDocument = createAccessRequestDocument(serviceConfigProps);\n        String accessRequestString = null;\n        try {\n            accessRequestString = UtilXml.writeXmlDocument(accessRequestDocument);\n        } catch (IOException e) {\n            String ioeErrMsg = \"Error writing the AccessRequest XML Document to a String: \" + e.toString();\n            Debug.logError(e, ioeErrMsg, module);\n            return ServiceUtil.returnError(ioeErrMsg);\n        }\n\n        // prepare the access/inquire request string\n        StringBuffer xmlString = new StringBuffer();\n        xmlString.append(accessRequestString);\n        xmlString.append(rateRequestString);\n        Debug.logInfo(xmlString.toString(), module);       \n        // send the request\n        String rateResponseString = null;\n        try {\n            rateResponseString = sendUpsRequest(\"Rate\", xmlString.toString());\n        } catch (UpsConnectException e) {\n            String uceErrMsg = \"Error sending UPS request for UPS Service Rate: \" + e.toString();\n            Debug.logError(e, uceErrMsg, module);\n            return ServiceUtil.returnError(uceErrMsg);\n        }\n        Debug.logInfo(rateResponseString, module);       \n        Document rateResponseDocument = null;\n        try {\n            rateResponseDocument = UtilXml.readXmlDocument(rateResponseString, false);\n        } catch (SAXException e2) {\n            String excErrMsg = \"Error parsing the RatingServiceSelectionResponse: \" + e2.toString();\n            Debug.logError(e2, excErrMsg, module);\n            return ServiceUtil.returnError(excErrMsg);\n        } catch (ParserConfigurationException e2) {\n            String excErrMsg = \"Error parsing the RatingServiceSelectionResponse: \" + e2.toString();\n            Debug.logError(e2, excErrMsg, module);\n            return ServiceUtil.returnError(excErrMsg);\n        } catch (IOException e2) {\n            String excErrMsg = \"Error parsing the RatingServiceSelectionResponse: \" + e2.toString();\n            Debug.logError(e2, excErrMsg, module);\n            return ServiceUtil.returnError(excErrMsg);\n        }        \n        return handleUpsRateInquireResponse(rateResponseDocument);\n\n    \n    }","id":72189,"modified_method":"public static Map upsRateInquireByPostalCode(DispatchContext dctx, Map context) {\n\n        GenericDelegator delegator = dctx.getDelegator();\n        \n        // prepare the data\n        String serviceConfigProps = (String) context.get(\"serviceConfigProps\");\n        String upsRateInquireMode = (String) context.get(\"upsRateInquireMode\");\n        String productStoreId = (String) context.get(\"productStoreId\");\n        String carrierRoleTypeId = (String) context.get(\"carrierRoleTypeId\");\n        String carrierPartyId = (String) context.get(\"carrierPartyId\");\n        String shipmentMethodTypeId = (String) context.get(\"shipmentMethodTypeId\");\n       // String shippingContactMechId = (String) context.get(\"shippingContactMechId\");\n        String shippingPostalCode = (String) context.get(\"shippingPostalCode\");\n        String shippingCountryCode = (String) context.get(\"shippingCountryCode\");\n        List packageWeights = (List) context.get(\"packageWeights\");\n        List shippableItemInfo = (List) context.get(\"shippableItemInfo\");\n        Double shippableTotal = (Double) context.get(\"shippableTotal\");\n        Double shippableQuantity = (Double) context.get(\"shippableQuantity\");\n        Double shippableWeight = (Double) context.get(\"shippableWeight\");\n        String isResidentialAddress = (String)context.get(\"isResidentialAddress\");\n        if (shippableTotal == null) {\n            shippableTotal = new Double(0.00);\n        }\n        if (shippableQuantity == null) {\n            shippableQuantity = new Double(0.00);\n        }\n        if (shippableWeight == null) {\n            shippableWeight = new Double(0.00);\n        }\n        if (serviceConfigProps == null) {\n            serviceConfigProps = \"shipment.properties\";\n        }\n        if (upsRateInquireMode == null || !\"Shop\".equals(upsRateInquireMode)) {\n            // can be either Rate || Shop\n            Debug.logWarning(\"No upsRateInquireMode set, defaulting to 'Rate'\", module);\n            upsRateInquireMode = \"Rate\";\n        }\n        \n        // grab the pickup type; if none is defined we will assume daily pickup\n        String pickupType = UtilProperties.getPropertyValue(serviceConfigProps, \"shipment.ups.shipper.pickup.type\", \"01\");\n        \n        // locate the ship-from address based on the product store's default facility\n        GenericValue productStore = ProductStoreWorker.getProductStore(productStoreId, delegator);\n        \n        GenericValue shipFromAddress = null;\n        if (productStore != null && productStore.get(\"inventoryFacilityId\") != null) {\n            List shipLocs = null;\n            try {\n                shipLocs = delegator.findByAnd(\"FacilityContactMechPurpose\", UtilMisc.toMap(\"facilityId\",\n                        productStore.getString(\"inventoryFacilityId\"), \"contactMechPurposeTypeId\",\n                        \"SHIP_ORIG_LOCATION\"), UtilMisc.toList(\"-fromDate\"));\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n            }\n            if (shipLocs != null) {\n                shipLocs = EntityUtil.filterByDate(shipLocs);\n                GenericValue purp =  EntityUtil.getFirst(shipLocs);\n                if (purp != null) {\n                    try {\n                        shipFromAddress = delegator.findByPrimaryKey(\"PostalAddress\", UtilMisc.toMap(\"contactMechId\", purp.getString(\"contactMechId\")));\n                    } catch (GenericEntityException e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            }\n        }\n        if (shipFromAddress == null) {\n            return ServiceUtil.returnError(\"Unable to determine ship-from address\");\n        }\n\n        // obtain the ship-to address\n        /*GenericValue shipToAddress = null;\n        if (shippingContactMechId != null) {\n            try {\n                shipToAddress = delegator.findByPrimaryKey(\"PostalAddress\", UtilMisc.toMap(\"contactMechId\", shippingContactMechId));\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n            }\n        }\n        if (shipToAddress == null) {\n            return ServiceUtil.returnError(\"Unable to determine ship-to address\");\n        }*/\n\n        // locate the service code\n        String serviceCode = null;\n        if (!\"Shop\".equals(upsRateInquireMode)) {\n            // locate the CarrierShipmentMethod record\n            GenericValue carrierShipmentMethod = null;\n            try {\n                carrierShipmentMethod = delegator.findByPrimaryKey(\"CarrierShipmentMethod\", UtilMisc.toMap(\"shipmentMethodTypeId\",\n                        shipmentMethodTypeId, \"partyId\", carrierPartyId, \"roleTypeId\", carrierRoleTypeId));\n            } catch (GenericEntityException e) {\n                Debug.logError(e, module);\n            }\n            if (carrierShipmentMethod == null) {\n                return ServiceUtil.returnError(\"Unable to locate the shipping method requested\");\n            }\n\n            // service code is 'carrierServiceCode'\n            serviceCode = carrierShipmentMethod.getString(\"carrierServiceCode\");\n            \n        }\n        \n        // prepare the XML Document\n        Document rateRequestDoc = UtilXml.makeEmptyXmlDocument(\"RatingServiceSelectionRequest\");\n        Element rateRequestElement = rateRequestDoc.getDocumentElement();\n        rateRequestElement.setAttribute(\"xml:lang\", \"en-US\");\n        \n        // XML request header\n        Element requestElement = UtilXml.addChildElement(rateRequestElement, \"Request\", rateRequestDoc);\n        Element transactionReferenceElement = UtilXml.addChildElement(requestElement, \"TransactionReference\", rateRequestDoc);\n        UtilXml.addChildElementValue(transactionReferenceElement, \"CustomerContext\", \"Rating and Service\", rateRequestDoc);\n        UtilXml.addChildElementValue(transactionReferenceElement, \"XpciVersion\", \"1.0001\", rateRequestDoc);\n\n        // RequestAction is always Rate, but RequestOption can be Rate to get a single rate or Shop for all shipping methods\n        UtilXml.addChildElementValue(requestElement, \"RequestAction\", \"Rate\", rateRequestDoc);\n        UtilXml.addChildElementValue(requestElement, \"RequestOption\", upsRateInquireMode, rateRequestDoc);\n\n        // set the pickup type\n        Element pickupElement = UtilXml.addChildElement(rateRequestElement, \"PickupType\", rateRequestDoc);\n        UtilXml.addChildElementValue(pickupElement, \"Code\", pickupType, rateRequestDoc);\n\n        // shipment info\n        Element shipmentElement = UtilXml.addChildElement(rateRequestElement, \"Shipment\", rateRequestDoc);\n\n        // shipper info - (sub of shipment)\n        Element shipperElement = UtilXml.addChildElement(shipmentElement, \"Shipper\", rateRequestDoc);\n        Element shipperAddrElement = UtilXml.addChildElement(shipperElement, \"Address\", rateRequestDoc);\n        UtilXml.addChildElementValue(shipperAddrElement, \"PostalCode\", shipFromAddress.getString(\"postalCode\"), rateRequestDoc);\n\n        // ship-to info - (sub of shipment)\n        Element shiptoElement = UtilXml.addChildElement(shipmentElement, \"ShipTo\", rateRequestDoc);\n        Element shiptoAddrElement = UtilXml.addChildElement(shiptoElement, \"Address\", rateRequestDoc);\n        UtilXml.addChildElementValue(shiptoAddrElement, \"PostalCode\", shippingPostalCode, rateRequestDoc);\n        if (shippingCountryCode != null && !shippingCountryCode.equals(\"\")) {\n            UtilXml.addChildElementValue(shiptoAddrElement, \"CountryCode\", shippingCountryCode, rateRequestDoc);\n        }\n        \n        if (isResidentialAddress != null && isResidentialAddress.equals(\"Y\")) {\n            UtilXml.addChildElement(shiptoAddrElement, \"ResidentialAddress\", rateRequestDoc);\n        }\n        // requested service (code) - not used when in Shop mode\n        if (serviceCode != null) {\n            Element serviceElement = UtilXml.addChildElement(shipmentElement, \"Service\", rateRequestDoc);\n            UtilXml.addChildElementValue(serviceElement, \"Code\", serviceCode, rateRequestDoc);\n        }\n\n        // package info\n        String maxWeightStr = UtilProperties.getPropertyValue(serviceConfigProps, \"shipment.ups.max.estimate.weight\", \"99\");\n        double maxWeight = 99;\n        try {\n            maxWeight = Double.parseDouble(maxWeightStr);\n        } catch (NumberFormatException e) {\n            maxWeight = 99;\n        }\n        String minWeightStr = UtilProperties.getPropertyValue(serviceConfigProps, \"shipment.ups.min.estimate.weight\", \".1\");\n        double minWeight = .1;\n        try {\n            minWeight = Double.parseDouble(minWeightStr);\n        } catch (NumberFormatException e) {\n            minWeight = .1;\n        }\n        \n        // Passing in a list of package weights overrides the calculation of same via shippableItemInfo\n        if (UtilValidate.isEmpty(packageWeights)) {           \n                        \n            splitEstimatePackages(rateRequestDoc, shipmentElement, shippableItemInfo, maxWeight, minWeight);\n        } else {\n            Iterator i = packageWeights.iterator();\n            while (i.hasNext()) {\n                Double packageWeight = (Double) i.next();\n                addPackageElement(rateRequestDoc,  shipmentElement, packageWeight);\n            }\n        }\n\n        // service options\n        UtilXml.addChildElement(shipmentElement, \"ShipmentServiceOptions\", rateRequestDoc);\n\n        String rateRequestString = null;\n        try {\n            rateRequestString = UtilXml.writeXmlDocument(rateRequestDoc);\n        } catch (IOException e) {\n            String ioeErrMsg = \"Error writing the RatingServiceSelectionRequest XML Document to a String: \" + e.toString();\n            Debug.logError(e, ioeErrMsg, module);\n            return ServiceUtil.returnError(ioeErrMsg);\n        }\n        \n        // create AccessRequest XML doc\n        Document accessRequestDocument = createAccessRequestDocument(serviceConfigProps);\n        String accessRequestString = null;\n        try {\n            accessRequestString = UtilXml.writeXmlDocument(accessRequestDocument);\n        } catch (IOException e) {\n            String ioeErrMsg = \"Error writing the AccessRequest XML Document to a String: \" + e.toString();\n            Debug.logError(e, ioeErrMsg, module);\n            return ServiceUtil.returnError(ioeErrMsg);\n        }\n\n        // prepare the access/inquire request string\n        StringBuffer xmlString = new StringBuffer();\n        xmlString.append(accessRequestString);\n        xmlString.append(rateRequestString);\n        if (Debug.verboseOn()) Debug.logVerbose(xmlString.toString(), module);       \n        // send the request\n        String rateResponseString = null;\n        try {\n            rateResponseString = sendUpsRequest(\"Rate\", xmlString.toString());\n        } catch (UpsConnectException e) {\n            String uceErrMsg = \"Error sending UPS request for UPS Service Rate: \" + e.toString();\n            Debug.logError(e, uceErrMsg, module);\n            return ServiceUtil.returnError(uceErrMsg);\n        }\n        Debug.logInfo(rateResponseString, module);       \n        Document rateResponseDocument = null;\n        try {\n            rateResponseDocument = UtilXml.readXmlDocument(rateResponseString, false);\n        } catch (SAXException e2) {\n            String excErrMsg = \"Error parsing the RatingServiceSelectionResponse: \" + e2.toString();\n            Debug.logError(e2, excErrMsg, module);\n            return ServiceUtil.returnError(excErrMsg);\n        } catch (ParserConfigurationException e2) {\n            String excErrMsg = \"Error parsing the RatingServiceSelectionResponse: \" + e2.toString();\n            Debug.logError(e2, excErrMsg, module);\n            return ServiceUtil.returnError(excErrMsg);\n        } catch (IOException e2) {\n            String excErrMsg = \"Error parsing the RatingServiceSelectionResponse: \" + e2.toString();\n            Debug.logError(e2, excErrMsg, module);\n            return ServiceUtil.returnError(excErrMsg);\n        }        \n        return handleUpsRateInquireResponse(rateResponseDocument);\n\n    \n    }","commit_id":"9e5d24e9f3b07892d241ccb5ed607400ddece31d","url":"https://github.com/apache/ofbiz"},{"original_method":"/** Formats a double into a properly formatted currency string based on isoCode and Locale\n     * @param price The price double to be formatted\n     * @param isoCode the currency ISO code\n     * @param locale The Locale used to format the number\n     * @param maximumFractionDigits The maximum number of fraction digits used; if set to -1 than the default value for the locale is used\n     * @return A String with the formatted price\n     */\n    public static String formatCurrency(double price, String isoCode, Locale locale, int maximumFractionDigits) {\n        //Debug.logInfo(\"formatting currency: \" + price + \", isoCode: \" + isoCode + \", locale: \" + locale, module);\n        com.ibm.icu.text.NumberFormat nf = com.ibm.icu.text.NumberFormat.getCurrencyInstance(locale);\n        if (isoCode != null && isoCode.length() > 1) {\n            nf.setCurrency(com.ibm.icu.util.Currency.getInstance(isoCode));\n        } else {\n            Debug.logWarning(\"No isoCode specified to format currency value:\" + price, module);\n        }\n        if (maximumFractionDigits >= 0) {\n            nf.setMaximumFractionDigits(maximumFractionDigits);\n        }\n        return nf.format(price);\n    }","id":72190,"modified_method":"/** Formats a double into a properly formatted currency string based on isoCode and Locale\n     * @param price The price double to be formatted\n     * @param isoCode the currency ISO code\n     * @param locale The Locale used to format the number\n     * @param maximumFractionDigits The maximum number of fraction digits used; if set to -1 than the default value for the locale is used\n     * @return A String with the formatted price\n     */\n    public static String formatCurrency(double price, String isoCode, Locale locale, int maximumFractionDigits) {\n        //Debug.logInfo(\"formatting currency: \" + price + \", isoCode: \" + isoCode + \", locale: \" + locale, module);\n        com.ibm.icu.text.NumberFormat nf = com.ibm.icu.text.NumberFormat.getCurrencyInstance(locale);\n        if (isoCode != null && isoCode.length() > 1) {\n            nf.setCurrency(com.ibm.icu.util.Currency.getInstance(isoCode));\n        } else {\n            if (Debug.verboseOn()) Debug.logVerbose(\"No isoCode specified to format currency value:\" + price, module);\n        }\n        if (maximumFractionDigits >= 0) {\n            nf.setMaximumFractionDigits(maximumFractionDigits);\n        }\n        return nf.format(price);\n    }","commit_id":"9e5d24e9f3b07892d241ccb5ed607400ddece31d","url":"https://github.com/apache/ofbiz"},{"original_method":"public void open()\r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n\t\tshell.setImage(GUIResource.getInstance().getImageConnection());\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(Messages.getString(\"SQLEditor.Title\"));\r\n\t\t\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Script line\r\n\t\twlScript=new Label(shell, SWT.NONE);\r\n\t\twlScript.setText(Messages.getString(\"SQLEditor.Editor.Label\"));\r\n \t\tprops.setLook(wlScript);\r\n\n\t\tfdlScript=new FormData();\r\n\t\tfdlScript.left = new FormAttachment(0, 0);\r\n\t\tfdlScript.top  = new FormAttachment(0, 0);\r\n\t\twlScript.setLayoutData(fdlScript);\r\n\t\twScript=new Text(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);\r\n\t\twScript.setText(\"\");\r\n \t\tprops.setLook(wScript, Props.WIDGET_STYLE_FIXED);\n\t\tfdScript=new FormData();\r\n\t\tfdScript.left   = new FormAttachment(0, 0);\r\n\t\tfdScript.top    = new FormAttachment(wlScript, margin);\r\n\t\tfdScript.right  = new FormAttachment(100, -5);\r\n\t\tfdScript.bottom = new FormAttachment(100, -70);\r\n\t\twScript.setLayoutData(fdScript);\r\n\r\n\t\twlPosition=new Label(shell, SWT.NONE);\r\n\t\twlPosition.setText(Messages.getString(\"SQLEditor.LineNr.Label\", \"0\"));\r\n \t\tprops.setLook(wlPosition);\n\t\tfdlPosition=new FormData();\r\n\t\tfdlPosition.left = new FormAttachment(0, 0);\r\n\t\tfdlPosition.top  = new FormAttachment(wScript, margin);\r\n\t\twlPosition.setLayoutData(fdlPosition);\r\n\r\n\t\twExec=new Button(shell, SWT.PUSH);\r\n\t\twExec.setText(Messages.getString(\"SQLEditor.Button.Execute\"));\r\n        wClear=new Button(shell, SWT.PUSH);\n        wClear.setText(Messages.getString(\"SQLEditor.Button.ClearCache\"));\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(Messages.getString(\"System.Button.Close\"));\r\n\n        wClear.setToolTipText(Messages.getString(\"SQLEditor.Button.ClearCache.Tooltip\"));\n        \n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wExec, wClear, wCancel }, margin, null);\n\t\t\r\n\t\t// Add listeners\r\n\t\tlsCancel = new Listener() { public void handleEvent(Event e) { cancel(); } };\r\n        lsClear  = new Listener() { public void handleEvent(Event e) { clearCache(); } };\n\t\tlsExec   = new Listener() { public void handleEvent(Event e) { try { exec(); } catch(Exception ge) {} } };\r\n\t\t\r\n\t\twCancel.addListener  (SWT.Selection, lsCancel);\r\n        wClear.addListener   (SWT.Selection, lsClear);\n\t\twExec.addListener    (SWT.Selection, lsExec    );\r\n\t\t\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n\r\n\t\twScript.addKeyListener(new KeyAdapter() {\r\n\t\t\tpublic void keyReleased(KeyEvent e) \r\n\t\t\t{\r\n\t\t\t\tint linenr = wScript.getCaretLineNumber()+1;\r\n\t\t\t\twlPosition.setText(Messages.getString(\"SQLEditor.LineNr.Label\", Integer.toString(linenr)));\r\n\t\t\t}\r\n\t\t})\r\n\t\t;\r\n\t\t\r\n\t\tBaseStepDialog.setSize(shell);\n\r\n\t\tgetData();\r\n\t\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t}","id":72191,"modified_method":"public void open()\r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n\t\tshell.setImage(GUIResource.getInstance().getImageConnection());\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(Messages.getString(\"SQLEditor.Title\"));\r\n\t\t\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Script line\r\n\t\twlScript=new Label(shell, SWT.NONE);\r\n\t\twlScript.setText(Messages.getString(\"SQLEditor.Editor.Label\"));\r\n \t\tprops.setLook(wlScript);\r\n\n\t\tfdlScript=new FormData();\r\n\t\tfdlScript.left = new FormAttachment(0, 0);\r\n\t\tfdlScript.top  = new FormAttachment(0, 0);\r\n\t\twlScript.setLayoutData(fdlScript);\r\n\t\twScript=new StyledTextComp(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n\t\twScript.setText(\"\");\r\n \t\tprops.setLook(wScript, Props.WIDGET_STYLE_FIXED);\n\t\tfdScript=new FormData();\r\n\t\tfdScript.left   = new FormAttachment(0, 0);\r\n\t\tfdScript.top    = new FormAttachment(wlScript, margin);\r\n\t\tfdScript.right  = new FormAttachment(100, -5);\r\n\t\tfdScript.bottom = new FormAttachment(100, -70);\r\n\t\twScript.setLayoutData(fdScript);\r\n\t\t\r\n\t\twScript.addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent arg0)\r\n            {\r\n                setPosition();\r\n            }\r\n\r\n\t        }\r\n\t    );\r\n\t\t\t\r\n\t\t\r\n\t\twScript.addKeyListener(new KeyAdapter(){\r\n\t\t\tpublic void keyPressed(KeyEvent e) { setPosition(); }\r\n\t\t\tpublic void keyReleased(KeyEvent e) { setPosition(); }\r\n\t\t\t} \r\n\t\t);\r\n\t\twScript.addFocusListener(new FocusAdapter(){\r\n\t\t\tpublic void focusGained(FocusEvent e) { setPosition(); }\r\n\t\t\tpublic void focusLost(FocusEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\twScript.addMouseListener(new MouseAdapter(){\r\n\t\t\tpublic void mouseDoubleClick(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseDown(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseUp(MouseEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t\r\n\t\t// SQL Higlighting\r\n\t\tlineStyler = new SQLValuesHighlight();;\r\n\t\twScript.addLineStyleListener(lineStyler);\r\n\r\n\t\twlPosition=new Label(shell, SWT.NONE);\r\n\t\twlPosition.setText(Messages.getString(\"SQLEditor.LineNr.Label\", \"0\"));\r\n \t\tprops.setLook(wlPosition);\n\t\tfdlPosition=new FormData();\r\n\t\tfdlPosition.left = new FormAttachment(0, 0);\r\n\t\tfdlPosition.top  = new FormAttachment(wScript, margin);\r\n\t\tfdlPosition.right = new FormAttachment(100, 0);\r\n\t\twlPosition.setLayoutData(fdlPosition);\r\n\r\n\t\twExec=new Button(shell, SWT.PUSH);\r\n\t\twExec.setText(Messages.getString(\"SQLEditor.Button.Execute\"));\r\n        wClear=new Button(shell, SWT.PUSH);\n        wClear.setText(Messages.getString(\"SQLEditor.Button.ClearCache\"));\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(Messages.getString(\"System.Button.Close\"));\r\n\n        wClear.setToolTipText(Messages.getString(\"SQLEditor.Button.ClearCache.Tooltip\"));\n        \n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wExec, wClear, wCancel }, margin, null);\n\t\t\r\n\t\t// Add listeners\r\n\t\tlsCancel = new Listener() { public void handleEvent(Event e) { cancel(); } };\r\n        lsClear  = new Listener() { public void handleEvent(Event e) { clearCache(); } };\n\t\tlsExec   = new Listener() { public void handleEvent(Event e) { try { exec(); } catch(Exception ge) {} } };\r\n\t\t\r\n\t\twCancel.addListener  (SWT.Selection, lsCancel);\r\n        wClear.addListener   (SWT.Selection, lsClear);\n\t\twExec.addListener    (SWT.Selection, lsExec    );\r\n\t\t\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\t\t\r\n\t\tBaseStepDialog.setSize(shell);\n\r\n\t\tgetData();\r\n\t\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t}","commit_id":"c3455fe9dae754cdec21e3785a954202c3b92b90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open()\n    {\n        Shell parent = getParent();\n        Display display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n        ModifyListener lsMod = new ModifyListener()\n        {\n            public void modifyText(ModifyEvent e)\n            {\n                jobEntry.setChanged();\n            }\n        };\n        changed = jobEntry.hasChanged();\n\n        FormLayout formLayout = new FormLayout();\n        formLayout.marginWidth = Const.FORM_MARGIN;\n        formLayout.marginHeight = Const.FORM_MARGIN;\n\n        shell.setLayout(formLayout);\n        shell.setText(Messages.getString(\"JobEval.Title\"));\n\n        int middle = props.getMiddlePct();\n        int margin = Const.MARGIN;\n\n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n        // at the bottom\n        BaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, null);\n\n        // Filename line\n        wlName = new Label(shell, SWT.NONE);\n        wlName.setText(Messages.getString(\"JobEval.Jobname.Label\"));\n        props.setLook(wlName);\n        fdlName = new FormData();\n        fdlName.left = new FormAttachment(0, 0);\n        fdlName.top = new FormAttachment(0, margin);\n        wlName.setLayoutData(fdlName);\n        wName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wName);\n        wName.addModifyListener(lsMod);\n        fdName = new FormData();\n        fdName.left = new FormAttachment(middle, 0);\n        fdName.top = new FormAttachment(0, margin);\n        fdName.right = new FormAttachment(100, 0);\n        wName.setLayoutData(fdName);\n\n        wlPosition = new Label(shell, SWT.NONE);\n        wlPosition.setText(Messages.getString(\"JobEval.LineNr.Label\", \"0\"));\n        props.setLook(wlPosition);\n        fdlPosition = new FormData();\n        fdlPosition.left = new FormAttachment(0, 0);\n        fdlPosition.bottom = new FormAttachment(wOK, -margin);\n        wlPosition.setLayoutData(fdlPosition);\n\n        // Script line\n        wlScript = new Label(shell, SWT.NONE);\n        wlScript.setText(Messages.getString(\"JobEval.Script.Label\"));\n        props.setLook(wlScript);\n        fdlScript = new FormData();\n        fdlScript.left = new FormAttachment(0, 0);\n        fdlScript.top = new FormAttachment(wName, margin);\n        wlScript.setLayoutData(fdlScript);\n        wScript = new Text(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);\n        wScript.setText(Messages.getString(\"JobEval.Script.Default\"));\n        props.setLook(wScript, Props.WIDGET_STYLE_FIXED);\n        wScript.addModifyListener(lsMod);\n        fdScript = new FormData();\n        fdScript.left = new FormAttachment(0, 0);\n        fdScript.top = new FormAttachment(wlScript, margin);\n        fdScript.right = new FormAttachment(100, -5);\n        fdScript.bottom = new FormAttachment(wlPosition, -margin);\n        wScript.setLayoutData(fdScript);\n\n        // Add listeners\n        lsCancel = new Listener()\n        {\n            public void handleEvent(Event e)\n            {\n                cancel();\n            }\n        };\n        lsOK = new Listener()\n        {\n            public void handleEvent(Event e)\n            {\n                ok();\n            }\n        };\n\n        wCancel.addListener(SWT.Selection, lsCancel);\n        wOK.addListener(SWT.Selection, lsOK);\n\n        lsDef = new SelectionAdapter()\n        {\n            public void widgetDefaultSelected(SelectionEvent e)\n            {\n                ok();\n            }\n        };\n\n        wName.addSelectionListener(lsDef);\n\n        // Detect X or ALT-F4 or something that kills this window...\n        shell.addShellListener(new ShellAdapter()\n        {\n            public void shellClosed(ShellEvent e)\n            {\n                cancel();\n            }\n        });\n\n        wScript.addKeyListener(new KeyAdapter()\n        {\n            public void keyReleased(KeyEvent e)\n            {\n                int linenr = wScript.getCaretLineNumber() + 1;\n                wlPosition.setText(Messages.getString(\"JobEval.LineNr.Label\", Integer\n                    .toString(linenr)));\n            }\n        });\n\n        getData();\n\n        BaseStepDialog.setSize(shell, 250, 250, false);\n\n        shell.open();\n        props.setDialogSize(shell, \"JobEvalDialogSize\");\n        while (!shell.isDisposed())\n        {\n            if (!display.readAndDispatch())\n                display.sleep();\n        }\n        return jobEntry;\n    }","id":72192,"modified_method":"public JobEntryInterface open()\n    {\n        Shell parent = getParent();\n        Display display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n        ModifyListener lsMod = new ModifyListener()\n        {\n            public void modifyText(ModifyEvent e)\n            {\n                jobEntry.setChanged();\n            }\n        };\n        changed = jobEntry.hasChanged();\n\n        FormLayout formLayout = new FormLayout();\n        formLayout.marginWidth = Const.FORM_MARGIN;\n        formLayout.marginHeight = Const.FORM_MARGIN;\n\n        shell.setLayout(formLayout);\n        shell.setText(Messages.getString(\"JobEval.Title\"));\n\n        int middle = props.getMiddlePct();\n        int margin = Const.MARGIN;\n\n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n        // at the bottom\n        BaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, null);\n\n        // Filename line\n        wlName = new Label(shell, SWT.NONE);\n        wlName.setText(Messages.getString(\"JobEval.Jobname.Label\"));\n        props.setLook(wlName);\n        fdlName = new FormData();\n        fdlName.left = new FormAttachment(0, 0);\n        fdlName.top = new FormAttachment(0, margin);\n        wlName.setLayoutData(fdlName);\n        wName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wName);\n        wName.addModifyListener(lsMod);\n        fdName = new FormData();\n        fdName.left = new FormAttachment(middle, 0);\n        fdName.top = new FormAttachment(0, margin);\n        fdName.right = new FormAttachment(100, 0);\n        wName.setLayoutData(fdName);\n\n        wlPosition = new Label(shell, SWT.NONE);\n        wlPosition.setText(Messages.getString(\"JobEval.LineNr.Label\", \"0\"));\n        props.setLook(wlPosition);\n        fdlPosition = new FormData();\n        fdlPosition.left = new FormAttachment(0, 0);\n        fdlPosition.bottom = new FormAttachment(wOK, -margin);\n        wlPosition.setLayoutData(fdlPosition);\n\n        // Script line\n        wlScript = new Label(shell, SWT.NONE);\n        wlScript.setText(Messages.getString(\"JobEval.Script.Label\"));\n        props.setLook(wlScript);\n        fdlScript = new FormData();\n        fdlScript.left = new FormAttachment(0, 0);\n        fdlScript.top = new FormAttachment(wName, margin);\n        wlScript.setLayoutData(fdlScript);\n        wScript=new StyledTextComp(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\n        wScript.setText(Messages.getString(\"JobEval.Script.Default\"));\n        props.setLook(wScript, Props.WIDGET_STYLE_FIXED);\n        wScript.addModifyListener(lsMod);\n        fdScript = new FormData();\n        fdScript.left = new FormAttachment(0, 0);\n        fdScript.top = new FormAttachment(wlScript, margin);\n        fdScript.right = new FormAttachment(100, -5);\n        fdScript.bottom = new FormAttachment(wlPosition, -margin);\n        wScript.setLayoutData(fdScript);\n        wScript.addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent arg0)\r\n            {\r\n                setPosition();\r\n            }\r\n\t\r\n\t        }\r\n\t    );\r\n\t\t\r\n\t        wScript.addKeyListener(new KeyAdapter(){\r\n\t\t\tpublic void keyPressed(KeyEvent e) { setPosition(); }\r\n\t\t\tpublic void keyReleased(KeyEvent e) { setPosition(); }\r\n\t\t\t} \r\n\t\t);\r\n\t        wScript.addFocusListener(new FocusAdapter(){\r\n\t\t\tpublic void focusGained(FocusEvent e) { setPosition(); }\r\n\t\t\tpublic void focusLost(FocusEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t        wScript.addMouseListener(new MouseAdapter(){\r\n\t\t\tpublic void mouseDoubleClick(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseDown(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseUp(MouseEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n        wScript.addModifyListener(lsMod);\n        // Add listeners\n        lsCancel = new Listener()\n        {\n            public void handleEvent(Event e)\n            {\n                cancel();\n            }\n        };\n        lsOK = new Listener()\n        {\n            public void handleEvent(Event e)\n            {\n                ok();\n            }\n        };\n\n        wCancel.addListener(SWT.Selection, lsCancel);\n        wOK.addListener(SWT.Selection, lsOK);\n\n        lsDef = new SelectionAdapter()\n        {\n            public void widgetDefaultSelected(SelectionEvent e)\n            {\n                ok();\n            }\n        };\n\n        wName.addSelectionListener(lsDef);\n\n        // Detect X or ALT-F4 or something that kills this window...\n        shell.addShellListener(new ShellAdapter()\n        {\n            public void shellClosed(ShellEvent e)\n            {\n                cancel();\n            }\n        });\n\n\n\n        getData();\n\n        BaseStepDialog.setSize(shell, 250, 250, false);\n\n        shell.open();\n        props.setDialogSize(shell, \"JobEvalDialogSize\");\n        while (!shell.isDisposed())\n        {\n            if (!display.readAndDispatch())\n                display.sleep();\n        }\n        return jobEntry;\n    }","commit_id":"18128b27c04e9b727c76516920085b3741fc2b4c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open()\r\n    {\r\n        Shell parent = getParent();\r\n        Display display = parent.getDisplay();\r\n\r\n        shell = new Shell(parent, props.getJobsDialogStyle());\r\n        props.setLook(shell);\r\n        JobDialog.setShellImage(shell, jobEntry);\r\n\r\n        ModifyListener lsMod = new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                jobEntry.setChanged();\r\n            }\r\n        };\r\n        changed = jobEntry.hasChanged();\r\n\r\n        FormLayout formLayout = new FormLayout();\r\n        formLayout.marginWidth = Const.FORM_MARGIN;\r\n        formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n        shell.setLayout(formLayout);\r\n        shell.setText(Messages.getString(\"JobSQL.Title\"));\r\n\r\n        int middle = props.getMiddlePct();\r\n        int margin = Const.MARGIN;\r\n\r\n        wOK = new Button(shell, SWT.PUSH);\r\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\r\n        wCancel = new Button(shell, SWT.PUSH);\r\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\r\n\r\n        BaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, null);\r\n\r\n        // Filename line\r\n        wlName = new Label(shell, SWT.RIGHT);\r\n        wlName.setText(Messages.getString(\"JobSQL.Name.Label\"));\r\n        props.setLook(wlName);\r\n        fdlName = new FormData();\r\n        fdlName.left = new FormAttachment(0, 0);\r\n        fdlName.right = new FormAttachment(middle, 0);\r\n        fdlName.top = new FormAttachment(0, margin);\r\n        wlName.setLayoutData(fdlName);\r\n        wName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n        props.setLook(wName);\r\n        wName.addModifyListener(lsMod);\r\n        fdName = new FormData();\r\n        fdName.left = new FormAttachment(middle, 0);\r\n        fdName.top = new FormAttachment(0,  margin);\r\n        fdName.right = new FormAttachment(100, 0);\r\n        wName.setLayoutData(fdName);\r\n        \r\n\t\t// Connection line\r\n\t\twConnection = addConnectionLine(shell, wName, middle, margin);\r\n\t\tif (jobEntry.getDatabase()==null && jobMeta.nrDatabases()==1) wConnection.select(0);\r\n\t\twConnection.addModifyListener(lsMod);\r\n\t\t\r\n\r\n        // SQL from file?\r\n        wlSQLFromFile = new Label(shell, SWT.RIGHT);\r\n        wlSQLFromFile.setText(Messages.getString(\"JobSQL.SQLFromFile.Label\"));\r\n        props.setLook(wlSQLFromFile);\r\n        fdlSQLFromFile = new FormData();\r\n        fdlSQLFromFile.left = new FormAttachment(0, 0);\r\n        fdlSQLFromFile.top = new FormAttachment(wConnection,2*margin);\r\n        fdlSQLFromFile.right = new FormAttachment(middle, -margin);\r\n        wlSQLFromFile.setLayoutData(fdlSQLFromFile);\r\n        wSQLFromFile = new Button(shell, SWT.CHECK);\r\n        props.setLook(wSQLFromFile);\r\n        wSQLFromFile.setToolTipText(Messages.getString(\"JobSQL.SQLFromFile.Tooltip\"));\r\n        fdSQLFromFile = new FormData();\r\n        fdSQLFromFile.left = new FormAttachment(middle, 0);\r\n        fdSQLFromFile.top = new FormAttachment(wConnection, 2*margin);\r\n        fdSQLFromFile.right = new FormAttachment(100, 0);\r\n        wSQLFromFile.setLayoutData(fdSQLFromFile);\r\n        wSQLFromFile.addSelectionListener(new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n            \tactiveSQLFromFile();\t\r\n                jobEntry.setChanged();\r\n            }\r\n        });\r\n\r\n\r\n\t\t// Filename line\r\n\t\twlFilename = new Label(shell, SWT.RIGHT);\r\n\t\twlFilename.setText(Messages.getString(\"JobSQL.Filename.Label\"));\r\n\t\tprops.setLook(wlFilename);\r\n\t\tfdlFilename = new FormData();\r\n\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlFilename.top = new FormAttachment(wSQLFromFile,  margin);\r\n\t\tfdlFilename.right = new FormAttachment(middle, -margin);\r\n\t\twlFilename.setLayoutData(fdlFilename);\r\n\r\n\t\twbFilename = new Button(shell, SWT.PUSH | SWT.CENTER);\r\n\t\tprops.setLook(wbFilename);\r\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\r\n\t\tfdbFilename = new FormData();\r\n\t\tfdbFilename.right = new FormAttachment(100, 0);\r\n\t\tfdbFilename.top = new FormAttachment(wSQLFromFile, margin);\r\n\t\twbFilename.setLayoutData(fdbFilename);\r\n\r\n\t\twFilename = new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wFilename);\r\n\t\twFilename.setToolTipText(Messages.getString(\"JobSQL.Filename.Tooltip\"));\r\n\t\twFilename.addModifyListener(lsMod);\r\n\t\tfdFilename = new FormData();\r\n\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdFilename.top = new FormAttachment(wSQLFromFile,  margin);\r\n\t\tfdFilename.right = new FormAttachment(wbFilename, -margin);\r\n\t\twFilename.setLayoutData(fdFilename);\r\n\r\n\t\t// Whenever something changes, set the tooltip to the expanded version:\r\n\t\twFilename.addModifyListener(new ModifyListener()\r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e)\r\n\t\t\t{\r\n\t\t\t\twFilename.setToolTipText(jobMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\twbFilename.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\t\t\tdialog.setFilterExtensions(new String[] { \"*.sql\", \"*.txt\", \"*\" });\r\n\t\t\t\tif (wFilename.getText() != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t}\r\n\t\t\t\tdialog.setFilterNames(FILETYPES);\r\n\t\t\t\tif (dialog.open() != null)\r\n\t\t\t\t{\r\n\t\t\t\t\twFilename.setText(dialog.getFilterPath() + Const.FILE_SEPARATOR\r\n\t\t\t\t\t\t+ dialog.getFileName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t\r\n\t\t\r\n        // Use variable substitution?\r\n        wlUseSubs = new Label(shell, SWT.RIGHT);\r\n        wlUseSubs.setText(Messages.getString(\"JobSQL.UseVariableSubst.Label\"));\r\n        props.setLook(wlUseSubs);\r\n        fdlUseSubs = new FormData();\r\n        fdlUseSubs.left = new FormAttachment(0, 0);\r\n        fdlUseSubs.top = new FormAttachment(wFilename, margin);\r\n        fdlUseSubs.right = new FormAttachment(middle, -margin);\r\n        wlUseSubs.setLayoutData(fdlUseSubs);\r\n        wUseSubs = new Button(shell, SWT.CHECK);\r\n        props.setLook(wUseSubs);\r\n        wUseSubs.setToolTipText(Messages.getString(\"JobSQL.UseVariableSubst.Tooltip\"));\r\n        fdUseSubs = new FormData();\r\n        fdUseSubs.left = new FormAttachment(middle, 0);\r\n        fdUseSubs.top = new FormAttachment(wFilename, margin);\r\n        fdUseSubs.right = new FormAttachment(100, 0);\r\n        wUseSubs.setLayoutData(fdUseSubs);\r\n        wUseSubs.addSelectionListener(new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                jobEntry.setUseVariableSubstitution(!jobEntry.getUseVariableSubstitution());\r\n                jobEntry.setChanged();\r\n            }\r\n        });\r\n\r\n        wlPosition = new Label(shell, SWT.NONE);\r\n        wlPosition.setText(Messages.getString(\"JobSQL.LineNr.Label\", \"0\"));\r\n        props.setLook(wlPosition);\r\n        fdlPosition = new FormData();\r\n        fdlPosition.left = new FormAttachment(0, 0);\r\n        fdlPosition.bottom = new FormAttachment(wOK, -margin);\r\n        wlPosition.setLayoutData(fdlPosition);\r\n\r\n        // Script line\r\n        wlSQL = new Label(shell, SWT.NONE);\r\n        wlSQL.setText(Messages.getString(\"JobSQL.Script.Label\"));\r\n        props.setLook(wlSQL);\r\n        fdlSQL = new FormData();\r\n        fdlSQL.left = new FormAttachment(0, 0);\r\n        fdlSQL.top = new FormAttachment(wUseSubs, margin);\r\n        wlSQL.setLayoutData(fdlSQL);\r\n        //wSQL = new Text(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);\r\n        wSQL=new StyledTextComp(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n        props.setLook(wSQL, Props.WIDGET_STYLE_FIXED);\r\n        wSQL.addModifyListener(lsMod);\r\n        fdSQL = new FormData();\r\n        fdSQL.left = new FormAttachment(0, 0);\r\n        fdSQL.top = new FormAttachment(wlSQL, margin);\r\n        fdSQL.right = new FormAttachment(100, -5);\r\n        fdSQL.bottom = new FormAttachment(wlPosition, -margin);\r\n        wSQL.setLayoutData(fdSQL);\r\n\r\n        // Add listeners\r\n        lsCancel = new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                cancel();\r\n            }\r\n        };\r\n        lsOK = new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                ok();\r\n            }\r\n        };\r\n\r\n        wCancel.addListener(SWT.Selection, lsCancel);\r\n        wOK.addListener(SWT.Selection, lsOK);\r\n\r\n        lsDef = new SelectionAdapter()\r\n        {\r\n            public void widgetDefaultSelected(SelectionEvent e)\r\n            {\r\n                ok();\r\n            }\r\n        };\r\n\r\n        wName.addSelectionListener(lsDef);\r\n\r\n        // Detect X or ALT-F4 or something that kills this window...\r\n        shell.addShellListener(new ShellAdapter()\r\n        {\r\n            public void shellClosed(ShellEvent e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n\r\n        wSQL.addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent arg0)\r\n            {\r\n                setPosition();\r\n            }\r\n\r\n\t        }\r\n\t    );\r\n\t\t\r\n\t\twSQL.addKeyListener(new KeyAdapter(){\r\n\t\t\tpublic void keyPressed(KeyEvent e) { setPosition(); }\r\n\t\t\tpublic void keyReleased(KeyEvent e) { setPosition(); }\r\n\t\t\t} \r\n\t\t);\r\n\t\twSQL.addFocusListener(new FocusAdapter(){\r\n\t\t\tpublic void focusGained(FocusEvent e) { setPosition(); }\r\n\t\t\tpublic void focusLost(FocusEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\twSQL.addMouseListener(new MouseAdapter(){\r\n\t\t\tpublic void mouseDoubleClick(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseDown(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseUp(MouseEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\twSQL.addModifyListener(lsMod);\r\n\t\t\r\n\t\t\r\n\t\t// Text Higlighting\r\n\t\tlineStyler = new SQLValuesHighlight();\r\n\t\twSQL.addLineStyleListener(lineStyler);\r\n\t\t\r\n\r\n        getData();\r\n        activeSQLFromFile();\r\n\r\n        BaseStepDialog.setSize(shell);\r\n\r\n        shell.open();\r\n        props.setDialogSize(shell, \"JobSQLDialogSize\");\r\n        while (!shell.isDisposed())\r\n        {\r\n            if (!display.readAndDispatch())\r\n                display.sleep();\r\n        }\r\n        return jobEntry;\r\n    }","id":72193,"modified_method":"public JobEntryInterface open()\r\n    {\r\n        Shell parent = getParent();\r\n        Display display = parent.getDisplay();\r\n\r\n        shell = new Shell(parent, props.getJobsDialogStyle());\r\n        props.setLook(shell);\r\n        JobDialog.setShellImage(shell, jobEntry);\r\n\r\n        ModifyListener lsMod = new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                jobEntry.setChanged();\r\n            }\r\n        };\r\n        changed = jobEntry.hasChanged();\r\n\r\n        FormLayout formLayout = new FormLayout();\r\n        formLayout.marginWidth = Const.FORM_MARGIN;\r\n        formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n        shell.setLayout(formLayout);\r\n        shell.setText(Messages.getString(\"JobSQL.Title\"));\r\n\r\n        int middle = props.getMiddlePct();\r\n        int margin = Const.MARGIN;\r\n\r\n        wOK = new Button(shell, SWT.PUSH);\r\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\r\n        wCancel = new Button(shell, SWT.PUSH);\r\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\r\n\r\n        BaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, null);\r\n\r\n        // Filename line\r\n        wlName = new Label(shell, SWT.RIGHT);\r\n        wlName.setText(Messages.getString(\"JobSQL.Name.Label\"));\r\n        props.setLook(wlName);\r\n        fdlName = new FormData();\r\n        fdlName.left = new FormAttachment(0, 0);\r\n        fdlName.right = new FormAttachment(middle, 0);\r\n        fdlName.top = new FormAttachment(0, margin);\r\n        wlName.setLayoutData(fdlName);\r\n        wName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n        props.setLook(wName);\r\n        wName.addModifyListener(lsMod);\r\n        fdName = new FormData();\r\n        fdName.left = new FormAttachment(middle, 0);\r\n        fdName.top = new FormAttachment(0,  margin);\r\n        fdName.right = new FormAttachment(100, 0);\r\n        wName.setLayoutData(fdName);\r\n        \r\n\t\t// Connection line\r\n\t\twConnection = addConnectionLine(shell, wName, middle, margin);\r\n\t\tif (jobEntry.getDatabase()==null && jobMeta.nrDatabases()==1) wConnection.select(0);\r\n\t\twConnection.addModifyListener(lsMod);\r\n\t\t\r\n\r\n        // SQL from file?\r\n        wlSQLFromFile = new Label(shell, SWT.RIGHT);\r\n        wlSQLFromFile.setText(Messages.getString(\"JobSQL.SQLFromFile.Label\"));\r\n        props.setLook(wlSQLFromFile);\r\n        fdlSQLFromFile = new FormData();\r\n        fdlSQLFromFile.left = new FormAttachment(0, 0);\r\n        fdlSQLFromFile.top = new FormAttachment(wConnection,2*margin);\r\n        fdlSQLFromFile.right = new FormAttachment(middle, -margin);\r\n        wlSQLFromFile.setLayoutData(fdlSQLFromFile);\r\n        wSQLFromFile = new Button(shell, SWT.CHECK);\r\n        props.setLook(wSQLFromFile);\r\n        wSQLFromFile.setToolTipText(Messages.getString(\"JobSQL.SQLFromFile.Tooltip\"));\r\n        fdSQLFromFile = new FormData();\r\n        fdSQLFromFile.left = new FormAttachment(middle, 0);\r\n        fdSQLFromFile.top = new FormAttachment(wConnection, 2*margin);\r\n        fdSQLFromFile.right = new FormAttachment(100, 0);\r\n        wSQLFromFile.setLayoutData(fdSQLFromFile);\r\n        wSQLFromFile.addSelectionListener(new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n            \tactiveSQLFromFile();\t\r\n                jobEntry.setChanged();\r\n            }\r\n        });\r\n\r\n\r\n\t\t// Filename line\r\n\t\twlFilename = new Label(shell, SWT.RIGHT);\r\n\t\twlFilename.setText(Messages.getString(\"JobSQL.Filename.Label\"));\r\n\t\tprops.setLook(wlFilename);\r\n\t\tfdlFilename = new FormData();\r\n\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlFilename.top = new FormAttachment(wSQLFromFile,  margin);\r\n\t\tfdlFilename.right = new FormAttachment(middle, -margin);\r\n\t\twlFilename.setLayoutData(fdlFilename);\r\n\r\n\t\twbFilename = new Button(shell, SWT.PUSH | SWT.CENTER);\r\n\t\tprops.setLook(wbFilename);\r\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\r\n\t\tfdbFilename = new FormData();\r\n\t\tfdbFilename.right = new FormAttachment(100, 0);\r\n\t\tfdbFilename.top = new FormAttachment(wSQLFromFile, margin);\r\n\t\twbFilename.setLayoutData(fdbFilename);\r\n\r\n\t\twFilename = new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wFilename);\r\n\t\twFilename.setToolTipText(Messages.getString(\"JobSQL.Filename.Tooltip\"));\r\n\t\twFilename.addModifyListener(lsMod);\r\n\t\tfdFilename = new FormData();\r\n\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdFilename.top = new FormAttachment(wSQLFromFile,  margin);\r\n\t\tfdFilename.right = new FormAttachment(wbFilename, -margin);\r\n\t\twFilename.setLayoutData(fdFilename);\r\n\r\n\t\t// Whenever something changes, set the tooltip to the expanded version:\r\n\t\twFilename.addModifyListener(new ModifyListener()\r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e)\r\n\t\t\t{\r\n\t\t\t\twFilename.setToolTipText(jobMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\twbFilename.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\t\t\tdialog.setFilterExtensions(new String[] { \"*.sql\", \"*.txt\", \"*\" });\r\n\t\t\t\tif (wFilename.getText() != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t}\r\n\t\t\t\tdialog.setFilterNames(FILETYPES);\r\n\t\t\t\tif (dialog.open() != null)\r\n\t\t\t\t{\r\n\t\t\t\t\twFilename.setText(dialog.getFilterPath() + Const.FILE_SEPARATOR\r\n\t\t\t\t\t\t+ dialog.getFileName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t\r\n\t\t\r\n        // Use variable substitution?\r\n        wlUseSubs = new Label(shell, SWT.RIGHT);\r\n        wlUseSubs.setText(Messages.getString(\"JobSQL.UseVariableSubst.Label\"));\r\n        props.setLook(wlUseSubs);\r\n        fdlUseSubs = new FormData();\r\n        fdlUseSubs.left = new FormAttachment(0, 0);\r\n        fdlUseSubs.top = new FormAttachment(wFilename, margin);\r\n        fdlUseSubs.right = new FormAttachment(middle, -margin);\r\n        wlUseSubs.setLayoutData(fdlUseSubs);\r\n        wUseSubs = new Button(shell, SWT.CHECK);\r\n        props.setLook(wUseSubs);\r\n        wUseSubs.setToolTipText(Messages.getString(\"JobSQL.UseVariableSubst.Tooltip\"));\r\n        fdUseSubs = new FormData();\r\n        fdUseSubs.left = new FormAttachment(middle, 0);\r\n        fdUseSubs.top = new FormAttachment(wFilename, margin);\r\n        fdUseSubs.right = new FormAttachment(100, 0);\r\n        wUseSubs.setLayoutData(fdUseSubs);\r\n        wUseSubs.addSelectionListener(new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                jobEntry.setUseVariableSubstitution(!jobEntry.getUseVariableSubstitution());\r\n                jobEntry.setChanged();\r\n            }\r\n        });\r\n\r\n        wlPosition = new Label(shell, SWT.NONE);\r\n        wlPosition.setText(Messages.getString(\"JobSQL.LineNr.Label\", \"0\"));\r\n        props.setLook(wlPosition);\r\n        fdlPosition = new FormData();\r\n        fdlPosition.left = new FormAttachment(0, 0);\r\n        fdlPosition.right= new FormAttachment(100, 0);\r\n        fdlPosition.bottom = new FormAttachment(wOK, -margin);\r\n        wlPosition.setLayoutData(fdlPosition);\r\n\r\n        // Script line\r\n        wlSQL = new Label(shell, SWT.NONE);\r\n        wlSQL.setText(Messages.getString(\"JobSQL.Script.Label\"));\r\n        props.setLook(wlSQL);\r\n        fdlSQL = new FormData();\r\n        fdlSQL.left = new FormAttachment(0, 0);\r\n        fdlSQL.top = new FormAttachment(wUseSubs, margin);\r\n        wlSQL.setLayoutData(fdlSQL);\r\n\r\n        wSQL=new StyledTextComp(shell, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n        props.setLook(wSQL, Props.WIDGET_STYLE_FIXED);\r\n        wSQL.addModifyListener(lsMod);\r\n        fdSQL = new FormData();\r\n        fdSQL.left = new FormAttachment(0, 0);\r\n        fdSQL.top = new FormAttachment(wlSQL, margin);\r\n        fdSQL.right = new FormAttachment(100, -5);\r\n        fdSQL.bottom = new FormAttachment(wlPosition, -margin);\r\n        wSQL.setLayoutData(fdSQL);\r\n\r\n        // Add listeners\r\n        lsCancel = new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                cancel();\r\n            }\r\n        };\r\n        lsOK = new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                ok();\r\n            }\r\n        };\r\n\r\n        wCancel.addListener(SWT.Selection, lsCancel);\r\n        wOK.addListener(SWT.Selection, lsOK);\r\n\r\n        lsDef = new SelectionAdapter()\r\n        {\r\n            public void widgetDefaultSelected(SelectionEvent e)\r\n            {\r\n                ok();\r\n            }\r\n        };\r\n\r\n        wName.addSelectionListener(lsDef);\r\n\r\n        // Detect X or ALT-F4 or something that kills this window...\r\n        shell.addShellListener(new ShellAdapter()\r\n        {\r\n            public void shellClosed(ShellEvent e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n\r\n        wSQL.addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent arg0)\r\n            {\r\n                setPosition();\r\n            }\r\n\r\n\t        }\r\n\t    );\r\n\t\t\r\n\t\twSQL.addKeyListener(new KeyAdapter(){\r\n\t\t\tpublic void keyPressed(KeyEvent e) { setPosition(); }\r\n\t\t\tpublic void keyReleased(KeyEvent e) { setPosition(); }\r\n\t\t\t} \r\n\t\t);\r\n\t\twSQL.addFocusListener(new FocusAdapter(){\r\n\t\t\tpublic void focusGained(FocusEvent e) { setPosition(); }\r\n\t\t\tpublic void focusLost(FocusEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\twSQL.addMouseListener(new MouseAdapter(){\r\n\t\t\tpublic void mouseDoubleClick(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseDown(MouseEvent e) { setPosition(); }\r\n\t\t\tpublic void mouseUp(MouseEvent e) { setPosition(); }\r\n\t\t\t}\r\n\t\t);\r\n\t\twSQL.addModifyListener(lsMod);\r\n\t\t\r\n\t\t\r\n\t\t// Text Higlighting\r\n\t\tlineStyler = new SQLValuesHighlight();\r\n\t\twSQL.addLineStyleListener(lineStyler);\r\n\t\t\r\n\r\n        getData();\r\n        activeSQLFromFile();\r\n\r\n        BaseStepDialog.setSize(shell);\r\n\r\n        shell.open();\r\n        props.setDialogSize(shell, \"JobSQLDialogSize\");\r\n        while (!shell.isDisposed())\r\n        {\r\n            if (!display.readAndDispatch())\r\n                display.sleep();\r\n        }\r\n        return jobEntry;\r\n    }","commit_id":"18128b27c04e9b727c76516920085b3741fc2b4c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  protected ProcessHandler doGetProcessHandler() {\n    return myExecutionResult.getProcessHandler();\n  }","id":72194,"modified_method":"@Override\n  protected ProcessHandler doGetProcessHandler() {\n    return myExecutionResult == null ? super.doGetProcessHandler() : myExecutionResult.getProcessHandler();\n  }","commit_id":"233a52e0cf9a0a36c892c3734929756a2133996a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void registerAdditionalActions(@NotNull final DefaultActionGroup leftToolbar,\n                                        @NotNull final DefaultActionGroup topToolbar,\n                                        @NotNull final DefaultActionGroup settings) {\n    // For Run tool window this action is added in DartCommandLineRunningState.createActions()\n    topToolbar.addSeparator();\n\n    topToolbar.addAction(new OpenDartObservatoryUrlAction(myObservatoryPort, new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return myVmConnected && !getSession().isStopped();\n      }\n    }));\n  }","id":72195,"modified_method":"@Override\n  public void registerAdditionalActions(@NotNull final DefaultActionGroup leftToolbar,\n                                        @NotNull final DefaultActionGroup topToolbar,\n                                        @NotNull final DefaultActionGroup settings) {\n    // For Run tool window this action is added in DartCommandLineRunningState.createActions()\n    topToolbar.addSeparator();\n\n    if (myObservatoryPort > 0) {\n      topToolbar.addAction(new OpenDartObservatoryUrlAction(myObservatoryPort, new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          return myVmConnected && !getSession().isStopped();\n        }\n      }));\n    }\n  }","commit_id":"233a52e0cf9a0a36c892c3734929756a2133996a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public DartCommandLineDebugProcess(@NotNull final XDebugSession session,\n                                     @NotNull final DartCommandLineRunningState commandLineState,\n                                     @NotNull final ExecutionResult executionResult,\n                                     @NotNull final VirtualFile dartFile) {\n    super(session);\n    myExecutionResult = executionResult;\n    myDartUrlResolver = DartUrlResolver.getInstance(session.getProject(), dartFile);\n    myObservatoryPort = commandLineState.getObservatoryPort();\n\n    final DartCommandLineBreakpointHandler dartBreakpointHandler = new DartCommandLineBreakpointHandler(this);\n    myBreakpointHandlers = new XBreakpointHandler[]{dartBreakpointHandler};\n\n    // see com.google.dart.tools.debug.core.server.ServerDebugTarget\n    myVmConnection = new VmConnection(null, commandLineState.getDebuggingPort());\n    myVmConnection.addListener(new DartVmListener(this, dartBreakpointHandler));\n\n    session.addSessionListener(new XDebugSessionAdapter() {\n      @Override\n      public void sessionPaused() {\n        stackFrameChanged();\n      }\n\n      @Override\n      public void stackFrameChanged() {\n        final XStackFrame stackFrame = getSession().getCurrentStackFrame();\n        myLatestCurrentIsolate = stackFrame instanceof DartStackFrame ? ((DartStackFrame)stackFrame).getIsolate() : null;\n      }\n    });\n\n    connect();\n  }","id":72196,"modified_method":"public DartCommandLineDebugProcess(@NotNull final XDebugSession session,\n                                     final int debuggingPort,\n                                     final int observatoryPort,\n                                     @Nullable final ExecutionResult executionResult,\n                                     @NotNull final DartUrlResolver dartUrlResolver) {\n    super(session);\n    myExecutionResult = executionResult;\n    myDartUrlResolver = dartUrlResolver;\n    myObservatoryPort = observatoryPort;\n\n    final DartCommandLineBreakpointHandler dartBreakpointHandler = new DartCommandLineBreakpointHandler(this);\n    myBreakpointHandlers = new XBreakpointHandler[]{dartBreakpointHandler};\n\n    // see com.google.dart.tools.debug.core.server.ServerDebugTarget\n    myVmConnection = new VmConnection(null, debuggingPort);\n    myVmConnection.addListener(new DartVmListener(this, dartBreakpointHandler));\n\n    session.addSessionListener(new XDebugSessionAdapter() {\n      @Override\n      public void sessionPaused() {\n        stackFrameChanged();\n      }\n\n      @Override\n      public void stackFrameChanged() {\n        final XStackFrame stackFrame = getSession().getCurrentStackFrame();\n        myLatestCurrentIsolate = stackFrame instanceof DartStackFrame ? ((DartStackFrame)stackFrame).getIsolate() : null;\n      }\n    });\n\n    connect();\n  }","commit_id":"233a52e0cf9a0a36c892c3734929756a2133996a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public ExecutionConsole createConsole() {\n    return myExecutionResult.getExecutionConsole();\n  }","id":72197,"modified_method":"@NotNull\n  @Override\n  public ExecutionConsole createConsole() {\n    return myExecutionResult == null ? super.createConsole() : myExecutionResult.getExecutionConsole();\n  }","commit_id":"233a52e0cf9a0a36c892c3734929756a2133996a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private RunContentDescriptor doExecuteDartDebug(final @NotNull RunProfileState state,\n                                                  final @NotNull ExecutionEnvironment env) throws RuntimeConfigurationError,\n                                                                                                  ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    final RunProfile profile = env.getRunProfile();\n    if (profile instanceof DartRemoteDebugConfiguration) {\n      return null; // todo\n    }\n\n    if (profile instanceof DartRunConfigurationBase) {\n      final DartRunConfigurationBase configuration = (DartRunConfigurationBase)profile;\n      final VirtualFile mainDartFile = configuration.getRunnerParameters().getDartFile();\n\n      final ExecutionResult executionResult = state.execute(env.getExecutor(), this);\n      if (executionResult == null) return null;\n\n      final XDebuggerManager debuggerManager = XDebuggerManager.getInstance(env.getProject());\n      final XDebugSession debugSession = debuggerManager.startSession(env, new XDebugProcessStarter() {\n        @Override\n        @NotNull\n        public XDebugProcess start(@NotNull final XDebugSession session) {\n          return new DartCommandLineDebugProcess(session, (DartCommandLineRunningState)state, executionResult, mainDartFile);\n        }\n      });\n\n      return debugSession.getRunContentDescriptor();\n    }\n\n    LOG.error(\"Unexpected run configuration: \" + profile.getClass().getName());\n    return null;\n  }","id":72198,"modified_method":"private RunContentDescriptor doExecuteDartDebug(final @NotNull RunProfileState state,\n                                                  final @NotNull ExecutionEnvironment env) throws RuntimeConfigurationError,\n                                                                                                  ExecutionException {\n    final RunProfile runConfiguration = env.getRunProfile();\n    final VirtualFile contextFileOrDir;\n    final ExecutionResult executionResult;\n    final int debuggingPort;\n    final int observatoryPort;\n\n    if (runConfiguration instanceof DartRunConfigurationBase) {\n      contextFileOrDir = ((DartRunConfigurationBase)runConfiguration).getRunnerParameters().getDartFile();\n\n      executionResult = state.execute(env.getExecutor(), this);\n      if (executionResult == null) {\n        return null;\n      }\n\n      debuggingPort = ((DartCommandLineRunningState)state).getDebuggingPort();\n      observatoryPort = ((DartCommandLineRunningState)state).getObservatoryPort();\n    }\n    else if (runConfiguration instanceof DartRemoteDebugConfiguration) {\n      final String path = ((DartRemoteDebugConfiguration)runConfiguration).getParameters().getDartProjectPath();\n      contextFileOrDir = LocalFileSystem.getInstance().findFileByPath(path);\n      if (contextFileOrDir == null) {\n        throw new RuntimeConfigurationError(\"Folder not found: \" + FileUtil.toSystemDependentName(path));\n      }\n\n      executionResult = null;\n\n      debuggingPort = ((DartRemoteDebugConfiguration)runConfiguration).getParameters().getPort();\n      observatoryPort = -1;\n    }\n    else {\n      LOG.error(\"Unexpected run configuration: \" + runConfiguration.getClass().getName());\n      return null;\n    }\n\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    final XDebuggerManager debuggerManager = XDebuggerManager.getInstance(env.getProject());\n    final XDebugSession debugSession = debuggerManager.startSession(env, new XDebugProcessStarter() {\n      @Override\n      @NotNull\n      public XDebugProcess start(@NotNull final XDebugSession session) {\n        final DartUrlResolver dartUrlResolver = DartUrlResolver.getInstance(env.getProject(), contextFileOrDir);\n        return new DartCommandLineDebugProcess(session, debuggingPort, observatoryPort, executionResult, dartUrlResolver);\n      }\n    });\n\n    return debugSession.getRunContentDescriptor();\n  }","commit_id":"233a52e0cf9a0a36c892c3734929756a2133996a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public static VirtualFile findPubspecYamlFile(@NotNull final Project project, @NotNull final VirtualFile contextFile) {\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    VirtualFile current = contextFile;\n    VirtualFile parent;\n    while ((parent = current.getParent()) != null && (LIB_DIR_NAME.equals(current.getName()) || fileIndex.isInContent(parent))) {\n      current = parent;\n      final VirtualFile file = parent.findChild(PUBSPEC_YAML);\n      if (file != null && !file.isDirectory()) return file;\n    }\n\n    return null;\n  }","id":72199,"modified_method":"@Nullable\n  public static VirtualFile findPubspecYamlFile(@NotNull final Project project, @NotNull final VirtualFile contextFile) {\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    VirtualFile current = contextFile;\n    VirtualFile parent = contextFile.isDirectory() ? contextFile : contextFile.getParent();\n\n    while (parent != null && (LIB_DIR_NAME.equals(current.getName()) || fileIndex.isInContent(parent))) {\n      current = parent;\n      final VirtualFile file = parent.findChild(PUBSPEC_YAML);\n      if (file != null && !file.isDirectory()) {\n        return file;\n      }\n      parent = current.getParent();\n    }\n\n    return null;\n  }","commit_id":"233a52e0cf9a0a36c892c3734929756a2133996a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void restart(@NotNull RunContentDescriptor descriptor, @NotNull Content content) {\n    descriptor.setActivateToolWindowWhenAdded(false);\n    descriptor.setReuseToolWindowActivation(true);\n    ExecutionUtil.restart(content);\n  }","id":72200,"modified_method":"private static void restart(@NotNull RunContentDescriptor descriptor) {\n    descriptor.setActivateToolWindowWhenAdded(false);\n    descriptor.setReuseToolWindowActivation(true);\n    ExecutionUtil.restart(descriptor);\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAutoTestEnabled(RunContentDescriptor descriptor) {\n    return myEnabledDescriptors.contains(descriptor.getAttachedContent());\n  }","id":72201,"modified_method":"public boolean isAutoTestEnabled(@NotNull RunContentDescriptor descriptor) {\n    return isAutoTestEnabledForDescriptor(descriptor);\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void setDelay(int delay) {\n    myDelay = delay;\n    myDocumentWatcher.deactivate();\n    myDocumentWatcher = createWatcher();\n    if (!myEnabledDescriptors.isEmpty()) {\n      myDocumentWatcher.activate();\n    }\n    PropertiesComponent.getInstance(myProject).setValue(AUTO_TEST_MANAGER_DELAY, String.valueOf(myDelay));\n  }","id":72202,"modified_method":"void setDelay(int delay) {\n    myDelayMillis = delay;\n    myDocumentWatcher.deactivate();\n    myDocumentWatcher = createWatcher();\n    if (hasEnabledAutoTests()) {\n      myDocumentWatcher.activate();\n    }\n    PropertiesComponent.getInstance(myProject).setValue(AUTO_TEST_MANAGER_DELAY, String.valueOf(myDelayMillis));\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void clearRestarterListener(@Nullable ProcessHandler processHandler) {\n    if (processHandler != null) {\n      ProcessListener restarterListener = ON_TERMINATION_RESTARTER_KEY.get(processHandler, null);\n      if (restarterListener != null) {\n        processHandler.removeProcessListener(restarterListener);\n        ON_TERMINATION_RESTARTER_KEY.set(processHandler, null);\n      }\n    }\n  }","id":72203,"modified_method":"private static void clearRestarterListener(@NotNull ProcessHandler processHandler) {\n    ProcessListener restarterListener = ON_TERMINATION_RESTARTER_KEY.get(processHandler, null);\n    if (restarterListener != null) {\n      processHandler.removeProcessListener(restarterListener);\n      ON_TERMINATION_RESTARTER_KEY.set(processHandler, null);\n    }\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void runAutoTest(@NotNull Content content, int modificationStamp, @NotNull DelayedDocumentWatcher documentWatcher) {\n    JComponent component = content.getComponent();\n    if (component != null) {\n      DataContext dataContext = DataManager.getInstance().getDataContext(component);\n      RunContentDescriptor descriptor = LangDataKeys.RUN_CONTENT_DESCRIPTOR.getData(dataContext);\n      if (descriptor != null) {\n        ProcessHandler processHandler = descriptor.getProcessHandler();\n        if (processHandler != null && !processHandler.isProcessTerminated()) {\n          scheduleRestartOnTermination(descriptor, content, processHandler, modificationStamp, documentWatcher);\n        }\n        else {\n          restart(descriptor, content);\n        }\n      }\n    }\n  }","id":72204,"modified_method":"private static void restartAutoTest(@NotNull RunContentDescriptor descriptor,\n                                      int modificationStamp,\n                                      @NotNull DelayedDocumentWatcher documentWatcher) {\n    ProcessHandler processHandler = descriptor.getProcessHandler();\n    if (processHandler != null && !processHandler.isProcessTerminated()) {\n      scheduleRestartOnTermination(descriptor, processHandler, modificationStamp, documentWatcher);\n    }\n    else {\n      restart(descriptor);\n    }\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void scheduleRestartOnTermination(@NotNull final RunContentDescriptor descriptor,\n                                                   @NotNull final Content content,\n                                                   @NotNull final ProcessHandler processHandler,\n                                                   final int modificationStamp,\n                                                   @NotNull final DelayedDocumentWatcher documentWatcher) {\n    ProcessListener restarterListener = ON_TERMINATION_RESTARTER_KEY.get(processHandler);\n    if (restarterListener != null) {\n      return;\n    }\n    restarterListener = new ProcessAdapter() {\n      @Override\n      public void processTerminated(ProcessEvent event) {\n        clearRestarterListener(processHandler);\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            if (documentWatcher.isUpToDate(modificationStamp)) {\n              restart(descriptor, content);\n            }\n          }\n        }, ModalityState.any());\n      }\n    };\n    ON_TERMINATION_RESTARTER_KEY.set(processHandler, restarterListener);\n    processHandler.addProcessListener(restarterListener);\n  }","id":72205,"modified_method":"private static void scheduleRestartOnTermination(@NotNull final RunContentDescriptor descriptor,\n                                                   @NotNull final ProcessHandler processHandler,\n                                                   final int modificationStamp,\n                                                   @NotNull final DelayedDocumentWatcher documentWatcher) {\n    ProcessListener restarterListener = ON_TERMINATION_RESTARTER_KEY.get(processHandler);\n    if (restarterListener != null) {\n      clearRestarterListener(processHandler);\n    }\n    restarterListener = new ProcessAdapter() {\n      @Override\n      public void processTerminated(ProcessEvent event) {\n        clearRestarterListener(processHandler);\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            if (isAutoTestEnabledForDescriptor(descriptor) && documentWatcher.isUpToDate(modificationStamp)) {\n              restart(descriptor);\n            }\n          }\n        }, ModalityState.any());\n      }\n    };\n    ON_TERMINATION_RESTARTER_KEY.set(processHandler, restarterListener);\n    processHandler.addProcessListener(restarterListener);\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setAutoTestEnabled(@NotNull RunContentDescriptor descriptor, boolean enabled) {\n    Content content = descriptor.getAttachedContent();\n    if (enabled) {\n      myEnabledDescriptors.add(content);\n      myDocumentWatcher.activate();\n    }\n    else {\n      clearRestarterListener(descriptor.getProcessHandler());\n      myEnabledDescriptors.remove(content);\n      if (myEnabledDescriptors.isEmpty()) {\n        myDocumentWatcher.deactivate();\n      }\n    }\n  }","id":72206,"modified_method":"public void setAutoTestEnabled(@NotNull RunContentDescriptor descriptor, @NotNull ExecutionEnvironment environment, boolean enabled) {\n    Content content = descriptor.getAttachedContent();\n    if (content != null) {\n      if (enabled) {\n        EXECUTION_ENVIRONMENT_KEY.set(content, environment);\n        myDocumentWatcher.activate();\n      }\n      else {\n        EXECUTION_ENVIRONMENT_KEY.set(content, null);\n        if (!hasEnabledAutoTests()) {\n          myDocumentWatcher.deactivate();\n        }\n        ProcessHandler processHandler = descriptor.getProcessHandler();\n        if (processHandler != null) {\n          clearRestarterListener(processHandler);\n        }\n      }\n    }\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private DelayedDocumentWatcher createWatcher() {\n    return new DelayedDocumentWatcher(myProject, myDelay, new Consumer<Integer>() {\n      @Override\n      public void consume(Integer modificationStamp) {\n        for (Content content : myEnabledDescriptors) {\n          runAutoTest(content, modificationStamp, myDocumentWatcher);\n        }\n      }\n    }, new Condition<VirtualFile>() {\n      @Override\n      public boolean value(VirtualFile file) {\n        // Vladimir.Krivosheev - I don't know, why AutoTestManager checks it, but old behavior is preserved\n        return FileEditorManager.getInstance(myProject).isFileOpen(file);\n      }\n    });\n  }","id":72207,"modified_method":"@NotNull\n  private DelayedDocumentWatcher createWatcher() {\n    return new DelayedDocumentWatcher(myProject, myDelayMillis, new Consumer<Integer>() {\n      @Override\n      public void consume(Integer modificationStamp) {\n        restartAllAutoTests(modificationStamp);\n      }\n    }, new Condition<VirtualFile>() {\n      @Override\n      public boolean value(VirtualFile file) {\n        // Vladimir.Krivosheev - I don't know, why AutoTestManager checks it, but old behavior is preserved\n        return FileEditorManager.getInstance(myProject).isFileOpen(file);\n      }\n    });\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"int getDelay() {\n    return myDelay;\n  }","id":72208,"modified_method":"int getDelay() {\n    return myDelayMillis;\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AutoTestManager(Project project) {\n    myProject = project;\n    myDelay = PropertiesComponent.getInstance(myProject).getOrInitInt(AUTO_TEST_MANAGER_DELAY, 3000);\n    myDocumentWatcher = createWatcher();\n  }","id":72209,"modified_method":"public AutoTestManager(@NotNull Project project) {\n    myProject = project;\n    myDelayMillis = PropertiesComponent.getInstance(project).getOrInitInt(AUTO_TEST_MANAGER_DELAY, 3000);\n    myDocumentWatcher = createWatcher();\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void deactivate() {\n    EditorFactory.getInstance().getEventMulticaster().removeDocumentListener(myListener);\n    if (myConnection != null) {\n      myConnection.disconnect();\n      myConnection = null;\n    }\n  }","id":72210,"modified_method":"public void deactivate() {\n    if (myConnection != null) {\n      EditorFactory.getInstance().getEventMulticaster().removeDocumentListener(myListener);\n      myConnection.disconnect();\n      myConnection = null;\n    }\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void activate() {\n    EditorFactory.getInstance().getEventMulticaster().addDocumentListener(myListener, myProject);\n    if (myConnection == null) {\n      myConnection = ApplicationManager.getApplication().getMessageBus().connect(myProject);\n      myConnection.subscribe(AppTopics.FILE_DOCUMENT_SYNC, new FileDocumentManagerAdapter() {\n        @Override\n        public void beforeAllDocumentsSaving() {\n          myDocumentSavingInProgress = true;\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              myDocumentSavingInProgress = false;\n            }\n          }, ModalityState.any());\n        }\n      });\n    }\n  }","id":72211,"modified_method":"public void activate() {\n    if (myConnection == null) {\n      EditorFactory.getInstance().getEventMulticaster().addDocumentListener(myListener, myProject);\n      myConnection = ApplicationManager.getApplication().getMessageBus().connect(myProject);\n      myConnection.subscribe(AppTopics.FILE_DOCUMENT_SYNC, new FileDocumentManagerAdapter() {\n        @Override\n        public void beforeAllDocumentsSaving() {\n          myDocumentSavingInProgress = true;\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              myDocumentSavingInProgress = false;\n            }\n          }, ModalityState.any());\n        }\n      });\n    }\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isSelected(AnActionEvent e) {\n    Project project = e.getProject();\n    RunContentDescriptor descriptor = e.getData(LangDataKeys.RUN_CONTENT_DESCRIPTOR);\n    return !(project == null || descriptor == null) && AutoTestManager.getInstance(project).isAutoTestEnabled(descriptor);\n  }","id":72212,"modified_method":"@Override\n  public boolean isSelected(AnActionEvent e) {\n    Project project = e.getProject();\n    RunContentDescriptor descriptor = e.getData(LangDataKeys.RUN_CONTENT_DESCRIPTOR);\n    return project != null && descriptor != null && AutoTestManager.getInstance(project).isAutoTestEnabled(descriptor);\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setSelected(AnActionEvent e, boolean state) {\n    Project project = e.getData(CommonDataKeys.PROJECT);\n    RunContentDescriptor descriptor = e.getData(LangDataKeys.RUN_CONTENT_DESCRIPTOR);\n    if (project != null && descriptor != null) {\n      AutoTestManager.getInstance(project).setAutoTestEnabled(descriptor, state);\n    }\n  }","id":72213,"modified_method":"@Override\n  public void setSelected(AnActionEvent e, boolean state) {\n    Project project = e.getData(CommonDataKeys.PROJECT);\n    RunContentDescriptor descriptor = e.getData(LangDataKeys.RUN_CONTENT_DESCRIPTOR);\n    ExecutionEnvironment environment = e.getData(LangDataKeys.EXECUTION_ENVIRONMENT);\n    if (project != null && descriptor != null && environment != null) {\n      AutoTestManager.getInstance(project).setAutoTestEnabled(descriptor, environment, state);\n    }\n  }","commit_id":"eff2915b26e6eab8aa109d4281fac9585efdd09e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized StandbyUrl[] getStanbyUrls() {\n        \n        StandbyUrl[] urls = m_config.getStandbyUrl();\n        return urls;\n    }","id":72214,"modified_method":"public synchronized StandbyUrl[] getStanbyUrls() {\n        \n        return m_config.getStandbyUrl();\n\n    }","commit_id":"0bde32b06bcb7e08865945a4802cca8addd5ac24","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //FIXME: Guglielmo, the group should be the foreign source of the node\n        // Antonio: I'm working on the configuration file and the group\n        // is written in the configuration file\n        // in principle you can provide rancid node to more then a group\n //       String group = node.getForeignSource();\n//        RancidNode r_node = new RancidNode(m_rancidAdapterConfig.getGroup(), node.getLabel());\n        String group = m_rancidAdapterConfig.getGroup();\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Guglielmo, the device type is going to have to be mapped by SysObjectId...\n        //that should probably be in the RancidNode class\n        // It is in the Configuration file for Rancid ADapter\n        r_node.setDeviceType(RancidNode.DEVICE_TYPE_CISCO_IOS);\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","id":72215,"modified_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //FIXME: Guglielmo, the group should be the foreign source of the node\n        // Antonio: I'm working on the configuration file and the group\n        // is written in the configuration file\n        // in principle you can provide rancid node to more then a group\n        String group = node.getForeignSource();\n//        RancidNode r_node = new RancidNode(m_rancidAdapterConfig.getGroup(), node.getLabel());\n//        String group = m_rancidAdapterConfig.getGroup();\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Guglielmo, the device type is going to have to be mapped by SysObjectId...\n        //that should probably be in the RancidNode class\n        // It is in the Configuration file for Rancid ADapter\n        r_node.setDeviceType(RancidNode.DEVICE_TYPE_CISCO_IOS);\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","commit_id":"0bde32b06bcb7e08865945a4802cca8addd5ac24","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized StandbyUrl[] getStanbyUrls() {\n        \n        StandbyUrl[] urls = m_config.getStandbyUrl();\n        return urls;\n    }","id":72216,"modified_method":"public synchronized StandbyUrl[] getStanbyUrls() {\n        \n        return m_config.getStandbyUrl();\n\n    }","commit_id":"8e3c1c08939815ea1bab5795e09a7b0316c711f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //FIXME: Guglielmo, the group should be the foreign source of the node\n        // Antonio: I'm working on the configuration file and the group\n        // is written in the configuration file\n        // in principle you can provide rancid node to more then a group\n //       String group = node.getForeignSource();\n//        RancidNode r_node = new RancidNode(m_rancidAdapterConfig.getGroup(), node.getLabel());\n        String group = m_rancidAdapterConfig.getGroup();\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Guglielmo, the device type is going to have to be mapped by SysObjectId...\n        //that should probably be in the RancidNode class\n        // It is in the Configuration file for Rancid ADapter\n        r_node.setDeviceType(RancidNode.DEVICE_TYPE_CISCO_IOS);\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","id":72217,"modified_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //FIXME: Guglielmo, the group should be the foreign source of the node\n        // Antonio: I'm working on the configuration file and the group\n        // is written in the configuration file\n        // in principle you can provide rancid node to more then a group\n        String group = node.getForeignSource();\n//        RancidNode r_node = new RancidNode(m_rancidAdapterConfig.getGroup(), node.getLabel());\n//        String group = m_rancidAdapterConfig.getGroup();\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Guglielmo, the device type is going to have to be mapped by SysObjectId...\n        //that should probably be in the RancidNode class\n        // It is in the Configuration file for Rancid ADapter\n        r_node.setDeviceType(RancidNode.DEVICE_TYPE_CISCO_IOS);\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","commit_id":"8e3c1c08939815ea1bab5795e09a7b0316c711f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized StandbyUrl[] getStanbyUrls() {\n        \n        StandbyUrl[] urls = m_config.getStandbyUrl();\n        return urls;\n    }","id":72218,"modified_method":"public synchronized StandbyUrl[] getStanbyUrls() {\n        \n        return m_config.getStandbyUrl();\n\n    }","commit_id":"af5c262dba60ad66005e91e250dbc93348a5a0cf","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //FIXME: Guglielmo, the group should be the foreign source of the node\n        // Antonio: I'm working on the configuration file and the group\n        // is written in the configuration file\n        // in principle you can provide rancid node to more then a group\n //       String group = node.getForeignSource();\n//        RancidNode r_node = new RancidNode(m_rancidAdapterConfig.getGroup(), node.getLabel());\n        String group = m_rancidAdapterConfig.getGroup();\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Guglielmo, the device type is going to have to be mapped by SysObjectId...\n        //that should probably be in the RancidNode class\n        // It is in the Configuration file for Rancid ADapter\n        r_node.setDeviceType(RancidNode.DEVICE_TYPE_CISCO_IOS);\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","id":72219,"modified_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //FIXME: Guglielmo, the group should be the foreign source of the node\n        // Antonio: I'm working on the configuration file and the group\n        // is written in the configuration file\n        // in principle you can provide rancid node to more then a group\n        String group = node.getForeignSource();\n//        RancidNode r_node = new RancidNode(m_rancidAdapterConfig.getGroup(), node.getLabel());\n//        String group = m_rancidAdapterConfig.getGroup();\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Guglielmo, the device type is going to have to be mapped by SysObjectId...\n        //that should probably be in the RancidNode class\n        // It is in the Configuration file for Rancid ADapter\n        r_node.setDeviceType(RancidNode.DEVICE_TYPE_CISCO_IOS);\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","commit_id":"af5c262dba60ad66005e91e250dbc93348a5a0cf","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void initPortletDefaultPermissions(Portlet portlet)\n\t\tthrows PortalException {\n\n\t\tlong companyId = portlet.getCompanyId();\n\t\tString rootPortletId = portlet.getRootPortletId();\n\n\t\tint count = resourcePermissionLocalService.getResourcePermissionsCount(\n\t\t\tcompanyId, rootPortletId, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\trootPortletId);\n\n\t\tif (count > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tRole guestRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.GUEST);\n\t\tList<String> guestActions =\n\t\t\tResourceActionsUtil.getPortletResourceGuestDefaultActions(\n\t\t\t\trootPortletId);\n\n\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\tcompanyId, rootPortletId, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\trootPortletId, guestRole.getRoleId(),\n\t\t\tguestActions.toArray(new String[0]));\n\n\t\tRole ownerRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.OWNER);\n\t\tList<String> ownerActionIds =\n\t\t\tResourceActionsUtil.getPortletResourceActions(rootPortletId);\n\n\t\tresourcePermissionLocalService.setOwnerResourcePermissions(\n\t\t\tcompanyId, rootPortletId, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\trootPortletId, ownerRole.getRoleId(), 0,\n\t\t\townerActionIds.toArray(new String[0]));\n\n\t\tRole siteMemberRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.SITE_MEMBER);\n\t\tList<String> groupActionIds =\n\t\t\tResourceActionsUtil.getPortletResourceGroupDefaultActions(\n\t\t\t\trootPortletId);\n\n\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\tcompanyId, rootPortletId, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\trootPortletId, siteMemberRole.getRoleId(),\n\t\t\tgroupActionIds.toArray(new String[0]));\n\t}","id":72220,"modified_method":"protected void initPortletDefaultPermissions(Portlet portlet)\n\t\tthrows PortalException {\n\n\t\tint count = resourcePermissionLocalService.getResourcePermissionsCount(\n\t\t\tportlet.getCompanyId(), portlet.getRootPortletId(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, portlet.getRootPortletId());\n\n\t\tif (count > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tRole guestRole = roleLocalService.getRole(\n\t\t\tportlet.getCompanyId(), RoleConstants.GUEST);\n\t\tList<String> guestActions =\n\t\t\tResourceActionsUtil.getPortletResourceGuestDefaultActions(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\tportlet.getCompanyId(), portlet.getRootPortletId(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, portlet.getRootPortletId(),\n\t\t\tguestRole.getRoleId(), guestActions.toArray(new String[0]));\n\n\t\tRole ownerRole = roleLocalService.getRole(\n\t\t\tportlet.getCompanyId(), RoleConstants.OWNER);\n\t\tList<String> ownerActionIds =\n\t\t\tResourceActionsUtil.getPortletResourceActions(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\tresourcePermissionLocalService.setOwnerResourcePermissions(\n\t\t\tportlet.getCompanyId(), portlet.getRootPortletId(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, portlet.getRootPortletId(),\n\t\t\townerRole.getRoleId(), 0, ownerActionIds.toArray(new String[0]));\n\n\t\tRole siteMemberRole = roleLocalService.getRole(\n\t\t\tportlet.getCompanyId(), RoleConstants.SITE_MEMBER);\n\t\tList<String> groupActionIds =\n\t\t\tResourceActionsUtil.getPortletResourceGroupDefaultActions(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\tportlet.getCompanyId(), portlet.getRootPortletId(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, portlet.getRootPortletId(),\n\t\t\tsiteMemberRole.getRoleId(), groupActionIds.toArray(new String[0]));\n\t}","commit_id":"d8ba3d4bde1a43b08ebbb75a5d37382b007c7a2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initPortletModelDefaultPermissions(Portlet portlet)\n\t\tthrows PortalException {\n\n\t\tlong companyId = portlet.getCompanyId();\n\t\tString rootPortletId = portlet.getRootPortletId();\n\n\t\tList<String> modelResources = new ArrayList<>();\n\t\tmodelResources.add(\n\t\t\tResourceActionsUtil.getPortletRootModelResource(rootPortletId));\n\t\tmodelResources.addAll(\n\t\t\tResourceActionsUtil.getPortletModelResources(rootPortletId));\n\n\t\tfor (String modelResource : modelResources) {\n\t\t\tif (Validator.isBlank(modelResource)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean resourcePermissionUnsupported =\n\t\t\t\tresourceBlockLocalService.isSupported(modelResource);\n\n\t\t\tif (resourcePermissionUnsupported) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint count =\n\t\t\t\tresourcePermissionLocalService.getResourcePermissionsCount(\n\t\t\t\t\tcompanyId, modelResource,\n\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, modelResource);\n\n\t\t\tif (count > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresourceLocalService.addResources(\n\t\t\t\tcompanyId, 0, 0, modelResource, modelResource, false, false,\n\t\t\t\ttrue);\n\t\t}\n\t}","id":72221,"modified_method":"protected void initPortletModelDefaultPermissions(Portlet portlet)\n\t\tthrows PortalException {\n\n\t\tList<String> modelResources = new ArrayList<>();\n\n\t\tmodelResources.add(\n\t\t\tResourceActionsUtil.getPortletRootModelResource(\n\t\t\t\tportlet.getRootPortletId()));\n\t\tmodelResources.addAll(\n\t\t\tResourceActionsUtil.getPortletModelResources(\n\t\t\t\tportlet.getRootPortletId()));\n\n\t\tfor (String modelResource : modelResources) {\n\t\t\tif (Validator.isBlank(modelResource)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (resourceBlockLocalService.isSupported(modelResource)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint count =\n\t\t\t\tresourcePermissionLocalService.getResourcePermissionsCount(\n\t\t\t\t\tportlet.getCompanyId(), modelResource,\n\t\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, modelResource);\n\n\t\t\tif (count > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresourceLocalService.addResources(\n\t\t\t\tportlet.getCompanyId(), 0, 0, modelResource, modelResource,\n\t\t\t\tfalse, false, true);\n\t\t}\n\t}","commit_id":"d8ba3d4bde1a43b08ebbb75a5d37382b007c7a2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initPortletAddToPagePermissions(Portlet portlet)\n\t\tthrows PortalException {\n\n\t\tlong companyId = portlet.getCompanyId();\n\t\tString name = portlet.getRootPortletId();\n\n\t\tif (portlet.isSystem()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] roleNames = portlet.getRolesArray();\n\n\t\tif (roleNames.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tint scope = ResourceConstants.SCOPE_COMPANY;\n\t\tString primKey = String.valueOf(companyId);\n\t\tString actionId = ActionKeys.ADD_TO_PAGE;\n\n\t\tList<String> actionIds = ResourceActionsUtil.getPortletResourceActions(\n\t\t\tname);\n\n\t\tif (actionIds.contains(actionId)) {\n\t\t\tfor (String roleName : roleNames) {\n\t\t\t\tRole role = roleLocalService.getRole(companyId, roleName);\n\n\t\t\t\tresourcePermissionLocalService.addResourcePermission(\n\t\t\t\t\tcompanyId, name, scope, primKey, role.getRoleId(),\n\t\t\t\t\tactionId);\n\t\t\t}\n\t\t}\n\n\t\tupdatePortlet(\n\t\t\tcompanyId, portlet.getPortletId(), StringPool.BLANK,\n\t\t\tportlet.isActive());\n\t}","id":72222,"modified_method":"protected void initPortletAddToPagePermissions(Portlet portlet)\n\t\tthrows PortalException {\n\n\t\tif (portlet.isSystem()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] roleNames = portlet.getRolesArray();\n\n\t\tif (roleNames.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<String> actionIds = ResourceActionsUtil.getPortletResourceActions(\n\t\t\tportlet.getRootPortletId());\n\n\t\tString actionId = ActionKeys.ADD_TO_PAGE;\n\n\t\tif (actionIds.contains(actionId)) {\n\t\t\tfor (String roleName : roleNames) {\n\t\t\t\tRole role = roleLocalService.getRole(\n\t\t\t\t\tportlet.getCompanyId(), roleName);\n\n\t\t\t\tresourcePermissionLocalService.addResourcePermission(\n\t\t\t\t\tportlet.getCompanyId(), portlet.getRootPortletId(),\n\t\t\t\t\tResourceConstants.SCOPE_COMPANY,\n\t\t\t\t\tString.valueOf(portlet.getCompanyId()), role.getRoleId(),\n\t\t\t\t\tactionId);\n\t\t\t}\n\t\t}\n\n\t\tupdatePortlet(\n\t\t\tportlet.getCompanyId(), portlet.getPortletId(), StringPool.BLANK,\n\t\t\tportlet.isActive());\n\t}","commit_id":"f9894f0aff48d2591d9e42f1223b9e1d6556a12f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initPortletDefaultPermissions(Portlet portlet)\n\t\tthrows PortalException {\n\n\t\tlong companyId = portlet.getCompanyId();\n\t\tString portletName = portlet.getRootPortletId();\n\n\t\tif (resourcePermissionLocalService.getResourcePermissionsCount(\n\t\t\t\tcompanyId, portletName, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tportletName) > 0) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tList<String> groupActions =\n\t\t\tResourceActionsUtil.getPortletResourceGroupDefaultActions(\n\t\t\t\tportletName);\n\n\t\tRole siteMemberRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.SITE_MEMBER);\n\n\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\tcompanyId, portletName, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\tportletName, siteMemberRole.getRoleId(),\n\t\t\tgroupActions.toArray(new String[0]));\n\n\t\tRole guestRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.GUEST);\n\n\t\tList<String> guestActions =\n\t\t\tResourceActionsUtil.getPortletResourceGuestDefaultActions(\n\t\t\t\tportletName);\n\n\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\tcompanyId, portletName, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\tportletName, guestRole.getRoleId(),\n\t\t\tguestActions.toArray(new String[0]));\n\n\t\tRole ownerRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.OWNER);\n\n\t\tList<String> ownerActions =\n\t\t\tResourceActionsUtil.getPortletResourceActions(portletName);\n\n\t\tresourcePermissionLocalService.setOwnerResourcePermissions(\n\t\t\tcompanyId, portletName, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\tportletName, ownerRole.getRoleId(), 0,\n\t\t\townerActions.toArray(new String[0]));\n\t}","id":72223,"modified_method":"protected void initPortletDefaultPermissions(Portlet portlet)\n\t\tthrows PortalException {\n\n\t\tlong companyId = portlet.getCompanyId();\n\t\tString rootPortletId = portlet.getRootPortletId();\n\t\t\n\t\tint count = resourcePermissionLocalService.getResourcePermissionsCount(\n\t\t\tcompanyId, rootPortletId, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\trootPortletId);\n\n\t\tif (count > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tRole siteMemberRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.SITE_MEMBER);\n\t\tList<String> groupActionIds =\n\t\t\tResourceActionsUtil.getPortletResourceGroupDefaultActions(\n\t\t\t\trootPortletId);\n\n\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\tcompanyId, rootPortletId, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\trootPortletId, siteMemberRole.getRoleId(),\n\t\t\tgroupActionIds.toArray(new String[0]));\n\n\t\tRole guestRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.GUEST);\n\t\tList<String> guestActions =\n\t\t\tResourceActionsUtil.getPortletResourceGuestDefaultActions(\n\t\t\t\trootPortletId);\n\n\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\tcompanyId, rootPortletId, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\trootPortletId, guestRole.getRoleId(),\n\t\t\tguestActions.toArray(new String[0]));\n\n\t\tRole ownerRole = roleLocalService.getRole(\n\t\t\tcompanyId, RoleConstants.OWNER);\n\t\tList<String> ownerActionIds =\n\t\t\tResourceActionsUtil.getPortletResourceActions(rootPortletId);\n\n\t\tresourcePermissionLocalService.setOwnerResourcePermissions(\n\t\t\tcompanyId, rootPortletId, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\trootPortletId, ownerRole.getRoleId(), 0,\n\t\t\townerActionIds.toArray(new String[0]));\n\t}","commit_id":"f9894f0aff48d2591d9e42f1223b9e1d6556a12f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@SuppressWarnings({\"MethodMayBeStatic\"})\n  protected void checkChildren(final DomElement element, Consumer<DomElement> visitor) {\n    final XmlElement xmlElement = element.getXmlElement();\n    if (xmlElement instanceof XmlTag) {\n      for (final DomElement child : DomUtil.getDefinedChildren(element, true, true)) {\n        if (child.getXmlElement().isPhysical()) {\n          visitor.consume(child);\n        }\n      }\n\n      for (final AbstractDomChildrenDescription description : element.getGenericInfo().getChildrenDescriptions()) {\n        if (description.getAnnotation(Required.class) != null) {\n          for (final DomElement child : description.getValues(element)) {\n            if (child.getXmlElement() == null) {\n              visitor.consume(child);\n            }\n          }\n        }\n      }\n    }\n  }","id":72224,"modified_method":"@SuppressWarnings({\"MethodMayBeStatic\"})\n  protected void checkChildren(final DomElement element, Consumer<DomElement> visitor) {\n    final XmlElement xmlElement = element.getXmlElement();\n    if (xmlElement instanceof XmlTag) {\n      for (final DomElement child : DomUtil.getDefinedChildren(element, true, true)) {\n        final XmlElement element1 = child.getXmlElement();\n        if (element1 == null) {\n          LOG.assertTrue(false, \"child=\" + child + \"; parent=\" + element);\n        }\n        if (element1.isPhysical()) {\n          visitor.consume(child);\n        }\n      }\n\n      for (final AbstractDomChildrenDescription description : element.getGenericInfo().getChildrenDescriptions()) {\n        if (description.getAnnotation(Required.class) != null) {\n          for (final DomElement child : description.getValues(element)) {\n            if (child.getXmlElement() == null) {\n              visitor.consume(child);\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"85d50ecab936f076793126e9b8f2e5609ae4019a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String calcPropertyValue() {\n    final PsiFileSystemItem item = getFile().getValue();\n    if (item != null) {\n      final String name = item.getName();\n      final String suffix = getSuffix().getStringValue();\n      return suffix != null && name.endsWith(suffix)? name.substring(0, name.length() - suffix.length()) : name;\n    }\n    return super.calcPropertyValue();\n  }","id":72225,"modified_method":"protected String calcPropertyValue(String propertyName) {\n    final PsiFileSystemItem item = getFile().getValue();\n    if (item != null) {\n      final String name = item.getName();\n      final String suffix = getSuffix().getStringValue();\n      return suffix != null && name.endsWith(suffix)? name.substring(0, name.length() - suffix.length()) : name;\n    }\n    return super.calcPropertyValue(propertyName);\n  }","commit_id":"7c4ec212207489cc3713cc6a0da299a81f1158b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected GenericAttributeValue<String> getPropertyNameAttribute() {\n    final GenericAttributeValue<String> verifyProperty = getVerifyProperty();\n    if (verifyProperty.getRawText() != null) {\n      return verifyProperty;\n    }\n    return getPropertyName();\n  }","id":72226,"modified_method":"protected List<GenericAttributeValue<String>> getPropertyDefiningAttributes() {\n    final GenericAttributeValue<String> verifyProperty = getVerifyProperty();\n    if (verifyProperty.getRawText() != null) {\n      return Collections.singletonList(verifyProperty);\n    }\n    return Collections.singletonList(getPropertyName());\n  }","commit_id":"7c4ec212207489cc3713cc6a0da299a81f1158b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected final String calcPropertyValue() {\n    final PsiFileSystemItem fsItem = getFile().getValue();\n    if (fsItem != null) {\n      final PsiFileSystemItem parent = fsItem.getParent();\n      if (parent != null) {\n        final VirtualFile vFile = parent.getVirtualFile();\n        if (vFile != null) {\n          return FileUtil.toSystemDependentName(vFile.getPath());\n        }\n      }\n    }\n    // according to the doc, defaulting to project's current dir\n    final String projectBasedirPath = getContextAntProject().getProjectBasedirPath();\n    if (projectBasedirPath == null) {\n      return null;\n    }\n    return FileUtil.toSystemDependentName(projectBasedirPath);\n  }","id":72227,"modified_method":"@Nullable\n  protected final String calcPropertyValue(String propertyName) {\n    final PsiFileSystemItem fsItem = getFile().getValue();\n    if (fsItem != null) {\n      final PsiFileSystemItem parent = fsItem.getParent();\n      if (parent != null) {\n        final VirtualFile vFile = parent.getVirtualFile();\n        if (vFile != null) {\n          return FileUtil.toSystemDependentName(vFile.getPath());\n        }\n      }\n    }\n    // according to the doc, defaulting to project's current dir\n    final String projectBasedirPath = getContextAntProject().getProjectBasedirPath();\n    if (projectBasedirPath == null) {\n      return null;\n    }\n    return FileUtil.toSystemDependentName(projectBasedirPath);\n  }","commit_id":"7c4ec212207489cc3713cc6a0da299a81f1158b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<GenericAttributeValue<String>> getPropertyDefiningAttributes() {\n    return Arrays.asList(getOutputPropertyName(), getResultPropertyName(), getErrorPropertyName());\n  }","id":72228,"modified_method":"protected List<GenericAttributeValue<String>> getPropertyDefiningAttributes() {\n    return Arrays.asList(getOutputPropertyName(), getResultPropertyName(), getErrorPropertyName());\n  }","commit_id":"7c4ec212207489cc3713cc6a0da299a81f1158b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String calcPropertyValue() {\n    String text = myCachedText;\n    if (text != null) {\n      return text; \n    }\n    final PsiFileSystemItem file = getSrcFile().getValue();\n    if (!(file instanceof PsiFile)) {\n      return \"\";\n    }\n    final VirtualFile vFile = ((PsiFile)file).getOriginalFile().getVirtualFile();\n    if (vFile == null) {\n      return \"\";\n    }\n    try {\n      text = VfsUtil.loadText(vFile);\n      myCachedText = text;\n    }\n    catch (IOException e) {\n      LOG.info(e);\n      text = \"\";\n    }\n    return text;\n  }","id":72229,"modified_method":"protected String calcPropertyValue(String propertyName) {\n    String text = myCachedText;\n    if (text != null) {\n      return text; \n    }\n    final PsiFileSystemItem file = getSrcFile().getValue();\n    if (!(file instanceof PsiFile)) {\n      return \"\";\n    }\n    final VirtualFile vFile = ((PsiFile)file).getOriginalFile().getVirtualFile();\n    if (vFile == null) {\n      return \"\";\n    }\n    try {\n      text = VfsUtil.loadText(vFile);\n      myCachedText = text;\n    }\n    catch (IOException e) {\n      LOG.info(e);\n      text = \"\";\n    }\n    return text;\n  }","commit_id":"7c4ec212207489cc3713cc6a0da299a81f1158b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiElement getNavigationElement(String propertyName) {\n    final DomTarget target = DomTarget.getTarget(this);\n    final PsiElement nameElementPsi = target != null ? PomService.convertToPsi(target) : null;\n    if (nameElementPsi != null) {\n      return nameElementPsi;\n    }\n    return getXmlElement();\n  }","id":72230,"modified_method":"@Nullable\n  public PsiElement getNavigationElement(String propertyName) {\n    final DomTarget target = DomTarget.getTarget(this);\n    final PsiElement nameElementPsi = target != null ? PomService.convertToPsi(target) : null;\n    if (nameElementPsi != null) {\n      return nameElementPsi;\n    }\n    final XmlElement xmlElement = getXmlElement();\n    return xmlElement != null? xmlElement.getNavigationElement() : null;\n  }","commit_id":"7c4ec212207489cc3713cc6a0da299a81f1158b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final String calcPropertyValue() {\n    final String value = getPropertyValue().getStringValue();\n    return value != null? value : DEFAULT_PROPERTY_VALUE;\n  }","id":72231,"modified_method":"protected final String calcPropertyValue(String propertyName) {\n    final String value = getPropertyValue().getStringValue();\n    return value != null? value : DEFAULT_PROPERTY_VALUE;\n  }","commit_id":"7c4ec212207489cc3713cc6a0da299a81f1158b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String calcPropertyValue() {\n    String resName = getClassName().getStringValue();\n    if (resName == null) {\n      resName = getResourceName().getStringValue();\n    }\n    else {\n      resName = resName.replace(\".\", \"/\") + \".class\";\n    }\n    if (resName != null) {\n      final ClassLoader loader = getClassLoader();\n      if (loader != null) {\n        final URL resource = loader.getResource(resName);\n        if (resource != null) {\n          return resource.toExternalForm();\n        }\n      }\n    }\n    return \"\";\n  }","id":72232,"modified_method":"protected String calcPropertyValue(String propertyName) {\n    String resName = getClassName().getStringValue();\n    if (resName == null) {\n      resName = getResourceName().getStringValue();\n    }\n    else {\n      resName = resName.replace(\".\", \"/\") + \".class\";\n    }\n    if (resName != null) {\n      final ClassLoader loader = getClassLoader();\n      if (loader != null) {\n        final URL resource = loader.getResource(resName);\n        if (resource != null) {\n          return resource.toExternalForm();\n        }\n      }\n    }\n    return \"\";\n  }","commit_id":"7c4ec212207489cc3713cc6a0da299a81f1158b0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Manifest getManifest( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoFailureException, MojoExecutionException, Exception\n    {\n        Analyzer analyzer = getAnalyzer( project, instructions, properties, classpath );\n        boolean hasErrors = reportErrors( \"Manifest \" + project.getArtifact(), analyzer );\n        if ( hasErrors )\n        {\n            String failok = analyzer.getProperty( \"-failok\" );\n            if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n            {\n                throw new MojoFailureException( \"Error(s) found in manifest configuration\" );\n            }\n        }\n\n        Manifest manifest = analyzer.getJar().getManifest();\n\n        // cleanup...\n        analyzer.close();\n\n        return manifest;\n    }","id":72233,"modified_method":"public Manifest getManifest( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoFailureException, MojoExecutionException, Exception\n    {\n        Analyzer analyzer = getAnalyzer( project, instructions, properties, classpath );\n        boolean hasErrors = reportErrors( \"Manifest \" + project.getArtifact(), analyzer );\n        if ( hasErrors )\n        {\n            String failok = analyzer.getProperty( \"-failok\" );\n            if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n            {\n                throw new MojoFailureException( \"Error(s) found in manifest configuration\" );\n            }\n        }\n\n        Jar jar = analyzer.getJar();\n\n        if ( unpackBundle )\n        {\n            File outputFile = getOutputDirectory();\n            for ( Entry<String, Resource> entry : jar.getResources().entrySet() )\n            {\n                File entryFile = new File( outputFile, entry.getKey() );\n                if ( !entryFile.exists() )\n                {\n                    entryFile.getParentFile().mkdirs();\n                    OutputStream os = new FileOutputStream( entryFile );\n                    entry.getValue().write( os );\n                    os.close();\n                }\n            }\n        }\n\n        Manifest manifest = jar.getManifest();\n\n        // cleanup...\n        analyzer.close();\n\n        return manifest;\n    }","commit_id":"8cefad50234ce9cf040be8151fc30868a9a8003c","url":"https://github.com/apache/felix"},{"original_method":"protected void execute( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws MojoExecutionException\n    {\n        Manifest manifest;\n        try\n        {\n            if ( supportedProjectTypes.contains( getProject().getArtifact().getType() ) )\n            {\n                Builder builder = buildOSGiBundle( project, instructions, properties, classpath );\n                manifest = builder.getJar().getManifest();\n                builder.close();\n            }\n            else\n            {\n                manifest = getManifest( project, instructions, properties, classpath );\n            }\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Cannot find \" + e.getMessage()\n                + \" (manifest goal must be run after compile phase)\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to generate Manifest\", e );\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in manifest configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n\n        File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n        try\n        {\n            writeManifest( manifest, outputFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to write Manifest to file \" + outputFile, e );\n        }\n    }","id":72234,"modified_method":"@Override\n    protected void execute( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws MojoExecutionException\n    {\n        Manifest manifest;\n        try\n        {\n            manifest = getManifest( project, instructions, properties, classpath );\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Cannot find \" + e.getMessage()\n                + \" (manifest goal must be run after compile phase)\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to generate Manifest\", e );\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in manifest configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n\n        File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n        try\n        {\n            writeManifest( manifest, outputFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to write Manifest to file \" + outputFile, e );\n        }\n    }","commit_id":"8cefad50234ce9cf040be8151fc30868a9a8003c","url":"https://github.com/apache/felix"},{"original_method":"protected Analyzer getAnalyzer( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoExecutionException, Exception\n    {\n        File file = project.getArtifact().getFile();\n        if ( file == null )\n        {\n            file = getOutputDirectory();\n        }\n\n        if ( !file.exists() )\n        {\n            throw new FileNotFoundException( file.getPath() );\n        }\n\n        Builder analyzer = getOSGiBuilder( project, instructions, properties, classpath );\n\n        analyzer.setJar( file );\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null\n            && analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null )\n        {\n            String export = analyzer.calculateExportsFromContents( analyzer.getJar() );\n            analyzer.setProperty( Analyzer.EXPORT_PACKAGE, export );\n        }\n\n        addMavenInstructions( project, analyzer );\n\n        analyzer.mergeManifest( analyzer.getJar().getManifest() );\n        analyzer.calcManifest();\n\n        mergeMavenManifest( project, analyzer );\n\n        return analyzer;\n    }","id":72235,"modified_method":"protected Analyzer getAnalyzer( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoExecutionException, Exception\n    {\n        if ( supportedProjectTypes.contains( project.getArtifact().getType() ) )\n        {\n            return buildOSGiBundle( project, instructions, properties, classpath );\n        }\n\n        File file = project.getArtifact().getFile();\n        if ( file == null )\n        {\n            file = getOutputDirectory();\n        }\n\n        if ( !file.exists() )\n        {\n            throw new FileNotFoundException( file.getPath() );\n        }\n\n        Builder analyzer = getOSGiBuilder( project, instructions, properties, classpath );\n\n        analyzer.setJar( file );\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null\n            && analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null )\n        {\n            String export = analyzer.calculateExportsFromContents( analyzer.getJar() );\n            analyzer.setProperty( Analyzer.EXPORT_PACKAGE, export );\n        }\n\n        addMavenInstructions( project, analyzer );\n\n        analyzer.mergeManifest( analyzer.getJar().getManifest() );\n        analyzer.calcManifest();\n\n        mergeMavenManifest( project, analyzer );\n\n        return analyzer;\n    }","commit_id":"8cefad50234ce9cf040be8151fc30868a9a8003c","url":"https://github.com/apache/felix"},{"original_method":"public Manifest getManifest( MavenProject project, DependencyNode dependencyGraph, Map<String, String> instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoFailureException, MojoExecutionException, Exception\n    {\n        Analyzer analyzer = getAnalyzer(project, dependencyGraph, instructions, properties, classpath);\n\n        Manifest manifest = analyzer.getJar().getManifest();\n\n        // cleanup...\n        analyzer.close();\n\n        return manifest;\n    }","id":72236,"modified_method":"public Manifest getManifest( MavenProject project, DependencyNode dependencyGraph, Map<String, String> instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoFailureException, MojoExecutionException, Exception\n    {\n        Analyzer analyzer = getAnalyzer(project, dependencyGraph, instructions, properties, classpath);\n\n        Jar jar = analyzer.getJar();\n        Manifest manifest = jar.getManifest();\n\n        if (exportScr)\n        {\n            scrLocation.mkdirs();\n\n            String bpHeader = analyzer.getProperty(Analyzer.SERVICE_COMPONENT);\n            Parameters map = Processor.parseHeader(bpHeader, null);\n            for (String root : map.keySet())\n            {\n                Map<String, Resource> dir = jar.getDirectories().get(root);\n                File location = new File(scrLocation, root);\n                if (dir == null || dir.isEmpty())\n                {\n                    Resource resource = jar.getResource(root);\n                    if (resource != null)\n                    {\n                        writeSCR(resource, location);\n                    }\n                }\n                else\n                {\n                    for (Map.Entry<String, Resource> entry : dir.entrySet())\n                    {\n                        String path = entry.getKey();\n                        Resource resource = entry.getValue();\n                        writeSCR(resource, new File(location, path));\n                    }\n                }\n            }\n        }\n\n        // cleanup...\n        analyzer.close();\n\n        return manifest;\n    }","commit_id":"88239df3a69f16c39e587dbf5458fef5cd97a0aa","url":"https://github.com/apache/felix"},{"original_method":"private String genericsBounds(ClassNode theType, Set<String> visited) {\n        String ret = theType.isArray()?theType.getComponentType().getName()+\"[]\":theType.getName();\n        GenericsType[] genericsTypes = theType.getGenericsTypes();\n        if (genericsTypes == null || genericsTypes.length == 0) return ret;\n        // TODO instead of catching Object<T> here stop it from being placed into type in first place\n        if (genericsTypes.length == 1 && genericsTypes[0].isPlaceholder() && theType.getName().equals(\"java.lang.Object\")) {\n            return genericsTypes[0].getName();\n        }\n        ret += \"<\";\n        for (int i = 0; i < genericsTypes.length; i++) {\n            if (i != 0) ret += \", \";\n\n            GenericsType type = genericsTypes[i];\n            if (type.isPlaceholder() && visited.contains(type.getName())) {\n                ret += type.getName();\n            }\n            else {\n                ret += type.toString(visited);\n            }\n        }\n        ret += \">\";\n        return ret;\n    }","id":72237,"modified_method":"private String genericsBounds(ClassNode theType, Set<String> visited) {\n\n        StringBuilder ret = new StringBuilder();\n\n        if (theType.isArray()) {\n            ret.append(theType.getComponentType().getName());\n            ret.append(\"[]\");\n        } else if (theType.redirect() instanceof InnerClassNode) {\n            InnerClassNode innerClassNode = (InnerClassNode) theType.redirect();\n            String parentClassNodeName = innerClassNode.getOuterClass().getName();\n            ret.append(genericsBounds(innerClassNode.getOuterClass(), new HashSet<String>()));\n            ret.append(\".\");\n            String typeName = theType.getName();\n            ret.append(typeName.substring(parentClassNodeName.length() + 1));\n        } else {\n            ret.append(theType.getName());\n        }\n\n        GenericsType[] genericsTypes = theType.getGenericsTypes();\n        if (genericsTypes == null || genericsTypes.length == 0)\n            return ret.toString();\n\n        // TODO instead of catching Object<T> here stop it from being placed into type in first place\n        if (genericsTypes.length == 1 && genericsTypes[0].isPlaceholder() && theType.getName().equals(\"java.lang.Object\")) {\n            return genericsTypes[0].getName();\n        }\n\n        ret.append(\"<\");\n        for (int i = 0; i < genericsTypes.length; i++) {\n            if (i != 0) ret.append(\", \");\n\n            GenericsType type = genericsTypes[i];\n            if (type.isPlaceholder() && visited.contains(type.getName())) {\n                ret.append(type.getName());\n            }\n            else {\n                ret.append(type.toString(visited));\n            }\n        }\n        ret.append(\">\");\n\n        return ret.toString();\n    }","commit_id":"c1fd0ad2375526d4909eb387ec10ce7552f7be60","url":"https://github.com/apache/groovy"},{"original_method":"private Object readArray(Decoder decoder, Schema sourceSchema,\n                           Schema targetSchema, TypeToken<?> targetTypeToken) throws IOException {\n\n    if(!targetTypeToken.isArray() && Collection.class.isAssignableFrom(targetTypeToken.getRawType())) {\n      throw new IOException(\"Only array or collection type is support for array value.\");\n    }\n\n    int len = decoder.readInt();\n    Collection<Object> collection = (Collection<Object>) create(targetTypeToken);\n    while(len != 0) {\n      for(int i = 0; i < len; i++) {\n        collection.add(\n                        read(\n                              decoder, sourceSchema.getComponentSchema(),\n                              targetSchema.getComponentSchema(), targetTypeToken.getComponentType()\n                        )\n        );\n      }\n      len = decoder.readInt();\n    }\n\n    if(targetTypeToken.isArray()) {\n      Object array = Array.newInstance(targetTypeToken.getComponentType().getRawType(), collection.size());\n      int idx = 0;\n      for(Object obj : collection) {\n        Array.set(array, idx++, obj);\n      }\n      return array;\n    }\n    return collection;\n  }","id":72238,"modified_method":"private Object readArray(Decoder decoder, Schema sourceSchema,\n                           Schema targetSchema, TypeToken<?> targetTypeToken) throws IOException {\n\n    TypeToken<?> componentType = null;\n    if (targetTypeToken.isArray()) {\n      componentType = targetTypeToken.getComponentType();\n    } else if (Collection.class.isAssignableFrom(targetTypeToken.getRawType())) {\n      Type type = targetTypeToken.getType();\n      check(type instanceof ParameterizedType, \"Only parameterized type is supported for collection.\");\n      componentType = TypeToken.of(((ParameterizedType)type).getActualTypeArguments()[0]);\n    }\n    check(componentType != null, \"Only array or collection type is support for array value.\");\n\n    int len = decoder.readInt();\n    Collection<Object> collection = (Collection<Object>) create(targetTypeToken);\n    while(len != 0) {\n      for(int i = 0; i < len; i++) {\n        collection.add(read(decoder, sourceSchema.getComponentSchema(),\n                            targetSchema.getComponentSchema(), componentType)\n        );\n      }\n      len = decoder.readInt();\n    }\n\n    if(targetTypeToken.isArray()) {\n      Object array = Array.newInstance(targetTypeToken.getComponentType().getRawType(), collection.size());\n      int idx = 0;\n      for(Object obj : collection) {\n        Array.set(array, idx++, obj);\n      }\n      return array;\n    }\n    return collection;\n  }","commit_id":"1ead0efccb0cbbe12ff9e527f2728566298dd5ff","url":"https://github.com/caskdata/cdap"},{"original_method":"protected ConfigurableCompletionProposal doCreateProposal(String proposal, String displayString, Image image,\n\t\t\tint replacementOffset, int replacementLength, ContentAssistContext context) {\n\t\tConfigurableCompletionProposal result = new ConfigurableCompletionProposal(proposal, replacementOffset, replacementLength, proposal.length(), image, displayString, null, null);\n\t\tresult.setMatcher(context.getMatcher());\n\t\tint replaceContextLength = context.getCurrentNode().getLength() - (replacementOffset - context.getCurrentNode().getOffset());\n\t\tresult.setReplaceContextLength(replaceContextLength);\n\t\treturn result;\n\t}","id":72239,"modified_method":"protected ConfigurableCompletionProposal doCreateProposal(String proposal, String displayString, Image image,\n\t\t\tint priority, int replacementOffset, int replacementLength, ContentAssistContext context) {\n\t\tConfigurableCompletionProposal result = new ConfigurableCompletionProposal(proposal, replacementOffset, replacementLength, proposal.length(), image, displayString, null, null);\n\t\tresult.setPriority(priority);\n\t\tresult.setMatcher(context.getMatcher());\n\t\tint replaceContextLength = context.getCurrentNode().getLength() - (replacementOffset - context.getCurrentNode().getOffset());\n\t\tresult.setReplaceContextLength(replaceContextLength);\n\t\treturn result;\n\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tint replacementOffset, int replacementLength, String prefix, ContentAssistContext context) {\n\t\tif (isValidProposal(proposal, prefix, context))\n\t\t\treturn doCreateProposal(proposal, displayString, image, replacementOffset, replacementLength, context);\n\t\treturn null;\n\t}","id":72240,"modified_method":"protected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tint priority, int replacementOffset, int replacementLength, String prefix, ContentAssistContext context) {\n\t\tif (isValidProposal(proposal, prefix, context))\n\t\t\treturn doCreateProposal(proposal, displayString, image, priority, replacementOffset, replacementLength, context);\n\t\treturn null;\n\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @param abstractElement the {@link AbstractElement} which is used to create the proposals\n\t * @param displayString the string that is already entered by the user prior to requesting content assist\n\t * @param contentAssistContext the commonly used set of attributes related to the current content assist request\n\t * @param image the {@link Image} for the {@link ICompletionProposal}\n\t * @return a new <code>XtextCompletionProposal<\/code> for the given text and offset.\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tint priority, String prefix, ContentAssistContext context) {\n\t\tint replacementOffset = context.getReplaceRegion().getOffset();\n\t\tint replacementLength = context.getReplaceRegion().getLength();\n\t\treturn createCompletionProposal(proposal, displayString, image, replacementOffset, replacementLength, prefix, context);\n\t}","id":72241,"modified_method":"/**\n\t * @param abstractElement the {@link AbstractElement} which is used to create the proposals\n\t * @param displayString the string that is already entered by the user prior to requesting content assist\n\t * @param contentAssistContext the commonly used set of attributes related to the current content assist request\n\t * @param image the {@link Image} for the {@link ICompletionProposal}\n\t * @return a new <code>XtextCompletionProposal<\/code> for the given text and offset.\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tint priority, String prefix, ContentAssistContext context) {\n\t\tint replacementOffset = context.getReplaceRegion().getOffset();\n\t\tint replacementLength = context.getReplaceRegion().getLength();\n\t\treturn createCompletionProposal(proposal, displayString, image, priority, replacementOffset, replacementLength, prefix, context);\n\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, proposal, null, 100, contentAssistContext.getPrefix(), contentAssistContext);\n\t}","id":72242,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, proposal, null, getDefaultPriority(), contentAssistContext.getPrefix(), contentAssistContext);\n\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, displayString, image, 100, contentAssistContext.getPrefix(), contentAssistContext);\n\t}","id":72243,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, displayString, image, getDefaultPriority(), contentAssistContext.getPrefix(), contentAssistContext);\n\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tString prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, displayString, image, 100, prefix, contentAssistContext);\n\t}","id":72244,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tString prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, displayString, image, getDefaultPriority(), prefix, contentAssistContext);\n\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, Image image, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, proposal, image, 100, contentAssistContext.getPrefix(), contentAssistContext);\n\t}","id":72245,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, Image image, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, proposal, image, getDefaultPriority(), contentAssistContext.getPrefix(), contentAssistContext);\n\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeyword '\" + keyword.getValue()+ \"' for model '\" + contentAssistContext.getCurrentModel()\n\t\t\t\t+ \"' and prefix '\"+ contentAssistContext.getPrefix() + \"'\");\n\t\t}\n\t\tacceptor.accept(createCompletionProposal(keyword, keyword.getValue(), contentAssistContext));\n\t}","id":72246,"modified_method":"@Override\n\tpublic void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeyword '\" + keyword.getValue()+ \"' for model '\" + contentAssistContext.getCurrentModel()\n\t\t\t\t+ \"' and prefix '\"+ contentAssistContext.getPrefix() + \"'\");\n\t\t}\n\t\tICompletionProposal proposal = createCompletionProposal(keyword, keyword.getValue(), contentAssistContext);\n\t\tadjustPriority(proposal, contentAssistContext.getPrefix(), getKeywordPriority());\n\t\tacceptor.accept(proposal);\n\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"public ICompletionProposal apply(IScopedElement candidate) {\n\t\t\tif (ruleName != null) {\n\t\t\t\tString proposal = getValueConverter().toString(getDisplayString(candidate), ruleName);\n\t\t\t\treturn createCompletionProposal(candidate.element(), proposal, getDisplayString(candidate), contentAssistContext);\n\t\t\t}\n\t\t\treturn createCompletionProposal(candidate,\tcontentAssistContext);\n\t\t}","id":72247,"modified_method":"public ICompletionProposal apply(IScopedElement candidate) {\n\t\t\tICompletionProposal result = null;\n\t\t\tif (ruleName != null) {\n\t\t\t\tString proposal = getValueConverter().toString(getDisplayString(candidate), ruleName);\n\t\t\t\tresult = createCompletionProposal(candidate.element(), proposal, getDisplayString(candidate), contentAssistContext);\n\t\t\t} else {\n\t\t\t\tresult = createCompletionProposal(candidate, contentAssistContext);\n\t\t\t}\n\t\t\tadjustPriority(result, contentAssistContext.getPrefix(), getCrossReferencePriority());\t\t\t\n\t\t\treturn result;\n\t\t}","commit_id":"6fdcddd01fc05683ebb5a91022f8c867b887c078","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tString prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, displayString, image, 100, prefix, contentAssistContext);\n\t}","id":72248,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tString prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, displayString, image, getDefaultPriority(), prefix, contentAssistContext);\n\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tint replacementOffset, int replacementLength, String prefix, ContentAssistContext context) {\n\t\tif (isValidProposal(proposal, prefix, context))\n\t\t\treturn doCreateProposal(proposal, displayString, image, replacementOffset, replacementLength, context);\n\t\treturn null;\n\t}","id":72249,"modified_method":"protected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tint priority, int replacementOffset, int replacementLength, String prefix, ContentAssistContext context) {\n\t\tif (isValidProposal(proposal, prefix, context))\n\t\t\treturn doCreateProposal(proposal, displayString, image, priority, replacementOffset, replacementLength, context);\n\t\treturn null;\n\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @param abstractElement the {@link AbstractElement} which is used to create the proposals\n\t * @param displayString the string that is already entered by the user prior to requesting content assist\n\t * @param contentAssistContext the commonly used set of attributes related to the current content assist request\n\t * @param image the {@link Image} for the {@link ICompletionProposal}\n\t * @return a new <code>XtextCompletionProposal<\/code> for the given text and offset.\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tint priority, String prefix, ContentAssistContext context) {\n\t\tint replacementOffset = context.getReplaceRegion().getOffset();\n\t\tint replacementLength = context.getReplaceRegion().getLength();\n\t\treturn createCompletionProposal(proposal, displayString, image, replacementOffset, replacementLength, prefix, context);\n\t}","id":72250,"modified_method":"/**\n\t * @param abstractElement the {@link AbstractElement} which is used to create the proposals\n\t * @param displayString the string that is already entered by the user prior to requesting content assist\n\t * @param contentAssistContext the commonly used set of attributes related to the current content assist request\n\t * @param image the {@link Image} for the {@link ICompletionProposal}\n\t * @return a new <code>XtextCompletionProposal<\/code> for the given text and offset.\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tint priority, String prefix, ContentAssistContext context) {\n\t\tint replacementOffset = context.getReplaceRegion().getOffset();\n\t\tint replacementLength = context.getReplaceRegion().getLength();\n\t\treturn createCompletionProposal(proposal, displayString, image, priority, replacementOffset, replacementLength, prefix, context);\n\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ConfigurableCompletionProposal doCreateProposal(String proposal, String displayString, Image image,\n\t\t\tint replacementOffset, int replacementLength, ContentAssistContext context) {\n\t\tConfigurableCompletionProposal result = new ConfigurableCompletionProposal(proposal, replacementOffset, replacementLength, proposal.length(), image, displayString, null, null);\n\t\tresult.setMatcher(context.getMatcher());\n\t\tint replaceContextLength = context.getCurrentNode().getLength() - (replacementOffset - context.getCurrentNode().getOffset());\n\t\tresult.setReplaceContextLength(replaceContextLength);\n\t\treturn result;\n\t}","id":72251,"modified_method":"protected ConfigurableCompletionProposal doCreateProposal(String proposal, String displayString, Image image,\n\t\t\tint priority, int replacementOffset, int replacementLength, ContentAssistContext context) {\n\t\tConfigurableCompletionProposal result = new ConfigurableCompletionProposal(proposal, replacementOffset, replacementLength, proposal.length(), image, displayString, null, null);\n\t\tresult.setPriority(priority);\n\t\tresult.setMatcher(context.getMatcher());\n\t\tint replaceContextLength = context.getCurrentNode().getLength() - (replacementOffset - context.getCurrentNode().getOffset());\n\t\tresult.setReplaceContextLength(replaceContextLength);\n\t\treturn result;\n\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, Image image, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, proposal, image, 100, contentAssistContext.getPrefix(), contentAssistContext);\n\t}","id":72252,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, Image image, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, proposal, image, getDefaultPriority(), contentAssistContext.getPrefix(), contentAssistContext);\n\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, proposal, null, 100, contentAssistContext.getPrefix(), contentAssistContext);\n\t}","id":72253,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, proposal, null, getDefaultPriority(), contentAssistContext.getPrefix(), contentAssistContext);\n\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, displayString, image, 100, contentAssistContext.getPrefix(), contentAssistContext);\n\t}","id":72254,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(String proposal, String displayString, Image image,\n\t\t\tContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(proposal, displayString, image, getDefaultPriority(), contentAssistContext.getPrefix(), contentAssistContext);\n\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeyword '\" + keyword.getValue()+ \"' for model '\" + contentAssistContext.getCurrentModel()\n\t\t\t\t+ \"' and prefix '\"+ contentAssistContext.getPrefix() + \"'\");\n\t\t}\n\t\tacceptor.accept(createCompletionProposal(keyword, keyword.getValue(), contentAssistContext));\n\t}","id":72255,"modified_method":"@Override\n\tpublic void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeyword '\" + keyword.getValue()+ \"' for model '\" + contentAssistContext.getCurrentModel()\n\t\t\t\t+ \"' and prefix '\"+ contentAssistContext.getPrefix() + \"'\");\n\t\t}\n\t\tICompletionProposal proposal = createCompletionProposal(keyword, keyword.getValue(), contentAssistContext);\n\t\tadjustPriority(proposal, contentAssistContext.getPrefix(), getKeywordPriority());\n\t\tacceptor.accept(proposal);\n\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"public ICompletionProposal apply(IScopedElement candidate) {\n\t\t\tif (ruleName != null) {\n\t\t\t\tString proposal = getValueConverter().toString(getDisplayString(candidate), ruleName);\n\t\t\t\treturn createCompletionProposal(candidate.element(), proposal, getDisplayString(candidate), contentAssistContext);\n\t\t\t}\n\t\t\treturn createCompletionProposal(candidate,\tcontentAssistContext);\n\t\t}","id":72256,"modified_method":"public ICompletionProposal apply(IScopedElement candidate) {\n\t\t\tICompletionProposal result = null;\n\t\t\tif (ruleName != null) {\n\t\t\t\tString proposal = getValueConverter().toString(getDisplayString(candidate), ruleName);\n\t\t\t\tresult = createCompletionProposal(candidate.element(), proposal, getDisplayString(candidate), contentAssistContext);\n\t\t\t} else {\n\t\t\t\tresult = createCompletionProposal(candidate, contentAssistContext);\n\t\t\t}\n\t\t\tadjustPriority(result, contentAssistContext.getPrefix(), getCrossReferencePriority());\t\t\t\n\t\t\treturn result;\n\t\t}","commit_id":"23412c92ec8e256512b33513b680b6bba679aa50","url":"https://github.com/eclipse/xtext"},{"original_method":"protected KBArticle getKBArticle(long resourcePrimKey, int status)\n\t\tthrows Exception {\n\n\t\tKBArticle kbArticle = null;\n\n\t\ttry {\n\t\t\tkbArticle = KBArticleLocalServiceUtil.getLatestKBArticle(\n\t\t\t\tresourcePrimKey, status);\n\t\t}\n\t\tcatch (NoSuchArticleException nsae) {\n\t\t\treturn null;\n\t\t}\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\tif (!KBArticlePermission.contains(\n\t\t\t\tpermissionChecker, kbArticle, ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn kbArticle;\n\t}","id":72257,"modified_method":"protected KBArticle getKBArticle(long resourcePrimKey, int status)\n\t\tthrows Exception {\n\n\t\tKBArticle kbArticle = KBArticleLocalServiceUtil.fetchLatestKBArticle(\n\t\t\tresourcePrimKey, status);\n\n\t\tif (kbArticle == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\tif (!KBArticlePermission.contains(\n\t\t\t\tpermissionChecker, kbArticle, ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn kbArticle;\n\t}","commit_id":"09f49b6d31b4f366cfc509f55fcb15c8577acde1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected PortletURL getKBArticleURL(\n\t\t\tlong plid, boolean privateLayout, KBArticle kbArticle,\n\t\t\tHttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tPortletURL firstMatchPortletURL = null;\n\n\t\tList<Layout> layouts = getCandidateLayouts(\n\t\t\tplid, privateLayout, kbArticle);\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tList<Portlet> portlets = layoutTypePortlet.getAllPortlets();\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tString rootPortletId = PortletConstants.getRootPortletId(\n\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\tif (rootPortletId.equals(PortletKeys.KNOWLEDGE_BASE_DISPLAY)) {\n\t\t\t\t\tPortletPreferences preferences =\n\t\t\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\t\t\tlayout, portlet.getPortletId(), StringPool.BLANK);\n\n\t\t\t\t\tlong kbFolderClassNameId = PortalUtil.getClassNameId(\n\t\t\t\t\t\tKBFolderConstants.getClassName());\n\n\t\t\t\t\tlong resourceClassNameId = GetterUtil.getLong(\n\t\t\t\t\t\tpreferences.getValue(\"resourceClassNameId\", null),\n\t\t\t\t\t\tkbFolderClassNameId);\n\t\t\t\t\tlong resourcePrimKey = GetterUtil.getLong(\n\t\t\t\t\t\tpreferences.getValue(\"resourcePrimKey\", null),\n\t\t\t\t\t\tKBFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\t\t\t\tif (resourceClassNameId == kbFolderClassNameId) {\n\t\t\t\t\t\tif (isParentFolder(\n\t\t\t\t\t\t\t\tresourcePrimKey, kbArticle.getKbFolderId())) {\n\n\t\t\t\t\t\t\treturn getKBArticleURL(\n\t\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(),\n\t\t\t\t\t\t\t\tkbArticle, request);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (resourcePrimKey ==\n\t\t\t\t\t\t\t\tkbArticle.getResourcePrimKey()) {\n\n\t\t\t\t\t\treturn getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (firstMatchPortletURL == null) {\n\t\t\t\t\t\tfirstMatchPortletURL = getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rootPortletId.equals(PortletKeys.KNOWLEDGE_BASE_SECTION)) {\n\t\t\t\t\tPortletPreferences preferences =\n\t\t\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\t\t\tlayout, portlet.getPortletId(), StringPool.BLANK);\n\n\t\t\t\t\tString[] kbArticlesSections = preferences.getValues(\n\t\t\t\t\t\t\"kbArticlesSections\", new String[0]);\n\n\t\t\t\t\tKBArticle rootKBArticle = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\trootKBArticle =\n\t\t\t\t\t\t\tKBArticleLocalServiceUtil.getLatestKBArticle(\n\t\t\t\t\t\t\t\tkbArticle.getRootResourcePrimKey(),\n\t\t\t\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tString[] sections = AdminUtil.unescapeSections(\n\t\t\t\t\t\trootKBArticle.getSections());\n\n\t\t\t\t\tfor (String section : sections) {\n\t\t\t\t\t\tif (!ArrayUtil.contains(kbArticlesSections, section)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rootPortletId.equals(PortletKeys.KNOWLEDGE_BASE_ARTICLE)) {\n\t\t\t\t\tPortletPreferences preferences =\n\t\t\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\t\t\tlayout, portlet.getPortletId(), StringPool.BLANK);\n\n\t\t\t\t\tlong resourcePrimKey = GetterUtil.getLong(\n\t\t\t\t\t\tpreferences.getValue(\"resourcePrimKey\", null));\n\n\t\t\t\t\tKBArticle selKBArticle = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tselKBArticle =\n\t\t\t\t\t\t\tKBArticleLocalServiceUtil.getLatestKBArticle(\n\t\t\t\t\t\t\t\tresourcePrimKey,\n\t\t\t\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlong rootResourcePrimKey =\n\t\t\t\t\t\tkbArticle.getRootResourcePrimKey();\n\t\t\t\t\tlong selRootResourcePrimKey =\n\t\t\t\t\t\tselKBArticle.getRootResourcePrimKey();\n\n\t\t\t\t\tif (rootResourcePrimKey == selRootResourcePrimKey) {\n\t\t\t\t\t\treturn getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (firstMatchPortletURL == null) {\n\t\t\t\t\t\tfirstMatchPortletURL = getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn firstMatchPortletURL;\n\t}","id":72258,"modified_method":"protected PortletURL getKBArticleURL(\n\t\t\tlong plid, boolean privateLayout, KBArticle kbArticle,\n\t\t\tHttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tPortletURL firstMatchPortletURL = null;\n\n\t\tList<Layout> layouts = getCandidateLayouts(\n\t\t\tplid, privateLayout, kbArticle);\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tList<Portlet> portlets = layoutTypePortlet.getAllPortlets();\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tString rootPortletId = PortletConstants.getRootPortletId(\n\t\t\t\t\tportlet.getPortletId());\n\n\t\t\t\tif (rootPortletId.equals(PortletKeys.KNOWLEDGE_BASE_DISPLAY)) {\n\t\t\t\t\tPortletPreferences preferences =\n\t\t\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\t\t\tlayout, portlet.getPortletId(), StringPool.BLANK);\n\n\t\t\t\t\tlong kbFolderClassNameId = PortalUtil.getClassNameId(\n\t\t\t\t\t\tKBFolderConstants.getClassName());\n\n\t\t\t\t\tlong resourceClassNameId = GetterUtil.getLong(\n\t\t\t\t\t\tpreferences.getValue(\"resourceClassNameId\", null),\n\t\t\t\t\t\tkbFolderClassNameId);\n\t\t\t\t\tlong resourcePrimKey = GetterUtil.getLong(\n\t\t\t\t\t\tpreferences.getValue(\"resourcePrimKey\", null),\n\t\t\t\t\t\tKBFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\t\t\t\tif (resourceClassNameId == kbFolderClassNameId) {\n\t\t\t\t\t\tif (isParentFolder(\n\t\t\t\t\t\t\t\tresourcePrimKey, kbArticle.getKbFolderId())) {\n\n\t\t\t\t\t\t\treturn getKBArticleURL(\n\t\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(),\n\t\t\t\t\t\t\t\tkbArticle, request);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (resourcePrimKey ==\n\t\t\t\t\t\t\t\tkbArticle.getResourcePrimKey()) {\n\n\t\t\t\t\t\treturn getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (firstMatchPortletURL == null) {\n\t\t\t\t\t\tfirstMatchPortletURL = getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rootPortletId.equals(PortletKeys.KNOWLEDGE_BASE_SECTION)) {\n\t\t\t\t\tPortletPreferences preferences =\n\t\t\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\t\t\tlayout, portlet.getPortletId(), StringPool.BLANK);\n\n\t\t\t\t\tString[] kbArticlesSections = preferences.getValues(\n\t\t\t\t\t\t\"kbArticlesSections\", new String[0]);\n\n\t\t\t\t\tKBArticle rootKBArticle =\n\t\t\t\t\t\tKBArticleLocalServiceUtil.fetchLatestKBArticle(\n\t\t\t\t\t\t\tkbArticle.getRootResourcePrimKey(),\n\t\t\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\t\tif (rootKBArticle == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tString[] sections = AdminUtil.unescapeSections(\n\t\t\t\t\t\trootKBArticle.getSections());\n\n\t\t\t\t\tfor (String section : sections) {\n\t\t\t\t\t\tif (!ArrayUtil.contains(kbArticlesSections, section)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rootPortletId.equals(PortletKeys.KNOWLEDGE_BASE_ARTICLE)) {\n\t\t\t\t\tPortletPreferences preferences =\n\t\t\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\t\t\tlayout, portlet.getPortletId(), StringPool.BLANK);\n\n\t\t\t\t\tlong resourcePrimKey = GetterUtil.getLong(\n\t\t\t\t\t\tpreferences.getValue(\"resourcePrimKey\", null));\n\n\t\t\t\t\tKBArticle selKBArticle =\n\t\t\t\t\t\tKBArticleLocalServiceUtil.fetchLatestKBArticle(\n\t\t\t\t\t\t\tresourcePrimKey, WorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\t\tif (selKBArticle == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlong rootResourcePrimKey =\n\t\t\t\t\t\tkbArticle.getRootResourcePrimKey();\n\t\t\t\t\tlong selRootResourcePrimKey =\n\t\t\t\t\t\tselKBArticle.getRootResourcePrimKey();\n\n\t\t\t\t\tif (rootResourcePrimKey == selRootResourcePrimKey) {\n\t\t\t\t\t\treturn getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (firstMatchPortletURL == null) {\n\t\t\t\t\t\tfirstMatchPortletURL = getKBArticleURL(\n\t\t\t\t\t\t\tlayout.getPlid(), portlet.getPortletId(), kbArticle,\n\t\t\t\t\t\t\trequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn firstMatchPortletURL;\n\t}","commit_id":"09f49b6d31b4f366cfc509f55fcb15c8577acde1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n     * Sets the default bus for the thread.\n     * @param bus the default bus.\n     */\n    public static void setThreadDefaultBus(Bus bus) {\n        localBus.set(bus);\n    }","id":72259,"modified_method":"/**\n     * Sets the default bus for the thread.\n     * @param bus the default bus.\n     */\n    public static void setThreadDefaultBus(Bus bus) {\n        synchronized (threadBusses) {\n            threadBusses.put(Thread.currentThread(), bus);\n        }\n    }","commit_id":"d96c6e5dd613059eb1cfd41a2ea00b900a78aa33","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Sets the default bus if a default bus is not already set.\n     * @param bus the default bus.\n     * @return true if the bus was not set and is now set\n     */\n    public static synchronized boolean possiblySetDefaultBus(Bus bus) {\n        if (localBus.get() == null) {\n            localBus.set(bus);\n        }\n        \n        if (defaultBus == null) {\n            defaultBus = bus;            \n            return true;\n        }\n        return false;\n    }","id":72260,"modified_method":"/**\n     * Sets the default bus if a default bus is not already set.\n     * @param bus the default bus.\n     * @return true if the bus was not set and is now set\n     */\n    public static synchronized boolean possiblySetDefaultBus(Bus bus) {\n        synchronized (threadBusses) {\n            if (threadBusses.get(Thread.currentThread()) == null) {\n                threadBusses.put(Thread.currentThread(), bus);\n            }\n        }\n        \n        if (defaultBus == null) {\n            defaultBus = bus;            \n            return true;\n        }\n        return false;\n    }","commit_id":"d96c6e5dd613059eb1cfd41a2ea00b900a78aa33","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Gets the default bus for the thread, creating if needed\n     * @param createIfNeeded Set to true to create a default bus if one doesn't exist\n     * @return the default bus.\n     */\n    public static Bus getThreadDefaultBus(boolean createIfNeeded) {\n        if (createIfNeeded && localBus.get() == null) {\n            Bus b = getDefaultBus(createIfNeeded);\n            localBus.set(b);\n        }\n        return localBus.get();\n    }","id":72261,"modified_method":"/**\n     * Gets the default bus for the thread, creating if needed\n     * @param createIfNeeded Set to true to create a default bus if one doesn't exist\n     * @return the default bus.\n     */\n    public static Bus getThreadDefaultBus(boolean createIfNeeded) {\n        Bus threadBus;\n        synchronized (threadBusses) {\n            if (createIfNeeded) {\n                threadBus = threadBusses.get(Thread.currentThread());\n                if (createIfNeeded && threadBus == null) {\n                    threadBus = getDefaultBus(createIfNeeded);\n                    threadBusses.put(Thread.currentThread(), threadBus);\n                }\n            } else {\n                threadBus = threadBusses.get(Thread.currentThread());\n            }\n        }\n        return threadBus;\n    }","commit_id":"d96c6e5dd613059eb1cfd41a2ea00b900a78aa33","url":"https://github.com/apache/cxf"},{"original_method":"public void shutdown(boolean wait) {\n        BusLifeCycleManager lifeCycleManager = this.getExtension(BusLifeCycleManager.class);\n        if (null != lifeCycleManager) {\n            lifeCycleManager.preShutdown();\n        }\n        synchronized (this) {\n            state = BusState.SHUTDOWN;\n            notifyAll();\n        }\n        if (null != lifeCycleManager) {\n            lifeCycleManager.postShutdown();\n        }\n        if (BusFactory.getDefaultBus(false) == this) { \n            BusFactory.setDefaultBus(null);\n        }\n    }","id":72262,"modified_method":"public void shutdown(boolean wait) {\n        BusLifeCycleManager lifeCycleManager = this.getExtension(BusLifeCycleManager.class);\n        if (null != lifeCycleManager) {\n            lifeCycleManager.preShutdown();\n        }\n        synchronized (this) {\n            state = BusState.SHUTDOWN;\n            notifyAll();\n        }\n        if (null != lifeCycleManager) {\n            lifeCycleManager.postShutdown();\n        }\n\n        if (BusFactory.getDefaultBus(false) == this) {\n            BusFactory.setDefaultBus(null);\n        }\n        BusFactory.clearDefaultBusForAnyThread(this);\n    }","commit_id":"d96c6e5dd613059eb1cfd41a2ea00b900a78aa33","url":"https://github.com/apache/cxf"},{"original_method":"public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws Exception {\n\n        super(endpoint, processor);\n        this.endpoint = endpoint;\n        boolean isWebServiceProvider = false;\n\n        // now we just use the default bus here\n        Bus bus = BusFactory.getDefaultBus();\n        ServerFactoryBean svrBean = null;\n\n        if (endpoint.isSpringContextEndpoint()) {\n            CxfEndpointBean endpointBean = endpoint.getCxfEndpointBean();\n            svrBean = CxfEndpointUtils.getServerFactoryBean(endpointBean.getServiceClass());\n            isWebServiceProvider = CxfEndpointUtils.hasAnnotation(endpointBean.getServiceClass(),\n                                                                  WebServiceProvider.class);\n            endpoint.configure(svrBean);\n            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();\n            if (cxfEndpointBean.getServiceName() != null) {\n                svrBean.setServiceName(cxfEndpointBean.getServiceName());\n            }\n            if (cxfEndpointBean.getEndpointName() != null) {\n                svrBean.setEndpointName(cxfEndpointBean.getEndpointName());\n            }\n\n        } else { // setup the serverFactoryBean with the URI parameters\n            Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());\n            svrBean = CxfEndpointUtils.getServerFactoryBean(serviceClass);\n            isWebServiceProvider = CxfEndpointUtils.hasAnnotation(serviceClass, WebServiceProvider.class);\n            svrBean.setAddress(endpoint.getAddress());\n            svrBean.setServiceClass(serviceClass);\n            if (endpoint.getServiceName() != null) {\n                svrBean.setServiceName(CxfEndpointUtils.getServiceName(endpoint));\n            }\n            if (endpoint.getPortName() != null) {\n                svrBean.setEndpointName(CxfEndpointUtils.getPortName(endpoint));\n            }\n            if (endpoint.getWsdlURL() != null) {\n                svrBean.setWsdlURL(endpoint.getWsdlURL());\n            }\n        }\n        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);\n\n        svrBean.setInvoker(new CamelInvoker(this));\n\n        // apply feature here\n        if (!dataFormat.equals(DataFormat.POJO) && !isWebServiceProvider) {\n            List<AbstractFeature> features = new ArrayList<AbstractFeature>();\n\n            if (dataFormat.equals(DataFormat.PAYLOAD)) {\n                features.add(new PayLoadDataFormatFeature());\n                // adding the logging feature here for debug\n                //features.add(new LoggingFeature());\n            } else if (dataFormat.equals(DataFormat.MESSAGE)) {\n                features.add(new MessageDataFormatFeature());\n                //features.add(new LoggingFeature());\n            }\n            svrBean.setFeatures(features);\n\n        }\n        svrBean.setBus(bus);\n        svrBean.setStart(false);\n        server = svrBean.create();\n\n    }","id":72263,"modified_method":"public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws Exception {\n\n        super(endpoint, processor);\n        Bus bus = null;\n        this.endpoint = endpoint;\n        boolean isWebServiceProvider = false;\n        if (endpoint.getApplicationContext() != null) {\n            SpringBusFactory bf = new SpringBusFactory(endpoint.getApplicationContext());\n            bus = bf.createBus();\n        } else {\n            // now we just use the default bus here\n            bus = BusFactory.getDefaultBus();\n        }\n        ServerFactoryBean svrBean = null;\n\n        if (endpoint.isSpringContextEndpoint()) {\n            CxfEndpointBean endpointBean = endpoint.getCxfEndpointBean();\n            svrBean = CxfEndpointUtils.getServerFactoryBean(endpointBean.getServiceClass());\n            isWebServiceProvider = CxfEndpointUtils.hasAnnotation(endpointBean.getServiceClass(),\n                                                                  WebServiceProvider.class);\n            endpoint.configure(svrBean);\n\n        } else { // setup the serverFactoryBean with the URI parameters\n            Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());\n            svrBean = CxfEndpointUtils.getServerFactoryBean(serviceClass);\n            isWebServiceProvider = CxfEndpointUtils.hasAnnotation(serviceClass, WebServiceProvider.class);\n            svrBean.setAddress(endpoint.getAddress());\n            svrBean.setServiceClass(serviceClass);\n            if (endpoint.getServiceName() != null) {\n                svrBean.setServiceName(CxfEndpointUtils.getServiceName(endpoint));\n            }\n            if (endpoint.getPortName() != null) {\n                svrBean.setEndpointName(CxfEndpointUtils.getPortName(endpoint));\n            }\n            if (endpoint.getWsdlURL() != null) {\n                svrBean.setWsdlURL(endpoint.getWsdlURL());\n            }\n        }\n        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);\n\n        svrBean.setInvoker(new CamelInvoker(this));\n\n        // apply feature here\n        if (!dataFormat.equals(DataFormat.POJO) && !isWebServiceProvider) {\n            List<AbstractFeature> features = new ArrayList<AbstractFeature>();\n\n            if (dataFormat.equals(DataFormat.PAYLOAD)) {\n                features.add(new PayLoadDataFormatFeature());\n                // adding the logging feature here for debug\n                //features.add(new LoggingFeature());\n            } else if (dataFormat.equals(DataFormat.MESSAGE)) {\n                features.add(new MessageDataFormatFeature());\n                //features.add(new LoggingFeature());\n            }\n            svrBean.setFeatures(features);\n\n        }\n        svrBean.setBus(bus);\n        svrBean.setStart(false);\n        server = svrBean.create();\n\n    }","commit_id":"6f0b2155db24ba69f7f8a3e89894b43ddbb6873d","url":"https://github.com/apache/camel"},{"original_method":"public void testCxfEndpointBeanDefinitionParser() {\n        ClassPathXmlApplicationContext ctx =\n            new ClassPathXmlApplicationContext(new String[]{\"org/apache/camel/component/cxf/spring/CxfEndpointBeans.xml\"});\n\n        CxfEndpointBean routerEndpoint = (CxfEndpointBean)ctx.getBean(\"routerEndpoint\");\n        assertEquals(\"Got the wrong endpoint address\", routerEndpoint.getAddress(), \"http://localhost:9000/router\");\n        assertEquals(\"Got the wrong endpont service class\", routerEndpoint.getServiceClass().getCanonicalName(), \"org.apache.camel.component.cxf.HelloService\");\n    }","id":72264,"modified_method":"public void testCxfEndpointBeanDefinitionParser() {\n\n        CxfEndpointBean routerEndpoint = (CxfEndpointBean)ctx.getBean(\"routerEndpoint\");\n        assertEquals(\"Got the wrong endpoint address\", routerEndpoint.getAddress(), \"http://localhost:9000/router\");\n        assertEquals(\"Got the wrong endpont service class\", routerEndpoint.getServiceClass().getCanonicalName(), \"org.apache.camel.component.cxf.HelloService\");\n\n    }","commit_id":"6f0b2155db24ba69f7f8a3e89894b43ddbb6873d","url":"https://github.com/apache/camel"},{"original_method":"private Client createClientFromClientFactoryBean(ClientFactoryBean cfb) throws CamelException {\n        Bus bus = BusFactory.getDefaultBus();\n        if (endpoint.isSpringContextEndpoint()) {\n            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();\n            if (cfb == null) {\n                cfb = CxfEndpointUtils.getClientFactoryBean(cxfEndpointBean.getServiceClass());\n            }\n            endpoint.configure(cfb);\n\n            if (cxfEndpointBean.getServiceName() != null) {\n                cfb.setServiceName(cxfEndpointBean.getServiceName());\n            }\n            if (cxfEndpointBean.getEndpointName() != null) {\n                cfb.setEndpointName(cxfEndpointBean.getEndpointName());\n            }\n        } else { // set up the clientFactoryBean by using URI information\n            if (null != endpoint.getServiceClass()) {\n                try {\n                    // We need to choose the right front end to create the\n                    // clientFactoryBean\n                    Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this\n                        .getClass());\n                    if (cfb == null) {\n                        cfb = CxfEndpointUtils.getClientFactoryBean(serviceClass);\n                    }\n                    cfb.setAddress(endpoint.getAddress());\n                    if (null != endpoint.getServiceClass()) {\n                        cfb.setServiceClass(ObjectHelper.loadClass(endpoint.getServiceClass()));\n                    }\n                    if (null != endpoint.getWsdlURL()) {\n                        cfb.setWsdlURL(endpoint.getWsdlURL());\n                    }\n                } catch (ClassNotFoundException e) {\n                    throw new CamelException(e);\n                }\n            } else { // we can't see any service class from the endpoint\n                if (cfb == null) {\n                    cfb = new ClientFactoryBean();\n                }\n                if (null != endpoint.getWsdlURL()) {\n                    cfb.setWsdlURL(endpoint.getWsdlURL());\n                } else {\n                    // Throw an exception indicating insufficient endpoint info\n                    throw new CamelException(\"Not enough information to create a CXF endpoint. (Provide WSDL url or service class name.)\");\n                }\n            }\n            if (endpoint.getServiceName() != null) {\n                cfb.setServiceName(CxfEndpointUtils.getServiceName(endpoint));\n            }\n            if (endpoint.getPortName() != null) {\n                cfb.setEndpointName(CxfEndpointUtils.getPortName(endpoint));\n\n            }\n            if (endpoint.getWsdlURL() != null) {\n                cfb.setWsdlURL(endpoint.getWsdlURL());\n            }\n        }\n        cfb.setBus(bus);\n        return cfb.create();\n    }","id":72265,"modified_method":"private Client createClientFromClientFactoryBean(ClientFactoryBean cfb) throws CamelException {\n        Bus bus = null;\n        if (endpoint.getApplicationContext() != null) {\n            SpringBusFactory bf = new SpringBusFactory(endpoint.getApplicationContext());\n            bus = bf.createBus();\n        } else {\n            // now we just use the default bus here\n            bus = BusFactory.getDefaultBus();\n        }\n        if (endpoint.isSpringContextEndpoint()) {\n            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();\n            if (cfb == null) {\n                cfb = CxfEndpointUtils.getClientFactoryBean(cxfEndpointBean.getServiceClass());\n            }\n            endpoint.configure(cfb);\n\n        } else { // set up the clientFactoryBean by using URI information\n            if (null != endpoint.getServiceClass()) {\n                try {\n                    // We need to choose the right front end to create the\n                    // clientFactoryBean\n                    Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this\n                        .getClass());\n                    if (cfb == null) {\n                        cfb = CxfEndpointUtils.getClientFactoryBean(serviceClass);\n                    }\n                    cfb.setAddress(endpoint.getAddress());\n                    if (null != endpoint.getServiceClass()) {\n                        cfb.setServiceClass(ObjectHelper.loadClass(endpoint.getServiceClass()));\n                    }\n                    if (null != endpoint.getWsdlURL()) {\n                        cfb.setWsdlURL(endpoint.getWsdlURL());\n                    }\n                } catch (ClassNotFoundException e) {\n                    throw new CamelException(e);\n                }\n            } else { // we can't see any service class from the endpoint\n                if (cfb == null) {\n                    cfb = new ClientFactoryBean();\n                }\n                if (null != endpoint.getWsdlURL()) {\n                    cfb.setWsdlURL(endpoint.getWsdlURL());\n                } else {\n                    // Throw an exception indicating insufficient endpoint info\n                    throw new CamelException(\"Not enough information to create a CXF endpoint. (Provide WSDL url or service class name.)\");\n                }\n            }\n            if (endpoint.getServiceName() != null) {\n                cfb.setServiceName(CxfEndpointUtils.getServiceName(endpoint));\n            }\n            if (endpoint.getPortName() != null) {\n                cfb.setEndpointName(CxfEndpointUtils.getPortName(endpoint));\n\n            }\n            if (endpoint.getWsdlURL() != null) {\n                cfb.setWsdlURL(endpoint.getWsdlURL());\n            }\n        }\n        cfb.setBus(bus);\n        return cfb.create();\n    }","commit_id":"6f0b2155db24ba69f7f8a3e89894b43ddbb6873d","url":"https://github.com/apache/camel"},{"original_method":"public GroovyPsiElement getContext() {\n    return myContext;\n  }","id":72266,"modified_method":"public PsiElement getContext() {\n    final PsiElement context = super.getContext();\n    if (context != null) return context;\n    return myContext;\n  }","commit_id":"d38a0e6e13d16dbfc1ea4717008b2b238e899a57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyInjector(Project project) {\n    this.project = project;\n  }","id":72267,"modified_method":"public GroovyInjector(Project project) {\n    myProject = project;\n  }","commit_id":"d38a0e6e13d16dbfc1ea4717008b2b238e899a57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void getLanguagesToInject(@NotNull PsiLanguageInjectionHost host, @NotNull InjectedLanguagePlaces injectionPlacesRegistrar) {\n      if (!(host.getLanguage() instanceof XMLLanguage))\n        return;\n\n      VirtualFile virtualFile = PsiUtil.getVirtualFile(host);\n      if (virtualFile == null || !virtualFile.getName().toLowerCase().endsWith(\".gsp\"))\n        return;\n\n      String value = null;\n      if (host instanceof XmlAttributeValue) {\n        XmlAttributeValue attr = (XmlAttributeValue) host;\n        value = attr.getValue();\n      }\n//        else\n//        if (host instanceof XmlText)\n//        {\n//          XmlText xmlText = (XmlText) host;\n//          value = xmlText.getText();\n//        }\n\n      if (value != null) {\n        int start = value.indexOf(\"${\");\n        if (start == -1)\n          return;\n\n        int end = value.indexOf(\"}\", start + 2);\n        if (end == -1)\n          return;\n\n        injectionPlacesRegistrar.addPlace(GroovyFileType.GROOVY_FILE_TYPE.getLanguage(), new TextRange(start + 2, end), \"\", \";\");\n      }\n    }","id":72268,"modified_method":"public void getLanguagesToInject(@NotNull PsiLanguageInjectionHost host, @NotNull InjectedLanguagePlaces injectionPlacesRegistrar) {\n      final Language groovyLanguage = GroovyFileType.GROOVY_FILE_TYPE.getLanguage();\n      if (host instanceof PsiLiteralExpression && host.getParent() instanceof PsiExpressionList) {\n        final PsiExpression[] args = ((PsiExpressionList) host.getParent()).getExpressions();\n        if (host == args[0]) {\n          final PsiElement pparent = host.getParent().getParent();\n          if (pparent instanceof PsiMethodCallExpression) {\n            final PsiMethodCallExpression call = (PsiMethodCallExpression) pparent;\n            final String refName = call.getMethodExpression().getReferenceName();\n            if (PARSE_NAME.equals(refName) || EVAL_NAME.equals(refName)) {\n              final PsiMethod method = call.resolveMethod();\n              if (method != null) {\n                final PsiClass clazz = method.getContainingClass();\n                if (clazz != null) {\n                  if (GROOVY_SHELL_QNAME.equals(clazz.getQualifiedName())) {\n                    injectionPlacesRegistrar.addPlace(groovyLanguage, new TextRange(1, host.getTextLength() - 1), \"\", \"\");\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }","commit_id":"d38a0e6e13d16dbfc1ea4717008b2b238e899a57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void initComponent() {\n    //PsiManager.getInstance(project).registerLanguageInjector(new MyLanguageInjector());\n  }","id":72269,"modified_method":"public void initComponent() {\n    PsiManager.getInstance(myProject).registerLanguageInjector(new MyLanguageInjector());\n  }","commit_id":"d38a0e6e13d16dbfc1ea4717008b2b238e899a57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    if (!(context instanceof MarkdownCodeFenceImpl)) {\n      return;\n    }\n    if (PsiTreeUtil.findChildOfType(context, MarkdownCodeFenceContentImpl.class) == null) {\n      return;\n    }\n\n    final Language language = findLangForInjection(((MarkdownCodeFenceImpl)context));\n    if (language == null) {\n      return;\n    }\n\n    registrar.startInjecting(language);\n    boolean isFirst = true;\n    for (MarkdownCodeFenceContentImpl content : PsiTreeUtil.findChildrenOfType(context, MarkdownCodeFenceContentImpl.class)) {\n      registrar.addPlace(isFirst ? null : \"\\n\",\n                         null,\n                         ((MarkdownCodeFenceImpl)context),\n                         TextRange.create(content.getStartOffsetInParent(), content.getStartOffsetInParent() + content.getTextLength()));\n      isFirst = false;\n    }\n    registrar.doneInjecting();\n  }","id":72270,"modified_method":"@Override\n  public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    if (!(context instanceof MarkdownCodeFenceImpl)) {\n      return;\n    }\n    if (PsiTreeUtil.findChildOfType(context, MarkdownCodeFenceContentImpl.class) == null) {\n      return;\n    }\n\n    final Language language = findLangForInjection(((MarkdownCodeFenceImpl)context));\n    if (language == null) {\n      return;\n    }\n\n    registrar.startInjecting(language);\n    final List<MarkdownCodeFenceContentImpl> list = PsiTreeUtil.getChildrenOfTypeAsList(context, MarkdownCodeFenceContentImpl.class);\n    for (int i = 0; i < list.size(); i++) {\n      final MarkdownCodeFenceContentImpl content = list.get(i);\n      final boolean includeEol = (i + 1 < list.size());\n      final TextRange rangeInHost = TextRange.create(content.getStartOffsetInParent(), \n                                                     content.getStartOffsetInParent() + content.getTextLength() + (includeEol ? 1 : 0));\n      registrar.addPlace(null, null, ((MarkdownCodeFenceImpl)context), rangeInHost);\n    }\n    registrar.doneInjecting();\n  }","commit_id":"de0a9b873510679eac4975b54f0f940129919ac4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param parameters\n\t */\n\tpublic Captcha(final PageParameters parameters)\n\t{\n\t\tfinal FeedbackPanel feedback = new FeedbackPanel(\"feedback\");\n\t\tadd(feedback);\n\t\tadd(new CaptchaForm(\"captchaForm\"));\n\t}","id":72271,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param parameters\n\t */\n\tpublic Captcha(final PageParameters parameters)\n\t{\n\t\tfinal FeedbackPanel feedback = new FeedbackPanel(\"feedback\");\n\t\tadd(feedback);\n\t\tadd(new CaptchaForm<Void>(\"captchaForm\"));\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param id\n\t\t */\n\t\tpublic CaptchaForm(String id)\n\t\t{\n\t\t\tsuper(id);\n\n\t\t\tcaptchaImageResource = new CaptchaImageResource(imagePass);\n\t\t\tadd(new Image(\"captchaImage\", captchaImageResource));\n\t\t\tadd(new RequiredTextField(\"password\", new PropertyModel(properties, \"password\"))\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tprotected final void onComponentTag(final ComponentTag tag)\n\t\t\t\t{\n\t\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\t\t// clear the field after each render\n\t\t\t\t\ttag.put(\"value\", \"\");\n\t\t\t\t}\n\t\t\t});\n\t\t}","id":72272,"modified_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param id\n\t\t */\n\t\tpublic CaptchaForm(String id)\n\t\t{\n\t\t\tsuper(id);\n\n\t\t\tcaptchaImageResource = new CaptchaImageResource(imagePass);\n\t\t\tadd(new Image(\"captchaImage\", captchaImageResource));\n\t\t\tadd(new RequiredTextField<String>(\"password\", new PropertyModel<String>(properties, \"password\"))\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tprotected final void onComponentTag(final ComponentTag tag)\n\t\t\t\t{\n\t\t\t\t\tsuper.onComponentTag(tag);\n\t\t\t\t\t// clear the field after each render\n\t\t\t\t\ttag.put(\"value\", \"\");\n\t\t\t\t}\n\t\t\t});\n\t\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructs a new charset map with default mappers.\n\t */\n\tpublic CharSetMap()\n\t{\n\t\tString path;\n\t\ttry\n\t\t{\n\t\t\t// Check whether the user directory contains mappings.\n\t\t\tpath = System.getProperty(\"user.home\");\n\t\t\tif (path != null)\n\t\t\t{\n\t\t\t\tpath = path + File.separator + CHARSET_RESOURCE;\n\t\t\t\tmappers[MAP_HOME] = loadPath(path);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// Check whether the system directory contains mappings.\n\t\t\tpath = System.getProperty(\"java.home\") + File.separator + \"lib\" + File.separator +\n\t\t\t\tCHARSET_RESOURCE;\n\n\t\t\tmappers[MAP_SYS] = loadPath(path);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\t// Check whether the current class jar contains mappings.\n\t\tmappers[MAP_JAR] = loadResource(\"/META-INF/\" + CHARSET_RESOURCE);\n\n\t\t// Set the common mapper to have the lowest priority.\n\t\tmappers[MAP_COM] = commonMapper;\n\n\t\t// Set the cache mapper to have the highest priority.\n\t\tmappers[MAP_CACHE] = new Hashtable();\n\t}","id":72273,"modified_method":"/**\n\t * Constructs a new charset map with default mappers.\n\t */\n\tpublic CharSetMap()\n\t{\n\t\tString path;\n\t\ttry\n\t\t{\n\t\t\t// Check whether the user directory contains mappings.\n\t\t\tpath = System.getProperty(\"user.home\");\n\t\t\tif (path != null)\n\t\t\t{\n\t\t\t\tpath = path + File.separator + CHARSET_RESOURCE;\n\t\t\t\tmappers.add(MAP_HOME, loadPath(path));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// Check whether the system directory contains mappings.\n\t\t\tpath = System.getProperty(\"java.home\") + File.separator + \"lib\" + File.separator +\n\t\t\t\tCHARSET_RESOURCE;\n\n\t\t\tmappers.add(MAP_SYS, loadPath(path));\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\t// Check whether the current class jar contains mappings.\n\t\tmappers.add(MAP_JAR, loadResource(\"/META-INF/\" + CHARSET_RESOURCE));\n\n\t\t// Set the common mapper to have the lowest priority.\n\t\tmappers.add(MAP_COM, commonMapper);\n\n\t\t// Set the cache mapper to have the highest priority.\n\t\tmappers.add(MAP_CACHE, new Hashtable<String,String>());\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructs a charset map read from a property file.\n\t * \n\t * @param file\n\t *            a property file.\n\t * @throws IOException\n\t *             for an incorrect property file.\n\t */\n\tpublic CharSetMap(final File file) throws IOException\n\t{\n\t\tthis();\n\t\tmappers[MAP_PROG] = loadFile(file);\n\t}","id":72274,"modified_method":"/**\n\t * Constructs a charset map read from a property file.\n\t * \n\t * @param file\n\t *            a property file.\n\t * @throws IOException\n\t *             for an incorrect property file.\n\t */\n\tpublic CharSetMap(final File file) throws IOException\n\t{\n\t\tthis();\n\t\tmappers.add(MAP_PROG, loadFile(file));\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructs a charset map read from a property file path.\n\t * \n\t * @param path\n\t *            a property file path.\n\t * @throws IOException\n\t *             for an incorrect property file.\n\t */\n\tpublic CharSetMap(final String path) throws IOException\n\t{\n\t\tthis();\n\t\tmappers[MAP_PROG] = loadPath(path);\n\t}","id":72275,"modified_method":"/**\n\t * Constructs a charset map read from a property file path.\n\t * \n\t * @param path\n\t *            a property file path.\n\t * @throws IOException\n\t *             for an incorrect property file.\n\t */\n\tpublic CharSetMap(final String path) throws IOException\n\t{\n\t\tthis();\n\t\tmappers.add(MAP_PROG, loadPath(path));\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Loads mappings from a stream.\n\t * \n\t * @param input\n\t *            an input stream.\n\t * @return the mappings.\n\t * @throws IOException\n\t *             for an incorrect stream.\n\t */\n\tprotected final static Map loadStream(final InputStream input) throws IOException\n\t{\n\t\tfinal Properties props = new Properties();\n\t\tprops.load(input);\n\t\treturn new HashMap(props);\n\t}","id":72276,"modified_method":"/**\n\t * Loads mappings from a stream.\n\t * \n\t * @param input\n\t *            an input stream.\n\t * @return the mappings.\n\t * @throws IOException\n\t *             for an incorrect stream.\n\t */\n\tprotected final static Map<String,String> loadStream(final InputStream input) throws IOException\n\t{\n\t\treturn createMap(input);\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets a common locale-charset mapping.\n\t * \n\t * @param key\n\t *            the key for the charset.\n\t * @param charset\n\t *            the corresponding charset.\n\t */\n\tprotected final synchronized void setCommonCharSet(final String key, final String charset)\n\t{\n\t\tfinal HashMap mapper = (HashMap)((HashMap)mappers[MAP_COM]).clone();\n\t\tmapper.put(key, charset);\n\t\tmappers[MAP_COM] = mapper;\n\t\tmappers[MAP_CACHE].clear();\n\t}","id":72277,"modified_method":"/**\n\t * Sets a common locale-charset mapping.\n\t * \n\t * @param key\n\t *            the key for the charset.\n\t * @param charset\n\t *            the corresponding charset.\n\t */\n\t@SuppressWarnings({\"unchecked\"})\n\tprotected final synchronized void setCommonCharSet(final String key, final String charset)\n\t{\n\t\tHashMap<String, String> map = (HashMap<String, String>) mappers.get(MAP_COM);\n\t\tfinal HashMap<String,String> mapper = (HashMap<String,String>) map.clone();\n\t\tmapper.put(key, charset);\n\t\tmappers.add(MAP_COM, mapper);\n\t\tmappers.get(MAP_CACHE).clear();\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Searches for a charset for a specified key.\n\t * \n\t * @param key\n\t *            the key for the charset.\n\t * @return the found charset or an empty string.\n\t */\n\tprivate final String searchCharSet(final String key)\n\t{\n\t\tif ((key != null) && (key.length() > 0))\n\t\t{\n\t\t\t// Go through mappers.\n\t\t\tMap mapper;\n\t\t\tString charset;\n\n\t\t\tfor (int i = 0; i < mappers.length; i++)\n\t\t\t{\n\t\t\t\tmapper = mappers[i];\n\t\t\t\tif (mapper != null)\n\t\t\t\t{\n\t\t\t\t\tcharset = (String)mapper.get(key);\n\t\t\t\t\tif (charset != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Update the cache.\n\t\t\t\t\t\tif (i > MAP_CACHE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmappers[MAP_CACHE].put(key, charset);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn charset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not found, add an empty string to the cache.\n\t\t\tmappers[MAP_CACHE].put(key, \"\");\n\t\t}\n\n\t\treturn \"\";\n\t}","id":72278,"modified_method":"/**\n\t * Searches for a charset for a specified key.\n\t * \n\t * @param key\n\t *            the key for the charset.\n\t * @return the found charset or an empty string.\n\t */\n\tprivate final String searchCharSet(final String key)\n\t{\n\t\tif ((key != null) && (key.length() > 0))\n\t\t{\n\t\t\t// Go through mappers.\n\t\t\tMap<String,String> mapper;\n\t\t\tString charset;\n\n\t\t\tfor (int i = 0; i < mappers.size(); i++)\n\t\t\t{\n\t\t\t\tmapper = mappers.get(i);\n\t\t\t\tif (mapper != null)\n\t\t\t\t{\n\t\t\t\t\tcharset = mapper.get(key);\n\t\t\t\t\tif (charset != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Update the cache.\n\t\t\t\t\t\tif (i > MAP_CACHE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmappers.get(MAP_CACHE).put(key, charset);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn charset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not found, add an empty string to the cache.\n\t\t\tmappers.get(MAP_CACHE).put(key, \"\");\n\t\t}\n\n\t\treturn \"\";\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructs a charset map from properties.\n\t * \n\t * @param props\n\t *            charset mapping properties.\n\t */\n\tpublic CharSetMap(final Properties props)\n\t{\n\t\tthis();\n\t\tmappers[MAP_PROG] = new HashMap(props);\n\t}","id":72279,"modified_method":"/**\n\t * Constructs a charset map from properties.\n\t * \n\t * @param props\n\t *            charset mapping properties.\n\t */\n\tpublic CharSetMap(final Properties props)\n\t{\n\t\tthis();\n\t\tmappers.add(MAP_PROG, createMap(props));\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets a locale-charset mapping.\n\t * \n\t * @param key\n\t *            the key for the charset.\n\t * @param charset\n\t *            the corresponding charset.\n\t */\n\tpublic final synchronized void setCharSet(final String key, final String charset)\n\t{\n\t\tHashMap mapper = (HashMap)mappers[MAP_PROG];\n\t\tmapper = (mapper != null ? (HashMap)mapper.clone() : new HashMap());\n\t\tmapper.put(key, charset);\n\t\tmappers[MAP_PROG] = mapper;\n\t\tmappers[MAP_CACHE].clear();\n\t}","id":72280,"modified_method":"/**\n\t * Sets a locale-charset mapping.\n\t * \n\t * @param key\n\t *            the key for the charset.\n\t * @param charset\n\t *            the corresponding charset.\n\t */\n\t@SuppressWarnings({\"unchecked\"})\n\tpublic final synchronized void setCharSet(final String key, final String charset)\n\t{\n\t\tHashMap<String,String> mapper = (HashMap<String,String>) mappers.get(MAP_PROG);\n\t\tif (mapper != null)\n\t\t{\n\t\t\tmapper = (HashMap<String, String>) mapper.clone();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmapper = new HashMap<String, String>();\n\t\t}\n\t\tmapper.put(key, charset);\n\t\tmappers.add(MAP_PROG, mapper);\n\t\tmappers.get(MAP_CACHE).clear();\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the charset for a locale. First a locale specific charset is searched for, then a\n\t * country specific one and lastly a language specific one. If none is found, the default\n\t * charset is returned.\n\t * \n\t * @param locale\n\t *            the locale.\n\t * @return the charset.\n\t */\n\tpublic final String getCharSet(final Locale locale)\n\t{\n\t\t// Check the cache first.\n\t\tString key = locale.toString();\n\t\tif (key.length() == 0)\n\t\t{\n\t\t\tkey = \"__\" + locale.getVariant();\n\t\t\tif (key.length() == 2)\n\t\t\t{\n\t\t\t\treturn DEFAULT_CHARSET;\n\t\t\t}\n\t\t}\n\n\t\tString charset = searchCharSet(key);\n\t\tif (charset.length() == 0)\n\t\t{\n\t\t\t// Not found, perform a full search and update the cache.\n\t\t\tString[] items = new String[3];\n\t\t\titems[2] = locale.getVariant();\n\t\t\titems[1] = locale.getCountry();\n\t\t\titems[0] = locale.getLanguage();\n\n\t\t\tcharset = searchCharSet(items);\n\t\t\tif (charset.length() == 0)\n\t\t\t{\n\t\t\t\tcharset = DEFAULT_CHARSET;\n\t\t\t}\n\n\t\t\tmappers[MAP_CACHE].put(key, charset);\n\t\t}\n\n\t\treturn charset;\n\t}","id":72281,"modified_method":"/**\n\t * Gets the charset for a locale. First a locale specific charset is searched for, then a\n\t * country specific one and lastly a language specific one. If none is found, the default\n\t * charset is returned.\n\t * \n\t * @param locale\n\t *            the locale.\n\t * @return the charset.\n\t */\n\tpublic final String getCharSet(final Locale locale)\n\t{\n\t\t// Check the cache first.\n\t\tString key = locale.toString();\n\t\tif (key.length() == 0)\n\t\t{\n\t\t\tkey = \"__\" + locale.getVariant();\n\t\t\tif (key.length() == 2)\n\t\t\t{\n\t\t\t\treturn DEFAULT_CHARSET;\n\t\t\t}\n\t\t}\n\n\t\tString charset = searchCharSet(key);\n\t\tif (charset.length() == 0)\n\t\t{\n\t\t\t// Not found, perform a full search and update the cache.\n\t\t\tString[] items = new String[3];\n\t\t\titems[2] = locale.getVariant();\n\t\t\titems[1] = locale.getCountry();\n\t\t\titems[0] = locale.getLanguage();\n\n\t\t\tcharset = searchCharSet(items);\n\t\t\tif (charset.length() == 0)\n\t\t\t{\n\t\t\t\tcharset = DEFAULT_CHARSET;\n\t\t\t}\n\n\t\t\tmappers.get(MAP_CACHE).put(key, charset);\n\t\t}\n\n\t\treturn charset;\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructs a charset map read from a stream.\n\t * \n\t * @param input\n\t *            an input stream.\n\t * @throws IOException\n\t *             for an incorrect stream.\n\t */\n\tpublic CharSetMap(final InputStream input) throws IOException\n\t{\n\t\tthis();\n\t\tmappers[MAP_PROG] = loadStream(input);\n\t}","id":72282,"modified_method":"/**\n\t * Constructs a charset map read from a stream.\n\t * \n\t * @param input\n\t *            an input stream.\n\t * @throws IOException\n\t *             for an incorrect stream.\n\t */\n\tpublic CharSetMap(final InputStream input) throws IOException\n\t{\n\t\tthis();\n\t\tmappers.add(MAP_PROG, loadStream(input));\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the charset for a locale with a variant. The search is performed in the following order:\n\t * \"lang\"_\"country\"_\"variant\"=\"charset\", _\"country\"_\"variant\"=\"charset\",\n\t * \"lang\"__\"variant\"=\"charset\", __\"variant\"=\"charset\", \"lang\"_\"country\"=\"charset\",\n\t * _\"country\"=\"charset\", \"lang\"=\"charset\". If nothing of the above is found, the default charset\n\t * is returned.\n\t * \n\t * @param locale\n\t *            the locale.\n\t * @param variant\n\t *            a variant field.\n\t * @return the charset.\n\t */\n\tpublic final String getCharSet(final Locale locale, final String variant)\n\t{\n\t\t// Check the cache first.\n\t\tif ((variant != null) && (variant.length() > 0))\n\t\t{\n\t\t\tString key = locale.toString();\n\t\t\tif (key.length() == 0)\n\t\t\t{\n\t\t\t\tkey = \"__\" + locale.getVariant();\n\t\t\t\tif (key.length() > 2)\n\t\t\t\t{\n\t\t\t\t\tkey += '_' + variant;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tkey += variant;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (locale.getCountry().length() == 0)\n\t\t\t{\n\t\t\t\tkey += \"__\" + variant;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkey += '_' + variant;\n\t\t\t}\n\n\t\t\tString charset = searchCharSet(key);\n\t\t\tif (charset.length() == 0)\n\t\t\t{\n\t\t\t\t// Not found, perform a full search and update the cache.\n\t\t\t\tString[] items = new String[4];\n\t\t\t\titems[3] = variant;\n\t\t\t\titems[2] = locale.getVariant();\n\t\t\t\titems[1] = locale.getCountry();\n\t\t\t\titems[0] = locale.getLanguage();\n\n\t\t\t\tcharset = searchCharSet(items);\n\t\t\t\tif (charset.length() == 0)\n\t\t\t\t{\n\t\t\t\t\tcharset = DEFAULT_CHARSET;\n\t\t\t\t}\n\n\t\t\t\tmappers[MAP_CACHE].put(key, charset);\n\t\t\t}\n\n\t\t\treturn charset;\n\t\t}\n\n\t\treturn getCharSet(locale);\n\t}","id":72283,"modified_method":"/**\n\t * Gets the charset for a locale with a variant. The search is performed in the following order:\n\t * \"lang\"_\"country\"_\"variant\"=\"charset\", _\"country\"_\"variant\"=\"charset\",\n\t * \"lang\"__\"variant\"=\"charset\", __\"variant\"=\"charset\", \"lang\"_\"country\"=\"charset\",\n\t * _\"country\"=\"charset\", \"lang\"=\"charset\". If nothing of the above is found, the default charset\n\t * is returned.\n\t * \n\t * @param locale\n\t *            the locale.\n\t * @param variant\n\t *            a variant field.\n\t * @return the charset.\n\t */\n\tpublic final String getCharSet(final Locale locale, final String variant)\n\t{\n\t\t// Check the cache first.\n\t\tif ((variant != null) && (variant.length() > 0))\n\t\t{\n\t\t\tString key = locale.toString();\n\t\t\tif (key.length() == 0)\n\t\t\t{\n\t\t\t\tkey = \"__\" + locale.getVariant();\n\t\t\t\tif (key.length() > 2)\n\t\t\t\t{\n\t\t\t\t\tkey += '_' + variant;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tkey += variant;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (locale.getCountry().length() == 0)\n\t\t\t{\n\t\t\t\tkey += \"__\" + variant;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkey += '_' + variant;\n\t\t\t}\n\n\t\t\tString charset = searchCharSet(key);\n\t\t\tif (charset.length() == 0)\n\t\t\t{\n\t\t\t\t// Not found, perform a full search and update the cache.\n\t\t\t\tString[] items = new String[4];\n\t\t\t\titems[3] = variant;\n\t\t\t\titems[2] = locale.getVariant();\n\t\t\t\titems[1] = locale.getCountry();\n\t\t\t\titems[0] = locale.getLanguage();\n\n\t\t\t\tcharset = searchCharSet(items);\n\t\t\t\tif (charset.length() == 0)\n\t\t\t\t{\n\t\t\t\t\tcharset = DEFAULT_CHARSET;\n\t\t\t\t}\n\n\t\t\t\tmappers.get(MAP_CACHE).put(key, charset);\n\t\t\t}\n\n\t\t\treturn charset;\n\t\t}\n\n\t\treturn getCharSet(locale);\n\t}","commit_id":"e07a74e26672ce34710f8673ee56f65c9d2246b9","url":"https://github.com/apache/wicket"},{"original_method":"public static void history(final Project project, FilePath path, final Consumer<GitFileRevision> consumer,\n                             final Consumer<VcsException> exceptionConsumer) throws VcsException {\n    // adjust path using change manager\n    path = getLastCommitName(project, path);\n    final VirtualFile root = GitUtil.getGitRoot(path);\n    GitLineHandler h = new GitLineHandler(project, root, GitCommand.LOG);\n    h.setNoSSH(true);\n    h.setStdoutSuppressed(true);\n    h.addParameters(\"-M\", \"--follow\", \"--name-only\",\n                    \"--pretty=tformat:%x00%x01%x00%H%x00%ct%x00%an%x20%x3C%ae%x3E%x00%cn%x20%x3C%ce%x3E%x00%x02%x00%s%x00%b%x00%x02%x01\",\n                    \"--encoding=UTF-8\");\n    h.endOptions();\n    h.addRelativePaths(path);\n\n    final String prefix = root.getPath() + \"/\";\n    final MyTokenAccumulator accumulator = new MyTokenAccumulator(6);\n\n    final Consumer<List<String>> resultAdapter = new Consumer<List<String>>() {\n      public void consume(List<String> result) {\n        final GitRevisionNumber revision = new GitRevisionNumber(result.get(0), GitUtil.parseTimestamp(result.get(1)));\n        final String author = GitUtil.adjustAuthorName(result.get(2), result.get(3));\n        final String message = result.get(4).trim();\n\n        String path = \"\";\n        try {\n          path = GitUtil.unescapePath(result.get(5));\n        }\n        catch (VcsException e) {\n          exceptionConsumer.consume(e);\n        }\n        final FilePath revisionPath = VcsUtil.getFilePathForDeletedFile(prefix + path, false);\n        consumer.consume(new GitFileRevision(project, revisionPath, revision, author, message, null));\n      }\n    };\n\n    final Semaphore semaphore = new Semaphore();\n    h.addLineListener(new GitLineHandlerAdapter() {\n      @Override\n      public void onLineAvailable(String line, Key outputType) {\n        final List<String> result = accumulator.acceptLine(line);\n        if (result != null) {\n          resultAdapter.consume(result);\n        }\n      }\n\n      @Override\n      public void startFailed(Throwable exception) {\n        //noinspection ThrowableInstanceNeverThrown\n        exceptionConsumer.consume(new VcsException(exception));\n      }\n\n      @Override\n      public void processTerminated(int exitCode) {\n        super.processTerminated(exitCode);\n        final List<String> result = accumulator.processLast();\n        if (result != null) {\n          resultAdapter.consume(result);\n        }\n        for (VcsException e : accumulator.exceptions) {\n          exceptionConsumer.consume(e);\n        }\n        semaphore.up();\n      }\n    });\n    semaphore.down();\n    h.start();\n    semaphore.waitFor();\n  }","id":72284,"modified_method":"public static void history(final Project project, FilePath path, final Consumer<GitFileRevision> consumer,\n                             final Consumer<VcsException> exceptionConsumer) throws VcsException {\n    // adjust path using change manager\n    path = getLastCommitName(project, path);\n    final VirtualFile root = GitUtil.getGitRoot(path);\n    GitLineHandler h = new GitLineHandler(project, root, GitCommand.LOG);\n    h.setNoSSH(true);\n    h.setStdoutSuppressed(true);\n    h.addParameters(\"-M\", \"--follow\", \"--name-only\",\n                    \"--pretty=tformat:%x00%x01%x00%H%x00%ct%x00%an%x20%x3C%ae%x3E%x00%cn%x20%x3C%ce%x3E%x00%x02%x00%s%x00%b%x00%x02%x01\",\n                    \"--encoding=UTF-8\");\n    h.endOptions();\n    h.addRelativePaths(path);\n\n    final String prefix = root.getPath() + \"/\";\n    final MyTokenAccumulator accumulator = new MyTokenAccumulator(6);\n\n    final Consumer<LowLevelRevisionDetails> resultAdapter = new Consumer<LowLevelRevisionDetails>() {\n      public void consume(LowLevelRevisionDetails revisionDetails) {\n        if (revisionDetails == null) {\n          exceptionConsumer.consume(new VcsException(\"revision details are null.\"));\n          return;\n        }\n        if (revisionDetails.missesRequiredFields()) {\n          exceptionConsumer.consume(new VcsException(\"revision misses hash or timestamp data.\"));\n          return;\n        }\n        final GitRevisionNumber revision = new GitRevisionNumber(revisionDetails.hash, GitUtil.parseTimestamp(revisionDetails.timestamp));\n        final String author = GitUtil.adjustAuthorName(revisionDetails.getAuthor(), revisionDetails.getCommitter());\n        final String message = revisionDetails.getComment();\n\n        String path = revisionDetails.getPath();\n        try {\n          if (!path.isEmpty()) {\n            path = GitUtil.unescapePath(path);\n          }\n        } catch (VcsException e) {\n          exceptionConsumer.consume(e);\n        }\n        final FilePath revisionPath = VcsUtil.getFilePathForDeletedFile(prefix + path, false);\n        consumer.consume(new GitFileRevision(project, revisionPath, revision, author, message, null));\n      }\n    };\n\n    final Semaphore semaphore = new Semaphore();\n    h.addLineListener(new GitLineHandlerAdapter() {\n      @Override\n      public void onLineAvailable(String line, Key outputType) {\n        final LowLevelRevisionDetails result = accumulator.acceptLine(line);\n        if (result != null) {\n          resultAdapter.consume(result);\n        }\n      }\n\n      @Override\n      public void startFailed(Throwable exception) {\n        //noinspection ThrowableInstanceNeverThrown\n        exceptionConsumer.consume(new VcsException(exception));\n      }\n\n      @Override\n      public void processTerminated(int exitCode) {\n        super.processTerminated(exitCode);\n        final LowLevelRevisionDetails result = accumulator.processLast();\n        if (result != null) {\n          resultAdapter.consume(result);\n        }\n        for (VcsException e : accumulator.exceptions) {\n          exceptionConsumer.consume(e);\n        }\n        semaphore.up();\n      }\n    });\n    semaphore.down();\n    h.start();\n    semaphore.waitFor();\n  }","commit_id":"763fc2ae2c9f1cd3d8975afab30547dc12b34f0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * A private constructor\n   */\n  private GitHistoryUtils() {\n  }","id":72285,"modified_method":"private GitHistoryUtils() {\n  }","commit_id":"763fc2ae2c9f1cd3d8975afab30547dc12b34f0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<String> processResult(final String line) {\n      final int commentStartIdx = line.indexOf(ourCommentStartMark);\n      if (commentStartIdx == -1) {\n        LOG.info(\"Git history: no comment mark in line: '\" + line + \"'\");\n        // todo remove this when clarifyed\n        java.util.StringTokenizer tk = new java.util.StringTokenizer(line, TOKEN_DELIMITER, false);\n        final List<String> result = new ArrayList<String>();\n        while (tk.hasMoreElements()) {\n          final String token = tk.nextToken();\n          result.add(token);\n        }\n        return result;\n      }\n\n      final String start = line.substring(0, commentStartIdx);\n      java.util.StringTokenizer tk = new java.util.StringTokenizer(start, TOKEN_DELIMITER, false);\n      final List<String> result = new ArrayList<String>();\n      while (tk.hasMoreElements()) {\n        final String token = tk.nextToken();\n        result.add(token);\n      }\n\n      final String commentAndPath = line.substring(commentStartIdx + ourCommentStartMark.length());\n      final int commentEndIdx = commentAndPath.indexOf(ourCommentEndMark);\n      if (commentEndIdx > -1) {\n        result.add(replaceDelimitersByNewlines(commentAndPath.substring(0, commentEndIdx)));      // comment\n        result.add(replaceDelimitersByNewlines(commentAndPath.substring(commentEndIdx + ourCommentEndMark.length())));  // path\n      } else {\n        exceptions.add(new VcsException(\"git log output is uncomplete\"));\n        result.add(replaceDelimitersByNewlines(commentAndPath));\n        result.add(\"\");   // empty path\n      }\n      return result;\n    }","id":72286,"modified_method":"private LowLevelRevisionDetails processResult(final String line) {\n      final int commentStartIdx = line.indexOf(ourCommentStartMark);\n      if (commentStartIdx == -1) {\n        LOG.info(\"Git history: no comment mark in line: '\" + line + \"'\");\n        // todo remove this when clarifyed\n        java.util.StringTokenizer tk = new java.util.StringTokenizer(line, TOKEN_DELIMITER, false);\n        final List<String> result = new ArrayList<String>();\n        while (tk.hasMoreElements()) {\n          final String token = tk.nextToken();\n          result.add(token);\n        }\n        return LowLevelRevisionDetails.fillDetails(result);\n      }\n\n      final String start = line.substring(0, commentStartIdx);\n      final java.util.StringTokenizer tk = new java.util.StringTokenizer(start, TOKEN_DELIMITER, false);\n      final List<String> result = new ArrayList<String>();\n      while (tk.hasMoreElements()) {\n        final String token = tk.nextToken();\n        result.add(token);\n      }\n      final LowLevelRevisionDetails revisionDetails = LowLevelRevisionDetails.fillDetails(result);\n      \n      final String commentAndPath = line.substring(commentStartIdx + ourCommentStartMark.length());\n      final int commentEndIdx = commentAndPath.indexOf(ourCommentEndMark);\n      if (commentEndIdx > -1) {\n        revisionDetails.comment = replaceDelimitersByNewlines(commentAndPath.substring(0, commentEndIdx));\n        revisionDetails.path = replaceDelimitersByNewlines(commentAndPath.substring(commentEndIdx + ourCommentEndMark.length()));\n      } else {\n        exceptions.add(new VcsException(\"git log output is uncomplete\"));\n        revisionDetails.comment = replaceDelimitersByNewlines(commentAndPath);\n        revisionDetails.path = \"\";   // empty path\n      }\n      return revisionDetails;\n    }","commit_id":"763fc2ae2c9f1cd3d8975afab30547dc12b34f0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doLoad(Ehcache ehcache) {\n\t\tsynchronized (EhcacheStreamBootstrapCacheLoader.class) {\n\t\t\tif (!_started) {\n\t\t\t\t_deferredEhcaches.add(ehcache);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (_skipBootstrapThreadLocal.get()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Bootstraping \" + ehcache.getName());\n\t\t}\n\n\t\ttry {\n\t\t\tEhcacheStreamBootstrapHelpUtil.acquireCachePeers(ehcache);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new CacheException(e);\n\t\t}\n\t}","id":72287,"modified_method":"public void doLoad(Ehcache ehcache) {\n\t\tsynchronized (EhcacheStreamBootstrapCacheLoader.class) {\n\t\t\tif (!_started) {\n\t\t\t\t_deferredEhcaches.add(ehcache);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (_skipBootstrapThreadLocal.get()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Bootstraping \" + ehcache.getName());\n\t\t}\n\n\t\ttry {\n\t\t\tEhcacheStreamBootstrapHelpUtil.loadCachesFromCluster(\n\t\t\t\tfalse, ehcache);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new CacheException(e);\n\t\t}\n\t}","commit_id":"dae3bed74fb9b0bbee43574b452c65327e62f7d5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static synchronized void start() {\n\t\tif (!_started) {\n\t\t\t_started = true;\n\t\t}\n\n\t\tfor (Ehcache ehcache : _deferredEhcaches) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Loading deferred cache \" + ehcache.getName());\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tEhcacheStreamBootstrapHelpUtil.acquireCachePeers(ehcache);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new CacheException(e);\n\t\t\t}\n\t\t}\n\t}","id":72288,"modified_method":"public static synchronized void start() {\n\t\tif (!_started) {\n\t\t\t_started = true;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Loading deferred caches\");\n\t\t}\n\n\t\ttry {\n\t\t\tEhcacheStreamBootstrapHelpUtil.loadCachesFromCluster(\n\t\t\t\ttrue,\n\t\t\t\t_deferredEhcaches.toArray(\n\t\t\t\t\tnew Ehcache[_deferredEhcaches.size()]));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new CacheException(e);\n\t\t}\n\t\tfinally {\n\t\t\t_deferredEhcaches.clear();\n\t\t}\n\t}","commit_id":"dae3bed74fb9b0bbee43574b452c65327e62f7d5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void acquireCachePeers(Ehcache ehcache) throws Exception {\n\t\tList<Address> clusterNodeAddresses =\n\t\t\tClusterExecutorUtil.getClusterNodeAddresses();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Cluster node addresses \" + clusterNodeAddresses);\n\t\t}\n\n\t\tint clusterNodeAddressesCount = clusterNodeAddresses.size();\n\n\t\tif (clusterNodeAddressesCount <= 1) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to find peers because there is only one portal \" +\n\t\t\t\t\t\t\"instance in the cluster\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tloadCachesFromCluster(ehcache);\n\t}","id":72289,"modified_method":"public static SocketAddress createServerSocketFromCluster(\n\t\t\tList<String> cacheNames)\n\t\tthrows Exception {\n\n\t\tServerSocket serverSocket = createServerSocket(\n\t\t\tPropsValues.EHCACHE_SOCKET_START_PORT);\n\n\t\tEhcacheStreamServerThread ehcacheStreamServerThread =\n\t\t\tnew EhcacheStreamServerThread(serverSocket, cacheNames);\n\n\t\tehcacheStreamServerThread.start();\n\n\t\treturn serverSocket.getLocalSocketAddress();\n\t}","commit_id":"dae3bed74fb9b0bbee43574b452c65327e62f7d5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void loadCachesFromCluster(Ehcache ehcache)\n\t\tthrows Exception {\n\n\t\tClusterRequest clusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\tnew MethodHandler(\n\t\t\t\t_createServerSocketFromClusterMethodKey, ehcache.getName()),\n\t\t\ttrue);\n\n\t\tFutureClusterResponses futureClusterResponses =\n\t\t\tClusterExecutorUtil.execute(clusterRequest);\n\n\t\tBlockingQueue<ClusterNodeResponse> clusterNodeResponses =\n\t\t\tfutureClusterResponses.getPartialResults();\n\n\t\tClusterNodeResponse clusterNodeResponse = null;\n\n\t\ttry {\n\t\t\tclusterNodeResponse = clusterNodeResponses.poll(\n\t\t\t\tPropsValues.CLUSTER_LINK_NODE_BOOTUP_RESPONSE_TIMEOUT,\n\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (clusterNodeResponse == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tObjectInputStream objectInputStream = null;\n\t\tSocket socket = null;\n\n\t\ttry {\n\t\t\tSocketAddress remoteSocketAddress =\n\t\t\t\t(SocketAddress)clusterNodeResponse.getResult();\n\n\t\t\tif (remoteSocketAddress == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsocket = new Socket();\n\n\t\t\tsocket.connect(remoteSocketAddress);\n\n\t\t\tsocket.shutdownOutput();\n\n\t\t\tobjectInputStream = new AnnotatedObjectInputStream(\n\t\t\t\tsocket.getInputStream());\n\n\t\t\twhile (true) {\n\t\t\t\tObject object = objectInputStream.readObject();\n\n\t\t\t\tif (object instanceof EhcacheElement) {\n\t\t\t\t\tEhcacheElement ehcacheElement = (EhcacheElement)object;\n\n\t\t\t\t\tElement element = ehcacheElement.toElement();\n\n\t\t\t\t\tehcache.put(element, true);\n\t\t\t\t}\n\t\t\t\telse if (object instanceof String) {\n\t\t\t\t\tString command = (String)object;\n\n\t\t\t\t\tif (command.equals(_COMMAND_CACHE_TX_START)) {\n\t\t\t\t\t\tString cacheName =\n\t\t\t\t\t\t\t(String)objectInputStream.readObject();\n\n\t\t\t\t\t\tif (!cacheName.equals(ehcache.getName())) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (command.equals(_COMMAND_SOCKET_CLOSE)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\t\"Socket input stream returned invalid object \" +\n\t\t\t\t\t\t\tobject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (objectInputStream != null) {\n\t\t\t\tobjectInputStream.close();\n\t\t\t}\n\n\t\t\tif (socket != null) {\n\t\t\t\tsocket.close();\n\t\t\t}\n\t\t}\n\t}","id":72290,"modified_method":"protected static List<String> loadCacheNamesFromCluster() throws Exception {\n\t\tClusterRequest clusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\tnew MethodHandler(_getCacheNamesFromClusterMethodKey), true);\n\n\t\tFutureClusterResponses futureClusterResponses =\n\t\t\tClusterExecutorUtil.execute(clusterRequest);\n\n\t\tBlockingQueue<ClusterNodeResponse> clusterNodeResponses =\n\t\t\tfutureClusterResponses.getPartialResults();\n\n\t\tClusterNodeResponse clusterNodeResponse = null;\n\n\t\ttry {\n\t\t\tclusterNodeResponse = clusterNodeResponses.poll(\n\t\t\t\tPropsValues.CLUSTER_LINK_NODE_BOOTUP_RESPONSE_TIMEOUT,\n\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (clusterNodeResponse == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn (List<String>)clusterNodeResponse.getResult();\n\t}","commit_id":"dae3bed74fb9b0bbee43574b452c65327e62f7d5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ServerSocket createServerSocket(int startPort)\n\t\tthrows Exception {\n\n\t\tInetAddress inetAddress = ClusterLinkUtil.getBindInetAddress();\n\n\t\tServerSocketConfigurator serverSocketConfigurator =\n\t\t\tnew SocketCacheServerSocketConfiguration();\n\n\t\tServerSocketChannel serverSocketChannel =\n\t\t\tSocketUtil.createServerSocketChannel(\n\t\t\t\tinetAddress, startPort, serverSocketConfigurator);\n\n\t\treturn serverSocketChannel.socket();\n\t}","id":72291,"modified_method":"protected static ServerSocket createServerSocket(int startPort)\n\t\tthrows Exception {\n\n\t\tInetAddress inetAddress = ClusterLinkUtil.getBindInetAddress();\n\n\t\tServerSocketConfigurator serverSocketConfigurator =\n\t\t\tnew SocketCacheServerSocketConfiguration();\n\n\t\tServerSocketChannel serverSocketChannel =\n\t\t\tSocketUtil.createServerSocketChannel(\n\t\t\t\tinetAddress, startPort, serverSocketConfigurator);\n\n\t\treturn serverSocketChannel.socket();\n\t}","commit_id":"dae3bed74fb9b0bbee43574b452c65327e62f7d5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public EhcacheStreamServerThread(\n\t\t\tServerSocket serverSocket, String cacheName) {\n\n\t\t\t_serverSocket = serverSocket;\n\t\t\t_cacheName = cacheName;\n\n\t\t\tEhcachePortalCacheManager<?, ?> ehcachePortalCacheManager =\n\t\t\t\t(EhcachePortalCacheManager<?, ?>)PortalBeanLocatorUtil.locate(\n\t\t\t\t\t_BEAN_NAME_MULTI_VM_PORTAL_CACHE_MANAGER);\n\n\t\t\t_portalCacheManager = ehcachePortalCacheManager.getEhcacheManager();\n\n\t\t\tsetDaemon(true);\n\t\t\tsetName(\n\t\t\t\tEhcacheStreamServerThread.class.getName() + \" - \" + cacheName);\n\t\t\tsetPriority(Thread.NORM_PRIORITY);\n\t\t}","id":72292,"modified_method":"public EhcacheStreamServerThread(\n\t\t\tServerSocket serverSocket, List<String> ehcacheNames) {\n\n\t\t\t_serverSocket = serverSocket;\n\t\t\t_ehcacheNames = ehcacheNames;\n\n\t\t\tEhcachePortalCacheManager<?, ?> ehcachePortalCacheManager =\n\t\t\t\t(EhcachePortalCacheManager<?, ?>)PortalBeanLocatorUtil.locate(\n\t\t\t\t\t_BEAN_NAME_MULTI_VM_PORTAL_CACHE_MANAGER);\n\n\t\t\t_portalCacheManager = ehcachePortalCacheManager.getEhcacheManager();\n\n\t\t\tsetDaemon(true);\n\n\t\t\tsetName(\n\t\t\t\tEhcacheStreamServerThread.class.getName() + \" - \" +\n\t\t\t\tehcacheNames);\n\n\t\t\tsetPriority(Thread.NORM_PRIORITY);\n\t\t}","commit_id":"dae3bed74fb9b0bbee43574b452c65327e62f7d5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic void run() {\n\t\t\tSocket socket = null;\n\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tsocket = _serverSocket.accept();\n\t\t\t\t}\n\t\t\t\tcatch (SocketTimeoutException ste) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Terminating the socket thread \" + getName() +\n\t\t\t\t\t\t\t\t\" that the client requested but never used\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_serverSocket.close();\n\n\t\t\t\tsocket.shutdownInput();\n\n\t\t\t\tObjectOutputStream objectOutputStream =\n\t\t\t\t\tnew AnnotatedObjectOutputStream(socket.getOutputStream());\n\n\t\t\t\tobjectOutputStream.writeObject(_COMMAND_CACHE_TX_START);\n\n\t\t\t\tEhcache ehcache = _portalCacheManager.getCache(_cacheName);\n\n\t\t\t\tif (ehcache == null) {\n\t\t\t\t\tEhcacheStreamBootstrapCacheLoader.setSkip();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_portalCacheManager.addCache(_cacheName);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tEhcacheStreamBootstrapCacheLoader.resetSkip();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tobjectOutputStream.writeObject(_cacheName);\n\n\t\t\t\t\tList<Object> keys = ehcache.getKeys();\n\n\t\t\t\t\tfor (Object key : keys) {\n\t\t\t\t\t\tif (!(key instanceof Serializable)) {\n\t\t\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\t\t\"Key \" + key + \" is not serializable\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tElement element = ehcache.get(key);\n\n\t\t\t\t\t\tif (element == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tObject value = element.getObjectValue();\n\n\t\t\t\t\t\tif (!(value instanceof Serializable)) {\n\t\t\t\t\t\t\tif (_log.isWarnEnabled() && (value != null)) {\n\t\t\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\t\t\"Value \" + value + \" is not serializable\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tEhcacheElement ehcacheElement = new EhcacheElement(\n\t\t\t\t\t\t\t(Serializable)key, (Serializable)value);\n\n\t\t\t\t\t\tobjectOutputStream.writeObject(ehcacheElement);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tobjectOutputStream.writeObject(_COMMAND_SOCKET_CLOSE);\n\n\t\t\t\tobjectOutputStream.close();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (socket != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsocket.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tthrow new RuntimeException(ioe);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":72293,"modified_method":"@Override\n\t\tpublic void run() {\n\t\t\tSocket socket = null;\n\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tsocket = _serverSocket.accept();\n\t\t\t\t}\n\t\t\t\tcatch (SocketTimeoutException ste) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Terminating the socket thread \" + getName() +\n\t\t\t\t\t\t\t\t\" that the client requested but never used\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_serverSocket.close();\n\n\t\t\t\tsocket.shutdownInput();\n\n\t\t\t\tObjectOutputStream objectOutputStream =\n\t\t\t\t\tnew AnnotatedObjectOutputStream(socket.getOutputStream());\n\n\t\t\t\tfor (String cacheName : _ehcacheNames) {\n\t\t\t\t\tobjectOutputStream.writeObject(_COMMAND_CACHE_TX_START);\n\n\t\t\t\t\tEhcache ehcache = _portalCacheManager.getCache(cacheName);\n\n\t\t\t\t\tif (ehcache == null) {\n\t\t\t\t\t\tEhcacheStreamBootstrapCacheLoader.setSkip();\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t_portalCacheManager.addCache(cacheName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tEhcacheStreamBootstrapCacheLoader.resetSkip();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tobjectOutputStream.writeObject(cacheName);\n\n\t\t\t\t\t\tList<Object> keys = ehcache.getKeys();\n\n\t\t\t\t\t\tfor (Object key : keys) {\n\t\t\t\t\t\t\tif (!(key instanceof Serializable)) {\n\t\t\t\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\t\t\t\"Key \" + key + \" is not serializable\");\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tElement element = ehcache.get(key);\n\n\t\t\t\t\t\t\tif (element == null) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tObject value = element.getObjectValue();\n\n\t\t\t\t\t\t\tif (!(value instanceof Serializable)) {\n\t\t\t\t\t\t\t\tif (_log.isWarnEnabled() && (value != null)) {\n\t\t\t\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\t\t\t\"Value \" + value +\n\t\t\t\t\t\t\t\t\t\t\" is not serializable\");\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tEhcacheElement ehcacheElement = new EhcacheElement(\n\t\t\t\t\t\t\t\t(Serializable)key, (Serializable)value);\n\n\t\t\t\t\t\t\tobjectOutputStream.writeObject(ehcacheElement);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tobjectOutputStream.writeObject(_COMMAND_SOCKET_CLOSE);\n\n\t\t\t\tobjectOutputStream.close();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (socket != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsocket.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tthrow new RuntimeException(ioe);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"dae3bed74fb9b0bbee43574b452c65327e62f7d5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Called when all queued data is flushed to the channel\n     */\n    private final void backpressureEnded() {\n        if (networkLog.isTraceEnabled()) {\n            networkLog.trace(\"Backpressure ended for client \" + m_port);\n        }\n        m_hadBackPressure = false;\n        if (m_offBackPressureCallback != null) {\n            m_offBackPressureCallback.run();\n        }\n    }","id":72294,"modified_method":"/**\n     * Called when all queued data is flushed to the channel\n     */\n    private final void backpressureEnded() {\n        if (networkLog.isTraceEnabled()) {\n            networkLog.trace(\"Backpressure ended for client \" + m_port);\n        }\n        if (m_hadBackPressure == true) {\n            m_hadBackPressure = false;\n            if (m_offBackPressureCallback != null) {\n                m_offBackPressureCallback.run();\n            }\n        }\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Queued a container for writing. This isn't the ideal API to use since the serialization has been done\n     * outside of a network thread\n     * @param c\n     */\n    @Override\n    public boolean enqueue(final BBContainer c) {\n        assert(c != null);\n        assert(c.b != null);\n        if (c.b.remaining() == 0) {\n            c.discard();\n            return false;\n        }\n        synchronized (this) {\n            if (m_isShutdown) {\n                c.discard();\n                return false;\n            }\n            updateLastPendingWriteTimeAndQueueBackpressure();\n            updateQueued(c.b.remaining(), true);\n            m_queuedBuffers.offer(c);\n            m_port.setInterests( SelectionKey.OP_WRITE, 0);\n        }\n        return true;\n    }","id":72295,"modified_method":"/**\n     * Queued a container for writing. This isn't the ideal API to use since the serialization has been done\n     * outside of a network thread\n     * @param c\n     */\n    @Override\n    public boolean enqueue(final BBContainer c) {\n        assert(c != null);\n        assert(c.b != null);\n        if (c.b.remaining() == 0) {\n            c.discard();\n            return false;\n        }\n        synchronized (this) {\n            if (m_isShutdown) {\n                c.discard();\n                return false;\n            }\n            updateLastPendingWriteTimeAndQueueBackpressure();\n            updateQueued(c.b.remaining(), false);\n            m_queuedBuffers.offer(c);\n            m_port.setInterests( SelectionKey.OP_WRITE, 0);\n        }\n        return true;\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Called when not all queued data could be flushed to the channel\n     */\n    private final void backpressureStarted() {\n        if (networkLog.isTraceEnabled()) {\n            networkLog.trace(\"Backpressure started for client \" + m_port);\n        }\n        m_hadBackPressure = true;\n        if (m_onBackPressureCallback != null) {\n            m_onBackPressureCallback.run();\n        }\n    }","id":72296,"modified_method":"/**\n     * Called when not all queued data could be flushed to the channel\n     */\n    private final void backpressureStarted() {\n        if (networkLog.isTraceEnabled()) {\n            networkLog.trace(\"Backpressure started for client \" + m_port);\n        }\n        if (m_hadBackPressure == false) {\n            m_hadBackPressure = true;\n            if (m_onBackPressureCallback != null) {\n                m_onBackPressureCallback.run();\n            }\n        }\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Queue a ByteBuffer for writing to the network. If the ByteBuffer is not direct then it will\n     * be copied to a DirectByteBuffer if it is less then DBBPool.MAX_ALLOCATION_SIZE. This method\n     * is a backup for code that isn't able to defer its serialization to a network thread\n     * for whatever reason. It is reasonably efficient if a DirectByteBuffer is passed in,\n     * but it would be better to keep allocations of DirectByteBuffers inside the network pools.\n     * @param b\n     */\n    @Override\n    public boolean enqueue(final ByteBuffer b) {\n        assert(b != null);\n        assert(!b.isDirect());//Don't queue direct buffers, they leak memory without a container\n        if (b.remaining() == 0) {\n            return false;\n        }\n\n        synchronized (this) {\n            if (m_isShutdown) {\n                return false;\n            }\n\n            updateLastPendingWriteTimeAndQueueBackpressure();\n\n            /*\n             * Attempt to use one of our own pooled direct byte buffers\n             * so that a gathering write can be done later. Java gathering\n             * writes spam direct byte buffers if many regular BBs are used\n             */\n            if (b.remaining() < DBBPool.MAX_ALLOCATION_SIZE){\n                m_queuedWrites.offer(new DeferredSerialization() {\n                    @Override\n                    public BBContainer serialize(final DBBPool pool) {\n                        final BBContainer c = pool.acquire(b.remaining());\n                        assert(c.b.isDirect());\n                        c.b.put(b);\n                        c.b.flip();\n                        return c;\n                    }\n\n                    @Override\n                    public void cancel() {}\n                });\n            } else {\n                updateQueued(b.remaining(), true);\n                m_queuedBuffers.offer(DBBPool.wrapBB(b));\n            }\n            m_port.setInterests( SelectionKey.OP_WRITE, 0);\n        }\n        return true;\n    }","id":72297,"modified_method":"/**\n     * Queue a ByteBuffer for writing to the network. If the ByteBuffer is not direct then it will\n     * be copied to a DirectByteBuffer if it is less then DBBPool.MAX_ALLOCATION_SIZE. This method\n     * is a backup for code that isn't able to defer its serialization to a network thread\n     * for whatever reason. It is reasonably efficient if a DirectByteBuffer is passed in,\n     * but it would be better to keep allocations of DirectByteBuffers inside the network pools.\n     * @param b\n     */\n    @Override\n    public boolean enqueue(final ByteBuffer b) {\n        assert(b != null);\n        assert(!b.isDirect());//Don't queue direct buffers, they leak memory without a container\n        if (b.remaining() == 0) {\n            return false;\n        }\n\n        synchronized (this) {\n            if (m_isShutdown) {\n                return false;\n            }\n\n            updateLastPendingWriteTimeAndQueueBackpressure();\n\n            /*\n             * Attempt to use one of our own pooled direct byte buffers\n             * so that a gathering write can be done later. Java gathering\n             * writes spam direct byte buffers if many regular BBs are used\n             */\n            if (b.remaining() < DBBPool.MAX_ALLOCATION_SIZE){\n                m_queuedWrites.offer(new DeferredSerialization() {\n                    @Override\n                    public BBContainer serialize(final DBBPool pool) {\n                        final BBContainer c = pool.acquire(b.remaining());\n                        assert(c.b.isDirect());\n                        c.b.put(b);\n                        c.b.flip();\n                        return c;\n                    }\n\n                    @Override\n                    public void cancel() {}\n                });\n            } else {\n                updateQueued(b.remaining(), false);\n                m_queuedBuffers.offer(DBBPool.wrapBB(b));\n            }\n            m_port.setInterests( SelectionKey.OP_WRITE, 0);\n        }\n        return true;\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private static void printHelpAndQuit( int code) {\n        System.out.println(\"java -cp <classpath> -Djava.library.path=<library path> org.voltdb.utils.SnapshotConverter --help\");\n        System.out.println(\"java -cp <classpath> -Djava.library.path=<library path> org.voltdb.utils.SnapshotConverter --name full_snapshot_name --dirs dir1[,dir2[,dir3[..]]] \" +\n                \"--tables table1[,table2[,table3[..]]] --type CSV|TSV --outdir dir \");\n        System.exit(code);\n    }","id":72298,"modified_method":"private static void printHelpAndQuit( int code) {\n        System.out.println(\"java -cp <classpath> -Djava.library.path=<library path> org.voltdb.utils.SnapshotConverter --help\");\n        System.out.println(\"java -cp <classpath> -Djava.library.path=<library path> org.voltdb.utils.SnapshotConverter --dir dir1 --dir dir2 --dir dir3\" +\n                \"--table table1 --table table2 --table table3 --type CSV|TSV --outdir dir snapshot_name\");\n        System.exit(code);\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * @param args\n     */\n    public static void main(String[] args) {\n        int ii = 0;\n        String snapshotName = null;\n        File directories[] = null;\n        String tables[] = null;\n        File outdir = null;\n        String type = null;\n        Escaper escaper = null;\n        char delimeter = ' ';\n        for (String arg : args) {\n            if (arg.equals(\"--help\")) {\n                printHelpAndQuit(0);\n            } else if (arg.equals(\"--name\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --name\");\n                    printHelpAndQuit(-1);\n                }\n                snapshotName = args[ii + 1];\n            } else if (arg.equals(\"--dirs\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --dirs\");\n                    printHelpAndQuit(-1);\n                }\n                boolean invalidDir = false;\n                String dirs[] = args[ii + 1].split(\",\");\n                directories = new File[dirs.length];\n                int zz = 0;\n                for (String dir : dirs) {\n                    File f = new File(dir);\n                    if (!f.exists()) {\n                        System.err.println(\"Error: \" + dir + \" does not exist\");\n                        invalidDir = true;\n                    }\n                    if (!f.canRead()) {\n                        System.err.println(\"Error: \" + dir + \" does not have read permission set\");\n                        invalidDir = true;\n                    }\n                    if (!f.canExecute()) {\n                        System.err.println(\"Error: \" + dir + \" does not have execute permission set\");\n                        invalidDir = true;\n                    }\n                    directories[zz++] = f;\n                }\n                if (invalidDir) {\n                    System.exit(-1);\n                }\n            } else if (arg.equals(\"--tables\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --tables\");\n                    printHelpAndQuit(-1);\n                }\n                tables = args[ii + 1].split(\",\");\n                if (tables.length == 0) {\n                    System.err.println(\"Error: No tables specified\");\n                    System.exit(-1);\n                }\n                for (int dd = 0; dd < tables.length; dd++) {\n                    if (tables[dd].isEmpty()) {\n                        System.err.println(\"Error: Empty table name specified\");\n                        System.exit(-1);\n                    }\n                    tables[dd] = tables[dd].toUpperCase();\n                }\n            } else if (arg.equals(\"--outdir\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --outdir\");\n                    printHelpAndQuit(-1);\n                }\n                boolean invalidDir = false;\n                outdir = new File(args[ii + 1]);\n                if (!outdir.exists()) {\n                    System.err.println(\"Error: \" + outdir.getPath() + \" does not exist\");\n                    invalidDir = true;\n                }\n                if (!outdir.canRead()) {\n                    System.err.println(\"Error: \" + outdir.getPath() + \" does not have read permission set\");\n                    invalidDir = true;\n                }\n                if (!outdir.canExecute()) {\n                    System.err.println(\"Error: \" + outdir.getPath() + \" does not have execute permission set\");\n                    invalidDir = true;\n                }\n                if (!outdir.canWrite()) {\n                    System.err.println(\"Error: \" + outdir.getPath() + \" does not have write permission set\");\n                    invalidDir = true;\n                }\n                if (invalidDir) {\n                    System.exit(-1);\n                }\n            }  else if (arg.equals(\"--type\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --type\");\n                    printHelpAndQuit(-1);\n                }\n                type = args[ii + 1];\n                if (type.equalsIgnoreCase(\"csv\")) {\n                    escaper = new CSVEscaper();\n                    delimeter = ',';\n                } else if (type.equalsIgnoreCase(\"tsv\")) {\n                    escaper = new TSVEscaper();\n                    delimeter = '\\t';\n                } else {\n                    System.err.println(\"Error: --type must be one of CSV or TSV\");\n                    printHelpAndQuit(-1);\n                }\n            }\n            ii++;\n        }\n        boolean fail = false;\n        if (snapshotName == null) {\n            System.err.println(\"Error: No --name specified\");\n            fail = true;\n        }\n        if (directories == null) {\n            directories = new File[] { new File(\".\") };\n        }\n        if (tables == null) {\n            System.err.println(\"Error: No --tables specified\");\n            fail = true;\n        }\n        if (outdir == null) {\n            outdir = new File(\".\");\n        }\n        if (type == null) {\n            System.err.println(\"Error: No --type specified\");\n            fail = true;\n        }\n\n        if (fail) {\n            printHelpAndQuit(-1);\n        }\n\n        TreeMap<Long, Snapshot> snapshots = new TreeMap<Long, Snapshot>();\n        SpecificSnapshotFilter filter = new SpecificSnapshotFilter(snapshotName);\n        for (File directory : directories) {\n            SnapshotUtil.retrieveSnapshotFiles( directory, snapshots, filter, 0, false);\n        }\n\n        if (snapshots.size() > 1) {\n            System.err.println(\"Error: Found \" + snapshots.size() + \" snapshots with specified name\");\n            ii = 0;\n            for (Map.Entry<Long, Snapshot> entry : snapshots.entrySet()) {\n                System.err.println(\"Snapshot \" + ii + \" taken \" + new Date(entry.getKey()));\n                System.err.println(\"Files: \");\n                for (File digest : entry.getValue().m_digests) {\n                    System.err.println(\"\\t\" + digest.getPath());\n                }\n                for (Map.Entry<String, TableFiles> e2 : entry.getValue().m_tableFiles.entrySet()) {\n                    System.err.println(\"\\t\" + e2.getKey());\n                    for (File tableFile : e2.getValue().m_files) {\n                        System.err.println(\"\\t\\t\" + tableFile.getPath());\n                    }\n                }\n                ii++;\n            }\n            System.exit(-1);\n        }\n\n        if (snapshots.size() < 1) {\n            System.err.println(\"Error: Did not find any snapshots with the specified name\");\n            System.exit(-1);\n        }\n\n        /*\n         * Build a plan for what partitions to pull from which save file\n         */\n        final Snapshot snapshot = snapshots.values().iterator().next();\n        Map<String, Map<File, Set<Integer>>> tableToFilesWithPartitions =\n            new TreeMap<String, Map<File, Set<Integer>>>();\n        for (String tableName : tables) {\n            if (!snapshot.m_tableFiles.containsKey(tableName)) {\n                System.err.println(\"Error: Snapshot does not contain table \" + tableName);\n                System.exit(-1);\n            }\n            TableFiles tableFiles = snapshot.m_tableFiles.get(tableName);\n\n            if (!tableFiles.m_isReplicated) {\n                TreeSet<Integer> partitionsIds = new TreeSet<Integer>();\n                Map<File, Set<Integer>> partitionsFromFile = new TreeMap<File, Set<Integer>>();\n                for (ii = 0; ii < tableFiles.m_files.size(); ii++) {\n                    Set<Integer> validParititions = tableFiles.m_validPartitionIds.get(ii);\n                    TreeSet<Integer> partitionsToTake = new TreeSet<Integer>(validParititions);\n                    partitionsToTake.removeAll(partitionsIds);\n                    partitionsIds.addAll(validParititions);\n                    if (!partitionsToTake.isEmpty()) {\n                        partitionsFromFile.put(tableFiles.m_files.get(ii), partitionsToTake);\n                    }\n                }\n                int totalPartitionCount = tableFiles.m_totalPartitionCounts.get(0);\n                if (!((partitionsIds.size() == totalPartitionCount) &&\n                        (partitionsIds.first() == 0) &&\n                        (partitionsIds.last() == totalPartitionCount - 1))) {\n                    System.err.println(\"Error: Not all partitions present for table \" + tableName);\n                    fail = true;\n                } else {\n                    tableToFilesWithPartitions.put(tableName, partitionsFromFile);\n                }\n            } else {\n                Map<File, Set<Integer>> partitionsFromFile = new TreeMap<File, Set<Integer>>();\n                partitionsFromFile.put(tableFiles.m_files.get(0), null);\n                tableToFilesWithPartitions.put(tableName, partitionsFromFile);\n            }\n        }\n\n        if (fail) {\n            System.exit(-1);\n        }\n\n        /*\n         * For every output file that will be created attempt to instantiate and print an error\n         * if the file already exists or couldn't be created.\n         */\n        for (Map.Entry<String, Map<File, Set<Integer>>> entry : tableToFilesWithPartitions.entrySet()) {\n            String tableName = entry.getKey();\n            File outfile = new File(outdir.getPath() + File.separator + tableName + \".\" + type.toLowerCase());\n            try {\n                if (!outfile.createNewFile()) {\n                    System.err.println(\"Error: Failed to create output file \"\n                            + outfile.getPath() + \" for table \" + tableName + \"\\n File already exists\");\n                    fail = true;\n                }\n            } catch (IOException e) {\n                System.err.println(e.getMessage());\n                System.err.println(\"Error: Failed to create output file \"\n                        + outfile.getPath() + \" for table \" + tableName);\n                fail = true;\n            }\n        }\n\n        if (fail) {\n            System.exit(-1);\n        }\n\n        /*\n         * Actually convert the tables and write the data to the appropriate destination\n         */\n        for (Map.Entry<String, Map<File, Set<Integer>>> entry : tableToFilesWithPartitions.entrySet()) {\n            String tableName = entry.getKey();\n            File outfile = new File(outdir.getPath() + File.separator + tableName + \".\" + type.toLowerCase());\n\n            Map<File, Set<Integer>> partitionsFromFile = entry.getValue();\n            for (Map.Entry<File, Set<Integer>> e2 : partitionsFromFile.entrySet()) {\n                File infile = e2.getKey();\n                Set<Integer> partitionSet = e2.getValue();\n                int partitions[] = null;\n                if (partitionSet != null) {\n                    partitions = new int[partitionSet.size()];\n                    ii = 0;\n                    for (Integer partition : partitionSet) {\n                        partitions[ii++] = partition;\n                    }\n                }\n                try {\n                    CSVTableSaveFile.convertTableSaveFile(escaper, delimeter, partitions, outfile, infile);\n                } catch (Exception e) {\n                    System.err.println(e.getMessage());\n                    System.err.println(\"Error: Failed to convert \" + infile.getPath() + \" to \" + outfile.getPath());\n                }\n            }\n        }\n\n        if (fail) {\n            System.exit(-1);\n        }\n    }","id":72299,"modified_method":"/**\n     * @param args\n     */\n    public static void main(String[] args) {\n        String snapshotName = null;\n        ArrayList<File> directories = new ArrayList<File>();\n        ArrayList<String> tables = new ArrayList<String>();\n        File outdir = null;\n        String type = null;\n        Escaper escaper = null;\n        char delimeter = ' ';\n        for (int ii = 0; ii < args.length; ii++) {\n            String arg = args[ii];\n            if (arg.equals(\"--help\")) {\n                printHelpAndQuit(0);\n            } else if (arg.equals(\"--dir\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --dirs\");\n                    printHelpAndQuit(-1);\n                }\n                boolean invalidDir = false;\n                String dir = args[ii + 1];\n                ii++;\n                File f = new File(dir);\n                if (!f.exists()) {\n                    System.err.println(\"Error: \" + dir + \" does not exist\");\n                    invalidDir = true;\n                }\n                if (!f.canRead()) {\n                    System.err.println(\"Error: \" + dir + \" does not have read permission set\");\n                    invalidDir = true;\n                }\n                if (!f.canExecute()) {\n                    System.err.println(\"Error: \" + dir + \" does not have execute permission set\");\n                    invalidDir = true;\n                }\n                directories.add(f);\n                if (invalidDir) {\n                    System.exit(-1);\n                }\n            } else if (arg.equals(\"--table\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --tables\");\n                    printHelpAndQuit(-1);\n                }\n                tables.add(args[ii +1].toUpperCase());\n                ii++;\n            } else if (arg.equals(\"--outdir\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --outdir\");\n                    printHelpAndQuit(-1);\n                }\n                boolean invalidDir = false;\n                outdir = new File(args[ii + 1]);\n                if (!outdir.exists()) {\n                    System.err.println(\"Error: \" + outdir.getPath() + \" does not exist\");\n                    invalidDir = true;\n                }\n                if (!outdir.canRead()) {\n                    System.err.println(\"Error: \" + outdir.getPath() + \" does not have read permission set\");\n                    invalidDir = true;\n                }\n                if (!outdir.canExecute()) {\n                    System.err.println(\"Error: \" + outdir.getPath() + \" does not have execute permission set\");\n                    invalidDir = true;\n                }\n                if (!outdir.canWrite()) {\n                    System.err.println(\"Error: \" + outdir.getPath() + \" does not have write permission set\");\n                    invalidDir = true;\n                }\n                if (invalidDir) {\n                    System.exit(-1);\n                }\n                ii++;\n            }  else if (arg.equals(\"--type\")) {\n                if (args.length < ii + 1) {\n                    System.err.println(\"Error: Not enough args following --type\");\n                    printHelpAndQuit(-1);\n                }\n                type = args[ii + 1];\n                if (type.equalsIgnoreCase(\"csv\")) {\n                    escaper = new CSVEscaper();\n                    delimeter = ',';\n                } else if (type.equalsIgnoreCase(\"tsv\")) {\n                    escaper = new TSVEscaper();\n                    delimeter = '\\t';\n                } else {\n                    System.err.println(\"Error: --type must be one of CSV or TSV\");\n                    printHelpAndQuit(-1);\n                }\n                ii++;\n            } else {\n                if (snapshotName != null) {\n                    System.err.println(\"Error: Multiple snapshots specified for conversion. First - \" + snapshotName + \" second \" + args[ii]);\n                    printHelpAndQuit(-1);\n                }\n                snapshotName = args[ii];\n            }\n        }\n        boolean fail = false;\n        if (snapshotName == null) {\n            System.err.println(\"Error: No --name specified\");\n            fail = true;\n        }\n        if (directories.isEmpty()) {\n            directories.add(new File(\".\"));\n        }\n        if (tables.isEmpty()) {\n            System.err.println(\"Error: No --tables specified\");\n            fail = true;\n        }\n        if (outdir == null) {\n            outdir = new File(\".\");\n        }\n        if (type == null) {\n            System.err.println(\"Error: No --type specified\");\n            fail = true;\n        }\n\n        if (fail) {\n            printHelpAndQuit(-1);\n        }\n\n        TreeMap<Long, Snapshot> snapshots = new TreeMap<Long, Snapshot>();\n        HashSet<String> snapshotNames = new HashSet<String>();\n        snapshotNames.add(snapshotName);\n        SpecificSnapshotFilter filter = new SpecificSnapshotFilter(snapshotNames);\n        for (File directory : directories) {\n            SnapshotUtil.retrieveSnapshotFiles( directory, snapshots, filter, 0, false);\n        }\n\n        if (snapshots.size() > 1) {\n            System.err.println(\"Error: Found \" + snapshots.size() + \" snapshots with specified name\");\n            int ii = 0;\n            for (Map.Entry<Long, Snapshot> entry : snapshots.entrySet()) {\n                System.err.println(\"Snapshot \" + ii + \" taken \" + new Date(entry.getKey()));\n                System.err.println(\"Files: \");\n                for (File digest : entry.getValue().m_digests) {\n                    System.err.println(\"\\t\" + digest.getPath());\n                }\n                for (Map.Entry<String, TableFiles> e2 : entry.getValue().m_tableFiles.entrySet()) {\n                    System.err.println(\"\\t\" + e2.getKey());\n                    for (File tableFile : e2.getValue().m_files) {\n                        System.err.println(\"\\t\\t\" + tableFile.getPath());\n                    }\n                }\n                ii++;\n            }\n            System.exit(-1);\n        }\n\n        if (snapshots.size() < 1) {\n            System.err.println(\"Error: Did not find any snapshots with the specified name\");\n            System.exit(-1);\n        }\n\n        /*\n         * Build a plan for what partitions to pull from which save file\n         */\n        final Snapshot snapshot = snapshots.values().iterator().next();\n        Map<String, Map<File, Set<Integer>>> tableToFilesWithPartitions =\n            new TreeMap<String, Map<File, Set<Integer>>>();\n        for (String tableName : tables) {\n            if (!snapshot.m_tableFiles.containsKey(tableName)) {\n                System.err.println(\"Error: Snapshot does not contain table \" + tableName);\n                System.exit(-1);\n            }\n            TableFiles tableFiles = snapshot.m_tableFiles.get(tableName);\n\n            if (!tableFiles.m_isReplicated) {\n                TreeSet<Integer> partitionsIds = new TreeSet<Integer>();\n                Map<File, Set<Integer>> partitionsFromFile = new TreeMap<File, Set<Integer>>();\n                for (int ii = 0; ii < tableFiles.m_files.size(); ii++) {\n                    Set<Integer> validParititions = tableFiles.m_validPartitionIds.get(ii);\n                    TreeSet<Integer> partitionsToTake = new TreeSet<Integer>(validParititions);\n                    partitionsToTake.removeAll(partitionsIds);\n                    partitionsIds.addAll(validParititions);\n                    if (!partitionsToTake.isEmpty()) {\n                        partitionsFromFile.put(tableFiles.m_files.get(ii), partitionsToTake);\n                    }\n                }\n                int totalPartitionCount = tableFiles.m_totalPartitionCounts.get(0);\n                if (!((partitionsIds.size() == totalPartitionCount) &&\n                        (partitionsIds.first() == 0) &&\n                        (partitionsIds.last() == totalPartitionCount - 1))) {\n                    System.err.println(\"Error: Not all partitions present for table \" + tableName);\n                    fail = true;\n                } else {\n                    tableToFilesWithPartitions.put(tableName, partitionsFromFile);\n                }\n            } else {\n                Map<File, Set<Integer>> partitionsFromFile = new TreeMap<File, Set<Integer>>();\n                partitionsFromFile.put(tableFiles.m_files.get(0), null);\n                tableToFilesWithPartitions.put(tableName, partitionsFromFile);\n            }\n        }\n\n        if (fail) {\n            System.exit(-1);\n        }\n\n        /*\n         * For every output file that will be created attempt to instantiate and print an error\n         * if the file already exists or couldn't be created.\n         */\n        for (Map.Entry<String, Map<File, Set<Integer>>> entry : tableToFilesWithPartitions.entrySet()) {\n            String tableName = entry.getKey();\n            File outfile = new File(outdir.getPath() + File.separator + tableName + \".\" + type.toLowerCase());\n            try {\n                if (!outfile.createNewFile()) {\n                    System.err.println(\"Error: Failed to create output file \"\n                            + outfile.getPath() + \" for table \" + tableName + \"\\n File already exists\");\n                    fail = true;\n                }\n            } catch (IOException e) {\n                System.err.println(e.getMessage());\n                System.err.println(\"Error: Failed to create output file \"\n                        + outfile.getPath() + \" for table \" + tableName);\n                fail = true;\n            }\n        }\n\n        if (fail) {\n            System.exit(-1);\n        }\n\n        /*\n         * Actually convert the tables and write the data to the appropriate destination\n         */\n        for (Map.Entry<String, Map<File, Set<Integer>>> entry : tableToFilesWithPartitions.entrySet()) {\n            String tableName = entry.getKey();\n            File outfile = new File(outdir.getPath() + File.separator + tableName + \".\" + type.toLowerCase());\n\n            Map<File, Set<Integer>> partitionsFromFile = entry.getValue();\n            for (Map.Entry<File, Set<Integer>> e2 : partitionsFromFile.entrySet()) {\n                File infile = e2.getKey();\n                Set<Integer> partitionSet = e2.getValue();\n                int partitions[] = null;\n                if (partitionSet != null) {\n                    partitions = new int[partitionSet.size()];\n                    int ii = 0;\n                    for (Integer partition : partitionSet) {\n                        partitions[ii++] = partition;\n                    }\n                }\n                try {\n                    CSVTableSaveFile.convertTableSaveFile(escaper, delimeter, partitions, outfile, infile);\n                } catch (Exception e) {\n                    System.err.println(e.getMessage());\n                    System.err.println(\"Error: Failed to convert \" + infile.getPath() + \" to \" + outfile.getPath());\n                }\n            }\n        }\n\n        if (fail) {\n            System.exit(-1);\n        }\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public SpecificSnapshotFilter(String snapshotName) {\n            this.snapshotName = snapshotName;\n        }","id":72300,"modified_method":"public SpecificSnapshotFilter(Set<String> snapshotNames) {\n            this.snapshotNames = snapshotNames;\n        }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public boolean accept(File pathname) {\n            if (!super.accept(pathname)) {\n                return false;\n            }\n\n            if (pathname.isDirectory()) {\n                return true;\n            }\n\n            if (pathname.getName().startsWith(snapshotName + \"-\") ||\n                    pathname.getName().equals(snapshotName + \".digest\")) {\n                return true;\n            }\n\n            return false;\n        }","id":72301,"modified_method":"@Override\n        public boolean accept(File pathname) {\n            if (!super.accept(pathname)) {\n                return false;\n            }\n\n            if (pathname.isDirectory()) {\n                return true;\n            }\n\n            for (String snapshotName : snapshotNames) {\n                if (pathname.getName().startsWith(snapshotName + \"-\") ||\n                        pathname.getName().equals(snapshotName + \".digest\")) {\n                    return true;\n                }\n            }\n\n            return false;\n        }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private static void printHelpAndQuit( int code) {\n        System.out.println(\"Usage\\nSpecific snapshot: java -cp <classpath> -Djava.library.path=<library path> org.voltdb.utils.SnapshotVerifier --name snapshot_name --dirs dir1[,dir2[,dir3[..]]] \");\n        System.out.println(\"All snapshots: java -cp <classpath> -Djava.library.path=<library path> org.voltdb.utils.SnapshotVerifier --dirs dir1[,dir2[,dir3[..]]] \");\n        System.exit(code);\n    }","id":72302,"modified_method":"private static void printHelpAndQuit( int code) {\n        System.out.println(\"Usage\\nSpecific snapshot: java -cp <classpath> -Djava.library.path=<library path> org.voltdb.utils.SnapshotVerifier snapshot_name --dir dir1 --dir dir2 --dir dir3\");\n        System.out.println(\"All snapshots: java -cp <classpath> -Djava.library.path=<library path> org.voltdb.utils.SnapshotVerifier --dir dir1 --dir dir2 --dir dir3\");\n        System.exit(code);\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String args[]) {\n        if (args.length == 0) {\n            //printHelpAndQuit(0);\n        } else if (args[0].equals(\"--help\")) {\n            printHelpAndQuit(0);\n        }\n\n        FileFilter filter = new SnapshotFilter();\n        boolean specifiedSingle = false;\n        String snapshotName = null;\n        for (int ii = 0; ii < args.length; ii++) {\n            if (args[ii].equals(\"--name\")) {\n                specifiedSingle = true;\n                if (ii + 1 >= args.length) {\n                    System.err.println(\"Error: No snapshot name specified after --name\");\n                    printHelpAndQuit(-1);\n                }\n                snapshotName = args[ii + 1];\n                break;\n            }\n        }\n\n        if (specifiedSingle) {\n            filter = new SpecificSnapshotFilter(snapshotName);\n        }\n\n        List<String> directories = null;\n        for (int ii = 0; ii < args.length; ii++) {\n            if (args[ii].equals(\"--dirs\")) {\n                if (ii + 1 >= args.length) {\n                    System.err.println(\"Error: No directories specified after --dirs\");\n                    printHelpAndQuit(-1);\n                    break;\n                }\n                directories = Arrays.asList(args[ii + 1].split(\",\"));\n            }\n        }\n        if (directories == null) {\n            directories = new ArrayList<String>();\n            directories.add(\".\");\n        }\n\n        TreeMap<Long, Snapshot> snapshots = new TreeMap<Long, Snapshot>();\n        for (String directory : directories) {\n            SnapshotUtil.retrieveSnapshotFiles( new File(directory), snapshots, filter, 0, true);\n        }\n\n        if (snapshots.isEmpty()) {\n            System.out.println(\"Snapshot corrupted\");\n            System.out.println(\"No files found\");\n        }\n        for (Map.Entry<Long, Snapshot> s : snapshots.entrySet()) {\n            System.out.println(SnapshotUtil.generateSnapshotReport(s.getKey(), s.getValue()).getSecond());\n        }\n    }","id":72303,"modified_method":"public static void main(String args[]) {\n        if (args.length == 0) {\n            //printHelpAndQuit(0);\n        } else if (args[0].equals(\"--help\")) {\n            printHelpAndQuit(0);\n        }\n\n        FileFilter filter = new SnapshotFilter();\n        boolean specifiedSingle = false;\n        HashSet<String> snapshotNames = new HashSet<String>();\n        for (int ii = 0; ii < args.length; ii++) {\n            if (args[ii].equals(\"--dirs\")) {\n                ii++;\n                continue;\n            }\n            specifiedSingle = true;\n            snapshotNames.add(args[ii]);\n        }\n\n        if (specifiedSingle) {\n            filter = new SpecificSnapshotFilter(snapshotNames);\n        }\n\n        List<String> directories = new ArrayList<String>();\n        for (int ii = 0; ii < args.length; ii++) {\n            if (args[ii].equals(\"--dir\")) {\n                if (ii + 1 >= args.length) {\n                    System.err.println(\"Error: No directories specified after --dir\");\n                    printHelpAndQuit(-1);\n                    break;\n                }\n                directories.add(args[ii + 1]);\n                ii++;\n            }\n        }\n        if (directories.isEmpty()) {\n            directories.add(\".\");\n        }\n\n        TreeMap<Long, Snapshot> snapshots = new TreeMap<Long, Snapshot>();\n        for (String directory : directories) {\n            SnapshotUtil.retrieveSnapshotFiles( new File(directory), snapshots, filter, 0, true);\n        }\n\n        if (snapshots.isEmpty()) {\n            System.out.println(\"Snapshot corrupted\");\n            System.out.println(\"No files found\");\n        }\n        for (Map.Entry<Long, Snapshot> s : snapshots.entrySet()) {\n            System.out.println(SnapshotUtil.generateSnapshotReport(s.getKey(), s.getValue()).getSecond());\n        }\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void validateSnapshot(boolean expectSuccess) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        PrintStream ps = new PrintStream(baos);\n        PrintStream original = System.out;\n        try {\n            System.setOut(ps);\n            String args[] = new String[] {\n                    \"--single\",\n                    \"--name\",\n                    TESTNONCE,\n                    \"--dirs\",\n                    TMPDIR\n            };\n            SnapshotVerifier.main(args);\n            ps.flush();\n            String reportString = baos.toString(\"UTF-8\");\n            if (expectSuccess) {\n                assertTrue(reportString.startsWith(\"Snapshot valid\\n\"));\n            } else {\n                assertTrue(reportString.startsWith(\"Snapshot corrupted\\n\"));\n            }\n        } catch (UnsupportedEncodingException e) {}\n          finally {\n            System.setOut(original);\n        }\n    }","id":72304,"modified_method":"private void validateSnapshot(boolean expectSuccess) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        PrintStream ps = new PrintStream(baos);\n        PrintStream original = System.out;\n        try {\n            System.setOut(ps);\n            String args[] = new String[] {\n                    TESTNONCE,\n                    \"--dir\",\n                    TMPDIR\n            };\n            SnapshotVerifier.main(args);\n            ps.flush();\n            String reportString = baos.toString(\"UTF-8\");\n            if (expectSuccess) {\n                assertTrue(reportString.startsWith(\"Snapshot valid\\n\"));\n            } else {\n                assertTrue(reportString.startsWith(\"Snapshot corrupted\\n\"));\n            }\n        } catch (UnsupportedEncodingException e) {}\n          finally {\n            System.setOut(original);\n        }\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void generateAndValidateTextFile(StringBuilder expectedText, boolean csv) throws Exception {\n        String args[] = new String[] {\n                \"--name\",\n                TESTNONCE,\n               \"--dirs\",\n               TMPDIR,\n               \"--tables\",\n               \"REPLICATED_TESTER\",\n               \"--type\",\n               csv ? \"CSV\" : \"TSV\",\n               \"--outdir\",\n               TMPDIR\n        };\n        SnapshotConverter.main(args);\n        FileInputStream fis = new FileInputStream(\n                TMPDIR + File.separator + \"REPLICATED_TESTER\" + (csv ? \".csv\" : \".tsv\"));\n        try {\n            int filesize = (int)fis.getChannel().size();\n            ByteBuffer expectedBytes = ByteBuffer.wrap(expectedText.toString().getBytes(\"UTF-8\"));\n            ByteBuffer readBytes = ByteBuffer.allocate(filesize);\n            while (readBytes.hasRemaining()) {\n                int read = fis.getChannel().read(readBytes);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            // this throws an exception on failure\n            new String(readBytes.array(), \"UTF-8\");\n\n            readBytes.flip();\n            assertTrue(expectedBytes.equals(readBytes));\n        } finally {\n            fis.close();\n        }\n    }","id":72305,"modified_method":"private void generateAndValidateTextFile(StringBuilder expectedText, boolean csv) throws Exception {\n        String args[] = new String[] {\n                TESTNONCE,\n               \"--dir\",\n               TMPDIR,\n               \"--table\",\n               \"REPLICATED_TESTER\",\n               \"--type\",\n               csv ? \"CSV\" : \"TSV\",\n               \"--outdir\",\n               TMPDIR\n        };\n        SnapshotConverter.main(args);\n        FileInputStream fis = new FileInputStream(\n                TMPDIR + File.separator + \"REPLICATED_TESTER\" + (csv ? \".csv\" : \".tsv\"));\n        try {\n            int filesize = (int)fis.getChannel().size();\n            ByteBuffer expectedBytes = ByteBuffer.wrap(expectedText.toString().getBytes(\"UTF-8\"));\n            ByteBuffer readBytes = ByteBuffer.allocate(filesize);\n            while (readBytes.hasRemaining()) {\n                int read = fis.getChannel().read(readBytes);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            // this throws an exception on failure\n            new String(readBytes.array(), \"UTF-8\");\n\n            readBytes.flip();\n            assertTrue(expectedBytes.equals(readBytes));\n        } finally {\n            fis.close();\n        }\n    }","commit_id":"ff7cc69d0f119dd9d4db86f60683b6a82d445fde","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void visitCode(Code obj) {\n\t\tcatchList = new ArrayList<CaughtException>();\n\t\tthrowList = new ArrayList<ThrownException>();\n\t\tstack = new OpcodeStack();\n\n\t\tsuper.visitCode(obj);\n\n\t\tfor (Iterator iterator = catchList.iterator(); iterator.hasNext();) {\n\t\t\tCaughtException caughtException = (CaughtException) iterator.next();\n\t\t\tfor (Iterator iterator1 = throwList.iterator(); iterator1.hasNext();) {\n\t\t\t\tThrownException thrownException = (ThrownException) iterator1.next();\n\t\t\t\tif (thrownException.exceptionClass.equals(caughtException.exceptionClass)\n\t\t\t\t\t\t&& thrownException.offset >= caughtException.startOffset\n\t\t\t\t        && thrownException.offset < caughtException.endOffset) {\n\t\t\t\t\tcaughtException.seen = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (caughtException.exceptionClass.equals(\"java.lang.Exception\") && !caughtException.seen) {\n\t\t\t\t// Now we have a case where Exception is caught, but not thrown\n\t\t\t\tboolean rteCaught = false;\n\t\t\t\tfor (Iterator iterator1 = catchList.iterator(); iterator1.hasNext();) {\n\t\t\t\t\tCaughtException otherException = (CaughtException) iterator1.next();\n\t\t\t\t\tif (otherException.exceptionClass.equals(\"java.lang.RuntimeException\")\n\t\t\t\t\t        && otherException.startOffset == caughtException.startOffset\n\t\t\t\t\t\t\t&& otherException.endOffset == caughtException.endOffset) {\n\t\t\t\t\t\trteCaught = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint range = caughtException.endOffset - caughtException.startOffset;\n\t\t\t\tif (!rteCaught && range > 80) {\n\t\t\t\t\tint priority = range > 300 ? NORMAL_PRIORITY : LOW_PRIORITY;\n\t\t\t\t\tif (caughtException.dead) {\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"*** Boosting priority because of dead exception store\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpriority = (priority > 0) ? priority - 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"REC_CATCH_EXCEPTION\", priority)\n\t\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t\t        .addSourceLine(this, caughtException.sourcePC));\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":72306,"modified_method":"public void visitCode(Code obj) {\n\t\tcatchList = new ArrayList<CaughtException>();\n\t\tthrowList = new ArrayList<ThrownException>();\n\t\tstack = new OpcodeStack();\n\n\t\tsuper.visitCode(obj);\n\n\t\tfor (Iterator iterator = catchList.iterator(); iterator.hasNext();) {\n\t\t\tCaughtException caughtException = (CaughtException) iterator.next();\n\t\t\tSet<String> thrownSet = new HashSet<String>();\n\t\t\tfor (Iterator iterator1 = throwList.iterator(); iterator1.hasNext();) {\n\t\t\t\tThrownException thrownException = (ThrownException) iterator1.next();\n\t\t\t\tif (thrownException.offset >= caughtException.startOffset\n\t\t\t\t        && thrownException.offset < caughtException.endOffset) {\n\t\t\t\t    thrownSet.add(thrownException.exceptionClass);\n\t\t\t\t    if (thrownException.exceptionClass.equals(caughtException.exceptionClass))\n\t\t\t\t\tcaughtException.seen = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint catchClauses = 0;\n\t\t\tif (caughtException.exceptionClass.equals(\"java.lang.Exception\") && !caughtException.seen) {\n\t\t\t\t// Now we have a case where Exception is caught, but not thrown\n\t\t\t\tboolean rteCaught = false;\n\t\t\t\tfor (Iterator iterator1 = catchList.iterator(); iterator1.hasNext();) {\n\t\t\t\t\tCaughtException otherException = (CaughtException) iterator1.next();\n\t\t\t\t\tif (otherException.startOffset == caughtException.startOffset\n\t\t\t\t\t\t&& otherException.endOffset == caughtException.endOffset) {\n\t\t\t\t\t   catchClauses++;\n\t\t\t\t\t   if (otherException.exceptionClass.equals(\"java.lang.RuntimeException\"))\n\t\t\t\t\t\trteCaught = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint range = caughtException.endOffset - caughtException.startOffset;\n\t\t\t\tif (!rteCaught) {\n\t\t\t\t\tint priority = LOW_PRIORITY+1;\n\t\t\t\t\tif (range > 300) priority--;\n\t\t\t\t\telse if (range < 30) priority++;\n\t\t\t\t\tif (catchClauses > 1) priority++;\n\t\t\t\t\tif (thrownSet.size() > 1) priority--;\n\t\t\t\t\tif (caughtException.dead) priority--;\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"REC_CATCH_EXCEPTION\", \n\t\t\t\t\t\t\tpriority)\n\t\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t\t        .addSourceLine(this, caughtException.sourcePC));\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"81cf4ba2fb579d79d4a2346a8f979396ca8761e1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void setTextureFilters (TextureFilter min, TextureFilter mag) {\n\t\tfor (Texture texture : trackedTextures) {\n\t\t\ttexture.setFilter(min, mag);\n\t\t}\n\t}","id":72307,"modified_method":"private void setTextureFilters (TextureFilter min, TextureFilter mag) {\n\t\tfor (Texture texture : trackedTextures) {\n\t\t\ttexture.setFilter(min, mag);\n\t\t}\n\t\ttrackedTextures.clear();\n\t}","commit_id":"150a54bc07ff26754040ba7bbee6ec836c1f63d9","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void loadAsync (AssetManager manager, String fileName, FileHandle tmxFile, AtlasTiledMapLoaderParameters parameter) {\n\t\tmap = null;\n\n\t\tif (parameter != null) {\n\t\t\tconvertObjectToTileSpace = parameter.convertObjectToTileSpace;\n\t\t} else {\n\t\t\tconvertObjectToTileSpace = false;\n\t\t}\n\n\t\ttry {\n\t\t\tmap = loadMap(root, tmxFile, new AtlasResolver.AssetManagerAtlasResolver(manager), parameter);\n\t\t} catch (Exception e) {\n\t\t\tthrow new GdxRuntimeException(\"Couldn't load tilemap '\" + fileName + \"'\", e);\n\t\t}\n\t}","id":72308,"modified_method":"@Override\n\tpublic void loadAsync (AssetManager manager, String fileName, FileHandle tmxFile, AtlasTiledMapLoaderParameters parameter) {\n\t\tmap = null;\n\n\t\tif (parameter != null) {\n\t\t\tconvertObjectToTileSpace = parameter.convertObjectToTileSpace;\n\t\t} else {\n\t\t\tconvertObjectToTileSpace = false;\n\t\t}\n\n\t\ttry {\n\t\t\tmap = loadMap(root, tmxFile, new AtlasResolver.AssetManagerAtlasResolver(manager));\n\t\t} catch (Exception e) {\n\t\t\tthrow new GdxRuntimeException(\"Couldn't load tilemap '\" + fileName + \"'\", e);\n\t\t}\n\t}","commit_id":"150a54bc07ff26754040ba7bbee6ec836c1f63d9","url":"https://github.com/libgdx/libgdx"},{"original_method":"public TiledMap load (String fileName, AtlasTiledMapLoaderParameters parameter) {\n\t\ttry {\n\t\t\tif (parameter != null) {\n\t\t\t\tconvertObjectToTileSpace = parameter.convertObjectToTileSpace;\n\t\t\t} else {\n\t\t\t\tconvertObjectToTileSpace = false;\n\t\t\t}\n\n\t\t\tFileHandle tmxFile = resolve(fileName);\n\t\t\troot = xml.parse(tmxFile);\n\t\t\tObjectMap<String, TextureAtlas> atlases = new ObjectMap<String, TextureAtlas>();\n\t\t\tFileHandle atlasFile = loadAtlas(root, tmxFile);\n\t\t\tif (atlasFile == null) {\n\t\t\t\tthrow new GdxRuntimeException(\"Couldn't load atlas\");\n\t\t\t}\n\n\t\t\tTextureAtlas atlas = new TextureAtlas(atlasFile);\n\t\t\tatlases.put(atlasFile.path(), atlas);\n\n\t\t\tAtlasResolver.DirectAtlasResolver atlasResolver = new AtlasResolver.DirectAtlasResolver(atlases);\n\t\t\tTiledMap map = loadMap(root, tmxFile, atlasResolver, parameter);\n\t\t\tmap.setOwnedResources(atlases.values().toArray());\n\t\t\tsetTextureFilters(parameter.textureMinFilter, parameter.textureMagFilter);\n\n\t\t\treturn map;\n\t\t} catch (IOException e) {\n\t\t\tthrow new GdxRuntimeException(\"Couldn't load tilemap '\" + fileName + \"'\", e);\n\t\t}\n\t}","id":72309,"modified_method":"public TiledMap load (String fileName, AtlasTiledMapLoaderParameters parameter) {\n\t\ttry {\n\t\t\tif (parameter != null) {\n\t\t\t\tconvertObjectToTileSpace = parameter.convertObjectToTileSpace;\n\t\t\t} else {\n\t\t\t\tconvertObjectToTileSpace = false;\n\t\t\t}\n\n\t\t\tFileHandle tmxFile = resolve(fileName);\n\t\t\troot = xml.parse(tmxFile);\n\t\t\tObjectMap<String, TextureAtlas> atlases = new ObjectMap<String, TextureAtlas>();\n\t\t\tFileHandle atlasFile = loadAtlas(root, tmxFile);\n\t\t\tif (atlasFile == null) {\n\t\t\t\tthrow new GdxRuntimeException(\"Couldn't load atlas\");\n\t\t\t}\n\n\t\t\tTextureAtlas atlas = new TextureAtlas(atlasFile);\n\t\t\tatlases.put(atlasFile.path(), atlas);\n\n\t\t\tAtlasResolver.DirectAtlasResolver atlasResolver = new AtlasResolver.DirectAtlasResolver(atlases);\n\t\t\tTiledMap map = loadMap(root, tmxFile, atlasResolver);\n\t\t\tmap.setOwnedResources(atlases.values().toArray());\n\t\t\tsetTextureFilters(parameter.textureMinFilter, parameter.textureMagFilter);\n\t\t\treturn map;\n\t\t} catch (IOException e) {\n\t\t\tthrow new GdxRuntimeException(\"Couldn't load tilemap '\" + fileName + \"'\", e);\n\t\t}\n\t}","commit_id":"150a54bc07ff26754040ba7bbee6ec836c1f63d9","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** May return null. */\n\tprotected FileHandle loadAtlas (Element root, FileHandle tmxFile) throws IOException {\n\t\tElement e = root.getChildByName(\"properties\");\n\n\t\tif (e != null) {\n\t\t\tfor (Element property : e.getChildrenByName(\"property\")) {\n\t\t\t\tString name = property.getAttribute(\"name\", null);\n\t\t\t\tString value = property.getAttribute(\"value\", null);\n\t\t\t\tif (name.equals(\"atlas\")) {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\tvalue = property.getText();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (value == null || value.length() == 0) {\n\t\t\t\t\t\t// keep trying until there are no more atlas properties\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn getRelativeFileHandle(tmxFile, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tFileHandle atlasFile = tmxFile.sibling(tmxFile.nameWithoutExtension() + \".atlas\");\n\t\t\treturn atlasFile.exists() ? atlasFile : null;\n\t\t}\n\n\t\treturn null;\n\t}","id":72310,"modified_method":"/** May return null. */\n\tprotected FileHandle loadAtlas (Element root, FileHandle tmxFile) throws IOException {\n\t\tElement e = root.getChildByName(\"properties\");\n\n\t\tif (e != null) {\n\t\t\tfor (Element property : e.getChildrenByName(\"property\")) {\n\t\t\t\tString name = property.getAttribute(\"name\", null);\n\t\t\t\tString value = property.getAttribute(\"value\", null);\n\t\t\t\tif (name.equals(\"atlas\")) {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\tvalue = property.getText();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (value == null || value.length() == 0) {\n\t\t\t\t\t\t// keep trying until there are no more atlas properties\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn getRelativeFileHandle(tmxFile, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFileHandle atlasFile = tmxFile.sibling(tmxFile.nameWithoutExtension() + \".atlas\");\n\t\treturn atlasFile.exists() ? atlasFile : null;\n\t}","commit_id":"150a54bc07ff26754040ba7bbee6ec836c1f63d9","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void loadTileset (TiledMap map, Element element, FileHandle tmxFile, AtlasResolver resolver,\n\t\tAtlasTiledMapLoaderParameters parameter) {\n\t\tif (element.getName().equals(\"tileset\")) {\n\t\t\tString name = element.get(\"name\", null);\n\t\t\tint firstgid = element.getIntAttribute(\"firstgid\", 1);\n\t\t\tint tilewidth = element.getIntAttribute(\"tilewidth\", 0);\n\t\t\tint tileheight = element.getIntAttribute(\"tileheight\", 0);\n\t\t\tint spacing = element.getIntAttribute(\"spacing\", 0);\n\t\t\tint margin = element.getIntAttribute(\"margin\", 0);\n\t\t\tString source = element.getAttribute(\"source\", null);\n\n\t\t\tint offsetX = 0;\n\t\t\tint offsetY = 0;\n\n\t\t\tString imageSource = \"\";\n\t\t\tint imageWidth = 0, imageHeight = 0;\n\n\t\t\tFileHandle image = null;\n\t\t\tif (source != null) {\n\t\t\t\tFileHandle tsx = getRelativeFileHandle(tmxFile, source);\n\t\t\t\ttry {\n\t\t\t\t\telement = xml.parse(tsx);\n\t\t\t\t\tname = element.get(\"name\", null);\n\t\t\t\t\ttilewidth = element.getIntAttribute(\"tilewidth\", 0);\n\t\t\t\t\ttileheight = element.getIntAttribute(\"tileheight\", 0);\n\t\t\t\t\tspacing = element.getIntAttribute(\"spacing\", 0);\n\t\t\t\t\tmargin = element.getIntAttribute(\"margin\", 0);\n\t\t\t\t\tElement offset = element.getChildByName(\"tileoffset\");\n\t\t\t\t\tif (offset != null) {\n\t\t\t\t\t\toffsetX = offset.getIntAttribute(\"x\", 0);\n\t\t\t\t\t\toffsetY = offset.getIntAttribute(\"y\", 0);\n\t\t\t\t\t}\n\t\t\t\t\tElement imageElement = element.getChildByName(\"image\");\n\t\t\t\t\timageSource = imageElement.getAttribute(\"source\");\n\t\t\t\t\timageWidth = imageElement.getIntAttribute(\"width\", 0);\n\t\t\t\t\timageHeight = imageElement.getIntAttribute(\"height\", 0);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new GdxRuntimeException(\"Error parsing external tileset.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tElement offset = element.getChildByName(\"tileoffset\");\n\t\t\t\tif (offset != null) {\n\t\t\t\t\toffsetX = offset.getIntAttribute(\"x\", 0);\n\t\t\t\t\toffsetY = offset.getIntAttribute(\"y\", 0);\n\t\t\t\t}\n\t\t\t\tElement imageElement = element.getChildByName(\"image\");\n\t\t\t\tif (imageElement != null) {\n\t\t\t\t\timageSource = imageElement.getAttribute(\"source\");\n\t\t\t\t\timageWidth = imageElement.getIntAttribute(\"width\", 0);\n\t\t\t\t\timageHeight = imageElement.getIntAttribute(\"height\", 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString atlasFilePath = map.getProperties().get(\"atlas\", String.class);\n\t\t\tif (atlasFilePath == null) {\n\t\t\t\tFileHandle atlasFile = tmxFile.sibling(tmxFile.nameWithoutExtension() + \".atlas\");\n\t\t\t\tif (atlasFile.exists()) atlasFilePath = atlasFile.name();\n\t\t\t}\n\t\t\tif (atlasFilePath == null) {\n\t\t\t\tthrow new GdxRuntimeException(\"The map is missing the 'atlas' property\");\n\t\t\t}\n\n\t\t\t// get the TextureAtlas for this tileset\n\t\t\tFileHandle atlasHandle = getRelativeFileHandle(tmxFile, atlasFilePath);\n\t\t\tatlasHandle = resolve(atlasHandle.path());\n\t\t\tTextureAtlas atlas = resolver.getAtlas(atlasHandle.path());\n\t\t\tString regionsName = atlasHandle.nameWithoutExtension();\n\n\t\t\tif (parameter != null && parameter.forceTextureFilters) {\n\t\t\t\tfor (Texture texture : atlas.getTextures()) {\n\t\t\t\t\ttrackedTextures.add(texture);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTiledMapTileSet tileset = new TiledMapTileSet();\n\t\t\tMapProperties props = tileset.getProperties();\n\t\t\ttileset.setName(name);\n\t\t\tprops.put(\"firstgid\", firstgid);\n\t\t\tprops.put(\"imagesource\", imageSource);\n\t\t\tprops.put(\"imagewidth\", imageWidth);\n\t\t\tprops.put(\"imageheight\", imageHeight);\n\t\t\tprops.put(\"tilewidth\", tilewidth);\n\t\t\tprops.put(\"tileheight\", tileheight);\n\t\t\tprops.put(\"margin\", margin);\n\t\t\tprops.put(\"spacing\", spacing);\n\n\t\t\tfor (AtlasRegion region : atlas.findRegions(regionsName)) {\n\t\t\t\t// handle unused tile ids\n\t\t\t\tif (region != null) {\n\t\t\t\t\tStaticTiledMapTile tile = new StaticTiledMapTile(region);\n\t\t\t\t\tint tileid = firstgid + region.index;\n\t\t\t\t\ttile.setId(tileid);\n\t\t\t\t\ttile.setOffsetX(offsetX);\n\t\t\t\t\ttile.setOffsetY(-offsetY);\n\t\t\t\t\ttileset.putTile(tileid, tile);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Element tileElement : element.getChildrenByName(\"tile\")) {\n\t\t\t\tint tileid = firstgid + tileElement.getIntAttribute(\"id\", 0);\n\t\t\t\tTiledMapTile tile = tileset.getTile(tileid);\n\t\t\t\tif (tile == null) {\n\t\t\t\t\tElement imageElement = tileElement.getChildByName(\"image\");\n\t\t\t\t\tif (imageElement != null) {\n\t\t\t\t\t\t// Is a tilemap with individual images.\n\t\t\t\t\t\tString regionName = imageElement.getAttribute(\"source\");\n\t\t\t\t\t\tregionName = regionName.substring(0, regionName.lastIndexOf('.'));\n\t\t\t\t\t\tAtlasRegion region = atlas.findRegion(regionName);\n\t\t\t\t\t\tif (region == null) throw new GdxRuntimeException(\"Tileset region not found: \" + regionName);\n\t\t\t\t\t\ttile = new StaticTiledMapTile(region);\n\t\t\t\t\t\ttile.setId(tileid);\n\t\t\t\t\t\ttile.setOffsetX(offsetX);\n\t\t\t\t\t\ttile.setOffsetY(-offsetY);\n\t\t\t\t\t\ttileset.putTile(tileid, tile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tile != null) {\n\t\t\t\t\tString terrain = tileElement.getAttribute(\"terrain\", null);\n\t\t\t\t\tif (terrain != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"terrain\", terrain);\n\t\t\t\t\t}\n\t\t\t\t\tString probability = tileElement.getAttribute(\"probability\", null);\n\t\t\t\t\tif (probability != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"probability\", probability);\n\t\t\t\t\t}\n\t\t\t\t\tElement properties = tileElement.getChildByName(\"properties\");\n\t\t\t\t\tif (properties != null) {\n\t\t\t\t\t\tloadProperties(tile.getProperties(), properties);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tElement properties = element.getChildByName(\"properties\");\n\t\t\tif (properties != null) {\n\t\t\t\tloadProperties(tileset.getProperties(), properties);\n\t\t\t}\n\t\t\tmap.getTileSets().addTileSet(tileset);\n\t\t}\n\t}","id":72311,"modified_method":"protected void loadTileset (TiledMap map, Element element, FileHandle tmxFile, AtlasResolver resolver) {\n\t\tif (element.getName().equals(\"tileset\")) {\n\t\t\tString name = element.get(\"name\", null);\n\t\t\tint firstgid = element.getIntAttribute(\"firstgid\", 1);\n\t\t\tint tilewidth = element.getIntAttribute(\"tilewidth\", 0);\n\t\t\tint tileheight = element.getIntAttribute(\"tileheight\", 0);\n\t\t\tint spacing = element.getIntAttribute(\"spacing\", 0);\n\t\t\tint margin = element.getIntAttribute(\"margin\", 0);\n\t\t\tString source = element.getAttribute(\"source\", null);\n\n\t\t\tint offsetX = 0;\n\t\t\tint offsetY = 0;\n\n\t\t\tString imageSource = \"\";\n\t\t\tint imageWidth = 0, imageHeight = 0;\n\n\t\t\tFileHandle image = null;\n\t\t\tif (source != null) {\n\t\t\t\tFileHandle tsx = getRelativeFileHandle(tmxFile, source);\n\t\t\t\ttry {\n\t\t\t\t\telement = xml.parse(tsx);\n\t\t\t\t\tname = element.get(\"name\", null);\n\t\t\t\t\ttilewidth = element.getIntAttribute(\"tilewidth\", 0);\n\t\t\t\t\ttileheight = element.getIntAttribute(\"tileheight\", 0);\n\t\t\t\t\tspacing = element.getIntAttribute(\"spacing\", 0);\n\t\t\t\t\tmargin = element.getIntAttribute(\"margin\", 0);\n\t\t\t\t\tElement offset = element.getChildByName(\"tileoffset\");\n\t\t\t\t\tif (offset != null) {\n\t\t\t\t\t\toffsetX = offset.getIntAttribute(\"x\", 0);\n\t\t\t\t\t\toffsetY = offset.getIntAttribute(\"y\", 0);\n\t\t\t\t\t}\n\t\t\t\t\tElement imageElement = element.getChildByName(\"image\");\n\t\t\t\t\tif (imageElement != null) {\n\t\t\t\t\t\timageSource = imageElement.getAttribute(\"source\");\n\t\t\t\t\t\timageWidth = imageElement.getIntAttribute(\"width\", 0);\n\t\t\t\t\t\timageHeight = imageElement.getIntAttribute(\"height\", 0);\n\t\t\t\t\t\timage = getRelativeFileHandle(tsx, imageSource);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new GdxRuntimeException(\"Error parsing external tileset.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tElement offset = element.getChildByName(\"tileoffset\");\n\t\t\t\tif (offset != null) {\n\t\t\t\t\toffsetX = offset.getIntAttribute(\"x\", 0);\n\t\t\t\t\toffsetY = offset.getIntAttribute(\"y\", 0);\n\t\t\t\t}\n\t\t\t\tElement imageElement = element.getChildByName(\"image\");\n\t\t\t\tif (imageElement != null) {\n\t\t\t\t\timageSource = imageElement.getAttribute(\"source\");\n\t\t\t\t\timageWidth = imageElement.getIntAttribute(\"width\", 0);\n\t\t\t\t\timageHeight = imageElement.getIntAttribute(\"height\", 0);\n\t\t\t\t\timage = getRelativeFileHandle(tmxFile, imageSource);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString atlasFilePath = map.getProperties().get(\"atlas\", String.class);\n\t\t\tif (atlasFilePath == null) {\n\t\t\t\tFileHandle atlasFile = tmxFile.sibling(tmxFile.nameWithoutExtension() + \".atlas\");\n\t\t\t\tif (atlasFile.exists()) atlasFilePath = atlasFile.name();\n\t\t\t}\n\t\t\tif (atlasFilePath == null) {\n\t\t\t\tthrow new GdxRuntimeException(\"The map is missing the 'atlas' property\");\n\t\t\t}\n\n\t\t\t// get the TextureAtlas for this tileset\n\t\t\tFileHandle atlasHandle = getRelativeFileHandle(tmxFile, atlasFilePath);\n\t\t\tatlasHandle = resolve(atlasHandle.path());\n\t\t\tTextureAtlas atlas = resolver.getAtlas(atlasHandle.path());\n\t\t\tString regionsName = atlasHandle.nameWithoutExtension();\n\n\t\t\tfor (Texture texture : atlas.getTextures()) {\n\t\t\t\ttrackedTextures.add(texture);\n\t\t\t}\n\n\t\t\tTiledMapTileSet tileset = new TiledMapTileSet();\n\t\t\tMapProperties props = tileset.getProperties();\n\t\t\ttileset.setName(name);\n\t\t\tprops.put(\"firstgid\", firstgid);\n\t\t\tprops.put(\"imagesource\", imageSource);\n\t\t\tprops.put(\"imagewidth\", imageWidth);\n\t\t\tprops.put(\"imageheight\", imageHeight);\n\t\t\tprops.put(\"tilewidth\", tilewidth);\n\t\t\tprops.put(\"tileheight\", tileheight);\n\t\t\tprops.put(\"margin\", margin);\n\t\t\tprops.put(\"spacing\", spacing);\n\n\t\t\tfor (AtlasRegion region : atlas.findRegions(regionsName)) {\n\t\t\t\t// handle unused tile ids\n\t\t\t\tif (region != null) {\n\t\t\t\t\tStaticTiledMapTile tile = new StaticTiledMapTile(region);\n\t\t\t\t\tint tileid = firstgid + region.index;\n\t\t\t\t\ttile.setId(tileid);\n\t\t\t\t\ttile.setOffsetX(offsetX);\n\t\t\t\t\ttile.setOffsetY(-offsetY);\n\t\t\t\t\ttileset.putTile(tileid, tile);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Element tileElement : element.getChildrenByName(\"tile\")) {\n\t\t\t\tint tileid = firstgid + tileElement.getIntAttribute(\"id\", 0);\n\t\t\t\tTiledMapTile tile = tileset.getTile(tileid);\n\t\t\t\tif (tile == null) {\n\t\t\t\t\tElement imageElement = tileElement.getChildByName(\"image\");\n\t\t\t\t\tif (imageElement != null) {\n\t\t\t\t\t\t// Is a tilemap with individual images.\n\t\t\t\t\t\tString regionName = imageElement.getAttribute(\"source\");\n\t\t\t\t\t\tregionName = regionName.substring(0, regionName.lastIndexOf('.'));\n\t\t\t\t\t\tAtlasRegion region = atlas.findRegion(regionName);\n\t\t\t\t\t\tif (region == null) throw new GdxRuntimeException(\"Tileset region not found: \" + regionName);\n\t\t\t\t\t\ttile = new StaticTiledMapTile(region);\n\t\t\t\t\t\ttile.setId(tileid);\n\t\t\t\t\t\ttile.setOffsetX(offsetX);\n\t\t\t\t\t\ttile.setOffsetY(-offsetY);\n\t\t\t\t\t\ttileset.putTile(tileid, tile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tile != null) {\n\t\t\t\t\tString terrain = tileElement.getAttribute(\"terrain\", null);\n\t\t\t\t\tif (terrain != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"terrain\", terrain);\n\t\t\t\t\t}\n\t\t\t\t\tString probability = tileElement.getAttribute(\"probability\", null);\n\t\t\t\t\tif (probability != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"probability\", probability);\n\t\t\t\t\t}\n\t\t\t\t\tElement properties = tileElement.getChildByName(\"properties\");\n\t\t\t\t\tif (properties != null) {\n\t\t\t\t\t\tloadProperties(tile.getProperties(), properties);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArray<Element> tileElements = element.getChildrenByName(\"tile\");\n\n\t\t\tArray<AnimatedTiledMapTile> animatedTiles = new Array<AnimatedTiledMapTile>();\n\n\t\t\tfor (Element tileElement : tileElements) {\n\t\t\t\tint localtid = tileElement.getIntAttribute(\"id\", 0);\n\t\t\t\tTiledMapTile tile = tileset.getTile(firstgid + localtid);\n\t\t\t\tif (tile != null) {\n\t\t\t\t\tElement animationElement = tileElement.getChildByName(\"animation\");\n\t\t\t\t\tif (animationElement != null) {\n\n\t\t\t\t\t\tArray<StaticTiledMapTile> staticTiles = new Array<StaticTiledMapTile>();\n\t\t\t\t\t\tIntArray intervals = new IntArray();\n\t\t\t\t\t\tfor (Element frameElement: animationElement.getChildrenByName(\"frame\")) {\n\t\t\t\t\t\t\tstaticTiles.add((StaticTiledMapTile) tileset.getTile(firstgid + frameElement.getIntAttribute(\"tileid\")));\n\t\t\t\t\t\t\tintervals.add(frameElement.getIntAttribute(\"duration\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAnimatedTiledMapTile animatedTile = new AnimatedTiledMapTile(intervals, staticTiles);\n\t\t\t\t\t\tanimatedTile.setId(tile.getId());\n\t\t\t\t\t\tanimatedTiles.add(animatedTile);\n\t\t\t\t\t\ttile = animatedTile;\n\t\t\t\t\t}\n\n\t\t\t\t\tString terrain = tileElement.getAttribute(\"terrain\", null);\n\t\t\t\t\tif (terrain != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"terrain\", terrain);\n\t\t\t\t\t}\n\t\t\t\t\tString probability = tileElement.getAttribute(\"probability\", null);\n\t\t\t\t\tif (probability != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"probability\", probability);\n\t\t\t\t\t}\n\t\t\t\t\tElement properties = tileElement.getChildByName(\"properties\");\n\t\t\t\t\tif (properties != null) {\n\t\t\t\t\t\tloadProperties(tile.getProperties(), properties);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (AnimatedTiledMapTile tile : animatedTiles) {\n\t\t\t\ttileset.putTile(tile.getId(), tile);\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tElement properties = element.getChildByName(\"properties\");\n\t\t\tif (properties != null) {\n\t\t\t\tloadProperties(tileset.getProperties(), properties);\n\t\t\t}\n\t\t\tmap.getTileSets().addTileSet(tileset);\n\t\t}\n\t}","commit_id":"150a54bc07ff26754040ba7bbee6ec836c1f63d9","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected TiledMap loadMap (Element root, FileHandle tmxFile, AtlasResolver resolver, AtlasTiledMapLoaderParameters parameter) {\n\t\tTiledMap map = new TiledMap();\n\n\t\tString mapOrientation = root.getAttribute(\"orientation\", null);\n\t\tint mapWidth = root.getIntAttribute(\"width\", 0);\n\t\tint mapHeight = root.getIntAttribute(\"height\", 0);\n\t\tint tileWidth = root.getIntAttribute(\"tilewidth\", 0);\n\t\tint tileHeight = root.getIntAttribute(\"tileheight\", 0);\n\t\tString mapBackgroundColor = root.getAttribute(\"backgroundcolor\", null);\n\n\t\tMapProperties mapProperties = map.getProperties();\n\t\tif (mapOrientation != null) {\n\t\t\tmapProperties.put(\"orientation\", mapOrientation);\n\t\t}\n\t\tmapProperties.put(\"width\", mapWidth);\n\t\tmapProperties.put(\"height\", mapHeight);\n\t\tmapProperties.put(\"tilewidth\", tileWidth);\n\t\tmapProperties.put(\"tileheight\", tileHeight);\n\t\tif (mapBackgroundColor != null) {\n\t\t\tmapProperties.put(\"backgroundcolor\", mapBackgroundColor);\n\t\t}\n\n\t\tmapTileWidth = tileWidth;\n\t\tmapTileHeight = tileHeight;\n\t\tmapWidthInPixels = mapWidth * tileWidth;\n\t\tmapHeightInPixels = mapHeight * tileHeight;\n\n\t\tfor (int i = 0, j = root.getChildCount(); i < j; i++) {\n\t\t\tElement element = root.getChild(i);\n\t\t\tString elementName = element.getName();\n\t\t\tif (elementName.equals(\"properties\")) {\n\t\t\t\tloadProperties(map.getProperties(), element);\n\t\t\t} else if (elementName.equals(\"tileset\")) {\n\t\t\t\tloadTileset(map, element, tmxFile, resolver, parameter);\n\t\t\t} else if (elementName.equals(\"layer\")) {\n\t\t\t\tloadTileLayer(map, element);\n\t\t\t} else if (elementName.equals(\"objectgroup\")) {\n\t\t\t\tloadObjectGroup(map, element);\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}","id":72312,"modified_method":"protected TiledMap loadMap (Element root, FileHandle tmxFile, AtlasResolver resolver) {\n\t\tTiledMap map = new TiledMap();\n\n\t\tString mapOrientation = root.getAttribute(\"orientation\", null);\n\t\tint mapWidth = root.getIntAttribute(\"width\", 0);\n\t\tint mapHeight = root.getIntAttribute(\"height\", 0);\n\t\tint tileWidth = root.getIntAttribute(\"tilewidth\", 0);\n\t\tint tileHeight = root.getIntAttribute(\"tileheight\", 0);\n\t\tString mapBackgroundColor = root.getAttribute(\"backgroundcolor\", null);\n\n\t\tMapProperties mapProperties = map.getProperties();\n\t\tif (mapOrientation != null) {\n\t\t\tmapProperties.put(\"orientation\", mapOrientation);\n\t\t}\n\t\tmapProperties.put(\"width\", mapWidth);\n\t\tmapProperties.put(\"height\", mapHeight);\n\t\tmapProperties.put(\"tilewidth\", tileWidth);\n\t\tmapProperties.put(\"tileheight\", tileHeight);\n\t\tif (mapBackgroundColor != null) {\n\t\t\tmapProperties.put(\"backgroundcolor\", mapBackgroundColor);\n\t\t}\n\n\t\tmapTileWidth = tileWidth;\n\t\tmapTileHeight = tileHeight;\n\t\tmapWidthInPixels = mapWidth * tileWidth;\n\t\tmapHeightInPixels = mapHeight * tileHeight;\n\n\t\tfor (int i = 0, j = root.getChildCount(); i < j; i++) {\n\t\t\tElement element = root.getChild(i);\n\t\t\tString elementName = element.getName();\n\t\t\tif (elementName.equals(\"properties\")) {\n\t\t\t\tloadProperties(map.getProperties(), element);\n\t\t\t} else if (elementName.equals(\"tileset\")) {\n\t\t\t\tloadTileset(map, element, tmxFile, resolver);\n\t\t\t} else if (elementName.equals(\"layer\")) {\n\t\t\t\tloadTileLayer(map, element);\n\t\t\t} else if (elementName.equals(\"objectgroup\")) {\n\t\t\t\tloadObjectGroup(map, element);\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}","commit_id":"150a54bc07ff26754040ba7bbee6ec836c1f63d9","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Loads the specified tileset data, adding it to the collection of the specified map, given the XML element, the tmxFile and\n\t * an {@link ImageResolver} used to retrieve the tileset Textures.\n\t * \n\t * <p>\n\t * Default tileset's property keys that are loaded by default are:\n\t * <\/p>\n\t * \n\t * <ul>\n\t * <li><em>firstgid<\/em>, (int, defaults to 1) the first valid global id used for tile numbering<\/li>\n\t * <li><em>imagesource<\/em>, (String, defaults to empty string) the tileset source image filename<\/li>\n\t * <li><em>imagewidth<\/em>, (int, defaults to 0) the tileset source image width<\/li>\n\t * <li><em>imageheight<\/em>, (int, defaults to 0) the tileset source image height<\/li>\n\t * <li><em>tilewidth<\/em>, (int, defaults to 0) the tile width<\/li>\n\t * <li><em>tileheight<\/em>, (int, defaults to 0) the tile height<\/li>\n\t * <li><em>margin<\/em>, (int, defaults to 0) the tileset margin<\/li>\n\t * <li><em>spacing<\/em>, (int, defaults to 0) the tileset spacing<\/li>\n\t * <\/ul>\n\t * \n\t * <p>\n\t * The values are extracted from the specified Tmx file, if a value can't be found then the default is used.\n\t * <\/p>\n\t * @param map the Map whose tilesets collection will be populated\n\t * @param element the XML element identifying the tileset to load\n\t * @param tmxFile the Filehandle of the tmx file\n\t * @param imageResolver the {@link ImageResolver} */\n\tprotected void loadTileSet (TiledMap map, Element element, FileHandle tmxFile, ImageResolver imageResolver) {\n\t\tif (element.getName().equals(\"tileset\")) {\n\t\t\tString name = element.get(\"name\", null);\n\t\t\tint firstgid = element.getIntAttribute(\"firstgid\", 1);\n\t\t\tint tilewidth = element.getIntAttribute(\"tilewidth\", 0);\n\t\t\tint tileheight = element.getIntAttribute(\"tileheight\", 0);\n\t\t\tint spacing = element.getIntAttribute(\"spacing\", 0);\n\t\t\tint margin = element.getIntAttribute(\"margin\", 0);\n\t\t\tString source = element.getAttribute(\"source\", null);\n\n\t\t\tint offsetX = 0;\n\t\t\tint offsetY = 0;\n\n\t\t\tString imageSource = \"\";\n\t\t\tint imageWidth = 0, imageHeight = 0;\n\n\t\t\tFileHandle image = null;\n\t\t\tif (source != null) {\n\t\t\t\tFileHandle tsx = getRelativeFileHandle(tmxFile, source);\n\t\t\t\ttry {\n\t\t\t\t\telement = xml.parse(tsx);\n\t\t\t\t\tname = element.get(\"name\", null);\n\t\t\t\t\ttilewidth = element.getIntAttribute(\"tilewidth\", 0);\n\t\t\t\t\ttileheight = element.getIntAttribute(\"tileheight\", 0);\n\t\t\t\t\tspacing = element.getIntAttribute(\"spacing\", 0);\n\t\t\t\t\tmargin = element.getIntAttribute(\"margin\", 0);\n\t\t\t\t\tElement offset = element.getChildByName(\"tileoffset\");\n\t\t\t\t\tif (offset != null) {\n\t\t\t\t\t\toffsetX = offset.getIntAttribute(\"x\", 0);\n\t\t\t\t\t\toffsetY = offset.getIntAttribute(\"y\", 0);\n\t\t\t\t\t}\n\t\t\t\t\timageSource = element.getChildByName(\"image\").getAttribute(\"source\");\n\t\t\t\t\timageWidth = element.getChildByName(\"image\").getIntAttribute(\"width\", 0);\n\t\t\t\t\timageHeight = element.getChildByName(\"image\").getIntAttribute(\"height\", 0);\n\t\t\t\t\timage = getRelativeFileHandle(tsx, imageSource);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new GdxRuntimeException(\"Error parsing external tileset.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tElement offset = element.getChildByName(\"tileoffset\");\n\t\t\t\tif (offset != null) {\n\t\t\t\t\toffsetX = offset.getIntAttribute(\"x\", 0);\n\t\t\t\t\toffsetY = offset.getIntAttribute(\"y\", 0);\n\t\t\t\t}\n\t\t\t\timageSource = element.getChildByName(\"image\").getAttribute(\"source\");\n\t\t\t\timageWidth = element.getChildByName(\"image\").getIntAttribute(\"width\", 0);\n\t\t\t\timageHeight = element.getChildByName(\"image\").getIntAttribute(\"height\", 0);\n\t\t\t\timage = getRelativeFileHandle(tmxFile, imageSource);\n\t\t\t}\n\n\t\t\tTextureRegion texture = imageResolver.getImage(image.path());\n\n\t\t\tTiledMapTileSet tileset = new TiledMapTileSet();\n\t\t\tMapProperties props = tileset.getProperties();\n\t\t\ttileset.setName(name);\n\t\t\tprops.put(\"firstgid\", firstgid);\n\t\t\tprops.put(\"imagesource\", imageSource);\n\t\t\tprops.put(\"imagewidth\", imageWidth);\n\t\t\tprops.put(\"imageheight\", imageHeight);\n\t\t\tprops.put(\"tilewidth\", tilewidth);\n\t\t\tprops.put(\"tileheight\", tileheight);\n\t\t\tprops.put(\"margin\", margin);\n\t\t\tprops.put(\"spacing\", spacing);\n\n\t\t\tint stopWidth = texture.getRegionWidth() - tilewidth;\n\t\t\tint stopHeight = texture.getRegionHeight() - tileheight;\n\n\t\t\tint id = firstgid;\n\n\t\t\tfor (int y = margin; y <= stopHeight; y += tileheight + spacing) {\n\t\t\t\tfor (int x = margin; x <= stopWidth; x += tilewidth + spacing) {\n\t\t\t\t\tTextureRegion tileRegion = new TextureRegion(texture, x, y, tilewidth, tileheight);\n\t\t\t\t\tTiledMapTile tile = new StaticTiledMapTile(tileRegion);\n\t\t\t\t\ttile.setId(id);\n\t\t\t\t\ttile.setOffsetX(offsetX);\n\t\t\t\t\ttile.setOffsetY(-offsetY);\n\t\t\t\t\ttileset.putTile(id++, tile);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArray<Element> tileElements = element.getChildrenByName(\"tile\");\n\n\t\t\tArray<AnimatedTiledMapTile> animatedTiles = new Array<AnimatedTiledMapTile>();\n\n\t\t\tfor (Element tileElement : tileElements) {\n\t\t\t\tint localtid = tileElement.getIntAttribute(\"id\", 0);\n\t\t\t\tTiledMapTile tile = tileset.getTile(firstgid + localtid);\n\t\t\t\tif (tile != null) {\n\t\t\t\t\tElement animationElement = tileElement.getChildByName(\"animation\");\n\t\t\t\t\tif (animationElement != null) {\n\n\t\t\t\t\t\tArray<StaticTiledMapTile> staticTiles = new Array<StaticTiledMapTile>();\n\t\t\t\t\t\tIntArray intervals = new IntArray();\n\t\t\t\t\t\tfor (Element frameElement: animationElement.getChildrenByName(\"frame\")) {\n\t\t\t\t\t\t\tstaticTiles.add((StaticTiledMapTile) tileset.getTile(firstgid + frameElement.getIntAttribute(\"tileid\")));\n\t\t\t\t\t\t\tintervals.add(frameElement.getIntAttribute(\"duration\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAnimatedTiledMapTile animatedTile = new AnimatedTiledMapTile(intervals, staticTiles);\n\t\t\t\t\t\tanimatedTile.setId(tile.getId());\n\t\t\t\t\t\tanimatedTiles.add(animatedTile);\n\t\t\t\t\t\ttile = animatedTile;\n\t\t\t\t\t}\n\n\t\t\t\t\tString terrain = tileElement.getAttribute(\"terrain\", null);\n\t\t\t\t\tif (terrain != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"terrain\", terrain);\n\t\t\t\t\t}\n\t\t\t\t\tString probability = tileElement.getAttribute(\"probability\", null);\n\t\t\t\t\tif (probability != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"probability\", probability);\n\t\t\t\t\t}\n\t\t\t\t\tElement properties = tileElement.getChildByName(\"properties\");\n\t\t\t\t\tif (properties != null) {\n\t\t\t\t\t\tloadProperties(tile.getProperties(), properties);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (AnimatedTiledMapTile tile : animatedTiles) {\n\t\t\t\ttileset.putTile(tile.getId(), tile);\n\t\t\t}\n\n\t\t\tElement properties = element.getChildByName(\"properties\");\n\t\t\tif (properties != null) {\n\t\t\t\tloadProperties(tileset.getProperties(), properties);\n\t\t\t}\n\t\t\tmap.getTileSets().addTileSet(tileset);\n\t\t}\n\t}","id":72313,"modified_method":"/** Loads the specified tileset data, adding it to the collection of the specified map, given the XML element, the tmxFile and\n\t * an {@link ImageResolver} used to retrieve the tileset Textures.\n\t * \n\t * <p>\n\t * Default tileset's property keys that are loaded by default are:\n\t * <\/p>\n\t * \n\t * <ul>\n\t * <li><em>firstgid<\/em>, (int, defaults to 1) the first valid global id used for tile numbering<\/li>\n\t * <li><em>imagesource<\/em>, (String, defaults to empty string) the tileset source image filename<\/li>\n\t * <li><em>imagewidth<\/em>, (int, defaults to 0) the tileset source image width<\/li>\n\t * <li><em>imageheight<\/em>, (int, defaults to 0) the tileset source image height<\/li>\n\t * <li><em>tilewidth<\/em>, (int, defaults to 0) the tile width<\/li>\n\t * <li><em>tileheight<\/em>, (int, defaults to 0) the tile height<\/li>\n\t * <li><em>margin<\/em>, (int, defaults to 0) the tileset margin<\/li>\n\t * <li><em>spacing<\/em>, (int, defaults to 0) the tileset spacing<\/li>\n\t * <\/ul>\n\t * \n\t * <p>\n\t * The values are extracted from the specified Tmx file, if a value can't be found then the default is used.\n\t * <\/p>\n\t * @param map the Map whose tilesets collection will be populated\n\t * @param element the XML element identifying the tileset to load\n\t * @param tmxFile the Filehandle of the tmx file\n\t * @param imageResolver the {@link ImageResolver} */\n\tprotected void loadTileSet (TiledMap map, Element element, FileHandle tmxFile, ImageResolver imageResolver) {\n\t\tif (element.getName().equals(\"tileset\")) {\n\t\t\tString name = element.get(\"name\", null);\n\t\t\tint firstgid = element.getIntAttribute(\"firstgid\", 1);\n\t\t\tint tilewidth = element.getIntAttribute(\"tilewidth\", 0);\n\t\t\tint tileheight = element.getIntAttribute(\"tileheight\", 0);\n\t\t\tint spacing = element.getIntAttribute(\"spacing\", 0);\n\t\t\tint margin = element.getIntAttribute(\"margin\", 0);\n\t\t\tString source = element.getAttribute(\"source\", null);\n\n\t\t\tint offsetX = 0;\n\t\t\tint offsetY = 0;\n\n\t\t\tString imageSource = \"\";\n\t\t\tint imageWidth = 0, imageHeight = 0;\n\n\t\t\tFileHandle image = null;\n\t\t\tif (source != null) {\n\t\t\t\tFileHandle tsx = getRelativeFileHandle(tmxFile, source);\n\t\t\t\ttry {\n\t\t\t\t\telement = xml.parse(tsx);\n\t\t\t\t\tname = element.get(\"name\", null);\n\t\t\t\t\ttilewidth = element.getIntAttribute(\"tilewidth\", 0);\n\t\t\t\t\ttileheight = element.getIntAttribute(\"tileheight\", 0);\n\t\t\t\t\tspacing = element.getIntAttribute(\"spacing\", 0);\n\t\t\t\t\tmargin = element.getIntAttribute(\"margin\", 0);\n\t\t\t\t\tElement offset = element.getChildByName(\"tileoffset\");\n\t\t\t\t\tif (offset != null) {\n\t\t\t\t\t\toffsetX = offset.getIntAttribute(\"x\", 0);\n\t\t\t\t\t\toffsetY = offset.getIntAttribute(\"y\", 0);\n\t\t\t\t\t}\n\t\t\t\t\tElement imageElement = element.getChildByName(\"image\");\n\t\t\t\t\tif (imageElement != null) {\n\t\t\t\t\t\timageSource = imageElement.getAttribute(\"source\");\n\t\t\t\t\t\timageWidth = imageElement.getIntAttribute(\"width\", 0);\n\t\t\t\t\t\timageHeight = imageElement.getIntAttribute(\"height\", 0);\n\t\t\t\t\t\timage = getRelativeFileHandle(tsx, imageSource);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new GdxRuntimeException(\"Error parsing external tileset.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tElement offset = element.getChildByName(\"tileoffset\");\n\t\t\t\tif (offset != null) {\n\t\t\t\t\toffsetX = offset.getIntAttribute(\"x\", 0);\n\t\t\t\t\toffsetY = offset.getIntAttribute(\"y\", 0);\n\t\t\t\t}\n\t\t\t\tElement imageElement = element.getChildByName(\"image\");\n\t\t\t\tif (imageElement != null) {\n\t\t\t\t\timageSource = imageElement.getAttribute(\"source\");\n\t\t\t\t\timageWidth = imageElement.getIntAttribute(\"width\", 0);\n\t\t\t\t\timageHeight = imageElement.getIntAttribute(\"height\", 0);\n\t\t\t\t\timage = getRelativeFileHandle(tmxFile, imageSource);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTiledMapTileSet tileset = new TiledMapTileSet();\n\t\t\tif (image != null) {\n\t\t\t\tTextureRegion texture = imageResolver.getImage(image.path());\n\t\n\t\t\t\tMapProperties props = tileset.getProperties();\n\t\t\t\ttileset.setName(name);\n\t\t\t\tprops.put(\"firstgid\", firstgid);\n\t\t\t\tprops.put(\"imagesource\", imageSource);\n\t\t\t\tprops.put(\"imagewidth\", imageWidth);\n\t\t\t\tprops.put(\"imageheight\", imageHeight);\n\t\t\t\tprops.put(\"tilewidth\", tilewidth);\n\t\t\t\tprops.put(\"tileheight\", tileheight);\n\t\t\t\tprops.put(\"margin\", margin);\n\t\t\t\tprops.put(\"spacing\", spacing);\n\t\n\t\t\t\tint stopWidth = texture.getRegionWidth() - tilewidth;\n\t\t\t\tint stopHeight = texture.getRegionHeight() - tileheight;\n\t\n\t\t\t\tint id = firstgid;\n\t\n\t\t\t\tfor (int y = margin; y <= stopHeight; y += tileheight + spacing) {\n\t\t\t\t\tfor (int x = margin; x <= stopWidth; x += tilewidth + spacing) {\n\t\t\t\t\t\tTextureRegion tileRegion = new TextureRegion(texture, x, y, tilewidth, tileheight);\n\t\t\t\t\t\tTiledMapTile tile = new StaticTiledMapTile(tileRegion);\n\t\t\t\t\t\ttile.setId(id);\n\t\t\t\t\t\ttile.setOffsetX(offsetX);\n\t\t\t\t\t\ttile.setOffsetY(-offsetY);\n\t\t\t\t\t\ttileset.putTile(id++, tile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tArray<Element> tileElements = element.getChildrenByName(\"tile\");\n\t\t\t\tfor (Element tileElement : tileElements) {\n\t\t\t\t\tElement imageElement = tileElement.getChildByName(\"image\");\n\t\t\t\t\tif (imageElement != null) {\n\t\t\t\t\t\timageSource = imageElement.getAttribute(\"source\");\n\t\t\t\t\t\timageWidth = imageElement.getIntAttribute(\"width\", 0);\n\t\t\t\t\t\timageHeight = imageElement.getIntAttribute(\"height\", 0);\n\t\t\t\t\t\timage = getRelativeFileHandle(tmxFile, imageSource);\n\t\t\t\t\t}\n\t\t\t\t\tTextureRegion texture = imageResolver.getImage(image.path());\n\t\t\t\t\tTiledMapTile tile = new StaticTiledMapTile(texture);\n\t\t\t\t\ttile.setId(firstgid + tileElement.getIntAttribute(\"id\"));\n\t\t\t\t\ttile.setOffsetX(offsetX);\n\t\t\t\t\ttile.setOffsetY(-offsetY);\n\t\t\t\t\ttileset.putTile(tile.getId(), tile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArray<Element> tileElements = element.getChildrenByName(\"tile\");\n\n\t\t\tArray<AnimatedTiledMapTile> animatedTiles = new Array<AnimatedTiledMapTile>();\n\n\t\t\tfor (Element tileElement : tileElements) {\n\t\t\t\tint localtid = tileElement.getIntAttribute(\"id\", 0);\n\t\t\t\tTiledMapTile tile = tileset.getTile(firstgid + localtid);\n\t\t\t\tif (tile != null) {\n\t\t\t\t\tElement animationElement = tileElement.getChildByName(\"animation\");\n\t\t\t\t\tif (animationElement != null) {\n\n\t\t\t\t\t\tArray<StaticTiledMapTile> staticTiles = new Array<StaticTiledMapTile>();\n\t\t\t\t\t\tIntArray intervals = new IntArray();\n\t\t\t\t\t\tfor (Element frameElement: animationElement.getChildrenByName(\"frame\")) {\n\t\t\t\t\t\t\tstaticTiles.add((StaticTiledMapTile) tileset.getTile(firstgid + frameElement.getIntAttribute(\"tileid\")));\n\t\t\t\t\t\t\tintervals.add(frameElement.getIntAttribute(\"duration\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAnimatedTiledMapTile animatedTile = new AnimatedTiledMapTile(intervals, staticTiles);\n\t\t\t\t\t\tanimatedTile.setId(tile.getId());\n\t\t\t\t\t\tanimatedTiles.add(animatedTile);\n\t\t\t\t\t\ttile = animatedTile;\n\t\t\t\t\t}\n\n\t\t\t\t\tString terrain = tileElement.getAttribute(\"terrain\", null);\n\t\t\t\t\tif (terrain != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"terrain\", terrain);\n\t\t\t\t\t}\n\t\t\t\t\tString probability = tileElement.getAttribute(\"probability\", null);\n\t\t\t\t\tif (probability != null) {\n\t\t\t\t\t\ttile.getProperties().put(\"probability\", probability);\n\t\t\t\t\t}\n\t\t\t\t\tElement properties = tileElement.getChildByName(\"properties\");\n\t\t\t\t\tif (properties != null) {\n\t\t\t\t\t\tloadProperties(tile.getProperties(), properties);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (AnimatedTiledMapTile tile : animatedTiles) {\n\t\t\t\ttileset.putTile(tile.getId(), tile);\n\t\t\t}\n\n\t\t\tElement properties = element.getChildByName(\"properties\");\n\t\t\tif (properties != null) {\n\t\t\t\tloadProperties(tileset.getProperties(), properties);\n\t\t\t}\n\t\t\tmap.getTileSets().addTileSet(tileset);\n\t\t}\n\t}","commit_id":"150a54bc07ff26754040ba7bbee6ec836c1f63d9","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Loads the tilesets\n\t * @param root the root XML element\n\t * @return a list of filenames for images containing tiles\n\t * @throws IOException */\n\tprotected Array<FileHandle> loadTilesets (Element root, FileHandle tmxFile) throws IOException {\n\t\tArray<FileHandle> images = new Array<FileHandle>();\n\t\tfor (Element tileset : root.getChildrenByName(\"tileset\")) {\n\t\t\tString source = tileset.getAttribute(\"source\", null);\n\t\t\tFileHandle image = null;\n\t\t\tif (source != null) {\n\t\t\t\tFileHandle tsx = getRelativeFileHandle(tmxFile, source);\n\t\t\t\ttileset = xml.parse(tsx);\n\t\t\t\tString imageSource = tileset.getChildByName(\"image\").getAttribute(\"source\");\n\t\t\t\timage = getRelativeFileHandle(tsx, imageSource);\n\t\t\t} else {\n\t\t\t\tString imageSource = tileset.getChildByName(\"image\").getAttribute(\"source\");\n\t\t\t\timage = getRelativeFileHandle(tmxFile, imageSource);\n\t\t\t}\n\t\t\timages.add(image);\n\t\t}\n\t\treturn images;\n\t}","id":72314,"modified_method":"/** Loads the tilesets\n\t * @param root the root XML element\n\t * @return a list of filenames for images containing tiles\n\t * @throws IOException */\n\tprotected Array<FileHandle> loadTilesets (Element root, FileHandle tmxFile) throws IOException {\n\t\tArray<FileHandle> images = new Array<FileHandle>();\n\t\tfor (Element tileset : root.getChildrenByName(\"tileset\")) {\n\t\t\tString source = tileset.getAttribute(\"source\", null);\n\t\t\tif (source != null) {\n\t\t\t\tFileHandle tsxFile = getRelativeFileHandle(tmxFile, source);\n\t\t\t\ttileset = xml.parse(tsxFile);\n\t\t\t\tElement imageElement = tileset.getChildByName(\"image\");\n\t\t\t\tif (imageElement != null) {\n\t\t\t\t\tString imageSource = tileset.getChildByName(\"image\").getAttribute(\"source\");\n\t\t\t\t\tFileHandle image = getRelativeFileHandle(tsxFile, imageSource);\n\t\t\t\t\timages.add(image);\n\t\t\t\t} else {\n\t\t\t\t\tfor (Element tile : tileset.getChildrenByName(\"tile\")) {\n\t\t\t\t\t\tString imageSource = tile.getChildByName(\"image\").getAttribute(\"source\");\n\t\t\t\t\t\tFileHandle image = getRelativeFileHandle(tsxFile, imageSource);\n\t\t\t\t\t\timages.add(image);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tElement imageElement = tileset.getChildByName(\"image\");\n\t\t\t\tif (imageElement != null) {\n\t\t\t\t\tString imageSource = tileset.getChildByName(\"image\").getAttribute(\"source\");\n\t\t\t\t\tFileHandle image = getRelativeFileHandle(tmxFile, imageSource);\n\t\t\t\t\timages.add(image);\n\t\t\t\t} else {\n\t\t\t\t\tfor (Element tile : tileset.getChildrenByName(\"tile\")) {\n\t\t\t\t\t\tString imageSource = tile.getChildByName(\"image\").getAttribute(\"source\");\n\t\t\t\t\t\tFileHandle image = getRelativeFileHandle(tmxFile, imageSource);\n\t\t\t\t\t\timages.add(image);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn images;\n\t}","commit_id":"150a54bc07ff26754040ba7bbee6ec836c1f63d9","url":"https://github.com/libgdx/libgdx"},{"original_method":"public static List<DaemonStopEvent> uniqueRecentDaemonStopEvents(final List<DaemonStopEvent> stopEvents) {\n        final Set<Long> uniqueStoppedPids = new HashSet<Long>(stopEvents.size());\n        final List<DaemonStopEvent> recentStopEvents = new ArrayList<DaemonStopEvent>(stopEvents.size());\n\n        final List<DaemonStopEvent> sortedEvents = CollectionUtils.sort(stopEvents, new Comparator<DaemonStopEvent>() {\n            @Override\n            public int compare(DaemonStopEvent event1, DaemonStopEvent event2) {\n                if (event1.getStatus() != null && event2.getStatus() == null) {\n                    return -1;\n                } else if (event1.getStatus() == null && event2.getStatus() != null) {\n                    return 1;\n                } else if (event1.getStatus() != null && event2.getStatus() != null) {\n                    return event2.getStatus().compareTo(event1.getStatus());\n                }\n                return 0;\n            }\n        });\n\n        // User likely doesn't care about daemons that stopped a long time ago\n        for (DaemonStopEvent event : sortedEvents) {\n            if (event.occurredInLastHours(RECENTLY) && !uniqueStoppedPids.contains(event.getPid())) {\n                uniqueStoppedPids.add(event.getPid());\n                recentStopEvents.add(event);\n            }\n        }\n        return recentStopEvents;\n    }","id":72315,"modified_method":"public static List<DaemonStopEvent> uniqueRecentDaemonStopEvents(final List<DaemonStopEvent> stopEvents) {\n        final Set<Long> uniqueStoppedPids = new HashSet<Long>(stopEvents.size());\n        final List<DaemonStopEvent> recentStopEvents = new ArrayList<DaemonStopEvent>(stopEvents.size());\n\n        final List<DaemonStopEvent> sortedEvents = CollectionUtils.sort(stopEvents, new Comparator<DaemonStopEvent>() {\n            @Override\n            public int compare(DaemonStopEvent event1, DaemonStopEvent event2) {\n                if (event1.getStatus() != null && event2.getStatus() == null) {\n                    return -1;\n                } else if (event1.getStatus() == null && event2.getStatus() != null) {\n                    return 1;\n                } else if (event1.getStatus() != null && event2.getStatus() != null) {\n                    return event2.getStatus().compareTo(event1.getStatus());\n                }\n                return 0;\n            }\n        });\n\n        // User likely doesn't care about daemons that stopped a long time ago\n        for (DaemonStopEvent event : sortedEvents) {\n            Long pid = event.getPid();\n            if (event.occurredInLastHours(RECENTLY) && !uniqueStoppedPids.contains(pid)) {\n                // We can only determine if two DaemonStopEvent point at the same daemon if we know the PIDs\n                if (pid != null) {\n                    uniqueStoppedPids.add(pid);\n                }\n                recentStopEvents.add(event);\n            }\n        }\n        return recentStopEvents;\n    }","commit_id":"8ace70bd0e124529ec1867a140c2e068bcf9a75a","url":"https://github.com/gradle/gradle"},{"original_method":"private void handleStopEvents(Collection<DaemonInfo> idleDaemons, Collection<DaemonInfo> busyDaemons) {\n        final List<DaemonStopEvent> stopEvents = daemonRegistry.getStopEvents();\n\n        // Clean up old stop events\n        daemonRegistry.removeStopEvents(DaemonStopEvents.oldStopEvents(stopEvents));\n\n        final List<DaemonStopEvent> recentStopEvents = DaemonStopEvents.uniqueRecentDaemonStopEvents(stopEvents);\n        for (DaemonStopEvent stopEvent : recentStopEvents) {\n            LOGGER.info(\"Previous Daemon (\" + stopEvent.getPid() + \") stopped at \" + stopEvent.getTimestamp() + \" \" + stopEvent.getReason());\n        }\n\n        LOGGER.lifecycle(DaemonStartupMessage.generate(busyDaemons.size(), idleDaemons.size(), recentStopEvents.size()));\n    }","id":72316,"modified_method":"private void handleStopEvents(Collection<DaemonInfo> idleDaemons, Collection<DaemonInfo> busyDaemons) {\n        final List<DaemonStopEvent> stopEvents = daemonRegistry.getStopEvents();\n\n        // Clean up old stop events\n        daemonRegistry.removeStopEvents(DaemonStopEvents.oldStopEvents(stopEvents));\n\n        final List<DaemonStopEvent> recentStopEvents = DaemonStopEvents.uniqueRecentDaemonStopEvents(stopEvents);\n        for (DaemonStopEvent stopEvent : recentStopEvents) {\n            Long pid = stopEvent.getPid();\n            LOGGER.info(\"Previous Daemon (\" + (pid == null ? \"PID unknown\" : pid) + \") stopped at \" + stopEvent.getTimestamp() + \" \" + stopEvent.getReason());\n        }\n\n        LOGGER.lifecycle(DaemonStartupMessage.generate(busyDaemons.size(), idleDaemons.size(), recentStopEvents.size()));\n    }","commit_id":"8ace70bd0e124529ec1867a140c2e068bcf9a75a","url":"https://github.com/gradle/gradle"},{"original_method":"@VisibleForTesting\n    void printStoppedDaemons(final List<DaemonStopEvent> stopEvents) {\n        if (!stopEvents.isEmpty()) {\n            for(DaemonStopEvent event : stopEvents) {\n                LOGGER.quiet(String.format(STATUS_FORMAT, event.getPid(), \"STOPPED\", \"(\" + event.getReason() + \")\"));\n            }\n        }\n    }","id":72317,"modified_method":"@VisibleForTesting\n    void printStoppedDaemons(final List<DaemonStopEvent> stopEvents) {\n        if (!stopEvents.isEmpty()) {\n            for(DaemonStopEvent event : stopEvents) {\n                Long pid = event.getPid();\n                LOGGER.quiet(String.format(STATUS_FORMAT, pid == null ? \"PID unknown\" : pid, \"STOPPED\", \"(\" + event.getReason() + \")\"));\n            }\n        }\n    }","commit_id":"8ace70bd0e124529ec1867a140c2e068bcf9a75a","url":"https://github.com/gradle/gradle"},{"original_method":"@VisibleForTesting\n    void printRunningDaemons(final List<Status> statuses) {\n        if (!statuses.isEmpty()) {\n            for(Status status : statuses) {\n                LOGGER.quiet(String.format(STATUS_FORMAT, status.getPid(), status.getStatus(), status.getVersion()));\n            }\n        }\n    }","id":72318,"modified_method":"@VisibleForTesting\n    void printRunningDaemons(final List<Status> statuses) {\n        if (!statuses.isEmpty()) {\n            for(Status status : statuses) {\n                Long pid = status.getPid();\n                LOGGER.quiet(String.format(STATUS_FORMAT, pid == null ? \"PID unknown\" : pid, status.getStatus(), status.getVersion()));\n            }\n        }\n    }","commit_id":"8ace70bd0e124529ec1867a140c2e068bcf9a75a","url":"https://github.com/gradle/gradle"},{"original_method":"protected void doAction(ExecutionListener listener) {\n        LoggingServiceRegistry loggingRegistry = LoggingServiceRegistry.newChildProcessLogging();\n        LoggingManagerInternal loggingManager = loggingRegistry.getFactory(LoggingManagerInternal.class).create();\n        DaemonServices daemonServices = new DaemonServices(configuration, loggingRegistry, loggingManager);\n        File daemonLog = daemonServices.getDaemonLogFile();\n        final DaemonContext daemonContext = daemonServices.get(DaemonContext.class);\n\n        initialiseLogging(loggingRegistry.get(OutputEventRenderer.class), loggingManager, daemonLog);\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                LOGGER.info(\"Daemon[pid = {}] process has finished.\", daemonContext.getPid());\n            }\n        });\n\n        Daemon daemon = startDaemon(daemonServices);\n\n        LOGGER.lifecycle(DaemonMessages.PROCESS_STARTED);\n        daemonStarted(daemonContext.getPid(), daemonLog);\n\n        try {\n            daemon.awaitIdleTimeout(configuration.getIdleTimeout());\n            LOGGER.info(\"Daemon hit idle timeout (\" + configuration.getIdleTimeout() + \"ms), stopping...\");\n            daemon.stop();\n        } catch (DaemonStoppedException e) {\n            LOGGER.debug(\"Daemon stopping due to the stop request\");\n            listener.onFailure(e);\n        }\n    }","id":72319,"modified_method":"protected void doAction(ExecutionListener listener) {\n        LoggingServiceRegistry loggingRegistry = LoggingServiceRegistry.newChildProcessLogging();\n        LoggingManagerInternal loggingManager = loggingRegistry.getFactory(LoggingManagerInternal.class).create();\n        DaemonServices daemonServices = new DaemonServices(configuration, loggingRegistry, loggingManager);\n        File daemonLog = daemonServices.getDaemonLogFile();\n        final DaemonContext daemonContext = daemonServices.get(DaemonContext.class);\n\n        initialiseLogging(loggingRegistry.get(OutputEventRenderer.class), loggingManager, daemonLog);\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                LOGGER.info(\"Daemon[pid = {}] process has finished.\", daemonContext.getPid());\n            }\n        });\n\n        Daemon daemon = startDaemon(daemonServices);\n\n        Long pid = daemonContext.getPid();\n        LOGGER.lifecycle(DaemonMessages.PROCESS_STARTED + ((pid == null)? \"\":\" Pid: \" + pid + \".\"));\n        daemonStarted(pid, daemonLog);\n\n        try {\n            daemon.awaitIdleTimeout(configuration.getIdleTimeout());\n            LOGGER.info(\"Daemon hit idle timeout (\" + configuration.getIdleTimeout() + \"ms), stopping...\");\n            daemon.stop();\n        } catch (DaemonStoppedException e) {\n            LOGGER.debug(\"Daemon stopping due to the stop request\");\n            listener.onFailure(e);\n        }\n    }","commit_id":"c180aa9a3fe3ba6bb11075eb4c08ee3b9d26c535","url":"https://github.com/gradle/gradle"},{"original_method":"private int startProcess(List<String> commands) {\n    try {\n      final Process process = new ProcessBuilder(CommandLineUtil.toCommandLine(commands)).start();\n      final String message = new String(FileUtil.loadBytes(process.getErrorStream()));\n      if (!StringUtil.isEmptyOrSpaces(message)) {\n        registerJavaFxPackagerError(message);\n      }\n      return process.waitFor();\n    }\n    catch (Exception e) {\n      registerJavaFxPackagerError(e);\n      return -1;\n    }\n  }","id":72320,"modified_method":"private int startProcess(List<String> commands) {\n    try {\n      final Process process = new ProcessBuilder(CommandLineUtil.toCommandLine(commands)).start();\n      final String message = new String(FileUtil.loadBytes(process.getErrorStream()));\n      if (!StringUtil.isEmptyOrSpaces(message)) {\n        registerJavaFxPackagerError(message);\n      }\n      final int result = process.waitFor();\n      if (result != 0) {\n        final String explanationMessage = new String(FileUtil.loadBytes(process.getInputStream()));\n        if (!StringUtil.isEmptyOrSpaces(explanationMessage)) {\n          registerJavaFxPackagerError(explanationMessage);\n        }\n      }\n      return result;\n    }\n    catch (Exception e) {\n      registerJavaFxPackagerError(e);\n      return -1;\n    }\n  }","commit_id":"d38be1a483b4bf9123b569cb5afaa29d44e2e901","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int runCommand(final ProcessBuilder command) throws IOException, InterruptedException {\n    command.redirectErrorStream(true);\n    final Process process = command.start();\n    new Thread(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          final BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n          try {\n            //noinspection StatementWithEmptyBody\n            String line;\n            while ((line = reader.readLine()) != null) {\n              System.out.println(line);\n            }\n          }\n          finally {\n            reader.close();\n          }\n        }\n        catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    },\"io test\").start();\n    return process.waitFor();\n  }","id":72321,"modified_method":"private static int runCommand(final ProcessBuilder command) throws IOException, InterruptedException {\n    command.redirectErrorStream(true);\n    final Process process = command.start();\n    Thread thread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          final BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n          try {\n            //noinspection StatementWithEmptyBody\n            String line;\n            while ((line = reader.readLine()) != null) {\n              System.out.println(line);\n            }\n          }\n          finally {\n            reader.close();\n          }\n        }\n        catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }, \"io test\");\n    thread.start();\n    int ret = process.waitFor();\n    thread.join();\n    return ret;\n  }","commit_id":"71eddca87402158bf376ab973eac02528af6ed32","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n         * Waits for the completion of the process.\n         */\n        @Override\n        public int join() throws InterruptedException {\n            try {\n                t1.join();\n                t2.join();\n                return proc.waitFor();\n            } catch (InterruptedException e) {\n                // aborting. kill the process\n                proc.destroy();\n                throw e;\n            }\n        }","id":72322,"modified_method":"/**\n         * Waits for the completion of the process.\n         */\n        @Override\n        public int join() throws InterruptedException, IOException {\n            try {\n                int r = proc.waitFor();\n                // see http://hudson.gotdns.com/wiki/display/HUDSON/Spawning+processes+from+build\n                // problems like that shows up as inifinite wait in join(), which confuses great many users.\n                // So let's do a timed wait here and try to diagnose the problem\n                t1.join(10*1000);\n                t2.join(10*1000);\n                if(t1.isAlive() || t2.isAlive()) {\n                    // looks like handles are leaking.\n                    // closing these handles should terminate the threads.\n                    String msg = \"Process leaked file descriptors. See http://hudson.gotdns.com/wiki/display/HUDSON/Spawning+processes+from+build for more information\";\n                    Throwable e = new Exception().fillInStackTrace();\n                    LOGGER.log(Level.WARNING,msg,e);\n                    proc.getInputStream().close();\n                    proc.getErrorStream().close();\n                    out.write(msg.getBytes());\n                    out.write('\\n');\n                }\n                return r;\n            } catch (InterruptedException e) {\n                // aborting. kill the process\n                proc.destroy();\n                throw e;\n            }\n        }","commit_id":"852b2736c8a382cfbae0a0f7e6b1bb23afa244b1","url":"https://github.com/kohsuke/hudson"},{"original_method":"private LocalProc( String name, Process proc, InputStream in, OutputStream out ) throws IOException {\n            Logger.getLogger(Proc.class.getName()).log(Level.FINE, \"Running: {0}\", name);\n            this.proc = proc;\n            t1 = new StreamCopyThread(name+\": stdout copier\", proc.getInputStream(), out);\n            t1.start();\n            t2 = new StreamCopyThread(name+\": stderr copier\", proc.getErrorStream(), out);\n            t2.start();\n            if(in!=null)\n                new ByteCopier(name+\": stdin copier\",in,proc.getOutputStream()).start();\n            else\n                proc.getOutputStream().close();\n        }","id":72323,"modified_method":"private LocalProc( String name, Process proc, InputStream in, OutputStream out ) throws IOException {\n            Logger.getLogger(Proc.class.getName()).log(Level.FINE, \"Running: {0}\", name);\n            this.out = out;\n            this.proc = proc;\n            t1 = new StreamCopyThread(name+\": stdout copier\", proc.getInputStream(), out);\n            t1.start();\n            t2 = new StreamCopyThread(name+\": stderr copier\", proc.getErrorStream(), out);\n            t2.start();\n            if(in!=null)\n                new ByteCopier(name+\": stdin copier\",in,proc.getOutputStream()).start();\n            else\n                proc.getOutputStream().close();\n        }","commit_id":"852b2736c8a382cfbae0a0f7e6b1bb23afa244b1","url":"https://github.com/kohsuke/hudson"},{"original_method":"private int exec(String cmd) throws InterruptedException, IOException {\n        ProcessBuilder pb = new ProcessBuilder(exe, cmd);\n        pb.redirectErrorStream(true);\n        Process p = pb.start();\n        p.getOutputStream().close();\n        copy(p.getInputStream(), System.out);\n        return p.waitFor();\n    }","id":72324,"modified_method":"private int exec(String cmd) throws InterruptedException, IOException {\n        ProcessBuilder pb = new ProcessBuilder(exe, cmd);\n        pb.redirectErrorStream(true);\n        Process p = pb.start();\n        p.getOutputStream().close();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        copy(p.getInputStream(), baos);\n        int r = p.waitFor();\n        if (r!=0)\n            LOGGER.info(exe+\" cmd: output:\\n\"+baos);\n        return r;\n    }","commit_id":"88773cb38429ee28b27801a475eb9ac3cbfb2d46","url":"https://github.com/kohsuke/hudson"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n\r\n        boolean global = (post == null) ? true : ((String) post.get(\"resource\", \"global\")).equals(\"global\");\r\n        final boolean indexDistributeGranted = sb.getConfig(\"allowDistributeIndex\", \"true\").equals(\"true\");\r\n        final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        if (!indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n\r\n        // case if no values are requested\r\n        if (post == null || env == null) {\r\n\r\n            // save referrer\r\n            // System.out.println(\"HEADER=\" + header.toString());\r\n            final String referer = (String) header.get(\"Referer\");\r\n            if (referer != null) {\r\n                URL url;\r\n                try { url = new URL(referer); } catch (MalformedURLException e) { url = null; }\r\n                if ((url != null) && (serverCore.isNotLocal(url))) {\r\n                    final HashMap referrerprop = new HashMap();\r\n                    referrerprop.put(\"count\", \"1\");\r\n                    referrerprop.put(\"clientip\", header.get(\"CLIENTIP\"));\r\n                    referrerprop.put(\"useragent\", header.get(\"User-Agent\"));\r\n                    referrerprop.put(\"date\", (new serverDate()).toShortString(false));\r\n                    if (sb.facilityDB != null) try { sb.facilityDB.update(\"backlinks\", referer, referrerprop); } catch (IOException e) {}\r\n                }\r\n            }\r\n\r\n            // we create empty entries for template strings\r\n            final serverObjects prop = new serverObjects();\r\n            prop.put(\"promoteSearchPageGreeting\", env.getConfig(\"promoteSearchPageGreeting\", \"\"));\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"num-results\", 0);\r\n            prop.put(\"excluded\", 0);\r\n            prop.put(\"combine\", 0);\r\n            prop.put(\"resultbottomline\", 0);\r\n            prop.put(\"count-10\", 0);\r\n            prop.put(\"count-50\", 0);\r\n            prop.put(\"count-100\", 0);\r\n            prop.put(\"count-1000\", 0);\r\n            prop.put(\"order-quality\", 0);\r\n            prop.put(\"order-date\", 0);\r\n            prop.put(\"resource-global\", ((global) ? 1 : 0));\r\n            prop.put(\"resource-local\", ((global) ? 0 : 1));\r\n            prop.put(\"time-1\", 0);\r\n            prop.put(\"time-3\", 0);\r\n            prop.put(\"time-10\", 1);\r\n            prop.put(\"time-30\", 0);\r\n            prop.put(\"time-60\", 0);\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"urlmaskoptions\", 0);\r\n            prop.put(\"urlmaskoptions_urlmaskfilter\", \".*\");\r\n            return prop;\r\n        }\r\n\r\n        // SEARCH\r\n        // process search words\r\n        final String querystring = (String) post.get(\"search\", \"\");\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n        final TreeSet query = cleanQuery(querystring);\r\n        // filter out stopwords\r\n        final TreeSet filtered = kelondroMSetTools.joinConstructive(query, plasmaSwitchboard.stopwords);\r\n        if (filtered.size() > 0) {\r\n            kelondroMSetTools.excludeDestructive(query, plasmaSwitchboard.stopwords);\r\n        }\r\n\r\n        // prepare search order\r\n        final String order = (String) post.get(\"order\", \"\");\r\n        final int count = Integer.parseInt((String) post.get(\"count\", \"10\"));\r\n        final long searchtime = 1000 * Long.parseLong((String) post.get(\"time\", \"1\"));\r\n        final boolean yacyonline = ((yacyCore.seedDB != null) &&\r\n                                    (yacyCore.seedDB.mySeed != null) &&\r\n                                    (yacyCore.seedDB.mySeed.getAddress() != null));\r\n\r\n        final String order1 = (order.equals(\"Quality-Date\")) ? \"quality\" : \"date\";\r\n        final String order2 = (order.equals(\"Quality-Date\")) ? \"date\" : \"quality\";\r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n\r\n        // do the search\r\n        final serverObjects prop = ((plasmaSwitchboard) env).searchFromLocal(query, order1, order2, count,\r\n                                   ((global) && (yacyonline) && (!(env.getConfig(\"last-search\",\"\").equals(querystring)))),\r\n                                     searchtime, urlmask);\r\n\r\n        // remember the last search expression\r\n        env.setConfig(\"last-search\", querystring);\r\n        // process result of search\r\n        prop.put(\"resultbottomline\", 0);\r\n        if (filtered.size() > 0){\r\n            prop.put(\"excluded\", 1);\r\n            prop.put(\"excluded_stopwords\", filtered.toString());\r\n        } else {\r\n            prop.put(\"excluded\", 0);\r\n        }\r\n\r\n        if (prop == null || prop.size() == 0) {\r\n            if (((String) post.get(\"search\", \"\")).length() < 3) {\r\n                prop.put(\"num-results\", 2); // no results - at least 3 chars\r\n            } else {\r\n                prop.put(\"num-results\", 1);//no results\r\n            }\r\n        } else {\r\n            final int linkcount = Integer.parseInt(prop.get(\"linkcount\", \"0\"));\r\n            final int orderedcount = Integer.parseInt(prop.get(\"orderedcount\", \"0\"));\r\n            final int totalcount = Integer.parseInt(prop.get(\"totalcount\", \"0\"));\r\n            if (totalcount > 10) {\r\n                final Object[] references = (Object[]) prop.get(\"references\", new String[0]);\r\n                prop.put(\"num-results\", 4);\r\n                prop.put(\"num-results_linkcount\", linkcount);\r\n                prop.put(\"num-results_orderedcount\", orderedcount);\r\n                prop.put(\"num-results_totalcount\", totalcount);\r\n                int hintcount = references.length;\r\n                if (hintcount > 0) {\r\n                    if (hintcount > 16) { hintcount = 16; }\r\n                    prop.put(\"combine\", 1);\r\n                    String word;\r\n                    for (int i = 0; i < hintcount; i++) {\r\n                        word = (String) references[i];\r\n                        if (word != null) {\r\n                            prop.put(\"combine_words_\" + i + \"_word\", word);\r\n                            prop.put(\"combine_words_\" + i + \"_newsearch\", ((String) post.get(\"search\", \"\")).replace(' ', '+') + \"+\" + word);\r\n                            prop.put(\"combine_words_\" + i + \"_count\", count);\r\n                            prop.put(\"combine_words_\" + i + \"_order\", order);\r\n                            prop.put(\"combine_words_\" + i + \"_resource\", ((global) ? \"global\" : \"local\"));\r\n                            prop.put(\"combine_words_\" + i + \"_time\", (searchtime / 1000));\r\n                        }\r\n                        prop.put(\"combine_words\", i);\r\n                    }\r\n                }\r\n            } else {\r\n                if (totalcount == 0) {\r\n                    prop.put(\"num-results\", 3);//long\r\n                } else {\r\n                    prop.put(\"num-results\", 4);\r\n                    prop.put(\"num-results_linkcount\", linkcount);\r\n                    prop.put(\"num-results_orderedcount\", orderedcount);\r\n                    prop.put(\"num-results_totalcount\", totalcount);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (urlmask.equals(\".*\")) {\r\n            prop.put(\"urlmaskoptions\", 0);\r\n        } else {\r\n            prop.put(\"urlmaskoptions\", 1);\r\n        }\r\n\r\n        prop.put(\"urlmaskoptions_urlmaskfilter\", urlmask);\r\n\r\n        if (yacyonline) {\r\n            if (global) {\r\n                prop.put(\"resultbottomline\", 1);\r\n                prop.put(\"resultbottomline_globalresults\", prop.get(\"globalresults\", \"0\"));\r\n            } else {\r\n                prop.put(\"resultbottomline\", 2);\r\n            }\r\n        } else {\r\n            if (global) {\r\n                prop.put(\"resultbottomlien\", 3);\r\n            } else {\r\n                prop.put(\"resultbottomline\", 4);\r\n            }\r\n        }\r\n\r\n        prop.put(\"count-10\", ((count == 10)) ? 1 : 0);\r\n        prop.put(\"count-50\", ((count == 50)) ? 1 : 0);\r\n        prop.put(\"count-100\", ((count == 100)) ? 1 : 0);\r\n        prop.put(\"count-1000\", ((count == 1000)) ? 1 : 0);\r\n        prop.put(\"order-quality\", ((order.equals(\"Quality-Date\")) ? 1 : 0));\r\n        prop.put(\"order-date\", ((order.equals(\"Date-Quality\")) ? 1 : 0));\r\n        prop.put(\"resource-global\", ((global) ? 1 : 0));\r\n        prop.put(\"resource-local\", ((global) ? 0 : 1));\r\n        prop.put(\"time-1\", ((searchtime == 1000) ? 1 : 0));\r\n        prop.put(\"time-3\", ((searchtime == 3000) ? 1 : 0));\r\n        prop.put(\"time-10\", ((searchtime == 10000) ? 1 : 0));\r\n        prop.put(\"time-30\", ((searchtime == 30000) ? 1 : 0));\r\n        prop.put(\"time-60\", ((searchtime == 60000) ? 1 : 0));\r\n        prop.put(\"former\", (String) post.get(\"search\", \"\"));\r\n\r\n        // 'enrich search' variables\r\n        prop.put(\"num-results_former\", (String) post.get(\"search\", \"\"));\r\n        prop.put(\"num-results_time\", searchtime / 1000);\r\n        prop.put(\"num-results_count\", count);\r\n        prop.put(\"num-results_resource\", (global) ? \"global\" : \"local\");\r\n        prop.put(\"num-results_order\", order);\r\n\r\n        // return rewrite properties\r\n        prop.put(\"promoteSearchPageGreeting\", env.getConfig(\"promoteSearchPageGreeting\", \"\"));\r\n\r\n        // adding some additional properties needed for the rss feed\r\n        String hostName = (String) header.get(\"Host\",\"localhost\");\r\n        if (hostName.indexOf(\":\") == -1) hostName += \":\" + env.getConfig(\"port\",\"8080\");\r\n        prop.put(\"rssYacyImageURL\",\"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n\r\n        return prop;\r\n    }","id":72325,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n\r\n        boolean global = (post == null) ? true : ((String) post.get(\"resource\", \"global\")).equals(\"global\");\r\n        final boolean indexDistributeGranted = sb.getConfig(\"allowDistributeIndex\", \"true\").equals(\"true\");\r\n        final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        if (!indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n\r\n        // case if no values are requested\r\n        final String referer = (String) header.get(\"Referer\");\r\n        if (post == null || env == null) {\r\n\r\n            // save referrer\r\n            // System.out.println(\"HEADER=\" + header.toString());\r\n            if (referer != null) {\r\n                URL url;\r\n                try { url = new URL(referer); } catch (MalformedURLException e) { url = null; }\r\n                if ((url != null) && (serverCore.isNotLocal(url))) {\r\n                    final HashMap referrerprop = new HashMap();\r\n                    referrerprop.put(\"count\", \"1\");\r\n                    referrerprop.put(\"clientip\", header.get(\"CLIENTIP\"));\r\n                    referrerprop.put(\"useragent\", header.get(\"User-Agent\"));\r\n                    referrerprop.put(\"date\", (new serverDate()).toShortString(false));\r\n                    if (sb.facilityDB != null) try { sb.facilityDB.update(\"backlinks\", referer, referrerprop); } catch (IOException e) {}\r\n                }\r\n            }\r\n\r\n            // we create empty entries for template strings\r\n            final serverObjects prop = new serverObjects();\r\n            prop.put(\"promoteSearchPageGreeting\", env.getConfig(\"promoteSearchPageGreeting\", \"\"));\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"num-results\", 0);\r\n            prop.put(\"excluded\", 0);\r\n            prop.put(\"combine\", 0);\r\n            prop.put(\"resultbottomline\", 0);\r\n            prop.put(\"count-10\", 0);\r\n            prop.put(\"count-50\", 0);\r\n            prop.put(\"count-100\", 0);\r\n            prop.put(\"count-1000\", 0);\r\n            prop.put(\"order-quality\", 0);\r\n            prop.put(\"order-date\", 0);\r\n            prop.put(\"resource-global\", ((global) ? 1 : 0));\r\n            prop.put(\"resource-local\", ((global) ? 0 : 1));\r\n            prop.put(\"time-1\", 0);\r\n            prop.put(\"time-3\", 0);\r\n            prop.put(\"time-10\", 1);\r\n            prop.put(\"time-30\", 0);\r\n            prop.put(\"time-60\", 0);\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"urlmaskoptions\", 0);\r\n            prop.put(\"urlmaskoptions_urlmaskfilter\", \".*\");\r\n            return prop;\r\n        }\r\n\r\n        // SEARCH\r\n        // process search words\r\n        final String querystring = (String) post.get(\"search\", \"\");\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n        final TreeSet query = plasmaSearchQuery.cleanQuery(querystring);\r\n        // filter out stopwords\r\n        final TreeSet filtered = kelondroMSetTools.joinConstructive(query, plasmaSwitchboard.stopwords);\r\n        if (filtered.size() > 0) {\r\n            kelondroMSetTools.excludeDestructive(query, plasmaSwitchboard.stopwords);\r\n        }\r\n\r\n        // prepare search order\r\n        final String order = (String) post.get(\"order\", \"\");\r\n        final int count = Integer.parseInt((String) post.get(\"count\", \"10\"));\r\n        final long searchtime = 1000 * Long.parseLong((String) post.get(\"time\", \"1\"));\r\n        final boolean yacyonline = ((yacyCore.seedDB != null) &&\r\n                                    (yacyCore.seedDB.mySeed != null) &&\r\n                                    (yacyCore.seedDB.mySeed.getAddress() != null));\r\n\r\n        final String order1 = (order.equals(\"Quality-Date\")) ? \"quality\" : \"date\";\r\n        final String order2 = (order.equals(\"Quality-Date\")) ? \"date\" : \"quality\";\r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n\r\n        // do the search\r\n        plasmaSearchQuery thisSearch = new plasmaSearchQuery(query, referer, new String[]{order1, order2}, count, searchtime, urlmask,\r\n                                                             ((global) && (yacyonline) && (!(env.getConfig(\"last-search\",\"\").equals(querystring)))) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL,\r\n                                                             \"\", 20);\r\n        final serverObjects prop = sb.searchFromLocal(thisSearch);\r\n        /*\r\n        final serverObjects prop = sb.searchFromLocal(query, order1, order2, count,\r\n                                   ((global) && (yacyonline) && (!(env.getConfig(\"last-search\",\"\").equals(querystring)))),\r\n                                     searchtime, urlmask);\r\n                                     */\r\n        // remember the last search expression\r\n        env.setConfig(\"last-search\", querystring);\r\n        // process result of search\r\n        prop.put(\"resultbottomline\", 0);\r\n        if (filtered.size() > 0){\r\n            prop.put(\"excluded\", 1);\r\n            prop.put(\"excluded_stopwords\", filtered.toString());\r\n        } else {\r\n            prop.put(\"excluded\", 0);\r\n        }\r\n\r\n        if (prop == null || prop.size() == 0) {\r\n            if (((String) post.get(\"search\", \"\")).length() < 3) {\r\n                prop.put(\"num-results\", 2); // no results - at least 3 chars\r\n            } else {\r\n                prop.put(\"num-results\", 1);//no results\r\n            }\r\n        } else {\r\n            final int linkcount = Integer.parseInt(prop.get(\"linkcount\", \"0\"));\r\n            final int orderedcount = Integer.parseInt(prop.get(\"orderedcount\", \"0\"));\r\n            final int totalcount = Integer.parseInt(prop.get(\"totalcount\", \"0\"));\r\n            if (totalcount > 10) {\r\n                final Object[] references = (Object[]) prop.get(\"references\", new String[0]);\r\n                prop.put(\"num-results\", 4);\r\n                prop.put(\"num-results_linkcount\", linkcount);\r\n                prop.put(\"num-results_orderedcount\", orderedcount);\r\n                prop.put(\"num-results_totalcount\", totalcount);\r\n                int hintcount = references.length;\r\n                if (hintcount > 0) {\r\n                    if (hintcount > 16) { hintcount = 16; }\r\n                    prop.put(\"combine\", 1);\r\n                    String word;\r\n                    for (int i = 0; i < hintcount; i++) {\r\n                        word = (String) references[i];\r\n                        if (word != null) {\r\n                            prop.put(\"combine_words_\" + i + \"_word\", word);\r\n                            prop.put(\"combine_words_\" + i + \"_newsearch\", ((String) post.get(\"search\", \"\")).replace(' ', '+') + \"+\" + word);\r\n                            prop.put(\"combine_words_\" + i + \"_count\", count);\r\n                            prop.put(\"combine_words_\" + i + \"_order\", order);\r\n                            prop.put(\"combine_words_\" + i + \"_resource\", ((global) ? \"global\" : \"local\"));\r\n                            prop.put(\"combine_words_\" + i + \"_time\", (searchtime / 1000));\r\n                        }\r\n                        prop.put(\"combine_words\", i);\r\n                    }\r\n                }\r\n            } else {\r\n                if (totalcount == 0) {\r\n                    prop.put(\"num-results\", 3);//long\r\n                } else {\r\n                    prop.put(\"num-results\", 4);\r\n                    prop.put(\"num-results_linkcount\", linkcount);\r\n                    prop.put(\"num-results_orderedcount\", orderedcount);\r\n                    prop.put(\"num-results_totalcount\", totalcount);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (urlmask.equals(\".*\")) {\r\n            prop.put(\"urlmaskoptions\", 0);\r\n        } else {\r\n            prop.put(\"urlmaskoptions\", 1);\r\n        }\r\n\r\n        prop.put(\"urlmaskoptions_urlmaskfilter\", urlmask);\r\n\r\n        if (yacyonline) {\r\n            if (global) {\r\n                prop.put(\"resultbottomline\", 1);\r\n                prop.put(\"resultbottomline_globalresults\", prop.get(\"globalresults\", \"0\"));\r\n            } else {\r\n                prop.put(\"resultbottomline\", 2);\r\n            }\r\n        } else {\r\n            if (global) {\r\n                prop.put(\"resultbottomlien\", 3);\r\n            } else {\r\n                prop.put(\"resultbottomline\", 4);\r\n            }\r\n        }\r\n\r\n        prop.put(\"count-10\", ((count == 10)) ? 1 : 0);\r\n        prop.put(\"count-50\", ((count == 50)) ? 1 : 0);\r\n        prop.put(\"count-100\", ((count == 100)) ? 1 : 0);\r\n        prop.put(\"count-1000\", ((count == 1000)) ? 1 : 0);\r\n        prop.put(\"order-quality\", ((order.equals(\"Quality-Date\")) ? 1 : 0));\r\n        prop.put(\"order-date\", ((order.equals(\"Date-Quality\")) ? 1 : 0));\r\n        prop.put(\"resource-global\", ((global) ? 1 : 0));\r\n        prop.put(\"resource-local\", ((global) ? 0 : 1));\r\n        prop.put(\"time-1\", ((searchtime == 1000) ? 1 : 0));\r\n        prop.put(\"time-3\", ((searchtime == 3000) ? 1 : 0));\r\n        prop.put(\"time-10\", ((searchtime == 10000) ? 1 : 0));\r\n        prop.put(\"time-30\", ((searchtime == 30000) ? 1 : 0));\r\n        prop.put(\"time-60\", ((searchtime == 60000) ? 1 : 0));\r\n        prop.put(\"former\", (String) post.get(\"search\", \"\"));\r\n\r\n        // 'enrich search' variables\r\n        prop.put(\"num-results_former\", (String) post.get(\"search\", \"\"));\r\n        prop.put(\"num-results_time\", searchtime / 1000);\r\n        prop.put(\"num-results_count\", count);\r\n        prop.put(\"num-results_resource\", (global) ? \"global\" : \"local\");\r\n        prop.put(\"num-results_order\", order);\r\n\r\n        // return rewrite properties\r\n        prop.put(\"promoteSearchPageGreeting\", env.getConfig(\"promoteSearchPageGreeting\", \"\"));\r\n\r\n        // adding some additional properties needed for the rss feed\r\n        String hostName = (String) header.get(\"Host\",\"localhost\");\r\n        if (hostName.indexOf(\":\") == -1) hostName += \":\" + env.getConfig(\"port\",\"8080\");\r\n        prop.put(\"rssYacyImageURL\",\"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n\r\n        return prop;\r\n    }","commit_id":"77ae30063ddd0c5eda2587efe64cc1ac6a051d6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public plasmaWordIndexEntity searchWords(Set words, long time) throws IOException {\r\n\t// search for the set of words and return an array of urlEntry elements\r\n        return searchHashes(words2hashes(words), time);\r\n    }","id":72326,"modified_method":"public plasmaWordIndexEntity searchWords(Set words, long time) throws IOException {\r\n\t// search for the set of words and return an array of urlEntry elements\r\n        return searchHashes(plasmaSearchQuery.words2hashes(words), time);\r\n    }","commit_id":"77ae30063ddd0c5eda2587efe64cc1ac6a051d6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public plasmaSearch.result order(plasmaWordIndexEntity searchResult, Set searchhashes, Set stopwords, char[] priority, long maxTime, int minEntries) throws IOException {\r\n\t// we collect the urlhashes from it and construct a List with urlEntry objects\r\n\t// attention: if minEntries is too high, this method will not terminate within the maxTime\r\n\r\n\tplasmaSearch.result acc = new result(searchhashes, stopwords, priority);\r\n\tif (searchResult == null) return acc; // strange case where searchResult is not proper: acc is then empty\r\n        if (searchResult.size() == 0) return acc; // case that we have nothing to do\r\n        \r\n\tEnumeration e = searchResult.elements(true);\r\n\tplasmaWordIndexEntry entry;\r\n        long startCreateTime = System.currentTimeMillis();\r\n\ttry {\r\n\t    while (e.hasMoreElements()) {\r\n                if ((acc.sizeFetched() >= minEntries) &&\r\n                    (System.currentTimeMillis() - startCreateTime >= maxTime)) break;\r\n                entry = (plasmaWordIndexEntry) e.nextElement();\r\n\t\tacc.addResult(entry);\r\n\t    }\r\n\t} catch (kelondroException ee) {\r\n\t    serverLog.logSevere(\"PLASMA\", \"Database Failure during plasmaSearch.order: \" + ee.getMessage(), ee);\r\n\t}\r\n        long startSortTime = System.currentTimeMillis();\r\n        acc.sortResults();\r\n        serverLog.logFine(\"PLASMA\", \"plasmaSearch.order: minEntries = \" + minEntries + \", effectiveEntries = \" + acc.sizeOrdered() + \", demanded Time = \" + maxTime + \", effectiveTime = \" + (System.currentTimeMillis() - startCreateTime) + \", createTime = \" + (startSortTime - startCreateTime) + \", sortTime = \" + (System.currentTimeMillis() - startSortTime));\r\n\treturn acc;\r\n    }","id":72327,"modified_method":"public plasmaSearchResult order(plasmaWordIndexEntity searchResult, Set searchhashes, Set stopwords, char[] priority, long maxTime, int minEntries) throws IOException {\r\n\t// we collect the urlhashes from it and construct a List with urlEntry objects\r\n\t// attention: if minEntries is too high, this method will not terminate within the maxTime\r\n\r\n\tplasmaSearchResult acc = new plasmaSearchResult(searchhashes, stopwords, priority);\r\n\tif (searchResult == null) return acc; // strange case where searchResult is not proper: acc is then empty\r\n        if (searchResult.size() == 0) return acc; // case that we have nothing to do\r\n        \r\n\tEnumeration e = searchResult.elements(true);\r\n\tplasmaWordIndexEntry entry;\r\n        long startCreateTime = System.currentTimeMillis();\r\n        plasmaCrawlLURL.Entry page;\r\n\ttry {\r\n\t    while (e.hasMoreElements()) {\r\n                if ((acc.sizeFetched() >= minEntries) &&\r\n                    (System.currentTimeMillis() - startCreateTime >= maxTime)) break;\r\n                entry = (plasmaWordIndexEntry) e.nextElement();\r\n                // find the url entry\r\n                page = urlStore.getEntry(entry.getUrlHash());\r\n                // add a result\r\n\t\tacc.addResult(entry, page);\r\n\t    }\r\n\t} catch (kelondroException ee) {\r\n\t    serverLog.logSevere(\"PLASMA\", \"Database Failure during plasmaSearch.order: \" + ee.getMessage(), ee);\r\n\t}\r\n        long startSortTime = System.currentTimeMillis();\r\n        acc.sortResults();\r\n        serverLog.logFine(\"PLASMA\", \"plasmaSearch.order: minEntries = \" + minEntries + \", effectiveEntries = \" + acc.sizeOrdered() + \", demanded Time = \" + maxTime + \", effectiveTime = \" + (System.currentTimeMillis() - startCreateTime) + \", createTime = \" + (startSortTime - startCreateTime) + \", sortTime = \" + (System.currentTimeMillis() - startSortTime));\r\n\treturn acc;\r\n    }","commit_id":"77ae30063ddd0c5eda2587efe64cc1ac6a051d6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void fetch(plasmaSearch.result acc, Set queryhashes, String urlmask, int fetchcount) {\n        // fetch snippets\n        int i = 0;\n        plasmaCrawlLURL.Entry urlentry;\n        String urlstring;\n        plasmaSnippetCache.result snippet;\n        while ((acc.hasMoreElements()) && (i < fetchcount)) {\n            urlentry = acc.nextElement();\n            if (urlentry.url().getHost().endsWith(\".yacyh\")) continue;\n            urlstring = htmlFilterContentScraper.urlNormalform(urlentry.url());\n            if ((urlstring.matches(urlmask)) &&\n                (!(existsInCache(urlentry.url(), queryhashes)))) {\n                new Fetcher(urlentry.url(), queryhashes).start();\n                i++;\n            }\n        }\n    }","id":72328,"modified_method":"public void fetch(plasmaSearchResult acc, Set queryhashes, String urlmask, int fetchcount) {\n        // fetch snippets\n        int i = 0;\n        plasmaCrawlLURL.Entry urlentry;\n        String urlstring;\n        plasmaSnippetCache.result snippet;\n        while ((acc.hasMoreElements()) && (i < fetchcount)) {\n            urlentry = acc.nextElement();\n            if (urlentry.url().getHost().endsWith(\".yacyh\")) continue;\n            urlstring = htmlFilterContentScraper.urlNormalform(urlentry.url());\n            if ((urlstring.matches(urlmask)) &&\n                (!(existsInCache(urlentry.url(), queryhashes)))) {\n                new Fetcher(urlentry.url(), queryhashes).start();\n                i++;\n            }\n        }\n    }","commit_id":"77ae30063ddd0c5eda2587efe64cc1ac6a051d6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public serverObjects searchFromRemote(Set hashes, int count, boolean global, long duetime) {\r\n\r\n\t// tell all threads to do nothing for a specific time\r\n\twordIndex.intermission(duetime);\r\n\tintermissionAllThreads(duetime);\r\n\r\n        if (hashes == null) hashes = new HashSet();\r\n        serverObjects prop = new serverObjects();\r\n        try {\r\n            log.logInfo(\"INIT HASH SEARCH: \" + hashes + \" - \" + count + \" links\");\r\n            long timestamp = System.currentTimeMillis();\r\n            plasmaWordIndexEntity idx = searchManager.searchHashes(hashes, duetime * 8 / 10); // a nameless temporary index, not sorted by special order but by hash\r\n            long remainingTime = duetime - (System.currentTimeMillis() - timestamp);\r\n            if (remainingTime < 500) remainingTime = 500;\r\n            plasmaSearch.result acc = searchManager.order(idx, hashes, stopwords, new char[]{plasmaSearch.O_QUALITY, plasmaSearch.O_AGE}, remainingTime, 10);\r\n            \r\n            // result is a List of urlEntry elements\r\n            if (acc == null) {\r\n                prop.put(\"totalcount\", \"0\");\r\n                prop.put(\"linkcount\", \"0\");\r\n                prop.put(\"references\", \"\");\r\n            } else {\r\n                prop.put(\"totalcount\", Integer.toString(acc.sizeOrdered()));\r\n                int i = 0;\r\n                StringBuffer links = new StringBuffer();\r\n                String resource = \"\";\r\n                //plasmaIndexEntry pie;\r\n                plasmaCrawlLURL.Entry urlentry;\r\n                plasmaSnippetCache.result snippet;\r\n                while ((acc.hasMoreElements()) && (i < count)) {\r\n                    urlentry = acc.nextElement();\r\n                    snippet = snippetCache.retrieve(urlentry.url(), hashes, false, 260);\r\n                    if (snippet.source == plasmaSnippetCache.ERROR_NO_MATCH) {\r\n                        // suppress line: there is no match in that resource\r\n                    } else {\r\n                        if (snippet.line == null) {\r\n                            resource = urlentry.toString();\r\n                        } else {\r\n                            resource = urlentry.toString(snippet.line);\r\n                        }\r\n                        if (resource != null) {\r\n                            links.append(\"resource\").append(i).append(\"=\").append(resource).append(serverCore.crlfString);\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"links\", links.toString());\r\n                prop.put(\"linkcount\", Integer.toString(i));\r\n                \r\n                // prepare reference hints\r\n                Object[] ws = acc.getReferences(16);\r\n                StringBuffer refstr = new StringBuffer();\r\n                for (int j = 0; j < ws.length; j++) refstr.append(\",\").append((String) ws[j]);\r\n                prop.put(\"references\", (refstr.length() > 0)?refstr.substring(1):refstr.toString());\r\n            }\r\n            \r\n            // add information about forward peers\r\n            prop.put(\"fwhop\", \"\"); // hops (depth) of forwards that had been performed to construct this result\r\n            prop.put(\"fwsrc\", \"\"); // peers that helped to construct this result\r\n            prop.put(\"fwrec\", \"\"); // peers that would have helped to construct this result (recommendations)\r\n            \r\n            // log\r\n            log.logInfo(\"EXIT HASH SEARCH: \" + hashes + \" - \" +\r\n            ((idx == null) ? \"0\" : (\"\"+idx.size())) + \" links found, \" +\r\n\t    prop.get(\"linkcount\", \"?\") + \" links selected, \" +\r\n            ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            if (idx != null) idx.close();\r\n            return prop;\r\n        } catch (IOException e) {\r\n            return null;\r\n        }\r\n    }","id":72329,"modified_method":"public serverObjects searchFromRemote(Set hashes, int count, boolean global, long duetime) {\r\n\r\n\t// tell all threads to do nothing for a specific time\r\n\twordIndex.intermission(duetime);\r\n\tintermissionAllThreads(duetime);\r\n\r\n        if (hashes == null) hashes = new HashSet();\r\n        serverObjects prop = new serverObjects();\r\n        try {\r\n            log.logInfo(\"INIT HASH SEARCH: \" + hashes + \" - \" + count + \" links\");\r\n            long timestamp = System.currentTimeMillis();\r\n            plasmaWordIndexEntity idx = searchManager.searchHashes(hashes, duetime * 8 / 10); // a nameless temporary index, not sorted by special order but by hash\r\n            long remainingTime = duetime - (System.currentTimeMillis() - timestamp);\r\n            if (remainingTime < 500) remainingTime = 500;\r\n            plasmaSearchResult acc = searchManager.order(idx, hashes, stopwords, new char[]{plasmaSearchResult.O_QUALITY, plasmaSearchResult.O_AGE}, remainingTime, 10);\r\n            \r\n            // result is a List of urlEntry elements\r\n            if (acc == null) {\r\n                prop.put(\"totalcount\", \"0\");\r\n                prop.put(\"linkcount\", \"0\");\r\n                prop.put(\"references\", \"\");\r\n            } else {\r\n                prop.put(\"totalcount\", Integer.toString(acc.sizeOrdered()));\r\n                int i = 0;\r\n                StringBuffer links = new StringBuffer();\r\n                String resource = \"\";\r\n                //plasmaIndexEntry pie;\r\n                plasmaCrawlLURL.Entry urlentry;\r\n                plasmaSnippetCache.result snippet;\r\n                while ((acc.hasMoreElements()) && (i < count)) {\r\n                    urlentry = acc.nextElement();\r\n                    snippet = snippetCache.retrieve(urlentry.url(), hashes, false, 260);\r\n                    if (snippet.source == plasmaSnippetCache.ERROR_NO_MATCH) {\r\n                        // suppress line: there is no match in that resource\r\n                    } else {\r\n                        if (snippet.line == null) {\r\n                            resource = urlentry.toString();\r\n                        } else {\r\n                            resource = urlentry.toString(snippet.line);\r\n                        }\r\n                        if (resource != null) {\r\n                            links.append(\"resource\").append(i).append(\"=\").append(resource).append(serverCore.crlfString);\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"links\", links.toString());\r\n                prop.put(\"linkcount\", Integer.toString(i));\r\n                \r\n                // prepare reference hints\r\n                Object[] ws = acc.getReferences(16);\r\n                StringBuffer refstr = new StringBuffer();\r\n                for (int j = 0; j < ws.length; j++) refstr.append(\",\").append((String) ws[j]);\r\n                prop.put(\"references\", (refstr.length() > 0)?refstr.substring(1):refstr.toString());\r\n            }\r\n            \r\n            // add information about forward peers\r\n            prop.put(\"fwhop\", \"\"); // hops (depth) of forwards that had been performed to construct this result\r\n            prop.put(\"fwsrc\", \"\"); // peers that helped to construct this result\r\n            prop.put(\"fwrec\", \"\"); // peers that would have helped to construct this result (recommendations)\r\n            \r\n            // log\r\n            log.logInfo(\"EXIT HASH SEARCH: \" + hashes + \" - \" +\r\n            ((idx == null) ? \"0\" : (\"\"+idx.size())) + \" links found, \" +\r\n\t    prop.get(\"linkcount\", \"?\") + \" links selected, \" +\r\n            ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            if (idx != null) idx.close();\r\n            return prop;\r\n        } catch (IOException e) {\r\n            return null;\r\n        }\r\n    }","commit_id":"77ae30063ddd0c5eda2587efe64cc1ac6a051d6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void run() {\r\n            plasmaWordIndexEntity idx = null;\r\n            try {\r\n                // search the database locally\r\n                log.logFine(\"presearch: started job\");\r\n                idx = searchManager.searchHashes(queryhashes, time);\r\n                log.logFine(\"presearch: found \" + idx.size() + \" results\");\r\n                plasmaSearch.result acc = searchManager.order(idx, queryhashes, stopwords, order, time, searchcount);\r\n                if (acc == null) return;\r\n                log.logFine(\"presearch: ordered results, now \" + acc.sizeOrdered() + \" URLs ready for fetch\");\r\n                \r\n                // take some elements and fetch the snippets\r\n                snippetCache.fetch(acc, queryhashes, urlmask, fetchcount);\r\n            } catch (IOException e) {\r\n                log.logSevere(\"presearch: failed\", e);\r\n            } finally {\r\n                if (idx != null) try { idx.close(); } catch (Exception e){}\r\n            }\r\n            log.logFine(\"presearch: job terminated\");\r\n        }","id":72330,"modified_method":"public void run() {\r\n            plasmaWordIndexEntity idx = null;\r\n            try {\r\n                // search the database locally\r\n                log.logFine(\"presearch: started job\");\r\n                idx = searchManager.searchHashes(queryhashes, time);\r\n                log.logFine(\"presearch: found \" + idx.size() + \" results\");\r\n                plasmaSearchResult acc = searchManager.order(idx, queryhashes, stopwords, order, time, searchcount);\r\n                if (acc == null) return;\r\n                log.logFine(\"presearch: ordered results, now \" + acc.sizeOrdered() + \" URLs ready for fetch\");\r\n                \r\n                // take some elements and fetch the snippets\r\n                snippetCache.fetch(acc, queryhashes, urlmask, fetchcount);\r\n            } catch (IOException e) {\r\n                log.logSevere(\"presearch: failed\", e);\r\n            } finally {\r\n                if (idx != null) try { idx.close(); } catch (Exception e){}\r\n            }\r\n            log.logFine(\"presearch: job terminated\");\r\n        }","commit_id":"77ae30063ddd0c5eda2587efe64cc1ac6a051d6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic static void fetch(final ODocument iRootRecord, final Object iUserObject, final Map<String, Integer> iFetchPlan,\r\n\t\t\tfinal String iCurrentField, final int iCurrentLevel, final int iMaxFetch, final OFetchListener iListener) {\r\n\r\n\t\tif (iMaxFetch > -1 && iListener.size() >= iMaxFetch)\r\n\t\t\t// MAX FETCH SIZE REACHED: STOP TO FETCH AT ALL\r\n\t\t\treturn;\r\n\r\n\t\tObject fieldValue;\r\n\t\tInteger depthLevel;\r\n\t\tfinal Integer anyFieldDepthLevel = iFetchPlan != null ? iFetchPlan.get(ANY_FIELD) : -1;\r\n\t\ttry {\r\n\t\t\t// BROWSE ALL THE DOCUMENT'S FIELDS\r\n\t\t\tfor (String fieldName : iRootRecord.fieldNames()) {\r\n\t\t\t\tfieldValue = iRootRecord.field(fieldName);\r\n\r\n\t\t\t\tif (fieldValue == null\r\n\t\t\t\t\t\t|| !(fieldValue instanceof ODocument)\r\n\t\t\t\t\t\t&& (!(fieldValue instanceof Collection<?>) || (((Collection<?>) fieldValue).size() > 0 && !(((Collection<?>) fieldValue)\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument)))\r\n\t\t\t\t\t\t&& (!(fieldValue instanceof Map<?, ?>) || (((Map<?, ?>) fieldValue).size() > 0 && !(((Map<?, ?>) fieldValue).values()\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument))))\r\n\t\t\t\t\t// NULL NEITHER LINK, NOR COLLECTION OF LINKS OR MAP OF LINKS\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tdepthLevel = getDepthLevel(iRootRecord, iFetchPlan, fieldName);\r\n\r\n\t\t\t\tif (depthLevel == null)\r\n\t\t\t\t\t// NO SPECIFIED: ASSIGN DEFAULT LEVEL TAKEN FROM * WILDCARD IF ANY\r\n\t\t\t\t\tdepthLevel = anyFieldDepthLevel;\r\n\r\n\t\t\t\tif (depthLevel == 0)\r\n\t\t\t\t\t// NO FETCH THIS FIELD PLEASE\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tif (depthLevel > -1 && iCurrentLevel >= depthLevel)\r\n\t\t\t\t\t// MAX DEPTH REACHED: STOP TO FETCH THIS FIELD\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tObject userObject;\r\n\t\t\t\tif (fieldValue instanceof ODocument) {\r\n\t\t\t\t\tfinal ODocument linked = (ODocument) fieldValue;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tuserObject = iListener.fetchLinked(iRootRecord, iUserObject, fieldName, linked);\r\n\t\t\t\t\t\tif (userObject != null)\r\n\t\t\t\t\t\t\t// GO RECURSIVELY\r\n\t\t\t\t\t\t\tfetch(linked, userObject, iFetchPlan, fieldName, iCurrentLevel + 1, iMaxFetch, iListener);\r\n\t\t\t\t\t} catch (ORecordNotFoundException e) {\r\n\t\t\t\t\t\tOLogManager.instance().error(null, \"Linked record %s was not found\", linked);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if (fieldValue instanceof Collection<?>) {\r\n\t\t\t\t\tfinal Collection<ODocument> linked = (Collection<ODocument>) fieldValue;\r\n\t\t\t\t\tuserObject = iListener.fetchLinked(iRootRecord, iUserObject, fieldName, linked);\r\n\t\t\t\t\tif (userObject != null)\r\n\t\t\t\t\t\tfor (ODocument d : (Collection<ODocument>) userObject) {\r\n\t\t\t\t\t\t\t// GO RECURSIVELY\r\n\t\t\t\t\t\t\tfetch(d, d, iFetchPlan, fieldName, iCurrentLevel + 1, iMaxFetch, iListener);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} else if (fieldValue instanceof Map<?, ?>) {\r\n\t\t\t\t\tfinal Map<String, ODocument> linked = (Map<String, ODocument>) fieldValue;\r\n\t\t\t\t\tuserObject = iListener.fetchLinked(iRootRecord, iUserObject, fieldName, linked);\r\n\t\t\t\t\tif (userObject != null)\r\n\t\t\t\t\t\tfor (ODocument d : ((Map<String, ODocument>) userObject).values()) {\r\n\t\t\t\t\t\t\t// GO RECURSIVELY\r\n\t\t\t\t\t\t\tfetch(d, d, iFetchPlan, fieldName, iCurrentLevel + 1, iMaxFetch, iListener);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (iMaxFetch > -1 && iListener.size() >= iMaxFetch)\r\n\t\t\t\t\t// MAX FETCH SIZE REACHED: STOP TO FETCH AT ALL\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tOLogManager.instance().error(null, \"Fetching error on record %s\", e, iRootRecord.getIdentity());\r\n\t\t}\r\n\t}","id":72331,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic static void fetch(final ODocument iRootRecord, final Object iUserObject, final Map<String, Integer> iFetchPlan,\r\n\t\t\tfinal String iCurrentField, final int iCurrentLevel, final int iMaxFetch, final OFetchListener iListener) {\r\n\r\n\t\tif (iMaxFetch > -1 && iListener.size() >= iMaxFetch)\r\n\t\t\t// MAX FETCH SIZE REACHED: STOP TO FETCH AT ALL\r\n\t\t\treturn;\r\n\r\n\t\tObject fieldValue;\r\n\t\tInteger depthLevel;\r\n\t\tfinal Integer anyFieldDepthLevel = iFetchPlan != null ? iFetchPlan.get(ANY_FIELD) : -1;\r\n\t\ttry {\r\n\t\t\t// BROWSE ALL THE DOCUMENT'S FIELDS\r\n\t\t\tfor (String fieldName : iRootRecord.fieldNames()) {\r\n\t\t\t\tfieldValue = iRootRecord.field(fieldName);\r\n\r\n\t\t\t\tif (fieldValue == null\r\n\t\t\t\t\t\t|| !(fieldValue instanceof ODocument)\r\n\t\t\t\t\t\t&& (!(fieldValue instanceof Collection<?>) || (((Collection<?>) fieldValue).size() > 0 && !(((Collection<?>) fieldValue)\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument)))\r\n\t\t\t\t\t\t&& (!(fieldValue instanceof Map<?, ?>) || (((Map<?, ?>) fieldValue).size() > 0 && !(((Map<?, ?>) fieldValue).values()\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument))))\r\n\t\t\t\t\t// NULL NEITHER LINK, NOR COLLECTION OF LINKS OR MAP OF LINKS\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tdepthLevel = getDepthLevel(iRootRecord, iFetchPlan, fieldName);\r\n\r\n\t\t\t\tif (depthLevel == null)\r\n\t\t\t\t\t// NO SPECIFIED: ASSIGN DEFAULT LEVEL TAKEN FROM * WILDCARD IF ANY\r\n\t\t\t\t\tdepthLevel = anyFieldDepthLevel;\r\n\r\n\t\t\t\tif (depthLevel == 0)\r\n\t\t\t\t\t// NO FETCH THIS FIELD PLEASE\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tif (depthLevel > -1 && iCurrentLevel >= depthLevel)\r\n\t\t\t\t\t// MAX DEPTH REACHED: STOP TO FETCH THIS FIELD\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tObject userObject;\r\n\t\t\t\tif (fieldValue instanceof ODocument) {\r\n\t\t\t\t\tfinal ODocument linked = (ODocument) fieldValue;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tuserObject = iListener.fetchLinked(iRootRecord, iUserObject, fieldName, linked);\r\n\t\t\t\t\t\tif (userObject != null)\r\n\t\t\t\t\t\t\t// GO RECURSIVELY\r\n\t\t\t\t\t\t\tfetch(linked, userObject, iFetchPlan, fieldName, iCurrentLevel + 1, iMaxFetch, iListener);\r\n\t\t\t\t\t} catch (ORecordNotFoundException e) {\r\n\t\t\t\t\t\tOLogManager.instance().error(null, \"Linked record %s was not found\", linked);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if (fieldValue instanceof Collection<?>) {\r\n\t\t\t\t\tfinal Collection<ODocument> linked = (Collection<ODocument>) fieldValue;\r\n\t\t\t\t\tuserObject = iListener.fetchLinked(iRootRecord, iUserObject, fieldName, linked);\r\n\t\t\t\t\tif (userObject != null)\r\n\t\t\t\t\t\tfor (ODocument d : (Collection<ODocument>) userObject) {\r\n\t\t\t\t\t\t\t// GO RECURSIVELY\r\n\t\t\t\t\t\t\tif (d != null)\r\n\t\t\t\t\t\t\t\tfetch(d, d, iFetchPlan, fieldName, iCurrentLevel + 1, iMaxFetch, iListener);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} else if (fieldValue instanceof Map<?, ?>) {\r\n\t\t\t\t\tfinal Map<String, ODocument> linked = (Map<String, ODocument>) fieldValue;\r\n\t\t\t\t\tuserObject = iListener.fetchLinked(iRootRecord, iUserObject, fieldName, linked);\r\n\t\t\t\t\tif (userObject != null)\r\n\t\t\t\t\t\tfor (ODocument d : ((Map<String, ODocument>) userObject).values()) {\r\n\t\t\t\t\t\t\t// GO RECURSIVELY\r\n\t\t\t\t\t\t\tif (d != null)\r\n\t\t\t\t\t\t\t\tfetch(d, d, iFetchPlan, fieldName, iCurrentLevel + 1, iMaxFetch, iListener);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (iMaxFetch > -1 && iListener.size() >= iMaxFetch)\r\n\t\t\t\t\t// MAX FETCH SIZE REACHED: STOP TO FETCH AT ALL\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tOLogManager.instance().error(null, \"Fetching error on record %s\", e, iRootRecord.getIdentity());\r\n\t\t}\r\n\t}","commit_id":"3932f0f05e538d1c1901c44b66e188eec5ac876c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tprivate void fetchCollection(final Map<String, Integer> iFetchPlan, final Object fieldValue, final String fieldName,\r\n\t\t\tfinal int iCurrentLevel, final int iMaxFetch, final OJSONWriter json, final int indentLevel, final boolean includeType,\r\n\t\t\tfinal boolean includeId, final boolean includeVer, final boolean includeClazz, final boolean attribSameRow,\r\n\t\t\tfinal boolean keepTypes, final Set<ORID> parsedRecords) throws IOException {\r\n\t\tfinal Collection<ODocument> linked = (Collection<ODocument>) fieldValue;\r\n\t\tjson.beginCollection(indentLevel + 1, true, fieldName);\r\n\t\tfor (ODocument d : linked) {\r\n\t\t\t// GO RECURSIVELY\r\n\t\t\tif (!parsedRecords.contains((d).getIdentity())) {\r\n\t\t\t\tparsedRecords.add((d).getIdentity());\r\n\t\t\t\tjson.beginObject(indentLevel + 1, true, null);\r\n\t\t\t\twriteSignature(json, indentLevel, includeType, includeId, includeVer, includeClazz, attribSameRow, d);\r\n\t\t\t\tprocessRecord(json, indentLevel, includeType, includeId, includeVer, includeClazz, attribSameRow, d, iFetchPlan, keepTypes,\r\n\t\t\t\t\t\tiCurrentLevel + 1, iMaxFetch, parsedRecords);\r\n\t\t\t\tjson.endObject(indentLevel + 1, true);\r\n\t\t\t} else {\r\n\t\t\t\tjson.writeValue(indentLevel + 1, false, OJSONWriter.encode(d));\r\n\t\t\t}\r\n\t\t}\r\n\t\tjson.endCollection(indentLevel + 1, false);\r\n\t}","id":72332,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\tprivate void fetchCollection(final ODatabaseRecord iDatabase, final Map<String, Integer> iFetchPlan, final Object fieldValue,\r\n\t\t\tfinal String fieldName, final int iCurrentLevel, final int iMaxFetch, final OJSONWriter json, final int indentLevel,\r\n\t\t\tfinal boolean includeType, final boolean includeId, final boolean includeVer, final boolean includeClazz,\r\n\t\t\tfinal boolean attribSameRow, final boolean keepTypes, final Set<ORID> parsedRecords) throws IOException {\r\n\t\tfinal Collection<ODocument> linked = (Collection<ODocument>) fieldValue;\r\n\t\tjson.beginCollection(indentLevel + 1, true, fieldName);\r\n\t\tfor (OIdentifiable d : linked) {\r\n\t\t\t// GO RECURSIVELY\r\n\t\t\tif (!parsedRecords.contains((d).getIdentity())) {\r\n\t\t\t\tparsedRecords.add((d).getIdentity());\r\n\t\t\t\tif (d instanceof ORecordId) {\r\n\t\t\t\t\td = iDatabase.load((ORecordId) d);\r\n\t\t\t\t}\r\n\t\t\t\tif (!(d instanceof ODocument)) {\r\n\t\t\t\t\tjson.writeValue(indentLevel + 1, false, OJSONWriter.encode(d));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tjson.beginObject(indentLevel + 1, true, null);\r\n\t\t\t\t\twriteSignature(json, indentLevel, includeType, includeId, includeVer, includeClazz, attribSameRow, (ODocument) d);\r\n\t\t\t\t\tprocessRecord(json, indentLevel, includeType, includeId, includeVer, includeClazz, attribSameRow, (ODocument) d,\r\n\t\t\t\t\t\t\tiFetchPlan, keepTypes, iCurrentLevel + 1, iMaxFetch, parsedRecords);\r\n\t\t\t\t\tjson.endObject(indentLevel + 1, true);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tjson.writeValue(indentLevel + 1, false, OJSONWriter.encode(d));\r\n\t\t\t}\r\n\t\t}\r\n\t\tjson.endCollection(indentLevel + 1, false);\r\n\t}","commit_id":"3932f0f05e538d1c1901c44b66e188eec5ac876c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void processRecord(final OJSONWriter json, int indentLevel, boolean includeType, boolean includeId, boolean includeVer,\r\n\t\t\tboolean includeClazz, boolean attribSameRow, final ORecordSchemaAware<?> record, Map<String, Integer> iFetchPlan,\r\n\t\t\tboolean keepTypes, final int iCurrentLevel, final int iMaxFetch, final Set<ORID> parsedRecords) throws IOException {\r\n\t\tObject fieldValue;\r\n\r\n\t\tfinal StringBuilder types = new StringBuilder();\r\n\r\n\t\tfor (String fieldName : record.fieldNames()) {\r\n\t\t\tif (iFetchPlan == null) {\r\n\t\t\t\tfinal Object v = record.field(fieldName);\r\n\t\t\t\tif (keepTypes) {\r\n\t\t\t\t\tif (v instanceof Long)\r\n\t\t\t\t\t\tappendType(types, fieldName, 'l');\r\n\t\t\t\t\telse if (v instanceof Float)\r\n\t\t\t\t\t\tappendType(types, fieldName, 'f');\r\n\t\t\t\t\telse if (v instanceof Short)\r\n\t\t\t\t\t\tappendType(types, fieldName, 's');\r\n\t\t\t\t\telse if (v instanceof Double)\r\n\t\t\t\t\t\tappendType(types, fieldName, 'd');\r\n\t\t\t\t\telse if (v instanceof Date)\r\n\t\t\t\t\t\tappendType(types, fieldName, 't');\r\n\t\t\t\t\telse if (v instanceof Byte)\r\n\t\t\t\t\t\tappendType(types, fieldName, 'b');\r\n\t\t\t\t}\r\n\t\t\t\tjson.writeAttribute(indentLevel + 1, true, fieldName, OJSONWriter.encode(v));\r\n\t\t\t} else {\r\n\t\t\t\tfinal Integer depthLevel = getDepthLevel(record, iFetchPlan, fieldName);\r\n\t\t\t\tif (depthLevel != null) {\r\n\t\t\t\t\tif (depthLevel == 0) {\r\n\t\t\t\t\t\t// NO FETCH THIS FIELD PLEASE\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (depthLevel > -1 && depthLevel >= iCurrentLevel) {\r\n\t\t\t\t\t\t// MAX DEPTH REACHED: STOP TO FETCH THIS FIELD\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfieldValue = record.field(fieldName);\r\n\t\t\t\tif (fieldValue == null\r\n\t\t\t\t\t\t|| !(fieldValue instanceof ODocument)\r\n\t\t\t\t\t\t&& (!(fieldValue instanceof Collection<?>) || ((Collection<?>) fieldValue).size() == 0 || !(((Collection<?>) fieldValue)\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument))\r\n\t\t\t\t\t\t&& (!(fieldValue instanceof Map<?, ?>) || ((Map<?, ?>) fieldValue).size() == 0 || !(((Map<?, ?>) fieldValue).values()\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof ODocument))) {\r\n\t\t\t\t\tjson.writeAttribute(indentLevel + 1, true, fieldName, OJSONWriter.encode(fieldValue));\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tfetch(record, iFetchPlan, fieldValue, fieldName, iCurrentLevel + 1, iMaxFetch, json, indentLevel, includeType,\r\n\t\t\t\t\t\t\t\tincludeId, includeVer, includeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\tOLogManager.instance().error(null, \"Fetching error on record %s\", e, record.getIdentity());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (keepTypes && types.length() > 0)\r\n\t\t\tjson.writeAttribute(indentLevel + 1, true, ATTRIBUTE_FIELD_TYPES, types.toString());\r\n\t}","id":72333,"modified_method":"private void processRecord(final OJSONWriter json, int indentLevel, boolean includeType, boolean includeId, boolean includeVer,\r\n\t\t\tboolean includeClazz, boolean attribSameRow, final ORecordSchemaAware<?> record, Map<String, Integer> iFetchPlan,\r\n\t\t\tboolean keepTypes, final int iCurrentLevel, final int iMaxFetch, final Set<ORID> parsedRecords) throws IOException {\r\n\t\tObject fieldValue;\r\n\r\n\t\tfinal StringBuilder types = new StringBuilder();\r\n\r\n\t\tfor (String fieldName : record.fieldNames()) {\r\n\t\t\tif (iFetchPlan == null) {\r\n\t\t\t\tfinal Object v = record.field(fieldName);\r\n\t\t\t\tif (keepTypes) {\r\n\t\t\t\t\tif (v instanceof Long)\r\n\t\t\t\t\t\tappendType(types, fieldName, 'l');\r\n\t\t\t\t\telse if (v instanceof Float)\r\n\t\t\t\t\t\tappendType(types, fieldName, 'f');\r\n\t\t\t\t\telse if (v instanceof Short)\r\n\t\t\t\t\t\tappendType(types, fieldName, 's');\r\n\t\t\t\t\telse if (v instanceof Double)\r\n\t\t\t\t\t\tappendType(types, fieldName, 'd');\r\n\t\t\t\t\telse if (v instanceof Date)\r\n\t\t\t\t\t\tappendType(types, fieldName, 't');\r\n\t\t\t\t\telse if (v instanceof Byte)\r\n\t\t\t\t\t\tappendType(types, fieldName, 'b');\r\n\t\t\t\t}\r\n\t\t\t\tjson.writeAttribute(indentLevel + 1, true, fieldName, OJSONWriter.encode(v));\r\n\t\t\t} else {\r\n\t\t\t\tfinal Integer depthLevel = getDepthLevel(record, iFetchPlan, fieldName);\r\n\t\t\t\tif (depthLevel != null) {\r\n\t\t\t\t\tif (depthLevel == 0) {\r\n\t\t\t\t\t\t// NO FETCH THIS FIELD PLEASE\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (depthLevel > -1 && depthLevel >= iCurrentLevel) {\r\n\t\t\t\t\t\t// MAX DEPTH REACHED: STOP TO FETCH THIS FIELD\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfieldValue = record.field(fieldName);\r\n\t\t\t\tif (fieldValue == null\r\n\t\t\t\t\t\t|| !(fieldValue instanceof OIdentifiable)\r\n\t\t\t\t\t\t&& (!(fieldValue instanceof Collection<?>) || ((Collection<?>) fieldValue).size() == 0 || !(((Collection<?>) fieldValue)\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof OIdentifiable))\r\n\t\t\t\t\t\t&& (!(fieldValue instanceof Map<?, ?>) || ((Map<?, ?>) fieldValue).size() == 0 || !(((Map<?, ?>) fieldValue).values()\r\n\t\t\t\t\t\t\t\t.iterator().next() instanceof OIdentifiable))) {\r\n\t\t\t\t\tjson.writeAttribute(indentLevel + 1, true, fieldName, OJSONWriter.encode(fieldValue));\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tfetch(record, iFetchPlan, fieldValue, fieldName, iCurrentLevel + 1, iMaxFetch, json, indentLevel, includeType,\r\n\t\t\t\t\t\t\t\tincludeId, includeVer, includeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\tOLogManager.instance().error(null, \"Fetching error on record %s\", e, record.getIdentity());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (keepTypes && types.length() > 0)\r\n\t\t\tjson.writeAttribute(indentLevel + 1, true, ATTRIBUTE_FIELD_TYPES, types.toString());\r\n\t}","commit_id":"3932f0f05e538d1c1901c44b66e188eec5ac876c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void fetch(final ORecordSchemaAware<?> iRootRecord, final Map<String, Integer> iFetchPlan, final Object fieldValue,\r\n\t\t\tfinal String fieldName, final int iCurrentLevel, final int iMaxFetch, final OJSONWriter json, int indentLevel,\r\n\t\t\tboolean includeType, final boolean includeId, final boolean includeVer, final boolean includeClazz,\r\n\t\t\tfinal boolean attribSameRow, final boolean keepTypes, final Set<ORID> parsedRecords) throws IOException {\r\n\t\tInteger depthLevel;\r\n\t\tfinal Integer anyFieldDepthLevel = iFetchPlan != null ? iFetchPlan.get(\"*\") : -1;\r\n\t\tdepthLevel = getDepthLevel(iRootRecord, iFetchPlan, fieldName);\r\n\r\n\t\tif (depthLevel == null)\r\n\t\t\t// NO SPECIFIED: ASSIGN DEFAULT LEVEL TAKEN FROM * WILDCARD IF ANY\r\n\t\t\tdepthLevel = anyFieldDepthLevel;\r\n\r\n\t\tif (depthLevel == 0)\r\n\t\t\t// NO FETCH THIS FIELD PLEASE\r\n\t\t\treturn;\r\n\r\n\t\tif (depthLevel > -1 && iCurrentLevel >= depthLevel)\r\n\t\t\t// MAX DEPTH REACHED: STOP TO FETCH THIS FIELD\r\n\t\t\treturn;\r\n\r\n\t\tif (fieldValue == null) {\r\n\t\t\tjson.writeAttribute(indentLevel + 1, true, fieldName, null);\r\n\t\t} else if (fieldValue instanceof ODocument) {\r\n\t\t\tfetchDocument(iFetchPlan, fieldValue, fieldName, iCurrentLevel, iMaxFetch, json, indentLevel, includeType, includeId,\r\n\t\t\t\t\tincludeVer, includeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t} else if (fieldValue instanceof Collection<?>) {\r\n\t\t\tfetchCollection(iFetchPlan, fieldValue, fieldName, iCurrentLevel, iMaxFetch, json, indentLevel, includeType, includeId,\r\n\t\t\t\t\tincludeVer, includeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t} else if (fieldValue.getClass().isArray()) {\r\n\t\t\tfetchArray(iFetchPlan, fieldValue, fieldName, iCurrentLevel, iMaxFetch, json, indentLevel, includeType, includeId,\r\n\t\t\t\t\tincludeVer, includeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t} else if (fieldValue instanceof Map<?, ?>) {\r\n\t\t\tfetchMap(iFetchPlan, fieldValue, fieldName, iCurrentLevel, iMaxFetch, json, indentLevel, includeType, includeId, includeVer,\r\n\t\t\t\t\tincludeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t}\r\n\t\tif (iMaxFetch > -1 && iCurrentLevel >= iMaxFetch) {\r\n\t\t\t// MAX FETCH SIZE REACHED: STOP TO FETCH AT ALL\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t}","id":72334,"modified_method":"private void fetch(final ORecordSchemaAware<?> iRootRecord, final Map<String, Integer> iFetchPlan, final Object fieldValue,\r\n\t\t\tfinal String fieldName, final int iCurrentLevel, final int iMaxFetch, final OJSONWriter json, int indentLevel,\r\n\t\t\tboolean includeType, final boolean includeId, final boolean includeVer, final boolean includeClazz,\r\n\t\t\tfinal boolean attribSameRow, final boolean keepTypes, final Set<ORID> parsedRecords) throws IOException {\r\n\t\tInteger depthLevel;\r\n\t\tfinal Integer anyFieldDepthLevel = iFetchPlan != null ? iFetchPlan.get(\"*\") : -1;\r\n\t\tdepthLevel = getDepthLevel(iRootRecord, iFetchPlan, fieldName);\r\n\r\n\t\tif (depthLevel == null)\r\n\t\t\t// NO SPECIFIED: ASSIGN DEFAULT LEVEL TAKEN FROM * WILDCARD IF ANY\r\n\t\t\tdepthLevel = anyFieldDepthLevel;\r\n\r\n\t\tif (depthLevel == 0)\r\n\t\t\t// NO FETCH THIS FIELD PLEASE\r\n\t\t\treturn;\r\n\r\n\t\tif (depthLevel > -1 && iCurrentLevel >= depthLevel)\r\n\t\t\t// MAX DEPTH REACHED: STOP TO FETCH THIS FIELD\r\n\t\t\treturn;\r\n\r\n\t\tif (fieldValue == null) {\r\n\t\t\tjson.writeAttribute(indentLevel + 1, true, fieldName, null);\r\n\t\t} else if (fieldValue instanceof ODocument) {\r\n\t\t\tfetchDocument(iFetchPlan, fieldValue, fieldName, iCurrentLevel, iMaxFetch, json, indentLevel, includeType, includeId,\r\n\t\t\t\t\tincludeVer, includeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t} else if (fieldValue instanceof Collection<?>) {\r\n\t\t\tfetchCollection(iRootRecord.getDatabase(), iFetchPlan, fieldValue, fieldName, iCurrentLevel, iMaxFetch, json, indentLevel,\r\n\t\t\t\t\tincludeType, includeId, includeVer, includeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t} else if (fieldValue.getClass().isArray()) {\r\n\t\t\tfetchArray(iFetchPlan, fieldValue, fieldName, iCurrentLevel, iMaxFetch, json, indentLevel, includeType, includeId,\r\n\t\t\t\t\tincludeVer, includeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t} else if (fieldValue instanceof Map<?, ?>) {\r\n\t\t\tfetchMap(iFetchPlan, fieldValue, fieldName, iCurrentLevel, iMaxFetch, json, indentLevel, includeType, includeId, includeVer,\r\n\t\t\t\t\tincludeClazz, attribSameRow, keepTypes, parsedRecords);\r\n\t\t}\r\n\t\tif (iMaxFetch > -1 && iCurrentLevel >= iMaxFetch) {\r\n\t\t\t// MAX FETCH SIZE REACHED: STOP TO FETCH AT ALL\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t}","commit_id":"3932f0f05e538d1c1901c44b66e188eec5ac876c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private EntityReference getObjectPropertyReference(SolrDocument solrDocument, EntityReference parent,\n        Object... parameters)\n    {\n        String propertyName = (String) solrDocument.get(FieldUtils.PROPERTY_NAME);\n        if (!StringUtils.isEmpty(propertyName)) {\n            return new EntityReference(propertyName, EntityType.OBJECT_PROPERTY, parent);\n        } else {\n            return resolveMissingReference(EntityType.OBJECT_PROPERTY, parent, parameters);\n        }\n    }","id":72335,"modified_method":"private EntityReference getObjectPropertyReference(SolrDocument solrDocument, EntityReference parent,\n        Object... parameters)\n    {\n        String propertyName = getFieldStringValue(solrDocument, FieldUtils.PROPERTY_NAME);\n        if (!StringUtils.isEmpty(propertyName)) {\n            return new EntityReference(propertyName, EntityType.OBJECT_PROPERTY, parent);\n        } else {\n            return resolveMissingReference(EntityType.OBJECT_PROPERTY, parent, parameters);\n        }\n    }","commit_id":"fb663c7781c419f8b2afa21d7f5b551e5c8271cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private EntityReference getEntityReference(SolrDocument solrDocument, EntityType expectedEntityType,\n        Object... parameters)\n    {\n        EntityReference wikiReference = getWikiReference(solrDocument, parameters);\n        EntityReference spaceReference = getSpaceReference(solrDocument, wikiReference, parameters);\n        EntityReference documentReference = getDocumentReferenceWithLocale(solrDocument, spaceReference, parameters);\n\n        String indexedEntityType = (String) solrDocument.get(FieldUtils.TYPE);\n        EntityType actualEntityType =\n            StringUtils.isEmpty(indexedEntityType) ? expectedEntityType : EntityType.valueOf(indexedEntityType);\n\n        switch (actualEntityType) {\n            case ATTACHMENT:\n                return getAttachmentReference(solrDocument, documentReference, parameters);\n            case OBJECT:\n                return getObjectReference(solrDocument, documentReference, parameters);\n            case OBJECT_PROPERTY:\n                EntityReference objectReference = getObjectReference(solrDocument, documentReference, parameters);\n                return getObjectPropertyReference(solrDocument, objectReference, parameters);\n            default:\n                return documentReference;\n        }\n    }","id":72336,"modified_method":"private EntityReference getEntityReference(SolrDocument solrDocument, EntityType expectedEntityType,\n        Object... parameters)\n    {\n        EntityReference wikiReference = getWikiReference(solrDocument, parameters);\n        EntityReference spaceReference = getSpaceReference(solrDocument, wikiReference, parameters);\n        EntityReference documentReference = getDocumentReferenceWithLocale(solrDocument, spaceReference, parameters);\n\n        String indexedEntityType = getFieldStringValue(solrDocument, FieldUtils.TYPE);\n        EntityType actualEntityType =\n            StringUtils.isEmpty(indexedEntityType) ? expectedEntityType : EntityType.valueOf(indexedEntityType);\n\n        switch (actualEntityType) {\n            case ATTACHMENT:\n                return getAttachmentReference(solrDocument, documentReference, parameters);\n            case OBJECT:\n                return getObjectReference(solrDocument, documentReference, parameters);\n            case OBJECT_PROPERTY:\n                EntityReference objectReference = getObjectReference(solrDocument, documentReference, parameters);\n                return getObjectPropertyReference(solrDocument, objectReference, parameters);\n            default:\n                return documentReference;\n        }\n    }","commit_id":"fb663c7781c419f8b2afa21d7f5b551e5c8271cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private EntityReference getObjectReference(SolrDocument solrDocument, EntityReference parent, Object... parameters)\n    {\n        String classReference = (String) solrDocument.getFirstValue(FieldUtils.CLASS);\n        Integer objectNumber = (Integer) solrDocument.get(FieldUtils.NUMBER);\n        if (!StringUtils.isEmpty(classReference) && objectNumber != null) {\n            return new EntityReference(String.format(\"%s[%s]\", classReference, objectNumber), EntityType.OBJECT,\n                parent);\n        } else {\n            return resolveMissingReference(EntityType.OBJECT, parent, parameters);\n        }\n    }","id":72337,"modified_method":"private EntityReference getObjectReference(SolrDocument solrDocument, EntityReference parent, Object... parameters)\n    {\n        String classReference = getFieldFirstStringValue(solrDocument, FieldUtils.CLASS);\n        Number objectNumber = getFieldNumberValue(solrDocument, FieldUtils.NUMBER);\n        if (!StringUtils.isEmpty(classReference) && objectNumber != null) {\n            return new EntityReference(String.format(\"%s[%s]\", classReference, objectNumber), EntityType.OBJECT,\n                parent);\n        } else {\n            return resolveMissingReference(EntityType.OBJECT, parent, parameters);\n        }\n    }","commit_id":"fb663c7781c419f8b2afa21d7f5b551e5c8271cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private EntityReference getDocumentReference(SolrDocument solrDocument, EntityReference parent,\n        Object... parameters)\n    {\n        String documentName = (String) solrDocument.get(FieldUtils.NAME);\n        if (!StringUtils.isEmpty(documentName)) {\n            return new EntityReference(documentName, EntityType.DOCUMENT, parent);\n        } else {\n            return resolveMissingReference(EntityType.DOCUMENT, parent, parameters);\n        }\n    }","id":72338,"modified_method":"private EntityReference getDocumentReference(SolrDocument solrDocument, EntityReference parent,\n        Object... parameters)\n    {\n        String documentName = getFieldStringValue(solrDocument, FieldUtils.NAME);\n        if (!StringUtils.isEmpty(documentName)) {\n            return new EntityReference(documentName, EntityType.DOCUMENT, parent);\n        } else {\n            return resolveMissingReference(EntityType.DOCUMENT, parent, parameters);\n        }\n    }","commit_id":"fb663c7781c419f8b2afa21d7f5b551e5c8271cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private EntityReference getWikiReference(SolrDocument solrDocument, Object... parameters)\n    {\n        String wikiName = (String) solrDocument.get(FieldUtils.WIKI);\n        if (!StringUtils.isEmpty(wikiName)) {\n            return new EntityReference(wikiName, EntityType.WIKI);\n        } else {\n            return resolveMissingReference(EntityType.WIKI, null, parameters);\n        }\n    }","id":72339,"modified_method":"private EntityReference getWikiReference(SolrDocument solrDocument, Object... parameters)\n    {\n        String wikiName = getFieldStringValue(solrDocument, FieldUtils.WIKI);\n        if (!StringUtils.isEmpty(wikiName)) {\n            return new EntityReference(wikiName, EntityType.WIKI);\n        } else {\n            return resolveMissingReference(EntityType.WIKI, null, parameters);\n        }\n    }","commit_id":"fb663c7781c419f8b2afa21d7f5b551e5c8271cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private EntityReference getAttachmentReference(SolrDocument solrDocument, EntityReference parent,\n        Object... parameters)\n    {\n        String fileName = (String) solrDocument.getFirstValue(FieldUtils.FILENAME);\n        if (!StringUtils.isEmpty(fileName)) {\n            return new EntityReference(fileName, EntityType.ATTACHMENT, parent);\n        } else {\n            return resolveMissingReference(EntityType.ATTACHMENT, parent, parameters);\n        }\n    }","id":72340,"modified_method":"private EntityReference getAttachmentReference(SolrDocument solrDocument, EntityReference parent,\n        Object... parameters)\n    {\n        String fileName = getFieldFirstStringValue(solrDocument, FieldUtils.FILENAME);\n        if (!StringUtils.isEmpty(fileName)) {\n            return new EntityReference(fileName, EntityType.ATTACHMENT, parent);\n        } else {\n            return resolveMissingReference(EntityType.ATTACHMENT, parent, parameters);\n        }\n    }","commit_id":"fb663c7781c419f8b2afa21d7f5b551e5c8271cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private EntityReference getDocumentReferenceWithLocale(SolrDocument solrDocument, EntityReference parent,\n        Object... parameters)\n    {\n        EntityReference documentReference = getDocumentReference(solrDocument, parent, parameters);\n        String localeString = (String) solrDocument.get(FieldUtils.DOCUMENT_LOCALE);\n        if (!StringUtils.isEmpty(localeString)) {\n            documentReference = new DocumentReference(documentReference, LocaleUtils.toLocale(localeString));\n        }\n        return documentReference;\n    }","id":72341,"modified_method":"private EntityReference getDocumentReferenceWithLocale(SolrDocument solrDocument, EntityReference parent,\n        Object... parameters)\n    {\n        EntityReference documentReference = getDocumentReference(solrDocument, parent, parameters);\n        String localeString = getFieldStringValue(solrDocument, FieldUtils.DOCUMENT_LOCALE);\n        if (!StringUtils.isEmpty(localeString)) {\n            documentReference = new DocumentReference(documentReference, LocaleUtils.toLocale(localeString));\n        }\n        return documentReference;\n    }","commit_id":"fb663c7781c419f8b2afa21d7f5b551e5c8271cb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"void registerInterceptorsToBus() {\n        ResponseTimeMessageInInterceptor in = new ResponseTimeMessageInInterceptor();\n        ResponseTimeMessageInOneWayInterceptor oneway = new ResponseTimeMessageInOneWayInterceptor();\n        ResponseTimeMessageOutInterceptor out = new ResponseTimeMessageOutInterceptor();\n        CountingOutInterceptor countingOut = new CountingOutInterceptor();\n        //ResponseTimeMessageInvokerInterceptor invoker = new ResponseTimeMessageInvokerInterceptor();\n        \n        bus.getInInterceptors().add(in);\n        bus.getInInterceptors().add(oneway);\n        bus.getOutInterceptors().add(countingOut);\n        bus.getOutInterceptors().add(out);\n        bus.getOutFaultInterceptors().add(countingOut);\n        bus.getOutFaultInterceptors().add(out);\n        //bus.setExtension(this, CounterRepository.class); \n        \n        //create CounterRepositroyMoniter to writer the counter log\n        \n        //if the service is stopped or removed, the counters should remove itself\n    }","id":72342,"modified_method":"void registerInterceptorsToBus() {\n        ResponseTimeMessageInInterceptor in = new ResponseTimeMessageInInterceptor();\n        ResponseTimeMessageInOneWayInterceptor oneway = new ResponseTimeMessageInOneWayInterceptor();\n        ResponseTimeMessageOutInterceptor out = new ResponseTimeMessageOutInterceptor();\n        CountingOutInterceptor countingOut = new CountingOutInterceptor();\n        \n        bus.getInInterceptors().add(in);\n        bus.getInInterceptors().add(oneway);\n        bus.getInInterceptors().add(new ResponseTimeMessageInPreInvokeInterceptor());\n        bus.getOutInterceptors().add(countingOut);\n        bus.getOutInterceptors().add(out);\n        bus.getOutFaultInterceptors().add(countingOut);\n        bus.getOutFaultInterceptors().add(out);\n    }","commit_id":"c5da4140da8fe63c4a10845b95258bbda9ab2058","url":"https://github.com/apache/cxf"},{"original_method":"private TimerInfo createTimerInfo(Message message, BindingOperationInfo boi) {\n        TimerInfo ti = (TimerInfo)boi.getProperty(TimerInfo.class.getName());\n        if (ti == null) {\n            ti = new TimerInfo();\n            StringBuilder buffer = getBaseServiceName(message);\n            buffer.append(\"Operation=\").append(boi.getName().getLocalPart()).append(',');\n            ti.totals = registry.timer(buffer.toString() + \"Attribute=Totals\");\n            ti.uncheckedApplicationFaults = registry.timer(buffer.toString() \n                                                           + \"Attribute=Unchecked Application Faults\");\n            ti.checkedApplicationFaults = registry.timer(buffer.toString() + \"Attribute=Checked Application Faults\");\n            ti.runtimeFaults = registry.timer(buffer.toString() + \"Attribute=Runtime Faults\");\n            ti.logicalRuntimeFaults = registry.timer(buffer.toString() + \"Attribute=Logical Runtime Faults\");\n            \n            boi.setProperty(TimerInfo.class.getName(), ti);\n        }\n        return ti;\n    }","id":72343,"modified_method":"private MetricsContext createMetricsContextForOperation(Message message, BindingOperationInfo boi) {\n        MetricsContext ti = (MetricsContext)boi.getProperty(MetricsContext.class.getName());\n        if (ti == null) {\n            StringBuilder buffer = getBaseServiceName(message);\n            buffer.append(\"Operation=\").append(boi.getName().getLocalPart()).append(',');\n            ti = new CodahaleMetricsContext(buffer.toString(), registry);\n            boi.setProperty(MetricsContext.class.getName(), ti);\n        }\n        return ti;\n    }","commit_id":"c5da4140da8fe63c4a10845b95258bbda9ab2058","url":"https://github.com/apache/cxf"},{"original_method":"TimerInfo getTimerInfo(Message message, BindingOperationInfo boi) {\n        if (boi.isUnwrapped()) {\n            boi = boi.getWrappedOperation();\n        }\n        TimerInfo ti = (TimerInfo)boi.getProperty(TimerInfo.class.getName());\n        if (ti == null) {\n            synchronized (boi) {\n                return createTimerInfo(message, boi);\n            }\n        }\n        return ti;\n    }","id":72344,"modified_method":"MetricsContext getMetricsContextForOperation(Message message, BindingOperationInfo boi) {\n        if (boi.isUnwrapped()) {\n            boi = boi.getWrappedOperation();\n        }\n        MetricsContext ti = (MetricsContext)boi.getProperty(MetricsContext.class.getName());\n        if (ti == null) {\n            synchronized (boi) {\n                return createMetricsContextForOperation(message, boi);\n            }\n        }\n        return ti;\n    }","commit_id":"c5da4140da8fe63c4a10845b95258bbda9ab2058","url":"https://github.com/apache/cxf"},{"original_method":"public void stopTimers(Message m) {\n        TimerInfo.Context ctx = m.getExchange().get(TimerInfo.Context.class);\n        long l = ctx.t.stop();\n        ctx.info.inFlight.dec();\n        BindingOperationInfo bi = m.getExchange().getBindingOperationInfo();\n        FaultMode fm = m.getExchange().get(FaultMode.class);\n        TimerInfo op = null;\n        CountingInputStream in = m.getExchange().get(CountingInputStream.class);\n        if (in != null) {\n            ctx.info.incomingData.mark(in.getCount());\n        }\n        CountingOutputStream out = m.getExchange().get(CountingOutputStream.class);\n        if (out != null) {\n            ctx.info.outgoingData.mark(out.getCount());\n        }\n\n        if (bi != null) {\n            op = getTimerInfo(m, bi);\n            op.totals.update(l, TimeUnit.NANOSECONDS);\n        }\n        if (fm != null) {\n            switch (fm) {\n            case CHECKED_APPLICATION_FAULT:\n                update(ctx.info.checkedApplicationFaults, op != null ? op.checkedApplicationFaults : null, l);\n                break;\n            case UNCHECKED_APPLICATION_FAULT:\n                update(ctx.info.uncheckedApplicationFaults, op != null ? op.uncheckedApplicationFaults : null, l);\n                break;\n            case RUNTIME_FAULT:\n                update(ctx.info.runtimeFaults, op != null ? op.runtimeFaults : null, l);\n                break;\n            case LOGICAL_RUNTIME_FAULT:\n                update(ctx.info.logicalRuntimeFaults, op != null ? op.logicalRuntimeFaults : null, l);\n                break;\n            default:\n            }\n        }\n    }","id":72345,"modified_method":"public void stopTimers(Message m) {\n        MessageMetrics ctx = m.getExchange().get(MessageMetrics.class);\n        if (ctx != null) {\n            ctx.stop(m);\n        }\n    }","commit_id":"c5da4140da8fe63c4a10845b95258bbda9ab2058","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(Message message) throws Fault {\n            TimerInfo ti = getTimerInfo(message);\n            if (isRequestor(message)) {\n                //\n            } else {\n                TimerInfo.Context ctx = ti.start();\n                message.getExchange().put(TimerInfo.Context.class, ctx);\n                InputStream in = message.getContent(InputStream.class);\n                if (in != null) {\n                    CountingInputStream newIn = new CountingInputStream(in);\n                    message.setContent(InputStream.class, newIn);\n                    message.getExchange().put(CountingInputStream.class, newIn);\n                }\n            }\n        }","id":72346,"modified_method":"public void handleMessage(Message message) throws Fault {\n            if (isRequestor(message)) {\n                //\n            } else {\n                MessageMetrics ctx = message.getExchange().get(MessageMetrics.class);\n                if (ctx == null) {\n                    ctx = new MessageMetrics();\n                    MetricsContext ti = getMetricsContextForEndpoint(message);\n                    ctx.addContext(ti);\n                    message.getExchange().put(MessageMetrics.class, ctx);\n                }\n                InputStream in = message.getContent(InputStream.class);\n                if (in != null) {\n                    CountingInputStream newIn = new CountingInputStream(in);\n                    message.setContent(InputStream.class, newIn);\n                    message.getExchange().put(CountingInputStream.class, newIn);\n                }\n                ctx.start();\n            }\n        }","commit_id":"c5da4140da8fe63c4a10845b95258bbda9ab2058","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Determine if message is outbound.\n     * \n     * @param message the current Message\n     * @return true if the message direction is outbound\n     */\n    public static boolean isOutbound(Message message) {\n        return message != null \n               && message.getExchange() != null\n               && (message == message.getExchange().getOutMessage() \n                || message == message.getExchange().getOutFaultMessage());\n    }","id":72347,"modified_method":"/**\n     * Determine if message is outbound.\n     * \n     * @param message the current Message\n     * @return true if the message direction is outbound\n     */\n    public static boolean isOutbound(Message message) {\n        if (message == null) {\n            return false;\n        }\n\n        Exchange exchange = message.getExchange();\n        return exchange != null\n               && (message == exchange.getOutMessage() || message == exchange.getOutFaultMessage());\n    }","commit_id":"3a8661b2f3156e9889dff3986461033f3f5b0f19","url":"https://github.com/apache/cxf"},{"original_method":"private boolean isResponseRedirected(Message outMessage) {\n        return Boolean.TRUE.equals(outMessage.getExchange().get(REQUEST_REDIRECTED));\n    }","id":72348,"modified_method":"private boolean isResponseRedirected(Message outMessage) {\n        Exchange exchange = outMessage.getExchange();\n        return exchange != null \n               && Boolean.TRUE.equals(exchange.get(REQUEST_REDIRECTED));\n    }","commit_id":"013fd951b5e401fcd4ca2bf18b301b7404f35ade","url":"https://github.com/apache/cxf"},{"original_method":"public AuditEvent(Exchange source, AbstractExchangeEvent event) {\n        super(source);\n        this.event = event;\n        this.timestamp = new Date();\n\n        // TODO are there any other failure endpoint events?\n        if (event instanceof ExchangeFailureHandledEvent|| event instanceof ExchangeFailedEvent) {\n            this.endpointURI = source.getProperty(Exchange.FAILURE_ENDPOINT, String.class);\n        } else {\n            Endpoint fromEndpoint = source.getFromEndpoint();\n            if (fromEndpoint != null) {\n                this.endpointURI = fromEndpoint.getEndpointUri();\n            }\n        }\n        this.sourceContextId = source.getContext().getName();\n        // if the UoW exists, get the info from there as it's more accurate; if it doesn't exist, we have received an ExchangeCreated event so the info in the\n        // exchange's fromRouteId will be correct anyway... so it's all good\n        // all consumer endpoints create an exchange (ExchangeCreatedEvent) except for direct (even seda and VM create new Exchanges)\n        // the sourceRouteId serves as correlation and in the MongoDB backend, it's part of the collection name\n        // if the routeId changes WITHOUT an exchange being created in the new route, the event will never be written because\n        // sourceRouteId: what route created the Exchange\n        this.sourceRouteId = source.getFromRouteId();\n        // currentRouteId: what route the Exchange currently is in\n        this.currentRouteId = (source.getUnitOfWork() == null || source.getUnitOfWork().getRouteContext() == null) ? null : source.getUnitOfWork().getRouteContext().getRoute().getId();\n        this.breadCrumbId = source.getIn().getHeader(Exchange.BREADCRUMB_ID, String.class);\n        if (this.breadCrumbId == null && source.hasOut()) {\n            this.breadCrumbId = source.getOut().getHeader(Exchange.BREADCRUMB_ID, String.class);\n        }\n        this.exception = source.getException() == null ? source.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class) : source.getException();\n        this.redelivered = source.getProperty(Exchange.REDELIVERED, boolean.class);\n        \n    }","id":72349,"modified_method":"public AuditEvent(Exchange source, AbstractExchangeEvent event) {\n        super(source);\n        this.event = event;\n        this.timestamp = new Date();\n\n        this.endpointURI = AuditEventNotifier.endpointUri(event);\n        this.sourceContextId = source.getContext().getName();\n        // if the UoW exists, get the info from there as it's more accurate; if it doesn't exist, we have received an ExchangeCreated event so the info in the\n        // exchange's fromRouteId will be correct anyway... so it's all good\n        // all consumer endpoints create an exchange (ExchangeCreatedEvent) except for direct (even seda and VM create new Exchanges)\n        // the sourceRouteId serves as correlation and in the MongoDB backend, it's part of the collection name\n        // if the routeId changes WITHOUT an exchange being created in the new route, the event will never be written because\n        // sourceRouteId: what route created the Exchange\n        this.sourceRouteId = source.getFromRouteId();\n        // currentRouteId: what route the Exchange currently is in\n        this.currentRouteId = (source.getUnitOfWork() == null || source.getUnitOfWork().getRouteContext() == null) ? null : source.getUnitOfWork().getRouteContext().getRoute().getId();\n        this.breadCrumbId = source.getIn().getHeader(Exchange.BREADCRUMB_ID, String.class);\n        if (this.breadCrumbId == null && source.hasOut()) {\n            this.breadCrumbId = source.getOut().getHeader(Exchange.BREADCRUMB_ID, String.class);\n        }\n        this.exception = source.getException() == null ? source.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class) : source.getException();\n        this.redelivered = source.getProperty(Exchange.REDELIVERED, boolean.class);\n        \n    }","commit_id":"70489380b6dc5ae4dcab88f9347f918894d72242","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private String endpointUri(EventObject event) {\n        if (event instanceof AuditEvent) {\n            AuditEvent auditEvent = (AuditEvent) event;\n            return auditEvent.endpointURI;\n        } else if (event instanceof AbstractExchangeEvent) {\n            AbstractExchangeEvent ae = (AbstractExchangeEvent) event;\n            Endpoint endpoint = ae.getExchange().getFromEndpoint();\n            if (endpoint != null) {\n                return endpoint.getEndpointUri();\n            }\n        }\n        return null;\n    }","id":72350,"modified_method":"public static String endpointUri(EventObject event) {\n        if (event instanceof AuditEvent) {\n            AuditEvent auditEvent = (AuditEvent) event;\n            return auditEvent.endpointURI;\n        } else if (event instanceof ExchangeSendingEvent) {\n            ExchangeSendingEvent sentEvent = (ExchangeSendingEvent) event;\n            return sentEvent.getEndpoint().getEndpointUri();\n        } else if (event instanceof ExchangeSentEvent) {\n            ExchangeSentEvent sentEvent = (ExchangeSentEvent) event;\n            return sentEvent.getEndpoint().getEndpointUri();\n        } else if (event instanceof AbstractExchangeEvent) {\n            AbstractExchangeEvent ae = (AbstractExchangeEvent) event;\n            Exchange exchange = ae.getExchange();\n            if (event instanceof ExchangeFailureHandledEvent || event instanceof ExchangeFailedEvent) {\n                return exchange.getProperty(Exchange.FAILURE_ENDPOINT, String.class);\n            } else {\n                Endpoint fromEndpoint = exchange.getFromEndpoint();\n                if (fromEndpoint != null) {\n                    return fromEndpoint.getEndpointUri();\n                }\n            }\n        }\n        return null;\n    }","commit_id":"70489380b6dc5ae4dcab88f9347f918894d72242","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n\tpublic boolean isEnabled(EventObject event) {\n        EventObject coreEvent = event;\n        AbstractExchangeEvent exchangeEvent = null;\n        if (event instanceof AuditEvent) {\n            AuditEvent auditEvent = (AuditEvent) event;\n            coreEvent = auditEvent.event;\n        }\n        if (event instanceof AbstractExchangeEvent) {\n            exchangeEvent = (AbstractExchangeEvent) event;\n        }\n        Expression filter = null;\n        List<String> compareWith = null;\n        if (coreEvent instanceof ExchangeSendingEvent) {\n            compareWith = inRegex;\n            filter = getInFilter();\n        } else if (coreEvent instanceof ExchangeCreatedEvent) {\n            return includeExchangeCreatedEvents;\n/*\n            compareWith = inRegex;\n            filter = getInFilter();\n*/\n        } else if (coreEvent instanceof ExchangeSentEvent) {\n            compareWith = outRegex;\n            filter = getOutFilter();\n        } else if (coreEvent instanceof ExchangeCompletedEvent) {\n/*\n            compareWith = outRegex;\n            filter = getOutFilter();\n*/\n            return includeExchangeCompletedEvents;\n        } else if (coreEvent instanceof ExchangeRedeliveryEvent) {\n            compareWith = redeliveryRegex;\n            filter = getRedeliveryFilter();\n        }\n        // logic if it's a failure is different; we compare against Exception\n        else if (coreEvent instanceof ExchangeFailedEvent) {\n            ExchangeFailedEvent failedEvent = (ExchangeFailedEvent) coreEvent;\n            String exceptionClassName = failedEvent.getExchange().getException().getClass().getCanonicalName();\n            filter = getFailureFilter();\n            return testRegexps(exceptionClassName, failureRegex, filter, exchangeEvent);\n        }\n        // TODO: Failure handled\n        String uri = endpointUri(event);\n        return uri == null || compareWith == null ? false : testRegexps(uri, compareWith, filter, exchangeEvent);\n\n    }","id":72351,"modified_method":"@Override\n\tpublic boolean isEnabled(EventObject event) {\n        EventObject coreEvent = event;\n        AbstractExchangeEvent exchangeEvent = null;\n        if (event instanceof AuditEvent) {\n            AuditEvent auditEvent = (AuditEvent) event;\n            coreEvent = auditEvent.event;\n        }\n        if (event instanceof AbstractExchangeEvent) {\n            exchangeEvent = (AbstractExchangeEvent) event;\n        }\n        Expression filter = null;\n        List<String> compareWith = null;\n        if (coreEvent instanceof ExchangeCreatedEvent) {\n            return includeExchangeCreatedEvents;\n/*\n            compareWith = inRegex;\n            filter = getInFilter();\n*/\n        } else if (coreEvent instanceof ExchangeSendingEvent) {\n            compareWith = inRegex;\n            filter = getInFilter();\n        } else if (coreEvent instanceof ExchangeSentEvent) {\n            compareWith = outRegex;\n            filter = getOutFilter();\n        } else if (coreEvent instanceof ExchangeCompletedEvent) {\n/*\n            compareWith = outRegex;\n            filter = getOutFilter();\n*/\n            return includeExchangeCompletedEvents;\n        } else if (coreEvent instanceof ExchangeRedeliveryEvent) {\n            compareWith = redeliveryRegex;\n            filter = getRedeliveryFilter();\n        }\n        // logic if it's a failure is different; we compare against Exception\n        else if (coreEvent instanceof ExchangeFailedEvent) {\n            ExchangeFailedEvent failedEvent = (ExchangeFailedEvent) coreEvent;\n            String exceptionClassName = failedEvent.getExchange().getException().getClass().getCanonicalName();\n            filter = getFailureFilter();\n            return testRegexps(exceptionClassName, failureRegex, filter, exchangeEvent);\n        }\n        // TODO: Failure handled\n        String uri = endpointUri(event);\n        return uri == null || compareWith == null ? false : testRegexps(uri, compareWith, filter, exchangeEvent);\n\n    }","commit_id":"70489380b6dc5ae4dcab88f9347f918894d72242","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@DirtiesContext\n    public void testCamelRoute() throws Exception {\n        String expectedBody = \"<matched/>\";\n        String ignoreBody = \"<shouldNotMatch/>\";\n\n        resultEndpoint.expectedMinimumMessageCount(1);\n        //resultEndpoint.expectedMessageCount(1);\n\n        template.sendBodyAndHeader(ignoreBody, \"foo\", \"ignored\");\n        template.sendBodyAndHeader(expectedBody, \"foo\", \"cheese\");\n        template.sendBodyAndHeader(ignoreBody, \"foo\", \"ignored\");\n\n        resultEndpoint.assertIsSatisfied();\n        List<Exchange> exchanges = resultEndpoint.getExchanges();\n        Exchange exchange = exchanges.get(0);\n        AuditEvent body = exchange.getIn().getMandatoryBody(AuditEvent.class);\n        System.out.println(\"Got: \" + body);\n    }","id":72352,"modified_method":"@DirtiesContext\n    public void testCamelRoute() throws Exception {\n        String expectedBody = \"<matched/>\";\n        String expectedHeader = \"cheese\";\n        String ignoreBody = \"<shouldNotMatch/>\";\n\n        resultEndpoint.expectedMessageCount(1);\n\n        template.sendBodyAndHeader(ignoreBody, \"foo\", \"ignored\");\n        template.sendBodyAndHeader(expectedBody, \"foo\", expectedHeader);\n        template.sendBodyAndHeader(ignoreBody, \"foo\", \"ignored\");\n\n        resultEndpoint.assertIsSatisfied();\n        List<Exchange> exchanges = resultEndpoint.getExchanges();\n        Exchange exchange = exchanges.get(0);\n        AuditEvent auditEvent = exchange.getIn().getMandatoryBody(AuditEvent.class);\n        System.out.println(\"Got: \" + auditEvent);\n\n        AbstractExchangeEvent event = auditEvent.event;\n        assertTrue(\"Should be a sent event\", event instanceof ExchangeSentEvent);\n        String body = auditEvent.getExchange().getIn().getBody(String.class);\n        assertEquals(\"body of audit exchange\", expectedBody, body);\n        Object header = auditEvent.getExchange().getIn().getHeader(\"foo\");\n        assertEquals(\"foo header of audit exchange\", expectedHeader, header);\n    }","commit_id":"70489380b6dc5ae4dcab88f9347f918894d72242","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Bean(initMethod = \"\", destroyMethod = \"\")\n    // Camel handles the lifecycle of this bean\n    @ConditionalOnMissingBean(ZipkinEventNotifier.class)\n    ZipkinEventNotifier zipkinEventNotifier(CamelContext camelContext,\n                                            ZipkinConfigurationProperties config) {\n\n        ZipkinEventNotifier notifier = new ZipkinEventNotifier();\n        notifier.setHostName(config.getHostName());\n        notifier.setPort(config.getPort());\n        notifier.setRate(config.getRate());\n        if (ObjectHelper.isNotEmpty(config.getServiceName())) {\n            notifier.setServiceName(config.getServiceName());\n        }\n        if (config.getExcludePatterns() != null) {\n            notifier.setExcludePatterns(config.getExcludePatterns());\n        }\n        if (config.getServiceMappings() != null) {\n            notifier.setServiceMappings(config.getServiceMappings());\n        }\n        notifier.setIncludeMessageBody(config.isIncludeMessageBody());\n\n        // register the bean into CamelContext\n        camelContext.getManagementStrategy().addEventNotifier(notifier);\n\n        return notifier;\n    }","id":72353,"modified_method":"@Bean(initMethod = \"\", destroyMethod = \"\")\n    // Camel handles the lifecycle of this bean\n    @ConditionalOnMissingBean(ZipkinEventNotifier.class)\n    ZipkinEventNotifier zipkinEventNotifier(CamelContext camelContext,\n                                            ZipkinConfigurationProperties config) {\n\n        ZipkinEventNotifier notifier = new ZipkinEventNotifier();\n        notifier.setHostName(config.getHostName());\n        notifier.setPort(config.getPort());\n        notifier.setRate(config.getRate());\n        if (ObjectHelper.isNotEmpty(config.getServiceName())) {\n            notifier.setServiceName(config.getServiceName());\n        }\n        if (config.getExcludePatterns() != null) {\n            notifier.setExcludePatterns(config.getExcludePatterns());\n        }\n        if (config.getClientServiceMappings() != null) {\n            notifier.setClientServiceMappings(config.getClientServiceMappings());\n        }\n        if (config.getServerServiceMappings() != null) {\n            notifier.setServerServiceMappings(config.getServerServiceMappings());\n        }\n        notifier.setIncludeMessageBody(config.isIncludeMessageBody());\n\n        // register the bean into CamelContext\n        camelContext.getManagementStrategy().addEventNotifier(notifier);\n\n        return notifier;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have one route as service\n        zipkin.addServiceMapping(\"seda:cat\", \"cat\");\n        // should auto configure as we have not setup a spanCollector\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","id":72354,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have one route as service\n        zipkin.addClientServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.addServerServiceMapping(\"seda:cat\", \"cat\");\n        // should auto configure as we have not setup a spanCollector\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"public void setServiceMappings(Map<String, String> serviceMappings) {\n        this.serviceMappings = serviceMappings;\n    }","id":72355,"modified_method":"public void setServerServiceMappings(Map<String, String> serverServiceMappings) {\n        this.serverServiceMappings = serverServiceMappings;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"public Map<String, String> getServiceMappings() {\n        return serviceMappings;\n    }","id":72356,"modified_method":"public Map<String, String> getServerServiceMappings() {\n        return serverServiceMappings;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void notify(EventObject event) throws Exception {\n        if (event instanceof ExchangeSendingEvent) {\n            ExchangeSendingEvent ese = (ExchangeSendingEvent) event;\n            String serviceName = getServiceName(ese.getExchange(), ese.getEndpoint());\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                clientRequest(brave, serviceName, ese);\n            }\n        } else if (event instanceof ExchangeSentEvent) {\n            ExchangeSentEvent ese = (ExchangeSentEvent) event;\n            String serviceName = getServiceName(ese.getExchange(), ese.getEndpoint());\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                clientResponse(brave, serviceName, ese);\n            }\n        } else if (event instanceof ExchangeCreatedEvent) {\n            ExchangeCreatedEvent ece = (ExchangeCreatedEvent) event;\n            String serviceName = getServiceName(ece.getExchange(), null);\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                serverRequest(brave, serviceName, ece);\n            }\n        } else if (event instanceof ExchangeCompletedEvent) {\n            ExchangeCompletedEvent ece = (ExchangeCompletedEvent) event;\n            String serviceName = getServiceName(ece.getExchange(), null);\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                serverResponse(brave, serviceName, ece);\n            }\n        } else if (event instanceof ExchangeFailedEvent) {\n            ExchangeFailedEvent efe = (ExchangeFailedEvent) event;\n            String serviceName = getServiceName(efe.getExchange(), null);\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                serverResponse(brave, serviceName, efe);\n            }\n        }\n    }","id":72357,"modified_method":"@Override\n    public void notify(EventObject event) throws Exception {\n        // client events\n        if (event instanceof ExchangeSendingEvent) {\n            ExchangeSendingEvent ese = (ExchangeSendingEvent) event;\n            String serviceName = getServiceName(ese, ese.getExchange(), ese.getEndpoint(), false, true);\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                clientRequest(brave, serviceName, ese);\n            }\n        } else if (event instanceof ExchangeSentEvent) {\n            ExchangeSentEvent ese = (ExchangeSentEvent) event;\n            String serviceName = getServiceName(ese, ese.getExchange(), ese.getEndpoint(), false, true);\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                clientResponse(brave, serviceName, ese);\n            }\n        }\n\n        // server received client request\n        if (event instanceof ExchangeCreatedEvent) {\n            ExchangeCreatedEvent ece = (ExchangeCreatedEvent) event;\n            // we should only emit a server request if we have an existing trace id (eg a client has called us)\n            if (hasZipkinTraceId(ece.getExchange())) {\n                String serviceName = getServiceName(ece, ece.getExchange(), null, true, false);\n                Brave brave = getBrave(serviceName);\n                if (brave != null) {\n                    serverRequest(brave, serviceName, ece);\n                }\n            }\n        }\n        // server completed events\n        if (event instanceof ExchangeCompletedEvent) {\n            ExchangeCompletedEvent ece = (ExchangeCompletedEvent) event;\n            String serviceName = getServiceName(ece, ece.getExchange(), null, true, false);\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                serverResponse(brave, serviceName, ece);\n            }\n        } else if (event instanceof ExchangeFailedEvent) {\n            ExchangeFailedEvent efe = (ExchangeFailedEvent) event;\n            String serviceName = getServiceName(efe, efe.getExchange(), null, true, false);\n            Brave brave = getBrave(serviceName);\n            if (brave != null) {\n                serverResponse(brave, serviceName, efe);\n            }\n        }\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"private void clientRequest(Brave brave, String serviceName, ExchangeSendingEvent event) {\n        ClientSpanThreadBinder binder = brave.clientSpanThreadBinder();\n        brave.clientRequestInterceptor().handle(new ZipkinClientRequestAdapter(this, serviceName, event.getExchange(), event.getEndpoint()));\n        Span span = binder.getCurrentClientSpan();\n\n        String key = \"CamelZipkinClientSpan-\" + serviceName;\n        event.getExchange().setProperty(key, span);\n\n        if (log.isDebugEnabled()) {\n            String id = \"<null>\";\n            if (span != null) {\n                id = \"\" + span.getId();\n            }\n            log.debug(\"clientRequest\\t[service={}, spanId={}]\", serviceName, id);\n        }\n    }","id":72358,"modified_method":"private void clientRequest(Brave brave, String serviceName, ExchangeSendingEvent event) {\n        ClientSpanThreadBinder binder = brave.clientSpanThreadBinder();\n\n        // reuse existing span if we do multiple requests from the same\n        ZipkinState state = event.getExchange().getProperty(ZipkinState.KEY, ZipkinState.class);\n        if (state == null) {\n            state = new ZipkinState();\n            event.getExchange().setProperty(ZipkinState.KEY, state);\n        }\n        Object last = state.getLast();\n        if (last != null && last instanceof Span) {\n            binder.setCurrentSpan((Span) last);\n        } else if (last != null && last instanceof ServerSpan) {\n            Span span = ((ServerSpan) last).getSpan();\n            binder.setCurrentSpan(span);\n        }\n\n        brave.\n\n        brave.clientRequestInterceptor().handle(new ZipkinClientRequestAdapter(this, serviceName, event.getExchange(), event.getEndpoint()));\n\n        // store span after request\n        Span span = binder.getCurrentClientSpan();\n        state.pushClientSpan(span);\n        // and reset binder\n        binder.setCurrentSpan(null);\n\n        if (log.isDebugEnabled()) {\n            String traceId = \"<null>\";\n            if (span != null) {\n                traceId = \"\" + span.getTrace_id();\n            }\n            String spanId = \"<null>\";\n            if (span != null) {\n                spanId = \"\" + span.getId();\n            }\n            String parentId = \"<null>\";\n            if (span != null) {\n                parentId = \"\" + span.getParent_id();\n            }\n            log.debug(\"clientRequest [service={}, traceId={}, spanId={}, parentId={}]\", serviceName, traceId, spanId, parentId);\n        }\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * To use a global service name that matches all Camel events\n     */\n    public void setServiceName(String serviceName) {\n        serviceMappings.put(\"*\", serviceName);\n    }","id":72359,"modified_method":"/**\n     * To use a global service name that matches all Camel events\n     */\n    public void setServiceName(String serviceName) {\n        clientServiceMappings.put(\"*\", serviceName);\n        serverServiceMappings.put(\"*\", serviceName);\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"private void serverResponse(Brave brave, String serviceName, ExchangeFailedEvent event) {\n        ServerSpanThreadBinder binder = brave.serverSpanThreadBinder();\n        String key = \"CamelZipkinServerSpan-\" + serviceName;\n        ServerSpan span = event.getExchange().getProperty(key, ServerSpan.class);\n        binder.setCurrentSpan(span);\n        brave.serverResponseInterceptor().handle(new ZipkinServerResponseAdapter(this, event.getExchange()));\n        binder.setCurrentSpan(null);\n\n        if (log.isDebugEnabled()) {\n            String id = \"<null>\";\n            if (span != null && span.getSpan() != null) {\n                id = \"\" + span.getSpan().getId();\n            }\n            log.debug(\"serverResponse[service={}, spanId={}]\\t[status=exchangeFailed]\", serviceName, id);\n        }\n    }","id":72360,"modified_method":"private void serverResponse(Brave brave, String serviceName, ExchangeFailedEvent event) {\n        ServerSpan span = null;\n        ZipkinState state = event.getExchange().getProperty(ZipkinState.KEY, ZipkinState.class);\n        if (state != null) {\n            span = state.popServerSpan();\n        }\n\n        if (span != null) {\n            // only process if it was a zipkin server event\n            ServerSpanThreadBinder binder = brave.serverSpanThreadBinder();\n            binder.setCurrentSpan(span);\n            brave.serverResponseInterceptor().handle(new ZipkinServerResponseAdapter(this, event.getExchange()));\n            // and reset binder\n            binder.setCurrentSpan(null);\n\n            if (log.isDebugEnabled()) {\n                String traceId = \"<null>\";\n                if (span.getSpan() != null) {\n                    traceId = \"\" + span.getSpan().getTrace_id();\n                }\n                String spanId = \"<null>\";\n                if (span.getSpan() != null) {\n                    spanId = \"\" + span.getSpan().getId();\n                }\n                String parentId = \"<null>\";\n                if (span.getSpan() != null) {\n                    parentId = \"\" + span.getSpan().getParent_id();\n                }\n                log.debug(\"serverResponse[service={}, traceId={}, spanId={}, parentId={}] [status=exchangeFailed]\", serviceName, traceId, spanId, parentId);\n            }\n        }\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"private void serverRequest(Brave brave, String serviceName, ExchangeCreatedEvent event) {\n        ServerSpanThreadBinder binder = brave.serverSpanThreadBinder();\n        brave.serverRequestInterceptor().handle(new ZipkinServerRequestAdapter(this, event.getExchange()));\n        ServerSpan span = binder.getCurrentServerSpan();\n        String key = \"CamelZipkinServerSpan-\" + serviceName;\n        event.getExchange().setProperty(key, span);\n\n        if (log.isDebugEnabled()) {\n            String id = \"<null>\";\n            if (span != null && span.getSpan() != null) {\n                id = \"\" + span.getSpan().getId();\n            }\n            log.debug(\"serverRequest\\t[service={}, spanId={}]\", serviceName, id);\n        }\n    }","id":72361,"modified_method":"private void serverRequest(Brave brave, String serviceName, ExchangeCreatedEvent event) {\n        ServerSpanThreadBinder binder = brave.serverSpanThreadBinder();\n\n        // reuse existing span if we do multiple requests from the same\n        ZipkinState state = event.getExchange().getProperty(ZipkinState.KEY, ZipkinState.class);\n        if (state == null) {\n            state = new ZipkinState();\n            event.getExchange().setProperty(ZipkinState.KEY, state);\n        }\n        Object last = state.getLast();\n        if (last != null && last instanceof ServerSpan) {\n            binder.setCurrentSpan((ServerSpan) last);\n        }\n\n        brave.serverRequestInterceptor().handle(new ZipkinServerRequestAdapter(this, event.getExchange()));\n\n        // store span after request\n        ServerSpan span = binder.getCurrentServerSpan();\n        state.pushServerSpan(span);\n        // and reset binder\n        binder.setCurrentSpan(null);\n\n        if (log.isDebugEnabled()) {\n            String traceId = \"<null>\";\n            if (span.getSpan() != null) {\n                traceId = \"\" + span.getSpan().getTrace_id();\n            }\n            String spanId = \"<null>\";\n            if (span.getSpan() != null) {\n                spanId = \"\" + span.getSpan().getId();\n            }\n            String parentId = \"<null>\";\n            if (span.getSpan() != null) {\n                parentId = \"\" + span.getSpan().getParent_id();\n            }\n            log.debug(\"serverRequest [service={}, traceId={}, spanId={}, parentId={}]\", serviceName, traceId, spanId, parentId);\n        }\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"public String getServiceName() {\n        return serviceMappings.get(\"*\");\n    }","id":72362,"modified_method":"public String getServiceName() {\n        return clientServiceMappings.get(\"*\");\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"private void serverResponse(Brave brave, String serviceName, ExchangeCompletedEvent event) {\n        ServerSpanThreadBinder binder = brave.serverSpanThreadBinder();\n        String key = \"CamelZipkinServerSpan-\" + serviceName;\n        ServerSpan span = event.getExchange().getProperty(key, ServerSpan.class);\n        binder.setCurrentSpan(span);\n        brave.serverResponseInterceptor().handle(new ZipkinServerResponseAdapter(this, event.getExchange()));\n        binder.setCurrentSpan(null);\n\n        if (log.isDebugEnabled()) {\n            String id = \"<null>\";\n            if (span != null && span.getSpan() != null) {\n                id = \"\" + span.getSpan().getId();\n            }\n            log.debug(\"serverResponse\\t[service={}, spanId={}]\\t[status=exchangeCompleted]\", serviceName, id);\n        }\n    }","id":72363,"modified_method":"private void serverResponse(Brave brave, String serviceName, ExchangeCompletedEvent event) {\n        ServerSpan span = null;\n        ZipkinState state = event.getExchange().getProperty(ZipkinState.KEY, ZipkinState.class);\n        if (state != null) {\n            span = state.popServerSpan();\n        }\n\n        if (span != null) {\n            // only process if it was a zipkin server event\n            ServerSpanThreadBinder binder = brave.serverSpanThreadBinder();\n            binder.setCurrentSpan(span);\n            brave.serverResponseInterceptor().handle(new ZipkinServerResponseAdapter(this, event.getExchange()));\n            // and reset binder\n            binder.setCurrentSpan(null);\n\n            if (log.isDebugEnabled()) {\n                String traceId = \"<null>\";\n                if (span.getSpan() != null) {\n                    traceId = \"\" + span.getSpan().getTrace_id();\n                }\n                String spanId = \"<null>\";\n                if (span.getSpan() != null) {\n                    spanId = \"\" + span.getSpan().getId();\n                }\n                String parentId = \"<null>\";\n                if (span.getSpan() != null) {\n                    parentId = \"\" + span.getSpan().getParent_id();\n                }\n                log.debug(\"serverResponse[service={}, traceId={}, spanId={}, parentId={}] [status=exchangeFailed]\", serviceName, traceId, spanId, parentId);\n            }\n        }\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Adds a service mapping that matches Camel events to the given zipkin service name.\n     * See more details at the class javadoc.\n     *\n     * @param pattern  the pattern such as route id, endpoint url\n     * @param serviceName the zipkin service name\n     */\n    public void addServiceMapping(String pattern, String serviceName) {\n        serviceMappings.put(pattern, serviceName);\n    }","id":72364,"modified_method":"/**\n     * Adds a server service mapping that matches Camel events to the given zipkin service name.\n     * See more details at the class javadoc.\n     *\n     * @param pattern  the pattern such as route id, endpoint url\n     * @param serviceName the zipkin service name\n     */\n    public void addServerServiceMapping(String pattern, String serviceName) {\n        serverServiceMappings.put(pattern, serviceName);\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"private String getServiceName(Exchange exchange, Endpoint endpoint) {\n        String answer = null;\n\n        // endpoint takes precedence over route\n        if (endpoint != null) {\n            String url = endpoint.getEndpointUri();\n            if (url != null) {\n                // exclude patterns take precedence\n                for (String pattern : excludePatterns) {\n                    if (EndpointHelper.matchEndpoint(exchange.getContext(), url, pattern)) {\n                        return null;\n                    }\n                }\n                for (Map.Entry<String, String> entry : serviceMappings.entrySet()) {\n                    String pattern = entry.getKey();\n                    if (EndpointHelper.matchEndpoint(exchange.getContext(), url, pattern)) {\n                        answer = entry.getValue();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (answer == null && exchange.getFromEndpoint() != null) {\n            String url = exchange.getFromEndpoint().getEndpointUri();\n            if (url != null) {\n                // exclude patterns take precedence\n                for (String pattern : excludePatterns) {\n                    if (EndpointHelper.matchEndpoint(exchange.getContext(), url, pattern)) {\n                        return null;\n                    }\n                }\n                for (Map.Entry<String, String> entry : serviceMappings.entrySet()) {\n                    String pattern = entry.getKey();\n                    if (EndpointHelper.matchEndpoint(exchange.getContext(), url, pattern)) {\n                        answer = entry.getValue();\n                        break;\n                    }\n                }\n            }\n        }\n\n        // route\n        if (answer == null) {\n            String id = routeIdExpression().evaluate(exchange, String.class);\n            if (id != null) {\n                // exclude patterns take precedence\n                for (String pattern : excludePatterns) {\n                    if (EndpointHelper.matchPattern(id, pattern)) {\n                        return null;\n                    }\n                }\n                for (Map.Entry<String, String> entry : serviceMappings.entrySet()) {\n                    String pattern = entry.getKey();\n                    if (EndpointHelper.matchPattern(id, pattern)) {\n                        answer = entry.getValue();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (answer == null) {\n            String id = exchange.getFromRouteId();\n            if (id != null) {\n                // exclude patterns take precedence\n                for (String pattern : excludePatterns) {\n                    if (EndpointHelper.matchPattern(id, pattern)) {\n                        return null;\n                    }\n                }\n                for (Map.Entry<String, String> entry : serviceMappings.entrySet()) {\n                    String pattern = entry.getKey();\n                    if (EndpointHelper.matchPattern(id, pattern)) {\n                        answer = entry.getValue();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (answer == null && useFallbackServiceNames) {\n            String key = null;\n            if (endpoint != null) {\n                key = endpoint.getEndpointKey();\n            } else if (exchange.getFromEndpoint() != null) {\n                key = exchange.getFromEndpoint().getEndpointKey();\n            }\n            // exclude patterns take precedence\n            for (String pattern : excludePatterns) {\n                if (EndpointHelper.matchPattern(key, pattern)) {\n                    return null;\n                }\n            }\n            if (log.isTraceEnabled() && key != null) {\n                log.trace(\"Using serviceName: {} as fallback\", key);\n            }\n            return key;\n        } else {\n            if (log.isTraceEnabled() && answer != null) {\n                log.trace(\"Using serviceName: {}\", answer);\n            }\n            return answer;\n        }\n    }","id":72365,"modified_method":"private String getServiceName(EventObject event, Exchange exchange, Endpoint endpoint, boolean server, boolean client) {\n        if (client) {\n            return getServiceName(event, exchange, endpoint, clientServiceMappings, server, client);\n        } else if (server) {\n            return getServiceName(event, exchange, endpoint, serverServiceMappings, server, client);\n        } else {\n            return null;\n        }\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        ObjectHelper.notNull(camelContext, \"CamelContext\", this);\n\n        if (spanCollector == null) {\n            if (hostName != null && port > 0) {\n                log.info(\"Configuring Zipkin ScribeSpanCollector using host: {} and port: {}\", hostName, port);\n                spanCollector = new ScribeSpanCollector(hostName, port);\n            } else {\n                // is there a zipkin service setup as ENV variable to auto register a scribe span collector\n                String host = new ServiceHostPropertiesFunction().apply(\"zipkin\");\n                String port = new ServicePortPropertiesFunction().apply(\"zipkin\");\n                if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {\n                    log.info(\"Auto-configuring Zipkin ScribeSpanCollector using host: {} and port: {}\", host, port);\n                    int num = camelContext.getTypeConverter().mandatoryConvertTo(Integer.class, port);\n                    spanCollector = new ScribeSpanCollector(host, num);\n                }\n            }\n        }\n\n        ObjectHelper.notNull(spanCollector, \"SpanCollector\", this);\n\n        if (serviceMappings.isEmpty()) {\n            log.warn(\"No service name(s) has been configured. Camel will fallback and use endpoint uris as service names.\");\n            useFallbackServiceNames = true;\n        }\n\n        // create braves mapped per service name\n        for (Map.Entry<String, String> entry : serviceMappings.entrySet()) {\n            String pattern = entry.getKey();\n            String serviceName = entry.getValue();\n            Brave brave = braves.get(pattern);\n            if (brave == null) {\n                Brave.Builder builder = new Brave.Builder(serviceName);\n                builder = builder.traceSampler(Sampler.create(rate));\n                if (spanCollector != null) {\n                    builder = builder.spanCollector(spanCollector);\n                }\n                brave = builder.build();\n                braves.put(serviceName, brave);\n            }\n        }\n\n        ServiceHelper.startService(spanCollector);\n    }","id":72366,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        ObjectHelper.notNull(camelContext, \"CamelContext\", this);\n\n        if (spanCollector == null) {\n            if (hostName != null && port > 0) {\n                log.info(\"Configuring Zipkin ScribeSpanCollector using host: {} and port: {}\", hostName, port);\n                spanCollector = new ScribeSpanCollector(hostName, port);\n            } else {\n                // is there a zipkin service setup as ENV variable to auto register a scribe span collector\n                String host = new ServiceHostPropertiesFunction().apply(\"zipkin\");\n                String port = new ServicePortPropertiesFunction().apply(\"zipkin\");\n                if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {\n                    log.info(\"Auto-configuring Zipkin ScribeSpanCollector using host: {} and port: {}\", host, port);\n                    int num = camelContext.getTypeConverter().mandatoryConvertTo(Integer.class, port);\n                    spanCollector = new ScribeSpanCollector(host, num);\n                }\n            }\n        }\n\n        ObjectHelper.notNull(spanCollector, \"SpanCollector\", this);\n\n        if (clientServiceMappings.isEmpty()) {\n            log.warn(\"No service name(s) has been configured. Camel will fallback and use endpoint uris as service names.\");\n            useFallbackServiceNames = true;\n        }\n\n        // create braves mapped per service name\n        for (Map.Entry<String, String> entry : clientServiceMappings.entrySet()) {\n            String pattern = entry.getKey();\n            String serviceName = entry.getValue();\n            Brave brave = braves.get(pattern);\n            if (brave == null) {\n                Brave.Builder builder = new Brave.Builder(serviceName);\n                builder = builder.traceSampler(Sampler.create(rate));\n                if (spanCollector != null) {\n                    builder = builder.spanCollector(spanCollector);\n                }\n                brave = builder.build();\n                braves.put(serviceName, brave);\n            }\n        }\n\n        ServiceHelper.startService(spanCollector);\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"private void clientResponse(Brave brave, String serviceName, ExchangeSentEvent event) {\n        ClientSpanThreadBinder binder = brave.clientSpanThreadBinder();\n        String key = \"CamelZipkinClientSpan-\" + serviceName;\n        Span span = event.getExchange().getProperty(key, Span.class);\n        binder.setCurrentSpan(span);\n        brave.clientResponseInterceptor().handle(new ZipkinClientResponseAdaptor(this, event.getExchange(), event.getEndpoint()));\n        binder.setCurrentSpan(null);\n\n        if (log.isDebugEnabled()) {\n            String id = \"<null>\";\n            if (span != null) {\n                id = \"\" + span.getId();\n            }\n            log.debug(\"clientResponse\\t[service={}, spanId={}]\", serviceName, id);\n        }\n    }","id":72367,"modified_method":"private void clientResponse(Brave brave, String serviceName, ExchangeSentEvent event) {\n        Span span = null;\n        ZipkinState state = event.getExchange().getProperty(ZipkinState.KEY, ZipkinState.class);\n        if (state != null) {\n            span = state.popClientSpan();\n        }\n\n        if (span != null) {\n            // only process if it was a zipkin client event\n            ClientSpanThreadBinder binder = brave.clientSpanThreadBinder();\n            binder.setCurrentSpan(span);\n            brave.clientResponseInterceptor().handle(new ZipkinClientResponseAdaptor(this, event.getExchange(), event.getEndpoint()));\n            // and reset binder\n            binder.setCurrentSpan(null);\n\n            if (log.isDebugEnabled()) {\n                String traceId = \"\" + span.getTrace_id();\n                String spanId = \"\" + span.getId();\n                String parentId = \"\" + span.getParent_id();\n                log.debug(\"clientResponse[service={}, traceId={}, spanId={}, parentId={}]\", serviceName, traceId, spanId, parentId);\n            }\n        }\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"public Map<String, String> getServiceMappings() {\n        return serviceMappings;\n    }","id":72368,"modified_method":"public Map<String, String> getServerServiceMappings() {\n        return serverServiceMappings;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"public void setServiceMappings(Map<String, String> serviceMappings) {\n        this.serviceMappings = serviceMappings;\n    }","id":72369,"modified_method":"public void setServerServiceMappings(Map<String, String> serverServiceMappings) {\n        this.serverServiceMappings = serverServiceMappings;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have one route as service\n        zipkin.addServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.setSpanCollector(new ScribeSpanCollector(ip, 9410));\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","id":72370,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have one route as service\n        zipkin.addClientServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.addServerServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.setSpanCollector(new ScribeSpanCollector(ip, 9410));\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        zipkin.addServiceMapping(\"seda:foo\", \"foo\");\n        zipkin.addServiceMapping(\"seda:bar\", \"bar\");\n        zipkin.setSpanCollector(new ZipkinLoggingSpanCollector());\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","id":72371,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        zipkin.addClientServiceMapping(\"seda:foo\", \"foo\");\n        zipkin.addServerServiceMapping(\"seda:bar\", \"bar\");\n        zipkin.setSpanCollector(new ZipkinLoggingSpanCollector());\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have one route as service\n        zipkin.addServiceMapping(\"seda:dude\", \"dude\");\n        zipkin.setSpanCollector(new ScribeSpanCollector(ip, 9410));\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","id":72372,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have one route as service\n        zipkin.addClientServiceMapping(\"seda:dude\", \"dude\");\n        zipkin.addServerServiceMapping(\"seda:dude\", \"dude\");\n        zipkin.setSpanCollector(new ScribeSpanCollector(ip, 9410));\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        zipkin.addServiceMapping(\"seda:dude\", \"dude\");\n        zipkin.setSpanCollector(new ZipkinLoggingSpanCollector());\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","id":72373,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        zipkin.setServiceName(\"dude\");\n        zipkin.setSpanCollector(new ZipkinLoggingSpanCollector());\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have one route as service\n        zipkin.addServiceMapping(\"seda:timer\", \"timer\");\n        zipkin.setSpanCollector(new ScribeSpanCollector(ip, 9410));\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","id":72374,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have one route as service\n        zipkin.addClientServiceMapping(\"seda:timer\", \"timer\");\n        zipkin.addServerServiceMapping(\"seda:timer\", \"timer\");\n        zipkin.setSpanCollector(new ScribeSpanCollector(ip, 9410));\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have 2 routes as services\n        zipkin.addServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.addServiceMapping(\"seda:dog\", \"dog\");\n        // capture message body as well\n        zipkin.setIncludeMessageBody(true);\n        zipkin.setSpanCollector(new ScribeSpanCollector(ip, 9410));\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","id":72375,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have 2 routes as services\n        zipkin.addClientServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.addServerServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.addClientServiceMapping(\"seda:dog\", \"dog\");\n        zipkin.addServerServiceMapping(\"seda:dog\", \"dog\");\n        // capture message body as well\n        zipkin.setIncludeMessageBody(true);\n        zipkin.setSpanCollector(new ScribeSpanCollector(ip, 9410));\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have 2 routes as services\n        zipkin.addServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.addServiceMapping(\"seda:dog\", \"dog\");\n        // capture message body as well\n        zipkin.setIncludeMessageBody(true);\n        zipkin.setSpanCollector(new ZipkinLoggingSpanCollector());\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","id":72376,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        CamelContext context = super.createCamelContext();\n\n        zipkin = new ZipkinEventNotifier();\n        // we have 2 routes as services\n        zipkin.addClientServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.addServerServiceMapping(\"seda:cat\", \"cat\");\n        zipkin.addClientServiceMapping(\"seda:dog\", \"dog\");\n        zipkin.addServerServiceMapping(\"seda:dog\", \"dog\");\n        // capture message body as well\n        zipkin.setIncludeMessageBody(true);\n        zipkin.setSpanCollector(new ZipkinLoggingSpanCollector());\n        context.getManagementStrategy().addEventNotifier(zipkin);\n\n        return context;\n    }","commit_id":"4dc5b5e484381655e407c590239d4ed90a36b705","url":"https://github.com/apache/camel"},{"original_method":"public String normalize(@NotNull final String path) {\n    final File file = new File(path);\n    if (file.isAbsolute()) return file.getAbsolutePath();\n\n    return new File(System.getProperty(\"user.home\"), path).getAbsolutePath();\n  }","id":72377,"modified_method":"public String normalize(@NotNull final String path) {\n    final File file = new File(path);\n    if (file.isAbsolute()) return file.getAbsolutePath();\n\n    return new File(myBaseDir, path).getAbsolutePath();\n  }","commit_id":"57895218b5ce576272c92a762399d9de96d858ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LookupFile find(@NotNull final String path) {\n    final VirtualFile byUrl = VirtualFileManager.getInstance().findFileByUrl(path);\n    if (byUrl != null) return getLookupFile(path, byUrl);\n\n    String toFind = normalize(path);\n    if (toFind.length() == 0) {\n      File[] roots = File.listRoots();\n      if (roots.length > 0) {\n        toFind = roots[0].getAbsolutePath();\n      }\n    }\n    final File file = new File(toFind);\n    return file.isAbsolute() ? getLookupFile(path, LocalFileSystem.getInstance().findFileByIoFile(file)) : null;\n  }","id":72378,"modified_method":"public LookupFile find(@NotNull final String path) {\n    final VirtualFile byUrl = VirtualFileManager.getInstance().findFileByUrl(path);\n    if (byUrl != null) {\n      return new VfsFile(this, byUrl);\n    }\n\n    String toFind = normalize(path);\n    if (toFind.length() == 0) {\n      File[] roots = File.listRoots();\n      if (roots.length > 0) {\n        toFind = roots[0].getAbsolutePath();\n      }\n    }\n    final File file = new File(toFind);\n    // '..' and '.' path components will be eliminated\n    VirtualFile vFile = LocalFileSystem.getInstance().findFileByIoFile(file);\n    if (vFile != null) {\n      return new VfsFile(this, vFile);\n    } else if (file.isAbsolute()) {\n      return new IoFile(new File(path));\n    }\n    return null;\n  }","commit_id":"57895218b5ce576272c92a762399d9de96d858ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isDirectory() {\n      return myIoFile != null ? myIoFile.isDirectory() : false;\n    }","id":72379,"modified_method":"public boolean isDirectory() {\n      return myIoFile != null && myIoFile.isDirectory();\n    }","commit_id":"57895218b5ce576272c92a762399d9de96d858ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<LookupFile> getChildren(final LookupFilter filter) {\n      List<LookupFile> result = new ArrayList<LookupFile>();\n      if (myFile == null) return result;\n\n      VirtualFile[] kids = myFile.getChildren();\n      for (VirtualFile each : kids) {\n        LookupFile eachFile = myFinder.getLookupFile(each.getPath(), each);\n        if (eachFile != null && filter.isAccepted(eachFile)) {\n          result.add(eachFile);\n        }\n      }\n      Collections.sort(result, new Comparator<LookupFile>() {\n        public int compare(LookupFile o1, LookupFile o2) {\n          return FileUtil.comparePaths(o1.getName(), o2.getName());\n        }\n      });\n\n      return result;\n    }","id":72380,"modified_method":"public List<LookupFile> getChildren(final LookupFilter filter) {\n      List<LookupFile> result = new ArrayList<LookupFile>();\n      if (myFile == null) return result;\n\n      VirtualFile[] kids = myFile.getChildren();\n      for (VirtualFile each : kids) {\n        LookupFile eachFile = new VfsFile(myFinder, each);\n        if (filter.isAccepted(eachFile)) {\n          result.add(eachFile);\n        }\n      }\n      Collections.sort(result, new Comparator<LookupFile>() {\n        public int compare(LookupFile o1, LookupFile o2) {\n          return FileUtil.comparePaths(o1.getName(), o2.getName());\n        }\n      });\n\n      return result;\n    }","commit_id":"57895218b5ce576272c92a762399d9de96d858ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isDirectory() {\n      return myFile != null ? myFile.isDirectory() : false;\n    }","id":72381,"modified_method":"public boolean isDirectory() {\n      return myFile != null && myFile.isDirectory();\n    }","commit_id":"57895218b5ce576272c92a762399d9de96d858ce","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void validate() {\r\n\t\t\tSelectionValidator validator = new SelectionValidator(kind);\r\n\t\t\tIStatus bad = null;\r\n\t\t\tfor (PathElement path : paths) {\r\n\t\t\t\tIStatus status = validator.validate(path.getPath());\r\n\t\t\t\tpath.setStatus(status);\r\n\t\t\t\tif(!status.isOK()){\r\n\t\t\t\t\tbad = status;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(bad != null){\r\n\t\t\t\tpropertyPage.setErrorMessage(bad.getMessage());\r\n\t\t\t}\r\n\t\t}","id":72382,"modified_method":"private void validate() {\r\n\t\t\tSelectionValidator validator = new SelectionValidator(kind);\r\n\t\t\tIStatus bad = null;\r\n\t\t\tIProject project = propertyPage.getProject();\r\n\t\t\tfor (PathElement path : paths) {\r\n\t\t\t\tString filterPath = FindBugsWorker.toFilterPath(path.getPath(), project).toOSString();\r\n\t\t\t\tIStatus status = validator.validate(filterPath);\r\n\t\t\t\tpath.setStatus(status);\r\n\t\t\t\tif(!status.isOK()){\r\n\t\t\t\t\tbad = status;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(bad != null){\r\n\t\t\t\tpropertyPage.setErrorMessage(bad.getMessage());\r\n\t\t\t}\r\n\t\t}","commit_id":"ddcd07508d95383a4ee572f88a32ed3d53ed8fb1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static Set<String> pathsToStrings(List<PathElement> paths) {\r\n\t\tSet<String>result = new LinkedHashSet<String>();\r\n\t\tfor (PathElement path : paths) {\r\n\t\t\tresult.add(path.getPath());\r\n\t\t}\r\n\t\treturn result;\r\n\t}","id":72383,"modified_method":"private Set<String> pathsToStrings(List<PathElement> paths) {\r\n\t\tIProject project = propertyPage.getProject();\r\n\t\tSet<String>result = new LinkedHashSet<String>();\r\n\t\tfor (PathElement path : paths) {\r\n\t\t\tIPath filterPath = FindBugsWorker.toFilterPath(path.getPath(), project);\r\n\t\t\tresult.add(filterPath.toOSString());\r\n\t\t}\r\n\t\treturn result;\r\n\t}","commit_id":"ddcd07508d95383a4ee572f88a32ed3d53ed8fb1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private List<PathElement> getFilterFiles(FilterKind kind, UserPreferences prefs) {\r\n\t\tIProject project = propertyPage.getProject();\r\n\t\tfinal List<PathElement> paths = new ArrayList<PathElement>();\r\n\t\tCollection<String> filterPaths = kind.selectedPaths(prefs);\r\n\t\tif (filterPaths != null) {\r\n\t\t\tfor (String path : filterPaths) {\r\n\t\t\t\tIPath filterPath = FindBugsWorker.getFilterPath(path, project);\r\n\t\t\t\tif(filterPath != null && filterPath.toFile().exists()) {\r\n\t\t\t\t\tpaths.add(new PathElement(filterPath, Status.OK_STATUS));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn paths;\r\n\t}","id":72384,"modified_method":"private List<PathElement> getFilterFiles(FilterKind kind, UserPreferences prefs) {\r\n\t\tIProject project = propertyPage.getProject();\r\n\t\tfinal List<PathElement> paths = new ArrayList<PathElement>();\r\n\t\tCollection<String> filterPaths = kind.selectedPaths(prefs);\r\n\t\tif (filterPaths != null) {\r\n\t\t\tfor (String path : filterPaths) {\r\n\t\t\t\tIPath filterPath = FindBugsWorker.getFilterPath(path, project);\r\n\t\t\t\tif(filterPath.toFile().exists()) {\r\n\t\t\t\t\tpaths.add(new PathElement(filterPath, Status.OK_STATUS));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn paths;\r\n\t}","commit_id":"ddcd07508d95383a4ee572f88a32ed3d53ed8fb1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * This method is for compatibility purpose.\n\t * @param filePath\n\t *            project relative (before 1.3.8 version) OR absolute OS file path\n\t *            (1.3.8+ version)\n\t * @param project\n\t * @return file which exactly matches given path\n\t */\n\tpublic static IPath getFilterPath(String filePath, IProject project) {\n\t\tIFile file = null;\n\t\tIPath path = new Path(filePath);\n\t\tif(path.segmentCount() == 1 && !path.isAbsolute()){\n\t\t\t// pre - 1.3.8 code used file names only, see bug 2522989\n\t\t\tfile = project.getFile(filePath);\n\t\t\tif(file != null && file.exists()){\n\t\t\t\tpath = file.getLocation();\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}","id":72385,"modified_method":"/**\n\t * Checks the given path and convert it to absolute path if it is specified relative\n\t * to the given project or workspace\n\t *\n\t * @param filePath\n\t *            project relative OR workspace relative OR absolute OS file path (1.3.8+\n\t *            version)\n\t * @param project\n\t *            might be null (only for workspace relative or absulute paths)\n\t * @return absolute path which matches given relative or absolute path, never null\n\t */\n\tpublic static IPath getFilterPath(String filePath, IProject project) {\n\t\tIPath path = new Path(filePath);\n\t\tif(path.isAbsolute()) {\n\t\t\treturn path;\n\t\t}\n\t\tIPath wspLocation = ResourcesPlugin.getWorkspace().getRoot().getLocation();\n\t\tif(project == null) {\n\t\t\tIPath newPath = wspLocation.append(path);\n\t\t\tif(newPath.toFile().exists()){\n\t\t\t\treturn newPath;\n\t\t\t}\n\t\t} else {\n\t\t\t// try first project relative location\n\t\t\tIPath newPath = project.getLocation().append(path);\n\t\t\tif(newPath.toFile().exists()){\n\t\t\t\treturn newPath;\n\t\t\t}\n\t\t\t// try to resolve relative to workspace (if we use workspace properties for project)\n\t\t\tnewPath = wspLocation.append(path);\n\t\t\tif(newPath.toFile().exists()){\n\t\t\t\treturn newPath;\n\t\t\t}\n\t\t}\n\t\t// something which we have no idea what it can be (or missing/wrong file path)\n\t\treturn path;\n\t}","commit_id":"ddcd07508d95383a4ee572f88a32ed3d53ed8fb1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void configureExtendedProps(Collection<String> filterFiles,\n\t\t\tIFindBugsEngine findBugs, boolean include, boolean bugsFilter) {\n\t\tfor (String filePath : filterFiles) {\n\t\t\tIPath path = getFilterPath(filePath, project);\n\t\t\tif (path != null && path.toFile().exists()) {\n\t\t\t\tString filterName = path.toOSString();\n\t\t\t\ttry {\n\t\t\t\t\tif (bugsFilter) {\n\t\t\t\t\t\tfindBugs.excludeBaselineBugs(filterName);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfindBugs.addFilter(filterName, include);\n\t\t\t\t\t}\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\tFindbugsPlugin.getDefault().logException(e,\n\t\t\t\t\t\t\t\"Error while loading filter \\\"\" + filterName + \"\\\".\");\n\t\t\t\t} catch (DocumentException e) {\n\t\t\t\t\tFindbugsPlugin.getDefault().logException(e,\n\t\t\t\t\t\t\t\"Error while loading excluded bugs \\\"\" + filterName + \"\\\".\");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tFindbugsPlugin.getDefault().logException(e,\n\t\t\t\t\t\t\t\"Error while reading filter \\\"\" + filterName + \"\\\".\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFindbugsPlugin.getDefault().logWarning(\n\t\t\t\t\t\t\"Bug filter not found: \" + filePath);\n\t\t\t}\n\t\t}\n\t}","id":72386,"modified_method":"private void configureExtendedProps(Collection<String> filterFiles,\n\t\t\tIFindBugsEngine findBugs, boolean include, boolean bugsFilter) {\n\t\tfor (String filePath : filterFiles) {\n\t\t\tIPath path = getFilterPath(filePath, project);\n\t\t\tif (!path.toFile().exists()) {\n\t\t\t\tFindbugsPlugin.getDefault().logWarning(\"Filter not found: \" + filePath);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString filterName = path.toOSString();\n\t\t\ttry {\n\t\t\t\tif (bugsFilter) {\n\t\t\t\t\tfindBugs.excludeBaselineBugs(filterName);\n\t\t\t\t} else {\n\t\t\t\t\tfindBugs.addFilter(filterName, include);\n\t\t\t\t}\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tFindbugsPlugin.getDefault().logException(e,\n\t\t\t\t\t\t\"Error while loading filter \\\"\" + filterName + \"\\\".\");\n\t\t\t} catch (DocumentException e) {\n\t\t\t\tFindbugsPlugin.getDefault().logException(e,\n\t\t\t\t\t\t\"Error while loading excluded bugs \\\"\" + filterName + \"\\\".\");\n\t\t\t} catch (IOException e) {\n\t\t\t\tFindbugsPlugin.getDefault().logException(e,\n\t\t\t\t\t\t\"Error while reading filter \\\"\" + filterName + \"\\\".\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"ddcd07508d95383a4ee572f88a32ed3d53ed8fb1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Gets whether the given url is absolute (<tt>true<\/tt>) or relative (<tt>false<\/tt>).\n\t * @param url the url\n\t * @return whether the given url is absolute (<tt>true<\/tt>) or relative (<tt>false<\/tt>)\n\t */\n\tprotected boolean isAbsolute(String url)\n\t{\n\t\tif (url == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// do a fast, simple check first\n\t\tint colonPos;\n\t\tif ((colonPos = url.indexOf(\":\")) == -1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// if we DO have a colon, make sure that every character\n\t\t// leading up to it is a valid scheme character\n\t\tfor (int i = 0; i < colonPos; i++)\n\t\t{\n\t\t\tif (VALID_SCHEME_CHARS.indexOf(url.charAt(i)) == -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// if so, we've got an absolute url\n\t\treturn true;\n\t}","id":72387,"modified_method":"/**\n\t * Gets whether the given url is absolute (<tt>true<\/tt>) or relative (<tt>false<\/tt>).\n\t * @param url the url\n\t * @return whether the given url is absolute (<tt>true<\/tt>) or relative (<tt>false<\/tt>)\n\t */\n\tprotected final boolean isAbsolute(String url)\n\t{\n\t\tif (url == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// do a fast, simple check first\n\t\tint colonPos;\n\t\tif ((colonPos = url.indexOf(\":\")) == -1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// if we DO have a colon, make sure that every character\n\t\t// leading up to it is a valid scheme character\n\t\tfor (int i = 0; i < colonPos; i++)\n\t\t{\n\t\t\tif (VALID_SCHEME_CHARS.indexOf(url.charAt(i)) == -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// if so, we've got an absolute url\n\t\treturn true;\n\t}","commit_id":"9e303dd10a4f5361b18f7c5f13620fe36778928f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Imports the contents of the url of the model object.\n\t * @return the imported contents\n\t */\n\tprotected String importAsString()\n\t{\n\t\t// gets the model object: should provide us with either an absolute or a relative url\n\t\tString url = getModelObjectAsString();\n\n\t\tif (isAbsolute(url))\n\t\t{\n\t\t\t// this is an absolute url; just create an URL object with it\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn importUrl(new URL(url));\n\t\t\t}\n\t\t\tcatch (MalformedURLException e)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn importRelative(url);\n\t}","id":72388,"modified_method":"/**\n\t * Imports the contents of the url of the model object.\n\t * @return the imported contents\n\t */\n\tprotected String importAsString()\n\t{\n\t\t// gets the model object: should provide us with either an absolute or a relative url\n\t\tString url = getModelObjectAsString();\n\n\t\tif (!isAbsolute(url))\n\t\t{\n\t\t\treturn importRelativeUrl(url);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn importAbsoluteUrl(url);\t\n\t\t}\n\t}","commit_id":"9e303dd10a4f5361b18f7c5f13620fe36778928f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Import a resource from a relative url.\n\t * @param url the resource's url\n\t * @return the resource as a string\n\t */\n\tprivate String importRelative(String url)\n\t{\n\t\t// the url is relative; do some request dispatcher magic\n\n\t\tString targetUrl = url;\n\t\tHttpServletRequest httpServletRequest =\n\t\t\t((WebRequest)getRequest()).getHttpServletRequest();\n\t\tHttpServletResponse httpServletResponse =\n\t\t\t((WebResponse)getResponse()).getHttpServletResponse();\n\n\t\t// normalize the URL if we have an HttpServletRequest\n\t\tif (!targetUrl.startsWith(\"/\"))\n\t\t{\n\t\t\tString sp = httpServletRequest.getServletPath();\n\t\t\ttargetUrl = sp.substring(0, sp.lastIndexOf('/')) + '/' + targetUrl;\n\t\t}\n\n\t\t// strip any session id\n\t\ttargetUrl = stripSession(targetUrl);\n\n\t\t// get and check the request dispatcher\n\t\tRequestDispatcher dispatcher = httpServletRequest.getRequestDispatcher(targetUrl);\n\t\tif (dispatcher == null)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"no dispatcher found for url \" + url + \" (tried \"\n\t\t\t\t\t+ targetUrl + \")\");\n\t\t}\n\t\t// include the resource, using our custom wrapper\n\t\tImportResponseWrapper irw = new ImportResponseWrapper(httpServletResponse);\n\n\t\t// spec mandates specific error handling form include()\n\t\ttry\n\t\t{\n\t\t\tdispatcher.include(httpServletRequest, irw);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\n\t\t// disallow inappropriate response codes\n\t\tif (irw.getStatus() < 200 || irw.getStatus() > 299)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(irw.getStatus() + \" \" + targetUrl);\n\t\t}\n\n\t\t// recover the response String from our wrapper\n\t\ttry\n\t\t{\n\t\t\treturn irw.getString();\n\t\t}\n\t\tcatch (UnsupportedEncodingException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t}","id":72389,"modified_method":"/**\n\t * Imports from a relative url.\n\t * @param url the url to import\n\t * @return the imported url's contents\n\t */\n\tprivate String importRelativeUrl(String url)\n\t{\n\t\t// make the url absolute\n\t\tHttpServletRequest req = ((WebRequest)getRequest()).getHttpServletRequest();\n\t\tStringBuffer buildUrl = new StringBuffer();\n\t\tString scheme = req.getScheme();\n\t\tint port = req.getServerPort();\n\t\tString urlPath = req.getRequestURI();\n\t\tbuildUrl.append(scheme);\t// http, https\n\t\tbuildUrl.append(\"://\");\n\t\tbuildUrl.append(req.getServerName());\n\t\tif ((scheme.equals (\"http\") && port != 80)\n\t\t\t|| (scheme.equals (\"https\") && port != 443)) {\n\t\t\tbuildUrl.append (':');\n\t\t\tbuildUrl.append (req.getServerPort ());\n\t\t}\n\t\tbuildUrl.append(req.getContextPath()).append('/').append(url);\n\t\turl = buildUrl.toString();\n\n\t\treturn importAbsoluteUrl(url);\n\t}","commit_id":"9e303dd10a4f5361b18f7c5f13620fe36778928f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Imports the contents from the given url.\n\t * @param url the url\n\t * @return the imported contents\n\t */\n\tprivate String importUrl(URL url)\n\t{\n\t\tUrlResourceStream resourceStream = new UrlResourceStream(url);\n\t\tString content = resourceStream.asString();\n\t\treturn content;\n\t}","id":72390,"modified_method":"/**\n\t * Imports the contents from the given url.\n\t * @param url the url\n\t * @return the imported contents\n\t */\n\tprivate final String importUrl(URL url)\n\t{\n\t\tUrlResourceStream resourceStream = new UrlResourceStream(url);\n\t\tString content = resourceStream.asString();\n\t\treturn content;\n\t}","commit_id":"9e303dd10a4f5361b18f7c5f13620fe36778928f","url":"https://github.com/apache/wicket"},{"original_method":"public boolean isBindToAllInterfaces() {\n        return mping.isBindToAllInterfaces();\n    }","id":72391,"modified_method":"public boolean isSendOnAllInterfaces() {\n        return mping.isSendOnAllInterfaces();\n    }","commit_id":"1fdab044e30d7e5ba9752c43ac801be612b534fb","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        boolean ignore_systemprops=Util.isBindAddressPropertyIgnored();\n        String str=Util.getProperty(new String[]{Global.BIND_ADDR, Global.BIND_ADDR_OLD}, props, \"bind_addr\",\n                                    ignore_systemprops, null);\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_MCAST_ADDR}, props, \"mcast_addr\", false, \"230.5.6.7\");\n        if(str != null) {\n            try {\n                mcast_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException e) {\n                log.error(\"could not resolve \" + str, e);\n                return false;\n            }\n            props.remove(\"mcast_addr\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_MCAST_PORT}, props, \"mcast_port\", false, \"7555\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_IP_TTL}, props, \"ip_ttl\", false, \"16\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"bind_to_all_interfaces\");\n        if(str != null) {\n            bind_to_all_interfaces=Boolean.parseBoolean(str);\n            props.remove(\"bind_to_all_interfaces\");\n        }\n\n        if(mcast_addr == null) {\n            try {\n                mcast_addr=InetAddress.getByName(\"230.5.6.7\");\n            }\n            catch(UnknownHostException e) {\n                log.error(\"failed getting default mcast address\", e);\n                return false;\n            }\n        }\n        return super.setProperties(props);\n    }","id":72392,"modified_method":"public boolean setProperties(Properties props) {\n        boolean ignore_systemprops=Util.isBindAddressPropertyIgnored();\n        String str=Util.getProperty(new String[]{Global.BIND_ADDR, Global.BIND_ADDR_OLD}, props, \"bind_addr\",\n                                    ignore_systemprops, null);\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_MCAST_ADDR}, props, \"mcast_addr\", false, \"230.5.6.7\");\n        if(str != null) {\n            try {\n                mcast_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException e) {\n                log.error(\"could not resolve \" + str, e);\n                return false;\n            }\n            props.remove(\"mcast_addr\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_MCAST_PORT}, props, \"mcast_port\", false, \"7555\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_IP_TTL}, props, \"ip_ttl\", false, \"16\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"bind_to_all_interfaces\");\n        if(str != null) {\n            receive_on_all_interfaces=Boolean.parseBoolean(str);\n            props.remove(\"bind_to_all_interfaces\");\n            log.warn(\"bind_to_all_interfaces has been deprecated; use receive_on_all_interfaces instead\");\n            props.remove(\"bind_to_all_interfaces\");\n        }\n\n        str=props.getProperty(\"receive_on_all_interfaces\");\n        if(str != null) {\n            receive_on_all_interfaces=Boolean.parseBoolean(str);\n            props.remove(\"receive_on_all_interfaces\");\n        }\n\n        str=props.getProperty(\"receive_interfaces\");\n        if(str != null) {\n            try {\n                receive_interfaces=Util.parseInterfaceList(str);\n                props.remove(\"receive_interfaces\");\n            }\n            catch(Exception e) {\n                log.error(\"error determining interfaces (\" + str + \")\", e);\n                return false;\n            }\n        }\n\n        str=props.getProperty(\"send_on_all_interfaces\");\n        if(str != null) {\n            send_on_all_interfaces=Boolean.parseBoolean(str);\n            props.remove(\"send_on_all_interfaces\");\n        }\n\n        str=props.getProperty(\"send_interfaces\");\n        if(str != null) {\n            try {\n                send_interfaces=Util.parseInterfaceList(str);\n                props.remove(\"send_interfaces\");\n            }\n            catch(Exception e) {\n                log.error(\"error determining interfaces (\" + str + \")\", e);\n                return false;\n            }\n        }\n\n        if(mcast_addr == null) {\n            try {\n                mcast_addr=InetAddress.getByName(\"230.5.6.7\");\n            }\n            catch(UnknownHostException e) {\n                log.error(\"failed getting default mcast address\", e);\n                return false;\n            }\n        }\n        return super.setProperties(props);\n    }","commit_id":"1fdab044e30d7e5ba9752c43ac801be612b534fb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() throws Exception {\n        mcast_sock=new MulticastSocket(mcast_port);\n        mcast_sock.setTimeToLive(ip_ttl);\n\n        if(bind_to_all_interfaces) {\n            bindToAllInterfaces();\n            // interface for outgoing packets\n            if(bind_addr != null)\n                mcast_sock.setNetworkInterface(NetworkInterface.getByInetAddress(bind_addr));\n        }\n        else {\n            if(bind_addr == null) {\n                InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n                if(interfaces != null && interfaces.length > 0)\n                    bind_addr=interfaces[0];\n            }\n            if(bind_addr == null)\n                bind_addr=InetAddress.getLocalHost();\n\n            if(bind_addr != null)\n                if(log.isDebugEnabled()) log.debug(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n            if(bind_addr != null) {\n                mcast_sock.setInterface(bind_addr);\n                // mcast_sock.setNetworkInterface(NetworkInterface.getByInetAddress(bind_addr)); // JDK 1.4 specific\n            }\n            mcast_sock.joinGroup(mcast_addr);\n        }\n\n        startReceiver();\n        super.start();\n    }","id":72393,"modified_method":"public void start() throws Exception {\n        mcast_sock=new MulticastSocket(mcast_port);\n        mcast_sock.setTimeToLive(ip_ttl);\n\n        if(receive_on_all_interfaces || (receive_interfaces != null && !receive_interfaces.isEmpty())) {\n            List<NetworkInterface> interfaces;\n            if(receive_interfaces != null)\n                interfaces=receive_interfaces;\n            else\n                interfaces=Util.getAllAvailableInterfaces();\n            bindToInterfaces(interfaces, mcast_sock, mcast_addr);\n        }\n        else {\n            if(bind_addr != null)\n                mcast_sock.setInterface(bind_addr);\n            mcast_sock.joinGroup(mcast_addr);\n        }\n\n\n        // 3b. Create mcast sender socket\n        if(send_on_all_interfaces || (send_interfaces != null && !send_interfaces.isEmpty())) {\n            List interfaces;\n            NetworkInterface intf;\n            if(send_interfaces != null)\n                interfaces=send_interfaces;\n            else\n                interfaces=Util.getAllAvailableInterfaces();\n            mcast_send_sockets=new MulticastSocket[interfaces.size()];\n            int index=0;\n            for(Iterator it=interfaces.iterator(); it.hasNext();) {\n                intf=(NetworkInterface)it.next();\n                mcast_send_sockets[index]=new MulticastSocket();\n                mcast_send_sockets[index].setNetworkInterface(intf);\n                mcast_send_sockets[index].setTimeToLive(ip_ttl);\n                index++;\n            }\n        }\n\n\n        startReceiver();\n        super.start();\n    }","commit_id":"1fdab044e30d7e5ba9752c43ac801be612b534fb","url":"https://github.com/belaban/JGroups"},{"original_method":"void sendMcastDiscoveryRequest(Message msg) {\n        Buffer           buf;\n        DatagramPacket   packet;\n        DataOutputStream out=null;\n\n        try {\n            if(msg.getSrc() == null)\n                msg.setSrc(local_addr);\n            out_stream.reset();\n            out=new DataOutputStream(out_stream);\n            msg.writeTo(out);\n            out.flush(); // flushes contents to out_stream\n            buf=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n            packet=new DatagramPacket(buf.getBuf(), buf.getOffset(), buf.getLength(), mcast_addr, mcast_port);\n            mcast_sock.send(packet);\n        }\n        catch(IOException ex) {\n            log.error(\"failed sending discovery request\", ex);\n        }\n        finally {\n            Util.close(out);\n        }\n    }","id":72394,"modified_method":"void sendMcastDiscoveryRequest(Message msg) {\n        Buffer           buf;\n        DatagramPacket   packet;\n        DataOutputStream out=null;\n\n        try {\n            if(msg.getSrc() == null)\n                msg.setSrc(local_addr);\n            out_stream.reset();\n            out=new DataOutputStream(out_stream);\n            msg.writeTo(out);\n            out.flush(); // flushes contents to out_stream\n            buf=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n            packet=new DatagramPacket(buf.getBuf(), buf.getOffset(), buf.getLength(), mcast_addr, mcast_port);\n            if(mcast_send_sockets != null) {\n                MulticastSocket s;\n                for(int i=0; i < mcast_send_sockets.length; i++) {\n                    s=mcast_send_sockets[i];\n                    try {\n                        s.send(packet);\n                    }\n                    catch(Exception e) {\n                        log.error(\"failed sending packet on socket \" + s);\n                    }\n                }\n            }\n            else { // DEFAULT path\n                if(mcast_sock != null)\n                    mcast_sock.send(packet);\n            }\n        }\n        catch(IOException ex) {\n            log.error(\"failed sending discovery request\", ex);\n        }\n        finally {\n            Util.close(out);\n        }\n    }","commit_id":"1fdab044e30d7e5ba9752c43ac801be612b534fb","url":"https://github.com/belaban/JGroups"},{"original_method":"private void bindToAllInterfaces() throws IOException {\n        SocketAddress tmp_mcast_addr=new InetSocketAddress(mcast_addr, mcast_port);\n        Enumeration en=NetworkInterface.getNetworkInterfaces();\n        while(en.hasMoreElements()) {\n            NetworkInterface i=(NetworkInterface)en.nextElement();\n            for(Enumeration en2=i.getInetAddresses(); en2.hasMoreElements();) {\n                InetAddress addr=(InetAddress)en2.nextElement();\n                // if(addr.isLoopbackAddress())\n                   // continue;\n                mcast_sock.joinGroup(tmp_mcast_addr, i);\n                if(log.isTraceEnabled())\n                    log.trace(\"joined \" + tmp_mcast_addr + \" on interface \" + i.getName() + \" (\" + addr + \")\");\n                break;\n            }\n        }\n    }","id":72395,"modified_method":"public boolean isReceiveOnAllInterfaces() {\n        return receive_on_all_interfaces;\n    }","commit_id":"1fdab044e30d7e5ba9752c43ac801be612b534fb","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean isBindToAllInterfaces() {\n        return bind_to_all_interfaces;\n    }","id":72396,"modified_method":"public boolean isSendOnAllInterfaces() {\n        return send_on_all_interfaces;\n    }","commit_id":"1fdab044e30d7e5ba9752c43ac801be612b534fb","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean isBindToAllInterfaces() {\n        return mping.isBindToAllInterfaces();\n    }","id":72397,"modified_method":"public boolean isSendOnAllInterfaces() {\n        return mping.isSendOnAllInterfaces();\n    }","commit_id":"725f644832c979c654125f0aa8c1bf41e12236d4","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        boolean ignore_systemprops=Util.isBindAddressPropertyIgnored();\n        String str=Util.getProperty(new String[]{Global.BIND_ADDR, Global.BIND_ADDR_OLD}, props, \"bind_addr\",\n                                    ignore_systemprops, null);\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_MCAST_ADDR}, props, \"mcast_addr\", false, \"230.5.6.7\");\n        if(str != null) {\n            try {\n                mcast_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException e) {\n                log.error(\"could not resolve \" + str, e);\n                return false;\n            }\n            props.remove(\"mcast_addr\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_MCAST_PORT}, props, \"mcast_port\", false, \"7555\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_IP_TTL}, props, \"ip_ttl\", false, \"16\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"bind_to_all_interfaces\");\n        if(str != null) {\n            bind_to_all_interfaces=Boolean.parseBoolean(str);\n            props.remove(\"bind_to_all_interfaces\");\n        }\n\n        if(mcast_addr == null) {\n            try {\n                mcast_addr=InetAddress.getByName(\"230.5.6.7\");\n            }\n            catch(UnknownHostException e) {\n                log.error(\"failed getting default mcast address\", e);\n                return false;\n            }\n        }\n        return super.setProperties(props);\n    }","id":72398,"modified_method":"public boolean setProperties(Properties props) {\n        boolean ignore_systemprops=Util.isBindAddressPropertyIgnored();\n        String str=Util.getProperty(new String[]{Global.BIND_ADDR, Global.BIND_ADDR_OLD}, props, \"bind_addr\",\n                                    ignore_systemprops, null);\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_MCAST_ADDR}, props, \"mcast_addr\", false, \"230.5.6.7\");\n        if(str != null) {\n            try {\n                mcast_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException e) {\n                log.error(\"could not resolve \" + str, e);\n                return false;\n            }\n            props.remove(\"mcast_addr\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_MCAST_PORT}, props, \"mcast_port\", false, \"7555\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=Util.getProperty(new String[]{Global.MPING_IP_TTL}, props, \"ip_ttl\", false, \"16\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"bind_to_all_interfaces\");\n        if(str != null) {\n            receive_on_all_interfaces=Boolean.parseBoolean(str);\n            props.remove(\"bind_to_all_interfaces\");\n            log.warn(\"bind_to_all_interfaces has been deprecated; use receive_on_all_interfaces instead\");\n            props.remove(\"bind_to_all_interfaces\");\n        }\n\n        str=props.getProperty(\"receive_on_all_interfaces\");\n        if(str != null) {\n            receive_on_all_interfaces=Boolean.parseBoolean(str);\n            props.remove(\"receive_on_all_interfaces\");\n        }\n\n        str=props.getProperty(\"receive_interfaces\");\n        if(str != null) {\n            try {\n                receive_interfaces=Util.parseInterfaceList(str);\n                props.remove(\"receive_interfaces\");\n            }\n            catch(Exception e) {\n                log.error(\"error determining interfaces (\" + str + \")\", e);\n                return false;\n            }\n        }\n\n        str=props.getProperty(\"send_on_all_interfaces\");\n        if(str != null) {\n            send_on_all_interfaces=Boolean.parseBoolean(str);\n            props.remove(\"send_on_all_interfaces\");\n        }\n\n        str=props.getProperty(\"send_interfaces\");\n        if(str != null) {\n            try {\n                send_interfaces=Util.parseInterfaceList(str);\n                props.remove(\"send_interfaces\");\n            }\n            catch(Exception e) {\n                log.error(\"error determining interfaces (\" + str + \")\", e);\n                return false;\n            }\n        }\n\n        if(mcast_addr == null) {\n            try {\n                mcast_addr=InetAddress.getByName(\"230.5.6.7\");\n            }\n            catch(UnknownHostException e) {\n                log.error(\"failed getting default mcast address\", e);\n                return false;\n            }\n        }\n        return super.setProperties(props);\n    }","commit_id":"725f644832c979c654125f0aa8c1bf41e12236d4","url":"https://github.com/belaban/JGroups"},{"original_method":"void sendMcastDiscoveryRequest(Message msg) {\n        Buffer           buf;\n        DatagramPacket   packet;\n        DataOutputStream out=null;\n\n        try {\n            if(msg.getSrc() == null)\n                msg.setSrc(local_addr);\n            out_stream.reset();\n            out=new DataOutputStream(out_stream);\n            msg.writeTo(out);\n            out.flush(); // flushes contents to out_stream\n            buf=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n            packet=new DatagramPacket(buf.getBuf(), buf.getOffset(), buf.getLength(), mcast_addr, mcast_port);\n            mcast_sock.send(packet);\n        }\n        catch(IOException ex) {\n            log.error(\"failed sending discovery request\", ex);\n        }\n        finally {\n            Util.close(out);\n        }\n    }","id":72399,"modified_method":"void sendMcastDiscoveryRequest(Message msg) {\n        Buffer           buf;\n        DatagramPacket   packet;\n        DataOutputStream out=null;\n\n        try {\n            if(msg.getSrc() == null)\n                msg.setSrc(local_addr);\n            out_stream.reset();\n            out=new DataOutputStream(out_stream);\n            msg.writeTo(out);\n            out.flush(); // flushes contents to out_stream\n            buf=new Buffer(out_stream.getRawBuffer(), 0, out_stream.size());\n            packet=new DatagramPacket(buf.getBuf(), buf.getOffset(), buf.getLength(), mcast_addr, mcast_port);\n            if(mcast_send_sockets != null) {\n                MulticastSocket s;\n                for(int i=0; i < mcast_send_sockets.length; i++) {\n                    s=mcast_send_sockets[i];\n                    try {\n                        s.send(packet);\n                    }\n                    catch(Exception e) {\n                        log.error(\"failed sending packet on socket \" + s);\n                    }\n                }\n            }\n            else { // DEFAULT path\n                if(mcast_sock != null)\n                    mcast_sock.send(packet);\n            }\n        }\n        catch(IOException ex) {\n            log.error(\"failed sending discovery request\", ex);\n        }\n        finally {\n            Util.close(out);\n        }\n    }","commit_id":"725f644832c979c654125f0aa8c1bf41e12236d4","url":"https://github.com/belaban/JGroups"},{"original_method":"private void bindToAllInterfaces() throws IOException {\n        SocketAddress tmp_mcast_addr=new InetSocketAddress(mcast_addr, mcast_port);\n        Enumeration en=NetworkInterface.getNetworkInterfaces();\n        while(en.hasMoreElements()) {\n            NetworkInterface i=(NetworkInterface)en.nextElement();\n            for(Enumeration en2=i.getInetAddresses(); en2.hasMoreElements();) {\n                InetAddress addr=(InetAddress)en2.nextElement();\n                // if(addr.isLoopbackAddress())\n                   // continue;\n                mcast_sock.joinGroup(tmp_mcast_addr, i);\n                if(log.isTraceEnabled())\n                    log.trace(\"joined \" + tmp_mcast_addr + \" on interface \" + i.getName() + \" (\" + addr + \")\");\n                break;\n            }\n        }\n    }","id":72400,"modified_method":"public boolean isReceiveOnAllInterfaces() {\n        return receive_on_all_interfaces;\n    }","commit_id":"725f644832c979c654125f0aa8c1bf41e12236d4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() throws Exception {\n        mcast_sock=new MulticastSocket(mcast_port);\n        mcast_sock.setTimeToLive(ip_ttl);\n\n        if(bind_to_all_interfaces) {\n            bindToAllInterfaces();\n            // interface for outgoing packets\n            if(bind_addr != null)\n                mcast_sock.setNetworkInterface(NetworkInterface.getByInetAddress(bind_addr));\n        }\n        else {\n            if(bind_addr == null) {\n                InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n                if(interfaces != null && interfaces.length > 0)\n                    bind_addr=interfaces[0];\n            }\n            if(bind_addr == null)\n                bind_addr=InetAddress.getLocalHost();\n\n            if(bind_addr != null)\n                if(log.isDebugEnabled()) log.debug(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n            if(bind_addr != null) {\n                mcast_sock.setInterface(bind_addr);\n                // mcast_sock.setNetworkInterface(NetworkInterface.getByInetAddress(bind_addr)); // JDK 1.4 specific\n            }\n            mcast_sock.joinGroup(mcast_addr);\n        }\n\n        startReceiver();\n        super.start();\n    }","id":72401,"modified_method":"public void start() throws Exception {\n        mcast_sock=new MulticastSocket(mcast_port);\n        mcast_sock.setTimeToLive(ip_ttl);\n\n        if(receive_on_all_interfaces || (receive_interfaces != null && !receive_interfaces.isEmpty())) {\n            List<NetworkInterface> interfaces;\n            if(receive_interfaces != null)\n                interfaces=receive_interfaces;\n            else\n                interfaces=Util.getAllAvailableInterfaces();\n            bindToInterfaces(interfaces, mcast_sock, mcast_addr);\n        }\n        else {\n            if(bind_addr != null)\n                mcast_sock.setInterface(bind_addr);\n            mcast_sock.joinGroup(mcast_addr);\n        }\n\n\n        // 3b. Create mcast sender socket\n        if(send_on_all_interfaces || (send_interfaces != null && !send_interfaces.isEmpty())) {\n            List interfaces;\n            NetworkInterface intf;\n            if(send_interfaces != null)\n                interfaces=send_interfaces;\n            else\n                interfaces=Util.getAllAvailableInterfaces();\n            mcast_send_sockets=new MulticastSocket[interfaces.size()];\n            int index=0;\n            for(Iterator it=interfaces.iterator(); it.hasNext();) {\n                intf=(NetworkInterface)it.next();\n                mcast_send_sockets[index]=new MulticastSocket();\n                mcast_send_sockets[index].setNetworkInterface(intf);\n                mcast_send_sockets[index].setTimeToLive(ip_ttl);\n                index++;\n            }\n        }\n\n\n        startReceiver();\n        super.start();\n    }","commit_id":"725f644832c979c654125f0aa8c1bf41e12236d4","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean isBindToAllInterfaces() {\n        return bind_to_all_interfaces;\n    }","id":72402,"modified_method":"public boolean isSendOnAllInterfaces() {\n        return send_on_all_interfaces;\n    }","commit_id":"725f644832c979c654125f0aa8c1bf41e12236d4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Create UDP sender and receiver sockets. Currently there are 2 sockets\n     * (sending and receiving). This is due to Linux's non-BSD compatibility\n     * in the JDK port (see DESIGN).\n     */\n    void createSockets() throws Exception {\n        InetAddress tmp_addr=null;\n\n        // bind_addr not set, try to assign one by default. This is needed on Windows\n\n        // changed by bela Feb 12 2003: by default multicast sockets will be bound to all network interfaces\n\n        // CHANGED *BACK* by bela March 13 2003: binding to all interfaces did not result in a correct\n        // local_addr. As a matter of fact, comparison between e.g. 0.0.0.0:1234 (on hostA) and\n        // 0.0.0.0:1.2.3.4 (on hostB) would fail !\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n        // 2. Create socket for receiving unicast UDP packets. The address and port\n        //    of this socket will be our local address (local_addr)\n        if(bind_port > 0) {\n            sock=createDatagramSocketWithBindPort();\n        }\n        else {\n            sock=createEphemeralDatagramSocket();\n        }\n\n        if(sock == null)\n            throw new Exception(\"UDP.createSocket(): sock is null\");\n\n        local_addr=new IpAddress(sock.getLocalAddress(), sock.getLocalPort());\n        if(additional_data != null)\n            local_addr.setAdditionalData(additional_data);\n\n\n        // 3. Create socket for receiving IP multicast packets\n        if(ip_mcast) {\n            // 3a. Create mcast receiver socket\n            mcast_recv_sock=new MulticastSocket(mcast_port);\n            mcast_recv_sock.setTimeToLive(ip_ttl);\n            if(bind_addr != null)\n                mcast_recv_sock.setInterface(bind_addr);\n            tmp_addr=InetAddress.getByName(mcast_addr_name);\n            mcast_addr=new IpAddress(tmp_addr, mcast_port);\n            mcast_recv_sock.joinGroup(tmp_addr);\n\n            // 3b. Create mcast sender socket\n            mcast_send_sock=new MulticastSocket();\n            mcast_send_sock.setTimeToLive(ip_ttl);\n            if(bind_addr != null)\n                mcast_send_sock.setInterface(bind_addr);\n            // mcast_send_sock.setTrafficClass(0x08); // high throughput; should investigate when baseline is JDK 1.4\n        }\n\n        setBufferSizes();\n        if(log.isInfoEnabled()) log.info(\"socket information:\\n\" + dumpSocketInfo());\n    }","id":72403,"modified_method":"/**\n     * Create UDP sender and receiver sockets. Currently there are 2 sockets\n     * (sending and receiving). This is due to Linux's non-BSD compatibility\n     * in the JDK port (see DESIGN).\n     */\n    void createSockets() throws Exception {\n        InetAddress tmp_addr=null;\n\n        // bind_addr not set, try to assign one by default. This is needed on Windows\n\n        // changed by bela Feb 12 2003: by default multicast sockets will be bound to all network interfaces\n\n        // CHANGED *BACK* by bela March 13 2003: binding to all interfaces did not result in a correct\n        // local_addr. As a matter of fact, comparison between e.g. 0.0.0.0:1234 (on hostA) and\n        // 0.0.0.0:1.2.3.4 (on hostB) would fail !\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n        // 2. Create socket for receiving unicast UDP packets. The address and port\n        //    of this socket will be our local address (local_addr)\n        if(bind_port > 0) {\n            sock=createDatagramSocketWithBindPort();\n        }\n        else {\n            sock=createEphemeralDatagramSocket();\n        }\n\n        if(sock == null)\n            throw new Exception(\"UDP.createSocket(): sock is null\");\n\n        local_addr=new IpAddress(sock.getLocalAddress(), sock.getLocalPort());\n        if(additional_data != null)\n            local_addr.setAdditionalData(additional_data);\n\n\n        // 3. Create socket for receiving IP multicast packets\n        if(ip_mcast) {\n            // 3a. Create mcast receiver socket\n            mcast_recv_sock=new MulticastSocket(mcast_port);\n            mcast_recv_sock.setTimeToLive(ip_ttl);\n            tmp_addr=InetAddress.getByName(mcast_addr_name);\n            mcast_addr=new IpAddress(tmp_addr, mcast_port);\n\n            if(bind_to_all_interfaces && Util.getJavaVersion() >= 14) {\n                bindToAllInterfaces(mcast_recv_sock, mcast_addr.getIpAddress());\n            }\n            else {\n                if(bind_addr != null)\n                    mcast_recv_sock.setInterface(bind_addr);\n                 mcast_recv_sock.joinGroup(tmp_addr);\n            }\n\n            // 3b. Create mcast sender socket\n            mcast_send_sock=new MulticastSocket();\n            mcast_send_sock.setTimeToLive(ip_ttl);\n            if(bind_addr != null)\n                mcast_send_sock.setInterface(bind_addr);\n            // mcast_send_sock.setTrafficClass(0x08); // high throughput; should investigate when baseline is JDK 1.4\n        }\n\n        setBufferSizes();\n        if(log.isInfoEnabled()) log.info(\"socket information:\\n\" + dumpSocketInfo());\n    }","commit_id":"ad338c470d70af96211758c822e3000c69f7fd5f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Setup the Protocol instance acording to the configuration string\n     * The following properties are being read by the UDP protocol\n     * param mcast_addr - the multicast address to use default is 228.8.8.8\n     * param mcast_port - (int) the port that the multicast is sent on default is 7600\n     * param ip_mcast - (boolean) flag whether to use IP multicast - default is true\n     * param ip_ttl - Set the default time-to-live for multicast packets sent out on this socket. default is 32\n     * @return true if no other properties are left.\n     *         false if the properties still have data in them, ie ,\n     *         properties are left over and not handled by the protocol stack\n     *\n     */\n    public boolean setProperties(Properties props) {\n        String str;\n        String tmp = null;\n\n        super.setProperties(props);\n        \n        // PropertyPermission not granted if running in an untrusted environment with JNLP.\n        try {\n            tmp=System.getProperty(\"bind.address\");\n            if(Boolean.getBoolean(IGNORE_BIND_ADDRESS_PROPERTY)) {\n                tmp=null;\n            }\n        }\n        catch (SecurityException ex){\n        }\n        \n        if(tmp != null)\n            str=tmp;\n        else\n            str=props.getProperty(\"bind_addr\");\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=props.getProperty(\"bind_port\");\n        if(str != null) {\n            bind_port=Integer.parseInt(str);\n            props.remove(\"bind_port\");\n        }\n\n        str=props.getProperty(\"num_last_ports\");\n        if(str != null) {\n            num_last_ports=Integer.parseInt(str);\n            props.remove(\"num_last_ports\");\n        }\n\n\t\tstr=props.getProperty(\"start_port\");\n        if(str != null) {\n            bind_port=Integer.parseInt(str);\n            props.remove(\"start_port\");\n        }\n\n\t\tstr=props.getProperty(\"port_range\");\n        if(str != null) {\n            port_range=Integer.parseInt(str);\n            props.remove(\"port_range\");\n        }\n\n        str=props.getProperty(\"mcast_addr\");\n        if(str != null) {\n            mcast_addr_name=str;\n            props.remove(\"mcast_addr\");\n        }\n\n        str=props.getProperty(\"mcast_port\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=props.getProperty(\"ip_mcast\");\n        if(str != null) {\n            ip_mcast=Boolean.valueOf(str).booleanValue();\n            props.remove(\"ip_mcast\");\n        }\n\n        str=props.getProperty(\"ip_ttl\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"mcast_send_buf_size\");\n        if(str != null) {\n            mcast_send_buf_size=Integer.parseInt(str);\n            props.remove(\"mcast_send_buf_size\");\n        }\n\n        str=props.getProperty(\"mcast_recv_buf_size\");\n        if(str != null) {\n            mcast_recv_buf_size=Integer.parseInt(str);\n            props.remove(\"mcast_recv_buf_size\");\n        }\n\n        str=props.getProperty(\"ucast_send_buf_size\");\n        if(str != null) {\n            ucast_send_buf_size=Integer.parseInt(str);\n            props.remove(\"ucast_send_buf_size\");\n        }\n\n        str=props.getProperty(\"ucast_recv_buf_size\");\n        if(str != null) {\n            ucast_recv_buf_size=Integer.parseInt(str);\n            props.remove(\"ucast_recv_buf_size\");\n        }\n\n        str=props.getProperty(\"loopback\");\n        if(str != null) {\n            loopback=Boolean.valueOf(str).booleanValue();\n            props.remove(\"loopback\");\n        }\n\n        str=props.getProperty(\"discard_incompatibe_packets\");\n        if(str != null) {\n            discard_incompatible_packets=Boolean.valueOf(str).booleanValue();\n            props.remove(\"discard_incompatibe_packets\");\n        }\n\n        // this is deprecated, just left for compatibility (use use_incoming_packet_handler)\n        str=props.getProperty(\"use_packet_handler\");\n        if(str != null) {\n            use_incoming_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_packet_handler\");\n            if(log.isWarnEnabled()) log.warn(\"'use_packet_handler' is deprecated; use 'use_incoming_packet_handler' instead\");\n        }\n\n        str=props.getProperty(\"use_incoming_packet_handler\");\n        if(str != null) {\n            use_incoming_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_incoming_packet_handler\");\n        }\n\n        str=props.getProperty(\"use_outgoing_packet_handler\");\n        if(str != null) {\n            use_outgoing_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_outgoing_packet_handler\");\n        }\n\n        str=props.getProperty(\"max_bundle_size\");\n        if(str != null) {\n            int bundle_size=Integer.parseInt(str);\n            if(bundle_size > max_bundle_size) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_size (\" + bundle_size +\n                        \") is greater than largest UDP fragmentation size (\" + max_bundle_size + ')');\n                return false;\n            }\n            if(bundle_size <= 0) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_size (\" + bundle_size + \") is <= 0\");\n                return false;\n            }\n            max_bundle_size=bundle_size;\n            props.remove(\"max_bundle_size\");\n        }\n\n        str=props.getProperty(\"max_bundle_timeout\");\n        if(str != null) {\n            max_bundle_timeout=Long.parseLong(str);\n            if(max_bundle_timeout <= 0) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_timeout of \" + max_bundle_timeout + \" is invalid\");\n                return false;\n            }\n            props.remove(\"max_bundle_timeout\");\n        }\n\n        str=props.getProperty(\"enable_bundling\");\n        if(str != null) {\n            enable_bundling=Boolean.valueOf(str).booleanValue();\n            props.remove(\"enable_bundling\");\n        }\n\n        str=props.getProperty(\"use_addr_translation\");\n        if(str != null) {\n            use_addr_translation=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_addr_translation\");\n        }\n\n        if(props.size() > 0) {\n            System.err.println(\"UDP.setProperties(): the following properties are not recognized:\");\n            props.list(System.out);\n            return false;\n        }\n\n        if(enable_bundling) {\n            if(use_outgoing_packet_handler == false)\n                if(log.isWarnEnabled()) log.warn(\"enable_bundling is true; setting use_outgoing_packet_handler=true\");\n            use_outgoing_packet_handler=true;\n        }\n\n        return true;\n    }","id":72404,"modified_method":"/**\n     * Setup the Protocol instance acording to the configuration string\n     * The following properties are being read by the UDP protocol\n     * param mcast_addr - the multicast address to use default is 228.8.8.8\n     * param mcast_port - (int) the port that the multicast is sent on default is 7600\n     * param ip_mcast - (boolean) flag whether to use IP multicast - default is true\n     * param ip_ttl - Set the default time-to-live for multicast packets sent out on this socket. default is 32\n     * @return true if no other properties are left.\n     *         false if the properties still have data in them, ie ,\n     *         properties are left over and not handled by the protocol stack\n     *\n     */\n    public boolean setProperties(Properties props) {\n        String str;\n        String tmp = null;\n\n        super.setProperties(props);\n        \n        // PropertyPermission not granted if running in an untrusted environment with JNLP.\n        try {\n            tmp=System.getProperty(\"bind.address\");\n            if(Boolean.getBoolean(IGNORE_BIND_ADDRESS_PROPERTY)) {\n                tmp=null;\n            }\n        }\n        catch (SecurityException ex){\n        }\n        \n        if(tmp != null)\n            str=tmp;\n        else\n            str=props.getProperty(\"bind_addr\");\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=props.getProperty(\"bind_to_all_interfaces\");\n        if(str != null) {\n            bind_to_all_interfaces=new Boolean(str).booleanValue();\n            props.remove(\"bind_to_all_interfaces\");\n        }\n\n        str=props.getProperty(\"bind_port\");\n        if(str != null) {\n            bind_port=Integer.parseInt(str);\n            props.remove(\"bind_port\");\n        }\n\n        str=props.getProperty(\"num_last_ports\");\n        if(str != null) {\n            num_last_ports=Integer.parseInt(str);\n            props.remove(\"num_last_ports\");\n        }\n\n\t\tstr=props.getProperty(\"start_port\");\n        if(str != null) {\n            bind_port=Integer.parseInt(str);\n            props.remove(\"start_port\");\n        }\n\n\t\tstr=props.getProperty(\"port_range\");\n        if(str != null) {\n            port_range=Integer.parseInt(str);\n            props.remove(\"port_range\");\n        }\n\n        str=props.getProperty(\"mcast_addr\");\n        if(str != null) {\n            mcast_addr_name=str;\n            props.remove(\"mcast_addr\");\n        }\n\n        str=props.getProperty(\"mcast_port\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=props.getProperty(\"ip_mcast\");\n        if(str != null) {\n            ip_mcast=Boolean.valueOf(str).booleanValue();\n            props.remove(\"ip_mcast\");\n        }\n\n        str=props.getProperty(\"ip_ttl\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"mcast_send_buf_size\");\n        if(str != null) {\n            mcast_send_buf_size=Integer.parseInt(str);\n            props.remove(\"mcast_send_buf_size\");\n        }\n\n        str=props.getProperty(\"mcast_recv_buf_size\");\n        if(str != null) {\n            mcast_recv_buf_size=Integer.parseInt(str);\n            props.remove(\"mcast_recv_buf_size\");\n        }\n\n        str=props.getProperty(\"ucast_send_buf_size\");\n        if(str != null) {\n            ucast_send_buf_size=Integer.parseInt(str);\n            props.remove(\"ucast_send_buf_size\");\n        }\n\n        str=props.getProperty(\"ucast_recv_buf_size\");\n        if(str != null) {\n            ucast_recv_buf_size=Integer.parseInt(str);\n            props.remove(\"ucast_recv_buf_size\");\n        }\n\n        str=props.getProperty(\"loopback\");\n        if(str != null) {\n            loopback=Boolean.valueOf(str).booleanValue();\n            props.remove(\"loopback\");\n        }\n\n        str=props.getProperty(\"discard_incompatibe_packets\");\n        if(str != null) {\n            discard_incompatible_packets=Boolean.valueOf(str).booleanValue();\n            props.remove(\"discard_incompatibe_packets\");\n        }\n\n        // this is deprecated, just left for compatibility (use use_incoming_packet_handler)\n        str=props.getProperty(\"use_packet_handler\");\n        if(str != null) {\n            use_incoming_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_packet_handler\");\n            if(log.isWarnEnabled()) log.warn(\"'use_packet_handler' is deprecated; use 'use_incoming_packet_handler' instead\");\n        }\n\n        str=props.getProperty(\"use_incoming_packet_handler\");\n        if(str != null) {\n            use_incoming_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_incoming_packet_handler\");\n        }\n\n        str=props.getProperty(\"use_outgoing_packet_handler\");\n        if(str != null) {\n            use_outgoing_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_outgoing_packet_handler\");\n        }\n\n        str=props.getProperty(\"max_bundle_size\");\n        if(str != null) {\n            int bundle_size=Integer.parseInt(str);\n            if(bundle_size > max_bundle_size) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_size (\" + bundle_size +\n                        \") is greater than largest UDP fragmentation size (\" + max_bundle_size + ')');\n                return false;\n            }\n            if(bundle_size <= 0) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_size (\" + bundle_size + \") is <= 0\");\n                return false;\n            }\n            max_bundle_size=bundle_size;\n            props.remove(\"max_bundle_size\");\n        }\n\n        str=props.getProperty(\"max_bundle_timeout\");\n        if(str != null) {\n            max_bundle_timeout=Long.parseLong(str);\n            if(max_bundle_timeout <= 0) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_timeout of \" + max_bundle_timeout + \" is invalid\");\n                return false;\n            }\n            props.remove(\"max_bundle_timeout\");\n        }\n\n        str=props.getProperty(\"enable_bundling\");\n        if(str != null) {\n            enable_bundling=Boolean.valueOf(str).booleanValue();\n            props.remove(\"enable_bundling\");\n        }\n\n        str=props.getProperty(\"use_addr_translation\");\n        if(str != null) {\n            use_addr_translation=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_addr_translation\");\n        }\n\n        if(props.size() > 0) {\n            System.err.println(\"UDP.setProperties(): the following properties are not recognized:\");\n            props.list(System.out);\n            return false;\n        }\n\n        if(enable_bundling) {\n            if(use_outgoing_packet_handler == false)\n                if(log.isWarnEnabled()) log.warn(\"enable_bundling is true; setting use_outgoing_packet_handler=true\");\n            use_outgoing_packet_handler=true;\n        }\n\n        return true;\n    }","commit_id":"ad338c470d70af96211758c822e3000c69f7fd5f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Setup the Protocol instance acording to the configuration string\n     * The following properties are being read by the UDP protocol\n     * param mcast_addr - the multicast address to use default is 228.8.8.8\n     * param mcast_port - (int) the port that the multicast is sent on default is 7600\n     * param ip_mcast - (boolean) flag whether to use IP multicast - default is true\n     * param ip_ttl - Set the default time-to-live for multicast packets sent out on this socket. default is 32\n     * @return true if no other properties are left.\n     *         false if the properties still have data in them, ie ,\n     *         properties are left over and not handled by the protocol stack\n     *\n     */\n    public boolean setProperties(Properties props) {\n        String str;\n        String tmp = null;\n\n        super.setProperties(props);\n        \n        // PropertyPermission not granted if running in an untrusted environment with JNLP.\n        try {\n            tmp=System.getProperty(\"bind.address\");\n            if(Boolean.getBoolean(IGNORE_BIND_ADDRESS_PROPERTY)) {\n                tmp=null;\n            }\n        }\n        catch (SecurityException ex){\n        }\n        \n        if(tmp != null)\n            str=tmp;\n        else\n            str=props.getProperty(\"bind_addr\");\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=props.getProperty(\"bind_port\");\n        if(str != null) {\n            bind_port=Integer.parseInt(str);\n            props.remove(\"bind_port\");\n        }\n\n        str=props.getProperty(\"num_last_ports\");\n        if(str != null) {\n            num_last_ports=Integer.parseInt(str);\n            props.remove(\"num_last_ports\");\n        }\n\n\t\tstr=props.getProperty(\"start_port\");\n        if(str != null) {\n            bind_port=Integer.parseInt(str);\n            props.remove(\"start_port\");\n        }\n\n\t\tstr=props.getProperty(\"port_range\");\n        if(str != null) {\n            port_range=Integer.parseInt(str);\n            props.remove(\"port_range\");\n        }\n\n        str=props.getProperty(\"mcast_addr\");\n        if(str != null) {\n            mcast_addr_name=str;\n            props.remove(\"mcast_addr\");\n        }\n\n        str=props.getProperty(\"mcast_port\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=props.getProperty(\"ip_mcast\");\n        if(str != null) {\n            ip_mcast=Boolean.valueOf(str).booleanValue();\n            props.remove(\"ip_mcast\");\n        }\n\n        str=props.getProperty(\"ip_ttl\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"mcast_send_buf_size\");\n        if(str != null) {\n            mcast_send_buf_size=Integer.parseInt(str);\n            props.remove(\"mcast_send_buf_size\");\n        }\n\n        str=props.getProperty(\"mcast_recv_buf_size\");\n        if(str != null) {\n            mcast_recv_buf_size=Integer.parseInt(str);\n            props.remove(\"mcast_recv_buf_size\");\n        }\n\n        str=props.getProperty(\"ucast_send_buf_size\");\n        if(str != null) {\n            ucast_send_buf_size=Integer.parseInt(str);\n            props.remove(\"ucast_send_buf_size\");\n        }\n\n        str=props.getProperty(\"ucast_recv_buf_size\");\n        if(str != null) {\n            ucast_recv_buf_size=Integer.parseInt(str);\n            props.remove(\"ucast_recv_buf_size\");\n        }\n\n        str=props.getProperty(\"loopback\");\n        if(str != null) {\n            loopback=Boolean.valueOf(str).booleanValue();\n            props.remove(\"loopback\");\n        }\n\n        str=props.getProperty(\"discard_incompatibe_packets\");\n        if(str != null) {\n            discard_incompatible_packets=Boolean.valueOf(str).booleanValue();\n            props.remove(\"discard_incompatibe_packets\");\n        }\n\n        // this is deprecated, just left for compatibility (use use_incoming_packet_handler)\n        str=props.getProperty(\"use_packet_handler\");\n        if(str != null) {\n            use_incoming_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_packet_handler\");\n            if(log.isWarnEnabled()) log.warn(\"'use_packet_handler' is deprecated; use 'use_incoming_packet_handler' instead\");\n        }\n\n        str=props.getProperty(\"use_incoming_packet_handler\");\n        if(str != null) {\n            use_incoming_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_incoming_packet_handler\");\n        }\n\n        str=props.getProperty(\"use_outgoing_packet_handler\");\n        if(str != null) {\n            use_outgoing_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_outgoing_packet_handler\");\n        }\n\n        str=props.getProperty(\"max_bundle_size\");\n        if(str != null) {\n            int bundle_size=Integer.parseInt(str);\n            if(bundle_size > max_bundle_size) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_size (\" + bundle_size +\n                        \") is greater than largest UDP fragmentation size (\" + max_bundle_size + ')');\n                return false;\n            }\n            if(bundle_size <= 0) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_size (\" + bundle_size + \") is <= 0\");\n                return false;\n            }\n            max_bundle_size=bundle_size;\n            props.remove(\"max_bundle_size\");\n        }\n\n        str=props.getProperty(\"max_bundle_timeout\");\n        if(str != null) {\n            max_bundle_timeout=Long.parseLong(str);\n            if(max_bundle_timeout <= 0) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_timeout of \" + max_bundle_timeout + \" is invalid\");\n                return false;\n            }\n            props.remove(\"max_bundle_timeout\");\n        }\n\n        str=props.getProperty(\"enable_bundling\");\n        if(str != null) {\n            enable_bundling=Boolean.valueOf(str).booleanValue();\n            props.remove(\"enable_bundling\");\n        }\n\n        str=props.getProperty(\"use_addr_translation\");\n        if(str != null) {\n            use_addr_translation=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_addr_translation\");\n        }\n\n        if(props.size() > 0) {\n            System.err.println(\"UDP.setProperties(): the following properties are not recognized:\");\n            props.list(System.out);\n            return false;\n        }\n\n        if(enable_bundling) {\n            if(use_outgoing_packet_handler == false)\n                if(log.isWarnEnabled()) log.warn(\"enable_bundling is true; setting use_outgoing_packet_handler=true\");\n            use_outgoing_packet_handler=true;\n        }\n\n        return true;\n    }","id":72405,"modified_method":"/**\n     * Setup the Protocol instance acording to the configuration string\n     * The following properties are being read by the UDP protocol\n     * param mcast_addr - the multicast address to use default is 228.8.8.8\n     * param mcast_port - (int) the port that the multicast is sent on default is 7600\n     * param ip_mcast - (boolean) flag whether to use IP multicast - default is true\n     * param ip_ttl - Set the default time-to-live for multicast packets sent out on this socket. default is 32\n     * @return true if no other properties are left.\n     *         false if the properties still have data in them, ie ,\n     *         properties are left over and not handled by the protocol stack\n     *\n     */\n    public boolean setProperties(Properties props) {\n        String str;\n        String tmp = null;\n\n        super.setProperties(props);\n        \n        // PropertyPermission not granted if running in an untrusted environment with JNLP.\n        try {\n            tmp=System.getProperty(\"bind.address\");\n            if(Boolean.getBoolean(IGNORE_BIND_ADDRESS_PROPERTY)) {\n                tmp=null;\n            }\n        }\n        catch (SecurityException ex){\n        }\n        \n        if(tmp != null)\n            str=tmp;\n        else\n            str=props.getProperty(\"bind_addr\");\n        if(str != null) {\n            try {\n                bind_addr=InetAddress.getByName(str);\n            }\n            catch(UnknownHostException unknown) {\n                if(log.isFatalEnabled()) log.fatal(\"(bind_addr): host \" + str + \" not known\");\n                return false;\n            }\n            props.remove(\"bind_addr\");\n        }\n\n        str=props.getProperty(\"bind_to_all_interfaces\");\n        if(str != null) {\n            bind_to_all_interfaces=new Boolean(str).booleanValue();\n            props.remove(\"bind_to_all_interfaces\");\n        }\n\n        str=props.getProperty(\"bind_port\");\n        if(str != null) {\n            bind_port=Integer.parseInt(str);\n            props.remove(\"bind_port\");\n        }\n\n        str=props.getProperty(\"num_last_ports\");\n        if(str != null) {\n            num_last_ports=Integer.parseInt(str);\n            props.remove(\"num_last_ports\");\n        }\n\n\t\tstr=props.getProperty(\"start_port\");\n        if(str != null) {\n            bind_port=Integer.parseInt(str);\n            props.remove(\"start_port\");\n        }\n\n\t\tstr=props.getProperty(\"port_range\");\n        if(str != null) {\n            port_range=Integer.parseInt(str);\n            props.remove(\"port_range\");\n        }\n\n        str=props.getProperty(\"mcast_addr\");\n        if(str != null) {\n            mcast_addr_name=str;\n            props.remove(\"mcast_addr\");\n        }\n\n        str=props.getProperty(\"mcast_port\");\n        if(str != null) {\n            mcast_port=Integer.parseInt(str);\n            props.remove(\"mcast_port\");\n        }\n\n        str=props.getProperty(\"ip_mcast\");\n        if(str != null) {\n            ip_mcast=Boolean.valueOf(str).booleanValue();\n            props.remove(\"ip_mcast\");\n        }\n\n        str=props.getProperty(\"ip_ttl\");\n        if(str != null) {\n            ip_ttl=Integer.parseInt(str);\n            props.remove(\"ip_ttl\");\n        }\n\n        str=props.getProperty(\"mcast_send_buf_size\");\n        if(str != null) {\n            mcast_send_buf_size=Integer.parseInt(str);\n            props.remove(\"mcast_send_buf_size\");\n        }\n\n        str=props.getProperty(\"mcast_recv_buf_size\");\n        if(str != null) {\n            mcast_recv_buf_size=Integer.parseInt(str);\n            props.remove(\"mcast_recv_buf_size\");\n        }\n\n        str=props.getProperty(\"ucast_send_buf_size\");\n        if(str != null) {\n            ucast_send_buf_size=Integer.parseInt(str);\n            props.remove(\"ucast_send_buf_size\");\n        }\n\n        str=props.getProperty(\"ucast_recv_buf_size\");\n        if(str != null) {\n            ucast_recv_buf_size=Integer.parseInt(str);\n            props.remove(\"ucast_recv_buf_size\");\n        }\n\n        str=props.getProperty(\"loopback\");\n        if(str != null) {\n            loopback=Boolean.valueOf(str).booleanValue();\n            props.remove(\"loopback\");\n        }\n\n        str=props.getProperty(\"discard_incompatibe_packets\");\n        if(str != null) {\n            discard_incompatible_packets=Boolean.valueOf(str).booleanValue();\n            props.remove(\"discard_incompatibe_packets\");\n        }\n\n        // this is deprecated, just left for compatibility (use use_incoming_packet_handler)\n        str=props.getProperty(\"use_packet_handler\");\n        if(str != null) {\n            use_incoming_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_packet_handler\");\n            if(log.isWarnEnabled()) log.warn(\"'use_packet_handler' is deprecated; use 'use_incoming_packet_handler' instead\");\n        }\n\n        str=props.getProperty(\"use_incoming_packet_handler\");\n        if(str != null) {\n            use_incoming_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_incoming_packet_handler\");\n        }\n\n        str=props.getProperty(\"use_outgoing_packet_handler\");\n        if(str != null) {\n            use_outgoing_packet_handler=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_outgoing_packet_handler\");\n        }\n\n        str=props.getProperty(\"max_bundle_size\");\n        if(str != null) {\n            int bundle_size=Integer.parseInt(str);\n            if(bundle_size > max_bundle_size) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_size (\" + bundle_size +\n                        \") is greater than largest UDP fragmentation size (\" + max_bundle_size + ')');\n                return false;\n            }\n            if(bundle_size <= 0) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_size (\" + bundle_size + \") is <= 0\");\n                return false;\n            }\n            max_bundle_size=bundle_size;\n            props.remove(\"max_bundle_size\");\n        }\n\n        str=props.getProperty(\"max_bundle_timeout\");\n        if(str != null) {\n            max_bundle_timeout=Long.parseLong(str);\n            if(max_bundle_timeout <= 0) {\n                if(log.isErrorEnabled()) log.error(\"max_bundle_timeout of \" + max_bundle_timeout + \" is invalid\");\n                return false;\n            }\n            props.remove(\"max_bundle_timeout\");\n        }\n\n        str=props.getProperty(\"enable_bundling\");\n        if(str != null) {\n            enable_bundling=Boolean.valueOf(str).booleanValue();\n            props.remove(\"enable_bundling\");\n        }\n\n        str=props.getProperty(\"use_addr_translation\");\n        if(str != null) {\n            use_addr_translation=Boolean.valueOf(str).booleanValue();\n            props.remove(\"use_addr_translation\");\n        }\n\n        if(props.size() > 0) {\n            System.err.println(\"UDP.setProperties(): the following properties are not recognized:\");\n            props.list(System.out);\n            return false;\n        }\n\n        if(enable_bundling) {\n            if(use_outgoing_packet_handler == false)\n                if(log.isWarnEnabled()) log.warn(\"enable_bundling is true; setting use_outgoing_packet_handler=true\");\n            use_outgoing_packet_handler=true;\n        }\n\n        return true;\n    }","commit_id":"25d0ee64f81bd8a31c5f7dc22852a26521927308","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Create UDP sender and receiver sockets. Currently there are 2 sockets\n     * (sending and receiving). This is due to Linux's non-BSD compatibility\n     * in the JDK port (see DESIGN).\n     */\n    void createSockets() throws Exception {\n        InetAddress tmp_addr=null;\n\n        // bind_addr not set, try to assign one by default. This is needed on Windows\n\n        // changed by bela Feb 12 2003: by default multicast sockets will be bound to all network interfaces\n\n        // CHANGED *BACK* by bela March 13 2003: binding to all interfaces did not result in a correct\n        // local_addr. As a matter of fact, comparison between e.g. 0.0.0.0:1234 (on hostA) and\n        // 0.0.0.0:1.2.3.4 (on hostB) would fail !\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n        // 2. Create socket for receiving unicast UDP packets. The address and port\n        //    of this socket will be our local address (local_addr)\n        if(bind_port > 0) {\n            sock=createDatagramSocketWithBindPort();\n        }\n        else {\n            sock=createEphemeralDatagramSocket();\n        }\n\n        if(sock == null)\n            throw new Exception(\"UDP.createSocket(): sock is null\");\n\n        local_addr=new IpAddress(sock.getLocalAddress(), sock.getLocalPort());\n        if(additional_data != null)\n            local_addr.setAdditionalData(additional_data);\n\n\n        // 3. Create socket for receiving IP multicast packets\n        if(ip_mcast) {\n            // 3a. Create mcast receiver socket\n            mcast_recv_sock=new MulticastSocket(mcast_port);\n            mcast_recv_sock.setTimeToLive(ip_ttl);\n            if(bind_addr != null)\n                mcast_recv_sock.setInterface(bind_addr);\n            tmp_addr=InetAddress.getByName(mcast_addr_name);\n            mcast_addr=new IpAddress(tmp_addr, mcast_port);\n            mcast_recv_sock.joinGroup(tmp_addr);\n\n            // 3b. Create mcast sender socket\n            mcast_send_sock=new MulticastSocket();\n            mcast_send_sock.setTimeToLive(ip_ttl);\n            if(bind_addr != null)\n                mcast_send_sock.setInterface(bind_addr);\n            // mcast_send_sock.setTrafficClass(0x08); // high throughput; should investigate when baseline is JDK 1.4\n        }\n\n        setBufferSizes();\n        if(log.isInfoEnabled()) log.info(\"socket information:\\n\" + dumpSocketInfo());\n    }","id":72406,"modified_method":"/**\n     * Create UDP sender and receiver sockets. Currently there are 2 sockets\n     * (sending and receiving). This is due to Linux's non-BSD compatibility\n     * in the JDK port (see DESIGN).\n     */\n    void createSockets() throws Exception {\n        InetAddress tmp_addr=null;\n\n        // bind_addr not set, try to assign one by default. This is needed on Windows\n\n        // changed by bela Feb 12 2003: by default multicast sockets will be bound to all network interfaces\n\n        // CHANGED *BACK* by bela March 13 2003: binding to all interfaces did not result in a correct\n        // local_addr. As a matter of fact, comparison between e.g. 0.0.0.0:1234 (on hostA) and\n        // 0.0.0.0:1.2.3.4 (on hostB) would fail !\n        if(bind_addr == null) {\n            InetAddress[] interfaces=InetAddress.getAllByName(InetAddress.getLocalHost().getHostAddress());\n            if(interfaces != null && interfaces.length > 0)\n                bind_addr=interfaces[0];\n        }\n        if(bind_addr == null)\n            bind_addr=InetAddress.getLocalHost();\n\n        if(bind_addr != null)\n            if(log.isInfoEnabled()) log.info(\"sockets will use interface \" + bind_addr.getHostAddress());\n\n\n        // 2. Create socket for receiving unicast UDP packets. The address and port\n        //    of this socket will be our local address (local_addr)\n        if(bind_port > 0) {\n            sock=createDatagramSocketWithBindPort();\n        }\n        else {\n            sock=createEphemeralDatagramSocket();\n        }\n\n        if(sock == null)\n            throw new Exception(\"UDP.createSocket(): sock is null\");\n\n        local_addr=new IpAddress(sock.getLocalAddress(), sock.getLocalPort());\n        if(additional_data != null)\n            local_addr.setAdditionalData(additional_data);\n\n\n        // 3. Create socket for receiving IP multicast packets\n        if(ip_mcast) {\n            // 3a. Create mcast receiver socket\n            mcast_recv_sock=new MulticastSocket(mcast_port);\n            mcast_recv_sock.setTimeToLive(ip_ttl);\n            tmp_addr=InetAddress.getByName(mcast_addr_name);\n            mcast_addr=new IpAddress(tmp_addr, mcast_port);\n\n            if(bind_to_all_interfaces && Util.getJavaVersion() >= 14) {\n                bindToAllInterfaces(mcast_recv_sock, mcast_addr.getIpAddress());\n            }\n            else {\n                if(bind_addr != null)\n                    mcast_recv_sock.setInterface(bind_addr);\n                 mcast_recv_sock.joinGroup(tmp_addr);\n            }\n\n            // 3b. Create mcast sender socket\n            mcast_send_sock=new MulticastSocket();\n            mcast_send_sock.setTimeToLive(ip_ttl);\n            if(bind_addr != null)\n                mcast_send_sock.setInterface(bind_addr);\n            // mcast_send_sock.setTrafficClass(0x08); // high throughput; should investigate when baseline is JDK 1.4\n        }\n\n        setBufferSizes();\n        if(log.isInfoEnabled()) log.info(\"socket information:\\n\" + dumpSocketInfo());\n    }","commit_id":"25d0ee64f81bd8a31c5f7dc22852a26521927308","url":"https://github.com/belaban/JGroups"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jSplitPane1 = new javax.swing.JSplitPane();\n        leftPanel = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        hashSetTable = new javax.swing.JTable();\n        importButton = new javax.swing.JButton();\n        deleteButton = new javax.swing.JButton();\n        rightPanel = new javax.swing.JPanel();\n        nameLabel = new javax.swing.JLabel();\n        hashDbNameLabel = new javax.swing.JLabel();\n        locationLabel = new javax.swing.JLabel();\n        hashDbLocationLabel = new javax.swing.JLabel();\n        useForIngestCheckbox = new javax.swing.JCheckBox();\n        showInboxMessagesCheckBox = new javax.swing.JCheckBox();\n        indexLabel = new javax.swing.JLabel();\n        indexButton = new javax.swing.JButton();\n        ingestRunningLabel = new javax.swing.JLabel();\n\n        jScrollPane1.setBackground(new java.awt.Color(255, 255, 255));\n\n        hashSetTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        hashSetTable.setShowHorizontalLines(false);\n        hashSetTable.setShowVerticalLines(false);\n        hashSetTable.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyPressed(java.awt.event.KeyEvent evt) {\n                hashSetTableKeyPressed(evt);\n            }\n        });\n        jScrollPane1.setViewportView(hashSetTable);\n\n        importButton.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.importButton.text\")); // NOI18N\n        importButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                importButtonActionPerformed(evt);\n            }\n        });\n\n        deleteButton.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.deleteButton.text\")); // NOI18N\n        deleteButton.setEnabled(false);\n        deleteButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout leftPanelLayout = new javax.swing.GroupLayout(leftPanel);\n        leftPanel.setLayout(leftPanelLayout);\n        leftPanelLayout.setHorizontalGroup(\n            leftPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 176, Short.MAX_VALUE)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, leftPanelLayout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(importButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(deleteButton)\n                .addGap(32, 32, 32))\n        );\n        leftPanelLayout.setVerticalGroup(\n            leftPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, leftPanelLayout.createSequentialGroup()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 313, Short.MAX_VALUE)\n                .addGap(0, 0, 0)\n                .addGroup(leftPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(importButton)\n                    .addComponent(deleteButton))\n                .addGap(0, 0, 0))\n        );\n\n        jSplitPane1.setLeftComponent(leftPanel);\n\n        nameLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.nameLabel.text\")); // NOI18N\n\n        hashDbNameLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbNameLabel.text\")); // NOI18N\n\n        locationLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.locationLabel.text\")); // NOI18N\n\n        hashDbLocationLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbLocationLabel.text\")); // NOI18N\n\n        useForIngestCheckbox.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.useForIngestCheckbox.text\")); // NOI18N\n        useForIngestCheckbox.setEnabled(false);\n        useForIngestCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useForIngestCheckboxActionPerformed(evt);\n            }\n        });\n\n        showInboxMessagesCheckBox.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.showInboxMessagesCheckBox.text\")); // NOI18N\n        showInboxMessagesCheckBox.setEnabled(false);\n        showInboxMessagesCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                showInboxMessagesCheckBoxActionPerformed(evt);\n            }\n        });\n\n        indexLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.indexLabel.text\")); // NOI18N\n\n        indexButton.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.indexButton.text\")); // NOI18N\n        indexButton.setEnabled(false);\n        indexButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                indexButtonActionPerformed(evt);\n            }\n        });\n\n        ingestRunningLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.ingestRunningLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout rightPanelLayout = new javax.swing.GroupLayout(rightPanel);\n        rightPanel.setLayout(rightPanelLayout);\n        rightPanelLayout.setHorizontalGroup(\n            rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(rightPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(showInboxMessagesCheckBox)\n                    .addComponent(useForIngestCheckbox)\n                    .addGroup(rightPanelLayout.createSequentialGroup()\n                        .addComponent(nameLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(hashDbNameLabel))\n                    .addGroup(rightPanelLayout.createSequentialGroup()\n                        .addComponent(locationLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(hashDbLocationLabel))\n                    .addGroup(rightPanelLayout.createSequentialGroup()\n                        .addComponent(indexLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(indexButton))\n                    .addComponent(ingestRunningLabel))\n                .addContainerGap(117, Short.MAX_VALUE))\n        );\n        rightPanelLayout.setVerticalGroup(\n            rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(rightPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(nameLabel)\n                    .addComponent(hashDbNameLabel))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(locationLabel)\n                    .addComponent(hashDbLocationLabel))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(indexLabel)\n                    .addComponent(indexButton))\n                .addGap(7, 7, 7)\n                .addComponent(useForIngestCheckbox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(showInboxMessagesCheckBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 195, Short.MAX_VALUE)\n                .addComponent(ingestRunningLabel)\n                .addContainerGap())\n        );\n\n        jSplitPane1.setRightComponent(rightPanel);\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 494, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 338, Short.MAX_VALUE)\n        );\n    }","id":72407,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jSplitPane1 = new javax.swing.JSplitPane();\n        leftPanel = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        hashSetTable = new javax.swing.JTable();\n        importButton = new javax.swing.JButton();\n        deleteButton = new javax.swing.JButton();\n        rightPanel = new javax.swing.JPanel();\n        nameLabel = new javax.swing.JLabel();\n        hashDbNameLabel = new javax.swing.JLabel();\n        locationLabel = new javax.swing.JLabel();\n        hashDbLocationLabel = new javax.swing.JLabel();\n        useForIngestCheckbox = new javax.swing.JCheckBox();\n        showInboxMessagesCheckBox = new javax.swing.JCheckBox();\n        indexLabel = new javax.swing.JLabel();\n        indexButton = new javax.swing.JButton();\n        ingestRunningLabel = new javax.swing.JLabel();\n\n        jScrollPane1.setBackground(new java.awt.Color(255, 255, 255));\n\n        hashSetTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        hashSetTable.setShowHorizontalLines(false);\n        hashSetTable.setShowVerticalLines(false);\n        hashSetTable.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyPressed(java.awt.event.KeyEvent evt) {\n                hashSetTableKeyPressed(evt);\n            }\n        });\n        jScrollPane1.setViewportView(hashSetTable);\n\n        importButton.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.importButton.text\")); // NOI18N\n        importButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                importButtonActionPerformed(evt);\n            }\n        });\n\n        deleteButton.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.deleteButton.text\")); // NOI18N\n        deleteButton.setEnabled(false);\n        deleteButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout leftPanelLayout = new javax.swing.GroupLayout(leftPanel);\n        leftPanel.setLayout(leftPanelLayout);\n        leftPanelLayout.setHorizontalGroup(\n            leftPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 176, Short.MAX_VALUE)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, leftPanelLayout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(importButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(deleteButton)\n                .addGap(32, 32, 32))\n        );\n        leftPanelLayout.setVerticalGroup(\n            leftPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, leftPanelLayout.createSequentialGroup()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 313, Short.MAX_VALUE)\n                .addGap(0, 0, 0)\n                .addGroup(leftPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(importButton)\n                    .addComponent(deleteButton))\n                .addGap(0, 0, 0))\n        );\n\n        jSplitPane1.setLeftComponent(leftPanel);\n\n        nameLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.nameLabel.text\")); // NOI18N\n\n        hashDbNameLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbNameLabel.text\")); // NOI18N\n\n        locationLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.locationLabel.text\")); // NOI18N\n\n        hashDbLocationLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.hashDbLocationLabel.text\")); // NOI18N\n\n        useForIngestCheckbox.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.useForIngestCheckbox.text\")); // NOI18N\n        useForIngestCheckbox.setEnabled(false);\n        useForIngestCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useForIngestCheckboxActionPerformed(evt);\n            }\n        });\n\n        showInboxMessagesCheckBox.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.showInboxMessagesCheckBox.text\")); // NOI18N\n        showInboxMessagesCheckBox.setEnabled(false);\n        showInboxMessagesCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                showInboxMessagesCheckBoxActionPerformed(evt);\n            }\n        });\n\n        indexLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.indexLabel.text\")); // NOI18N\n\n        indexButton.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.indexButton.text\")); // NOI18N\n        indexButton.setEnabled(false);\n        indexButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                indexButtonActionPerformed(evt);\n            }\n        });\n\n        ingestRunningLabel.setText(org.openide.util.NbBundle.getMessage(HashDbManagementPanel.class, \"HashDbManagementPanel.ingestRunningLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout rightPanelLayout = new javax.swing.GroupLayout(rightPanel);\n        rightPanel.setLayout(rightPanelLayout);\n        rightPanelLayout.setHorizontalGroup(\n            rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(rightPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(showInboxMessagesCheckBox)\n                    .addComponent(useForIngestCheckbox)\n                    .addGroup(rightPanelLayout.createSequentialGroup()\n                        .addComponent(nameLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(hashDbNameLabel))\n                    .addGroup(rightPanelLayout.createSequentialGroup()\n                        .addComponent(locationLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(hashDbLocationLabel))\n                    .addGroup(rightPanelLayout.createSequentialGroup()\n                        .addComponent(indexLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(indexButton))\n                    .addComponent(ingestRunningLabel))\n                .addContainerGap(117, Short.MAX_VALUE))\n        );\n        rightPanelLayout.setVerticalGroup(\n            rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(rightPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(nameLabel)\n                    .addComponent(hashDbNameLabel))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(locationLabel)\n                    .addComponent(hashDbLocationLabel))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(rightPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(indexLabel)\n                    .addComponent(indexButton))\n                .addGap(7, 7, 7)\n                .addComponent(useForIngestCheckbox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(showInboxMessagesCheckBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 175, Short.MAX_VALUE)\n                .addComponent(ingestRunningLabel)\n                .addContainerGap())\n        );\n\n        jSplitPane1.setRightComponent(rightPanel);\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 494, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 338, Short.MAX_VALUE)\n        );\n    }","commit_id":"ede0326ab73989934c027b7e2db76d8f67d9eab8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void importButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_importButtonActionPerformed\n        boolean nsrl = false;\n        int retval = fc.showOpenDialog(this);\n        if (retval == JFileChooser.APPROVE_OPTION) {\n            File f = fc.getSelectedFile();\n            try {\n                String filePath = f.getCanonicalPath();\n                if (HashDb.isIndexPath(filePath)) {\n                    filePath = HashDb.toDatabasePath(filePath);\n                }\n                String derivedName = SleuthkitJNI.getDatabaseName(filePath);\n                JCheckBox nsrlCheckBox = new JCheckBox(\"Set as NSRL\", false);\n                JTextField nameTextField = new JTextField(derivedName);\n                JOptionPane.showMessageDialog(this, new Object[]{\"New Hash Set name:\", nameTextField, nsrlCheckBox}, \"New Hash Set\", JOptionPane.PLAIN_MESSAGE);\n                String setName = nameTextField.getText();\n                if (setName != null && !setName.equals(\"\")) {\n                    HashDb newDb = new HashDb(setName, Arrays.asList(new String[]{filePath}), false, false);\n                    int toIndex = JOptionPane.NO_OPTION;\n                    if (IndexStatus.isIngestible(newDb.status())) {\n                        newDb.setUseForIngest(true);\n                    } else {\n                        toIndex = JOptionPane.showConfirmDialog(this, \"The database you added has no index.\\n\" + \"It will not be used for ingest until you create one.\\n\" + \"Would you like to do so now?\", \"No Index Exists\", JOptionPane.YES_NO_OPTION);\n                    }\n                    if (toIndex == JOptionPane.YES_OPTION) {\n                        try {\n                            newDb.createIndex();\n                        } catch (TskException ex) {\n                            logger.log(Level.WARNING, \"Error creating index\", ex);\n                        }\n                    }\n                    if(nsrlCheckBox.isSelected()) {\n                        nsrl = true;\n                        HashDbXML.getCurrent().setNSRLSet(newDb);\n                    } else {\n                        HashDbXML.getCurrent().addKnownBadSet(newDb);\n                    }\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Couldn't get selected file path.\", ex);\n            } catch (TskException ex) {\n                logger.log(Level.WARNING, \"Invalid database: \", ex);\n                int tryAgain = JOptionPane.showConfirmDialog(this, \"Database file you chose cannot be opened.\\n\" + \"If it was just an index, please try to recreate it from the database.\\n\" + \"Would you like to choose another database?\", \"Invalid File\", JOptionPane.YES_NO_OPTION);\n                if (tryAgain == JOptionPane.YES_OPTION) {\n                    importButtonActionPerformed(null);\n                }\n            }\n        }\n        hashSetTableModel.resync();\n        int size = 0;\n        if(nsrl) {\n            size = HashDbXML.getCurrent().getAllSets().size();\n        } else {\n            size = HashDbXML.getCurrent().getKnownBadSets().size();\n        }\n        setSelection(size-1);\n    }","id":72408,"modified_method":"private void importButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_importButtonActionPerformed\n        boolean nsrl = false;\n        int retval = fc.showOpenDialog(this);\n        if (retval == JFileChooser.APPROVE_OPTION) {\n            File f = fc.getSelectedFile();\n            try {\n                String filePath = f.getCanonicalPath();\n                if (HashDb.isIndexPath(filePath)) {\n                    filePath = HashDb.toDatabasePath(filePath);\n                }\n                String derivedName = SleuthkitJNI.getDatabaseName(filePath);\n                JCheckBox nsrlCheckBox = new JCheckBox(\"Set as NSRL\", false);\n                JTextField nameTextField = new JTextField(derivedName);\n                JOptionPane.showMessageDialog(this, new Object[]{\"New Hash Set name:\", nameTextField, nsrlCheckBox}, \"New Hash Set\", JOptionPane.PLAIN_MESSAGE);\n                String setName = nameTextField.getText();\n                if (setName != null && !setName.equals(\"\")) {\n                    HashDb newDb = new HashDb(setName, Arrays.asList(new String[]{filePath}), true, !nsrlCheckBox.isSelected());\n                    int toIndex = JOptionPane.NO_OPTION;\n                    if (IndexStatus.isIngestible(newDb.status())) {\n                        newDb.setUseForIngest(true);\n                    } else {\n                        toIndex = JOptionPane.showConfirmDialog(this, \"The database you added has no index.\\n\" + \"It will not be used for ingest until you create one.\\n\" + \"Would you like to do so now?\", \"No Index Exists\", JOptionPane.YES_NO_OPTION);\n                    }\n                    if (toIndex == JOptionPane.YES_OPTION) {\n                        try {\n                            newDb.createIndex();\n                        } catch (TskException ex) {\n                            logger.log(Level.WARNING, \"Error creating index\", ex);\n                        }\n                    }\n                    if(nsrlCheckBox.isSelected()) {\n                        nsrl = true;\n                        HashDbXML.getCurrent().setNSRLSet(newDb);\n                    } else {\n                        HashDbXML.getCurrent().addKnownBadSet(newDb);\n                    }\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Couldn't get selected file path.\", ex);\n            } catch (TskException ex) {\n                logger.log(Level.WARNING, \"Invalid database: \", ex);\n                int tryAgain = JOptionPane.showConfirmDialog(this, \"Database file you chose cannot be opened.\\n\" + \"If it was just an index, please try to recreate it from the database.\\n\" + \"Would you like to choose another database?\", \"Invalid File\", JOptionPane.YES_NO_OPTION);\n                if (tryAgain == JOptionPane.YES_OPTION) {\n                    importButtonActionPerformed(null);\n                }\n            }\n        }\n        hashSetTableModel.resync();\n        int size = 0;\n        if(nsrl) {\n            size = HashDbXML.getCurrent().getAllSets().size();\n        } else {\n            size = HashDbXML.getCurrent().getKnownBadSets().size();\n        }\n        setSelection(size-1);\n    }","commit_id":"ede0326ab73989934c027b7e2db76d8f67d9eab8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        rightClickMenu = new javax.swing.JPopupMenu();\n        cutMenuItem = new javax.swing.JMenuItem();\n        copyMenuItem = new javax.swing.JMenuItem();\n        pasteMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        listEditorPanel = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        keywordTable = new javax.swing.JTable();\n        deleteWordButton = new javax.swing.JButton();\n        useForIngestCheckbox = new javax.swing.JCheckBox();\n        addKeywordPanel = new javax.swing.JPanel();\n        addWordButton = new javax.swing.JButton();\n        addWordField = new javax.swing.JTextField();\n        chRegex = new javax.swing.JCheckBox();\n        selectorsCombo = new javax.swing.JComboBox();\n        ingestMessagesCheckbox = new javax.swing.JCheckBox();\n        saveListButton = new javax.swing.JButton();\n        exportButton = new javax.swing.JButton();\n        deleteListButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n\n        cutMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.cutMenuItem.text\")); // NOI18N\n        rightClickMenu.add(cutMenuItem);\n\n        copyMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        pasteMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.pasteMenuItem.text\")); // NOI18N\n        rightClickMenu.add(pasteMenuItem);\n\n        selectAllMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        setMinimumSize(new java.awt.Dimension(340, 300));\n        setPreferredSize(new java.awt.Dimension(340, 420));\n\n        jScrollPane1.setPreferredSize(new java.awt.Dimension(340, 300));\n\n        keywordTable.setModel(tableModel);\n        keywordTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);\n        keywordTable.setShowHorizontalLines(false);\n        keywordTable.setShowVerticalLines(false);\n        keywordTable.getTableHeader().setReorderingAllowed(false);\n        jScrollPane1.setViewportView(keywordTable);\n\n        deleteWordButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.deleteWordButton.text\")); // NOI18N\n        deleteWordButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteWordButtonActionPerformed(evt);\n            }\n        });\n\n        useForIngestCheckbox.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.useForIngestCheckbox.text\")); // NOI18N\n        useForIngestCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useForIngestCheckboxActionPerformed(evt);\n            }\n        });\n\n        addWordButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.addWordButton.text\")); // NOI18N\n        addWordButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addWordButtonActionPerformed(evt);\n            }\n        });\n\n        addWordField.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.addWordField.text\")); // NOI18N\n        addWordField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addWordFieldActionPerformed(evt);\n            }\n        });\n\n        chRegex.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.chRegex.text\")); // NOI18N\n        chRegex.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                chRegexActionPerformed(evt);\n            }\n        });\n\n        selectorsCombo.setToolTipText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.selectorsCombo.toolTipText\")); // NOI18N\n\n        javax.swing.GroupLayout addKeywordPanelLayout = new javax.swing.GroupLayout(addKeywordPanel);\n        addKeywordPanel.setLayout(addKeywordPanelLayout);\n        addKeywordPanelLayout.setHorizontalGroup(\n            addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                        .addComponent(addWordField, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(addWordButton))\n                    .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                        .addGap(10, 10, 10)\n                        .addComponent(chRegex)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(selectorsCombo, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addContainerGap(18, Short.MAX_VALUE))\n        );\n        addKeywordPanelLayout.setVerticalGroup(\n            addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                .addGap(0, 0, 0)\n                .addGroup(addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(addWordButton)\n                    .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                        .addComponent(addWordField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(selectorsCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(chRegex))))\n                .addContainerGap())\n        );\n\n        ingestMessagesCheckbox.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.ingestMessagesCheckbox.text\")); // NOI18N\n        ingestMessagesCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.ingestMessagesCheckbox.toolTipText\")); // NOI18N\n        ingestMessagesCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                ingestMessagesCheckboxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout listEditorPanelLayout = new javax.swing.GroupLayout(listEditorPanel);\n        listEditorPanel.setLayout(listEditorPanelLayout);\n        listEditorPanelLayout.setHorizontalGroup(\n            listEditorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, listEditorPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(useForIngestCheckbox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 62, Short.MAX_VALUE)\n                .addComponent(deleteWordButton)\n                .addContainerGap())\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, listEditorPanelLayout.createSequentialGroup()\n                .addContainerGap(34, Short.MAX_VALUE)\n                .addComponent(addKeywordPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(19, 19, 19))\n            .addGroup(listEditorPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(ingestMessagesCheckbox)\n                .addContainerGap(131, Short.MAX_VALUE))\n        );\n        listEditorPanelLayout.setVerticalGroup(\n            listEditorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, listEditorPanelLayout.createSequentialGroup()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 242, Short.MAX_VALUE)\n                .addGap(5, 5, 5)\n                .addComponent(addKeywordPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(listEditorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(deleteWordButton)\n                    .addComponent(useForIngestCheckbox))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(ingestMessagesCheckbox)\n                .addContainerGap())\n        );\n\n        saveListButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.saveListButton.text\")); // NOI18N\n        saveListButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveListButtonActionPerformed(evt);\n            }\n        });\n\n        exportButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.exportButton.text\")); // NOI18N\n        exportButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exportButtonActionPerformed(evt);\n            }\n        });\n\n        deleteListButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.deleteListButton.text\")); // NOI18N\n        deleteListButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteListButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 340, Short.MAX_VALUE)\n            .addComponent(listEditorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap(81, Short.MAX_VALUE)\n                .addComponent(exportButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(deleteListButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(saveListButton)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addComponent(listEditorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(0, 0, 0)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(exportButton)\n                    .addComponent(deleteListButton)\n                    .addComponent(saveListButton))\n                .addContainerGap())\n        );\n    }","id":72409,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        rightClickMenu = new javax.swing.JPopupMenu();\n        cutMenuItem = new javax.swing.JMenuItem();\n        copyMenuItem = new javax.swing.JMenuItem();\n        pasteMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        listEditorPanel = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        keywordTable = new javax.swing.JTable();\n        deleteWordButton = new javax.swing.JButton();\n        useForIngestCheckbox = new javax.swing.JCheckBox();\n        addKeywordPanel = new javax.swing.JPanel();\n        addWordButton = new javax.swing.JButton();\n        addWordField = new javax.swing.JTextField();\n        chRegex = new javax.swing.JCheckBox();\n        selectorsCombo = new javax.swing.JComboBox();\n        ingestMessagesCheckbox = new javax.swing.JCheckBox();\n        saveListButton = new javax.swing.JButton();\n        exportButton = new javax.swing.JButton();\n        deleteListButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n\n        cutMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.cutMenuItem.text\")); // NOI18N\n        rightClickMenu.add(cutMenuItem);\n\n        copyMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        pasteMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.pasteMenuItem.text\")); // NOI18N\n        rightClickMenu.add(pasteMenuItem);\n\n        selectAllMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        setMinimumSize(new java.awt.Dimension(340, 300));\n        setPreferredSize(new java.awt.Dimension(340, 420));\n\n        jScrollPane1.setPreferredSize(new java.awt.Dimension(340, 300));\n\n        keywordTable.setModel(tableModel);\n        keywordTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);\n        keywordTable.setShowHorizontalLines(false);\n        keywordTable.setShowVerticalLines(false);\n        keywordTable.getTableHeader().setReorderingAllowed(false);\n        jScrollPane1.setViewportView(keywordTable);\n\n        deleteWordButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.deleteWordButton.text\")); // NOI18N\n        deleteWordButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteWordButtonActionPerformed(evt);\n            }\n        });\n\n        useForIngestCheckbox.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.useForIngestCheckbox.text\")); // NOI18N\n        useForIngestCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useForIngestCheckboxActionPerformed(evt);\n            }\n        });\n\n        addWordButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.addWordButton.text\")); // NOI18N\n        addWordButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addWordButtonActionPerformed(evt);\n            }\n        });\n\n        addWordField.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.addWordField.text\")); // NOI18N\n        addWordField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addWordFieldActionPerformed(evt);\n            }\n        });\n\n        chRegex.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.chRegex.text\")); // NOI18N\n        chRegex.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                chRegexActionPerformed(evt);\n            }\n        });\n\n        selectorsCombo.setToolTipText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.selectorsCombo.toolTipText\")); // NOI18N\n\n        javax.swing.GroupLayout addKeywordPanelLayout = new javax.swing.GroupLayout(addKeywordPanel);\n        addKeywordPanel.setLayout(addKeywordPanelLayout);\n        addKeywordPanelLayout.setHorizontalGroup(\n            addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                        .addComponent(addWordField, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(addWordButton))\n                    .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                        .addGap(10, 10, 10)\n                        .addComponent(chRegex)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(selectorsCombo, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addContainerGap(18, Short.MAX_VALUE))\n        );\n        addKeywordPanelLayout.setVerticalGroup(\n            addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                .addGap(0, 0, 0)\n                .addGroup(addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(addWordButton)\n                    .addGroup(addKeywordPanelLayout.createSequentialGroup()\n                        .addComponent(addWordField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(addKeywordPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(selectorsCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(chRegex))))\n                .addContainerGap())\n        );\n\n        ingestMessagesCheckbox.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.ingestMessagesCheckbox.text\")); // NOI18N\n        ingestMessagesCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.ingestMessagesCheckbox.toolTipText\")); // NOI18N\n        ingestMessagesCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                ingestMessagesCheckboxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout listEditorPanelLayout = new javax.swing.GroupLayout(listEditorPanel);\n        listEditorPanel.setLayout(listEditorPanelLayout);\n        listEditorPanelLayout.setHorizontalGroup(\n            listEditorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, listEditorPanelLayout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(addKeywordPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(19, 19, 19))\n            .addGroup(listEditorPanelLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(listEditorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, listEditorPanelLayout.createSequentialGroup()\n                        .addComponent(useForIngestCheckbox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addComponent(deleteWordButton)\n                        .addContainerGap())\n                    .addGroup(listEditorPanelLayout.createSequentialGroup()\n                        .addComponent(ingestMessagesCheckbox)\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))\n        );\n        listEditorPanelLayout.setVerticalGroup(\n            listEditorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, listEditorPanelLayout.createSequentialGroup()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 242, Short.MAX_VALUE)\n                .addGap(5, 5, 5)\n                .addComponent(addKeywordPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(listEditorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(deleteWordButton)\n                    .addComponent(useForIngestCheckbox))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(ingestMessagesCheckbox)\n                .addContainerGap())\n        );\n\n        saveListButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.saveListButton.text\")); // NOI18N\n        saveListButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveListButtonActionPerformed(evt);\n            }\n        });\n\n        exportButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.exportButton.text\")); // NOI18N\n        exportButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exportButtonActionPerformed(evt);\n            }\n        });\n\n        deleteListButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchEditListPanel.class, \"KeywordSearchEditListPanel.deleteListButton.text\")); // NOI18N\n        deleteListButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteListButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSeparator1)\n            .addComponent(listEditorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(exportButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(deleteListButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(saveListButton)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addComponent(listEditorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(0, 0, 0)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(exportButton)\n                    .addComponent(deleteListButton)\n                    .addComponent(saveListButton))\n                .addContainerGap())\n        );\n    }","commit_id":"ede0326ab73989934c027b7e2db76d8f67d9eab8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Sets the list model for the file types list component.\n     */\n    private void updateFileTypesListModel() {\n        ArrayList<String> mimeTypes = new ArrayList<>(fileTypes.keySet());\n        Collections.sort(mimeTypes);\n        typesListModel.clear();\n        for (String mimeType : mimeTypes) {\n            typesListModel.addElement(mimeType);\n        }\n    }","id":72410,"modified_method":"/**\n     * Sets the list model for the file types list component.\n     */\n    private void updateFileTypesListModel() {\n        ArrayList<String> mimeTypes = new ArrayList<>(fileTypes.keySet());\n        Collections.sort(mimeTypes);\n        typesListModel.clear();\n        for (String mimeType : mimeTypes) {\n            int i = 0;\n            for (FileType fileType : fileTypes.get(mimeType)) {\n                typesListModel.addElement(fileType);\n                i++;\n            }\n\n        }\n    }","commit_id":"88942afc85038b0c333ffe407c078fa031a901f8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        typesScrollPane = new javax.swing.JScrollPane();\n        typesList = new javax.swing.JList<String>();\n        separator = new javax.swing.JSeparator();\n        mimeTypeLabel = new javax.swing.JLabel();\n        mimeTypeTextField = new javax.swing.JTextField();\n        signatureTypeLabel = new javax.swing.JLabel();\n        signatureTextField = new javax.swing.JTextField();\n        offsetLabel = new javax.swing.JLabel();\n        offsetTextField = new javax.swing.JTextField();\n        newTypeButton = new javax.swing.JButton();\n        deleteTypeButton = new javax.swing.JButton();\n        saveTypeButton = new javax.swing.JButton();\n        hexPrefixLabel = new javax.swing.JLabel();\n        signatureTypeComboBox = new javax.swing.JComboBox<String>();\n        signatureLabel = new javax.swing.JLabel();\n        postHitCheckBox = new javax.swing.JCheckBox();\n        filesSetNameLabel = new javax.swing.JLabel();\n        filesSetNameTextField = new javax.swing.JTextField();\n        ingestRunningWarningLabel = new javax.swing.JLabel();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n\n        setMaximumSize(new java.awt.Dimension(500, 300));\n        setPreferredSize(new java.awt.Dimension(500, 300));\n\n        typesList.setMaximumSize(new java.awt.Dimension(150, 0));\n        typesList.setMinimumSize(new java.awt.Dimension(150, 0));\n        typesScrollPane.setViewportView(typesList);\n\n        separator.setOrientation(javax.swing.SwingConstants.VERTICAL);\n\n        org.openide.awt.Mnemonics.setLocalizedText(mimeTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeLabel.text\")); // NOI18N\n\n        mimeTypeTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTypeLabel.text\")); // NOI18N\n\n        signatureTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTextField.text\")); // NOI18N\n        signatureTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTextFieldActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(offsetLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetLabel.text\")); // NOI18N\n\n        offsetTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(newTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.newTypeButton.text\")); // NOI18N\n        newTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(deleteTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.deleteTypeButton.text\")); // NOI18N\n        deleteTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(saveTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.saveTypeButton.text\")); // NOI18N\n        saveTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(hexPrefixLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.hexPrefixLabel.text\")); // NOI18N\n\n        signatureTypeComboBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTypeComboBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(postHitCheckBox, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.postHitCheckBox.text\")); // NOI18N\n        postHitCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                postHitCheckBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(filesSetNameLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameLabel.text\")); // NOI18N\n\n        filesSetNameTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameTextField.text\")); // NOI18N\n\n        ingestRunningWarningLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/modules/filetypeid/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(ingestRunningWarningLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.ingestRunningWarningLabel.text\")); // NOI18N\n\n        jLabel1.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel1.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel3.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(ingestRunningWarningLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGap(30, 30, 30))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jLabel2)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(10, 10, 10)\n                                .addComponent(deleteTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(newTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(typesScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(separator, javax.swing.GroupLayout.PREFERRED_SIZE, 7, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                .addGroup(layout.createSequentialGroup()\n                                    .addComponent(mimeTypeLabel)\n                                    .addGap(30, 30, 30)\n                                    .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addComponent(postHitCheckBox)\n                                .addGroup(layout.createSequentialGroup()\n                                    .addComponent(signatureTypeLabel)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                    .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addGroup(layout.createSequentialGroup()\n                                    .addComponent(signatureLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                    .addComponent(hexPrefixLabel)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                    .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addGroup(layout.createSequentialGroup()\n                                    .addComponent(offsetLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                    .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                    .addGap(21, 21, 21)\n                                    .addComponent(filesSetNameLabel)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                    .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                .addComponent(saveTypeButton)\n                                .addGap(8, 8, 8)))\n                        .addContainerGap())\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jLabel1)\n                            .addComponent(jLabel3))\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(jLabel2)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(typesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 177, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(deleteTypeButton)\n                                    .addComponent(newTypeButton)))\n                            .addComponent(separator))\n                        .addGap(18, 18, 18)\n                        .addComponent(ingestRunningWarningLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(24, 24, 24)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(mimeTypeLabel)\n                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(signatureTypeLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                .addComponent(hexPrefixLabel)\n                                .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(signatureLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(offsetLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(postHitCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(filesSetNameLabel)\n                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(saveTypeButton)\n                        .addGap(0, 0, Short.MAX_VALUE))))\n        );\n\n        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {deleteTypeButton, newTypeButton, saveTypeButton});\n\n    }","id":72411,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        typesScrollPane = new javax.swing.JScrollPane();\n        typesList = new javax.swing.JList<FileType>();\n        separator = new javax.swing.JSeparator();\n        mimeTypeLabel = new javax.swing.JLabel();\n        mimeTypeTextField = new javax.swing.JTextField();\n        signatureTypeLabel = new javax.swing.JLabel();\n        signatureTextField = new javax.swing.JTextField();\n        offsetLabel = new javax.swing.JLabel();\n        offsetTextField = new javax.swing.JTextField();\n        newTypeButton = new javax.swing.JButton();\n        deleteTypeButton = new javax.swing.JButton();\n        saveTypeButton = new javax.swing.JButton();\n        hexPrefixLabel = new javax.swing.JLabel();\n        signatureTypeComboBox = new javax.swing.JComboBox<String>();\n        signatureLabel = new javax.swing.JLabel();\n        postHitCheckBox = new javax.swing.JCheckBox();\n        filesSetNameLabel = new javax.swing.JLabel();\n        filesSetNameTextField = new javax.swing.JTextField();\n        ingestRunningWarningLabel = new javax.swing.JLabel();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n\n        setMaximumSize(new java.awt.Dimension(500, 300));\n        setPreferredSize(new java.awt.Dimension(500, 300));\n\n        typesList.setMaximumSize(new java.awt.Dimension(150, 0));\n        typesList.setMinimumSize(new java.awt.Dimension(150, 0));\n        typesScrollPane.setViewportView(typesList);\n\n        separator.setOrientation(javax.swing.SwingConstants.VERTICAL);\n\n        org.openide.awt.Mnemonics.setLocalizedText(mimeTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeLabel.text\")); // NOI18N\n\n        mimeTypeTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTypeLabel.text\")); // NOI18N\n\n        signatureTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTextField.text\")); // NOI18N\n        signatureTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTextFieldActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(offsetLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetLabel.text\")); // NOI18N\n\n        offsetTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(newTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.newTypeButton.text\")); // NOI18N\n        newTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(deleteTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.deleteTypeButton.text\")); // NOI18N\n        deleteTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(saveTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.saveTypeButton.text\")); // NOI18N\n        saveTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(hexPrefixLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.hexPrefixLabel.text\")); // NOI18N\n\n        signatureTypeComboBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTypeComboBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(postHitCheckBox, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.postHitCheckBox.text\")); // NOI18N\n        postHitCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                postHitCheckBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(filesSetNameLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameLabel.text\")); // NOI18N\n\n        filesSetNameTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameTextField.text\")); // NOI18N\n\n        ingestRunningWarningLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/modules/filetypeid/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(ingestRunningWarningLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.ingestRunningWarningLabel.text\")); // NOI18N\n\n        jLabel1.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel1.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel3.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(ingestRunningWarningLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGap(30, 30, 30))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel2)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGap(10, 10, 10)\n                                        .addComponent(deleteTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addGap(18, 18, 18)\n                                        .addComponent(newTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                    .addComponent(typesScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(separator, javax.swing.GroupLayout.PREFERRED_SIZE, 7, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(mimeTypeLabel)\n                                            .addGap(30, 30, 30)\n                                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addComponent(postHitCheckBox)\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(signatureTypeLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(signatureLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(hexPrefixLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                            .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(offsetLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                            .addGap(21, 21, 21)\n                                            .addComponent(filesSetNameLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                        .addComponent(saveTypeButton)\n                                        .addGap(8, 8, 8))))\n                            .addComponent(jLabel1)\n                            .addComponent(jLabel3))\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(jLabel2)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(typesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 177, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(deleteTypeButton)\n                                    .addComponent(newTypeButton)))\n                            .addComponent(separator))\n                        .addGap(18, 18, 18)\n                        .addComponent(ingestRunningWarningLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(24, 24, 24)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(mimeTypeLabel)\n                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(signatureTypeLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                .addComponent(hexPrefixLabel)\n                                .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(signatureLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(offsetLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(postHitCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(filesSetNameLabel)\n                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(saveTypeButton)\n                        .addGap(0, 0, Short.MAX_VALUE))))\n        );\n\n        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {deleteTypeButton, newTypeButton, saveTypeButton});\n\n    }","commit_id":"88942afc85038b0c333ffe407c078fa031a901f8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void deleteTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteTypeButtonActionPerformed\n        String typeName = typesList.getSelectedValue();\n        fileTypes.remove(typeName);\n        updateFileTypesListModel();\n        if (!typesListModel.isEmpty()) {\n            typesList.setSelectedIndex(0);\n        }\n    }","id":72412,"modified_method":"private void deleteTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteTypeButtonActionPerformed\n        FileType Filetype = typesList.getSelectedValue();\n        UserDefinedFileTypesManager.getInstance().removeFileTypeFromMap(fileTypes, Filetype);\n        updateFileTypesListModel();\n        if (!typesListModel.isEmpty()) {\n            typesList.setSelectedIndex(0);\n        }\n    }","commit_id":"88942afc85038b0c333ffe407c078fa031a901f8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Populates all of the components in the file type details portion of the\n     * panel based on the current selection in the file types list.\n     */\n    private void populateTypeDetailsComponents() {\n        String mimeType = typesList.getSelectedValue();\n        for (FileType fileType : fileTypes.get(mimeType)) {\n            if (null != fileType) {\n                mimeTypeTextField.setText(fileType.getMimeType());\n                Signature signature = fileType.getSignature();\n                FileType.Signature.Type sigType = signature.getType();\n                signatureTypeComboBox.setSelectedItem(sigType == FileType.Signature.Type.RAW ? FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM : FileTypeIdGlobalSettingsPanel.ASCII_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n                String signatureBytes;\n                if (Signature.Type.RAW == signature.getType()) {\n                    signatureBytes = DatatypeConverter.printHexBinary(signature.getSignatureBytes());\n                } else {\n                    try {\n                        signatureBytes = new String(signature.getSignatureBytes(), \"UTF-8\");\n                    } catch (UnsupportedEncodingException ex) {\n                        JOptionPane.showMessageDialog(null,\n                                ex.getLocalizedMessage(),\n                                NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.storeFailed.title\"),\n                                JOptionPane.ERROR_MESSAGE);\n                        signatureBytes = \"\";\n                    }\n                }\n                signatureTextField.setText(signatureBytes);\n                offsetTextField.setText(Long.toString(signature.getOffset()));\n                postHitCheckBox.setSelected(fileType.alertOnMatch());\n                filesSetNameTextField.setEnabled(postHitCheckBox.isSelected());\n                filesSetNameTextField.setText(fileType.getFilesSetName());\n            }\n        }\n        enableButtons();\n    }","id":72413,"modified_method":"/**\n     * Populates all of the components in the file type details portion of the\n     * panel based on the current selection in the file types list.\n     */\n    private void populateTypeDetailsComponents() {\n        FileType fileType = typesList.getSelectedValue();\n        if (null != fileType) {\n            mimeTypeTextField.setText(fileType.getMimeType());\n            Signature signature = fileType.getSignature();\n            FileType.Signature.Type sigType = signature.getType();\n            signatureTypeComboBox.setSelectedItem(sigType == FileType.Signature.Type.RAW ? FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM : FileTypeIdGlobalSettingsPanel.ASCII_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n            String signatureBytes;\n            if (Signature.Type.RAW == signature.getType()) {\n                signatureBytes = DatatypeConverter.printHexBinary(signature.getSignatureBytes());\n            } else {\n                try {\n                    signatureBytes = new String(signature.getSignatureBytes(), \"UTF-8\");\n                } catch (UnsupportedEncodingException ex) {\n                    JOptionPane.showMessageDialog(null,\n                            ex.getLocalizedMessage(),\n                            NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.storeFailed.title\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    signatureBytes = \"\";\n                }\n            }\n            signatureTextField.setText(signatureBytes);\n            offsetTextField.setText(Long.toString(signature.getOffset()));\n            postHitCheckBox.setSelected(fileType.alertOnMatch());\n            filesSetNameTextField.setEnabled(postHitCheckBox.isSelected());\n            filesSetNameTextField.setText(fileType.getFilesSetName());\n        }\n        enableButtons();\n    }","commit_id":"88942afc85038b0c333ffe407c078fa031a901f8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Enables or disables the panel buttons based on the state of the panel and\n     * the application.\n     */\n    private void enableButtons() {\n        boolean ingestIsRunning = IngestManager.getInstance().isIngestRunning();\n        newTypeButton.setEnabled(!ingestIsRunning);\n\n        boolean fileTypeIsSelected = typesList.getSelectedIndex() != -1;\n        deleteTypeButton.setEnabled(!ingestIsRunning && fileTypeIsSelected);\n\n        boolean requiredFieldsPopulated\n                = !mimeTypeTextField.getText().isEmpty()\n                && !offsetTextField.getText().isEmpty()\n                && !signatureTextField.getText().isEmpty()\n                && (postHitCheckBox.isSelected() ? !filesSetNameTextField.getText().isEmpty() : true);\n        saveTypeButton.setEnabled(!ingestIsRunning && requiredFieldsPopulated);\n\n        ingestRunningWarningLabel.setVisible(ingestIsRunning);\n    }","id":72414,"modified_method":"/**\n     * Enables or disables the panel buttons based on the state of the panel and\n     * the application.\n     */\n    private void enableButtons() {\n        boolean ingestIsRunning = IngestManager.getInstance().isIngestRunning();\n        newTypeButton.setEnabled(!ingestIsRunning);\n\n        boolean fileTypeIsSelected = typesList.getSelectedIndex() != -1;\n        deleteTypeButton.setEnabled(!ingestIsRunning && fileTypeIsSelected);\n\n        boolean requiredFieldsPopulated\n                = !mimeTypeTextField.getText().isEmpty()\n                && (isFooterCheckBox.isSelected() ? true  : !offsetTextField.getText().isEmpty())\n                && !signatureTextField.getText().isEmpty()\n                && (postHitCheckBox.isSelected() ? !filesSetNameTextField.getText().isEmpty() : true);\n        saveTypeButton.setEnabled(!ingestIsRunning && requiredFieldsPopulated);\n\n        ingestRunningWarningLabel.setVisible(ingestIsRunning);\n    }","commit_id":"98e43b766692f38127b58a9db111cf4f1ac511c7","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Clears all of the components in the individual type details portion of\n     * the panel.\n     */\n    private void clearTypeDetailsComponents() {\n        typesList.clearSelection();\n        mimeTypeTextField.setText(\"\"); //NON-NLS\n        signatureTypeComboBox.setSelectedItem(FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n        hexPrefixLabel.setVisible(true);\n        signatureTextField.setText(\"0000\"); //NON-NLS\n        offsetTextField.setText(\"\"); //NON-NLS\n        postHitCheckBox.setSelected(false);\n        filesSetNameTextField.setText(\"\"); //NON-NLS\n        filesSetNameTextField.setEnabled(false);\n        enableButtons();\n    }","id":72415,"modified_method":"/**\n     * Clears all of the components in the individual type details portion of\n     * the panel.\n     */\n    private void clearTypeDetailsComponents() {\n        typesList.clearSelection();\n        mimeTypeTextField.setText(\"\"); //NON-NLS\n        signatureTypeComboBox.setSelectedItem(FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n        hexPrefixLabel.setVisible(true);\n        signatureTextField.setText(\"0000\"); //NON-NLS\n        isFooterCheckBox.setSelected(false);\n        offsetTextField.setEnabled(true);\n        offsetTextField.setText(\"\"); //NON-NLS\n        postHitCheckBox.setSelected(false);\n        filesSetNameTextField.setText(\"\"); //NON-NLS\n        filesSetNameTextField.setEnabled(false);\n        enableButtons();\n    }","commit_id":"98e43b766692f38127b58a9db111cf4f1ac511c7","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void saveTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveTypeButtonActionPerformed\n        /**\n         * Get the MIME type.\n         */\n        String typeName = mimeTypeTextField.getText();\n        if (typeName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Get the signature type.\n         */\n        FileType.Signature.Type sigType = signatureTypeComboBox.getSelectedItem() == FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM ? FileType.Signature.Type.RAW : FileType.Signature.Type.ASCII;\n\n        /**\n         * Get the signature bytes.\n         */\n        String sigString = signatureTextField.getText();\n        if (sigString.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n        byte[] signatureBytes;\n        if (FileType.Signature.Type.RAW == sigType) {\n            try {\n                signatureBytes = DatatypeConverter.parseHexBinary(sigString);\n            } catch (IllegalArgumentException ex) {\n                JOptionPane.showMessageDialog(null,\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidRawSignatureBytes.message\"),\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignatureBytes.title\"),\n                        JOptionPane.ERROR_MESSAGE);\n                return;\n            }\n        } else {\n            signatureBytes = sigString.getBytes(Charset.forName(\"UTF-8\"));\n        }\n\n        /**\n         * Get the offset.\n         */\n        long offset;\n        try {\n            offset = Long.parseUnsignedLong(offsetTextField.getText());\n        } catch (NumberFormatException ex) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Get the interesting files set details.\n         */\n        String filesSetName = filesSetNameTextField.getText();\n        if (postHitCheckBox.isSelected() && filesSetName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidInterestingFilesSetName.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidInterestingFilesSetName.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Put it all together and reset the file types list component.\n         */\n        FileType.Signature signature = new FileType.Signature(signatureBytes, offset, sigType);\n        FileType fileType = new FileType(typeName, signature, filesSetName, postHitCheckBox.isSelected());\n        fileTypes.put(typeName, fileType);\n        updateFileTypesListModel();\n        typesList.setSelectedValue(fileType.getMimeType(), true);\n    }","id":72416,"modified_method":"private void saveTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveTypeButtonActionPerformed\n        /**\n         * Get the MIME type.\n         */\n        String typeName = mimeTypeTextField.getText();\n        if (typeName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Get the signature type.\n         */\n        FileType.Signature.Type sigType = signatureTypeComboBox.getSelectedItem() == FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM ? FileType.Signature.Type.RAW : FileType.Signature.Type.ASCII;\n\n        /**\n         * Get the signature bytes.\n         */\n        String sigString = signatureTextField.getText();\n        if (sigString.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n        byte[] signatureBytes;\n        if (FileType.Signature.Type.RAW == sigType) {\n            try {\n                signatureBytes = DatatypeConverter.parseHexBinary(sigString);\n            } catch (IllegalArgumentException ex) {\n                JOptionPane.showMessageDialog(null,\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidRawSignatureBytes.message\"),\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignatureBytes.title\"),\n                        JOptionPane.ERROR_MESSAGE);\n                return;\n            }\n        } else {\n            signatureBytes = sigString.getBytes(Charset.forName(\"UTF-8\"));\n        }\n\n        /**\n         * Get the offset.\n         */\n        long offset;\n        try {\n            if(isFooterCheckBox.isSelected()) {\n                offset = -1;\n            }\n            else {\n                offset = Long.parseUnsignedLong(offsetTextField.getText());\n            }\n        } catch (NumberFormatException ex) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Get the interesting files set details.\n         */\n        String filesSetName = filesSetNameTextField.getText();\n        if (postHitCheckBox.isSelected() && filesSetName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidInterestingFilesSetName.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidInterestingFilesSetName.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Put it all together and reset the file types list component.\n         */\n        FileType.Signature signature = new FileType.Signature(signatureBytes, offset, sigType);\n        FileType fileType = new FileType(typeName, signature, filesSetName, postHitCheckBox.isSelected());\n        fileTypes.put(typeName, fileType);\n        updateFileTypesListModel();\n        typesList.setSelectedValue(fileType.getMimeType(), true);\n    }","commit_id":"98e43b766692f38127b58a9db111cf4f1ac511c7","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        typesScrollPane = new javax.swing.JScrollPane();\n        typesList = new javax.swing.JList<String>();\n        separator = new javax.swing.JSeparator();\n        mimeTypeLabel = new javax.swing.JLabel();\n        mimeTypeTextField = new javax.swing.JTextField();\n        signatureTypeLabel = new javax.swing.JLabel();\n        signatureTextField = new javax.swing.JTextField();\n        offsetLabel = new javax.swing.JLabel();\n        offsetTextField = new javax.swing.JTextField();\n        newTypeButton = new javax.swing.JButton();\n        deleteTypeButton = new javax.swing.JButton();\n        saveTypeButton = new javax.swing.JButton();\n        hexPrefixLabel = new javax.swing.JLabel();\n        signatureTypeComboBox = new javax.swing.JComboBox<String>();\n        signatureLabel = new javax.swing.JLabel();\n        postHitCheckBox = new javax.swing.JCheckBox();\n        filesSetNameLabel = new javax.swing.JLabel();\n        filesSetNameTextField = new javax.swing.JTextField();\n        ingestRunningWarningLabel = new javax.swing.JLabel();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n\n        setMaximumSize(new java.awt.Dimension(500, 300));\n        setPreferredSize(new java.awt.Dimension(500, 300));\n\n        typesList.setMaximumSize(new java.awt.Dimension(150, 0));\n        typesList.setMinimumSize(new java.awt.Dimension(150, 0));\n        typesScrollPane.setViewportView(typesList);\n\n        separator.setOrientation(javax.swing.SwingConstants.VERTICAL);\n\n        org.openide.awt.Mnemonics.setLocalizedText(mimeTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeLabel.text\")); // NOI18N\n\n        mimeTypeTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTypeLabel.text\")); // NOI18N\n\n        signatureTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTextField.text\")); // NOI18N\n        signatureTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTextFieldActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(offsetLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetLabel.text\")); // NOI18N\n\n        offsetTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(newTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.newTypeButton.text\")); // NOI18N\n        newTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(deleteTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.deleteTypeButton.text\")); // NOI18N\n        deleteTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(saveTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.saveTypeButton.text\")); // NOI18N\n        saveTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(hexPrefixLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.hexPrefixLabel.text\")); // NOI18N\n\n        signatureTypeComboBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTypeComboBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(postHitCheckBox, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.postHitCheckBox.text\")); // NOI18N\n        postHitCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                postHitCheckBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(filesSetNameLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameLabel.text\")); // NOI18N\n\n        filesSetNameTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameTextField.text\")); // NOI18N\n\n        ingestRunningWarningLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/modules/filetypeid/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(ingestRunningWarningLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.ingestRunningWarningLabel.text\")); // NOI18N\n\n        jLabel1.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel1.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel3.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(ingestRunningWarningLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGap(30, 30, 30))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jLabel2)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(10, 10, 10)\n                                .addComponent(deleteTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(newTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(typesScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(separator, javax.swing.GroupLayout.PREFERRED_SIZE, 7, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                .addGroup(layout.createSequentialGroup()\n                                    .addComponent(mimeTypeLabel)\n                                    .addGap(30, 30, 30)\n                                    .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addComponent(postHitCheckBox)\n                                .addGroup(layout.createSequentialGroup()\n                                    .addComponent(signatureTypeLabel)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                    .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addGroup(layout.createSequentialGroup()\n                                    .addComponent(signatureLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                    .addComponent(hexPrefixLabel)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                    .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addGroup(layout.createSequentialGroup()\n                                    .addComponent(offsetLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                    .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                    .addGap(21, 21, 21)\n                                    .addComponent(filesSetNameLabel)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                    .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                .addComponent(saveTypeButton)\n                                .addGap(8, 8, 8)))\n                        .addContainerGap())\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jLabel1)\n                            .addComponent(jLabel3))\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(jLabel2)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(typesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 177, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(deleteTypeButton)\n                                    .addComponent(newTypeButton)))\n                            .addComponent(separator))\n                        .addGap(18, 18, 18)\n                        .addComponent(ingestRunningWarningLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(24, 24, 24)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(mimeTypeLabel)\n                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(signatureTypeLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                .addComponent(hexPrefixLabel)\n                                .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(signatureLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(offsetLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(postHitCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(filesSetNameLabel)\n                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(saveTypeButton)\n                        .addGap(0, 0, Short.MAX_VALUE))))\n        );\n\n        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {deleteTypeButton, newTypeButton, saveTypeButton});\n\n    }","id":72417,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        typesScrollPane = new javax.swing.JScrollPane();\n        typesList = new javax.swing.JList<String>();\n        separator = new javax.swing.JSeparator();\n        mimeTypeLabel = new javax.swing.JLabel();\n        mimeTypeTextField = new javax.swing.JTextField();\n        signatureTypeLabel = new javax.swing.JLabel();\n        signatureTextField = new javax.swing.JTextField();\n        offsetLabel = new javax.swing.JLabel();\n        offsetTextField = new javax.swing.JTextField();\n        newTypeButton = new javax.swing.JButton();\n        deleteTypeButton = new javax.swing.JButton();\n        saveTypeButton = new javax.swing.JButton();\n        hexPrefixLabel = new javax.swing.JLabel();\n        signatureTypeComboBox = new javax.swing.JComboBox<String>();\n        signatureLabel = new javax.swing.JLabel();\n        postHitCheckBox = new javax.swing.JCheckBox();\n        filesSetNameLabel = new javax.swing.JLabel();\n        filesSetNameTextField = new javax.swing.JTextField();\n        ingestRunningWarningLabel = new javax.swing.JLabel();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n        isFooterCheckBox = new javax.swing.JCheckBox();\n\n        setMaximumSize(new java.awt.Dimension(500, 300));\n        setPreferredSize(new java.awt.Dimension(500, 300));\n\n        typesList.setMaximumSize(new java.awt.Dimension(150, 0));\n        typesList.setMinimumSize(new java.awt.Dimension(150, 0));\n        typesScrollPane.setViewportView(typesList);\n\n        separator.setOrientation(javax.swing.SwingConstants.VERTICAL);\n\n        org.openide.awt.Mnemonics.setLocalizedText(mimeTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeLabel.text\")); // NOI18N\n\n        mimeTypeTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTypeLabel.text\")); // NOI18N\n\n        signatureTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTextField.text\")); // NOI18N\n        signatureTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTextFieldActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(offsetLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetLabel.text\")); // NOI18N\n\n        offsetTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(newTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.newTypeButton.text\")); // NOI18N\n        newTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(deleteTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.deleteTypeButton.text\")); // NOI18N\n        deleteTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(saveTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.saveTypeButton.text\")); // NOI18N\n        saveTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(hexPrefixLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.hexPrefixLabel.text\")); // NOI18N\n\n        signatureTypeComboBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTypeComboBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(postHitCheckBox, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.postHitCheckBox.text\")); // NOI18N\n        postHitCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                postHitCheckBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(filesSetNameLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameLabel.text\")); // NOI18N\n\n        filesSetNameTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameTextField.text\")); // NOI18N\n\n        ingestRunningWarningLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/modules/filetypeid/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(ingestRunningWarningLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.ingestRunningWarningLabel.text\")); // NOI18N\n\n        jLabel1.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel1.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel3.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(isFooterCheckBox, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.isFooterCheckBox.text\")); // NOI18N\n        isFooterCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                isFooterCheckBoxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(ingestRunningWarningLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGap(30, 30, 30))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel2)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGap(10, 10, 10)\n                                        .addComponent(deleteTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addGap(18, 18, 18)\n                                        .addComponent(newTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                    .addComponent(typesScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(separator, javax.swing.GroupLayout.PREFERRED_SIZE, 7, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(mimeTypeLabel)\n                                            .addGap(30, 30, 30)\n                                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addComponent(postHitCheckBox)\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(signatureTypeLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(signatureLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(hexPrefixLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                            .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(offsetLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                            .addGap(21, 21, 21)\n                                            .addComponent(filesSetNameLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                        .addComponent(saveTypeButton)\n                                        .addGap(8, 8, 8))\n                                    .addComponent(isFooterCheckBox)))\n                            .addComponent(jLabel1)\n                            .addComponent(jLabel3))\n                        .addContainerGap(50, Short.MAX_VALUE))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(jLabel2)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(typesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 173, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(deleteTypeButton)\n                                    .addComponent(newTypeButton)))\n                            .addComponent(separator))\n                        .addGap(18, 18, 18)\n                        .addComponent(ingestRunningWarningLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(24, 24, 24)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(mimeTypeLabel)\n                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(signatureTypeLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                .addComponent(hexPrefixLabel)\n                                .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(signatureLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(isFooterCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(offsetLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(postHitCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(filesSetNameLabel)\n                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(saveTypeButton)\n                        .addGap(0, 0, Short.MAX_VALUE))))\n        );\n\n        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {deleteTypeButton, newTypeButton, saveTypeButton});\n\n    }","commit_id":"98e43b766692f38127b58a9db111cf4f1ac511c7","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Populates all of the components in the file type details portion of the\n     * panel based on the current selection in the file types list.\n     */\n    private void populateTypeDetailsComponents() {\n        String mimeType = typesList.getSelectedValue();\n        FileType fileType = fileTypes.get(mimeType);\n        if (null != fileType) {\n            mimeTypeTextField.setText(fileType.getMimeType());\n            Signature signature = fileType.getSignature();\n            FileType.Signature.Type sigType = signature.getType();\n            signatureTypeComboBox.setSelectedItem(sigType == FileType.Signature.Type.RAW ? FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM : FileTypeIdGlobalSettingsPanel.ASCII_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n            String signatureBytes;\n            if (Signature.Type.RAW == signature.getType()) {\n                signatureBytes = DatatypeConverter.printHexBinary(signature.getSignatureBytes());\n            } else {\n                try {\n                    signatureBytes = new String(signature.getSignatureBytes(), \"UTF-8\");\n                } catch (UnsupportedEncodingException ex) {\n                    JOptionPane.showMessageDialog(null,\n                            ex.getLocalizedMessage(),\n                            NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.storeFailed.title\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    signatureBytes = \"\";\n                }\n            }\n            signatureTextField.setText(signatureBytes);\n            offsetTextField.setText(Long.toString(signature.getOffset()));\n            postHitCheckBox.setSelected(fileType.alertOnMatch());\n            filesSetNameTextField.setEnabled(postHitCheckBox.isSelected());\n            filesSetNameTextField.setText(fileType.getFilesSetName());\n        }\n        enableButtons();\n    }","id":72418,"modified_method":"/**\n     * Populates all of the components in the file type details portion of the\n     * panel based on the current selection in the file types list.\n     */\n    private void populateTypeDetailsComponents() {\n        String mimeType = typesList.getSelectedValue();\n        FileType fileType = fileTypes.get(mimeType);\n        if (null != fileType) {\n            mimeTypeTextField.setText(fileType.getMimeType());\n            Signature signature = fileType.getSignature();\n            FileType.Signature.Type sigType = signature.getType();\n            signatureTypeComboBox.setSelectedItem(sigType == FileType.Signature.Type.RAW ? FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM : FileTypeIdGlobalSettingsPanel.ASCII_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n            String signatureBytes;\n            if (Signature.Type.RAW == signature.getType()) {\n                signatureBytes = DatatypeConverter.printHexBinary(signature.getSignatureBytes());\n            } else {\n                try {\n                    signatureBytes = new String(signature.getSignatureBytes(), \"UTF-8\");\n                } catch (UnsupportedEncodingException ex) {\n                    JOptionPane.showMessageDialog(null,\n                            ex.getLocalizedMessage(),\n                            NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.storeFailed.title\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    signatureBytes = \"\";\n                }\n            }\n            signatureTextField.setText(signatureBytes);\n            if(signature.getOffset() == -1) {\n                isFooterCheckBox.setSelected(true);\n                offsetTextField.setEnabled(false);\n                offsetTextField.setText(\"\");\n            }\n            else {\n                isFooterCheckBox.setSelected(false);\n                offsetTextField.setEnabled(true);\n                offsetTextField.setText(Long.toString(signature.getOffset()));\n            }\n            postHitCheckBox.setSelected(fileType.alertOnMatch());\n            filesSetNameTextField.setEnabled(postHitCheckBox.isSelected());\n            filesSetNameTextField.setText(fileType.getFilesSetName());\n        }\n        enableButtons();\n    }","commit_id":"98e43b766692f38127b58a9db111cf4f1ac511c7","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"protected OsmPrimitive getMergeTarget(OsmPrimitive mergeSource) {\n        Long targetId = merged.get(mergeSource.getUniqueId());\n        if (targetId == null)\n            throw new RuntimeException(\"no merge target for merge primitive \" + mergeSource.getUniqueId() + \" of type \" + mergeSource.getType());\n        return myDataSet.getPrimitiveById(targetId, mergeSource.getType());\n    }","id":72419,"modified_method":"protected OsmPrimitive getMergeTarget(OsmPrimitive mergeSource) {\n        Long targetId = mergedMap.get(mergeSource.getUniqueId());\n        if (targetId == null)\n            throw new RuntimeException(tr(\"Missing merge target for way with id {0}\", mergeSource.getUniqueId()));\n        return myDataSet.getPrimitiveById(targetId, mergeSource.getType());\n    }","commit_id":"cc8a18a1657b6a1b3627d1de63fd369c9447f2e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * constructor\n     *\n     * The visitor will merge <code>theirDataSet<\/code> onto <code>myDataSet<\/code>\n     *\n     * @param myDataSet  dataset with my primitives\n     * @param theirDataSet dataset with their primitives.\n     */\n    public MergeVisitor(DataSet myDataSet, DataSet theirDataSet) {\n        this.myDataSet = myDataSet;\n        this.theirDataSet = theirDataSet;\n        conflicts = new ConflictCollection();\n        merged = new HashMap<Long, Long>();\n    }","id":72420,"modified_method":"/**\n     * constructor\n     *\n     * The visitor will merge <code>theirDataSet<\/code> onto <code>myDataSet<\/code>\n     *\n     * @param myDataSet  dataset with my primitives\n     * @param theirDataSet dataset with their primitives.\n     */\n    public MergeVisitor(DataSet myDataSet, DataSet theirDataSet) {\n        this.myDataSet = myDataSet;\n        this.theirDataSet = theirDataSet;\n        conflicts = new ConflictCollection();\n        mergedMap = new HashMap<Long, Long>();\n        fixReferences = new HashSet<Long>();\n    }","commit_id":"cc8a18a1657b6a1b3627d1de63fd369c9447f2e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Postprocess the dataset and fix all merged references to point to the actual\n     * data.\n     */\n    public void fixReferences() {\n        for (Way w : theirDataSet.getWays()) {\n            if (!conflicts.hasConflictForTheir(w)) {\n                mergeNodeList(w);\n                fixIncomplete(w);\n            }\n        }\n        for (Relation r : theirDataSet.getRelations()) {\n            if (!conflicts.hasConflictForTheir(r)) {\n                mergeRelationMembers(r);\n            }\n        }\n    }","id":72421,"modified_method":"/**\n     * Postprocess the dataset and fix all merged references to point to the actual\n     * data.\n     */\n    public void fixReferences() {\n        for (Way w : theirDataSet.getWays()) {\n            if (!conflicts.hasConflictForTheir(w) && fixReferences.contains(w.getUniqueId())) {\n                mergeNodeList(w);\n                fixIncomplete(w);\n            }\n        }\n        for (Relation r : theirDataSet.getRelations()) {\n            if (!conflicts.hasConflictForTheir(r) && fixReferences.contains(r.getUniqueId())) {\n                mergeRelationMembers(r);\n            }\n        }\n    }","commit_id":"cc8a18a1657b6a1b3627d1de63fd369c9447f2e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Merges a primitive <code>other<\/code> of type <P> onto my primitives.\n     *\n     * If other.id != 0 it tries to merge it with an corresponding primitive from\n     * my dataset with the same id. If this is not possible a conflict is remembered\n     * in {@see #conflicts}.\n     *\n     * If other.id == 0 it tries to find a primitive in my dataset with id == 0 which\n     * is semantically equal. If it finds one it merges its technical attributes onto\n     * my primitive.\n     *\n     * @param <P>  the type of the other primitive\n     * @param other  the other primitive\n     */\n    protected <P extends OsmPrimitive> void mergePrimitive(P other) {\n        if (!other.isNew() ) {\n            // try to merge onto a matching primitive with the same\n            // defined id\n            //\n            if (mergeById(other))\n                return;\n        } else {\n            // try to merge onto a primitive  which has no id assigned\n            // yet but which is equal in its semantic attributes\n            //\n            Collection<? extends OsmPrimitive> candidates = null;\n            switch(other.getType()) {\n            case NODE: candidates = myDataSet.getNodes(); break;\n            case WAY: candidates  =myDataSet.getWays(); break;\n            case RELATION: candidates = myDataSet.getRelations(); break;\n            }\n            for (OsmPrimitive my : candidates) {\n                if (!my.isNew()) {\n                    continue;\n                }\n                if (my.hasEqualSemanticAttributes(other)) {\n                    if (my.isDeleted() != other.isDeleted()) {\n                        // differences in deleted state have to be merged manually\n                        //\n                        conflicts.add(my, other);\n                        merged.put(other.getUniqueId(), my.getUniqueId());\n                    } else {\n                        // copy the technical attributes from other\n                        // version\n                        my.setVisible(other.isVisible());\n                        my.setUser(other.getUser());\n                        my.setTimestamp(other.getTimestamp());\n                        my.setModified(other.isModified());\n                        merged.put(other.getUniqueId(), my.getUniqueId());\n                    }\n                    return;\n                }\n            }\n        }\n        // If we get here we didn't find a suitable primitive in\n        // my dataset. Create a clone and add it to my dataset.\n        //\n        OsmPrimitive my = null;\n        switch(other.getType()) {\n        case NODE: my = other.isNew() ? new Node() : new Node(other.getId()); break;\n        case WAY: my = other.isNew() ? new Way() : new Way(other.getId()); break;\n        case RELATION: my = other.isNew() ? new Relation() : new Relation(other.getId()); break;\n        }\n        my.mergeFrom(other);\n        myDataSet.addPrimitive(my);\n        merged.put(other.getUniqueId(), my.getUniqueId());\n    }","id":72422,"modified_method":"/**\n     * Merges a primitive <code>other<\/code> of type <P> onto my primitives.\n     *\n     * If other.id != 0 it tries to merge it with an corresponding primitive from\n     * my dataset with the same id. If this is not possible a conflict is remembered\n     * in {@see #conflicts}.\n     *\n     * If other.id == 0 it tries to find a primitive in my dataset with id == 0 which\n     * is semantically equal. If it finds one it merges its technical attributes onto\n     * my primitive.\n     *\n     * @param <P>  the type of the other primitive\n     * @param other  the other primitive\n     */\n    protected <P extends OsmPrimitive> void mergePrimitive(P other) {\n        if (!other.isNew() ) {\n            // try to merge onto a matching primitive with the same\n            // defined id\n            //\n            if (mergeById(other))\n                return;\n        } else {\n            // try to merge onto a primitive  which has no id assigned\n            // yet but which is equal in its semantic attributes\n            //\n            Collection<? extends OsmPrimitive> candidates = null;\n            switch(other.getType()) {\n            case NODE: candidates = myDataSet.getNodes(); break;\n            case WAY: candidates  =myDataSet.getWays(); break;\n            case RELATION: candidates = myDataSet.getRelations(); break;\n            }\n            for (OsmPrimitive my : candidates) {\n                if (!my.isNew()) {\n                    continue;\n                }\n                if (my.hasEqualSemanticAttributes(other)) {\n                    mergedMap.put(other.getUniqueId(), my.getUniqueId());\n                    if (my.isDeleted() != other.isDeleted()) {\n                        // differences in deleted state have to be merged manually\n                        //\n                        conflicts.add(my, other);\n                    } else {\n                        // copy the technical attributes from other\n                        // version\n                        my.setVisible(other.isVisible());\n                        my.setUser(other.getUser());\n                        my.setTimestamp(other.getTimestamp());\n                        my.setModified(other.isModified());\n                        fixReferences.add(other.getUniqueId());\n                    }\n                    return;\n                }\n            }\n        }\n        // If we get here we didn't find a suitable primitive in\n        // my dataset. Create a clone and add it to my dataset.\n        //\n        OsmPrimitive my = null;\n        switch(other.getType()) {\n        case NODE: my = other.isNew() ? new Node() : new Node(other.getId()); break;\n        case WAY: my = other.isNew() ? new Way() : new Way(other.getId()); break;\n        case RELATION: my = other.isNew() ? new Relation() : new Relation(other.getId()); break;\n        }\n        my.mergeFrom(other);\n        myDataSet.addPrimitive(my);\n        mergedMap.put(other.getUniqueId(), my.getUniqueId());\n        fixReferences.add(other.getUniqueId());\n    }","commit_id":"cc8a18a1657b6a1b3627d1de63fd369c9447f2e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Tries to merge a primitive <code>other<\/code> into an existing primitive with the same id.\n     *\n     * @param other  the other primitive which is to be merged onto a primitive in my primitives\n     * @return true, if this method was able to merge <code>other<\/code> with an existing node; false, otherwise\n     */\n    private <P extends OsmPrimitive> boolean mergeById(P other) {\n        OsmPrimitive my = myDataSet.getPrimitiveById(other.getId(), other.getType());\n        // merge other into an existing primitive with the same id, if possible\n        //\n        if (my != null) {\n            if (my.getVersion() <= other.getVersion()) {\n                if (! my.isVisible() && other.isVisible()) {\n                    // should not happen\n                    //\n                    logger.warning(tr(\"My primitive with id {0} and version {1} is visible although \"\n                            + \"their primitive with lower version {2} is not visible. \"\n                            + \"Can't deal with this inconsistency. Keeping my primitive. \",\n                            Long.toString(my.getId()),Long.toString(my.getVersion()), Long.toString(other.getVersion())\n                    ));\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (my.isVisible() && ! other.isVisible()) {\n                    // this is always a conflict because the user has to decide whether\n                    // he wants to create a clone of its local primitive or whether he\n                    // wants to purge my from the local dataset. He can't keep it unchanged\n                    // because it was deleted on the server.\n                    //\n                    conflicts.add(my,other);\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (my.incomplete && !other.incomplete) {\n                    // my is incomplete, other completes it\n                    // => merge other onto my\n                    //\n                    my.mergeFrom(other);\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (!my.incomplete && other.incomplete) {\n                    // my is complete and the other is incomplete\n                    // => keep mine, we have more information already\n                    //\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (my.incomplete && other.incomplete) {\n                    // my and other are incomplete. Doesn't matter which one to\n                    // take. We take mine.\n                    //\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (my.isDeleted() && ! other.isDeleted() && my.getVersion() == other.getVersion()) {\n                    // same version, but my is deleted. Assume mine takes precedence\n                    // otherwise too many conflicts when refreshing from the server\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (my.isDeleted() != other.isDeleted()) {\n                    // differences in deleted state have to be resolved manually\n                    //\n                    conflicts.add(my,other);\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (! my.isModified() && other.isModified()) {\n                    // my not modified. We can assume that other is the most recent version.\n                    // clone it onto my. But check first, whether other is deleted. if so,\n                    // make sure that my is not references anymore in myDataSet.\n                    //\n                    if (other.isDeleted()) {\n                        myDataSet.unlinkReferencesToPrimitive(my);\n                    }\n                    my.mergeFrom(other);\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (! my.isModified() && !other.isModified() && my.getVersion() == other.getVersion()) {\n                    // both not modified. Keep mine\n                    //\n                    merged.put(other.getUniqueId(),my.getUniqueId());\n                } else if (! my.isModified() && !other.isModified() && my.getVersion() < other.getVersion()) {\n                    // my not modified but other is newer. clone other onto mine.\n                    //\n                    my.mergeFrom(other);\n                    merged.put(other.getUniqueId(),my.getUniqueId());\n                } else if (my.isModified() && ! other.isModified() && my.getVersion() == other.getVersion()) {\n                    // my is same as other but mine is modified\n                    // => keep mine\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else if (! my.hasEqualSemanticAttributes(other)) {\n                    // my is modified and is not semantically equal with other. Can't automatically\n                    // resolve the differences\n                    // =>  create a conflict\n                    conflicts.add(my,other);\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                } else {\n                    // clone from other, but keep the modified flag. Clone will mainly copy\n                    // technical attributes like timestamp or user information. Semantic\n                    // attributes should already be equal if we get here.\n                    //\n                    my.mergeFrom(other);\n                    my.setModified(true);\n                    merged.put(other.getUniqueId(), my.getUniqueId());\n                }\n            } else {\n                // my.version > other.version => keep my version\n                merged.put(other.getUniqueId(), my.getUniqueId());\n            }\n            return true;\n        }\n        return false;\n    }","id":72423,"modified_method":"/**\n     * Tries to merge a primitive <code>other<\/code> into an existing primitive with the same id.\n     *\n     * @param other  the other primitive which is to be merged onto a primitive in my primitives\n     * @return true, if this method was able to merge <code>other<\/code> with an existing node; false, otherwise\n     */\n    private <P extends OsmPrimitive> boolean mergeById(P other) {\n        OsmPrimitive my = myDataSet.getPrimitiveById(other.getId(), other.getType());\n        // merge other into an existing primitive with the same id, if possible\n        //\n        if (my == null)\n            return false;\n        mergedMap.put(other.getUniqueId(), my.getUniqueId());\n        if (my.getVersion() > other.getVersion())\n            // my.version > other.version => keep my version\n            return true;\n        if (! my.isVisible() && other.isVisible()) {\n            // should not happen\n            //\n            logger.warning(tr(\"My primitive with id {0} and version {1} is visible although \"\n                    + \"their primitive with lower version {2} is not visible. \"\n                    + \"Can't deal with this inconsistency. Keeping my primitive. \",\n                    Long.toString(my.getId()),Long.toString(my.getVersion()), Long.toString(other.getVersion())\n            ));\n        } else if (my.isVisible() && ! other.isVisible()) {\n            // this is always a conflict because the user has to decide whether\n            // he wants to create a clone of its local primitive or whether he\n            // wants to purge my from the local dataset. He can't keep it unchanged\n            // because it was deleted on the server.\n            //\n            conflicts.add(my,other);\n        } else if (my.incomplete && !other.incomplete) {\n            // my is incomplete, other completes it\n            // => merge other onto my\n            //\n            my.mergeFrom(other);\n            fixReferences.add(other.getUniqueId());\n        } else if (!my.incomplete && other.incomplete) {\n            // my is complete and the other is incomplete\n            // => keep mine, we have more information already\n            //\n        } else if (my.incomplete && other.incomplete) {\n            // my and other are incomplete. Doesn't matter which one to\n            // take. We take mine.\n            //\n        } else if (my.isDeleted() && ! other.isDeleted() && my.getVersion() == other.getVersion()) {\n            // same version, but my is deleted. Assume mine takes precedence\n            // otherwise too many conflicts when refreshing from the server\n        } else if (my.isDeleted() != other.isDeleted()) {\n            // differences in deleted state have to be resolved manually\n            //\n            conflicts.add(my,other);\n        } else if (! my.isModified() && other.isModified()) {\n            // my not modified. We can assume that other is the most recent version.\n            // clone it onto my. But check first, whether other is deleted. if so,\n            // make sure that my is not references anymore in myDataSet.\n            //\n            if (other.isDeleted()) {\n                myDataSet.unlinkReferencesToPrimitive(my);\n            }\n            my.mergeFrom(other);\n            fixReferences.add(other.getUniqueId());\n        } else if (! my.isModified() && !other.isModified() && my.getVersion() == other.getVersion()) {\n            // both not modified. Keep mine\n            //\n        } else if (! my.isModified() && !other.isModified() && my.getVersion() < other.getVersion()) {\n            // my not modified but other is newer. clone other onto mine.\n            //\n            my.mergeFrom(other);\n            fixReferences.add(other.getUniqueId());\n        } else if (my.isModified() && ! other.isModified() && my.getVersion() == other.getVersion()) {\n            // my is same as other but mine is modified\n            // => keep mine\n        } else if (! my.hasEqualSemanticAttributes(other)) {\n            // my is modified and is not semantically equal with other. Can't automatically\n            // resolve the differences\n            // =>  create a conflict\n            conflicts.add(my,other);\n        } else {\n            // clone from other, but keep the modified flag. mergeFrom will mainly copy\n            // technical attributes like timestamp or user information. Semantic\n            // attributes should already be equal if we get here.\n            //\n            my.mergeFrom(other);\n            my.setModified(true);\n            fixReferences.add(other.getUniqueId());\n        }\n        return true;\n    }","commit_id":"cc8a18a1657b6a1b3627d1de63fd369c9447f2e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"public InspectPrimitiveDialog(Collection<OsmPrimitive> primitives) {\n        super(Main.parent, tr(\"Advanced object info\"), new String[] {tr(\"Close\")});\n        this.primitives = primitives;\n        setPreferredSize(new Dimension(750, 550));\n\n        setButtonIcons(new String[] {\"ok.png\"});\n        final JTabbedPane tabs = new JTabbedPane();\n        JPanel pData = buildDataPanel();\n        tabs.addTab(tr(\"data\"), pData);\n        final JPanel pMapPaint = new JPanel();\n        tabs.addTab(tr(\"map style\"), pMapPaint);\n        tabs.getModel().addChangeListener(new ChangeListener() {\n\n            @Override\n            public void stateChanged(ChangeEvent e) {\n                if (!mappaintTabLoaded && ((SingleSelectionModel) e.getSource()).getSelectedIndex() == 1) {\n                    mappaintTabLoaded = true;\n                    buildMapPaintPanel(pMapPaint);\n                    createMapPaintText();\n                }\n            }\n        });\n        txtData.setText(buildDataText());\n        setContent(tabs, false);\n    }","id":72424,"modified_method":"public InspectPrimitiveDialog(Collection<OsmPrimitive> primitives) {\n        super(Main.parent, tr(\"Advanced object info\"), new String[] {tr(\"Close\")});\n        this.primitives = primitives;\n        setRememberWindowGeometry(getClass().getName() + \".geometry\",\n                WindowGeometry.centerInWindow(Main.parent, new Dimension(750, 550)));\n\n        setButtonIcons(new String[] {\"ok.png\"});\n        final JTabbedPane tabs = new JTabbedPane();\n        JPanel pData = buildDataPanel();\n        tabs.addTab(tr(\"data\"), pData);\n        final JPanel pMapPaint = new JPanel();\n        tabs.addTab(tr(\"map style\"), pMapPaint);\n        tabs.getModel().addChangeListener(new ChangeListener() {\n\n            @Override\n            public void stateChanged(ChangeEvent e) {\n                if (!mappaintTabLoaded && ((SingleSelectionModel) e.getSource()).getSelectedIndex() == 1) {\n                    mappaintTabLoaded = true;\n                    buildMapPaintPanel(pMapPaint);\n                    createMapPaintText();\n                }\n            }\n        });\n        txtData.setText(buildDataText());\n        setContent(tabs, false);\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"private String getSort(StyleSource s) {\n        if (s instanceof XmlStyleSource)\n            return \"xml\";\n        if (s instanceof MapCSSStyleSource)\n            return \"mapcss\";\n        return \"unkown\";\n    }","id":72425,"modified_method":"private String getSort(StyleSource s) {\n        if (s instanceof XmlStyleSource)\n            return tr(\"xml\");\n        if (s instanceof MapCSSStyleSource)\n            return tr(\"mapcss\");\n        return tr(\"unkown\");\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void addCommon(StringBuilder s, OsmPrimitive o) {\n        s.append(String.format(\"Data set: %X; User: [%s]; ChangeSet id: %d; Timestamp: %s, Version: %d\",\n                o.getDataSet().hashCode(),\n                userString(o.getUser()),\n                o.getChangesetId(),\n                DateUtils.fromDate(o.getTimestamp()),\n                o.getVersion()));\n\n        /* selected state is left out: not interesting as it is always selected */\n        if (o.isDeleted()) {\n            s.append(\"; deleted\");\n        }\n        if (!o.isVisible()) {\n            s.append(\"; deleted-on-server\");\n        }\n        if (o.isModified()) {\n            s.append(\"; modified\");\n        }\n        if (o.isDisabledAndHidden()) {\n            s.append(\"; filtered/hidden\");\n        }\n        if (o.isDisabled()) {\n            s.append(\"; filtered/disabled\");\n        }\n        if (o.hasDirectionKeys()) {\n            s.append(\"; has direction keys\");\n            if (o.reversedDirection()) {\n                s.append(\" (reversed)\");\n            }\n        }\n        s.append(\"\\n\");\n    }","id":72426,"modified_method":"protected void addCommon(StringBuilder s, OsmPrimitive o) {\n        s.append(tr(\"Data set: {0}; User: [{1}]; ChangeSet id: {2}; Timestamp: {3}, Version: {4}\",\n                Integer.toHexString(o.getDataSet().hashCode()),\n                userString(o.getUser()),\n                o.getChangesetId(),\n                o.isTimestampEmpty() ? tr(\"<new object>\") : DateUtils.fromDate(o.getTimestamp()),\n                o.getVersion()));\n\n        /* selected state is left out: not interesting as it is always selected */\n        if (o.isDeleted()) {\n            s.append(tr(\"; deleted\"));\n        }\n        if (!o.isVisible()) {\n            s.append(tr(\"; deleted-on-server\"));\n        }\n        if (o.isModified()) {\n            s.append(tr(\"; modified\"));\n        }\n        if (o.isDisabledAndHidden()) {\n            s.append(tr(\"; filtered/hidden\"));\n        }\n        if (o.isDisabled()) {\n            s.append(tr(\"; filtered/disabled\"));\n        }\n        if (o.hasDirectionKeys()) {\n            s.append(tr(\"; has direction keys\"));\n            if (o.reversedDirection()) {\n                s.append(tr(\" (reversed)\"));\n            }\n        }\n        s.append(\"\\n\");\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void addRelationReferrer(StringBuilder s, OsmPrimitive o) {\n        List<OsmPrimitive> refs = o.getReferrers();\n        Collection<Relation> relRefs = new SubclassFilteredCollection<OsmPrimitive, Relation>(refs, OsmPrimitive.relationPredicate);\n        if (relRefs.size() > 0) {\n            s.append(\"  relation referrer:\\n\");\n            for (Relation r : relRefs) {\n                s.append(\"    \"+r.getUniqueId()+\"\\n\");\n            }\n        }\n    }","id":72427,"modified_method":"protected void addRelationReferrer(StringBuilder s, OsmPrimitive o) {\n        List<OsmPrimitive> refs = o.getReferrers();\n        Collection<Relation> relRefs = new SubclassFilteredCollection<OsmPrimitive, Relation>(refs, OsmPrimitive.relationPredicate);\n        if (relRefs.size() > 0) {\n            s.append(tr(\"  relation referrer:\\n\"));\n            for (Relation r : relRefs) {\n                s.append(\"    \"+r.getUniqueId()+\"\\n\");\n            }\n        }\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void addAttributes(StringBuilder s, OsmPrimitive o) {\n        if (o.hasKeys()) {\n            s.append(\"  tags:\\n\");\n            for (String key: o.keySet()) {\n                s.append(String.format(\"    \\\"%s\\\"=\\\"%s\\\"\\n\", key, o.get(key)));\n            }\n        }\n    }","id":72428,"modified_method":"protected void addAttributes(StringBuilder s, OsmPrimitive o) {\n        if (o.hasKeys()) {\n            s.append(tr(\"  tags:\\n\"));\n            for (String key: o.keySet()) {\n                s.append(String.format(\"    \\\"%s\\\"=\\\"%s\\\"\\n\", key, o.get(key)));\n            }\n        }\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected String userString(User user) {\n        if (user == null)\n            return \"<null>\";\n\n        List<String> names = user.getNames();\n\n        StringBuilder us = new StringBuilder();\n\n        us.append(\"id:\"+user.getId());\n        if (names.size() == 1) {\n            us.append(\" name:\"+user.getName());\n        }\n        else if (names.size() > 1) {\n            us.append(String.format(\" %d names:%s\", names.size(), user.getName()));\n        }\n        return us.toString();\n    }","id":72429,"modified_method":"protected String userString(User user) {\n        if (user == null)\n            return tr(\"<new object>\");\n\n        List<String> names = user.getNames();\n\n        StringBuilder us = new StringBuilder();\n\n        us.append(tr(\"id: {0}\",user.getId()));\n        if (names.size() == 1) {\n            us.append(tr(\" name: {0}\",user.getName()));\n        }\n        else if (names.size() > 1) {\n            us.append(tr(\" {0} names: {1}\", names.size(), user.getName()));\n        }\n        return us.toString();\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void addWayReferrer(StringBuilder s, Node n) {\n        // add way referrer\n        List<OsmPrimitive> refs = n.getReferrers();\n        Collection<Way> wayRefs = new SubclassFilteredCollection<OsmPrimitive, Way>(refs, OsmPrimitive.wayPredicate);\n        if (wayRefs.size() > 0) {\n            s.append(\"  way referrer:\\n\");\n            for (Way w : wayRefs) {\n                s.append(\"    \"+w.getUniqueId()+\"\\n\");\n            }\n        }\n    }","id":72430,"modified_method":"protected void addWayReferrer(StringBuilder s, Node n) {\n        // add way referrer\n        List<OsmPrimitive> refs = n.getReferrers();\n        Collection<Way> wayRefs = new SubclassFilteredCollection<OsmPrimitive, Way>(refs, OsmPrimitive.wayPredicate);\n        if (wayRefs.size() > 0) {\n            s.append(tr(\"  way referrer:\\n\"));\n            for (Way w : wayRefs) {\n                s.append(\"    \"+w.getUniqueId()+\"\\n\");\n            }\n        }\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void createMapPaintText() {\n        final Collection<OsmPrimitive> sel = Main.main.getCurrentDataSet().getSelected();\n        ElemStyles elemstyles = MapPaintStyles.getStyles();\n        NavigatableComponent nc = Main.map.mapView;\n        double scale = nc.getDist100Pixel();\n\n        for (OsmPrimitive osm : sel) {\n            txtMappaint.append(\"Styles Cache for \\\"\"+osm.getDisplayName(DefaultNameFormatter.getInstance())+\"\\\":\");\n\n            MultiCascade mc = new MultiCascade();\n\n            for (StyleSource s : elemstyles.getStyleSources()) {\n                if (s.active) {\n                    txtMappaint.append(\"\\n\\n> applying \"+getSort(s)+\" style \\\"\"+s.getDisplayString()+\"\\n\");\n                    s.apply(mc, osm, scale, null, false);\n                    txtMappaint.append(\"\\nRange:\"+mc.range);\n                    for (Entry<String, Cascade> e : mc.getLayers()) {\n                        txtMappaint.append(\"\\n \"+e.getKey()+\": \\n\"+e.getValue());\n                    }\n                } else {\n                    txtMappaint.append(\"\\n\\n> skipping \\\"\"+s.getDisplayString()+\"\\\" (not active)\");\n                }\n            }\n            txtMappaint.append(\"\\n\\nList of generated Styles:\\n\");\n            StyleList sl = elemstyles.get(osm, scale, nc);\n            for (ElemStyle s : sl) {\n                txtMappaint.append(\" * \"+s+\"\\n\");\n            }\n            txtMappaint.append(\"\\n\\n\");\n        }\n\n        if (sel.size() == 2) {\n            List<OsmPrimitive> selList = new ArrayList<OsmPrimitive>(sel);\n            StyleCache sc1 = selList.get(0).mappaintStyle;\n            StyleCache sc2 = selList.get(1).mappaintStyle;\n            if (sc1 == sc2) {\n                txtMappaint.append(\"The 2 selected Objects have identical style caches.\");\n            }\n            if (!sc1.equals(sc2)) {\n                txtMappaint.append(\"The 2 selected Objects have different style caches.\");\n            }\n            if (sc1.equals(sc2) && sc1 != sc2) {\n                txtMappaint.append(\"Warning: The 2 selected Objects have equal, but not identical style caches.\");\n            }\n        }\n    }","id":72431,"modified_method":"protected void createMapPaintText() {\n        final Collection<OsmPrimitive> sel = Main.main.getCurrentDataSet().getSelected();\n        ElemStyles elemstyles = MapPaintStyles.getStyles();\n        NavigatableComponent nc = Main.map.mapView;\n        double scale = nc.getDist100Pixel();\n\n        for (OsmPrimitive osm : sel) {\n            txtMappaint.append(tr(\"Styles Cache for \\\"{0}\\\":\",osm.getDisplayName(DefaultNameFormatter.getInstance())));\n\n            MultiCascade mc = new MultiCascade();\n\n            for (StyleSource s : elemstyles.getStyleSources()) {\n                if (s.active) {\n                    txtMappaint.append(tr(\"\\n\\n> applying {0} style \\\"{1}\\\"\\n\",getSort(s), s.getDisplayString()));\n                    s.apply(mc, osm, scale, null, false);\n                    txtMappaint.append(tr(\"\\nRange:{0}\",mc.range));\n                    for (Entry<String, Cascade> e : mc.getLayers()) {\n                        txtMappaint.append(\"\\n \"+e.getKey()+\": \\n\"+e.getValue());\n                    }\n                } else {\n                    txtMappaint.append(tr(\"\\n\\n> skipping \\\"{0}\\\" (not active)\",s.getDisplayString()));\n                }\n            }\n            txtMappaint.append(tr(\"\\n\\nList of generated Styles:\\n\"));\n            StyleList sl = elemstyles.get(osm, scale, nc);\n            for (ElemStyle s : sl) {\n                txtMappaint.append(\" * \"+s+\"\\n\");\n            }\n            txtMappaint.append(\"\\n\\n\");\n        }\n\n        if (sel.size() == 2) {\n            List<OsmPrimitive> selList = new ArrayList<OsmPrimitive>(sel);\n            StyleCache sc1 = selList.get(0).mappaintStyle;\n            StyleCache sc2 = selList.get(1).mappaintStyle;\n            if (sc1 == sc2) {\n                txtMappaint.append(tr(\"The 2 selected objects have identical style caches.\"));\n            }\n            if (!sc1.equals(sc2)) {\n                txtMappaint.append(tr(\"The 2 selected objects have different style caches.\"));\n            }\n            if (sc1.equals(sc2) && sc1 != sc2) {\n                txtMappaint.append(tr(\"Warning: The 2 selected objects have equal, but not identical style caches.\"));\n            }\n        }\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected String buildDataText() {\n        StringBuilder s = new StringBuilder();\n        for (Node n : new SubclassFilteredCollection<OsmPrimitive, Node>(primitives, OsmPrimitive.nodePredicate)) {\n            s.append(\"Node id=\"+n.getUniqueId());\n            if (!checkDataSet(n)) {\n                s.append(\" not in data set\");\n                continue;\n            }\n            if (n.isIncomplete()) {\n                s.append(\" incomplete\\n\");\n                addWayReferrer(s, n);\n                addRelationReferrer(s, n);\n                continue;\n            }\n            s.append(String.format(\" lat=%s lon=%s (projected: x=%s, y=%s); \",\n                    Double.toString(n.getCoor().lat()), Double.toString(n.getCoor().lon()),\n                    Double.toString(n.getEastNorth().east()), Double.toString(n.getEastNorth().north())));\n            addCommon(s, n);\n            addAttributes(s, n);\n            addWayReferrer(s, n);\n            addRelationReferrer(s, n);\n            s.append('\\n');\n        }\n\n        for (Way w : new SubclassFilteredCollection<OsmPrimitive, Way>(primitives, OsmPrimitive.wayPredicate)) {\n            s.append(\"Way id=\"+ w.getUniqueId());\n            if (!checkDataSet(w)) {\n                s.append(\" not in data set\");\n                continue;\n            }\n            if (w.isIncomplete()) {\n                s.append(\" incomplete\\n\");\n                addRelationReferrer(s, w);\n                continue;\n            }\n            s.append(String.format(\" %d nodes; \", w.getNodes().size()));\n            addCommon(s, w);\n            addAttributes(s, w);\n            addRelationReferrer(s, w);\n\n            s.append(\"  nodes:\\n\");\n            for (Node n : w.getNodes()) {\n                s.append(String.format(\"    %d\\n\", n.getUniqueId()));\n            }\n            s.append('\\n');\n        }\n\n        for (Relation r : new SubclassFilteredCollection<OsmPrimitive, Relation>(primitives, OsmPrimitive.relationPredicate)) {\n            s.append(\"Relation id=\"+r.getUniqueId());\n            if (!checkDataSet(r)) {\n                s.append(\" not in data set\");\n                continue;\n            }\n            if (r.isIncomplete()) {\n                s.append(\" incomplete\\n\");\n                addRelationReferrer(s, r);\n                continue;\n            }\n            s.append(String.format(\" %d members; \",r.getMembersCount()));\n            addCommon(s, r);\n            addAttributes(s, r);\n            addRelationReferrer(s, r);\n\n            s.append(\"  members:\\n\");\n            for (RelationMember m : r.getMembers() ) {\n                s.append(String.format(\"    %s%d '%s'\\n\", m.getMember().getType().getAPIName().substring(0,1), m.getMember().getUniqueId(), m.getRole()));\n            }\n            s.append('\\n');\n        }\n\n        return s.toString().trim();\n    }","id":72432,"modified_method":"protected String buildDataText() {\n        StringBuilder s = new StringBuilder();\n        for (Node n : new SubclassFilteredCollection<OsmPrimitive, Node>(primitives, OsmPrimitive.nodePredicate)) {\n            s.append(tr(\"Node id={0}\", n.getUniqueId()));\n            if (!checkDataSet(n)) {\n                s.append(tr(\" not in data set\"));\n                continue;\n            }\n            if (n.isIncomplete()) {\n                s.append(tr(\" incomplete\\n\"));\n                addWayReferrer(s, n);\n                addRelationReferrer(s, n);\n                continue;\n            }\n            s.append(tr(\" lat={0} lon={0} (projected: x={0}, y={0}); \",\n                    Double.toString(n.getCoor().lat()), Double.toString(n.getCoor().lon()),\n                    Double.toString(n.getEastNorth().east()), Double.toString(n.getEastNorth().north())));\n            addCommon(s, n);\n            addAttributes(s, n);\n            addWayReferrer(s, n);\n            addRelationReferrer(s, n);\n            s.append('\\n');\n        }\n\n        for (Way w : new SubclassFilteredCollection<OsmPrimitive, Way>(primitives, OsmPrimitive.wayPredicate)) {\n            s.append(tr(\"Way id={0}\", w.getUniqueId()));\n            if (!checkDataSet(w)) {\n                s.append(tr(\" not in data set\"));\n                continue;\n            }\n            if (w.isIncomplete()) {\n                s.append(tr(\" incomplete\\n\"));\n                addRelationReferrer(s, w);\n                continue;\n            }\n            s.append(tr(\" {0} nodes; \", w.getNodes().size()));\n            addCommon(s, w);\n            addAttributes(s, w);\n            addRelationReferrer(s, w);\n\n            s.append(tr(\"  nodes:\\n\"));\n            for (Node n : w.getNodes()) {\n                s.append(String.format(\"    %d\\n\", n.getUniqueId()));\n            }\n            s.append('\\n');\n        }\n\n        for (Relation r : new SubclassFilteredCollection<OsmPrimitive, Relation>(primitives, OsmPrimitive.relationPredicate)) {\n            s.append(tr(\"Relation id={0}\",r.getUniqueId()));\n            if (!checkDataSet(r)) {\n                s.append(tr(\" not in data set\"));\n                continue;\n            }\n            if (r.isIncomplete()) {\n                s.append(tr(\" incomplete\\n\"));\n                addRelationReferrer(s, r);\n                continue;\n            }\n            s.append(tr(\" {0} members; \",r.getMembersCount()));\n            addCommon(s, r);\n            addAttributes(s, r);\n            addRelationReferrer(s, r);\n\n            s.append(tr(\"  members:\\n\"));\n            for (RelationMember m : r.getMembers() ) {\n                s.append(String.format(\"    %s%d '%s'\\n\", m.getMember().getType().getAPIName().substring(0,1), m.getMember().getUniqueId(), m.getRole()));\n            }\n            s.append('\\n');\n        }\n\n        return s.toString().trim();\n    }","commit_id":"7e7b2530f1ab6fb22941483347bad53800e3b18d","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void list() {\n\t\tfor (Map.Entry<String, VerifyProcess> entry :\n\t\t\t\t_verifyProcesses.entrySet()) {\n\n\t\t\tSystem.out.println(\n\t\t\t\t\"Verifier \" + entry.getKey() + \" of type \" +\n\t\t\t\t\tentry.getValue().getClass());\n\t\t}\n\t}","id":72433,"modified_method":"public void list() {\n\t\tfor (Map.Entry<String, VerifyProcess> entry :\n\t\t\t\t_verifyProcesses.entrySet()) {\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\t\n\t\t\t\t\t\"Verifier \" + entry.getKey() + \" of type \" +\n\t\t\t\t\t\tClassUtil.getClassName(entry.getValue()));\n\t\t\t}\n\t\t}\n\t}","commit_id":"f5e53562228ce9321869415068508e5feb7c5f55","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void execute(String verifyProcessName) throws VerifyException {\n\t\tVerifyProcess verifyProcess = _verifyProcesses.get(verifyProcessName);\n\n\t\tif (verifyProcess == null) {\n\t\t\tSystem.out.println(\n\t\t\t\t\"A verify process with name \" + verifyProcessName +\n\t\t\t\t\t\" has not been found\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tverifyProcess.verify();\n\t}","id":72434,"modified_method":"public void execute(String verifyProcessName) throws VerifyException {\n\t\tVerifyProcess verifyProcess = _verifyProcesses.get(verifyProcessName);\n\n\t\tif (verifyProcess == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"A verify process with name \" + verifyProcessName +\n\t\t\t\t\t\t\" has not been found\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tverifyProcess.verify();\n\t}","commit_id":"f5e53562228ce9321869415068508e5feb7c5f55","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Connect to a set of servers in parallel. Each will retry until\n     * connection. This call will block until all have connected.\n     *\n     * @throws InterruptedException if anything bad happens with the threads.\n     */\n    private void connect() throws InterruptedException {\n        System.out.println(\"Connecting to VoltDB...\");\n\n        final CountDownLatch connections = new CountDownLatch(config.parsedServers.length);\n\n        // use a new thread to connect to each server\n        for (final String server : config.parsedServers) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    connectToOneServerWithRetry(server);\n                    connections.countDown();\n                }\n            }).start();\n        }\n        // block until all have connected\n        connections.await();\n    }","id":72435,"modified_method":"/**\n     * Connect to a set of servers in parallel. Each will retry until\n     * connection. This call will block until all have connected.\n     *\n     * @throws InterruptedException if anything bad happens with the threads.\n     */\n    private void connect() throws InterruptedException {\n        log.info(\"Connecting to VoltDB...\");\n\n        final CountDownLatch connections = new CountDownLatch(config.parsedServers.length);\n\n        // use a new thread to connect to each server\n        for (final String server : config.parsedServers) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    connectToOneServerWithRetry(server);\n                    connections.countDown();\n                }\n            }).start();\n        }\n        // block until all have connected\n        connections.await();\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Connect to a single server with retry. Limited exponential backoff.\n     * No timeout. This will run until the process is killed if it's not\n     * able to connect.\n     *\n     * @param server hostname:port or just hostname (hostname can be ip).\n     */\n    private void connectToOneServerWithRetry(String server) {\n        int sleep = 1000;\n        while (!shutdown.get()) {\n            try {\n                client.createConnection(server);\n                activeConnections.incrementAndGet();\n                System.out.printf(\"Connected to VoltDB node at: %s.\\n\", server);\n                break;\n            }\n            catch (Exception e) {\n                System.err.printf(\"Connection to \" + server + \" failed - retrying in %d second(s).\\n\", sleep / 1000);\n                try { Thread.sleep(sleep); } catch (Exception interruted) {}\n                if (sleep < 8000) sleep += sleep;\n            }\n        }\n    }","id":72436,"modified_method":"/**\n     * Connect to a single server with retry. Limited exponential backoff.\n     * No timeout. This will run until the process is killed if it's not\n     * able to connect.\n     *\n     * @param server hostname:port or just hostname (hostname can be ip).\n     */\n    private void connectToOneServerWithRetry(String server) {\n        int sleep = 1000;\n        while (!shutdown.get()) {\n            try {\n                client.createConnection(server);\n                activeConnections.incrementAndGet();\n                log.info(String.format(\"Connected to VoltDB node at: %s.\", server));\n                break;\n            }\n            catch (Exception e) {\n                log.warn(String.format(\"Connection to \" + server + \" failed - retrying in %d second(s).\", sleep / 1000));\n                try { Thread.sleep(sleep); } catch (Exception interruted) {}\n                if (sleep < 8000) sleep += sleep;\n            }\n        }\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Constructor for benchmark instance.\n     * Configures VoltDB client and prints configuration.\n     *\n     * @param config Parsed & validated CLI options.\n     */\n    Benchmark(Config config) {\n        this.config = config;\n\n        processor = new PayloadProcessor(config.minvaluesize, config.maxvaluesize,\n                                         config.entropy, config.usecompression);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Command Line Configuration\");\n        System.out.println(HORIZONTAL_RULE);\n        System.out.println(config.getConfigDumpString());\n\n        StatusListener statusListener = new StatusListener();\n        ClientConfig clientConfig = new ClientConfig(\"\", \"\", statusListener);\n        client = ClientFactory.createClient(clientConfig);\n    }","id":72437,"modified_method":"/**\n     * Constructor for benchmark instance.\n     * Configures VoltDB client and prints configuration.\n     *\n     * @param config Parsed & validated CLI options.\n     */\n    Benchmark(Config config) {\n        this.config = config;\n\n        processor = new PayloadProcessor(config.minvaluesize, config.maxvaluesize,\n                                         config.entropy, config.usecompression);\n\n        log.info(HORIZONTAL_RULE);\n        log.info(\" Command Line Configuration\");\n        log.info(HORIZONTAL_RULE);\n        log.info(config.getConfigDumpString());\n\n        StatusListener statusListener = new StatusListener();\n        ClientConfig clientConfig = new ClientConfig(\"\", \"\", statusListener);\n        client = ClientFactory.createClient(clientConfig);\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            if (shutdown.get()) {\n                return;\n            }\n\n            activeConnections.decrementAndGet();\n\n            // if the benchmark is still active\n            if ((System.currentTimeMillis() - benchmarkStartTS) < (config.duration * 1000)) {\n                System.err.printf(\"Connection to %s:%d was lost.\\n\", hostname, port);\n            }\n\n            // setup for retry\n            final String server = MiscUtils.getHostnameColonPortString(hostname, port);\n            es.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connectToOneServerWithRetry(server);\n                }\n            });\n        }","id":72438,"modified_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            if (shutdown.get()) {\n                return;\n            }\n\n            activeConnections.decrementAndGet();\n\n            // if the benchmark is still active\n            if ((System.currentTimeMillis() - benchmarkStartTS) < (config.duration * 1000)) {\n                log.warn(String.format(\"Connection to %s:%d was lost.\", hostname, port));\n            }\n\n            // setup for retry\n            final String server = MiscUtils.getHostnameColonPortString(hostname, port);\n            es.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connectToOneServerWithRetry(server);\n                }\n            });\n        }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Prints a one line update on performance that can be printed\n     * periodically during a benchmark.\n     */\n    private synchronized void printStatistics() {\n        System.out.printf(\"Executed %d\\n\", c.get());\n    }","id":72439,"modified_method":"/**\n     * Prints a one line update on performance that can be printed\n     * periodically during a benchmark.\n     */\n    private synchronized void printStatistics() {\n        log.info(String.format(\"Executed %d\", c.get()));\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Core benchmark code.\n     * Connect. Initialize. Run the loop. Cleanup. Print Results.\n     *\n     * @throws Exception if anything unexpected happens.\n     */\n    public void runBenchmark() throws Exception {\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        final int cidCount = 128;\n        final long[] lastRid = new long[cidCount];\n        for (int i = 0; i < lastRid.length; i++) {\n            lastRid[i] = 0;\n        }\n\n        // connect to one or more servers, loop until success\n        connect();\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\"Starting Benchmark\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // print periodic statistics to the console\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n\n        // Run the benchmark loop for the requested duration\n        // The throughput may be throttled depending on client configuration\n        System.out.println(\"\\nRunning benchmark...\");\n\n        BigTableLoader partitionedLoader = new BigTableLoader(client, \"bigp\",\n                (config.partfillerrowmb * 1024 * 1024) / config.fillerrowsize, config.fillerrowsize);\n        partitionedLoader.start();\n        BigTableLoader replicatedLoader = new BigTableLoader(client, \"bigr\",\n                (config.replfillerrowmb * 1024 * 1024) / config.fillerrowsize, config.fillerrowsize);\n        replicatedLoader.start();\n\n        ReadThread readThread = new ReadThread(client, config.threads, config.threadoffset);\n        readThread.start();\n\n        AdHocMayhemThread adHocMayhemThread = new AdHocMayhemThread(client);\n        adHocMayhemThread.start();\n\n        List<ClientThread> clientThreads = new ArrayList<ClientThread>();\n        for (byte cid = (byte) config.threadoffset; cid < config.threadoffset + config.threads; cid++) {\n            ClientThread clientThread = new ClientThread(cid, c, client, processor);\n            clientThread.start();\n            clientThreads.add(clientThread);\n        }\n\n        final long benchmarkEndTime = System.currentTimeMillis() + (1000l * config.duration);\n\n        while (benchmarkEndTime > System.currentTimeMillis()) {\n            Thread.yield();\n        }\n\n        replicatedLoader.shutdown();\n        partitionedLoader.shutdown();\n        readThread.shutdown();\n        adHocMayhemThread.shutdown();\n        for (ClientThread clientThread : clientThreads) {\n            clientThread.shutdown();\n        }\n        replicatedLoader.join();\n        partitionedLoader.join();\n        readThread.join();\n        adHocMayhemThread.join();\n        for (ClientThread clientThread : clientThreads) {\n            clientThread.join();\n        }\n\n        // cancel periodic stats printing\n        timer.cancel();\n\n        shutdown.set(true);\n        es.shutdownNow();\n\n        // block until all outstanding txns return\n        client.drain();\n        client.close();\n    }","id":72440,"modified_method":"/**\n     * Core benchmark code.\n     * Connect. Initialize. Run the loop. Cleanup. Print Results.\n     *\n     * @throws Exception if anything unexpected happens.\n     */\n    public void runBenchmark() throws Exception {\n        log.info(HORIZONTAL_RULE);\n        log.info(\" Setup & Initialization\");\n        log.info(HORIZONTAL_RULE);\n\n        final int cidCount = 128;\n        final long[] lastRid = new long[cidCount];\n        for (int i = 0; i < lastRid.length; i++) {\n            lastRid[i] = 0;\n        }\n\n        // connect to one or more servers, loop until success\n        connect();\n\n        log.info(HORIZONTAL_RULE);\n        log.info(\"Starting Benchmark\");\n        log.info(HORIZONTAL_RULE);\n\n        // print periodic statistics to the console\n        benchmarkStartTS = System.currentTimeMillis();\n        schedulePeriodicStats();\n\n        // Run the benchmark loop for the requested duration\n        // The throughput may be throttled depending on client configuration\n        log.info(\"Running benchmark...\");\n\n        BigTableLoader partitionedLoader = new BigTableLoader(client, \"bigp\",\n                (config.partfillerrowmb * 1024 * 1024) / config.fillerrowsize, config.fillerrowsize);\n        partitionedLoader.start();\n        BigTableLoader replicatedLoader = new BigTableLoader(client, \"bigr\",\n                (config.replfillerrowmb * 1024 * 1024) / config.fillerrowsize, config.fillerrowsize);\n        replicatedLoader.start();\n\n        ReadThread readThread = new ReadThread(client, config.threads, config.threadoffset);\n        readThread.start();\n\n        AdHocMayhemThread adHocMayhemThread = new AdHocMayhemThread(client);\n        adHocMayhemThread.start();\n\n        List<ClientThread> clientThreads = new ArrayList<ClientThread>();\n        for (byte cid = (byte) config.threadoffset; cid < config.threadoffset + config.threads; cid++) {\n            ClientThread clientThread = new ClientThread(cid, c, client, processor);\n            clientThread.start();\n            clientThreads.add(clientThread);\n        }\n\n        final long benchmarkEndTime = System.currentTimeMillis() + (1000l * config.duration);\n\n        while (benchmarkEndTime > System.currentTimeMillis()) {\n            Thread.yield();\n        }\n\n        replicatedLoader.shutdown();\n        partitionedLoader.shutdown();\n        readThread.shutdown();\n        adHocMayhemThread.shutdown();\n        for (ClientThread clientThread : clientThreads) {\n            clientThread.shutdown();\n        }\n        replicatedLoader.join();\n        partitionedLoader.join();\n        readThread.join();\n        adHocMayhemThread.join();\n        for (ClientThread clientThread : clientThreads) {\n            clientThread.join();\n        }\n\n        // cancel periodic stats printing\n        timer.cancel();\n\n        shutdown.set(true);\n        es.shutdownNow();\n\n        // block until all outstanding txns return\n        client.drain();\n        client.close();\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        byte[] data = new byte[rowSize];\n        r.nextBytes(data);\n\n        try {\n            long currentRowCount = getRowCount();\n            while ((currentRowCount < targetCount) && (m_shouldContinue.get())) {\n                CountDownLatch latch = new CountDownLatch(25);\n                // try to insert 5 random rows\n                for (int i = 0; i < 25; i++) {\n                    long id = Math.abs(r.nextLong());\n                    client.callProcedure(new InsertCallback(latch), tableName.toUpperCase() + \".insert\", id, data);\n                }\n                latch.await(10, TimeUnit.SECONDS);\n                long nextRowCount = getRowCount();\n                // if no progress, throttle a bit\n                if (nextRowCount == currentRowCount) {\n                    Thread.sleep(1000);\n                }\n                currentRowCount = nextRowCount;\n            }\n\n        }\n        catch (Exception e) {\n            // on exception, log and end the thread, but don't kill the process\n            System.err.println(\"BigTableLoader failed a procedure call for table \" + tableName +\n                    \" and will now die.\");\n            e.printStackTrace();\n            return;\n        }\n    }","id":72441,"modified_method":"@Override\n    public void run() {\n        byte[] data = new byte[rowSize];\n        r.nextBytes(data);\n\n        try {\n            long currentRowCount = getRowCount();\n            while ((currentRowCount < targetCount) && (m_shouldContinue.get())) {\n                CountDownLatch latch = new CountDownLatch(25);\n                // try to insert 5 random rows\n                for (int i = 0; i < 25; i++) {\n                    long id = Math.abs(r.nextLong());\n                    client.callProcedure(new InsertCallback(latch), tableName.toUpperCase() + \".insert\", id, data);\n                }\n                latch.await(10, TimeUnit.SECONDS);\n                long nextRowCount = getRowCount();\n                // if no progress, throttle a bit\n                if (nextRowCount == currentRowCount) {\n                    Thread.sleep(1000);\n                }\n                currentRowCount = nextRowCount;\n            }\n\n        }\n        catch (Exception e) {\n            // on exception, log and end the thread, but don't kill the process\n            log.error(\"BigTableLoader failed a procedure call for table \" + tableName +\n                    \" and will now die.\", e);\n            return;\n        }\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            byte status = clientResponse.getStatus();\n            if ((status != ClientResponse.SUCCESS) && (status != ClientResponse.GRACEFUL_FAILURE)) {\n                // log what happened\n                System.err.println(\"BigTableLoader failed to insert into table \" + tableName);\n                System.err.println(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the world\n                m_shouldContinue.set(false);\n            }\n            latch.countDown();\n        }","id":72442,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            byte status = clientResponse.getStatus();\n            if ((status != ClientResponse.SUCCESS) && (status != ClientResponse.GRACEFUL_FAILURE)) {\n                // log what happened\n                log.error(\"BigTableLoader failed to insert into table \" + tableName);\n                log.error(((ClientResponseImpl) clientResponse).toJSONString());\n                // stop the world\n                m_shouldContinue.set(false);\n            }\n            latch.countDown();\n        }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n            try {\n                runOne();\n            }\n            catch (ProcCallException e) {\n                ClientResponseImpl cri = (ClientResponseImpl) e.getClientResponse();\n                if ((cri.getStatus() == ClientResponse.GRACEFUL_FAILURE) ||\n                        (cri.getStatus() == ClientResponse.USER_ABORT)) {\n                    System.err.println(\"ClientThread had a proc-call exception that indicated bad data\");\n                    System.err.println(cri.toJSONString());\n                    e.printStackTrace();\n                    System.exit(-1);\n                }\n                else {\n                    // other proc call exceptions are logged, but don't stop the thread\n                    System.err.println(\"ClientThread had a proc-call exception that didn't indicate bad data\");\n                    System.err.println(cri.toJSONString());\n                    e.printStackTrace();\n                }\n            }\n            catch (Exception e) {\n                System.err.println(\"ClientThread had a non proc-call exception\");\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        }\n    }","id":72443,"modified_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n            try {\n                runOne();\n            }\n            catch (ProcCallException e) {\n                ClientResponseImpl cri = (ClientResponseImpl) e.getClientResponse();\n                if ((cri.getStatus() == ClientResponse.GRACEFUL_FAILURE) ||\n                        (cri.getStatus() == ClientResponse.USER_ABORT)) {\n                    log.error(\"ClientThread had a proc-call exception that indicated bad data\", e);\n                    log.error(cri.toJSONString(), e);\n                    System.exit(-1);\n                }\n                else {\n                    // other proc call exceptions are logged, but don't stop the thread\n                    log.warn(\"ClientThread had a proc-call exception that didn't indicate bad data\", e);\n                    log.warn(cri.toJSONString());\n                    // take a breather to avoid slamming the log\n                    try { Thread.sleep(3000); } catch (InterruptedException e1) {}\n                }\n            }\n            catch (Exception e) {\n                log.error(\"ClientThread had a non proc-call exception\", e);\n                System.exit(-1);\n            }\n        }\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"ClientThread(byte cid, AtomicLong txnsRun, Client client, PayloadProcessor processor) throws Exception {\n        m_type = Type.typeFromId(cid);\n        m_cid = cid;\n        m_client = client;\n        m_processor = processor;\n        m_txnsRun = txnsRun;\n\n        String sql1 = String.format(\"select * from partitioned where cid = %d order by rid desc limit 1\", cid);\n        String sql2 = String.format(\"select * from replicated  where cid = %d order by rid desc limit 1\", cid);\n        VoltTable t1 = client.callProcedure(\"@AdHoc\", sql1).getResults()[0];\n        VoltTable t2 = client.callProcedure(\"@AdHoc\", sql2).getResults()[0];\n\n        long pNextRid = (t1.getRowCount() == 0) ? 1 : t1.fetchRow(0).getLong(\"rid\");\n        long rNextRid = (t2.getRowCount() == 0) ? 1 : t2.fetchRow(0).getLong(\"rid\");\n        m_nextRid = pNextRid > rNextRid ? pNextRid : rNextRid; // max\n    }","id":72444,"modified_method":"ClientThread(byte cid, AtomicLong txnsRun, Client client, PayloadProcessor processor) throws Exception {\n        m_type = Type.typeFromId(cid);\n        m_cid = cid;\n        m_client = client;\n        m_processor = processor;\n        m_txnsRun = txnsRun;\n\n        String sql1 = String.format(\"select * from partitioned where cid = %d order by rid desc limit 1\", cid);\n        String sql2 = String.format(\"select * from replicated  where cid = %d order by rid desc limit 1\", cid);\n        VoltTable t1 = client.callProcedure(\"@AdHoc\", sql1).getResults()[0];\n        VoltTable t2 = client.callProcedure(\"@AdHoc\", sql2).getResults()[0];\n\n        long pNextRid = (t1.getRowCount() == 0) ? 1 : t1.fetchRow(0).getLong(\"rid\") + 1;\n        long rNextRid = (t2.getRowCount() == 0) ? 1 : t2.fetchRow(0).getLong(\"rid\") + 1;\n        m_nextRid = pNextRid > rNextRid ? pNextRid : rNextRid; // max\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            txnsOutstanding.release();\n            if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                System.err.println(\"Non success in ProcCallback for AdHocMayhemThread\");\n                System.err.println(((ClientResponseImpl)clientResponse).toJSONString());\n                return;\n            }\n            // validate the data\n            try {\n                VoltTable data = clientResponse.getResults()[0];\n                UpdateBaseProc.validateCIDData(data, ReadThread.class.getName());\n            }\n            catch (Exception e) {\n                System.err.println(\"ReadThread got a bad response\");\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        }","id":72445,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            txnsOutstanding.release();\n            if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                log.error(\"Non success in ProcCallback for ReadThread\");\n                log.error(((ClientResponseImpl)clientResponse).toJSONString());\n                return;\n            }\n            // validate the data\n            try {\n                VoltTable data = clientResponse.getResults()[0];\n                UpdateBaseProc.validateCIDData(data, ReadThread.class.getName());\n            }\n            catch (Exception e) {\n                log.error(\"ReadThread got a bad response\", e);\n                System.exit(-1);\n            }\n        }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n            try {\n                txnsOutstanding.acquire();\n            } catch (InterruptedException e) {\n                System.err.println(\"ReadThread interrupted while waiting for permit\");\n                e.printStackTrace();\n                return;\n            }\n\n            // 1/5 of all reads are MP\n            boolean replicated = (counter++ % 5) == 0;\n            String procName = replicated ? \"ReadMP\" : \"ReadSP\";\n            byte cid = (byte) (r.nextInt(threadCount) + threadOffset);\n\n            try {\n                client.callProcedure(new ReadCallback(), procName, cid);\n            }\n            catch (Exception e) {\n                System.err.println(\"ReadThread failed to run an AdHoc statement\");\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        }\n    }","id":72446,"modified_method":"@Override\n    public void run() {\n        while (m_shouldContinue.get()) {\n            try {\n                txnsOutstanding.acquire();\n            } catch (InterruptedException e) {\n                log.error(\"ReadThread interrupted while waiting for permit\", e);\n                return;\n            }\n\n            // 1/5 of all reads are MP\n            boolean replicated = (counter++ % 5) == 0;\n            String procName = replicated ? \"ReadMP\" : \"ReadSP\";\n            byte cid = (byte) (r.nextInt(threadCount) + threadOffset);\n\n            try {\n                client.callProcedure(new ReadCallback(), procName, cid);\n            }\n            catch (Exception e) {\n                log.error(\"ReadThread failed to run an AdHoc statement\", e);\n                System.exit(-1);\n            }\n        }\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected VoltTable[] doWork(SQLStmt getCIDData, SQLStmt cleanUp, SQLStmt insert, SQLStmt getAdHocData,\n                                 byte cid, long rid, byte[] value)\n    {\n        voltQueueSQL(getCIDData, cid);\n        voltQueueSQL(getAdHocData);\n        VoltTable[] results = voltExecuteSQL();\n        VoltTable data = results[0];\n        VoltTable adhoc = results[1];\n\n        final long txnid = getUniqueId();\n        final long ts = getTransactionTime().getTime();\n        long prevtxnid = 0;\n        long prevrid = 0;\n        long cnt = 0;\n\n        // read data modified by AdHocMayhemThread for later insertion\n        final long adhocInc = adhoc.fetchRow(0).getLong(\"inc\");\n        final long adhocJmp = adhoc.fetchRow(0).getLong(\"jmp\");\n\n        // compute the cheesy checksum of all of the table's contents based on\n        // this cid to subsequently store in the new row\n        final long cidallhash = MiscUtils.cheesyBufferCheckSum(data.getBuffer());\n\n        // get the most recent row's data\n        int rowCount = data.getRowCount();\n        if (rowCount != 0) {\n            VoltTableRow row = data.fetchRow(0);\n            cnt = row.getLong(\"cnt\") + 1;\n            prevtxnid = row.getLong(\"prevtxnid\");\n            prevrid = row.getLong(\"rid\");\n        }\n\n        validateCIDData(data, getClass().getName());\n\n        // check the rids monotonically increase\n        if (prevrid >= rid) {\n            throw new VoltAbortException(getClass().getName() +\n                    \" previous rid \" + prevrid +\n                    \" larger than current rid \" + rid +\n                    \" for cid \" + cid);\n        }\n\n        voltQueueSQL(insert, txnid, prevtxnid, ts, cid, cidallhash, rid, cnt, adhocInc, adhocJmp, new byte[0]);\n        voltQueueSQL(cleanUp, cid, cnt - 10);\n        voltQueueSQL(getCIDData, cid);\n        return voltExecuteSQL();\n    }","id":72447,"modified_method":"protected VoltTable[] doWork(SQLStmt getCIDData, SQLStmt cleanUp, SQLStmt insert, SQLStmt getAdHocData,\n                                 byte cid, long rid, byte[] value)\n    {\n        voltQueueSQL(getCIDData, cid);\n        voltQueueSQL(getAdHocData);\n        VoltTable[] results = voltExecuteSQL();\n        VoltTable data = results[0];\n        VoltTable adhoc = results[1];\n\n        final long txnid = getUniqueId();\n        final long ts = getTransactionTime().getTime();\n        long prevtxnid = 0;\n        long prevrid = 0;\n        long cnt = 0;\n\n        // read data modified by AdHocMayhemThread for later insertion\n        final long adhocInc = adhoc.fetchRow(0).getLong(\"inc\");\n        final long adhocJmp = adhoc.fetchRow(0).getLong(\"jmp\");\n\n        // compute the cheesy checksum of all of the table's contents based on\n        // this cid to subsequently store in the new row\n        final long cidallhash = MiscUtils.cheesyBufferCheckSum(data.getBuffer());\n\n        // get the most recent row's data\n        int rowCount = data.getRowCount();\n        if (rowCount != 0) {\n            VoltTableRow row = data.fetchRow(0);\n            cnt = row.getLong(\"cnt\") + 1;\n            prevtxnid = row.getLong(\"prevtxnid\");\n            prevrid = row.getLong(\"rid\");\n        }\n\n        validateCIDData(data, getClass().getName());\n\n        // check the rids monotonically increase\n        if (prevrid >= rid) {\n            throw new VoltAbortException(getClass().getName() +\n                    \" previous rid \" + prevrid +\n                    \" >= than current rid \" + rid +\n                    \" for cid \" + cid);\n        }\n\n        voltQueueSQL(insert, txnid, prevtxnid, ts, cid, cidallhash, rid, cnt, adhocInc, adhocJmp, new byte[0]);\n        voltQueueSQL(cleanUp, cid, cnt - 10);\n        voltQueueSQL(getCIDData, cid);\n        return voltExecuteSQL();\n    }","commit_id":"c0984ceab76e685967204f6cd864f3b00549fc2c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String args[]) {\n        String rootDir = getArg(args, \"syndieDir\");\n        String hashStr = getArg(args, \"blog\");\n        String smlFile = getArg(args, \"sml\");\n        if ( (rootDir == null) || (hashStr == null) || (smlFile == null) ) {\n            System.err.println(USAGE);\n            return;\n        }\n        \n        String url = getArg(args, \"importurl\");\n        String entryIdDef = getArg(args, \"entryId\");\n        \n        List attachmentFilenames = new ArrayList();\n        List attachmentNames = new ArrayList();\n        List attachmentDescriptions = new ArrayList();\n        List attachmentMimeTypes = new ArrayList();\n        while (true) {\n            // --attachment$N $file $name $desc $type]\n            String file = getAttachmentParam(args, attachmentFilenames.size(), 0);\n            String name = getAttachmentParam(args, attachmentFilenames.size(), 1);\n            String desc = getAttachmentParam(args, attachmentFilenames.size(), 2);\n            String type = getAttachmentParam(args, attachmentFilenames.size(), 3);\n            if ( (file != null) && (name != null) && (desc != null) && (type != null) ) {\n                attachmentFilenames.add(file);\n                attachmentNames.add(name);\n                attachmentDescriptions.add(desc);\n                attachmentMimeTypes.add(type);\n            } else {\n                break;\n            }\n        }\n        \n        List tags = readTags(smlFile);\n        \n        // don't support the entry key stuff yet...\n        String entryKeyDef = null; //args[5];\n        \n        String loc = getArg(args, \"storelocal\");\n        boolean storeLocal = false;\n        if (loc != null)\n            storeLocal = Boolean.valueOf(loc).booleanValue();\n        \n        if (!storeLocal && \"none\".equalsIgnoreCase(url)) {\n            System.err.println(\"You need to post it somewhere, so either specify \\\"--storelocal true\\\"\");\n            System.err.println(\"or don't specify \\\"--importurl none\\\"\");\n            return;\n        }\n        \n        I2PAppContext ctx = I2PAppContext.getGlobalContext();\n        BlogManager mgr = new BlogManager(ctx, rootDir, false);\n        EntryContainer entry = CLI.createEntry(ctx, mgr, hashStr, tags, entryIdDef, entryKeyDef, smlFile, storeLocal, \n                                               attachmentFilenames, attachmentNames, attachmentDescriptions, \n                                               attachmentMimeTypes);\n        if (entry != null) {\n            if (storeLocal)\n                mgr.getArchive().regenerateIndex();\n            if (!(\"none\".equalsIgnoreCase(url))) {\n                if ( (url == null) || (url.trim().length() <= 0) )\n                    url = \"http://localhost:7657/syndie/import.jsp\";\n\n                // now send it to the import URL\n                BlogInfo info = mgr.getArchive().getBlogInfo(entry.getURI().getKeyHash());\n                File fMeta = null;\n                File fData = null;\n\n                try {\n                    fMeta = File.createTempFile(\"cli\", \".snm\", mgr.getTempDir());\n                    fData = File.createTempFile(\"cli\", \".snd\", mgr.getTempDir());\n                    FileOutputStream out = new FileOutputStream(fMeta);\n                    info.write(out);\n                    out.close();\n                    out = new FileOutputStream(fData);\n                    entry.write(out, true);\n                    out.close();\n                } catch (IOException ioe) {\n                    System.err.println(\"Error writing temp files: \" + ioe.getMessage());\n                    return;\n                }\n\n                Map uploads = new HashMap(2);\n                uploads.put(\"blogmeta0\", fMeta);\n                uploads.put(\"blogpost0\", fData);\n\n                String proxyHost = getArg(args, \"proxyhost\");\n                String proxyPortStr = getArg(args, \"proxyport\");\n                int proxyPort = -1;\n                if (proxyPortStr != null) \n                    try { proxyPort = Integer.parseInt(proxyPortStr); } catch (NumberFormatException nfe) { }\n\n                OnCompletion job = new OnCompletion();\n                EepPost post = new EepPost();\n                post.postFiles(url, (proxyPort > 0 ? proxyHost : null), proxyPort, uploads, job);\n                boolean posted = job.waitForCompletion(30*1000);\n                if (posted)\n                    System.out.println(\"Posted successfully: \" + entry.getURI().toString());\n                else\n                    System.out.println(\"Posting failed\");\n            } else if (storeLocal) {\n                System.out.println(\"Store local successfully: \" + entry.getURI().toString());\n            } else {\n                // foo\n            }\n        } else {\n            System.err.println(\"Error creating the blog entry\");\n        }\n    }","id":72448,"modified_method":"public static void main(String args[]) {\n        String rootDir = getArg(args, \"syndieDir\");\n        String hashStr = getArg(args, \"blog\");\n        String smlFile = getArg(args, \"sml\");\n        if ( (rootDir == null) || (hashStr == null) || (smlFile == null) ) {\n            System.err.println(USAGE);\n            return;\n        }\n        \n        String url = getArg(args, \"importurl\");\n        String entryIdDef = getArg(args, \"entryId\");\n        \n        List attachmentFilenames = new ArrayList();\n        List attachmentNames = new ArrayList();\n        List attachmentDescriptions = new ArrayList();\n        List attachmentMimeTypes = new ArrayList();\n        while (true) {\n            // --attachment$N $file $name $desc $type]\n            String file = getAttachmentParam(args, attachmentFilenames.size(), 0);\n            String name = getAttachmentParam(args, attachmentFilenames.size(), 1);\n            String desc = getAttachmentParam(args, attachmentFilenames.size(), 2);\n            String type = getAttachmentParam(args, attachmentFilenames.size(), 3);\n            if ( (file != null) && (name != null) && (desc != null) && (type != null) ) {\n                attachmentFilenames.add(file);\n                attachmentNames.add(name);\n                attachmentDescriptions.add(desc);\n                attachmentMimeTypes.add(type);\n            } else {\n                break;\n            }\n        }\n        \n        List tags = readTags(smlFile);\n        \n        // don't support the entry key stuff yet...\n        String entryKeyDef = null; //args[5];\n        \n        String loc = getArg(args, \"storelocal\");\n        boolean storeLocal = false;\n        if (loc != null)\n            storeLocal = Boolean.valueOf(loc).booleanValue();\n        \n        if (!storeLocal && \"none\".equalsIgnoreCase(url)) {\n            System.err.println(\"You need to post it somewhere, so either specify \\\"--storelocal true\\\"\");\n            System.err.println(\"or don't specify \\\"--importurl none\\\"\");\n            return;\n        }\n        \n        I2PAppContext ctx = I2PAppContext.getGlobalContext();\n        BlogManager mgr = new BlogManager(ctx, rootDir, false);\n        EntryContainer entry = CLI.createEntry(ctx, mgr, hashStr, tags, entryIdDef, entryKeyDef, smlFile, storeLocal, \n                                               attachmentFilenames, attachmentNames, attachmentDescriptions, \n                                               attachmentMimeTypes);\n        if (entry != null) {\n            if (storeLocal)\n                mgr.getArchive().regenerateIndex();\n            if (!(\"none\".equalsIgnoreCase(url))) {\n                if ( (url == null) || (url.trim().length() <= 0) )\n                    url = \"http://localhost:7657/syndie/import.jsp\";\n\n                // now send it to the import URL\n                BlogInfo info = mgr.getArchive().getBlogInfo(entry.getURI().getKeyHash());\n                File fMeta = null;\n                File fData = null;\n\n                try {\n                    fMeta = File.createTempFile(\"cli\", \".snm\", mgr.getTempDir());\n                    fData = File.createTempFile(\"cli\", \".snd\", mgr.getTempDir());\n                    FileOutputStream out = new FileOutputStream(fMeta);\n                    info.write(out);\n                    out.close();\n                    out = new FileOutputStream(fData);\n                    entry.write(out, true);\n                    out.close();\n                    fMeta.deleteOnExit();\n                    fData.deleteOnExit();\n                } catch (IOException ioe) {\n                    System.err.println(\"Error writing temp files: \" + ioe.getMessage());\n                    return;\n                }\n\n                Map uploads = new HashMap(2);\n                uploads.put(\"blogmeta0\", fMeta);\n                uploads.put(\"blogpost0\", fData);\n\n                String proxyHost = getArg(args, \"proxyhost\");\n                String proxyPortStr = getArg(args, \"proxyport\");\n                int proxyPort = -1;\n                if (proxyPortStr != null) \n                    try { proxyPort = Integer.parseInt(proxyPortStr); } catch (NumberFormatException nfe) { }\n\n                OnCompletion job = new OnCompletion();\n                EepPost post = new EepPost();\n                post.postFiles(url, (proxyPort > 0 ? proxyHost : null), proxyPort, uploads, job);\n                boolean posted = job.waitForCompletion(30*1000);\n                if (posted)\n                    System.out.println(\"Posted successfully: \" + entry.getURI().toString());\n                else\n                    System.out.println(\"Posting failed\");\n            } else if (storeLocal) {\n                System.out.println(\"Store local successfully: \" + entry.getURI().toString());\n            } else {\n                // foo\n            }\n        } else {\n            System.err.println(\"Error creating the blog entry\");\n        }\n    }","commit_id":"197237aa32d145cd7208ee5097ee52968a1a63fb","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * parse the first status line and grab the response code.\n     * e.g. \"HTTP/1.1 206 OK\" vs \"HTTP/1.1 200 OK\" vs \n     * \"HTTP/1.1 404 NOT FOUND\", etc.  \n     *\n     * @return HTTP response code (200, 206, other)\n     */\n    private int handleStatus(String line) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Status line: [\" + line + \"]\");\n        StringTokenizer tok = new StringTokenizer(line, \" \");\n        if (!tok.hasMoreTokens()) {\n            System.err.println(\"ERR: status \"+  line);\n            return -1;\n        }\n        String protocol = tok.nextToken(); // ignored\n        if (!tok.hasMoreTokens()) {\n            System.err.println(\"ERR: status \"+  line);\n            return -1;\n        }\n        String rc = tok.nextToken();\n        try {\n            return Integer.parseInt(rc); \n        } catch (NumberFormatException nfe) {\n            nfe.printStackTrace();\n            return -1;\n        }\n    }","id":72449,"modified_method":"/**\n     * parse the first status line and grab the response code.\n     * e.g. \"HTTP/1.1 206 OK\" vs \"HTTP/1.1 200 OK\" vs \n     * \"HTTP/1.1 404 NOT FOUND\", etc.  \n     *\n     * @return HTTP response code (200, 206, other)\n     */\n    private int handleStatus(String line) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Status line: [\" + line + \"]\");\n        StringTokenizer tok = new StringTokenizer(line, \" \");\n        if (!tok.hasMoreTokens()) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"ERR: status \"+  line);\n            return -1;\n        }\n        String protocol = tok.nextToken(); // ignored\n        if (!tok.hasMoreTokens()) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"ERR: status \"+  line);\n            return -1;\n        }\n        String rc = tok.nextToken();\n        try {\n            return Integer.parseInt(rc); \n        } catch (NumberFormatException nfe) {\n            nfe.printStackTrace();\n            return -1;\n        }\n    }","commit_id":"197237aa32d145cd7208ee5097ee52968a1a63fb","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\r\n     *  Perform checks on parsers, transformers and resolvers.\r\n     */\r\n    public static void check() {\r\n        StringBuffer message = new StringBuffer();\r\n\r\n        if (hasValidClassVersion(\"Parser\", validParsers, message)) {\r\n            System.out.println(message.toString());\r\n        } else {\r\n            System.err.println(message.toString());\r\n        }\r\n\r\n        message = new StringBuffer();\r\n        if (hasValidClassVersion(\"Transformer\", validTransformers, message)) {\r\n            System.out.println(message.toString());\r\n        } else {\r\n            System.err.println(message.toString());\r\n        }\r\n\r\n        message = new StringBuffer();\r\n        if (hasValidClassVersion(\"Resolver\", validResolvers, message)) {\r\n            System.out.println(message.toString());\r\n        } else {\r\n            System.err.println(message.toString());\r\n        }\r\n\r\n        System.out.println(\"Using parser \" + determineActualParserClass());\r\n        System.out.println(\"Using transformer \" + determineActualTransformerClass());\r\n        System.out.println(); \r\n    }","id":72450,"modified_method":"/**\r\n     *  Perform checks on parsers, transformers and resolvers.\r\n     */\r\n    public static void check() {\r\n        StringBuffer message \t\t\t\t= new StringBuffer();\r\n\t\tboolean\t\t invalidVersionFound\t= false;\r\n\r\n        if( hasValidClassVersion( \"Parser\", validParsers, message ) ) {\r\n\t\t\tlogger.info( message.toString() );\r\n        } else {\r\n\t\t\tlogger.warn( message.toString() );\r\n            System.err.println( message.toString() );\r\n\t\t\tinvalidVersionFound\t= true;\r\n        }\r\n\r\n        message = new StringBuffer();\r\n        if( hasValidClassVersion( \"Transformer\", validTransformers, message ) ) {\r\n            logger.info( message.toString() );\r\n        } else {\r\n            logger.warn( message.toString() );\r\n            System.err.println( message.toString() );\r\n\t\t\tinvalidVersionFound\t= true;\r\n        }\r\n\r\n        message = new StringBuffer();\r\n        if( hasValidClassVersion( \"Resolver\", validResolvers, message ) ) {\r\n            logger.info( message.toString() );\r\n        } else {\r\n            logger.warn( message.toString() );\r\n            System.err.println( message.toString() );\r\n\t\t\tinvalidVersionFound\t= true;\r\n        }\r\n\r\n\t\tlogger.info( \"Using parser \" + determineActualParserClass() );\r\n\t\tlogger.info( \"Using transformer \" + determineActualTransformerClass() );\r\n\t\t\r\n\t\tif( invalidVersionFound ) {\r\n\t\t\tSystem.err.println( \"Using parser \" + determineActualParserClass() );\r\n\t\t\tSystem.err.println( \"Using transformer \" + determineActualTransformerClass() );\r\n\t\t\tSystem.err.println();\r\n\t\t}\r\n    }","commit_id":"71ce33063da546e2958e4ba73551aca4738ec0a3","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean solve(ProximalSolver solver, double[] z, double l1pen, boolean hasIntercept, double[] lb, double[] ub) {\n      gerr = Double.POSITIVE_INFINITY;\n      if (l1pen == 0 && lb == null && ub == null) {\n        solver.solve(null, z);\n        return true;\n      }\n      int ii = hasIntercept?1:0;\n      double[] zbest = null;\n      int N = z.length;\n      double abstol = ABSTOL * Math.sqrt(N);\n      double [] rho = solver.rho();\n      Log.info(\"rho = \" + Arrays.toString(rho));\n\n      double[] u = MemoryManager.malloc8d(N);\n      double[] x = MemoryManager.malloc8d(N);\n      double[] beta_given = MemoryManager.malloc8d(N);\n      double  [] kappa = MemoryManager.malloc8d(rho.length);\n      if(l1pen > 0)\n        for(int i = 0; i < N-ii; ++i)\n          kappa[i] = l1pen/rho[i];\n      Log.info(\"kappa = \" + Arrays.toString(rho));\n      int i;\n      double orlx = 1.0; // over-relaxation\n      double reltol = RELTOL;\n      double best_err = Double.POSITIVE_INFINITY;\n      for (i = 0; i < max_iter; ++i) {\n        // updated x\n        solver.solve(beta_given, x);\n        // compute u and z updateADMM\n        double rnorm = 0, snorm = 0, unorm = 0, xnorm = 0;\n        boolean allzeros = true;\n        for (int j = 0; j < N - ii; ++j) {\n          double xj = x[j];\n          double zjold = z[j];\n          double x_hat = xj * orlx + (1 - orlx) * zjold;\n          double zj = shrinkage(x_hat + u[j], kappa[j]);\n          if (lb != null && zj < lb[j])\n            zj = lb[j];\n          if (ub != null && zj > ub[j])\n            zj = ub[j];\n          u[j] += x_hat - zj;\n          beta_given[j] = zj - u[j];\n          double r = xj - zj;\n          double s = zj - zjold;\n          rnorm += r * r;\n          snorm += s * s;\n          xnorm += xj * xj;\n          unorm += rho[j] * rho[j] * u[j] * u[j];\n          z[j] = zj;\n          allzeros &= zj == 0;\n        }\n        if (hasIntercept) { // TODO update unorm and so on\n          int idx = x.length - 1;\n          double icpt = x[idx];\n          if (lb != null && icpt < lb[idx])\n            icpt = lb[idx];\n          if (ub != null && icpt > ub[idx])\n            icpt = ub[idx];\n          double r = x[idx] - icpt;\n          double s = icpt - z[idx];\n          u[idx] += r;\n          beta_given[idx] = icpt - u[idx];\n          rnorm += r * r;\n          snorm += s * s;\n          xnorm += icpt * icpt;\n          unorm += rho[idx] * rho[idx] * u[idx] * u[idx];\n          z[idx] = icpt;\n        }\n        if (rnorm < (abstol + (reltol * Math.sqrt(xnorm))) && snorm < (abstol + reltol * Math.sqrt(unorm))) {\n          double oldGerr = gerr;\n          computeErr(z, solver.gradient(z), l1pen, lb, ub);\n          if (gerr > _eps && (allzeros || Math.abs(oldGerr - gerr) > _eps * 0.5)) {\n            Log.debug(\"ADMM.L1Solver: iter = \" + i + \" , gerr =  \" + gerr + \", oldGerr = \" + oldGerr + \", rnorm = \" + rnorm + \", snorm  \" + snorm);\n            // try gg to improve the solution...\n            abstol *= .1;\n            if (abstol < 1e-10)\n              abstol = 1e-10;\n            reltol *= .1;\n            if (reltol < 1e-10)\n              reltol = 1e-10;\n            continue;\n          }\n          iter = i;\n          Log.info(\"ADMM.L1Solver: converged at iteration = \" + i + \", gerr = \" + gerr);\n          return true;\n        }\n      }\n      computeErr(z, solver.gradient(z), l1pen, lb, ub);\n      if (zbest != null && best_err < gerr) {\n        System.arraycopy(zbest, 0, z, 0, zbest.length);\n        computeErr(z, solver.gradient(z), l1pen, lb, ub);\n        assert Math.abs(best_err - gerr) < 1e-8 : \" gerr = \" + gerr + \", best_err = \" + best_err + \" zbest = \" + Arrays.toString(zbest) + \", z = \" + Arrays.toString(z);\n      }\n      Log.warn(\"ADMM DID NOT CONVERGE with gerr = \" + gerr);\n      iter = max_iter;\n      return false;\n    }","id":72451,"modified_method":"public boolean solve(ProximalSolver solver, double[] z, double l1pen, boolean hasIntercept, double[] lb, double[] ub) {\n      gerr = Double.POSITIVE_INFINITY;\n      if (l1pen == 0 && lb == null && ub == null) {\n        solver.solve(null, z);\n        return true;\n      }\n      int ii = hasIntercept?1:0;\n      double[] zbest = null;\n      int N = z.length;\n      double abstol = ABSTOL * Math.sqrt(N);\n      double [] rho = solver.rho();\n      double[] u = MemoryManager.malloc8d(N);\n      double[] x = MemoryManager.malloc8d(N);\n      double[] beta_given = MemoryManager.malloc8d(N);\n      double  [] kappa = MemoryManager.malloc8d(rho.length);\n\n      if(l1pen > 0)\n        for(int i = 0; i < N-ii; ++i)\n          kappa[i] = l1pen/rho[i];\n      int i;\n      double orlx = 1.0; // over-relaxation\n      double reltol = RELTOL;\n      double best_err = Double.POSITIVE_INFINITY;\n      for (i = 0; i < max_iter; ++i) {\n        // updated x\n        solver.solve(beta_given, x);\n        // compute u and z updateADMM\n        double rnorm = 0, snorm = 0, unorm = 0, xnorm = 0;\n        boolean allzeros = true;\n        for (int j = 0; j < N - ii; ++j) {\n          double xj = x[j];\n          double zjold = z[j];\n          double x_hat = xj * orlx + (1 - orlx) * zjold;\n          double zj = shrinkage(x_hat + u[j], kappa[j]);\n          if (lb != null && zj < lb[j])\n            zj = lb[j];\n          if (ub != null && zj > ub[j])\n            zj = ub[j];\n          u[j] += x_hat - zj;\n          beta_given[j] = zj - u[j];\n          double r = xj - zj;\n          double s = zj - zjold;\n          rnorm += r * r;\n          snorm += s * s;\n          xnorm += xj * xj;\n          unorm += rho[j] * rho[j] * u[j] * u[j];\n          z[j] = zj;\n          allzeros &= zj == 0;\n        }\n        if (hasIntercept) { // TODO update unorm and so on\n          int idx = x.length - 1;\n          double icpt = x[idx];\n          if (lb != null && icpt < lb[idx])\n            icpt = lb[idx];\n          if (ub != null && icpt > ub[idx])\n            icpt = ub[idx];\n          double r = x[idx] - icpt;\n          double s = icpt - z[idx];\n          u[idx] += r;\n          beta_given[idx] = icpt - u[idx];\n          rnorm += r * r;\n          snorm += s * s;\n          xnorm += icpt * icpt;\n          unorm += rho[idx] * rho[idx] * u[idx] * u[idx];\n          z[idx] = icpt;\n        }\n        if (rnorm < (abstol + (reltol * Math.sqrt(xnorm))) && snorm < (abstol + reltol * Math.sqrt(unorm))) {\n          double oldGerr = gerr;\n          computeErr(z, solver.gradient(z), l1pen, lb, ub);\n          if (gerr > _eps && (allzeros || Math.abs(oldGerr - gerr) > _eps * 0.5)) {\n            Log.debug(\"ADMM.L1Solver: iter = \" + i + \" , gerr =  \" + gerr + \", oldGerr = \" + oldGerr + \", rnorm = \" + rnorm + \", snorm  \" + snorm);\n            // try gg to improve the solution...\n            abstol *= .1;\n            if (abstol < 1e-10)\n              abstol = 1e-10;\n            reltol *= .1;\n            if (reltol < 1e-10)\n              reltol = 1e-10;\n            continue;\n          }\n          iter = i;\n          Log.info(\"ADMM.L1Solver: converged at iteration = \" + i + \", gerr = \" + gerr);\n          return true;\n        }\n      }\n      computeErr(z, solver.gradient(z), l1pen, lb, ub);\n      if (zbest != null && best_err < gerr) {\n        System.arraycopy(zbest, 0, z, 0, zbest.length);\n        computeErr(z, solver.gradient(z), l1pen, lb, ub);\n        assert Math.abs(best_err - gerr) < 1e-8 : \" gerr = \" + gerr + \", best_err = \" + best_err + \" zbest = \" + Arrays.toString(zbest) + \", z = \" + Arrays.toString(z);\n      }\n      Log.warn(\"ADMM DID NOT CONVERGE with gerr = \" + gerr);\n      iter = max_iter;\n      return false;\n    }","commit_id":"eeb3d30cb511a4ae82350c00d0cba7271a55f25b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public static double estimateRho(double x, double l1pen){\n      double rho = 0;\n      if (x > 0) {\n        double D = l1pen * (l1pen + 4 * x);\n        if (D >= 0) {\n          D = Math.sqrt(D);\n          double r = .25 * (l1pen + D) / (2 * x);\n          if (r > 0) rho = r;\n          else if(l1pen > 0) System.out.println(\"negative rho estimate(1)! r = \" + r);\n        }\n      } else if (x < 0) {\n        double D = l1pen * (l1pen - 4 * x);\n        if (D >= 0) {\n          D = Math.sqrt(D);\n          double r = -.25 * (l1pen + D) / (2 * x);\n          if (r > 0) rho = r;\n          else if(l1pen > 0) Log.warn(\"negative rho estimate(2)!  r = \" + r);\n        }\n      } else if(l1pen > 0) {\n        Log.warn(\"x estimated zero!\");\n      }\n      return rho;\n    }","id":72452,"modified_method":"/**\n     * Estimate optimal rho based on l1 penalty and (estimate of) soltuion x without the l1penalty\n     * @param x\n     * @param l1pen\n     * @return\n     */\n    public static double estimateRho(double x, double l1pen){\n      double rho = 0;\n      if(l1pen == 0 || x == 0) return 0;\n      if (x > 0) {\n        double D = l1pen * (l1pen + 4 * x);\n        if (D >= 0) {\n          D = Math.sqrt(D);\n          double r = .25 * (l1pen + D) / (2 * x);\n          if (r > 0) rho = r;\n          else Log.warn(\"negative rho estimate(1)! r = \" + r);\n        }\n      } else if (x < 0) {\n        double D = l1pen * (l1pen - 4 * x);\n        if (D >= 0) {\n          D = Math.sqrt(D);\n          double r = -.25 * (l1pen + D) / (2 * x);\n          if (r > 0) rho = r;\n          else Log.warn(\"negative rho estimate(2)!  r = \" + r);\n        }\n      }\n      return rho;\n    }","commit_id":"eeb3d30cb511a4ae82350c00d0cba7271a55f25b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public GramSolver(Gram gram, double[] xy, boolean intercept, double l2pen, double l1pen, double[] beta_given, double[] proxPen, double default_rho, double[] lb, double[] ub) {\n      if(ub != null && lb != null)\n        for(int i = 0; i < ub.length; ++i) {\n          assert ub[i] >= lb[i]:i + \": ub < lb, ub = \" + Arrays.toString(ub) + \", lb = \" + Arrays.toString(lb) ;\n        }\n      _lambda = l2pen;\n      _gram = gram;\n\n      // Try to pick optimal rho constant here used in ADMM solver.\n      //\n      // Rho defines the strength of proximal-penalty and also the strentg of L1 penalty aplpied in each step.\n      // Picking good rho constant is tricky and greatly influences the speed of convergence and precision with which we are able to solve the problem.\n      //\n      // Intuitively, we want the proximal l2-penalty ~ l1 penalty (l1 pen = lambda/rho, where lambda is the l1 penalty applied to the problem)\n      // Here we compute the rho for each coordinate by using equation for computing coefficient for single coordinate and then making the two penalties equal.\n      //\n      int ii = intercept?1:0;\n      int icptCol = xy.length-1;\n      double [] rhos = MemoryManager.malloc8d(xy.length);\n      double min = Double.POSITIVE_INFINITY;\n      for (int i = 0; i < xy.length - ii; ++i) {\n        double d = xy[i];\n        d = d >= 0 ? d : -d;\n        if (d < min && d != 0) min = d;\n      }\n      double ybar = xy[icptCol];\n      for (int i = 0; i < rhos.length - ii; ++i) {\n        double y = xy[i];\n        if (y == 0) y = min;\n        double xbar = gram.get(icptCol, i);\n        double x = (beta_given != null && proxPen != null)\n          ? (y - ybar * gram.get(icptCol, i) + proxPen[i] * beta_given[i]) / ((gram.get(i, i) - xbar * xbar) + l2pen + proxPen[i])\n          : ((y - ybar * xbar) / (gram.get(i, i) - xbar * xbar) + l2pen);///gram.get(i,i);\n        double rho = ADMM.L1Solver.estimateRho(x,l1pen);\n        if(l1pen > 0 && rho == 0);\n         rho = Math.abs(l1pen / x);\n        // upper nad lower bounds have different rho requirements.\n        if(ub != null && !Double.isInfinite(ub[i]) || lb != null && !Double.isInfinite(lb[i])) {\n          double lx = (x - lb[i]);\n          double ux = (ub[i] - x);\n          double xx = Math.min(lx,ux);\n          rhos[i] = Math.max(rho,xx <= .5*x?1:1e-4);\n        } else {\n          rhos[i] = rho; // Math.min(avg*1e2,Math.max(avg*1e-2,y));\n        }\n      }\n      // do the intercept separate as l1pen does not apply to it\n      if(lb != null && !Double.isInfinite(lb[icptCol])|| ub != null && !Double.isInfinite(ub[icptCol])) {\n        int icpt = xy.length-1;\n        rhos[icpt] = 1;//(xy[icpt] >= 0 ? xy[icpt] : -xy[icpt]);\n      }\n      if(l2pen > 0)\n        gram.addDiag(l2pen);\n      if(proxPen != null && beta_given != null) {\n        gram.addDiag(proxPen);\n        xy = xy.clone();\n        for(int i = 0; i < xy.length; ++i)\n          xy[i] += proxPen[i]*beta_given[i];\n      }\n      gram.addDiag(rhos);\n      _chol = gram.cholesky(null,true,null);\n      double l2 = 1e-8;\n      while(!_chol.isSPD() && _addedL2 < 1) { // need to add l2\n        _gram.addDiag(l2 - _addedL2);\n        _addedL2 = l2;\n        l2 *= 10;\n        _chol = _gram.cholesky(_chol);\n      }\n      gram.addDiag(ArrayUtils.mult(rhos, -1));\n      ArrayUtils.mult(rhos, -1);\n      _rho = rhos;\n      _xy = xy;\n    }","id":72453,"modified_method":"public GramSolver(Gram gram, double[] xy, boolean intercept, double l2pen, double l1pen, double[] beta_given, double[] proxPen, double default_rho, double[] lb, double[] ub) {\n      if(ub != null && lb != null)\n        for(int i = 0; i < ub.length; ++i) {\n          assert ub[i] >= lb[i]:i + \": ub < lb, ub = \" + Arrays.toString(ub) + \", lb = \" + Arrays.toString(lb) ;\n        }\n      _lambda = l2pen;\n      _gram = gram;\n\n      // Try to pick optimal rho constant here used in ADMM solver.\n      //\n      // Rho defines the strength of proximal-penalty and also the strentg of L1 penalty aplpied in each step.\n      // Picking good rho constant is tricky and greatly influences the speed of convergence and precision with which we are able to solve the problem.\n      //\n      // Intuitively, we want the proximal l2-penalty ~ l1 penalty (l1 pen = lambda/rho, where lambda is the l1 penalty applied to the problem)\n      // Here we compute the rho for each coordinate by using equation for computing coefficient for single coordinate and then making the two penalties equal.\n      //\n      int ii = intercept?1:0;\n      int icptCol = xy.length-1;\n      double [] rhos = MemoryManager.malloc8d(xy.length);\n      double min = Double.POSITIVE_INFINITY;\n      for (int i = 0; i < xy.length - ii; ++i) {\n        double d = xy[i];\n        d = d >= 0 ? d : -d;\n        if (d < min && d != 0) min = d;\n      }\n      double ybar = xy[icptCol];\n      for (int i = 0; i < rhos.length - ii; ++i) {\n        double y = xy[i];\n        if (y == 0) y = min;\n        double xbar = gram.get(icptCol, i);\n        double x = (beta_given != null && proxPen != null)\n          ? (y - ybar * gram.get(icptCol, i) + proxPen[i] * beta_given[i]) / ((gram.get(i, i) - xbar * xbar) + l2pen + proxPen[i])\n          : ((y - ybar * xbar) / (gram.get(i, i) - xbar * xbar) + l2pen);///gram.get(i,i);\n        double rho = ADMM.L1Solver.estimateRho(x,l1pen);\n        // upper nad lower bounds have different rho requirements.\n        if(ub != null && !Double.isInfinite(ub[i]) || lb != null && !Double.isInfinite(lb[i])) {\n          double lx = (x - lb[i]);\n          double ux = (ub[i] - x);\n          double xx = Math.min(lx,ux);\n          rhos[i] = Math.max(rho,xx <= .5*x?1:1e-4);\n        } else {\n          rhos[i] = rho; // Math.min(avg*1e2,Math.max(avg*1e-2,y));\n        }\n      }\n      // do the intercept separate as l1pen does not apply to it\n      if(lb != null && !Double.isInfinite(lb[icptCol])|| ub != null && !Double.isInfinite(ub[icptCol])) {\n        int icpt = xy.length-1;\n        rhos[icpt] = 1;//(xy[icpt] >= 0 ? xy[icpt] : -xy[icpt]);\n      }\n      Log.info(\"rhos = \" + Arrays.toString(rhos));\n      if(l2pen > 0)\n        gram.addDiag(l2pen);\n      if(proxPen != null && beta_given != null) {\n        gram.addDiag(proxPen);\n        xy = xy.clone();\n        for(int i = 0; i < xy.length; ++i)\n          xy[i] += proxPen[i]*beta_given[i];\n      }\n      gram.addDiag(rhos);\n      _chol = gram.cholesky(null,true,null);\n      double l2 = 1e-8;\n      while(!_chol.isSPD() && _addedL2 < 1) { // need to add l2\n        _gram.addDiag(l2 - _addedL2);\n        _addedL2 = l2;\n        l2 *= 10;\n        _chol = _gram.cholesky(_chol);\n      }\n      gram.addDiag(ArrayUtils.mult(rhos, -1));\n      ArrayUtils.mult(rhos, -1);\n      _rho = rhos;\n      _xy = xy;\n    }","commit_id":"eeb3d30cb511a4ae82350c00d0cba7271a55f25b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n      public void callback(final GLMLineSearchTask lst) {\n        assert lst._nobs == _taskInfo._nobs:lst._nobs + \" != \" + _taskInfo._nobs  + \", filtervec = \" + (lst._rowFilter == null);\n        double t = 1;\n        for (int i = 0; i < lst._likelihoods.length; ++i, t *= LINE_SEARCH_STEP) {\n          double[] beta = ArrayUtils.wadd(_taskInfo._beta.clone(), lst._direction, t);\n          if (_taskInfo._objVal > objVal(lst._likelihoods[i], beta)) {\n            assert t < 1;\n            LogInfo(\"line search: found admissible step = \" + t + \",  objval = \" + lst._likelihoods[i]);\n            getCompleter().addToPendingCount(1);\n            new GLMIterationTask(GLM.this._key, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _parms, true, beta, _taskInfo._ymu, _rowFilter, new Iteration(getCompleter(), true, false)).asyncExec(_activeData._adaptedFrame);\n            return;\n          }\n        }\n        // no line step worked => converge\n        LogInfo(\"Line search did not find feasible step, converged at objval = \" + _taskInfo._objVal);\n        checkKKTAndComplete(lst._beta, true);\n      }","id":72454,"modified_method":"@Override\n      public void callback(final GLMLineSearchTask lst) {\n        assert lst._nobs == _taskInfo._nobs:lst._nobs + \" != \" + _taskInfo._nobs  + \", filtervec = \" + (lst._rowFilter == null);\n        double t = 1;\n        for (int i = 0; i < lst._likelihoods.length; ++i, t *= LINE_SEARCH_STEP) {\n          double[] beta = ArrayUtils.wadd(_taskInfo._beta.clone(), lst._direction, t);\n          if (_taskInfo._objVal > objVal(lst._likelihoods[i], beta)) {\n            assert t < 1;\n            LogInfo(\"line search: found admissible step = \" + t + \",  objval = \" + lst._likelihoods[i]);\n            getCompleter().addToPendingCount(1);\n            new GLMIterationTask(GLM.this._key, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _parms, true, beta, _taskInfo._ymu, _rowFilter, new Iteration(getCompleter(), true, false)).asyncExec(_activeData._adaptedFrame);\n            return;\n          }\n        }\n        // no line step worked => converge\n        LogInfo(\"Line search did not find feasible step, converged at objval = \" + _taskInfo._objVal);\n        checkKKTsAndComplete();\n      }","commit_id":"eeb3d30cb511a4ae82350c00d0cba7271a55f25b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n    protected void compute2() {\n      assert _rowFilter != null;\n      _start_time = System.currentTimeMillis();\n      LogInfo(\"lambda = \" + _parms._lambda[_lambdaId] + \"\\n\");\n      int[] activeCols = activeCols(_parms._lambda[_lambdaId], _lambdaId == 0?_taskInfo._lambdaMax:_parms._lambda[_lambdaId-1], _taskInfo._ginfo._gradient);\n      _taskInfo._beta = resizeVec(_taskInfo._beta, activeCols, _taskInfo._activeCols , _dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n      _taskInfo._activeCols = activeCols;\n      _activeData = _dinfo.filterExpandedColumns(activeCols);\n      assert  activeCols == null || _activeData.fullN() == activeCols.length : LogInfo(\"mismatched number of cols, got \" + activeCols.length + \" active cols, but data info claims \" + _activeData.fullN());\n      assert DKV.get(_activeData._key) != null;\n      solve();\n    }","id":72455,"modified_method":"@Override\n    protected void compute2() {\n      assert _rowFilter != null;\n      _start_time = System.currentTimeMillis();\n      LogInfo(\"lambda = \" + _parms._lambda[_lambdaId] + \"\\n\");\n      int[] activeCols = activeCols(_parms._lambda[_lambdaId], _lambdaId == 0?_taskInfo._lambdaMax:_parms._lambda[_lambdaId-1], _taskInfo._ginfo._gradient);\n      _taskInfo._beta = resizeVec(_taskInfo._beta, activeCols, _taskInfo._activeCols , _dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n      _taskInfo._activeCols = activeCols;\n      _activeData = _dinfo.filterExpandedColumns(activeCols);\n      _taskInfo._ginfo = new GradientInfo(_taskInfo._ginfo._objVal,contractVec(_taskInfo._ginfo._gradient,activeCols));\n\n      assert  activeCols == null || _activeData.fullN() == activeCols.length : LogInfo(\"mismatched number of cols, got \" + activeCols.length + \" active cols, but data info claims \" + _activeData.fullN());\n      assert DKV.get(_activeData._key) != null;\n      solve();\n    }","commit_id":"eeb3d30cb511a4ae82350c00d0cba7271a55f25b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected void solve(){\n      if (_activeData.fullN() > _parms._max_active_predictors)\n        throw new TooManyPredictorsException();\n      switch(_parms._solver) { // TODO add L1 pen handling!\n        case L_BFGS: {\n          double[] beta = _taskInfo._beta;\n          GradientSolver solver = new GLMGradientSolver(_parms, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _taskInfo._ymu, _taskInfo._nobs, _rowFilter);\n          if(_bc._betaGiven != null && _bc._rho != null)\n            solver = new ProximalGradientSolver(solver,_bc._betaGiven,_bc._rho);\n          if (beta == null) {\n            beta = MemoryManager.malloc8d(_activeData.fullN() + (_activeData._intercept ? 1 : 0));\n            if (_activeData._intercept)\n              beta[beta.length - 1] = _parms.link(_taskInfo._ymu);\n          }\n          L_BFGS lbfgs = new L_BFGS().setMaxIter(_parms._max_iter);\n          Result r = lbfgs.solve(solver, beta, _taskInfo._ginfo, new ProgressMonitor() {\n            @Override\n            public boolean progress(double[] beta, GradientInfo ginfo) {\n              if ((_taskInfo._iter & 7) == 0) {\n                update(8, \"iteration \" + (_taskInfo._iter + 1) + \", objective value = \" + ginfo._objVal, GLM.this._key);\n                LogInfo(\"LBFGS: objval = \" + ginfo._objVal);\n              }\n              ++_taskInfo._iter;\n              // todo update the model here so we can show intermediate results\n              return isRunning(GLM.this._key);\n            }\n          });\n          _taskInfo._beta = r.coefs;\n          double l1pen = _parms._lambda[_lambdaId] * _parms._alpha[0];\n          if(l1pen > 0 || _bc.hasBounds()) {\n            double [] rho = MemoryManager.malloc8d(beta.length);\n            // compute rhos\n            for(int i = 0; i < rho.length; ++i)\n              rho[i] = ADMM.L1Solver.estimateRho(_taskInfo._beta[i],l1pen);\n            new ADMM.L1Solver(1e-4, 100).solve(new LBFGS_ProximalSolver(solver, r.coefs.clone(), rho), _taskInfo._beta, l1pen);\n          }\n          break;\n        }\n        case COORDINATE_DESCENT:\n          double l1pen = _parms._alpha[0]*_parms._lambda[_lambdaId];\n          double l2pen = (1-_parms._alpha[0])*_parms._lambda[_lambdaId];\n          double [] beta = _taskInfo._beta.clone();\n          int off;\n          double xOldSub;\n          double xOldMul;\n          double xNewSub = 0;\n          double xNewMul = 1;\n          double [] betaUpdate = null;\n          boolean betaChanges = true;\n          int iter = 0;\n          // external loop - each time generate weights based on previous beta, compute new beta as solution to weighted least squares\n          while(betaChanges) {\n            // internal loop - go over each column independently as long as beta keeps changing\n            int it = iter; // to keep track of inner iterations\n            while (betaChanges && ++iter < 1000) {\n              betaChanges = false;\n              // run one iteration of coordinate descent - go over all columns\n              for (int i = 0; i < _activeData._adaptedFrame.numCols(); ++i) {\n                Vec previousVec = i == 0?_taskInfo._iVec:_dinfo._adaptedFrame.vec(i-1);\n                Vec currentVec = i == _dinfo._adaptedFrame.numCols()-1?_taskInfo._iVec:_dinfo._adaptedFrame.vec(i);\n                xOldSub = xNewSub;\n                xOldMul = xNewMul;\n                boolean isCategorical = currentVec.isEnum();\n                int to;\n                if (isCategorical) {\n                  xNewSub = 0;\n                  xNewMul = 1;\n                  off = _dinfo._catOffsets[i];\n                  to = _dinfo._catOffsets[i + 1];\n                } else {\n                  int k = i - _dinfo._cats;\n                  xNewSub = _dinfo._normSub[k];\n                  xNewMul = _dinfo._normMul[k];\n                  off = _dinfo.numStart() + k;\n                  to = off + 1;\n                }\n                double[] currentBeta = Arrays.copyOfRange(_taskInfo._beta, off, to);\n                double[] xy = new GLMCoordinateDescentTask(betaUpdate, currentBeta, xOldSub, xOldMul, xNewSub, xNewMul).doAll(previousVec,currentVec,_taskInfo._eVec,_taskInfo._wVec, _taskInfo._zVec)._xy;\n                for (int j = 0; j < xy.length; ++j) {\n                  betaUpdate = currentBeta;\n                  double updatedCoef = ADMM.shrinkage(xy[j], l1pen) / (1 + l2pen);\n                  betaUpdate[j] = updatedCoef - currentBeta[j];\n                  if (betaUpdate[j] < -1e-4 || betaUpdate[j] > 1e-4)\n                    betaChanges = true;\n                  beta[off + j] = updatedCoef;\n                }\n              }\n            }\n            if(iter > it+1) {\n              betaChanges = true; // beta changed during inner iteration\n              // generate new weights\n              new GLMTask.GLMWeightsTask(_parms).doAll(_dinfo._adaptedFrame.lastVec(), _taskInfo._zVec, _taskInfo._wVec, _taskInfo._eVec);\n            }\n          }\n          // done, compute the gradient and check KKTs\n          break;\n        case ADMM:// fork off ADMM iteration\n          new GLMIterationTask(GLM.this._key, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _parms, false, _taskInfo._beta, _taskInfo._ymu, _rowFilter, new Iteration(this, false)).asyncExec(_activeData._adaptedFrame);\n          return;\n        default:\n          throw H2O.unimpl();\n      }\n      checkKKTsAndComplete();\n      tryComplete();\n    }","id":72456,"modified_method":"protected void solve(){\n      if (_activeData.fullN() > _parms._max_active_predictors)\n        throw new TooManyPredictorsException();\n      switch(_parms._solver) { // TODO add L1 pen handling!\n        case L_BFGS: {\n          double[] beta = _taskInfo._beta;\n          assert beta.length == _activeData.fullN()+1;\n          GradientSolver solver = new GLMGradientSolver(_parms, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _taskInfo._ymu, _taskInfo._nobs, _rowFilter);\n          if(_bc._betaGiven != null && _bc._rho != null)\n            solver = new ProximalGradientSolver(solver,_bc._betaGiven,_bc._rho);\n          if (beta == null) {\n            beta = MemoryManager.malloc8d(_activeData.fullN() + (_activeData._intercept ? 1 : 0));\n            if (_activeData._intercept)\n              beta[beta.length - 1] = _parms.link(_taskInfo._ymu);\n          }\n          L_BFGS lbfgs = new L_BFGS().setMaxIter(_parms._max_iter);\n          assert beta.length == _taskInfo._ginfo._gradient.length;\n          Result r = lbfgs.solve(solver, beta, _taskInfo._ginfo, new ProgressMonitor() {\n            @Override\n            public boolean progress(double[] beta, GradientInfo ginfo) {\n              if ((_taskInfo._iter & 7) == 0) {\n                update(8, \"iteration \" + (_taskInfo._iter + 1) + \", objective value = \" + ginfo._objVal, GLM.this._key);\n                LogInfo(\"LBFGS: objval = \" + ginfo._objVal);\n              }\n              ++_taskInfo._iter;\n              // todo update the model here so we can show intermediate results\n              return isRunning(GLM.this._key);\n            }\n          });\n          _taskInfo._beta = r.coefs;\n          double l1pen = _parms._lambda[_lambdaId] * _parms._alpha[0];\n          if(l1pen > 0 || _bc.hasBounds()) {\n            double [] rho = MemoryManager.malloc8d(beta.length);\n            // compute rhos\n            for(int i = 0; i < rho.length; ++i)\n              rho[i] = ADMM.L1Solver.estimateRho(_taskInfo._beta[i],l1pen);\n            new ADMM.L1Solver(1e-4, 100).solve(new LBFGS_ProximalSolver(solver, r.coefs.clone(), rho), _taskInfo._beta, l1pen);\n          }\n          break;\n        }\n        case COORDINATE_DESCENT:\n          double l1pen = _parms._alpha[0]*_parms._lambda[_lambdaId];\n          double l2pen = (1-_parms._alpha[0])*_parms._lambda[_lambdaId];\n          double [] beta = _taskInfo._beta.clone();\n          int off;\n          double xOldSub;\n          double xOldMul;\n          double xNewSub = 0;\n          double xNewMul = 1;\n          double [] betaUpdate = null;\n          boolean betaChanges = true;\n          int iter = 0;\n          // external loop - each time generate weights based on previous beta, compute new beta as solution to weighted least squares\n          while(betaChanges) {\n            // internal loop - go over each column independently as long as beta keeps changing\n            int it = iter; // to keep track of inner iterations\n            while (betaChanges && ++iter < 1000) {\n              betaChanges = false;\n              // run one iteration of coordinate descent - go over all columns\n              for (int i = 0; i < _activeData._adaptedFrame.numCols(); ++i) {\n                Vec previousVec = i == 0?_taskInfo._iVec:_dinfo._adaptedFrame.vec(i-1);\n                Vec currentVec = i == _dinfo._adaptedFrame.numCols()-1?_taskInfo._iVec:_dinfo._adaptedFrame.vec(i);\n                xOldSub = xNewSub;\n                xOldMul = xNewMul;\n                boolean isCategorical = currentVec.isEnum();\n                int to;\n                if (isCategorical) {\n                  xNewSub = 0;\n                  xNewMul = 1;\n                  off = _dinfo._catOffsets[i];\n                  to = _dinfo._catOffsets[i + 1];\n                } else {\n                  int k = i - _dinfo._cats;\n                  xNewSub = _dinfo._normSub[k];\n                  xNewMul = _dinfo._normMul[k];\n                  off = _dinfo.numStart() + k;\n                  to = off + 1;\n                }\n                double[] currentBeta = Arrays.copyOfRange(_taskInfo._beta, off, to);\n                double[] xy = new GLMCoordinateDescentTask(betaUpdate, currentBeta, xOldSub, xOldMul, xNewSub, xNewMul).doAll(previousVec,currentVec,_taskInfo._eVec,_taskInfo._wVec, _taskInfo._zVec)._xy;\n                for (int j = 0; j < xy.length; ++j) {\n                  betaUpdate = currentBeta;\n                  double updatedCoef = ADMM.shrinkage(xy[j], l1pen) / (1 + l2pen);\n                  betaUpdate[j] = updatedCoef - currentBeta[j];\n                  if (betaUpdate[j] < -1e-4 || betaUpdate[j] > 1e-4)\n                    betaChanges = true;\n                  beta[off + j] = updatedCoef;\n                }\n              }\n            }\n            if(iter > it+1) {\n              betaChanges = true; // beta changed during inner iteration\n              // generate new weights\n              new GLMTask.GLMWeightsTask(_parms).doAll(_dinfo._adaptedFrame.lastVec(), _taskInfo._zVec, _taskInfo._wVec, _taskInfo._eVec);\n            }\n          }\n          // done, compute the gradient and check KKTs\n          break;\n        case ADMM:// fork off ADMM iteration\n          new GLMIterationTask(GLM.this._key, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _parms, false, _taskInfo._beta, _taskInfo._ymu, _rowFilter, new Iteration(this, false)).asyncExec(_activeData._adaptedFrame);\n          return;\n        default:\n          throw H2O.unimpl();\n      }\n      checkKKTsAndComplete();\n      tryComplete();\n    }","commit_id":"eeb3d30cb511a4ae82350c00d0cba7271a55f25b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Test bounds on prostate dataset, 2 cases :\n   *    1) test against known result in glmnet (with elastic net regularization) with elastic net penalty\n   *    2) test with no regularization, check the gradient in the end.\n   */\n  @Test public void testBounds() {\n//    glmnet's result:\n//    res2 <- glmnet(x=M,y=D$CAPSULE,lower.limits=-.5,upper.limits=.5,family='binomial')\n//    res2$beta[,58]\n//    AGE        RACE          DPROS       PSA         VOL         GLEASON\n//    -0.00616326 -0.50000000  0.50000000  0.03628192 -0.01249324  0.50000000 //    res2$a0[100]\n//    res2$a0[58]\n//    s57\n//    -4.155864\n//    lambda = 0.001108, null dev =  512.2888, res dev = 379.7597\n    GLMModel model = null;\n\n    Key parsed = Key.make(\"prostate_parsed\");\n    Key modelKey = Key.make(\"prostate_model\");\n\n    Frame fr = parse_test_file(parsed, \"smalldata/logreg/prostate.csv\");\n    Key betaConsKey = Key.make(\"beta_constraints\");\n\n    String[] cfs1 = new String[]{\"AGE\", \"RACE\", \"DPROS\", \"DCAPS\", \"PSA\", \"VOL\", \"GLEASON\", \"Intercept\"};\n    double[] vals = new double[]{-0.006502588, -0.500000000,  0.500000000,  0.400000000,  0.034826559, -0.011661747,  0.500000000, -4.564024 };\n\n//    [AGE, RACE, DPROS, DCAPS, PSA, VOL, GLEASON, Intercept]\n    FVecTest.makeByteVec(betaConsKey, \"names, lower_bounds, upper_bounds\\n AGE, -.5, .5\\n RACE, -.5, .5\\n DCAPS, -.4, .4\\n DPROS, -.5, .5 \\nPSA, -.5, .5\\n VOL, -.5, .5\\nGLEASON, -.5, .5\");\n    Frame betaConstraints = ParseDataset.parse(Key.make(\"beta_constraints.hex\"), new Key[]{betaConsKey});\n\n    try {\n      // H2O differs on intercept and race, same residual deviance though\n      GLMParameters params = new GLMParameters();\n      params._standardize = true;\n      params._family = Family.binomial;\n      params._beta_constraint = betaConstraints._key;\n      params._response_column = \"CAPSULE\";\n      params._ignored_columns = new String[]{\"ID\"};\n      params._train = fr._key;\n      params._alpha = new double[]{1};\n      params._lambda = new double[]{0.001607};\n      GLM job = new GLM(modelKey, \"glm test simple poisson\", params);\n      job.trainModel().get();\n      assertTrue(job.isDone());\n      model = DKV.get(modelKey).get();\n      Map<String, Double> coefs =  model.coefficients();\n      for (int i = 0; i < cfs1.length; ++i)\n        assertEquals(vals[i], coefs.get(cfs1[i]), 1e-2);\n      GLMValidation val = model.validation();\n      System.out.println(\"val = \" + val);\n      assertEquals(512.2888, val.nullDeviance(), 1e-1);\n                // 388.4952716196743\n      assertEquals(388.4686, val.residualDeviance(),1e-1);\n      model.delete();\n      params._lambda = new double[]{0};\n      params._alpha = new double[]{0};\n      FVecTest.makeByteVec(betaConsKey, \"names, lower_bounds, upper_bounds\\n RACE, -.5, .5\\n DCAPS, -.4, .4\\n DPROS, -.5, .5 \\nPSA, -.5, .5\\n VOL, -.5, .5\");\n      betaConstraints = ParseDataset.parse(Key.make(\"beta_constraints.hex\"), new Key[]{betaConsKey});\n      job = new GLM(modelKey, \"glm test simple poisson\", params);\n      job.trainModel().get();\n      assertTrue(job.isDone());\n      model = DKV.get(modelKey).get();\n      double [] beta = model.beta();\n      System.out.println(\"beta = \" + Arrays.toString(beta));\n      fr.add(\"CAPSULE\", fr.remove(\"CAPSULE\"));\n      fr.remove(\"ID\").remove();\n      DKV.put(fr._key,fr);\n      // now check the gradient\n      DataInfo dinfo = new DataInfo(Key.make(),fr, null, 1, true, TransformType.NONE, DataInfo.TransformType.NONE, true);\n      // todo: remove, result from h2o.1\n      // beta = new double[]{0.06644411112189823, -0.11172826074033719, 9.77360531534266, -9.972691681370678, 0.24664516432994327, -0.12369381230741447, 0.11330593275731994, -19.64465932744036};\n      LBFGS_LogisticGradientTask lt = (LBFGS_LogisticGradientTask)new LBFGS_LogisticGradientTask(dinfo,params,0,beta,1.0/380.0, null).doAll(dinfo._adaptedFrame);\n      double [] grad = lt._gradient;\n      String [] names = model._dinfo.coefNames();\n      System.out.println(\"coefs = \" + Arrays.toString(names));\n      System.out.println(\"grad = \" + Arrays.toString(grad));\n      ValueString vs = new ValueString();\n      outer:\n      for(int i = 0; i < names.length; ++i){\n        for(int j = 0; j < betaConstraints.numRows();++j) {\n          if(betaConstraints.vec(\"names\").atStr(vs,j).toString().equals(names[i])) {\n            if(Math.abs(beta[i] - betaConstraints.vec(\"lower_bounds\").at(j)) < 1e-4 || Math.abs(beta[i] - betaConstraints.vec(\"upper_bounds\").at(j)) < 1e-4) {\n              continue outer;\n            }\n          }\n        }\n        assertEquals(0,grad[i],1e-2);\n      }\n    } finally {\n      fr.delete();\n      betaConstraints.delete();\n      if(model != null)model.delete();\n    }\n  }","id":72457,"modified_method":"/**\n   * Test bounds on prostate dataset, 2 cases :\n   *    1) test against known result in glmnet (with elastic net regularization) with elastic net penalty\n   *    2) test with no regularization, check the gradient in the end.\n   */\n  @Test public void testBounds() {\n//    glmnet's result:\n//    res2 <- glmnet(x=M,y=D$CAPSULE,lower.limits=-.5,upper.limits=.5,family='binomial')\n//    res2$beta[,58]\n//    AGE        RACE          DPROS       PSA         VOL         GLEASON\n//    -0.00616326 -0.50000000  0.50000000  0.03628192 -0.01249324  0.50000000 //    res2$a0[100]\n//    res2$a0[58]\n//    s57\n//    -4.155864\n//    lambda = 0.001108, null dev =  512.2888, res dev = 379.7597\n    GLMModel model = null;\n\n    Key parsed = Key.make(\"prostate_parsed\");\n    Key modelKey = Key.make(\"prostate_model\");\n\n    Frame fr = parse_test_file(parsed, \"smalldata/logreg/prostate.csv\");\n    Key betaConsKey = Key.make(\"beta_constraints\");\n\n    String[] cfs1 = new String[]{\"AGE\", \"RACE\", \"DPROS\", \"DCAPS\", \"PSA\", \"VOL\", \"GLEASON\", \"Intercept\"};\n    double[] vals = new double[]{-0.006502588, -0.500000000,  0.500000000,  0.400000000,  0.034826559, -0.011661747,  0.500000000, -4.564024 };\n\n//    [AGE, RACE, DPROS, DCAPS, PSA, VOL, GLEASON, Intercept]\n    FVecTest.makeByteVec(betaConsKey, \"names, lower_bounds, upper_bounds\\n AGE, -.5, .5\\n RACE, -.5, .5\\n DCAPS, -.4, .4\\n DPROS, -.5, .5 \\nPSA, -.5, .5\\n VOL, -.5, .5\\nGLEASON, -.5, .5\");\n    Frame betaConstraints = ParseDataset.parse(Key.make(\"beta_constraints.hex\"), new Key[]{betaConsKey});\n\n    try {\n      // H2O differs on intercept and race, same residual deviance though\n      GLMParameters params = new GLMParameters();\n      params._standardize = true;\n      params._family = Family.binomial;\n      params._beta_constraint = betaConstraints._key;\n      params._response_column = \"CAPSULE\";\n      params._ignored_columns = new String[]{\"ID\"};\n      params._train = fr._key;\n      params._alpha = new double[]{1};\n      params._lambda = new double[]{0.001607};\n      GLM job = new GLM(modelKey, \"glm test simple poisson\", params);\n      job.trainModel().get();\n      assertTrue(job.isDone());\n      model = DKV.get(modelKey).get();\n//      Map<String, Double> coefs =  model.coefficients();\n//      for (int i = 0; i < cfs1.length; ++i)\n//        assertEquals(vals[i], coefs.get(cfs1[i]), 1e-1);\n      GLMValidation val = model.validation();\n      System.out.println(\"val = \" + val);\n      assertEquals(512.2888, val.nullDeviance(), 1e-1);\n                // 388.4952716196743\n      assertEquals(388.4686, val.residualDeviance(),1e-1);\n      model.delete();\n      params._lambda = new double[]{0};\n      params._alpha = new double[]{0};\n      FVecTest.makeByteVec(betaConsKey, \"names, lower_bounds, upper_bounds\\n RACE, -.5, .5\\n DCAPS, -.4, .4\\n DPROS, -.5, .5 \\nPSA, -.5, .5\\n VOL, -.5, .5\");\n      betaConstraints = ParseDataset.parse(Key.make(\"beta_constraints.hex\"), new Key[]{betaConsKey});\n      job = new GLM(modelKey, \"glm test simple poisson\", params);\n      job.trainModel().get();\n      assertTrue(job.isDone());\n      model = DKV.get(modelKey).get();\n      double [] beta = model.beta();\n      System.out.println(\"beta = \" + Arrays.toString(beta));\n      fr.add(\"CAPSULE\", fr.remove(\"CAPSULE\"));\n      fr.remove(\"ID\").remove();\n      DKV.put(fr._key,fr);\n      // now check the gradient\n      DataInfo dinfo = new DataInfo(Key.make(),fr, null, 1, true, TransformType.NONE, DataInfo.TransformType.NONE, true);\n      // todo: remove, result from h2o.1\n      // beta = new double[]{0.06644411112189823, -0.11172826074033719, 9.77360531534266, -9.972691681370678, 0.24664516432994327, -0.12369381230741447, 0.11330593275731994, -19.64465932744036};\n      LBFGS_LogisticGradientTask lt = (LBFGS_LogisticGradientTask)new LBFGS_LogisticGradientTask(dinfo,params,0,beta,1.0/380.0, null).doAll(dinfo._adaptedFrame);\n      double [] grad = lt._gradient;\n      String [] names = model._dinfo.coefNames();\n      System.out.println(\"coefs = \" + Arrays.toString(names));\n      System.out.println(\"grad = \" + Arrays.toString(grad));\n      ValueString vs = new ValueString();\n      outer:\n      for(int i = 0; i < names.length; ++i){\n        for(int j = 0; j < betaConstraints.numRows();++j) {\n          if(betaConstraints.vec(\"names\").atStr(vs,j).toString().equals(names[i])) {\n            if(Math.abs(beta[i] - betaConstraints.vec(\"lower_bounds\").at(j)) < 1e-4 || Math.abs(beta[i] - betaConstraints.vec(\"upper_bounds\").at(j)) < 1e-4) {\n              continue outer;\n            }\n          }\n        }\n        assertEquals(0,grad[i],1e-2);\n      }\n    } finally {\n      fr.delete();\n      betaConstraints.delete();\n      if(model != null)model.delete();\n    }\n  }","commit_id":"eeb3d30cb511a4ae82350c00d0cba7271a55f25b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Test strong rules on arcene datasets (10k predictors, 100 rows).\n   * Should be able to obtain good model (~100 predictors, ~1 explained deviance) with up to 250 active predictors.\n   * Scaled down (higher lambda min, fewer lambdas) to run at reasonable speed (whole test takes 20s on my laptop).\n   *\n   * Test runs glm with gaussian on arcene dataset and verifies it gets all lambda while limiting maximum actove predictors to reasonably small number.\n   * Compares the objective value to expected one.\n   */\n  @Test public void testArcene() throws InterruptedException, ExecutionException{\n    GLM job = null;\n    Key parsed = Key.make(\"arcene_parsed\");\n    Key modelKey = Key.make(\"arcene_model\");\n    GLMModel model = null;\n    Frame fr = parse_test_file(parsed, \"smalldata/glm_test/arcene.csv\");\n    try{\n      Scope.enter();\n      GLMParameters params = new GLMParameters(Family.gaussian);\n      // params._response = 0;\n      params._lambda = null;\n      params._response_column = fr._names[0];\n      params._train = parsed;\n      params._lambda_search = true;\n      params._nlambdas = 35;\n      params._lambda_min_ratio = 0.18;\n      params._max_active_predictors = 215;\n      params._alpha = new double[]{1};\n      job = new GLM(modelKey,\"glm test simple poisson\",params);\n      job.trainModel().get();\n      model = DKV.get(modelKey).get();\n      // assert on that we got all submodels (if strong rules work, we should be able to get the results with this many active predictors)\n      assertEquals(params._nlambdas,model._output._submodels.length);\n      GLMValidation val = model.validation();\n      // assert on the quality of the result, technically should compare objective value, but this should be good enough for now\n      model._output.setSubmodelIdx(model._output._submodels.length-1);\n      Submodel sm = model._output._submodels[model._output._best_lambda_idx];\n      double l1norm = 0;\n      for(double d:sm.norm_beta) l1norm += Math.abs(d);\n      double objval = sm.trainVal.residual_deviance / sm.trainVal.nobs + sm.lambda_value*l1norm;\n      assertEquals(0.32922849120947384,objval,1e-3);\n      // test scoring on several submodels\n      GLMModel m = new GetScoringModelTask(null,model._key,sm.lambda_value).invokeTask()._res;\n      Frame score = m.score(fr);\n      MSETsk mse = new MSETsk().doAll(score.anyVec(), fr.vec(m._output.responseName()));\n      assertEquals(val.residualDeviance(),mse._resDev,1e-6);\n      score.remove();\n      // try scoring another model\n      model._output.setSubmodelIdx(model._output._submodels.length>>1);\n      sm = model._output._submodels[model._output._best_lambda_idx];\n      val = model._output._submodels[model._output._best_lambda_idx].trainVal;\n      m = new GetScoringModelTask(null,model._key,sm.lambda_value).invokeTask()._res;\n      score = m.score(fr);\n      mse = new MSETsk().doAll(score.anyVec(), fr.vec(m._output.responseName()));\n      assertEquals(val.residualDeviance(),mse._resDev,1e-6);\n      score.remove();\n      job.remove();\n\n      // test behavior when we can not fit within the active cols limit (should just bail out early and give us whatever it got)\n      params = new GLMParameters(Family.gaussian);\n      // params._response = 0;\n      params._lambda = null;\n      params._response_column = fr._names[0];\n      params._train = parsed;\n      params._lambda_search = true;\n      params._nlambdas = 35;\n      params._lambda_min_ratio = 0.18;\n      params._max_active_predictors = 20;\n      params._alpha = new double[]{1};\n      job = new GLM(modelKey,\"glm test simple poisson\",params);\n      job.trainModel().get();\n      model = DKV.get(modelKey).get();\n      assertTrue(model._output._submodels.length > 3);\n      assertTrue(model.validation().residualDeviance() <= 93);\n    } finally {\n      fr.delete();\n      if(model != null)model.delete();\n      if( job != null ) job.remove();\n      Scope.exit();\n    }\n  }","id":72458,"modified_method":"/**\n   * Test strong rules on arcene datasets (10k predictors, 100 rows).\n   * Should be able to obtain good model (~100 predictors, ~1 explained deviance) with up to 250 active predictors.\n   * Scaled down (higher lambda min, fewer lambdas) to run at reasonable speed (whole test takes 20s on my laptop).\n   *\n   * Test runs glm with gaussian on arcene dataset and verifies it gets all lambda while limiting maximum actove predictors to reasonably small number.\n   * Compares the objective value to expected one.\n   */\n  @Test public void testArcene() throws InterruptedException, ExecutionException{\n    GLM job = null;\n    Key parsed = Key.make(\"arcene_parsed\");\n    Key modelKey = Key.make(\"arcene_model\");\n    GLMModel model = null;\n    Frame fr = parse_test_file(parsed, \"smalldata/glm_test/arcene.csv\");\n    try{\n      Scope.enter();\n      GLMParameters params = new GLMParameters(Family.gaussian);\n      // params._response = 0;\n      params._lambda = null;\n      params._response_column = fr._names[0];\n      params._train = parsed;\n      params._lambda_search = true;\n      params._nlambdas = 35;\n      params._lambda_min_ratio = 0.18;\n      params._max_active_predictors = 215;\n      params._alpha = new double[]{1};\n      for(Solver s: new Solver[]{Solver.L_BFGS, Solver.ADMM}) {\n        params._solver = s;\n        job = new GLM(modelKey, \"glm test simple poisson\", params);\n        job.trainModel().get();\n        model = DKV.get(modelKey).get();\n        // assert on that we got all submodels (if strong rules work, we should be able to get the results with this many active predictors)\n        assertEquals(params._nlambdas, model._output._submodels.length);\n        GLMValidation val = model.validation();\n        // assert on the quality of the result, technically should compare objective value, but this should be good enough for now\n        model._output.setSubmodelIdx(model._output._submodels.length - 1);\n        Submodel sm = model._output._submodels[model._output._best_lambda_idx];\n        double l1norm = 0;\n        for (double d : sm.norm_beta) l1norm += Math.abs(d);\n        double objval = sm.trainVal.residual_deviance / sm.trainVal.nobs + sm.lambda_value * l1norm;\n        assertEquals(0.32922849120947384, objval, 1e-3);\n        // test scoring on several submodels\n        GLMModel m = new GetScoringModelTask(null, model._key, sm.lambda_value).invokeTask()._res;\n        Frame score = m.score(fr);\n        MSETsk mse = new MSETsk().doAll(score.anyVec(), fr.vec(m._output.responseName()));\n        assertEquals(val.residualDeviance(), mse._resDev, 1e-6);\n        score.remove();\n        // try scoring another model\n        model._output.setSubmodelIdx(model._output._submodels.length >> 1);\n        sm = model._output._submodels[model._output._best_lambda_idx];\n        val = model._output._submodels[model._output._best_lambda_idx].trainVal;\n        m = new GetScoringModelTask(null, model._key, sm.lambda_value).invokeTask()._res;\n        score = m.score(fr);\n        mse = new MSETsk().doAll(score.anyVec(), fr.vec(m._output.responseName()));\n        assertEquals(val.residualDeviance(), mse._resDev, 1e-6);\n        score.remove();\n        job.remove();\n      }\n\n      // test behavior when we can not fit within the active cols limit (should just bail out early and give us whatever it got)\n      params = new GLMParameters(Family.gaussian);\n      // params._response = 0;\n      params._lambda = null;\n      params._response_column = fr._names[0];\n      params._train = parsed;\n      params._lambda_search = true;\n      params._nlambdas = 35;\n      params._lambda_min_ratio = 0.18;\n      params._max_active_predictors = 20;\n      params._alpha = new double[]{1};\n      job = new GLM(modelKey,\"glm test simple poisson\",params);\n      job.trainModel().get();\n      model = DKV.get(modelKey).get();\n      assertTrue(model._output._submodels.length > 3);\n      assertTrue(model.validation().residualDeviance() <= 93);\n    } finally {\n      fr.delete();\n      if(model != null)model.delete();\n      if( job != null ) job.remove();\n      Scope.exit();\n    }\n  }","commit_id":"eeb3d30cb511a4ae82350c00d0cba7271a55f25b","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void run() {\n            try {\n                if(cancelled || (future != null && future.isCancelled()))\n                    return;\n                task.run();\n            }\n            catch(Throwable t) {\n                log.error(\"failed running task \" + task, t);\n            }\n            if(cancelled && future != null)\n                future.cancel(true);\n            if(future != null && !future.isCancelled()) {\n                doSchedule();\n            }\n        }","id":72459,"modified_method":"public void run() {\n            try {\n                if(cancelled) {\n                    if(future != null)\n                        future.cancel(true);\n                    return;\n                }\n                if(future != null && future.isCancelled())\n                    return;\n                task.run();\n            }\n            catch(Throwable t) {\n                log.error(\"failed running task \" + task, t);\n            }\n\n            if(cancelled) {\n                if(future != null)\n                    future.cancel(true);\n                return;\n            }\n            if(future != null && future.isCancelled())\n                return;\n            \n            doSchedule();\n        }","commit_id":"74fe981d973432147588726763bff1cac80c42a8","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean cancel(boolean mayInterruptIfRunning) {\n            cancelled=true;\n            return future != null && future.cancel(mayInterruptIfRunning);\n        }","id":72460,"modified_method":"public boolean cancel(boolean mayInterruptIfRunning) {\n            cancelled=true;\n            if(future != null)\n                future.cancel(mayInterruptIfRunning);\n            return cancelled;\n        }","commit_id":"74fe981d973432147588726763bff1cac80c42a8","url":"https://github.com/belaban/JGroups"},{"original_method":"public void doSchedule() {\n            long next_interval=task.nextInterval();\n            if(next_interval <= 0) {\n                if(log.isTraceEnabled())\n                    log.trace(\"task will not get rescheduled as interval is \" + next_interval);\n            }\n            else {\n                future=schedule(this, next_interval, TimeUnit.MILLISECONDS);\n            }\n        }","id":72461,"modified_method":"public void doSchedule() {\n            long next_interval=task.nextInterval();\n            if(next_interval <= 0) {\n                if(log.isTraceEnabled())\n                    log.trace(\"task will not get rescheduled as interval is \" + next_interval);\n                System.out.println(\"task will not get rescheduled as interval is \" + next_interval);\n            }\n            else {\n                future=schedule(this, next_interval, TimeUnit.MILLISECONDS);\n                if(cancelled)\n                    future.cancel(true);\n            }\n        }","commit_id":"74fe981d973432147588726763bff1cac80c42a8","url":"https://github.com/belaban/JGroups"},{"original_method":"public void doSchedule() {\n            long next_interval=task.nextInterval();\n            if(next_interval <= 0) {\n                if(log.isTraceEnabled())\n                    log.trace(\"task will not get rescheduled as interval is \" + next_interval);\n            }\n            else {\n                future=schedule(this, next_interval, TimeUnit.MILLISECONDS);\n            }\n        }","id":72462,"modified_method":"public void doSchedule() {\n            long next_interval=task.nextInterval();\n            if(next_interval <= 0) {\n                if(log.isTraceEnabled())\n                    log.trace(\"task will not get rescheduled as interval is \" + next_interval);\n                System.out.println(\"task will not get rescheduled as interval is \" + next_interval);\n            }\n            else {\n                future=schedule(this, next_interval, TimeUnit.MILLISECONDS);\n                if(cancelled)\n                    future.cancel(true);\n            }\n        }","commit_id":"88781687663ee35b76ab5ebef9e48fec92d7edaf","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            try {\n                if(cancelled || (future != null && future.isCancelled()))\n                    return;\n                task.run();\n            }\n            catch(Throwable t) {\n                log.error(\"failed running task \" + task, t);\n            }\n            if(cancelled && future != null)\n                future.cancel(true);\n            if(future != null && !future.isCancelled()) {\n                doSchedule();\n            }\n        }","id":72463,"modified_method":"public void run() {\n            try {\n                if(cancelled) {\n                    if(future != null)\n                        future.cancel(true);\n                    return;\n                }\n                if(future != null && future.isCancelled())\n                    return;\n                task.run();\n            }\n            catch(Throwable t) {\n                log.error(\"failed running task \" + task, t);\n            }\n\n            if(cancelled) {\n                if(future != null)\n                    future.cancel(true);\n                return;\n            }\n            if(future != null && future.isCancelled())\n                return;\n            \n            doSchedule();\n        }","commit_id":"88781687663ee35b76ab5ebef9e48fec92d7edaf","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean cancel(boolean mayInterruptIfRunning) {\n            cancelled=true;\n            return future != null && future.cancel(mayInterruptIfRunning);\n        }","id":72464,"modified_method":"public boolean cancel(boolean mayInterruptIfRunning) {\n            cancelled=true;\n            if(future != null)\n                future.cancel(mayInterruptIfRunning);\n            return cancelled;\n        }","commit_id":"88781687663ee35b76ab5ebef9e48fec92d7edaf","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Return the final status of the fetch. Throws an exception, or returns a \n\t * Bucket containing the fetched data.\n\t * @throws FetchException If the fetch failed for some reason.\n\t */\n\tprivate Bucket finalStatus(ObjectContainer container, ClientContext context) throws FetchException {\n\t\tlong finalLength = 0;\n\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\tSplitFileFetcherSegment s = segments[i];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(s, 1);\n\t\t\tif(!s.isFinished()) throw new IllegalStateException(\"Not all finished\");\n\t\t\ts.throwError();\n\t\t\t// If still here, it succeeded\n\t\t\tfinalLength += s.decodedLength();\n\t\t\t// Healing is done by Segment\n\t\t}\n\t\tif(finalLength > overrideLength) {\n\t\t\tif(finalLength - overrideLength > CHKBlock.DATA_LENGTH)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile is \"+finalLength+\" but length is \"+finalLength);\n\t\t\tfinalLength = overrideLength;\n\t\t}\n\t\t\n\t\tlong bytesWritten = 0;\n\t\tOutputStream os = null;\n\t\tBucket output;\n\t\ttry {\n\t\t\tif((returnBucket != null) && decompressors.isEmpty())\n\t\t\t\toutput = returnBucket;\n\t\t\telse\n\t\t\t\toutput = context.getBucketFactory(parent.persistent()).makeBucket(finalLength);\n\t\t\tos = output.getOutputStream();\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\tSplitFileFetcherSegment s = segments[i];\n\t\t\t\tlong max = (finalLength < 0 ? 0 : (finalLength - bytesWritten));\n\t\t\t\tbytesWritten += s.writeDecodedDataTo(os, max);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t} finally {\n\t\t\tif(os != null) {\n\t\t\t\ttry {\n\t\t\t\t\tos.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// If it fails to close it may return corrupt data.\n\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}","id":72465,"modified_method":"/** Return the final status of the fetch. Throws an exception, or returns a \n\t * Bucket containing the fetched data.\n\t * @throws FetchException If the fetch failed for some reason.\n\t */\n\tprivate Bucket finalStatus(ObjectContainer container, ClientContext context) throws FetchException {\n\t\tlong finalLength = 0;\n\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\tSplitFileFetcherSegment s = segments[i];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(s, 1);\n\t\t\tif(!s.succeeded()) {\n\t\t\t\tthrow new IllegalStateException(\"Not all finished\");\n\t\t\t}\n\t\t\ts.throwError();\n\t\t\t// If still here, it succeeded\n\t\t\tfinalLength += s.decodedLength();\n\t\t\t// Healing is done by Segment\n\t\t}\n\t\tif(finalLength > overrideLength) {\n\t\t\tif(finalLength - overrideLength > CHKBlock.DATA_LENGTH)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile is \"+finalLength+\" but length is \"+finalLength);\n\t\t\tfinalLength = overrideLength;\n\t\t}\n\t\t\n\t\tlong bytesWritten = 0;\n\t\tOutputStream os = null;\n\t\tBucket output;\n\t\ttry {\n\t\t\tif((returnBucket != null) && decompressors.isEmpty())\n\t\t\t\toutput = returnBucket;\n\t\t\telse\n\t\t\t\toutput = context.getBucketFactory(parent.persistent()).makeBucket(finalLength);\n\t\t\tos = output.getOutputStream();\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\tSplitFileFetcherSegment s = segments[i];\n\t\t\t\tlong max = (finalLength < 0 ? 0 : (finalLength - bytesWritten));\n\t\t\t\tbytesWritten += s.writeDecodedDataTo(os, max);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t} finally {\n\t\t\tif(os != null) {\n\t\t\t\ttry {\n\t\t\t\t\tos.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// If it fails to close it may return corrupt data.\n\t\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"public void segmentFinished(SplitFileFetcherSegment segment, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Finished segment: \"+segment);\n\t\tboolean finish = false;\n\t\tsynchronized(this) {\n\t\t\tboolean allDone = true;\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(segments[i], 1);\n\t\t\t\tif(!segments[i].isFinished()) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Segment \"+segments[i]+\" is not finished\");\n\t\t\t\t\tallDone = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(allDone) {\n\t\t\t\tif(allSegmentsFinished) {\n\t\t\t\t\tLogger.error(this, \"Was already finished! (segmentFinished(\"+segment+ ')', new Exception(\"debug\"));\n\t\t\t\t} else {\n\t\t\t\t\tallSegmentsFinished = true;\n\t\t\t\t\tfinish = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\t\tif(segments[i] == segment) continue;\n\t\t\t\t\tcontainer.deactivate(segments[i], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnotifyAll();\n\t\t}\n\t\tif(persistent) container.set(this);\n\t\tif(finish) finish(container, context);\n\t}","id":72466,"modified_method":"public void segmentFinished(SplitFileFetcherSegment segment, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Finished segment: \"+segment);\n\t\tboolean finish = false;\n\t\tsynchronized(this) {\n\t\t\tboolean allDone = true;\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(segments[i], 1);\n\t\t\t\tif(!segments[i].isFinished(container)) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Segment \"+segments[i]+\" is not finished\");\n\t\t\t\t\tallDone = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(allDone) {\n\t\t\t\tif(allSegmentsFinished) {\n\t\t\t\t\tLogger.error(this, \"Was already finished! (segmentFinished(\"+segment+ ')', new Exception(\"debug\"));\n\t\t\t\t} else {\n\t\t\t\t\tallSegmentsFinished = true;\n\t\t\t\t\tfinish = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\t\tif(segments[i] == segment) continue;\n\t\t\t\t\tcontainer.deactivate(segments[i], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnotifyAll();\n\t\t}\n\t\tif(persistent) container.set(this);\n\t\tif(finish) finish(container, context);\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Double-check whether we need to remove a subsegment, and if so, remove it.\n\t * We need to do the check because there is no point removing the subsegment until all\n\t * its running requests have been removed (since request data structures will refer to it\n\t * anyway), and all the requests on the cooldown queue for it have been removed. In either\n\t * case we get duplicated structures in memory.\n\t * @return True if we removed the subsegment.\n\t */\n\tpublic synchronized boolean maybeRemoveSeg(SplitFileFetcherSubSegment segment) {\n\t\tint retryCount = segment.retryCount;\n\t\tboolean dontRemove = true;\n\t\tfor(int i=0;i<dataRetries.length;i++)\n\t\t\tif(dataRetries[i] == retryCount) {\n\t\t\t\tdontRemove = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(int i=0;i<checkRetries.length;i++)\n\t\t\tif(checkRetries[i] == retryCount) {\n\t\t\t\tdontRemove = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(isFinishing()) dontRemove = false;\n\t\tif(dontRemove) return false;\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Removing sub segment: \"+segment+\" for retry count \"+retryCount);\n\t\tfor(int i=0;i<subSegments.size();i++) {\n\t\t\tif(segment.equals(subSegments.get(i))) {\n\t\t\t\tsubSegments.remove(i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":72467,"modified_method":"/**\n\t * Double-check whether we need to remove a subsegment, and if so, remove it.\n\t * We need to do the check because there is no point removing the subsegment until all\n\t * its running requests have been removed (since request data structures will refer to it\n\t * anyway), and all the requests on the cooldown queue for it have been removed. In either\n\t * case we get duplicated structures in memory.\n\t * @return True if we removed the subsegment.\n\t */\n\tpublic synchronized boolean maybeRemoveSeg(SplitFileFetcherSubSegment segment, ObjectContainer container) {\n\t\tint retryCount = segment.retryCount;\n\t\tboolean dontRemove = true;\n\t\tfor(int i=0;i<dataRetries.length;i++)\n\t\t\tif(dataRetries[i] == retryCount) {\n\t\t\t\tdontRemove = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(int i=0;i<checkRetries.length;i++)\n\t\t\tif(checkRetries[i] == retryCount) {\n\t\t\t\tdontRemove = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(isFinishing(container)) dontRemove = false;\n\t\tif(dontRemove) return false;\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Removing sub segment: \"+segment+\" for retry count \"+retryCount);\n\t\tfor(int i=0;i<subSegments.size();i++) {\n\t\t\tif(segment.equals(subSegments.get(i))) {\n\t\t\t\tsubSegments.remove(i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"/** This is after any retries and therefore is either out-of-retries or fatal \n\t * @param container */\n\tpublic synchronized void onFatalFailure(FetchException e, int blockNo, SplitFileFetcherSubSegment seg, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Permanently failed block: \"+blockNo+\" on \"+this+\" : \"+e, e);\n\t\tboolean allFailed;\n\t\t// Since we can't keep the key, we need to unregister for it at this point to avoid a memory leak\n\t\tNodeCHK key = getBlockNodeKey(blockNo, container);\n\t\tif(key != null) seg.unregisterKey(key, context);\n\t\tsynchronized(this) {\n\t\t\tif(isFinishing()) return; // this failure is now irrelevant, and cleanup will occur on the decoder thread\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tif(dataKeys[blockNo] == null) {\n\t\t\t\t\tLogger.error(this, \"Block already finished: \"+blockNo);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdataKeys[blockNo] = null;\n\t\t\t} else if(blockNo < checkKeys.length + dataKeys.length) {\n\t\t\t\tif(checkKeys[blockNo-dataKeys.length] == null) {\n\t\t\t\t\tLogger.error(this, \"Check block already finished: \"+blockNo);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcheckKeys[blockNo-dataKeys.length] = null;\n\t\t\t} else\n\t\t\t\tLogger.error(this, \"Unrecognized block number: \"+blockNo, new Exception(\"error\"));\n\t\t\t// :(\n\t\t\tif(e.isFatal()) {\n\t\t\t\tfatallyFailedBlocks++;\n\t\t\t\tparentFetcher.parent.fatallyFailedBlock(container, context);\n\t\t\t} else {\n\t\t\t\tfailedBlocks++;\n\t\t\t\tparentFetcher.parent.failedBlock(container, context);\n\t\t\t}\n\t\t\t// Once it is no longer possible to have a successful fetch, fail...\n\t\t\tallFailed = failedBlocks + fatallyFailedBlocks > (dataKeys.length + checkKeys.length - minFetched);\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tif(allFailed)\n\t\t\tfail(new FetchException(FetchException.SPLITFILE_ERROR, errors), container, context);\n\t\telse\n\t\t\tseg.possiblyRemoveFromParent(container);\n\t}","id":72468,"modified_method":"/** This is after any retries and therefore is either out-of-retries or fatal \n\t * @param container */\n\tpublic synchronized void onFatalFailure(FetchException e, int blockNo, SplitFileFetcherSubSegment seg, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Permanently failed block: \"+blockNo+\" on \"+this+\" : \"+e, e);\n\t\tboolean allFailed;\n\t\t// Since we can't keep the key, we need to unregister for it at this point to avoid a memory leak\n\t\tNodeCHK key = getBlockNodeKey(blockNo, container);\n\t\tif(key != null) seg.unregisterKey(key, context);\n\t\tsynchronized(this) {\n\t\t\tif(isFinishing(container)) return; // this failure is now irrelevant, and cleanup will occur on the decoder thread\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tif(dataKeys[blockNo] == null) {\n\t\t\t\t\tLogger.error(this, \"Block already finished: \"+blockNo);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdataKeys[blockNo] = null;\n\t\t\t} else if(blockNo < checkKeys.length + dataKeys.length) {\n\t\t\t\tif(checkKeys[blockNo-dataKeys.length] == null) {\n\t\t\t\t\tLogger.error(this, \"Check block already finished: \"+blockNo);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcheckKeys[blockNo-dataKeys.length] = null;\n\t\t\t} else\n\t\t\t\tLogger.error(this, \"Unrecognized block number: \"+blockNo, new Exception(\"error\"));\n\t\t\t// :(\n\t\t\tif(e.isFatal()) {\n\t\t\t\tfatallyFailedBlocks++;\n\t\t\t\tparentFetcher.parent.fatallyFailedBlock(container, context);\n\t\t\t} else {\n\t\t\t\tfailedBlocks++;\n\t\t\t\tparentFetcher.parent.failedBlock(container, context);\n\t\t\t}\n\t\t\t// Once it is no longer possible to have a successful fetch, fail...\n\t\t\tallFailed = failedBlocks + fatallyFailedBlocks > (dataKeys.length + checkKeys.length - minFetched);\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tif(allFailed)\n\t\t\tfail(new FetchException(FetchException.SPLITFILE_ERROR, errors), container, context);\n\t\telse\n\t\t\tseg.possiblyRemoveFromParent(container);\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"/** A request has failed non-fatally, so the block may be retried \n\t * @param container */\n\tpublic void onNonFatalFailure(FetchException e, int blockNo, SplitFileFetcherSubSegment seg, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tRequestScheduler sched = context.getFetchScheduler(false);\n\t\tint tries;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tboolean failed = false;\n\t\tboolean cooldown = false;\n\t\tClientCHK key;\n\t\tSplitFileFetcherSubSegment sub = null;\n\t\tsynchronized(this) {\n\t\t\tif(isFinished()) return;\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tkey = dataKeys[blockNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++dataRetries[blockNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(dataCooldownTimes[blockNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" data block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdataCooldownTimes[blockNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint checkNo = blockNo - dataKeys.length;\n\t\t\t\tkey = checkKeys[checkNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++checkRetries[checkNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(checkCooldownTimes[checkNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" check block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcheckCooldownTimes[checkNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tif(failed) {\n\t\t\tonFatalFailure(e, blockNo, seg, container, context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries);\n\t\t\treturn;\n\t\t}\n\t\tif(cooldown) {\n\t\t\t// Register to the next sub-segment before removing from the old one.\n\t\t\tsub.getScheduler(context).addPendingKey(key, sub);\n\t\t\tseg.unregisterKey(key.getNodeKey(), context);\n\t\t} else {\n\t\t\t// If we are here we are going to retry\n\t\t\t// Unregister from the old sub-segment before registering on the new.\n\t\t\tseg.unregisterKey(key.getNodeKey(), context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\tsub.add(blockNo, false, container, context);\n\t\t}\n\t}","id":72469,"modified_method":"/** A request has failed non-fatally, so the block may be retried \n\t * @param container */\n\tpublic void onNonFatalFailure(FetchException e, int blockNo, SplitFileFetcherSubSegment seg, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tRequestScheduler sched = context.getFetchScheduler(false);\n\t\tint tries;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tboolean failed = false;\n\t\tboolean cooldown = false;\n\t\tClientCHK key;\n\t\tSplitFileFetcherSubSegment sub = null;\n\t\tsynchronized(this) {\n\t\t\tif(isFinished(container)) return;\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tkey = dataKeys[blockNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++dataRetries[blockNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(dataCooldownTimes[blockNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" data block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdataCooldownTimes[blockNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint checkNo = blockNo - dataKeys.length;\n\t\t\t\tkey = checkKeys[checkNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++checkRetries[checkNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(checkCooldownTimes[checkNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" check block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcheckCooldownTimes[checkNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tif(failed) {\n\t\t\tonFatalFailure(e, blockNo, seg, container, context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries);\n\t\t\treturn;\n\t\t}\n\t\tif(cooldown) {\n\t\t\t// Register to the next sub-segment before removing from the old one.\n\t\t\tsub.getScheduler(context).addPendingKey(key, sub);\n\t\t\tseg.unregisterKey(key.getNodeKey(), context);\n\t\t} else {\n\t\t\t// If we are here we are going to retry\n\t\t\t// Unregister from the old sub-segment before registering on the new.\n\t\t\tseg.unregisterKey(key.getNodeKey(), context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\tsub.add(blockNo, false, container, context);\n\t\t}\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"public void requeueAfterCooldown(Key key, long time, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tVector v = null;\n\t\tboolean notFound = true;\n\t\tsynchronized(this) {\n\t\tif(isFinishing()) return;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tfor(int i=0;i<dataKeys.length;i++) {\n\t\t\tif(dataKeys[i] == null) continue;\n\t\t\tif(dataKeys[i].getNodeKey().equals(key)) {\n\t\t\t\tif(dataCooldownTimes[i] > time) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not retrying after cooldown for data block \"+i+\"as deadline has not passed yet on \"+this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint tries = dataRetries[i];\n\t\t\t\tSplitFileFetcherSubSegment sub = getSubSegment(tries);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Retrying after cooldown on \"+this+\": data block \"+i+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\t\tif(v == null) v = new Vector();\n\t\t\t\tsub.add(i, true, container, context);\n\t\t\t\tif(!v.contains(sub)) v.add(sub);\n\t\t\t\tnotFound = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<checkKeys.length;i++) {\n\t\t\tif(checkKeys[i] == null) continue;\n\t\t\tif(checkKeys[i].getNodeKey().equals(key)) {\n\t\t\t\tif(checkCooldownTimes[i] > time) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not retrying after cooldown for data block \"+i+\" as deadline has not passed yet on \"+this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint tries = checkRetries[i];\n\t\t\t\tSplitFileFetcherSubSegment sub = getSubSegment(tries);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Retrying after cooldown on \"+this+\": check block \"+i+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\t\tif(v == null) v = new Vector();\n\t\t\t\tsub.add(i+dataKeys.length, true, container, context);\n\t\t\t\tif(!v.contains(sub)) v.add(sub);\n\t\t\t\tnotFound = false;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(notFound) {\n\t\t\tLogger.error(this, \"requeueAfterCooldown: Key not found!: \"+key+\" on \"+this);\n\t\t}\n\t\tif(v != null) {\n\t\t\tfor(int i=0;i<v.size();i++) {\n\t\t\t\t((SplitFileFetcherSubSegment) v.get(i)).schedule(container, context);\n\t\t\t}\n\t\t}\n\t}","id":72470,"modified_method":"public void requeueAfterCooldown(Key key, long time, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tVector v = null;\n\t\tboolean notFound = true;\n\t\tsynchronized(this) {\n\t\tif(isFinishing(container)) return;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tfor(int i=0;i<dataKeys.length;i++) {\n\t\t\tif(dataKeys[i] == null) continue;\n\t\t\tif(dataKeys[i].getNodeKey().equals(key)) {\n\t\t\t\tif(dataCooldownTimes[i] > time) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not retrying after cooldown for data block \"+i+\"as deadline has not passed yet on \"+this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint tries = dataRetries[i];\n\t\t\t\tSplitFileFetcherSubSegment sub = getSubSegment(tries);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Retrying after cooldown on \"+this+\": data block \"+i+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\t\tif(v == null) v = new Vector();\n\t\t\t\tsub.add(i, true, container, context);\n\t\t\t\tif(!v.contains(sub)) v.add(sub);\n\t\t\t\tnotFound = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<checkKeys.length;i++) {\n\t\t\tif(checkKeys[i] == null) continue;\n\t\t\tif(checkKeys[i].getNodeKey().equals(key)) {\n\t\t\t\tif(checkCooldownTimes[i] > time) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not retrying after cooldown for data block \"+i+\" as deadline has not passed yet on \"+this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint tries = checkRetries[i];\n\t\t\t\tSplitFileFetcherSubSegment sub = getSubSegment(tries);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Retrying after cooldown on \"+this+\": check block \"+i+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\t\tif(v == null) v = new Vector();\n\t\t\t\tsub.add(i+dataKeys.length, true, container, context);\n\t\t\t\tif(!v.contains(sub)) v.add(sub);\n\t\t\t\tnotFound = false;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(notFound) {\n\t\t\tLogger.error(this, \"requeueAfterCooldown: Key not found!: \"+key+\" on \"+this);\n\t\t}\n\t\tif(v != null) {\n\t\t\tfor(int i=0;i<v.size();i++) {\n\t\t\t\t((SplitFileFetcherSubSegment) v.get(i)).schedule(container, context);\n\t\t\t}\n\t\t}\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"public void possiblyRemoveFromParent(ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Possibly removing from parent: \"+this);\n\t\tsynchronized(segment) {\n\t\t\tif(!blockNums.isEmpty()) return;\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Definitely removing from parent: \"+this);\n\t\t\tif(!segment.maybeRemoveSeg(this)) return;\n\t\t}\n\t\tunregister(false, container);\n\t}","id":72471,"modified_method":"public void possiblyRemoveFromParent(ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Possibly removing from parent: \"+this);\n\t\tsynchronized(segment) {\n\t\t\tif(!blockNums.isEmpty()) return;\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Definitely removing from parent: \"+this);\n\t\t\tif(!segment.maybeRemoveSeg(this, container)) return;\n\t\t}\n\t\tunregister(false, container);\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"public ClientKey getKey(Object token, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tsynchronized(segment) {\n\t\t\tif(cancelled) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Segment is finishing when getting key \"+token+\" on \"+this);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tClientKey key = segment.getBlockKey(((Integer)token).intValue(), container);\n\t\t\tif(key == null) {\n\t\t\t\tif(segment.isFinished()) {\n\t\t\t\t\tLogger.error(this, \"Segment finished but didn't tell us! \"+this);\n\t\t\t\t} else if(segment.isFinishing()) {\n\t\t\t\t\tLogger.error(this, \"Segment finishing but didn't tell us! \"+this);\n\t\t\t\t} else {\n\t\t\t\t\tLogger.error(this, \"Segment not finishing yet still returns null for getKey()!: \"+token+\" for \"+this, new Exception(\"debug\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn key;\n\t\t}\n\t}","id":72472,"modified_method":"public ClientKey getKey(Object token, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tsynchronized(segment) {\n\t\t\tif(cancelled) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Segment is finishing when getting key \"+token+\" on \"+this);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tClientKey key = segment.getBlockKey(((Integer)token).intValue(), container);\n\t\t\tif(key == null) {\n\t\t\t\tif(segment.isFinished(container)) {\n\t\t\t\t\tLogger.error(this, \"Segment finished but didn't tell us! \"+this);\n\t\t\t\t} else if(segment.isFinishing(container)) {\n\t\t\t\t\tLogger.error(this, \"Segment finishing but didn't tell us! \"+this);\n\t\t\t\t} else {\n\t\t\t\t\tLogger.error(this, \"Segment not finishing yet still returns null for getKey()!: \"+token+\" for \"+this, new Exception(\"debug\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn key;\n\t\t}\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"private Object removeRandomBlockNum(KeysFetchingLocally keys, ClientContext context, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(blockNums, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(segment) {\n\t\t\tif(blockNums.isEmpty()) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"No blocks to remove\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor(int i=0;i<10;i++) {\n\t\t\t\tObject ret;\n\t\t\t\tint x;\n\t\t\t\tx = context.random.nextInt(blockNums.size());\n\t\t\t\tret = (Integer) blockNums.remove(x);\n\t\t\t\tKey key = segment.getBlockNodeKey(((Integer)ret).intValue(), container);\n\t\t\t\tif(key == null) {\n\t\t\t\t\tif(segment.isFinishing() || segment.isFinished()) return null;\n\t\t\t\t\tLogger.error(this, \"Key is null for block \"+ret+\" for \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(keys.hasKey(key)) {\n\t\t\t\t\tblockNums.add(ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Removing block \"+x+\" of \"+(blockNums.size()+1)+ \" : \"+ret+ \" on \"+this);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(blockNums);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}","id":72473,"modified_method":"private Object removeRandomBlockNum(KeysFetchingLocally keys, ClientContext context, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(blockNums, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(segment) {\n\t\t\tif(blockNums.isEmpty()) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"No blocks to remove\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor(int i=0;i<10;i++) {\n\t\t\t\tObject ret;\n\t\t\t\tint x;\n\t\t\t\tx = context.random.nextInt(blockNums.size());\n\t\t\t\tret = (Integer) blockNums.remove(x);\n\t\t\t\tKey key = segment.getBlockNodeKey(((Integer)ret).intValue(), container);\n\t\t\t\tif(key == null) {\n\t\t\t\t\tif(segment.isFinishing(container) || segment.isFinished(container)) return null;\n\t\t\t\t\tLogger.error(this, \"Key is null for block \"+ret+\" for \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(keys.hasKey(key)) {\n\t\t\t\t\tblockNums.add(ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Removing block \"+x+\" of \"+(blockNums.size()+1)+ \" : \"+ret+ \" on \"+this);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(blockNums);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"d96decd41494e159d20f2ad91a8f36083426806b","url":"https://github.com/freenet/fred"},{"original_method":"private Object[] getVariantsImpl(ReferenceKind kind) {\n    PsiManager manager = getManager();\n    switch (kind) {\n      case STATIC_MEMBER_FQ: {\n        final GrCodeReferenceElement qualifier = getQualifier();\n        if (qualifier != null) {\n          final PsiElement resolve = qualifier.resolve();\n          if (resolve instanceof PsiClass) {\n            final PsiClass clazz = (PsiClass) resolve;\n            List<PsiElement> result = new ArrayList<PsiElement>();\n\n            for (PsiField field : clazz.getFields()) {\n              if (field.hasModifierProperty(PsiModifier.STATIC)) {\n                result.add(field);\n              }\n            }\n\n            for (PsiMethod method : clazz.getMethods()) {\n              if (method.hasModifierProperty(PsiModifier.STATIC)) {\n                result.add(method);\n              }\n            }\n\n            return result.toArray(new PsiElement[result.size()]);\n          }\n        }\n      }\n      //fallthrough\n\n      case PACKAGE_FQ:\n      case CLASS_OR_PACKAGE_FQ: {\n        final String refText = PsiUtil.getQualifiedReferenceText(this);\n        final int lastDot = refText.lastIndexOf(\".\");\n        String parentPackageFQName = lastDot > 0 ? refText.substring(0, lastDot) : \"\";\n        final PsiPackage parentPackage = manager.findPackage(parentPackageFQName);\n        if (parentPackage != null) {\n          final GlobalSearchScope scope = getResolveScope();\n          if (kind == PACKAGE_FQ) {\n            return parentPackage.getSubPackages(scope);\n          } else {\n            final PsiPackage[] subpackages = parentPackage.getSubPackages(scope);\n            final PsiClass[] classes = parentPackage.getClasses(scope);\n            PsiElement[] result = new PsiElement[subpackages.length + classes.length];\n            System.arraycopy(subpackages, 0, result, 0, subpackages.length);\n            System.arraycopy(classes, 0, result, subpackages.length, classes.length);\n            return result;\n          }\n        }\n      }\n\n      case CLASS_OR_PACKAGE:\n      case CLASS: {\n        GrCodeReferenceElement qualifier = getQualifier();\n        if (qualifier != null) {\n          PsiElement qualifierResolved = qualifier.resolve();\n          if (qualifierResolved instanceof PsiPackage) {\n            PsiPackage aPackage = (PsiPackage) qualifierResolved;\n            PsiClass[] classes = aPackage.getClasses();\n            if (kind == CLASS) return classes;\n            PsiPackage[] subpackages = aPackage.getSubPackages();\n            return ArrayUtil.mergeArrays(classes, subpackages, Object.class);\n          } else if (qualifierResolved instanceof PsiClass) {\n            return ((PsiClass) qualifierResolved).getInnerClasses();\n          }\n        } else {\n          ResolverProcessor processor = CompletionProcessor.createClassCompletionProcessor(this);\n          ResolveUtil.treeWalkUp(this, processor);\n          return GroovyCompletionUtil.getCompletionVariants(processor.getCandidates());\n        }\n      }\n    }\n\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","id":72474,"modified_method":"private Object[] getVariantsImpl(ReferenceKind kind) {\n    PsiManager manager = getManager();\n    switch (kind) {\n      case STATIC_MEMBER_FQ: {\n        final GrCodeReferenceElement qualifier = getQualifier();\n        if (qualifier != null) {\n          final PsiElement resolve = qualifier.resolve();\n          if (resolve instanceof PsiClass) {\n            final PsiClass clazz = (PsiClass) resolve;\n            List<PsiElement> result = new ArrayList<PsiElement>();\n\n            for (PsiField field : clazz.getFields()) {\n              if (field.hasModifierProperty(PsiModifier.STATIC)) {\n                result.add(field);\n              }\n            }\n\n            for (PsiMethod method : clazz.getMethods()) {\n              if (method.hasModifierProperty(PsiModifier.STATIC)) {\n                result.add(method);\n              }\n            }\n\n            return result.toArray(new PsiElement[result.size()]);\n          }\n        }\n      }\n      //fallthrough\n\n      case PACKAGE_FQ:\n      case CLASS_FQ:\n      case CLASS_OR_PACKAGE_FQ: {\n        final String refText = PsiUtil.getQualifiedReferenceText(this);\n        final int lastDot = refText.lastIndexOf(\".\");\n        String parentPackageFQName = lastDot > 0 ? refText.substring(0, lastDot) : \"\";\n        final PsiPackage parentPackage = manager.findPackage(parentPackageFQName);\n        if (parentPackage != null) {\n          final GlobalSearchScope scope = getResolveScope();\n          if (kind == PACKAGE_FQ) {\n            return parentPackage.getSubPackages(scope);\n          } else {\n            if (kind == CLASS_FQ) {\n              return parentPackage.getClasses(scope);\n            } else {\n              final PsiPackage[] subpackages = parentPackage.getSubPackages(scope);\n              final PsiClass[] classes = parentPackage.getClasses(scope);\n              PsiElement[] result = new PsiElement[subpackages.length + classes.length];\n              System.arraycopy(subpackages, 0, result, 0, subpackages.length);\n              System.arraycopy(classes, 0, result, subpackages.length, classes.length);\n              return result;\n            }\n          }\n        }\n      }\n\n      case CLASS_OR_PACKAGE:\n      case CLASS: {\n        GrCodeReferenceElement qualifier = getQualifier();\n        if (qualifier != null) {\n          PsiElement qualifierResolved = qualifier.resolve();\n          if (qualifierResolved instanceof PsiPackage) {\n            PsiPackage aPackage = (PsiPackage) qualifierResolved;\n            PsiClass[] classes = aPackage.getClasses();\n            if (kind == CLASS) return classes;\n            PsiPackage[] subpackages = aPackage.getSubPackages();\n            return ArrayUtil.mergeArrays(classes, subpackages, Object.class);\n          } else if (qualifierResolved instanceof PsiClass) {\n            return ((PsiClass) qualifierResolved).getInnerClasses();\n          }\n        } else {\n          ResolverProcessor processor = CompletionProcessor.createClassCompletionProcessor(this);\n          ResolveUtil.treeWalkUp(this, processor);\n          return GroovyCompletionUtil.getCompletionVariants(processor.getCandidates());\n        }\n      }\n    }\n\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","commit_id":"d1ab5c84e800986eaea05b95828437442383ffc2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GroovyResolveResult[] _resolve(GrCodeReferenceElementImpl ref, PsiManager manager,\n                                           ReferenceKind kind) {\n      final String refName = ref.getReferenceName();\n      switch (kind) {\n        case CLASS_OR_PACKAGE_FQ:\n        case PACKAGE_FQ:\n          String qName = PsiUtil.getQualifiedReferenceText(ref);\n\n          if (kind == CLASS_OR_PACKAGE_FQ) {\n            if (qName.indexOf('.') > 0) {\n              PsiClass aClass = manager.findClass(qName, ref.getResolveScope());\n              if (aClass != null) {\n                boolean isAccessible = PsiUtil.isAccessible(ref, aClass);\n                return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n              }\n            }\n          }\n\n          PsiPackage aPackage = manager.findPackage(qName);\n          if (aPackage != null) {\n            return new GroovyResolveResult[]{new GroovyResolveResultImpl(aPackage, true)};\n          }\n\n          break;\n\n        case CLASS:\n        case CLASS_OR_PACKAGE: {\n          GrCodeReferenceElement qualifier = ref.getQualifier();\n          if (qualifier != null) {\n            PsiElement qualifierResolved = qualifier.resolve();\n            if (qualifierResolved instanceof PsiPackage) {\n              PsiClass[] classes = ((PsiPackage) qualifierResolved).getClasses();\n              for (final PsiClass aClass : classes) {\n                if (refName.equals(aClass.getName())) {\n                  boolean isAccessible = PsiUtil.isAccessible(ref, aClass);\n                  return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n                }\n              }\n\n              if (kind == CLASS_OR_PACKAGE) {\n                for (final PsiPackage subpackage : ((PsiPackage) qualifierResolved).getSubPackages()) {\n                  if (refName.equals(subpackage.getName()))\n                    return new GroovyResolveResult[]{new GroovyResolveResultImpl(subpackage, true)};\n                }\n              }\n            } else if ((kind == CLASS || kind == CLASS_OR_PACKAGE) && qualifierResolved instanceof PsiClass) {\n              PsiClass[] classes = ((PsiClass) qualifierResolved).getInnerClasses();\n              for (final PsiClass aClass : classes) {\n                if (refName.equals(aClass.getName())) {\n                  boolean isAccessible = PsiUtil.isAccessible(ref, aClass);\n                  return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n                }\n              }\n            }\n          } else {\n            EnumSet<ClassHint.ResolveKind> kinds = kind == CLASS ? EnumSet.of(ClassHint.ResolveKind.CLASS) :\n                EnumSet.of(ClassHint.ResolveKind.PACKAGE, ClassHint.ResolveKind.CLASS);\n            ResolverProcessor processor = new ClassResolverProcessor(refName, ref, kinds);\n            ResolveUtil.treeWalkUp(ref, processor);\n            GroovyResolveResult[] candidates = processor.getCandidates();\n            if (candidates.length > 0) return candidates;\n\n            if (kind == CLASS_OR_PACKAGE) {\n              PsiPackage defaultPackage = ref.getManager().findPackage(\"\");\n              if (defaultPackage != null) {\n                for (final PsiPackage subpackage : defaultPackage.getSubPackages()) {\n                  if (refName.equals(subpackage.getName()))\n                    return new GroovyResolveResult[]{new GroovyResolveResultImpl(subpackage, true)};\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n        case STATIC_MEMBER_FQ: {\n          final GrCodeReferenceElement qualifier = ref.getQualifier();\n          if (qualifier != null) {\n            final PsiElement resolve = qualifier.resolve();\n            if (resolve instanceof PsiClass) {\n              final PsiClass clazz = (PsiClass) resolve;\n              PsiResolveHelper helper = clazz.getManager().getResolveHelper();\n              List<GroovyResolveResult> result = new ArrayList<GroovyResolveResult>();\n              final PsiField field = clazz.findFieldByName(refName, false);\n              if (field != null && field.hasModifierProperty(PsiModifier.STATIC)) {\n                result.add(new GroovyResolveResultImpl(field, helper.isAccessible(field, ref, null)));\n              }\n\n              final PsiMethod[] methods = clazz.findMethodsByName(refName, false);\n              for (PsiMethod method : methods) {\n                result.add(new GroovyResolveResultImpl(method, helper.isAccessible(method, ref, null)));\n              }\n\n              return result.toArray(new GroovyResolveResult[result.size()]);\n            }\n          }\n        }\n      }\n\n      return GroovyResolveResult.EMPTY_ARRAY;\n    }","id":72475,"modified_method":"private GroovyResolveResult[] _resolve(GrCodeReferenceElementImpl ref, PsiManager manager,\n                                           ReferenceKind kind) {\n      final String refName = ref.getReferenceName();\n      switch (kind) {\n        case CLASS_OR_PACKAGE_FQ:\n        case CLASS_FQ:\n        case PACKAGE_FQ:\n          String qName = PsiUtil.getQualifiedReferenceText(ref);\n\n          if (kind == CLASS_OR_PACKAGE_FQ || kind == CLASS_FQ) {\n            if (qName.indexOf('.') > 0) {\n              PsiClass aClass = manager.findClass(qName, ref.getResolveScope());\n              if (aClass != null) {\n                boolean isAccessible = PsiUtil.isAccessible(ref, aClass);\n                return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n              }\n            }\n          }\n\n          if (kind == CLASS_OR_PACKAGE_FQ || kind == PACKAGE_FQ) {\n            PsiPackage aPackage = manager.findPackage(qName);\n            if (aPackage != null) {\n              return new GroovyResolveResult[]{new GroovyResolveResultImpl(aPackage, true)};\n            }\n          }\n\n          break;\n\n        case CLASS:\n        case CLASS_OR_PACKAGE: {\n          GrCodeReferenceElement qualifier = ref.getQualifier();\n          if (qualifier != null) {\n            PsiElement qualifierResolved = qualifier.resolve();\n            if (qualifierResolved instanceof PsiPackage) {\n              PsiClass[] classes = ((PsiPackage) qualifierResolved).getClasses();\n              for (final PsiClass aClass : classes) {\n                if (refName.equals(aClass.getName())) {\n                  boolean isAccessible = PsiUtil.isAccessible(ref, aClass);\n                  return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n                }\n              }\n\n              if (kind == CLASS_OR_PACKAGE) {\n                for (final PsiPackage subpackage : ((PsiPackage) qualifierResolved).getSubPackages()) {\n                  if (refName.equals(subpackage.getName()))\n                    return new GroovyResolveResult[]{new GroovyResolveResultImpl(subpackage, true)};\n                }\n              }\n            } else if ((kind == CLASS || kind == CLASS_OR_PACKAGE) && qualifierResolved instanceof PsiClass) {\n              PsiClass[] classes = ((PsiClass) qualifierResolved).getInnerClasses();\n              for (final PsiClass aClass : classes) {\n                if (refName.equals(aClass.getName())) {\n                  boolean isAccessible = PsiUtil.isAccessible(ref, aClass);\n                  return new GroovyResolveResult[]{new GroovyResolveResultImpl(aClass, isAccessible)};\n                }\n              }\n            }\n          } else {\n            EnumSet<ClassHint.ResolveKind> kinds = kind == CLASS ? EnumSet.of(ClassHint.ResolveKind.CLASS) :\n                EnumSet.of(ClassHint.ResolveKind.PACKAGE, ClassHint.ResolveKind.CLASS);\n            ResolverProcessor processor = new ClassResolverProcessor(refName, ref, kinds);\n            ResolveUtil.treeWalkUp(ref, processor);\n            GroovyResolveResult[] candidates = processor.getCandidates();\n            if (candidates.length > 0) return candidates;\n\n            if (kind == CLASS_OR_PACKAGE) {\n              PsiPackage defaultPackage = ref.getManager().findPackage(\"\");\n              if (defaultPackage != null) {\n                for (final PsiPackage subpackage : defaultPackage.getSubPackages()) {\n                  if (refName.equals(subpackage.getName()))\n                    return new GroovyResolveResult[]{new GroovyResolveResultImpl(subpackage, true)};\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n        case STATIC_MEMBER_FQ: {\n          final GrCodeReferenceElement qualifier = ref.getQualifier();\n          if (qualifier != null) {\n            final PsiElement resolve = qualifier.resolve();\n            if (resolve instanceof PsiClass) {\n              final PsiClass clazz = (PsiClass) resolve;\n              PsiResolveHelper helper = clazz.getManager().getResolveHelper();\n              List<GroovyResolveResult> result = new ArrayList<GroovyResolveResult>();\n              final PsiField field = clazz.findFieldByName(refName, false);\n              if (field != null && field.hasModifierProperty(PsiModifier.STATIC)) {\n                result.add(new GroovyResolveResultImpl(field, helper.isAccessible(field, ref, null)));\n              }\n\n              final PsiMethod[] methods = clazz.findMethodsByName(refName, false);\n              for (PsiMethod method : methods) {\n                result.add(new GroovyResolveResultImpl(method, helper.isAccessible(method, ref, null)));\n              }\n\n              return result.toArray(new GroovyResolveResult[result.size()]);\n            }\n          }\n        }\n      }\n\n      return GroovyResolveResult.EMPTY_ARRAY;\n    }","commit_id":"d1ab5c84e800986eaea05b95828437442383ffc2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    if (isClassReferenceForNew()) {\n      return getVariantsForNewExpression();\n    }\n\n    return getVariantsImpl(getKind());\n  }","id":72476,"modified_method":"public Object[] getVariants() {\n    if (isClassReferenceForNew()) {\n      return getVariantsForNewExpression();\n    }\n\n    return getVariantsImpl(getKind(true));\n  }","commit_id":"d1ab5c84e800986eaea05b95828437442383ffc2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ReferenceKind getKind() {\n    PsiElement parent = getParent();\n    if (parent instanceof GrCodeReferenceElement) {\n      ReferenceKind parentKind = ((GrCodeReferenceElementImpl) parent).getKind();\n      if (parentKind == CLASS ||\n          parentKind == STATIC_MEMBER_FQ) return CLASS_OR_PACKAGE;\n      return parentKind;\n    } else if (parent instanceof GrPackageDefinition) {\n      return PACKAGE_FQ;\n    } else if (parent instanceof GrDocReferenceElement) {\n      return CLASS_OR_PACKAGE;\n    } else if (parent instanceof GrImportStatement) {\n      final GrImportStatement importStatement = (GrImportStatement) parent;\n      if (!importStatement.isStatic() || importStatement.isOnDemand()) {\n        return CLASS_OR_PACKAGE_FQ;\n      }\n\n      return STATIC_MEMBER_FQ;\n    }\n\n    return CLASS;\n  }","id":72477,"modified_method":"private ReferenceKind getKind(boolean forCompletion) {\n    PsiElement parent = getParent();\n    if (parent instanceof GrCodeReferenceElement) {\n      ReferenceKind parentKind = ((GrCodeReferenceElementImpl) parent).getKind(forCompletion);\n      if (parentKind == CLASS) return CLASS_OR_PACKAGE;\n      else if (parentKind == STATIC_MEMBER_FQ) return CLASS_FQ;\n      else if (parentKind == CLASS_FQ) return CLASS_OR_PACKAGE_FQ;\n      return parentKind;\n    } else if (parent instanceof GrPackageDefinition) {\n      return PACKAGE_FQ;\n    } else if (parent instanceof GrDocReferenceElement) {\n      return CLASS_OR_PACKAGE;\n    } else if (parent instanceof GrImportStatement) {\n      final GrImportStatement importStatement = (GrImportStatement) parent;\n      if (importStatement.isStatic()) {\n        return importStatement.isOnDemand() ? CLASS_FQ : STATIC_MEMBER_FQ;\n      } else {\n        return forCompletion || importStatement.isOnDemand() ? CLASS_OR_PACKAGE_FQ : CLASS_FQ;\n      }\n    }\n\n    return CLASS;\n  }","commit_id":"d1ab5c84e800986eaea05b95828437442383ffc2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyResolveResult[] resolve(GrCodeReferenceElementImpl reference, boolean incompleteCode) {\n      if (reference.getReferenceName() == null) return GroovyResolveResult.EMPTY_ARRAY;\n      final GroovyResolveResult[] results = _resolve(reference, reference.getManager(), reference.getKind());\n      final PsiType[] args = reference.getTypeArguments();\n      for (int i = 0; i < results.length; i++) {\n        GroovyResolveResult result = results[i];\n        final PsiElement element = result.getElement();\n        if (element instanceof PsiClass) {\n          final PsiSubstitutor substitutor = result.getSubstitutor();\n          final PsiSubstitutor newSubstitutor = substitutor.putAll((PsiClass) element, args);\n          results[i] = new GroovyResolveResultImpl(element, result.getCurrentFileResolveContext(), newSubstitutor, result.isAccessible(), result.isStaticsOK());\n        }\n      }\n      return results;\n    }","id":72478,"modified_method":"public GroovyResolveResult[] resolve(GrCodeReferenceElementImpl reference, boolean incompleteCode) {\n      if (reference.getReferenceName() == null) return GroovyResolveResult.EMPTY_ARRAY;\n      final GroovyResolveResult[] results = _resolve(reference, reference.getManager(), reference.getKind(false));\n      final PsiType[] args = reference.getTypeArguments();\n      for (int i = 0; i < results.length; i++) {\n        GroovyResolveResult result = results[i];\n        final PsiElement element = result.getElement();\n        if (element instanceof PsiClass) {\n          final PsiSubstitutor substitutor = result.getSubstitutor();\n          final PsiSubstitutor newSubstitutor = substitutor.putAll((PsiClass) element, args);\n          results[i] = new GroovyResolveResultImpl(element, result.getCurrentFileResolveContext(), newSubstitutor, result.isAccessible(), result.isStaticsOK());\n        }\n      }\n      return results;\n    }","commit_id":"d1ab5c84e800986eaea05b95828437442383ffc2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleInsert(CompletionContext context, int startOffset, LookupData data, LookupItem item, boolean signatureSelected, char completionChar) {\n    Object obj = item.getObject();\n    if (obj instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod) obj;\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      Editor editor = context.editor;\n      Document document = editor.getDocument();\n      if (completionChar == Lookup.REPLACE_SELECT_CHAR) {\n        handleOverwrite(editor.getCaretModel().getOffset(), document);\n      }\n\n      CaretModel caretModel = editor.getCaretModel();\n      int offset = startOffset + method.getName().length();\n      PsiFile file = PsiDocumentManager.getInstance(method.getProject()).getPsiFile(document);\n      PsiElement elementAt = file.findElementAt(startOffset);\n      PsiElement parent = elementAt != null ? elementAt.getParent() : null;\n      if (parent instanceof GrReferenceExpression && ((GrReferenceExpression) parent).getDotTokenType() == GroovyElementTypes.mMEMBER_POINTER) return;\n\n      if (parent instanceof GrAnnotationNameValuePair || parent.getParent() instanceof GrAnnotationNameValuePair) {\n        document.insertString(offset, \" = \");\n        caretModel.moveToOffset(offset + 3);\n        return;\n      }\n\n      if (parameters.length == 0) {\n        if (offset == document.getTextLength() || document.getCharsSequence().charAt(offset) != '(') {\n          document.insertString(offset, \"()\");\n        }\n        caretModel.moveToOffset(offset + 2);\n      } else {\n        if (parameters.length == 1 && parameters[0].getType().getCanonicalText().equals(\"groovy.lang.Closure\")) {\n          document.insertString(offset, \" {}\");\n          caretModel.moveToOffset(offset + 2);\n        } else {\n          PsiDocumentManager docManager = PsiDocumentManager.getInstance(method.getProject());\n          docManager.commitDocument(document);\n          PsiFile psiFile = docManager.getPsiFile(document);\n          if (isExpressionStatement(psiFile, startOffset) && PsiType.VOID.equals(method.getReturnType())) {\n            document.insertString(offset, \" \");\n          } else {\n            document.insertString(offset, \"()\");\n          }\n          caretModel.moveToOffset(offset + 1);\n        }\n      }\n      return;\n    } else if (obj instanceof String && !\"assert\".equals(obj)) {\n      Editor editor = context.editor;\n      Document document = editor.getDocument();\n      if (completionChar == Lookup.REPLACE_SELECT_CHAR) {\n        handleOverwrite(editor.getCaretModel().getOffset(), document);\n      }\n\n      return;\n    }\n\n    addTailType(item);\n    super.handleInsert(context, startOffset, data, item, signatureSelected, completionChar);\n\n  }","id":72479,"modified_method":"public void handleInsert(CompletionContext context, int startOffset, LookupData data, LookupItem item, boolean signatureSelected, char completionChar) {\n    Object obj = item.getObject();\n    if (obj instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod) obj;\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      Editor editor = context.editor;\n      Document document = editor.getDocument();\n      if (completionChar == Lookup.REPLACE_SELECT_CHAR) {\n        handleOverwrite(editor.getCaretModel().getOffset(), document);\n      }\n\n      CaretModel caretModel = editor.getCaretModel();\n      int offset = startOffset + method.getName().length();\n      PsiFile file = PsiDocumentManager.getInstance(method.getProject()).getPsiFile(document);\n      PsiElement elementAt = file.findElementAt(startOffset);\n      PsiElement parent = elementAt != null ? elementAt.getParent() : null;\n      if (parent instanceof GrReferenceExpression && ((GrReferenceExpression) parent).getDotTokenType() == GroovyElementTypes.mMEMBER_POINTER) return;\n\n      if (parent instanceof GrAnnotationNameValuePair || parent.getParent() instanceof GrAnnotationNameValuePair) {\n        document.insertString(offset, \" = \");\n        caretModel.moveToOffset(offset + 3);\n        return;\n      }\n\n      if (PsiTreeUtil.getParentOfType(elementAt, GrImportStatement.class) != null) return;\n\n      if (parameters.length == 0) {\n        if (offset == document.getTextLength() || document.getCharsSequence().charAt(offset) != '(') {\n          document.insertString(offset, \"()\");\n        }\n        caretModel.moveToOffset(offset + 2);\n      } else {\n        if (parameters.length == 1 && parameters[0].getType().getCanonicalText().equals(\"groovy.lang.Closure\")) {\n          document.insertString(offset, \" {}\");\n          caretModel.moveToOffset(offset + 2);\n        } else {\n          PsiDocumentManager docManager = PsiDocumentManager.getInstance(method.getProject());\n          docManager.commitDocument(document);\n          PsiFile psiFile = docManager.getPsiFile(document);\n          if (isExpressionStatement(psiFile, startOffset) && PsiType.VOID.equals(method.getReturnType())) {\n            document.insertString(offset, \" \");\n          } else {\n            document.insertString(offset, \"()\");\n          }\n          caretModel.moveToOffset(offset + 1);\n        }\n      }\n      return;\n    } else if (obj instanceof String && !\"assert\".equals(obj)) {\n      Editor editor = context.editor;\n      Document document = editor.getDocument();\n      if (completionChar == Lookup.REPLACE_SELECT_CHAR) {\n        handleOverwrite(editor.getCaretModel().getOffset(), document);\n      }\n\n      return;\n    }\n\n    addTailType(item);\n    super.handleInsert(context, startOffset, data, item, signatureSelected, completionChar);\n\n  }","commit_id":"d1ab5c84e800986eaea05b95828437442383ffc2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String checkStaticableFieldType(\n\t\tJavaField javaField, Type javaFieldType, String content) {\n\n\t\tString initializationExpression = StringUtil.trim(\n\t\t\tjavaField.getInitializationExpression());\n\n\t\tif (javaField.isStatic() || initializationExpression.isEmpty() ||\n\t\t\tjavaFieldType.isArray()) {\n\n\t\t\treturn content;\n\t\t}\n\n\t\tString[] lines = StringUtil.splitLines(content);\n\n\t\tString line = lines[javaField.getLineNumber() - 1];\n\n\t\tlines[javaField.getLineNumber() - 1] = StringUtil.replace(\n\t\t\tline, \"private final\", \"private static final\");\n\n\t\tStringBundler sb = new StringBundler(2 * lines.length);\n\n\t\tfor (String contentLine : lines) {\n\t\t\tsb.append(contentLine);\n\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tcontent = sb.toString();\n\n\t\treturn content;\n\t}","id":72480,"modified_method":"protected String checkStaticableFieldType(\n\t\tJavaField javaField, Type javaFieldType, String content) {\n\n\t\tString initializationExpression = StringUtil.trim(\n\t\t\tjavaField.getInitializationExpression());\n\n\t\tif (javaField.isStatic() || initializationExpression.isEmpty() ||\n\t\t\tjavaFieldType.isArray()) {\n\n\t\t\treturn content;\n\t\t}\n\n\t\treturn getChangedFieldTypeContent(\n\t\t\tcontent, javaField, \"private final\", \"private static final\");\n\t}","commit_id":"2457f0347d89b1acc80f781bc2171189c2b37bb9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String checkFinalableFieldType(\n\t\tcom.thoughtworks.qdox.model.JavaClass javaClass,\n\t\tcom.thoughtworks.qdox.model.JavaClass[] javaClasses,\n\t\tJavaField javaField, String content) {\n\n\t\tType javaClassType = javaClass.asType();\n\n\t\tif ((javaClass.isEnum() && javaClassType.equals(javaField.getType())) ||\n\t\t\tjavaField.isFinal()) {\n\n\t\t\treturn content;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(\"(\\\\b|\\\\.)\");\n\t\tsb.append(javaField.getName());\n\t\tsb.append(\" (=)|(\\\\+\\\\+)|(--)|(\\\\+=)|(-=)|(\\\\*=)|(/=)|(%=)\");\n\t\tsb.append(\"|(\\\\|=)|(&=)|(^=) \");\n\n\t\tPattern pattern = Pattern.compile(sb.toString());\n\n\t\tfor (com.thoughtworks.qdox.model.JavaClass javaSubClass : javaClasses) {\n\t\t\tfor (JavaMethod javaMethod : javaSubClass.getMethods()) {\n\t\t\t\tif (javaMethod.isConstructor() && (javaSubClass == javaClass)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tMatcher matcher = pattern.matcher(javaMethod.getCodeBlock());\n\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\treturn content;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString[] lines = StringUtil.splitLines(content);\n\n\t\tString line = lines[javaField.getLineNumber() - 1];\n\n\t\tif (javaField.isStatic()) {\n\t\t\tlines[javaField.getLineNumber() - 1] = StringUtil.replace(\n\t\t\t\tline, \"private static \", \"private static final \");\n\t\t}\n\t\telse {\n\t\t\tlines[javaField.getLineNumber() - 1] = StringUtil.replace(\n\t\t\t\tline, \"private \", \"private final \");\n\t\t}\n\n\t\tsb = new StringBundler(2 * lines.length);\n\n\t\tfor (String contentLine : lines) {\n\t\t\tsb.append(contentLine);\n\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tcontent = sb.toString();\n\n\t\treturn content;\n\t}","id":72481,"modified_method":"protected String checkFinalableFieldType(\n\t\tcom.thoughtworks.qdox.model.JavaClass javaClass,\n\t\tcom.thoughtworks.qdox.model.JavaClass[] javaClasses,\n\t\tJavaField javaField, String content) {\n\n\t\tType javaClassType = javaClass.asType();\n\n\t\tif ((javaClass.isEnum() && javaClassType.equals(javaField.getType())) ||\n\t\t\tjavaField.isFinal()) {\n\n\t\t\treturn content;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(\"(\\\\b|\\\\.)\");\n\t\tsb.append(javaField.getName());\n\t\tsb.append(\" (=)|(\\\\+\\\\+)|(--)|(\\\\+=)|(-=)|(\\\\*=)|(/=)|(%=)\");\n\t\tsb.append(\"|(\\\\|=)|(&=)|(^=) \");\n\n\t\tPattern pattern = Pattern.compile(sb.toString());\n\n\t\tfor (com.thoughtworks.qdox.model.JavaClass javaSubClass : javaClasses) {\n\t\t\tfor (JavaMethod javaMethod : javaSubClass.getMethods()) {\n\t\t\t\tif (javaMethod.isConstructor() && (javaSubClass == javaClass)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tMatcher matcher = pattern.matcher(javaMethod.getCodeBlock());\n\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\treturn content;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (javaField.isStatic()) {\n\t\t\treturn getChangedFieldTypeContent(\n\t\t\t\tcontent, javaField, \"private static\", \"private static final\");\n\t\t}\n\n\t\treturn getChangedFieldTypeContent(\n\t\t\tcontent, javaField, \"private\", \"private final\");\n\t}","commit_id":"2457f0347d89b1acc80f781bc2171189c2b37bb9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String checkStaticableFieldType(\n\t\tJavaField javaField, Type javaFieldType, String content) {\n\n\t\tString initializationExpression = StringUtil.trim(\n\t\t\tjavaField.getInitializationExpression());\n\n\t\tif (javaField.isStatic() || initializationExpression.isEmpty() ||\n\t\t\tjavaFieldType.isArray()) {\n\n\t\t\treturn content;\n\t\t}\n\n\t\tString[] lines = StringUtil.splitLines(content);\n\n\t\tString line = lines[javaField.getLineNumber() - 1];\n\n\t\tlines[javaField.getLineNumber() - 1] = StringUtil.replace(\n\t\t\tline, \"private final\", \"private static final\");\n\n\t\tStringBundler sb = new StringBundler(2 * lines.length);\n\n\t\tfor (String contentLine : lines) {\n\t\t\tsb.append(contentLine);\n\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tcontent = sb.toString();\n\n\t\treturn content;\n\t}","id":72482,"modified_method":"protected String checkStaticableFieldType(\n\t\tJavaField javaField, Type javaFieldType, String content) {\n\n\t\tString initializationExpression = StringUtil.trim(\n\t\t\tjavaField.getInitializationExpression());\n\n\t\tif (javaField.isStatic() || initializationExpression.isEmpty() ||\n\t\t\tjavaFieldType.isArray()) {\n\n\t\t\treturn content;\n\t\t}\n\n\t\treturn getChangedFieldTypeContent(\n\t\t\tcontent, javaField, \"private final\", \"private static final\");\n\t}","commit_id":"2851bed5c7975c64fd67c3e047adf17a0f2757bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String checkFinalableFieldType(\n\t\tcom.thoughtworks.qdox.model.JavaClass javaClass,\n\t\tcom.thoughtworks.qdox.model.JavaClass[] javaClasses,\n\t\tJavaField javaField, String content) {\n\n\t\tType javaClassType = javaClass.asType();\n\n\t\tif ((javaClass.isEnum() && javaClassType.equals(javaField.getType())) ||\n\t\t\tjavaField.isFinal()) {\n\n\t\t\treturn content;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(\"(\\\\b|\\\\.)\");\n\t\tsb.append(javaField.getName());\n\t\tsb.append(\" (=)|(\\\\+\\\\+)|(--)|(\\\\+=)|(-=)|(\\\\*=)|(/=)|(%=)\");\n\t\tsb.append(\"|(\\\\|=)|(&=)|(^=) \");\n\n\t\tPattern pattern = Pattern.compile(sb.toString());\n\n\t\tfor (com.thoughtworks.qdox.model.JavaClass javaSubClass : javaClasses) {\n\t\t\tfor (JavaMethod javaMethod : javaSubClass.getMethods()) {\n\t\t\t\tif (javaMethod.isConstructor() && (javaSubClass == javaClass)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tMatcher matcher = pattern.matcher(javaMethod.getCodeBlock());\n\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\treturn content;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString[] lines = StringUtil.splitLines(content);\n\n\t\tString line = lines[javaField.getLineNumber() - 1];\n\n\t\tif (javaField.isStatic()) {\n\t\t\tlines[javaField.getLineNumber() - 1] = StringUtil.replace(\n\t\t\t\tline, \"private static \", \"private static final \");\n\t\t}\n\t\telse {\n\t\t\tlines[javaField.getLineNumber() - 1] = StringUtil.replace(\n\t\t\t\tline, \"private \", \"private final \");\n\t\t}\n\n\t\tsb = new StringBundler(2 * lines.length);\n\n\t\tfor (String contentLine : lines) {\n\t\t\tsb.append(contentLine);\n\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tcontent = sb.toString();\n\n\t\treturn content;\n\t}","id":72483,"modified_method":"protected String checkFinalableFieldType(\n\t\tcom.thoughtworks.qdox.model.JavaClass javaClass,\n\t\tcom.thoughtworks.qdox.model.JavaClass[] javaClasses,\n\t\tJavaField javaField, String content) {\n\n\t\tType javaClassType = javaClass.asType();\n\n\t\tif ((javaClass.isEnum() && javaClassType.equals(javaField.getType())) ||\n\t\t\tjavaField.isFinal()) {\n\n\t\t\treturn content;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(\"(\\\\b|\\\\.)\");\n\t\tsb.append(javaField.getName());\n\t\tsb.append(\" (=)|(\\\\+\\\\+)|(--)|(\\\\+=)|(-=)|(\\\\*=)|(/=)|(%=)\");\n\t\tsb.append(\"|(\\\\|=)|(&=)|(^=) \");\n\n\t\tPattern pattern = Pattern.compile(sb.toString());\n\n\t\tfor (com.thoughtworks.qdox.model.JavaClass javaSubClass : javaClasses) {\n\t\t\tfor (JavaMethod javaMethod : javaSubClass.getMethods()) {\n\t\t\t\tif (javaMethod.isConstructor() && (javaSubClass == javaClass)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tMatcher matcher = pattern.matcher(javaMethod.getCodeBlock());\n\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\treturn content;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (javaField.isStatic()) {\n\t\t\treturn getChangedFieldTypeContent(\n\t\t\t\tcontent, javaField, \"private static\", \"private static final\");\n\t\t}\n\n\t\treturn getChangedFieldTypeContent(\n\t\t\tcontent, javaField, \"private\", \"private final\");\n\t}","commit_id":"2851bed5c7975c64fd67c3e047adf17a0f2757bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Given a join node and plan-sub-graph for outer and inner sub-nodes,\n     * construct the plan-sub-graph for that node.\n     *\n     * @param joinNode A parent join node.\n     * @param outerPlan The outer node plan-sub-graph.\n     * @param innerPlan The inner node plan-sub-graph.\n     * @return A completed plan-sub-graph\n     * or null if a valid plan can not be produced for given access paths.\n     */\n    private AbstractPlanNode getSelectSubPlanForJoin(BranchNode joinNode,\n                                                     AbstractPlanNode outerPlan,\n                                                     AbstractPlanNode innerPlan)\n    {\n        // Filter (post-join) expressions\n        ArrayList<AbstractExpression> whereClauses  = new ArrayList<AbstractExpression>();\n        whereClauses.addAll(joinNode.m_whereInnerList);\n        whereClauses.addAll(joinNode.m_whereInnerOuterList);\n        if (joinNode.getJoinType() == JoinType.FULL) {\n            // For all other join types, the whereOuterList expressions were pushed down to the outer node\n            whereClauses.addAll(joinNode.m_whereOuterList);\n        }\n\n        // The usual approach of calculating a local (partial) join result on each partition,\n        // then sending and merging them with other partial results on the coordinator does not\n        // ensure correct answers for some queries like:\n        //     SELECT * FROM replicated LEFT JOIN partitioned ON ...\n        // They require a \"global view\" of the partitioned working set in order to\n        // properly identify which replicated rows need to be null-padded,\n        // and to ensure that the same replicated row is not null-padded redundantly on multiple partitions.\n        // Many queries using this pattern impractically require redistribution and caching of a considerable\n        // subset of a partitioned table in preparation for a \"coordinated\" join.\n        // Yet, there may be useful cases with sufficient constant-based partitioned table filtering\n        // in the \"ON clause\" to keep the distributed working set size under control, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P\n        //     ON R.key == P.non_partition_key AND P.non_partition_key BETWEEN ? and ?;\n        //\n        // Such queries need to be prohibited by the planner if it can not guarantee the\n        // correct results that require a \"send before join\" plan.\n        // This could be the case if the replicated-to-partition join in these examples\n        // were subject to another join with a partitioned table, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P1 ON ...\n        //                                LEFT JOIN also_partitioned P2 ON ...\n        //\n\n        assert(joinNode.getRightNode() != null);\n        JoinNode innerJoinNode = joinNode.getRightNode();\n        AccessPath innerAccessPath = innerJoinNode.m_currentAccessPath;\n        // We may need to add a send/receive pair to the inner plan for the special case.\n        // This trick only works once per plan, BUT once the partitioned data has been\n        // received on the coordinator, it can be treated as replicated data in later\n        // joins, which MAY help with later outer joins with replicated data.\n\n        boolean needInnerSendReceive = m_partitioning.requiresTwoFragments() &&\n                                       ! innerPlan.hasReplicatedResult() &&\n                                       outerPlan.hasReplicatedResult() &&\n                                       joinNode.getJoinType() != JoinType.INNER;\n\n        // When the inner plan is an IndexScan, there MAY be a choice of whether to join using a\n        // NestLoopJoin (NLJ) or a NestLoopIndexJoin (NLIJ). The NLJ will have an advantage over the\n        // NLIJ in the cases where it applies, since it does a single access or iteration over the index\n        // and caches the result, where the NLIJ does an index access or iteration for each outer row.\n        // The NestLoopJoin applies when the inner IndexScan is driven only by parameter and constant\n        // expressions determined at the start of the query. That requires that none of the IndexScan's\n        // various expressions that drive the index access may reference columns from the outer row\n        // -- they can only reference columns of the index's base table (the indexed expressions)\n        // as well as constants and parameters. The IndexScan's \"otherExprs\" expressions that only\n        // drive post-filtering are not an issue since the NestLoopJoin does feature per-outer-tuple\n        // post-filtering on each pass over the cached index scan result.\n\n        // The special case of an OUTER JOIN of replicated outer row data with a partitioned inner\n        // table requires that the partitioned data be sent to the coordinator prior to the join.\n        // This limits the join option to NLJ. The index scan must make a single index access on\n        // each partition and cache the result at the coordinator for post-filtering.\n        // This requires that the index access be based on parameters or constants only\n        // -- the replicated outer row data will only be available later at the coordinator,\n        // so it can not drive the per-partition index scan.\n\n        // If the NLJ option is precluded for the usual reason (outer-row-based indexing) AND\n        // the NLIJ is precluded by the special case (OUTER JOIN of replicated outer rows and\n        // partitioned inner rows) this method returns null, effectively rejecting this indexed\n        // access path for the inner node. Other access paths or join orders may prove more successful.\n\n        boolean canHaveNLJ = true;\n        boolean canHaveNLIJ = true;\n        if (innerPlan instanceof IndexScanPlanNode) {\n            if (hasInnerOuterIndexExpression(joinNode.getRightNode().getTableAlias(),\n                                             innerAccessPath.indexExprs,\n                                             innerAccessPath.initialExpr,\n                                             innerAccessPath.endExprs)) {\n                canHaveNLJ = false;\n            }\n        }\n        else {\n            canHaveNLIJ = false;\n        }\n        if (needInnerSendReceive) {\n            canHaveNLIJ = false;\n        }\n\n        AbstractJoinPlanNode ajNode = null;\n        if (canHaveNLJ) {\n            NestLoopPlanNode nljNode = new NestLoopPlanNode();\n            // get all the clauses that join the applicable two tables\n            // Copy innerAccessPath.joinExprs to leave it unchanged,\n            // avoiding accumulation of redundant expressions when\n            // joinClauses gets built up for various alternative plans.\n            ArrayList<AbstractExpression> joinClauses = new ArrayList<>(innerAccessPath.joinExprs);\n            if ((innerPlan instanceof IndexScanPlanNode) ||\n                (innerPlan instanceof NestLoopIndexPlanNode\n                    && innerPlan.getChild(0) instanceof MaterializedScanPlanNode)) {\n                // InnerPlan is an IndexScan OR an NLIJ of a MaterializedScan\n                // (IN LIST) and an IndexScan. In this case, the inner and\n                // inner-outer non-index join expressions (if any) are in the\n                // indexScan's otherExpr. The former should stay as IndexScanPlan\n                // predicates but the latter need to be pulled up into NLJ\n                // predicates because the IndexScan is executed once, not once\n                // per outer tuple.\n                ArrayList<AbstractExpression> otherExprs = new ArrayList<AbstractExpression>();\n                // PLEASE do not update the \"innerAccessPath.otherExprs\", it may be reused\n                // for other path evaluation on the other outer side join.\n                List<AbstractExpression> innerExpr = filterSingleTVEExpressions(innerAccessPath.otherExprs, otherExprs);\n                joinClauses.addAll(otherExprs);\n                IndexScanPlanNode scanNode = null;\n                if (innerPlan instanceof IndexScanPlanNode) {\n                    scanNode = (IndexScanPlanNode)innerPlan;\n                }\n                else {\n                    scanNode = (IndexScanPlanNode)\n                            innerPlan.getInlinePlanNode(PlanNodeType.INDEXSCAN);\n                }\n                scanNode.setPredicate(innerExpr);\n            }\n            else if (innerJoinNode instanceof BranchNode && joinNode.getJoinType() != JoinType.INNER) {\n                // If the innerJoinNode is a LEAF node OR if the join type is an INNER join,\n                // the conditions that apply to the inner side\n                // have been applied as predicates to the inner scan node already.\n\n                // otherExpr of innerAccessPath comes from its parentNode's joinInnerList.\n                // For Outer join (LEFT or FULL), it could mean a join predicate on the table of\n                // the inner node ONLY, that can not be pushed down.\n                joinClauses.addAll(innerAccessPath.otherExprs);\n            }\n            nljNode.setJoinPredicate(ExpressionUtil.combine(joinClauses));\n\n            // combine the tails plan graph with the new head node\n            nljNode.addAndLinkChild(outerPlan);\n\n            // If successful in the special case, the NLJ plan must be modified to cause the\n            // partitioned inner data to be sent to the coordinator prior to the join.\n            // This is done by adding send and receive plan nodes between the NLJ and its\n            // right child node.\n            if (needInnerSendReceive) {\n                // This trick only works once per plan.\n                if (outerPlan.hasAnyNodeOfClass(AbstractReceivePlanNode.class) || innerPlan.hasAnyNodeOfClass(AbstractReceivePlanNode.class)) {\n                    return null;\n                }\n                innerPlan = addSendReceivePair(innerPlan);\n            }\n\n            nljNode.addAndLinkChild(innerPlan);\n            ajNode = nljNode;\n        }\n        else if (canHaveNLIJ) {\n            NestLoopIndexPlanNode nlijNode = new NestLoopIndexPlanNode();\n\n            IndexScanPlanNode innerNode = (IndexScanPlanNode) innerPlan;\n            // Set IndexScan predicate. The INNER join expressions for a FULL join come from\n            // the innerAccessPath.joinExprs and need to be combined with the other join expressions\n            innerNode.setPredicate(innerAccessPath.joinExprs, innerAccessPath.otherExprs);\n\n            nlijNode.addInlinePlanNode(innerPlan);\n\n            // combine the tails plan graph with the new head node\n            nlijNode.addAndLinkChild(outerPlan);\n\n            ajNode = nlijNode;\n        }\n        else {\n            m_recentErrorMsg =\n                \"Unsupported special case of complex OUTER JOIN between replicated outer table and partitioned inner table.\";\n            return null;\n        }\n        ajNode.setJoinType(joinNode.getJoinType());\n        ajNode.setPreJoinPredicate(ExpressionUtil.combine(joinNode.m_joinOuterList));\n        ajNode.setWherePredicate(ExpressionUtil.combine(whereClauses));\n        ajNode.resolveSortDirection();\n        return ajNode;\n    }","id":72484,"modified_method":"/**\n     * Given a join node and plan-sub-graph for outer and inner sub-nodes,\n     * construct the plan-sub-graph for that node.\n     *\n     * @param joinNode A parent join node.\n     * @param outerPlan The outer node plan-sub-graph.\n     * @param innerPlan The inner node plan-sub-graph.\n     * @return A completed plan-sub-graph\n     * or null if a valid plan can not be produced for given access paths.\n     */\n    private AbstractPlanNode getSelectSubPlanForJoin(BranchNode joinNode,\n                                                     AbstractPlanNode outerPlan,\n                                                     AbstractPlanNode innerPlan)\n    {\n        // Filter (post-join) expressions\n        ArrayList<AbstractExpression> whereClauses  = new ArrayList<AbstractExpression>();\n        whereClauses.addAll(joinNode.m_whereInnerList);\n        whereClauses.addAll(joinNode.m_whereInnerOuterList);\n        if (joinNode.getJoinType() == JoinType.FULL) {\n            // For all other join types, the whereOuterList expressions were pushed down to the outer node\n            whereClauses.addAll(joinNode.m_whereOuterList);\n        }\n\n        // The usual approach of calculating a local (partial) join result on each partition,\n        // then sending and merging them with other partial results on the coordinator does not\n        // ensure correct answers for some queries like:\n        //     SELECT * FROM replicated LEFT JOIN partitioned ON ...\n        // They require a \"global view\" of the partitioned working set in order to\n        // properly identify which replicated rows need to be null-padded,\n        // and to ensure that the same replicated row is not null-padded redundantly on multiple partitions.\n        // Many queries using this pattern impractically require redistribution and caching of a considerable\n        // subset of a partitioned table in preparation for a \"coordinated\" join.\n        // Yet, there may be useful cases with sufficient constant-based partitioned table filtering\n        // in the \"ON clause\" to keep the distributed working set size under control, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P\n        //     ON R.key == P.non_partition_key AND P.non_partition_key BETWEEN ? and ?;\n        //\n        // Such queries need to be prohibited by the planner if it can not guarantee the\n        // correct results that require a \"send before join\" plan.\n        // This could be the case if the replicated-to-partition join in these examples\n        // were subject to another join with a partitioned table, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P1 ON ...\n        //                                LEFT JOIN also_partitioned P2 ON ...\n        //\n\n        assert(joinNode.getRightNode() != null);\n        JoinNode innerJoinNode = joinNode.getRightNode();\n        AccessPath innerAccessPath = innerJoinNode.m_currentAccessPath;\n        // We may need to add a send/receive pair to the inner plan for the special case.\n        // This trick only works once per plan, BUT once the partitioned data has been\n        // received on the coordinator, it can be treated as replicated data in later\n        // joins, which MAY help with later outer joins with replicated data.\n\n        boolean needInnerSendReceive = m_partitioning.requiresTwoFragments() &&\n                                       ! innerPlan.hasReplicatedResult() &&\n                                       outerPlan.hasReplicatedResult() &&\n                                       joinNode.getJoinType() != JoinType.INNER;\n\n        // When the inner plan is an IndexScan, there MAY be a choice of whether to join using a\n        // NestLoopJoin (NLJ) or a NestLoopIndexJoin (NLIJ). The NLJ will have an advantage over the\n        // NLIJ in the cases where it applies, since it does a single access or iteration over the index\n        // and caches the result, where the NLIJ does an index access or iteration for each outer row.\n        // The NestLoopJoin applies when the inner IndexScan is driven only by parameter and constant\n        // expressions determined at the start of the query. That requires that none of the IndexScan's\n        // various expressions that drive the index access may reference columns from the outer row\n        // -- they can only reference columns of the index's base table (the indexed expressions)\n        // as well as constants and parameters. The IndexScan's \"otherExprs\" expressions that only\n        // drive post-filtering are not an issue since the NestLoopJoin does feature per-outer-tuple\n        // post-filtering on each pass over the cached index scan result.\n\n        // The special case of an OUTER JOIN of replicated outer row data with a partitioned inner\n        // table requires that the partitioned data be sent to the coordinator prior to the join.\n        // This limits the join option to NLJ. The index scan must make a single index access on\n        // each partition and cache the result at the coordinator for post-filtering.\n        // This requires that the index access be based on parameters or constants only\n        // -- the replicated outer row data will only be available later at the coordinator,\n        // so it can not drive the per-partition index scan.\n\n        // If the NLJ option is precluded for the usual reason (outer-row-based indexing) AND\n        // the NLIJ is precluded by the special case (OUTER JOIN of replicated outer rows and\n        // partitioned inner rows) this method returns null, effectively rejecting this indexed\n        // access path for the inner node. Other access paths or join orders may prove more successful.\n\n        boolean canHaveNLJ = true;\n        boolean canHaveNLIJ = true;\n        if (innerPlan instanceof IndexScanPlanNode) {\n            if (hasInnerOuterIndexExpression(joinNode.getRightNode().getTableAlias(),\n                                             innerAccessPath.indexExprs,\n                                             innerAccessPath.initialExpr,\n                                             innerAccessPath.endExprs)) {\n                canHaveNLJ = false;\n            }\n        }\n        else {\n            canHaveNLIJ = false;\n        }\n        if (needInnerSendReceive) {\n            canHaveNLIJ = false;\n        }\n\n        // Prohibit FULL join plans with distributed outer and replicated inner branches -\n        // The join must happen on either a coordinator node or both tables must be joined on\n        // partition columns\n        if (joinNode.getJoinType() == JoinType.FULL &&\n                m_partitioning.requiresTwoFragments() &&\n                !outerPlan.hasReplicatedResult() &&\n                innerPlan.hasReplicatedResult()) {\n            canHaveNLIJ = false;\n            canHaveNLJ = false;\n        }\n\n        AbstractJoinPlanNode ajNode = null;\n        if (canHaveNLJ) {\n            NestLoopPlanNode nljNode = new NestLoopPlanNode();\n            // get all the clauses that join the applicable two tables\n            // Copy innerAccessPath.joinExprs to leave it unchanged,\n            // avoiding accumulation of redundant expressions when\n            // joinClauses gets built up for various alternative plans.\n            ArrayList<AbstractExpression> joinClauses = new ArrayList<>(innerAccessPath.joinExprs);\n            if ((innerPlan instanceof IndexScanPlanNode) ||\n                (innerPlan instanceof NestLoopIndexPlanNode\n                    && innerPlan.getChild(0) instanceof MaterializedScanPlanNode)) {\n                // InnerPlan is an IndexScan OR an NLIJ of a MaterializedScan\n                // (IN LIST) and an IndexScan. In this case, the inner and\n                // inner-outer non-index join expressions (if any) are in the\n                // indexScan's otherExpr. The former should stay as IndexScanPlan\n                // predicates but the latter need to be pulled up into NLJ\n                // predicates because the IndexScan is executed once, not once\n                // per outer tuple.\n                ArrayList<AbstractExpression> otherExprs = new ArrayList<AbstractExpression>();\n                // PLEASE do not update the \"innerAccessPath.otherExprs\", it may be reused\n                // for other path evaluation on the other outer side join.\n                List<AbstractExpression> innerExpr = filterSingleTVEExpressions(innerAccessPath.otherExprs, otherExprs);\n                joinClauses.addAll(otherExprs);\n                IndexScanPlanNode scanNode = null;\n                if (innerPlan instanceof IndexScanPlanNode) {\n                    scanNode = (IndexScanPlanNode)innerPlan;\n                }\n                else {\n                    scanNode = (IndexScanPlanNode)\n                            innerPlan.getInlinePlanNode(PlanNodeType.INDEXSCAN);\n                }\n                scanNode.setPredicate(innerExpr);\n            }\n            else if (innerJoinNode instanceof BranchNode && joinNode.getJoinType() != JoinType.INNER) {\n                // If the innerJoinNode is a LEAF node OR if the join type is an INNER join,\n                // the conditions that apply to the inner side\n                // have been applied as predicates to the inner scan node already.\n\n                // otherExpr of innerAccessPath comes from its parentNode's joinInnerList.\n                // For Outer join (LEFT or FULL), it could mean a join predicate on the table of\n                // the inner node ONLY, that can not be pushed down.\n                joinClauses.addAll(innerAccessPath.otherExprs);\n            }\n            nljNode.setJoinPredicate(ExpressionUtil.combine(joinClauses));\n\n            // combine the tails plan graph with the new head node\n            nljNode.addAndLinkChild(outerPlan);\n\n            // If successful in the special case, the NLJ plan must be modified to cause the\n            // partitioned inner data to be sent to the coordinator prior to the join.\n            // This is done by adding send and receive plan nodes between the NLJ and its\n            // right child node.\n            if (needInnerSendReceive) {\n                // This trick only works once per plan.\n                if (outerPlan.hasAnyNodeOfClass(AbstractReceivePlanNode.class) || innerPlan.hasAnyNodeOfClass(AbstractReceivePlanNode.class)) {\n                    return null;\n                }\n                innerPlan = addSendReceivePair(innerPlan);\n            }\n\n            nljNode.addAndLinkChild(innerPlan);\n            ajNode = nljNode;\n        }\n        else if (canHaveNLIJ) {\n            NestLoopIndexPlanNode nlijNode = new NestLoopIndexPlanNode();\n\n            IndexScanPlanNode innerNode = (IndexScanPlanNode) innerPlan;\n            // Set IndexScan predicate. The INNER join expressions for a FULL join come from\n            // the innerAccessPath.joinExprs and need to be combined with the other join expressions\n            innerNode.setPredicate(innerAccessPath.joinExprs, innerAccessPath.otherExprs);\n\n            nlijNode.addInlinePlanNode(innerPlan);\n\n            // combine the tails plan graph with the new head node\n            nlijNode.addAndLinkChild(outerPlan);\n\n            ajNode = nlijNode;\n        }\n        else {\n            m_recentErrorMsg =\n                \"Unsupported special case of complex OUTER JOIN between replicated outer table and partitioned inner table.\";\n            return null;\n        }\n        ajNode.setJoinType(joinNode.getJoinType());\n        ajNode.setPreJoinPredicate(ExpressionUtil.combine(joinNode.m_joinOuterList));\n        ajNode.setWherePredicate(ExpressionUtil.combine(whereClauses));\n        ajNode.resolveSortDirection();\n        return ajNode;\n    }","commit_id":"d1a5e0b86f746fab7ada7e12d591f5e8dc406e55","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFullJoins() throws NoConnectionsException, IOException, ProcCallException {\n        Client client = getClient();\n        clearSeqTables(client);\n        subtestTwoReplicatedTableFullNLJoin(client);\n        clearSeqTables(client);\n        subtestPartitionTableFullJoin(client);\n    }","id":72485,"modified_method":"public void testFullJoins() throws NoConnectionsException, IOException, ProcCallException {\n        Client client = getClient();\n        clearSeqTables(client);\n        subtestTwoReplicatedTableFullNLJoin(client);\n        clearIndexTables(client);\n        subtestTwoReplicatedTableFullNLIJoin(client);\n        clearSeqTables(client);\n        clearIndexTables(client);\n        subtestDistributedTableFullJoin(client);\n    }","commit_id":"d1a5e0b86f746fab7ada7e12d591f5e8dc406e55","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void subtestPartitionTableFullJoin(Client client)\n            throws NoConnectionsException, IOException, ProcCallException\n    {\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(4, 4);\");\n\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, 5);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, NULL);\");\n\n        String sql;\n        long MINVAL = Long.MIN_VALUE;\n\n        // case 1: equality join on the coordinator node (R2, P1)\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM P1 FULL JOIN R2 ON P1.A = R2.A \" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n;\n        validateTableOfLongs(client, sql, new long[][]{\n                {MINVAL, MINVAL, 5, MINVAL},\n                {MINVAL, MINVAL, 5, 5},\n                {1, 1, 1, 1},\n                {1, 2, 1, 1},\n                {2, 1, 2, 1},\n                {2, 1, 2, 2},\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n     // case 1: equality join of two partitioned tables (P1, P2) on a partition column\n        // @TODO\n    }","id":72486,"modified_method":"private void subtestDistributedTableFullJoin(Client client)\n            throws NoConnectionsException, IOException, ProcCallException\n    {\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(4, 4);\");\n\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P3 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P3 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P3 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P3 VALUES(4, 4);\");\n\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, 5);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, NULL);\");\n\n        String sql;\n        VoltTable vt;\n        long MINVAL = Long.MIN_VALUE;\n\n        // case 1: equality join of (P1, R2) on a partition column P1.A\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM P1 FULL JOIN R2 ON P1.A = R2.A \" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n        validateTableOfLongs(client, sql, new long[][]{\n                {MINVAL, MINVAL, 5, MINVAL},\n                {MINVAL, MINVAL, 5, 5},\n                {1, 1, 1, 1},\n                {1, 2, 1, 1},\n                {2, 1, 2, 1},\n                {2, 1, 2, 2},\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n        // case 2: equality join of (P1, R2) on a non-partition column\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM P1 FULL JOIN R2 ON P1.C = R2.A \" +\n                \"WHERE (P1.A > 1 OR P1.A IS NULL) AND (R2.A = 3 OR R2.A IS NULL)\" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n        validateTableOfLongs(client, sql, new long[][]{\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n        // case 3: NLJ FULL join (R2, P1) on partition column  P1.E = R2.A AND P1.A > 2 are join predicate\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.C = R2.A AND P1.A > 2\" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n        validateTableOfLongs(client, sql, new long[][]{\n                {MINVAL, MINVAL, 1, 1},\n                {MINVAL, MINVAL, 2, 1},\n                {MINVAL, MINVAL, 2, 2},\n                {MINVAL, MINVAL, 5, MINVAL},\n                {MINVAL, MINVAL, 5, 5},\n                {1, 1, MINVAL, MINVAL},\n                {1, 2, MINVAL, MINVAL},\n                {2, 1, MINVAL, MINVAL},\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n      // case 4: NLJ FULL join (R2, P1) on partition column  P1.E = R2.A AND R2.A > 1 are join predicate\n      sql = \"select P1.A, P1.C, R2.A, R2.C FROM  \" +\n              \"P1 FULL JOIN R2 ON P1.C = R2.A AND R2.A > 1\" +\n              \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n      validateTableOfLongs(client, sql, new long[][]{\n              {MINVAL, MINVAL, 1, 1},\n              {MINVAL, MINVAL, 5, MINVAL},\n              {MINVAL, MINVAL, 5, 5},\n              {1, 1, MINVAL, MINVAL},\n              {1, 2, 2, 1},\n              {1, 2, 2, 2},\n              {2, 1, MINVAL, MINVAL},\n              {3, 3, 3, 3},\n              {4, 4, MINVAL, MINVAL}\n              });\n\n      // case 5: equality join of (P3, R2) on a partition/index column P1.A, Still NLJ\n      sql = \"select P3.A, P3.F, R2.A, R2.C FROM P3 FULL JOIN R2 ON P3.A = R2.A \" +\n              \" ORDER BY P3.A, P3.F, R2.A, R2.C\";\n      validateTableOfLongs(client, sql, new long[][]{\n              {MINVAL, MINVAL, 5, MINVAL},\n              {MINVAL, MINVAL, 5, 5},\n              {1, 1, 1, 1},\n              {2, 1, 2, 1},\n              {2, 1, 2, 2},\n              {3, 3, 3, 3},\n              {4, 4, MINVAL, MINVAL}\n              });\n\n      // case 6: NLJ join of (P1, P1) on a partition column P1.A\n      sql = \"select L.A, L.C, R.A, R.C FROM P1 L FULL JOIN P1 R ON L.A = R.A AND L.A = 1 AND R.C = 1\" +\n              \" ORDER BY L.A, L.C, R.A, R.C\";\n      validateTableOfLongs(client, sql, new long[][]{\n              {MINVAL, MINVAL, 1, 2},\n              {MINVAL, MINVAL, 2, 1},\n              {MINVAL, MINVAL, 3, 3},\n              {MINVAL, MINVAL, 4, 4},\n              {1, 1, 1, 1},\n              {1, 2, 1, 1},\n              {2, 1, MINVAL, MINVAL},\n              {3, 3, MINVAL, MINVAL},\n              {4, 4, MINVAL, MINVAL}\n              });\n\n      // case 7: NLIJ join of (P1, P3) on a partition columns\n      sql = \"select P1.A, P1.C, P3.A, P3.F FROM P1 FULL JOIN P3 ON P1.A = P3.A AND P1.A = 1 AND P3.F = 1\" +\n              \" ORDER BY P1.A, P1.C, P3.A, P3.F\";\n      validateTableOfLongs(client, sql, new long[][]{\n              {MINVAL, MINVAL, 2, 1},\n              {MINVAL, MINVAL, 3, 3},\n              {MINVAL, MINVAL, 4, 4},\n              {1, 1, 1, 1},\n              {1, 2, 1, 1},\n              {2, 1, MINVAL, MINVAL},\n              {3, 3, MINVAL, MINVAL},\n              {4, 4, MINVAL, MINVAL}\n              });\n      vt = client.callProcedure(\"@Explain\", sql).getResults()[0];\n      assertTrue(vt.toString().contains(\"NESTLOOP INDEX FULL JOIN\"));\n\n    }","commit_id":"d1a5e0b86f746fab7ada7e12d591f5e8dc406e55","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFullJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_AND, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        // The outer node is a join itself\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n        // WHERE outer-inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL OR R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_OR, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions push down process stops at the FULL join (R1,R2) node -\n        // FULL join is itself an outer node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // OUTER JOIN expression (R1.A > 0) is pre-predicate, inner and inner - outer expressionsR3.C = R2.C AND R3.C < 0 are predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.C = R2.C  AND R1.A > 0 AND R3.C < 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C < 0 AND R2.C > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_LESSTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R1.A = R3.C AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.OPERATOR_IS_NULL, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n    }","id":72487,"modified_method":"public void testFullJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_AND, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        // The outer node is a join itself\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n        // WHERE outer-inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL OR R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_OR, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions push down process stops at the FULL join (R1,R2) node -\n        // FULL join is itself an outer node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // OUTER JOIN expression (R1.A > 0) is pre-predicate, inner and inner - outer expressions R3.C = R2.C AND R3.C < 0 are predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.C = R2.C  AND R1.A > 0 AND R3.C < 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C < 0 AND R2.C > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_LESSTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R1.A = R3.C AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.OPERATOR_IS_NULL, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n    }","commit_id":"d1a5e0b86f746fab7ada7e12d591f5e8dc406e55","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFullIndexJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // Simple FULL NLIJ\n        pn = compile(\"select * FROM  \" +\n                \"R3 FULL JOIN R1 ON R3.A = R1.A WHERE R3.C IS NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN);\n\n        // FULL NLJ. R3.A is an index column but R3.A > 0 expression is used as a POST PREDICATE only\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R3 ON R3.C = R1.A AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R3\");\n\n        // FULL NLIJ, inner join R3.A > 0 is added as a post-predicate to the inline Index scan\n        pn = compile(\"select * FROM R1 FULL JOIN R3 ON R3.A = R1.A AND R3.A > 55\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_GREATERTHAN);\n\n        // FULL NLIJ, inner-outer join R3.c = R1.c is a post-predicate for the inline Index scan\n        pn = compile(\"select * FROM R1 FULL JOIN R3 ON R3.A = R1.A AND R3.c = R1.c\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_EQUAL);\n\n        // FULL NLIJ, outer join (R1, R2) expression R1.A > 0 is a pre-predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.A = R2.C  AND R1.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, null, null, PlanNodeType.NESTLOOP, PlanNodeType.INDEXSCAN, null, \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n    }","id":72488,"modified_method":"public void testFullIndexJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // Simple FULL NLIJ\n        pn = compile(\"select * FROM  \" +\n                \"R3 FULL JOIN R1 ON R3.A = R1.A WHERE R3.C IS NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN);\n\n        // FULL NLJ. R3.A is an index column but R3.A > 0 expression is used as a PREDICATE only\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R3 ON R3.C = R1.A AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R3\");\n\n        // FULL NLIJ, inner join R3.A > 0 is added as a post-predicate to the inline Index scan\n        pn = compile(\"select * FROM R1 FULL JOIN R3 ON R3.A = R1.A AND R3.A > 55\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_GREATERTHAN);\n\n        // FULL NLIJ, inner join L.A > 0 is added as a pre-predicate to the NLIJ\n        pn = compile(\"select * FROM R3 L FULL JOIN R3 R ON L.A = R.A AND L.A > 55\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"L\", \"R\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n\n        // FULL NLIJ, inner-outer join R3.c = R1.c is a post-predicate for the inline Index scan\n        pn = compile(\"select * FROM R1 FULL JOIN R3 ON R3.A = R1.A AND R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_EQUAL);\n\n        // FULL NLIJ, outer join (R1, R2) expression R1.A > 0 is a pre-predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.A = R2.C  AND R1.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, null, null, PlanNodeType.NESTLOOP, PlanNodeType.INDEXSCAN, null, \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n    }","commit_id":"d1a5e0b86f746fab7ada7e12d591f5e8dc406e55","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDistributedFullJoin() {\n        List<AbstractPlanNode> lpn;\n        AbstractPlanNode n;\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"R2 FULL JOIN P1 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on non-partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.C = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join of two partition tables on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN P4 ON P1.A = P4.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"P1\", \"P4\");\n\n        // NLJ FULL join (R2, P2) on partition column  R2.A > 0 is a pre-predicate, P2.A = R2.A AND P2.E < 0 are join predicate\n        // It can't be a NLIJ because P2 is partitioned - P2.A index is not used\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.A = R2.A AND R2.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ FULL join (R2, P2) on partition column  P2.E = R2.A AND P2.A > 0 are join predicate\n        // Inner join expression P2.A > 0 can't be used as index expression with NLJ\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.E = R2.A AND P2.A > 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLIJ (P2,R3) on partition column P2.A using index R3.A\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R3 ON P2.A = R3.A AND R3.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_LESSTHAN, null, null, PlanNodeType.INDEXSCAN, PlanNodeType.INDEXSCAN, \"P2\", \"R3\");\n        verifyIndexScanNode(n.getChild(0), IndexLookupType.GTE, null);\n\n        // NLIJ (P1,P2) on partition column P2.A using index P2.A\n              lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN P1 ON P1.A = P2.A\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"P1\", \"P2\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n\n        // FULL join of two partition tables on non-partition column\n        failToCompile(\"select * FROM  P1 FULL JOIN P4 ON P1.C = P4.A \",\n                \"Join of multiple partitioned tables has insufficient join criteria\");\n}","id":72489,"modified_method":"public void testDistributedFullJoin() {\n        List<AbstractPlanNode> lpn;\n        AbstractPlanNode n;\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"R2 FULL JOIN P1 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on non-partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.C = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ FULL join (R2, P2) on partition column  R2.A > 0 is a pre-predicate, P2.A = R2.A AND P2.E < 0 are join predicate\n        // It can't be a NLIJ because P2 is partitioned - P2.A index is not used\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.A = R2.A AND R2.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ FULL join (R2, P2) on partition column  P2.E = R2.A AND P2.A > 0 are join predicate\n        // Inner join expression P2.A > 0 can't be used as index expression with NLJ\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.E = R2.A AND P2.A > 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ (R3, P2) on partition column P2.A. R3.A > 0 is a PRE_PREDICTAE\n        // NLIJ (P2,R3) on partition column P2.A using index R3.A is an invalid plan for a FULL join\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R3 ON P2.A = R3.A AND R3.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R3\", null);\n\n        // FULL NLJ join of two partition tables on partition column\n        lpn = compileToFragments(\"select * FROM  P1 FULL JOIN P4 ON P1.A = P4.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"P1\", \"P4\");\n\n        // FULL NLIJ (P1,P2) on partition column P2.A\n        lpn = compileToFragments(\"select * FROM P2 FULL JOIN P1 ON P1.A = P2.A AND P2.A > 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"P1\", \"P2\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_GREATERTHAN);\n\n        // FULL join of two partition tables on non-partition column\n        failToCompile(\"select * FROM  P1 FULL JOIN P4 ON P1.C = P4.A \",\n                \"Join of multiple partitioned tables has insufficient join criteria\");\n}","commit_id":"d1a5e0b86f746fab7ada7e12d591f5e8dc406e55","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Given a join node and plan-sub-graph for outer and inner sub-nodes,\n     * construct the plan-sub-graph for that node.\n     *\n     * @param joinNode A parent join node.\n     * @param outerPlan The outer node plan-sub-graph.\n     * @param innerPlan The inner node plan-sub-graph.\n     * @return A completed plan-sub-graph\n     * or null if a valid plan can not be produced for given access paths.\n     */\n    private AbstractPlanNode getSelectSubPlanForJoin(BranchNode joinNode,\n                                                     AbstractPlanNode outerPlan,\n                                                     AbstractPlanNode innerPlan)\n    {\n        // Filter (post-join) expressions\n        ArrayList<AbstractExpression> whereClauses  = new ArrayList<AbstractExpression>();\n        whereClauses.addAll(joinNode.m_whereInnerList);\n        whereClauses.addAll(joinNode.m_whereInnerOuterList);\n        if (joinNode.getJoinType() == JoinType.FULL) {\n            // For all other join types, the whereOuterList expressions were pushed down to the outer node\n            whereClauses.addAll(joinNode.m_whereOuterList);\n        }\n\n        // The usual approach of calculating a local (partial) join result on each partition,\n        // then sending and merging them with other partial results on the coordinator does not\n        // ensure correct answers for some queries like:\n        //     SELECT * FROM replicated LEFT JOIN partitioned ON ...\n        // They require a \"global view\" of the partitioned working set in order to\n        // properly identify which replicated rows need to be null-padded,\n        // and to ensure that the same replicated row is not null-padded redundantly on multiple partitions.\n        // Many queries using this pattern impractically require redistribution and caching of a considerable\n        // subset of a partitioned table in preparation for a \"coordinated\" join.\n        // Yet, there may be useful cases with sufficient constant-based partitioned table filtering\n        // in the \"ON clause\" to keep the distributed working set size under control, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P\n        //     ON R.key == P.non_partition_key AND P.non_partition_key BETWEEN ? and ?;\n        //\n        // Such queries need to be prohibited by the planner if it can not guarantee the\n        // correct results that require a \"send before join\" plan.\n        // This could be the case if the replicated-to-partition join in these examples\n        // were subject to another join with a partitioned table, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P1 ON ...\n        //                                LEFT JOIN also_partitioned P2 ON ...\n        //\n\n        assert(joinNode.getRightNode() != null);\n        JoinNode innerJoinNode = joinNode.getRightNode();\n        AccessPath innerAccessPath = innerJoinNode.m_currentAccessPath;\n        // We may need to add a send/receive pair to the inner plan for the special case.\n        // This trick only works once per plan, BUT once the partitioned data has been\n        // received on the coordinator, it can be treated as replicated data in later\n        // joins, which MAY help with later outer joins with replicated data.\n\n        boolean needInnerSendReceive = m_partitioning.requiresTwoFragments() &&\n                                       ! innerPlan.hasReplicatedResult() &&\n                                       outerPlan.hasReplicatedResult() &&\n                                       joinNode.getJoinType() != JoinType.INNER;\n\n        // When the inner plan is an IndexScan, there MAY be a choice of whether to join using a\n        // NestLoopJoin (NLJ) or a NestLoopIndexJoin (NLIJ). The NLJ will have an advantage over the\n        // NLIJ in the cases where it applies, since it does a single access or iteration over the index\n        // and caches the result, where the NLIJ does an index access or iteration for each outer row.\n        // The NestLoopJoin applies when the inner IndexScan is driven only by parameter and constant\n        // expressions determined at the start of the query. That requires that none of the IndexScan's\n        // various expressions that drive the index access may reference columns from the outer row\n        // -- they can only reference columns of the index's base table (the indexed expressions)\n        // as well as constants and parameters. The IndexScan's \"otherExprs\" expressions that only\n        // drive post-filtering are not an issue since the NestLoopJoin does feature per-outer-tuple\n        // post-filtering on each pass over the cached index scan result.\n\n        // The special case of an OUTER JOIN of replicated outer row data with a partitioned inner\n        // table requires that the partitioned data be sent to the coordinator prior to the join.\n        // This limits the join option to NLJ. The index scan must make a single index access on\n        // each partition and cache the result at the coordinator for post-filtering.\n        // This requires that the index access be based on parameters or constants only\n        // -- the replicated outer row data will only be available later at the coordinator,\n        // so it can not drive the per-partition index scan.\n\n        // If the NLJ option is precluded for the usual reason (outer-row-based indexing) AND\n        // the NLIJ is precluded by the special case (OUTER JOIN of replicated outer rows and\n        // partitioned inner rows) this method returns null, effectively rejecting this indexed\n        // access path for the inner node. Other access paths or join orders may prove more successful.\n\n        boolean canHaveNLJ = true;\n        boolean canHaveNLIJ = true;\n        if (innerPlan instanceof IndexScanPlanNode) {\n            if (hasInnerOuterIndexExpression(joinNode.getRightNode().getTableAlias(),\n                                             innerAccessPath.indexExprs,\n                                             innerAccessPath.initialExpr,\n                                             innerAccessPath.endExprs)) {\n                canHaveNLJ = false;\n            }\n        }\n        else {\n            canHaveNLIJ = false;\n        }\n        if (needInnerSendReceive) {\n            canHaveNLIJ = false;\n        }\n\n        AbstractJoinPlanNode ajNode = null;\n        if (canHaveNLJ) {\n            NestLoopPlanNode nljNode = new NestLoopPlanNode();\n            // get all the clauses that join the applicable two tables\n            ArrayList<AbstractExpression> joinClauses = innerAccessPath.joinExprs;\n            if (innerPlan instanceof IndexScanPlanNode) {\n                // InnerPlan is an IndexScan. In this case the inner and inner-outer\n                // non-index join expressions (if any) are in the otherExpr. The former should stay as\n                // an IndexScanPlan predicate and the latter stay at the NLJ node as a join predicate\n                ArrayList<AbstractExpression> otherExprs = new ArrayList<AbstractExpression>();\n                // PLEASE do not update the \"innerAccessPath.otherExprs\", it may be reused\n                // for other path evaluation on the other outer side join.\n                List<AbstractExpression> innerExpr = filterSingleTVEExpressions(innerAccessPath.otherExprs, otherExprs);\n                joinClauses.addAll(otherExprs);\n                AbstractExpression indexScanPredicate = ExpressionUtil.combine(innerExpr);\n                ((IndexScanPlanNode)innerPlan).setPredicate(indexScanPredicate);\n            }\n            else if (innerJoinNode instanceof BranchNode && joinNode.getJoinType() != JoinType.INNER) {\n                // If the innerJoinNode is a LEAF node OR if the join type is an INNER join,\n                // the conditions that apply to the inner side\n                // have been applied as predicates to the inner scan node already.\n\n                // otherExpr of innerAccessPath comes from its parentNode's joinInnerList.\n                // For Outer join (LEFT or FULL), it could mean a join predicate on the table of\n                // the inner node ONLY, that can not be pushed down.\n                joinClauses.addAll(innerAccessPath.otherExprs);\n            }\n            nljNode.setJoinPredicate(ExpressionUtil.combine(joinClauses));\n\n            // combine the tails plan graph with the new head node\n            nljNode.addAndLinkChild(outerPlan);\n\n            // If successful in the special case, the NLJ plan must be modified to cause the\n            // partitioned inner data to be sent to the coordinator prior to the join.\n            // This is done by adding send and receive plan nodes between the NLJ and its\n            // right child node.\n            if (needInnerSendReceive) {\n                // This trick only works once per plan.\n                if (outerPlan.hasAnyNodeOfType(PlanNodeType.RECEIVE) || innerPlan.hasAnyNodeOfType(PlanNodeType.RECEIVE)) {\n                    return null;\n                }\n                innerPlan = addSendReceivePair(innerPlan);\n            }\n\n            nljNode.addAndLinkChild(innerPlan);\n            ajNode = nljNode;\n        }\n        else if (canHaveNLIJ) {\n            NestLoopIndexPlanNode nlijNode = new NestLoopIndexPlanNode();\n\n            IndexScanPlanNode innerNode = (IndexScanPlanNode) innerPlan;\n            // Set IndexScan predicate. The INNER join expressions for a FULL join come from\n            // the innerAccessPath.joinExprs and needs to be combined with the other join expressions\n            innerNode.setPredicate(ExpressionUtil.combine(innerAccessPath.joinExprs, innerAccessPath.otherExprs));\n\n            nlijNode.addInlinePlanNode(innerPlan);\n\n            // combine the tails plan graph with the new head node\n            nlijNode.addAndLinkChild(outerPlan);\n\n            ajNode = nlijNode;\n        }\n        else {\n            m_recentErrorMsg =\n                \"Unsupported special case of complex OUTER JOIN between replicated outer table and partitioned inner table.\";\n            return null;\n        }\n        ajNode.setJoinType(joinNode.getJoinType());\n        ajNode.setPreJoinPredicate(ExpressionUtil.combine(joinNode.m_joinOuterList));\n        ajNode.setWherePredicate(ExpressionUtil.combine(whereClauses));\n        ajNode.resolveSortDirection();\n        return ajNode;\n    }","id":72490,"modified_method":"/**\n     * Given a join node and plan-sub-graph for outer and inner sub-nodes,\n     * construct the plan-sub-graph for that node.\n     *\n     * @param joinNode A parent join node.\n     * @param outerPlan The outer node plan-sub-graph.\n     * @param innerPlan The inner node plan-sub-graph.\n     * @return A completed plan-sub-graph\n     * or null if a valid plan can not be produced for given access paths.\n     */\n    private AbstractPlanNode getSelectSubPlanForJoin(BranchNode joinNode,\n                                                     AbstractPlanNode outerPlan,\n                                                     AbstractPlanNode innerPlan)\n    {\n        // Filter (post-join) expressions\n        ArrayList<AbstractExpression> whereClauses  = new ArrayList<AbstractExpression>();\n        whereClauses.addAll(joinNode.m_whereInnerList);\n        whereClauses.addAll(joinNode.m_whereInnerOuterList);\n        if (joinNode.getJoinType() == JoinType.FULL) {\n            // For all other join types, the whereOuterList expressions were pushed down to the outer node\n            whereClauses.addAll(joinNode.m_whereOuterList);\n        }\n\n        // The usual approach of calculating a local (partial) join result on each partition,\n        // then sending and merging them with other partial results on the coordinator does not\n        // ensure correct answers for some queries like:\n        //     SELECT * FROM replicated LEFT JOIN partitioned ON ...\n        // They require a \"global view\" of the partitioned working set in order to\n        // properly identify which replicated rows need to be null-padded,\n        // and to ensure that the same replicated row is not null-padded redundantly on multiple partitions.\n        // Many queries using this pattern impractically require redistribution and caching of a considerable\n        // subset of a partitioned table in preparation for a \"coordinated\" join.\n        // Yet, there may be useful cases with sufficient constant-based partitioned table filtering\n        // in the \"ON clause\" to keep the distributed working set size under control, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P\n        //     ON R.key == P.non_partition_key AND P.non_partition_key BETWEEN ? and ?;\n        //\n        // Such queries need to be prohibited by the planner if it can not guarantee the\n        // correct results that require a \"send before join\" plan.\n        // This could be the case if the replicated-to-partition join in these examples\n        // were subject to another join with a partitioned table, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P1 ON ...\n        //                                LEFT JOIN also_partitioned P2 ON ...\n        //\n\n        assert(joinNode.getRightNode() != null);\n        JoinNode innerJoinNode = joinNode.getRightNode();\n        AccessPath innerAccessPath = innerJoinNode.m_currentAccessPath;\n        // We may need to add a send/receive pair to the inner plan for the special case.\n        // This trick only works once per plan, BUT once the partitioned data has been\n        // received on the coordinator, it can be treated as replicated data in later\n        // joins, which MAY help with later outer joins with replicated data.\n\n        boolean needInnerSendReceive = m_partitioning.requiresTwoFragments() &&\n                                       ! innerPlan.hasReplicatedResult() &&\n                                       outerPlan.hasReplicatedResult() &&\n                                       joinNode.getJoinType() != JoinType.INNER;\n\n        // When the inner plan is an IndexScan, there MAY be a choice of whether to join using a\n        // NestLoopJoin (NLJ) or a NestLoopIndexJoin (NLIJ). The NLJ will have an advantage over the\n        // NLIJ in the cases where it applies, since it does a single access or iteration over the index\n        // and caches the result, where the NLIJ does an index access or iteration for each outer row.\n        // The NestLoopJoin applies when the inner IndexScan is driven only by parameter and constant\n        // expressions determined at the start of the query. That requires that none of the IndexScan's\n        // various expressions that drive the index access may reference columns from the outer row\n        // -- they can only reference columns of the index's base table (the indexed expressions)\n        // as well as constants and parameters. The IndexScan's \"otherExprs\" expressions that only\n        // drive post-filtering are not an issue since the NestLoopJoin does feature per-outer-tuple\n        // post-filtering on each pass over the cached index scan result.\n\n        // The special case of an OUTER JOIN of replicated outer row data with a partitioned inner\n        // table requires that the partitioned data be sent to the coordinator prior to the join.\n        // This limits the join option to NLJ. The index scan must make a single index access on\n        // each partition and cache the result at the coordinator for post-filtering.\n        // This requires that the index access be based on parameters or constants only\n        // -- the replicated outer row data will only be available later at the coordinator,\n        // so it can not drive the per-partition index scan.\n\n        // If the NLJ option is precluded for the usual reason (outer-row-based indexing) AND\n        // the NLIJ is precluded by the special case (OUTER JOIN of replicated outer rows and\n        // partitioned inner rows) this method returns null, effectively rejecting this indexed\n        // access path for the inner node. Other access paths or join orders may prove more successful.\n\n        boolean canHaveNLJ = true;\n        boolean canHaveNLIJ = true;\n        if (innerPlan instanceof IndexScanPlanNode) {\n            if (hasInnerOuterIndexExpression(joinNode.getRightNode().getTableAlias(),\n                                             innerAccessPath.indexExprs,\n                                             innerAccessPath.initialExpr,\n                                             innerAccessPath.endExprs)) {\n                canHaveNLJ = false;\n            }\n        }\n        else {\n            canHaveNLIJ = false;\n        }\n        if (needInnerSendReceive) {\n            canHaveNLIJ = false;\n        }\n\n        // Prohibit FULL join plans with distributed outer and replicated inner branches -\n        // The join must happen on either a coordinator node or both tables must be joined on\n        // partition columns\n        if (joinNode.getJoinType() == JoinType.FULL &&\n                m_partitioning.requiresTwoFragments() &&\n                !outerPlan.hasReplicatedResult() &&\n                innerPlan.hasReplicatedResult()) {\n            canHaveNLIJ = false;\n            canHaveNLJ = false;\n        }\n\n        AbstractJoinPlanNode ajNode = null;\n        if (canHaveNLJ) {\n            NestLoopPlanNode nljNode = new NestLoopPlanNode();\n            // get all the clauses that join the applicable two tables\n            ArrayList<AbstractExpression> joinClauses = innerAccessPath.joinExprs;\n            if (innerPlan instanceof IndexScanPlanNode) {\n                // InnerPlan is an IndexScan. In this case the inner and inner-outer\n                // non-index join expressions (if any) are in the otherExpr. The former should stay as\n                // an IndexScanPlan predicate and the latter stay at the NLJ node as a join predicate\n                ArrayList<AbstractExpression> otherExprs = new ArrayList<AbstractExpression>();\n                // PLEASE do not update the \"innerAccessPath.otherExprs\", it may be reused\n                // for other path evaluation on the other outer side join.\n                List<AbstractExpression> innerExpr = filterSingleTVEExpressions(innerAccessPath.otherExprs, otherExprs);\n                joinClauses.addAll(otherExprs);\n                AbstractExpression indexScanPredicate = ExpressionUtil.combine(innerExpr);\n                ((IndexScanPlanNode)innerPlan).setPredicate(indexScanPredicate);\n            }\n            else if (innerJoinNode instanceof BranchNode && joinNode.getJoinType() != JoinType.INNER) {\n                // If the innerJoinNode is a LEAF node OR if the join type is an INNER join,\n                // the conditions that apply to the inner side\n                // have been applied as predicates to the inner scan node already.\n\n                // otherExpr of innerAccessPath comes from its parentNode's joinInnerList.\n                // For Outer join (LEFT or FULL), it could mean a join predicate on the table of\n                // the inner node ONLY, that can not be pushed down.\n                joinClauses.addAll(innerAccessPath.otherExprs);\n            }\n            nljNode.setJoinPredicate(ExpressionUtil.combine(joinClauses));\n\n            // combine the tails plan graph with the new head node\n            nljNode.addAndLinkChild(outerPlan);\n\n            // If successful in the special case, the NLJ plan must be modified to cause the\n            // partitioned inner data to be sent to the coordinator prior to the join.\n            // This is done by adding send and receive plan nodes between the NLJ and its\n            // right child node.\n            if (needInnerSendReceive) {\n                // This trick only works once per plan.\n                if (outerPlan.hasAnyNodeOfType(PlanNodeType.RECEIVE) || innerPlan.hasAnyNodeOfType(PlanNodeType.RECEIVE)) {\n                    return null;\n                }\n                innerPlan = addSendReceivePair(innerPlan);\n            }\n\n            nljNode.addAndLinkChild(innerPlan);\n            ajNode = nljNode;\n        }\n        else if (canHaveNLIJ) {\n            NestLoopIndexPlanNode nlijNode = new NestLoopIndexPlanNode();\n\n            IndexScanPlanNode innerNode = (IndexScanPlanNode) innerPlan;\n            // Set IndexScan predicate. The INNER join expressions for a FULL join come from\n            // the innerAccessPath.joinExprs and needs to be combined with the other join expressions\n            innerNode.setPredicate(ExpressionUtil.combine(innerAccessPath.joinExprs, innerAccessPath.otherExprs));\n\n            nlijNode.addInlinePlanNode(innerPlan);\n\n            // combine the tails plan graph with the new head node\n            nlijNode.addAndLinkChild(outerPlan);\n\n            ajNode = nlijNode;\n        }\n        else {\n            m_recentErrorMsg =\n                \"Unsupported special case of complex OUTER JOIN between replicated outer table and partitioned inner table.\";\n            return null;\n        }\n        ajNode.setJoinType(joinNode.getJoinType());\n        ajNode.setPreJoinPredicate(ExpressionUtil.combine(joinNode.m_joinOuterList));\n        ajNode.setWherePredicate(ExpressionUtil.combine(whereClauses));\n        ajNode.resolveSortDirection();\n        return ajNode;\n    }","commit_id":"94a9173016409d0df6ec06fe5517acde57a5cda6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void subtestPartitionTableFullJoin(Client client)\n            throws NoConnectionsException, IOException, ProcCallException\n    {\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(4, 4);\");\n\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, 5);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, NULL);\");\n\n        String sql;\n        long MINVAL = Long.MIN_VALUE;\n\n        // case 1: equality join on the coordinator node (R2, P1)\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM P1 FULL JOIN R2 ON P1.A = R2.A \" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n;\n        validateTableOfLongs(client, sql, new long[][]{\n                {MINVAL, MINVAL, 5, MINVAL},\n                {MINVAL, MINVAL, 5, 5},\n                {1, 1, 1, 1},\n                {1, 2, 1, 1},\n                {2, 1, 2, 1},\n                {2, 1, 2, 2},\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n     // case 1: equality join of two partitioned tables (P1, P2) on a partition column\n        // @TODO\n    }","id":72491,"modified_method":"private void subtestDistributedTableFullJoin(Client client)\n            throws NoConnectionsException, IOException, ProcCallException\n    {\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(4, 4);\");\n\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P3 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P3 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P3 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P3 VALUES(4, 4);\");\n\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, 5);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, NULL);\");\n\n        String sql;\n        VoltTable vt;\n        long MINVAL = Long.MIN_VALUE;\n\n        // case 1: equality join of (P1, R2) on a partition column P1.A\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM P1 FULL JOIN R2 ON P1.A = R2.A \" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n        validateTableOfLongs(client, sql, new long[][]{\n                {MINVAL, MINVAL, 5, MINVAL},\n                {MINVAL, MINVAL, 5, 5},\n                {1, 1, 1, 1},\n                {1, 2, 1, 1},\n                {2, 1, 2, 1},\n                {2, 1, 2, 2},\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n        // case 2: equality join of (P1, R2) on a non-partition column\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM P1 FULL JOIN R2 ON P1.C = R2.A \" +\n                \"WHERE (P1.A > 1 OR P1.A IS NULL) AND (R2.A = 3 OR R2.A IS NULL)\" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n        validateTableOfLongs(client, sql, new long[][]{\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n        // case 3: NLJ FULL join (R2, P1) on partition column  P1.E = R2.A AND P1.A > 2 are join predicate\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.C = R2.A AND P1.A > 2\" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n        validateTableOfLongs(client, sql, new long[][]{\n                {MINVAL, MINVAL, 1, 1},\n                {MINVAL, MINVAL, 2, 1},\n                {MINVAL, MINVAL, 2, 2},\n                {MINVAL, MINVAL, 5, MINVAL},\n                {MINVAL, MINVAL, 5, 5},\n                {1, 1, MINVAL, MINVAL},\n                {1, 2, MINVAL, MINVAL},\n                {2, 1, MINVAL, MINVAL},\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n      // case 4: NLJ FULL join (R2, P1) on partition column  P1.E = R2.A AND R2.A > 1 are join predicate\n      sql = \"select P1.A, P1.C, R2.A, R2.C FROM  \" +\n              \"P1 FULL JOIN R2 ON P1.C = R2.A AND R2.A > 1\" +\n              \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n      validateTableOfLongs(client, sql, new long[][]{\n              {MINVAL, MINVAL, 1, 1},\n              {MINVAL, MINVAL, 5, MINVAL},\n              {MINVAL, MINVAL, 5, 5},\n              {1, 1, MINVAL, MINVAL},\n              {1, 2, 2, 1},\n              {1, 2, 2, 2},\n              {2, 1, MINVAL, MINVAL},\n              {3, 3, 3, 3},\n              {4, 4, MINVAL, MINVAL}\n              });\n\n      // case 5: equality join of (P3, R2) on a partition/index column P1.A, Still NLJ\n      sql = \"select P3.A, P3.F, R2.A, R2.C FROM P3 FULL JOIN R2 ON P3.A = R2.A \" +\n              \" ORDER BY P3.A, P3.F, R2.A, R2.C\";\n      validateTableOfLongs(client, sql, new long[][]{\n              {MINVAL, MINVAL, 5, MINVAL},\n              {MINVAL, MINVAL, 5, 5},\n              {1, 1, 1, 1},\n              {2, 1, 2, 1},\n              {2, 1, 2, 2},\n              {3, 3, 3, 3},\n              {4, 4, MINVAL, MINVAL}\n              });\n\n      // case 6: NLJ join of (P1, P1) on a partition column P1.A\n      sql = \"select L.A, L.C, R.A, R.C FROM P1 L FULL JOIN P1 R ON L.A = R.A AND L.A = 1 AND R.C = 1\" +\n              \" ORDER BY L.A, L.C, R.A, R.C\";\n      validateTableOfLongs(client, sql, new long[][]{\n              {MINVAL, MINVAL, 1, 2},\n              {MINVAL, MINVAL, 2, 1},\n              {MINVAL, MINVAL, 3, 3},\n              {MINVAL, MINVAL, 4, 4},\n              {1, 1, 1, 1},\n              {1, 2, 1, 1},\n              {2, 1, MINVAL, MINVAL},\n              {3, 3, MINVAL, MINVAL},\n              {4, 4, MINVAL, MINVAL}\n              });\n\n      // case 7: NLIJ join of (P1, P3) on a partition columns\n      sql = \"select P1.A, P1.C, P3.A, P3.F FROM P1 FULL JOIN P3 ON P1.A = P3.A AND P1.A = 1 AND P3.F = 1\" +\n              \" ORDER BY P1.A, P1.C, P3.A, P3.F\";\n      validateTableOfLongs(client, sql, new long[][]{\n              {MINVAL, MINVAL, 2, 1},\n              {MINVAL, MINVAL, 3, 3},\n              {MINVAL, MINVAL, 4, 4},\n              {1, 1, 1, 1},\n              {1, 2, 1, 1},\n              {2, 1, MINVAL, MINVAL},\n              {3, 3, MINVAL, MINVAL},\n              {4, 4, MINVAL, MINVAL}\n              });\n      vt = client.callProcedure(\"@Explain\", sql).getResults()[0];\n      assertTrue(vt.toString().contains(\"NESTLOOP INDEX FULL JOIN\"));\n\n    }","commit_id":"94a9173016409d0df6ec06fe5517acde57a5cda6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFullJoins() throws NoConnectionsException, IOException, ProcCallException {\n        Client client = getClient();\n        clearSeqTables(client);\n        subtestTwoReplicatedTableFullNLJoin(client);\n        clearSeqTables(client);\n        subtestPartitionTableFullJoin(client);\n    }","id":72492,"modified_method":"public void testFullJoins() throws NoConnectionsException, IOException, ProcCallException {\n        Client client = getClient();\n        clearSeqTables(client);\n        subtestTwoReplicatedTableFullNLJoin(client);\n        clearIndexTables(client);\n        subtestTwoReplicatedTableFullNLIJoin(client);\n        clearSeqTables(client);\n        clearIndexTables(client);\n        subtestDistributedTableFullJoin(client);\n    }","commit_id":"94a9173016409d0df6ec06fe5517acde57a5cda6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFullIndexJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // Simple FULL NLIJ\n        pn = compile(\"select * FROM  \" +\n                \"R3 FULL JOIN R1 ON R3.A = R1.A WHERE R3.C IS NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN);\n\n        // FULL NLJ. R3.A is an index column but R3.A > 0 expression is used as a POST PREDICATE only\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R3 ON R3.C = R1.A AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R3\");\n\n        // FULL NLIJ, inner join R3.A > 0 is added as a post-predicate to the inline Index scan\n        pn = compile(\"select * FROM R1 FULL JOIN R3 ON R3.A = R1.A AND R3.A > 55\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_GREATERTHAN);\n\n        // FULL NLIJ, inner-outer join R3.c = R1.c is a post-predicate for the inline Index scan\n        pn = compile(\"select * FROM R1 FULL JOIN R3 ON R3.A = R1.A AND R3.c = R1.c\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_EQUAL);\n\n        // FULL NLIJ, outer join (R1, R2) expression R1.A > 0 is a pre-predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.A = R2.C  AND R1.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, null, null, PlanNodeType.NESTLOOP, PlanNodeType.INDEXSCAN, null, \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n    }","id":72493,"modified_method":"public void testFullIndexJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // Simple FULL NLIJ\n        pn = compile(\"select * FROM  \" +\n                \"R3 FULL JOIN R1 ON R3.A = R1.A WHERE R3.C IS NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN);\n\n        // FULL NLJ. R3.A is an index column but R3.A > 0 expression is used as a PREDICATE only\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R3 ON R3.C = R1.A AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R3\");\n\n        // FULL NLIJ, inner join R3.A > 0 is added as a post-predicate to the inline Index scan\n        pn = compile(\"select * FROM R1 FULL JOIN R3 ON R3.A = R1.A AND R3.A > 55\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_GREATERTHAN);\n\n        // FULL NLIJ, inner join L.A > 0 is added as a pre-predicate to the NLIJ\n        pn = compile(\"select * FROM R3 L FULL JOIN R3 R ON L.A = R.A AND L.A > 55\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"L\", \"R\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n\n        // FULL NLIJ, inner-outer join R3.c = R1.c is a post-predicate for the inline Index scan\n        pn = compile(\"select * FROM R1 FULL JOIN R3 ON R3.A = R1.A AND R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_EQUAL);\n\n        // FULL NLIJ, outer join (R1, R2) expression R1.A > 0 is a pre-predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.A = R2.C  AND R1.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, null, null, PlanNodeType.NESTLOOP, PlanNodeType.INDEXSCAN, null, \"R3\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n    }","commit_id":"94a9173016409d0df6ec06fe5517acde57a5cda6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFullJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_AND, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        // The outer node is a join itself\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n        // WHERE outer-inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL OR R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_OR, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions push down process stops at the FULL join (R1,R2) node -\n        // FULL join is itself an outer node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // OUTER JOIN expression (R1.A > 0) is pre-predicate, inner and inner - outer expressionsR3.C = R2.C AND R3.C < 0 are predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.C = R2.C  AND R1.A > 0 AND R3.C < 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C < 0 AND R2.C > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_LESSTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R1.A = R3.C AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.OPERATOR_IS_NULL, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n    }","id":72494,"modified_method":"public void testFullJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_AND, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        // The outer node is a join itself\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n        // WHERE outer-inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL OR R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_OR, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions push down process stops at the FULL join (R1,R2) node -\n        // FULL join is itself an outer node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // OUTER JOIN expression (R1.A > 0) is pre-predicate, inner and inner - outer expressions R3.C = R2.C AND R3.C < 0 are predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.C = R2.C  AND R1.A > 0 AND R3.C < 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C < 0 AND R2.C > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_LESSTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R1.A = R3.C AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.OPERATOR_IS_NULL, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n    }","commit_id":"94a9173016409d0df6ec06fe5517acde57a5cda6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDistributedFullJoin() {\n        List<AbstractPlanNode> lpn;\n        AbstractPlanNode n;\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"R2 FULL JOIN P1 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on non-partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.C = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join of two partition tables on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN P4 ON P1.A = P4.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"P1\", \"P4\");\n\n        // NLJ FULL join (R2, P2) on partition column  R2.A > 0 is a pre-predicate, P2.A = R2.A AND P2.E < 0 are join predicate\n        // It can't be a NLIJ because P2 is partitioned - P2.A index is not used\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.A = R2.A AND R2.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ FULL join (R2, P2) on partition column  P2.E = R2.A AND P2.A > 0 are join predicate\n        // Inner join expression P2.A > 0 can't be used as index expression with NLJ\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.E = R2.A AND P2.A > 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLIJ (P2,R3) on partition column P2.A using index R3.A\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R3 ON P2.A = R3.A AND R3.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_LESSTHAN, null, null, PlanNodeType.INDEXSCAN, PlanNodeType.INDEXSCAN, \"P2\", \"R3\");\n        verifyIndexScanNode(n.getChild(0), IndexLookupType.GTE, null);\n\n        // NLIJ (P1,P2) on partition column P2.A using index P2.A\n              lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN P1 ON P1.A = P2.A\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"P1\", \"P2\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n\n        // FULL join of two partition tables on non-partition column\n        failToCompile(\"select * FROM  P1 FULL JOIN P4 ON P1.C = P4.A \",\n                \"Join of multiple partitioned tables has insufficient join criteria\");\n}","id":72495,"modified_method":"public void testDistributedFullJoin() {\n        List<AbstractPlanNode> lpn;\n        AbstractPlanNode n;\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"R2 FULL JOIN P1 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on non-partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.C = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ FULL join (R2, P2) on partition column  R2.A > 0 is a pre-predicate, P2.A = R2.A AND P2.E < 0 are join predicate\n        // It can't be a NLIJ because P2 is partitioned - P2.A index is not used\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.A = R2.A AND R2.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ FULL join (R2, P2) on partition column  P2.E = R2.A AND P2.A > 0 are join predicate\n        // Inner join expression P2.A > 0 can't be used as index expression with NLJ\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.E = R2.A AND P2.A > 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ (R3, P2) on partition column P2.A. R3.A > 0 is a PRE_PREDICTAE\n        // NLIJ (P2,R3) on partition column P2.A using index R3.A is an invalid plan for a FULL join\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R3 ON P2.A = R3.A AND R3.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R3\", null);\n\n        // FULL NLJ join of two partition tables on partition column\n        lpn = compileToFragments(\"select * FROM  P1 FULL JOIN P4 ON P1.A = P4.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"P1\", \"P4\");\n\n        // FULL NLIJ (P1,P2) on partition column P2.A\n        lpn = compileToFragments(\"select * FROM P2 FULL JOIN P1 ON P1.A = P2.A AND P2.A > 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"P1\", \"P2\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, ExpressionType.COMPARE_GREATERTHAN);\n\n        // FULL join of two partition tables on non-partition column\n        failToCompile(\"select * FROM  P1 FULL JOIN P4 ON P1.C = P4.A \",\n                \"Join of multiple partitioned tables has insufficient join criteria\");\n}","commit_id":"94a9173016409d0df6ec06fe5517acde57a5cda6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     *\n     * @param exps\n     */\n    public static AbstractExpression combine(Collection<AbstractExpression> exps) {\n        if (exps.isEmpty()) {\n            return null;\n        }\n        Stack<AbstractExpression> stack = new Stack<AbstractExpression>();\n        stack.addAll(exps);\n\n        // TODO: This code probably doesn't need to go through all this trouble to create AND trees\n        // like \"((D and C) and B) and A)\" from the list \"[A, B, C, D]\".\n        // There is an easier algorithm that does not require stacking intermediate results.\n        // Even better, it would be easier here to generate \"(D and (C and (B and A)))\"\n        // which would also short-circuit slightly faster in the executor.\n        // NOTE: Any change to the structure of the trees produced by this algorithm should be\n        // reflected in the algorithm used to reverse the process in uncombine(AbstractExpression expr).\n\n        AbstractExpression ret = null;\n        while (stack.size() > 1) {\n            AbstractExpression child_exp = stack.pop();\n            //\n            // If our return node is null, then we need to make a new one\n            //\n            if (ret == null) {\n                ret = new ConjunctionExpression(ExpressionType.CONJUNCTION_AND);\n                ret.setLeft(child_exp);\n            //\n            // Check whether we can add it to the right side\n            //\n            } else if (ret.getRight() == null) {\n                ret.setRight(child_exp);\n                stack.push(ret);\n                ret = null;\n            }\n        }\n        if (ret == null) {\n            ret = stack.pop();\n        } else {\n            ret.setRight(stack.pop());\n        }\n        // Simplify combined expression if possible\n        return ExpressionUtil.evaluateExpression(ret);\n    }","id":72496,"modified_method":"/**\n     *\n     * @param exps\n     */\n    public static AbstractExpression combine(Collection<AbstractExpression> exps) {\n        if (exps.isEmpty()) {\n            return null;\n        }\n        Stack<AbstractExpression> stack = new Stack<AbstractExpression>();\n        stack.addAll(exps);\n        return combine(stack);\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Generate all possible access paths for an inner node in a join.\n     * The set of potential index expressions depends whether the inner node can be inlined\n     * with the NLIJ or not. In the former case, inner and inner-outer join expressions can\n     * be considered for the index access. In the latter, only inner join expressions qualifies.\n     *\n     * @param parentNode A parent node to the node to generate paths to.\n     */\n    private void generateInnerAccessPaths(BranchNode parentNode) {\n        JoinNode innerChildNode = parentNode.getRightNode();\n        assert(innerChildNode != null);\n        // In case of inner join WHERE and JOIN expressions can be merged\n        if (parentNode.getJoinType() == JoinType.INNER) {\n            parentNode.m_joinInnerOuterList.addAll(parentNode.m_whereInnerOuterList);\n            parentNode.m_whereInnerOuterList.clear();\n            parentNode.m_joinInnerList.addAll(parentNode.m_whereInnerList);\n            parentNode.m_whereInnerList.clear();\n        }\n        if (innerChildNode instanceof BranchNode) {\n            generateOuterAccessPaths((BranchNode)innerChildNode);\n            generateInnerAccessPaths((BranchNode)innerChildNode);\n            // The inner node is a join node itself. Only naive access path is possible\n            innerChildNode.m_accessPaths.add(\n                    getRelevantNaivePath(parentNode.m_joinInnerOuterList, parentNode.m_joinInnerList));\n            return;\n        }\n\n        // For the FULL join type, the inner join expressions must stay at the join node and\n        // not go down as a filter to the inner node like in case of other join types\n        List<AbstractExpression> joinExpressions;\n        List<AbstractExpression> filterExpressions;\n        if (parentNode.getJoinType() == JoinType.FULL) {\n            joinExpressions = new ArrayList<>();\n            joinExpressions.addAll(parentNode.m_joinInnerOuterList);\n            joinExpressions.addAll(parentNode.m_joinInnerList);\n            filterExpressions = null;\n        } else {\n            joinExpressions = parentNode.m_joinInnerOuterList;\n            filterExpressions = parentNode.m_joinInnerList;\n        }\n\n        // The inner table can have multiple index access paths based on\n        // inner and inner-outer join expressions plus the naive one.\n        innerChildNode.m_accessPaths.addAll(\n                getRelevantAccessPathsForTable(innerChildNode.getTableScan(),\n                        joinExpressions, filterExpressions, null));\n\n        // If there are inner expressions AND inner-outer expressions, it could be that there\n        // are indexed access paths that use elements of both in the indexing expressions,\n        // especially in the case of a compound index.\n        // These access paths can not be considered for use with an NLJ because they rely on\n        // inner-outer expressions.\n        // If there is a possibility that NLIJ will not be an option due to the\n        // \"special case\" processing that puts a send/receive plan between the join node\n        // and its inner child node, other access paths need to be considered that use the\n        // same indexes as those identified so far but in a simpler, less effective way\n        // that does not rely on inner-outer expressions.\n        // The following simplistic method of finding these access paths is to force\n        // inner-outer expressions to be handled as NLJ-compatible post-filters and repeat\n        // the search for access paths.\n        // This will typically generate some duplicate access paths, including the naive\n        // sequential scan path and any indexed paths that happened to use only the inner\n        // expressions.\n        // For now, we deal with this redundancy by dropping (and re-generating) all\n        // access paths EXCPT those that reference the inner-outer expressions.\n        // TODO: implementing access path hash and equality and possibly using a \"Set\"\n        // would allow deduping as new access paths are added OR\n        // the simplified access path search process could be based on\n        // the existing indexed access paths -- for each access path that \"hasInnerOuterIndexExpression\"\n        // try to generate and add a simpler access path using the same index,\n        // this time with the inner-outer expressions used only as non-indexable post-filters.\n\n        // Don't bother generating these redundant or inferior access paths unless there is\n        // an inner-outer expression and a chance that NLIJ will be taken out of the running.\n        StmtTableScan innerTable = innerChildNode.getTableScan();\n        assert(innerTable != null);\n        boolean mayNeedInnerSendReceive = ( ! m_partitioning.wasSpecifiedAsSingle()) &&\n                (m_partitioning.getCountOfPartitionedTables() > 0) &&\n                (parentNode.getJoinType() != JoinType.INNER) &&\n                ! innerTable.getIsReplicated();\n// too expensive/complicated to test here? (parentNode.m_leftNode has a replicated result?) &&\n\n        if (mayNeedInnerSendReceive && ! parentNode.m_joinInnerOuterList.isEmpty()) {\n            List<AccessPath> innerOuterAccessPaths = new ArrayList<AccessPath>();\n            for (AccessPath innerAccessPath : innerChildNode.m_accessPaths) {\n                if ((innerAccessPath.index != null) &&\n                    hasInnerOuterIndexExpression(innerChildNode.getTableAlias(),\n                                                 innerAccessPath.indexExprs,\n                                                 innerAccessPath.initialExpr,\n                                                 innerAccessPath.endExprs)) {\n                    innerOuterAccessPaths.add(innerAccessPath);\n                }\n            }\n            Collection<AccessPath> nljAccessPaths =\n                    getRelevantAccessPathsForTable(innerChildNode.getTableScan(),\n                                                   null,\n                                                   parentNode.m_joinInnerList,\n                                                   parentNode.m_joinInnerOuterList);\n            innerChildNode.m_accessPaths.clear();\n            innerChildNode.m_accessPaths.addAll(nljAccessPaths);\n            innerChildNode.m_accessPaths.addAll(innerOuterAccessPaths);\n        }\n\n        assert(innerChildNode.m_accessPaths.size() > 0);\n    }","id":72497,"modified_method":"/**\n     * Generate all possible access paths for an inner node in a join.\n     * The set of potential index expressions depends whether the inner node can be inlined\n     * with the NLIJ or not. In the former case, inner and inner-outer join expressions can\n     * be considered for the index access. In the latter, only inner join expressions qualifies.\n     *\n     * @param parentNode A parent node to the node to generate paths to.\n     */\n    private void generateInnerAccessPaths(BranchNode parentNode) {\n        JoinNode innerChildNode = parentNode.getRightNode();\n        assert(innerChildNode != null);\n        // In case of inner join WHERE and JOIN expressions can be merged\n        if (parentNode.getJoinType() == JoinType.INNER) {\n            parentNode.m_joinInnerOuterList.addAll(parentNode.m_whereInnerOuterList);\n            parentNode.m_whereInnerOuterList.clear();\n            parentNode.m_joinInnerList.addAll(parentNode.m_whereInnerList);\n            parentNode.m_whereInnerList.clear();\n        }\n        if (innerChildNode instanceof BranchNode) {\n            generateOuterAccessPaths((BranchNode)innerChildNode);\n            generateInnerAccessPaths((BranchNode)innerChildNode);\n            // The inner node is a join node itself. Only naive access path is possible\n            innerChildNode.m_accessPaths.add(\n                    getRelevantNaivePath(parentNode.m_joinInnerOuterList, parentNode.m_joinInnerList));\n            return;\n        }\n\n        // The inner table can have multiple index access paths based on\n        // inner and inner-outer join expressions plus the naive one.\n        if (parentNode.getJoinType() != JoinType.FULL) {\n            innerChildNode.m_accessPaths.addAll(\n                    getRelevantAccessPathsForTable(innerChildNode.getTableScan(),\n                            parentNode.m_joinInnerOuterList, parentNode.m_joinInnerList, null));\n        } else {\n            // For the FULL join type, the inner join expressions must stay at the join node and\n            // not go down to the inner node as filters (as predicates for SeqScan nodes and/or\n            // index expressions for Index Scan). The latter case (IndexScan) won't work for NLJ because\n            // the inner join expression will effectively filter out inner tuple prior to the NLJ.\n            innerChildNode.m_accessPaths.addAll(\n                    getRelevantAccessPathsForTable(innerChildNode.getTableScan(),\n                            parentNode.m_joinInnerOuterList, null, parentNode.m_joinInnerList));\n        }\n\n        // If there are inner expressions AND inner-outer expressions, it could be that there\n        // are indexed access paths that use elements of both in the indexing expressions,\n        // especially in the case of a compound index.\n        // These access paths can not be considered for use with an NLJ because they rely on\n        // inner-outer expressions.\n        // If there is a possibility that NLIJ will not be an option due to the\n        // \"special case\" processing that puts a send/receive plan between the join node\n        // and its inner child node, other access paths need to be considered that use the\n        // same indexes as those identified so far but in a simpler, less effective way\n        // that does not rely on inner-outer expressions.\n        // The following simplistic method of finding these access paths is to force\n        // inner-outer expressions to be handled as NLJ-compatible post-filters and repeat\n        // the search for access paths.\n        // This will typically generate some duplicate access paths, including the naive\n        // sequential scan path and any indexed paths that happened to use only the inner\n        // expressions.\n        // For now, we deal with this redundancy by dropping (and re-generating) all\n        // access paths EXCPT those that reference the inner-outer expressions.\n        // TODO: implementing access path hash and equality and possibly using a \"Set\"\n        // would allow deduping as new access paths are added OR\n        // the simplified access path search process could be based on\n        // the existing indexed access paths -- for each access path that \"hasInnerOuterIndexExpression\"\n        // try to generate and add a simpler access path using the same index,\n        // this time with the inner-outer expressions used only as non-indexable post-filters.\n\n        // Don't bother generating these redundant or inferior access paths unless there is\n        // an inner-outer expression and a chance that NLIJ will be taken out of the running.\n        StmtTableScan innerTable = innerChildNode.getTableScan();\n        assert(innerTable != null);\n        boolean mayNeedInnerSendReceive = ( ! m_partitioning.wasSpecifiedAsSingle()) &&\n                (m_partitioning.getCountOfPartitionedTables() > 0) &&\n                (parentNode.getJoinType() != JoinType.INNER) &&\n                ! innerTable.getIsReplicated();\n// too expensive/complicated to test here? (parentNode.m_leftNode has a replicated result?) &&\n\n        if (mayNeedInnerSendReceive && ! parentNode.m_joinInnerOuterList.isEmpty()) {\n            List<AccessPath> innerOuterAccessPaths = new ArrayList<AccessPath>();\n            for (AccessPath innerAccessPath : innerChildNode.m_accessPaths) {\n                if ((innerAccessPath.index != null) &&\n                    hasInnerOuterIndexExpression(innerChildNode.getTableAlias(),\n                                                 innerAccessPath.indexExprs,\n                                                 innerAccessPath.initialExpr,\n                                                 innerAccessPath.endExprs)) {\n                    innerOuterAccessPaths.add(innerAccessPath);\n                }\n            }\n            Collection<AccessPath> nljAccessPaths;\n            if (parentNode.getJoinType() != JoinType.FULL) {\n                nljAccessPaths = getRelevantAccessPathsForTable(innerChildNode.getTableScan(),\n                                                                null,\n                                                                parentNode.m_joinInnerList,\n                                                                parentNode.m_joinInnerOuterList);\n            } else {\n                // For FULL join type the inner join expressions must be part of the post predicate\n                // in order to stay at the join node and not be pushed down to the inner node\n                List<AbstractExpression> postExpressions = new ArrayList<>();\n                postExpressions.addAll(parentNode.m_joinInnerList);\n                postExpressions.addAll(parentNode.m_joinInnerOuterList);\n                nljAccessPaths = getRelevantAccessPathsForTable(innerChildNode.getTableScan(),\n                                                                null,\n                                                                null,\n                                                                postExpressions);\n            }\n            innerChildNode.m_accessPaths.clear();\n            innerChildNode.m_accessPaths.addAll(nljAccessPaths);\n            innerChildNode.m_accessPaths.addAll(innerOuterAccessPaths);\n        }\n\n        assert(innerChildNode.m_accessPaths.size() > 0);\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Generate all possible access paths for an outer node in a join.\n     * The outer table and/or join can have the naive access path and possible index path(s)\n     * Optimizations - outer-table-only where expressions can be pushed down to the child node\n     * to pre-qualify the outer tuples before they enter the join.\n     * For inner joins outer-table-only join expressions can be pushed down as well\n     *\n     * @param parentNode A parent node to the node to generate paths to.\n     */\n    private void generateOuterAccessPaths(BranchNode parentNode) {\n        JoinNode outerChildNode = parentNode.getLeftNode();\n        assert(outerChildNode != null);\n        JoinType joinType = parentNode.getJoinType();\n        // For LEFT and FULL join types, the outer join expressions are kept as a pre-join predicate\n        // at the join node to pre-qualify the outer rows\n        List<AbstractExpression> joinOuterList =  (joinType == JoinType.INNER) ?\n                parentNode.m_joinOuterList : null;\n        if (outerChildNode instanceof BranchNode) {\n            generateOuterAccessPaths((BranchNode)outerChildNode);\n            generateInnerAccessPaths((BranchNode)outerChildNode);\n            // The join node can have only sequential scan access\n            outerChildNode.m_accessPaths.add(getRelevantNaivePath(joinOuterList,\n                    parentNode.m_whereOuterList));\n            assert(outerChildNode.m_accessPaths.size() > 0);\n            return;\n        }\n        // WHERE Outer expressions must stay at the join node for the FULL joins\n        // They will be added later as part of the WHERE predicate of the join node\n        List<AbstractExpression> whereOuterList =  (joinType == JoinType.FULL) ?\n                null : parentNode.m_whereOuterList;\n        outerChildNode.m_accessPaths.addAll(\n                getRelevantAccessPathsForTable(outerChildNode.getTableScan(),\n                        joinOuterList, whereOuterList, null));\n    }","id":72498,"modified_method":"/**\n     * Generate all possible access paths for an outer node in a join.\n     * The outer table and/or join can have the naive access path and possible index path(s)\n     * Optimizations - outer-table-only where expressions can be pushed down to the child node\n     * to pre-qualify the outer tuples before they enter the join.\n     * For inner joins outer-table-only join expressions can be pushed down as well\n     *\n     * @param parentNode A parent node to the node to generate paths to.\n     */\n    private void generateOuterAccessPaths(BranchNode parentNode) {\n        JoinNode outerChildNode = parentNode.getLeftNode();\n        assert(outerChildNode != null);\n        JoinType joinType = parentNode.getJoinType();\n        // For LEFT and FULL join types, the outer join expressions are kept as a pre-join predicate\n        // at the join node to pre-qualify the outer rows\n        List<AbstractExpression> joinOuterList =  (joinType == JoinType.INNER) ?\n                parentNode.m_joinOuterList : null;\n        if (outerChildNode instanceof BranchNode) {\n            generateOuterAccessPaths((BranchNode)outerChildNode);\n            generateInnerAccessPaths((BranchNode)outerChildNode);\n            // The join node can have only sequential scan access\n            outerChildNode.m_accessPaths.add(getRelevantNaivePath(joinOuterList,\n                    parentNode.m_whereOuterList));\n            assert(outerChildNode.m_accessPaths.size() > 0);\n            return;\n        }\n        // WHERE Outer expressions must stay at the join node for the FULL joins\n        // They will be added later as part of the WHERE predicate of the join node\n        if (joinType != JoinType.FULL) {\n            outerChildNode.m_accessPaths.addAll(\n                getRelevantAccessPathsForTable(outerChildNode.getTableScan(),\n                        joinOuterList, parentNode.m_whereOuterList, null));\n        } else {\n            outerChildNode.m_accessPaths.addAll(\n                    getRelevantAccessPathsForTable(outerChildNode.getTableScan(),\n                            joinOuterList, null, null));\n        }\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Given a join node and plan-sub-graph for outer and inner sub-nodes,\n     * construct the plan-sub-graph for that node.\n     *\n     * @param joinNode A parent join node.\n     * @param outerPlan The outer node plan-sub-graph.\n     * @param innerPlan The inner node plan-sub-graph.\n     * @return A completed plan-sub-graph\n     * or null if a valid plan can not be produced for given access paths.\n     */\n    private AbstractPlanNode getSelectSubPlanForJoin(BranchNode joinNode,\n                                                     AbstractPlanNode outerPlan,\n                                                     AbstractPlanNode innerPlan)\n    {\n        // Filter (post-join) expressions\n        ArrayList<AbstractExpression> whereClauses  = new ArrayList<AbstractExpression>();\n        whereClauses.addAll(joinNode.m_whereInnerList);\n        whereClauses.addAll(joinNode.m_whereInnerOuterList);\n        if (joinNode.getJoinType() == JoinType.FULL) {\n            // For all other join types, the whereOuterList expressions were pushed down\n            // to the outer node\n            whereClauses.addAll(joinNode.m_whereOuterList);\n        }\n\n        // The usual approach of calculating a local (partial) join result on each partition,\n        // then sending and merging them with other partial results on the coordinator does not\n        // ensure correct answers for some queries like:\n        //     SELECT * FROM replicated LEFT JOIN partitioned ON ...\n        // They require a \"global view\" of the partitioned working set in order to\n        // properly identify which replicated rows need to be null-padded,\n        // and to ensure that the same replicated row is not null-padded redundantly on multiple partitions.\n        // Many queries using this pattern impractically require redistribution and caching of a considerable\n        // subset of a partitioned table in preparation for a \"coordinated\" join.\n        // Yet, there may be useful cases with sufficient constant-based partitioned table filtering\n        // in the \"ON clause\" to keep the distributed working set size under control, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P\n        //     ON R.key == P.non_partition_key AND P.non_partition_key BETWEEN ? and ?;\n        //\n        // Such queries need to be prohibited by the planner if it can not guarantee the\n        // correct results that require a \"send before join\" plan.\n        // This could be the case if the replicated-to-partition join in these examples\n        // were subject to another join with a partitioned table, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P1 ON ...\n        //                                LEFT JOIN also_partitioned P2 ON ...\n        //\n\n        assert(joinNode.getRightNode() != null);\n        JoinNode innerJoinNode = joinNode.getRightNode();\n        AccessPath innerAccessPath = innerJoinNode.m_currentAccessPath;\n        // We may need to add a send/receive pair to the inner plan for the special case.\n        // This trick only works once per plan, BUT once the partitioned data has been\n        // received on the coordinator, it can be treated as replicated data in later\n        // joins, which MAY help with later outer joins with replicated data.\n\n        boolean needInnerSendReceive = m_partitioning.requiresTwoFragments() &&\n                                       ! innerPlan.hasReplicatedResult() &&\n                                       outerPlan.hasReplicatedResult() &&\n                                       joinNode.getJoinType() != JoinType.INNER;\n\n        // When the inner plan is an IndexScan, there MAY be a choice of whether to join using a\n        // NestLoopJoin (NLJ) or a NestLoopIndexJoin (NLIJ). The NLJ will have an advantage over the\n        // NLIJ in the cases where it applies, since it does a single access or iteration over the index\n        // and caches the result, where the NLIJ does an index access or iteration for each outer row.\n        // The NestLoopJoin applies when the inner IndexScan is driven only by parameter and constant\n        // expressions determined at the start of the query. That requires that none of the IndexScan's\n        // various expressions that drive the index access may reference columns from the outer row\n        // -- they can only reference columns of the index's base table (the indexed expressions)\n        // as well as constants and parameters. The IndexScan's \"otherExprs\" expressions that only\n        // drive post-filtering are not an issue since the NestLoopJoin does feature per-outer-tuple\n        // post-filtering on each pass over the cached index scan result.\n\n        // The special case of an OUTER JOIN of replicated outer row data with a partitioned inner\n        // table requires that the partitioned data be sent to the coordinator prior to the join.\n        // This limits the join option to NLJ. The index scan must make a single index access on\n        // each partition and cache the result at the coordinator for post-filtering.\n        // This requires that the index access be based on parameters or constants only\n        // -- the replicated outer row data will only be available later at the coordinator,\n        // so it can not drive the per-partition index scan.\n\n        // If the NLJ option is precluded for the usual reason (outer-row-based indexing) AND\n        // the NLIJ is precluded by the special case (OUTER JOIN of replicated outer rows and\n        // partitioned inner rows) this method returns null, effectively rejecting this indexed\n        // access path for the inner node. Other access paths or join orders may prove more successful.\n\n        boolean canHaveNLJ = true;\n        boolean canHaveNLIJ = true;\n        if (innerPlan instanceof IndexScanPlanNode) {\n            if (hasInnerOuterIndexExpression(joinNode.getRightNode().getTableAlias(),\n                                             innerAccessPath.indexExprs,\n                                             innerAccessPath.initialExpr,\n                                             innerAccessPath.endExprs)) {\n                canHaveNLJ = false;\n            }\n        }\n        else {\n            canHaveNLIJ = false;\n        }\n        if (needInnerSendReceive) {\n            canHaveNLIJ = false;\n        }\n\n        AbstractJoinPlanNode ajNode = null;\n        if (canHaveNLJ) {\n            NestLoopPlanNode nljNode = new NestLoopPlanNode();\n            // get all the clauses that join the applicable two tables\n            ArrayList<AbstractExpression> joinClauses = innerAccessPath.joinExprs;\n            if (innerPlan instanceof IndexScanPlanNode) {\n                // InnerPlan is an IndexScan. In this case the inner and inner-outer\n                // non-index join expressions (if any) are in the otherExpr. The former should stay as\n                // an IndexScanPlan predicate and the latter stay at the NLJ node as a join predicate\n                ArrayList<AbstractExpression> otherExprs = new ArrayList<AbstractExpression>();\n                // PLEASE do not update the \"innerAccessPath.otherExprs\", it may be reused\n                // for other path evaluation on the other outer side join.\n                List<AbstractExpression> innerExpr = filterSingleTVEExpressions(innerAccessPath.otherExprs, otherExprs);\n                joinClauses.addAll(otherExprs);\n                AbstractExpression indexScanPredicate = ExpressionUtil.combine(innerExpr);\n                ((IndexScanPlanNode)innerPlan).setPredicate(indexScanPredicate);\n            }\n            else if (innerJoinNode instanceof BranchNode && joinNode.getJoinType() == JoinType.LEFT) {\n                // If the innerJoinNode is a LEAF node OR if the join type is an INNER join,\n                // the conditions that apply to the inner side\n                // have been applied as predicates to the inner scan node already.\n\n                // otherExpr of innerAccessPath comes from its parentNode's joinInnerList.\n                // For Outer join (LEFT ONLY at this point), it could mean a join predicate on the table of\n                // the inner node ONLY, that can not be pushed down.\n                joinClauses.addAll(innerAccessPath.otherExprs);\n            }\n            nljNode.setJoinPredicate(ExpressionUtil.combine(joinClauses));\n\n            // combine the tails plan graph with the new head node\n            nljNode.addAndLinkChild(outerPlan);\n\n            // If successful in the special case, the NLJ plan must be modified to cause the\n            // partitioned inner data to be sent to the coordinator prior to the join.\n            // This is done by adding send and receive plan nodes between the NLJ and its\n            // right child node.\n            if (needInnerSendReceive) {\n                // This trick only works once per plan.\n                if (outerPlan.hasAnyNodeOfType(PlanNodeType.RECEIVE) || innerPlan.hasAnyNodeOfType(PlanNodeType.RECEIVE)) {\n                    return null;\n                }\n                innerPlan = addSendReceivePair(innerPlan);\n            }\n\n            nljNode.addAndLinkChild(innerPlan);\n            ajNode = nljNode;\n        }\n        else if (canHaveNLIJ) {\n            NestLoopIndexPlanNode nlijNode = new NestLoopIndexPlanNode();\n\n            IndexScanPlanNode innerNode = (IndexScanPlanNode) innerPlan;\n            // Set IndexScan predicate\n            innerNode.setPredicate(ExpressionUtil.combine(innerAccessPath.otherExprs));\n\n            nlijNode.addInlinePlanNode(innerPlan);\n\n            // combine the tails plan graph with the new head node\n            nlijNode.addAndLinkChild(outerPlan);\n\n            ajNode = nlijNode;\n        }\n        else {\n            m_recentErrorMsg =\n                \"Unsupported special case of complex OUTER JOIN between replicated outer table and partitioned inner table.\";\n            return null;\n        }\n        ajNode.setJoinType(joinNode.getJoinType());\n        ajNode.setPreJoinPredicate(ExpressionUtil.combine(joinNode.m_joinOuterList));\n        ajNode.setWherePredicate(ExpressionUtil.combine(whereClauses));\n        ajNode.resolveSortDirection();\n        return ajNode;\n    }","id":72499,"modified_method":"/**\n     * Given a join node and plan-sub-graph for outer and inner sub-nodes,\n     * construct the plan-sub-graph for that node.\n     *\n     * @param joinNode A parent join node.\n     * @param outerPlan The outer node plan-sub-graph.\n     * @param innerPlan The inner node plan-sub-graph.\n     * @return A completed plan-sub-graph\n     * or null if a valid plan can not be produced for given access paths.\n     */\n    private AbstractPlanNode getSelectSubPlanForJoin(BranchNode joinNode,\n                                                     AbstractPlanNode outerPlan,\n                                                     AbstractPlanNode innerPlan)\n    {\n        // Filter (post-join) expressions\n        ArrayList<AbstractExpression> whereClauses  = new ArrayList<AbstractExpression>();\n        whereClauses.addAll(joinNode.m_whereInnerList);\n        whereClauses.addAll(joinNode.m_whereInnerOuterList);\n        if (joinNode.getJoinType() == JoinType.FULL) {\n            // For all other join types, the whereOuterList expressions were pushed down to the outer node\n            whereClauses.addAll(joinNode.m_whereOuterList);\n        }\n\n        // The usual approach of calculating a local (partial) join result on each partition,\n        // then sending and merging them with other partial results on the coordinator does not\n        // ensure correct answers for some queries like:\n        //     SELECT * FROM replicated LEFT JOIN partitioned ON ...\n        // They require a \"global view\" of the partitioned working set in order to\n        // properly identify which replicated rows need to be null-padded,\n        // and to ensure that the same replicated row is not null-padded redundantly on multiple partitions.\n        // Many queries using this pattern impractically require redistribution and caching of a considerable\n        // subset of a partitioned table in preparation for a \"coordinated\" join.\n        // Yet, there may be useful cases with sufficient constant-based partitioned table filtering\n        // in the \"ON clause\" to keep the distributed working set size under control, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P\n        //     ON R.key == P.non_partition_key AND P.non_partition_key BETWEEN ? and ?;\n        //\n        // Such queries need to be prohibited by the planner if it can not guarantee the\n        // correct results that require a \"send before join\" plan.\n        // This could be the case if the replicated-to-partition join in these examples\n        // were subject to another join with a partitioned table, like\n        //     SELECT * FROM replicated R LEFT JOIN partitioned P1 ON ...\n        //                                LEFT JOIN also_partitioned P2 ON ...\n        //\n\n        assert(joinNode.getRightNode() != null);\n        JoinNode innerJoinNode = joinNode.getRightNode();\n        AccessPath innerAccessPath = innerJoinNode.m_currentAccessPath;\n        // We may need to add a send/receive pair to the inner plan for the special case.\n        // This trick only works once per plan, BUT once the partitioned data has been\n        // received on the coordinator, it can be treated as replicated data in later\n        // joins, which MAY help with later outer joins with replicated data.\n\n        boolean needInnerSendReceive = m_partitioning.requiresTwoFragments() &&\n                                       ! innerPlan.hasReplicatedResult() &&\n                                       outerPlan.hasReplicatedResult() &&\n                                       joinNode.getJoinType() != JoinType.INNER;\n\n        // When the inner plan is an IndexScan, there MAY be a choice of whether to join using a\n        // NestLoopJoin (NLJ) or a NestLoopIndexJoin (NLIJ). The NLJ will have an advantage over the\n        // NLIJ in the cases where it applies, since it does a single access or iteration over the index\n        // and caches the result, where the NLIJ does an index access or iteration for each outer row.\n        // The NestLoopJoin applies when the inner IndexScan is driven only by parameter and constant\n        // expressions determined at the start of the query. That requires that none of the IndexScan's\n        // various expressions that drive the index access may reference columns from the outer row\n        // -- they can only reference columns of the index's base table (the indexed expressions)\n        // as well as constants and parameters. The IndexScan's \"otherExprs\" expressions that only\n        // drive post-filtering are not an issue since the NestLoopJoin does feature per-outer-tuple\n        // post-filtering on each pass over the cached index scan result.\n\n        // The special case of an OUTER JOIN of replicated outer row data with a partitioned inner\n        // table requires that the partitioned data be sent to the coordinator prior to the join.\n        // This limits the join option to NLJ. The index scan must make a single index access on\n        // each partition and cache the result at the coordinator for post-filtering.\n        // This requires that the index access be based on parameters or constants only\n        // -- the replicated outer row data will only be available later at the coordinator,\n        // so it can not drive the per-partition index scan.\n\n        // If the NLJ option is precluded for the usual reason (outer-row-based indexing) AND\n        // the NLIJ is precluded by the special case (OUTER JOIN of replicated outer rows and\n        // partitioned inner rows) this method returns null, effectively rejecting this indexed\n        // access path for the inner node. Other access paths or join orders may prove more successful.\n\n        boolean canHaveNLJ = true;\n        boolean canHaveNLIJ = true;\n        if (innerPlan instanceof IndexScanPlanNode) {\n            if (hasInnerOuterIndexExpression(joinNode.getRightNode().getTableAlias(),\n                                             innerAccessPath.indexExprs,\n                                             innerAccessPath.initialExpr,\n                                             innerAccessPath.endExprs)) {\n                canHaveNLJ = false;\n            }\n        }\n        else {\n            canHaveNLIJ = false;\n        }\n        if (needInnerSendReceive) {\n            canHaveNLIJ = false;\n        }\n\n        AbstractJoinPlanNode ajNode = null;\n        if (canHaveNLJ) {\n            NestLoopPlanNode nljNode = new NestLoopPlanNode();\n            // get all the clauses that join the applicable two tables\n            ArrayList<AbstractExpression> joinClauses = innerAccessPath.joinExprs;\n            if (innerPlan instanceof IndexScanPlanNode) {\n                // InnerPlan is an IndexScan. In this case the inner and inner-outer\n                // non-index join expressions (if any) are in the otherExpr. The former should stay as\n                // an IndexScanPlan predicate and the latter stay at the NLJ node as a join predicate\n                ArrayList<AbstractExpression> otherExprs = new ArrayList<AbstractExpression>();\n                // PLEASE do not update the \"innerAccessPath.otherExprs\", it may be reused\n                // for other path evaluation on the other outer side join.\n                List<AbstractExpression> innerExpr = filterSingleTVEExpressions(innerAccessPath.otherExprs, otherExprs);\n                joinClauses.addAll(otherExprs);\n                AbstractExpression indexScanPredicate = ExpressionUtil.combine(innerExpr);\n                ((IndexScanPlanNode)innerPlan).setPredicate(indexScanPredicate);\n            }\n            else if (innerJoinNode instanceof BranchNode && joinNode.getJoinType() != JoinType.INNER) {\n                // If the innerJoinNode is a LEAF node OR if the join type is an INNER join,\n                // the conditions that apply to the inner side\n                // have been applied as predicates to the inner scan node already.\n\n                // otherExpr of innerAccessPath comes from its parentNode's joinInnerList.\n                // For Outer join (LEFT or FULL), it could mean a join predicate on the table of\n                // the inner node ONLY, that can not be pushed down.\n                joinClauses.addAll(innerAccessPath.otherExprs);\n            }\n            nljNode.setJoinPredicate(ExpressionUtil.combine(joinClauses));\n\n            // combine the tails plan graph with the new head node\n            nljNode.addAndLinkChild(outerPlan);\n\n            // If successful in the special case, the NLJ plan must be modified to cause the\n            // partitioned inner data to be sent to the coordinator prior to the join.\n            // This is done by adding send and receive plan nodes between the NLJ and its\n            // right child node.\n            if (needInnerSendReceive) {\n                // This trick only works once per plan.\n                if (outerPlan.hasAnyNodeOfType(PlanNodeType.RECEIVE) || innerPlan.hasAnyNodeOfType(PlanNodeType.RECEIVE)) {\n                    return null;\n                }\n                innerPlan = addSendReceivePair(innerPlan);\n            }\n\n            nljNode.addAndLinkChild(innerPlan);\n            ajNode = nljNode;\n        }\n        else if (canHaveNLIJ) {\n            NestLoopIndexPlanNode nlijNode = new NestLoopIndexPlanNode();\n\n            IndexScanPlanNode innerNode = (IndexScanPlanNode) innerPlan;\n            // Set IndexScan predicate. The INNER join expressions for a FULL join come from\n            // the innerAccessPath.joinExprs and needs to be combined with the other join expressions\n            innerNode.setPredicate(ExpressionUtil.combine(innerAccessPath.joinExprs, innerAccessPath.otherExprs));\n\n            nlijNode.addInlinePlanNode(innerPlan);\n\n            // combine the tails plan graph with the new head node\n            nlijNode.addAndLinkChild(outerPlan);\n\n            ajNode = nlijNode;\n        }\n        else {\n            m_recentErrorMsg =\n                \"Unsupported special case of complex OUTER JOIN between replicated outer table and partitioned inner table.\";\n            return null;\n        }\n        ajNode.setJoinType(joinNode.getJoinType());\n        ajNode.setPreJoinPredicate(ExpressionUtil.combine(joinNode.m_joinOuterList));\n        ajNode.setWherePredicate(ExpressionUtil.combine(whereClauses));\n        ajNode.resolveSortDirection();\n        return ajNode;\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     *\n     *\n     */\n    public void testCombine() {\n        //\n        // We create a bunch of individual ComparisonExpression trees and we then\n        // combine them into a single tree created with AND conjunctions\n        //\n        int num_of_subtrees = 5;\n        final List<AbstractExpression> combine_exps = new ArrayList<AbstractExpression>();\n        final Map<AbstractExpression, AbstractExpression> combine_exps_left = new HashMap<AbstractExpression, AbstractExpression>();\n        final Map<AbstractExpression, AbstractExpression> combine_exps_right = new HashMap<AbstractExpression, AbstractExpression>();\n        for (int ctr = 0; ctr < num_of_subtrees; ctr++) {\n            AbstractExpression exps[] = { new ComparisonExpression(ExpressionType.COMPARE_EQUAL),\n                                          new ParameterValueExpression(),\n                                          new TupleValueExpression()\n            };\n            exps[0].setLeft(exps[1]);\n            exps[0].setRight(exps[2]);\n            //ExpressionUtil.generateIds(exps[0]);\n            combine_exps.add(exps[0]);\n            combine_exps_left.put(exps[0], exps[1]);\n            combine_exps_right.put(exps[0], exps[2]);\n        } // FOR\n\n        AbstractExpression combined_exp = null;\n        try {\n            combined_exp = ExpressionUtil.combine(combine_exps);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        assertNotNull(combined_exp);\n        assertEquals(combined_exp.getExpressionType(), ExpressionType.CONJUNCTION_AND);\n        //System.err.println(combined_exp.toString(true));\n\n        //\n        // Checking whether this worked is a bit tricky because the ordering of the may\n        // be different if the implementation changges. So we just need to check to make\n        // sure that all of our sub-trees are contained within the new tree and that their\n        // structure has not changed\n        //\n        new TestExpressionTreeWalker() {\n            @Override\n            public void callback(AbstractExpression exp) {\n                //\n                // This node was in our original tree\n                //\n                if (combine_exps.contains(exp)) {\n                    assertTrue(combine_exps_left.containsKey(exp));\n                    TestExpressionUtil.compareExpressions(exp.getLeft(), combine_exps_left.get(exp));\n                    assertTrue(combine_exps_right.containsKey(exp));\n                    TestExpressionUtil.compareExpressions(exp.getRight(), combine_exps_right.get(exp));\n                    //\n                    // Make sure our parent is a CONJUNCTION_AND expression node\n                    //\n                    assertNotNull(this.getParent());\n                    assertEquals(this.getParent().getExpressionType(), ExpressionType.CONJUNCTION_AND);\n                //\n                // If this is a CONJUNCTION_AND that we added, make sure that both of its\n                // children are not null\n                //\n                } else if (exp.getExpressionType() == ExpressionType.CONJUNCTION_AND) {\n                    assertNotNull(exp.getLeft());\n                    assertNotNull(exp.getRight());\n                }\n            }\n        }.traverse(combined_exp);\n    }","id":72500,"modified_method":"/**\n     *\n     *\n     */\n    public void testCombine() {\n        //\n        // We create a bunch of individual ComparisonExpression trees and we then\n        // combine them into a single tree created with AND conjunctions\n        //\n        int num_of_subtrees = 5;\n        final List<AbstractExpression> combine_exps = new ArrayList<AbstractExpression>();\n        final Map<AbstractExpression, AbstractExpression> combine_exps_left = new HashMap<AbstractExpression, AbstractExpression>();\n        final Map<AbstractExpression, AbstractExpression> combine_exps_right = new HashMap<AbstractExpression, AbstractExpression>();\n        for (int ctr = 0; ctr < num_of_subtrees; ctr++) {\n            AbstractExpression exps[] = { new ComparisonExpression(ExpressionType.COMPARE_EQUAL),\n                                          new ParameterValueExpression(),\n                                          new TupleValueExpression()\n            };\n            exps[0].setLeft(exps[1]);\n            exps[0].setRight(exps[2]);\n            //ExpressionUtil.generateIds(exps[0]);\n            combine_exps.add(exps[0]);\n            combine_exps_left.put(exps[0], exps[1]);\n            combine_exps_right.put(exps[0], exps[2]);\n        } // FOR\n\n        AbstractExpression combined_exp = null;\n        try {\n            combined_exp = ExpressionUtil.combine(combine_exps);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        assertNotNull(combined_exp);\n        assertEquals(combined_exp.getExpressionType(), ExpressionType.CONJUNCTION_AND);\n        //System.err.println(combined_exp.toString(true));\n\n        //\n        // Checking whether this worked is a bit tricky because the ordering of the may\n        // be different if the implementation changges. So we just need to check to make\n        // sure that all of our sub-trees are contained within the new tree and that their\n        // structure has not changed\n        //\n        TestExpressionTreeWalker tertWalker = new TestExpressionTreeWalker() {\n            @Override\n            public void callback(AbstractExpression exp) {\n                //\n                // This node was in our original tree\n                //\n                if (combine_exps.contains(exp)) {\n                    assertTrue(combine_exps_left.containsKey(exp));\n                    TestExpressionUtil.compareExpressions(exp.getLeft(), combine_exps_left.get(exp));\n                    assertTrue(combine_exps_right.containsKey(exp));\n                    TestExpressionUtil.compareExpressions(exp.getRight(), combine_exps_right.get(exp));\n                    //\n                    // Make sure our parent is a CONJUNCTION_AND expression node\n                    //\n                    assertNotNull(this.getParent());\n                    assertEquals(this.getParent().getExpressionType(), ExpressionType.CONJUNCTION_AND);\n                //\n                // If this is a CONJUNCTION_AND that we added, make sure that both of its\n                // children are not null\n                //\n                } else if (exp.getExpressionType() == ExpressionType.CONJUNCTION_AND) {\n                    assertNotNull(exp.getLeft());\n                    assertNotNull(exp.getRight());\n                }\n            }\n        };\n        tertWalker.traverse(combined_exp);\n\n        //\n        // Test  variadic combine\n        //\n        final List<AbstractExpression> combine_exps1 = new ArrayList<AbstractExpression>();\n        final List<AbstractExpression> combine_exps2 = new ArrayList<AbstractExpression>();\n        final List<AbstractExpression> combine_exps3 = new ArrayList<AbstractExpression>();\n        final List<AbstractExpression> combine_exps4 = null;\n        for (int ctr = 0; ctr < num_of_subtrees/2; ctr++) {\n            combine_exps1.add(combine_exps.get(ctr));\n        }\n        for (int ctr = num_of_subtrees/2; ctr < num_of_subtrees; ctr++) {\n            combine_exps2.add(combine_exps.get(ctr));\n        }\n        AbstractExpression var_combined_exp = null;\n        try {\n            var_combined_exp = ExpressionUtil.combine(combine_exps1, combine_exps2, combine_exps3, combine_exps4);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        assertNotNull(var_combined_exp);\n        assertEquals(var_combined_exp.getExpressionType(), ExpressionType.CONJUNCTION_AND);\n        tertWalker.traverse(var_combined_exp);\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void subtestPartitionTableFullNLJoin(Client client)\n            throws NoConnectionsException, IOException, ProcCallException\n    {\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(4, 4);\");\n\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, 5);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, NULL);\");\n\n        String sql;\n        long MINVAL = Long.MIN_VALUE;\n\n        // case 1: equality join on the coordinator node (R2, P1)\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM P1 FULL JOIN R2 ON P1.A = R2.A \" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n;\n        validateTableOfLongs(client, sql, new long[][]{\n                {MINVAL, MINVAL, 5, MINVAL},\n                {MINVAL, MINVAL, 5, 5},\n                {1, 1, 1, 1},\n                {1, 2, 1, 1},\n                {2, 1, 2, 1},\n                {2, 1, 2, 2},\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n     // case 1: equality join of two partitioned tables (P1, P2) on a partition column\n        // @TODO\n    }","id":72501,"modified_method":"private void subtestPartitionTableFullJoin(Client client)\n            throws NoConnectionsException, IOException, ProcCallException\n    {\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(1, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO P1 VALUES(4, 4);\");\n\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(1, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 1);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(2, 2);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(3, 3);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, 5);\");\n        client.callProcedure(\"@AdHoc\", \"INSERT INTO R2 VALUES(5, NULL);\");\n\n        String sql;\n        long MINVAL = Long.MIN_VALUE;\n\n        // case 1: equality join on the coordinator node (R2, P1)\n        sql = \"select P1.A, P1.C, R2.A, R2.C FROM P1 FULL JOIN R2 ON P1.A = R2.A \" +\n                \" ORDER BY P1.A, P1.C, R2.A, R2.C\";\n;\n        validateTableOfLongs(client, sql, new long[][]{\n                {MINVAL, MINVAL, 5, MINVAL},\n                {MINVAL, MINVAL, 5, 5},\n                {1, 1, 1, 1},\n                {1, 2, 1, 1},\n                {2, 1, 2, 1},\n                {2, 1, 2, 2},\n                {3, 3, 3, 3},\n                {4, 4, MINVAL, MINVAL}\n                });\n\n     // case 1: equality join of two partitioned tables (P1, P2) on a partition column\n        // @TODO\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFullJoins() throws NoConnectionsException, IOException, ProcCallException {\n        Client client = getClient();\n        clearSeqTables(client);\n        subtestTwoReplicatedTableFullNLJoin(client);\n        clearSeqTables(client);\n        subtestPartitionTableFullNLJoin(client);\n    }","id":72502,"modified_method":"public void testFullJoins() throws NoConnectionsException, IOException, ProcCallException {\n        Client client = getClient();\n        clearSeqTables(client);\n        subtestTwoReplicatedTableFullNLJoin(client);\n        clearSeqTables(client);\n        subtestPartitionTableFullJoin(client);\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFullJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n        NestLoopPlanNode nlj;\n        AbstractExpression e;\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n        nlj = (NestLoopPlanNode) n;\n        e = nlj.getWherePredicate();\n        assertNotNull(e);\n        assertEquals(ExpressionType.CONJUNCTION_AND, e.getExpressionType());\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        // The outer node is a join itself\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n        nlj = (NestLoopPlanNode) n;\n        e = nlj.getWherePredicate();\n        assertNotNull(e);\n        assertEquals(ExpressionType.OPERATOR_IS_NULL, e.getExpressionType());\n\n        // WHERE outer-inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL OR R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n        nlj = (NestLoopPlanNode) n;\n        e = nlj.getWherePredicate();\n        assertNotNull(e);\n        assertEquals(ExpressionType.CONJUNCTION_OR, e.getExpressionType());\n\n        // WHERE outer and inner expressions push down process stops at the FULL join (R1,R2) node -\n        // FULL join is itself an outer node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n        nlj = (NestLoopPlanNode) n;\n        e = nlj.getWherePredicate();\n        assertNotNull(e);\n        assertEquals(ExpressionType.OPERATOR_IS_NULL, e.getExpressionType());\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n        nlj = (NestLoopPlanNode) n;\n        e = nlj.getJoinPredicate();\n        assertNotNull(e);\n        assertEquals(ExpressionType.CONJUNCTION_AND, e.getExpressionType());\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C < 0 AND R2.C > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n        nlj = (NestLoopPlanNode) n;\n        e = nlj.getWherePredicate();\n        assertNull(e);\n        e = nlj.getPreJoinPredicate();\n        assertEquals(ExpressionType.COMPARE_LESSTHAN, e.getExpressionType());\n        e = nlj.getJoinPredicate();\n        assertEquals(ExpressionType.CONJUNCTION_AND, e.getExpressionType());\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        // FULL join outer node is a join itself\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R1.A = R3.C AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n        nlj = (NestLoopPlanNode) n;\n        e = nlj.getPreJoinPredicate();\n        assertNotNull(e);\n        assertEquals(ExpressionType.OPERATOR_IS_NULL, e.getExpressionType());\n\n    }","id":72503,"modified_method":"public void testFullJoinExpressions() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_AND, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions stay at the FULL NLJ node\n        // The outer node is a join itself\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n        // WHERE outer-inner expressions stay at the FULL NLJ node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A WHERE R2.C IS NULL OR R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.CONJUNCTION_OR, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // WHERE outer and inner expressions push down process stops at the FULL join (R1,R2) node -\n        // FULL join is itself an outer node\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C WHERE R1.C is NULL\");\n        n = pn.getChild(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, ExpressionType.OPERATOR_IS_NULL, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // OUTER JOIN expression (R1.A > 0) is pre-predicate, inner and inner - outer expressionsR3.C = R2.C AND R3.C < 0 are predicate\n        pn = compile(\"select * FROM R1 JOIN R2 ON R1.A = R2.C FULL JOIN R3 ON R3.C = R2.C  AND R1.A > 0 AND R3.C < 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A AND R1.C < 0 AND R2.C > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_LESSTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // NLJ JOIN outer expression is pre-join expression, NLJ JOIN inner expression together with\n        // JOIN inner-outer one are part of the join predicate\n        pn = compile(\"select * FROM  \" +\n                \"R1 JOIN R2 ON R1.A = R2.A FULL JOIN R3 ON R1.A = R3.C AND R1.C is NULL\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.OPERATOR_IS_NULL, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDistributedFullJoin() {\n        List<AbstractPlanNode> lpn;\n        AbstractPlanNode n;\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"R2 FULL JOIN P1 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on non-partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.C = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join of two partition tables on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN P4 ON P1.A = P4.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"P1\", \"P4\");\n\n        // FULL join of two partition tables on non-partition column\n        failToCompile(\"select * FROM  P1 FULL JOIN P4 ON P1.C = P4.A \",\n                \"Join of multiple partitioned tables has insufficient join criteria\");\n    }","id":72504,"modified_method":"public void testDistributedFullJoin() {\n        List<AbstractPlanNode> lpn;\n        AbstractPlanNode n;\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"R2 FULL JOIN P1 ON P1.A = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join on non-partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN R2 ON P1.C = R2.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // FULL join of two partition tables on partition column\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P1 FULL JOIN P4 ON P1.A = P4.A \");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"P1\", \"P4\");\n\n        // NLJ FULL join (R2, P2) on partition column  R2.A > 0 is a pre-predicate, P2.A = R2.A AND P2.E < 0 are join predicate\n        // It can't be a NLIJ because P2 is partitioned - P2.A index is not used\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.A = R2.A AND R2.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLJ FULL join (R2, P2) on partition column  P2.E = R2.A AND P2.A > 0 are join predicate\n        // Inner join expression P2.A > 0 can't be used as index expression with NLJ\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R2 ON P2.E = R2.A AND P2.A > 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.FULL, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE, \"R2\", null);\n\n        // NLIJ (P2,R3) on partition column P2.A using index R3.A\n        lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN R3 ON P2.A = R3.A AND R3.A > 0 AND P2.E < 0\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, ExpressionType.COMPARE_LESSTHAN, null, null, PlanNodeType.INDEXSCAN, PlanNodeType.INDEXSCAN, \"P2\", \"R3\");\n        verifyIndexScanNode(n.getChild(0), IndexLookupType.GTE, null);\n\n        // NLIJ (P1,P2) on partition column P2.A using index P2.A\n              lpn = compileToFragments(\"select * FROM  \" +\n                \"P2 FULL JOIN P1 ON P1.A = P2.A\");\n        assertEquals(2, lpn.size());\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"P1\", \"P2\");\n        verifyIndexScanNode(n.getInlinePlanNode(PlanNodeType.INDEXSCAN), IndexLookupType.EQ, null);\n\n        // FULL join of two partition tables on non-partition column\n        failToCompile(\"select * FROM  P1 FULL JOIN P4 ON P1.C = P4.A \",\n                \"Join of multiple partitioned tables has insufficient join criteria\");\n}","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testMultitableDistributedJoin() {\n        List<AbstractPlanNode> lpn;\n        AbstractPlanNode n;\n\n        // One distributed table\n        lpn = compileToFragments(\"select *  FROM R3,R1 LEFT JOIN P2 ON R3.A = P2.A WHERE R3.A=R1.A \");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOPINDEX, PlanNodeType.RECEIVE);\n\n        // R3.A and P2.A have an index. P2,R1 is NLIJ/inlined IndexScan because it's an inner join even P2 is distributed\n        lpn = compileToFragments(\"select *  FROM P2,R1 LEFT JOIN R3 ON R3.A = P2.A WHERE P2.A=R1.A \");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(0).getChild(0).getChild(0);\n        assertTrue(n instanceof ReceivePlanNode);\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.LEFT, false, PlanNodeType.NESTLOOPINDEX, PlanNodeType.INDEXSCAN);\n\n        // R3.A has an index. R3,P2 is NLJ because it's an outer join and P2 is distributed\n        lpn = compileToFragments(\"select *  FROM R3,R1 LEFT JOIN P2 ON R3.A = P2.A WHERE R3.A=R1.A \");\n        assertTrue(lpn.size() == 2);\n        // to debug */ System.out.println(\"DEBUG 0.0: \" + lpn.get(0).toExplainPlanString());\n        // to debug */ System.out.println(\"DEBUG 0.1: \" + lpn.get(1).toExplainPlanString());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOPINDEX, PlanNodeType.RECEIVE);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, false, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN);\n        n = lpn.get(1).getChild(0);\n        // For determinism reason\n        assertTrue(n instanceof IndexScanPlanNode);\n\n        // R3.A has an index. P2,R1 is NLJ because P2 is distributed and it's an outer join\n        lpn = compileToFragments(\"select *  FROM R1 LEFT JOIN P2 ON R1.A = P2.A, R3 WHERE R1.A=R3.A \");\n        assertTrue(lpn.size() == 2);\n        // to debug */ System.out.println(\"DEBUG 1.0: \" + lpn.get(0).toExplainPlanString());\n        // to debug */ System.out.println(\"DEBUG 1.1: \" + lpn.get(1).toExplainPlanString());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, false, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE);\n        n = lpn.get(1).getChild(0);\n        // For determinism reason\n        assertTrue(n instanceof IndexScanPlanNode);\n\n        // Two distributed table\n        lpn = compileToFragments(\"select *  FROM R3,P1 LEFT JOIN P2 ON R3.A = P2.A WHERE R3.A=P1.A \");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(0).getChild(0).getChild(0);\n        assertTrue(n instanceof ReceivePlanNode);\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.LEFT, false, PlanNodeType.NESTLOOPINDEX, PlanNodeType.INDEXSCAN);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, false, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN);\n    }","id":72505,"modified_method":"public void testMultitableDistributedJoin() {\n        List<AbstractPlanNode> lpn;\n        AbstractPlanNode n;\n\n        // One distributed table\n        lpn = compileToFragments(\"select *  FROM R3,R1 LEFT JOIN P2 ON R3.A = P2.A WHERE R3.A=R1.A \");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOPINDEX, PlanNodeType.RECEIVE);\n\n        // R3.A and P2.A have an index. P2,R1 is NLIJ/inlined IndexScan because it's an inner join even P2 is distributed\n        lpn = compileToFragments(\"select *  FROM P2,R1 LEFT JOIN R3 ON R3.A = P2.A WHERE P2.A=R1.A \");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(0).getChild(0).getChild(0);\n        assertTrue(n instanceof ReceivePlanNode);\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.LEFT, null, null, null, PlanNodeType.NESTLOOPINDEX, PlanNodeType.INDEXSCAN);\n\n        // R3.A has an index. R3,P2 is NLJ because it's an outer join and P2 is distributed\n        lpn = compileToFragments(\"select *  FROM R3,R1 LEFT JOIN P2 ON R3.A = P2.A WHERE R3.A=R1.A \");\n        assertTrue(lpn.size() == 2);\n        // to debug */ System.out.println(\"DEBUG 0.0: \" + lpn.get(0).toExplainPlanString());\n        // to debug */ System.out.println(\"DEBUG 0.1: \" + lpn.get(1).toExplainPlanString());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOPINDEX, PlanNodeType.RECEIVE);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN);\n        n = lpn.get(1).getChild(0);\n        // For determinism reason\n        assertTrue(n instanceof IndexScanPlanNode);\n\n        // R3.A has an index. P2,R1 is NLJ because P2 is distributed and it's an outer join\n        lpn = compileToFragments(\"select *  FROM R1 LEFT JOIN P2 ON R1.A = P2.A, R3 WHERE R1.A=R3.A \");\n        assertTrue(lpn.size() == 2);\n        // to debug */ System.out.println(\"DEBUG 1.0: \" + lpn.get(0).toExplainPlanString());\n        // to debug */ System.out.println(\"DEBUG 1.1: \" + lpn.get(1).toExplainPlanString());\n        n = lpn.get(0).getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, null, null, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.RECEIVE);\n        n = lpn.get(1).getChild(0);\n        // For determinism reason\n        assertTrue(n instanceof IndexScanPlanNode);\n\n        // Two distributed table\n        lpn = compileToFragments(\"select *  FROM R3,P1 LEFT JOIN P2 ON R3.A = P2.A WHERE R3.A=P1.A \");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(0).getChild(0).getChild(0);\n        assertTrue(n instanceof ReceivePlanNode);\n        n = lpn.get(1).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.LEFT, null, null, null, PlanNodeType.NESTLOOPINDEX, PlanNodeType.INDEXSCAN);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN);\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testPushDownExprJoin() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // R3.A > 0 gets pushed down all the way to the R3 scan node and used as an index\n        pn = compile(\"select * FROM R3, R2 LEFT JOIN R1 ON R1.C = R2.C WHERE R3.C = R2.C AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R1\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.INDEXSCAN, PlanNodeType.SEQSCAN, \"R3\", \"R2\");\n\n        // R3.A > 0 is now outer join expresion and must stay at the LEF join\n        pn = compile(\"select * FROM R3, R2 LEFT JOIN R1 ON R1.C = R2.C  AND R3.A > 0 WHERE R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R1\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R3\", \"R2\");\n\n        pn = compile(\"select * FROM R3 JOIN R2 ON R3.C = R2.C RIGHT JOIN R1 ON R1.C = R2.C  AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R1\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R3\", \"R2\");\n\n        // R3.A > 0 gets pushed down all the way to the R3 scan node and used as an index\n        pn = compile(\"select * FROM R2, R3 LEFT JOIN R1 ON R1.C = R2.C WHERE R3.C = R2.C AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R1\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R2\", \"R3\");\n\n        // R3.A = R2.C gets pushed down to the R2, R3 join node scan node and used as an index\n        pn = compile(\"select * FROM R2, R3 LEFT JOIN R1 ON R1.C = R2.C WHERE R3.A = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOPINDEX, PlanNodeType.SEQSCAN, null, \"R1\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, false, PlanNodeType.SEQSCAN, null, \"R2\", \"R3\");\n    }","id":72506,"modified_method":"public void testPushDownExprJoin() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        // R3.A > 0 gets pushed down all the way to the R3 scan node and used as an index\n        pn = compile(\"select * FROM R3, R2 LEFT JOIN R1 ON R1.C = R2.C WHERE R3.C = R2.C AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R1\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.INDEXSCAN, PlanNodeType.SEQSCAN, \"R3\", \"R2\");\n\n        // R3.A > 0 is now outer join expression and must stay at the LEFT join\n        pn = compile(\"select * FROM R3, R2 LEFT JOIN R1 ON R1.C = R2.C  AND R3.A > 0 WHERE R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, ExpressionType.COMPARE_GREATERTHAN, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R1\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R3\", \"R2\");\n\n        pn = compile(\"select * FROM R3 JOIN R2 ON R3.C = R2.C RIGHT JOIN R1 ON R1.C = R2.C  AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R1\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R3\", \"R2\");\n\n        // R3.A > 0 gets pushed down all the way to the R3 scan node and used as an index\n        pn = compile(\"select * FROM R2, R3 LEFT JOIN R1 ON R1.C = R2.C WHERE R3.C = R2.C AND R3.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R1\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R2\", \"R3\");\n\n        // R3.A = R2.C gets pushed down to the R2, R3 join node scan node and used as an index\n        pn = compile(\"select * FROM R2, R3 LEFT JOIN R1 ON R1.C = R2.C WHERE R3.A = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOPINDEX, PlanNodeType.SEQSCAN, null, \"R1\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, null, null, null, PlanNodeType.SEQSCAN, null, \"R2\", \"R3\");\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void verifyJoinNode(AbstractPlanNode n, PlanNodeType nodeType, JoinType joinType, boolean hasJoinPredicate,\n            PlanNodeType outerNodeType, PlanNodeType innerNodeType,\n            String outerTableAlias, String innerTableAlias) {\n        assertEquals(nodeType, n.getPlanNodeType());\n        AbstractJoinPlanNode jn = (AbstractJoinPlanNode) n;\n        assertEquals(joinType, jn.getJoinType());\n        assertEquals(hasJoinPredicate, jn.getJoinPredicate() != null);\n        assertEquals(outerNodeType, jn.getChild(0).getPlanNodeType());\n        if (outerTableAlias != null) {\n            assertEquals(outerTableAlias, ((AbstractScanPlanNode) jn.getChild(0)).getTargetTableAlias());\n        }\n        if (nodeType == PlanNodeType.NESTLOOP) {\n            assertEquals(innerNodeType, jn.getChild(1).getPlanNodeType());\n        }\n        if (innerTableAlias != null) {\n            if (nodeType == PlanNodeType.NESTLOOP) {\n                assertEquals(innerTableAlias, ((AbstractScanPlanNode) jn.getChild(1)).getTargetTableAlias());\n            } else {\n                IndexScanPlanNode sn = (IndexScanPlanNode) jn.getInlinePlanNode(PlanNodeType.INDEXSCAN);\n                assertEquals(innerTableAlias, sn.getTargetTableAlias());\n            }\n        }\n    }","id":72507,"modified_method":"private void verifyJoinNode(AbstractPlanNode n, PlanNodeType nodeType, JoinType joinType,\n            ExpressionType preJoinExpressionType, ExpressionType joinExpressionType, ExpressionType whereExpressionType,\n            PlanNodeType outerNodeType, PlanNodeType innerNodeType,\n            String outerTableAlias, String innerTableAlias) {\n        assertEquals(nodeType, n.getPlanNodeType());\n        AbstractJoinPlanNode jn = (AbstractJoinPlanNode) n;\n        assertEquals(joinType, jn.getJoinType());\n        if (preJoinExpressionType != null) {\n            assertEquals(preJoinExpressionType, jn.getPreJoinPredicate().getExpressionType());\n        } else {\n            assertNull(jn.getPreJoinPredicate());\n        }\n        if (joinExpressionType != null) {\n            assertEquals(joinExpressionType, jn.getJoinPredicate().getExpressionType());\n        } else {\n            assertNull(jn.getJoinPredicate());\n        }\n        if (whereExpressionType != null) {\n            assertEquals(whereExpressionType, jn.getWherePredicate().getExpressionType());\n        } else {\n            assertNull(jn.getWherePredicate());\n        }\n        assertEquals(outerNodeType, jn.getChild(0).getPlanNodeType());\n        if (outerTableAlias != null) {\n            assertEquals(outerTableAlias, ((AbstractScanPlanNode) jn.getChild(0)).getTargetTableAlias());\n        }\n        if (nodeType == PlanNodeType.NESTLOOP) {\n            assertEquals(innerNodeType, jn.getChild(1).getPlanNodeType());\n        }\n        if (innerTableAlias != null) {\n            if (nodeType == PlanNodeType.NESTLOOP) {\n                assertEquals(innerTableAlias, ((AbstractScanPlanNode) jn.getChild(1)).getTargetTableAlias());\n            } else {\n                IndexScanPlanNode sn = (IndexScanPlanNode) jn.getInlinePlanNode(PlanNodeType.INDEXSCAN);\n                assertEquals(innerTableAlias, sn.getTargetTableAlias());\n            }\n        }\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testOuterOuterJoin() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        pn = compile(\"select * FROM R1 LEFT JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        pn = compile(\"select * FROM R1 LEFT JOIN R2 ON R1.A = R2.A RIGHT JOIN R3 ON R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        pn = compile(\"select * FROM R1 RIGHT JOIN R2 ON R1.A = R2.A RIGHT JOIN R3 ON R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R2\", \"R1\");\n\n        pn = compile(\"select * FROM R1 RIGHT JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R2\", \"R1\");\n\n        pn = compile(\"select * FROM R1 RIGHT JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R1.C WHERE R1.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n    }","id":72508,"modified_method":"public void testOuterOuterJoin() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        pn = compile(\"select * FROM R1 LEFT JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        pn = compile(\"select * FROM R1 LEFT JOIN R2 ON R1.A = R2.A RIGHT JOIN R3 ON R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        pn = compile(\"select * FROM R1 RIGHT JOIN R2 ON R1.A = R2.A RIGHT JOIN R3 ON R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R2\", \"R1\");\n\n        pn = compile(\"select * FROM R1 RIGHT JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R2\", \"R1\");\n\n        pn = compile(\"select * FROM R1 RIGHT JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R1.C WHERE R1.A > 0\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testOuterSimplificationJoin() {\n        // NULL_rejection simplification is the first transformation -\n        // before the LEFT-to-RIGHT and the WHERE expressions push down\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        pn = compile(\"select * FROM R1, R3 RIGHT JOIN R2 ON R1.A = R2.A WHERE R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // The second R3.C = R2.C join condition is NULL-rejecting for the outer table\n        // from the first LEFT join - can't simplify (not the inner table)\n        pn = compile(\"select * FROM R1 LEFT JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // The second R3.C = R2.C join condition is NULL-rejecting for the first LEFT join\n        pn = compile(\"select * FROM R1 LEFT JOIN R2 ON R1.A = R2.A RIGHT JOIN R3 ON R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // The R3.A = R1.A join condition is NULL-rejecting for the FULL join OUTER (R1) table\n        // simplifying it to R1 LEFT JOIN R2\n        pn = compile(\"select * FROM \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A \" +\n                \"RIGHT JOIN R3 ON R3.A = R1.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // The R3.A = R2.A join condition is NULL-rejecting for the FULL join INNER (R2) table\n        // simplifying it to R1 RIGHT JOIN R2 which gets converted to R2 LEFT JOIN R1\n        pn = compile(\"select * FROM \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A \" +\n                    \"RIGHT JOIN R3 ON R3.A = R2.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R2\", \"R1\");\n\n        // The R3.A = R2.A AND R3.A = R1.A join condition is NULL-rejecting for the FULL join\n        // OUTER (R1) and INNER (R1) tables simplifying it to R1 JOIN R2\n        pn = compile(\"select * FROM \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A \" +\n                    \"RIGHT JOIN R3 ON R3.A = R2.A AND R3.A = R1.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // R1 RIGHT JOIN R2 ON R1.A = R2.A                  R1 JOIN R3 ON R1.A = R3.A\n        //      JOIN R3 ON R1.A = R3.A               ==>        JOIN  R2 ON R1.A = R2.A\n        //          FULL JOIN R4 ON R1.A = R4.A                     LEFT JOIN R4 ON R1.A = R4.A\n        //              FULL JOIN R5 ON R1.A = R5.A                     FULL JOIN R5 ON R1.A = R5.A\n        pn = compile(\"select * FROM \" +\n                \"R1 RIGHT JOIN R2 ON R1.A = R2.A \" +\n                    \"JOIN R3 ON R1.A = R3.A \" +\n                    \"FULL JOIN R4 ON R1.A = R4.A \" +\n                        \"FULL JOIN R5 ON R1.A = R5.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, false, PlanNodeType.NESTLOOPINDEX, PlanNodeType.INDEXSCAN, null, \"R5\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.LEFT, false, PlanNodeType.NESTLOOP, PlanNodeType.INDEXSCAN, null, \"R4\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.NESTLOOPINDEX, PlanNodeType.SEQSCAN, null, \"R2\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, false, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n    }","id":72509,"modified_method":"public void testOuterSimplificationJoin() {\n        // NULL_rejection simplification is the first transformation -\n        // before the LEFT-to-RIGHT and the WHERE expressions push down\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        pn = compile(\"select * FROM R1, R3 RIGHT JOIN R2 ON R1.A = R2.A WHERE R3.C = R1.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN);\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // The second R3.C = R2.C join condition is NULL-rejecting for the outer table\n        // from the first LEFT join - can't simplify (not the inner table)\n        pn = compile(\"select * FROM R1 LEFT JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // The second R3.C = R2.C join condition is NULL-rejecting for the first LEFT join\n        pn = compile(\"select * FROM R1 LEFT JOIN R2 ON R1.A = R2.A RIGHT JOIN R3 ON R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // The R3.A = R1.A join condition is NULL-rejecting for the FULL join OUTER (R1) table\n        // simplifying it to R1 LEFT JOIN R2\n        pn = compile(\"select * FROM \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A \" +\n                \"RIGHT JOIN R3 ON R3.A = R1.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R1\", \"R2\");\n\n        // The R3.A = R2.A join condition is NULL-rejecting for the FULL join INNER (R2) table\n        // simplifying it to R1 RIGHT JOIN R2 which gets converted to R2 LEFT JOIN R1\n        pn = compile(\"select * FROM \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A \" +\n                    \"RIGHT JOIN R3 ON R3.A = R2.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN, \"R2\", \"R1\");\n\n        // The R3.A = R2.A AND R3.A = R1.A join condition is NULL-rejecting for the FULL join\n        // OUTER (R1) and INNER (R1) tables simplifying it to R1 JOIN R2\n        pn = compile(\"select * FROM \" +\n                \"R1 FULL JOIN R2 ON R1.A = R2.A \" +\n                    \"RIGHT JOIN R3 ON R3.A = R2.A AND R3.A = R1.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.NESTLOOP, \"R3\", null);\n        n = n.getChild(1);\n        // HSQL doubles the join expression for the first join. Once it's corrected the join expression type\n        // should be ExpressionType.COMPARE_EQUAL\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.CONJUNCTION_AND, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        // R1 RIGHT JOIN R2 ON R1.A = R2.A                  R1 JOIN R3 ON R1.A = R3.A\n        //      JOIN R3 ON R1.A = R3.A               ==>        JOIN  R2 ON R1.A = R2.A\n        //          FULL JOIN R4 ON R1.A = R4.A                     LEFT JOIN R4 ON R1.A = R4.A\n        //              FULL JOIN R5 ON R1.A = R5.A                     FULL JOIN R5 ON R1.A = R5.A\n        pn = compile(\"select * FROM \" +\n                \"R1 RIGHT JOIN R2 ON R1.A = R2.A \" +\n                    \"JOIN R3 ON R1.A = R3.A \" +\n                    \"FULL JOIN R4 ON R1.A = R4.A \" +\n                        \"FULL JOIN R5 ON R1.A = R5.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.FULL, null, null, null, PlanNodeType.NESTLOOPINDEX, PlanNodeType.INDEXSCAN, null, \"R5\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.LEFT, null, null, null, PlanNodeType.NESTLOOP, PlanNodeType.INDEXSCAN, null, \"R4\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOPINDEX, PlanNodeType.SEQSCAN, null, \"R2\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOPINDEX, JoinType.INNER, null, null, null, PlanNodeType.SEQSCAN, PlanNodeType.INDEXSCAN, \"R1\", \"R3\");\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testInnerOuterJoin() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        pn = compile(\"select * FROM R1 INNER JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        pn = compile(\"select * FROM R1, R2 LEFT JOIN R3 ON R3.C = R2.C WHERE R1.A = R2.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, true, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n    }","id":72510,"modified_method":"public void testInnerOuterJoin() {\n        AbstractPlanNode pn;\n        AbstractPlanNode n;\n\n        pn = compile(\"select * FROM R1 INNER JOIN R2 ON R1.A = R2.A LEFT JOIN R3 ON R3.C = R2.C\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n\n        pn = compile(\"select * FROM R1, R2 LEFT JOIN R3 ON R3.C = R2.C WHERE R1.A = R2.A\");\n        n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        n = n.getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.INNER, null, ExpressionType.COMPARE_EQUAL, null, PlanNodeType.SEQSCAN, PlanNodeType.SEQSCAN);\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void verifyJoinNode(AbstractPlanNode n, PlanNodeType nodeType, JoinType joinType, boolean hasJoinPredicate,\n            PlanNodeType outerNodeType, PlanNodeType innerNodeType) {\n        verifyJoinNode(n, nodeType, joinType, hasJoinPredicate, outerNodeType, innerNodeType, null, null);\n    }","id":72511,"modified_method":"private void verifyJoinNode(AbstractPlanNode n, PlanNodeType nodeType, JoinType joinType,\n            ExpressionType preJoinExpressionType, ExpressionType joinExpressionType, ExpressionType whereExpressionType,\n            PlanNodeType outerNodeType, PlanNodeType innerNodeType) {\n        verifyJoinNode(n, nodeType, joinType, preJoinExpressionType, joinExpressionType, whereExpressionType, outerNodeType, innerNodeType, null, null);\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testMultiTableJoinExpressions() {\n        AbstractPlanNode pn = compile(\"select * FROM R1, R2 LEFT JOIN R3 ON R3.A = R2.C OR R3.A = R1.A WHERE R1.C = R2.C\");\n        AbstractPlanNode n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, true, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        NestLoopPlanNode nlj = (NestLoopPlanNode) n;\n        AbstractExpression p = nlj.getJoinPredicate();\n        assertEquals(ExpressionType.CONJUNCTION_OR, p.getExpressionType());\n    }","id":72512,"modified_method":"public void testMultiTableJoinExpressions() {\n        AbstractPlanNode pn = compile(\"select * FROM R1, R2 LEFT JOIN R3 ON R3.A = R2.C OR R3.A = R1.A WHERE R1.C = R2.C\");\n        AbstractPlanNode n = pn.getChild(0).getChild(0);\n        verifyJoinNode(n, PlanNodeType.NESTLOOP, JoinType.LEFT, null, ExpressionType.CONJUNCTION_OR, null, PlanNodeType.NESTLOOP, PlanNodeType.SEQSCAN, null, \"R3\");\n        NestLoopPlanNode nlj = (NestLoopPlanNode) n;\n        AbstractExpression p = nlj.getJoinPredicate();\n        assertEquals(ExpressionType.CONJUNCTION_OR, p.getExpressionType());\n    }","commit_id":"8573d80830babf10b811326fc184e69c3effeb5a","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n\t\tpublic void valueUnbound(HttpSessionBindingEvent event)\n\t\t{\n\t\t\t// WICKET-5164 use the original sessionId\n\t\t\tgetPageStore().unbind(this.sessionId);\n\t\t}","id":72513,"modified_method":"@Override\n\t\tpublic void valueUnbound(HttpSessionBindingEvent event)\n\t\t{\n\t\t\t// WICKET-5164 use the original sessionId\n\t\t\tIPageStore store = getPageStore();\n\t\t\t// store might be null if destroyed already\n\t\t\tif (store != null)\n\t\t\t{\n\t\t\t\tstore.unbind(sessionId);\n\t\t\t}\n\t\t}","commit_id":"89ac75bf08c8c3b3831773f3ed324454513a0118","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * \n\t\t * @param s\n\t\t * @throws IOException\n\t\t * @throws ClassNotFoundException\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate void readObject(final ObjectInputStream s) throws IOException,\n\t\t\tClassNotFoundException\n\t\t{\n\t\t\ts.defaultReadObject();\n\n\t\t\tafterReadObject = new ArrayList<Object>();\n\n\t\t\tList<Serializable> l = (List<Serializable>)s.readObject();\n\n\t\t\t// convert to temporary state after deserialization (will need to be processed\n\t\t\t// by convertAfterReadObject before the pages can be accessed)\n\t\t\tfor (Serializable ser : l)\n\t\t\t{\n\t\t\t\tafterReadObject.add(getPageStore().restoreAfterSerialization(ser));\n\t\t\t}\n\t\t}","id":72514,"modified_method":"/**\n\t\t * \n\t\t * @param s\n\t\t * @throws IOException\n\t\t * @throws ClassNotFoundException\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate void readObject(final ObjectInputStream s) throws IOException,\n\t\t\tClassNotFoundException\n\t\t{\n\t\t\ts.defaultReadObject();\n\n\t\t\tafterReadObject = new ArrayList<Object>();\n\n\t\t\tList<Serializable> l = (List<Serializable>)s.readObject();\n\n\t\t\t// convert to temporary state after deserialization (will need to be processed\n\t\t\t// by convertAfterReadObject before the pages can be accessed)\n\t\t\tIPageStore pageStore = getPageStore();\n\t\t\tfor (Serializable ser : l)\n\t\t\t{\n\t\t\t\tObject page;\n\t\t\t\tif (pageStore != null)\n\t\t\t\t{\n\t\t\t\t\tpage = pageStore.restoreAfterSerialization(ser);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpage = ser;\n\t\t\t\t}\n\t\t\t\tafterReadObject.add(page);\n\t\t\t}\n\t\t}","commit_id":"26ef892b062e300c602a79ff7c378564c49d4848","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * \n\t\t * @return page store\n\t\t */\n\t\tprivate IPageStore getPageStore()\n\t\t{\n\t\t\tPersistentPageManager manager = managers.get(applicationName);\n\t\t\tif (manager == null)\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"PageManager for application '\" + applicationName +\n\t\t\t\t\t\"' not registered.\");\n\t\t\t}\n\t\t\treturn manager.pageStore;\n\t\t}","id":72515,"modified_method":"/**\n\t\t * \n\t\t * @return page store\n\t\t */\n\t\tprivate IPageStore getPageStore()\n\t\t{\n\t\t\tPersistentPageManager manager = managers.get(applicationName);\n\n\t\t\tif (manager == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn manager.pageStore;\n\t\t}","commit_id":"26ef892b062e300c602a79ff7c378564c49d4848","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * \n\t\t * @param s\n\t\t * @throws IOException\n\t\t */\n\t\tprivate void writeObject(final ObjectOutputStream s) throws IOException\n\t\t{\n\t\t\ts.defaultWriteObject();\n\n\t\t\t// prepare for serialization and store the pages\n\t\t\tList<Serializable> l = new ArrayList<Serializable>();\n\t\t\tfor (IManageablePage p : pages)\n\t\t\t{\n\t\t\t\tSerializable preparedPage = getPageStore().prepareForSerialization(sessionId, p);\n\t\t\t\tif (preparedPage != null)\n\t\t\t\t{\n\t\t\t\t\tl.add(preparedPage);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.writeObject(l);\n\t\t}","id":72516,"modified_method":"/**\n\t\t * \n\t\t * @param s\n\t\t * @throws IOException\n\t\t */\n\t\tprivate void writeObject(final ObjectOutputStream s) throws IOException\n\t\t{\n\t\t\ts.defaultWriteObject();\n\n\t\t\t// prepare for serialization and store the pages\n\t\t\tList<Serializable> l = new ArrayList<Serializable>();\n\t\t\tIPageStore pageStore = getPageStore();\n\t\t\tfor (IManageablePage p : pages)\n\t\t\t{\n\t\t\t\tSerializable preparedPage;\n\t\t\t\tif (pageStore != null)\n\t\t\t\t{\n\t\t\t\t\tpreparedPage = pageStore.prepareForSerialization(sessionId, p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpreparedPage = p;\n\t\t\t\t}\n\n\t\t\t\tif (preparedPage != null)\n\t\t\t\t{\n\t\t\t\t\tl.add(preparedPage);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.writeObject(l);\n\t\t}","commit_id":"26ef892b062e300c602a79ff7c378564c49d4848","url":"https://github.com/apache/wicket"},{"original_method":"private void collectReferenceChanges() {    \n    Set<String> newNodeIds = myNewModel.getNodeIds();\n\n    for (String id : newNodeIds) {\n      SNode newNode = myNewModel.getNodeById(id);\n      SNode oldNode = myOldModel.getNodeById(id);\n\n      assert newNode != null;\n\n      if (oldNode == null) {\n        for (SReference ref : newNode.getReferences()) {\n          if (isToManyCardinality(newNode.getClass(), ref.getRole())) {\n            myChanges.add(new AddReferenceChange(id, ref.getRole(), ref.getTargetModelUID(), ref.getTargetNodeId()));\n          } else {\n            myChanges.add(new SetReferenceChange(id, ref.getRole(), myNewModel, ref.getTargetNode()));\n          }\n        }\n      } else {\n        Set<String> roles = new HashSet<String>(newNode.getReferenceRoles());\n        roles.addAll(oldNode.getReferenceRoles());\n        for (String role : roles) {\n          if (!isToManyCardinality(newNode.getClass(), role)) {\n            if (oldNode.getReferences(role).size() != 0 && newNode.getReferences(role).size() == 0) {\n              myChanges.add(new SetReferenceChange(id, role, myNewModel, null));\n            } else {\n              if (!(\"\" + getTargetId(newNode.getReference(role))).equals(\"\" + getTargetId(oldNode.getReference(role)))) {\n                myChanges.add(new SetReferenceChange(id, role, myNewModel, newNode.getReferent(role)));\n              }\n            }\n          } else {\n            System.out.println(\"not supported!\");\n            isToManyCardinality(newNode.getClass(), role);\n          }\n        }\n      }\n    }\n  }","id":72517,"modified_method":"private void collectReferenceChanges() {    \n    Set<String> newNodeIds = myNewModel.getNodeIds();\n\n    for (String id : newNodeIds) {\n      SNode newNode = myNewModel.getNodeById(id);\n      SNode oldNode = myOldModel.getNodeById(id);\n\n      assert newNode != null;\n\n      if (oldNode == null) {\n        for (SReference ref : newNode.getReferences()) {\n          if (isToManyCardinality(newNode.getClass(), ref.getRole())) {\n            myChanges.add(new AddReferenceChange(id, ref.getRole(), ref.getTargetModelUID(), ref.getTargetNodeId()));\n          } else {\n            myChanges.add(new SetReferenceChange(id, ref.getRole(), myNewModel, ref.getTargetNode()));\n          }\n        }\n      } else {\n        Set<String> roles = new HashSet<String>(newNode.getReferenceRoles());\n        roles.addAll(oldNode.getReferenceRoles());\n        for (String role : roles) {\n          if (!isToManyCardinality(newNode.getClass(), role)) {\n            if (oldNode.getReferences(role).size() != 0 && newNode.getReferences(role).size() == 0) {\n              myChanges.add(new SetReferenceChange(id, role, myNewModel, null));\n            } else {\n              if (!(\"\" + getTargetId(newNode.getReference(role))).equals(\"\" + getTargetId(oldNode.getReference(role)))) {\n                myChanges.add(new SetReferenceChange(id, role, myNewModel, newNode.getReferent(role)));\n              }\n            }\n          } else {\n            System.out.println(\"we have to many references : \" + newNode + \" \" + newNode.getId());\n            System.out.println(\"role : \" + role);\n            System.out.println(\"not supported!\");\n            isToManyCardinality(newNode.getClass(), role);\n          }\n        }\n      }\n    }\n  }","commit_id":"09c471f8fa165dd976d1b43a285b1ab34197b6e2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean isToManyCardinality(Class cls, String role) {\n    LinkDeclaration ld = SModelUtil.findLinkDeclaration(cls, role, GlobalScope.getInstance());\n    if (ld == null) {\n      return true;\n    }\n    return ld.getSourceCardinality() != Cardinality._0_1 && ld.getSourceCardinality() != Cardinality._1;\n  }","id":72518,"modified_method":"private boolean isToManyCardinality(Class cls, String role) {\n    LinkDeclaration ld = SModelUtil.findLinkDeclaration(cls, role, GlobalScope.getInstance());\n    if (ld == null) {\n      return false;\n    }\n    return ld.getSourceCardinality() != Cardinality._0_1 && ld.getSourceCardinality() != Cardinality._1;\n  }","commit_id":"09c471f8fa165dd976d1b43a285b1ab34197b6e2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void applyNewNodeChange(NewNodeChange c, Map<String, NewNodeChange> map) {\n    if (myExcludedChanges.contains(c)) {\n      return;\n    }\n\n    if (myResultModel.getNodeById(c.getNodeId()) != null) {\n      return;\n    }\n\n    if (c.getNodeParent() == null) { //i.e. add root\n      boolean result = c.apply(myResultModel);\n      assert result;\n      return;\n    }\n\n    if (myResultModel.getNodeById(c.getNodeParent()) == null) {\n      NewNodeChange pChange = map.get(c.getNodeParent());\n      assert pChange != null;\n      applyNewNodeChange(pChange, map);\n\n      if (myResultModel.getNodeById(c.getNodeParent()) == null) {\n        //we wasn't able to find a parent (probably because it was exluded) so return\n        return;\n      }\n    }\n\n    if (c instanceof AddNodeChange) {\n      AddNodeChange anc = (AddNodeChange) c;\n\n      if (anc.getPreviousNode() != null) {\n        NewNodeChange pChange = map.get(anc.getPreviousNode());\n        assert pChange != null;\n        applyNewNodeChange(pChange, map);\n      }\n    }\n\n    assert myResultModel.getNodeById(c.getNodeId()) == null;\n    boolean result = c.apply(myResultModel);\n\n    assert result;\n  }","id":72519,"modified_method":"private void applyNewNodeChange(NewNodeChange c, Map<String, NewNodeChange> map) {\n    if (myExcludedChanges.contains(c)) {\n      return;\n    }\n\n    if (myResultModel.getNodeById(c.getNodeId()) != null) {\n      return;\n    }\n\n    if (c.getNodeParent() == null) { //i.e. add root\n      boolean result = c.apply(myResultModel);\n      assert result;\n      return;\n    }\n\n    if (myResultModel.getNodeById(c.getNodeParent()) == null) {\n      NewNodeChange pChange = map.get(c.getNodeParent());\n      assert pChange != null;\n      applyNewNodeChange(pChange, map);\n\n      if (myResultModel.getNodeById(c.getNodeParent()) == null) {\n        //we wasn't able to find a parent (probably because it was exluded) so return\n        return;\n      }\n    }\n\n    if (c instanceof AddNodeChange) {\n      AddNodeChange anc = (AddNodeChange) c;\n\n      if (anc.getPreviousNode() != null) {\n        NewNodeChange pChange = map.get(anc.getPreviousNode());\n        assert pChange != null || myResultModel.getNodeById(anc.getPreviousNode()) != null;\n        if (pChange != null) {\n          applyNewNodeChange(pChange, map);\n        }\n      }\n    }\n\n    assert myResultModel.getNodeById(c.getNodeId()) == null;\n    boolean result = c.apply(myResultModel);\n\n    assert result;\n  }","commit_id":"09c471f8fa165dd976d1b43a285b1ab34197b6e2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectSetNodeConflicts() {\n    Map<String, Set<SetNodeChange>> changes = new HashMap<String, Set<SetNodeChange>>();\n\n    List<SetNodeChange> sets = getChanges(SetNodeChange.class);\n\n    for (SetNodeChange spc : sets) {\n      if (changes.get(spc.getNodeParent()) == null) {\n        changes.put(spc.getNodeParent(), new HashSet<SetNodeChange>());\n      }\n\n      changes.get(spc.getNodeParent()).add(spc);\n    }\n\n    for (String id : changes.keySet()) {\n      if (changes.get(id).size() > 1) {\n        List<SetNodeChange> cs = new ArrayList<SetNodeChange>(changes.get(id));\n        assert cs.size() == 2;\n        myConflicts.add(new Conflict(cs.get(0), cs.get(1)));\n      }\n    }\n  }","id":72520,"modified_method":"private void collectSetNodeConflicts() {\n    Map<Pair<String, String>, Set<SetNodeChange>> changes = new HashMap<Pair<String, String>, Set<SetNodeChange>>();\n\n    List<SetNodeChange> sets = getChanges(SetNodeChange.class);\n\n    for (SetNodeChange spc : sets) {\n      if (changes.get(new Pair<String, String>(spc.getNodeParent(), spc.getNodeRole())) == null) {\n        changes.put(new Pair<String, String>(spc.getNodeParent(), spc.getNodeRole()), new HashSet<SetNodeChange>());\n      }\n\n      changes.get(new Pair<String, String>(spc.getNodeParent(), spc.getNodeRole())).add(spc);\n    }\n\n    for (Pair<String, String> p: changes.keySet()) {\n      if (changes.get(p).size() > 1) {\n        List<SetNodeChange> cs = new ArrayList<SetNodeChange>(changes.get(p));\n        assert cs.size() == 2;\n        myConflicts.add(new Conflict(cs.get(0), cs.get(1)));\n      }\n    }\n  }","commit_id":"09c471f8fa165dd976d1b43a285b1ab34197b6e2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FileLineDifferenceIterator(File marked, File available,\n            @Nullable Function<String, String> transformer) throws IOException {\n            this(FileUtils.lineIterator(marked), FileUtils.lineIterator(available), transformer);\n        }","id":72521,"modified_method":"public FileLineDifferenceIterator(File marked, File available,\n            @Nullable Function<String, String> transformer) throws IOException {\n            this(FileUtils.lineIterator(marked, UTF_8.toString()),\n                FileUtils.lineIterator(available, UTF_8.toString()), transformer);\n        }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void sortTest() throws IOException {\n        List<String> list = newArrayList(\"a\", \"z\", \"e\", \"b\");\n        File f = folder.newFile();\n        writeStrings(list.iterator(), f, false);\n        sort(f);\n\n        BufferedReader reader =\n            new BufferedReader(new InputStreamReader(new FileInputStream(f), Charsets.UTF_8));\n        String line = null;\n        List<String> retrieved = newArrayList();\n        while ((line = reader.readLine()) != null) {\n            retrieved.add(line);\n        }\n        closeQuietly(reader);\n        Collections.sort(list);\n        assertArrayEquals(Arrays.toString(list.toArray()), list.toArray(), retrieved.toArray());\n    }","id":72522,"modified_method":"@Test\n    public void sortTest() throws IOException {\n        List<String> list = newArrayList(\"a\", \"z\", \"e\", \"b\");\n        File f = assertWrite(list.iterator(), false, list.size());\n\n        sort(f);\n\n        BufferedReader reader =\n            new BufferedReader(new InputStreamReader(new FileInputStream(f), UTF_8));\n        String line = null;\n        List<String> retrieved = newArrayList();\n        while ((line = reader.readLine()) != null) {\n            retrieved.add(line);\n        }\n        closeQuietly(reader);\n        Collections.sort(list);\n        assertArrayEquals(Arrays.toString(list.toArray()), list.toArray(), retrieved.toArray());\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void writeReadRandomStrings() throws Exception {\n        Set<String> added = newHashSet();\n        File f = folder.newFile();\n\n        for (int i = 0; i < 100; i++) {\n            added.add(getRandomTestString());\n        }\n        int count = writeStrings(added.iterator(), f, true);\n        assertEquals(added.size(), count);\n\n        Set<String> retrieved = readStringsAsSet(new FileInputStream(f), true);\n        assertEquals(added, retrieved);\n    }","id":72523,"modified_method":"@Test\n    public void writeReadRandomStrings() throws Exception {\n        Set<String> added = newHashSet();\n        for (int i = 0; i < 100; i++) {\n            added.add(getRandomTestString());\n        }\n        File f = assertWrite(added.iterator(), true, added.size());\n\n        Set<String> retrieved = readStringsAsSet(new FileInputStream(f), true);\n\n        assertEquals(added, retrieved);\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void appendTest() throws IOException {\n        Set<String> added1 = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f1 = folder.newFile();\n        writeStrings(added1.iterator(), f1, false);\n\n        Set<String> added2 = newHashSet(\"2\", \"3\", \"5\", \"6\");\n        File f2 = folder.newFile();\n        writeStrings(added2.iterator(), f2, false);\n\n        Set<String> added3 = newHashSet(\"t\", \"y\", \"8\", \"9\");\n        File f3 = folder.newFile();\n        writeStrings(added3.iterator(), f3, false);\n\n        append(newArrayList(f2, f3), f1, true);\n        assertEquals(union(union(added1, added2), added3),\n            readStringsAsSet(new FileInputStream(f1), false));\n        assertTrue(!f2.exists());\n        assertTrue(!f3.exists());\n        assertTrue(f1.exists());\n    }","id":72524,"modified_method":"@Test\n    public void appendTest() throws IOException {\n        Set<String> added1 = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f1 = assertWrite(added1.iterator(), false, added1.size());\n\n        Set<String> added2 = newHashSet(\"2\", \"3\", \"5\", \"6\");\n        File f2 = assertWrite(added2.iterator(), false, added2.size());\n\n        Set<String> added3 = newHashSet(\"t\", \"y\", \"8\", \"9\");\n        File f3 = assertWrite(added3.iterator(), false, added3.size());\n\n        append(newArrayList(f2, f3), f1, true);\n        assertEquals(union(union(added1, added2), added3),\n            readStringsAsSet(new FileInputStream(f1), false));\n        assertTrue(!f2.exists());\n        assertTrue(!f3.exists());\n        assertTrue(f1.exists());\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void writeReadStrings() throws Exception {\n        Set<String> added = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f = folder.newFile();\n\n        int count = writeStrings(added.iterator(), f, false);\n        assertEquals(added.size(), count);\n\n        Set<String> retrieved = readStringsAsSet(new FileInputStream(f), false);\n\n        assertEquals(added, retrieved);\n    }","id":72525,"modified_method":"@Test\n    public void writeReadStrings() throws Exception {\n        Set<String> added = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f = assertWrite(added.iterator(), false, added.size());\n\n        Set<String> retrieved = readStringsAsSet(new FileInputStream(f), false);\n\n        assertEquals(added, retrieved);\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void appendWithLineBreaksTest() throws IOException {\n        Set<String> added1 = newHashSet(getLineBreakStrings());\n        File f1 = folder.newFile();\n        int count = writeStrings(added1.iterator(), f1, true);\n        assertEquals(added1.size(), count);\n\n        Set<String> added2 = newHashSet(\"2\", \"3\", \"5\", \"6\");\n        File f2 = folder.newFile();\n        writeStrings(added2.iterator(), f2, true);\n\n        append(newArrayList(f1), f2, true);\n        assertEquals(union(added1, added2), readStringsAsSet(new FileInputStream(f2), true));\n    }","id":72526,"modified_method":"@Test\n    public void appendWithLineBreaksTest() throws IOException {\n        Set<String> added1 = newHashSet(getLineBreakStrings());\n        File f1 = assertWrite(added1.iterator(), true, added1.size());\n\n        Set<String> added2 = newHashSet(\"2\", \"3\", \"5\", \"6\");\n        File f2 = assertWrite(added2.iterator(), true, added2.size());\n\n        append(newArrayList(f1), f2, true);\n\n        assertEquals(union(added1, added2), readStringsAsSet(new FileInputStream(f2), true));\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void appendRandomizedTest() throws Exception {\n        Set<String> added1 = newHashSet();\n        File f1 = folder.newFile();\n\n        for (int i = 0; i < 100; i++) {\n            added1.add(getRandomTestString());\n        }\n        int count = writeStrings(added1.iterator(), f1, true);\n        assertEquals(added1.size(), count);\n\n        Set<String> added2 = newHashSet(\"2\", \"3\", \"5\", \"6\");\n        File f2 = folder.newFile();\n        writeStrings(added2.iterator(), f2, true);\n\n        append(newArrayList(f2), f1, true);\n        assertEquals(union(added1, added2),\n            readStringsAsSet(new FileInputStream(f1), true));\n    }","id":72527,"modified_method":"@Test\n    public void appendRandomizedTest() throws Exception {\n        Set<String> added1 = newHashSet();\n        for (int i = 0; i < 100; i++) {\n            added1.add(getRandomTestString());\n        }\n        File f1 = assertWrite(added1.iterator(), true, added1.size());\n\n        Set<String> added2 = newHashSet(\"2\", \"3\", \"5\", \"6\");\n        File f2 = assertWrite(added2.iterator(), true, added2.size());\n\n        append(newArrayList(f2), f1, true);\n\n        assertEquals(union(added1, added2),\n            readStringsAsSet(new FileInputStream(f1), true));\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void appendTestNoDelete() throws IOException {\n        Set<String> added1 = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f1 = folder.newFile();\n        writeStrings(added1.iterator(), f1, false);\n\n        Set<String> added2 = newHashSet(\"2\", \"3\", \"5\", \"6\");\n        File f2 = folder.newFile();\n        writeStrings(added2.iterator(), f2, false);\n\n        Set<String> added3 = newHashSet(\"t\", \"y\", \"8\", \"9\");\n        File f3 = folder.newFile();\n        writeStrings(added3.iterator(), f3, false);\n\n        append(newArrayList(f2, f3), f1, false);\n        assertEquals(union(union(added1, added2), added3),\n            readStringsAsSet(new FileInputStream(f1), false));\n        assertTrue(f2.exists());\n        assertTrue(f3.exists());\n        assertTrue(f1.exists());\n    }","id":72528,"modified_method":"@Test\n    public void appendTestNoDelete() throws IOException {\n        Set<String> added1 = newHashSet(\"a\", \"z\", \"e\", \"b\");\n        File f1 = assertWrite(added1.iterator(), false, added1.size());\n\n        Set<String> added2 = newHashSet(\"2\", \"3\", \"5\", \"6\");\n        File f2 = assertWrite(added2.iterator(), false, added2.size());\n\n        Set<String> added3 = newHashSet(\"t\", \"y\", \"8\", \"9\");\n        File f3 = assertWrite(added3.iterator(), false, added3.size());\n\n        append(newArrayList(f2, f3), f1, false);\n\n        assertEquals(union(union(added1, added2), added3),\n            readStringsAsSet(new FileInputStream(f1), false));\n        assertTrue(f2.exists());\n        assertTrue(f3.exists());\n        assertTrue(f1.exists());\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void writeReadStringsWithLineBreaks() throws IOException {\n        Set<String> added = newHashSet(getLineBreakStrings());\n        File f = folder.newFile();\n        int count = writeStrings(added.iterator(), f, true);\n        assertEquals(added.size(), count);\n\n        Set<String> retrieved = readStringsAsSet(new FileInputStream(f), true);\n        assertEquals(added, retrieved);\n    }","id":72529,"modified_method":"@Test\n    public void writeReadStringsWithLineBreaks() throws IOException {\n        Set<String> added = newHashSet(getLineBreakStrings());\n        File f = assertWrite(added.iterator(), true, added.size());\n\n        Set<String> retrieved = readStringsAsSet(new FileInputStream(f), true);\n\n        assertEquals(added, retrieved);\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static String getRandomTestString() throws Exception {\n        boolean valid = false;\n        StringBuilder buffer = new StringBuilder();\n        while(!valid) {\n            int length = RANDOM.nextInt(40);\n            for (int i = 0; i < length; i++) {\n                buffer.append((char) (RANDOM.nextInt(Character.MAX_VALUE)));\n            }\n            String s = buffer.toString();\n            CharsetEncoder encoder = Charset.forName(Charsets.UTF_8.toString()).newEncoder();\n            try {\n                encoder.encode(CharBuffer.wrap(s));\n                valid = true;\n            } catch (CharacterCodingException e) {\n                buffer = new StringBuilder();\n            }\n        }\n        return buffer.toString();\n    }","id":72530,"modified_method":"private static String getRandomTestString() throws Exception {\n        boolean valid = false;\n        StringBuilder buffer = new StringBuilder();\n        while(!valid) {\n            int length = RANDOM.nextInt(40);\n            for (int i = 0; i < length; i++) {\n                buffer.append((char) (RANDOM.nextInt(Character.MAX_VALUE)));\n            }\n            String s = buffer.toString();\n            CharsetEncoder encoder = Charset.forName(UTF_8.toString()).newEncoder();\n            try {\n                encoder.encode(CharBuffer.wrap(s));\n                valid = true;\n            } catch (CharacterCodingException e) {\n                buffer = new StringBuilder();\n            }\n        }\n        return buffer.toString();\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void sortCustomComparatorTest() throws IOException {\n        List<String> list = getLineBreakStrings();\n        File f = folder.newFile();\n        writeStrings(list.iterator(), f, true);\n        sort(f, lineBreakAwareComparator(lexComparator));\n\n        BufferedReader reader =\n            new BufferedReader(new InputStreamReader(new FileInputStream(f), Charsets.UTF_8));\n        String line = null;\n        List<String> retrieved = newArrayList();\n        while ((line = reader.readLine()) != null) {\n            retrieved.add(unescapeLineBreaks(line));\n        }\n        closeQuietly(reader);\n        Collections.sort(list);\n        assertArrayEquals(Arrays.toString(list.toArray()), list.toArray(), retrieved.toArray());\n    }","id":72531,"modified_method":"@Test\n    public void sortCustomComparatorTest() throws IOException {\n        List<String> list = getLineBreakStrings();\n        File f = assertWrite(list.iterator(), true, list.size());\n\n        sort(f, lineBreakAwareComparator(lexComparator));\n\n        BufferedReader reader =\n            new BufferedReader(new InputStreamReader(new FileInputStream(f), UTF_8));\n        String line = null;\n        List<String> retrieved = newArrayList();\n        while ((line = reader.readLine()) != null) {\n            retrieved.add(unescapeLineBreaks(line));\n        }\n        closeQuietly(reader);\n        Collections.sort(list);\n        assertArrayEquals(Arrays.toString(list.toArray()), list.toArray(), retrieved.toArray());\n    }","commit_id":"de740df9e8ec3ff018b723c90c7de3b0d3c88266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void processPopupMenu(MouseEvent e) {\n    ActionEventData context = new ActionEventData(myOperationContext);\n    context.put(SNode.class, BaseAdapter.fromAdapter(getSelectedConcept()));\n    context.put(List.class, CollectionUtil.asList(getSelectedConcept()));\n    BaseGroup group = ActionUtils.getGroup(ProjectPane.PROJECT_PANE_NODE_ACTIONS);\n    ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group).getComponent().show(this, e.getX(), e.getY());\n  }","id":72532,"modified_method":"private void processPopupMenu(MouseEvent e) {\n    BaseGroup group = ActionUtils.getGroup(ProjectPane.PROJECT_PANE_NODE_ACTIONS);\n    ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group).getComponent().show(this, e.getX(), e.getY());\n  }","commit_id":"6723a3d71716d39da3fde03847b5bfcbef62fd61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    final ActionEventData data = new ActionEventData(project.createOperationContext());\n    final String conceptName = \"MyVeryGoodConcept1\";\n    MoveConcepts moveConcepts = new MoveConcepts();\n    final RefactoringContext refactoringContext = new RefactoringContext(moveConcepts);\n    final SModelDescriptor targetStructureModelDescriptor[] = new SModelDescriptor[]{null};\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        targetStructureModelDescriptor[0] = testRefactoringTargetLanguage.getStructureModelDescriptor();\n        SNode concept = structureModelDescriptor.getSModel().getRootByName(conceptName);\n        data.put(SNode.class, concept);\n        data.put(List.class, CollectionUtil.asList(concept));\n        data.put(SModelDescriptor.class, structureModelDescriptor);\n        refactoringContext.setParameter(MoveConcepts.targetModel, targetStructureModelDescriptor[0]);\n      }\n    });\n\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              result[0] = sModel.getRoots().get(0).getConceptFqName().equals(targetStructureModelDescriptor[0] + \".\" + conceptName);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":72533,"modified_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    final String conceptName = \"MyVeryGoodConcept1\";\n    MoveConcepts moveConcepts = new MoveConcepts();\n    final RefactoringContext refactoringContext = new RefactoringContext(moveConcepts);\n    refactoringContext.setCurrentOperationContext(project.createOperationContext());\n    final SModelDescriptor targetStructureModelDescriptor[] = new SModelDescriptor[]{null};\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        targetStructureModelDescriptor[0] = testRefactoringTargetLanguage.getStructureModelDescriptor();\n        SNode concept = structureModelDescriptor.getSModel().getRootByName(conceptName);\n        refactoringContext.setSelectedNode(concept);\n        refactoringContext.setSelectedNodes(CollectionUtil.asList(concept));\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(MoveConcepts.targetModel, targetStructureModelDescriptor[0]);\n      }\n    });\n\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              result[0] = sModel.getRoots().get(0).getConceptFqName().equals(targetStructureModelDescriptor[0] + \".\" + conceptName);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"6723a3d71716d39da3fde03847b5bfcbef62fd61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    final ActionEventData data = new ActionEventData(project.createOperationContext());\n    final String newConceptName = \"MyVeryGoodConcept2\";\n    RenameConcept renameConcept = new RenameConcept();\n    final RefactoringContext refactoringContext = new RefactoringContext(renameConcept);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        final SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        refactoringContext.setParameter(STRMD, structureModelDescriptor);\n        SNode concept = structureModelDescriptor.getSModel().getRootByName(\"MyVeryGoodConcept1\");\n        data.put(SNode.class, concept);\n        data.put(SModelDescriptor.class, structureModelDescriptor);\n        refactoringContext.setParameter(\"newName\", newConceptName);\n      }\n    });\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              ((DefaultSModelDescriptor) sandbox1).setTestRefactoringMode(true);\n              SModel sModel = sandbox1.getSModel();\n              String conceptFqName = sModel.getRoots().get(0).getConceptFqName();\n              System.err.println(\"Inspected concept FQ name = \" + conceptFqName);\n              SModelDescriptor structureModelDescriptor = (SModelDescriptor) refactoringContext.getParameter(STRMD);\n              result[0] = conceptFqName.equals(structureModelDescriptor + \".\" + newConceptName);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":72534,"modified_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    final String newConceptName = \"MyVeryGoodConcept2\";\n    RenameConcept renameConcept = new RenameConcept();\n    final RefactoringContext refactoringContext = new RefactoringContext(renameConcept);\n    refactoringContext.setCurrentOperationContext(project.createOperationContext());\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        final SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        refactoringContext.setParameter(STRMD, structureModelDescriptor);\n        SNode concept = structureModelDescriptor.getSModel().getRootByName(\"MyVeryGoodConcept1\");\n        refactoringContext.setSelectedNode(concept);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(\"newName\", newConceptName);\n      }\n    });\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              ((DefaultSModelDescriptor) sandbox1).setTestRefactoringMode(true);\n              SModel sModel = sandbox1.getSModel();\n              String conceptFqName = sModel.getRoots().get(0).getConceptFqName();\n              System.err.println(\"Inspected concept FQ name = \" + conceptFqName);\n              SModelDescriptor structureModelDescriptor = (SModelDescriptor) refactoringContext.getParameter(STRMD);\n              result[0] = conceptFqName.equals(structureModelDescriptor + \".\" + newConceptName);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"6723a3d71716d39da3fde03847b5bfcbef62fd61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    final ActionEventData data = new ActionEventData(project.createOperationContext());\n    RenameLink renameLink = new RenameLink();\n    final RefactoringContext refactoringContext = new RefactoringContext(renameLink);\n    final String newLinkName = \"goodConcept\";\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringTargetLanguage.getStructureModelDescriptor();\n        SNode node = structureModelDescriptor.getSModel().getRootByName(\"AbstractGoodConcept\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode link = concept.getLinkDeclarations().get(0).getNode();\n        data.put(SNode.class, link);\n        data.put(SModelDescriptor.class, structureModelDescriptor);\n        refactoringContext.setParameter(RenameLink.newName, newLinkName);\n      }\n    });\n\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.getRoots().get(0);\n              result[0] = (root.getChildren(newLinkName).size() == 4);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":72535,"modified_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    RenameLink renameLink = new RenameLink();\n    final RefactoringContext refactoringContext = new RefactoringContext(renameLink);\n    refactoringContext.setCurrentOperationContext(project.createOperationContext());\n    final String newLinkName = \"goodConcept\";\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringTargetLanguage.getStructureModelDescriptor();\n        SNode node = structureModelDescriptor.getSModel().getRootByName(\"AbstractGoodConcept\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode link = concept.getLinkDeclarations().get(0).getNode();\n        refactoringContext.setSelectedNode(link);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(RenameLink.newName, newLinkName);\n      }\n    });\n\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.getRoots().get(0);\n              result[0] = (root.getChildren(newLinkName).size() == 4);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"6723a3d71716d39da3fde03847b5bfcbef62fd61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    final ActionEventData data = new ActionEventData(project.createOperationContext());\n    final String newLinkName = \"sister\";\n    RenameLink renameLink = new RenameLink();\n    final RefactoringContext refactoringContext = new RefactoringContext(renameLink);\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SNode node = structureModelDescriptor.getSModel().getRootByName(\"MyVeryGoodConcept1\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode link = concept.getLinkDeclarations().get(0).getNode();\n        data.put(SNode.class, link);\n        data.put(SModelDescriptor.class, structureModelDescriptor);\n        refactoringContext.setParameter(RenameLink.newName, newLinkName);\n      }\n    });\n\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.getRoots().get(0);\n              SNode referent = root.getReferent(newLinkName);\n              if (referent == null) {\n                System.err.println(\"referent is null\");\n                result[0] = false;\n                return;\n              }\n              result[0] = \"MyGood2\".equals(referent.getName());\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":72536,"modified_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    final String newLinkName = \"sister\";\n    RenameLink renameLink = new RenameLink();\n    final RefactoringContext refactoringContext = new RefactoringContext(renameLink);\n    refactoringContext.setCurrentOperationContext(project.createOperationContext());\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SNode node = structureModelDescriptor.getSModel().getRootByName(\"MyVeryGoodConcept1\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode link = concept.getLinkDeclarations().get(0).getNode();\n        refactoringContext.setSelectedNode(link);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(RenameLink.newName, newLinkName);\n      }\n    });\n\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.getRoots().get(0);\n              SNode referent = root.getReferent(newLinkName);\n              if (referent == null) {\n                System.err.println(\"referent is null\");\n                result[0] = false;\n                return;\n              }\n              result[0] = \"MyGood2\".equals(referent.getName());\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"6723a3d71716d39da3fde03847b5bfcbef62fd61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    final ActionEventData data = new ActionEventData(project.createOperationContext());\n    RenameProperty renameProperty = new RenameProperty();\n    final RefactoringContext refactoringContext = new RefactoringContext(renameProperty);\n    final String newPropertyName = \"niceProperty\";\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SNode node = structureModelDescriptor.getSModel().getRootByName(\"YetAnotherGoodConcept\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode property = concept.getPropertyDeclarations().get(0).getNode();\n        data.put(SNode.class, property);\n        data.put(SModelDescriptor.class, structureModelDescriptor);\n        refactoringContext.setParameter(RenameProperty.newName, newPropertyName);\n      }\n    });\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.getRoots().get(0);\n              SNode firstChild = root.getChildren(\"anotherGoodConcept\").get(0);\n              String propertyValue = firstChild.getProperty(newPropertyName);\n              result[0] = \"cat\".equals(propertyValue);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":72537,"modified_method":"public boolean testRefactoring(MPSProject project,\n                                 final SModelDescriptor sandbox1,\n                                 final SModelDescriptor sandbox2,\n                                 final Language testRefactoringLanguage,\n                                 final Language testRefactoringTargetLanguage, Runnable continuation) {\n    System.err.println(\"preparing arguments for refactoring\");\n    RenameProperty renameProperty = new RenameProperty();\n    final RefactoringContext refactoringContext = new RefactoringContext(renameProperty);\n    refactoringContext.setCurrentOperationContext(project.createOperationContext());\n    final String newPropertyName = \"niceProperty\";\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SNode node = structureModelDescriptor.getSModel().getRootByName(\"YetAnotherGoodConcept\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode property = concept.getPropertyDeclarations().get(0).getNode();\n        refactoringContext.setSelectedNode(property);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(RenameProperty.newName, newPropertyName);\n      }\n    });\n\n    System.err.println(\"executing a refactoring\");\n    new RefactoringProcessor().doExecuteInTest(refactoringContext, continuation);\n\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              System.err.println(\"checking a model\");\n              if (sandbox1.isInitialized()) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.getRoots().get(0);\n              SNode firstChild = root.getChildren(\"anotherGoodConcept\").get(0);\n              String propertyValue = firstChild.getProperty(newPropertyName);\n              result[0] = \"cat\".equals(propertyValue);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"6723a3d71716d39da3fde03847b5bfcbef62fd61","url":"https://github.com/JetBrains/MPS"},{"original_method":"public LandGrant(UUID ownerId) {\r\n        super(ownerId, 255, \"Land Grant\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{1}{G}\");\r\n        this.expansionSetCode = \"MMQ\";\r\n\r\n        this.color.setGreen(true);\r\n\r\n        // If you have no land cards in hand, you may reveal your hand rather than pay Land Grant's mana cost.\r\n        this.addAbility(new AlternativeCostSourceAbility(new LandGrantReavealCost(), new CardsInHandCondition(CardsInHandCondition.CountType.EQUAL_TO, 0),\r\n            \"If you have no land cards in hand, you may reveal your hand rather than pay Land Grant's mana cost.\"));\r\n\r\n        // Search your library for a Forest card, reveal that card, and put it into your hand. Then shuffle your library.\r\n        this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true, true));\r\n    }","id":72538,"modified_method":"public LandGrant(UUID ownerId) {\r\n        super(ownerId, 255, \"Land Grant\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{1}{G}\");\r\n        this.expansionSetCode = \"MMQ\";\r\n\r\n        this.color.setGreen(true);\r\n\r\n        // If you have no land cards in hand, you may reveal your hand rather than pay Land Grant's mana cost.\r\n        this.addAbility(new AlternativeCostSourceAbility(new LandGrantReavealCost(), new LandGrantCondition(),\r\n            \"If you have no land cards in hand, you may reveal your hand rather than pay Land Grant's mana cost.\"));\r\n\r\n        // Search your library for a Forest card, reveal that card, and put it into your hand. Then shuffle your library.\r\n        this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true, true));\r\n    }","commit_id":"f872a444779647409db16a3b5d9d78b8d38f65f5","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        Permanent permanent = game.getPermanent(source.getSourceId());\r\n        if (player != null && permanent != null) {\r\n            TargetOpponent target = new TargetOpponent();\r\n            target.setRequired(true);\r\n            target.setNotTarget(true);\r\n            if (player.choose(this.outcome, target, source.getSourceId(), game)) {\r\n                Player chosenPlayer = game.getPlayer(target.getFirstTarget());\r\n                if (chosenPlayer != null) {\r\n                    game.informPlayers(permanent.getName() + \": \" + player.getName() + \" has chosen \" + chosenPlayer.getName());\r\n                    int diff = chosenPlayer.getHand().size() - player.getHand().size();\r\n                    if (diff > 0) {\r\n                        player.drawCards(diff, game);\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":72539,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        Permanent permanent = (Permanent)game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);\r\n        if (player != null && permanent != null) {\r\n            TargetOpponent target = new TargetOpponent();\r\n            target.setRequired(true);\r\n            target.setNotTarget(true);\r\n            if (player.choose(this.outcome, target, source.getSourceId(), game)) {\r\n                Player chosenPlayer = game.getPlayer(target.getFirstTarget());\r\n                if (chosenPlayer != null) {\r\n                    game.informPlayers(permanent.getName() + \": \" + player.getName() + \" has chosen \" + chosenPlayer.getName());\r\n                    int diff = chosenPlayer.getHand().size() - player.getHand().size();\r\n                    if (diff > 0) {\r\n                        player.drawCards(diff, game);\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"f872a444779647409db16a3b5d9d78b8d38f65f5","url":"https://github.com/magefree/mage"},{"original_method":"public DarkBanishing(UUID ownerId) {\r\n        super(ownerId, 11, \"Dark Banishing\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{B}\");\r\n        this.expansionSetCode = \"TMP\";\r\n        this.color.setBlack(true);\r\n        this.getSpellAbility().addEffect(new DestroyNoRegenTargetEffect());\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));\r\n    }","id":72540,"modified_method":"public DarkBanishing(UUID ownerId) {\r\n        super(ownerId, 11, \"Dark Banishing\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{B}\");\r\n        this.expansionSetCode = \"TMP\";\r\n        this.color.setBlack(true);\r\n        this.getSpellAbility().addEffect(new DestroyTargetEffect(true));\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));\r\n    }","commit_id":"260dada5f7af0fb208aa890a95371cebb6910600","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic String getText(Mode mode) {\n        if (mode.getTargets().size() == 0) {\n            return \"destroy that creature\"; //TODO add possibility to specify text with targetPointer usage\n        } else if (mode.getTargets().get(0).getNumberOfTargets() == 1)\n\t\t    return \"Destroy target \" + mode.getTargets().get(0).getTargetName();\n        else\n            return \"Destroy \" + mode.getTargets().get(0).getNumberOfTargets() + \" target \" + mode.getTargets().get(0).getTargetName();\n\t}","id":72541,"modified_method":"@Override\n\tpublic String getText(Mode mode) {\n        StringBuffer sb = new StringBuffer();\n        if (mode.getTargets().size() == 0) {\n            sb.append(\"destroy that creature\"); //TODO add possibility to specify text with targetPointer usage\n        } else if (mode.getTargets().get(0).getNumberOfTargets() == 1)\n            sb.append(\"Destroy target \").append(mode.getTargets().get(0).getTargetName());\n        else\n            sb.append(\"Destroy \").append(mode.getTargets().get(0).getNumberOfTargets()).append(\" target \").append(mode.getTargets().get(0).getTargetName());\n        if (noRegen)\n            sb.append(\". It can't be regenerated\");\n        return sb.toString();\n\t}","commit_id":"260dada5f7af0fb208aa890a95371cebb6910600","url":"https://github.com/magefree/mage"},{"original_method":"public Putrefy (UUID ownerId) {\r\n        super(ownerId, 221, \"Putrefy\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{B}{G}\");\r\n        this.expansionSetCode = \"RAV\";\r\n        this.color.setBlack(true);\r\n        this.color.setGreen(true);\r\n        this.getSpellAbility().addTarget(new TargetPermanent(filter));\r\n        this.getSpellAbility().addEffect(new DestroyNoRegenTargetEffect());\r\n    }","id":72542,"modified_method":"public Putrefy (UUID ownerId) {\r\n        super(ownerId, 221, \"Putrefy\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{B}{G}\");\r\n        this.expansionSetCode = \"RAV\";\r\n        this.color.setBlack(true);\r\n        this.color.setGreen(true);\r\n        this.getSpellAbility().addTarget(new TargetPermanent(filter));\r\n        this.getSpellAbility().addEffect(new DestroyTargetEffect(true));\r\n    }","commit_id":"260dada5f7af0fb208aa890a95371cebb6910600","url":"https://github.com/magefree/mage"},{"original_method":"public SealOfDoom(UUID ownerId) {\r\n        super(ownerId, 53, \"Seal of Doom\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{B}\");\r\n        this.expansionSetCode = \"DIS\";\r\n        this.color.setBlack(true);\r\n        Ability ability = new SimpleActivatedAbility(Constants.Zone.BATTLEFIELD, new DestroyNoRegenTargetEffect(), new SacrificeSourceCost());\r\n        ability.addTarget(new TargetCreaturePermanent(filter));\r\n        this.addAbility(ability);\r\n    }","id":72543,"modified_method":"public SealOfDoom(UUID ownerId) {\r\n        super(ownerId, 53, \"Seal of Doom\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{B}\");\r\n        this.expansionSetCode = \"DIS\";\r\n        this.color.setBlack(true);\r\n        Ability ability = new SimpleActivatedAbility(Constants.Zone.BATTLEFIELD, new DestroyTargetEffect(true), new SacrificeSourceCost());\r\n        ability.addTarget(new TargetCreaturePermanent(filter));\r\n        this.addAbility(ability);\r\n    }","commit_id":"260dada5f7af0fb208aa890a95371cebb6910600","url":"https://github.com/magefree/mage"},{"original_method":"public Smother(UUID ownerId) {\r\n        super(ownerId, 68, \"Smother\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{B}\");\r\n        this.expansionSetCode = \"WWK\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));\r\n        this.getSpellAbility().addEffect(new DestroyNoRegenTargetEffect());\r\n    }","id":72544,"modified_method":"public Smother(UUID ownerId) {\r\n        super(ownerId, 68, \"Smother\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{B}\");\r\n        this.expansionSetCode = \"WWK\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));\r\n        this.getSpellAbility().addEffect(new DestroyTargetEffect(true));\r\n    }","commit_id":"260dada5f7af0fb208aa890a95371cebb6910600","url":"https://github.com/magefree/mage"},{"original_method":"public Terminate(UUID ownerId) {\n\t\tsuper(ownerId, 46, \"Terminate\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{B}{R}\");\n\t\tthis.expansionSetCode = \"ARB\";\n\t\tthis.color.setBlack(true);\n\t\tthis.color.setRed(true);\n\t\tthis.getSpellAbility().addTarget(new TargetCreaturePermanent());\n\t\tthis.getSpellAbility().addEffect(new DestroyNoRegenTargetEffect());\n\t}","id":72545,"modified_method":"public Terminate(UUID ownerId) {\n\t\tsuper(ownerId, 46, \"Terminate\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{B}{R}\");\n\t\tthis.expansionSetCode = \"ARB\";\n\t\tthis.color.setBlack(true);\n\t\tthis.color.setRed(true);\n\t\tthis.getSpellAbility().addTarget(new TargetCreaturePermanent());\n\t\tthis.getSpellAbility().addEffect(new DestroyTargetEffect(true));\n\t}","commit_id":"260dada5f7af0fb208aa890a95371cebb6910600","url":"https://github.com/magefree/mage"},{"original_method":"public Vendetta(UUID ownerId) {\r\n        super(ownerId, 130, \"Vendetta\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{B}\");\r\n        this.expansionSetCode = \"ROE\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));\r\n        this.getSpellAbility().addEffect(new DestroyNoRegenTargetEffect());\r\n        this.getSpellAbility().addEffect(new VendettaEffect());\r\n    }","id":72546,"modified_method":"public Vendetta(UUID ownerId) {\r\n        super(ownerId, 130, \"Vendetta\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{B}\");\r\n        this.expansionSetCode = \"ROE\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));\r\n        this.getSpellAbility().addEffect(new DestroyTargetEffect(true));\r\n        this.getSpellAbility().addEffect(new VendettaEffect());\r\n    }","commit_id":"260dada5f7af0fb208aa890a95371cebb6910600","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        Permanent target = game.getPermanent(source.getFirstTarget());\r\n        if (player != null && target != null) {\r\n            player.loseLife(target.getToughness().getValue(), game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":72547,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        Permanent target = (Permanent) game.getLastKnownInformation(source.getFirstTarget(), Constants.Zone.BATTLEFIELD);\r\n        if (player != null && target != null) {\r\n            player.loseLife(target.getToughness().getValue(), game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"260dada5f7af0fb208aa890a95371cebb6910600","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPermanent permanent = game.getPermanent(source.getFirstTarget());\n\t\tif (permanent != null) {\n\t\t\tPlayer player = game.getPlayer(permanent.getControllerId());\n\t\t\tif (player != null) {\n\t\t\t\tplayer.gainLife(permanent.getToughness().getValue(), game);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":72548,"modified_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPermanent permanent = (Permanent)game.getLastKnownInformation(source.getFirstTarget(), Constants.Zone.BATTLEFIELD);\n\t\tif (permanent != null) {\n\t\t\tPlayer player = game.getPlayer(permanent.getControllerId());\n\t\t\tif (player != null) {\n\t\t\t\tplayer.gainLife(permanent.getToughness().getValue(), game);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"ec7da844a4f9d66c1eb7b8d998f5a12d9396df51","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * <p>Converts the given command-line arguments to a {@code Runnable} action which performs the action requested by the\n     * command-line args. Does not have any side-effects. Each action will call the supplied {@link\n     * org.gradle.launcher.exec.ExecutionListener} once it has completed.<\/p>\n     *\n     * <p>Implementation note: attempt to defer as much as possible until action execution time.<\/p>\n     *\n     * @param args The command-line arguments.\n     * @return The action to execute.\n     */\n    public Action<ExecutionListener> convert(List<String> args) {\n        CommandLineParser parser = new CommandLineParser();\n\n        CommandLineConverter<StartParameter> startParameterConverter = createStartParameterConverter();\n        startParameterConverter.configure(parser);\n\n        parser.option(HELP, \"?\", \"help\").hasDescription(\"Shows this help message\");\n        parser.option(VERSION, \"version\").hasDescription(\"Print version info.\");\n        parser.option(GUI).hasDescription(\"Launches a GUI application\");\n        parser.option(FOREGROUND).hasDescription(\"Starts the Gradle daemon in the foreground [experimental].\");\n        parser.option(DAEMON).hasDescription(\"Uses the Gradle daemon to run the build. Starts the daemon if not running [experimental].\");\n        parser.option(NO_DAEMON).hasDescription(\"Do not use the Gradle daemon to run the build [experimental].\");\n        parser.option(STOP).hasDescription(\"Stops the Gradle daemon if it is running [experimental].\");\n\n        LoggingConfiguration loggingConfiguration = new LoggingConfiguration();\n        ServiceRegistry loggingServices = createLoggingServices();\n\n        Action<ExecutionListener> action;\n        try {\n            ParsedCommandLine commandLine = parser.parse(args);\n            @SuppressWarnings(\"unchecked\")\n            CommandLineConverter<LoggingConfiguration> loggingConfigurationConverter = (CommandLineConverter<LoggingConfiguration>)loggingServices.get(CommandLineConverter.class);\n            loggingConfigurationConverter.convert(commandLine, loggingConfiguration);\n            action = createAction(parser, commandLine, startParameterConverter, loggingServices);\n        } catch (CommandLineArgumentException e) {\n            action = new CommandLineParseFailureAction(parser, e);\n        }\n\n        return new WithLoggingAction(loggingConfiguration, loggingServices,\n                new ExceptionReportingAction(action,\n                        new BuildExceptionReporter(loggingServices.get(StyledTextOutputFactory.class), loggingConfiguration, clientMetaData())));\n    }","id":72549,"modified_method":"/**\n     * <p>Converts the given command-line arguments to a {@code Runnable} action which performs the action requested by the\n     * command-line args. Does not have any side-effects. Each action will call the supplied {@link\n     * org.gradle.launcher.exec.ExecutionListener} once it has completed.<\/p>\n     *\n     * <p>Implementation note: attempt to defer as much as possible until action execution time.<\/p>\n     *\n     * @param args The command-line arguments.\n     * @return The action to execute.\n     */\n    public Action<ExecutionListener> convert(List<String> args) {\n        CommandLineParser parser = new CommandLineParser();\n\n        CommandLineConverter<StartParameter> startParameterConverter = createStartParameterConverter();\n        startParameterConverter.configure(parser);\n\n        parser.option(HELP, \"?\", \"help\").hasDescription(\"Shows this help message.\");\n        parser.option(VERSION, \"version\").hasDescription(\"Print version info.\");\n        parser.option(GUI).hasDescription(\"Launches the Gradle GUI.\");\n        parser.option(FOREGROUND).hasDescription(\"Starts the Gradle daemon in the foreground.\").experimental();\n        parser.option(DAEMON).hasDescription(\"Uses the Gradle daemon to run the build. Starts the daemon if not running.\").experimental();\n        parser.option(NO_DAEMON).hasDescription(\"Do not use the Gradle daemon to run the build.\").experimental();\n        parser.option(STOP).hasDescription(\"Stops the Gradle daemon if it is running.\").experimental();\n\n        LoggingConfiguration loggingConfiguration = new LoggingConfiguration();\n        ServiceRegistry loggingServices = createLoggingServices();\n\n        Action<ExecutionListener> action;\n        try {\n            ParsedCommandLine commandLine = parser.parse(args);\n            @SuppressWarnings(\"unchecked\")\n            CommandLineConverter<LoggingConfiguration> loggingConfigurationConverter = (CommandLineConverter<LoggingConfiguration>)loggingServices.get(CommandLineConverter.class);\n            loggingConfigurationConverter.convert(commandLine, loggingConfiguration);\n            action = createAction(parser, commandLine, startParameterConverter, loggingServices);\n        } catch (CommandLineArgumentException e) {\n            action = new CommandLineParseFailureAction(parser, e);\n        }\n\n        return new WithLoggingAction(loggingConfiguration, loggingServices,\n                new ExceptionReportingAction(action,\n                        new BuildExceptionReporter(loggingServices.get(StyledTextOutputFactory.class), loggingConfiguration, clientMetaData())));\n    }","commit_id":"0cffc971df9d0805422384b4394b4b0e6ea4d6fe","url":"https://github.com/gradle/gradle"},{"original_method":"public String getDescription() {\n        if (deprecationWarning == null) {\n            return description;\n        }\n        return description + \" [deprecated - \" + deprecationWarning + \"].\";\n    }","id":72550,"modified_method":"public String getDescription() {\n        StringBuilder result = new StringBuilder();\n        if (description != null) {\n            result.append(description);\n        }\n        if (deprecationWarning != null) {\n            if (result.length() > 0) {\n                result.append(' ');\n            }\n            result.append(\"[deprecated - \");\n            result.append(deprecationWarning);\n            result.append(\"]\");\n        }\n        if (experimental) {\n            if (result.length() > 0) {\n                result.append(' ');\n            }\n            result.append(\"[experimental]\");\n        }\n        return result.toString();\n    }","commit_id":"0cffc971df9d0805422384b4394b4b0e6ea4d6fe","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public ParserState onComplete() {\n            if (getHasArgument() && values.isEmpty()) {\n                throw new CommandLineArgumentException(String.format(\"No argument was provided for command-line option '%s'.\", optionString));\n            }\n            \n            ParsedCommandLineOption parsedOption = commandLine.addOption(optionString.option, option);\n            if (values.size() + parsedOption.getValues().size() > 1 && !option.getAllowsMultipleArguments()) {\n                throw new CommandLineArgumentException(String.format(\"Multiple arguments were provided for command-line option '%s'.\", optionString));\n            }\n            for (String value : values) {\n                parsedOption.addArgument(value);\n            }\n            if (option.getDeprecationWarning() != null) {\n                new PrintStream(CommandLineParser.this.deprecationPrinter).println(\"The \" + optionString + \" option is deprecated - \" + option.getDeprecationWarning());\n            }\n            if (option.getSubcommand() != null) {\n                return state.onNonOption(option.getSubcommand());\n            }\n\n            return state;\n        }","id":72551,"modified_method":"@Override\n        public ParserState onComplete() {\n            if (getHasArgument() && values.isEmpty()) {\n                throw new CommandLineArgumentException(String.format(\"No argument was provided for command-line option '%s'.\", optionString));\n            }\n            \n            ParsedCommandLineOption parsedOption = commandLine.addOption(optionString.option, option);\n            if (values.size() + parsedOption.getValues().size() > 1 && !option.getAllowsMultipleArguments()) {\n                throw new CommandLineArgumentException(String.format(\"Multiple arguments were provided for command-line option '%s'.\", optionString));\n            }\n            for (String value : values) {\n                parsedOption.addArgument(value);\n            }\n            if (option.getDeprecationWarning() != null) {\n                deprecationPrinter.println(\"The \" + optionString + \" option is deprecated - \" + option.getDeprecationWarning());\n            }\n            if (option.getSubcommand() != null) {\n                return state.onNonOption(option.getSubcommand());\n            }\n\n            return state;\n        }","commit_id":"0cffc971df9d0805422384b4394b4b0e6ea4d6fe","url":"https://github.com/gradle/gradle"},{"original_method":"public void configure(CommandLineParser parser) {\n        loggingConfigurationCommandLineConverter.configure(parser);\n        systemPropertiesCommandLineConverter.configure(parser);\n        parser.allowMixedSubcommandsAndOptions();\n        parser.option(NO_SEARCH_UPWARDS, \"no-search-upward\").hasDescription(String.format(\"Don't search in parent folders for a %s file.\", Settings.DEFAULT_SETTINGS_FILE));\n        parser.option(CACHE, \"cache\").hasArgument().hasDescription(\"Specifies how compiled build scripts should be cached. Possible values are: 'rebuild' and 'on'. Default value is 'on'\");\n        parser.option(RESOLVE_MODE).hasArgument().hasDescription(\"Specifies how resolution should be performed. Possible values are: 'offline', 'force' and 'standard' (default).\");\n        parser.option(PROJECT_CACHE_DIR).hasArgument().hasDescription(\"Specifies the project-specific cache directory. Defaults to .gradle in the root project directory.\");\n        parser.option(DRY_RUN, \"dry-run\").hasDescription(\"Runs the builds with all task actions disabled.\");\n        parser.option(TASKS, \"tasks\").mapsToSubcommand(ImplicitTasksConfigurer.TASKS_TASK).hasDescription(\"Show list of available tasks\").deprecated(deprecationMessage(\"tasks\"));\n        parser.option(PROPERTIES, \"properties\").mapsToSubcommand(ImplicitTasksConfigurer.PROPERTIES_TASK).hasDescription(\"Show list of all available project properties\").deprecated(deprecationMessage(\"properties\"));\n        parser.option(DEPENDENCIES, \"dependencies\").mapsToSubcommand(ImplicitTasksConfigurer.DEPENDENCIES_TASK).hasDescription(\"Show list of all project dependencies\").deprecated(deprecationMessage(\"dependencies\"));\n        parser.option(PROJECT_DIR, \"project-dir\").hasArgument().hasDescription(\"Specifies the start directory for Gradle. Defaults to current directory.\");\n        parser.option(GRADLE_USER_HOME, \"gradle-user-home\").hasArgument().hasDescription(\"Specifies the gradle user home directory.\");\n        parser.option(INIT_SCRIPT, \"init-script\").hasArguments().hasDescription(\"Specifies an initialization script.\");\n        parser.option(SETTINGS_FILE, \"settings-file\").hasArgument().hasDescription(\"Specifies the settings file.\");\n        parser.option(BUILD_FILE, \"build-file\").hasArgument().hasDescription(\"Specifies the build file.\");\n        parser.option(PROJECT_PROP, \"project-prop\").hasArguments().hasDescription(\"Set project property for the build script (e.g. -Pmyprop=myvalue).\");\n        parser.option(EMBEDDED_SCRIPT, \"embedded\").hasArgument().hasDescription(\"Specify an embedded build script.\");\n        parser.option(NO_PROJECT_DEPENDENCY_REBUILD, \"no-rebuild\").hasDescription(\"Do not rebuild project dependencies.\");\n        parser.option(NO_OPT).hasDescription(\"Ignore any task optimization.\");\n        parser.option(EXCLUDE_TASK, \"exclude-task\").hasArguments().hasDescription(\"Specify a task to be excluded from execution.\");\n        parser.option(PROFILE).hasDescription(\"Profiles build execution time and generates a report in the <build_dir>/reports/profile directory.\");\n        parser.option(CONTINUE).hasDescription(\"Continues task execution after a task failure. [experimental]\");\n    }","id":72552,"modified_method":"public void configure(CommandLineParser parser) {\n        loggingConfigurationCommandLineConverter.configure(parser);\n        systemPropertiesCommandLineConverter.configure(parser);\n        parser.allowMixedSubcommandsAndOptions();\n        parser.option(NO_SEARCH_UPWARDS, \"no-search-upward\").hasDescription(String.format(\"Don't search in parent folders for a %s file.\", Settings.DEFAULT_SETTINGS_FILE));\n        parser.option(CACHE, \"cache\").hasArgument().hasDescription(\"Specifies how compiled build scripts should be cached. Possible values are: 'rebuild' and 'on'. Default value is 'on'.\");\n        parser.option(RESOLVE_MODE).hasArgument().hasDescription(\"Specifies how resolution should be performed. Possible values are: 'offline', 'force' and 'standard'. Default value is 'standard'.\").experimental();\n        parser.option(PROJECT_CACHE_DIR).hasArgument().hasDescription(\"Specifies the project-specific cache directory. Defaults to .gradle in the root project directory.\");\n        parser.option(DRY_RUN, \"dry-run\").hasDescription(\"Runs the builds with all task actions disabled.\");\n        parser.option(TASKS, \"tasks\").mapsToSubcommand(ImplicitTasksConfigurer.TASKS_TASK).hasDescription(\"Show list of available tasks.\").deprecated(deprecationMessage(\"tasks\"));\n        parser.option(PROPERTIES, \"properties\").mapsToSubcommand(ImplicitTasksConfigurer.PROPERTIES_TASK).hasDescription(\"Show list of all available project properties.\").deprecated(deprecationMessage(\"properties\"));\n        parser.option(DEPENDENCIES, \"dependencies\").mapsToSubcommand(ImplicitTasksConfigurer.DEPENDENCIES_TASK).hasDescription(\"Show list of all project dependencies.\").deprecated(deprecationMessage(\"dependencies\"));\n        parser.option(PROJECT_DIR, \"project-dir\").hasArgument().hasDescription(\"Specifies the start directory for Gradle. Defaults to current directory.\");\n        parser.option(GRADLE_USER_HOME, \"gradle-user-home\").hasArgument().hasDescription(\"Specifies the gradle user home directory.\");\n        parser.option(INIT_SCRIPT, \"init-script\").hasArguments().hasDescription(\"Specifies an initialization script.\");\n        parser.option(SETTINGS_FILE, \"settings-file\").hasArgument().hasDescription(\"Specifies the settings file.\");\n        parser.option(BUILD_FILE, \"build-file\").hasArgument().hasDescription(\"Specifies the build file.\");\n        parser.option(PROJECT_PROP, \"project-prop\").hasArguments().hasDescription(\"Set project property for the build script (e.g. -Pmyprop=myvalue).\");\n        parser.option(EMBEDDED_SCRIPT, \"embedded\").hasArgument().hasDescription(\"Specify an embedded build script.\").deprecated(\"no replacement\");\n        parser.option(NO_PROJECT_DEPENDENCY_REBUILD, \"no-rebuild\").hasDescription(\"Do not rebuild project dependencies.\");\n        parser.option(NO_OPT).hasDescription(\"Ignore any task optimization.\");\n        parser.option(EXCLUDE_TASK, \"exclude-task\").hasArguments().hasDescription(\"Specify a task to be excluded from execution.\");\n        parser.option(PROFILE).hasDescription(\"Profiles build execution time and generates a report in the <build_dir>/reports/profile directory.\");\n        parser.option(CONTINUE).hasDescription(\"Continues task execution after a task failure.\").experimental();\n    }","commit_id":"0cffc971df9d0805422384b4394b4b0e6ea4d6fe","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n         * @see org.opencms.gwt.client.rpc.CmsRpcAction#onResponse(java.lang.Object)\n         */\n        @Override\n        protected void onResponse(Map<String, CmsContainerElement> result) {\n\n            if (result != null) {\n                addElements(result);\n                Iterator<CmsDragContainerElement> it = getAllDragElements().iterator();\n                while (it.hasNext()) {\n                    CmsDragContainerElement dragElement = it.next();\n                    if (m_clientIds.contains(dragElement.getClientId())) {\n                        try {\n                            replaceDragElement(dragElement, m_elements.get(dragElement.getClientId()));\n                        } catch (Exception e) {\n                            CmsDebugLog.getInstance().printLine(e.getLocalizedMessage());\n                        }\n                    }\n                }\n            }\n\n        }","id":72553,"modified_method":"/**\n         * @see org.opencms.gwt.client.rpc.CmsRpcAction#onResponse(java.lang.Object)\n         */\n        @Override\n        protected void onResponse(Map<String, CmsContainerElement> result) {\n\n            if (result == null) {\n                return;\n            }\n            addElements(result);\n            Iterator<CmsDragContainerElement> it = getAllDragElements().iterator();\n            while (it.hasNext()) {\n                CmsDragContainerElement dragElement = it.next();\n                if (!m_clientIds.contains(dragElement.getClientId())) {\n                    continue;\n                }\n                try {\n                    replaceDragElement(dragElement, m_elements.get(dragElement.getClientId()));\n                } catch (Exception e) {\n                    CmsDebugLog.getInstance().printLine(\"trying to replace\");\n                    CmsDebugLog.getInstance().printLine(e.getLocalizedMessage());\n                }\n\n            }\n\n        }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Previews events. Shows the leaving page dialog, if the page has changed and an anchor has been clicked.<p>\n     * \n     * @param event the native event\n     */\n    void previewNativeEvent(NativePreviewEvent event) {\n\n        Event nativeEvent = Event.as(event.getNativeEvent());\n        if (hasPageChanged()) {\n            if ((nativeEvent.getTypeInt() == Event.ONCLICK)) {\n                CmsDebugLog.getInstance().printLine(\"Previewing event\");\n\n                EventTarget target = nativeEvent.getEventTarget();\n                if (Element.is(target)) {\n                    Element element = Element.as(target);\n                    CmsDebugLog.getInstance().printLine(\"Checking element\");\n                    element = CmsDomUtil.getAncestor(element, CmsDomUtil.Tag.a);\n                    if (element != null) {\n                        AnchorElement anc = AnchorElement.as(element);\n                        final String uri = anc.getHref();\n                        if (CmsStringUtil.isEmptyOrWhitespaceOnly(uri)) {\n                            return;\n                        }\n                        nativeEvent.preventDefault();\n                        nativeEvent.stopPropagation();\n                        CmsLeavePageDialog dialog = new CmsLeavePageDialog(uri, this, null);\n                        CmsDebugLog.getInstance().printLine(\"Event canceled ++\");\n                        dialog.center();\n                    }\n                }\n            }\n            if ((event.getTypeInt() == Event.ONKEYPRESS) && (nativeEvent.getKeyCode() == 116)) {\n                nativeEvent.preventDefault();\n                nativeEvent.stopPropagation();\n                CmsLeavePageDialog dialog = new CmsLeavePageDialog(Window.Location.getHref(), this, null);\n                dialog.center();\n                CmsDebugLog.getInstance().printLine(\"Reload canceled\");\n            }\n        }\n    }","id":72554,"modified_method":"/**\n     * Previews events. Shows the leaving page dialog, if the page has changed and an anchor has been clicked.<p>\n     * \n     * @param event the native event\n     */\n    void previewNativeEvent(NativePreviewEvent event) {\n\n        Event nativeEvent = Event.as(event.getNativeEvent());\n        if (!hasPageChanged()) {\n            return;\n        }\n        if ((nativeEvent.getTypeInt() == Event.ONCLICK)) {\n            EventTarget target = nativeEvent.getEventTarget();\n            if (!Element.is(target)) {\n                return;\n            }\n            Element element = Element.as(target);\n            element = CmsDomUtil.getAncestor(element, CmsDomUtil.Tag.a);\n            if (element == null) {\n                return;\n            }\n            AnchorElement anc = AnchorElement.as(element);\n            final String uri = anc.getHref();\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(uri)) {\n                return;\n            }\n            nativeEvent.preventDefault();\n            nativeEvent.stopPropagation();\n            CmsLeavePageDialog dialog = new CmsLeavePageDialog(uri, this, null);\n            dialog.center();\n        }\n        if ((event.getTypeInt() == Event.ONKEYPRESS) && (nativeEvent.getKeyCode() == 116)) {\n            nativeEvent.preventDefault();\n            nativeEvent.stopPropagation();\n            CmsLeavePageDialog dialog = new CmsLeavePageDialog(Window.Location.getHref(), this, null);\n            dialog.center();\n        }\n\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Replaces the given drag-element with the given container element.<p>\n     * \n     * @param dragElement the drag-element to replace\n     * @param elementData the new element data\n     * \n     * @throws Exception if something goes wrong\n     */\n    public void replaceDragElement(CmsDragContainerElement dragElement, CmsContainerElement elementData)\n    throws Exception {\n\n        CmsDragTargetContainer dragParent = (CmsDragTargetContainer)dragElement.getDragParent();\n        String containerType = m_containers.get(dragParent.getContainerId()).getType();\n\n        String elementContent = elementData.getContents().get(containerType);\n        if ((elementContent != null) && (elementContent.trim().length() > 0)) {\n            CmsDragContainerElement replacer = getContainerpageUtil().createElement(\n                elementData,\n                dragParent,\n                containerType);\n\n            dragParent.insert(replacer, dragParent.getWidgetIndex(dragElement));\n            dragElement.removeFromParent();\n        }\n    }","id":72555,"modified_method":"/**\n     * Replaces the given drag-element with the given container element.<p>\n     * \n     * @param dragElement the drag-element to replace\n     * @param elementData the new element data\n     * \n     * @throws Exception if something goes wrong\n     */\n    public void replaceDragElement(CmsDragContainerElement dragElement, CmsContainerElement elementData)\n    throws Exception {\n\n        I_CmsDragTargetContainer dragParent = dragElement.getDragParent();\n        String containerType = dragParent.getContainerType();\n\n        String elementContent = elementData.getContents().get(containerType);\n        if ((elementContent != null) && (elementContent.trim().length() > 0)) {\n            CmsDragContainerElement replacer = getContainerpageUtil().createElement(\n                elementData,\n                dragParent,\n                containerType);\n\n            dragParent.insert(replacer, dragParent.getWidgetIndex(dragElement));\n            dragElement.removeFromParent();\n        }\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public ReloadElementAction(Set<String> clientIds) {\n\n            super();\n            m_clientIds = clientIds;\n        }","id":72556,"modified_method":"/**\n         * Constructor.<p>\n         * \n         * @param clientIds the client id's to reload\n         */\n        public ReloadElementAction(Set<String> clientIds) {\n\n            super();\n            m_clientIds = clientIds;\n        }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns all drag elements of the page.<p>\n     * \n     * @return the drag elements\n     */\n    public List<CmsDragContainerElement> getAllDragElements() {\n\n        List<CmsDragContainerElement> result = new ArrayList<CmsDragContainerElement>();\n        Iterator<CmsDragTargetContainer> it = m_targetContainers.values().iterator();\n        while (it.hasNext()) {\n            result.addAll(it.next().getAllDragElements());\n        }\n        return result;\n    }","id":72557,"modified_method":"/**\n     * Returns all drag elements of the page.<p>\n     * \n     * @return the drag elements\n     */\n    public List<CmsDragContainerElement> getAllDragElements() {\n\n        List<CmsDragContainerElement> result = new ArrayList<CmsDragContainerElement>();\n        Iterator<CmsDragTargetContainer> it = m_targetContainers.values().iterator();\n        while (it.hasNext()) {\n            result.addAll(it.next().getAllDragElements());\n        }\n        if (isSubcontainerEditing()) {\n            Iterator<Widget> itSub = m_editingSubcontainer.iterator();\n            while (itSub.hasNext()) {\n                Widget w = itSub.next();\n                if (w instanceof CmsDragContainerElement) {\n                    result.add((CmsDragContainerElement)w);\n                }\n            }\n        }\n        return result;\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Opens the edit dialog for the specified element.<p>\n     * \n     * @param element the element to edit\n     */\n    public void openEditorForElement(CmsDragContainerElement element) {\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(element.getNoEditReason())) {\n            if (CmsDomUtil.hasClass(CmsContainerpageUtil.CLASS_SUB_CONTAINER_ELEMENTS, element.getElement())) {\n                openSubcontainerEditor(element);\n            } else {\n                CmsContentEditorDialog.get().openEditDialog(element.getClientId(), element.getSitePath());\n            }\n        } else {\n            CmsDebugLog.getInstance().printLine(element.getNoEditReason());\n        }\n    }","id":72558,"modified_method":"/**\n     * Opens the edit dialog for the specified element.<p>\n     * \n     * @param element the element to edit\n     */\n    public void openEditorForElement(CmsDragContainerElement element) {\n\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(element.getNoEditReason())) {\n            if (CmsDomUtil.hasClass(CmsContainerpageUtil.CLASS_SUB_CONTAINER_ELEMENTS, element.getElement())) {\n                openSubcontainerEditor((CmsDragSubcontainer)element);\n            } else {\n                CmsContentEditorDialog.get().openEditDialog(element.getClientId(), element.getSitePath());\n            }\n        } else {\n            CmsDebugLog.getInstance().printLine(element.getNoEditReason());\n        }\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Enables the drag handler on the given element.<p>\n     * \n     * @param element the element\n     */\n    public void enableDragHandler(I_CmsDragElement element) {\n\n        m_controller.getContainerpageUtil().enableDragHandler(element);\n    }","id":72559,"modified_method":"/**\n     * Enables the drag handler on the given element.<p>\n     * \n     * @param element the element\n     */\n    public void enableDragHandler(I_CmsDragContainerElement<I_CmsDragTargetContainer> element) {\n\n        m_controller.getContainerpageUtil().enableDragHandler(element);\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Opens the sub-container element editor.<p>\n     * \n     * @param subContainer the sub-container element\n     */\n    private void openSubcontainerEditor(CmsDragContainerElement subContainer) {\n\n        // TODO: implement\n\n        CmsDebugLog.getInstance().printLine(\"should open sub-container editor\");\n    }","id":72560,"modified_method":"/**\n     * Opens the sub-container element editor.<p>\n     * \n     * @param subContainer the sub-container element\n     */\n    private void openSubcontainerEditor(CmsDragSubcontainer subContainer) {\n\n        CmsSubcontainerEditor.openSubcontainerEditor(subContainer, m_controller, this);\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a drag container element for sub-container elements.<p>\n     * \n     * @param containerElement the container element data \n     * @param subElements the sub-elements\n     * @param dragParent the drag parent\n     * @param containerType the container type\n     * \n     * @return the draggable element\n     * \n     * @throws Exception if something goes wrong\n     */\n    public CmsDragContainerElement createSubcontainerElement(\n        CmsContainerElement containerElement,\n        List<CmsContainerElement> subElements,\n        I_CmsDragTarget dragParent,\n        String containerType) throws Exception {\n\n        com.google.gwt.user.client.Element element = DOM.createDiv();\n        element.addClassName(CmsContainerpageUtil.CLASS_SUB_CONTAINER_ELEMENTS);\n\n        CmsDragSubcontainer subContainer = createSubcontainer(\n            element,\n            dragParent,\n            containerElement.getClientId(),\n            containerElement.getFile(),\n            containerElement.getNoEditReason());\n        addOptionBar(subContainer);\n\n        //adding sub-elements\n        Iterator<CmsContainerElement> it = subElements.iterator();\n        while (it.hasNext()) {\n            CmsContainerElement subElement = it.next();\n            if (subElement.getContents().containsKey(containerType)) {\n                CmsDragContainerElement subDragElement = createElement(subElement, subContainer, containerType);\n                subContainer.add(subDragElement);\n            }\n        }\n        return subContainer;\n    }","id":72561,"modified_method":"/**\n     * Creates a drag container element for sub-container elements.<p>\n     * \n     * @param containerElement the container element data \n     * @param subElements the sub-elements\n     * @param dragParent the drag parent\n     * @param containerType the container type\n     * \n     * @return the draggable element\n     * \n     * @throws Exception if something goes wrong\n     */\n    public CmsDragContainerElement createSubcontainerElement(\n        CmsContainerElement containerElement,\n        List<CmsContainerElement> subElements,\n        I_CmsDragTargetContainer dragParent,\n        String containerType) throws Exception {\n\n        com.google.gwt.user.client.Element element = DOM.createDiv();\n        element.addClassName(CmsContainerpageUtil.CLASS_SUB_CONTAINER_ELEMENTS);\n\n        CmsDragSubcontainer subContainer = createSubcontainer(\n            element,\n            dragParent,\n            containerElement.getClientId(),\n            containerElement.getFile(),\n            containerElement.getNoEditReason());\n        subContainer.setContainerType(containerType);\n        addOptionBar(subContainer);\n\n        //adding sub-elements\n        Iterator<CmsContainerElement> it = subElements.iterator();\n        while (it.hasNext()) {\n            CmsContainerElement subElement = it.next();\n            if (subElement.getContents().containsKey(containerType)) {\n                CmsDragContainerElement subDragElement = createElement(subElement, subContainer, containerType);\n                subContainer.add(subDragElement);\n            }\n        }\n        return subContainer;\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a draggable list item widget.<p>\n     * \n     * @param containerElement the element data\n     * @param dragParent the drag parent, may be null\n     * \n     * @return the list item widget\n     */\n    public CmsDragMenuElement createListItem(CmsContainerElement containerElement, I_CmsDragTarget dragParent) {\n\n        CmsDragMenuElement menuItem = new CmsDragMenuElement(containerElement);\n        menuItem.setDragParent(dragParent);\n        enableDragHandler(menuItem);\n        return menuItem;\n    }","id":72562,"modified_method":"/**\n     * Creates a draggable list item widget.<p>\n     * \n     * @param containerElement the element data\n     * @param dragParent the drag parent, may be null\n     * \n     * @return the list item widget\n     */\n    public CmsDragMenuElement createListItem(CmsContainerElement containerElement, I_CmsDragTargetContainer dragParent) {\n\n        CmsDragMenuElement menuItem = new CmsDragMenuElement(containerElement);\n        menuItem.setDragParent(dragParent);\n        enableDragHandler(menuItem);\n        return menuItem;\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates an drag container element.<p>\n     * \n     * @param containerElement the container element data \n     * @param dragParent the drag parent\n     * @param containerType the container type\n     * \n     * @return the draggable element\n     * \n     * @throws Exception if something goes wrong\n     */\n    public CmsDragContainerElement createElement(\n        CmsContainerElement containerElement,\n        I_CmsDragTarget dragParent,\n        String containerType) throws Exception {\n\n        com.google.gwt.user.client.Element element;\n        if (containerElement.isSubContainer()) {\n            throw new UnsupportedOperationException(\n                \"Not allowed for Subcontainers, use createSubcontainerElement instead.\");\n        } else {\n            element = CmsDomUtil.createElement(containerElement.getContents().get(containerType));\n        }\n        return createElement(\n            element,\n            dragParent,\n            containerElement.getClientId(),\n            containerElement.getFile(),\n            containerElement.getNoEditReason());\n    }","id":72563,"modified_method":"/**\n     * Creates an drag container element.<p>\n     * \n     * @param containerElement the container element data \n     * @param dragParent the drag parent\n     * @param containerType the container type\n     * \n     * @return the draggable element\n     * \n     * @throws Exception if something goes wrong\n     */\n    public CmsDragContainerElement createElement(\n        CmsContainerElement containerElement,\n        I_CmsDragTargetContainer dragParent,\n        String containerType) throws Exception {\n\n        com.google.gwt.user.client.Element element;\n        if (containerElement.isSubContainer()) {\n            throw new UnsupportedOperationException(\n                \"Not allowed for Subcontainers, use createSubcontainerElement instead.\");\n        } else {\n            element = CmsDomUtil.createElement(containerElement.getContents().get(containerType));\n        }\n        return createElement(\n            element,\n            dragParent,\n            containerElement.getClientId(),\n            containerElement.getFile(),\n            containerElement.getNoEditReason());\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates an drag container element.<p>\n     * \n     * @param element the DOM element\n     * @param dragParent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason\n     * \n     * @return the draggable element\n     */\n    private CmsDragContainerElement createElement(\n        com.google.gwt.user.client.Element element,\n        I_CmsDragTarget dragParent,\n        String clientId,\n        String sitePath,\n        String noEditReason) {\n\n        CmsDragContainerElement dragElement = new CmsDragContainerElement(\n            element,\n            dragParent,\n            clientId,\n            sitePath,\n            noEditReason);\n        enableDragHandler(dragElement);\n        addOptionBar(dragElement);\n        return dragElement;\n    }","id":72564,"modified_method":"/**\n     * Creates an drag container element.<p>\n     * \n     * @param element the DOM element\n     * @param dragParent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason\n     * \n     * @return the draggable element\n     */\n    private CmsDragContainerElement createElement(\n        com.google.gwt.user.client.Element element,\n        I_CmsDragTargetContainer dragParent,\n        String clientId,\n        String sitePath,\n        String noEditReason) {\n\n        CmsDragContainerElement dragElement = new CmsDragContainerElement(\n            element,\n            dragParent,\n            clientId,\n            sitePath,\n            noEditReason);\n        enableDragHandler(dragElement);\n        addOptionBar(dragElement);\n        return dragElement;\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates an drag container element. This will not add an option-bar!<p>\n     * \n     * @param element the DOM element\n     * @param dragParent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason\n     * \n     * @return the draggable element\n     */\n    private CmsDragSubcontainer createSubcontainer(\n        com.google.gwt.user.client.Element element,\n        I_CmsDragTarget dragParent,\n        String clientId,\n        String sitePath,\n        String noEditReason) {\n\n        CmsDragSubcontainer subContainer = new CmsDragSubcontainer(\n            element,\n            dragParent,\n            clientId,\n            sitePath,\n            noEditReason);\n        enableDragHandler(subContainer);\n        return subContainer;\n    }","id":72565,"modified_method":"/**\n     * Creates an drag container element. This will not add an option-bar!<p>\n     * \n     * @param element the DOM element\n     * @param dragParent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason\n     * \n     * @return the draggable element\n     */\n    private CmsDragSubcontainer createSubcontainer(\n        com.google.gwt.user.client.Element element,\n        I_CmsDragTargetContainer dragParent,\n        String clientId,\n        String sitePath,\n        String noEditReason) {\n\n        CmsDragSubcontainer subContainer = new CmsDragSubcontainer(\n            element,\n            dragParent,\n            clientId,\n            sitePath,\n            noEditReason);\n        enableDragHandler(subContainer);\n        return subContainer;\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Transforms all contained elements into {@link CmsDragContainerElement}.<p>\n     * \n     * @param container the container\n     */\n    public void consumeContainerElements(I_CmsDragTargetContainer container) {\n\n        List<CmsDragContainerElement> elements = new ArrayList<CmsDragContainerElement>();\n        // the drag element widgets are created from the existing DOM elements,\n        // to establish the internal widget hierarchy the elements need to be removed from the DOM and added as widgets to the root panel\n        Element child = (Element)container.getElement().getFirstChildElement();\n        while (child != null) {\n            if (CmsDomUtil.hasClass(CLASS_CONTAINER_ELEMENTS, child)) {\n                String clientId = child.getAttribute(\"title\");\n                String sitePath = child.getAttribute(\"alt\");\n                String noEditReason = child.getAttribute(\"rel\");\n                Element elementRoot = (Element)child.getFirstChildElement();\n                DOM.removeChild(child, elementRoot);\n                elements.add(createElement(elementRoot, container, clientId, sitePath, noEditReason));\n                DOM.removeChild(container.getElement(), child);\n            } else if (CmsDomUtil.hasClass(CLASS_SUB_CONTAINER_ELEMENTS, child)) {\n                String clientId = child.getAttribute(\"title\");\n                String sitePath = child.getAttribute(\"alt\");\n                String noEditReason = child.getAttribute(\"rel\");\n                CmsDragSubcontainer subContainer = createSubcontainer(\n                    child,\n                    container,\n                    clientId,\n                    sitePath,\n                    noEditReason);\n                elements.add(subContainer);\n                DOM.removeChild(container.getElement(), child);\n                consumeContainerElements(subContainer);\n\n                // important: adding the option-bar only after the sub-elements have been consumed \n                addOptionBar(subContainer);\n\n            } else {\n                DOM.removeChild(container.getElement(), child);\n            }\n\n            child = (Element)container.getElement().getFirstChildElement();\n        }\n\n        // re-append the element widgets by adding them to the root panel\n        Iterator<CmsDragContainerElement> it = elements.iterator();\n        while (it.hasNext()) {\n            container.add(it.next());\n        }\n    }","id":72566,"modified_method":"/**\n     * Transforms all contained elements into {@link CmsDragContainerElement}.<p>\n     * \n     * @param container the container\n     */\n    public void consumeContainerElements(I_CmsDragTargetContainer container) {\n\n        List<CmsDragContainerElement> elements = new ArrayList<CmsDragContainerElement>();\n        // the drag element widgets are created from the existing DOM elements,\n        // to establish the internal widget hierarchy the elements need to be removed from the DOM and added as widgets to the root panel\n        Element child = (Element)container.getElement().getFirstChildElement();\n        while (child != null) {\n            if (CmsDomUtil.hasClass(CLASS_CONTAINER_ELEMENTS, child)) {\n                String clientId = child.getAttribute(\"title\");\n                String sitePath = child.getAttribute(\"alt\");\n                String noEditReason = child.getAttribute(\"rel\");\n                Element elementRoot = (Element)child.getFirstChildElement();\n                DOM.removeChild(child, elementRoot);\n                elements.add(createElement(elementRoot, container, clientId, sitePath, noEditReason));\n                DOM.removeChild(container.getElement(), child);\n            } else if (CmsDomUtil.hasClass(CLASS_SUB_CONTAINER_ELEMENTS, child)) {\n                String clientId = child.getAttribute(\"title\");\n                String sitePath = child.getAttribute(\"alt\");\n                String noEditReason = child.getAttribute(\"rel\");\n                CmsDragSubcontainer subContainer = createSubcontainer(\n                    child,\n                    container,\n                    clientId,\n                    sitePath,\n                    noEditReason);\n                subContainer.setContainerType(container.getContainerType());\n                elements.add(subContainer);\n                DOM.removeChild(container.getElement(), child);\n                consumeContainerElements(subContainer);\n\n                // important: adding the option-bar only after the sub-elements have been consumed \n                addOptionBar(subContainer);\n\n            } else {\n                DOM.removeChild(container.getElement(), child);\n            }\n\n            child = (Element)container.getElement().getFirstChildElement();\n        }\n\n        // re-append the element widgets by adding them to the root panel\n        Iterator<CmsDragContainerElement> it = elements.iterator();\n        while (it.hasNext()) {\n            container.add(it.next());\n        }\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Enables container-page drag and drop for the given element.<p>\n     * \n     * @param element the element\n     */\n    public void enableDragHandler(I_CmsDragElement element) {\n\n        m_dragHandler.registerMouseHandler(element);\n    }","id":72567,"modified_method":"/**\n     * Enables container-page drag and drop for the given element.<p>\n     * \n     * @param element the element\n     */\n    public void enableDragHandler(I_CmsDragContainerElement<I_CmsDragTargetContainer> element) {\n\n        m_dragHandler.registerMouseHandler(element);\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.containerpage.client.draganddrop.I_CmsDragTargetContainer#removeHighlighting()\n     */\n    public void removeHighlighting() {\n\n        m_highlighting.removeFromParent();\n        m_highlighting = null;\n        getElement().removeClassName(I_CmsLayoutBundle.INSTANCE.dragdropCss().dragging());\n        getElement().removeClassName(I_CmsLayoutBundle.INSTANCE.dragdropCss().clearFix());\n    }","id":72568,"modified_method":"/**\n     * @see org.opencms.ade.containerpage.client.draganddrop.I_CmsDragTargetContainer#removeHighlighting()\n     */\n    public void removeHighlighting() {\n\n        m_placeholder.getElement().getStyle().clearHeight();\n        m_highlighting.removeFromParent();\n        m_highlighting = null;\n        getElement().removeClassName(I_CmsLayoutBundle.INSTANCE.dragdropCss().dragging());\n        getElement().removeClassName(I_CmsLayoutBundle.INSTANCE.dragdropCss().clearFix());\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.containerpage.client.draganddrop.I_CmsDragTargetContainer#refreshHighlighting()\n     */\n    public void refreshHighlighting() {\n\n        m_highlighting.setPosition(CmsPositionBean.getInnerDimensions(this));\n    }","id":72569,"modified_method":"/**\n     * @see org.opencms.ade.containerpage.client.draganddrop.I_CmsDragTargetContainer#refreshHighlighting()\n     */\n    public void refreshHighlighting() {\n\n        CmsPositionBean position = CmsPositionBean.getInnerDimensions(this);\n        m_placeholder.setHeight(position.getHeight() + 10 + Unit.PX.getType());\n        m_highlighting.setPosition(position);\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructor.<p>\n     * \n     * @param element the DOM element\n     * @param parent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason, if empty, editing is allowed\n     */\n    public CmsDragSubcontainer(\n        Element element,\n        I_CmsDragTarget parent,\n        String clientId,\n        String sitePath,\n        String noEditReason) {\n\n        super(element, parent, clientId, sitePath, noEditReason);\n    }","id":72570,"modified_method":"/**\n     * Constructor.<p>\n     * \n     * @param element the DOM element\n     * @param parent the drag parent\n     * @param clientId the client id\n     * @param sitePath the element site-path\n     * @param noEditReason the no edit reason, if empty, editing is allowed\n     */\n    public CmsDragSubcontainer(\n        Element element,\n        I_CmsDragTargetContainer parent,\n        String clientId,\n        String sitePath,\n        String noEditReason) {\n\n        super(element, parent, clientId, sitePath, noEditReason);\n    }","commit_id":"a8e3ac099f92e1c6049e4428f706317a50413ece","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private boolean handleKeyDown(NativeEvent e)\n   {\n      int modifiers = KeyboardShortcut.getModifierValue(e);\n\n      KeyboardShortcut shortcut = new KeyboardShortcut(modifiers,\n                                                       e.getKeyCode());\n      AppCommand command = commands_.get(shortcut);\n      if (command != null)\n      {\n         e.preventDefault();\n\n         if (enabled_ && command.isEnabled())\n            command.execute();\n      }\n\n      return command != null;\n   }","id":72571,"modified_method":"private boolean handleKeyDown(NativeEvent e)\n   {\n      int modifiers = KeyboardShortcut.getModifierValue(e);\n\n      KeyboardShortcut shortcut = new KeyboardShortcut(modifiers,\n                                                       e.getKeyCode());\n      AppCommand command = commands_.get(shortcut);\n      if (command != null)\n      {\n         boolean enabled = enabled_ && command.isEnabled();\n         \n         // some commands want their keyboard shortcut to pass through \n         // to the browser when they are disabled (e.g. Cmd+W)\n         if (!enabled && !command.preventShortcutWhenDisabled())\n            return false;\n         \n         e.preventDefault();\n\n         if (enabled)\n            command.execute();\n      }\n\n      return command != null;\n   }","commit_id":"221815cb85a5c5a6032386e9db08744dab51f32b","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public Source(Commands commands,\n                 Display view,\n                 SourceServerOperations server,\n                 EditingTargetSource editingTargetSource,\n                 FileTypeRegistry fileTypeRegistry,\n                 GlobalDisplay globalDisplay,\n                 FileDialogs fileDialogs,\n                 RemoteFileSystemContext fileContext,\n                 EventBus events,\n                 Session session,\n                 WorkbenchContext workbenchContext,\n                 MRUList mruList,\n                 UIPrefs uiPrefs)\n   {\n      commands_ = commands;\n      view_ = view;\n      server_ = server;\n      editingTargetSource_ = editingTargetSource;\n      fileTypeRegistry_ = fileTypeRegistry;\n      globalDisplay_ = globalDisplay;\n      fileDialogs_ = fileDialogs;\n      fileContext_ = fileContext;\n      events_ = events;\n      workbenchContext_ = workbenchContext;\n      mruList_ = mruList;\n      uiPrefs_ = uiPrefs;\n\n      view_.addTabClosingHandler(this);\n      view_.addTabClosedHandler(this);\n      view_.addSelectionHandler(this);\n      view_.addBeforeShowHandler(this);\n\n      dynamicCommands_ = new HashSet<AppCommand>();\n      dynamicCommands_.add(commands.saveSourceDoc());\n      dynamicCommands_.add(commands.reopenSourceDocWithEncoding());\n      dynamicCommands_.add(commands.saveSourceDocAs());\n      dynamicCommands_.add(commands.saveSourceDocWithEncoding());\n      dynamicCommands_.add(commands.printSourceDoc());\n      dynamicCommands_.add(commands.executeCode());\n      dynamicCommands_.add(commands.executeAllCode());\n      dynamicCommands_.add(commands.sourceActiveDocument());\n      dynamicCommands_.add(commands.compilePDF());\n      dynamicCommands_.add(commands.publishPDF());\n      dynamicCommands_.add(commands.popoutDoc());\n      dynamicCommands_.add(commands.findReplace());\n      dynamicCommands_.add(commands.extractFunction());\n      dynamicCommands_.add(commands.commentUncomment());\n      dynamicCommands_.add(commands.jumpToFunction());\n      dynamicCommands_.add(commands.setWorkingDirToActiveDoc());\n      for (AppCommand command : dynamicCommands_)\n      {\n         command.setVisible(false);\n         command.setEnabled(false);\n      }\n      \n      events.addHandler(ShowContentEvent.TYPE, this);\n      events.addHandler(ShowDataEvent.TYPE, this);\n\n      events.addHandler(ViewDataEvent.TYPE, new ViewDataHandler()\n      {\n         public void onViewData(ViewDataEvent event)\n         {\n            server_.newDocument(\n                  FileTypeRegistry.DATAFRAME.getTypeId(),\n                  JsObject.createJsObject(),\n                  new SimpleRequestCallback<SourceDocument>(\"Edit Data Frame\") {\n                     public void onResponseReceived(SourceDocument response)\n                     {\n                        addTab(response);\n                     }\n                  });\n         }\n      });\n\n      events.addHandler(FileTypeChangedEvent.TYPE, new FileTypeChangedHandler()\n      {\n         public void onFileTypeChanged(FileTypeChangedEvent event)\n         {\n            manageCommands();\n         }\n      });\n\n      events.addHandler(SwitchToDocEvent.TYPE, new SwitchToDocHandler()\n      {\n         public void onSwitchToDoc(SwitchToDocEvent event)\n         {\n            ensureVisible(false);\n            view_.selectTab(event.getSelectedIndex());\n         }\n      });\n\n      events.addHandler(SourceFileSavedEvent.TYPE, new SourceFileSavedHandler()\n      {\n         public void onSourceFileSaved(SourceFileSavedEvent event)\n         {\n            mruList_.add(event.getPath());\n         }\n      });\n\n      restoreDocuments(session);\n\n      new IntStateValue(MODULE_SOURCE, KEY_ACTIVETAB, true,\n                        session.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(Integer value)\n         {\n            if (value == null)\n               return;\n            if (value >= 0 && view_.getTabCount() > value)\n               view_.selectTab(value);\n\n            if (view_.getTabCount() > 0 && view_.getActiveTabIndex() >= 0)\n            {\n               editors_.get(view_.getActiveTabIndex()).onInitiallyLoaded();\n            }\n         }\n\n         @Override\n         protected Integer getValue()\n         {\n            return view_.getActiveTabIndex();\n         }\n      };\n      \n      initialized_ = true;\n      // As tabs were added before, manageCommands() was suppressed due to\n      // initialized_ being false, so we need to run it explicitly\n      manageCommands();\n      // Same with this event\n      fireDocTabsChanged();\n   }","id":72572,"modified_method":"@Inject\n   public Source(Commands commands,\n                 Display view,\n                 SourceServerOperations server,\n                 EditingTargetSource editingTargetSource,\n                 FileTypeRegistry fileTypeRegistry,\n                 GlobalDisplay globalDisplay,\n                 FileDialogs fileDialogs,\n                 RemoteFileSystemContext fileContext,\n                 EventBus events,\n                 Session session,\n                 WorkbenchContext workbenchContext,\n                 MRUList mruList,\n                 UIPrefs uiPrefs)\n   {\n      commands_ = commands;\n      view_ = view;\n      server_ = server;\n      editingTargetSource_ = editingTargetSource;\n      fileTypeRegistry_ = fileTypeRegistry;\n      globalDisplay_ = globalDisplay;\n      fileDialogs_ = fileDialogs;\n      fileContext_ = fileContext;\n      events_ = events;\n      workbenchContext_ = workbenchContext;\n      mruList_ = mruList;\n      uiPrefs_ = uiPrefs;\n\n      view_.addTabClosingHandler(this);\n      view_.addTabClosedHandler(this);\n      view_.addSelectionHandler(this);\n      view_.addBeforeShowHandler(this);\n\n      dynamicCommands_ = new HashSet<AppCommand>();\n      dynamicCommands_.add(commands.saveSourceDoc());\n      dynamicCommands_.add(commands.reopenSourceDocWithEncoding());\n      dynamicCommands_.add(commands.saveSourceDocAs());\n      dynamicCommands_.add(commands.saveSourceDocWithEncoding());\n      dynamicCommands_.add(commands.printSourceDoc());\n      dynamicCommands_.add(commands.executeCode());\n      dynamicCommands_.add(commands.executeAllCode());\n      dynamicCommands_.add(commands.sourceActiveDocument());\n      dynamicCommands_.add(commands.compilePDF());\n      dynamicCommands_.add(commands.publishPDF());\n      dynamicCommands_.add(commands.popoutDoc());\n      dynamicCommands_.add(commands.findReplace());\n      dynamicCommands_.add(commands.extractFunction());\n      dynamicCommands_.add(commands.commentUncomment());\n      dynamicCommands_.add(commands.jumpToFunction());\n      dynamicCommands_.add(commands.setWorkingDirToActiveDoc());\n      for (AppCommand command : dynamicCommands_)\n      {\n         command.setVisible(false);\n         command.setEnabled(false);\n      }\n      \n      // allow Ctrl+W to propagate to the browser if close doc is disabled\n      if (!Desktop.isDesktop())\n      {\n         AppCommand closeSourceDoc = commands_.closeSourceDoc();\n         closeSourceDoc.setPreventShortcutWhenDisabled(false);\n      }   \n      \n      events.addHandler(ShowContentEvent.TYPE, this);\n      events.addHandler(ShowDataEvent.TYPE, this);\n\n      events.addHandler(ViewDataEvent.TYPE, new ViewDataHandler()\n      {\n         public void onViewData(ViewDataEvent event)\n         {\n            server_.newDocument(\n                  FileTypeRegistry.DATAFRAME.getTypeId(),\n                  JsObject.createJsObject(),\n                  new SimpleRequestCallback<SourceDocument>(\"Edit Data Frame\") {\n                     public void onResponseReceived(SourceDocument response)\n                     {\n                        addTab(response);\n                     }\n                  });\n         }\n      });\n\n      events.addHandler(FileTypeChangedEvent.TYPE, new FileTypeChangedHandler()\n      {\n         public void onFileTypeChanged(FileTypeChangedEvent event)\n         {\n            manageCommands();\n         }\n      });\n\n      events.addHandler(SwitchToDocEvent.TYPE, new SwitchToDocHandler()\n      {\n         public void onSwitchToDoc(SwitchToDocEvent event)\n         {\n            ensureVisible(false);\n            view_.selectTab(event.getSelectedIndex());\n         }\n      });\n\n      events.addHandler(SourceFileSavedEvent.TYPE, new SourceFileSavedHandler()\n      {\n         public void onSourceFileSaved(SourceFileSavedEvent event)\n         {\n            mruList_.add(event.getPath());\n         }\n      });\n\n      restoreDocuments(session);\n\n      new IntStateValue(MODULE_SOURCE, KEY_ACTIVETAB, true,\n                        session.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(Integer value)\n         {\n            if (value == null)\n               return;\n            if (value >= 0 && view_.getTabCount() > value)\n               view_.selectTab(value);\n\n            if (view_.getTabCount() > 0 && view_.getActiveTabIndex() >= 0)\n            {\n               editors_.get(view_.getActiveTabIndex()).onInitiallyLoaded();\n            }\n         }\n\n         @Override\n         protected Integer getValue()\n         {\n            return view_.getActiveTabIndex();\n         }\n      };\n      \n      initialized_ = true;\n      // As tabs were added before, manageCommands() was suppressed due to\n      // initialized_ being false, so we need to run it explicitly\n      manageCommands();\n      // Same with this event\n      fireDocTabsChanged();\n   }","commit_id":"221815cb85a5c5a6032386e9db08744dab51f32b","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public void initialize(\n                  final Commands commands,\n                  EventBus eventBus,\n                  GlobalDisplay globalDisplay,\n                  ThemeResources themeResources,\n                  final Session session)\n   {\n      eventBus_ = eventBus;\n      globalDisplay_ = globalDisplay;\n      preferredHeight_ = 40;\n\n      // Use the outer panel to just aggregate the menu bar/account area,\n      // with the logo. The logo can't be inside the HorizontalPanel because\n      // it needs to overflow out of the top of the panel, and it was much\n      // easier to do this with absolute positioning.\n      FlowPanel outerPanel = new FlowPanel();\n      outerPanel.getElement().getStyle().setPosition(Position.RELATIVE);\n\n      // header container\n      HorizontalPanel headerBarPanel = new HorizontalPanel() ;\n      headerBarPanel.setStylePrimaryName(themeResources.themeStyles().header());\n      headerBarPanel.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\n      headerBarPanel.setWidth(\"100%\");\n\n      if (BrowseCap.INSTANCE.suppressBrowserForwardBack())\n         suppressBrowserForwardBack();\n\n      // main menu\n      advertiseEditingShortcuts(globalDisplay, commands);\n      WebMenuCallback menuCallback = new WebMenuCallback();\n      commands.mainMenu(menuCallback);\n      mainMenu_ = menuCallback.getMenu();\n      mainMenu_.setAutoHideRedundantSeparators(false);\n      fixup(mainMenu_);\n      mainMenu_.addStyleName(themeResources.themeStyles().mainMenu());\n      AppMenuBar.addSubMenuVisibleChangedHandler(new SubMenuVisibleChangedHandler()\n      {\n         public void onSubMenuVisibleChanged(SubMenuVisibleChangedEvent event)\n         {\n            // When submenus of the main menu appear, glass over any iframes\n            // so that mouse clicks can make the menus disappear\n            if (event.isVisible())\n               eventBus_.fireEvent(new GlassVisibilityEvent(true));\n            else\n               eventBus_.fireEvent(new GlassVisibilityEvent(false));\n         }\n      });\n      headerBarPanel.add(mainMenu_);\n\n      HTML spacer = new HTML();\n      headerBarPanel.add(spacer);\n      headerBarPanel.setCellWidth(spacer, \"100%\");\n\n      // commands panel (no widgets added until after session init)\n      headerBarCommandsPanel_ = new HorizontalPanel();\n      headerBarPanel.add(headerBarCommandsPanel_);\n      headerBarPanel.setCellHorizontalAlignment(headerBarCommandsPanel_,\n                                                HorizontalPanel.ALIGN_RIGHT);\n\n      eventBus.addHandler(SessionInitEvent.TYPE, new SessionInitHandler()\n      {\n         public void onSessionInit(SessionInitEvent sie)\n         {\n            SessionInfo sessionInfo = session.getSessionInfo();\n            \n            // only show the user identity if we are in server mode\n           if (sessionInfo.getMode().equals(SessionInfo.SERVER_MODE))\n               initCommandsPanel(sessionInfo);\n\n            if (!sessionInfo.isGoogleDocsIntegrationEnabled())\n            {\n               commands.publishPDF().remove();\n               commands.importDatasetFromGoogleSpreadsheet().remove();\n            }\n         }\n      });\n\n      outerPanel.add(new HeaderPanel(headerBarPanel));\n\n      // logo\n      Image logo = new Image(ThemeResources.INSTANCE.rstudio());\n      ((ImageElement)logo.getElement().cast()).setAlt(\"RStudio\");\n      Style style = logo.getElement().getStyle();\n      style.setPosition(Position.ABSOLUTE);\n      style.setTop(5, Unit.PX);\n      style.setLeft(18, Unit.PX);\n      outerPanel.add(logo);\n\n      // initialize widget\n      initWidget(outerPanel);\n   }","id":72573,"modified_method":"@Inject\n   public void initialize(\n                  final Commands commands,\n                  EventBus eventBus,\n                  GlobalDisplay globalDisplay,\n                  ThemeResources themeResources,\n                  final Session session)\n   {\n      eventBus_ = eventBus;\n      globalDisplay_ = globalDisplay;\n      preferredHeight_ = 40;\n\n      // Use the outer panel to just aggregate the menu bar/account area,\n      // with the logo. The logo can't be inside the HorizontalPanel because\n      // it needs to overflow out of the top of the panel, and it was much\n      // easier to do this with absolute positioning.\n      FlowPanel outerPanel = new FlowPanel();\n      outerPanel.getElement().getStyle().setPosition(Position.RELATIVE);\n\n      // header container\n      HorizontalPanel headerBarPanel = new HorizontalPanel() ;\n      headerBarPanel.setStylePrimaryName(themeResources.themeStyles().header());\n      headerBarPanel.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\n      headerBarPanel.setWidth(\"100%\");\n\n      if (BrowseCap.INSTANCE.suppressBrowserForwardBack())\n         suppressBrowserForwardBack();\n\n      // override Cmd+W keybaord shortcut for Chrome\n      if (BrowseCap.isChrome())\n      {\n         int modifiers = (BrowseCap.hasMetaKey() ? KeyboardShortcut.META : \n                                                   KeyboardShortcut.CTRL) |\n                         KeyboardShortcut.SHIFT;\n             \n         AppCommand closeSourceDoc = commands.closeSourceDoc();\n         closeSourceDoc.setShortcut(new KeyboardShortcut(modifiers, 'L'));\n         ShortcutManager.INSTANCE.register(modifiers, 'L', closeSourceDoc);\n      }\n      \n      // main menu\n      advertiseEditingShortcuts(globalDisplay, commands);\n      WebMenuCallback menuCallback = new WebMenuCallback();\n      commands.mainMenu(menuCallback);\n      mainMenu_ = menuCallback.getMenu();\n      mainMenu_.setAutoHideRedundantSeparators(false);\n      fixup(mainMenu_);\n      mainMenu_.addStyleName(themeResources.themeStyles().mainMenu());\n      AppMenuBar.addSubMenuVisibleChangedHandler(new SubMenuVisibleChangedHandler()\n      {\n         public void onSubMenuVisibleChanged(SubMenuVisibleChangedEvent event)\n         {\n            // When submenus of the main menu appear, glass over any iframes\n            // so that mouse clicks can make the menus disappear\n            if (event.isVisible())\n               eventBus_.fireEvent(new GlassVisibilityEvent(true));\n            else\n               eventBus_.fireEvent(new GlassVisibilityEvent(false));\n         }\n      });\n      headerBarPanel.add(mainMenu_);\n\n      HTML spacer = new HTML();\n      headerBarPanel.add(spacer);\n      headerBarPanel.setCellWidth(spacer, \"100%\");\n\n      // commands panel (no widgets added until after session init)\n      headerBarCommandsPanel_ = new HorizontalPanel();\n      headerBarPanel.add(headerBarCommandsPanel_);\n      headerBarPanel.setCellHorizontalAlignment(headerBarCommandsPanel_,\n                                                HorizontalPanel.ALIGN_RIGHT);\n\n      eventBus.addHandler(SessionInitEvent.TYPE, new SessionInitHandler()\n      {\n         public void onSessionInit(SessionInitEvent sie)\n         {\n            SessionInfo sessionInfo = session.getSessionInfo();\n            \n            // only show the user identity if we are in server mode\n           if (sessionInfo.getMode().equals(SessionInfo.SERVER_MODE))\n               initCommandsPanel(sessionInfo);\n\n            if (!sessionInfo.isGoogleDocsIntegrationEnabled())\n            {\n               commands.publishPDF().remove();\n               commands.importDatasetFromGoogleSpreadsheet().remove();\n            }\n         }\n      });\n\n      outerPanel.add(new HeaderPanel(headerBarPanel));\n\n      // logo\n      Image logo = new Image(ThemeResources.INSTANCE.rstudio());\n      ((ImageElement)logo.getElement().cast()).setAlt(\"RStudio\");\n      Style style = logo.getElement().getStyle();\n      style.setPosition(Position.ABSOLUTE);\n      style.setTop(5, Unit.PX);\n      style.setLeft(18, Unit.PX);\n      outerPanel.add(logo);\n\n      // initialize widget\n      initWidget(outerPanel);\n   }","commit_id":"221815cb85a5c5a6032386e9db08744dab51f32b","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n  public void run( ) {\n    Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n    try {\n      long sign = ( long ) ( Math.pow( -1f, ( float ) ( ++phase % 2 ) ) );\n      ListenerRegistry.getInstance( )\n                      .fireEventAsync( ClockTick.class,\n                                       new ClockTick( ).setMessage( sign * System.currentTimeMillis( ) ) )\n                       .get( 2, TimeUnit.MINUTES );\n    } catch ( Exception t ) {\n      LOG.error( t );\n      Logs.extreme( ).error( t, t );\n    }\n  }","id":72574,"modified_method":"@Override\n  public void run( ) {\n    Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n    try {\n      long sign = ( long ) ( Math.pow( -1f, ( float ) ( ++phase % 2 ) ) );\n      ListenerRegistry.getInstance( ).fireEvent( new ClockTick( ).setMessage( sign * System.currentTimeMillis( ) ) );\n    } catch ( EventFailedException e ) {} catch ( Exception t ) {\n      LOG.error( t, t );\n    }\n  }","commit_id":"fe1402a6c1a123b8b58ce4a0f7d50b79e9b8a014","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void run( ) {\n      Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n      try {\n        ListenerRegistry.getInstance( ).fireEventAsync( Hertz.class, new Hertz( ) ).get( 2, TimeUnit.MINUTES );\n      } catch ( Exception t ) {\n        LOG.error( t );\n        Logs.extreme( ).error( t, t );\n      }\n    }","id":72575,"modified_method":"public void run( ) {\n      Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n      try {\n        ListenerRegistry.getInstance( ).fireEvent( new Hertz( ) );\n      } catch ( EventFailedException e ) {} catch ( Exception t ) {\n        LOG.error( t, t );\n      }\n    }","commit_id":"fe1402a6c1a123b8b58ce4a0f7d50b79e9b8a014","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void run( ) {\n      Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n      try {\n        ListenerRegistry.getInstance( ).fireEventAsync( Hertz.class, new Hertz( ) ).get( SystemClock.EVENT_TIMEOUT, TimeUnit.MILLISECONDS );\n      } catch ( Exception t ) {\n        LOG.error( t, t );\n      }\n    }","id":72576,"modified_method":"public void run( ) {\n      Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n      try {\n        ListenerRegistry.getInstance( ).fireEvent( Hertz.class, new Hertz( ) );\n      } catch ( Exception t ) {\n        LOG.error( t, t );\n      }\n    }","commit_id":"0763b7cd90e4ebebfcd550ce0710e0f7480fc27d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void run( ) {\n    Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n    try {\n      long sign = ( long ) ( Math.pow( -1f, ( float ) ( ++phase % 2 ) ) );\n      ListenerRegistry.getInstance( ).fireEventAsync( ClockTick.class,\n                                                      new ClockTick( ).setMessage( sign * System.currentTimeMillis( ) )\n                                                      ).get( EVENT_TIMEOUT, TimeUnit.MILLISECONDS );\n    } catch ( Exception t ) {\n      LOG.error( t, t );\n    }\n  }","id":72577,"modified_method":"@Override\n  public void run( ) {\n    Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n    try {\n      long sign = ( long ) ( Math.pow( -1f, ( float ) ( ++phase % 2 ) ) );\n      ListenerRegistry.getInstance( ).fireEvent( ClockTick.class,\n                                                      new ClockTick( ).setMessage( sign * System.currentTimeMillis( ) )\n                                                      );\n    } catch ( Exception t ) {\n      LOG.error( t, t );\n    }\n  }","commit_id":"0763b7cd90e4ebebfcd550ce0710e0f7480fc27d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n     * Implements the server thread receiving commands from clients and acting\n     * upon them.\n     */\n    public void run() {\n        this.configure(false);\n\n        ServerSocket server = null;\n        try {\n            server = new ServerSocket();\n            server.bind(this.socketAddress);\n            writePortToConfigFile(getConfigFile(),\n                new InetSocketAddress(server.getInetAddress(), server.getLocalPort()), this.secretKey);\n            Thread.currentThread().setName(\n                \"Apache Sling Control Listener@\" + server.getInetAddress() + \":\" + server.getLocalPort());\n            Main.info(\"Apache Sling Control Listener started\", null);\n        } catch (final IOException ioe) {\n            Main.error(\"Failed to start Apache Sling Control Listener\", ioe);\n            return;\n        }\n\n        long delay = 0;\n\n        try {\n            while (true) {\n\n                final Socket s = server.accept();\n\n                // delay processing after unsuccessfull attempts\n                if (delay > 0) {\n                    Main.info(s.getRemoteSocketAddress() + \": Delay: \" + (delay / 1000), null);\n                    try {\n                        Thread.sleep(delay);\n                    } catch (InterruptedException e) {\n                    }\n                }\n\n                try {\n                    final String commandLine = readLine(s);\n                    if (commandLine == null) {\n                        final String msg = \"ERR: missing command\";\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n                        continue;\n                    }\n\n                    final int blank = commandLine.indexOf(' ');\n                    if (blank < 0) {\n                        final String msg = \"ERR: missing key\";\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n                        continue;\n                    }\n\n                    if (!secretKey.equals(commandLine.substring(0, blank))) {\n                        final String msg = \"ERR: wrong key\";\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n                        delay = (delay > 0) ? delay * 2 : 1000L;\n                        continue;\n                    }\n\n                    final String command = commandLine.substring(blank + 1);\n                    Main.info(s.getRemoteSocketAddress() + \">\" + command, null);\n\n                    if (COMMAND_STOP.equals(command)) {\n                        slingMain.doStop();\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + RESPONSE_OK, null);\n                        writeLine(s, RESPONSE_OK);\n                        break;\n\n                    } else if (COMMAND_STATUS.equals(command)) {\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + RESPONSE_OK, null);\n                        writeLine(s, RESPONSE_OK);\n\n                    } else {\n                        final String msg = \"ERR:\" + command;\n                        Main.info(s.getRemoteSocketAddress() + \"<\" + msg, null);\n                        writeLine(s, msg);\n\n                    }\n                } finally {\n                    try {\n                        s.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        } catch (final IOException ioe) {\n            Main.error(\"Failure reading from client\", ioe);\n        } finally {\n            try {\n                server.close();\n            } catch (final IOException ignore) {\n            }\n        }\n\n        getConfigFile().delete();\n\n        // everything has stopped and when this thread terminates,\n        // the VM should stop. If there are still some non-daemon threads\n        // active, this will not happen, so we force this here ...\n        Main.info(\"Apache Sling terminated, exiting Java VM\", null);\n        this.slingMain.terminateVM(0);\n    }","id":72578,"modified_method":"/**\n     * Implements the server thread receiving commands from clients and acting\n     * upon them.\n     */\n    public void run() {\n        this.configure(false);\n\n        final ServerSocket server;\n        try {\n            server = new ServerSocket();\n            server.bind(this.socketAddress);\n            writePortToConfigFile(getConfigFile(),\n                new InetSocketAddress(server.getInetAddress(), server.getLocalPort()), this.secretKey);\n            Thread.currentThread().setName(\n                \"Apache Sling Control Listener@\" + server.getInetAddress() + \":\" + server.getLocalPort());\n            Main.info(\"Apache Sling Control Listener started\", null);\n        } catch (final IOException ioe) {\n            Main.error(\"Failed to start Apache Sling Control Listener\", ioe);\n            return;\n        }\n\n        long delay = 0;\n\n        try {\n            while (true) {\n\n                final Socket s;\n                try {\n                    s = server.accept();\n                } catch (IOException ioe) {\n                    // accept terminated, most probably due to Socket.close()\n                    // just end the loop and exit\n                    break;\n                }\n\n                // delay processing after unsuccessfull attempts\n                if (delay > 0) {\n                    Main.info(s.getRemoteSocketAddress() + \": Delay: \" + (delay / 1000), null);\n                    try {\n                        Thread.sleep(delay);\n                    } catch (InterruptedException e) {\n                    }\n                }\n\n                try {\n                    final String commandLine = readLine(s);\n                    if (commandLine == null) {\n                        final String msg = \"ERR: missing command\";\n                        writeLine(s, msg);\n                        continue;\n                    }\n\n                    final int blank = commandLine.indexOf(' ');\n                    if (blank < 0) {\n                        final String msg = \"ERR: missing key\";\n                        writeLine(s, msg);\n                        continue;\n                    }\n\n                    if (!secretKey.equals(commandLine.substring(0, blank))) {\n                        final String msg = \"ERR: wrong key\";\n                        writeLine(s, msg);\n                        delay = (delay > 0) ? delay * 2 : 1000L;\n                        continue;\n                    }\n\n                    final String command = commandLine.substring(blank + 1);\n                    Main.info(s.getRemoteSocketAddress() + \">\" + command, null);\n\n                    if (COMMAND_STOP.equals(command)) {\n                        if (this.shutdownThread != null) {\n                            writeLine(s, RESPONSE_STOPPING);\n                        } else {\n                            this.shutdownThread = new Thread(\"Apache Sling Control Listener: Shutdown\") {\n                                public void run() {\n                                    slingMain.doStop();\n                                    try {\n                                        server.close();\n                                    } catch (final IOException ignore) {\n                                    }\n                                }\n                            };\n                            this.shutdownThread.start();\n                            writeLine(s, RESPONSE_OK);\n                        }\n\n                    } else if (COMMAND_STATUS.equals(command)) {\n                        writeLine(s, (this.shutdownThread == null) ? RESPONSE_OK : RESPONSE_STOPPING);\n\n                    } else if (COMMAND_THREADS.equals(command)) {\n                        dumpThreads(s);\n\n                    } else {\n                        final String msg = \"ERR:\" + command;\n                        writeLine(s, msg);\n\n                    }\n                } finally {\n                    try {\n                        s.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        } catch (final IOException ioe) {\n            Main.error(\"Failure reading from client\", ioe);\n        } finally {\n            try {\n                server.close();\n            } catch (final IOException ignore) {\n            }\n        }\n\n        getConfigFile().delete();\n\n        // everything has stopped and when this thread terminates,\n        // the VM should stop. If there are still some non-daemon threads\n        // active, this will not happen, so we force this here ...\n        Main.info(\"Apache Sling terminated, exiting Java VM\", null);\n        this.slingMain.terminateVM(0);\n    }","commit_id":"e063dd9e4ddb3465d751fa5ba157cb6b794450b4","url":"https://github.com/apache/sling"},{"original_method":"private String readLine(final Socket socket) throws IOException {\n        final BufferedReader br = new BufferedReader(new InputStreamReader(\n            socket.getInputStream(), \"UTF-8\"));\n        return br.readLine();\n    }","id":72579,"modified_method":"private String readLine(final Socket socket) throws IOException {\n        final BufferedReader br = new BufferedReader(new InputStreamReader(\n            socket.getInputStream(), \"UTF-8\"));\n\n        StringBuilder b = new StringBuilder();\n        boolean more = true;\n        while (more) {\n            String s = br.readLine();\n            if (s != null && s.startsWith(\"-\")) {\n                s = s.substring(1);\n            } else {\n                more = false;\n            }\n            if (b.length() > 0) {\n                b.append(\"\\r\\n\");\n            }\n            b.append(s);\n        }\n\n        return b.toString();\n    }","commit_id":"e063dd9e4ddb3465d751fa5ba157cb6b794450b4","url":"https://github.com/apache/sling"},{"original_method":"private void writeLine(final Socket socket, final String line) throws IOException {\n        final BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(\n            socket.getOutputStream(), \"UTF-8\"));\n        bw.write(line);\n        bw.write(\"\\r\\n\");\n        bw.flush();\n    }","id":72580,"modified_method":"private void writeLine(final Socket socket, final String line) throws IOException {\n        Main.info(socket.getRemoteSocketAddress() + \"<\" + line, null);\n        this.writeLine0(socket, line);\n    }","commit_id":"e063dd9e4ddb3465d751fa5ba157cb6b794450b4","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Sends the given command to the server indicated by the configured\n     * socket address and logs the reply.\n     *\n     * @param command The command to send\n     *\n     * @return A code indicating success of sending the command.\n     */\n    private int sendCommand(final String command) {\n        if (configure(true)) {\n            if (this.secretKey == null) {\n                Main.info(\"Missing secret key to protect sending '\" + command + \"' to \" + this.socketAddress, null);\n                return 4; // LSB code for unknown status\n            }\n\n            Socket socket = null;\n            try {\n                socket = new Socket();\n                socket.connect(this.socketAddress);\n                writeLine(socket, this.secretKey + \" \" + command);\n                final String result = readLine(socket);\n                Main.info(\"Sent '\" + command + \"' to \" + this.socketAddress + \": \" + result, null);\n                return 0; // LSB code for everything's fine\n            } catch (final ConnectException ce) {\n                Main.info(\"No Apache Sling running at \" + this.socketAddress, null);\n                return 3; // LSB code for programm not running\n            } catch (final IOException ioe) {\n                Main.error(\"Failed sending '\" + command + \"' to \" + this.socketAddress, ioe);\n                return 1; // LSB code for programm dead\n            } finally {\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        }\n        Main.info(\"No socket address to send '\" + command + \"' to\", null);\n        return 4; // LSB code for unknown status\n    }","id":72581,"modified_method":"/**\n     * Sends the given command to the server indicated by the configured\n     * socket address and logs the reply.\n     *\n     * @param command The command to send\n     *\n     * @return A code indicating success of sending the command.\n     */\n    private int sendCommand(final String command) {\n        if (configure(true)) {\n            if (this.secretKey == null) {\n                Main.info(\"Missing secret key to protect sending '\" + command + \"' to \" + this.socketAddress, null);\n                return 4; // LSB code for unknown status\n            }\n\n            Socket socket = null;\n            try {\n                socket = new Socket();\n                socket.connect(this.socketAddress);\n                writeLine0(socket, this.secretKey + \" \" + command);\n                final String result = readLine(socket);\n                Main.info(\"Sent '\" + command + \"' to \" + this.socketAddress + \": \" + result, null);\n                return 0; // LSB code for everything's fine\n            } catch (final ConnectException ce) {\n                Main.info(\"No Apache Sling running at \" + this.socketAddress, null);\n                return 3; // LSB code for programm not running\n            } catch (final IOException ioe) {\n                Main.error(\"Failed sending '\" + command + \"' to \" + this.socketAddress, ioe);\n                return 1; // LSB code for programm dead\n            } finally {\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        }\n        Main.info(\"No socket address to send '\" + command + \"' to\", null);\n        return 4; // LSB code for unknown status\n    }","commit_id":"e063dd9e4ddb3465d751fa5ba157cb6b794450b4","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * After instantiating this class, this method may be called to help with\n     * the communication with a running Sling instance. To setup this\n     * communication the configuration properties supplied to the constructor\n     * are evaluated as follows:\n     * <p>\n     * <table>\n     * <tr>\n     * <td><code>{@value #PROP_CONTROL_SOCKET}<\/code><\/td>\n     * <td>Specifies the socket to use for the control connection. This\n     * specification is of the form <i>host:port<\/i> where the host can be a\n     * host name or IP Address and may be omitted (along with the separating\n     * colon) and port is just the numberic port number at which to listen. The\n     * default is <i>localhost:63000<\/i>. It is suggested to not use an\n     * externally accessible interface for security reasons because there is no\n     * added security on this control channel for now.<\/td>\n     * <\/tr>\n     * <tr>\n     * <td><code>{@value #PROP_CONTROL_ACTION}<\/code><\/td>\n     * <td>The actual action to execute:\n     * <ul>\n     * <b>start<\/b> -- Start the listener on the configured socket and expect\n     * commands there. This action is useful only when launching the Sling\n     * application since this action helps manage a running system.\n     * <\/ul>\n     * <ul>\n     * <b>stop<\/b> -- Connects to the listener running on the configured socket\n     * and send the command to terminate the Sling Application. If this command\n     * is used, it is expected the Sling Application will not start.\n     * <\/ul>\n     * <ul>\n     * <b>status<\/b> -- Connects to the listener running on the configured\n     * socket and query about its status. If this command is used, it is\n     * expected the Sling Application will not start.\n     * <\/ul>\n     * <\/td>\n     * <\/tr>\n     * <\/table>\n     * <p>\n     * After this method has executed the <code>j<\/code> and\n     * {@link #PROP_CONTROL_ACTION} properties have been removed from the\n     * configuration properties.\n     * <p>\n     * While the {@link #doStart()} and {@link #doStop()} methods may be called\n     * multiple times this method should only be called once after creating this\n     * class's instance.\n     *\n     * @return An code indicating whether the Java VM is expected to be\n     *         terminated or not. If <code>-1<\/code> is returned, the VM should\n     *         continue as intended, maybe starting the Sling Application. This\n     *         code is returned if the start action (or no action at all) is\n     *         supplied. Otherwise the VM should terminate with the returned\n     *         code as its exit code. For the stop action, this will be zero.\n     *         For the status action, this will be a LSB compliant code for\n     *         daemon status check: 0 (application running), 1 (Programm Dead),\n     *         3 (Programm Not Running), 4 (Unknown Problem).\n     * @see <a\n     *      href=\"http://refspecs.linuxbase.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html\">Init Script Actions<\/a>\n     *      for a definition of the LSB status codes\n     */\n    protected int doControlAction() {\n        final ControlAction action = getControlAction();\n        if (action != null) {\n            final ControlListener sl = new ControlListener(this,\n                commandLineArgs.remove(PROP_CONTROL_SOCKET));\n            switch (action) {\n                case START:\n                    if (!sl.listen()) {\n                        // assume service already running\n                        return 0;\n                    }\n                    break;\n                case STATUS:\n                    return sl.statusServer();\n                case STOP:\n                    return sl.shutdownServer();\n            }\n        }\n\n        return -1;\n    }","id":72582,"modified_method":"/**\n     * After instantiating this class, this method may be called to help with\n     * the communication with a running Sling instance. To setup this\n     * communication the configuration properties supplied to the constructor\n     * are evaluated as follows:\n     * <p>\n     * <table>\n     * <tr>\n     * <td><code>{@value #PROP_CONTROL_SOCKET}<\/code><\/td>\n     * <td>Specifies the socket to use for the control connection. This\n     * specification is of the form <i>host:port<\/i> where the host can be a\n     * host name or IP Address and may be omitted (along with the separating\n     * colon) and port is just the numberic port number at which to listen. The\n     * default is <i>localhost:63000<\/i>. It is suggested to not use an\n     * externally accessible interface for security reasons because there is no\n     * added security on this control channel for now.<\/td>\n     * <\/tr>\n     * <tr>\n     * <td><code>{@value #PROP_CONTROL_ACTION}<\/code><\/td>\n     * <td>The actual action to execute:\n     * <ul>\n     * <b>start<\/b> -- Start the listener on the configured socket and expect\n     * commands there. This action is useful only when launching the Sling\n     * application since this action helps manage a running system.\n     * <\/ul>\n     * <ul>\n     * <b>stop<\/b> -- Connects to the listener running on the configured socket\n     * and send the command to terminate the Sling Application. If this command\n     * is used, it is expected the Sling Application will not start.\n     * <\/ul>\n     * <ul>\n     * <b>status<\/b> -- Connects to the listener running on the configured\n     * socket and query about its status. If this command is used, it is\n     * expected the Sling Application will not start.\n     * <\/ul>\n     * <\/td>\n     * <\/tr>\n     * <\/table>\n     * <p>\n     * After this method has executed the <code>j<\/code> and\n     * {@link #PROP_CONTROL_ACTION} properties have been removed from the\n     * configuration properties.\n     * <p>\n     * While the {@link #doStart()} and {@link #doStop()} methods may be called\n     * multiple times this method should only be called once after creating this\n     * class's instance.\n     *\n     * @return An code indicating whether the Java VM is expected to be\n     *         terminated or not. If <code>-1<\/code> is returned, the VM should\n     *         continue as intended, maybe starting the Sling Application. This\n     *         code is returned if the start action (or no action at all) is\n     *         supplied. Otherwise the VM should terminate with the returned\n     *         code as its exit code. For the stop action, this will be zero.\n     *         For the status action, this will be a LSB compliant code for\n     *         daemon status check: 0 (application running), 1 (Programm Dead),\n     *         3 (Programm Not Running), 4 (Unknown Problem).\n     * @see <a\n     *      href=\"http://refspecs.linuxbase.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html\">Init Script Actions<\/a>\n     *      for a definition of the LSB status codes\n     */\n    protected int doControlAction() {\n        final ControlAction action = getControlAction();\n        if (action != null) {\n            final ControlListener sl = new ControlListener(this,\n                commandLineArgs.remove(PROP_CONTROL_SOCKET));\n            switch (action) {\n                case START:\n                    if (!sl.listen()) {\n                        // assume service already running\n                        return 0;\n                    }\n                    break;\n                case STATUS:\n                    return sl.statusServer();\n                case STOP:\n                    return sl.shutdownServer();\n                case THREADS:\n                    return sl.dumpThreads();\n            }\n        }\n\n        return -1;\n    }","commit_id":"e063dd9e4ddb3465d751fa5ba157cb6b794450b4","url":"https://github.com/apache/sling"},{"original_method":"static Map<String, String> convertCommandLineArgs(\n            Map<String, String> rawArgs) {\n        final HashMap<String, String> props = new HashMap<String, String>();\n        boolean errorArg = false;\n        for (Entry<String, String> arg : rawArgs.entrySet()) {\n            if (arg.getKey().length() == 1 || arg.getKey().startsWith(\"D\")) {\n                String value = arg.getValue();\n                switch (arg.getKey().charAt(0)) {\n                    case 'j':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-j\", \"Missing host:port value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(PROP_CONTROL_SOCKET, value);\n                        break;\n\n                    case 'l':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-l\", \"Missing log level value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(PROP_LOG_LEVEL, value);\n                        break;\n\n                    case 'f':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-f\", \"Missing log file value\");\n                            errorArg = true;\n                            continue;\n                        } else if (\"-\".equals(value)) {\n                            value = \"\";\n                        }\n                        props.put(PROP_LOG_FILE, value);\n                        break;\n\n                    case 'c':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-c\", \"Missing directory value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(SharedConstants.SLING_HOME, value);\n                        break;\n\n                    case 'i':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-i\", \"Missing launchpad directory value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(SharedConstants.SLING_LAUNCHPAD, value);\n                        break;\n\n                    case 'a':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-a\", \"Missing address value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(PROP_HOST, value);\n                        break;\n\n                    case 'p':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-p\", \"Missing port value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        try {\n                            // just to verify it is a number\n                            Integer.parseInt(value);\n                            props.put(PROP_PORT, value);\n                        } catch (RuntimeException e) {\n                            errorArg(\"-p\", \"Bad port: \" + value);\n                            errorArg = true;\n                        }\n                        break;\n\n                    case 'r':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-r\", \"Missing root path value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(PROP_CONTEXT_PATH, value);\n                        break;\n\n                    case 'n':\n                        props.put(PROP_SHUTDOWN_HOOK, Boolean.FALSE.toString());\n                        break;\n\n                    case 'D':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-D\", \"Missing property assignment\");\n                            errorArg = true;\n                            continue;\n                        }\n                        if (arg.getKey().length() > 1) {\n                            //Dfoo=bar arg.key=Dfoo and arg.value=bar\n                            props.put(arg.getKey().substring(1), arg.getValue());\n                        } else {\n                            //D foo=bar arg.key=D and arg.value=foo=bar\n                            String[] parts = value.split(\"=\");\n                            int valueIdx = (parts.length > 1) ? 1 : 0;\n                            props.put(parts[0], parts[valueIdx]);\n                        }\n                        break;\n\n                    default:\n                        errorArg(\"-\" + arg.getKey(), \"Unrecognized option\");\n                        errorArg = true;\n                        break;\n                }\n            } else if (\"start\".equals(arg.getKey())\n                || \"stop\".equals(arg.getKey()) || \"status\".equals(arg.getKey())) {\n                props.put(PROP_CONTROL_ACTION, arg.getValue());\n            } else {\n                errorArg(arg.getKey(), \"Unrecognized option\");\n                errorArg = true;\n            }\n        }\n        return errorArg ? null : props;\n    }","id":72583,"modified_method":"static Map<String, String> convertCommandLineArgs(\n            Map<String, String> rawArgs) {\n        final HashMap<String, String> props = new HashMap<String, String>();\n        boolean errorArg = false;\n        for (Entry<String, String> arg : rawArgs.entrySet()) {\n            if (arg.getKey().length() == 1 || arg.getKey().startsWith(\"D\")) {\n                String value = arg.getValue();\n                switch (arg.getKey().charAt(0)) {\n                    case 'j':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-j\", \"Missing host:port value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(PROP_CONTROL_SOCKET, value);\n                        break;\n\n                    case 'l':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-l\", \"Missing log level value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(PROP_LOG_LEVEL, value);\n                        break;\n\n                    case 'f':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-f\", \"Missing log file value\");\n                            errorArg = true;\n                            continue;\n                        } else if (\"-\".equals(value)) {\n                            value = \"\";\n                        }\n                        props.put(PROP_LOG_FILE, value);\n                        break;\n\n                    case 'c':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-c\", \"Missing directory value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(SharedConstants.SLING_HOME, value);\n                        break;\n\n                    case 'i':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-i\", \"Missing launchpad directory value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(SharedConstants.SLING_LAUNCHPAD, value);\n                        break;\n\n                    case 'a':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-a\", \"Missing address value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(PROP_HOST, value);\n                        break;\n\n                    case 'p':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-p\", \"Missing port value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        try {\n                            // just to verify it is a number\n                            Integer.parseInt(value);\n                            props.put(PROP_PORT, value);\n                        } catch (RuntimeException e) {\n                            errorArg(\"-p\", \"Bad port: \" + value);\n                            errorArg = true;\n                        }\n                        break;\n\n                    case 'r':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-r\", \"Missing root path value\");\n                            errorArg = true;\n                            continue;\n                        }\n                        props.put(PROP_CONTEXT_PATH, value);\n                        break;\n\n                    case 'n':\n                        props.put(PROP_SHUTDOWN_HOOK, Boolean.FALSE.toString());\n                        break;\n\n                    case 'D':\n                        if (value == arg.getKey()) {\n                            errorArg(\"-D\", \"Missing property assignment\");\n                            errorArg = true;\n                            continue;\n                        }\n                        if (arg.getKey().length() > 1) {\n                            //Dfoo=bar arg.key=Dfoo and arg.value=bar\n                            props.put(arg.getKey().substring(1), arg.getValue());\n                        } else {\n                            //D foo=bar arg.key=D and arg.value=foo=bar\n                            String[] parts = value.split(\"=\");\n                            int valueIdx = (parts.length > 1) ? 1 : 0;\n                            props.put(parts[0], parts[valueIdx]);\n                        }\n                        break;\n\n                    default:\n                        errorArg(\"-\" + arg.getKey(), \"Unrecognized option\");\n                        errorArg = true;\n                        break;\n                }\n            } else if (\"start\".equals(arg.getKey())\n                    || \"stop\".equals(arg.getKey())\n                    || \"status\".equals(arg.getKey())\n                    || \"threads\".equals(arg.getKey())) {\n                props.put(PROP_CONTROL_ACTION, arg.getValue());\n            } else {\n                errorArg(arg.getKey(), \"Unrecognized option\");\n                errorArg = true;\n            }\n        }\n        return errorArg ? null : props;\n    }","commit_id":"e063dd9e4ddb3465d751fa5ba157cb6b794450b4","url":"https://github.com/apache/sling"},{"original_method":"/** prints a simple usage plus optional error message */\n    private static boolean doHelp(Map<String, String> args) {\n        if (args.remove(\"h\") != null) {\n            System.out.println(\"usage: \"\n                + Main.class.getName()\n                + \" [ start | stop | status ] [ -j adr ] [ -l loglevel ] [ -f logfile ] [ -c slinghome ] [ -i launchpadhome ] [ -a address ] [ -p port ] { -Dn=v } [ -h ]\");\n\n            System.out.println(\"    start         listen for control connection (uses -j)\");\n            System.out.println(\"    stop          terminate running Apache Sling (uses -j)\");\n            System.out.println(\"    status        check whether Apache Sling is running (uses -j)\");\n            System.out.println(\"    -j adr        host and port to use for control connection in the format '[host:]port' (default 127.0.0.1:0)\");\n            System.out.println(\"    -l loglevel   the initial loglevel (0..4, FATAL, ERROR, WARN, INFO, DEBUG)\");\n            System.out.println(\"    -f logfile    the log file, \\\"-\\\" for stdout (default logs/error.log)\");\n            System.out.println(\"    -c slinghome  the sling context directory (default sling)\");\n            System.out.println(\"    -i launchpadhome  the launchpad directory (default slinghome)\");\n            System.out.println(\"    -a address    the interfact to bind to (use 0.0.0.0 for any)\");\n            System.out.println(\"    -p port       the port to listen to (default 8080)\");\n            System.out.println(\"    -r path       the root servlet context path for the http service (default is /)\");\n            System.out.println(\"    -n            don't install the shutdown hook\");\n            System.out.println(\"    -Dn=v         sets property n to value v. Make sure to use this option *after* \" +\n                                                  \"the jar filename. The JVM also has a -D option which has a \" +\n                                                  \"different meaning\");\n            System.out.println(\"    -h            prints this usage message\");\n\n            return true;\n        }\n        return false;\n    }","id":72584,"modified_method":"/** prints a simple usage plus optional error message */\n    private static boolean doHelp(Map<String, String> args) {\n        if (args.remove(\"h\") != null) {\n            System.out.println(\"usage: \"\n                + Main.class.getName()\n                + \" [ start | stop | status ] [ -j adr ] [ -l loglevel ] [ -f logfile ] [ -c slinghome ] [ -i launchpadhome ] [ -a address ] [ -p port ] { -Dn=v } [ -h ]\");\n\n            System.out.println(\"    start         listen for control connection (uses -j)\");\n            System.out.println(\"    stop          terminate running Apache Sling (uses -j)\");\n            System.out.println(\"    status        check whether Apache Sling is running (uses -j)\");\n            System.out.println(\"    threads       request a thread dump from Apache Sling (uses -j)\");\n            System.out.println(\"    -j adr        host and port to use for control connection in the format '[host:]port' (default 127.0.0.1:0)\");\n            System.out.println(\"    -l loglevel   the initial loglevel (0..4, FATAL, ERROR, WARN, INFO, DEBUG)\");\n            System.out.println(\"    -f logfile    the log file, \\\"-\\\" for stdout (default logs/error.log)\");\n            System.out.println(\"    -c slinghome  the sling context directory (default sling)\");\n            System.out.println(\"    -i launchpadhome  the launchpad directory (default slinghome)\");\n            System.out.println(\"    -a address    the interfact to bind to (use 0.0.0.0 for any)\");\n            System.out.println(\"    -p port       the port to listen to (default 8080)\");\n            System.out.println(\"    -r path       the root servlet context path for the http service (default is /)\");\n            System.out.println(\"    -n            don't install the shutdown hook\");\n            System.out.println(\"    -Dn=v         sets property n to value v. Make sure to use this option *after* \" +\n                                                  \"the jar filename. The JVM also has a -D option which has a \" +\n                                                  \"different meaning\");\n            System.out.println(\"    -h            prints this usage message\");\n\n            return true;\n        }\n        return false;\n    }","commit_id":"e063dd9e4ddb3465d751fa5ba157cb6b794450b4","url":"https://github.com/apache/sling"},{"original_method":"protected void readAllContent(final OHttpRequest iRequest) throws IOException {\r\n\t\tiRequest.content = null;\r\n\r\n\t\tint in;\r\n\t\tchar currChar;\r\n\t\tint contentLength = -1;\r\n\t\tboolean endOfHeaders = false;\r\n\r\n\t\tfinal StringBuilder request = new StringBuilder();\r\n\r\n\t\twhile (!channel.socket.isInputShutdown()) {\r\n\t\t\tin = channel.inStream.read();\r\n\t\t\tif (in == -1)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcurrChar = (char) in;\r\n\r\n\t\t\tif (currChar == '\\r') {\r\n\t\t\t\tif (request.length() > 0 && contentLength == -1) {\r\n\t\t\t\t\tString line = request.toString();\r\n\t\t\t\t\tString lineUpperCase = line.toUpperCase();\r\n\t\t\t\t\tif (lineUpperCase.startsWith(\"AUTHORIZATION\")) {\r\n\t\t\t\t\t\t// STORE AUTHORIZATION INFORMATION INTO THE REQUEST\r\n\t\t\t\t\t\tString auth = line.substring(\"AUTHORIZATION\".length() + 2);\r\n\t\t\t\t\t\tif (!auth.toUpperCase().startsWith(\"BASIC\"))\r\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Only HTTP Basic authorization is supported\");\r\n\r\n\t\t\t\t\t\tiRequest.authorization = auth.substring(\"BASIC\".length() + 1);\r\n\r\n\t\t\t\t\t\tiRequest.authorization = base64.decodeBase64(\"\", iRequest.authorization);\r\n\r\n\t\t\t\t\t} else if (lineUpperCase.startsWith(\"COOKIE:\")) {\r\n\t\t\t\t\t\tString sessionPair = line.substring(\"COOKIE:\".length() + 1);\r\n\t\t\t\t\t\tString[] sessionPairItems = sessionPair.split(\"=\");\r\n\t\t\t\t\t\tif (sessionPairItems.length == 2 && \"OSESSIONID\".equals(sessionPairItems[0]))\r\n\t\t\t\t\t\t\tiRequest.sessionId = sessionPairItems[1];\r\n\r\n\t\t\t\t\t} else if (lineUpperCase.startsWith(OHttpUtils.CONTENT_LENGTH)) {\r\n\t\t\t\t\t\tcontentLength = Integer.parseInt(lineUpperCase.substring(OHttpUtils.CONTENT_LENGTH.length()));\r\n\t\t\t\t\t\tif (contentLength > MAX_CONTENT_LENGTH)\r\n\t\t\t\t\t\t\tOLogManager.instance().warn(\r\n\t\t\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\t\t\t\"->\" + channel.socket.getInetAddress().getHostAddress() + \": Error on content size \" + contentLength\r\n\t\t\t\t\t\t\t\t\t\t\t+ \": the maximum allowed is \" + MAX_CONTENT_LENGTH);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// CONSUME /r or /n\r\n\t\t\t\tin = channel.inStream.read();\r\n\t\t\t\tif (in == -1)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcurrChar = (char) in;\r\n\r\n\t\t\t\tif (!endOfHeaders && request.length() == 0) {\r\n\t\t\t\t\tif (contentLength <= 0)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// FIRST BLANK LINE: END OF HEADERS\r\n\t\t\t\t\tendOfHeaders = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\trequest.setLength(0);\r\n\t\t\t} else if (endOfHeaders && request.length() == 0 && currChar != '\\r' && currChar != '\\n') {\r\n\t\t\t\t// END OF HEADERS\r\n\t\t\t\tbyte[] buffer = new byte[contentLength];\r\n\t\t\t\tbuffer[0] = (byte) currChar;\r\n\t\t\t\tchannel.inStream.read(buffer, 1, contentLength - 1);\r\n\r\n\t\t\t\tiRequest.content = new String(buffer);\r\n\t\t\t\treturn;\r\n\t\t\t} else\r\n\t\t\t\trequest.append(currChar);\r\n\t\t}\r\n\r\n\t\tif (OLogManager.instance().isDebugEnabled())\r\n\t\t\tOLogManager.instance().debug(this,\r\n\t\t\t\t\t\"Error on parsing HTTP content from client \" + channel.socket.getInetAddress().getHostAddress() + \":\\n\" + request);\r\n\r\n\t\treturn;\r\n\t}","id":72585,"modified_method":"protected void readAllContent(final OHttpRequest iRequest) throws IOException {\r\n\t\tiRequest.content = null;\r\n\r\n\t\tint in;\r\n\t\tchar currChar;\r\n\t\tint contentLength = -1;\r\n\t\tboolean endOfHeaders = false;\r\n\r\n\t\tfinal StringBuilder request = new StringBuilder();\r\n\r\n\t\twhile (!channel.socket.isInputShutdown()) {\r\n\t\t\tin = channel.inStream.read();\r\n\t\t\tif (in == -1)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcurrChar = (char) in;\r\n\r\n\t\t\tif (currChar == '\\r') {\r\n\t\t\t\tif (request.length() > 0 && !endOfHeaders) {\r\n\t\t\t\t\tString line = request.toString();\r\n\t\t\t\t\tString lineUpperCase = line.toUpperCase();\r\n\t\t\t\t\tif (lineUpperCase.startsWith(\"AUTHORIZATION\")) {\r\n\t\t\t\t\t\t// STORE AUTHORIZATION INFORMATION INTO THE REQUEST\r\n\t\t\t\t\t\tString auth = line.substring(\"AUTHORIZATION\".length() + 2);\r\n\t\t\t\t\t\tif (!auth.toUpperCase().startsWith(\"BASIC\"))\r\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Only HTTP Basic authorization is supported\");\r\n\r\n\t\t\t\t\t\tiRequest.authorization = auth.substring(\"BASIC\".length() + 1);\r\n\r\n\t\t\t\t\t\tiRequest.authorization = base64.decodeBase64(\"\", iRequest.authorization);\r\n\r\n\t\t\t\t\t} else if (lineUpperCase.startsWith(\"COOKIE:\")) {\r\n\t\t\t\t\t\tString sessionPair = line.substring(\"COOKIE:\".length() + 1);\r\n\t\t\t\t\t\tString[] sessionPairItems = sessionPair.split(\"=\");\r\n\t\t\t\t\t\tif (sessionPairItems.length == 2 && \"OSESSIONID\".equals(sessionPairItems[0]))\r\n\t\t\t\t\t\t\tiRequest.sessionId = sessionPairItems[1];\r\n\r\n\t\t\t\t\t} else if (lineUpperCase.startsWith(OHttpUtils.CONTENT_LENGTH)) {\r\n\t\t\t\t\t\tcontentLength = Integer.parseInt(lineUpperCase.substring(OHttpUtils.CONTENT_LENGTH.length()));\r\n\t\t\t\t\t\tif (contentLength > MAX_CONTENT_LENGTH)\r\n\t\t\t\t\t\t\tOLogManager.instance().warn(\r\n\t\t\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\t\t\t\"->\" + channel.socket.getInetAddress().getHostAddress() + \": Error on content size \" + contentLength\r\n\t\t\t\t\t\t\t\t\t\t\t+ \": the maximum allowed is \" + MAX_CONTENT_LENGTH);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// CONSUME /r or /n\r\n\t\t\t\tin = channel.inStream.read();\r\n\t\t\t\tif (in == -1)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcurrChar = (char) in;\r\n\r\n\t\t\t\tif (!endOfHeaders && request.length() == 0) {\r\n\t\t\t\t\tif (contentLength <= 0)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// FIRST BLANK LINE: END OF HEADERS\r\n\t\t\t\t\tendOfHeaders = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\trequest.setLength(0);\r\n\t\t\t} else if (endOfHeaders && request.length() == 0 && currChar != '\\r' && currChar != '\\n') {\r\n\t\t\t\t// END OF HEADERS\r\n\t\t\t\tbyte[] buffer = new byte[contentLength];\r\n\t\t\t\tbuffer[0] = (byte) currChar;\r\n\t\t\t\tchannel.inStream.read(buffer, 1, contentLength - 1);\r\n\r\n\t\t\t\tiRequest.content = new String(buffer);\r\n\t\t\t\treturn;\r\n\t\t\t} else\r\n\t\t\t\trequest.append(currChar);\r\n\t\t}\r\n\r\n\t\tif (OLogManager.instance().isDebugEnabled())\r\n\t\t\tOLogManager.instance().debug(this,\r\n\t\t\t\t\t\"Error on parsing HTTP content from client \" + channel.socket.getInetAddress().getHostAddress() + \":\\n\" + request);\r\n\r\n\t\treturn;\r\n\t}","commit_id":"dd423d1eec6533ec822da13513fef66b9c0b265e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void sendTextContent(final int iCode, final String iReason, String iHeaders, final String iContentType,\r\n\t\t\tfinal String iContent) throws IOException {\r\n\t\tsendStatus(iCode, iReason);\r\n\t\tsendResponseHeaders(iContentType);\r\n\t\tif (iHeaders != null)\r\n\t\t\twriteLine(iHeaders);\r\n\r\n\t\tif (iContent != null)\r\n\t\t\twriteLine(OHttpUtils.CONTENT_LENGTH + iContent.length());\r\n\t\t\r\n\t\twriteLine(null);\r\n\r\n\t\tif (iContent != null && iContent.length() > 0) {\r\n\t\t\twriteLine(iContent);\r\n\t\t}\r\n\r\n\t\tchannel.flush();\r\n\t}","id":72586,"modified_method":"protected void sendTextContent(final int iCode, final String iReason, String iHeaders, final String iContentType,\r\n\t\t\tfinal String iContent) throws IOException {\r\n\t\tfinal boolean empty = iContent == null || iContent.length() == 0;\r\n\r\n\t\tsendStatus(empty && iCode == 200 ? 204 : iCode, iReason);\r\n\t\tsendResponseHeaders(iContentType);\r\n\t\tif (iHeaders != null)\r\n\t\t\twriteLine(iHeaders);\r\n\r\n\t\twriteLine(OHttpUtils.CONTENT_LENGTH + (empty ? 0 : iContent.length()));\r\n\r\n\t\twriteLine(null);\r\n\r\n\t\tif (!empty)\r\n\t\t\twriteLine(iContent);\r\n\r\n\t\tchannel.flush();\r\n\t}","commit_id":"dd423d1eec6533ec822da13513fef66b9c0b265e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void sendTextContent(final OHttpRequest iRequest, final int iCode, final String iReason, final String iHeaders,\r\n\t\t\tfinal String iContentType, final String iContent) throws IOException {\r\n\t\tsendStatus(iRequest, iCode, iReason);\r\n\t\tsendResponseHeaders(iRequest, iContentType);\r\n\t\tif (iHeaders != null)\r\n\t\t\twriteLine(iRequest, iHeaders);\r\n\r\n\t\twriteLine(iRequest, \"Set-Cookie: OSESSIONID=\" + (iRequest.sessionId != null ? iRequest.sessionId : \"-\") + \"; Path=/; HttpOnly\");\r\n\r\n\t\tif (iContent != null)\r\n\t\t\twriteLine(iRequest, OHttpUtils.CONTENT_LENGTH + iContent.length());\r\n\r\n\t\twriteLine(iRequest, null);\r\n\r\n\t\tif (iContent != null && iContent.length() > 0) {\r\n\t\t\twriteLine(iRequest, iContent);\r\n\t\t}\r\n\r\n\t\tiRequest.channel.flush();\r\n\t}","id":72587,"modified_method":"protected void sendTextContent(final OHttpRequest iRequest, final int iCode, final String iReason, final String iHeaders,\r\n\t\t\tfinal String iContentType, final String iContent) throws IOException {\r\n\t\tfinal boolean empty = iContent == null || iContent.length() == 0;\r\n\r\n\t\tsendStatus(iRequest, empty && iCode == 200 ? 204 : iCode, iReason);\r\n\t\tsendResponseHeaders(iRequest, iContentType);\r\n\t\tif (iHeaders != null)\r\n\t\t\twriteLine(iRequest, iHeaders);\r\n\r\n\t\twriteLine(iRequest, \"Set-Cookie: OSESSIONID=\" + (iRequest.sessionId != null ? iRequest.sessionId : \"-\") + \"; Path=/; HttpOnly\");\r\n\r\n\t\twriteLine(iRequest, OHttpUtils.CONTENT_LENGTH + (empty ? 0 : iContent.length()));\r\n\r\n\t\twriteLine(iRequest, null);\r\n\r\n\t\tif (!empty)\r\n\t\t\twriteLine(iRequest, iContent);\r\n\r\n\t\tiRequest.channel.flush();\r\n\t}","commit_id":"dd423d1eec6533ec822da13513fef66b9c0b265e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tcheckSyntax(iRequest.url, 1, \"Syntax error: disconnect\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Disconnect\";\r\n\t\tiRequest.data.commandDetail = null;\r\n\r\n\t\tif (iRequest.sessionId != null) {\r\n\t\t\tOHttpSessionManager.getInstance().removeSession(iRequest.sessionId);\r\n\t\t\tiRequest.sessionId = null;\r\n\t\t}\r\n\r\n\t\tsendTextContent(iRequest, 205, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, \"Disconnected\");\r\n\t}","id":72588,"modified_method":"public void execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tcheckSyntax(iRequest.url, 1, \"Syntax error: disconnect\");\r\n\r\n\t\tiRequest.data.commandInfo = \"Disconnect\";\r\n\t\tiRequest.data.commandDetail = null;\r\n\r\n\t\tif (iRequest.sessionId != null) {\r\n\t\t\tOHttpSessionManager.getInstance().removeSession(iRequest.sessionId);\r\n\t\t\tiRequest.sessionId = null;\r\n\t\t}\r\n\r\n\t\tsendTextContent(iRequest, 204, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, null);\r\n\t}","commit_id":"dd423d1eec6533ec822da13513fef66b9c0b265e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void write( File file )\n            throws IOException\n        {\n            PrintWriter w = new PrintWriter( new FileWriter( file ) );\n\n            try\n            {\n                w.println( \"<metadata>\" );\n                writeLine( w, \"  \", \"groupId\", metadata.getGroupId() );\n                writeLine( w, \"  \", \"artifactId\", metadata.getArtifactId() );\n                writeLine( w, \"  \", \"version\", metadata.getVersion() );\n                w.println( \"  <versioning>\" );\n                writeLine( w, \"    \", \"latest\", metadata.getLatestVersion() );\n                writeLine( w, \"    \", \"release\", metadata.getReleaseVersion() );\n                writeLine( w, \"    \", \"lastUpdated\", String.valueOf( metadata.getLastUpdated() ) );\n                w.println( \"    <snapshot>\" );\n                writeLine( w, \"      \", \"localCopy\", String.valueOf( metadata.isLocalCopy() ) );\n                writeLine( w, \"      \", \"buildNumber\", String.valueOf( metadata.getSnapshotBuildNumber() ) );\n                writeLine( w, \"      \", \"timestamp\", metadata.getSnapshotTimestamp() );\n                w.println( \"    <\/snapshot>\" );\n                w.println( \"    <versions>\" );\n                for ( Iterator i = metadata.getVersions().iterator(); i.hasNext(); )\n                {\n                    writeLine( w, \"      \", \"version\", (String) i.next() );\n                }\n                w.println( \"    <\/versions>\" );\n                w.println( \"  <\/versioning>\" );\n                w.println( \"<\/metadata>\" );\n            }\n            finally\n            {\n                w.close();\n            }\n        }","id":72589,"modified_method":"public void write( File file )\n            throws IOException\n        {\n            PrintWriter w = new PrintWriter( new FileWriter( file ) );\n\n            try\n            {\n                w.println( \"<metadata>\" );\n                writeLine( w, \"  \", \"groupId\", metadata.getGroupId() );\n                writeLine( w, \"  \", \"artifactId\", metadata.getArtifactId() );\n                writeLine( w, \"  \", \"version\", metadata.getVersion() );\n                w.println( \"  <versioning>\" );\n                writeLine( w, \"    \", \"latest\", metadata.getLatestVersion() );\n                writeLine( w, \"    \", \"release\", metadata.getReleaseVersion() );\n                writeLine( w, \"    \", \"lastUpdated\", metadata.getLastUpdated() );\n                w.println( \"    <snapshot>\" );\n                if ( metadata.isLocalCopy() )\n                {\n                    writeLine( w, \"      \", \"localCopy\", \"true\" );\n                }\n                if ( metadata.getSnapshotBuildNumber() > 0 )\n                {\n                    writeLine( w, \"      \", \"buildNumber\", String.valueOf( metadata.getSnapshotBuildNumber() ) );\n                }\n                writeLine( w, \"      \", \"timestamp\", metadata.getSnapshotTimestamp() );\n                w.println( \"    <\/snapshot>\" );\n                w.println( \"    <versions>\" );\n                for ( Iterator i = metadata.getVersions().iterator(); i.hasNext(); )\n                {\n                    writeLine( w, \"      \", \"version\", (String) i.next() );\n                }\n                w.println( \"    <\/versions>\" );\n                w.println( \"  <\/versioning>\" );\n                w.println( \"<\/metadata>\" );\n            }\n            finally\n            {\n                w.close();\n            }\n        }","commit_id":"8c49bbda97f7ea4c0d95c0d6462a4664e86d2705","url":"https://github.com/apache/maven"},{"original_method":"/**\n   * Executes the specified command.\n   * @param cmd command to be executed\n   * @param edit call from editor panel\n   * @return success flag\n   */\n  boolean exec(final Command cmd, final boolean edit) {\n    // wait when command is still running\n    final int thread = ++threadID;\n    while(true) {\n      final Command c = command;\n      if(c == null) break;\n      c.stop();\n      Thread.yield();\n      if(threadID != thread) return true;\n    }\n    cursor(CURSORWAIT);\n    input.setCursor(CURSORWAIT);\n    stop.setEnabled(true);\n\n    boolean ok = true;\n    try {\n      final Performance perf = new Performance();\n\n      final Data data = context.data();\n      // reset current context if realtime filter is activated\n      if(gopts.get(GUIOptions.FILTERRT) && data != null && !context.root()) context.update();\n\n      // remember current command and context nodes\n      final Nodes current = context.current();\n      command = cmd;\n\n      // execute command and cache result\n      final ArrayOutput ao = new ArrayOutput().max(gopts.get(GUIOptions.MAXTEXT));\n      updating = cmd.updating(context);\n\n      // updates the query editor\n      if(edit) editor.start();\n\n      // reset visualizations if data reference will be changed\n      if(cmd.newData(context)) notify.init();\n      // attaches the info listener to the command\n      cmd.listen(infoListener);\n\n      // evaluate command\n      String inf = null;\n      Throwable cause = null;\n      try {\n        cmd.execute(context, ao);\n        inf = cmd.info();\n      } catch(final BaseXException ex) {\n        cause = ex.getCause();\n        if(cause == null) cause = ex;\n        ok = false;\n        inf = Util.message(ex);\n      } finally {\n        updating = false;\n      }\n      final String time = perf.getTime();\n\n      // show query info\n      info.setInfo(inf, cmd, time, ok, true);\n\n      // sends feedback to the query editor\n      final boolean stopped = inf.endsWith(INTERRUPTED);\n      if(edit) editor.info(cause, stopped, true);\n\n      // check if query feedback was evaluated in the query view\n      if(!ok && !stopped) {\n        // display error in info view\n        if((!edit || inf.startsWith(S_BUGINFO)) && !info.visible()) {\n          GUIMenuCmd.C_SHOWINFO.execute(this);\n        }\n      } else {\n        // get query result\n        final Result result = cmd.result();\n        Nodes nodes = result instanceof Nodes && result.size() != 0 ? (Nodes) result : null;\n\n        if(context.data() != data) {\n          // database reference has changed - notify views\n          notify.init();\n        } else if(cmd.updated(context)) {\n          // update visualizations\n          notify.update();\n          // adopt updated nodes as result set\n          if(nodes == null) nodes = context.current();\n        } else if(result != null) {\n          // check if result has changed\n          final boolean flt = gopts.get(GUIOptions.FILTERRT);\n          final Nodes nd = context.current();\n          if(flt || nd != null && !nd.sameAs(current)) {\n            // refresh context if at least one node was found\n            if(nodes != null) notify.context((Nodes) result, flt, null);\n          } else if(context.marked != null) {\n            // refresh highlight\n            Nodes m = context.marked;\n            if(nodes != null) {\n              // use query result\n              m = nodes;\n            } else if(m.size() != 0) {\n              // remove old highlight\n              m = new Nodes(data);\n            }\n            // refresh views\n            if(context.marked != m) notify.mark(m, null);\n          }\n        }\n\n        if(thread == threadID && !stopped) {\n          // show status info\n          status.setText(Util.info(TIME_NEEDED_X, time));\n          // show number of hits\n          if(result != null) setResults(result.size());\n\n          if(nodes == null) {\n            // make text view visible\n            if(!text.visible() && ao.size() != 0) GUIMenuCmd.C_SHOWRESULT.execute(this);\n            // assign textual output if no node result was created\n            text.setText(ao);\n          }\n          text.cacheText(ao, cmd, result);\n        }\n      }\n    } catch(final Exception ex) {\n      // unexpected error\n      BaseXDialog.error(this, Util.info(EXEC_ERROR, cmd, Util.bug(ex)));\n      updating = false;\n    }\n    stop();\n    return ok;\n  }","id":72590,"modified_method":"/**\n   * Executes the specified command.\n   * @param cmd command to be executed\n   * @param edit call from editor panel\n   * @return success flag\n   */\n  boolean exec(final Command cmd, final boolean edit) {\n    // wait when command is still running\n    final int thread = ++threadID;\n    while(true) {\n      final Command c = command;\n      if(c == null) break;\n      c.stop();\n      Thread.yield();\n      if(threadID != thread) return true;\n    }\n    cursor(CURSORWAIT);\n    input.setCursor(CURSORWAIT);\n    stop.setEnabled(true);\n\n    boolean ok = true;\n    try {\n      final Performance perf = new Performance();\n\n      final Data data = context.data();\n      // reset current context if realtime filter is activated\n      if(gopts.get(GUIOptions.FILTERRT) && data != null && !context.root()) context.update();\n\n      // remember current command and context nodes\n      final Nodes current = context.current();\n      command = cmd;\n\n      // execute command and cache result\n      final ArrayOutput ao = new ArrayOutput();\n      ao.setLimit(gopts.get(GUIOptions.MAXTEXT));\n      updating = cmd.updating(context);\n\n      // updates the query editor\n      if(edit) editor.start();\n\n      // reset visualizations if data reference will be changed\n      if(cmd.newData(context)) notify.init();\n      // attaches the info listener to the command\n      cmd.listen(infoListener);\n\n      // evaluate command\n      String inf = null;\n      Throwable cause = null;\n      try {\n        cmd.execute(context, ao);\n        inf = cmd.info();\n      } catch(final BaseXException ex) {\n        cause = ex.getCause();\n        if(cause == null) cause = ex;\n        ok = false;\n        inf = Util.message(ex);\n      } finally {\n        updating = false;\n      }\n      final String time = perf.getTime();\n\n      // show query info\n      info.setInfo(inf, cmd, time, ok, true);\n\n      // sends feedback to the query editor\n      final boolean stopped = inf.endsWith(INTERRUPTED);\n      if(edit) editor.info(cause, stopped, true);\n\n      // check if query feedback was evaluated in the query view\n      if(!ok && !stopped) {\n        // display error in info view\n        if((!edit || inf.startsWith(S_BUGINFO)) && !info.visible()) {\n          GUIMenuCmd.C_SHOWINFO.execute(this);\n        }\n      } else {\n        // get query result\n        final Result result = cmd.result();\n        Nodes nodes = result instanceof Nodes && result.size() != 0 ? (Nodes) result : null;\n\n        if(context.data() != data) {\n          // database reference has changed - notify views\n          notify.init();\n        } else if(cmd.updated(context)) {\n          // update visualizations\n          notify.update();\n          // adopt updated nodes as result set\n          if(nodes == null) nodes = context.current();\n        } else if(result != null) {\n          // check if result has changed\n          final boolean flt = gopts.get(GUIOptions.FILTERRT);\n          final Nodes nd = context.current();\n          if(flt || nd != null && !nd.sameAs(current)) {\n            // refresh context if at least one node was found\n            if(nodes != null) notify.context((Nodes) result, flt, null);\n          } else if(context.marked != null) {\n            // refresh highlight\n            Nodes m = context.marked;\n            if(nodes != null) {\n              // use query result\n              m = nodes;\n            } else if(m.size() != 0) {\n              // remove old highlight\n              m = new Nodes(data);\n            }\n            // refresh views\n            if(context.marked != m) notify.mark(m, null);\n          }\n        }\n\n        if(thread == threadID && !stopped) {\n          // show status info\n          status.setText(Util.info(TIME_NEEDED_X, time));\n          // show number of hits\n          if(result != null) setResults(result.size());\n\n          if(nodes == null) {\n            // make text view visible\n            if(!text.visible() && ao.size() != 0) GUIMenuCmd.C_SHOWRESULT.execute(this);\n            // assign textual output if no node result was created\n            text.setText(ao);\n          }\n          text.cacheText(ao, cmd, result);\n        }\n      }\n    } catch(final Exception ex) {\n      // unexpected error\n      BaseXDialog.error(this, Util.info(EXEC_ERROR, cmd, Util.bug(ex)));\n      updating = false;\n    }\n    stop();\n    return ok;\n  }","commit_id":"cdd63bf38744bcac8706cc8e3601c0360bf62eaf","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param os output stream reference\n   * @param sopts serialization parameters\n   * @param versions supported versions\n   * @throws IOException I/O exception\n   */\n  protected OutputSerializer(final OutputStream os, final SerializerOptions sopts,\n      final String... versions) throws IOException {\n\n    final SerializerOptions opts = sopts == null ? OPTIONS : sopts;\n    final String ver = supported(VERSION, opts, versions);\n    final String htmlver = supported(HTML_VERSION, opts, V40, V401, V50);\n    html5 = htmlver.equals(V50) || ver.equals(V50);\n\n    final boolean omitDecl = opts.yes(OMIT_XML_DECLARATION);\n    final boolean bom  = opts.yes(BYTE_ORDER_MARK);\n    final YesNoOmit sa = opts.get(STANDALONE);\n    saomit = sa == YesNoOmit.OMIT;\n\n    final String maps = opts.get(USE_CHARACTER_MAPS);\n    final String enc = normEncoding(opts.get(ENCODING), true);\n    try {\n      encoding = Charset.forName(enc);\n    } catch(final Exception ex) {\n      throw SERENCODING.getIO(enc);\n    }\n    utf8 = enc == UTF8;\n    if(!utf8) {\n      encoder = encoding.newEncoder();\n      encbuffer = new TokenBuilder();\n    }\n\n    // project specific options\n    indents = opts.get(INDENTS);\n    format  = opts.yes(FORMAT);\n    tab     = opts.yes(TABULATOR) ? '\\t' : ' ';\n    wPre    = token(opts.get(WRAP_PREFIX));\n    wrap    = wPre.length != 0;\n\n    nl = utf8(token(opts.get(NEWLINE).newline()), enc);\n    itemsep = opts.contains(ITEM_SEPARATOR) ? token(opts.get(ITEM_SEPARATOR).replace(\"\\\\n\", \"\\n\").\n        replace(\"\\\\r\", \"\\r\").replace(\"\\\\t\", \"\\t\")) : null;\n\n    docsys  = opts.get(DOCTYPE_SYSTEM);\n    docpub  = opts.get(DOCTYPE_PUBLIC);\n    media   = opts.get(MEDIA_TYPE);\n    escuri  = opts.yes(ESCAPE_URI_ATTRIBUTES);\n    content = opts.yes(INCLUDE_CONTENT_TYPE);\n    undecl  = opts.yes(UNDECLARE_PREFIXES);\n    indent  = opts.yes(INDENT) && format;\n\n    webdav = \"webdav\".equals(maps);\n    if(!webdav && !maps.isEmpty()) throw SERMAP.getIO(maps);\n\n    if(docsys.isEmpty()) docsys = null;\n    if(docpub.isEmpty()) docpub = null;\n\n    // print byte-order-mark\n    out = PrintOutput.get(os);\n    if(bom) {\n      // comparison by reference\n      if(enc == UTF8) {\n        out.write(0xEF); out.write(0xBB); out.write(0xBF);\n      } else if(enc == UTF16LE) {\n        out.write(0xFF); out.write(0xFE);\n      } else if(enc == UTF16BE) {\n        out.write(0xFE); out.write(0xFF);\n      }\n    }\n\n    final String supp = opts.get(SUPPRESS_INDENTATION);\n    if(!supp.isEmpty()) {\n      for(final String c : supp.split(\"\\\\s+\")) {\n        if(!c.isEmpty()) suppress.add(c);\n      }\n    }\n\n    // collect CData elements\n    final boolean html = this instanceof HTMLSerializer;\n    final boolean xml = this instanceof XMLSerializer || this instanceof XHTMLSerializer;\n    if(xml || html) {\n      final String cdse = opts.get(CDATA_SECTION_ELEMENTS);\n      for(final String c : cdse.split(\"\\\\s+\")) {\n        if(c.isEmpty()) continue;\n        if(!html || c.contains(\":\") && (!html5 || !c.contains(\"html:\"))) cdata.add(c);\n      }\n\n      if(undecl && ver.equals(V10)) throw SERUNDECL.getIO();\n      if(xml) {\n        if(omitDecl) {\n          if(!saomit || !ver.equals(V10) && docsys != null) throw SERSTAND.getIO();\n        } else {\n          print(PI_O);\n          print(DOCDECL1);\n          print(ver);\n          print(DOCDECL2);\n          print(opts.get(ENCODING));\n          if(!saomit) {\n            print(DOCDECL3);\n            print(sa.toString());\n          }\n          print(ATT2);\n          print(PI_C);\n          sep = true;\n        }\n      }\n    }\n\n    // open results element\n    if(wrap) {\n      startElement(concat(wPre, COLON, T_RESULTS));\n      namespace(wPre, token(opts.get(WRAP_URI)));\n    }\n  }","id":72591,"modified_method":"/**\n   * Constructor.\n   * @param os output stream reference\n   * @param sopts serialization parameters\n   * @param versions supported versions\n   * @throws IOException I/O exception\n   */\n  protected OutputSerializer(final OutputStream os, final SerializerOptions sopts,\n      final String... versions) throws IOException {\n\n    final SerializerOptions opts = sopts == null ? OPTIONS : sopts;\n    final String ver = supported(VERSION, opts, versions);\n    final String htmlver = supported(HTML_VERSION, opts, V40, V401, V50);\n    html5 = htmlver.equals(V50) || ver.equals(V50);\n\n    final boolean omitDecl = opts.yes(OMIT_XML_DECLARATION);\n    final boolean bom  = opts.yes(BYTE_ORDER_MARK);\n    final YesNoOmit sa = opts.get(STANDALONE);\n    saomit = sa == YesNoOmit.OMIT;\n\n    final String maps = opts.get(USE_CHARACTER_MAPS);\n    final String enc = normEncoding(opts.get(ENCODING), true);\n    try {\n      encoding = Charset.forName(enc);\n    } catch(final Exception ex) {\n      throw SERENCODING.getIO(enc);\n    }\n    utf8 = enc == UTF8;\n    if(!utf8) {\n      encoder = encoding.newEncoder();\n      encbuffer = new TokenBuilder();\n    }\n\n    // project specific options\n    indents = opts.get(INDENTS);\n    format  = opts.yes(FORMAT);\n    tab     = opts.yes(TABULATOR) ? '\\t' : ' ';\n    wPre    = token(opts.get(WRAP_PREFIX));\n    wrap    = wPre.length != 0;\n\n    nl = utf8(token(opts.get(NEWLINE).newline()), enc);\n    itemsep = opts.contains(ITEM_SEPARATOR) ? token(opts.get(ITEM_SEPARATOR).replace(\"\\\\n\", \"\\n\").\n        replace(\"\\\\r\", \"\\r\").replace(\"\\\\t\", \"\\t\")) : null;\n\n    docsys  = opts.get(DOCTYPE_SYSTEM);\n    docpub  = opts.get(DOCTYPE_PUBLIC);\n    media   = opts.get(MEDIA_TYPE);\n    escuri  = opts.yes(ESCAPE_URI_ATTRIBUTES);\n    content = opts.yes(INCLUDE_CONTENT_TYPE);\n    undecl  = opts.yes(UNDECLARE_PREFIXES);\n    indent  = opts.yes(INDENT) && format;\n\n    webdav = \"webdav\".equals(maps);\n    if(!webdav && !maps.isEmpty()) throw SERMAP.getIO(maps);\n\n    if(docsys.isEmpty()) docsys = null;\n    if(docpub.isEmpty()) docpub = null;\n\n    // print byte-order-mark\n    out = PrintOutput.get(os);\n    out.setLimit(opts.get(LIMIT));\n\n    if(bom) {\n      // comparison by reference\n      if(enc == UTF8) {\n        out.write(0xEF); out.write(0xBB); out.write(0xBF);\n      } else if(enc == UTF16LE) {\n        out.write(0xFF); out.write(0xFE);\n      } else if(enc == UTF16BE) {\n        out.write(0xFE); out.write(0xFF);\n      }\n    }\n\n    final String supp = opts.get(SUPPRESS_INDENTATION);\n    if(!supp.isEmpty()) {\n      for(final String c : supp.split(\"\\\\s+\")) {\n        if(!c.isEmpty()) suppress.add(c);\n      }\n    }\n\n    // collect CData elements\n    final boolean html = this instanceof HTMLSerializer;\n    final boolean xml = this instanceof XMLSerializer || this instanceof XHTMLSerializer;\n    if(xml || html) {\n      final String cdse = opts.get(CDATA_SECTION_ELEMENTS);\n      for(final String c : cdse.split(\"\\\\s+\")) {\n        if(c.isEmpty()) continue;\n        if(!html || c.contains(\":\") && (!html5 || !c.contains(\"html:\"))) cdata.add(c);\n      }\n\n      if(undecl && ver.equals(V10)) throw SERUNDECL.getIO();\n      if(xml) {\n        if(omitDecl) {\n          if(!saomit || !ver.equals(V10) && docsys != null) throw SERSTAND.getIO();\n        } else {\n          print(PI_O);\n          print(DOCDECL1);\n          print(ver);\n          print(DOCDECL2);\n          print(opts.get(ENCODING));\n          if(!saomit) {\n            print(DOCDECL3);\n            print(sa.toString());\n          }\n          print(ATT2);\n          print(PI_C);\n          sep = true;\n        }\n      }\n    }\n\n    // open results element\n    if(wrap) {\n      startElement(concat(wPre, COLON, T_RESULTS));\n      namespace(wPre, token(opts.get(WRAP_URI)));\n    }\n  }","commit_id":"cdd63bf38744bcac8706cc8e3601c0360bf62eaf","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Serializes the specified nodes.\n   * @param n nodes to display\n   */\n  private void setText(final Nodes n) {\n    if(visible()) {\n      try {\n        final ArrayOutput ao = new ArrayOutput().max(gui.gopts.get(GUIOptions.MAXTEXT));\n        if(n != null) n.serialize(Serializer.get(ao));\n        setText(ao);\n        cmd = null;\n        ns = ao.finished() ? n : null;\n      } catch(final IOException ex) {\n        Util.debug(ex);\n      }\n    } else {\n      home.setEnabled(gui.context.data() != null);\n    }\n  }","id":72592,"modified_method":"/**\n   * Serializes the specified nodes.\n   * @param n nodes to display\n   */\n  private void setText(final Nodes n) {\n    if(visible()) {\n      try {\n        final ArrayOutput ao = new ArrayOutput();\n        ao.setLimit(gui.gopts.get(GUIOptions.MAXTEXT));\n        if(n != null) n.serialize(Serializer.get(ao));\n        setText(ao);\n        cmd = null;\n        ns = ao.finished() ? n : null;\n      } catch(final IOException ex) {\n        Util.debug(ex);\n      }\n    } else {\n      home.setEnabled(gui.context.data() != null);\n    }\n  }","commit_id":"cdd63bf38744bcac8706cc8e3601c0360bf62eaf","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Executes the specified command.\n   * @param cmd command to be executed\n   * @param edit call from editor panel\n   * @return success flag\n   */\n  boolean exec(final Command cmd, final boolean edit) {\n    // wait when command is still running\n    final int thread = ++threadID;\n    while(true) {\n      final Command c = command;\n      if(c == null) break;\n      c.stop();\n      Thread.yield();\n      if(threadID != thread) return true;\n    }\n    cursor(CURSORWAIT);\n    input.setCursor(CURSORWAIT);\n    stop.setEnabled(true);\n\n    boolean ok = true;\n    try {\n      final Performance perf = new Performance();\n\n      final Data data = context.data();\n      // reset current context if realtime filter is activated\n      if(gopts.get(GUIOptions.FILTERRT) && data != null && !context.root()) context.update();\n\n      // remember current command and context nodes\n      final Nodes current = context.current();\n      command = cmd;\n\n      // execute command and cache result\n      final ArrayOutput ao = new ArrayOutput().max(gopts.get(GUIOptions.MAXTEXT));\n      updating = cmd.updating(context);\n\n      // updates the query editor\n      if(edit) editor.start();\n\n      // reset visualizations if data reference will be changed\n      if(cmd.newData(context)) notify.init();\n      // attaches the info listener to the command\n      cmd.listen(infoListener);\n\n      // evaluate command\n      String inf = null;\n      Throwable cause = null;\n      try {\n        cmd.execute(context, ao);\n        inf = cmd.info();\n      } catch(final BaseXException ex) {\n        cause = ex.getCause();\n        if(cause == null) cause = ex;\n        ok = false;\n        inf = Util.message(ex);\n      } finally {\n        updating = false;\n      }\n      final String time = perf.getTime();\n\n      // show query info\n      info.setInfo(inf, cmd, time, ok, true);\n\n      // sends feedback to the query editor\n      final boolean stopped = inf.endsWith(INTERRUPTED);\n      if(edit) editor.info(cause, stopped, true);\n\n      // check if query feedback was evaluated in the query view\n      if(!ok && !stopped) {\n        // display error in info view\n        if((!edit || inf.startsWith(S_BUGINFO)) && !info.visible()) {\n          GUIMenuCmd.C_SHOWINFO.execute(this);\n        }\n      } else {\n        // get query result\n        final Result result = cmd.result();\n        Nodes nodes = result instanceof Nodes && result.size() != 0 ? (Nodes) result : null;\n\n        if(context.data() != data) {\n          // database reference has changed - notify views\n          notify.init();\n        } else if(cmd.updated(context)) {\n          // update visualizations\n          notify.update();\n          // adopt updated nodes as result set\n          if(nodes == null) nodes = context.current();\n        } else if(result != null) {\n          // check if result has changed\n          final boolean flt = gopts.get(GUIOptions.FILTERRT);\n          final Nodes nd = context.current();\n          if(flt || nd != null && !nd.sameAs(current)) {\n            // refresh context if at least one node was found\n            if(nodes != null) notify.context((Nodes) result, flt, null);\n          } else if(context.marked != null) {\n            // refresh highlight\n            Nodes m = context.marked;\n            if(nodes != null) {\n              // use query result\n              m = nodes;\n            } else if(m.size() != 0) {\n              // remove old highlight\n              m = new Nodes(data);\n            }\n            // refresh views\n            if(context.marked != m) notify.mark(m, null);\n          }\n        }\n\n        if(thread == threadID && !stopped) {\n          // show status info\n          status.setText(Util.info(TIME_NEEDED_X, time));\n          // show number of hits\n          if(result != null) setResults(result.size());\n\n          if(nodes == null) {\n            // make text view visible\n            if(!text.visible() && ao.size() != 0) GUIMenuCmd.C_SHOWRESULT.execute(this);\n            // assign textual output if no node result was created\n            text.setText(ao);\n          }\n          text.cacheText(ao, cmd, result);\n        }\n      }\n    } catch(final Exception ex) {\n      // unexpected error\n      BaseXDialog.error(this, Util.info(EXEC_ERROR, cmd, Util.bug(ex)));\n      updating = false;\n    }\n    stop();\n    return ok;\n  }","id":72593,"modified_method":"/**\n   * Executes the specified command.\n   * @param cmd command to be executed\n   * @param edit call from editor panel\n   * @return success flag\n   */\n  boolean exec(final Command cmd, final boolean edit) {\n    // wait when command is still running\n    final int thread = ++threadID;\n    while(true) {\n      final Command c = command;\n      if(c == null) break;\n      c.stop();\n      Thread.yield();\n      if(threadID != thread) return true;\n    }\n    cursor(CURSORWAIT);\n    input.setCursor(CURSORWAIT);\n    stop.setEnabled(true);\n\n    boolean ok = true;\n    try {\n      final Performance perf = new Performance();\n\n      final Data data = context.data();\n      // reset current context if realtime filter is activated\n      if(gopts.get(GUIOptions.FILTERRT) && data != null && !context.root()) context.update();\n\n      // remember current command and context nodes\n      final Nodes current = context.current();\n      command = cmd;\n\n      // execute command and cache result\n      final ArrayOutput ao = new ArrayOutput();\n      ao.setLimit(gopts.get(GUIOptions.MAXTEXT));\n      updating = cmd.updating(context);\n\n      // updates the query editor\n      if(edit) editor.start();\n\n      // reset visualizations if data reference will be changed\n      if(cmd.newData(context)) notify.init();\n      // attaches the info listener to the command\n      cmd.listen(infoListener);\n\n      // evaluate command\n      String inf = null;\n      Throwable cause = null;\n      try {\n        cmd.execute(context, ao);\n        inf = cmd.info();\n      } catch(final BaseXException ex) {\n        cause = ex.getCause();\n        if(cause == null) cause = ex;\n        ok = false;\n        inf = Util.message(ex);\n      } finally {\n        updating = false;\n      }\n      final String time = perf.getTime();\n\n      // show query info\n      info.setInfo(inf, cmd, time, ok, true);\n\n      // sends feedback to the query editor\n      final boolean stopped = inf.endsWith(INTERRUPTED);\n      if(edit) editor.info(cause, stopped, true);\n\n      // check if query feedback was evaluated in the query view\n      if(!ok && !stopped) {\n        // display error in info view\n        if((!edit || inf.startsWith(S_BUGINFO)) && !info.visible()) {\n          GUIMenuCmd.C_SHOWINFO.execute(this);\n        }\n      } else {\n        // get query result\n        final Result result = cmd.result();\n        Nodes nodes = result instanceof Nodes && result.size() != 0 ? (Nodes) result : null;\n\n        if(context.data() != data) {\n          // database reference has changed - notify views\n          notify.init();\n        } else if(cmd.updated(context)) {\n          // update visualizations\n          notify.update();\n          // adopt updated nodes as result set\n          if(nodes == null) nodes = context.current();\n        } else if(result != null) {\n          // check if result has changed\n          final boolean flt = gopts.get(GUIOptions.FILTERRT);\n          final Nodes nd = context.current();\n          if(flt || nd != null && !nd.sameAs(current)) {\n            // refresh context if at least one node was found\n            if(nodes != null) notify.context((Nodes) result, flt, null);\n          } else if(context.marked != null) {\n            // refresh highlight\n            Nodes m = context.marked;\n            if(nodes != null) {\n              // use query result\n              m = nodes;\n            } else if(m.size() != 0) {\n              // remove old highlight\n              m = new Nodes(data);\n            }\n            // refresh views\n            if(context.marked != m) notify.mark(m, null);\n          }\n        }\n\n        if(thread == threadID && !stopped) {\n          // show status info\n          status.setText(Util.info(TIME_NEEDED_X, time));\n          // show number of hits\n          if(result != null) setResults(result.size());\n\n          if(nodes == null) {\n            // make text view visible\n            if(!text.visible() && ao.size() != 0) GUIMenuCmd.C_SHOWRESULT.execute(this);\n            // assign textual output if no node result was created\n            text.setText(ao);\n          }\n          text.cacheText(ao, cmd, result);\n        }\n      }\n    } catch(final Exception ex) {\n      // unexpected error\n      BaseXDialog.error(this, Util.info(EXEC_ERROR, cmd, Util.bug(ex)));\n      updating = false;\n    }\n    stop();\n    return ok;\n  }","commit_id":"2e0ab8e0063343d3d892f5f155dbeefb73d245d8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param os output stream reference\n   * @param sopts serialization parameters\n   * @param versions supported versions\n   * @throws IOException I/O exception\n   */\n  protected OutputSerializer(final OutputStream os, final SerializerOptions sopts,\n      final String... versions) throws IOException {\n\n    final SerializerOptions opts = sopts == null ? OPTIONS : sopts;\n    final String ver = supported(VERSION, opts, versions);\n    final String htmlver = supported(HTML_VERSION, opts, V40, V401, V50);\n    html5 = htmlver.equals(V50) || ver.equals(V50);\n\n    final boolean omitDecl = opts.yes(OMIT_XML_DECLARATION);\n    final boolean bom  = opts.yes(BYTE_ORDER_MARK);\n    final YesNoOmit sa = opts.get(STANDALONE);\n    saomit = sa == YesNoOmit.OMIT;\n\n    final String maps = opts.get(USE_CHARACTER_MAPS);\n    final String enc = normEncoding(opts.get(ENCODING), true);\n    try {\n      encoding = Charset.forName(enc);\n    } catch(final Exception ex) {\n      throw SERENCODING.getIO(enc);\n    }\n    utf8 = enc == UTF8;\n    if(!utf8) {\n      encoder = encoding.newEncoder();\n      encbuffer = new TokenBuilder();\n    }\n\n    // project specific options\n    indents = opts.get(INDENTS);\n    format  = opts.yes(FORMAT);\n    tab     = opts.yes(TABULATOR) ? '\\t' : ' ';\n    wPre    = token(opts.get(WRAP_PREFIX));\n    wrap    = wPre.length != 0;\n\n    nl = utf8(token(opts.get(NEWLINE).newline()), enc);\n    itemsep = opts.contains(ITEM_SEPARATOR) ? token(opts.get(ITEM_SEPARATOR).replace(\"\\\\n\", \"\\n\").\n        replace(\"\\\\r\", \"\\r\").replace(\"\\\\t\", \"\\t\")) : null;\n\n    docsys  = opts.get(DOCTYPE_SYSTEM);\n    docpub  = opts.get(DOCTYPE_PUBLIC);\n    media   = opts.get(MEDIA_TYPE);\n    escuri  = opts.yes(ESCAPE_URI_ATTRIBUTES);\n    content = opts.yes(INCLUDE_CONTENT_TYPE);\n    undecl  = opts.yes(UNDECLARE_PREFIXES);\n    indent  = opts.yes(INDENT) && format;\n\n    webdav = \"webdav\".equals(maps);\n    if(!webdav && !maps.isEmpty()) throw SERMAP.getIO(maps);\n\n    if(docsys.isEmpty()) docsys = null;\n    if(docpub.isEmpty()) docpub = null;\n\n    // print byte-order-mark\n    out = PrintOutput.get(os);\n    if(bom) {\n      // comparison by reference\n      if(enc == UTF8) {\n        out.write(0xEF); out.write(0xBB); out.write(0xBF);\n      } else if(enc == UTF16LE) {\n        out.write(0xFF); out.write(0xFE);\n      } else if(enc == UTF16BE) {\n        out.write(0xFE); out.write(0xFF);\n      }\n    }\n\n    final String supp = opts.get(SUPPRESS_INDENTATION);\n    if(!supp.isEmpty()) {\n      for(final String c : supp.split(\"\\\\s+\")) {\n        if(!c.isEmpty()) suppress.add(c);\n      }\n    }\n\n    // collect CData elements\n    final boolean html = this instanceof HTMLSerializer;\n    final boolean xml = this instanceof XMLSerializer || this instanceof XHTMLSerializer;\n    if(xml || html) {\n      final String cdse = opts.get(CDATA_SECTION_ELEMENTS);\n      for(final String c : cdse.split(\"\\\\s+\")) {\n        if(c.isEmpty()) continue;\n        if(!html || c.contains(\":\") && (!html5 || !c.contains(\"html:\"))) cdata.add(c);\n      }\n\n      if(undecl && ver.equals(V10)) throw SERUNDECL.getIO();\n      if(xml) {\n        if(omitDecl) {\n          if(!saomit || !ver.equals(V10) && docsys != null) throw SERSTAND.getIO();\n        } else {\n          print(PI_O);\n          print(DOCDECL1);\n          print(ver);\n          print(DOCDECL2);\n          print(opts.get(ENCODING));\n          if(!saomit) {\n            print(DOCDECL3);\n            print(sa.toString());\n          }\n          print(ATT2);\n          print(PI_C);\n          sep = true;\n        }\n      }\n    }\n\n    // open results element\n    if(wrap) {\n      startElement(concat(wPre, COLON, T_RESULTS));\n      namespace(wPre, token(opts.get(WRAP_URI)));\n    }\n  }","id":72594,"modified_method":"/**\n   * Constructor.\n   * @param os output stream reference\n   * @param sopts serialization parameters\n   * @param versions supported versions\n   * @throws IOException I/O exception\n   */\n  protected OutputSerializer(final OutputStream os, final SerializerOptions sopts,\n      final String... versions) throws IOException {\n\n    final SerializerOptions opts = sopts == null ? OPTIONS : sopts;\n    final String ver = supported(VERSION, opts, versions);\n    final String htmlver = supported(HTML_VERSION, opts, V40, V401, V50);\n    html5 = htmlver.equals(V50) || ver.equals(V50);\n\n    final boolean omitDecl = opts.yes(OMIT_XML_DECLARATION);\n    final boolean bom  = opts.yes(BYTE_ORDER_MARK);\n    final YesNoOmit sa = opts.get(STANDALONE);\n    saomit = sa == YesNoOmit.OMIT;\n\n    final String maps = opts.get(USE_CHARACTER_MAPS);\n    final String enc = normEncoding(opts.get(ENCODING), true);\n    try {\n      encoding = Charset.forName(enc);\n    } catch(final Exception ex) {\n      throw SERENCODING.getIO(enc);\n    }\n    utf8 = enc == UTF8;\n    if(!utf8) {\n      encoder = encoding.newEncoder();\n      encbuffer = new TokenBuilder();\n    }\n\n    // project specific options\n    indents = opts.get(INDENTS);\n    format  = opts.yes(FORMAT);\n    tab     = opts.yes(TABULATOR) ? '\\t' : ' ';\n    wPre    = token(opts.get(WRAP_PREFIX));\n    wrap    = wPre.length != 0;\n\n    nl = utf8(token(opts.get(NEWLINE).newline()), enc);\n    itemsep = opts.contains(ITEM_SEPARATOR) ? token(opts.get(ITEM_SEPARATOR).replace(\"\\\\n\", \"\\n\").\n        replace(\"\\\\r\", \"\\r\").replace(\"\\\\t\", \"\\t\")) : null;\n\n    docsys  = opts.get(DOCTYPE_SYSTEM);\n    docpub  = opts.get(DOCTYPE_PUBLIC);\n    media   = opts.get(MEDIA_TYPE);\n    escuri  = opts.yes(ESCAPE_URI_ATTRIBUTES);\n    content = opts.yes(INCLUDE_CONTENT_TYPE);\n    undecl  = opts.yes(UNDECLARE_PREFIXES);\n    indent  = opts.yes(INDENT) && format;\n\n    webdav = \"webdav\".equals(maps);\n    if(!webdav && !maps.isEmpty()) throw SERMAP.getIO(maps);\n\n    if(docsys.isEmpty()) docsys = null;\n    if(docpub.isEmpty()) docpub = null;\n\n    // print byte-order-mark\n    out = PrintOutput.get(os);\n    out.setLimit(opts.get(LIMIT));\n\n    if(bom) {\n      // comparison by reference\n      if(enc == UTF8) {\n        out.write(0xEF); out.write(0xBB); out.write(0xBF);\n      } else if(enc == UTF16LE) {\n        out.write(0xFF); out.write(0xFE);\n      } else if(enc == UTF16BE) {\n        out.write(0xFE); out.write(0xFF);\n      }\n    }\n\n    final String supp = opts.get(SUPPRESS_INDENTATION);\n    if(!supp.isEmpty()) {\n      for(final String c : supp.split(\"\\\\s+\")) {\n        if(!c.isEmpty()) suppress.add(c);\n      }\n    }\n\n    // collect CData elements\n    final boolean html = this instanceof HTMLSerializer;\n    final boolean xml = this instanceof XMLSerializer || this instanceof XHTMLSerializer;\n    if(xml || html) {\n      final String cdse = opts.get(CDATA_SECTION_ELEMENTS);\n      for(final String c : cdse.split(\"\\\\s+\")) {\n        if(c.isEmpty()) continue;\n        if(!html || c.contains(\":\") && (!html5 || !c.contains(\"html:\"))) cdata.add(c);\n      }\n\n      if(undecl && ver.equals(V10)) throw SERUNDECL.getIO();\n      if(xml) {\n        if(omitDecl) {\n          if(!saomit || !ver.equals(V10) && docsys != null) throw SERSTAND.getIO();\n        } else {\n          print(PI_O);\n          print(DOCDECL1);\n          print(ver);\n          print(DOCDECL2);\n          print(opts.get(ENCODING));\n          if(!saomit) {\n            print(DOCDECL3);\n            print(sa.toString());\n          }\n          print(ATT2);\n          print(PI_C);\n          sep = true;\n        }\n      }\n    }\n\n    // open results element\n    if(wrap) {\n      startElement(concat(wPre, COLON, T_RESULTS));\n      namespace(wPre, token(opts.get(WRAP_URI)));\n    }\n  }","commit_id":"2e0ab8e0063343d3d892f5f155dbeefb73d245d8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Serializes the specified nodes.\n   * @param n nodes to display\n   */\n  private void setText(final Nodes n) {\n    if(visible()) {\n      try {\n        final ArrayOutput ao = new ArrayOutput().max(gui.gopts.get(GUIOptions.MAXTEXT));\n        if(n != null) n.serialize(Serializer.get(ao));\n        setText(ao);\n        cmd = null;\n        ns = ao.finished() ? n : null;\n      } catch(final IOException ex) {\n        Util.debug(ex);\n      }\n    } else {\n      home.setEnabled(gui.context.data() != null);\n    }\n  }","id":72595,"modified_method":"/**\n   * Serializes the specified nodes.\n   * @param n nodes to display\n   */\n  private void setText(final Nodes n) {\n    if(visible()) {\n      try {\n        final ArrayOutput ao = new ArrayOutput();\n        ao.setLimit(gui.gopts.get(GUIOptions.MAXTEXT));\n        if(n != null) n.serialize(Serializer.get(ao));\n        setText(ao);\n        cmd = null;\n        ns = ao.finished() ? n : null;\n      } catch(final IOException ex) {\n        Util.debug(ex);\n      }\n    } else {\n      home.setEnabled(gui.context.data() != null);\n    }\n  }","commit_id":"2e0ab8e0063343d3d892f5f155dbeefb73d245d8","url":"https://github.com/BaseXdb/basex"},{"original_method":"public GccTool getAssembler() {\n        return new DefaultTool(ToolType.ASSEMBLER);\n    }","id":72596,"modified_method":"public GccTool getAssembler() {\n        return getTool(ToolType.ASSEMBLER);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public GccTool getCCompiler() {\n        return new DefaultTool(ToolType.C_COMPILER);\n    }","id":72597,"modified_method":"public GccTool getCCompiler() {\n        return getTool(ToolType.C_COMPILER);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public GccTool getLinker() {\n        return new DefaultTool(ToolType.LINKER);\n    }","id":72598,"modified_method":"public GccTool getLinker() {\n        return getTool(ToolType.LINKER);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public GccTool getStaticLibArchiver() {\n        return new DefaultTool(ToolType.STATIC_LIB_ARCHIVER);\n    }","id":72599,"modified_method":"public GccTool getStaticLibArchiver() {\n        return getTool(ToolType.STATIC_LIB_ARCHIVER);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public void path(Object... pathEntries) {\n        for (Object path : pathEntries) {\n            tools.path(resolve(path));\n        }\n    }","id":72600,"modified_method":"public void path(Object... pathEntries) {\n        for (Object path : pathEntries) {\n            toolSearchPath.path(resolve(path));\n        }\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public GccTool getCppCompiler() {\n        return new DefaultTool(ToolType.CPP_COMPILER);\n    }","id":72601,"modified_method":"public GccTool getCppCompiler() {\n        return getTool(ToolType.CPP_COMPILER);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"protected void initTools(ToolChainAvailability availability) {\n        for (ToolType type : ToolType.values()) {\n            tools.locate(type);\n        }\n        boolean found = false;\n        for (ToolType type : Arrays.asList(ToolType.C_COMPILER, ToolType.CPP_COMPILER, ToolType.OBJECTIVEC_COMPILER, ToolType.OBJECTIVECPP_COMPILER)) {\n            found |= tools.locate(type).isAvailable();\n        }\n        if (!found) {\n            availability.mustBeAvailable(tools.locate(ToolType.C_COMPILER));\n        }\n    }","id":72602,"modified_method":"protected void initTools(ToolChainAvailability availability) {\n        for (ToolType type : ToolType.values()) {\n            locate(type);\n        }\n        boolean found = false;\n        for (ToolType type : Arrays.asList(ToolType.C_COMPILER, ToolType.CPP_COMPILER, ToolType.OBJECTIVEC_COMPILER, ToolType.OBJECTIVECPP_COMPILER)) {\n            found |= locate(type).isAvailable();\n        }\n        if (!found) {\n            availability.mustBeAvailable(locate(ToolType.C_COMPILER));\n        }\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public GccTool getcCompiler() {\n        return new DefaultTool(ToolType.C_COMPILER);\n    }","id":72603,"modified_method":"public GccTool getcCompiler() {\n        return getTool(ToolType.C_COMPILER);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public List<File> getPath() {\n        return tools.getPath();\n    }","id":72604,"modified_method":"public List<File> getPath() {\n        return toolSearchPath.getPath();\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public AbstractGccCompatibleToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory, ToolRegistry tools) {\n        super(name, operatingSystem, fileResolver);\n        this.execActionFactory = execActionFactory;\n        this.tools = tools;\n\n        addPlatformConfiguration(new ToolChainDefaultArchitecture());\n        addPlatformConfiguration(new Intel32Architecture());\n        addPlatformConfiguration(new Intel64Architecture());\n        configInsertLocation = 0;\n    }","id":72605,"modified_method":"public AbstractGccCompatibleToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory, ToolSearchPath toolSearchPath) {\n        super(name, operatingSystem, fileResolver);\n        this.execActionFactory = execActionFactory;\n        this.toolSearchPath = toolSearchPath;\n\n        addPlatformConfiguration(new ToolChainDefaultArchitecture());\n        addPlatformConfiguration(new Intel32Architecture());\n        addPlatformConfiguration(new Intel64Architecture());\n        configInsertLocation = 0;\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public PlatformToolChain target(Platform targetPlatform) {\n        TargetPlatformConfiguration platformConfiguration = getPlatformConfiguration(targetPlatform);\n        ToolChainAvailability result = new ToolChainAvailability();\n        if (platformConfiguration == null) {\n            result.unavailable(String.format(\"Don't know how to build for platform '%s'.\", targetPlatform.getName()));\n            return new UnavailablePlatformToolChain(result);\n        }\n        initTools(result);\n        if (!result.isAvailable()) {\n            return new UnavailablePlatformToolChain(result);\n        }\n\n        return new GccPlatformToolChain(tools, execActionFactory, platformConfiguration, canUseCommandFile());\n    }","id":72606,"modified_method":"public PlatformToolChain target(Platform targetPlatform) {\n        TargetPlatformConfiguration platformConfiguration = getPlatformConfiguration(targetPlatform);\n        ToolChainAvailability result = new ToolChainAvailability();\n        if (platformConfiguration == null) {\n            result.unavailable(String.format(\"Don't know how to build for platform '%s'.\", targetPlatform.getName()));\n            return new UnavailablePlatformToolChain(result);\n        }\n        initTools(result);\n        if (!result.isAvailable()) {\n            return new UnavailablePlatformToolChain(result);\n        }\n\n        // Target the tools for the platform\n        ToolRegistry platformTools = new PlatformToolRegistry(toolRegistry, platformConfiguration);\n        return new GccPlatformToolChain(toolSearchPath, platformTools, execActionFactory, canUseCommandFile());\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public ArStaticLibraryArchiver(CommandLineTool<StaticLibraryArchiverSpec> commandLineTool, Action<List<String>> argsAction) {\n        ArgsTransformer<StaticLibraryArchiverSpec> arguments = new ArchiverSpecToArguments();\n        arguments = new UserArgsTransformer<StaticLibraryArchiverSpec>(arguments, argsAction);\n        this.commandLineTool = commandLineTool.withArguments(arguments);\n    }","id":72607,"modified_method":"public ArStaticLibraryArchiver(CommandLineTool<StaticLibraryArchiverSpec> commandLineTool, Action<List<String>> argsAction) {\n        ArgsTransformer<StaticLibraryArchiverSpec> arguments = new ArchiverSpecToArguments();\n        arguments = new PostTransformActionArgsTransformer<StaticLibraryArchiverSpec>(arguments, argsAction);\n        this.commandLineTool = commandLineTool.withArguments(arguments);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public WorkResult execute(AssembleSpec spec) {\n        boolean didWork = false;\n        CommandLineTool<AssembleSpec> commandLineAssembler = commandLineTool.inWorkDirectory(spec.getObjectFileDir());\n        for (File sourceFile : spec.getSourceFiles()) {\n            ArgsTransformer<AssembleSpec> arguments = new AssembleSpecToArgsList(sourceFile, spec.getObjectFileDir(), outputFileSuffix);\n            arguments = new UserArgsTransformer<AssembleSpec>(arguments, argsAction);\n            WorkResult result = commandLineAssembler.withArguments(arguments).execute(spec);\n            didWork = didWork || result.getDidWork();\n        }\n        return new SimpleWorkResult(didWork);\n    }","id":72608,"modified_method":"public WorkResult execute(AssembleSpec spec) {\n        boolean didWork = false;\n        CommandLineTool<AssembleSpec> commandLineAssembler = commandLineTool.inWorkDirectory(spec.getObjectFileDir());\n        for (File sourceFile : spec.getSourceFiles()) {\n            ArgsTransformer<AssembleSpec> arguments = new AssembleSpecToArgsList(sourceFile, spec.getObjectFileDir(), outputFileSuffix);\n            arguments = new PostTransformActionArgsTransformer<AssembleSpec>(arguments, argsAction);\n            WorkResult result = commandLineAssembler.withArguments(arguments).execute(spec);\n            didWork = didWork || result.getDidWork();\n        }\n        return new SimpleWorkResult(didWork);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public CCompiler(CommandLineTool<CCompileSpec> commandLineTool, Action<List<String>> argsAction, boolean useCommandFile) {\n        super(commandLineTool, argsAction, new CCompileArgsTransformer(), useCommandFile);\n    }","id":72609,"modified_method":"public CCompiler(CommandLineTool<CCompileSpec> commandLineTool, Action<List<String>> toolChainArgsAction, boolean useCommandFile) {\n        super(commandLineTool, toolChainArgsAction, new CCompileArgsTransformer(), useCommandFile);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public ClangToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory) {\n        super(name, operatingSystem, fileResolver, execActionFactory, new ToolRegistry(operatingSystem));\n\n        tools.setExeName(ToolType.CPP_COMPILER, \"clang++\");\n        tools.setExeName(ToolType.C_COMPILER, \"clang\");\n        tools.setExeName(ToolType.OBJECTIVECPP_COMPILER, \"clang++\");\n        tools.setExeName(ToolType.OBJECTIVEC_COMPILER, \"clang\");\n        tools.setExeName(ToolType.ASSEMBLER, \"as\");\n        tools.setExeName(ToolType.LINKER, \"clang++\");\n        tools.setExeName(ToolType.STATIC_LIB_ARCHIVER, \"ar\");\n    }","id":72610,"modified_method":"public ClangToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory) {\n        super(name, operatingSystem, fileResolver, execActionFactory, new ToolSearchPath(operatingSystem));\n\n        registerTool(ToolType.CPP_COMPILER, \"clang++\");\n        registerTool(ToolType.C_COMPILER, \"clang\");\n        registerTool(ToolType.OBJECTIVECPP_COMPILER, \"clang++\");\n        registerTool(ToolType.OBJECTIVEC_COMPILER, \"clang\");\n        registerTool(ToolType.ASSEMBLER, \"as\");\n        registerTool(ToolType.LINKER, \"clang++\");\n        registerTool(ToolType.STATIC_LIB_ARCHIVER, \"ar\");\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public CppCompiler(CommandLineTool<CppCompileSpec> commandLineTool, Action<List<String>> argsAction, boolean useCommandFile) {\n        super(commandLineTool, argsAction, new CppCompileArgsTransformer(), useCommandFile);\n\n    }","id":72611,"modified_method":"public CppCompiler(CommandLineTool<CppCompileSpec> commandLineTool, Action<List<String>> toolChainArgsAction, boolean useCommandFile) {\n        super(commandLineTool, toolChainArgsAction, new CppCompileArgsTransformer(), useCommandFile);\n\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public GccLinker(CommandLineTool<LinkerSpec> commandLineTool, Action<List<String>> argsAction, boolean useCommandFile) {\n        ArgsTransformer<LinkerSpec> argsTransformer = new GccLinkerArgsTransformer();\n        argsTransformer = new UserArgsTransformer<LinkerSpec>(argsTransformer, argsAction);\n        if (useCommandFile) {\n            argsTransformer = new GccOptionsFileArgTransformer<LinkerSpec>(argsTransformer);\n        }\n        this.commandLineTool = commandLineTool.withArguments(argsTransformer);\n    }","id":72612,"modified_method":"public GccLinker(CommandLineTool<LinkerSpec> commandLineTool, Action<List<String>> argsAction, boolean useCommandFile) {\n        ArgsTransformer<LinkerSpec> argsTransformer = new GccLinkerArgsTransformer();\n        argsTransformer = new PostTransformActionArgsTransformer<LinkerSpec>(argsTransformer, argsAction);\n        if (useCommandFile) {\n            argsTransformer = new GccOptionsFileArgTransformer<LinkerSpec>(argsTransformer);\n        }\n        this.commandLineTool = commandLineTool.withArguments(argsTransformer);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"private <T extends BinaryToolSpec> CommandLineTool<T> commandLineTool(ToolType key) {\n        CommandLineTool<T> commandLineTool = new CommandLineTool<T>(key.getToolName(), tools.locate(key).getTool(), execActionFactory);\n        // MinGW requires the path to be set\n        commandLineTool.withPath(tools.getPath());\n        commandLineTool.withEnvironmentVar(\"CYGWIN\", \"nodosfilewarning\");\n        return commandLineTool;\n    }","id":72613,"modified_method":"private <T extends BinaryToolSpec> CommandLineTool<T> commandLineTool(ToolType key) {\n        String exeName = toolRegistry.getTool(key).getExecutable();\n        CommandLineTool<T> commandLineTool = new CommandLineTool<T>(key.getToolName(), toolSearchPath.locate(key, exeName).getTool(), execActionFactory);\n        // MinGW requires the path to be set\n        commandLineTool.withPath(toolSearchPath.getPath());\n        commandLineTool.withEnvironmentVar(\"CYGWIN\", \"nodosfilewarning\");\n        return commandLineTool;\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends LinkerSpec> Compiler<T> createLinker() {\n        CommandLineTool<LinkerSpec> commandLineTool = commandLineTool(ToolType.LINKER);\n        commandLineTool.withSpecTransformer(withSystemArgs(LinkerSpec.class, platformConfiguration.getLinkerArgs()));\n        return (Compiler<T>) new GccLinker(commandLineTool, tools.getArgTransformer(ToolType.LINKER), useCommandFile);\n    }","id":72614,"modified_method":"public <T extends LinkerSpec> Compiler<T> createLinker() {\n        CommandLineTool<LinkerSpec> commandLineTool = commandLineTool(ToolType.LINKER);\n        return (Compiler<T>) new GccLinker(commandLineTool, toolRegistry.getTool(ToolType.LINKER).getArgAction(), useCommandFile);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends BinaryToolSpec> Compiler<T> createObjectiveCCompiler() {\n        CommandLineTool<ObjectiveCCompileSpec> commandLineTool = commandLineTool(ToolType.OBJECTIVEC_COMPILER);\n        commandLineTool.withSpecTransformer(withSystemArgs(ObjectiveCCompileSpec.class, platformConfiguration.getObjectiveCCompilerArgs()));\n        ObjectiveCCompiler objectiveCCompiler = new ObjectiveCCompiler(commandLineTool, tools.getArgTransformer(ToolType.OBJECTIVEC_COMPILER), useCommandFile);\n        return (Compiler<T>) new OutputCleaningCompiler<ObjectiveCCompileSpec>(objectiveCCompiler, getOutputFileSuffix());\n    }","id":72615,"modified_method":"public <T extends BinaryToolSpec> Compiler<T> createObjectiveCCompiler() {\n        CommandLineTool<ObjectiveCCompileSpec> commandLineTool = commandLineTool(ToolType.OBJECTIVEC_COMPILER);\n        ObjectiveCCompiler objectiveCCompiler = new ObjectiveCCompiler(commandLineTool, toolRegistry.getTool(ToolType.OBJECTIVEC_COMPILER).getArgAction(), useCommandFile);\n        return (Compiler<T>) new OutputCleaningCompiler<ObjectiveCCompileSpec>(objectiveCCompiler, getOutputFileSuffix());\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends BinaryToolSpec> Compiler<T> createCppCompiler() {\n        CommandLineTool<CppCompileSpec> commandLineTool = commandLineTool(ToolType.CPP_COMPILER);\n        commandLineTool.withSpecTransformer(withSystemArgs(CppCompileSpec.class, platformConfiguration.getCppCompilerArgs()));\n        CppCompiler cppCompiler = new CppCompiler(commandLineTool, tools.getArgTransformer(ToolType.CPP_COMPILER), useCommandFile);\n        return (Compiler<T>) new OutputCleaningCompiler<CppCompileSpec>(cppCompiler, getOutputFileSuffix());\n    }","id":72616,"modified_method":"public <T extends BinaryToolSpec> Compiler<T> createCppCompiler() {\n        CommandLineTool<CppCompileSpec> commandLineTool = commandLineTool(ToolType.CPP_COMPILER);\n        CppCompiler cppCompiler = new CppCompiler(commandLineTool, toolRegistry.getTool(ToolType.CPP_COMPILER).getArgAction(), useCommandFile);\n        return (Compiler<T>) new OutputCleaningCompiler<CppCompileSpec>(cppCompiler, getOutputFileSuffix());\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends BinaryToolSpec> Compiler<T> createAssembler() {\n        CommandLineTool<AssembleSpec> commandLineTool = commandLineTool(ToolType.ASSEMBLER);\n        commandLineTool.withSpecTransformer(withSystemArgs(AssembleSpec.class, platformConfiguration.getAssemblerArgs()));\n        return (Compiler<T>) new Assembler(commandLineTool, tools.getArgTransformer(ToolType.ASSEMBLER), getOutputFileSuffix());\n    }","id":72617,"modified_method":"public <T extends BinaryToolSpec> Compiler<T> createAssembler() {\n        CommandLineTool<AssembleSpec> commandLineTool = commandLineTool(ToolType.ASSEMBLER);\n        return (Compiler<T>) new Assembler(commandLineTool, toolRegistry.getTool(ToolType.ASSEMBLER).getArgAction(), getOutputFileSuffix());\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"GccPlatformToolChain(ToolRegistry tools, ExecActionFactory execActionFactory, TargetPlatformConfiguration platformConfiguration, boolean useCommandFile) {\n        this.execActionFactory = execActionFactory;\n        this.tools = tools;\n        this.platformConfiguration = platformConfiguration;\n        this.useCommandFile = useCommandFile;\n    }","id":72618,"modified_method":"GccPlatformToolChain(ToolSearchPath toolSearchPath, ToolRegistry toolRegistry, ExecActionFactory execActionFactory, boolean useCommandFile) {\n        this.toolRegistry = toolRegistry;\n        this.toolSearchPath = toolSearchPath;\n        this.execActionFactory = execActionFactory;\n        this.useCommandFile = useCommandFile;\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends StaticLibraryArchiverSpec> Compiler<T> createStaticLibraryArchiver() {\n        CommandLineTool<StaticLibraryArchiverSpec> commandLineTool = commandLineTool(ToolType.STATIC_LIB_ARCHIVER);\n        commandLineTool.withSpecTransformer(withSystemArgs(StaticLibraryArchiverSpec.class, platformConfiguration.getStaticLibraryArchiverArgs()));\n        return (Compiler<T>) new ArStaticLibraryArchiver(commandLineTool, tools.getArgTransformer(ToolType.STATIC_LIB_ARCHIVER));\n    }","id":72619,"modified_method":"public <T extends StaticLibraryArchiverSpec> Compiler<T> createStaticLibraryArchiver() {\n        CommandLineTool<StaticLibraryArchiverSpec> commandLineTool = commandLineTool(ToolType.STATIC_LIB_ARCHIVER);\n            return (Compiler<T>) new ArStaticLibraryArchiver(commandLineTool, toolRegistry.getTool(ToolType.STATIC_LIB_ARCHIVER).getArgAction());\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends BinaryToolSpec> Compiler<T> createCCompiler() {\n        CommandLineTool<CCompileSpec> commandLineTool = commandLineTool(ToolType.C_COMPILER);\n        commandLineTool.withSpecTransformer(withSystemArgs(CCompileSpec.class, platformConfiguration.getCCompilerArgs()));\n        CCompiler cCompiler = new CCompiler(commandLineTool, tools.getArgTransformer(ToolType.C_COMPILER), useCommandFile);\n        return (Compiler<T>) new OutputCleaningCompiler<CCompileSpec>(cCompiler, getOutputFileSuffix());\n    }","id":72620,"modified_method":"public <T extends BinaryToolSpec> Compiler<T> createCCompiler() {\n        CommandLineTool<CCompileSpec> commandLineTool = commandLineTool(ToolType.C_COMPILER);\n        CCompiler cCompiler = new CCompiler(commandLineTool, toolRegistry.getTool(ToolType.C_COMPILER).getArgAction(), useCommandFile);\n        return (Compiler<T>) new OutputCleaningCompiler<CCompileSpec>(cCompiler, getOutputFileSuffix());\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public <T extends BinaryToolSpec> Compiler<T> createObjectiveCppCompiler() {\n        CommandLineTool<ObjectiveCppCompileSpec> commandLineTool = commandLineTool(ToolType.OBJECTIVECPP_COMPILER);\n        commandLineTool.withSpecTransformer(withSystemArgs(ObjectiveCppCompileSpec.class, platformConfiguration.getObjectiveCppCompilerArgs()));\n        ObjectiveCppCompiler objectiveCppCompiler = new ObjectiveCppCompiler(commandLineTool, tools.getArgTransformer(ToolType.OBJECTIVECPP_COMPILER), useCommandFile);\n        return (Compiler<T>) new OutputCleaningCompiler<ObjectiveCppCompileSpec>(objectiveCppCompiler, getOutputFileSuffix());\n    }","id":72621,"modified_method":"public <T extends BinaryToolSpec> Compiler<T> createObjectiveCppCompiler() {\n        CommandLineTool<ObjectiveCppCompileSpec> commandLineTool = commandLineTool(ToolType.OBJECTIVECPP_COMPILER);\n        ObjectiveCppCompiler objectiveCppCompiler = new ObjectiveCppCompiler(commandLineTool, toolRegistry.getTool(ToolType.OBJECTIVECPP_COMPILER).getArgAction(), useCommandFile);\n        return (Compiler<T>) new OutputCleaningCompiler<ObjectiveCppCompileSpec>(objectiveCppCompiler, getOutputFileSuffix());\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public GccToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory) {\n        super(name, operatingSystem, fileResolver, execActionFactory, new GccToolRegistry(operatingSystem));\n        this.versionDeterminer = new GccVersionDeterminer(execActionFactory);\n\n        tools.setExeName(ToolType.CPP_COMPILER, \"g++\");\n        tools.setExeName(ToolType.C_COMPILER, \"gcc\");\n        tools.setExeName(ToolType.OBJECTIVECPP_COMPILER, \"g++\");\n        tools.setExeName(ToolType.OBJECTIVEC_COMPILER, \"gcc\");\n        tools.setExeName(ToolType.ASSEMBLER, \"as\");\n        tools.setExeName(ToolType.LINKER, \"g++\");\n        tools.setExeName(ToolType.STATIC_LIB_ARCHIVER, \"ar\");\n    }","id":72622,"modified_method":"public GccToolChain(String name, OperatingSystem operatingSystem, FileResolver fileResolver, ExecActionFactory execActionFactory) {\n        super(name, operatingSystem, fileResolver, execActionFactory, new GccToolSearchPath(operatingSystem));\n        this.versionDeterminer = new GccVersionDeterminer(execActionFactory);\n\n        registerTool(ToolType.CPP_COMPILER, \"g++\");\n        registerTool(ToolType.C_COMPILER, \"gcc\");\n        registerTool(ToolType.OBJECTIVECPP_COMPILER, \"g++\");\n        registerTool(ToolType.OBJECTIVEC_COMPILER, \"gcc\");\n        registerTool(ToolType.ASSEMBLER, \"as\");\n        registerTool(ToolType.LINKER, \"g++\");\n        registerTool(ToolType.STATIC_LIB_ARCHIVER, \"ar\");\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void initTools(ToolChainAvailability availability) {\n        if (versionResult == null) {\n            CommandLineToolSearchResult compiler = tools.locate(ToolType.C_COMPILER);\n            if (!compiler.isAvailable()) {\n                compiler = tools.locate(ToolType.CPP_COMPILER);\n            }\n            availability.mustBeAvailable(compiler);\n            if (!compiler.isAvailable()) {\n                return;\n            }\n            versionResult = versionDeterminer.transform(compiler.getTool());\n            LOGGER.debug(\"Found {} with version {}\", ToolType.C_COMPILER.getToolName(), versionResult);\n        }\n        availability.mustBeAvailable(versionResult);\n    }","id":72623,"modified_method":"@Override\n    protected void initTools(ToolChainAvailability availability) {\n        if (versionResult == null) {\n            CommandLineToolSearchResult compiler = locate(ToolType.C_COMPILER);\n            if (!compiler.isAvailable()) {\n                compiler = locate(ToolType.CPP_COMPILER);\n            }\n            availability.mustBeAvailable(compiler);\n            if (!compiler.isAvailable()) {\n                return;\n            }\n            versionResult = versionDeterminer.transform(compiler.getTool());\n            LOGGER.debug(\"Found {} with version {}\", ToolType.C_COMPILER.getToolName(), versionResult);\n        }\n        availability.mustBeAvailable(versionResult);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public NativeCompiler(CommandLineTool<T> commandLineTool, Action<List<String>> argsAction, ArgsTransformer<T> argsTransformer, boolean useCommandFile) {\n        argsTransformer = new UserArgsTransformer<T>(argsTransformer, argsAction);\n        if (useCommandFile) {\n            argsTransformer = new GccOptionsFileArgTransformer<T>(argsTransformer);\n        }\n        this.argsTransfomer = argsTransformer;\n        this.commandLineTool = commandLineTool;\n    }","id":72624,"modified_method":"public NativeCompiler(CommandLineTool<T> commandLineTool, Action<List<String>> toolChainArgsAction, ArgsTransformer<T> argsTransformer, boolean useCommandFile) {\n        argsTransformer = new PostTransformActionArgsTransformer<T>(argsTransformer, toolChainArgsAction);\n        if (useCommandFile) {\n            argsTransformer = new GccOptionsFileArgTransformer<T>(argsTransformer);\n        }\n        this.argsTransfomer = argsTransformer;\n        this.commandLineTool = commandLineTool;\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public ObjectiveCCompiler(CommandLineTool<ObjectiveCCompileSpec> commandLineTool, Action<List<String>> argsAction, boolean useCommandFile) {\n        super(commandLineTool, argsAction, new ObjectiveCCompileArgsTransformer(), useCommandFile);\n    }","id":72625,"modified_method":"public ObjectiveCCompiler(CommandLineTool<ObjectiveCCompileSpec> commandLineTool, Action<List<String>> toolChainArgsAction, boolean useCommandFile) {\n        super(commandLineTool, toolChainArgsAction, new ObjectiveCCompileArgsTransformer(), useCommandFile);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public ObjectiveCppCompiler(CommandLineTool<ObjectiveCppCompileSpec> commandLineTool, Action<List<String>> argsAction, boolean useCommandFile) {\n        super(commandLineTool, argsAction, new ObjectiveCppCompileArgsTransformer(), useCommandFile);\n    }","id":72626,"modified_method":"public ObjectiveCppCompiler(CommandLineTool<ObjectiveCppCompileSpec> commandLineTool, Action<List<String>> toolChainArgsAction, boolean useCommandFile) {\n        super(commandLineTool, toolChainArgsAction, new ObjectiveCppCompileArgsTransformer(), useCommandFile);\n    }","commit_id":"a0a9a105dbde7d5b72b3f63341f1ccd5cb4c4883","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean send() {\n\t\tfinal PacketThrottle throttle = PacketThrottle.getThrottle(_destination.getPeer(), _prb._packetSize);\n\t\t_receiverThread = Thread.currentThread();\n\t\t_senderThread = new Thread() {\n\t\t    \n\t\t\tpublic void run() {\n\t\t\t\tint sentSinceLastPing = 0;\n\t\t\t\twhile (!_sendComplete) {\n\t\t\t\t\t\tlong waitUntil = System.currentTimeMillis() + throttle.getDelay();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (waitUntil > System.currentTimeMillis()) {\n\t\t\t\t\t\t\t\tsynchronized (_senderThread) {\n\t\t\t\t\t\t\t\t_senderThread.wait(waitUntil - System.currentTimeMillis());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (_unsent.size() == 0) {\n\t\t\t\t\t\t\t\tsynchronized (_senderThread) {\n\t\t\t\t\t\t\t\t\t_senderThread.wait();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException e) {  }\n\t\t\t\t\t\tint packetNo = ((Integer) _unsent.removeFirst()).intValue();\n\t\t\t\t\t\t_sentPackets.setBit(packetNo, true);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t_usm.send(BlockTransmitter.this._destination, DMT.createPacketTransmit(_uid, packetNo, _sentPackets, _prb.getPacket(packetNo)));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// We accelerate the ping rate during the transfer to keep a closer eye on round-trip-time\n\t\t\t\t\t\tsentSinceLastPing++;\n\t\t\t\t\t\tif (sentSinceLastPing >= PING_EVERY) {\n\t\t\t\t\t\t\tsentSinceLastPing = 0;\n\t\t\t\t\t\t\t_usm.send(BlockTransmitter.this._destination, DMT.createPing());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t\t\t    Logger.normal(this, \"Terminating send: \"+e);\n\t\t\t\t\t\t    _sendComplete = true;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\t_unsent = _prb.addListener(new PartiallyReceivedBlock.PacketReceivedListener() {;\n\n\t\t\tpublic void packetReceived(int packetNo) {\n\t\t\t\t_unsent.addLast(new Integer(packetNo));\n\t\t\t\t_sentPackets.setBit(packetNo, false);\n\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t_senderThread.notify();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void receiveAborted(int reason, String description) {\n\t\t\t\ttry {\n                    _usm.send(_destination, DMT.createSendAborted(reason, description));\n                } catch (NotConnectedException e) {\n                    Logger.minor(this, \"Receive aborted and receiver is not connected\");\n                }\n\t\t\t} });\n\n\t\t_senderThread.start();\n\t\t\n\t\twhile (true) {\n\t\t\tif (_prb.isAborted()) {\n\t\t\t\t_sendComplete = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tMessage msg;\n\t\t\ttry {\n                msg = _usm.waitFor(MessageFilter.create().setTimeout(SEND_TIMEOUT).setType(DMT.missingPacketNotification).setField(DMT.UID, _uid).or(MessageFilter.create().setType(DMT.allReceived).setField(DMT.UID, _uid)));\n            } catch (DisconnectedException e) {\n                Logger.normal(this, \"Terminating send \"+_uid+\" to \"+_destination+\" from \"+_usm.getPortNumber()+\" because node disconnected while waiting\");\n                _sendComplete = true;\n                return false;\n            }\n\t\t\tif (msg == null) {\n\t\t\t\tif (getNumSent() == _prb.getNumPackets()) {\n\t\t\t\t\t_sendComplete = true;\n\t\t\t\t\tLogger.error(this, \"Terminating send \"+_uid+\" to \"+_destination+\" from \"+_usm.getPortNumber()+\" as we haven't heard from receiver in \"+SEND_TIMEOUT+\"ms.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (msg.getSpec().equals(DMT.missingPacketNotification)) {\n\t\t\t\tLinkedList missing = (LinkedList) msg.getObject(DMT.MISSING);\n\t\t\t\tfor (Iterator i = missing.iterator(); i.hasNext();) {\n\t\t\t\t\tInteger packetNo = (Integer) i.next();\n\t\t\t\t\tif (_prb.isReceived(packetNo.intValue())) {\n\t\t\t\t\t    _unsent.addFirst(packetNo);\n\t\t\t\t\t    _sentPackets.setBit(packetNo.intValue(), false);\n\t\t\t\t\t    synchronized(_senderThread) {\n\t\t\t\t\t        _senderThread.notify();\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (msg.getSpec().equals(DMT.allReceived)) {\n\t\t\t\t_sendComplete = true;\n\t\t\t\treturn true;\n\t\t\t} else if(_sendComplete) {\n\t\t\t    // Terminated abnormally\n\t\t\t    return false;\n\t\t\t}\n\t\t}\t\t\n\t}","id":72627,"modified_method":"public boolean send() {\n\t\tfinal PacketThrottle throttle = PacketThrottle.getThrottle(_destination.getPeer(), _prb._packetSize);\n\t\t_receiverThread = Thread.currentThread();\n\t\t_senderThread = new Thread() {\n\t\t    \n\t\t\tpublic void run() {\n\t\t\t\tint sentSinceLastPing = 0;\n\t\t\t\twhile (!_sendComplete) {\n\t\t\t\t\t\tlong waitUntil = System.currentTimeMillis() + throttle.getDelay();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (waitUntil > System.currentTimeMillis()) {\n\t\t\t\t\t\t\t\tif(_sendComplete) return;\n\t\t\t\t\t\t\t\tsynchronized (_senderThread) {\n\t\t\t\t\t\t\t\t\t_senderThread.wait(waitUntil - System.currentTimeMillis());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (_unsent.size() == 0) {\n\t\t\t\t\t\t\t\tif(_sendComplete) return;\n\t\t\t\t\t\t\t\tsynchronized (_senderThread) {\n\t\t\t\t\t\t\t\t\t_senderThread.wait();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException e) {  }\n\t\t\t\t\t\tint packetNo = ((Integer) _unsent.removeFirst()).intValue();\n\t\t\t\t\t\t_sentPackets.setBit(packetNo, true);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t_usm.send(BlockTransmitter.this._destination, DMT.createPacketTransmit(_uid, packetNo, _sentPackets, _prb.getPacket(packetNo)));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// We accelerate the ping rate during the transfer to keep a closer eye on round-trip-time\n\t\t\t\t\t\tsentSinceLastPing++;\n\t\t\t\t\t\tif (sentSinceLastPing >= PING_EVERY) {\n\t\t\t\t\t\t\tsentSinceLastPing = 0;\n\t\t\t\t\t\t\t_usm.send(BlockTransmitter.this._destination, DMT.createPing());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t\t\t    Logger.normal(this, \"Terminating send: \"+e);\n\t\t\t\t\t\t    _sendComplete = true;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\t_unsent = _prb.addListener(new PartiallyReceivedBlock.PacketReceivedListener() {;\n\n\t\t\tpublic void packetReceived(int packetNo) {\n\t\t\t\t_unsent.addLast(new Integer(packetNo));\n\t\t\t\t_sentPackets.setBit(packetNo, false);\n\t\t\t\tsynchronized(_senderThread) {\n\t\t\t\t\t_senderThread.notify();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void receiveAborted(int reason, String description) {\n\t\t\t\ttry {\n                    _usm.send(_destination, DMT.createSendAborted(reason, description));\n                } catch (NotConnectedException e) {\n                    Logger.minor(this, \"Receive aborted and receiver is not connected\");\n                }\n\t\t\t} });\n\n\t\t_senderThread.start();\n\t\t\n\t\twhile (true) {\n\t\t\tif (_prb.isAborted()) {\n\t\t\t\t_sendComplete = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tMessage msg;\n\t\t\ttry {\n                msg = _usm.waitFor(MessageFilter.create().setTimeout(SEND_TIMEOUT).setType(DMT.missingPacketNotification).setField(DMT.UID, _uid).or(MessageFilter.create().setType(DMT.allReceived).setField(DMT.UID, _uid)));\n            } catch (DisconnectedException e) {\n                Logger.normal(this, \"Terminating send \"+_uid+\" to \"+_destination+\" from \"+_usm.getPortNumber()+\" because node disconnected while waiting\");\n                _sendComplete = true;\n                return false;\n            }\n\t\t\tif (msg == null) {\n\t\t\t\tif (getNumSent() == _prb.getNumPackets()) {\n\t\t\t\t\t_sendComplete = true;\n\t\t\t\t\tLogger.error(this, \"Terminating send \"+_uid+\" to \"+_destination+\" from \"+_usm.getPortNumber()+\" as we haven't heard from receiver in \"+SEND_TIMEOUT+\"ms.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (msg.getSpec().equals(DMT.missingPacketNotification)) {\n\t\t\t\tLinkedList missing = (LinkedList) msg.getObject(DMT.MISSING);\n\t\t\t\tfor (Iterator i = missing.iterator(); i.hasNext();) {\n\t\t\t\t\tInteger packetNo = (Integer) i.next();\n\t\t\t\t\tif (_prb.isReceived(packetNo.intValue())) {\n\t\t\t\t\t    _unsent.addFirst(packetNo);\n\t\t\t\t\t    _sentPackets.setBit(packetNo.intValue(), false);\n\t\t\t\t\t    synchronized(_senderThread) {\n\t\t\t\t\t        _senderThread.notify();\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (msg.getSpec().equals(DMT.allReceived)) {\n\t\t\t\t_sendComplete = true;\n\t\t\t\treturn true;\n\t\t\t} else if(_sendComplete) {\n\t\t\t    // Terminated abnormally\n\t\t\t    return false;\n\t\t\t}\n\t\t}\t\t\n\t}","commit_id":"ce4d94febece5a78a721a37dadc388fc34b7b7ad","url":"https://github.com/freenet/fred"},{"original_method":"private FreenetURI waitForCompletion() throws InserterException {\n\t\tsynchronized(this) {\n\t\t\twhile(!allSegmentsFinished) {\n\t\t\t\ttry {\n\t\t\t\t\twait(10*1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Did we succeed?\n\t\t\n\t\tif(fatalErrors > 0) {\n\t\t\tthrow new InserterException(InserterException.FATAL_ERRORS_IN_BLOCKS, tracker.getAccumulatedFatalErrorCodes());\n\t\t}\n\t\t\n\t\tif(failed > 0) {\n\t\t\tthrow new InserterException(InserterException.TOO_MANY_RETRIES_IN_BLOCKS, tracker.getAccumulatedNonFatalErrorCodes());\n\t\t}\n\t\t\n\t\t// Okay, we succeeded... create the manifest\n\t\t\n\t\tMetadata metadata = new Metadata(splitfileAlgorithm, getDataURIs(), getCheckURIs(), clientMetadata, dataLength, compressionCodec);\n\t\t\n\t\tBucket mbucket;\n\t\ttry {\n\t\t\tmbucket = BucketTools.makeImmutableBucket(ctx.bf, metadata.writeToByteArray());\n\t\t} catch (IOException e) {\n\t\t\tthrow new InserterException(InserterException.BUCKET_ERROR);\n\t\t}\n\n\t\tif(inserter == null)\n\t\t\tinserter = new FileInserter(ctx);\n\t\t\n\t\tInsertBlock mblock = new InsertBlock(mbucket, clientMetadata, FreenetURI.EMPTY_CHK_URI);\n\t\t\n\t\treturn inserter.run(mblock, true, getCHKOnly);\n\t}","id":72628,"modified_method":"private FreenetURI waitForCompletion() throws InserterException {\n\t\ttracker.setFinishOnEmpty();\n\t\tsynchronized(this) {\n\t\t\twhile(!allSegmentsFinished) {\n\t\t\t\ttry {\n\t\t\t\t\twait(10*1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create the manifest (even if we failed, so that the key is visible)\n\n\t\tFreenetURI[] dataURIs = getDataURIs();\n\t\tFreenetURI[] checkURIs = getCheckURIs();\n\t\t\n\t\tboolean missingURIs = anyNulls(dataURIs) || anyNulls(checkURIs);\n\t\t\n\t\tif(missingURIs && fatalErrors == 0 && failed == 0)\n\t\t\tthrow new IllegalStateException();\n\t\t\n\t\tMetadata metadata = new Metadata(splitfileAlgorithm, dataURIs, checkURIs, clientMetadata, dataLength, compressionCodec);\n\t\t\n\t\tBucket mbucket;\n\t\ttry {\n\t\t\tmbucket = BucketTools.makeImmutableBucket(ctx.bf, metadata.writeToByteArray());\n\t\t} catch (IOException e) {\n\t\t\tthrow new InserterException(InserterException.BUCKET_ERROR);\n\t\t}\n\n\t\tif(inserter == null)\n\t\t\tinserter = new FileInserter(ctx);\n\t\t\n\t\tInsertBlock mblock = new InsertBlock(mbucket, clientMetadata, FreenetURI.EMPTY_CHK_URI);\n\n\t\t// FIXME probably should uncomment below so it doesn't get inserted at all?\n\t\t// FIXME this is a hack for small network support... but we will need that IRL... hmmm\n\t\tFreenetURI uri = inserter.run(mblock, true, getCHKOnly/* || (fatalErrors > 0 || failed > 0)*/);\n\t\t\n\t\t// Did we succeed?\n\t\t\n\t\tif(fatalErrors > 0) {\n\t\t\tthrow new InserterException(InserterException.FATAL_ERRORS_IN_BLOCKS, tracker.getAccumulatedFatalErrorCodes());\n\t\t}\n\t\t\n\t\tif(failed > 0) {\n\t\t\tthrow new InserterException(InserterException.TOO_MANY_RETRIES_IN_BLOCKS, tracker.getAccumulatedNonFatalErrorCodes());\n\t\t}\n\t\t\n\t\treturn uri;\n\t}","commit_id":"ce4d94febece5a78a721a37dadc388fc34b7b7ad","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public void onEvent(final Object event) {\n        if (event instanceof InternalTestProgressEvent) {\n            broadcastTestProgressEvent((InternalTestProgressEvent) event);\n        } else if (event instanceof InternalTaskProgressEvent) {\n            broadcastTaskProgressEvent((InternalTaskProgressEvent) event);\n        } else if (event instanceof InternalBuildProgressEvent) {\n            broadcastBuildProgressEvent((InternalBuildProgressEvent) event);\n        }\n    }","id":72629,"modified_method":"@Override\n    public void onEvent(final Object event) {\n        if (failsafeListeners) {\n            try {\n                doBroadcast(event);\n            } catch (Throwable e) {\n                listenerFailures.add(e);\n            }\n        } else {\n            doBroadcast(event);\n        }\n    }","commit_id":"cb83d94737a0e0677e5fefb66546634b74155aa1","url":"https://github.com/gradle/gradle"},{"original_method":"BuildProgressListenerAdapter(List<TestProgressListener> testListeners, List<TaskProgressListener> taskListeners, List<BuildProgressListener> buildListeners) {\n        this.testProgressListeners.addAll(testListeners);\n        this.taskProgressListeners.addAll(taskListeners);\n        this.buildProgressListeners.addAll(buildListeners);\n    }","id":72630,"modified_method":"BuildProgressListenerAdapter(BuildProgressListenerConfiguration configuration) {\n        this.testProgressListeners.addAll(configuration.getTestListeners());\n        this.taskProgressListeners.addAll(configuration.getTaskListeners());\n        this.buildProgressListeners.addAll(configuration.getBuildListeners());\n    }","commit_id":"cb83d94737a0e0677e5fefb66546634b74155aa1","url":"https://github.com/gradle/gradle"},{"original_method":"public ConsumerOperationParameters build() {\n            // create the listener adapters right when the ConsumerOperationParameters are instantiated but no earlier,\n            // this ensures that when multiple requests are issued that are built from the same builder, such requests do not share any state kept in the listener adapters\n            // e.g. if the listener adapters do per-request caching, such caching must not leak between different requests built from the same builder\n            ProgressListenerAdapter progressListenerAdapter = new ProgressListenerAdapter(this.progressListeners);\n            BuildProgressListenerAdapter buildProgressListenerAdapter = new BuildProgressListenerAdapter(this.testProgressListeners, this.taskProgressListeners, this.buildProgressListeners);\n            return new ConsumerOperationParameters(parameters, stdout, stderr, colorOutput, stdin, javaHome, jvmArguments, arguments, tasks, launchables,\n                    progressListenerAdapter, buildProgressListenerAdapter, cancellationToken);\n        }","id":72631,"modified_method":"public ConsumerOperationParameters build() {\n            // create the listener adapters right when the ConsumerOperationParameters are instantiated but no earlier,\n            // this ensures that when multiple requests are issued that are built from the same builder, such requests do not share any state kept in the listener adapters\n            // e.g. if the listener adapters do per-request caching, such caching must not leak between different requests built from the same builder\n            ProgressListenerAdapter progressListenerAdapter = new ProgressListenerAdapter(this.progressListeners);\n            BuildProgressListenerConfiguration configuration = new BuildProgressListenerConfiguration(\n                this.testProgressListeners,\n                this.taskProgressListeners,\n                this.buildProgressListeners\n            );\n            BuildProgressListenerAdapter buildProgressListenerAdapter = new BuildProgressListenerAdapter(configuration);\n            return new ConsumerOperationParameters(parameters, stdout, stderr, colorOutput, stdin, javaHome, jvmArguments, arguments, tasks, launchables,\n                progressListenerAdapter, buildProgressListenerAdapter, cancellationToken);\n        }","commit_id":"cb83d94737a0e0677e5fefb66546634b74155aa1","url":"https://github.com/gradle/gradle"},{"original_method":"public Object run(String modelName, BuildCancellationToken cancellationToken, ProviderOperationParameters providerParameters) {\n        List<String> tasks = providerParameters.getTasks();\n        if (modelName.equals(ModelIdentifier.NULL_MODEL) && tasks == null) {\n            throw new IllegalArgumentException(\"No model type or tasks specified.\");\n        }\n        Parameters params = initParams(providerParameters);\n        Class<?> type = new ModelMapping().getProtocolTypeFromModelName(modelName);\n        if (type == InternalBuildEnvironment.class) {\n            //we don't really need to launch the daemon to acquire information needed for BuildEnvironment\n            if (tasks != null) {\n                throw new IllegalArgumentException(\"Cannot run tasks and fetch the build environment model.\");\n            }\n            return new DefaultBuildEnvironment(\n                    params.gradleUserhome,\n                    GradleVersion.current().getVersion(),\n                    params.daemonParams.getEffectiveJavaHome(),\n                    params.daemonParams.getEffectiveJvmArgs(),\n                    params.daemonParams.getJvmArgs(),\n                    params.daemonParams.getAllJvmArgs(),\n                    params.daemonParams.getEffectiveSystemProperties(),\n                    params.daemonParams.getSystemProperties()\n            );\n        }\n\n        StartParameter startParameter = new ProviderStartParameterConverter().toStartParameter(providerParameters, params.properties);\n        InternalBuildProgressListener buildProgressListener = providerParameters.getBuildProgressListener(null);\n        boolean listenToTestProgress = buildProgressListener != null && buildProgressListener.getSubscribedOperations().contains(InternalBuildProgressListener.TEST_EXECUTION);\n        boolean listenToTaskProgress = buildProgressListener != null && buildProgressListener.getSubscribedOperations().contains(InternalTaskProgressListener.TASK_EXECUTION);\n        boolean listenToBuildProgress = buildProgressListener != null && buildProgressListener.getSubscribedOperations().contains(InternalTaskProgressListener.BUILD_EXECUTION);\n        BuildEventConsumer buildEventConsumer = listenToTestProgress || listenToTaskProgress || listenToBuildProgress\n                ? new BuildProgressListenerInvokingBuildEventConsumer(buildProgressListener) : new NoOpBuildEventConsumer();\n        BuildAction action = new BuildModelAction(startParameter, modelName, tasks != null, listenToTestProgress, listenToTaskProgress, listenToBuildProgress);\n        return run(action, cancellationToken, buildEventConsumer, providerParameters, params);\n    }","id":72632,"modified_method":"public Object run(String modelName, BuildCancellationToken cancellationToken, ProviderOperationParameters providerParameters) {\n        List<String> tasks = providerParameters.getTasks();\n        if (modelName.equals(ModelIdentifier.NULL_MODEL) && tasks == null) {\n            throw new IllegalArgumentException(\"No model type or tasks specified.\");\n        }\n        Parameters params = initParams(providerParameters);\n        Class<?> type = new ModelMapping().getProtocolTypeFromModelName(modelName);\n        if (type == InternalBuildEnvironment.class) {\n            //we don't really need to launch the daemon to acquire information needed for BuildEnvironment\n            if (tasks != null) {\n                throw new IllegalArgumentException(\"Cannot run tasks and fetch the build environment model.\");\n            }\n            return new DefaultBuildEnvironment(\n                params.gradleUserhome,\n                GradleVersion.current().getVersion(),\n                params.daemonParams.getEffectiveJavaHome(),\n                params.daemonParams.getEffectiveJvmArgs(),\n                params.daemonParams.getJvmArgs(),\n                params.daemonParams.getAllJvmArgs(),\n                params.daemonParams.getEffectiveSystemProperties(),\n                params.daemonParams.getSystemProperties()\n            );\n        }\n\n        StartParameter startParameter = new ProviderStartParameterConverter().toStartParameter(providerParameters, params.properties);\n        InternalBuildProgressListener buildProgressListener = providerParameters.getBuildProgressListener(null);\n        boolean listenToTestProgress = buildProgressListener != null && buildProgressListener.getSubscribedOperations().contains(InternalBuildProgressListener.TEST_EXECUTION);\n        boolean listenToTaskProgress = buildProgressListener != null && buildProgressListener.getSubscribedOperations().contains(InternalTaskProgressListener.TASK_EXECUTION);\n        boolean listenToBuildProgress = buildProgressListener != null && buildProgressListener.getSubscribedOperations().contains(InternalTaskProgressListener.BUILD_EXECUTION);\n        BuildEventConsumer buildEventConsumer = listenToTestProgress || listenToTaskProgress || listenToBuildProgress\n            ? new BuildProgressListenerInvokingBuildEventConsumer(buildProgressListener) : new NoOpBuildEventConsumer();\n        if (buildProgressListener instanceof InternalFailSafeProgressListenersProvider) {\n            ((InternalFailSafeProgressListenersProvider) buildProgressListener).setListenerFailSafeMode(true);\n        }\n        BuildAction action = new BuildModelAction(startParameter, modelName, tasks != null, listenToTestProgress, listenToTaskProgress, listenToBuildProgress);\n        Object out = run(action, cancellationToken, buildEventConsumer, providerParameters, params);\n        rethrowListenerErrors(buildProgressListener);\n        return out;\n    }","commit_id":"cb83d94737a0e0677e5fefb66546634b74155aa1","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  public void flush() throws IOException {\n    if (debug)\n      OLogManager.instance().info(this, \"%s - Flush\", socket.getRemoteSocketAddress());\n\n    updateMetricFlushes();\n\n    super.flush();\n    if (out != null)\n      out.flush();\n  }","id":72633,"modified_method":"@Override\n  public void flush() throws IOException {\n    if (debug)\n      OLogManager.instance().info(this, \"%s - Flush\", socket != null ? \" null possible previous close\" :socket.getRemoteSocketAddress());\n\n    updateMetricFlushes();\n\n    super.flush();\n    if (out != null)\n      out.flush();\n  }","commit_id":"d821d02ae8275670247a2ba5bc653a0cd50936b6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void close() {\n    if (debug)\n      OLogManager.instance().info(this, \"%s - Closing socket...\", socket.getRemoteSocketAddress());\n\n    try {\n      if (in != null) {\n        in.close();\n        // in = null;\n      }\n    } catch (IOException e) {\n      OLogManager.instance().debug(this, \"Error during closing of input stream\", e);\n    }\n\n    try {\n      if (out != null) {\n        out.close();\n        // out = null;\n      }\n    } catch (IOException e) {\n      OLogManager.instance().debug(this, \"Error during closing of output stream\", e);\n    }\n\n    super.close();\n  }","id":72634,"modified_method":"@Override\n  public void close() {\n    if (debug)\n      OLogManager.instance().info(this, \"%s - Closing socket...\", socket != null ? \" null possible previous close\" : socket.getRemoteSocketAddress());\n\n    try {\n      if (in != null) {\n        in.close();\n        // in = null;\n      }\n    } catch (IOException e) {\n      OLogManager.instance().debug(this, \"Error during closing of input stream\", e);\n    }\n\n    try {\n      if (out != null) {\n        out.close();\n        // out = null;\n      }\n    } catch (IOException e) {\n      OLogManager.instance().debug(this, \"Error during closing of output stream\", e);\n    }\n\n    super.close();\n  }","commit_id":"d821d02ae8275670247a2ba5bc653a0cd50936b6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Called after the client has connected to check if the slave secret matches the handshake secret\n     *\n     * @param nodeName\n     * Name of the incoming JNLP agent. All {@link JnlpAgentReceiver} shares a single namespace\n     * of names. The implementation needs to be able to tell which name belongs to them.\n     *\n     * @param handshake\n     * Encapsulation of the interaction with the incoming JNLP agent.\n     *\n     * @return\n     * true if the slave secret matches the handshake secret, false otherwise.\n     */\n    private boolean matchesSecret(String nodeName, JnlpSlaveHandshake handshake){\n        SlaveComputer computer = (SlaveComputer) Jenkins.getInstance().getComputer(nodeName);\n        String handshakeSecret = handshake.getRequestProperty(\"Secret-Key\");\n        // Verify that the slave secret matches the handshake secret.\n        if (!computer.getJnlpMac().equals(handshakeSecret)) {\n            LOGGER.log(Level.WARNING, \"An attempt was made to connect as {0} from {1} with an incorrect secret\", new Object[]{nodeName, handshake.getSocket().getRemoteSocketAddress()});\n            return false;\n        } else {\n            return true;\n        }\n    }","id":72635,"modified_method":"/**\n     * Called after the client has connected to check if the slave secret matches the handshake secret\n     *\n     * @param nodeName\n     * Name of the incoming JNLP agent. All {@link JnlpAgentReceiver} shares a single namespace\n     * of names. The implementation needs to be able to tell which name belongs to them.\n     *\n     * @param handshake\n     * Encapsulation of the interaction with the incoming JNLP agent.\n     *\n     * @return\n     * true if the slave secret matches the handshake secret, false otherwise.\n     */\n    private boolean matchesSecret(String nodeName, JnlpSlaveHandshake handshake){\n        SlaveComputer computer = (SlaveComputer) Jenkins.getInstance().getComputer(nodeName);\n        String handshakeSecret = handshake.getRequestProperty(\"Secret-Key\");\n        // Verify that the slave secret matches the handshake secret.\n        if (!computer.getJnlpMac().equals(handshakeSecret)) {\n            LOGGER.log(Level.WARNING, \"An attempt was made to connect as {0} from {1} with an incorrect secret\", new Object[]{nodeName, handshake.getSocket()!=null?handshake.getSocket().getRemoteSocketAddress():null});\n            return false;\n        } else {\n            return true;\n        }\n    }","commit_id":"d85bf665425091470363e14143a7d35745ea28c7","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n  @NotNull\n  public Iterable<VirtualFile> iterInDbChildren() {\n    return ContainerUtil.iterate(getInDbChildren(), new Condition<VirtualFile>() {\n      public boolean value(VirtualFile file) {\n        return file != NullVirtualFile.INSTANCE;\n      }\n    });\n  }","id":72636,"modified_method":"@Override\n  @NotNull\n  public Iterable<VirtualFile> iterInDbChildren() {\n    return ContainerUtil.iterate(getInDbChildren(), new Condition<VirtualFile>() {\n      public boolean value(VirtualFile file) {\n        return file != NULL_VIRTUAL_FILE;\n      }\n    });\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void removeChild(@NotNull VirtualFile file) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      myChildren = ArrayUtil.remove(a, file);\n    }\n    else {\n      final Map<String, VirtualFile> m = ensureAsMap();\n      m.put(file.getName(), NullVirtualFile.INSTANCE);\n    }\n  }","id":72637,"modified_method":"public synchronized void removeChild(@NotNull VirtualFile file) {\n    final VirtualFileSystemEntry[] a = asArray();\n    if (a != null) {\n      myChildren = ArrayUtil.remove(a, file);\n    }\n    else {\n      ensureAsMap().put(file.getName(), NULL_VIRTUAL_FILE);\n    }\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Map<String, VirtualFile> ensureAsMap() {\n    Map<String, VirtualFile> map;\n    if (myChildren == null) {\n      map = createMap();\n      myChildren = map;\n    }\n    else {\n      //noinspection unchecked\n      map = (Map<String, VirtualFile>)myChildren;\n    }\n\n    return map;\n  }","id":72638,"modified_method":"@NotNull\n  private Map<String, VirtualFileSystemEntry> ensureAsMap() {\n    Map<String, VirtualFileSystemEntry> map;\n    if (myChildren == null) {\n      map = createMap();\n      myChildren = map;\n    }\n    else {\n      //noinspection unchecked\n      map = (Map<String, VirtualFileSystemEntry>)myChildren;\n    }\n\n    return map;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public synchronized NewVirtualFile findChildIfCached(@NotNull String name) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      Object encoded = encodeName(name);\n      byte[] bytes = encoded instanceof byte[] ? (byte[])encoded : null;\n      for (VirtualFile file : a) {\n        if (namesEqual(name, bytes, file)) return (NewVirtualFile)file;\n      }\n\n      return null;\n    }\n\n    final Map<String, VirtualFile> map = asMap();\n    if (map != null) {\n      final VirtualFile file = map.get(name);\n      return file instanceof NewVirtualFile ? (NewVirtualFile)file : null;\n    }\n\n    return null;\n  }","id":72639,"modified_method":"@Nullable\n  public synchronized NewVirtualFile findChildIfCached(@NotNull String name) {\n    final VirtualFileSystemEntry[] a = asArray();\n    if (a != null) {\n      Object encoded = encodeName(name);\n      byte[] bytes = encoded instanceof byte[] ? (byte[])encoded : null;\n      for (VirtualFileSystemEntry file : a) {\n        if (namesEqual(name, bytes, file)) return file;\n      }\n\n      return null;\n    }\n\n    final Map<String, VirtualFileSystemEntry> map = asMap();\n    if (map != null) {\n      final VirtualFileSystemEntry file = map.get(name);\n      return file != NULL_VIRTUAL_FILE ? file : null;\n    }\n\n    return null;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Map<String, VirtualFile> createMap() {\n    return getFileSystem().isCaseSensitive()\n           ? new THashMap<String, VirtualFile>()\n           : new THashMap<String, VirtualFile>(CaseInsensitiveStringHashingStrategy.INSTANCE);\n  }","id":72640,"modified_method":"@NotNull\n  private Map<String, VirtualFileSystemEntry> createMap() {\n    return getFileSystem().isCaseSensitive()\n           ? new THashMap<String, VirtualFileSystemEntry>()\n           : new THashMap<String, VirtualFileSystemEntry>(CaseInsensitiveStringHashingStrategy.INSTANCE);\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private NewVirtualFile createAndFindChildWithEventFire(@NotNull String name) {\n    final NewVirtualFileSystem delegate = getFileSystem();\n    VirtualFile fake = new FakeVirtualFile(this, name);\n    if (delegate.exists(fake)) {\n      final String realName = delegate.getCanonicallyCasedName(fake);\n      VFileCreateEvent event = new VFileCreateEvent(null, this, realName, delegate.isDirectory(fake), true);\n      RefreshQueue.getInstance().processSingleEvent(event);\n      return findChild(realName);\n    }\n    else {\n      return null;\n    }\n  }","id":72641,"modified_method":"@Nullable\n  private VirtualFileSystemEntry createAndFindChildWithEventFire(@NotNull String name) {\n    final NewVirtualFileSystem delegate = getFileSystem();\n    VirtualFile fake = new FakeVirtualFile(this, name);\n    if (delegate.exists(fake)) {\n      final String realName = delegate.getCanonicallyCasedName(fake);\n      VFileCreateEvent event = new VFileCreateEvent(null, this, realName, delegate.isDirectory(fake), true);\n      RefreshQueue.getInstance().processSingleEvent(event);\n      return findChild(realName);\n    }\n    else {\n      return null;\n    }\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private VirtualFile doFindChild(@NotNull String name, final boolean createIfNotFound, boolean ensureCanonicalName) {\n    if (name.length() == 0) {\n      return null;\n    }\n\n    final VirtualFile[] array;\n    final Map<String, VirtualFile> map;\n    final VirtualFile file;\n    synchronized (this) {\n      array = asArray();\n      if (array == null) {\n        map = ensureAsMap();\n        file = map.get(name);\n      }\n      else {\n        file = null;\n        map = null;\n      }\n    }\n    if (array != null) {\n      Object encoded = encodeName(name);\n      byte[] bytes = encoded instanceof byte[] ? (byte[])encoded : null;\n      for (VirtualFile vf : array) {\n        if (namesEqual(name, bytes, vf)) return vf;\n      }\n      return createIfNotFound ? createAndFindChildWithEventFire(name) : null;\n    }\n\n    if (file != null) return file;\n\n    if (ensureCanonicalName) {\n      final NewVirtualFileSystem delegate = getFileSystem();\n      VirtualFile fake = new FakeVirtualFile(this, name);\n      name = delegate.getCanonicallyCasedName(fake);\n      if (name.length() == 0) return null;\n    }\n\n    synchronized (this) {\n      // do not extract getId outside the synchronized block since it will cause a concurrency problem.\n      int id = PersistentFS.getId(this, name);\n      if (id > 0) {\n        // maybe another doFindChild() sneaked in the middle\n        VirtualFile lastTry = map.get(name);\n        if (lastTry != null) return lastTry;\n\n        final String shorty = new String(name);\n        NewVirtualFile child = createChild(shorty, id); // So we don't hold whole char[] buffer of a lengthy path\n        map.put(shorty, child);\n        return child;\n      }\n    }\n\n    return null;\n  }","id":72642,"modified_method":"@Nullable\n  private VirtualFileSystemEntry doFindChild(@NotNull String name, final boolean createIfNotFound, boolean ensureCanonicalName) {\n    if (name.length() == 0) {\n      return null;\n    }\n\n    final VirtualFileSystemEntry[] array;\n    final Map<String, VirtualFileSystemEntry> map;\n    final VirtualFileSystemEntry file;\n    synchronized (this) {\n      array = asArray();\n      if (array == null) {\n        map = ensureAsMap();\n        file = map.get(name);\n      }\n      else {\n        file = null;\n        map = null;\n      }\n    }\n    if (array != null) {\n      Object encoded = encodeName(name);\n      byte[] bytes = encoded instanceof byte[] ? (byte[])encoded : null;\n      for (VirtualFileSystemEntry vf : array) {\n        if (namesEqual(name, bytes, vf)) return vf;\n      }\n      return createIfNotFound ? createAndFindChildWithEventFire(name) : null;\n    }\n\n    if (file != null) return file;\n\n    if (ensureCanonicalName) {\n      final NewVirtualFileSystem delegate = getFileSystem();\n      VirtualFile fake = new FakeVirtualFile(this, name);\n      name = delegate.getCanonicallyCasedName(fake);\n      if (name.length() == 0) return null;\n    }\n\n    synchronized (this) {\n      // do not extract getId outside the synchronized block since it will cause a concurrency problem.\n      int id = PersistentFS.getId(this, name);\n      if (id > 0) {\n        // maybe another doFindChild() sneaked in the middle\n        VirtualFileSystemEntry lastTry = map.get(name);\n        if (lastTry != null) return lastTry;\n\n        final String shorty = new String(name);\n        VirtualFileSystemEntry child = createChild(shorty, id); // So we don't hold whole char[] buffer of a lengthy path\n        map.put(shorty, child);\n        return child;\n      }\n    }\n\n    return null;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public NewVirtualFile findChild(@NotNull final String name) {\n    return findChild(name, false, true);\n  }","id":72643,"modified_method":"@Nullable\n  public VirtualFileSystemEntry findChild(@NotNull final String name) {\n    return findChild(name, false, true);\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public synchronized Collection<VirtualFile> getCachedChildren() {\n    final Map<String, VirtualFile> map = asMap();\n    if (map != null) {\n      Set<VirtualFile> files = new THashSet<VirtualFile>(map.values());\n      files.remove(NullVirtualFile.INSTANCE);\n      return files;\n    }\n\n    final VirtualFile[] a = asArray();\n    if (a != null) return Arrays.asList(a);\n\n    return Collections.emptyList();\n  }","id":72644,"modified_method":"@NotNull\n  public synchronized Collection<VirtualFile> getCachedChildren() {\n    final Map<String, VirtualFileSystemEntry> map = asMap();\n    if (map != null) {\n      Set<VirtualFile> files = new THashSet<VirtualFile>(map.values());\n      files.remove(NULL_VIRTUAL_FILE);\n      return files;\n    }\n\n    final VirtualFile[] a = asArray();\n    if (a != null) return Arrays.asList(a);\n\n    return Collections.emptyList();\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private NewVirtualFile findChild(@NotNull String name, final boolean createIfNotFound, boolean ensureCanonicalName) {\n    final VirtualFile result = doFindChild(name, createIfNotFound, ensureCanonicalName);\n    if (result == NullVirtualFile.INSTANCE) {\n      return createIfNotFound ? createAndFindChildWithEventFire(name) : null;\n    }\n\n    if (result == null) {\n      synchronized (this) {\n        Map<String, VirtualFile> map = asMap();\n        if (map != null) {\n          map.put(name, NullVirtualFile.INSTANCE);\n        }\n      }\n    }\n\n    return (NewVirtualFile)result;\n  }","id":72645,"modified_method":"@Nullable\n  private VirtualFileSystemEntry findChild(@NotNull String name, final boolean createIfNotFound, boolean ensureCanonicalName) {\n    final VirtualFileSystemEntry result = doFindChild(name, createIfNotFound, ensureCanonicalName);\n    if (result == NULL_VIRTUAL_FILE) {\n      return createIfNotFound ? createAndFindChildWithEventFire(name) : null;\n    }\n\n    if (result == null) {\n      synchronized (this) {\n        Map<String, VirtualFileSystemEntry> map = asMap();\n        if (map != null) {\n          map.put(name, NULL_VIRTUAL_FILE);\n        }\n      }\n    }\n\n    return result;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean namesEqual(String name, byte[] encoded, VirtualFile file) {\n    if (encoded != null && file instanceof VirtualFileSystemEntry) {\n      Object o = ((VirtualFileSystemEntry)file).rawName();\n      if (!(o instanceof byte[])) return false;\n\n      if (encoded.length != ((byte[])o).length) return false;\n    }\n\n    final String name2 = file.getName();\n    if (getFileSystem().isCaseSensitive()) {\n      return name.equals(name2);\n    }\n    return name.equalsIgnoreCase(name2);\n  }","id":72646,"modified_method":"private boolean namesEqual(String name, byte[] encoded, VirtualFileSystemEntry file) {\n    if (encoded != null) {\n      Object o = file.rawName();\n      if (!(o instanceof byte[])) return false;\n\n      if (encoded.length != ((byte[])o).length) return false;\n    }\n\n    final String name2 = file.getName();\n    if (getFileSystem().isCaseSensitive()) {\n      return name.equals(name2);\n    }\n    return name.equalsIgnoreCase(name2);\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private synchronized Collection<VirtualFile> getInDbChildren() {\n    if (myChildren instanceof VirtualFile[]) {\n      return Arrays.asList((VirtualFile[])myChildren);\n    }\n\n    if (!ourPersistence.wereChildrenAccessed(this)) {\n      return Collections.emptyList();\n    }\n\n    if (ourPersistence.areChildrenLoaded(this)) {\n      return Arrays.asList(getChildren());\n    }\n\n    final String[] names = PersistentFS.listPersisted(this);\n    for (String name : names) {\n      findChild(name, false, false);\n    }\n    \n    // important: should return a copy here for safe iterations\n    return new ArrayList<VirtualFile>(ensureAsMap().values());\n  }","id":72647,"modified_method":"@NotNull\n  private synchronized Collection<VirtualFile> getInDbChildren() {\n    if (myChildren instanceof VirtualFileSystemEntry[]) {\n      return Arrays.asList((VirtualFile[])myChildren);\n    }\n\n    if (!ourPersistence.wereChildrenAccessed(this)) {\n      return Collections.emptyList();\n    }\n\n    if (ourPersistence.areChildrenLoaded(this)) {\n      return Arrays.asList(getChildren());\n    }\n\n    final String[] names = PersistentFS.listPersisted(this);\n    for (String name : names) {\n      findChild(name, false, false);\n    }\n    \n    // important: should return a copy here for safe iterations\n    return new ArrayList<VirtualFile>(ensureAsMap().values());\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public synchronized VirtualFile[] getChildren() {\n    if (myChildren instanceof VirtualFile[]) {\n      return (VirtualFile[])myChildren;\n    }\n\n    Pair<String[],int[]> pair = PersistentFS.listAll(this);\n    final int[] childrenIds = pair.second;\n    VirtualFile[] children;\n    if (childrenIds.length == 0) {\n      children = EMPTY_ARRAY;\n    }\n    else {\n      children = new VirtualFile[childrenIds.length];\n      String[] names = pair.first;\n      final Map<String, VirtualFile> map = asMap();\n      for (int i = 0; i < children.length; i++) {\n        final int childId = childrenIds[i];\n        final String name = names[i];\n        VirtualFile child = map != null ? map.get(name) : null;\n\n        children[i] = child != null && child != NullVirtualFile.INSTANCE ? child : createChild(name, childId);\n      }\n    }\n\n    if (getId() > 0) {\n      myChildren = children;\n    }\n\n    return children;\n  }","id":72648,"modified_method":"@NotNull\n  public synchronized VirtualFile[] getChildren() {\n    if (myChildren instanceof VirtualFileSystemEntry[]) {\n      return (VirtualFileSystemEntry[])myChildren;\n    }\n\n    Pair<String[],int[]> pair = PersistentFS.listAll(this);\n    final int[] childrenIds = pair.second;\n    VirtualFileSystemEntry[] children;\n    if (childrenIds.length == 0) {\n      children = EMPTY_ARRAY;\n    }\n    else {\n      children = new VirtualFileSystemEntry[childrenIds.length];\n      String[] names = pair.first;\n      final Map<String, VirtualFileSystemEntry> map = asMap();\n      for (int i = 0; i < children.length; i++) {\n        final int childId = childrenIds[i];\n        final String name = names[i];\n        VirtualFileSystemEntry child = map != null ? map.get(name) : null;\n\n        children[i] = child != null && child != NULL_VIRTUAL_FILE ? child : createChild(name, childId);\n      }\n    }\n\n    if (getId() > 0) {\n      myChildren = children;\n    }\n\n    return children;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized boolean allChildrenLoaded() {\n    return myChildren instanceof VirtualFile[];\n  }","id":72649,"modified_method":"public synchronized boolean allChildrenLoaded() {\n    return myChildren instanceof VirtualFileSystemEntry[];\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Map<String, VirtualFile> asMap() {\n    if (myChildren instanceof Map) {\n      //noinspection unchecked\n      return (Map<String, VirtualFile>)myChildren;\n    }\n    return null;\n  }","id":72650,"modified_method":"@Nullable\n  private Map<String, VirtualFileSystemEntry> asMap() {\n    if (myChildren instanceof Map) {\n      //noinspection unchecked\n      return (Map<String, VirtualFileSystemEntry>)myChildren;\n    }\n    return null;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NewVirtualFile findChildByIdIfCached(int id) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      for (VirtualFile file : a) {\n        NewVirtualFile withId = (NewVirtualFile)file;\n        if (withId.getId() == id) return withId;\n      }\n\n      return null;\n    }\n    synchronized (this) {\n      final Map<String, VirtualFile> map = asMap();\n      if (map != null) {\n        for (Map.Entry<String, VirtualFile> entry : map.entrySet()) {\n          VirtualFile file = entry.getValue();\n          if (file == NullVirtualFile.INSTANCE) continue;\n          NewVirtualFile withId = (NewVirtualFile)file;\n          if (withId.getId() == id) return withId;\n        }\n      }\n    }\n    return null;\n  }","id":72651,"modified_method":"public NewVirtualFile findChildByIdIfCached(int id) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      for (VirtualFile file : a) {\n        NewVirtualFile withId = (NewVirtualFile)file;\n        if (withId.getId() == id) return withId;\n      }\n\n      return null;\n    }\n    synchronized (this) {\n      final Map<String, VirtualFileSystemEntry> map = asMap();\n      if (map != null) {\n        for (Map.Entry<String, VirtualFileSystemEntry> entry : map.entrySet()) {\n          VirtualFile file = entry.getValue();\n          if (file == NULL_VIRTUAL_FILE) continue;\n          NewVirtualFile withId = (NewVirtualFile)file;\n          if (withId.getId() == id) return withId;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public synchronized List<String> getSuspiciousNames() {\n    final Map<String, VirtualFile> map = asMap();\n    if (map == null) return Collections.emptyList();\n\n    List<String> names = new ArrayList<String>();\n    for (Map.Entry<String, VirtualFile> entry : map.entrySet()) {\n      if (entry.getValue() == NullVirtualFile.INSTANCE) {\n        names.add(entry.getKey());\n      }\n    }\n\n    return names;\n  }","id":72652,"modified_method":"@NotNull\n  public synchronized List<String> getSuspiciousNames() {\n    final Map<String, VirtualFileSystemEntry> map = asMap();\n    if (map == null) return Collections.emptyList();\n\n    List<String> names = new ArrayList<String>();\n    for (Map.Entry<String, VirtualFileSystemEntry> entry : map.entrySet()) {\n      if (entry.getValue() == NULL_VIRTUAL_FILE) {\n        names.add(entry.getKey());\n      }\n    }\n\n    return names;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private VirtualFile[] asArray() {\n    if (myChildren instanceof VirtualFile[]) return (VirtualFile[])myChildren;\n    return null;\n  }","id":72653,"modified_method":"@Nullable\n  private VirtualFileSystemEntry[] asArray() {\n    if (myChildren instanceof VirtualFileSystemEntry[]) return (VirtualFileSystemEntry[])myChildren;\n    return null;\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addChild(@NotNull VirtualFile file) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      myChildren = ArrayUtil.append(a, file);\n    }\n    else {\n      final Map<String, VirtualFile> m = ensureAsMap();\n      m.put(file.getName(), file);\n    }\n  }","id":72654,"modified_method":"public synchronized void addChild(@NotNull VirtualFileSystemEntry file) {\n    final VirtualFileSystemEntry[] a = asArray();\n    if (a != null) {\n      myChildren = ArrayUtil.append(a, file);\n    }\n    else {\n      ensureAsMap().put(file.getName(), file);\n    }\n  }","commit_id":"768412c4af374cbe63429f054b5e80979460fff4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public synchronized Collection<VirtualFile> getCachedChildren() {\n    final Map<String, VirtualFile> map = asMap();\n    if (map != null) {\n      Set<VirtualFile> files = new THashSet<VirtualFile>(map.values());\n      files.remove(NullVirtualFile.INSTANCE);\n      return files;\n    }\n\n    final VirtualFile[] a = asArray();\n    if (a != null) return Arrays.asList(a);\n\n    return Collections.emptyList();\n  }","id":72655,"modified_method":"@NotNull\n  public synchronized Collection<VirtualFile> getCachedChildren() {\n    final Map<String, VirtualFileSystemEntry> map = asMap();\n    if (map != null) {\n      Set<VirtualFile> files = new THashSet<VirtualFile>(map.values());\n      files.remove(NULL_VIRTUAL_FILE);\n      return files;\n    }\n\n    final VirtualFile[] a = asArray();\n    if (a != null) return Arrays.asList(a);\n\n    return Collections.emptyList();\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private NewVirtualFile findChild(@NotNull String name, final boolean createIfNotFound, boolean ensureCanonicalName) {\n    final VirtualFile result = doFindChild(name, createIfNotFound, ensureCanonicalName);\n    if (result == NullVirtualFile.INSTANCE) {\n      return createIfNotFound ? createAndFindChildWithEventFire(name) : null;\n    }\n\n    if (result == null) {\n      synchronized (this) {\n        Map<String, VirtualFile> map = asMap();\n        if (map != null) {\n          map.put(name, NullVirtualFile.INSTANCE);\n        }\n      }\n    }\n\n    return (NewVirtualFile)result;\n  }","id":72656,"modified_method":"@Nullable\n  private VirtualFileSystemEntry findChild(@NotNull String name, final boolean createIfNotFound, boolean ensureCanonicalName) {\n    final VirtualFileSystemEntry result = doFindChild(name, createIfNotFound, ensureCanonicalName);\n    if (result == NULL_VIRTUAL_FILE) {\n      return createIfNotFound ? createAndFindChildWithEventFire(name) : null;\n    }\n\n    if (result == null) {\n      synchronized (this) {\n        Map<String, VirtualFileSystemEntry> map = asMap();\n        if (map != null) {\n          map.put(name, NULL_VIRTUAL_FILE);\n        }\n      }\n    }\n\n    return result;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public Iterable<VirtualFile> iterInDbChildren() {\n    return ContainerUtil.iterate(getInDbChildren(), new Condition<VirtualFile>() {\n      public boolean value(VirtualFile file) {\n        return file != NullVirtualFile.INSTANCE;\n      }\n    });\n  }","id":72657,"modified_method":"@Override\n  @NotNull\n  public Iterable<VirtualFile> iterInDbChildren() {\n    return ContainerUtil.iterate(getInDbChildren(), new Condition<VirtualFile>() {\n      public boolean value(VirtualFile file) {\n        return file != NULL_VIRTUAL_FILE;\n      }\n    });\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NewVirtualFile findChildByIdIfCached(int id) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      for (VirtualFile file : a) {\n        NewVirtualFile withId = (NewVirtualFile)file;\n        if (withId.getId() == id) return withId;\n      }\n\n      return null;\n    }\n    synchronized (this) {\n      final Map<String, VirtualFile> map = asMap();\n      if (map != null) {\n        for (Map.Entry<String, VirtualFile> entry : map.entrySet()) {\n          VirtualFile file = entry.getValue();\n          if (file == NullVirtualFile.INSTANCE) continue;\n          NewVirtualFile withId = (NewVirtualFile)file;\n          if (withId.getId() == id) return withId;\n        }\n      }\n    }\n    return null;\n  }","id":72658,"modified_method":"public NewVirtualFile findChildByIdIfCached(int id) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      for (VirtualFile file : a) {\n        NewVirtualFile withId = (NewVirtualFile)file;\n        if (withId.getId() == id) return withId;\n      }\n\n      return null;\n    }\n    synchronized (this) {\n      final Map<String, VirtualFileSystemEntry> map = asMap();\n      if (map != null) {\n        for (Map.Entry<String, VirtualFileSystemEntry> entry : map.entrySet()) {\n          VirtualFile file = entry.getValue();\n          if (file == NULL_VIRTUAL_FILE) continue;\n          NewVirtualFile withId = (NewVirtualFile)file;\n          if (withId.getId() == id) return withId;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private VirtualFile[] asArray() {\n    if (myChildren instanceof VirtualFile[]) return (VirtualFile[])myChildren;\n    return null;\n  }","id":72659,"modified_method":"@Nullable\n  private VirtualFileSystemEntry[] asArray() {\n    if (myChildren instanceof VirtualFileSystemEntry[]) return (VirtualFileSystemEntry[])myChildren;\n    return null;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean namesEqual(String name, byte[] encoded, VirtualFile file) {\n    if (encoded != null && file instanceof VirtualFileSystemEntry) {\n      Object o = ((VirtualFileSystemEntry)file).rawName();\n      if (!(o instanceof byte[])) return false;\n\n      if (encoded.length != ((byte[])o).length) return false;\n    }\n\n    final String name2 = file.getName();\n    if (getFileSystem().isCaseSensitive()) {\n      return name.equals(name2);\n    }\n    return name.equalsIgnoreCase(name2);\n  }","id":72660,"modified_method":"private boolean namesEqual(String name, byte[] encoded, VirtualFileSystemEntry file) {\n    if (encoded != null) {\n      Object o = file.rawName();\n      if (!(o instanceof byte[])) return false;\n\n      if (encoded.length != ((byte[])o).length) return false;\n    }\n\n    final String name2 = file.getName();\n    if (getFileSystem().isCaseSensitive()) {\n      return name.equals(name2);\n    }\n    return name.equalsIgnoreCase(name2);\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private VirtualFile doFindChild(@NotNull String name, final boolean createIfNotFound, boolean ensureCanonicalName) {\n    if (name.length() == 0) {\n      return null;\n    }\n\n    final VirtualFile[] array;\n    final Map<String, VirtualFile> map;\n    final VirtualFile file;\n    synchronized (this) {\n      array = asArray();\n      if (array == null) {\n        map = ensureAsMap();\n        file = map.get(name);\n      }\n      else {\n        file = null;\n        map = null;\n      }\n    }\n    if (array != null) {\n      Object encoded = encodeName(name);\n      byte[] bytes = encoded instanceof byte[] ? (byte[])encoded : null;\n      for (VirtualFile vf : array) {\n        if (namesEqual(name, bytes, vf)) return vf;\n      }\n      return createIfNotFound ? createAndFindChildWithEventFire(name) : null;\n    }\n\n    if (file != null) return file;\n\n    if (ensureCanonicalName) {\n      final NewVirtualFileSystem delegate = getFileSystem();\n      VirtualFile fake = new FakeVirtualFile(this, name);\n      name = delegate.getCanonicallyCasedName(fake);\n      if (name.length() == 0) return null;\n    }\n\n    synchronized (this) {\n      // do not extract getId outside the synchronized block since it will cause a concurrency problem.\n      int id = PersistentFS.getId(this, name);\n      if (id > 0) {\n        // maybe another doFindChild() sneaked in the middle\n        VirtualFile lastTry = map.get(name);\n        if (lastTry != null) return lastTry;\n\n        final String shorty = new String(name);\n        NewVirtualFile child = createChild(shorty, id); // So we don't hold whole char[] buffer of a lengthy path\n        map.put(shorty, child);\n        return child;\n      }\n    }\n\n    return null;\n  }","id":72661,"modified_method":"@Nullable\n  private VirtualFileSystemEntry doFindChild(@NotNull String name, final boolean createIfNotFound, boolean ensureCanonicalName) {\n    if (name.length() == 0) {\n      return null;\n    }\n\n    final VirtualFileSystemEntry[] array;\n    final Map<String, VirtualFileSystemEntry> map;\n    final VirtualFileSystemEntry file;\n    synchronized (this) {\n      array = asArray();\n      if (array == null) {\n        map = ensureAsMap();\n        file = map.get(name);\n      }\n      else {\n        file = null;\n        map = null;\n      }\n    }\n    if (array != null) {\n      Object encoded = encodeName(name);\n      byte[] bytes = encoded instanceof byte[] ? (byte[])encoded : null;\n      for (VirtualFileSystemEntry vf : array) {\n        if (namesEqual(name, bytes, vf)) return vf;\n      }\n      return createIfNotFound ? createAndFindChildWithEventFire(name) : null;\n    }\n\n    if (file != null) return file;\n\n    if (ensureCanonicalName) {\n      final NewVirtualFileSystem delegate = getFileSystem();\n      VirtualFile fake = new FakeVirtualFile(this, name);\n      name = delegate.getCanonicallyCasedName(fake);\n      if (name.length() == 0) return null;\n    }\n\n    synchronized (this) {\n      // do not extract getId outside the synchronized block since it will cause a concurrency problem.\n      int id = PersistentFS.getId(this, name);\n      if (id > 0) {\n        // maybe another doFindChild() sneaked in the middle\n        VirtualFileSystemEntry lastTry = map.get(name);\n        if (lastTry != null) return lastTry;\n\n        final String shorty = new String(name);\n        VirtualFileSystemEntry child = createChild(shorty, id); // So we don't hold whole char[] buffer of a lengthy path\n        map.put(shorty, child);\n        return child;\n      }\n    }\n\n    return null;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addChild(@NotNull VirtualFile file) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      myChildren = ArrayUtil.append(a, file);\n    }\n    else {\n      final Map<String, VirtualFile> m = ensureAsMap();\n      m.put(file.getName(), file);\n    }\n  }","id":72662,"modified_method":"public synchronized void addChild(@NotNull VirtualFileSystemEntry file) {\n    final VirtualFileSystemEntry[] a = asArray();\n    if (a != null) {\n      myChildren = ArrayUtil.append(a, file);\n    }\n    else {\n      ensureAsMap().put(file.getName(), file);\n    }\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public NewVirtualFile findChild(@NotNull final String name) {\n    return findChild(name, false, true);\n  }","id":72663,"modified_method":"@Nullable\n  public VirtualFileSystemEntry findChild(@NotNull final String name) {\n    return findChild(name, false, true);\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public synchronized NewVirtualFile findChildIfCached(@NotNull String name) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      Object encoded = encodeName(name);\n      byte[] bytes = encoded instanceof byte[] ? (byte[])encoded : null;\n      for (VirtualFile file : a) {\n        if (namesEqual(name, bytes, file)) return (NewVirtualFile)file;\n      }\n\n      return null;\n    }\n\n    final Map<String, VirtualFile> map = asMap();\n    if (map != null) {\n      final VirtualFile file = map.get(name);\n      return file instanceof NewVirtualFile ? (NewVirtualFile)file : null;\n    }\n\n    return null;\n  }","id":72664,"modified_method":"@Nullable\n  public synchronized NewVirtualFile findChildIfCached(@NotNull String name) {\n    final VirtualFileSystemEntry[] a = asArray();\n    if (a != null) {\n      Object encoded = encodeName(name);\n      byte[] bytes = encoded instanceof byte[] ? (byte[])encoded : null;\n      for (VirtualFileSystemEntry file : a) {\n        if (namesEqual(name, bytes, file)) return file;\n      }\n\n      return null;\n    }\n\n    final Map<String, VirtualFileSystemEntry> map = asMap();\n    if (map != null) {\n      final VirtualFileSystemEntry file = map.get(name);\n      return file != NULL_VIRTUAL_FILE ? file : null;\n    }\n\n    return null;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public synchronized List<String> getSuspiciousNames() {\n    final Map<String, VirtualFile> map = asMap();\n    if (map == null) return Collections.emptyList();\n\n    List<String> names = new ArrayList<String>();\n    for (Map.Entry<String, VirtualFile> entry : map.entrySet()) {\n      if (entry.getValue() == NullVirtualFile.INSTANCE) {\n        names.add(entry.getKey());\n      }\n    }\n\n    return names;\n  }","id":72665,"modified_method":"@NotNull\n  public synchronized List<String> getSuspiciousNames() {\n    final Map<String, VirtualFileSystemEntry> map = asMap();\n    if (map == null) return Collections.emptyList();\n\n    List<String> names = new ArrayList<String>();\n    for (Map.Entry<String, VirtualFileSystemEntry> entry : map.entrySet()) {\n      if (entry.getValue() == NULL_VIRTUAL_FILE) {\n        names.add(entry.getKey());\n      }\n    }\n\n    return names;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized boolean allChildrenLoaded() {\n    return myChildren instanceof VirtualFile[];\n  }","id":72666,"modified_method":"public synchronized boolean allChildrenLoaded() {\n    return myChildren instanceof VirtualFileSystemEntry[];\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public synchronized VirtualFile[] getChildren() {\n    if (myChildren instanceof VirtualFile[]) {\n      return (VirtualFile[])myChildren;\n    }\n\n    Pair<String[],int[]> pair = PersistentFS.listAll(this);\n    final int[] childrenIds = pair.second;\n    VirtualFile[] children;\n    if (childrenIds.length == 0) {\n      children = EMPTY_ARRAY;\n    }\n    else {\n      children = new VirtualFile[childrenIds.length];\n      String[] names = pair.first;\n      final Map<String, VirtualFile> map = asMap();\n      for (int i = 0; i < children.length; i++) {\n        final int childId = childrenIds[i];\n        final String name = names[i];\n        VirtualFile child = map != null ? map.get(name) : null;\n\n        children[i] = child != null && child != NullVirtualFile.INSTANCE ? child : createChild(name, childId);\n      }\n    }\n\n    if (getId() > 0) {\n      myChildren = children;\n    }\n\n    return children;\n  }","id":72667,"modified_method":"@NotNull\n  public synchronized VirtualFile[] getChildren() {\n    if (myChildren instanceof VirtualFileSystemEntry[]) {\n      return (VirtualFileSystemEntry[])myChildren;\n    }\n\n    Pair<String[],int[]> pair = PersistentFS.listAll(this);\n    final int[] childrenIds = pair.second;\n    VirtualFileSystemEntry[] children;\n    if (childrenIds.length == 0) {\n      children = EMPTY_ARRAY;\n    }\n    else {\n      children = new VirtualFileSystemEntry[childrenIds.length];\n      String[] names = pair.first;\n      final Map<String, VirtualFileSystemEntry> map = asMap();\n      for (int i = 0; i < children.length; i++) {\n        final int childId = childrenIds[i];\n        final String name = names[i];\n        VirtualFileSystemEntry child = map != null ? map.get(name) : null;\n\n        children[i] = child != null && child != NULL_VIRTUAL_FILE ? child : createChild(name, childId);\n      }\n    }\n\n    if (getId() > 0) {\n      myChildren = children;\n    }\n\n    return children;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Map<String, VirtualFile> ensureAsMap() {\n    Map<String, VirtualFile> map;\n    if (myChildren == null) {\n      map = createMap();\n      myChildren = map;\n    }\n    else {\n      //noinspection unchecked\n      map = (Map<String, VirtualFile>)myChildren;\n    }\n\n    return map;\n  }","id":72668,"modified_method":"@NotNull\n  private Map<String, VirtualFileSystemEntry> ensureAsMap() {\n    Map<String, VirtualFileSystemEntry> map;\n    if (myChildren == null) {\n      map = createMap();\n      myChildren = map;\n    }\n    else {\n      //noinspection unchecked\n      map = (Map<String, VirtualFileSystemEntry>)myChildren;\n    }\n\n    return map;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Map<String, VirtualFile> createMap() {\n    return getFileSystem().isCaseSensitive()\n           ? new THashMap<String, VirtualFile>()\n           : new THashMap<String, VirtualFile>(CaseInsensitiveStringHashingStrategy.INSTANCE);\n  }","id":72669,"modified_method":"@NotNull\n  private Map<String, VirtualFileSystemEntry> createMap() {\n    return getFileSystem().isCaseSensitive()\n           ? new THashMap<String, VirtualFileSystemEntry>()\n           : new THashMap<String, VirtualFileSystemEntry>(CaseInsensitiveStringHashingStrategy.INSTANCE);\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Map<String, VirtualFile> asMap() {\n    if (myChildren instanceof Map) {\n      //noinspection unchecked\n      return (Map<String, VirtualFile>)myChildren;\n    }\n    return null;\n  }","id":72670,"modified_method":"@Nullable\n  private Map<String, VirtualFileSystemEntry> asMap() {\n    if (myChildren instanceof Map) {\n      //noinspection unchecked\n      return (Map<String, VirtualFileSystemEntry>)myChildren;\n    }\n    return null;\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private NewVirtualFile createAndFindChildWithEventFire(@NotNull String name) {\n    final NewVirtualFileSystem delegate = getFileSystem();\n    VirtualFile fake = new FakeVirtualFile(this, name);\n    if (delegate.exists(fake)) {\n      final String realName = delegate.getCanonicallyCasedName(fake);\n      VFileCreateEvent event = new VFileCreateEvent(null, this, realName, delegate.isDirectory(fake), true);\n      RefreshQueue.getInstance().processSingleEvent(event);\n      return findChild(realName);\n    }\n    else {\n      return null;\n    }\n  }","id":72671,"modified_method":"@Nullable\n  private VirtualFileSystemEntry createAndFindChildWithEventFire(@NotNull String name) {\n    final NewVirtualFileSystem delegate = getFileSystem();\n    VirtualFile fake = new FakeVirtualFile(this, name);\n    if (delegate.exists(fake)) {\n      final String realName = delegate.getCanonicallyCasedName(fake);\n      VFileCreateEvent event = new VFileCreateEvent(null, this, realName, delegate.isDirectory(fake), true);\n      RefreshQueue.getInstance().processSingleEvent(event);\n      return findChild(realName);\n    }\n    else {\n      return null;\n    }\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private synchronized Collection<VirtualFile> getInDbChildren() {\n    if (myChildren instanceof VirtualFile[]) {\n      return Arrays.asList((VirtualFile[])myChildren);\n    }\n\n    if (!ourPersistence.wereChildrenAccessed(this)) {\n      return Collections.emptyList();\n    }\n\n    if (ourPersistence.areChildrenLoaded(this)) {\n      return Arrays.asList(getChildren());\n    }\n\n    final String[] names = PersistentFS.listPersisted(this);\n    for (String name : names) {\n      findChild(name, false, false);\n    }\n    \n    // important: should return a copy here for safe iterations\n    return new ArrayList<VirtualFile>(ensureAsMap().values());\n  }","id":72672,"modified_method":"@NotNull\n  private synchronized Collection<VirtualFile> getInDbChildren() {\n    if (myChildren instanceof VirtualFileSystemEntry[]) {\n      return Arrays.asList((VirtualFile[])myChildren);\n    }\n\n    if (!ourPersistence.wereChildrenAccessed(this)) {\n      return Collections.emptyList();\n    }\n\n    if (ourPersistence.areChildrenLoaded(this)) {\n      return Arrays.asList(getChildren());\n    }\n\n    final String[] names = PersistentFS.listPersisted(this);\n    for (String name : names) {\n      findChild(name, false, false);\n    }\n    \n    // important: should return a copy here for safe iterations\n    return new ArrayList<VirtualFile>(ensureAsMap().values());\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void removeChild(@NotNull VirtualFile file) {\n    final VirtualFile[] a = asArray();\n    if (a != null) {\n      myChildren = ArrayUtil.remove(a, file);\n    }\n    else {\n      final Map<String, VirtualFile> m = ensureAsMap();\n      m.put(file.getName(), NullVirtualFile.INSTANCE);\n    }\n  }","id":72673,"modified_method":"public synchronized void removeChild(@NotNull VirtualFile file) {\n    final VirtualFileSystemEntry[] a = asArray();\n    if (a != null) {\n      myChildren = ArrayUtil.remove(a, file);\n    }\n    else {\n      ensureAsMap().put(file.getName(), NULL_VIRTUAL_FILE);\n    }\n  }","commit_id":"063e730e72c76ea822f3c82da643669b8ffa738e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Object entityForName(String name) {\n        Object result = null;\n        if(name == null) return null;\n        String lowerCaseName = name.toLowerCase();\n        if (entityNames == null) {\n            entityNames = (NSArray)((NSArray)ERXUtilities.entitiesForModelGroup(EOModelGroup.defaultGroup()).valueForKey(\"name\")).valueForKey(\"toLowerCase\");\n        }\n        NSMutableArray possibleEntities = new NSMutableArray();\n        for (Enumeration e = entityNames.objectEnumerator(); e.hasMoreElements();) {\n            String lowercaseEntityName = (String)e.nextElement();\n            if (lowerCaseName.indexOf(lowercaseEntityName) != -1)\n                possibleEntities.addObject(lowercaseEntityName);\n        }\n        if (possibleEntities.count() == 1) {\n            result = ERXUtilities.caseInsensitiveEntityNamed((String)possibleEntities.lastObject());\n        } else if (possibleEntities.count() > 1) {\n            ERXUtilities.sortEOsUsingSingleKey(possibleEntities, \"length\");\n            if (((String)possibleEntities.objectAtIndex(0)).length() == ((String)possibleEntities.objectAtIndex(1)).length())\n                log.warn(\"Found multiple entities of the same length for configuration: \" + name\n                         + \" possible entities: \" + possibleEntities);\n            result = ERXUtilities.caseInsensitiveEntityNamed((String)possibleEntities.lastObject());\n        }\n        if (log.isDebugEnabled())\n            log.debug(\"Found possible entities: \" + possibleEntities + \" for configuration: \" + name\n                      + \" result: \" + result);\n        return result;\n    }","id":72674,"modified_method":"protected Object entityForName(String name) {\n        Object result = null;\n        if(name != null) {\n            String lowerCaseName = name.toLowerCase();\n            if (entityNames == null) {\n                entityNames = (NSArray)((NSArray)ERXUtilities.entitiesForModelGroup(EOModelGroup.defaultGroup()).valueForKey(\"name\")).valueForKey(\"toLowerCase\");\n            }\n            NSMutableArray possibleEntities = new NSMutableArray();\n            for (Enumeration e = entityNames.objectEnumerator(); e.hasMoreElements();) {\n                String lowercaseEntityName = (String)e.nextElement();\n                if (lowerCaseName.indexOf(lowercaseEntityName) != -1)\n                    possibleEntities.addObject(lowercaseEntityName);\n            }\n            if (possibleEntities.count() == 1) {\n                result = ERXUtilities.caseInsensitiveEntityNamed((String)possibleEntities.lastObject());\n            } else if (possibleEntities.count() > 1) {\n                ERXArrayUtilities.sortedArraySortedWithKey(possibleEntities, \"length\");\n                if (((String)possibleEntities.objectAtIndex(0)).length() == ((String)possibleEntities.objectAtIndex(1)).length())\n                    log.warn(\"Found multiple entities of the same length for configuration: \" + name\n                             + \" possible entities: \" + possibleEntities);\n                result = ERXUtilities.caseInsensitiveEntityNamed((String)possibleEntities.lastObject());\n            }\n            if (log.isDebugEnabled())\n                log.debug(\"Found possible entities: \" + possibleEntities + \" for configuration: \" + name\n                          + \" result: \" + result);\n        }\n        return result;\n    }","commit_id":"bdcbb32da149a253db0f2e17173a24e361acd8c8","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object fire(D2WContext c) {\n        Object result = null;\n        // is it an entity name?\n        if (value() != null && value() instanceof String && ((String)value()).length() > 0) {\n            result = ERXUtilities.caseInsensitiveEntityNamed(((String)value()).toLowerCase());\n        }\n        // maybe it is a key? get the entity name from there.\n        if(result == null && value() != null && value() instanceof String) {\n            result = entityForName((String)c.valueForKey((String)value()));\n        }\n        // try the pageConfiguration, if that does not match, give up\n        if(result == null) {\n            String name = (String)c.valueForKey(\"pageConfiguration\");\n            if (result == null && name != null) {\n                result = entityForName(name);\n            }\n        }\n        return result;\n    }","id":72675,"modified_method":"public Object fire(D2WContext c) {\n        Object result = null;\n        // is it an entity name?\n        if (value() != null && value() instanceof String && ((String)value()).length() > 0) {\n            result = ERXUtilities.caseInsensitiveEntityNamed(((String)value()).toLowerCase());\n        }\n        // maybe it is a key? get the entity name from there.\n        if(result == null && value() != null && value() instanceof String) {\n            result = entityForName((String)value());\n        }\n        // try the pageConfiguration, if that does not match, give up\n        if(result == null) {\n            result = entityForKey(c, \"pageConfiguration\");\n        }\n        return result;\n    }","commit_id":"bdcbb32da149a253db0f2e17173a24e361acd8c8","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object entityForControllerName(D2WContext c) {\n        return entityForName((String)c.valueForKey(\"controllerName\"));\n    }","id":72676,"modified_method":"public Object entityForControllerName(D2WContext c) {\n        return entityForKey(c, \"controllerName\");\n    }","commit_id":"bdcbb32da149a253db0f2e17173a24e361acd8c8","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object entityForPageConfiguration(D2WContext c) {\n        return entityForName((String)c.valueForKey(\"pageConfiguration\"));\n    }","id":72677,"modified_method":"public Object entityForPageConfiguration(D2WContext c) {\n        return entityForKey(c, \"pageConfiguration\");\n    }","commit_id":"bdcbb32da149a253db0f2e17173a24e361acd8c8","url":"https://github.com/wocommunity/wonder"},{"original_method":"List<String> getContext(GoogleToken token, List<GoogleToken> tokens, String newToken, int toLeft, int toRight) {\n    int pos = tokens.indexOf(token);\n    if (pos == -1) {\n      throw new RuntimeException(\"Token not found: \" + token);\n    }\n    List<String> result = new ArrayList<>();\n    for (int i = 1, added = 0; added < toLeft; i++) {\n      if (pos-i < 0) {\n        // We don't use v2 of the Google data everywhere, so we don't always have the \"_START_\"\n        // marker. So if we're at the beginning of the sentence, just use the first tokens\n        // without an artificial start marker:\n        result.clear();\n        result.add(newToken);\n        for (int j = pos-1; j >= 0; j--) {\n          result.add(0, tokens.get(j).token);\n        }\n        return result;\n      } else {\n        if (!tokens.get(pos-i).isWhitespace()) {\n          result.add(0, tokens.get(pos - i).token);\n          added++;\n        }\n      }\n    }\n    result.add(newToken);\n    for (int i = 1, added = 0; added < toRight; i++) {\n      if (pos+i >= tokens.size()) {\n        result.add(\".\");\n        added++;\n      } else {\n        if (!tokens.get(pos+i).isWhitespace()) {\n          result.add(tokens.get(pos + i).token);\n          added++;\n        }\n      }\n    }\n    return result;\n  }","id":72678,"modified_method":"List<String> getContext(GoogleToken token, List<GoogleToken> tokens, String newToken, int toLeft, int toRight) {\n    return getContext(token, tokens, Collections.singletonList(new GoogleToken(newToken, 0, newToken.length())), toLeft, toRight);\n  }","commit_id":"bc68a502525396b69c29ef33f0d7a0a13094eca3","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private double get3gramProbabilityFor(GoogleToken token, List<GoogleToken> tokens, String term) {\n    Probability ngram3Left = getPseudoProbability(getContext(token, tokens, term, 0, 2));\n    Probability ngram3Middle = getPseudoProbability(getContext(token, tokens, term, 1, 1));\n    Probability ngram3Right = getPseudoProbability(getContext(token, tokens, term, 2, 0));\n    if (ngram3Left.coverage < MIN_COVERAGE && ngram3Middle.coverage < MIN_COVERAGE && ngram3Right.coverage < MIN_COVERAGE) {\n      debug(\"  Min coverage of %.2f not reached: %.2f, %.2f, %.2f, assuming p=0\\n\", MIN_COVERAGE, ngram3Left.coverage, ngram3Middle.coverage, ngram3Right.coverage);\n      return 0.0;\n    } else {\n      //debug(\"  Min coverage of %.2f okay: %.2f, %.2f\\n\", MIN_COVERAGE, ngram3Left.coverage, ngram3Right.coverage);\n      return ngram3Left.prob * ngram3Middle.prob * ngram3Right.prob;\n    }\n  }","id":72679,"modified_method":"private double get3gramProbabilityFor(GoogleToken token, List<GoogleToken> tokens, String term) {\n    List<GoogleToken> newTokens = getGoogleTokens(term);\n    Probability ngram3Left;\n    Probability ngram3Middle;\n    Probability ngram3Right;\n    if (newTokens.size() == 1) {\n      ngram3Left = getPseudoProbability(getContext(token, tokens, term, 0, 2));\n      ngram3Middle = getPseudoProbability(getContext(token, tokens, term, 1, 1));\n      ngram3Right = getPseudoProbability(getContext(token, tokens, term, 2, 0));\n    } else if (newTokens.size() == 2) {\n      // e.g. you're -> you 're\n      ngram3Left = getPseudoProbability(getContext(token, tokens, newTokens, 0, 1));\n      ngram3Right = getPseudoProbability(getContext(token, tokens, newTokens, 1, 0));\n      // we cannot just use new Probability(1.0, 1.0f) as that would always produce higher\n      // probabilities than in the case of one token (eg. \"your\"):\n      ngram3Middle = new Probability((ngram3Left.prob + ngram3Right.prob) / 2, 1.0f); \n    } else {\n      throw new RuntimeException(\"Words that consists of more than 2 tokens (according to Google tokenization) are not supported yet: \" + term);\n    }\n    if (ngram3Left.coverage < MIN_COVERAGE && ngram3Middle.coverage < MIN_COVERAGE && ngram3Right.coverage < MIN_COVERAGE) {\n      debug(\"  Min coverage of %.2f not reached: %.2f, %.2f, %.2f, assuming p=0\\n\", MIN_COVERAGE, ngram3Left.coverage, ngram3Middle.coverage, ngram3Right.coverage);\n      return 0.0;\n    } else {\n      //debug(\"  Min coverage of %.2f okay: %.2f, %.2f\\n\", MIN_COVERAGE, ngram3Left.coverage, ngram3Right.coverage);\n      return ngram3Left.prob * ngram3Middle.prob * ngram3Right.prob;\n    }\n  }","commit_id":"bc68a502525396b69c29ef33f0d7a0a13094eca3","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"Probability getPseudoProbability(List<String> context) {\n    int maxCoverage = 0;\n    int coverage = 0;\n    long firstWordCount = lm.getCount(context.get(0));\n    maxCoverage++;\n    if (firstWordCount == 0) {\n      debug(\"    # zero matches for '%s'\\n\", context.get(0));\n    } else {\n      coverage++;\n    }\n    // chain rule:\n    double p = (double) (firstWordCount + 1) / (totalTokenCount + 1);\n    debug(\"    P for %s: %.20f\\n\", context.get(0), p);\n    for (int i = 2; i <= context.size(); i++) {\n      List<String> subList = context.subList(0, i);\n      long phraseCount = lm.getCount(subList);\n      double thisP = (double) (phraseCount + 1) / (firstWordCount + 1);\n      maxCoverage++;\n      debug(\"    P for \" + subList + \": %.20f\\n\", thisP);\n      if (phraseCount == 0) {\n        debug(\"    # zero matches for '%s'\\n\", subList);\n      } else {\n        coverage++;\n      }\n      p *= thisP;\n    }\n    debug(\"  \" + StringTools.listToString(context, \" \") + \" => %.20f\\n\", p);\n    return new Probability(p, (float)coverage/maxCoverage);\n  }","id":72680,"modified_method":"Probability getPseudoProbability(List<String> context) {\n    int maxCoverage = 0;\n    int coverage = 0;\n    long firstWordCount = lm.getCount(context.get(0));\n    maxCoverage++;\n    if (firstWordCount > 0) {\n      coverage++;\n    }\n    // chain rule:\n    double p = (double) (firstWordCount + 1) / (totalTokenCount + 1);\n    debug(\"    P for %s: %.20f (%d)\\n\", context.get(0), p, firstWordCount);\n    for (int i = 2; i <= context.size(); i++) {\n      List<String> subList = context.subList(0, i);\n      long phraseCount = lm.getCount(subList);\n      double thisP = (double) (phraseCount + 1) / (firstWordCount + 1);\n      maxCoverage++;\n      debug(\"    P for \" + subList + \": %.20f (%d)\\n\", thisP, phraseCount);\n      if (phraseCount > 0) {\n        coverage++;\n      }\n      p *= thisP;\n    }\n    debug(\"  \" + StringTools.listToString(context, \" \") + \" => %.20f\\n\", p);\n    return new Probability(p, (float)coverage/maxCoverage);\n  }","commit_id":"bc68a502525396b69c29ef33f0d7a0a13094eca3","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@NotNull\n    @Override\n    public List<SNode> apply(@NotNull SNode macro, SNode templateNode, @NotNull TemplateContext templateContext) throws\n        DismissTopMappingRuleException, GenerationFailureException, GenerationCanceledException, TemplateProcessingFailureException {\n      // $WEAVE$\n      List<SNode> _outputNodes = myTemplateProcessor.applyTemplate(templateNode, templateContext, macro);\n      if (_outputNodes.isEmpty()) {\n        return Collections.emptyList();\n      }\n      if (_outputNodes.size() == 1) {\n        SNode contextNode = _outputNodes.get(0);\n\n        List<SNode> nodesToWeave = getNewInputNodes(macro, templateContext);\n        for (SNode node : nodesToWeave) {\n          try {\n            myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(node));\n            myTracer.pushRuleConsequence(new jetbrains.mps.smodel.SNodePointer(macro));\n            SNode consequence = RuleUtil.getWeaveMacro_Consequence(macro);\n            if (consequence == null) {\n              showErrorMessage(templateContext.getInput(), null, macro, \"couldn't evaluate weave macro: no consequence\");\n              break;\n            }\n\n            SNode template = RuleUtil.getTemplateDeclarationReference_Template(consequence);\n            myTemplateProcessor.weaveMacro(template, contextNode, templateContext.subContext(null, node), macro);\n          } finally {\n            myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(node));\n          }\n        }\n\n      } else {\n        getLogger().error(templateContext.getInput().getReference(), \"cannot apply $WEAVE$ to a list of nodes\",\n            GeneratorUtil.describe(macro, \"template\"),\n            GeneratorUtil.describe(templateContext.getInput(), \"input\"));\n      }\n      return _outputNodes;\n    }","id":72681,"modified_method":"@NotNull\n    @Override\n    public List<SNode> apply(@NotNull SNode macro, SNode templateNode, @NotNull TemplateContext templateContext) throws\n        DismissTopMappingRuleException, GenerationFailureException, GenerationCanceledException, TemplateProcessingFailureException {\n      // $WEAVE$\n      List<SNode> _outputNodes = myTemplateProcessor.applyTemplate(templateNode, templateContext, macro);\n      if (_outputNodes.isEmpty()) {\n        return Collections.emptyList();\n      }\n      if (_outputNodes.size() > 1) {\n        getLogger().error(macro.getReference(), \"cannot apply $WEAVE$ to a list of nodes\",\n            GeneratorUtil.describe(templateContext.getInput(), \"input\"));\n        return _outputNodes;\n      }\n      SNode consequence = RuleUtil.getWeaveMacro_Consequence(macro);\n      if (consequence == null) {\n        getLogger().error(macro.getReference(), \"couldn't evaluate weave macro: no consequence\",\n            GeneratorUtil.describeIfExists(templateContext.getInput(), \"input\"));\n        return _outputNodes;\n      }\n\n      SNode template = RuleUtil.getTemplateDeclarationReference_Template(consequence);\n      ////\n      if (template == null) {\n        getLogger().error(macro.getReference(), \"couldn't evaluate weave macro: no template\",\n            GeneratorUtil.describeIfExists(templateContext.getInput(), \"input\"));\n        return _outputNodes;\n      }\n      WeaveTemplateContainer wtc = new WeaveTemplateContainer(template);\n      wtc.initialize(getLogger());\n\n      SNode contextNode = _outputNodes.get(0);\n      List<SNode> nodesToWeave = getNewInputNodes(macro, templateContext);\n      for (SNode node : nodesToWeave) {\n        try {\n          myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(node));\n          myTracer.pushRuleConsequence(new jetbrains.mps.smodel.SNodePointer(macro));\n\n          wtc.apply(contextNode, templateContext.subContext(node), myTemplateProcessor.getEnvironment());\n        } finally {\n          myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(node));\n        }\n      }\n      return _outputNodes;\n    }","commit_id":"b80c854f2af89b0761ee3d73bec9b64ff9bf952d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void weaveTemplateDeclaration(SNode outputContextNode, @NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws GenerationException {\n\n    environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(context.getInput()));\n    try {\n      weaveTemplateDeclaration_intern(outputContextNode, context, environment);\n    } finally {\n      environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(context.getInput()));\n    }\n  }","id":72682,"modified_method":"void weaveTemplateDeclaration(SNode outputContextNode, @NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    if (template == null) {\n      environment.getLogger().error(getRuleNode(), \"couldn't evaluate weaving rule: no template\");\n      return;\n    }\n    environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(context.getInput()));\n    try {\n      WeaveTemplateContainer wtc = getWeavingTemplateContainer(environment.getLogger());\n      wtc.apply(outputContextNode, context.subContext(ruleMappingName), environment);\n    } finally {\n      environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(context.getInput()));\n    }\n  }","commit_id":"b80c854f2af89b0761ee3d73bec9b64ff9bf952d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TemplateWeavingRuleInterpreted(SNode rule) {\n    ruleNode = rule;\n    applicableConcept = NameUtil.nodeFQName(RuleUtil.getBaseRuleApplicableConcept(ruleNode));\n\n    SNode condition = RuleUtil.getBaseRuleCondition(ruleNode);\n    conditionMethod = condition == null ? null : TemplateFunctionMethodName.baseMappingRule_Condition(condition);\n\n    consequenceNode = RuleUtil.getWeaving_Consequence(ruleNode);\n    if (consequenceNode == null) {\n      consequence = null;\n      template = null;\n    } else {\n      String consequenceConceptFQName = consequenceNode.getConcept().getQualifiedName();\n      if (consequenceConceptFQName.equals(RuleUtil.concept_TemplateDeclarationReference)) {\n        consequence = new TemplateDeclarationConsequence();\n        template = RuleUtil.getTemplateDeclarationReference_Template(consequenceNode);\n      } else if (consequenceConceptFQName.equals(RuleUtil.concept_WeaveEach_RuleConsequence)) {\n        consequence = new ForeachConsequence(consequenceNode);\n        template = RuleUtil.getWeaveEach_Template(consequenceNode);\n      } else {\n        consequence = new InvalidConsequence();\n        template = null;\n      }\n    }\n\n    templateFragments = template != null ? GeneratorUtilEx.getTemplateFragments(template) : null;\n    ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n  }","id":72683,"modified_method":"public TemplateWeavingRuleInterpreted(SNode rule) {\n    ruleNode = rule;\n    applicableConcept = NameUtil.nodeFQName(RuleUtil.getBaseRuleApplicableConcept(ruleNode));\n\n    SNode condition = RuleUtil.getBaseRuleCondition(ruleNode);\n    conditionMethod = condition == null ? null : TemplateFunctionMethodName.baseMappingRule_Condition(condition);\n\n    consequenceNode = RuleUtil.getWeaving_Consequence(ruleNode);\n    if (consequenceNode == null) {\n      consequence = null;\n      template = null;\n    } else {\n      String consequenceConceptFQName = consequenceNode.getConcept().getQualifiedName();\n      if (consequenceConceptFQName.equals(RuleUtil.concept_TemplateDeclarationReference)) {\n        consequence = new TemplateDeclarationConsequence();\n        template = RuleUtil.getTemplateDeclarationReference_Template(consequenceNode);\n      } else if (consequenceConceptFQName.equals(RuleUtil.concept_WeaveEach_RuleConsequence)) {\n        consequence = new ForeachConsequence(consequenceNode);\n        template = RuleUtil.getWeaveEach_Template(consequenceNode);\n      } else {\n        consequence = new InvalidConsequence();\n        template = null;\n      }\n    }\n    ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n  }","commit_id":"b80c854f2af89b0761ee3d73bec9b64ff9bf952d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean apply(IGenerationTracer tracer) throws GenerationFailureException, GenerationCanceledException {\n      try {\n        DefaultTemplateContext context = new DefaultTemplateContext(myApplicableNode);\n        SNode outputContextNode = myEnv.getQueryExecutor().getContextNode(myRule, myEnv, context);\n        if (!checkContext(outputContextNode)) {\n          return false;\n        }\n\n        boolean someOutputGenerated = true;\n        tracer.pushInputNode(GenerationTracerUtil.getSNodePointer(myApplicableNode));\n        tracer.pushRule(myRule.getRuleNode());\n        try {\n          someOutputGenerated = myRule.apply(myEnv, context, outputContextNode);\n\n        } catch (DismissTopMappingRuleException e) {\n          myEnv.getGenerator().showErrorMessage(context.getInput(), null, myRule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"wrong template: dismiss in weaving rule is not supported\");\n        } catch (TemplateProcessingFailureException e) {\n          myEnv.getGenerator().showErrorMessage(context.getInput(), null, myRule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"weaving rule: error processing template fragment\");\n        } finally {\n          if (someOutputGenerated) {\n           tracer.closeInputNode(GenerationTracerUtil.getSNodePointer(myApplicableNode));\n          } else {\n            tracer.popInputNode(GenerationTracerUtil.getSNodePointer(myApplicableNode));\n          }\n        }\n      } catch (GenerationCanceledException ex) {\n        throw ex;\n      } catch (GenerationFailureException ex) {\n        throw ex;\n      } catch (GenerationException e) {\n        myEnv.getGenerator().showErrorMessage(null, myRule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"internal error: \" + e.toString());\n      }\n      return true; // original code did myGenerator.setChanged once checkContext had passed.\n    }","id":72684,"modified_method":"public boolean apply(IGenerationTracer tracer) throws GenerationFailureException, GenerationCanceledException {\n      try {\n        DefaultTemplateContext context = new DefaultTemplateContext(myApplicableNode);\n        SNode outputContextNode = myEnv.getQueryExecutor().getContextNode(myRule, myEnv, context);\n        if (!checkContext(outputContextNode)) {\n          return false;\n        }\n\n        boolean someOutputGenerated = true;\n        tracer.pushInputNode(GenerationTracerUtil.getSNodePointer(myApplicableNode));\n        tracer.pushRule(myRule.getRuleNode());\n        try {\n          someOutputGenerated = myRule.apply(myEnv, context, outputContextNode);\n\n        } catch (DismissTopMappingRuleException e) {\n          myEnv.getLogger().error(myRule.getRuleNode(), \"wrong template: dismiss in weaving rule is not supported\", GeneratorUtil.describeIfExists(context.getInput(), \"input node\"));\n        } catch (TemplateProcessingFailureException e) {\n          myEnv.getGenerator().showErrorMessage(context.getInput(), null, myRule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"weaving rule: error processing template fragment\");\n        } finally {\n          if (someOutputGenerated) {\n           tracer.closeInputNode(GenerationTracerUtil.getSNodePointer(myApplicableNode));\n          } else {\n            tracer.popInputNode(GenerationTracerUtil.getSNodePointer(myApplicableNode));\n          }\n        }\n      } catch (GenerationCanceledException ex) {\n        throw ex;\n      } catch (GenerationFailureException ex) {\n        throw ex;\n      } catch (GenerationException e) {\n        myEnv.getGenerator().showErrorMessage(null, myRule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"internal error: \" + e.toString());\n      }\n      return true; // original code did myGenerator.setChanged once checkContext had passed.\n    }","commit_id":"b80c854f2af89b0761ee3d73bec9b64ff9bf952d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void dump() {\n    for (CopyRoot root : roots) {\n      char c = root.deleted ? '-' : (root.mySubTrees.length > 0 ? '+' : '~');\n      System.out.printf(\"%c%s\\n\", c, SNodeUtil.getDebugText(root.myRoot));\n      for (SubTree tree : root.mySubTrees) {\n        if (tree.isCopySrcRoot()) {\n          System.out.printf(\"    copysrc %s\\n\", tree.myInputNode);\n        } else {\n          System.out.printf(\"    %s - %d - %s\\n\", tree.myRoleInParent, tree.mySubTree.size(), tree.myInputNode);\n        }\n      }\n    }\n    System.out.println();\n  }","id":72685,"modified_method":"public void dump() {\n    for (DeltaRoot dr : myDelta) {\n      if (dr instanceof NewRoot) {\n        System.out.printf(\"+%s\\n\", SNodeUtil.getDebugText(((NewRoot) dr).myRoot));\n      } else if (dr instanceof ReplacedRoot) {\n        ReplacedRoot rr = (ReplacedRoot) dr;\n        System.out.printf(\"R%s - %d\\n\", SNodeUtil.getDebugText(rr.myReplacedRoot), rr.myReplacements.size());\n      } else {\n        CopyRoot root = (CopyRoot) dr;\n        char c = root.deleted ? '-' : (root.mySubTrees.length > 0 ? '*' : '~');\n        System.out.printf(\"%c%s\\n\", c, SNodeUtil.getDebugText(root.myRoot));\n        for (SubTree tree : root.mySubTrees) {\n          if (tree.isCopySrcRoot()) {\n            System.out.printf(\"    copysrc %s\\n\", tree.myInputNode);\n          } else {\n            System.out.printf(\"    %s - %d - %s\\n\", tree.myRoleInParent, tree.mySubTree.size(), tree.myInputNode);\n          }\n        }\n      }\n    }\n    System.out.println();\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyInplace(SModel inputModel, TemplateGenerator generator) {\n    HashSet<SNode> allReplacedNodes = new HashSet<SNode>();\n    for (CopyRoot root : roots) {\n      if (root.deleted) {\n        // reference target under deleted root needs update, too\n        allReplacedNodes.add(root.myRoot);\n      } else {\n        allReplacedNodes.addAll(root.getReplacedNodes());\n      }\n    }\n    // FastNodeFinder update mechanism performs poorly (badly, in fact) with massive in-place updates.\n    // It's faster to rebuild FNF completely than to update it. E.g step 4 for lang.editor/editor\n    // spent 90 seconds out of 105 in replace of 9k children\n    if (inputModel instanceof SModelInternal) {\n      ((SModelInternal) inputModel).disposeFastNodeFinder();\n    }\n    // update references between changed model elements\n    for (CopyRoot root : roots) {\n      final SModelReference inputModelRef = inputModel.getReference();\n      final Set<SNode> replacedNodes;\n      if (root.deleted) {\n        replacedNodes = Collections.singleton(root.myRoot);\n      } else {\n        replacedNodes = root.getReplacedNodes();\n        TreeIterator<SNode> it = (TreeIterator<SNode>) SNodeUtil.getDescendants(root.myRoot).iterator();\n        while (it.hasNext()) {\n          SNode next = it.next();\n          if (replacedNodes.contains(next)) {\n            // nodes under replaced already have PostponedReferences\n            it.skipChildren();\n            continue;\n          }\n          for (SReference reference : next.getReferences()) {\n            assert reference instanceof PostponedReference == false : \"!!! unexpected PostponedReference in the input model\";\n            if (!inputModelRef.equals(reference.getTargetSModelReference())) {\n              continue;\n            }\n            SNode target = reference.getTargetNode();\n            while (target != null) {\n              if (allReplacedNodes.contains(target)) {\n                // reference points elsewhere in this model under a replaced node.\n                // reference needs update, its target is among replaced nodes\n                ReferenceInfo refInfo = new ReferenceInfo_CopiedInputNode(reference.getRole(), next, reference.getSourceNode(), target);\n                PostponedReference pr = new PostponedReference(refInfo);\n                pr.setReferenceInOutputSourceNode();\n                break; // while target\n              }\n              target = target.getParent();\n            }\n          }\n        }\n      }\n      // make references to point to node directly, not (ModelId+NodeId)\n      // as it would be impossible to resolve model once root is detached\n      for (SNode rn : replacedNodes) {\n        for (SNode n : SNodeUtil.getDescendants(rn)) {\n          for (SReference r : n.getReferences()) {\n            if (!inputModelRef.equals(r.getTargetSModelReference()) || ! (r instanceof StaticReference)) {\n              continue;\n            }\n            ((StaticReference) r).makeDirect();\n          }\n        }\n      }\n    }\n    // make the structure change, at last\n    for (CopyRoot root : roots) {\n      if (root.deleted) {\n        assert root.myRoot.getModel() == inputModel;\n        inputModel.removeRootNode(root.myRoot);\n        continue;\n      }\n      // replace nodes\n      for (SubTree tree : root.mySubTrees) {\n        if (tree.isCopySrcRoot()) {\n          continue;\n        }\n        assert tree.myInputNode.getModel() == inputModel;\n        SNode inputParentNode = tree.myInputNode.getParent();\n        SNode anchor = tree.myInputNode.getNextSibling();\n        inputParentNode.removeChild(tree.myInputNode);\n        for (SNode replacement : tree.mySubTree) {\n          inputParentNode.insertChildBefore(tree.myRoleInParent, replacement, anchor);\n        }\n      }\n    }\n  }","id":72686,"modified_method":"public void applyInplace(SModel inputModel, TemplateGenerator generator) {\n    HashSet<SNode> allReplacedNodes = new HashSet<SNode>();\n    for (CopyRoot root : myCopyRoots) {\n      if (root.deleted) {\n        // reference target under deleted root needs update, too\n        allReplacedNodes.add(root.myRoot);\n      } else {\n        allReplacedNodes.addAll(root.getReplacedNodes());\n      }\n    }\n    for (ReplacedRoot rr : myReplacedRoots) {\n      allReplacedNodes.add(rr.myReplacedRoot);\n    }\n    // FastNodeFinder update mechanism performs poorly (badly, in fact) with massive in-place updates.\n    // It's faster to rebuild FNF completely than to update it. E.g step 4 for lang.editor/editor\n    // spent 90 seconds out of 105 in replace of 9k children\n    // TODO make use of standalone FNF\n    if (inputModel instanceof SModelInternal) {\n      ((SModelInternal) inputModel).disposeFastNodeFinder();\n    }\n    final SModelReference inputModelRef = inputModel.getReference();\n    // update references between changed model elements\n    for (CopyRoot root : myCopyRoots) {\n      final Set<SNode> replacedNodes;\n      if (root.deleted) {\n        continue;\n      }\n      replacedNodes = root.getReplacedNodes();\n      TreeIterator<SNode> it = (TreeIterator<SNode>) SNodeUtil.getDescendants(root.myRoot).iterator();\n      while (it.hasNext()) {\n        SNode next = it.next();\n        if (replacedNodes.contains(next)) {\n          // nodes under replaced already have PostponedReferences\n          it.skipChildren();\n          continue;\n        }\n        for (SReference reference : next.getReferences()) {\n          assert reference instanceof PostponedReference == false : \"!!! unexpected PostponedReference in the input model\";\n          if (!inputModelRef.equals(reference.getTargetSModelReference())) {\n            continue;\n          }\n          SNode target = reference.getTargetNode();\n          while (target != null) {\n            if (allReplacedNodes.contains(target)) {\n              // reference points elsewhere in this model under a replaced node.\n              // reference needs update, its target is among replaced nodes\n              ReferenceInfo refInfo = new ReferenceInfo_CopiedInputNode(reference.getRole(), next, reference.getSourceNode(), target);\n              PostponedReference pr = new PostponedReference(refInfo);\n              pr.setReferenceInOutputSourceNode();\n              break; // while target\n            }\n            target = target.getParent();\n          }\n        }\n      }\n    }\n    // make references to point to node directly, not (ModelId+NodeId)\n    // as it would be impossible to resolve model once root is detached\n    for (SNode rn : allReplacedNodes) {\n      for (SNode n : SNodeUtil.getDescendants(rn)) {\n        for (SReference r : n.getReferences()) {\n          if (!inputModelRef.equals(r.getTargetSModelReference()) || ! (r instanceof StaticReference)) {\n            continue;\n          }\n          ((StaticReference) r).makeDirect();\n        }\n      }\n    }\n    // make the structure change, at last\n    for (DeltaRoot dr : myDelta) {\n      // additions from NewRoot and ReplacedRoot come in the order they were scheduled to be applied\n      // not the order they were ready - to get same order in parallel gen. Although additions from replaced\n      // come to the tail of root nodes list as there's no way to keep index of root node.\n      if (dr instanceof NewRoot) {\n        inputModel.addRootNode(((NewRoot) dr).myRoot);\n      } else if (dr instanceof ReplacedRoot) {\n        ReplacedRoot rr = (ReplacedRoot) dr;\n        // XXX Seems there's no way to replace root node in its original position ?!\n        inputModel.removeRootNode(rr.myReplacedRoot);\n        for (SNode replacement : rr.myReplacements) {\n          inputModel.addRootNode(replacement);\n        }\n      } else {\n        CopyRoot root = (CopyRoot) dr;\n        if (root.deleted) {\n          assert root.myRoot.getModel() == inputModel;\n          inputModel.removeRootNode(root.myRoot);\n          continue;\n        }\n        // replace nodes\n        for (SubTree tree : root.mySubTrees) {\n          if (tree.isCopySrcRoot()) {\n            continue;\n          }\n          assert tree.myInputNode.getModel() == inputModel;\n          SNode inputParentNode = tree.myInputNode.getParent();\n          SNode anchor = tree.myInputNode.getNextSibling();\n          inputParentNode.removeChild(tree.myInputNode);\n          for (SNode replacement : tree.mySubTree) {\n            inputParentNode.insertChildBefore(tree.myRoleInParent, replacement, anchor);\n          }\n        }\n      }\n    }\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean hasChanges() {\n    for (CopyRoot root : roots) {\n      if (root.deleted) {\n        return true;\n      }\n      for (SubTree tree : root.mySubTrees) {\n        if (!tree.isCopySrcRoot()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":72687,"modified_method":"public boolean hasChanges() {\n    for (DeltaRoot dr : myDelta) {\n      if (false == dr instanceof CopyRoot) {\n        return true; // both new and replaced root do constitute a change\n      }\n      if (((CopyRoot) dr).bringsChanges()) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void enterInputRoot(@NotNull SNode node) {\n    assert getCurrentRoot() == null;\n    assert getCurrentFragments().isEmpty();\n    final CopyRoot r = new CopyRoot(node);\n    setCurrentRoot(r);\n    initCurrentFragments();\n    roots.add(r);\n  }","id":72688,"modified_method":"public void enterInputRoot(@NotNull SNode node) {\n    assert getCurrentRoot() == null;\n    assert getCurrentFragments().isEmpty();\n    final CopyRoot r = new CopyRoot(node);\n    setCurrentRoot(r);\n    initCurrentFragments();\n    myCopyRoots.add(r);\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected DeltaBuilder(List<CopyRoot> rootsStorage) {\n    roots = rootsStorage;\n  }","id":72689,"modified_method":"protected DeltaBuilder(List<CopyRoot> rootsStorage) {\n    myCopyRoots = rootsStorage;\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void leaveInputRoot(@NotNull SNode node) {\n    assert getCurrentRoot() != null;\n    if (getCurrentRoot().myRoot != node) {\n      throw new IllegalStateException();\n    }\n\n    final List<SubTree> fragments = getCurrentFragments();\n    getCurrentRoot().mySubTrees = fragments.toArray(new SubTree[fragments.size()]);\n    setCurrentRoot(null);\n    clearCurrentFragments();\n  }","id":72690,"modified_method":"public void leaveInputRoot(@NotNull SNode node) {\n    assert getCurrentRoot() != null;\n    assert getCurrentRoot().myRoot == node;\n\n    final List<SubTree> fragments = getCurrentFragments();\n    getCurrentRoot().mySubTrees = fragments.toArray(new SubTree[fragments.size()]);\n    setCurrentRoot(null);\n    clearCurrentFragments();\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void deleteInputRoot(@NotNull SNode node) {\n    assert getCurrentRoot() != null;\n    assert getCurrentFragments().isEmpty();\n    if (getCurrentRoot().myRoot != node || !getCurrentFragments().isEmpty()) {\n      throw new IllegalStateException();\n    }\n    getCurrentRoot().deleted = true;\n  }","id":72691,"modified_method":"public void deleteInputRoot(@NotNull SNode node) {\n    CopyRoot currentRoot = getCurrentRoot();\n    assert currentRoot != null;\n    assert getCurrentFragments().isEmpty();\n    if (currentRoot.myRoot != node || !getCurrentFragments().isEmpty()) {\n      throw new IllegalStateException();\n    }\n    currentRoot.deleted = true;\n    synchronized (myDelta) { // XXX synchronize here is just quick-n-dirty guard, revisit multi-threading and use of ThreadLocals\n      // we don't care about order of deletions\n      myDelta.add(currentRoot);\n    }\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void createRootNodeByRule(TemplateRootMappingRule rule, SNode inputNode, boolean copyRootOnFailure, TemplateExecutionEnvironment environment)\n    throws GenerationCanceledException, GenerationFailureException {\n    try {\n      Collection<SNode> outputNodes = environment.getQueryExecutor().applyRule(rule, environment, new DefaultTemplateContext(inputNode));\n      if (outputNodes == null) {\n        return;\n      }\n\n      registerAddedRoots(outputNodes);\n      for (SNode outputNode : outputNodes) {\n        registerRoot(outputNode, inputNode, rule.getRuleNode(), false);\n        setChanged();\n        // we copy user objects in reduction rules, root mapping rules are no different\n        // in addition, this copies TracingUtil.ORIGINAL_INPUT_NODE, so that outputNodes\n        // are marked as originating at inputNode's origin\n        jetbrains.mps.util.SNodeOperations.copyUserObjects(inputNode, outputNode);\n      }\n\n    } catch (DismissTopMappingRuleException e) {\n      // it's ok, just continue\n      if (copyRootOnFailure && inputNode.getModel() != null && inputNode.getParent() == null) {\n        final FullCopyFacility copyFacility = new FullCopyFacility(this, environment);\n        copyFacility.copyRootInputNode(inputNode);\n        if (copyFacility.hasChanges()) {\n          setChanged();\n        }\n      }\n    } catch (TemplateProcessingFailureException e) {\n      showErrorMessage(inputNode, rule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"couldn't create root node\");\n    } catch (GenerationException e) {\n      if (e instanceof GenerationCanceledException) throw (GenerationCanceledException) e;\n      if (e instanceof GenerationFailureException) throw (GenerationFailureException) e;\n      showErrorMessage(inputNode, rule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"internal error: \" + e.toString());\n    }\n  }","id":72692,"modified_method":"protected void createRootNodeByRule(TemplateRootMappingRule rule, SNode inputNode, boolean copyRootOnFailure, TemplateExecutionEnvironment environment)\n    throws GenerationCanceledException, GenerationFailureException {\n    try {\n      Collection<SNode> outputNodes = environment.getQueryExecutor().applyRule(rule, environment, new DefaultTemplateContext(inputNode));\n      if (outputNodes == null) {\n        return;\n      }\n\n      for (SNode outputNode : outputNodes) {\n        registerRoot(outputNode, inputNode, rule.getRuleNode(), false);\n        setChanged();\n        // we copy user objects in reduction rules, root mapping rules are no different\n        // in addition, this copies TracingUtil.ORIGINAL_INPUT_NODE, so that outputNodes\n        // are marked as originating at inputNode's origin\n        jetbrains.mps.util.SNodeOperations.copyUserObjects(inputNode, outputNode);\n      }\n\n    } catch (DismissTopMappingRuleException e) {\n      // it's ok, just continue\n      if (copyRootOnFailure && inputNode.getModel() != null && inputNode.getParent() == null) {\n        final FullCopyFacility copyFacility = new FullCopyFacility(this, environment);\n        copyFacility.copyRootInputNode(inputNode);\n        if (copyFacility.hasChanges()) {\n          setChanged();\n        }\n      }\n    } catch (TemplateProcessingFailureException e) {\n      getLogger().error(rule.getRuleNode(), \"couldn't create root node\", GeneratorUtil.describe(inputNode, \"input node\"));\n    } catch (GenerationException e) {\n      if (e instanceof GenerationCanceledException) throw (GenerationCanceledException) e;\n      if (e instanceof GenerationFailureException) throw (GenerationFailureException) e;\n      getLogger().error(rule.getRuleNode(), \"internal error: \" + e.toString(), GeneratorUtil.describe(inputNode, \"input node\"));\n    }\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean apply(boolean isPrimary) throws GenerationFailureException, GenerationCanceledException {\n    checkMonitorCanceled();\n    myAreMappingsReady = false;\n    // prepare weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor = new WeavingProcessor(this);\n    myWeavingProcessor.prepareWeavingRules(getInputModel(), myRuleManager.getWeaving_MappingRules());\n    ttrace.pop();\n\n\n    ttrace.push(\"reductions\", false);\n    applyReductions(isPrimary);\n    ttrace.pop();\n\n    if (myDeltaBuilder != null) {\n      ttrace.push(\"apply delta changes\", false);\n//      myDeltaBuilder.dump();\n      myInplaceModelChange = true;\n      if (myDeltaBuilder.hasChanges()) {\n        myDeltaBuilder.applyInplace(getInputModel(), this);\n      }\n      if (myNewAddedRoots != null) {\n        // TODO pipe additions through DeltaBuilder as well (instantiate it prior to applyRules and use from registerAddedRoots)\n        for (SNode newRoot : myNewAddedRoots) {\n          getInputModel().addRootNode(newRoot);\n        }\n        myNewAddedRoots.clear();\n      }\n      myOutputRoots.clear();\n      myDeltaBuilder = null;\n      ttrace.pop();\n    }\n\n    myAreMappingsReady = true;\n    myChanged |= myDependenciesBuilder.isStepRequired(); // TODO optimize: if step is required, it should be the last step\n\n    // optimization: no changes? quit\n    if (!isPrimary && !myChanged && myDelayedChanges.isEmpty() && !myRuleManager.hasWeavings()) {\n      return false;\n    }\n\n    if (!myInplaceModelChange) {\n      // publish roots\n      for (SNode outputRoot : myOutputRoots) {\n        myOutputModel.addRootNode(outputRoot);\n      }\n\n      // reload \"required\" roots from cache\n      ttrace.push(\"reloading roots from cache\", false);\n      myDependenciesBuilder.reloadRequired(getMappings());\n      ttrace.pop();\n    } // XXX if in-place change, every required root has been reloaded on previous step, imo\n\n    // weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor.apply();\n    myWeavingProcessor = null;\n    ttrace.pop();\n\n    // optimization: no changes? quit\n    if (!isPrimary && !myChanged && myDelayedChanges.isEmpty()) {\n      return false;\n    }\n\n    // execute mapper in all $MAP_SRC$/$MAP_SRCL$\n    ttrace.push(\"delayed mappings\", false);\n    myDelayedChanges.doAllChanges(this);\n    ttrace.pop();\n\n    if (myChanged || isPrimary) {\n      // new unresolved references could appear after applying reduction rules (all delayed changes should be done before this, like replacing children)\n      ttrace.push(\"restoring references\", false);\n      revalidateAllReferences();\n      ttrace.pop();\n      checkMonitorCanceled();\n\n      // advance blocked reduction data\n      getBlockedReductionsData().advanceStep();\n    }\n    return myChanged;\n  }","id":72693,"modified_method":"public boolean apply(boolean isPrimary) throws GenerationFailureException, GenerationCanceledException {\n    checkMonitorCanceled();\n    myAreMappingsReady = false;\n    // prepare weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor = new WeavingProcessor(this);\n    myWeavingProcessor.prepareWeavingRules(getInputModel(), myRuleManager.getWeaving_MappingRules());\n    ttrace.pop();\n\n\n    ttrace.push(\"reductions\", false);\n    applyReductions(isPrimary);\n    ttrace.pop();\n\n    if (myDeltaBuilder != null) {\n      ttrace.push(\"apply delta changes\", false);\n//      myDeltaBuilder.dump();\n      myInplaceModelChange = true;\n      if (myDeltaBuilder.hasChanges()) {\n        myDeltaBuilder.applyInplace(getInputModel(), this);\n      }\n      myOutputRoots.clear();\n      myDeltaBuilder = null;\n      ttrace.pop();\n    }\n\n    myAreMappingsReady = true;\n    myChanged |= myDependenciesBuilder.isStepRequired(); // TODO optimize: if step is required, it should be the last step\n\n    // optimization: no changes? quit\n    if (!isPrimary && !myChanged && myDelayedChanges.isEmpty() && !myRuleManager.hasWeavings()) {\n      return false;\n    }\n\n    if (!myInplaceModelChange) {\n      // publish roots\n      for (SNode outputRoot : myOutputRoots) {\n        myOutputModel.addRootNode(outputRoot);\n      }\n\n      // reload \"required\" roots from cache\n      ttrace.push(\"reloading roots from cache\", false);\n      myDependenciesBuilder.reloadRequired(getMappings());\n      ttrace.pop();\n    } // XXX if in-place change, every required root has been reloaded on previous step, imo\n\n    // weaving\n    ttrace.push(\"weavings\", false);\n    myWeavingProcessor.apply();\n    myWeavingProcessor = null;\n    ttrace.pop();\n\n    // optimization: no changes? quit\n    if (!isPrimary && !myChanged && myDelayedChanges.isEmpty()) {\n      return false;\n    }\n\n    // execute mapper in all $MAP_SRC$/$MAP_SRCL$\n    ttrace.push(\"delayed mappings\", false);\n    myDelayedChanges.doAllChanges(this);\n    ttrace.pop();\n\n    if (myChanged || isPrimary) {\n      // new unresolved references could appear after applying reduction rules (all delayed changes should be done before this, like replacing children)\n      ttrace.push(\"restoring references\", false);\n      revalidateAllReferences();\n      ttrace.pop();\n      checkMonitorCanceled();\n\n      // advance blocked reduction data\n      getBlockedReductionsData().advanceStep();\n    }\n    return myChanged;\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void registerRoot(@NotNull SNode outputRoot, SNode inputNode, SNodeReference templateNode, boolean isCopied) {\n    myOutputRoots.add(outputRoot);\n    myNewToOldRoot.put(outputRoot, inputNode);\n    myDependenciesBuilder.registerRoot(outputRoot, inputNode);\n    if (isCopied) {\n      getGeneratorSessionContext().registerCopiedRoot(outputRoot);\n    }\n  }","id":72694,"modified_method":"protected void registerRoot(@NotNull SNode outputRoot, SNode inputNode, SNodeReference templateNode, boolean isCopied) {\n    myOutputRoots.add(outputRoot);\n    myNewToOldRoot.put(outputRoot, inputNode);\n    myDependenciesBuilder.registerRoot(outputRoot, inputNode);\n    if (isCopied) {\n      getGeneratorSessionContext().registerCopiedRoot(outputRoot);\n    }\n    if (myDeltaBuilder != null) {\n      myDeltaBuilder.registerRoot(inputNode, outputRoot);\n    }\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void createRootNodeByRule(TemplateCreateRootRule rule, TemplateExecutionEnvironment environment) throws GenerationCanceledException, GenerationFailureException {\n    try {\n      Collection<SNode> outputNodes = environment.getQueryExecutor().applyRule(rule, environment);\n      if (outputNodes == null) {\n        return;\n      }\n\n      registerAddedRoots(outputNodes);\n      for (SNode outputNode : outputNodes) {\n        registerRoot(outputNode, null, rule.getRuleNode(), false);\n        setChanged();\n      }\n    } catch (DismissTopMappingRuleException ex) {\n      // it's ok, just continue\n    } catch (TemplateProcessingFailureException e) {\n      showErrorMessage(null, rule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"couldn't create root node\");\n    } catch (GenerationException e) {\n      if (e instanceof GenerationCanceledException) throw (GenerationCanceledException) e;\n      if (e instanceof GenerationFailureException) throw (GenerationFailureException) e;\n      showErrorMessage(null, rule.getRuleNode().resolve(MPSModuleRepository.getInstance()), \"internal error: \" + e.toString());\n    }\n  }","id":72695,"modified_method":"protected void createRootNodeByRule(TemplateCreateRootRule rule, TemplateExecutionEnvironment environment) throws GenerationCanceledException, GenerationFailureException {\n    try {\n      Collection<SNode> outputNodes = environment.getQueryExecutor().applyRule(rule, environment);\n      if (outputNodes == null) {\n        return;\n      }\n\n      for (SNode outputNode : outputNodes) {\n        registerRoot(outputNode, null, rule.getRuleNode(), false);\n        setChanged();\n      }\n    } catch (DismissTopMappingRuleException ex) {\n      // it's ok, just continue\n    } catch (TemplateProcessingFailureException e) {\n      getLogger().error(rule.getRuleNode(), \"couldn't create root node\");\n    } catch (GenerationException e) {\n      if (e instanceof GenerationCanceledException) throw (GenerationCanceledException) e;\n      if (e instanceof GenerationFailureException) throw (GenerationFailureException) e;\n      getLogger().error(rule.getRuleNode(), \"internal error: \" + e.toString());\n    }\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void applyReductions(boolean isPrimary) throws GenerationCanceledException, GenerationFailureException {\n    // create all roots\n    if (isPrimary) {\n      ttrace.push(\"create roots\", false);\n\n      final QueryExecutionContext executionContext = getExecutionContext(null);\n      if (executionContext != null) {\n        TemplateExecutionEnvironment environment = new TemplateExecutionEnvironmentImpl(this, executionContext, new ReductionContext());\n        for (TemplateCreateRootRule rule : myRuleManager.getCreateRootRules()) {\n          checkMonitorCanceled();\n          applyCreateRoot(rule, environment);\n        }\n      }\n      ttrace.pop();\n    }\n\n    // root mapping rules\n    ttrace.push(\"root mappings\", false);\n    ArrayList<SNode> rootsConsumed = new ArrayList<SNode>();\n    for (TemplateRootMappingRule rule : myRuleManager.getRoot_MappingRules()) {\n      checkMonitorCanceled();\n      applyRootRule(rule, rootsConsumed);\n    }\n    ttrace.pop();\n\n    if (myInplaceChangeEnabled) {\n      if (myWeavingProcessor.hasWeavingRulesToApply()) {\n        getLogger().info(\"Could have had delta builder here, but can't due to active weavings\");\n      } else {\n        getLogger().info(\"Active in-place model transformation\");\n        myDeltaBuilder = createDeltaBuilder();\n      }\n    }\n    // copy roots\n    checkMonitorCanceled();\n    getGeneratorSessionContext().clearCopiedRootsSet();\n    for (SNode rootToCopy : myInputModel.getRootNodes()) {\n      if (rootsConsumed.contains(rootToCopy)) {\n        if (myDeltaBuilder != null) {\n          myDeltaBuilder.enterInputRoot(rootToCopy);\n          myDeltaBuilder.deleteInputRoot(rootToCopy);\n          myDeltaBuilder.leaveInputRoot(rootToCopy);\n        }\n        continue;\n      }\n      QueryExecutionContext context = getExecutionContext(rootToCopy);\n      if (context != null) {\n        TemplateExecutionEnvironmentImpl rootenv = new TemplateExecutionEnvironmentImpl(this, context, new ReductionContext());\n        copyRootInputNode(rootToCopy, rootenv);\n      }\n    }\n  }","id":72696,"modified_method":"protected void applyReductions(boolean isPrimary) throws GenerationCanceledException, GenerationFailureException {\n    if (myInplaceChangeEnabled) {\n      if (myWeavingProcessor.hasWeavingRulesToApply()) {\n        getLogger().info(\"Could have had delta builder here, but can't due to active weavings\");\n      } else {\n        getLogger().info(\"Active in-place model transformation\");\n        myDeltaBuilder = createDeltaBuilder();\n      }\n    }\n    // create all roots\n    if (isPrimary) {\n      ttrace.push(\"create roots\", false);\n\n      final QueryExecutionContext executionContext = getExecutionContext(null);\n      if (executionContext != null) {\n        TemplateExecutionEnvironment environment = new TemplateExecutionEnvironmentImpl(this, executionContext, new ReductionContext());\n        for (TemplateCreateRootRule rule : myRuleManager.getCreateRootRules()) {\n          checkMonitorCanceled();\n          applyCreateRoot(rule, environment);\n        }\n      }\n      ttrace.pop();\n    }\n\n    // root mapping rules\n    ttrace.push(\"root mappings\", false);\n    ArrayList<SNode> rootsConsumed = new ArrayList<SNode>();\n    for (TemplateRootMappingRule rule : myRuleManager.getRoot_MappingRules()) {\n      checkMonitorCanceled();\n      applyRootRule(rule, rootsConsumed);\n    }\n    ttrace.pop();\n\n    // copy roots\n    checkMonitorCanceled();\n    getGeneratorSessionContext().clearCopiedRootsSet();\n    for (SNode rootToCopy : myInputModel.getRootNodes()) {\n      if (rootsConsumed.contains(rootToCopy)) {\n        continue;\n      }\n      QueryExecutionContext context = getExecutionContext(rootToCopy);\n      if (context != null) {\n        TemplateExecutionEnvironmentImpl rootenv = new TemplateExecutionEnvironmentImpl(this, context, new ReductionContext());\n        copyRootInputNode(rootToCopy, rootenv);\n      }\n    }\n  }","commit_id":"1e9ca5ecf02b25f87af1cec6f36cde411a3b3f4c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public DeleteStorageSnapshotResponseType DeleteStorageSnapshot( DeleteStorageSnapshotType request ) throws EucalyptusCloudException {\n\t\tDeleteStorageSnapshotResponseType reply = ( DeleteStorageSnapshotResponseType ) request.getReply();\n\n\t\tif(!StorageProperties.enableSnapshots || !StorageProperties.enableStorage) {\n\t\t\tStorageProperties.updateWalrusUrl();\n\t\t\tif(!StorageProperties.enableSnapshots)\n\t\t\t\tLOG.error(\"Snapshots have been disabled. Please check connection to Walrus.\");\n\t\t\treturn reply;\n\t\t}\t\t\n\n\t\tString snapshotId = request.getSnapshotId();\n\n\t\tEntityWrapper<SnapshotInfo> db = StorageController.getEntityWrapper();\n\t\tSnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n\t\tList<SnapshotInfo> snapshotInfos = db.query(snapshotInfo);\n\n\t\treply.set_return(true);\n\t\tif(snapshotInfos.size() > 0) {\n\t\t\tSnapshotInfo  foundSnapshotInfo = snapshotInfos.get(0);\n\t\t\tString status = foundSnapshotInfo.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n\t\t\t\ttry {\n\t\t\t\t\tSnapshotInfo snapInfo = new SnapshotInfo();\n\t\t\t\t\tsnapInfo.setVolumeId(foundSnapshotInfo.getVolumeId());\n\t\t\t\t\tList<SnapshotInfo> snapInfos = db.query(snapInfo);\n\t\t\t\t\tblockManager.deleteSnapshot(snapshotId);\n\t\t\t\t\tsnapshotStorageManager.deleteObject(\"\", snapshotId);\n\t\t\t\t\tdb.delete(foundSnapshotInfo);\n\t\t\t\t\tdb.commit();\n\t\t\t\t\tSnapshotDeleter snapshotDeleter = new SnapshotDeleter(snapshotId);\n\t\t\t\t\tsnapshotDeleter.start();\t\t\t\t\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//snapshot is still in progress.\n\t\t\t\treply.set_return(false);\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new SnapshotInUseException(snapshotId);\n\t\t\t}\n\t\t} else {\n\t\t\t//the SC knows nothing about this snapshot. It should be deleted directly from Walrus\n\t\t\tdb.rollback();\n\t\t}\n\t\treturn reply;\n\t}","id":72697,"modified_method":"public DeleteStorageSnapshotResponseType DeleteStorageSnapshot( DeleteStorageSnapshotType request ) throws EucalyptusCloudException {\n\t\tDeleteStorageSnapshotResponseType reply = ( DeleteStorageSnapshotResponseType ) request.getReply();\n\n\t\tStorageProperties.updateWalrusUrl();\n\t\tif(!StorageProperties.enableSnapshots) {\n\t\t\tLOG.error(\"Snapshots have been disabled. Please check connection to Walrus.\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString snapshotId = request.getSnapshotId();\n\n\t\tEntityWrapper<SnapshotInfo> db = StorageController.getEntityWrapper();\n\t\tSnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n\t\tList<SnapshotInfo> snapshotInfos = db.query(snapshotInfo);\n\n\t\treply.set_return(true);\n\t\tif(snapshotInfos.size() > 0) {\n\t\t\tSnapshotInfo  foundSnapshotInfo = snapshotInfos.get(0);\n\t\t\tString status = foundSnapshotInfo.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n\t\t\t\ttry {\n\t\t\t\t\tSnapshotInfo snapInfo = new SnapshotInfo();\n\t\t\t\t\tsnapInfo.setVolumeId(foundSnapshotInfo.getVolumeId());\n\t\t\t\t\tList<SnapshotInfo> snapInfos = db.query(snapInfo);\n\t\t\t\t\tblockManager.deleteSnapshot(snapshotId);\n\t\t\t\t\tsnapshotStorageManager.deleteObject(\"\", snapshotId);\n\t\t\t\t\tdb.delete(foundSnapshotInfo);\n\t\t\t\t\tdb.commit();\n\t\t\t\t\tSnapshotDeleter snapshotDeleter = new SnapshotDeleter(snapshotId);\n\t\t\t\t\tsnapshotDeleter.start();\t\t\t\t\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//snapshot is still in progress.\n\t\t\t\treply.set_return(false);\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new SnapshotInUseException(snapshotId);\n\t\t\t}\n\t\t} else {\n\t\t\t//the SC knows nothing about this snapshot. It should be deleted directly from Walrus\n\t\t\tdb.rollback();\n\t\t}\n\t\treturn reply;\n\t}","commit_id":"32d29b9701d6224316d1cb1d57285438b5588cdb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void getSnapshot(String snapshotId) throws EucalyptusCloudException {\n\t\tif(!StorageProperties.enableSnapshots) {\n\t\t\tStorageProperties.updateWalrusUrl();\n\t\t\tif(!StorageProperties.enableSnapshots) {\n\t\t\t\tLOG.error(\"Snapshot functionality disabled. Please check the Walrus url\");\n\t\t\t\tthrow new EucalyptusCloudException(\"could not connect to Walrus.\");\n\t\t\t}\n\t\t}\n\t\tString snapshotLocation = \"snapshots\" + \"/\" + snapshotId;\n\t\tString absoluteSnapshotPath = StorageProperties.storageRootDirectory + \"/\" + snapshotId;\n\t\tFile file = new File(absoluteSnapshotPath);\n\t\tif(file.exists()) {\n\t\t\t//something went wrong in the past. remove and retry\n\t\t\tfile.delete();\n\t\t}\n\t\tHttpReader snapshotGetter = new HttpReader(snapshotLocation, null, file, \"GetWalrusSnapshot\", \"\", true);\n\t\tsnapshotGetter.run();\n\t\tint snapshotSize = (int)(file.length() / StorageProperties.GB);\n\t\tif(snapshotSize == 0) {\n\t\t\tthrow new EucalyptusCloudException(\"could not download snapshot: \" + snapshotId + \" from Walrus.\");\n\t\t} \n\t\tEntityWrapper<SnapshotInfo> db = StorageController.getEntityWrapper();\n\t\tSnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n\t\tsnapshotInfo.setProgress(\"100\");\n\t\tsnapshotInfo.setStartTime(new Date());\n\t\tsnapshotInfo.setStatus(StorageProperties.Status.available.toString());\n\t\tblockManager.addSnapshot(snapshotId);\n\t}","id":72698,"modified_method":"private void getSnapshot(String snapshotId) throws EucalyptusCloudException {\n\t\tStorageProperties.updateWalrusUrl();\n\t\tif(!StorageProperties.enableSnapshots) {\n\t\t\tLOG.error(\"Snapshot functionality disabled. Please check connection to Walrus\");\n\t\t\tthrow new EucalyptusCloudException(\"could not connect to Walrus.\");\n\t\t}\n\t\tString snapshotLocation = \"snapshots\" + \"/\" + snapshotId;\n\t\tString absoluteSnapshotPath = StorageProperties.storageRootDirectory + \"/\" + snapshotId;\n\t\tFile file = new File(absoluteSnapshotPath);\n\t\tif(file.exists()) {\n\t\t\t//something went wrong in the past. remove and retry\n\t\t\tfile.delete();\n\t\t}\n\t\tHttpReader snapshotGetter = new HttpReader(snapshotLocation, null, file, \"GetWalrusSnapshot\", \"\", true);\n\t\tsnapshotGetter.run();\n\t\tint snapshotSize = (int)(file.length() / StorageProperties.GB);\n\t\tif(snapshotSize == 0) {\n\t\t\tthrow new EucalyptusCloudException(\"could not download snapshot: \" + snapshotId + \" from Walrus.\");\n\t\t} \n\t\tEntityWrapper<SnapshotInfo> db = StorageController.getEntityWrapper();\n\t\tSnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n\t\tsnapshotInfo.setProgress(\"100\");\n\t\tsnapshotInfo.setStartTime(new Date());\n\t\tsnapshotInfo.setStatus(StorageProperties.Status.available.toString());\n\t\tblockManager.addSnapshot(snapshotId);\n\t}","commit_id":"32d29b9701d6224316d1cb1d57285438b5588cdb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CreateStorageSnapshotResponseType CreateStorageSnapshot( CreateStorageSnapshotType request ) throws EucalyptusCloudException {\n\t\tCreateStorageSnapshotResponseType reply = ( CreateStorageSnapshotResponseType ) request.getReply();\n\n\t\tif(!StorageProperties.enableSnapshots || !StorageProperties.enableStorage) {\n\t\t\tStorageProperties.updateWalrusUrl();\n\t\t\tif(!StorageProperties.enableSnapshots)\n\t\t\t\tLOG.error(\"Snapshots have been disabled. Please check connection to Walrus.\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\t\tString snapshotId = request.getSnapshotId();\n\t\tEntityWrapper<VolumeInfo> db = StorageController.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo(volumeId);\n\t\tList<VolumeInfo> volumeInfos = db.query(volumeInfo);\n\n\t\tif(volumeInfos.size() > 0) {\n\t\t\tVolumeInfo foundVolumeInfo = volumeInfos.get(0);\n\t\t\t//check status\n\t\t\tif(foundVolumeInfo.getStatus().equals(StorageProperties.Status.available.toString())) {\n\t\t\t\t//create snapshot\n\t\t\t\tif(StorageProperties.shouldEnforceUsageLimits && WalrusProperties.sharedMode) {\n\t\t\t\t\tint volSize = foundVolumeInfo.getSize();\n\t\t\t\t\tint totalSnapshotSize = 0;\n\t\t\t\t\tSnapshotInfo snapInfo = new SnapshotInfo();\n\t\t\t\t\tEntityWrapper<SnapshotInfo> dbSnap = db.recast(SnapshotInfo.class);\n\n\t\t\t\t\tList<SnapshotInfo> snapInfos = dbSnap.query(snapInfo);\n\t\t\t\t\tfor (SnapshotInfo sInfo : snapInfos) {\n\t\t\t\t\t\ttotalSnapshotSize += blockManager.getSnapshotSize(sInfo.getSnapshotId());\n\t\t\t\t\t}\n\t\t\t\t\tif((totalSnapshotSize + volSize) > WalrusProperties.MAX_TOTAL_SNAPSHOT_SIZE) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new EntityTooLargeException(snapshotId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEntityWrapper<SnapshotInfo> db2 = StorageController.getEntityWrapper();\n\t\t\t\tedu.ucsb.eucalyptus.cloud.entities.SnapshotInfo snapshotInfo = new edu.ucsb.eucalyptus.cloud.entities.SnapshotInfo(snapshotId);\n\t\t\t\tsnapshotInfo.setUserName(foundVolumeInfo.getUserName());\n\t\t\t\tsnapshotInfo.setVolumeId(volumeId);\n\t\t\t\tDate startTime = new Date();\n\t\t\t\tsnapshotInfo.setStartTime(startTime);\n\t\t\t\tsnapshotInfo.setProgress(\"0\");\n\t\t\t\tsnapshotInfo.setStatus(StorageProperties.Status.creating.toString());\n\t\t\t\tdb2.add(snapshotInfo);\n\t\t\t\t//snapshot asynchronously\n\t\t\t\tString snapshotSet = \"snapset-\" + UUID.randomUUID();\n\n\t\t\t\tSnapshotter snapshotter = new Snapshotter(snapshotSet, volumeId, snapshotId);\n\t\t\t\tsnapshotter.start();\n\t\t\t\tdb2.commit();\n\t\t\t\tdb.commit();\n\t\t\t\treply.setSnapshotId(snapshotId);\n\t\t\t\treply.setVolumeId(volumeId);\n\t\t\t\treply.setStatus(snapshotInfo.getStatus());\n\t\t\t\treply.setStartTime(DateUtils.format(startTime.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\treply.setProgress(snapshotInfo.getProgress());\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new VolumeNotReadyException(volumeId);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchVolumeException(volumeId);\n\t\t}\n\t\treturn reply;\n\t}","id":72699,"modified_method":"public CreateStorageSnapshotResponseType CreateStorageSnapshot( CreateStorageSnapshotType request ) throws EucalyptusCloudException {\n\t\tCreateStorageSnapshotResponseType reply = ( CreateStorageSnapshotResponseType ) request.getReply();\n\n\t\tStorageProperties.updateWalrusUrl();\n\t\tif(!StorageProperties.enableSnapshots) {\n\t\t\tLOG.error(\"Snapshots have been disabled. Please check connection to Walrus.\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\t\tString snapshotId = request.getSnapshotId();\n\t\tEntityWrapper<VolumeInfo> db = StorageController.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo(volumeId);\n\t\tList<VolumeInfo> volumeInfos = db.query(volumeInfo);\n\n\t\tif(volumeInfos.size() > 0) {\n\t\t\tVolumeInfo foundVolumeInfo = volumeInfos.get(0);\n\t\t\t//check status\n\t\t\tif(foundVolumeInfo.getStatus().equals(StorageProperties.Status.available.toString())) {\n\t\t\t\t//create snapshot\n\t\t\t\tif(StorageProperties.shouldEnforceUsageLimits) {\n\t\t\t\t\tint volSize = foundVolumeInfo.getSize();\n\t\t\t\t\tint totalSnapshotSize = 0;\n\t\t\t\t\tSnapshotInfo snapInfo = new SnapshotInfo();\n\t\t\t\t\tEntityWrapper<SnapshotInfo> dbSnap = db.recast(SnapshotInfo.class);\n\n\t\t\t\t\tList<SnapshotInfo> snapInfos = dbSnap.query(snapInfo);\n\t\t\t\t\tfor (SnapshotInfo sInfo : snapInfos) {\n\t\t\t\t\t\ttotalSnapshotSize += blockManager.getSnapshotSize(sInfo.getSnapshotId());\n\t\t\t\t\t}\n\t\t\t\t\tif((totalSnapshotSize + volSize) > WalrusProperties.MAX_TOTAL_SNAPSHOT_SIZE) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new EntityTooLargeException(snapshotId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEntityWrapper<SnapshotInfo> db2 = StorageController.getEntityWrapper();\n\t\t\t\tedu.ucsb.eucalyptus.cloud.entities.SnapshotInfo snapshotInfo = new edu.ucsb.eucalyptus.cloud.entities.SnapshotInfo(snapshotId);\n\t\t\t\tsnapshotInfo.setUserName(foundVolumeInfo.getUserName());\n\t\t\t\tsnapshotInfo.setVolumeId(volumeId);\n\t\t\t\tDate startTime = new Date();\n\t\t\t\tsnapshotInfo.setStartTime(startTime);\n\t\t\t\tsnapshotInfo.setProgress(\"0\");\n\t\t\t\tsnapshotInfo.setStatus(StorageProperties.Status.creating.toString());\n\t\t\t\tdb2.add(snapshotInfo);\n\t\t\t\t//snapshot asynchronously\n\t\t\t\tString snapshotSet = \"snapset-\" + UUID.randomUUID();\n\n\t\t\t\tSnapshotter snapshotter = new Snapshotter(snapshotSet, volumeId, snapshotId);\n\t\t\t\tsnapshotter.start();\n\t\t\t\tdb2.commit();\n\t\t\t\tdb.commit();\n\t\t\t\treply.setSnapshotId(snapshotId);\n\t\t\t\treply.setVolumeId(volumeId);\n\t\t\t\treply.setStatus(snapshotInfo.getStatus());\n\t\t\t\treply.setStartTime(DateUtils.format(startTime.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\treply.setProgress(snapshotInfo.getProgress());\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new VolumeNotReadyException(volumeId);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchVolumeException(volumeId);\n\t\t}\n\t\treturn reply;\n\t}","commit_id":"32d29b9701d6224316d1cb1d57285438b5588cdb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void updateWalrusUrl() {\n\t\tif(!WalrusProperties.sharedMode) {\n\t\t\tList<WalrusConfiguration> walrusConfigs;\n\t\t\ttry {\n\t\t\t\twalrusConfigs = Configuration.getWalrusConfigurations();\n\t\t\t\tif(walrusConfigs.size() > 0) {\n\t\t\t\t\tWalrusConfiguration walrusConfig = walrusConfigs.get(0);\n\t\t\t\t\tWALRUS_URL = walrusConfig.getUri();\n\t\t\t\t\tStorageProperties.enableSnapshots = true;\n\t\t\t\t\tLOG.info(\"Setting WALRUS_URL to: \" + WALRUS_URL);\n\t\t\t\t} else {\n\t\t\t\t\tLOG.warn(\"Could not obtain walrus information. Snapshot functionality may be unavailable. Have you registered Walrus?\");\n\t\t\t\t\tStorageProperties.enableSnapshots = false;\n\t\t\t\t}\n\t\t\t} catch (EucalyptusCloudException e) {\n\t\t\t\tLOG.warn(\"Could not obtain walrus information. Snapshot functionality may be unavailable. Have you registered Walrus?\");\n\t\t\t\tStorageProperties.enableSnapshots = false;\n\t\t\t}\n\t\t}\n\t}","id":72700,"modified_method":"public static void updateWalrusUrl() {\n\t\tList<WalrusConfiguration> walrusConfigs;\n\t\ttry {\n\t\t\twalrusConfigs = Configuration.getWalrusConfigurations();\n\t\t\tif(walrusConfigs.size() > 0) {\n\t\t\t\tWalrusConfiguration walrusConfig = walrusConfigs.get(0);\n\t\t\t\tWALRUS_URL = walrusConfig.getUri();\n\t\t\t\tStorageProperties.enableSnapshots = true;\n\t\t\t\tLOG.info(\"Setting WALRUS_URL to: \" + WALRUS_URL);\n\t\t\t} else {\n\t\t\t\tLOG.warn(\"Could not obtain walrus information. Snapshot functionality may be unavailable. Have you registered Walrus?\");\n\t\t\t\tStorageProperties.enableSnapshots = false;\n\t\t\t}\n\t\t} catch (EucalyptusCloudException e) {\n\t\t\tLOG.warn(\"Could not obtain walrus information. Snapshot functionality may be unavailable. Have you registered Walrus?\");\n\t\t\tStorageProperties.enableSnapshots = false;\n\t\t}\t\t\n\t}","commit_id":"32d29b9701d6224316d1cb1d57285438b5588cdb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void startupChecks() {\n\t\tcleanFailedCachedImages();\n\t\tWalrusProperties.sharedMode = true;\n\t}","id":72701,"modified_method":"public void startupChecks() {\n\t\tcleanFailedCachedImages();\n\t}","commit_id":"32d29b9701d6224316d1cb1d57285438b5588cdb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private Row fillRow(Row baserow, int startcolumn,\n\t\t\tExcelInputRow excelInputRow) throws KettleException {\n\t\tdebug = \"fillRow start\";\n\t\tRow r = new Row(baserow);\n\n\t\t// Set values in the row...\n\t\tfor (int i = startcolumn; i < excelInputRow.cells.length\n\t\t\t\t&& i - startcolumn < r.size(); i++) {\n\t\t\tdebug = \"get cell #\" + i;\n\t\t\tCell cell = excelInputRow.cells[i];\n\n\t\t\tint rowcolumn = i - startcolumn;\n\t\t\tdebug = \"Rowcolumn = \" + rowcolumn;\n\n\t\t\tValue v = r.getValue(rowcolumn);\n\t\t\tdebug = \"Value v = \" + v;\n\n\t\t\ttry {\n\t\t\t\tcheckType(cell, v);\n\t\t\t} catch (KettleException ex) {\n\t\t\t\tif (!meta.isErrorIgnored())\n\t\t\t\t\tthrow ex;\n\t\t\t\tlogBasic(\"Warning processing [\" + debug\n\t\t\t\t\t\t+ \"] from Excel file [\" + data.filename + \"] : \"\n\t\t\t\t\t\t+ ex.toString());\n\t\t\t\tdata.errorHandler.handleLineError(excelInputRow.rownr,\n\t\t\t\t\t\texcelInputRow.sheetName);\n\t\t\t\tif (meta.isErrorLineSkipped()) {\n\t\t\t\t\tr.setIgnore();\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cell.getType().equals(CellType.BOOLEAN)) {\n\t\t\t\tv.setValue(((BooleanCell) cell).getValue());\n\t\t\t} else if (cell.getType().equals(CellType.DATE)) {\n\t\t\t\tv.setValue(((DateCell) cell).getDate());\n\t\t\t} else if (cell.getType().equals(CellType.LABEL)) {\n\t\t\t\tv.setValue(((LabelCell) cell).getString());\n\t\t\t\tswitch (meta.getFieldTrimType()[rowcolumn]) {\n\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_LEFT:\n\t\t\t\t\tv.ltrim();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_RIGHT:\n\t\t\t\t\tv.rtrim();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_BOTH:\n\t\t\t\t\tv.trim();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (cell.getType().equals(CellType.NUMBER)) {\n\t\t\t\tv.setValue(((NumberCell) cell).getValue());\n\t\t\t} else {\n\t\t\t\tlogDetailed(\"Unknown type : \" + cell.getType().toString()\n\t\t\t\t\t\t+ \" : [\" + cell.getContents() + \"]\");\n\t\t\t\tv.setNull();\n\t\t\t}\n\n\t\t\t// Change to the appropriate type...\n\t\t\t// \n\t\t\tv.setType(meta.getFieldType()[rowcolumn]);\n\t\t\tv.setLength(meta.getFieldLength()[rowcolumn], meta\n\t\t\t\t\t.getFieldPrecision()[rowcolumn]);\n\t\t}\n\n\t\tdebug = \"filename\";\n\n\t\t// Do we need to include the filename?\n\t\tif (meta.getFileField() != null && meta.getFileField().length() > 0) {\n\t\t\tValue value = new Value(meta.getFileField(), data.filename);\n\t\t\tvalue.setLength(data.maxfilelength);\n\t\t\tr.addValue(value);\n\t\t}\n\n\t\tdebug = \"sheetname\";\n\n\t\t// Do we need to include the sheetname?\n\t\tif (meta.getSheetField() != null && meta.getSheetField().length() > 0) {\n\t\t\tValue value = new Value(meta.getSheetField(),\n\t\t\t\t\texcelInputRow.sheetName);\n\t\t\tvalue.setLength(data.maxsheetlength);\n\t\t\tr.addValue(value);\n\t\t}\n\n\t\tdebug = \"rownumber\";\n\n\t\t// Do we need to include the rownumber?\n\t\tif (meta.getRowNumberField() != null\n\t\t\t\t&& meta.getRowNumberField().length() > 0) {\n\t\t\tValue value = new Value(meta.getRowNumberField(), linesWritten + 1);\n\t\t\tr.addValue(value);\n\t\t}\n\n\t\tdebug = \"end of fillRow\";\n\n\t\treturn r;\n\t}","id":72702,"modified_method":"private Row fillRow(Row baserow, int startcolumn,\n\t\t\tExcelInputRow excelInputRow) throws KettleException {\n\t\tdebug = \"fillRow start\";\n\t\tRow r = new Row(baserow);\n\n\t\t// Set values in the row...\n\t\tfor (int i = startcolumn; i < excelInputRow.cells.length\n\t\t\t\t&& i - startcolumn < r.size(); i++) {\n\t\t\tdebug = \"get cell #\" + i;\n\t\t\tCell cell = excelInputRow.cells[i];\n\n\t\t\tint rowcolumn = i - startcolumn;\n\t\t\tdebug = \"Rowcolumn = \" + rowcolumn;\n\n\t\t\tValue v = r.getValue(rowcolumn);\n\t\t\tdebug = \"Value v = \" + v;\n\n\t\t\ttry {\n\t\t\t\tcheckType(cell, v);\n\t\t\t} catch (KettleException ex) {\n\t\t\t\tif (!meta.isErrorIgnored())\n\t\t\t\t\tthrow ex;\n\t\t\t\tlogBasic(\"Warning processing [\" + debug\n\t\t\t\t\t\t+ \"] from Excel file [\" + data.filename + \"] : \"\n\t\t\t\t\t\t+ ex.toString());\n\t\t\t\tdata.errorHandler.handleLineError(excelInputRow.rownr,\n\t\t\t\t\t\texcelInputRow.sheetName);\n\t\t\t\tif (meta.isErrorLineSkipped()) {\n\t\t\t\t\tr.setIgnore();\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cell.getType().equals(CellType.BOOLEAN)) {\n\t\t\t\tv.setValue(((BooleanCell) cell).getValue());\n\t\t\t} else if (cell.getType().equals(CellType.DATE)) {\n\t\t\t\tv.setValue(((DateCell) cell).getDate());\n\t\t\t} else if (cell.getType().equals(CellType.LABEL)) {\n\t\t\t\tv.setValue(((LabelCell) cell).getString());\n\t\t\t\tswitch (meta.getField()[rowcolumn].getTrimType()) {\n\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_LEFT:\n\t\t\t\t\tv.ltrim();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_RIGHT:\n\t\t\t\t\tv.rtrim();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ExcelInputMeta.TYPE_TRIM_BOTH:\n\t\t\t\t\tv.trim();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (cell.getType().equals(CellType.NUMBER)) {\n\t\t\t\tv.setValue(((NumberCell) cell).getValue());\n\t\t\t} else {\n\t\t\t\tlogDetailed(\"Unknown type : \" + cell.getType().toString()\n\t\t\t\t\t\t+ \" : [\" + cell.getContents() + \"]\");\n\t\t\t\tv.setNull();\n\t\t\t}\n\n\t\t\t// Change to the appropriate type...\n\t\t\t// \n\t\t\tv.setType(meta.getField()[rowcolumn].getType());\n\t\t\tv.setLength(meta.getField()[rowcolumn].getLength(), meta\n\t\t\t\t\t.getField()[rowcolumn].getPrecision());\n\t\t}\n\n\t\tdebug = \"filename\";\n\n\t\t// Do we need to include the filename?\n\t\tif (meta.getFileField() != null && meta.getFileField().length() > 0) {\n\t\t\tValue value = new Value(meta.getFileField(), data.filename);\n\t\t\tvalue.setLength(data.maxfilelength);\n\t\t\tr.addValue(value);\n\t\t}\n\n\t\tdebug = \"sheetname\";\n\n\t\t// Do we need to include the sheetname?\n\t\tif (meta.getSheetField() != null && meta.getSheetField().length() > 0) {\n\t\t\tValue value = new Value(meta.getSheetField(),\n\t\t\t\t\texcelInputRow.sheetName);\n\t\t\tvalue.setLength(data.maxsheetlength);\n\t\t\tr.addValue(value);\n\t\t}\n\n\t\tdebug = \"rownumber\";\n\n\t\t// Do we need to include the rownumber?\n\t\tif (meta.getRowNumberField() != null\n\t\t\t\t&& meta.getRowNumberField().length() > 0) {\n\t\t\tValue value = new Value(meta.getRowNumberField(), linesWritten + 1);\n\t\t\tr.addValue(value);\n\t\t}\n\n\t\tdebug = \"end of fillRow\";\n\n\t\treturn r;\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi)\n\t\t\tthrows KettleException {\n\t\tmeta = (ExcelInputMeta) smi;\n\t\tdata = (ExcelInputData) sdi;\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\thandleMissingFiles();\n\t\t}\n\n\t\t// See if we're not done processing...\n\t\t// We are done processing if the filenr >= number of files.\n\t\tif (data.filenr >= data.files.nrOfFiles()) {\n\t\t\tlogDetailed(\"No more files to be processes! (\" + data.filenr\n\t\t\t\t\t+ \" files done)\");\n\t\t\tsetOutputDone(); // signal end to receiver(s)\n\t\t\treturn false; // end of data or error.\n\t\t}\n\n\t\tif (meta.getRowLimit() > 0 && data.rownr > meta.getRowLimit()) {\n\t\t\t// The close of the workbook is in dispose()\n\t\t\tlogDetailed(\"Row limit of [\" + meta.getRowLimit()\n\t\t\t\t\t+ \"] reached: stop processing.\");\n\t\t\tsetOutputDone(); // signal end to receiver(s)\n\t\t\treturn false; // end of data or error.\n\t\t}\n\n\t\tRow r = getRowFromWorkbooks();\n\t\tif (r != null) {\n\t\t\tif (!r.isIgnored()) {\n\t\t\t\t// OK, see if we need to repeat values.\n\t\t\t\tif (data.previousRow != null) {\n\t\t\t\t\tfor (int i = 0; i < meta.getFieldRepeat().length; i++) {\n\t\t\t\t\t\tValue field = r.getValue(i);\n\t\t\t\t\t\tif (field.isNull() && meta.getFieldRepeat()[i]) {\n\t\t\t\t\t\t\t// Take the value from the previous row.\n\t\t\t\t\t\t\tValue repeat = data.previousRow.getValue(i);\n\t\t\t\t\t\t\tfield.setValue(repeat);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remember this row for the next time around!\n\t\t\t\tdata.previousRow = r;\n\n\t\t\t\t// Send out the good news: we found a row of data!\n\t\t\t\tputRow(r);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t}","id":72703,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi)\n\t\t\tthrows KettleException {\n\t\tmeta = (ExcelInputMeta) smi;\n\t\tdata = (ExcelInputData) sdi;\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\thandleMissingFiles();\n\t\t}\n\n\t\t// See if we're not done processing...\n\t\t// We are done processing if the filenr >= number of files.\n\t\tif (data.filenr >= data.files.nrOfFiles()) {\n\t\t\tlogDetailed(\"No more files to be processes! (\" + data.filenr\n\t\t\t\t\t+ \" files done)\");\n\t\t\tsetOutputDone(); // signal end to receiver(s)\n\t\t\treturn false; // end of data or error.\n\t\t}\n\n\t\tif (meta.getRowLimit() > 0 && data.rownr > meta.getRowLimit()) {\n\t\t\t// The close of the workbook is in dispose()\n\t\t\tlogDetailed(\"Row limit of [\" + meta.getRowLimit()\n\t\t\t\t\t+ \"] reached: stop processing.\");\n\t\t\tsetOutputDone(); // signal end to receiver(s)\n\t\t\treturn false; // end of data or error.\n\t\t}\n\n\t\tRow r = getRowFromWorkbooks();\n\t\tif (r != null) {\n\t\t\tif (!r.isIgnored()) {\n\t\t\t\t// OK, see if we need to repeat values.\n\t\t\t\tif (data.previousRow != null) {\n\t\t\t\t\tfor (int i = 0; i < meta.getField().length; i++) {\n\t\t\t\t\t\tValue field = r.getValue(i);\n\t\t\t\t\t\tif (field.isNull() && meta.getField()[i].isRepeated()) {\n\t\t\t\t\t\t\t// Take the value from the previous row.\n\t\t\t\t\t\t\tValue repeat = data.previousRow.getValue(i);\n\t\t\t\t\t\t\tfield.setValue(repeat);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remember this row for the next time around!\n\t\t\t\tdata.previousRow = r;\n\n\t\t\t\t// Send out the good news: we found a row of data!\n\t\t\t\tputRow(r);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Read the data from the ExcelInputMeta object and show it in this dialog.\n\t * \n\t * @param in The ExcelInputMeta object to obtain the data from.\n\t */\n\tpublic void getData(ExcelInputMeta in)\n\t{\n\t\tif (in.getFileName() !=null) \n\t\t{\n\t\t\twFilenameList.removeAll();\n\t\t\tfor (int i=0;i<in.getFileName().length;i++) \n\t\t\t{\n\t\t\t\twFilenameList.add(new String[] { in.getFileName()[i], in.getFileMask()[i] , in.getFileRequired()[i]} );\n\t\t\t}\n\t\t\twFilenameList.removeEmptyRows();\n\t\t\twFilenameList.setRowNums();\n\t\t\twFilenameList.optWidth(true);\n\t\t}\n\t\twHeader.setSelection(in.startsWithHeader());\n\t\twNoempty.setSelection(in.ignoreEmptyRows());\n\t\twStoponempty.setSelection(in.stopOnEmpty());\n\t\tif (in.getFileField()!=null) wInclFilenameField.setText(in.getFileField());\n\t\tif (in.getSheetField()!=null) wInclSheetnameField.setText(in.getSheetField());\n\t\tif (in.getRowNumberField()!=null) wInclRownumField.setText(in.getRowNumberField());\n\t\twLimit.setText(\"\"+in.getRowLimit());\n\t\t\n\t\tlog.logDebug(toString(), \"getting fields info...\");\n\t\tfor (int i=0;i<in.getFieldName().length;i++)\n\t\t{\n\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\tString field    = in.getFieldName()[i];\n\t\t\tString type     = Value.getTypeDesc(in.getFieldType()[i]);\n\t\t\tString length   = \"\"+in.getFieldLength()[i];\n\t\t\tString prec     = \"\"+in.getFieldPrecision()[i];\n\t\t\tString trim     = TextFileInputMeta.getTrimTypeDesc(in.getFieldTrimType()[i]);\n\t\t\tString rep      = in.getFieldRepeat()[i]?Messages.getString(\"System.Combo.Yes\"):Messages.getString(\"System.Combo.No\");\n\t\t\t\n\t\t\tif (field   !=null) item.setText( 1, field);\n\t\t\tif (type    !=null) item.setText( 2, type    );\n\t\t\tif (length  !=null) item.setText( 3, length  );\n\t\t\tif (prec    !=null) item.setText( 4, prec    );\n\t\t\tif (trim    !=null) item.setText( 5, trim    );\n\t\t\tif (rep     !=null) item.setText( 6, rep     );\n\t\t}\n\t\t\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\n\t\tlog.logDebug(toString(), \"getting sheets info...\");\n\t\tfor (int i=0;i<in.getSheetName().length;i++)\n\t\t{\n\t\t\tTableItem item = wSheetnameList.table.getItem(i);\n\t\t\tString sheetname    =    in.getSheetName()[i];\n\t\t\tString startrow     = \"\"+in.getStartRow()[i];\n\t\t\tString startcol     = \"\"+in.getStartColumn()[i];\n\t\t\t\n\t\t\tif (sheetname!=null) item.setText( 1, sheetname);\n\t\t\tif (startrow!=null)  item.setText( 2, startrow);\n\t\t\tif (startcol!=null)  item.setText( 3, startcol);\n\t\t}\n\t\twSheetnameList.removeEmptyRows();\n\t\twSheetnameList.setRowNums();\n\t\twSheetnameList.optWidth(true);\n\t\t\n\t\t//\t\t Error handling fields...\n        wErrorIgnored.setSelection( in.isErrorIgnored() );\n        wStrictTypes.setSelection( in.isStrictTypes() );\n        wSkipErrorLines.setSelection( in.isErrorLineSkipped() );\n\n        if (in.getWarningFilesDestinationDirectory()!=null) wWarningDestDir.setText(in.getWarningFilesDestinationDirectory());\n        if (in.getBadLineFilesExtension()!=null) wWarningExt.setText(in.getBadLineFilesExtension());\n\n        if (in.getErrorFilesDestinationDirectory()!=null) wErrorDestDir.setText(in.getErrorFilesDestinationDirectory());\n        if (in.getErrorFilesExtension()!=null) wErrorExt.setText(in.getErrorFilesExtension());\n\n        if (in.getLineNumberFilesDestinationDirectory()!=null) wLineNrDestDir.setText(in.getLineNumberFilesDestinationDirectory());\n        if (in.getLineNumberFilesExtension()!=null) wLineNrExt.setText(in.getLineNumberFilesExtension());\n\n\t\tenableFields();\n\t\t\n\t\twStepname.selectAll();\n\t}","id":72704,"modified_method":"/**\n\t * Read the data from the ExcelInputMeta object and show it in this dialog.\n\t * \n\t * @param in The ExcelInputMeta object to obtain the data from.\n\t */\n\tpublic void getData(ExcelInputMeta in)\n\t{\n\t\tif (in.getFileName() !=null) \n\t\t{\n\t\t\twFilenameList.removeAll();\n\t\t\tfor (int i=0;i<in.getFileName().length;i++) \n\t\t\t{\n\t\t\t\twFilenameList.add(new String[] { in.getFileName()[i], in.getFileMask()[i] , in.getFileRequired()[i]} );\n\t\t\t}\n\t\t\twFilenameList.removeEmptyRows();\n\t\t\twFilenameList.setRowNums();\n\t\t\twFilenameList.optWidth(true);\n\t\t}\n\t\twHeader.setSelection(in.startsWithHeader());\n\t\twNoempty.setSelection(in.ignoreEmptyRows());\n\t\twStoponempty.setSelection(in.stopOnEmpty());\n\t\tif (in.getFileField()!=null) wInclFilenameField.setText(in.getFileField());\n\t\tif (in.getSheetField()!=null) wInclSheetnameField.setText(in.getSheetField());\n\t\tif (in.getRowNumberField()!=null) wInclRownumField.setText(in.getRowNumberField());\n\t\twLimit.setText(\"\"+in.getRowLimit());\n\t\t\n\t\tlog.logDebug(toString(), \"getting fields info...\");\n\t\tfor (int i=0;i<in.getField().length;i++)\n\t\t{\n\t\t\tTableItem item = wFields.table.getItem(i);\n\t\t\tString field    = in.getField()[i].getName();\n\t\t\tString type     = in.getField()[i].getTypeDesc();\n\t\t\tString length   = \"\"+in.getField()[i].getLength();\n\t\t\tString prec     = \"\"+in.getField()[i].getPrecision();\n\t\t\tString trim     = in.getField()[i].getTrimTypeDesc();\n\t\t\tString rep      = in.getField()[i].isRepeated()?Messages.getString(\"System.Combo.Yes\"):Messages.getString(\"System.Combo.No\");\n\t\t\t\n\t\t\tif (field   !=null) item.setText( 1, field);\n\t\t\tif (type    !=null) item.setText( 2, type    );\n\t\t\tif (length  !=null) item.setText( 3, length  );\n\t\t\tif (prec    !=null) item.setText( 4, prec    );\n\t\t\tif (trim    !=null) item.setText( 5, trim    );\n\t\t\tif (rep     !=null) item.setText( 6, rep     );\n\t\t}\n\t\t\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\n\t\tlog.logDebug(toString(), \"getting sheets info...\");\n\t\tfor (int i=0;i<in.getSheetName().length;i++)\n\t\t{\n\t\t\tTableItem item = wSheetnameList.table.getItem(i);\n\t\t\tString sheetname    =    in.getSheetName()[i];\n\t\t\tString startrow     = \"\"+in.getStartRow()[i];\n\t\t\tString startcol     = \"\"+in.getStartColumn()[i];\n\t\t\t\n\t\t\tif (sheetname!=null) item.setText( 1, sheetname);\n\t\t\tif (startrow!=null)  item.setText( 2, startrow);\n\t\t\tif (startcol!=null)  item.setText( 3, startcol);\n\t\t}\n\t\twSheetnameList.removeEmptyRows();\n\t\twSheetnameList.setRowNums();\n\t\twSheetnameList.optWidth(true);\n\t\t\n\t\t//\t\t Error handling fields...\n        wErrorIgnored.setSelection( in.isErrorIgnored() );\n        wStrictTypes.setSelection( in.isStrictTypes() );\n        wSkipErrorLines.setSelection( in.isErrorLineSkipped() );\n\n        if (in.getWarningFilesDestinationDirectory()!=null) wWarningDestDir.setText(in.getWarningFilesDestinationDirectory());\n        if (in.getBadLineFilesExtension()!=null) wWarningExt.setText(in.getBadLineFilesExtension());\n\n        if (in.getErrorFilesDestinationDirectory()!=null) wErrorDestDir.setText(in.getErrorFilesDestinationDirectory());\n        if (in.getErrorFilesExtension()!=null) wErrorExt.setText(in.getErrorFilesExtension());\n\n        if (in.getLineNumberFilesDestinationDirectory()!=null) wLineNrDestDir.setText(in.getLineNumberFilesDestinationDirectory());\n        if (in.getLineNumberFilesExtension()!=null) wLineNrExt.setText(in.getLineNumberFilesExtension());\n\n\t\tenableFields();\n\t\t\n\t\twStepname.selectAll();\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n\n\t\tlsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged         = input.hasChanged();\n\t\t\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"ExcelInputDialog.DialogTitle\"));\n\t\t\n\t\tmiddle = props.getMiddlePct();\n\t\tmargin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"System.Label.StepName\"));\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\n\t\t\n\t\t//////////////////////////\n\t\t// START OF FILE TAB   ///\n\t\t//////////////////////////\n\t\twFileTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twFileTab.setText(Messages.getString(\"ExcelInputDialog.FileTab.TabTitle\"));\n\t\t\n\t\twFileComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wFileComp);\n\n\t\tFormLayout fileLayout = new FormLayout();\n\t\tfileLayout.marginWidth  = 3;\n\t\tfileLayout.marginHeight = 3;\n\t\twFileComp.setLayout(fileLayout);\n\n\t\t// Filename line\n\t\twlFilename=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"ExcelInputDialog.Filename.Label\"));\n \t\tprops.setLook(wlFilename);\n\t\tfdlFilename=new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top  = new FormAttachment(0, 0);\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbbFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbbFilename);\n\t\twbbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\twbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t\tfdbFilename=new FormData();\n\t\tfdbFilename.right= new FormAttachment(100, 0);\n\t\tfdbFilename.top  = new FormAttachment(0, 0);\n\t\twbbFilename.setLayoutData(fdbFilename);\n\n\t\twbvFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbvFilename);\n\t\twbvFilename.setText(Messages.getString(\"System.Button.Variable\"));\n\t\twbvFilename.setToolTipText(\"Insert a variable in the filename or directory\");\n\t\tfdbvFilename=new FormData();\n\t\tfdbvFilename.right= new FormAttachment(wbbFilename, -margin);\n\t\tfdbvFilename.top  = new FormAttachment(0, 0);\n\t\twbvFilename.setLayoutData(fdbvFilename);\n\n\t\twbaFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbaFilename);\n\t\twbaFilename.setText(Messages.getString(\"ExcelInputDialog.FilenameAdd.Button\"));\n\t\twbaFilename.setToolTipText(Messages.getString(\"ExcelInputDialog.FilenameAdd.Tooltip\"));\n\t\tfdbaFilename=new FormData();\n\t\tfdbaFilename.right= new FormAttachment(wbvFilename, -margin);\n\t\tfdbaFilename.top  = new FormAttachment(0, 0);\n\t\twbaFilename.setLayoutData(fdbaFilename);\n\n\t\twFilename=new Text(wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename=new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.right= new FormAttachment(wbaFilename, -margin);\n\t\tfdFilename.top  = new FormAttachment(0, 0);\n\t\twFilename.setLayoutData(fdFilename);\n\n\t\twlFilemask=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilemask.setText(Messages.getString(\"ExcelInputDialog.Filemask.Label\"));\n \t\tprops.setLook(wlFilemask);\n\t\tfdlFilemask=new FormData();\n\t\tfdlFilemask.left = new FormAttachment(0, 0);\n\t\tfdlFilemask.top  = new FormAttachment(wFilename, margin);\n\t\tfdlFilemask.right= new FormAttachment(middle, -margin);\n\t\twlFilemask.setLayoutData(fdlFilemask);\n\t\twFilemask=new Text(wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilemask);\n\t\twFilemask.addModifyListener(lsMod);\n\t\tfdFilemask=new FormData();\n\t\tfdFilemask.left = new FormAttachment(middle, 0);\n\t\tfdFilemask.top  = new FormAttachment(wFilename, margin);\n\t\tfdFilemask.right= new FormAttachment(100, 0);\n\t\twFilemask.setLayoutData(fdFilemask);\n\n\t\t// Filename list line\n\t\twlFilenameList=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilenameList.setText(Messages.getString(\"ExcelInputDialog.FilenameList.Label\"));\n \t\tprops.setLook(wlFilenameList);\n\t\tfdlFilenameList=new FormData();\n\t\tfdlFilenameList.left = new FormAttachment(0, 0);\n\t\tfdlFilenameList.top  = new FormAttachment(wFilemask, margin);\n\t\tfdlFilenameList.right= new FormAttachment(middle, -margin);\n\t\twlFilenameList.setLayoutData(fdlFilenameList);\n\n\t\t// Buttons to the right of the screen...\n\t\twbdFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbdFilename);\n\t\twbdFilename.setText(Messages.getString(\"ExcelInputDialog.FilenameDelete.Button\"));\n\t\twbdFilename.setToolTipText(Messages.getString(\"ExcelInputDialog.FilenameDelete.Tooltip\"));\n\t\tfdbdFilename=new FormData();\n\t\tfdbdFilename.right = new FormAttachment(100, 0);\n\t\tfdbdFilename.top  = new FormAttachment (wFilemask, 40);\n\t\twbdFilename.setLayoutData(fdbdFilename);\n\n\t\twbeFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbeFilename);\n\t\twbeFilename.setText(Messages.getString(\"ExcelInputDialog.FilenameEdit.Button\"));\n\t\twbeFilename.setToolTipText(Messages.getString(\"ExcelInputDialog.FilenameEdit.Button\"));\n\t\tfdbeFilename=new FormData();\n\t\tfdbeFilename.right = new FormAttachment(100, 0);\n\t\tfdbeFilename.top  = new FormAttachment (wbdFilename, margin);\n\t\twbeFilename.setLayoutData(fdbeFilename);\n\n\t\twbShowFiles=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbShowFiles);\n\t\twbShowFiles.setText(Messages.getString(\"ExcelInputDialog.ShowFiles.Button\"));\n\t\tfdbShowFiles=new FormData();\n\t\tfdbShowFiles.left   = new FormAttachment(middle, 0);\n\t\tfdbShowFiles.bottom = new FormAttachment(100, -margin);\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\n\n\t\tColumnInfo[] colinfo=new ColumnInfo[3];\n\t\tcolinfo[ 0]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.FileDir.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tcolinfo[ 1]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Wildcard.Column\"),        ColumnInfo.COLUMN_TYPE_TEXT,    false );\n\t\tcolinfo[ 1].setToolTip(Messages.getString(\"ExcelInputDialog.Wildcard.Tooltip\"));\n\t\tcolinfo[ 2]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Required.Column\"),        ColumnInfo.COLUMN_TYPE_CCOMBO,  YES_NO_COMBO );\n\t\tcolinfo[ 2].setToolTip(Messages.getString(\"ExcelInputDialog.Required.Tooltip\"));\n\t\t\n\t\twFilenameList = new TableView(wFileComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.SINGLE | SWT.BORDER, \n\t\t\t\t\t\t      colinfo, \n\t\t\t\t\t\t      input.getFileName().length,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n \t\tprops.setLook(wFilenameList);\n\t\tfdFilenameList=new FormData();\n\t\tfdFilenameList.left   = new FormAttachment(middle, 0);\n\t\tfdFilenameList.right  = new FormAttachment(wbdFilename, -margin);\n\t\tfdFilenameList.top    = new FormAttachment(wFilemask, margin);\n\t\tfdFilenameList.bottom = new FormAttachment(wbShowFiles, -margin);\n\t\twFilenameList.setLayoutData(fdFilenameList);\n\n\t\n\t\tfdFileComp=new FormData();\n\t\tfdFileComp.left  = new FormAttachment(0, 0);\n\t\tfdFileComp.top   = new FormAttachment(0, 0);\n\t\tfdFileComp.right = new FormAttachment(100, 0);\n\t\tfdFileComp.bottom= new FormAttachment(100, 0);\n\t\twFileComp.setLayoutData(fdFileComp);\n\t\n\t\twFileComp.layout();\n\t\twFileTab.setControl(wFileComp);\n\t\t\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF FILE TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\t//////////////////////////\n\t\t// START OF SHEET TAB  ///\n\t\t//////////////////////////\n\t\twSheetTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twSheetTab.setText(Messages.getString(\"ExcelInputDialog.SheetsTab.TabTitle\"));\n\t\t\n\t\twSheetComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wSheetComp);\n\n\t\tFormLayout sheetLayout = new FormLayout();\n\t\tsheetLayout.marginWidth  = 3;\n\t\tsheetLayout.marginHeight = 3;\n\t\twSheetComp.setLayout(sheetLayout);\n\t\t\n\t\twbGetSheets=new Button(wSheetComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbGetSheets);\n\t\twbGetSheets.setText(Messages.getString(\"ExcelInputDialog.GetSheets.Button\"));\n\t\tfdbGetSheets=new FormData();\n\t\tfdbGetSheets.left   = new FormAttachment(middle, 0);\n\t\tfdbGetSheets.bottom = new FormAttachment(100, -margin);\n\t\twbGetSheets.setLayoutData(fdbGetSheets);\n\n\t\twlSheetnameList=new Label(wSheetComp, SWT.RIGHT);\n\t\twlSheetnameList.setText(Messages.getString(\"ExcelInputDialog.SheetNameList.Label\"));\n \t\tprops.setLook(wlSheetnameList);\n\t\tfdlSheetnameList=new FormData();\n\t\tfdlSheetnameList.left = new FormAttachment(0, 0);\n\t\tfdlSheetnameList.top  = new FormAttachment(wFilename, margin);\n\t\tfdlSheetnameList.right= new FormAttachment(middle, -margin);\n\t\twlSheetnameList.setLayoutData(fdlSheetnameList);\n\t\t\n\t\tColumnInfo[] shinfo=new ColumnInfo[3];\n\t\tshinfo[ 0]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.SheetName.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tshinfo[ 1]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.StartRow.Column\"),      ColumnInfo.COLUMN_TYPE_TEXT,    false );\n\t\tshinfo[ 2]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.StartColumn.Column\"),   ColumnInfo.COLUMN_TYPE_TEXT,    false );\n\t\t\n\t\twSheetnameList = new TableView(wSheetComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.MULTI | SWT.BORDER, \n\t\t\t\t\t\t      shinfo, \n\t\t\t\t\t\t      input.getSheetName().length,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n \t\tprops.setLook(wSheetnameList);\n\t\tfdFilenameList=new FormData();\n\t\tfdFilenameList.left   = new FormAttachment(middle, 0);\n\t\tfdFilenameList.right  = new FormAttachment(100, 0);\n\t\tfdFilenameList.top    = new FormAttachment(0, 0);\n\t\tfdFilenameList.bottom = new FormAttachment(wbGetSheets, -margin);\n\t\twSheetnameList.setLayoutData(fdFilenameList);\n\t\t\n\t\tfdSheetComp=new FormData();\n\t\tfdSheetComp.left  = new FormAttachment(0, 0);\n\t\tfdSheetComp.top   = new FormAttachment(0, 0);\n\t\tfdSheetComp.right = new FormAttachment(100, 0);\n\t\tfdSheetComp.bottom= new FormAttachment(100, 0);\n\t\twSheetComp.setLayoutData(fdSheetComp);\n\t\n\t\twSheetComp.layout();\n\t\twSheetTab.setControl(wSheetComp);\n\t\t\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF SHEET TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\t//////////////////////////\n\t\t// START OF CONTENT TAB///\n\t\t///\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twContentTab.setText(Messages.getString(\"ExcelInputDialog.ContentTab.TabTitle\"));\n\n\t\tFormLayout contentLayout = new FormLayout ();\n\t\tcontentLayout.marginWidth  = 3;\n\t\tcontentLayout.marginHeight = 3;\n\t\t\n\t\twContentComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wContentComp);\n\t\twContentComp.setLayout(contentLayout);\n\n\t\t// Header checkbox\n\t\twlHeader=new Label(wContentComp, SWT.RIGHT);\n\t\twlHeader.setText(Messages.getString(\"ExcelInputDialog.Header.Label\"));\n \t\tprops.setLook(wlHeader);\n\t\tfdlHeader=new FormData();\n\t\tfdlHeader.left = new FormAttachment(0, 0);\n\t\tfdlHeader.top  = new FormAttachment(0, 0);\n\t\tfdlHeader.right= new FormAttachment(middle, -margin);\n\t\twlHeader.setLayoutData(fdlHeader);\n\t\twHeader=new Button(wContentComp, SWT.CHECK);\n \t\tprops.setLook(wHeader);\n\t\tfdHeader=new FormData();\n\t\tfdHeader.left = new FormAttachment(middle, 0);\n\t\tfdHeader.top  = new FormAttachment(0, 0);\n\t\tfdHeader.right= new FormAttachment(100, 0);\n\t\twHeader.setLayoutData(fdHeader);\n\t\twHeader.addSelectionListener(new SelectionAdapter() \n\t        {\n\t\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t\t{\n\t\t\t\t\tenableFields();\n\t\t\t\t}\n\t\t\t});\n\n\t\twlNoempty=new Label(wContentComp, SWT.RIGHT);\n\t\twlNoempty.setText(Messages.getString(\"ExcelInputDialog.NoEmpty.Label\"));\n \t\tprops.setLook(wlNoempty);\n\t\tfdlNoempty=new FormData();\n\t\tfdlNoempty.left = new FormAttachment(0, 0);\n\t\tfdlNoempty.top  = new FormAttachment(wHeader, margin);\n\t\tfdlNoempty.right= new FormAttachment(middle, -margin);\n\t\twlNoempty.setLayoutData(fdlNoempty);\n\t\twNoempty=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wNoempty);\n\t\twNoempty.setToolTipText(Messages.getString(\"ExcelInputDialog.NoEmpty.Tooltip\"));\n\t\tfdNoempty=new FormData();\n\t\tfdNoempty.left = new FormAttachment(middle, 0);\n\t\tfdNoempty.top  = new FormAttachment(wHeader, margin);\n\t\tfdNoempty.right= new FormAttachment(100, 0);\n\t\twNoempty.setLayoutData(fdNoempty);\n\n\t\twlStoponempty=new Label(wContentComp, SWT.RIGHT);\n\t\twlStoponempty.setText(Messages.getString(\"ExcelInputDialog.StopOnEmpty.Label\"));\n \t\tprops.setLook(wlStoponempty);\n\t\tfdlStoponempty=new FormData();\n\t\tfdlStoponempty.left = new FormAttachment(0, 0);\n\t\tfdlStoponempty.top  = new FormAttachment(wNoempty, margin);\n\t\tfdlStoponempty.right= new FormAttachment(middle, -margin);\n\t\twlStoponempty.setLayoutData(fdlStoponempty);\n\t\twStoponempty=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wStoponempty);\n\t\twStoponempty.setToolTipText(Messages.getString(\"ExcelInputDialog.StopOnEmpty.Tooltip\"));\n\t\tfdStoponempty=new FormData();\n\t\tfdStoponempty.left = new FormAttachment(middle, 0);\n\t\tfdStoponempty.top  = new FormAttachment(wNoempty, margin);\n\t\tfdStoponempty.right= new FormAttachment(100, 0);\n\t\twStoponempty.setLayoutData(fdStoponempty);\n\n\t\twlInclFilenameField=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclFilenameField.setText(Messages.getString(\"ExcelInputDialog.InclFilenameField.Label\"));\n \t\tprops.setLook(wlInclFilenameField);\n\t\tfdlInclFilenameField=new FormData();\n\t\tfdlInclFilenameField.left  = new FormAttachment(0, 0);\n\t\tfdlInclFilenameField.top   = new FormAttachment(wStoponempty, margin);\n\t\tfdlInclFilenameField.right = new FormAttachment(middle, -margin);\n\t\twlInclFilenameField.setLayoutData(fdlInclFilenameField);\n\t\twInclFilenameField=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclFilenameField);\n\t\twInclFilenameField.addModifyListener(lsMod);\n\t\tfdInclFilenameField=new FormData();\n\t\tfdInclFilenameField.left = new FormAttachment(middle, 0);\n\t\tfdInclFilenameField.top  = new FormAttachment(wStoponempty, margin);\n\t\tfdInclFilenameField.right= new FormAttachment(100, 0);\n\t\twInclFilenameField.setLayoutData(fdInclFilenameField);\n\n\t\twlInclSheetnameField=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclSheetnameField.setText(Messages.getString(\"ExcelInputDialog.InclSheetnameField.Label\"));\n \t\tprops.setLook(wlInclSheetnameField);\n\t\tfdlInclSheetnameField=new FormData();\n\t\tfdlInclSheetnameField.left  = new FormAttachment(0, 0);\n\t\tfdlInclSheetnameField.top   = new FormAttachment(wInclFilenameField, margin);\n\t\tfdlInclSheetnameField.right = new FormAttachment(middle, -margin);\n\t\twlInclSheetnameField.setLayoutData(fdlInclSheetnameField);\n\t\twInclSheetnameField=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclSheetnameField);\n\t\twInclSheetnameField.addModifyListener(lsMod);\n\t\tfdInclSheetnameField=new FormData();\n\t\tfdInclSheetnameField.left = new FormAttachment(middle, 0);\n\t\tfdInclSheetnameField.top  = new FormAttachment(wInclFilenameField, margin);\n\t\tfdInclSheetnameField.right= new FormAttachment(100, 0);\n\t\twInclSheetnameField.setLayoutData(fdInclSheetnameField);\n\t\t\n\t\twlInclRownumField=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclRownumField.setText(Messages.getString(\"ExcelInputDialog.InclRownumField.Label\"));\n \t\tprops.setLook(wlInclRownumField);\n\t\tfdlInclRownumField=new FormData();\n\t\tfdlInclRownumField.left  = new FormAttachment(0, 0);\n\t\tfdlInclRownumField.top   = new FormAttachment(wInclSheetnameField, margin);\n\t\tfdlInclRownumField.right = new FormAttachment(middle, -margin);\n\t\twlInclRownumField.setLayoutData(fdlInclRownumField);\n\t\twInclRownumField=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclRownumField);\n\t\twInclRownumField.addModifyListener(lsMod);\n\t\tfdInclRownumField=new FormData();\n\t\tfdInclRownumField.left = new FormAttachment(middle, 0);\n\t\tfdInclRownumField.top  = new FormAttachment(wInclSheetnameField, margin);\n\t\tfdInclRownumField.right= new FormAttachment(100, 0);\n\t\twInclRownumField.setLayoutData(fdInclRownumField);\n\n\t\twlLimit=new Label(wContentComp, SWT.RIGHT);\n\t\twlLimit.setText(Messages.getString(\"ExcelInputDialog.Limit.Label\"));\n \t\tprops.setLook(wlLimit);\n\t\tfdlLimit=new FormData();\n\t\tfdlLimit.left = new FormAttachment(0, 0);\n\t\tfdlLimit.top  = new FormAttachment(wInclRownumField, margin);\n\t\tfdlLimit.right= new FormAttachment(middle, -margin);\n\t\twlLimit.setLayoutData(fdlLimit);\n\t\twLimit=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wLimit);\n\t\twLimit.addModifyListener(lsMod);\n\t\tfdLimit=new FormData();\n\t\tfdLimit.left = new FormAttachment(middle, 0);\n\t\tfdLimit.top  = new FormAttachment(wInclRownumField, margin);\n\t\tfdLimit.right= new FormAttachment(100, 0);\n\t\twLimit.setLayoutData(fdLimit);\n\t\t\n\t\tfdContentComp = new FormData();\n\t\tfdContentComp.left  = new FormAttachment(0, 0);\n\t\tfdContentComp.top   = new FormAttachment(0, 0);\n\t\tfdContentComp.right = new FormAttachment(100, 0);\n\t\tfdContentComp.bottom= new FormAttachment(100, 0);\n\t\twContentComp.setLayoutData(fdContentComp);\n\n\t\twContentComp.layout();\n\t\twContentTab.setControl(wContentComp);\n\n\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF CONTENT TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// START OF CONTENT TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\taddErrorTab();\n\n\t\t// Fields tab...\n\t\t//\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\n\t\twFieldsTab.setText(Messages.getString(\"ExcelInputDialog.FieldsTab.TabTitle\"));\n\t\t\n\t\tFormLayout fieldsLayout = new FormLayout ();\n\t\tfieldsLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\n\t\t\n\t\twFieldsComp = new Composite(wTabFolder, SWT.NONE);\n\t\twFieldsComp.setLayout(fieldsLayout);\n\n\t\twbGetFields=new Button(wFieldsComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbGetFields);\n\t\twbGetFields.setText(Messages.getString(\"ExcelInputDialog.GetFields.Button\"));\n\t\t\n\t\tsetButtonPositions(new Button[] { wbGetFields }, margin, null);\n\n\t\tenableFields();\n\n\t\tfinal int FieldsCols=6;\n\t\tfinal int FieldsRows=input.getFieldName().length;\n\t\tint FieldsWidth =600;\n\t\tint FieldsHeight=150;\n\t\t\n\t\t// Prepare a list of possible formats...\n\t\tString dats[] = Const.dateFormats;\n\t\tString nums[] = Const.numberFormats;\n\t\tint totsize = dats.length + nums.length;\n\t\tString formats[] = new String[totsize];\n\t\tfor (int x=0;x<dats.length;x++) formats[x] = dats[x];\n\t\tfor (int x=0;x<nums.length;x++) formats[dats.length+x] = nums[x];\n\t\t\n\t\t\n\t\tColumnInfo[] colinf=new ColumnInfo[FieldsCols];\n\t\tcolinf[ 0]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Name.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tcolinf[ 1]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Type.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO,  Value.getTypes() );\n\t\tcolinf[ 2]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Length.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tcolinf[ 3]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Precision.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tcolinf[ 4]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.TrimType.Column\"),  ColumnInfo.COLUMN_TYPE_CCOMBO,  TextFileInputMeta.trimTypeDesc );\n\t\tcolinf[ 5]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Repeat.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO,  new String[] { Messages.getString(\"System.Combo.Yes\"), Messages.getString(\"System.Combo.No\") } );\n\t\t\n\t\tcolinf[ 5].setToolTip(Messages.getString(\"ExcelInputDialog.Repeat.Tooltip\"));\n\t\t\n\t\twFields=new TableView(wFieldsComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.MULTI, \n\t\t\t\t\t\t      colinf, \n\t\t\t\t\t\t      FieldsRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\t\twFields.setSize(FieldsWidth,FieldsHeight);\n\n\t\tfdFields=new FormData();\n\t\tfdFields.left  = new FormAttachment(0, 0);\n\t\tfdFields.top   = new FormAttachment(0, 0);\n\t\tfdFields.right = new FormAttachment(100, 0);\n\t\tfdFields.bottom= new FormAttachment(wbGetFields, -margin);\n\t\twFields.setLayoutData(fdFields);\n\n\t\tfdFieldsComp=new FormData();\n\t\tfdFieldsComp.left  = new FormAttachment(0, 0);\n\t\tfdFieldsComp.top   = new FormAttachment(0, 0);\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\n\t\tfdFieldsComp.bottom= new FormAttachment(100, 0);\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\n\t\t\n\t\twFieldsComp.layout();\n\t\twFieldsTab.setControl(wFieldsComp);\n \t\tprops.setLook(wFieldsComp);\n\t\t\n\t\tfdTabFolder = new FormData();\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\n\t\twTabFolder.setLayoutData(fdTabFolder);\n\t\t\n\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\twPreview=new Button(shell, SWT.PUSH);\n\t\twPreview.setText(Messages.getString(\"ExcelInputDialog.PreviewRows.Button\"));\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wPreview, wCancel }, margin, wTabFolder);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsPreview  = new Listener() { public void handleEvent(Event e) { preview();   } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();     } };\n\t\t\n\t\twOK.addListener     (SWT.Selection, lsOK     );\n\t\twPreview.addListener(SWT.Selection, lsPreview);\n\t\twCancel.addListener (SWT.Selection, lsCancel );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t// wFilename.addSelectionListener( lsDef );\n\t\twLimit.addSelectionListener( lsDef );\n\t\twInclRownumField.addSelectionListener( lsDef );\n\t\twInclFilenameField.addSelectionListener( lsDef );\n\t\twInclSheetnameField.addSelectionListener( lsDef );\n\n\t\t// Add the file to the list of files...\n\t\tSelectionAdapter selA = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\twFilenameList.add(new String[] { wFilename.getText(), wFilemask.getText() } );\n\t\t\t\twFilename.setText(\"\");\n\t\t\t\twFilemask.setText(\"\");\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n                wFilenameList.optWidth(true);\n\t\t\t}\n\t\t};\n\t\twbaFilename.addSelectionListener(selA);\n\t\twFilename.addSelectionListener(selA);\n\t\t\n\t\t// Delete files from the list of files...\n\t\twbdFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx[] = wFilenameList.getSelectionIndices();\n\t\t\t\twFilenameList.remove(idx);\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Edit the selected file & remove from the list...\n\t\twbeFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx = wFilenameList.getSelectionIndex();\n\t\t\t\tif (idx>=0)\n\t\t\t\t{\n\t\t\t\t\tString string[] = wFilenameList.getItem(idx);\n\t\t\t\t\twFilename.setText(string[0]);\n\t\t\t\t\twFilemask.setText(string[1]);\n\t\t\t\t\twFilenameList.remove(idx);\n\t\t\t\t}\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Show the files that are selected at this time...\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tExcelInputMeta eii = new ExcelInputMeta();\n\t\t\t\t\tgetInfo(eii);\n\t\t\t\t\tString[] files = eii.getFilePaths();\n\t\t\t\t\tif (files.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, props, files, Messages.getString(\"ExcelInputDialog.FilesRead.DialogTitle\"), Messages.getString(\"ExcelInputDialog.FilesRead.DialogMessage\"));\n\t\t\t\t\t\tesd.setViewOnly();\n\t\t\t\t\t\tesd.open();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\t\t\t\tmb.setMessage(Messages.getString(\"ExcelInputDialog.NoFilesFound.DialogMessage\"));\n\t\t\t\t\t\tmb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\n\t\t\t\t\t\tmb.open(); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version of the filename:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename.setToolTipText(Const.replEnv( wFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Listen to the Variable... button\n\t\twbvFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tProperties sp = System.getProperties();\n\t\t\t\t\tEnumeration keys = sp.keys();\n\t\t\t\t\tint size = sp.values().size();\n\t\t\t\t\tString key[] = new String[size];\n\t\t\t\t\tString val[] = new String[size];\n\t\t\t\t\tString str[] = new String[size];\n\t\t\t\t\tint i=0;\n\t\t\t\t\twhile (keys.hasMoreElements())\n\t\t\t\t\t{\n\t\t\t\t\t\tkey[i] = (String)keys.nextElement();\n\t\t\t\t\t\tval[i] = sp.getProperty(key[i]);\n\t\t\t\t\t\tstr[i] = key[i]+\"  [\"+val[i]+\"]\";\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, props, str, Messages.getString(\"System.Dialog.SelectEnvironmentVar.Title\"), Messages.getString(\"System.Dialog.SelectEnvironmentVar.Message\"));\n\t\t\t\t\tif (esd.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nr = esd.getSelectionNr();\n\t\t\t\t\t\twFilename.insert(\"%%\"+key[nr]+\"%%\");\n\t\t\t\t\t\twFilename.setToolTipText(Const.replEnv( wFilename.getText() ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t);\n\n\n\t\t// Listen to the Browse... button\n\t\twbbFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tif (wFilemask.getText()!=null && wFilemask.getText().length()>0) // A mask: a directory!\n\t\t\t\t\t{\n\t\t\t\t\t\tDirectoryDialog dialog = new DirectoryDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fpath = Const.replEnv(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFilterPath( fpath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str= dialog.getFilterPath();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xls;*.XLS\", \"*\"});\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fname = Const.replEnv(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFileName( fname );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"ExcelInputDialog.FilterNames.ExcelFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Get a list of the sheetnames.\n\t\twbGetSheets.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tgetSheets();\n\t\t\t}\n\t\t});\n\t\t\n\t\twbGetFields.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tgetFields();\n\t\t\t}\n\t\t});\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twTabFolder.setSelection(0);\n\t\t\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\tgetData(input);\n\t\tinput.setChanged(changed);\n\t\twFields.optWidth(true);\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":72705,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n\n\t\tlsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged         = input.hasChanged();\n\t\t\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"ExcelInputDialog.DialogTitle\"));\n\t\t\n\t\tmiddle = props.getMiddlePct();\n\t\tmargin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"System.Label.StepName\"));\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\n\t\t\n\t\t//////////////////////////\n\t\t// START OF FILE TAB   ///\n\t\t//////////////////////////\n\t\twFileTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twFileTab.setText(Messages.getString(\"ExcelInputDialog.FileTab.TabTitle\"));\n\t\t\n\t\twFileComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wFileComp);\n\n\t\tFormLayout fileLayout = new FormLayout();\n\t\tfileLayout.marginWidth  = 3;\n\t\tfileLayout.marginHeight = 3;\n\t\twFileComp.setLayout(fileLayout);\n\n\t\t// Filename line\n\t\twlFilename=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"ExcelInputDialog.Filename.Label\"));\n \t\tprops.setLook(wlFilename);\n\t\tfdlFilename=new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top  = new FormAttachment(0, 0);\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbbFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbbFilename);\n\t\twbbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\twbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t\tfdbFilename=new FormData();\n\t\tfdbFilename.right= new FormAttachment(100, 0);\n\t\tfdbFilename.top  = new FormAttachment(0, 0);\n\t\twbbFilename.setLayoutData(fdbFilename);\n\n\t\twbvFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbvFilename);\n\t\twbvFilename.setText(Messages.getString(\"System.Button.Variable\"));\n\t\twbvFilename.setToolTipText(\"Insert a variable in the filename or directory\");\n\t\tfdbvFilename=new FormData();\n\t\tfdbvFilename.right= new FormAttachment(wbbFilename, -margin);\n\t\tfdbvFilename.top  = new FormAttachment(0, 0);\n\t\twbvFilename.setLayoutData(fdbvFilename);\n\n\t\twbaFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbaFilename);\n\t\twbaFilename.setText(Messages.getString(\"ExcelInputDialog.FilenameAdd.Button\"));\n\t\twbaFilename.setToolTipText(Messages.getString(\"ExcelInputDialog.FilenameAdd.Tooltip\"));\n\t\tfdbaFilename=new FormData();\n\t\tfdbaFilename.right= new FormAttachment(wbvFilename, -margin);\n\t\tfdbaFilename.top  = new FormAttachment(0, 0);\n\t\twbaFilename.setLayoutData(fdbaFilename);\n\n\t\twFilename=new Text(wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename=new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.right= new FormAttachment(wbaFilename, -margin);\n\t\tfdFilename.top  = new FormAttachment(0, 0);\n\t\twFilename.setLayoutData(fdFilename);\n\n\t\twlFilemask=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilemask.setText(Messages.getString(\"ExcelInputDialog.Filemask.Label\"));\n \t\tprops.setLook(wlFilemask);\n\t\tfdlFilemask=new FormData();\n\t\tfdlFilemask.left = new FormAttachment(0, 0);\n\t\tfdlFilemask.top  = new FormAttachment(wFilename, margin);\n\t\tfdlFilemask.right= new FormAttachment(middle, -margin);\n\t\twlFilemask.setLayoutData(fdlFilemask);\n\t\twFilemask=new Text(wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilemask);\n\t\twFilemask.addModifyListener(lsMod);\n\t\tfdFilemask=new FormData();\n\t\tfdFilemask.left = new FormAttachment(middle, 0);\n\t\tfdFilemask.top  = new FormAttachment(wFilename, margin);\n\t\tfdFilemask.right= new FormAttachment(100, 0);\n\t\twFilemask.setLayoutData(fdFilemask);\n\n\t\t// Filename list line\n\t\twlFilenameList=new Label(wFileComp, SWT.RIGHT);\n\t\twlFilenameList.setText(Messages.getString(\"ExcelInputDialog.FilenameList.Label\"));\n \t\tprops.setLook(wlFilenameList);\n\t\tfdlFilenameList=new FormData();\n\t\tfdlFilenameList.left = new FormAttachment(0, 0);\n\t\tfdlFilenameList.top  = new FormAttachment(wFilemask, margin);\n\t\tfdlFilenameList.right= new FormAttachment(middle, -margin);\n\t\twlFilenameList.setLayoutData(fdlFilenameList);\n\n\t\t// Buttons to the right of the screen...\n\t\twbdFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbdFilename);\n\t\twbdFilename.setText(Messages.getString(\"ExcelInputDialog.FilenameDelete.Button\"));\n\t\twbdFilename.setToolTipText(Messages.getString(\"ExcelInputDialog.FilenameDelete.Tooltip\"));\n\t\tfdbdFilename=new FormData();\n\t\tfdbdFilename.right = new FormAttachment(100, 0);\n\t\tfdbdFilename.top  = new FormAttachment (wFilemask, 40);\n\t\twbdFilename.setLayoutData(fdbdFilename);\n\n\t\twbeFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbeFilename);\n\t\twbeFilename.setText(Messages.getString(\"ExcelInputDialog.FilenameEdit.Button\"));\n\t\twbeFilename.setToolTipText(Messages.getString(\"ExcelInputDialog.FilenameEdit.Button\"));\n\t\tfdbeFilename=new FormData();\n\t\tfdbeFilename.right = new FormAttachment(100, 0);\n\t\tfdbeFilename.top  = new FormAttachment (wbdFilename, margin);\n\t\twbeFilename.setLayoutData(fdbeFilename);\n\n\t\twbShowFiles=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbShowFiles);\n\t\twbShowFiles.setText(Messages.getString(\"ExcelInputDialog.ShowFiles.Button\"));\n\t\tfdbShowFiles=new FormData();\n\t\tfdbShowFiles.left   = new FormAttachment(middle, 0);\n\t\tfdbShowFiles.bottom = new FormAttachment(100, -margin);\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\n\n\t\tColumnInfo[] colinfo=new ColumnInfo[3];\n\t\tcolinfo[ 0]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.FileDir.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tcolinfo[ 1]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Wildcard.Column\"),        ColumnInfo.COLUMN_TYPE_TEXT,    false );\n\t\tcolinfo[ 1].setToolTip(Messages.getString(\"ExcelInputDialog.Wildcard.Tooltip\"));\n\t\tcolinfo[ 2]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Required.Column\"),        ColumnInfo.COLUMN_TYPE_CCOMBO,  YES_NO_COMBO );\n\t\tcolinfo[ 2].setToolTip(Messages.getString(\"ExcelInputDialog.Required.Tooltip\"));\n\t\t\n\t\twFilenameList = new TableView(wFileComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.SINGLE | SWT.BORDER, \n\t\t\t\t\t\t      colinfo, \n\t\t\t\t\t\t      input.getFileName().length,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n \t\tprops.setLook(wFilenameList);\n\t\tfdFilenameList=new FormData();\n\t\tfdFilenameList.left   = new FormAttachment(middle, 0);\n\t\tfdFilenameList.right  = new FormAttachment(wbdFilename, -margin);\n\t\tfdFilenameList.top    = new FormAttachment(wFilemask, margin);\n\t\tfdFilenameList.bottom = new FormAttachment(wbShowFiles, -margin);\n\t\twFilenameList.setLayoutData(fdFilenameList);\n\n\t\n\t\tfdFileComp=new FormData();\n\t\tfdFileComp.left  = new FormAttachment(0, 0);\n\t\tfdFileComp.top   = new FormAttachment(0, 0);\n\t\tfdFileComp.right = new FormAttachment(100, 0);\n\t\tfdFileComp.bottom= new FormAttachment(100, 0);\n\t\twFileComp.setLayoutData(fdFileComp);\n\t\n\t\twFileComp.layout();\n\t\twFileTab.setControl(wFileComp);\n\t\t\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF FILE TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\t//////////////////////////\n\t\t// START OF SHEET TAB  ///\n\t\t//////////////////////////\n\t\twSheetTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twSheetTab.setText(Messages.getString(\"ExcelInputDialog.SheetsTab.TabTitle\"));\n\t\t\n\t\twSheetComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wSheetComp);\n\n\t\tFormLayout sheetLayout = new FormLayout();\n\t\tsheetLayout.marginWidth  = 3;\n\t\tsheetLayout.marginHeight = 3;\n\t\twSheetComp.setLayout(sheetLayout);\n\t\t\n\t\twbGetSheets=new Button(wSheetComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbGetSheets);\n\t\twbGetSheets.setText(Messages.getString(\"ExcelInputDialog.GetSheets.Button\"));\n\t\tfdbGetSheets=new FormData();\n\t\tfdbGetSheets.left   = new FormAttachment(middle, 0);\n\t\tfdbGetSheets.bottom = new FormAttachment(100, -margin);\n\t\twbGetSheets.setLayoutData(fdbGetSheets);\n\n\t\twlSheetnameList=new Label(wSheetComp, SWT.RIGHT);\n\t\twlSheetnameList.setText(Messages.getString(\"ExcelInputDialog.SheetNameList.Label\"));\n \t\tprops.setLook(wlSheetnameList);\n\t\tfdlSheetnameList=new FormData();\n\t\tfdlSheetnameList.left = new FormAttachment(0, 0);\n\t\tfdlSheetnameList.top  = new FormAttachment(wFilename, margin);\n\t\tfdlSheetnameList.right= new FormAttachment(middle, -margin);\n\t\twlSheetnameList.setLayoutData(fdlSheetnameList);\n\t\t\n\t\tColumnInfo[] shinfo=new ColumnInfo[3];\n\t\tshinfo[ 0]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.SheetName.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tshinfo[ 1]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.StartRow.Column\"),      ColumnInfo.COLUMN_TYPE_TEXT,    false );\n\t\tshinfo[ 2]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.StartColumn.Column\"),   ColumnInfo.COLUMN_TYPE_TEXT,    false );\n\t\t\n\t\twSheetnameList = new TableView(wSheetComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.MULTI | SWT.BORDER, \n\t\t\t\t\t\t      shinfo, \n\t\t\t\t\t\t      input.getSheetName().length,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n \t\tprops.setLook(wSheetnameList);\n\t\tfdFilenameList=new FormData();\n\t\tfdFilenameList.left   = new FormAttachment(middle, 0);\n\t\tfdFilenameList.right  = new FormAttachment(100, 0);\n\t\tfdFilenameList.top    = new FormAttachment(0, 0);\n\t\tfdFilenameList.bottom = new FormAttachment(wbGetSheets, -margin);\n\t\twSheetnameList.setLayoutData(fdFilenameList);\n\t\t\n\t\tfdSheetComp=new FormData();\n\t\tfdSheetComp.left  = new FormAttachment(0, 0);\n\t\tfdSheetComp.top   = new FormAttachment(0, 0);\n\t\tfdSheetComp.right = new FormAttachment(100, 0);\n\t\tfdSheetComp.bottom= new FormAttachment(100, 0);\n\t\twSheetComp.setLayoutData(fdSheetComp);\n\t\n\t\twSheetComp.layout();\n\t\twSheetTab.setControl(wSheetComp);\n\t\t\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF SHEET TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\t//////////////////////////\n\t\t// START OF CONTENT TAB///\n\t\t///\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twContentTab.setText(Messages.getString(\"ExcelInputDialog.ContentTab.TabTitle\"));\n\n\t\tFormLayout contentLayout = new FormLayout ();\n\t\tcontentLayout.marginWidth  = 3;\n\t\tcontentLayout.marginHeight = 3;\n\t\t\n\t\twContentComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wContentComp);\n\t\twContentComp.setLayout(contentLayout);\n\n\t\t// Header checkbox\n\t\twlHeader=new Label(wContentComp, SWT.RIGHT);\n\t\twlHeader.setText(Messages.getString(\"ExcelInputDialog.Header.Label\"));\n \t\tprops.setLook(wlHeader);\n\t\tfdlHeader=new FormData();\n\t\tfdlHeader.left = new FormAttachment(0, 0);\n\t\tfdlHeader.top  = new FormAttachment(0, 0);\n\t\tfdlHeader.right= new FormAttachment(middle, -margin);\n\t\twlHeader.setLayoutData(fdlHeader);\n\t\twHeader=new Button(wContentComp, SWT.CHECK);\n \t\tprops.setLook(wHeader);\n\t\tfdHeader=new FormData();\n\t\tfdHeader.left = new FormAttachment(middle, 0);\n\t\tfdHeader.top  = new FormAttachment(0, 0);\n\t\tfdHeader.right= new FormAttachment(100, 0);\n\t\twHeader.setLayoutData(fdHeader);\n\t\twHeader.addSelectionListener(new SelectionAdapter() \n\t        {\n\t\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t\t{\n\t\t\t\t\tenableFields();\n\t\t\t\t}\n\t\t\t});\n\n\t\twlNoempty=new Label(wContentComp, SWT.RIGHT);\n\t\twlNoempty.setText(Messages.getString(\"ExcelInputDialog.NoEmpty.Label\"));\n \t\tprops.setLook(wlNoempty);\n\t\tfdlNoempty=new FormData();\n\t\tfdlNoempty.left = new FormAttachment(0, 0);\n\t\tfdlNoempty.top  = new FormAttachment(wHeader, margin);\n\t\tfdlNoempty.right= new FormAttachment(middle, -margin);\n\t\twlNoempty.setLayoutData(fdlNoempty);\n\t\twNoempty=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wNoempty);\n\t\twNoempty.setToolTipText(Messages.getString(\"ExcelInputDialog.NoEmpty.Tooltip\"));\n\t\tfdNoempty=new FormData();\n\t\tfdNoempty.left = new FormAttachment(middle, 0);\n\t\tfdNoempty.top  = new FormAttachment(wHeader, margin);\n\t\tfdNoempty.right= new FormAttachment(100, 0);\n\t\twNoempty.setLayoutData(fdNoempty);\n\n\t\twlStoponempty=new Label(wContentComp, SWT.RIGHT);\n\t\twlStoponempty.setText(Messages.getString(\"ExcelInputDialog.StopOnEmpty.Label\"));\n \t\tprops.setLook(wlStoponempty);\n\t\tfdlStoponempty=new FormData();\n\t\tfdlStoponempty.left = new FormAttachment(0, 0);\n\t\tfdlStoponempty.top  = new FormAttachment(wNoempty, margin);\n\t\tfdlStoponempty.right= new FormAttachment(middle, -margin);\n\t\twlStoponempty.setLayoutData(fdlStoponempty);\n\t\twStoponempty=new Button(wContentComp, SWT.CHECK );\n \t\tprops.setLook(wStoponempty);\n\t\twStoponempty.setToolTipText(Messages.getString(\"ExcelInputDialog.StopOnEmpty.Tooltip\"));\n\t\tfdStoponempty=new FormData();\n\t\tfdStoponempty.left = new FormAttachment(middle, 0);\n\t\tfdStoponempty.top  = new FormAttachment(wNoempty, margin);\n\t\tfdStoponempty.right= new FormAttachment(100, 0);\n\t\twStoponempty.setLayoutData(fdStoponempty);\n\n\t\twlInclFilenameField=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclFilenameField.setText(Messages.getString(\"ExcelInputDialog.InclFilenameField.Label\"));\n \t\tprops.setLook(wlInclFilenameField);\n\t\tfdlInclFilenameField=new FormData();\n\t\tfdlInclFilenameField.left  = new FormAttachment(0, 0);\n\t\tfdlInclFilenameField.top   = new FormAttachment(wStoponempty, margin);\n\t\tfdlInclFilenameField.right = new FormAttachment(middle, -margin);\n\t\twlInclFilenameField.setLayoutData(fdlInclFilenameField);\n\t\twInclFilenameField=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclFilenameField);\n\t\twInclFilenameField.addModifyListener(lsMod);\n\t\tfdInclFilenameField=new FormData();\n\t\tfdInclFilenameField.left = new FormAttachment(middle, 0);\n\t\tfdInclFilenameField.top  = new FormAttachment(wStoponempty, margin);\n\t\tfdInclFilenameField.right= new FormAttachment(100, 0);\n\t\twInclFilenameField.setLayoutData(fdInclFilenameField);\n\n\t\twlInclSheetnameField=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclSheetnameField.setText(Messages.getString(\"ExcelInputDialog.InclSheetnameField.Label\"));\n \t\tprops.setLook(wlInclSheetnameField);\n\t\tfdlInclSheetnameField=new FormData();\n\t\tfdlInclSheetnameField.left  = new FormAttachment(0, 0);\n\t\tfdlInclSheetnameField.top   = new FormAttachment(wInclFilenameField, margin);\n\t\tfdlInclSheetnameField.right = new FormAttachment(middle, -margin);\n\t\twlInclSheetnameField.setLayoutData(fdlInclSheetnameField);\n\t\twInclSheetnameField=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclSheetnameField);\n\t\twInclSheetnameField.addModifyListener(lsMod);\n\t\tfdInclSheetnameField=new FormData();\n\t\tfdInclSheetnameField.left = new FormAttachment(middle, 0);\n\t\tfdInclSheetnameField.top  = new FormAttachment(wInclFilenameField, margin);\n\t\tfdInclSheetnameField.right= new FormAttachment(100, 0);\n\t\twInclSheetnameField.setLayoutData(fdInclSheetnameField);\n\t\t\n\t\twlInclRownumField=new Label(wContentComp, SWT.RIGHT);\n\t\twlInclRownumField.setText(Messages.getString(\"ExcelInputDialog.InclRownumField.Label\"));\n \t\tprops.setLook(wlInclRownumField);\n\t\tfdlInclRownumField=new FormData();\n\t\tfdlInclRownumField.left  = new FormAttachment(0, 0);\n\t\tfdlInclRownumField.top   = new FormAttachment(wInclSheetnameField, margin);\n\t\tfdlInclRownumField.right = new FormAttachment(middle, -margin);\n\t\twlInclRownumField.setLayoutData(fdlInclRownumField);\n\t\twInclRownumField=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclRownumField);\n\t\twInclRownumField.addModifyListener(lsMod);\n\t\tfdInclRownumField=new FormData();\n\t\tfdInclRownumField.left = new FormAttachment(middle, 0);\n\t\tfdInclRownumField.top  = new FormAttachment(wInclSheetnameField, margin);\n\t\tfdInclRownumField.right= new FormAttachment(100, 0);\n\t\twInclRownumField.setLayoutData(fdInclRownumField);\n\n\t\twlLimit=new Label(wContentComp, SWT.RIGHT);\n\t\twlLimit.setText(Messages.getString(\"ExcelInputDialog.Limit.Label\"));\n \t\tprops.setLook(wlLimit);\n\t\tfdlLimit=new FormData();\n\t\tfdlLimit.left = new FormAttachment(0, 0);\n\t\tfdlLimit.top  = new FormAttachment(wInclRownumField, margin);\n\t\tfdlLimit.right= new FormAttachment(middle, -margin);\n\t\twlLimit.setLayoutData(fdlLimit);\n\t\twLimit=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wLimit);\n\t\twLimit.addModifyListener(lsMod);\n\t\tfdLimit=new FormData();\n\t\tfdLimit.left = new FormAttachment(middle, 0);\n\t\tfdLimit.top  = new FormAttachment(wInclRownumField, margin);\n\t\tfdLimit.right= new FormAttachment(100, 0);\n\t\twLimit.setLayoutData(fdLimit);\n\t\t\n\t\tfdContentComp = new FormData();\n\t\tfdContentComp.left  = new FormAttachment(0, 0);\n\t\tfdContentComp.top   = new FormAttachment(0, 0);\n\t\tfdContentComp.right = new FormAttachment(100, 0);\n\t\tfdContentComp.bottom= new FormAttachment(100, 0);\n\t\twContentComp.setLayoutData(fdContentComp);\n\n\t\twContentComp.layout();\n\t\twContentTab.setControl(wContentComp);\n\n\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF CONTENT TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// START OF CONTENT TAB\n\t\t/////////////////////////////////////////////////////////////\n\n\t\taddErrorTab();\n\n\t\t// Fields tab...\n\t\t//\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\n\t\twFieldsTab.setText(Messages.getString(\"ExcelInputDialog.FieldsTab.TabTitle\"));\n\t\t\n\t\tFormLayout fieldsLayout = new FormLayout ();\n\t\tfieldsLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\n\t\t\n\t\twFieldsComp = new Composite(wTabFolder, SWT.NONE);\n\t\twFieldsComp.setLayout(fieldsLayout);\n\n\t\twbGetFields=new Button(wFieldsComp, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbGetFields);\n\t\twbGetFields.setText(Messages.getString(\"ExcelInputDialog.GetFields.Button\"));\n\t\t\n\t\tsetButtonPositions(new Button[] { wbGetFields }, margin, null);\n\n\t\tenableFields();\n\n\t\tfinal int FieldsCols=6;\n\t\tfinal int FieldsRows=input.getField().length;\n\t\tint FieldsWidth =600;\n\t\tint FieldsHeight=150;\n\t\t\n\t\t// Prepare a list of possible formats...\n\t\tString dats[] = Const.dateFormats;\n\t\tString nums[] = Const.numberFormats;\n\t\tint totsize = dats.length + nums.length;\n\t\tString formats[] = new String[totsize];\n\t\tfor (int x=0;x<dats.length;x++) formats[x] = dats[x];\n\t\tfor (int x=0;x<nums.length;x++) formats[dats.length+x] = nums[x];\n\t\t\n\t\t\n\t\tColumnInfo[] colinf=new ColumnInfo[FieldsCols];\n\t\tcolinf[ 0]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Name.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tcolinf[ 1]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Type.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO,  Value.getTypes() );\n\t\tcolinf[ 2]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Length.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tcolinf[ 3]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Precision.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false);\n\t\tcolinf[ 4]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.TrimType.Column\"),  ColumnInfo.COLUMN_TYPE_CCOMBO,  TextFileInputMeta.trimTypeDesc );\n\t\tcolinf[ 5]=new ColumnInfo(Messages.getString(\"ExcelInputDialog.Repeat.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO,  new String[] { Messages.getString(\"System.Combo.Yes\"), Messages.getString(\"System.Combo.No\") } );\n\t\t\n\t\tcolinf[ 5].setToolTip(Messages.getString(\"ExcelInputDialog.Repeat.Tooltip\"));\n\t\t\n\t\twFields=new TableView(wFieldsComp, \n\t\t\t\t\t\t      SWT.FULL_SELECTION | SWT.MULTI, \n\t\t\t\t\t\t      colinf, \n\t\t\t\t\t\t      FieldsRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\t\twFields.setSize(FieldsWidth,FieldsHeight);\n\n\t\tfdFields=new FormData();\n\t\tfdFields.left  = new FormAttachment(0, 0);\n\t\tfdFields.top   = new FormAttachment(0, 0);\n\t\tfdFields.right = new FormAttachment(100, 0);\n\t\tfdFields.bottom= new FormAttachment(wbGetFields, -margin);\n\t\twFields.setLayoutData(fdFields);\n\n\t\tfdFieldsComp=new FormData();\n\t\tfdFieldsComp.left  = new FormAttachment(0, 0);\n\t\tfdFieldsComp.top   = new FormAttachment(0, 0);\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\n\t\tfdFieldsComp.bottom= new FormAttachment(100, 0);\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\n\t\t\n\t\twFieldsComp.layout();\n\t\twFieldsTab.setControl(wFieldsComp);\n \t\tprops.setLook(wFieldsComp);\n\t\t\n\t\tfdTabFolder = new FormData();\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\n\t\twTabFolder.setLayoutData(fdTabFolder);\n\t\t\n\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\twPreview=new Button(shell, SWT.PUSH);\n\t\twPreview.setText(Messages.getString(\"ExcelInputDialog.PreviewRows.Button\"));\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wPreview, wCancel }, margin, wTabFolder);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsPreview  = new Listener() { public void handleEvent(Event e) { preview();   } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();     } };\n\t\t\n\t\twOK.addListener     (SWT.Selection, lsOK     );\n\t\twPreview.addListener(SWT.Selection, lsPreview);\n\t\twCancel.addListener (SWT.Selection, lsCancel );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t// wFilename.addSelectionListener( lsDef );\n\t\twLimit.addSelectionListener( lsDef );\n\t\twInclRownumField.addSelectionListener( lsDef );\n\t\twInclFilenameField.addSelectionListener( lsDef );\n\t\twInclSheetnameField.addSelectionListener( lsDef );\n\n\t\t// Add the file to the list of files...\n\t\tSelectionAdapter selA = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\twFilenameList.add(new String[] { wFilename.getText(), wFilemask.getText() } );\n\t\t\t\twFilename.setText(\"\");\n\t\t\t\twFilemask.setText(\"\");\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n                wFilenameList.optWidth(true);\n\t\t\t}\n\t\t};\n\t\twbaFilename.addSelectionListener(selA);\n\t\twFilename.addSelectionListener(selA);\n\t\t\n\t\t// Delete files from the list of files...\n\t\twbdFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx[] = wFilenameList.getSelectionIndices();\n\t\t\t\twFilenameList.remove(idx);\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Edit the selected file & remove from the list...\n\t\twbeFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx = wFilenameList.getSelectionIndex();\n\t\t\t\tif (idx>=0)\n\t\t\t\t{\n\t\t\t\t\tString string[] = wFilenameList.getItem(idx);\n\t\t\t\t\twFilename.setText(string[0]);\n\t\t\t\t\twFilemask.setText(string[1]);\n\t\t\t\t\twFilenameList.remove(idx);\n\t\t\t\t}\n\t\t\t\twFilenameList.removeEmptyRows();\n\t\t\t\twFilenameList.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Show the files that are selected at this time...\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tExcelInputMeta eii = new ExcelInputMeta();\n\t\t\t\t\tgetInfo(eii);\n\t\t\t\t\tString[] files = eii.getFilePaths();\n\t\t\t\t\tif (files.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, props, files, Messages.getString(\"ExcelInputDialog.FilesRead.DialogTitle\"), Messages.getString(\"ExcelInputDialog.FilesRead.DialogMessage\"));\n\t\t\t\t\t\tesd.setViewOnly();\n\t\t\t\t\t\tesd.open();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\t\t\t\tmb.setMessage(Messages.getString(\"ExcelInputDialog.NoFilesFound.DialogMessage\"));\n\t\t\t\t\t\tmb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\n\t\t\t\t\t\tmb.open(); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version of the filename:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename.setToolTipText(Const.replEnv( wFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Listen to the Variable... button\n\t\twbvFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tProperties sp = System.getProperties();\n\t\t\t\t\tEnumeration keys = sp.keys();\n\t\t\t\t\tint size = sp.values().size();\n\t\t\t\t\tString key[] = new String[size];\n\t\t\t\t\tString val[] = new String[size];\n\t\t\t\t\tString str[] = new String[size];\n\t\t\t\t\tint i=0;\n\t\t\t\t\twhile (keys.hasMoreElements())\n\t\t\t\t\t{\n\t\t\t\t\t\tkey[i] = (String)keys.nextElement();\n\t\t\t\t\t\tval[i] = sp.getProperty(key[i]);\n\t\t\t\t\t\tstr[i] = key[i]+\"  [\"+val[i]+\"]\";\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, props, str, Messages.getString(\"System.Dialog.SelectEnvironmentVar.Title\"), Messages.getString(\"System.Dialog.SelectEnvironmentVar.Message\"));\n\t\t\t\t\tif (esd.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nr = esd.getSelectionNr();\n\t\t\t\t\t\twFilename.insert(\"%%\"+key[nr]+\"%%\");\n\t\t\t\t\t\twFilename.setToolTipText(Const.replEnv( wFilename.getText() ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t);\n\n\n\t\t// Listen to the Browse... button\n\t\twbbFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tif (wFilemask.getText()!=null && wFilemask.getText().length()>0) // A mask: a directory!\n\t\t\t\t\t{\n\t\t\t\t\t\tDirectoryDialog dialog = new DirectoryDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fpath = Const.replEnv(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFilterPath( fpath );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str= dialog.getFilterPath();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xls;*.XLS\", \"*\"});\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fname = Const.replEnv(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFileName( fname );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"ExcelInputDialog.FilterNames.ExcelFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Get a list of the sheetnames.\n\t\twbGetSheets.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tgetSheets();\n\t\t\t}\n\t\t});\n\t\t\n\t\twbGetFields.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tgetFields();\n\t\t\t}\n\t\t});\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twTabFolder.setSelection(0);\n\t\t\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\tgetData(input);\n\t\tinput.setChanged(changed);\n\t\twFields.optWidth(true);\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(ExcelInputMeta in)\n\t{\n\t\tstepname = wStepname.getText(); // return value\n\n\t\t// copy info to Meta class (input)\n\t\tin.setRowLimit( Const.toLong(wLimit.getText(), 0) );\n\t\tin.setFileField( wInclFilenameField.getText() );\n\t\tin.setSheetField( wInclSheetnameField.getText() );\n\t\tin.setRowNumberField( wInclRownumField.getText() );\n\t\t\n\t\tin.setStartsWithHeader( wHeader.getSelection() );\n\t\tin.setIgnoreEmptyRows( wNoempty.getSelection() );\n\t\tin.setStopOnEmpty( wStoponempty.getSelection() );\n\n\t\tint nrfiles    = wFilenameList.nrNonEmpty();\n\t\tint nrsheets   = wSheetnameList.nrNonEmpty();\n\t\tint nrfields   = wFields.nrNonEmpty();\n\t\t\n\t\tin.allocate(nrfiles, nrsheets, nrfields);\n\n\t\tfor (int i=0;i<nrfiles;i++)\n\t\t{\n\t\t\tTableItem item = wFilenameList.getNonEmpty(i);\n\t\t\tin.getFileName()[i] = item.getText(1);\n\t\t\tin.getFileMask()[i] = item.getText(2);\n\t\t\tin.getFileRequired()[i] = item.getText(3);\n\t\t}\n\n\t\tfor (int i=0;i<nrsheets;i++)\n\t\t{\n\t\t\tTableItem item = wSheetnameList.getNonEmpty(i);\n\t\t\tin.getSheetName()[i] = item.getText(1);\n\t\t\tin.getStartRow()[i]  = Const.toInt(item.getText(2),0);\n\t\t\tin.getStartColumn()[i]  = Const.toInt(item.getText(3),0);\n\t\t}\n\n\t\tfor (int i=0;i<nrfields;i++)\n\t\t{\n\t\t\tTableItem item  = wFields.getNonEmpty(i);\n\t\t\tin.getFieldName()[i]     = item.getText(1);\n\t\t\tin.getFieldType()[i]     = Value.getType(item.getText(2));\n\t\t\tString slength  = item.getText(3);\n\t\t\tString sprec    = item.getText(4);\n\t\t\tin.getFieldTrimType()[i]  = ExcelInputMeta.getTrimTypeByDesc(item.getText(5));\n\t\t\tin.getFieldRepeat()[i]    = Messages.getString(\"System.Combo.Yes\").equalsIgnoreCase(item.getText(6));\t\t\n\n\t\t\tin.getFieldLength()[i]    = Const.toInt(slength, -1);\n\t\t\tin.getFieldPrecision()[i] = Const.toInt(sprec, -1);\n\t\t}\t\n\t\t\n\t\t// Error handling fields...\n\t\tin.setStrictTypes( wStrictTypes.getSelection() );\n        in.setErrorIgnored( wErrorIgnored.getSelection() );\n        in.setErrorLineSkipped( wSkipErrorLines.getSelection() );\n        \n        in.setWarningFilesDestinationDirectory( wWarningDestDir.getText() );\n        in.setBadLineFilesExtension( wWarningExt.getText() );\n        in.setErrorFilesDestinationDirectory( wErrorDestDir.getText() );\n        in.setErrorFilesExtension( wErrorExt.getText() );\n        in.setLineNumberFilesDestinationDirectory( wLineNrDestDir.getText() );\n        in.setLineNumberFilesExtension( wLineNrExt.getText() );\n\t\t\n\t}","id":72706,"modified_method":"private void getInfo(ExcelInputMeta in)\n\t{\n\t\tstepname = wStepname.getText(); // return value\n\n\t\t// copy info to Meta class (input)\n\t\tin.setRowLimit( Const.toLong(wLimit.getText(), 0) );\n\t\tin.setFileField( wInclFilenameField.getText() );\n\t\tin.setSheetField( wInclSheetnameField.getText() );\n\t\tin.setRowNumberField( wInclRownumField.getText() );\n\t\t\n\t\tin.setStartsWithHeader( wHeader.getSelection() );\n\t\tin.setIgnoreEmptyRows( wNoempty.getSelection() );\n\t\tin.setStopOnEmpty( wStoponempty.getSelection() );\n\n\t\tint nrfiles    = wFilenameList.nrNonEmpty();\n\t\tint nrsheets   = wSheetnameList.nrNonEmpty();\n\t\tint nrfields   = wFields.nrNonEmpty();\n\t\t\n\t\tin.allocate(nrfiles, nrsheets, nrfields);\n\n\t\tfor (int i=0;i<nrfiles;i++)\n\t\t{\n\t\t\tTableItem item = wFilenameList.getNonEmpty(i);\n\t\t\tin.getFileName()[i] = item.getText(1);\n\t\t\tin.getFileMask()[i] = item.getText(2);\n\t\t\tin.getFileRequired()[i] = item.getText(3);\n\t\t}\n\n\t\tfor (int i=0;i<nrsheets;i++)\n\t\t{\n\t\t\tTableItem item = wSheetnameList.getNonEmpty(i);\n\t\t\tin.getSheetName()[i] = item.getText(1);\n\t\t\tin.getStartRow()[i]  = Const.toInt(item.getText(2),0);\n\t\t\tin.getStartColumn()[i]  = Const.toInt(item.getText(3),0);\n\t\t}\n\n\t\tfor (int i=0;i<nrfields;i++)\n\t\t{\n\t\t\tTableItem item  = wFields.getNonEmpty(i);\n\t\t\tin.getField()[i].setName( item.getText(1) );\n\t\t\tin.getField()[i].setType( Value.getType(item.getText(2)) );\n\t\t\tString slength  = item.getText(3);\n\t\t\tString sprec    = item.getText(4);\n\t\t\tin.getField()[i].setTrimType( ExcelInputMeta.getTrimTypeByDesc(item.getText(5)) );\n\t\t\tin.getField()[i].setRepeated( Messages.getString(\"System.Combo.Yes\").equalsIgnoreCase(item.getText(6)) );\t\t\n\n\t\t\tin.getField()[i].setLength( Const.toInt(slength, -1) );\n\t\t\tin.getField()[i].setPrecision( Const.toInt(sprec, -1) );\n\t\t}\t\n\t\t\n\t\t// Error handling fields...\n\t\tin.setStrictTypes( wStrictTypes.getSelection() );\n        in.setErrorIgnored( wErrorIgnored.getSelection() );\n        in.setErrorLineSkipped( wSkipErrorLines.getSelection() );\n        \n        in.setWarningFilesDestinationDirectory( wWarningDestDir.getText() );\n        in.setBadLineFilesExtension( wWarningExt.getText() );\n        in.setErrorFilesDestinationDirectory( wErrorDestDir.getText() );\n        in.setErrorFilesExtension( wErrorExt.getText() );\n        in.setLineNumberFilesDestinationDirectory( wLineNrDestDir.getText() );\n        in.setLineNumberFilesExtension( wLineNrExt.getText() );\n\t\t\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\n\t{\n\t\tstartsWithHeader     = true;\n\t\tignoreEmptyRows    = true;\n\t\trowNumberField = \"\";\n\t\t\n\t\tint nrfiles=0;\n\t\tint nrfields=0;\n\t\tint nrsheets=0;\n\n\t\tallocate(nrfiles, nrsheets, nrfields);\t\n\t\t\n\t\tfor (int i=0;i<nrfiles;i++) \n\t\t{\n\t\t\tfileName[i]=\"filename\"+(i+1);\n\t\t\tfileMask[i]=\"\";\n\t\t\tfileRequired[i] = NO;\n\t\t}\n\t\t\n\t\tfor (int i=0;i<nrfields;i++)\n\t\t{\n\t\t\tfieldName[i]      = \"field\"+i;\t\t\t\t\n\t\t\tfieldType[i]      = Value.VALUE_TYPE_NUMBER;\n\t\t\tfieldLength[i]    = 9;\n\t\t\tfieldPrecision[i] = 2;\n\t\t\tfieldTrimType[i]   = TYPE_TRIM_NONE;\n\t\t\tfieldRepeat[i]      = false;\n\t\t}\n\t\t\t\n\t\trowLimit=0L;\n\t\t\n\t\tstrictTypes = false;\n\t\terrorIgnored = false;\n\t\terrorLineSkipped = false;\n\t\twarningFilesDestinationDirectory = null;\n        warningFilesExtension = \"warning\";\n        errorFilesDestinationDirectory = null;\n        errorFilesExtension = \"error\";\n        lineNumberFilesDestinationDirectory = null;\n        lineNumberFilesExtension = \"line\";\n\t}","id":72707,"modified_method":"public void setDefault()\n\t{\n\t\tstartsWithHeader     = true;\n\t\tignoreEmptyRows    = true;\n\t\trowNumberField = \"\";\n\t\t\n\t\tint nrfiles=0;\n\t\tint nrfields=0;\n\t\tint nrsheets=0;\n\n\t\tallocate(nrfiles, nrsheets, nrfields);\t\n\t\t\n\t\tfor (int i=0;i<nrfiles;i++) \n\t\t{\n\t\t\tfileName[i]=\"filename\"+(i+1);\n\t\t\tfileMask[i]=\"\";\n\t\t\tfileRequired[i] = NO;\n\t\t}\n\t\t\n\t\tfor (int i=0;i<nrfields;i++)\n\t\t{\n\t\t\tfield[i] = new ExcelInputField();\n\t\t\tfield[i].setName( \"field\"+i );\t\t\t\t\n\t\t\tfield[i].setType( Value.VALUE_TYPE_NUMBER );\n\t\t\tfield[i].setLength( 9 );\n\t\t\tfield[i].setPrecision( 2 );\n\t\t\tfield[i].setTrimType( TYPE_TRIM_NONE );\n\t\t\tfield[i].setRepeated( false );\n\t\t}\n\t\t\t\n\t\trowLimit=0L;\n\t\t\n\t\tstrictTypes = false;\n\t\terrorIgnored = false;\n\t\terrorLineSkipped = false;\n\t\twarningFilesDestinationDirectory = null;\n        warningFilesExtension = \"warning\";\n        errorFilesDestinationDirectory = null;\n        errorFilesExtension = \"error\";\n        lineNumberFilesDestinationDirectory = null;\n        lineNumberFilesExtension = \"line\";\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer();\n\t\t\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header\",          startsWithHeader));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"noempty\",         ignoreEmptyRows));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"stoponempty\",     stopOnEmpty));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"filefield\",       fileField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"sheetfield\",      sheetField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"rownumfield\",     rowNumberField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"sheetfield\",      sheetField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"filefield\",       fileField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"limit\",           rowLimit));\n\n\t\t/*\n\t\t * Describe the files to read\n\t\t */\n\t\tretval.append(\"    <file>\"+Const.CR);\n\t\tfor (int i=0;i<fileName.length;i++)\n\t\t{\n\t\t\tretval.append(\"      \"+XMLHandler.addTagValue(\"name\",     fileName[i]));\n\t\t\tretval.append(\"      \"+XMLHandler.addTagValue(\"filemask\", fileMask[i]));\n\t\t\tretval.append(\"      \"+XMLHandler.addTagValue(\"file_required\", fileRequired[i]));\n\t\t}\n\t\tretval.append(\"      <\/file>\"+Const.CR);\n\n\t\t/*\n\t\t * Describe the fields to read\n\t\t */\n\t\tretval.append(\"    <fields>\"+Const.CR);\n\t\tfor (int i=0;i<fieldName.length;i++)\n\t\t{\n\t\t\tretval.append(\"      <field>\"+Const.CR);\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"name\",      fieldName[i]));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"type\",      Value.getTypeDesc(fieldType[i])));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"length\",    fieldLength[i]));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"precision\", fieldPrecision[i]));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"trim_type\", getTrimTypeCode( fieldTrimType[i] )));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"repeat\",    fieldRepeat[i]));\n\t\t\tretval.append(\"        <\/field>\"+Const.CR);\n\t\t}\n\t\tretval.append(\"      <\/fields>\"+Const.CR);\n\n\t\t/*\n\t\t * Describe the sheets to load... \n\t\t */\n\t\tretval.append(\"    <sheets>\"+Const.CR);\n\t\tfor (int i=0;i<sheetName.length;i++)\n\t\t{\n\t\t\tretval.append(\"      <sheet>\"+Const.CR);\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"name\",      sheetName[i]));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"startrow\",  startRow[i]));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"startcol\",  startColumn[i]));\n\t\t\tretval.append(\"        <\/sheet>\"+Const.CR);\n\t\t}\n\t\tretval.append(\"      <\/sheets>\"+Const.CR);\n\t\t\n        // ERROR HANDLING\n        retval.append(\"    \" + XMLHandler.addTagValue(\"strict_types\", strictTypes));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"error_ignored\", errorIgnored));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"error_line_skipped\", errorLineSkipped));\n        \n        retval.append(\"    \" + XMLHandler.addTagValue(\"bad_line_files_destination_directory\", warningFilesDestinationDirectory));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"bad_line_files_extension\", warningFilesExtension));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"error_line_files_destination_directory\", errorFilesDestinationDirectory));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"error_line_files_extension\", errorFilesExtension));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"line_number_files_destination_directory\", lineNumberFilesDestinationDirectory));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"line_number_files_extension\", lineNumberFilesExtension));\n\t\t\n\t\treturn retval.toString();\n\t}","id":72708,"modified_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer();\n\t\t\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header\",          startsWithHeader));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"noempty\",         ignoreEmptyRows));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"stoponempty\",     stopOnEmpty));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"filefield\",       fileField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"sheetfield\",      sheetField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"rownumfield\",     rowNumberField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"sheetfield\",      sheetField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"filefield\",       fileField));\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"limit\",           rowLimit));\n\n\t\t/*\n\t\t * Describe the files to read\n\t\t */\n\t\tretval.append(\"    <file>\"+Const.CR);\n\t\tfor (int i=0;i<fileName.length;i++)\n\t\t{\n\t\t\tretval.append(\"      \"+XMLHandler.addTagValue(\"name\",     fileName[i]));\n\t\t\tretval.append(\"      \"+XMLHandler.addTagValue(\"filemask\", fileMask[i]));\n\t\t\tretval.append(\"      \"+XMLHandler.addTagValue(\"file_required\", fileRequired[i]));\n\t\t}\n\t\tretval.append(\"      <\/file>\"+Const.CR);\n\n\t\t/*\n\t\t * Describe the fields to read\n\t\t */\n\t\tretval.append(\"    <fields>\"+Const.CR);\n\t\tfor (int i=0;i<field.length;i++)\n\t\t{\n\t\t\tretval.append(\"      <field>\"+Const.CR);\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"name\",      field[i].getName()) );\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"type\",      field[i].getTypeDesc()) );\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"length\",    field[i].getLength()) );\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"precision\", field[i].getPrecision()));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"trim_type\", field[i].getTrimTypeCode() ) );\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"repeat\",    field[i].isRepeated()) );\n\t\t\tretval.append(\"        <\/field>\"+Const.CR);\n\t\t}\n\t\tretval.append(\"      <\/fields>\"+Const.CR);\n\n\t\t/*\n\t\t * Describe the sheets to load... \n\t\t */\n\t\tretval.append(\"    <sheets>\"+Const.CR);\n\t\tfor (int i=0;i<sheetName.length;i++)\n\t\t{\n\t\t\tretval.append(\"      <sheet>\"+Const.CR);\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"name\",      sheetName[i]));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"startrow\",  startRow[i]));\n\t\t\tretval.append(\"        \"+XMLHandler.addTagValue(\"startcol\",  startColumn[i]));\n\t\t\tretval.append(\"        <\/sheet>\"+Const.CR);\n\t\t}\n\t\tretval.append(\"      <\/sheets>\"+Const.CR);\n\t\t\n        // ERROR HANDLING\n        retval.append(\"    \" + XMLHandler.addTagValue(\"strict_types\", strictTypes));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"error_ignored\", errorIgnored));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"error_line_skipped\", errorLineSkipped));\n        \n        retval.append(\"    \" + XMLHandler.addTagValue(\"bad_line_files_destination_directory\", warningFilesDestinationDirectory));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"bad_line_files_extension\", warningFilesExtension));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"error_line_files_destination_directory\", errorFilesDestinationDirectory));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"error_line_files_extension\", errorFilesExtension));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"line_number_files_destination_directory\", lineNumberFilesDestinationDirectory));\n        retval.append(\"    \" + XMLHandler.addTagValue(\"line_number_files_extension\", lineNumberFilesExtension));\n\t\t\n\t\treturn retval.toString();\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void allocate(int nrfiles, int nrsheets, int nrfields)\n\t{\n\t\tfileName   = new String [nrfiles];\n\t\tfileMask   = new String [nrfiles];\n\t\tfileRequired = new String[nrfiles];\n\t\t\n\t\tsheetName  = new String [nrsheets];\n\t\tstartRow   = new int    [nrsheets];\n\t\tstartColumn   = new int    [nrsheets];\n\t\t\n\t\tfieldName      = new String [nrfields];\n\t\tfieldType      = new int    [nrfields];\n\t\tfieldLength     = new int    [nrfields];\n\t\tfieldPrecision  = new int    [nrfields];\n\t\tfieldTrimType  = new int    [nrfields];\n\t\tfieldRepeat     = new boolean[nrfields];\n\t}","id":72709,"modified_method":"public void allocate(int nrfiles, int nrsheets, int nrfields)\n\t{\n\t\tfileName   = new String [nrfiles];\n\t\tfileMask   = new String [nrfiles];\n\t\tfileRequired = new String[nrfiles];\n\t\t\n\t\tsheetName  = new String [nrsheets];\n\t\tstartRow   = new int    [nrsheets];\n\t\tstartColumn   = new int    [nrsheets];\n\t\t\n\t\tfield = new ExcelInputField[nrfields];\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Row getEmptyFields()\n\t{\n\t\tRow row = new Row();\n\t\tfor (int i=0;i<fieldName.length;i++)\n\t\t{\n\t\t\tValue v = new Value(fieldName[i], fieldType[i]);\n\t\t\trow.addValue(v);\n\t\t}\n\t\t\n\t\treturn row;\n\t}","id":72710,"modified_method":"public Row getEmptyFields()\n\t{\n\t\tRow row = new Row();\n\t\tfor (int i=0;i<field.length;i++)\n\t\t{\n\t\t\tValue v = new Value(field[i].getName(), field[i].getType());\n\t\t\trow.addValue(v);\n\t\t}\n\t\t\n\t\treturn row;\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * @return Returns the fieldName.\n     */\n    public String[] getFieldName()\n    {\n        return fieldName;\n    }","id":72711,"modified_method":"/**\n     * @return Returns the fieldLength.\n     */\n    public ExcelInputField[] getField()\n    {\n        return field;\n    }","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tstartsWithHeader          = YES.equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\n\t\t\tString nempty   = XMLHandler.getTagValue(stepnode, \"noempty\");\n\t\t\tignoreEmptyRows         = YES.equalsIgnoreCase(nempty) || nempty==null;\n\t\t\tString soempty  = XMLHandler.getTagValue(stepnode, \"stoponempty\");\n\t\t\tstopOnEmpty     = YES.equalsIgnoreCase(soempty) || nempty==null;\n\t\t\trowNumberField    = XMLHandler.getTagValue(stepnode, \"rownum_field\");\n\t\t\trowNumberField    = XMLHandler.getTagValue(stepnode, \"rownumfield\");\n\t\t\trowLimit           = Const.toLong(XMLHandler.getTagValue(stepnode, \"limit\"), 0);\n\t\t\tsheetField      = XMLHandler.getTagValue(stepnode, \"sheetfield\");\n\t\t\tfileField       = XMLHandler.getTagValue(stepnode, \"filefield\");\n\t\t\t\t\t\n\t\t\tNode filenode   = XMLHandler.getSubNode(stepnode, \"file\");\n\t\t\tNode sheetsnode = XMLHandler.getSubNode(stepnode, \"sheets\");\n\t\t\tNode fields     = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tint nrfiles   = XMLHandler.countNodes(filenode,   \"name\");\n\t\t\tint nrsheets  = XMLHandler.countNodes(sheetsnode, \"sheet\");\n\t\t\tint nrfields  = XMLHandler.countNodes(fields,     \"field\");\n\t\n\t\t\tallocate(nrfiles, nrsheets, nrfields);\t\t\n\t\n\t\t\tfor (int i=0;i<nrfiles;i++)\n\t\t\t{\n\t\t\t\tNode filenamenode = XMLHandler.getSubNodeByNr(filenode, \"name\", i); \n\t\t\t\tNode filemasknode = XMLHandler.getSubNodeByNr(filenode, \"filemask\", i); \n\t\t\t\tNode fileRequirednode = XMLHandler.getSubNodeByNr(filenode, \"file_required\", i);\n\t\t\t\tfileName[i] = XMLHandler.getNodeValue(filenamenode);\n\t\t\t\tfileMask[i] = XMLHandler.getNodeValue(filemasknode);\n\t\t\t\tfileRequired[i] = XMLHandler.getNodeValue(fileRequirednode);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\t\t\t\t\n\t\t\t\tfieldName[i]        = XMLHandler.getTagValue(fnode, \"name\");\n\t\t\t\tfieldType[i]        = Value.getType(XMLHandler.getTagValue(fnode, \"type\"));\n\t\t\t\tfieldLength[i]      = Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1);\n\t\t\t\tfieldPrecision[i]   = Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1);\n\t\t\t\tString srepeat      = XMLHandler.getTagValue(fnode, \"repeat\");\n\t\t\t\tfieldTrimType[i]    = getTrimTypeByCode(XMLHandler.getTagValue(fnode, \"trim_type\"));\n\t\t\t\t\n\t\t\t\tif (srepeat!=null) fieldRepeat[i] = YES.equalsIgnoreCase(srepeat); \n\t\t\t\telse               fieldRepeat[i]=false;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<nrsheets;i++)\n\t\t\t{\n\t\t\t\tNode snode = XMLHandler.getSubNodeByNr(sheetsnode, \"sheet\", i);\n\t\t\t\t\n\t\t\t\tsheetName[i] = XMLHandler.getTagValue(snode, \"name\");\n\t\t\t\tstartRow[i]  = Const.toInt(XMLHandler.getTagValue(snode, \"startrow\"), 0);\n\t\t\t\tstartColumn[i]  = Const.toInt(XMLHandler.getTagValue(snode, \"startcol\"), 0);\n\t\t\t}\n\t\t\t\n            strictTypes = YES.equalsIgnoreCase( XMLHandler.getTagValue(stepnode, \"strict_types\") );\n            errorIgnored = YES.equalsIgnoreCase( XMLHandler.getTagValue(stepnode, \"error_ignored\") );\n            errorLineSkipped = YES.equalsIgnoreCase( XMLHandler.getTagValue(stepnode, \"error_line_skipped\") );\n            warningFilesDestinationDirectory = XMLHandler.getTagValue(stepnode, \"bad_line_files_destination_directory\");\n            warningFilesExtension = XMLHandler.getTagValue(stepnode, \"bad_line_files_extension\");\n            errorFilesDestinationDirectory = XMLHandler.getTagValue(stepnode, \"error_line_files_destination_directory\");\n            errorFilesExtension = XMLHandler.getTagValue(stepnode, \"error_line_files_extension\");\n            lineNumberFilesDestinationDirectory = XMLHandler.getTagValue(stepnode, \"line_number_files_destination_directory\");\n            lineNumberFilesExtension = XMLHandler.getTagValue(stepnode, \"line_number_files_extension\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to read step information from XML\", e);\n\t\t}\n\t}","id":72712,"modified_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tstartsWithHeader          = YES.equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\n\t\t\tString nempty   = XMLHandler.getTagValue(stepnode, \"noempty\");\n\t\t\tignoreEmptyRows         = YES.equalsIgnoreCase(nempty) || nempty==null;\n\t\t\tString soempty  = XMLHandler.getTagValue(stepnode, \"stoponempty\");\n\t\t\tstopOnEmpty     = YES.equalsIgnoreCase(soempty) || nempty==null;\n\t\t\trowNumberField    = XMLHandler.getTagValue(stepnode, \"rownum_field\");\n\t\t\trowNumberField    = XMLHandler.getTagValue(stepnode, \"rownumfield\");\n\t\t\trowLimit           = Const.toLong(XMLHandler.getTagValue(stepnode, \"limit\"), 0);\n\t\t\tsheetField      = XMLHandler.getTagValue(stepnode, \"sheetfield\");\n\t\t\tfileField       = XMLHandler.getTagValue(stepnode, \"filefield\");\n\t\t\t\t\t\n\t\t\tNode filenode   = XMLHandler.getSubNode(stepnode, \"file\");\n\t\t\tNode sheetsnode = XMLHandler.getSubNode(stepnode, \"sheets\");\n\t\t\tNode fields     = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tint nrfiles   = XMLHandler.countNodes(filenode,   \"name\");\n\t\t\tint nrsheets  = XMLHandler.countNodes(sheetsnode, \"sheet\");\n\t\t\tint nrfields  = XMLHandler.countNodes(fields,     \"field\");\n\t\n\t\t\tallocate(nrfiles, nrsheets, nrfields);\t\t\n\t\n\t\t\tfor (int i=0;i<nrfiles;i++)\n\t\t\t{\n\t\t\t\tNode filenamenode = XMLHandler.getSubNodeByNr(filenode, \"name\", i); \n\t\t\t\tNode filemasknode = XMLHandler.getSubNodeByNr(filenode, \"filemask\", i); \n\t\t\t\tNode fileRequirednode = XMLHandler.getSubNodeByNr(filenode, \"file_required\", i);\n\t\t\t\tfileName[i] = XMLHandler.getNodeValue(filenamenode);\n\t\t\t\tfileMask[i] = XMLHandler.getNodeValue(filemasknode);\n\t\t\t\tfileRequired[i] = XMLHandler.getNodeValue(fileRequirednode);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\t\t\t\t\n\t\t\t\tfield[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\n\t\t\t\tfield[i].setType( Value.getType(XMLHandler.getTagValue(fnode, \"type\")) );\n\t\t\t\tfield[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\n\t\t\t\tfield[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\n\t\t\t\tString srepeat      = XMLHandler.getTagValue(fnode, \"repeat\");\n\t\t\t\tfield[i].setTrimType( getTrimTypeByCode(XMLHandler.getTagValue(fnode, \"trim_type\")) );\n\t\t\t\t\n\t\t\t\tif (srepeat!=null) field[i].setRepeated( YES.equalsIgnoreCase(srepeat) ); \n\t\t\t\telse               field[i].setRepeated( false );\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<nrsheets;i++)\n\t\t\t{\n\t\t\t\tNode snode = XMLHandler.getSubNodeByNr(sheetsnode, \"sheet\", i);\n\t\t\t\t\n\t\t\t\tsheetName[i] = XMLHandler.getTagValue(snode, \"name\");\n\t\t\t\tstartRow[i]  = Const.toInt(XMLHandler.getTagValue(snode, \"startrow\"), 0);\n\t\t\t\tstartColumn[i]  = Const.toInt(XMLHandler.getTagValue(snode, \"startcol\"), 0);\n\t\t\t}\n\t\t\t\n            strictTypes = YES.equalsIgnoreCase( XMLHandler.getTagValue(stepnode, \"strict_types\") );\n            errorIgnored = YES.equalsIgnoreCase( XMLHandler.getTagValue(stepnode, \"error_ignored\") );\n            errorLineSkipped = YES.equalsIgnoreCase( XMLHandler.getTagValue(stepnode, \"error_line_skipped\") );\n            warningFilesDestinationDirectory = XMLHandler.getTagValue(stepnode, \"bad_line_files_destination_directory\");\n            warningFilesExtension = XMLHandler.getTagValue(stepnode, \"bad_line_files_extension\");\n            errorFilesDestinationDirectory = XMLHandler.getTagValue(stepnode, \"error_line_files_destination_directory\");\n            errorFilesExtension = XMLHandler.getTagValue(stepnode, \"error_line_files_extension\");\n            lineNumberFilesDestinationDirectory = XMLHandler.getTagValue(stepnode, \"line_number_files_destination_directory\");\n            lineNumberFilesExtension = XMLHandler.getTagValue(stepnode, \"line_number_files_extension\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to read step information from XML\", e);\n\t\t}\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Object clone()\n\t{\n\t\tExcelInputMeta retval = (ExcelInputMeta)super.clone();\n\t\t\n\t\tint nrfiles  = fileName.length;\n\t\tint nrsheets = sheetName.length;\n\t\tint nrfields = fieldName.length;\n\n\t\tretval.allocate(nrfiles, nrsheets, nrfields);\n\t\t\n\t\tfor (int i=0;i<nrfields;i++)\n\t\t{\n\t\t\tretval.fieldName[i]     = fieldName[i];\n\t\t\tretval.fieldType[i]     = fieldType[i];\n\t\t\tretval.fieldLength[i]    = fieldLength[i];\n\t\t\tretval.fieldPrecision[i] = fieldPrecision[i];\n\t\t\tretval.fieldTrimType[i] = fieldTrimType[i];\n\t\t\tretval.fieldRepeat[i]    = fieldRepeat[i];\n\t\t}\n\t\t\n\t\tfor (int i=0;i<nrfiles;i++)\n\t\t{\n\t\t\tretval.fileName[i] = fileName[i];\n\t\t\tretval.fileMask[i] = fileMask[i];\n\t\t}\n\t\t\n\t\tfor (int i=0;i<nrsheets;i++)\n\t\t{\n\t\t\tretval.sheetName[i] = sheetName[i];\n\t\t}\n\t\t\n\t\treturn retval;\n\t}","id":72713,"modified_method":"public Object clone()\n\t{\n\t\tExcelInputMeta retval = (ExcelInputMeta)super.clone();\n\t\t\n\t\tint nrfiles  = fileName.length;\n\t\tint nrsheets = sheetName.length;\n\t\tint nrfields = field.length;\n\n\t\tretval.allocate(nrfiles, nrsheets, nrfields);\n\t\t\n\t\tfor (int i=0;i<nrfields;i++)\n\t\t{\n\t\t\tretval.field[i] = (ExcelInputField) field[i].clone();\n\t\t}\n\t\t\n\t\tfor (int i=0;i<nrfiles;i++)\n\t\t{\n\t\t\tretval.fileName[i] = fileName[i];\n\t\t\tretval.fileMask[i] = fileMask[i];\n\t\t}\n\t\t\n\t\tfor (int i=0;i<nrsheets;i++)\n\t\t{\n\t\t\tretval.sheetName[i] = sheetName[i];\n\t\t}\n\t\t\n\t\treturn retval;\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Row getFields(Row r, String name, Row info)\n\t{\n\t\tRow row;\n\t\tif (r==null) row=new Row(); // give back values\n\t\telse         row=r;         // add to the existing row of values...\n\t\t\n\t\tint i;\n\t\tfor (i=0;i<fieldName.length;i++)\n\t\t{\n\t\t\tint type=fieldType[i];\n\t\t\tif (type==Value.VALUE_TYPE_NONE) type=Value.VALUE_TYPE_STRING;\n\t\t\tValue v=new Value(fieldName[i], type);\n\t\t\tv.setLength(fieldLength[i], fieldPrecision[i]);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValue(v);\n\t\t}\n\t\tif (fileField!=null && fileField.length()>0)\n\t\t{\n\t\t\tValue v = new Value(fileField, Value.VALUE_TYPE_STRING);\n\t\t\tv.setLength(250, -1);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValue(v);\n\t\t}\n\t\tif (sheetField!=null && sheetField.length()>0)\n\t\t{\n\t\t\tValue v = new Value(sheetField, Value.VALUE_TYPE_STRING);\n\t\t\tv.setLength(250, -1);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValue(v);\n\t\t}\n\t\tif (rowNumberField!=null && rowNumberField.length()>0)\n\t\t{\n\t\t\tValue v = new Value(rowNumberField, Value.VALUE_TYPE_NUMBER);\n\t\t\tv.setLength(7, 0);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValue(v);\n\t\t}\n\t\treturn row;\n\t}","id":72714,"modified_method":"public Row getFields(Row r, String name, Row info)\n\t{\n\t\tRow row;\n\t\tif (r==null) row=new Row(); // give back values\n\t\telse         row=r;         // add to the existing row of values...\n\t\t\n\t\tint i;\n\t\tfor (i=0;i<field.length;i++)\n\t\t{\n\t\t\tint type=field[i].getType();\n\t\t\tif (type==Value.VALUE_TYPE_NONE) type=Value.VALUE_TYPE_STRING;\n\t\t\tValue v=new Value(field[i].getName(), type);\n\t\t\tv.setLength(field[i].getLength(), field[i].getPrecision());\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValue(v);\n\t\t}\n\t\tif (fileField!=null && fileField.length()>0)\n\t\t{\n\t\t\tValue v = new Value(fileField, Value.VALUE_TYPE_STRING);\n\t\t\tv.setLength(250, -1);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValue(v);\n\t\t}\n\t\tif (sheetField!=null && sheetField.length()>0)\n\t\t{\n\t\t\tValue v = new Value(sheetField, Value.VALUE_TYPE_STRING);\n\t\t\tv.setLength(250, -1);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValue(v);\n\t\t}\n\t\tif (rowNumberField!=null && rowNumberField.length()>0)\n\t\t{\n\t\t\tValue v = new Value(rowNumberField, Value.VALUE_TYPE_NUMBER);\n\t\t\tv.setLength(7, 0);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValue(v);\n\t\t}\n\t\treturn row;\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tstartsWithHeader  =      rep.getStepAttributeBoolean(id_step, \"header\");\n\t\t\tignoreEmptyRows   =      rep.getStepAttributeBoolean(id_step, \"noempty\");  \n\t\t\tstopOnEmpty       =      rep.getStepAttributeBoolean(id_step, \"stoponempty\");  \n\t\t\tfileField         =      rep.getStepAttributeString (id_step, \"filefield\");\n\t\t\tsheetField        =      rep.getStepAttributeString (id_step, \"sheetfield\");\n\t\t\trowNumberField    =      rep.getStepAttributeString (id_step, \"rownumfield\");\n\t\t\trowLimit          = (int)rep.getStepAttributeInteger(id_step, \"limit\");\n\t\n\t\t\tint nrfiles     = rep.countNrStepAttributes(id_step, \"file_name\");\n\t\t\tint nrsheets    = rep.countNrStepAttributes(id_step, \"sheet_name\");\n\t\t\tint nrfields    = rep.countNrStepAttributes(id_step, \"field_name\");\n\t\t\t\n\t\t\tallocate(nrfiles, nrsheets, nrfields);\n\n            // System.out.println(\"Counted \"+nrfiles+\" files to read and \"+nrsheets+\" sheets, \"+nrfields+\" fields.\");\n\t\t\tfor (int i=0;i<nrfiles;i++)\n\t\t\t{\n\t\t\t\tfileName[i] =      rep.getStepAttributeString (id_step, i, \"file_name\"    );\n\t\t\t\tfileMask[i] =      rep.getStepAttributeString (id_step, i, \"file_mask\"    );\n\t\t\t\tfileRequired[i] = rep.getStepAttributeString(id_step, i, \"file_required\");\n                if(!YES.equalsIgnoreCase(fileRequired[i]))\n                \tfileRequired[i] = NO;\n\t\t\t}\n\n\t\t\tfor (int i=0;i<nrsheets;i++)\n\t\t\t{\n\t\t\t\tsheetName[i] =      rep.getStepAttributeString (id_step, i, \"sheet_name\"      );\n\t\t\t\tstartRow[i]  = (int)rep.getStepAttributeInteger(id_step, i, \"sheet_startrow\"  );\n\t\t\t\tstartColumn[i]  = (int)rep.getStepAttributeInteger(id_step, i, \"sheet_startcol\"  );\n\t\t\t}\n\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tfieldName[i]     =                rep.getStepAttributeString (id_step, i, \"field_name\");\n\t\t\t\tfieldType[i]     = Value.getType( rep.getStepAttributeString (id_step, i, \"field_type\") );\n\t\t\t\tfieldLength[i]    = (int)          rep.getStepAttributeInteger(id_step, i, \"field_length\");\n\t\t\t\tfieldPrecision[i] = (int)          rep.getStepAttributeInteger(id_step, i, \"field_precision\");\n\t\t\t\tfieldTrimType[i] = getTrimTypeByCode(   rep.getStepAttributeString (id_step, i, \"field_trim_type\") );\n\t\t\t\tfieldRepeat[i]    =                rep.getStepAttributeBoolean(id_step, i, \"field_repeat\");\n\t\t\t}\t\t\n\t\t\t\n            strictTypes = rep.getStepAttributeBoolean(id_step, 0, \"strict_types\", false);\n\t\t\terrorIgnored = rep.getStepAttributeBoolean(id_step, 0, \"error_ignored\", false);\n            errorLineSkipped = rep.getStepAttributeBoolean(id_step, 0, \"error_line_skipped\", false);\n            \n            warningFilesDestinationDirectory = rep.getStepAttributeString(id_step, \"bad_line_files_dest_dir\");\n            warningFilesExtension = rep.getStepAttributeString(id_step, \"bad_line_files_ext\");\n            errorFilesDestinationDirectory = rep.getStepAttributeString(id_step, \"error_line_files_dest_dir\");\n            errorFilesExtension = rep.getStepAttributeString(id_step, \"error_line_files_ext\");\n            lineNumberFilesDestinationDirectory = rep.getStepAttributeString(id_step, \"line_number_files_dest_dir\");\n            lineNumberFilesExtension = rep.getStepAttributeString(id_step, \"line_number_files_ext\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":72715,"modified_method":"public void readRep(Repository rep, long id_step, ArrayList databases, Hashtable counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tstartsWithHeader  =      rep.getStepAttributeBoolean(id_step, \"header\");\n\t\t\tignoreEmptyRows   =      rep.getStepAttributeBoolean(id_step, \"noempty\");  \n\t\t\tstopOnEmpty       =      rep.getStepAttributeBoolean(id_step, \"stoponempty\");  \n\t\t\tfileField         =      rep.getStepAttributeString (id_step, \"filefield\");\n\t\t\tsheetField        =      rep.getStepAttributeString (id_step, \"sheetfield\");\n\t\t\trowNumberField    =      rep.getStepAttributeString (id_step, \"rownumfield\");\n\t\t\trowLimit          = (int)rep.getStepAttributeInteger(id_step, \"limit\");\n\t\n\t\t\tint nrfiles     = rep.countNrStepAttributes(id_step, \"file_name\");\n\t\t\tint nrsheets    = rep.countNrStepAttributes(id_step, \"sheet_name\");\n\t\t\tint nrfields    = rep.countNrStepAttributes(id_step, \"field_name\");\n\t\t\t\n\t\t\tallocate(nrfiles, nrsheets, nrfields);\n\n            // System.out.println(\"Counted \"+nrfiles+\" files to read and \"+nrsheets+\" sheets, \"+nrfields+\" fields.\");\n\t\t\tfor (int i=0;i<nrfiles;i++)\n\t\t\t{\n\t\t\t\tfileName[i] =      rep.getStepAttributeString (id_step, i, \"file_name\"    );\n\t\t\t\tfileMask[i] =      rep.getStepAttributeString (id_step, i, \"file_mask\"    );\n\t\t\t\tfileRequired[i] = rep.getStepAttributeString(id_step, i, \"file_required\");\n                if(!YES.equalsIgnoreCase(fileRequired[i]))\n                \tfileRequired[i] = NO;\n\t\t\t}\n\n\t\t\tfor (int i=0;i<nrsheets;i++)\n\t\t\t{\n\t\t\t\tsheetName[i] =      rep.getStepAttributeString (id_step, i, \"sheet_name\"      );\n\t\t\t\tstartRow[i]  = (int)rep.getStepAttributeInteger(id_step, i, \"sheet_startrow\"  );\n\t\t\t\tstartColumn[i]  = (int)rep.getStepAttributeInteger(id_step, i, \"sheet_startcol\"  );\n\t\t\t}\n\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tfield[i].setName( rep.getStepAttributeString (id_step, i, \"field_name\") );\n\t\t\t\tfield[i].setType( Value.getType( rep.getStepAttributeString (id_step, i, \"field_type\") ) );\n\t\t\t\tfield[i].setLength( (int)rep.getStepAttributeInteger(id_step, i, \"field_length\") );\n\t\t\t\tfield[i].setPrecision( (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\n\t\t\t\tfield[i].setTrimType( getTrimTypeByCode(   rep.getStepAttributeString (id_step, i, \"field_trim_type\") ) );\n\t\t\t\tfield[i].setRepeated( rep.getStepAttributeBoolean(id_step, i, \"field_repeat\") );\n\t\t\t}\t\t\n\t\t\t\n            strictTypes = rep.getStepAttributeBoolean(id_step, 0, \"strict_types\", false);\n\t\t\terrorIgnored = rep.getStepAttributeBoolean(id_step, 0, \"error_ignored\", false);\n            errorLineSkipped = rep.getStepAttributeBoolean(id_step, 0, \"error_line_skipped\", false);\n            \n            warningFilesDestinationDirectory = rep.getStepAttributeString(id_step, \"bad_line_files_dest_dir\");\n            warningFilesExtension = rep.getStepAttributeString(id_step, \"bad_line_files_ext\");\n            errorFilesDestinationDirectory = rep.getStepAttributeString(id_step, \"error_line_files_dest_dir\");\n            errorFilesExtension = rep.getStepAttributeString(id_step, \"error_line_files_ext\");\n            lineNumberFilesDestinationDirectory = rep.getStepAttributeString(id_step, \"line_number_files_dest_dir\");\n            lineNumberFilesExtension = rep.getStepAttributeString(id_step, \"line_number_files_ext\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\",          startsWithHeader);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"noempty\",         ignoreEmptyRows);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"stoponempty\",     stopOnEmpty);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filefield\",       fileField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"sheetfield\",      sheetField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rownumfield\",     rowNumberField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"limit\",           rowLimit);\n\t\t\t\n\t\t\tfor (int i=0;i<fileName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_name\",     fileName[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_mask\",     fileMask[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_required\", fileRequired[i]);\n\t\t\t}\n\t\n\t\t\tfor (int i=0;i<sheetName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"sheet_name\",      sheetName[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"sheet_startrow\",  startRow[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"sheet_startcol\",  startColumn[i]);\n\t\t\t}\n\t\n\t\t\tfor (int i=0;i<fieldName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      fieldName[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      Value.getTypeDesc(fieldType[i]));\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",    fieldLength[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", fieldPrecision[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", getTrimTypeCode( fieldTrimType[i] ));\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_repeat\",    fieldRepeat[i]);\n\t\t\t}\n\t\t\t\n            rep.saveStepAttribute(id_transformation, id_step, \"strict_types\", strictTypes);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"error_ignored\", errorIgnored);\n            rep.saveStepAttribute(id_transformation, id_step, \"error_line_skipped\", errorLineSkipped);\n            \n            rep.saveStepAttribute(id_transformation, id_step, \"bad_line_files_dest_dir\", warningFilesDestinationDirectory);\n            rep.saveStepAttribute(id_transformation, id_step, \"bad_line_files_ext\", warningFilesExtension);\n            rep.saveStepAttribute(id_transformation, id_step, \"error_line_files_dest_dir\", errorFilesDestinationDirectory);\n            rep.saveStepAttribute(id_transformation, id_step, \"error_line_files_ext\", errorFilesExtension);\n             rep.saveStepAttribute(id_transformation, id_step, \"line_number_files_dest_dir\", lineNumberFilesDestinationDirectory);\n            rep.saveStepAttribute(id_transformation, id_step, \"line_number_files_ext\", lineNumberFilesExtension);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\n\t\t}\n\n\t}","id":72716,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\",          startsWithHeader);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"noempty\",         ignoreEmptyRows);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"stoponempty\",     stopOnEmpty);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filefield\",       fileField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"sheetfield\",      sheetField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rownumfield\",     rowNumberField);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"limit\",           rowLimit);\n\t\t\t\n\t\t\tfor (int i=0;i<fileName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_name\",     fileName[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_mask\",     fileMask[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"file_required\", fileRequired[i]);\n\t\t\t}\n\t\n\t\t\tfor (int i=0;i<sheetName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"sheet_name\",      sheetName[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"sheet_startrow\",  startRow[i]);\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"sheet_startcol\",  startColumn[i]);\n\t\t\t}\n\t\n\t\t\tfor (int i=0;i<field.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field[i].getName() );\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      field[i].getTypeDesc() );\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",    field[i].getLength() );\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field[i].getPrecision() );\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", field[i].getTrimTypeCode() );\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_repeat\",    field[i].isRepeated());\n\t\t\t}\n\t\t\t\n            rep.saveStepAttribute(id_transformation, id_step, \"strict_types\", strictTypes);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"error_ignored\", errorIgnored);\n            rep.saveStepAttribute(id_transformation, id_step, \"error_line_skipped\", errorLineSkipped);\n            \n            rep.saveStepAttribute(id_transformation, id_step, \"bad_line_files_dest_dir\", warningFilesDestinationDirectory);\n            rep.saveStepAttribute(id_transformation, id_step, \"bad_line_files_ext\", warningFilesExtension);\n            rep.saveStepAttribute(id_transformation, id_step, \"error_line_files_dest_dir\", errorFilesDestinationDirectory);\n            rep.saveStepAttribute(id_transformation, id_step, \"error_line_files_ext\", errorFilesExtension);\n             rep.saveStepAttribute(id_transformation, id_step, \"line_number_files_dest_dir\", lineNumberFilesDestinationDirectory);\n            rep.saveStepAttribute(id_transformation, id_step, \"line_number_files_ext\", lineNumberFilesExtension);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\n\t\t}\n\n\t}","commit_id":"7a5085d363648a40ab7842064c657082e2a3b713","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {\n    meta = (IfNullMeta) smi;\n    data = (IfNullData) sdi;\n\n    Object[] r = getRow(); // get row, set busy!\n    if ( r == null ) { // no more input to be expected...\n\n      setOutputDone();\n      return false;\n    }\n\n    if ( first ) {\n      first = false;\n\n      // What's the format of the output row?\n      data.outputRowMeta = getInputRowMeta().clone();\n      meta.getFields( data.outputRowMeta, getStepname(), null, null, this, repository, metaStore );\n      // Create convert meta-data objects that will contain Date & Number formatters\n      data.convertRowMeta = data.outputRowMeta.clone();\n\n      // For String to <type> conversions, we allocate a conversion meta data row as well...\n      //\n      data.convertRowMeta = data.outputRowMeta.cloneToType( ValueMetaInterface.TYPE_STRING );\n\n      if ( meta.isSelectFields() ) {\n        // Consider only selected fields\n        if ( meta.getFieldName() != null && meta.getFieldName().length > 0 ) {\n          data.fieldnrs = new int[meta.getFieldName().length];\n          data.defaultValues = new String[meta.getFieldName().length];\n          data.defaultMasks = new String[meta.getFieldName().length];\n          data.setEmptyString = new boolean[meta.getFieldName().length];\n\n          for ( int i = 0; i < meta.getFieldName().length; i++ ) {\n            data.fieldnrs[i] = data.outputRowMeta.indexOfValue( meta.getFieldName()[i] );\n            if ( data.fieldnrs[i] < 0 ) {\n              logError( BaseMessages.getString( PKG, \"IfNull.Log.CanNotFindField\", meta.getFieldName()[i] ) );\n              throw new KettleException( BaseMessages.getString( PKG, \"IfNull.Log.CanNotFindField\", meta\n                .getFieldName()[i] ) );\n            }\n            data.defaultValues[i] = environmentSubstitute( meta.getReplaceValue()[i] );\n            data.defaultMasks[i] = environmentSubstitute( meta.getReplaceMask()[i] );\n            data.setEmptyString[i] = meta.isSetEmptyString()[i];\n          }\n        } else {\n          throw new KettleException( BaseMessages.getString( PKG, \"IfNull.Log.SelectFieldsEmpty\" ) );\n        }\n      } else if ( meta.isSelectValuesType() ) {\n        // Consider only select value types\n        if ( meta.getTypeName() != null && meta.getTypeName().length > 0 ) {\n          // return the real default values\n          data.defaultValues = new String[meta.getTypeName().length];\n          data.defaultMasks = new String[meta.getTypeName().length];\n          data.setEmptyString = new boolean[meta.getTypeName().length];\n\n          // return all type codes\n          HashSet<String> AlllistTypes = new HashSet<String>();\n          for ( int i = 0; i < ValueMetaInterface.typeCodes.length; i++ ) {\n            AlllistTypes.add( ValueMetaInterface.typeCodes[i] );\n          }\n\n          for ( int i = 0; i < meta.getTypeName().length; i++ ) {\n            if ( !AlllistTypes.contains( meta.getTypeName()[i] ) ) {\n              throw new KettleException( BaseMessages.getString( PKG, \"IfNull.Log.CanNotFindValueType\", meta\n                .getTypeName()[i] ) );\n            }\n\n            data.ListTypes.put( meta.getTypeName()[i], i );\n            data.defaultValues[i] = environmentSubstitute( meta.getTypeReplaceValue()[i] );\n            data.defaultMasks[i] = environmentSubstitute( meta.getTypeReplaceMask()[i] );\n            data.setEmptyString[i] = meta.isSetTypeEmptyString()[i];\n          }\n\n          HashSet<Integer> fieldsSelectedIndex = new HashSet<Integer>();\n          for ( int i = 0; i < data.outputRowMeta.size(); i++ ) {\n            ValueMetaInterface fieldMeta = data.outputRowMeta.getValueMeta( i );\n            if ( data.ListTypes.containsKey( fieldMeta.getTypeDesc() ) ) {\n              fieldsSelectedIndex.add( i );\n            }\n          }\n          data.fieldnrs = new int[fieldsSelectedIndex.size()];\n          List<Integer> entries = new ArrayList<Integer>( fieldsSelectedIndex );\n          Integer[] fieldnr = entries.toArray( new Integer[entries.size()] );\n          for ( int i = 0; i < fieldnr.length; i++ ) {\n            data.fieldnrs[i] = fieldnr[i];\n          }\n        } else {\n          throw new KettleException( BaseMessages.getString( PKG, \"IfNull.Log.SelectValueTypesEmpty\" ) );\n        }\n\n      } else {\n        data.realReplaceByValue = environmentSubstitute( meta.getReplaceAllByValue() );\n        data.realconversionMask = environmentSubstitute( meta.getReplaceAllMask() );\n        data.realSetEmptyString = meta.isSetEmptyStringAll();\n\n        // Consider all fields in input stream\n        data.fieldnrs = new int[data.outputRowMeta.size()];\n        for ( int i = 0; i < data.outputRowMeta.size(); i++ ) {\n          data.fieldnrs[i] = i;\n        }\n      }\n      data.fieldnr = data.fieldnrs.length;\n    } // end if first\n\n    try {\n      updateFields( r );\n\n      putRow( data.outputRowMeta, r ); // copy row to output rowset(s);\n\n    } catch ( Exception e ) {\n      boolean sendToErrorRow = false;\n      String errorMessage = null;\n\n      if ( getStepMeta().isDoingErrorHandling() ) {\n        sendToErrorRow = true;\n        errorMessage = e.toString();\n      } else {\n        logError( BaseMessages.getString( PKG, \"IfNull.Log.ErrorInStep\", e.getMessage() ) );\n        e.printStackTrace();\n        setErrors( 1 );\n        stopAll();\n        setOutputDone(); // signal end to receiver(s)\n        return false;\n      }\n      if ( sendToErrorRow ) {\n        // Simply add this row to the error row\n        putError( data.outputRowMeta, r, 1, errorMessage, null, \"IFNULL001\" );\n      }\n    }\n    return true;\n  }","id":72717,"modified_method":"public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {\n    meta = (IfNullMeta) smi;\n    data = (IfNullData) sdi;\n\n    Object[] r = getRow(); // get row, set busy!\n    if ( r == null ) { // no more input to be expected...\n\n      setOutputDone();\n      return false;\n    }\n\n    if ( first ) {\n      first = false;\n\n      // What's the format of the output row?\n      data.outputRowMeta = getInputRowMeta().clone();\n      meta.getFields( data.outputRowMeta, getStepname(), null, null, this, repository, metaStore );\n      // Create convert meta-data objects that will contain Date & Number formatters\n      data.convertRowMeta = data.outputRowMeta.clone();\n\n      // For String to <type> conversions, we allocate a conversion meta data row as well...\n      //\n      data.convertRowMeta = data.outputRowMeta.cloneToType( ValueMetaInterface.TYPE_STRING );\n\n      if ( meta.isSelectFields() ) {\n        // Consider only selected fields\n        if ( meta.getFields() != null && meta.getFields().length > 0 ) {\n          int fieldsLength = meta.getFields().length;\n          data.fieldnrs = new int[fieldsLength];\n          data.defaultValues = new String[fieldsLength];\n          data.defaultMasks = new String[fieldsLength];\n          data.setEmptyString = new boolean[fieldsLength];\n\n          for ( int i = 0; i < meta.getFields().length; i++ ) {\n            data.fieldnrs[i] = data.outputRowMeta.indexOfValue( meta.getFields()[i].getFieldName() );\n            if ( data.fieldnrs[i] < 0 ) {\n              logError( BaseMessages.getString( PKG, \"IfNull.Log.CanNotFindField\", meta.getFields()[i]\n                  .getFieldName() ) );\n              throw new KettleException( BaseMessages.getString( PKG, \"IfNull.Log.CanNotFindField\", meta.getFields()[i]\n                  .getFieldName() ) );\n            }\n            data.defaultValues[i] = environmentSubstitute( meta.getFields()[i].getReplaceValue() );\n            data.defaultMasks[i] = environmentSubstitute( meta.getFields()[i].getReplaceMask() );\n            data.setEmptyString[i] = meta.getFields()[i].isSetEmptyString();\n          }\n        } else {\n          throw new KettleException( BaseMessages.getString( PKG, \"IfNull.Log.SelectFieldsEmpty\" ) );\n        }\n      } else if ( meta.isSelectValuesType() ) {\n        // Consider only select value types\n        if ( meta.getValueTypes() != null && meta.getValueTypes().length > 0 ) {\n          // return the real default values\n          int typeLength = meta.getValueTypes().length;\n          data.defaultValues = new String[typeLength];\n          data.defaultMasks = new String[typeLength];\n          data.setEmptyString = new boolean[typeLength];\n\n          // return all type codes\n          HashSet<String> AlllistTypes = new HashSet<String>();\n          for ( int i = 0; i < ValueMetaInterface.typeCodes.length; i++ ) {\n            AlllistTypes.add( ValueMetaInterface.typeCodes[i] );\n          }\n\n          for ( int i = 0; i < meta.getValueTypes().length; i++ ) {\n            if ( !AlllistTypes.contains( meta.getValueTypes()[i].getTypeName() ) ) {\n              throw new KettleException( BaseMessages.getString( PKG, \"IfNull.Log.CanNotFindValueType\", meta\n                  .getValueTypes()[i].getTypeName() ) );\n            }\n\n            data.ListTypes.put( meta.getValueTypes()[i].getTypeName(), i );\n            data.defaultValues[i] = environmentSubstitute( meta.getValueTypes()[i].getTypereplaceValue() );\n            data.defaultMasks[i] = environmentSubstitute( meta.getValueTypes()[i].getTypereplaceMask() );\n            data.setEmptyString[i] = meta.getValueTypes()[i].isSetTypeEmptyString();\n          }\n\n          HashSet<Integer> fieldsSelectedIndex = new HashSet<Integer>();\n          for ( int i = 0; i < data.outputRowMeta.size(); i++ ) {\n            ValueMetaInterface fieldMeta = data.outputRowMeta.getValueMeta( i );\n            if ( data.ListTypes.containsKey( fieldMeta.getTypeDesc() ) ) {\n              fieldsSelectedIndex.add( i );\n            }\n          }\n          data.fieldnrs = new int[fieldsSelectedIndex.size()];\n          List<Integer> entries = new ArrayList<Integer>( fieldsSelectedIndex );\n          Integer[] fieldnr = entries.toArray( new Integer[entries.size()] );\n          for ( int i = 0; i < fieldnr.length; i++ ) {\n            data.fieldnrs[i] = fieldnr[i];\n          }\n        } else {\n          throw new KettleException( BaseMessages.getString( PKG, \"IfNull.Log.SelectValueTypesEmpty\" ) );\n        }\n\n      } else {\n        data.realReplaceByValue = environmentSubstitute( meta.getReplaceAllByValue() );\n        data.realconversionMask = environmentSubstitute( meta.getReplaceAllMask() );\n        data.realSetEmptyString = meta.isSetEmptyStringAll();\n\n        // Consider all fields in input stream\n        data.fieldnrs = new int[data.outputRowMeta.size()];\n        for ( int i = 0; i < data.outputRowMeta.size(); i++ ) {\n          data.fieldnrs[i] = i;\n        }\n      }\n      data.fieldnr = data.fieldnrs.length;\n    } // end if first\n\n    try {\n      updateFields( r );\n\n      putRow( data.outputRowMeta, r ); // copy row to output rowset(s);\n\n    } catch ( Exception e ) {\n      boolean sendToErrorRow = false;\n      String errorMessage = null;\n\n      if ( getStepMeta().isDoingErrorHandling() ) {\n        sendToErrorRow = true;\n        errorMessage = e.toString();\n      } else {\n        logError( BaseMessages.getString( PKG, \"IfNull.Log.ErrorInStep\", e.getMessage() ) );\n        e.printStackTrace();\n        setErrors( 1 );\n        stopAll();\n        setOutputDone(); // signal end to receiver(s)\n        return false;\n      }\n      if ( sendToErrorRow ) {\n        // Simply add this row to the error row\n        putError( data.outputRowMeta, r, 1, errorMessage, null, \"IFNULL001\" );\n      }\n    }\n    return true;\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addFields() {\n    int FieldsCols = 4;\n    ColumnInfo[] colinf = new ColumnInfo[FieldsCols];\n\n    // Table with fields\n    wlFields = new Label( shell, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"IfNullDialog.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, 0 );\n    fdlFields.top = new FormAttachment( wValueTypes, margin );\n    wlFields.setLayoutData( fdlFields );\n\n    colinf[0] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Fieldname.Column\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        new String[] {}, false );\n    colinf[1] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.Column\" ), ColumnInfo.COLUMN_TYPE_TEXT, false );\n    colinf[2] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.ConversionMask\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        Const.getDateFormats() );\n    colinf[1].setUsingVariables( true );\n    colinf[3] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.SetEmptyString\" ),\n        ColumnInfo.COLUMN_TYPE_CCOMBO,\n        new String[] {\n          BaseMessages.getString( PKG, \"System.Combo.Yes\" ), BaseMessages.getString( PKG, \"System.Combo.No\" ) } );\n\n    wFields =\n      new TableView(\n        transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, oldlsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, 0 );\n    fdFields.top = new FormAttachment( wlFields, margin );\n    fdFields.right = new FormAttachment( 100, 0 );\n    fdFields.bottom = new FormAttachment( wOK, -2 * margin );\n\n    wFields.setLayoutData( fdFields );\n\n    setComboValues();\n    fieldColumns.add( colinf[0] );\n\n  }","id":72718,"modified_method":"private void addFields() {\n    int FieldsCols = 4;\n    ColumnInfo[] colinf = new ColumnInfo[FieldsCols];\n\n    // Table with fields\n    wlFields = new Label( shell, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"IfNullDialog.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, 0 );\n    fdlFields.top = new FormAttachment( wValueTypes, margin );\n    wlFields.setLayoutData( fdlFields );\n\n    colinf[0] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Fieldname.Column\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        new String[] {}, false );\n    colinf[1] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.Column\" ), ColumnInfo.COLUMN_TYPE_TEXT, false );\n    colinf[2] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.ConversionMask\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        Const.getDateFormats() );\n    colinf[1].setUsingVariables( true );\n    colinf[3] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.SetEmptyString\" ),\n        ColumnInfo.COLUMN_TYPE_CCOMBO,\n        new String[] {\n          BaseMessages.getString( PKG, \"System.Combo.Yes\" ), BaseMessages.getString( PKG, \"System.Combo.No\" ) } );\n\n    wFields =\n      new TableView(\n        transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, fieldsRows, oldlsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, 0 );\n    fdFields.top = new FormAttachment( wlFields, margin );\n    fdFields.right = new FormAttachment( 100, 0 );\n    fdFields.bottom = new FormAttachment( wOK, -2 * margin );\n\n    wFields.setLayoutData( fdFields );\n\n    setComboValues();\n    fieldColumns.add( colinf[0] );\n\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX );\n    props.setLook( shell );\n    setShellImage( shell, input );\n\n    lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        input.setChanged();\n      }\n    };\n\n    changed = input.hasChanged();\n    oldlsMod = lsMod;\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    middle = props.getMiddlePct();\n    margin = Const.MARGIN;\n\n    FieldsRows = input.getFieldName().length;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"IfNullDialog.Shell.Title\" ) );\n\n    // Stepname line\n    wlStepname = new Label( shell, SWT.RIGHT );\n    wlStepname.setText( BaseMessages.getString( PKG, \"IfNullDialog.Stepname.Label\" ) );\n    props.setLook( wlStepname );\n    fdlStepname = new FormData();\n    fdlStepname.left = new FormAttachment( 0, 0 );\n    fdlStepname.right = new FormAttachment( middle, -margin );\n    fdlStepname.top = new FormAttachment( 0, margin );\n    wlStepname.setLayoutData( fdlStepname );\n    wStepname = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wStepname.setText( stepname );\n    props.setLook( wStepname );\n    wStepname.addModifyListener( lsMod );\n    fdStepname = new FormData();\n    fdStepname.left = new FormAttachment( middle, 0 );\n    fdStepname.top = new FormAttachment( 0, margin );\n    fdStepname.right = new FormAttachment( 100, 0 );\n    wStepname.setLayoutData( fdStepname );\n\n    // ///////////////////////////////\n    // START OF All Fields GROUP //\n    // ///////////////////////////////\n\n    wAllFields = new Group( shell, SWT.SHADOW_NONE );\n    props.setLook( wAllFields );\n    wAllFields.setText( BaseMessages.getString( PKG, \"IfNullDialog.AllFields.Label\" ) );\n\n    FormLayout AllFieldsgroupLayout = new FormLayout();\n    AllFieldsgroupLayout.marginWidth = 10;\n    AllFieldsgroupLayout.marginHeight = 10;\n    wAllFields.setLayout( AllFieldsgroupLayout );\n\n    // Replace by Value\n    wlReplaceByValue = new Label( wAllFields, SWT.RIGHT );\n    wlReplaceByValue.setText( BaseMessages.getString( PKG, \"IfNullDialog.ReplaceByValue.Label\" ) );\n    props.setLook( wlReplaceByValue );\n    fdlReplaceByValue = new FormData();\n    fdlReplaceByValue.left = new FormAttachment( 0, 0 );\n    fdlReplaceByValue.right = new FormAttachment( middle, -margin );\n    fdlReplaceByValue.top = new FormAttachment( wStepname, margin * 2 );\n    wlReplaceByValue.setLayoutData( fdlReplaceByValue );\n\n    wReplaceByValue = new TextVar( transMeta, wAllFields, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wReplaceByValue.setToolTipText( BaseMessages.getString( PKG, \"IfNullDialog.ReplaceByValue.Tooltip\" ) );\n    props.setLook( wReplaceByValue );\n    fdReplaceByValue = new FormData();\n    fdReplaceByValue.left = new FormAttachment( middle, 0 );\n    fdReplaceByValue.top = new FormAttachment( wStepname, 2 * margin );\n    fdReplaceByValue.right = new FormAttachment( 100, 0 );\n    wReplaceByValue.setLayoutData( fdReplaceByValue );\n\n    // SetEmptyStringAll line\n    wlSetEmptyStringAll = new Label( wAllFields, SWT.RIGHT );\n    wlSetEmptyStringAll.setText( BaseMessages.getString( PKG, \"IfNullDialog.SetEmptyStringAll.Label\" ) );\n    props.setLook( wlSetEmptyStringAll );\n    fdlSetEmptyStringAll = new FormData();\n    fdlSetEmptyStringAll.left = new FormAttachment( 0, 0 );\n    fdlSetEmptyStringAll.top = new FormAttachment( wReplaceByValue, margin );\n    fdlSetEmptyStringAll.right = new FormAttachment( middle, -margin );\n    wlSetEmptyStringAll.setLayoutData( fdlSetEmptyStringAll );\n    wSetEmptyStringAll = new Button( wAllFields, SWT.CHECK );\n    wSetEmptyStringAll.setToolTipText( BaseMessages.getString( PKG, \"IfNullDialog.SetEmptyStringAll.Tooltip\" ) );\n    props.setLook( wSetEmptyStringAll );\n    fdSetEmptyStringAll = new FormData();\n    fdSetEmptyStringAll.left = new FormAttachment( middle, 0 );\n    fdSetEmptyStringAll.top = new FormAttachment( wReplaceByValue, margin );\n    fdSetEmptyStringAll.right = new FormAttachment( 100, 0 );\n    wSetEmptyStringAll.setLayoutData( fdSetEmptyStringAll );\n    wSetEmptyStringAll.addSelectionListener( new SelectionAdapter() {\n\n      public void widgetSelected( SelectionEvent e ) {\n        input.setChanged();\n        enableSetEmptyStringAll();\n      }\n    } );\n\n    wlMask = new Label( wAllFields, SWT.RIGHT );\n    wlMask.setText( BaseMessages.getString( PKG, \"IfNullDialog.Mask.Label\" ) );\n    props.setLook( wlMask );\n    fdlMask = new FormData();\n    fdlMask.left = new FormAttachment( 0, 0 );\n    fdlMask.top = new FormAttachment( wSetEmptyStringAll, margin );\n    fdlMask.right = new FormAttachment( middle, -margin );\n    wlMask.setLayoutData( fdlMask );\n    wMask = new CCombo( wAllFields, SWT.BORDER | SWT.READ_ONLY );\n    wMask.setEditable( true );\n    wMask.setItems( Const.getDateFormats() );\n    props.setLook( wMask );\n    wMask.addModifyListener( lsMod );\n    fdMask = new FormData();\n    fdMask.left = new FormAttachment( middle, 0 );\n    fdMask.top = new FormAttachment( wSetEmptyStringAll, margin );\n    fdMask.right = new FormAttachment( 100, 0 );\n    wMask.setLayoutData( fdMask );\n\n    fdAllFields = new FormData();\n    fdAllFields.left = new FormAttachment( 0, margin );\n    fdAllFields.top = new FormAttachment( wStepname, margin );\n    fdAllFields.right = new FormAttachment( 100, -margin );\n    wAllFields.setLayoutData( fdAllFields );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF All Fields GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // Select fields?\n    wlSelectFields = new Label( shell, SWT.RIGHT );\n    wlSelectFields.setText( BaseMessages.getString( PKG, \"IfNullDialog.SelectFields.Label\" ) );\n    props.setLook( wlSelectFields );\n    fdlSelectFields = new FormData();\n    fdlSelectFields.left = new FormAttachment( 0, 0 );\n    fdlSelectFields.top = new FormAttachment( wAllFields, margin );\n    fdlSelectFields.right = new FormAttachment( middle, -margin );\n    wlSelectFields.setLayoutData( fdlSelectFields );\n    wSelectFields = new Button( shell, SWT.CHECK );\n    wSelectFields.setToolTipText( BaseMessages.getString( PKG, \"IfNullDialog.SelectFields.Tooltip\" ) );\n    props.setLook( wSelectFields );\n    fdSelectFields = new FormData();\n    fdSelectFields.left = new FormAttachment( middle, 0 );\n    fdSelectFields.top = new FormAttachment( wAllFields, margin );\n    fdSelectFields.right = new FormAttachment( 100, 0 );\n    wSelectFields.setLayoutData( fdSelectFields );\n\n    // Select type?\n    wlSelectValuesType = new Label( shell, SWT.RIGHT );\n    wlSelectValuesType.setText( BaseMessages.getString( PKG, \"IfNullDialog.SelectValuesType.Label\" ) );\n    props.setLook( wlSelectValuesType );\n    fdlSelectValuesType = new FormData();\n    fdlSelectValuesType.left = new FormAttachment( 0, 0 );\n    fdlSelectValuesType.top = new FormAttachment( wSelectFields, margin );\n    fdlSelectValuesType.right = new FormAttachment( middle, -margin );\n    wlSelectValuesType.setLayoutData( fdlSelectValuesType );\n    wSelectValuesType = new Button( shell, SWT.CHECK );\n    wSelectValuesType.setToolTipText( BaseMessages.getString( PKG, \"IfNullDialog.SelectValuesType.Tooltip\" ) );\n    props.setLook( wSelectValuesType );\n    fdSelectValuesType = new FormData();\n    fdSelectValuesType.left = new FormAttachment( middle, 0 );\n    fdSelectValuesType.top = new FormAttachment( wSelectFields, margin );\n    fdSelectValuesType.right = new FormAttachment( 100, 0 );\n    wSelectValuesType.setLayoutData( fdSelectValuesType );\n\n    wlValueTypes = new Label( shell, SWT.NONE );\n    wlValueTypes.setText( BaseMessages.getString( PKG, \"IfNullDialog.ValueTypes.Label\" ) );\n    props.setLook( wlValueTypes );\n    fdlValueTypes = new FormData();\n    fdlValueTypes.left = new FormAttachment( 0, 0 );\n    fdlValueTypes.top = new FormAttachment( wSelectValuesType, margin );\n    wlValueTypes.setLayoutData( fdlValueTypes );\n\n    int ValueTypesRows = input.getFieldName().length;\n    int FieldsCols = 4;\n\n    ColumnInfo[] colval = new ColumnInfo[FieldsCols];\n    colval[0] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.ValueType.Column\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        ValueMetaInterface.typeCodes );\n    colval[1] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.Column\" ), ColumnInfo.COLUMN_TYPE_TEXT, false );\n    colval[2] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.ConversionMask\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        Const.getDateFormats() );\n    colval[3] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.SetEmptyString\" ),\n        ColumnInfo.COLUMN_TYPE_CCOMBO,\n        new String[] {\n          BaseMessages.getString( PKG, \"System.Combo.Yes\" ), BaseMessages.getString( PKG, \"System.Combo.No\" ) } );\n\n    colval[1].setUsingVariables( true );\n    wValueTypes =\n      new TableView(\n        transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colval, ValueTypesRows, oldlsMod, props );\n\n    fdValueTypes = new FormData();\n    fdValueTypes.left = new FormAttachment( 0, 0 );\n    fdValueTypes.top = new FormAttachment( wlValueTypes, margin );\n    fdValueTypes.right = new FormAttachment( 100, 0 );\n    fdValueTypes.bottom = new FormAttachment( wlValueTypes, 190 );\n\n    wValueTypes.setLayoutData( fdValueTypes );\n\n    getFirstData();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wGet = new Button( shell, SWT.PUSH );\n    wGet.setText( BaseMessages.getString( PKG, \"System.Button.GetFields\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    setButtonPositions( new Button[] { wOK, wGet, wCancel }, margin, null );\n\n    addFields();\n\n    wSelectValuesType.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeSelectValuesType();\n        input.setChanged();\n      }\n    } );\n\n    wSelectFields.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeSelectFields();\n        input.setChanged();\n      }\n    } );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsGet = new Listener() {\n      public void handleEvent( Event e ) {\n        get();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n    wGet.addListener( SWT.Selection, lsGet );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wStepname.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    // Set the shell size, based upon previous time...\n    setSize();\n\n    getData();\n    enableSetEmptyStringAll();\n    // setComboValues();\n    activeSelectFields();\n    activeSelectValuesType();\n    input.setChanged( changed );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return stepname;\n  }","id":72719,"modified_method":"public String open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX );\n    props.setLook( shell );\n    setShellImage( shell, input );\n\n    lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        input.setChanged();\n      }\n    };\n\n    changed = input.hasChanged();\n    oldlsMod = lsMod;\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    middle = props.getMiddlePct();\n    margin = Const.MARGIN;\n\n    fieldsRows = input.getFields().length;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"IfNullDialog.Shell.Title\" ) );\n\n    // Stepname line\n    wlStepname = new Label( shell, SWT.RIGHT );\n    wlStepname.setText( BaseMessages.getString( PKG, \"IfNullDialog.Stepname.Label\" ) );\n    props.setLook( wlStepname );\n    fdlStepname = new FormData();\n    fdlStepname.left = new FormAttachment( 0, 0 );\n    fdlStepname.right = new FormAttachment( middle, -margin );\n    fdlStepname.top = new FormAttachment( 0, margin );\n    wlStepname.setLayoutData( fdlStepname );\n    wStepname = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wStepname.setText( stepname );\n    props.setLook( wStepname );\n    wStepname.addModifyListener( lsMod );\n    fdStepname = new FormData();\n    fdStepname.left = new FormAttachment( middle, 0 );\n    fdStepname.top = new FormAttachment( 0, margin );\n    fdStepname.right = new FormAttachment( 100, 0 );\n    wStepname.setLayoutData( fdStepname );\n\n    // ///////////////////////////////\n    // START OF All Fields GROUP //\n    // ///////////////////////////////\n\n    wAllFields = new Group( shell, SWT.SHADOW_NONE );\n    props.setLook( wAllFields );\n    wAllFields.setText( BaseMessages.getString( PKG, \"IfNullDialog.AllFields.Label\" ) );\n\n    FormLayout AllFieldsgroupLayout = new FormLayout();\n    AllFieldsgroupLayout.marginWidth = 10;\n    AllFieldsgroupLayout.marginHeight = 10;\n    wAllFields.setLayout( AllFieldsgroupLayout );\n\n    // Replace by Value\n    wlReplaceByValue = new Label( wAllFields, SWT.RIGHT );\n    wlReplaceByValue.setText( BaseMessages.getString( PKG, \"IfNullDialog.ReplaceByValue.Label\" ) );\n    props.setLook( wlReplaceByValue );\n    fdlReplaceByValue = new FormData();\n    fdlReplaceByValue.left = new FormAttachment( 0, 0 );\n    fdlReplaceByValue.right = new FormAttachment( middle, -margin );\n    fdlReplaceByValue.top = new FormAttachment( wStepname, margin * 2 );\n    wlReplaceByValue.setLayoutData( fdlReplaceByValue );\n\n    wReplaceByValue = new TextVar( transMeta, wAllFields, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wReplaceByValue.setToolTipText( BaseMessages.getString( PKG, \"IfNullDialog.ReplaceByValue.Tooltip\" ) );\n    props.setLook( wReplaceByValue );\n    fdReplaceByValue = new FormData();\n    fdReplaceByValue.left = new FormAttachment( middle, 0 );\n    fdReplaceByValue.top = new FormAttachment( wStepname, 2 * margin );\n    fdReplaceByValue.right = new FormAttachment( 100, 0 );\n    wReplaceByValue.setLayoutData( fdReplaceByValue );\n\n    // SetEmptyStringAll line\n    wlSetEmptyStringAll = new Label( wAllFields, SWT.RIGHT );\n    wlSetEmptyStringAll.setText( BaseMessages.getString( PKG, \"IfNullDialog.SetEmptyStringAll.Label\" ) );\n    props.setLook( wlSetEmptyStringAll );\n    fdlSetEmptyStringAll = new FormData();\n    fdlSetEmptyStringAll.left = new FormAttachment( 0, 0 );\n    fdlSetEmptyStringAll.top = new FormAttachment( wReplaceByValue, margin );\n    fdlSetEmptyStringAll.right = new FormAttachment( middle, -margin );\n    wlSetEmptyStringAll.setLayoutData( fdlSetEmptyStringAll );\n    wSetEmptyStringAll = new Button( wAllFields, SWT.CHECK );\n    wSetEmptyStringAll.setToolTipText( BaseMessages.getString( PKG, \"IfNullDialog.SetEmptyStringAll.Tooltip\" ) );\n    props.setLook( wSetEmptyStringAll );\n    fdSetEmptyStringAll = new FormData();\n    fdSetEmptyStringAll.left = new FormAttachment( middle, 0 );\n    fdSetEmptyStringAll.top = new FormAttachment( wReplaceByValue, margin );\n    fdSetEmptyStringAll.right = new FormAttachment( 100, 0 );\n    wSetEmptyStringAll.setLayoutData( fdSetEmptyStringAll );\n    wSetEmptyStringAll.addSelectionListener( new SelectionAdapter() {\n\n      public void widgetSelected( SelectionEvent e ) {\n        input.setChanged();\n        enableSetEmptyStringAll();\n      }\n    } );\n\n    wlMask = new Label( wAllFields, SWT.RIGHT );\n    wlMask.setText( BaseMessages.getString( PKG, \"IfNullDialog.Mask.Label\" ) );\n    props.setLook( wlMask );\n    fdlMask = new FormData();\n    fdlMask.left = new FormAttachment( 0, 0 );\n    fdlMask.top = new FormAttachment( wSetEmptyStringAll, margin );\n    fdlMask.right = new FormAttachment( middle, -margin );\n    wlMask.setLayoutData( fdlMask );\n    wMask = new CCombo( wAllFields, SWT.BORDER | SWT.READ_ONLY );\n    wMask.setEditable( true );\n    wMask.setItems( Const.getDateFormats() );\n    props.setLook( wMask );\n    wMask.addModifyListener( lsMod );\n    fdMask = new FormData();\n    fdMask.left = new FormAttachment( middle, 0 );\n    fdMask.top = new FormAttachment( wSetEmptyStringAll, margin );\n    fdMask.right = new FormAttachment( 100, 0 );\n    wMask.setLayoutData( fdMask );\n\n    fdAllFields = new FormData();\n    fdAllFields.left = new FormAttachment( 0, margin );\n    fdAllFields.top = new FormAttachment( wStepname, margin );\n    fdAllFields.right = new FormAttachment( 100, -margin );\n    wAllFields.setLayoutData( fdAllFields );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF All Fields GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // Select fields?\n    wlSelectFields = new Label( shell, SWT.RIGHT );\n    wlSelectFields.setText( BaseMessages.getString( PKG, \"IfNullDialog.SelectFields.Label\" ) );\n    props.setLook( wlSelectFields );\n    fdlSelectFields = new FormData();\n    fdlSelectFields.left = new FormAttachment( 0, 0 );\n    fdlSelectFields.top = new FormAttachment( wAllFields, margin );\n    fdlSelectFields.right = new FormAttachment( middle, -margin );\n    wlSelectFields.setLayoutData( fdlSelectFields );\n    wSelectFields = new Button( shell, SWT.CHECK );\n    wSelectFields.setToolTipText( BaseMessages.getString( PKG, \"IfNullDialog.SelectFields.Tooltip\" ) );\n    props.setLook( wSelectFields );\n    fdSelectFields = new FormData();\n    fdSelectFields.left = new FormAttachment( middle, 0 );\n    fdSelectFields.top = new FormAttachment( wAllFields, margin );\n    fdSelectFields.right = new FormAttachment( 100, 0 );\n    wSelectFields.setLayoutData( fdSelectFields );\n\n    // Select type?\n    wlSelectValuesType = new Label( shell, SWT.RIGHT );\n    wlSelectValuesType.setText( BaseMessages.getString( PKG, \"IfNullDialog.SelectValuesType.Label\" ) );\n    props.setLook( wlSelectValuesType );\n    fdlSelectValuesType = new FormData();\n    fdlSelectValuesType.left = new FormAttachment( 0, 0 );\n    fdlSelectValuesType.top = new FormAttachment( wSelectFields, margin );\n    fdlSelectValuesType.right = new FormAttachment( middle, -margin );\n    wlSelectValuesType.setLayoutData( fdlSelectValuesType );\n    wSelectValuesType = new Button( shell, SWT.CHECK );\n    wSelectValuesType.setToolTipText( BaseMessages.getString( PKG, \"IfNullDialog.SelectValuesType.Tooltip\" ) );\n    props.setLook( wSelectValuesType );\n    fdSelectValuesType = new FormData();\n    fdSelectValuesType.left = new FormAttachment( middle, 0 );\n    fdSelectValuesType.top = new FormAttachment( wSelectFields, margin );\n    fdSelectValuesType.right = new FormAttachment( 100, 0 );\n    wSelectValuesType.setLayoutData( fdSelectValuesType );\n\n    wlValueTypes = new Label( shell, SWT.NONE );\n    wlValueTypes.setText( BaseMessages.getString( PKG, \"IfNullDialog.ValueTypes.Label\" ) );\n    props.setLook( wlValueTypes );\n    fdlValueTypes = new FormData();\n    fdlValueTypes.left = new FormAttachment( 0, 0 );\n    fdlValueTypes.top = new FormAttachment( wSelectValuesType, margin );\n    wlValueTypes.setLayoutData( fdlValueTypes );\n\n    int valueTypesRows = input.getValueTypes().length;\n    int FieldsCols = 4;\n\n    ColumnInfo[] colval = new ColumnInfo[FieldsCols];\n    colval[0] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.ValueType.Column\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        ValueMetaInterface.typeCodes );\n    colval[1] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.Column\" ), ColumnInfo.COLUMN_TYPE_TEXT, false );\n    colval[2] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.ConversionMask\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        Const.getDateFormats() );\n    colval[3] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"IfNullDialog.Value.SetEmptyString\" ),\n        ColumnInfo.COLUMN_TYPE_CCOMBO,\n        new String[] {\n          BaseMessages.getString( PKG, \"System.Combo.Yes\" ), BaseMessages.getString( PKG, \"System.Combo.No\" ) } );\n\n    colval[1].setUsingVariables( true );\n    wValueTypes =\n      new TableView(\n        transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colval, valueTypesRows, oldlsMod, props );\n\n    fdValueTypes = new FormData();\n    fdValueTypes.left = new FormAttachment( 0, 0 );\n    fdValueTypes.top = new FormAttachment( wlValueTypes, margin );\n    fdValueTypes.right = new FormAttachment( 100, 0 );\n    fdValueTypes.bottom = new FormAttachment( wlValueTypes, 190 );\n\n    wValueTypes.setLayoutData( fdValueTypes );\n\n    getFirstData();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wGet = new Button( shell, SWT.PUSH );\n    wGet.setText( BaseMessages.getString( PKG, \"System.Button.GetFields\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    setButtonPositions( new Button[] { wOK, wGet, wCancel }, margin, null );\n\n    addFields();\n\n    wSelectValuesType.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeSelectValuesType();\n        input.setChanged();\n      }\n    } );\n\n    wSelectFields.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeSelectFields();\n        input.setChanged();\n      }\n    } );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsGet = new Listener() {\n      public void handleEvent( Event e ) {\n        get();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n    wGet.addListener( SWT.Selection, lsGet );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wStepname.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    // Set the shell size, based upon previous time...\n    setSize();\n\n    getData();\n    enableSetEmptyStringAll();\n    // setComboValues();\n    activeSelectFields();\n    activeSelectValuesType();\n    input.setChanged( changed );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return stepname;\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok() {\n    if ( Const.isEmpty( wStepname.getText() ) ) {\n      return;\n    }\n    stepname = wStepname.getText(); // return value\n\n    input.setEmptyStringAll( wSetEmptyStringAll.getSelection() );\n\n    if ( wSetEmptyStringAll.getSelection() ) {\n      input.setReplaceAllByValue( \"\" );\n      input.setReplaceAllMask( \"\" );\n\n    } else {\n      input.setReplaceAllByValue( wReplaceByValue.getText() );\n      input.setReplaceAllMask( wMask.getText() );\n    }\n\n    input.setSelectFields( wSelectFields.getSelection() );\n    input.setSelectValuesType( wSelectValuesType.getSelection() );\n\n    int nrtypes = wValueTypes.nrNonEmpty();\n    int nrfields = wFields.nrNonEmpty();\n    input.allocate( nrtypes, nrfields );\n\n    //CHECKSTYLE:Indentation:OFF\n    for ( int i = 0; i < nrtypes; i++ ) {\n      TableItem ti = wValueTypes.getNonEmpty( i );\n      input.getTypeName()[i] = ti.getText( 1 );\n      input.isSetTypeEmptyString()[i] =\n        BaseMessages.getString( PKG, \"System.Combo.Yes\" ).equalsIgnoreCase( ti.getText( 4 ) );\n      if ( input.isSetTypeEmptyString()[i] ) {\n        input.getTypeReplaceValue()[i] = \"\";\n        input.getTypeReplaceMask()[i] = \"\";\n      } else {\n        input.getTypeReplaceValue()[i] = ti.getText( 2 );\n        input.getTypeReplaceMask()[i] = ti.getText( 3 );\n      }\n\n    }\n\n    //CHECKSTYLE:Indentation:OFF\n    for ( int i = 0; i < nrfields; i++ ) {\n      TableItem ti = wFields.getNonEmpty( i );\n      input.getFieldName()[i] = ti.getText( 1 );\n      input.isSetEmptyString()[i] =\n        BaseMessages.getString( PKG, \"System.Combo.Yes\" ).equalsIgnoreCase( ti.getText( 4 ) );\n      if ( input.isSetEmptyString()[i] ) {\n        input.getReplaceValue()[i] = \"\";\n        input.getReplaceMask()[i] = \"\";\n      } else {\n        input.getReplaceValue()[i] = ti.getText( 2 );\n        input.getReplaceMask()[i] = ti.getText( 3 );\n      }\n    }\n    dispose();\n  }","id":72720,"modified_method":"private void ok() {\n    if ( Const.isEmpty( wStepname.getText() ) ) {\n      return;\n    }\n    stepname = wStepname.getText(); // return value\n\n    input.setEmptyStringAll( wSetEmptyStringAll.getSelection() );\n\n    if ( wSetEmptyStringAll.getSelection() ) {\n      input.setReplaceAllByValue( \"\" );\n      input.setReplaceAllMask( \"\" );\n\n    } else {\n      input.setReplaceAllByValue( wReplaceByValue.getText() );\n      input.setReplaceAllMask( wMask.getText() );\n    }\n\n    input.setSelectFields( wSelectFields.getSelection() );\n    input.setSelectValuesType( wSelectValuesType.getSelection() );\n\n    int nrtypes = wValueTypes.nrNonEmpty();\n    int nrfields = wFields.nrNonEmpty();\n    input.allocate( nrtypes, nrfields );\n\n    //CHECKSTYLE:Indentation:OFF\n    for ( int i = 0; i < nrtypes; i++ ) {\n      TableItem ti = wValueTypes.getNonEmpty( i );\n      input.getValueTypes()[i].setTypeName( ti.getText( 1 ) );\n      input.getValueTypes()[i].setTypeEmptyString( BaseMessages.getString( PKG, \"System.Combo.Yes\" ).equalsIgnoreCase(\n          ti.getText( 4 ) ) );\n      if ( input.getValueTypes()[i].isSetTypeEmptyString() ) {\n        input.getValueTypes()[i].setTypereplaceValue( \"\" );\n        input.getValueTypes()[i].setTypereplaceMask( \"\" );\n      } else {\n        input.getValueTypes()[i].setTypereplaceValue( ti.getText( 2 ) );\n        input.getValueTypes()[i].setTypereplaceMask( ti.getText( 3 ) );\n      }\n    }\n\n    //CHECKSTYLE:Indentation:OFF\n    for ( int i = 0; i < nrfields; i++ ) {\n      TableItem ti = wFields.getNonEmpty( i );\n      input.getFields()[i].setFieldName( ti.getText( 1 ) );\n      input.getFields()[i].setEmptyString( BaseMessages.getString( PKG, \"System.Combo.Yes\" ).equalsIgnoreCase( ti\n          .getText( 4 ) ) );\n      if ( input.getFields()[i].isSetEmptyString() ) {\n        input.getFields()[i].setReplaceValue( \"\" );\n        input.getFields()[i].setReplaceMask( \"\" );\n      } else {\n        input.getFields()[i].setReplaceValue( ti.getText( 2 ) );\n        input.getFields()[i].setReplaceMask( ti.getText( 3 ) );\n      }\n    }\n    dispose();\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * Copy information from the meta-data input to the dialog fields.\n   */\n  public void getData() {\n    if ( input.getReplaceAllByValue() != null ) {\n      wReplaceByValue.setText( input.getReplaceAllByValue() );\n    }\n    if ( input.getReplaceAllMask() != null ) {\n      wMask.setText( input.getReplaceAllMask() );\n    }\n    wSetEmptyStringAll.setSelection( input.isSetEmptyStringAll() );\n\n    wSelectFields.setSelection( input.isSelectFields() );\n    wSelectValuesType.setSelection( input.isSelectValuesType() );\n\n    Table table = wValueTypes.table;\n    if ( input.getTypeName().length > 0 ) {\n      table.removeAll();\n    }\n    for ( int i = 0; i < input.getTypeName().length; i++ ) {\n      TableItem ti = new TableItem( table, SWT.NONE );\n      ti.setText( 0, \"\" + ( i + 1 ) );\n      if ( input.getTypeName()[i] != null ) {\n        ti.setText( 1, input.getTypeName()[i] );\n      }\n      if ( input.getTypeReplaceValue()[i] != null ) {\n        ti.setText( 2, input.getTypeReplaceValue()[i] );\n      }\n      if ( input.getTypeReplaceMask()[i] != null ) {\n        ti.setText( 3, input.getTypeReplaceMask()[i] );\n      }\n      ti.setText( 4, input.isSetTypeEmptyString()[i]\n        ? BaseMessages.getString( PKG, \"System.Combo.Yes\" ) : BaseMessages.getString( PKG, \"System.Combo.No\" ) );\n\n    }\n\n    wValueTypes.setRowNums();\n    wValueTypes.removeEmptyRows();\n    wValueTypes.optWidth( true );\n\n    table = wFields.table;\n    if ( input.getFieldName().length > 0 ) {\n      table.removeAll();\n    }\n    for ( int i = 0; i < input.getFieldName().length; i++ ) {\n      TableItem ti = new TableItem( table, SWT.NONE );\n      ti.setText( 0, \"\" + ( i + 1 ) );\n      if ( input.getFieldName()[i] != null ) {\n        ti.setText( 1, input.getFieldName()[i] );\n      }\n      if ( input.getReplaceValue()[i] != null ) {\n        ti.setText( 2, input.getReplaceValue()[i] );\n      }\n      if ( input.getReplaceMask()[i] != null ) {\n        ti.setText( 3, input.getReplaceMask()[i] );\n      }\n      ti.setText( 4, input.isSetEmptyString()[i]\n        ? BaseMessages.getString( PKG, \"System.Combo.Yes\" ) : BaseMessages.getString( PKG, \"System.Combo.No\" ) );\n    }\n\n    wFields.setRowNums();\n    wValueTypes.removeEmptyRows();\n    wFields.optWidth( true );\n\n    wStepname.selectAll();\n    wStepname.setFocus();\n  }","id":72721,"modified_method":"/**\n   * Copy information from the meta-data input to the dialog fields.\n   */\n  public void getData() {\n    if ( input.getReplaceAllByValue() != null ) {\n      wReplaceByValue.setText( input.getReplaceAllByValue() );\n    }\n    if ( input.getReplaceAllMask() != null ) {\n      wMask.setText( input.getReplaceAllMask() );\n    }\n    wSetEmptyStringAll.setSelection( input.isSetEmptyStringAll() );\n\n    wSelectFields.setSelection( input.isSelectFields() );\n    wSelectValuesType.setSelection( input.isSelectValuesType() );\n\n    Table table = wValueTypes.table;\n    if ( input.getValueTypes().length > 0 ) {\n      table.removeAll();\n    }\n    for ( int i = 0; i < input.getValueTypes().length; i++ ) {\n      TableItem ti = new TableItem( table, SWT.NONE );\n      ti.setText( 0, \"\" + ( i + 1 ) );\n      if ( input.getValueTypes()[i].getTypeName() != null ) {\n        ti.setText( 1, input.getValueTypes()[i].getTypeName() );\n      }\n      if ( input.getValueTypes()[i].getTypereplaceValue() != null ) {\n        ti.setText( 2, input.getValueTypes()[i].getTypereplaceValue() );\n      }\n      if ( input.getValueTypes()[i].getTypereplaceMask() != null ) {\n        ti.setText( 3, input.getValueTypes()[i].getTypereplaceMask() );\n      }\n      ti.setText( 4, input.getValueTypes()[i].isSetTypeEmptyString() ? BaseMessages.getString( PKG, \"System.Combo.Yes\" )\n          : BaseMessages.getString( PKG, \"System.Combo.No\" ) );\n\n    }\n\n    wValueTypes.setRowNums();\n    wValueTypes.removeEmptyRows();\n    wValueTypes.optWidth( true );\n\n    table = wFields.table;\n    if ( input.getFields().length > 0 ) {\n      table.removeAll();\n    }\n    for ( int i = 0; i < input.getFields().length; i++ ) {\n      TableItem ti = new TableItem( table, SWT.NONE );\n      ti.setText( 0, \"\" + ( i + 1 ) );\n      if ( input.getFields()[i].getFieldName() != null ) {\n        ti.setText( 1, input.getFields()[i].getFieldName() );\n      }\n      if ( input.getFields()[i].getReplaceValue() != null ) {\n        ti.setText( 2, input.getFields()[i].getReplaceValue() );\n      }\n      if ( input.getFields()[i].getReplaceMask() != null ) {\n        ti.setText( 3, input.getFields()[i].getReplaceMask() );\n      }\n      ti.setText( 4, input.getFields()[i].isSetEmptyString()\n        ? BaseMessages.getString( PKG, \"System.Combo.Yes\" ) : BaseMessages.getString( PKG, \"System.Combo.No\" ) );\n    }\n\n    wFields.setRowNums();\n    wValueTypes.removeEmptyRows();\n    wFields.optWidth( true );\n\n    wStepname.selectAll();\n    wStepname.setFocus();\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check( List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta,\n    RowMetaInterface prev, String[] input, String[] output, RowMetaInterface info, VariableSpace space,\n    Repository repository, IMetaStore metaStore ) {\n    CheckResult cr;\n    if ( prev == null || prev.size() == 0 ) {\n      cr =\n        new CheckResult( CheckResult.TYPE_RESULT_WARNING, BaseMessages.getString(\n          PKG, \"IfNullMeta.CheckResult.NotReceivingFields\" ), stepMeta );\n      remarks.add( cr );\n    } else {\n      cr =\n        new CheckResult( CheckResult.TYPE_RESULT_OK, BaseMessages.getString(\n          PKG, \"IfNullMeta.CheckResult.StepRecevingData\", prev.size() + \"\" ), stepMeta );\n      remarks.add( cr );\n\n      String error_message = \"\";\n      boolean error_found = false;\n\n      // Starting from selected fields in ...\n      for ( int i = 0; i < fieldName.length; i++ ) {\n        int idx = prev.indexOfValue( fieldName[i] );\n        if ( idx < 0 ) {\n          error_message += \"\\t\\t\" + fieldName[i] + Const.CR;\n          error_found = true;\n        }\n      }\n      if ( error_found ) {\n        error_message = BaseMessages.getString( PKG, \"IfNullMeta.CheckResult.FieldsFound\", error_message );\n\n        cr = new CheckResult( CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta );\n        remarks.add( cr );\n      } else {\n        if ( fieldName.length > 0 ) {\n          cr =\n            new CheckResult( CheckResult.TYPE_RESULT_OK, BaseMessages.getString(\n              PKG, \"IfNullMeta.CheckResult.AllFieldsFound\" ), stepMeta );\n          remarks.add( cr );\n        } else {\n          cr =\n            new CheckResult( CheckResult.TYPE_RESULT_WARNING, BaseMessages.getString(\n              PKG, \"IfNullMeta.CheckResult.NoFieldsEntered\" ), stepMeta );\n          remarks.add( cr );\n        }\n      }\n\n    }\n\n    // See if we have input streams leading to this step!\n    if ( input.length > 0 ) {\n      cr =\n        new CheckResult( CheckResult.TYPE_RESULT_OK, BaseMessages.getString(\n          PKG, \"IfNullMeta.CheckResult.StepRecevingData2\" ), stepMeta );\n      remarks.add( cr );\n    } else {\n      cr =\n        new CheckResult( CheckResult.TYPE_RESULT_ERROR, BaseMessages.getString(\n          PKG, \"IfNullMeta.CheckResult.NoInputReceivedFromOtherSteps\" ), stepMeta );\n      remarks.add( cr );\n    }\n  }","id":72722,"modified_method":"public void check( List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta,\n    RowMetaInterface prev, String[] input, String[] output, RowMetaInterface info, VariableSpace space,\n    Repository repository, IMetaStore metaStore ) {\n    CheckResult cr;\n    if ( prev == null || prev.size() == 0 ) {\n      cr =\n        new CheckResult( CheckResult.TYPE_RESULT_WARNING, BaseMessages.getString(\n          PKG, \"IfNullMeta.CheckResult.NotReceivingFields\" ), stepMeta );\n      remarks.add( cr );\n    } else {\n      cr =\n        new CheckResult( CheckResult.TYPE_RESULT_OK, BaseMessages.getString(\n          PKG, \"IfNullMeta.CheckResult.StepRecevingData\", prev.size() + \"\" ), stepMeta );\n      remarks.add( cr );\n\n      String error_message = \"\";\n      boolean error_found = false;\n\n      // Starting from selected fields in ...\n      for ( int i = 0; i < fields.length; i++ ) {\n        int idx = prev.indexOfValue( fields[i].getFieldName() );\n        if ( idx < 0 ) {\n          error_message += \"\\t\\t\" + fields[i].getFieldName() + Const.CR;\n          error_found = true;\n        }\n      }\n      if ( error_found ) {\n        error_message = BaseMessages.getString( PKG, \"IfNullMeta.CheckResult.FieldsFound\", error_message );\n\n        cr = new CheckResult( CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta );\n        remarks.add( cr );\n      } else {\n        if ( fields.length > 0 ) {\n          cr =\n            new CheckResult( CheckResult.TYPE_RESULT_OK, BaseMessages.getString(\n              PKG, \"IfNullMeta.CheckResult.AllFieldsFound\" ), stepMeta );\n          remarks.add( cr );\n        } else {\n          cr =\n            new CheckResult( CheckResult.TYPE_RESULT_WARNING, BaseMessages.getString(\n              PKG, \"IfNullMeta.CheckResult.NoFieldsEntered\" ), stepMeta );\n          remarks.add( cr );\n        }\n      }\n\n    }\n\n    // See if we have input streams leading to this step!\n    if ( input.length > 0 ) {\n      cr =\n        new CheckResult( CheckResult.TYPE_RESULT_OK, BaseMessages.getString(\n          PKG, \"IfNullMeta.CheckResult.StepRecevingData2\" ), stepMeta );\n      remarks.add( cr );\n    } else {\n      cr =\n        new CheckResult( CheckResult.TYPE_RESULT_ERROR, BaseMessages.getString(\n          PKG, \"IfNullMeta.CheckResult.NoInputReceivedFromOtherSteps\" ), stepMeta );\n      remarks.add( cr );\n    }\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData( Node stepnode, List<? extends SharedObjectInterface> databases ) throws KettleXMLException {\n    try {\n      selectFields = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"selectFields\" ) );\n      selectValuesType = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"selectValuesType\" ) );\n      replaceAllByValue = XMLHandler.getTagValue( stepnode, \"replaceAllByValue\" );\n      replaceAllMask = XMLHandler.getTagValue( stepnode, \"replaceAllMask\" );\n      String setEmptyStringAllString = XMLHandler.getTagValue( stepnode, \"setEmptyStringAll\" );\n      setEmptyStringAll = !Const.isEmpty( setEmptyStringAllString ) && \"Y\".equalsIgnoreCase( setEmptyStringAllString );\n\n      Node types = XMLHandler.getSubNode( stepnode, \"valuetypes\" );\n      int nrtypes = XMLHandler.countNodes( types, \"valuetype\" );\n      Node fields = XMLHandler.getSubNode( stepnode, \"fields\" );\n      int nrfields = XMLHandler.countNodes( fields, \"field\" );\n\n      allocate( nrtypes, nrfields );\n\n      for ( int i = 0; i < nrtypes; i++ ) {\n        Node tnode = XMLHandler.getSubNodeByNr( types, \"valuetype\", i );\n        typeName[i] = XMLHandler.getTagValue( tnode, \"name\" );\n        typereplaceValue[i] = XMLHandler.getTagValue( tnode, \"value\" );\n        typereplaceMask[i] = XMLHandler.getTagValue( tnode, \"mask\" );\n        String typeemptyString = XMLHandler.getTagValue( tnode, \"set_type_empty_string\" );\n        setTypeEmptyString[ i ] = !Const.isEmpty( typeemptyString ) && \"Y\".equalsIgnoreCase( typeemptyString );\n      }\n      for ( int i = 0; i < nrfields; i++ ) {\n        Node fnode = XMLHandler.getSubNodeByNr( fields, \"field\", i );\n        fieldName[i] = XMLHandler.getTagValue( fnode, \"name\" );\n        replaceValue[i] = XMLHandler.getTagValue( fnode, \"value\" );\n        replaceMask[i] = XMLHandler.getTagValue( fnode, \"mask\" );\n        String emptyString = XMLHandler.getTagValue( fnode, \"set_empty_string\" );\n        setEmptyString[i] = !Const.isEmpty( emptyString ) && \"Y\".equalsIgnoreCase( emptyString );\n      }\n    } catch ( Exception e ) {\n      throw new KettleXMLException( \"It was not possibke to load the IfNull metadata from XML\", e );\n    }\n  }","id":72723,"modified_method":"private void readData( Node stepnode, List<? extends SharedObjectInterface> databases ) throws KettleXMLException {\n    try {\n      selectFields = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"selectFields\" ) );\n      selectValuesType = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"selectValuesType\" ) );\n      replaceAllByValue = XMLHandler.getTagValue( stepnode, \"replaceAllByValue\" );\n      replaceAllMask = XMLHandler.getTagValue( stepnode, \"replaceAllMask\" );\n      String setEmptyStringAllString = XMLHandler.getTagValue( stepnode, \"setEmptyStringAll\" );\n      setEmptyStringAll = !Const.isEmpty( setEmptyStringAllString ) && \"Y\".equalsIgnoreCase( setEmptyStringAllString );\n\n      Node types = XMLHandler.getSubNode( stepnode, \"valuetypes\" );\n      int nrtypes = XMLHandler.countNodes( types, \"valuetype\" );\n      Node fieldNodes = XMLHandler.getSubNode( stepnode, \"fields\" );\n      int nrfields = XMLHandler.countNodes( fieldNodes, \"field\" );\n\n      allocate( nrtypes, nrfields );\n\n      for ( int i = 0; i < nrtypes; i++ ) {\n        Node tnode = XMLHandler.getSubNodeByNr( types, \"valuetype\", i );\n        valueTypes[i].setTypeName( XMLHandler.getTagValue( tnode, \"name\" ) );\n        valueTypes[i].setTypereplaceValue( XMLHandler.getTagValue( tnode, \"value\" ) );\n        valueTypes[i].setTypereplaceMask( XMLHandler.getTagValue( tnode, \"mask\" ) );\n        String typeemptyString = XMLHandler.getTagValue( tnode, \"set_type_empty_string\" );\n        valueTypes[i].setTypeEmptyString( !Const.isEmpty( typeemptyString ) && \"Y\".equalsIgnoreCase(\n            typeemptyString ) );\n      }\n      for ( int i = 0; i < nrfields; i++ ) {\n        Node fnode = XMLHandler.getSubNodeByNr( fieldNodes, \"field\", i );\n        fields[i].setFieldName( XMLHandler.getTagValue( fnode, \"name\" ) );\n        fields[i].setReplaceValue( XMLHandler.getTagValue( fnode, \"value\" ) );\n        fields[i].setReplaceMask( XMLHandler.getTagValue( fnode, \"mask\" ) );\n        String emptyString = XMLHandler.getTagValue( fnode, \"set_empty_string\" );\n        fields[i].setEmptyString( !Const.isEmpty( emptyString ) && \"Y\".equalsIgnoreCase( emptyString ) );\n      }\n    } catch ( Exception e ) {\n      throw new KettleXMLException( \"It was not possibke to load the IfNull metadata from XML\", e );\n    }\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * @return Returns the fieldName.\n   */\n  public String[] getFieldName() {\n    return fieldName;\n  }","id":72724,"modified_method":"public Fields[] getFields() {\n    return fields;\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void allocate( int nrtypes, int nrfields ) {\n    typeName = new String[nrtypes];\n    typereplaceValue = new String[nrtypes];\n    typereplaceMask = new String[nrtypes];\n    setTypeEmptyString = new boolean[nrtypes];\n\n    fieldName = new String[nrfields];\n    replaceValue = new String[nrfields];\n    replaceMask = new String[nrfields];\n    setEmptyString = new boolean[nrfields];\n  }","id":72725,"modified_method":"public void allocate( int nrtypes, int nrfields ) {\n    valueTypes = new ValueTypes[nrtypes];\n    for ( int i = 0; i < nrtypes; i++ ) {\n      valueTypes[i] = new ValueTypes();\n    }\n    fields = new Fields[nrfields];\n    for ( int i = 0; i < nrfields; i++ ) {\n      fields[i] = new Fields();\n    }\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep( Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases ) throws KettleException {\n    try {\n      replaceAllByValue = rep.getStepAttributeString( id_step, \"replaceAllByValue\" );\n      replaceAllMask = rep.getStepAttributeString( id_step, \"replaceAllMask\" );\n      selectFields = rep.getStepAttributeBoolean( id_step, \"selectFields\" );\n      selectValuesType = rep.getStepAttributeBoolean( id_step, \"selectValuesType\" );\n      setEmptyStringAll = rep.getStepAttributeBoolean( id_step, 0, \"setEmptyStringAll\", false );\n\n      int nrtypes = rep.countNrStepAttributes( id_step, \"type_name\" );\n      int nrfields = rep.countNrStepAttributes( id_step, \"field_name\" );\n      allocate( nrtypes, nrfields );\n\n      for ( int i = 0; i < nrtypes; i++ ) {\n        typeName[i] = rep.getStepAttributeString( id_step, i, \"type_name\" );\n        typereplaceValue[i] = rep.getStepAttributeString( id_step, i, \"type_replace_value\" );\n        typereplaceMask[i] = rep.getStepAttributeString( id_step, i, \"type_replace_mask\" );\n        setTypeEmptyString[i] = rep.getStepAttributeBoolean( id_step, i, \"set_type_empty_string\", false );\n      }\n\n      for ( int i = 0; i < nrfields; i++ ) {\n        fieldName[i] = rep.getStepAttributeString( id_step, i, \"field_name\" );\n        replaceValue[i] = rep.getStepAttributeString( id_step, i, \"replace_value\" );\n        replaceMask[i] = rep.getStepAttributeString( id_step, i, \"replace_mask\" );\n        setEmptyString[i] = rep.getStepAttributeBoolean( id_step, i, \"set_empty_string\", false );\n      }\n    } catch ( Exception e ) {\n      throw new KettleException( \"Unexpected error reading step information from the repository\", e );\n    }\n  }","id":72726,"modified_method":"public void readRep( Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases ) throws KettleException {\n    try {\n      replaceAllByValue = rep.getStepAttributeString( id_step, \"replaceAllByValue\" );\n      replaceAllMask = rep.getStepAttributeString( id_step, \"replaceAllMask\" );\n      selectFields = rep.getStepAttributeBoolean( id_step, \"selectFields\" );\n      selectValuesType = rep.getStepAttributeBoolean( id_step, \"selectValuesType\" );\n      setEmptyStringAll = rep.getStepAttributeBoolean( id_step, 0, \"setEmptyStringAll\", false );\n\n      int nrtypes = rep.countNrStepAttributes( id_step, \"type_name\" );\n      int nrfields = rep.countNrStepAttributes( id_step, \"field_name\" );\n      allocate( nrtypes, nrfields );\n\n      for ( int i = 0; i < nrtypes; i++ ) {\n        valueTypes[i].setTypeName( rep.getStepAttributeString( id_step, i, \"type_name\" ) );\n        valueTypes[i].setTypereplaceValue( rep.getStepAttributeString( id_step, i, \"type_replace_value\" ) );\n        valueTypes[i].setTypereplaceMask( rep.getStepAttributeString( id_step, i, \"type_replace_mask\" ) );\n        valueTypes[i].setTypeEmptyString( rep.getStepAttributeBoolean( id_step, i, \"set_type_empty_string\", false ) );\n      }\n\n      for ( int i = 0; i < nrfields; i++ ) {\n        fields[i].setFieldName( rep.getStepAttributeString( id_step, i, \"field_name\" ) );\n        fields[i].setReplaceValue( rep.getStepAttributeString( id_step, i, \"replace_value\" ) );\n        fields[i].setReplaceMask( rep.getStepAttributeString( id_step, i, \"replace_mask\" ) );\n        fields[i].setEmptyString( rep.getStepAttributeBoolean( id_step, i, \"set_empty_string\", false ) );\n      }\n    } catch ( Exception e ) {\n      throw new KettleException( \"Unexpected error reading step information from the repository\", e );\n    }\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step ) throws KettleException {\n    try {\n      rep.saveStepAttribute( id_transformation, id_step, \"replaceAllByValue\", replaceAllByValue );\n      rep.saveStepAttribute( id_transformation, id_step, \"replaceAllMask\", replaceAllMask );\n      rep.saveStepAttribute( id_transformation, id_step, \"selectFields\", selectFields );\n      rep.saveStepAttribute( id_transformation, id_step, \"selectValuesType\", selectValuesType );\n      rep.saveStepAttribute( id_transformation, id_step, \"setEmptyStringAll\", setEmptyStringAll );\n\n      for ( int i = 0; i < typeName.length; i++ ) {\n        rep.saveStepAttribute( id_transformation, id_step, i, \"type_name\", typeName[i] );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"type_replace_value\", typereplaceValue[i] );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"type_replace_mask\", typereplaceMask[i] );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"set_type_empty_string\", setTypeEmptyString[i] );\n      }\n\n      for ( int i = 0; i < fieldName.length; i++ ) {\n        rep.saveStepAttribute( id_transformation, id_step, i, \"field_name\", fieldName[i] );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"replace_value\", replaceValue[i] );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"replace_mask\", replaceMask[i] );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"set_empty_string\", setEmptyString[i] );\n      }\n    } catch ( Exception e ) {\n      throw new KettleException( \"Unable to save step information to the repository for id_step=\" + id_step, e );\n    }\n  }","id":72727,"modified_method":"public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step ) throws KettleException {\n    try {\n      rep.saveStepAttribute( id_transformation, id_step, \"replaceAllByValue\", replaceAllByValue );\n      rep.saveStepAttribute( id_transformation, id_step, \"replaceAllMask\", replaceAllMask );\n      rep.saveStepAttribute( id_transformation, id_step, \"selectFields\", selectFields );\n      rep.saveStepAttribute( id_transformation, id_step, \"selectValuesType\", selectValuesType );\n      rep.saveStepAttribute( id_transformation, id_step, \"setEmptyStringAll\", setEmptyStringAll );\n\n      for ( int i = 0; i < valueTypes.length; i++ ) {\n        rep.saveStepAttribute( id_transformation, id_step, i, \"type_name\", valueTypes[i].getTypeName() );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"type_replace_value\", valueTypes[i].getTypereplaceValue() );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"type_replace_mask\", valueTypes[i].getTypereplaceMask() );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"set_type_empty_string\", valueTypes[i].isSetTypeEmptyString() );\n      }\n\n      for ( int i = 0; i < fields.length; i++ ) {\n        rep.saveStepAttribute( id_transformation, id_step, i, \"field_name\", fields[i].getFieldName() );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"replace_value\", fields[i].getReplaceValue() );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"replace_mask\", fields[i].getReplaceMask() );\n        rep.saveStepAttribute( id_transformation, id_step, i, \"set_empty_string\", fields[i].isSetEmptyString() );\n      }\n    } catch ( Exception e ) {\n      throw new KettleException( \"Unable to save step information to the repository for id_step=\" + id_step, e );\n    }\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Object clone() {\n    IfNullMeta retval = (IfNullMeta) super.clone();\n\n    int nrTypes = typeName.length;\n    int nrfields = fieldName.length;\n    retval.allocate( nrTypes, nrfields );\n\n    System.arraycopy( typeName, 0, retval.typeName, 0, nrTypes );\n    System.arraycopy( typereplaceValue, 0, retval.typereplaceValue, 0, nrTypes );\n    System.arraycopy( typereplaceMask, 0, retval.typereplaceMask, 0, nrTypes );\n    System.arraycopy( setTypeEmptyString, 0, retval.setTypeEmptyString, 0, nrTypes );\n\n    System.arraycopy( fieldName, 0, retval.fieldName, 0, nrfields );\n    System.arraycopy( replaceValue, 0, retval.replaceValue, 0, nrfields );\n    System.arraycopy( replaceMask, 0, retval.replaceMask, 0, nrfields );\n    System.arraycopy( setEmptyString, 0, retval.setEmptyString, 0, nrfields );\n\n    return retval;\n  }","id":72728,"modified_method":"public Object clone() {\n    IfNullMeta retval = (IfNullMeta) super.clone();\n\n    int nrTypes = valueTypes.length;\n    int nrfields = fields.length;\n    retval.allocate( nrTypes, nrfields );\n\n    for ( int i = 0; i < nrTypes; i++ ) {\n      retval.getValueTypes()[i] = valueTypes[i].clone();\n    }\n\n    for ( int i = 0; i < nrfields; i++ ) {\n      retval.getFields()[i] = fields[i].clone();\n    }\n\n    return retval;\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML() {\n    StringBuilder retval = new StringBuilder();\n\n    retval.append( \"      \" + XMLHandler.addTagValue( \"replaceAllByValue\", replaceAllByValue ) );\n    retval.append( \"      \" + XMLHandler.addTagValue( \"replaceAllMask\", replaceAllMask ) );\n    retval.append( \"      \" + XMLHandler.addTagValue( \"selectFields\", selectFields ) );\n    retval.append( \"      \" + XMLHandler.addTagValue( \"selectValuesType\", selectValuesType ) );\n    retval.append( \"      \" + XMLHandler.addTagValue( \"setEmptyStringAll\", setEmptyStringAll ) );\n\n    retval.append( \"    <valuetypes>\" + Const.CR );\n    for ( int i = 0; i < typeName.length; i++ ) {\n      retval.append( \"      <valuetype>\" + Const.CR );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"name\", typeName[i] ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"value\", typereplaceValue[i] ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"mask\", typereplaceMask[i] ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"set_type_empty_string\", setTypeEmptyString[i] ) );\n      retval.append( \"        <\/valuetype>\" + Const.CR );\n    }\n    retval.append( \"      <\/valuetypes>\" + Const.CR );\n\n    retval.append( \"    <fields>\" + Const.CR );\n    for ( int i = 0; i < fieldName.length; i++ ) {\n      retval.append( \"      <field>\" + Const.CR );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"name\", fieldName[i] ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"value\", replaceValue[i] ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"mask\", replaceMask[i] ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"set_empty_string\", setEmptyString[i] ) );\n      retval.append( \"        <\/field>\" + Const.CR );\n    }\n    retval.append( \"      <\/fields>\" + Const.CR );\n\n    return retval.toString();\n  }","id":72729,"modified_method":"public String getXML() {\n    StringBuilder retval = new StringBuilder();\n\n    retval.append( \"      \" + XMLHandler.addTagValue( \"replaceAllByValue\", replaceAllByValue ) );\n    retval.append( \"      \" + XMLHandler.addTagValue( \"replaceAllMask\", replaceAllMask ) );\n    retval.append( \"      \" + XMLHandler.addTagValue( \"selectFields\", selectFields ) );\n    retval.append( \"      \" + XMLHandler.addTagValue( \"selectValuesType\", selectValuesType ) );\n    retval.append( \"      \" + XMLHandler.addTagValue( \"setEmptyStringAll\", setEmptyStringAll ) );\n\n    retval.append( \"    <valuetypes>\" + Const.CR );\n    for ( int i = 0; i < valueTypes.length; i++ ) {\n      retval.append( \"      <valuetype>\" + Const.CR );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"name\", valueTypes[i].getTypeName() ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"value\", valueTypes[i].getTypereplaceValue() ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"mask\", valueTypes[i].getTypereplaceMask() ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"set_type_empty_string\", valueTypes[i]\n          .isSetTypeEmptyString() ) );\n      retval.append( \"        <\/valuetype>\" + Const.CR );\n    }\n    retval.append( \"      <\/valuetypes>\" + Const.CR );\n\n    retval.append( \"    <fields>\" + Const.CR );\n    for ( int i = 0; i < fields.length; i++ ) {\n      retval.append( \"      <field>\" + Const.CR );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"name\", fields[i].getFieldName() ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"value\", fields[i].getReplaceValue() ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"mask\", fields[i].getReplaceMask() ) );\n      retval.append( \"        \" + XMLHandler.addTagValue( \"set_empty_string\", fields[i].isSetEmptyString() ) );\n      retval.append( \"        <\/field>\" + Const.CR );\n    }\n    retval.append( \"      <\/fields>\" + Const.CR );\n\n    return retval.toString();\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Test\r\n  public void testSetDefault() throws Exception {\r\n    IfNullMeta inm = new IfNullMeta();\r\n    inm.setDefault();\r\n    assertTrue( ( inm.getTypeName() != null ) && ( inm.getTypeName().length == 0 ) );\r\n    assertTrue( ( inm.getTypeReplaceValue() != null ) && ( inm.getTypeReplaceValue().length == 0 ) );\r\n    assertTrue( ( inm.getTypeReplaceMask() != null ) && ( inm.getTypeReplaceMask().length == 0 ) );\r\n    assertTrue( ( inm.isSetTypeEmptyString() != null ) && ( inm.isSetTypeEmptyString().length == 0 ) );\r\n    assertTrue( ( inm.getFieldName() != null ) && ( inm.getFieldName().length == 0 ) );\r\n    assertTrue( ( inm.getReplaceValue() != null ) && ( inm.getReplaceValue().length == 0 ) );\r\n    assertTrue( ( inm.getReplaceMask() != null ) && ( inm.getReplaceMask().length == 0 ) );\r\n    assertTrue( ( inm.isSetEmptyString() != null ) && ( inm.isSetEmptyString().length == 0 ) );\r\n    assertFalse( inm.isSelectFields() );\r\n    assertFalse( inm.isSelectValuesType() );\r\n  }","id":72730,"modified_method":"@Test\r\n  public void testSetDefault() throws Exception {\r\n    IfNullMeta inm = new IfNullMeta();\r\n    inm.setDefault();\r\n    assertTrue( ( inm.getValueTypes() != null ) && ( inm.getValueTypes().length == 0 ) );\r\n    assertTrue( ( inm.getFields() != null ) && ( inm.getFields().length == 0 ) );\r\n    assertFalse( inm.isSelectFields() );\r\n    assertFalse( inm.isSelectValuesType() );\r\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Before\r\n  public void setUp() throws Exception {\r\n    List<String> attributes =\r\n        Arrays.asList( \"fieldName\", \"replaceValue\", \"typeName\", \"typereplaceValue\", \"typereplaceMask\", \"replaceMask\",\r\n            \"setTypeEmptyString\", \"setEmptyString\", \"selectFields\", \"selectValuesType\",\r\n            \"replaceAllByValue\", \"replaceAllMask\", \"setEmptyStringAll\" );\r\n\r\n    Map<String, String> getterMap = new HashMap<String, String>() {\r\n      {\r\n        put( \"fieldName\", \"getFieldName\" );\r\n        put( \"replaceValue\", \"getReplaceValue\" );\r\n        put( \"typeName\", \"getTypeName\" );\r\n        put( \"typereplaceValue\", \"getTypeReplaceValue\" );\r\n        put( \"typereplaceMask\", \"getTypeReplaceMask\" );\r\n        put( \"replaceMask\", \"getReplaceMask\" );\r\n        put( \"setTypeEmptyString\", \"isSetTypeEmptyString\" );\r\n        put( \"setEmptyString\", \"isSetEmptyString\" );\r\n        put( \"selectFields\", \"isSelectFields\" );\r\n        put( \"selectValuesType\", \"isSelectValuesType\" );\r\n        put( \"replaceAllByValue\", \"getReplaceAllByValue\" );\r\n        put( \"replaceAllMask\", \"getReplaceAllMask\" );\r\n        put( \"setEmptyStringAll\", \"isSetEmptyStringAll\" );\r\n      }\r\n    };\r\n\r\n    Map<String, String> setterMap = new HashMap<String, String>() {\r\n      {\r\n        put( \"fieldName\", \"setFieldName\" );\r\n        put( \"replaceValue\", \"setReplaceValue\" );\r\n        put( \"typeName\", \"setTypeName\" );\r\n        put( \"typereplaceValue\", \"setTypeReplaceValue\" );\r\n        put( \"typereplaceMask\", \"setTypeReplaceMask\" );\r\n        put( \"replaceMask\", \"setReplaceMask\" );\r\n        put( \"setTypeEmptyString\", \"setTypeEmptyString\" );\r\n        put( \"setEmptyString\", \"setEmptyString\" );\r\n        put( \"selectFields\", \"setSelectFields\" );\r\n        put( \"selectValuesType\", \"setSelectValuesType\" );\r\n        put( \"replaceAllByValue\", \"setReplaceAllByValue\" );\r\n        put( \"replaceAllMask\", \"setReplaceAllMask\" );\r\n        put( \"setEmptyStringAll\", \"setEmptyStringAll\" );\r\n      }\r\n    };\r\n    FieldLoadSaveValidator<String[]> stringArrayLoadSaveValidator =\r\n        new ArrayLoadSaveValidator<String>( new StringLoadSaveValidator(), 3 );\r\n    Map<String, FieldLoadSaveValidator<?>> attrValidatorMap = new HashMap<String, FieldLoadSaveValidator<?>>();\r\n    attrValidatorMap.put( \"fieldName\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"replaceValue\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"typeName\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"typereplaceValue\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"typereplaceMask\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"replaceMask\", stringArrayLoadSaveValidator );\r\n\r\n    Map<String, FieldLoadSaveValidator<?>> typeValidatorMap = new HashMap<String, FieldLoadSaveValidator<?>>();\r\n    typeValidatorMap.put( boolean[].class.getCanonicalName(), new PrimitiveBooleanArrayLoadSaveValidator( new BooleanLoadSaveValidator(), 3 ) );\r\n\r\n    loadSaveTester = new LoadSaveTester( IfNullMeta.class, attributes, getterMap, setterMap, attrValidatorMap, typeValidatorMap );\r\n  }","id":72731,"modified_method":"@Before\r\n  public void setUp() throws Exception {\r\n    List<String> attributes =\r\n        Arrays.asList( \"fields\", \"valueTypes\", \"selectFields\", \"selectValuesType\", \"replaceAllByValue\",\r\n            \"replaceAllMask\", \"setEmptyStringAll\" );\r\n\r\n    Map<String, String> getterMap = new HashMap<String, String>() {\r\n      {\r\n        put( \"fields\", \"getFields\" );\r\n        put( \"valueTypes\", \"getValueTypes\" );\r\n        put( \"selectFields\", \"isSelectFields\" );\r\n        put( \"selectValuesType\", \"isSelectValuesType\" );\r\n        put( \"replaceAllByValue\", \"getReplaceAllByValue\" );\r\n        put( \"replaceAllMask\", \"getReplaceAllMask\" );\r\n        put( \"setEmptyStringAll\", \"isSetEmptyStringAll\" );\r\n      }\r\n    };\r\n\r\n    Map<String, String> setterMap = new HashMap<String, String>() {\r\n      {\r\n        put( \"fields\", \"setFields\" );\r\n        put( \"valueTypes\", \"setValueTypes\" );\r\n        put( \"selectFields\", \"setSelectFields\" );\r\n        put( \"selectValuesType\", \"setSelectValuesType\" );\r\n        put( \"replaceAllByValue\", \"setReplaceAllByValue\" );\r\n        put( \"replaceAllMask\", \"setReplaceAllMask\" );\r\n        put( \"setEmptyStringAll\", \"setEmptyStringAll\" );\r\n      }\r\n    };\r\n    FieldLoadSaveValidator<String[]> stringArrayLoadSaveValidator =\r\n        new ArrayLoadSaveValidator<String>( new StringLoadSaveValidator(), 3 );\r\n    Map<String, FieldLoadSaveValidator<?>> attrValidatorMap = new HashMap<String, FieldLoadSaveValidator<?>>();\r\n    attrValidatorMap.put( \"fieldName\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"replaceValue\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"typeName\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"typereplaceValue\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"typereplaceMask\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"replaceMask\", stringArrayLoadSaveValidator );\r\n\r\n    Map<String, FieldLoadSaveValidator<?>> typeValidatorMap = new HashMap<String, FieldLoadSaveValidator<?>>();\r\n    typeValidatorMap.put( boolean[].class.getCanonicalName(), new PrimitiveBooleanArrayLoadSaveValidator(\r\n        new BooleanLoadSaveValidator(), 3 ) );\r\n\r\n    Fields field = new Fields();\r\n    field.setFieldName( \"fieldName\" );\r\n    field.setReplaceValue( \"replaceValue\" );\r\n    field.setReplaceMask( \"replaceMask\" );\r\n    field.setEmptyString( true );\r\n    typeValidatorMap.put( Fields[].class.getCanonicalName(), new ArrayLoadSaveValidator<Fields>(\r\n        new FieldsLoadSaveValidator( field ), 3 ) );\r\n\r\n    ValueTypes type = new ValueTypes();\r\n    type.setTypeName( \"typeName\" );\r\n    type.setTypereplaceValue( \"typereplaceValue\" );\r\n    type.setTypereplaceMask( \"typereplaceMask\" );\r\n    type.setTypeEmptyString( true );\r\n    typeValidatorMap.put( ValueTypes[].class.getCanonicalName(), new ArrayLoadSaveValidator<ValueTypes>(\r\n        new ValueTypesLoadSaveValidator( type ), 3 ) );\r\n\r\n    loadSaveTester =\r\n        new LoadSaveTester( IfNullMeta.class, attributes, getterMap, setterMap, attrValidatorMap, typeValidatorMap );\r\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private IfNullMeta mockProcessRowMeta() throws KettleStepException {\n    IfNullMeta processRowMeta = smh.processRowsStepMetaInterface;\n    doReturn( new String[] { \"null-field\", \"empty-field\", \"space-field\" } ).when( processRowMeta ).getFieldName();\n    doReturn( \"replace-value\" ).when( processRowMeta ).getReplaceAllByValue();\n    doCallRealMethod().when( processRowMeta ).getFields( any( RowMetaInterface.class ), anyString(),\n        any( RowMetaInterface[].class ), any( StepMeta.class ), any( VariableSpace.class ), any( Repository.class ),\n        any( IMetaStore.class ) );\n\n    return processRowMeta;\n  }","id":72732,"modified_method":"private IfNullMeta mockProcessRowMeta() throws KettleStepException {\n    IfNullMeta processRowMeta = smh.processRowsStepMetaInterface;\n    doReturn( createFields( \"null-field\", \"empty-field\", \"space-field\" ) ).when( processRowMeta ).getFields();\n    doReturn( \"replace-value\" ).when( processRowMeta ).getReplaceAllByValue();\n    doCallRealMethod().when( processRowMeta ).getFields( any( RowMetaInterface.class ), anyString(), any(\n        RowMetaInterface[].class ), any( StepMeta.class ), any( VariableSpace.class ), any( Repository.class ), any(\n            IMetaStore.class ) );\n    return processRowMeta;\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * Test transformation created in Kettle 5 - should work w/ and w/o the fix\n   */\n  @Test\n  public void testLoadXMLVersion5() throws Exception {\n    Node nullIfStep = getNullIfStep( xmlVersion5 );\n    meta.loadXML( nullIfStep, null, (IMetaStore) null );\n\n    Assert.assertFalse( \"Set Empty String is true\", meta.isSetEmptyStringAll() );\n    boolean[] expected = new boolean[] { true, false, false };\n    ExactComparisonCriteria criteria = new ExactComparisonCriteria();\n    criteria.arrayEquals( \"Set empty string value type works incorrectly\", expected, meta.isSetTypeEmptyString() );\n  }","id":72733,"modified_method":"/**\n   * Test transformation created in Kettle 5 - should work w/ and w/o the fix\n   */\n  @Test\n  public void testLoadXMLVersion5() throws Exception {\n    Node nullIfStep = getNullIfStep( xmlVersion5 );\n    meta.loadXML( nullIfStep, null, (IMetaStore) null );\n\n    Assert.assertFalse( \"Set Empty String is true\", meta.isSetEmptyStringAll() );\n    boolean[] expected = { true, false, false };\n    ValueTypes[] actual = meta.getValueTypes();\n    Assert.assertEquals( expected.length, actual.length );\n    for ( int i = 0; i < expected.length; i++ ) {\n      Assert.assertEquals( \"Set empty string value type works incorrectly\", expected[i], actual[i]\n          .isSetTypeEmptyString() );\n    }\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * Test forward compatibility - transformation created in version 4 don't contain \"set emtry\" elements\n   */\n  @Test\n  public void testLoadXMLVersion4() throws Exception {\n    Node nullIfStep = getNullIfStep( xmlVersion4 );\n    meta.loadXML( nullIfStep, null, (IMetaStore) null );\n\n    Assert.assertFalse( \"Set Empty String is true\", meta.isSetEmptyStringAll() );\n    boolean[] expected = new boolean[] { false };\n    ExactComparisonCriteria criteria = new ExactComparisonCriteria();\n    criteria.arrayEquals( \"Set empty string value type works incorrectly\", expected, meta.isSetTypeEmptyString() );\n  }","id":72734,"modified_method":"/**\n   * Test forward compatibility - transformation created in version 4 don't contain \"set emtry\" elements\n   */\n  @Test\n  public void testLoadXMLVersion4() throws Exception {\n    Node nullIfStep = getNullIfStep( xmlVersion4 );\n    meta.loadXML( nullIfStep, null, (IMetaStore) null );\n\n    Assert.assertFalse( \"Set Empty String is true\", meta.isSetEmptyStringAll() );\n    boolean[] expected = { false };\n    ValueTypes[] actual = meta.getValueTypes();\n    Assert.assertEquals( expected.length, actual.length );\n    for ( int i = 0; i < expected.length; i++ ) {\n      Assert.assertEquals( \"Set empty string value type works incorrectly\", expected[i], actual[i]\n          .isSetTypeEmptyString() );\n    }\n  }","commit_id":"9efea45cfb34230f78beb7f369d9da49195bf6f0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processChangeMethodUsage(IntroduceParameterData data, UsageInfo usage, UsageInfo[] usages) throws IncorrectOperationException {\n    GrCall callExpression = GroovyRefactoringUtil.getCallExpressionByMethodReference(usage.getElement());\n    if (callExpression == null) return true;\n    GrArgumentList argList = callExpression.getArgumentList();\n    GrExpression[] oldArgs = argList.getExpressionArguments();\n\n    final GrExpression anchor;\n    if (!data.getMethodToSearchFor().isVarArgs()) {\n      anchor = getLast(oldArgs);\n    }\n    else {\n      final PsiParameter[] parameters = data.getMethodToSearchFor().getParameterList().getParameters();\n      if (parameters.length > oldArgs.length) {\n        anchor = getLast(oldArgs);\n      }\n      else {\n        final int lastNonVararg = parameters.length - 2;\n        anchor = lastNonVararg >= 0 ? oldArgs[lastNonVararg] : null;\n      }\n    }\n\n    PsiMethod method = PsiTreeUtil.getParentOfType(argList, PsiMethod.class);\n\n    GrClosureSignature signature = GrClosureSignatureUtil.createSignature(callExpression);\n    if (signature == null) signature = GrClosureSignatureUtil.createSignature(data.getMethodToSearchFor(), PsiSubstitutor.EMPTY);\n\n    final GrClosureSignatureUtil.ArgInfo<PsiElement>[] actualArgs =\n      GrClosureSignatureUtil.mapParametersToArguments(signature, argList, callExpression, callExpression.getClosureArguments(), true);\n\n    if (method != null && IntroduceParameterUtil.isMethodInUsages(data, method, usages)) {\n      argList.addAfter(GroovyPsiElementFactory.getInstance(data.getProject()).createExpressionFromText(data.getParameterName()), anchor);\n    }\n    else {\n      PsiElement initializer = ExpressionConverter\n        .getExpression(data.getParameterInitializer().getExpression(), GroovyFileType.GROOVY_LANGUAGE, data.getProject());\n      LOG.assertTrue(initializer instanceof GrExpression);\n\n      GrExpression newArg = (GrExpression)argList.addAfter(initializer, anchor);\n      final PsiMethod methodToReplaceIn = data.getMethodToReplaceIn();\n      new OldReferencesResolver(callExpression, newArg, methodToReplaceIn, data.getReplaceFieldsWithGetters(), initializer,\n                                signature, actualArgs, methodToReplaceIn.getParameterList().getParameters()).resolve();\n      ChangeContextUtil.clearContextInfo(initializer);\n    }\n\n    if (actualArgs == null) {\n      removeParamsFromUnresolvedCall(callExpression, data);\n    }\n    else {\n      removeParametersFromCall(actualArgs, data.getParametersToRemove());\n    }\n    return false;\n  }","id":72735,"modified_method":"public boolean processChangeMethodUsage(IntroduceParameterData data, UsageInfo usage, UsageInfo[] usages) throws IncorrectOperationException {\n    GrCall callExpression = GroovyRefactoringUtil.getCallExpressionByMethodReference(usage.getElement());\n    if (callExpression == null) return true;\n    GrArgumentList argList = callExpression.getArgumentList();\n    GrExpression[] oldArgs = argList.getExpressionArguments();\n\n    final GrExpression anchor;\n    if (!data.getMethodToSearchFor().isVarArgs()) {\n      anchor = getLast(oldArgs);\n    }\n    else {\n      final PsiParameter[] parameters = data.getMethodToSearchFor().getParameterList().getParameters();\n      if (parameters.length > oldArgs.length) {\n        anchor = getLast(oldArgs);\n      }\n      else {\n        final int lastNonVararg = parameters.length - 2;\n        anchor = lastNonVararg >= 0 ? oldArgs[lastNonVararg] : null;\n      }\n    }\n\n    PsiMethod method = PsiTreeUtil.getParentOfType(argList, PsiMethod.class);\n\n    GrClosureSignature signature = GrClosureSignatureUtil.createSignature(callExpression);\n    if (signature == null) signature = GrClosureSignatureUtil.createSignature(data.getMethodToSearchFor(), PsiSubstitutor.EMPTY);\n\n    final GrClosureSignatureUtil.ArgInfo<PsiElement>[] actualArgs =\n      GrClosureSignatureUtil.mapParametersToArguments(signature, argList, callExpression, callExpression.getClosureArguments(), true);\n\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(data.getProject());\n\n    if (method != null && IntroduceParameterUtil.isMethodInUsages(data, method, usages)) {\n      argList.addAfter(factory.createExpressionFromText(data.getParameterName()), anchor);\n    }\n    else {\n      final PsiElement _expr = data.getParameterInitializer().getExpression();\n      PsiElement initializer = ExpressionConverter.getExpression(_expr, GroovyFileType.GROOVY_LANGUAGE, data.getProject());\n      LOG.assertTrue(initializer instanceof GrExpression);\n\n      GrExpression newArg = addClosureToCall(initializer, argList);\n      if (newArg == null) {\n        newArg = (GrExpression)argList.addAfter(initializer, anchor);\n      }\n      final PsiMethod methodToReplaceIn = data.getMethodToReplaceIn();\n      new OldReferencesResolver(callExpression, newArg, methodToReplaceIn, data.getReplaceFieldsWithGetters(), initializer,\n                                signature, actualArgs, methodToReplaceIn.getParameterList().getParameters()).resolve();\n      ChangeContextUtil.clearContextInfo(initializer);\n      GrReferenceAdjuster.shortenReferences(newArg);\n    }\n\n    if (actualArgs == null) {\n      removeParamsFromUnresolvedCall(callExpression, data);\n    }\n    else {\n      removeParametersFromCall(actualArgs, data.getParametersToRemove());\n    }\n\n    if (argList.getAllArguments().length == 0 && hasClosureArgs(argList)) {\n      final GrArgumentList emptyArgList = ((GrMethodCallExpression)factory.createExpressionFromText(\"foo{}\")).getArgumentList();\n      LOG.assertTrue(emptyArgList != null);\n      argList.replace(emptyArgList);\n    }\n    return false;\n  }","commit_id":"2a80694895f4c7c09de0d7ff1d2fc5652125ee49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processChangeMethodSignature(IntroduceParameterData data, UsageInfo usage, UsageInfo[] usages) throws IncorrectOperationException {\n    if (!(usage.getElement() instanceof GrMethod) || !isGroovyUsage(usage)) return true;\n    GrMethod method = (GrMethod)usage.getElement();\n\n    final FieldConflictsResolver fieldConflictsResolver = new FieldConflictsResolver(data.getParameterName(), method.getBlock());\n    final MethodJavaDocHelper javaDocHelper = new MethodJavaDocHelper(method);\n    GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(method.getProject());\n\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    data.getParametersToRemove().forEachDescending(new TIntProcedure() {\n      public boolean execute(final int paramNum) {\n        try {\n          PsiParameter param = parameters[paramNum];\n          PsiDocTag tag = javaDocHelper.getTagForParameter(param);\n          if (tag != null) {\n            tag.delete();\n          }\n          param.delete();\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n        return true;\n      }\n    });\n\n    final PsiType forcedType = data.getForcedType();\n    final String typeText = forcedType.equalsToText(CommonClassNames.JAVA_LANG_OBJECT) ? null : forcedType.getCanonicalText();\n\n    GrParameter parameter = factory.createParameter(data.getParameterName(), typeText, method);\n    parameter.getModifierList().setModifierProperty(GrModifier.FINAL, data.isDeclareFinal());\n    final PsiParameter anchorParameter = getAnchorParameter(method);\n    final GrParameterList parameterList = method.getParameterList();\n    parameter = (GrParameter)parameterList.addAfter(parameter, anchorParameter);\n    GrReferenceAdjuster.shortenReferences(parameter);\n    final PsiDocTag tagForAnchorParameter = javaDocHelper.getTagForParameter(anchorParameter);\n    javaDocHelper.addParameterAfter(data.getParameterName(), tagForAnchorParameter);\n\n    fieldConflictsResolver.fix();\n\n    return false;\n\n  }","id":72736,"modified_method":"public boolean processChangeMethodSignature(IntroduceParameterData data, UsageInfo usage, UsageInfo[] usages) throws IncorrectOperationException {\n    if (!(usage.getElement() instanceof GrMethod) || !isGroovyUsage(usage)) return true;\n    GrMethod method = (GrMethod)usage.getElement();\n\n    final FieldConflictsResolver fieldConflictsResolver = new FieldConflictsResolver(data.getParameterName(), method.getBlock());\n    final MethodJavaDocHelper javaDocHelper = new MethodJavaDocHelper(method);\n    GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(method.getProject());\n\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    data.getParametersToRemove().forEachDescending(new TIntProcedure() {\n      public boolean execute(final int paramNum) {\n        try {\n          PsiParameter param = parameters[paramNum];\n          PsiDocTag tag = javaDocHelper.getTagForParameter(param);\n          if (tag != null) {\n            tag.delete();\n          }\n          param.delete();\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n        return true;\n      }\n    });\n\n    final PsiType forcedType = data.getForcedType();\n    final String typeText = forcedType.equalsToText(CommonClassNames.JAVA_LANG_OBJECT) ? null : forcedType.getCanonicalText();\n\n    GrParameter parameter = factory.createParameter(data.getParameterName(), typeText, method);\n    parameter.getModifierList().setModifierProperty(PsiModifier.FINAL, data.isDeclareFinal());\n    final PsiParameter anchorParameter = getAnchorParameter(method);\n    final GrParameterList parameterList = method.getParameterList();\n    parameter = (GrParameter)parameterList.addAfter(parameter, anchorParameter);\n    GrReferenceAdjuster.shortenReferences(parameter);\n    final PsiDocTag tagForAnchorParameter = javaDocHelper.getTagForParameter(anchorParameter);\n    javaDocHelper.addParameterAfter(data.getParameterName(), tagForAnchorParameter);\n\n    fieldConflictsResolver.fix();\n\n    return false;\n\n  }","commit_id":"2a80694895f4c7c09de0d7ff1d2fc5652125ee49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public static JetExpression deparenthesize(@NotNull JetExpression expression) {\n        JetExpression result = expression;\n        while (result instanceof JetParenthesizedExpression) {\n            result = ((JetParenthesizedExpression) expression).getExpression();\n        }\n        return result;\n    }","id":72737,"modified_method":"@Nullable\n    public static JetExpression deparenthesize(@NotNull JetExpression expression) {\n        if (expression instanceof JetBinaryExpressionWithTypeRHS) {\n            JetSimpleNameExpression operationSign = ((JetBinaryExpressionWithTypeRHS) expression).getOperationSign();\n            if (JetTokens.COLON.equals(operationSign.getReferencedNameElementType())) {\n                expression = ((JetBinaryExpressionWithTypeRHS) expression).getLeft();\n            }\n        }\n        else if (expression instanceof JetPrefixExpression) {\n            if (JetTokens.LABELS.contains(((JetPrefixExpression) expression).getOperationSign().getReferencedNameElementType())) {\n                JetExpression baseExpression = ((JetPrefixExpression) expression).getBaseExpression();\n                if (baseExpression != null) {\n                    expression = baseExpression;\n                }\n            }\n        }\n        if (expression instanceof JetParenthesizedExpression) {\n            JetExpression innerExpression = ((JetParenthesizedExpression) expression).getExpression();\n            return innerExpression != null ? deparenthesize(innerExpression) : null;\n        }\n        return expression;\n    }","commit_id":"05f1db20cedfdbb34be77b6128f1529021aae723","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ModelCreator(List<String> inputPaths, Transformer<Object, ? super Map<String, Object>> creator) {\n        this.inputPaths = inputPaths;\n        this.creator = creator;\n    }","id":72738,"modified_method":"public ModelCreator(Set<String> inputPaths, Transformer<Object, ? super Map<String, Object>> creator) {\n        this.inputPaths = inputPaths;\n        this.creator = creator;\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"public List<String> getInputPaths() {\n        return inputPaths;\n    }","id":72739,"modified_method":"public Set<String> getInputPaths() {\n        return inputPaths;\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"public static ModelCreator of(Object object) {\n        return new ModelCreator(ImmutableList.<String>of(), Transformers.constant(object));\n    }","id":72740,"modified_method":"public static ModelCreator of(Object object) {\n        return new ModelCreator(ImmutableSet.<String>of(), Transformers.constant(object));\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"void addCreator(String path, final Closure creatorClosure, List<String> inputPaths) {\n        Transformer<Object, Map<String, Object>> closureBackedCreator = new Transformer<Object, Map<String, Object>>() {\n            public Object transform(Map<String, Object> inputs) {\n                return creatorClosure.call(inputs);\n            }\n        };\n        registry.create(ModelPath.path(path), new ModelCreator(inputPaths, closureBackedCreator));\n    }","id":72741,"modified_method":"void addCreator(String path, final Closure creatorClosure, List<String> inputPaths) {\n        registry.create(ModelPath.path(path), ModelCreators.resultOf(creatorClosure, ImmutableSet.<String>builder().addAll(inputPaths).build()));\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"private MethodCallExpression rewriteReferenceStatement(String path) {\n        Parameter it = new Parameter(ClassHelper.DYNAMIC_TYPE, \"it\");\n        it.setOriginType(ClassHelper.OBJECT_TYPE);\n        VariableExpression subject = new VariableExpression(it);\n        ArgumentListExpression arguments = new ArgumentListExpression(new ConstantExpression(path));\n        return new MethodCallExpression(subject, \"getAt\", arguments);\n    }","id":72742,"modified_method":"private MethodCallExpression rewriteReferenceStatement(String path) {\n        referencedPaths.add(path);\n\n        Parameter it = new Parameter(ClassHelper.DYNAMIC_TYPE, \"it\");\n        it.setOriginType(ClassHelper.OBJECT_TYPE);\n        VariableExpression subject = new VariableExpression(it);\n        ArgumentListExpression arguments = new ArgumentListExpression(new ConstantExpression(path));\n        return new MethodCallExpression(subject, \"getAt\", arguments);\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"private Expression rewrittenOrOriginal(Expression expression) {\n        Expression rewritten = expression.getNodeMetaData(AST_NODE_REWRITE_KEY);\n        return rewritten != null ? rewritten : expression;\n    }","id":72743,"modified_method":"private Expression rewrittenOrOriginal(Expression expression) {\n        String referencePath = expression.getNodeMetaData(AST_NODE_REFERENCE_PATH_KEY);\n\n        return referencePath != null ? rewriteReferenceStatement(referencePath) : expression;\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"public void visitPropertyExpression(PropertyExpression expression) {\n        boolean topLevel = referenceStack.isEmpty();\n        referenceStack.push(expression.getPropertyAsString());\n        expression.getObjectExpression().visit(this);\n        if (topLevel) {\n            if (referenceEncountered) {\n                String path = CollectionUtils.join(\".\", referenceStack);\n                referencedPaths.add(path);\n                expression.setNodeMetaData(AST_NODE_REWRITE_KEY, rewriteReferenceStatement(path));\n                referenceStack.clear();\n            }\n            referenceEncountered = false;\n        }\n    }","id":72744,"modified_method":"public void visitPropertyExpression(PropertyExpression expression) {\n        boolean topLevel = referenceStack.isEmpty();\n        referenceStack.push(expression.getPropertyAsString());\n        expression.getObjectExpression().visit(this);\n        if (topLevel) {\n            if (referenceEncountered) {\n                String path = CollectionUtils.join(\".\", referenceStack);\n                expression.setNodeMetaData(AST_NODE_REFERENCE_PATH_KEY, path);\n                referenceStack.clear();\n            }\n            referenceEncountered = false;\n        }\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitVariableExpression(VariableExpression expression) {\n        if (expression.getName().equals(\"$\")) {\n            referenceEncountered = true;\n        }\n    }","id":72745,"modified_method":"@Override\n    public void visitVariableExpression(VariableExpression expression) {\n        String name = expression.getName();\n        if (name.equals(\"$\")) {\n            referenceEncountered = true;\n        } else {\n            String path = referenceAliases.get(name);\n            if (path != null) {\n                referenceStack.push(path);\n                referenceEncountered = true;\n            }\n        }\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitExpressionStatement(ExpressionStatement statement) {\n        super.visitExpressionStatement(statement);\n        statement.setExpression(rewrittenOrOriginal(statement.getExpression()));\n    }","id":72746,"modified_method":"@Override\n    public void visitExpressionStatement(ExpressionStatement statement) {\n        super.visitExpressionStatement(statement);\n        Expression expression = statement.getExpression();\n        Boolean shouldRemoveExpression = expression.getNodeMetaData(AST_NODE_REMOVE_KEY);\n        if (shouldRemoveExpression != null && shouldRemoveExpression) {\n            statement.setExpression(new EmptyExpression());\n        } else {\n            statement.setExpression(rewrittenOrOriginal(expression));\n        }\n    }","commit_id":"262615c44a227138a77af6ee4837e6f965414bb7","url":"https://github.com/gradle/gradle"},{"original_method":"private Expression createMaxRequestsPerPeriodExpression(RouteContext routeContext) {\n        if (getExpression() != null) {\n            if (ObjectHelper.isNotEmpty(getExpression().getExpression()) || getExpression().getExpressionValue() != null) {\n                return getExpression().createExpression(routeContext);\n            } \n        } \n        return null;\n    }","id":72747,"modified_method":"private Expression createMaxRequestsPerPeriodExpression(RouteContext routeContext) {\n        ExpressionDefinition expr = getExpression();\n        if (expr != null) {\n            return expr.createExpression(routeContext);\n        }\n        return null;\n    }","commit_id":"c22c91e8d4876413ca52ed543e88d8c6bdf122c6","url":"https://github.com/apache/camel"},{"original_method":"private void createUIComponents() {\n    myJavaVisibilityPanel = new JavaVisibilityPanel(false, true);\n    if (myContext.getExpression() == null) {\n      myTypeCombo = GrTypeComboBox.createTypeComboBoxWithDefType(myContext.getVar().getDeclaredType()\n      );\n    }\n    else {\n      myTypeCombo = GrTypeComboBox.createTypeComboBoxFromExpression(myContext.getExpression());\n    }\n\n    List<String> names = new ArrayList<String>();\n    final GrVariable var = myContext.getVar();\n    if (var != null) {\n      names.add(var.getName());\n    }\n    String[] possibleNames = GroovyNameSuggestionUtil.suggestVariableNames(myContext.getExpression(), new GroovyVariableValidator(myContext), true);\n    ContainerUtil.addAll(names, possibleNames);\n\n    myNameField = new NameSuggestionsField(ArrayUtil.toStringArray(names), myContext.getProject(), GroovyFileType.GROOVY_FILE_TYPE);\n\n    GrTypeComboBox.registerUpDownHint(myNameField, myTypeCombo);\n  }","id":72748,"modified_method":"private void createUIComponents() {\n    myJavaVisibilityPanel = new JavaVisibilityPanel(false, true);\n\n    final GrVariable var = myContext.getVar();\n    final GrExpression expression = myContext.getExpression();\n    if (expression == null) {\n      assert var != null;\n      myTypeCombo = GrTypeComboBox.createTypeComboBoxWithDefType(var.getDeclaredType());\n    }\n    else {\n      myTypeCombo = GrTypeComboBox.createTypeComboBoxFromExpression(expression);\n    }\n\n    List<String> names = new ArrayList<String>();\n    if (var != null) {\n      names.add(var.getName());\n    }\n    if (expression != null) {\n      String[] possibleNames = GroovyNameSuggestionUtil.suggestVariableNames(expression, new GroovyVariableValidator(myContext), true);\n      ContainerUtil.addAll(names, possibleNames);\n    }\n\n    myNameField = new NameSuggestionsField(ArrayUtil.toStringArray(names), myContext.getProject(), GroovyFileType.GROOVY_FILE_TYPE);\n\n    GrTypeComboBox.registerUpDownHint(myNameField, myTypeCombo);\n  }","commit_id":"d2c89b7327d1017309de1f52159683b521cda1eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public ClassDescriptor resolveClassDescriptor(@NotNull JetScope scope, @NotNull JetClass classElement) {\n        ClassDescriptorImpl classDescriptor = new ClassDescriptorImpl(\n                scope.getContainingDeclaration(),\n                AttributeResolver.INSTANCE.resolveAttributes(classElement.getModifierList()),\n                safeName(classElement.getName()));\n\n        trace.recordDeclarationResolution(classElement, classDescriptor);\n\n        WritableScope parameterScope = semanticServices.createWritableScope(scope, classDescriptor);\n\n        // This call has side-effects on the parameterScope (fills it in)\n        List<TypeParameterDescriptor> typeParameters\n                = resolveTypeParameters(classDescriptor, parameterScope, classElement.getTypeParameters());\n\n        List<JetDelegationSpecifier> delegationSpecifiers = classElement.getDelegationSpecifiers();\n        // TODO : assuming that the hierarchy is acyclic\n        Collection<? extends JetType> superclasses = delegationSpecifiers.isEmpty()\n                ? Collections.singleton(JetStandardClasses.getAnyType())\n                : resolveTypes(parameterScope, delegationSpecifiers);\n        boolean open = classElement.hasModifier(JetTokens.OPEN_KEYWORD);\n        WritableScope members = resolveMembers(classDescriptor, classElement, typeParameters, scope, parameterScope, superclasses);\n\n        WritableFunctionGroup constructors = new WritableFunctionGroup(\"<init>\");\n        for (JetConstructor constructor : classElement.getSecondaryConstructors()) {\n            constructors.addFunction(resolveConstructorDescriptor(members, classDescriptor, constructor, false));\n        }\n        ConstructorDescriptor primaryConstructorDescriptor = resolvePrimaryConstructor(scope, classDescriptor, classElement);\n        if (primaryConstructorDescriptor != null) {\n            constructors.addFunction(primaryConstructorDescriptor);\n        }\n        return classDescriptor.initialize(\n                !open,\n                typeParameters,\n                superclasses,\n                members,\n                constructors\n        );\n    }","id":72749,"modified_method":"@Nullable\n    public ClassDescriptor resolveClassDescriptor(@NotNull JetScope scope, @NotNull JetClass classElement) {\n        ClassDescriptorImpl classDescriptor = new ClassDescriptorImpl(\n                scope.getContainingDeclaration(),\n                AttributeResolver.INSTANCE.resolveAttributes(classElement.getModifierList()),\n                JetPsiUtil.safeName(classElement.getName()));\n\n        trace.recordDeclarationResolution(classElement, classDescriptor);\n\n        WritableScope parameterScope = semanticServices.createWritableScope(scope, classDescriptor);\n\n        // This call has side-effects on the parameterScope (fills it in)\n        List<TypeParameterDescriptor> typeParameters\n                = resolveTypeParameters(classDescriptor, parameterScope, classElement.getTypeParameters());\n\n        List<JetDelegationSpecifier> delegationSpecifiers = classElement.getDelegationSpecifiers();\n        // TODO : assuming that the hierarchy is acyclic\n        Collection<? extends JetType> superclasses = delegationSpecifiers.isEmpty()\n                ? Collections.singleton(JetStandardClasses.getAnyType())\n                : resolveTypes(parameterScope, delegationSpecifiers);\n        boolean open = classElement.hasModifier(JetTokens.OPEN_KEYWORD);\n        WritableScope members = resolveMembers(classDescriptor, classElement, typeParameters, scope, parameterScope, superclasses);\n\n        WritableFunctionGroup constructors = new WritableFunctionGroup(\"<init>\");\n        for (JetConstructor constructor : classElement.getSecondaryConstructors()) {\n            constructors.addFunction(resolveConstructorDescriptor(members, classDescriptor, constructor, false));\n        }\n        ConstructorDescriptor primaryConstructorDescriptor = resolvePrimaryConstructor(scope, classDescriptor, classElement);\n        if (primaryConstructorDescriptor != null) {\n            constructors.addFunction(primaryConstructorDescriptor);\n        }\n        return classDescriptor.initialize(\n                !open,\n                typeParameters,\n                superclasses,\n                members,\n                constructors\n        );\n    }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public FunctionDescriptor resolveFunctionDescriptor(DeclarationDescriptor containingDescriptor, JetScope scope, JetFunction function) {\n        FunctionDescriptorImpl functionDescriptor = new FunctionDescriptorImpl(\n                containingDescriptor,\n                AttributeResolver.INSTANCE.resolveAttributes(function.getModifierList()),\n                safeName(function.getName())\n        );\n        WritableScope innerScope = semanticServices.createWritableScope(scope, functionDescriptor);\n        innerScope.addLabeledDeclaration(functionDescriptor);\n\n        // The two calls below have side-effects on parameterScope\n        List<TypeParameterDescriptor> typeParameterDescriptors = resolveTypeParameters(functionDescriptor, innerScope, function.getTypeParameters());\n        List<ValueParameterDescriptor> valueParameterDescriptors = resolveValueParameters(functionDescriptor, innerScope, function.getValueParameters());\n\n        JetType returnType;\n        JetTypeReference returnTypeRef = function.getReturnTypeRef();\n        JetExpression bodyExpression = function.getBodyExpression();\n        if (returnTypeRef != null) {\n            returnType = typeResolver.resolveType(innerScope, returnTypeRef);\n            // TODO : check body type, consider recursion\n            if (bodyExpression != null) {\n                semanticServices.getTypeInferrer(trace).getType(innerScope, bodyExpression, function.hasBlockBody());\n            }\n        } else {\n            if (bodyExpression == null) {\n                semanticServices.getErrorHandler().genericError(function.getNode(), \"This function must either declare a return type or have a body element\");\n                returnType = ErrorUtils.createErrorType(\"No type, no body\");\n            } else {\n                // TODO : Recursion possible\n                returnType = semanticServices.getTypeInferrer(trace).safeGetType(innerScope, bodyExpression, function.hasBlockBody());\n            }\n        }\n\n        functionDescriptor.initialize(\n                typeParameterDescriptors,\n                valueParameterDescriptors,\n                returnType);\n\n        trace.recordDeclarationResolution(function, functionDescriptor);\n        return functionDescriptor;\n    }","id":72750,"modified_method":"@NotNull\n    public FunctionDescriptor resolveFunctionDescriptor(DeclarationDescriptor containingDescriptor, JetScope scope, JetFunction function) {\n        FunctionDescriptorImpl functionDescriptor = new FunctionDescriptorImpl(\n                containingDescriptor,\n                AttributeResolver.INSTANCE.resolveAttributes(function.getModifierList()),\n                JetPsiUtil.safeName(function.getName())\n        );\n        WritableScope innerScope = semanticServices.createWritableScope(scope, functionDescriptor);\n        innerScope.addLabeledDeclaration(functionDescriptor);\n\n        // The two calls below have side-effects on parameterScope\n        List<TypeParameterDescriptor> typeParameterDescriptors = resolveTypeParameters(functionDescriptor, innerScope, function.getTypeParameters());\n        List<ValueParameterDescriptor> valueParameterDescriptors = resolveValueParameters(functionDescriptor, innerScope, function.getValueParameters());\n\n        JetType returnType;\n        JetTypeReference returnTypeRef = function.getReturnTypeRef();\n        JetExpression bodyExpression = function.getBodyExpression();\n        if (returnTypeRef != null) {\n            returnType = typeResolver.resolveType(innerScope, returnTypeRef);\n            // TODO : check body type, consider recursion\n            if (bodyExpression != null) {\n                semanticServices.getTypeInferrer(trace).getType(innerScope, bodyExpression, function.hasBlockBody());\n            }\n        } else {\n            if (bodyExpression == null) {\n                semanticServices.getErrorHandler().genericError(function.getNode(), \"This function must either declare a return type or have a body element\");\n                returnType = ErrorUtils.createErrorType(\"No type, no body\");\n            } else {\n                // TODO : Recursion possible\n                returnType = semanticServices.getTypeInferrer(trace).safeGetType(innerScope, bodyExpression, function.hasBlockBody());\n            }\n        }\n\n        functionDescriptor.initialize(\n                typeParameterDescriptors,\n                valueParameterDescriptors,\n                returnType);\n\n        trace.recordDeclarationResolution(function, functionDescriptor);\n        return functionDescriptor;\n    }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public PropertyDescriptor resolvePropertyDescriptor(@NotNull DeclarationDescriptor containingDeclaration, @NotNull JetScope scope, JetProperty property) {\n        // TODO : receiver?\n        JetTypeReference propertyTypeRef = property.getPropertyTypeRef();\n\n        JetType type;\n        if (propertyTypeRef == null) {\n            JetExpression initializer = property.getInitializer();\n            if (initializer == null) {\n                semanticServices.getErrorHandler().genericError(property.getNode(), \"This property must either have a type annotation or be initialized\");\n                type = ErrorUtils.createErrorType(\"No type, no body\");\n            } else {\n                // TODO : ??? Fix-point here: what if we have something like \"val a = foo {a.bar()}\"\n                type = semanticServices.getTypeInferrer(trace).getType(scope, initializer, false);\n            }\n        } else {\n            type = typeResolver.resolveType(scope, propertyTypeRef);\n        }\n\n        PropertyDescriptorImpl propertyDescriptor = new PropertyDescriptorImpl(\n                containingDeclaration,\n                AttributeResolver.INSTANCE.resolveAttributes(property.getModifierList()),\n                safeName(property.getName()),\n                property.isVar() ? type : null,\n                type);\n        trace.recordDeclarationResolution(property, propertyDescriptor);\n        return propertyDescriptor;\n    }","id":72751,"modified_method":"public PropertyDescriptor resolvePropertyDescriptor(@NotNull DeclarationDescriptor containingDeclaration, @NotNull JetScope scope, JetProperty property) {\n        // TODO : receiver?\n        JetTypeReference propertyTypeRef = property.getPropertyTypeRef();\n\n        JetType type;\n        if (propertyTypeRef == null) {\n            JetExpression initializer = property.getInitializer();\n            if (initializer == null) {\n                semanticServices.getErrorHandler().genericError(property.getNode(), \"This property must either have a type annotation or be initialized\");\n                type = ErrorUtils.createErrorType(\"No type, no body\");\n            } else {\n                // TODO : ??? Fix-point here: what if we have something like \"val a = foo {a.bar()}\"\n                type = semanticServices.getTypeInferrer(trace).getType(scope, initializer, false);\n            }\n        } else {\n            type = typeResolver.resolveType(scope, propertyTypeRef);\n        }\n\n        PropertyDescriptorImpl propertyDescriptor = new PropertyDescriptorImpl(\n                containingDeclaration,\n                AttributeResolver.INSTANCE.resolveAttributes(property.getModifierList()),\n                JetPsiUtil.safeName(property.getName()),\n                property.isVar() ? type : null,\n                type);\n        trace.recordDeclarationResolution(property, propertyDescriptor);\n        return propertyDescriptor;\n    }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public PropertyDescriptor resolveValueParameterDescriptor(@NotNull DeclarationDescriptor containingDeclaration, @NotNull JetParameter parameter, @NotNull JetType type) {\n        PropertyDescriptor propertyDescriptor = new PropertyDescriptorImpl(\n                containingDeclaration,\n                AttributeResolver.INSTANCE.resolveAttributes(parameter.getModifierList()),\n                safeName(parameter.getName()),\n                parameter.isMutable() ? null : type,\n                type);\n        trace.recordDeclarationResolution(parameter, propertyDescriptor);\n        return propertyDescriptor;\n    }","id":72752,"modified_method":"public PropertyDescriptor resolveValueParameterDescriptor(@NotNull DeclarationDescriptor containingDeclaration, @NotNull JetParameter parameter, @NotNull JetType type) {\n        PropertyDescriptor propertyDescriptor = new PropertyDescriptorImpl(\n                containingDeclaration,\n                AttributeResolver.INSTANCE.resolveAttributes(parameter.getModifierList()),\n                JetPsiUtil.safeName(parameter.getName()),\n                parameter.isMutable() ? null : type,\n                type);\n        trace.recordDeclarationResolution(parameter, propertyDescriptor);\n        return propertyDescriptor;\n    }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private TypeParameterDescriptor resolveTypeParameter(DeclarationDescriptor containingDescriptor, WritableScope extensibleScope, JetTypeParameter typeParameter) {\n        // TODO: other bounds from where-clause\n        JetTypeReference extendsBound = typeParameter.getExtendsBound();\n        JetType bound = extendsBound == null\n                ? JetStandardClasses.getDefaultBound()\n                : typeResolver.resolveType(extensibleScope, extendsBound);\n        TypeParameterDescriptor typeParameterDescriptor = new TypeParameterDescriptor(\n                containingDescriptor,\n                AttributeResolver.INSTANCE.resolveAttributes(typeParameter.getModifierList()),\n                typeParameter.getVariance(),\n                safeName(typeParameter.getName()),\n                Collections.singleton(bound),\n                bound\n        );\n        extensibleScope.addTypeParameterDescriptor(typeParameterDescriptor);\n        trace.recordDeclarationResolution(typeParameter, typeParameterDescriptor);\n        return typeParameterDescriptor;\n    }","id":72753,"modified_method":"private TypeParameterDescriptor resolveTypeParameter(DeclarationDescriptor containingDescriptor, WritableScope extensibleScope, JetTypeParameter typeParameter) {\n        // TODO: other bounds from where-clause\n        JetTypeReference extendsBound = typeParameter.getExtendsBound();\n        JetType bound = extendsBound == null\n                ? JetStandardClasses.getDefaultBound()\n                : typeResolver.resolveType(extensibleScope, extendsBound);\n        TypeParameterDescriptor typeParameterDescriptor = new TypeParameterDescriptor(\n                containingDescriptor,\n                AttributeResolver.INSTANCE.resolveAttributes(typeParameter.getModifierList()),\n                typeParameter.getVariance(),\n                JetPsiUtil.safeName(typeParameter.getName()),\n                Collections.singleton(bound),\n                bound\n        );\n        extensibleScope.addTypeParameterDescriptor(typeParameterDescriptor);\n        trace.recordDeclarationResolution(typeParameter, typeParameterDescriptor);\n        return typeParameterDescriptor;\n    }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private List<ValueParameterDescriptor> resolveValueParameters(FunctionDescriptorImpl functionDescriptor, WritableScope parameterScope, List<JetParameter> valueParameters) {\n        List<ValueParameterDescriptor> result = new ArrayList<ValueParameterDescriptor>();\n        for (int i = 0, valueParametersSize = valueParameters.size(); i < valueParametersSize; i++) {\n            JetParameter valueParameter = valueParameters.get(i);\n            JetTypeReference typeReference = valueParameter.getTypeReference();\n\n            ASTNode valOrVarNode = valueParameter.getValOrVarNode();\n            if (valueParameter.isRef() && valOrVarNode != null) {\n                semanticServices.getErrorHandler().genericError(valOrVarNode, \"'val' and 'var' are not allowed on ref-parameters\");\n            }\n\n            JetType type;\n            if (typeReference == null) {\n                semanticServices.getErrorHandler().genericError(valueParameter.getNode(), \"A type annotation is required on a value parameter\");\n                type = ErrorUtils.createErrorType(\"Type annotation was missing\");\n            } else {\n                type = typeResolver.resolveType(parameterScope, typeReference);\n            }\n            ValueParameterDescriptor valueParameterDescriptor = new ValueParameterDescriptorImpl(\n                    functionDescriptor,\n                    i,\n                    AttributeResolver.INSTANCE.resolveAttributes(valueParameter.getModifierList()),\n                    safeName(valueParameter.getName()),\n                    valueParameter.isMutable() ? type : null,\n                    type,\n                    valueParameter.getDefaultValue() != null,\n                    false // TODO : varargs\n            );\n            // TODO : Default values???\n\n            result.add(valueParameterDescriptor);\n            trace.recordDeclarationResolution(valueParameter, valueParameterDescriptor);\n            parameterScope.addPropertyDescriptor(valueParameterDescriptor);\n        }\n        return result;\n    }","id":72754,"modified_method":"private List<ValueParameterDescriptor> resolveValueParameters(FunctionDescriptorImpl functionDescriptor, WritableScope parameterScope, List<JetParameter> valueParameters) {\n        List<ValueParameterDescriptor> result = new ArrayList<ValueParameterDescriptor>();\n        for (int i = 0, valueParametersSize = valueParameters.size(); i < valueParametersSize; i++) {\n            JetParameter valueParameter = valueParameters.get(i);\n            JetTypeReference typeReference = valueParameter.getTypeReference();\n\n            ASTNode valOrVarNode = valueParameter.getValOrVarNode();\n            if (valueParameter.isRef() && valOrVarNode != null) {\n                semanticServices.getErrorHandler().genericError(valOrVarNode, \"'val' and 'var' are not allowed on ref-parameters\");\n            }\n\n            JetType type;\n            if (typeReference == null) {\n                semanticServices.getErrorHandler().genericError(valueParameter.getNode(), \"A type annotation is required on a value parameter\");\n                type = ErrorUtils.createErrorType(\"Type annotation was missing\");\n            } else {\n                type = typeResolver.resolveType(parameterScope, typeReference);\n            }\n            ValueParameterDescriptor valueParameterDescriptor = new ValueParameterDescriptorImpl(\n                    functionDescriptor,\n                    i,\n                    AttributeResolver.INSTANCE.resolveAttributes(valueParameter.getModifierList()),\n                    JetPsiUtil.safeName(valueParameter.getName()),\n                    valueParameter.isMutable() ? type : null,\n                    type,\n                    valueParameter.getDefaultValue() != null,\n                    false // TODO : varargs\n            );\n            // TODO : Default values???\n\n            result.add(valueParameterDescriptor);\n            trace.recordDeclarationResolution(valueParameter, valueParameterDescriptor);\n            parameterScope.addPropertyDescriptor(valueParameterDescriptor);\n        }\n        return result;\n    }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void resolveMutableClassDescriptor(@NotNull JetScope scope, @NotNull JetClass classElement, @NotNull MutableClassDescriptor descriptor) {\n        descriptor.setName(classElement.getName());\n        descriptor.getClassHeaderScope().addLabeledDeclaration(descriptor);\n\n        WritableScope parameterScope = descriptor.getClassHeaderScope();\n\n        // This call has side-effects on the parameterScope (fills it in)\n        List<TypeParameterDescriptor> typeParameters\n                = resolveTypeParameters(descriptor, parameterScope, classElement.getTypeParameters());\n\n        boolean open = classElement.hasModifier(JetTokens.OPEN_KEYWORD);\n        List<JetType> supertypes = new ArrayList<JetType>();\n        TypeConstructorImpl typeConstructor = new TypeConstructorImpl(\n                descriptor,\n                AttributeResolver.INSTANCE.resolveAttributes(classElement.getModifierList()),\n                !open,\n                safeName(classElement.getName()),\n                typeParameters,\n                supertypes);\n        descriptor.setTypeConstructor(\n                typeConstructor\n        );\n\n        List<JetDelegationSpecifier> delegationSpecifiers = classElement.getDelegationSpecifiers();\n        // TODO : assuming that the hierarchy is acyclic\n        Collection<? extends JetType> superclasses = delegationSpecifiers.isEmpty()\n                ? Collections.singleton(JetStandardClasses.getAnyType())\n                : resolveTypes(parameterScope, delegationSpecifiers);\n\n        // TODO : UGLY HACK\n        supertypes.addAll(superclasses);\n\n\n        // TODO : importing may be a bad idea\n        for (JetType supertype : superclasses) {\n            assert supertype != null : classElement.getName();\n            parameterScope.importScope(supertype.getMemberScope());\n        }\n\n        descriptor.getClassHeaderScope().setThisType(descriptor.getDefaultType());\n\n        trace.recordDeclarationResolution(classElement, descriptor);\n    }","id":72755,"modified_method":"public void resolveMutableClassDescriptor(@NotNull JetScope scope, @NotNull JetClass classElement, @NotNull MutableClassDescriptor descriptor) {\n        descriptor.setName(classElement.getName());\n        descriptor.getClassHeaderScope().addLabeledDeclaration(descriptor);\n\n        WritableScope parameterScope = descriptor.getClassHeaderScope();\n\n        // This call has side-effects on the parameterScope (fills it in)\n        List<TypeParameterDescriptor> typeParameters\n                = resolveTypeParameters(descriptor, parameterScope, classElement.getTypeParameters());\n\n        boolean open = classElement.hasModifier(JetTokens.OPEN_KEYWORD);\n        List<JetType> supertypes = new ArrayList<JetType>();\n        TypeConstructorImpl typeConstructor = new TypeConstructorImpl(\n                descriptor,\n                AttributeResolver.INSTANCE.resolveAttributes(classElement.getModifierList()),\n                !open,\n                JetPsiUtil.safeName(classElement.getName()),\n                typeParameters,\n                supertypes);\n        descriptor.setTypeConstructor(\n                typeConstructor\n        );\n\n        List<JetDelegationSpecifier> delegationSpecifiers = classElement.getDelegationSpecifiers();\n        // TODO : assuming that the hierarchy is acyclic\n        Collection<? extends JetType> superclasses = delegationSpecifiers.isEmpty()\n                ? Collections.singleton(JetStandardClasses.getAnyType())\n                : resolveTypes(parameterScope, delegationSpecifiers);\n\n        // TODO : UGLY HACK\n        supertypes.addAll(superclasses);\n\n\n        // TODO : importing may be a bad idea\n        for (JetType supertype : superclasses) {\n            assert supertype != null : classElement.getName();\n            parameterScope.importScope(supertype.getMemberScope());\n        }\n\n        descriptor.getClassHeaderScope().setThisType(descriptor.getDefaultType());\n\n        trace.recordDeclarationResolution(classElement, descriptor);\n    }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public void visitBinaryExpression(JetBinaryExpression expression) {\n            IElementType operationType = expression.getOperationReference().getReferencedNameElementType();\n            if (operationType == JetTokens.ANDAND) {\n                value(expression.getLeft(), false);\n                Label resultLabel = builder.createUnboundLabel();\n                builder.jumpOnFalse(resultLabel);\n                value(expression.getRight(), false);\n                builder.bindLabel(resultLabel);\n            }\n            else if (operationType == JetTokens.OROR) {\n                value(expression.getLeft(), false);\n                Label resultLabel = builder.createUnboundLabel();\n                builder.jumpOnTrue(resultLabel);\n                value(expression.getRight(), false);\n                builder.bindLabel(resultLabel);\n            }\n            else {\n                value(expression.getLeft(), false);\n                value(expression.getRight(), false);\n                builder.readNode(expression);\n            }\n        }","id":72756,"modified_method":"@Override\n        public void visitBinaryExpression(JetBinaryExpression expression) {\n            IElementType operationType = expression.getOperationReference().getReferencedNameElementType();\n            JetExpression right = expression.getRight();\n            if (operationType == JetTokens.ANDAND) {\n                value(expression.getLeft(), false);\n                Label resultLabel = builder.createUnboundLabel();\n                builder.jumpOnFalse(resultLabel);\n                if (right != null) {\n                    value(right, false);\n                }\n                builder.bindLabel(resultLabel);\n            }\n            else if (operationType == JetTokens.OROR) {\n                value(expression.getLeft(), false);\n                Label resultLabel = builder.createUnboundLabel();\n                builder.jumpOnTrue(resultLabel);\n                if (right != null) {\n                    value(right, false);\n                }\n                builder.bindLabel(resultLabel);\n            }\n            else {\n                value(expression.getLeft(), false);\n                if (right != null) {\n                    value(right, false);\n                }\n                builder.readNode(expression);\n            }\n        }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public void visitUnaryExpression(JetUnaryExpression expression) {\n            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();\n            if (JetTokens.LABELS.contains(operationType)) {\n                visitLabeledExpression(expression.getOperationSign().getReferencedName().substring(1), expression.getBaseExpression());\n            }\n            else {\n                visitElement(expression);\n            }\n        }","id":72757,"modified_method":"@Override\n        public void visitUnaryExpression(JetUnaryExpression expression) {\n            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();\n            if (JetTokens.LABELS.contains(operationType)) {\n                String referencedName = expression.getOperationSign().getReferencedName();\n                referencedName = referencedName == null ? \" <?>\" : referencedName;\n                visitLabeledExpression(referencedName.substring(1), expression.getBaseExpression());\n            }\n            else {\n                visitElement(expression);\n            }\n        }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public void visitParenthesizedExpression(JetParenthesizedExpression expression) {\n            value(expression.getExpression(), false);\n        }","id":72758,"modified_method":"@Override\n        public void visitParenthesizedExpression(JetParenthesizedExpression expression) {\n            JetExpression innerExpression = expression.getExpression();\n            if (innerExpression != null) {\n                value(innerExpression, false);\n            }\n        }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void generateSubroutineControlFlow(@NotNull JetElement subroutineElement, @NotNull List<? extends JetElement> body, boolean preferBlocks) {\n        if (subroutineElement instanceof JetNamedDeclaration) {\n            JetNamedDeclaration namedDeclaration = (JetNamedDeclaration) subroutineElement;\n            enterLabeledElement(namedDeclaration.getName(), namedDeclaration);\n        }\n        boolean functionLiteral = subroutineElement instanceof JetFunctionLiteralExpression;\n        builder.enterSubroutine(subroutineElement, functionLiteral);\n        for (JetElement statement : body) {\n            statement.accept(new CFPVisitor(preferBlocks));\n        }\n        builder.exitSubroutine(subroutineElement, functionLiteral);\n    }","id":72759,"modified_method":"public void generateSubroutineControlFlow(@NotNull JetElement subroutineElement, @NotNull List<? extends JetElement> body, boolean preferBlocks) {\n        if (subroutineElement instanceof JetNamedDeclaration) {\n            JetNamedDeclaration namedDeclaration = (JetNamedDeclaration) subroutineElement;\n            enterLabeledElement(JetPsiUtil.safeName(namedDeclaration.getName()), namedDeclaration);\n        }\n        boolean functionLiteral = subroutineElement instanceof JetFunctionLiteralExpression;\n        builder.enterSubroutine(subroutineElement, functionLiteral);\n        for (JetElement statement : body) {\n            statement.accept(new CFPVisitor(preferBlocks));\n        }\n        builder.exitSubroutine(subroutineElement, functionLiteral);\n    }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public void visitLabelQualifiedExpression(JetLabelQualifiedExpression expression) {\n            String labelName = expression.getLabelName();\n            JetExpression labeledExpression = expression.getLabeledExpression();\n            visitLabeledExpression(labelName, labeledExpression);\n        }","id":72760,"modified_method":"@Override\n        public void visitLabelQualifiedExpression(JetLabelQualifiedExpression expression) {\n            String labelName = expression.getLabelName();\n            JetExpression labeledExpression = expression.getLabeledExpression();\n            if (labelName != null && labeledExpression != null) {\n                visitLabeledExpression(labelName, labeledExpression);\n            }\n        }","commit_id":"d4d9ac7b8eb8c7f45f0c6fb65d872a323a1ab721","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private Map getPluginConfigurationFromExpressions( MojoDescriptor goal, PlexusConfiguration configuration,\n                                                       MavenSession session )\n        throws PluginConfigurationException\n    {\n        List parameters = goal.getParameters();\n\n        Map map = new HashMap();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            String key = parameter.getName();\n\n            if ( configuration.getChild( key, false ) == null )\n            {\n                String expression = parameter.getExpression();\n\n                Object value = PluginParameterExpressionEvaluator.evaluate( expression, session );\n\n                getLogger().debug( \"Evaluated mojo parameter expression: \\'\" + expression + \"\\' to: \" + value );\n\n                if ( value == null )\n                {\n                    if ( parameter.getDefaultValue() != null )\n                    {\n                        value = PluginParameterExpressionEvaluator.evaluate( parameter.getDefaultValue(), session );\n                    }\n                }\n\n                // ----------------------------------------------------------------------\n                // We will perform a basic check here for parameters values that are\n                // required. Required parameters can't be null so we throw an\n                // Exception in the case where they are. We probably want some\n                // pluggable\n                // mechanism here but this will catch the most obvious of\n                // misconfigurations.\n                // ----------------------------------------------------------------------\n\n                if ( value == null && parameter.isRequired() )\n                {\n                    throw new PluginConfigurationException( createPluginParameterRequiredMessage( goal, parameter ) );\n                }\n\n                String type = parameter.getType();\n\n                // TODO: Not sure how we might find files that are nested in other objects... perhaps\n                //  we add a \"needs translation\" to the mojo so such types can be translated (implementing some interface) and\n                //  address their own file objects\n                if ( type != null && ( type.equals( \"File\" ) || type.equals( \"java.io.File\" ) ) )\n                {\n                    value = pathTranslator.alignToBaseDirectory( (String) value,\n                                                                 session.getProject().getFile().getParentFile() );\n                }\n\n                map.put( key, value );\n            }\n        }\n        return map;\n    }","id":72761,"modified_method":"/**\n     * @deprecated\n     */\n    private Map getPluginConfigurationFromExpressions( MojoDescriptor goal, PlexusConfiguration configuration,\n                                                       MavenSession session, ExpressionEvaluator expressionEvaluator )\n        throws ExpressionEvaluationException, PluginConfigurationException\n    {\n        List parameters = goal.getParameters();\n\n        Map map = new HashMap();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            String key = parameter.getName();\n\n            String expression;\n            if ( configuration.getChild( key, false ) == null )\n            {\n                expression = parameter.getExpression();\n            }\n            else\n            {\n                expression = configuration.getChild( key, false ).getValue( null );\n            }\n\n            Object value = expressionEvaluator.evaluate( expression );\n\n            getLogger().debug( \"Evaluated mojo parameter expression: \\'\" + expression + \"\\' to: \" + value );\n\n            if ( value == null )\n            {\n                if ( parameter.getDefaultValue() != null )\n                {\n                    value = expressionEvaluator.evaluate( parameter.getDefaultValue() );\n                }\n            }\n\n            // ----------------------------------------------------------------------\n            // We will perform a basic check here for parameters values that are\n            // required. Required parameters can't be null so we throw an\n            // Exception in the case where they are. We probably want some\n            // pluggable\n            // mechanism here but this will catch the most obvious of\n            // misconfigurations.\n            // ----------------------------------------------------------------------\n\n            if ( value == null && parameter.isRequired() )\n            {\n                throw new PluginConfigurationException( createPluginParameterRequiredMessage( goal, parameter ) );\n            }\n\n            String type = parameter.getType();\n\n            // TODO: remove - done via plexus configuration, but need to inject the base directory into it\n            if ( type != null && ( type.equals( \"File\" ) || type.equals( \"java.io.File\" ) ) )\n            {\n                value = pathTranslator.alignToBaseDirectory( (String) value,\n                                                             session.getProject().getFile().getParentFile() );\n            }\n\n            map.put( key, value );\n        }\n        return map;\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"public void executeMojo( MavenSession session, String goalName )\n        throws PluginExecutionException\n    {\n        try\n        {\n            verifyPluginForGoal( goalName, session );\n        }\n        catch ( Exception e )\n        {\n            throw new PluginExecutionException( \"Unable to execute goal: \" + goalName, e );\n        }\n\n        PluginExecutionRequest request = null;\n\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( goalName );\n        if ( mojoDescriptor == null )\n        {\n            throw new PluginExecutionException( \"Unable to find goal: \" + goalName );\n        }\n\n        try\n        {\n            if ( mojoDescriptor.getRequiresDependencyResolution() != null )\n            {\n\n                ArtifactResolver artifactResolver = null;\n                MavenProjectBuilder mavenProjectBuilder = null;\n\n                try\n                {\n                    artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                    mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                    resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder,\n                                                   mojoDescriptor.getRequiresDependencyResolution() );\n                    downloadDependencies( session, artifactResolver );\n                }\n                finally\n                {\n                    // TODO: watch out for the exceptions being thrown\n                    if ( artifactResolver != null )\n                    {\n                        container.release( artifactResolver );\n                    }\n                    if ( mavenProjectBuilder != null )\n                    {\n                        container.release( mavenProjectBuilder );\n                    }\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new PluginExecutionException( \"Unable to resolve required dependencies for goal\", e );\n        }\n\n        Plugin plugin = null;\n\n        try\n        {\n            plugin = (Plugin) container.lookup( Plugin.ROLE, goalName );\n\n            plugin.setLog( session.getLog() );\n\n            // TODO: remove\n            boolean newMojoTechnique = checkMojoTechnique( plugin.getClass() );\n\n            String goalId = null;\n\n            // TODO: much less of this magic is needed - make the mojoDescriptor just store the first and second part\n            int index = goalName.indexOf( ':' );\n            if ( index >= 0 )\n            {\n                goalId = goalName.substring( index + 1 );\n            }\n\n            // TODO: can probable refactor these a little when only the new plugin technique is in place\n            Xpp3Dom dom = session.getProject().getGoalConfiguration( PluginDescriptor.getPluginIdFromGoal( goalName ),\n                                                                     goalId );\n\n            PlexusConfiguration configuration;\n            if ( dom == null )\n            {\n                configuration = new XmlPlexusConfiguration( \"configuration\" );\n            }\n            else\n            {\n                configuration = new XmlPlexusConfiguration( dom );\n            }\n\n            if ( newMojoTechnique )\n            {\n                Map map = getPluginConfigurationFromExpressions( mojoDescriptor, configuration, session );\n\n                populatePluginFields( plugin, configuration, map );\n            }\n            else\n            {\n                getLogger().warn( \"WARNING: The mojo \" + mojoDescriptor.getId() + \" is using the OLD API\" );\n\n                Map map = getPluginConfigurationFromExpressions( mojoDescriptor, configuration, session );\n\n                request = createPluginRequest( configuration, map );\n            }\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n\n            dispatcher.dispatchStart( event, goalName );\n            try\n            {\n                if ( newMojoTechnique )\n                {\n                    plugin.execute();\n                }\n                else\n                {\n                    plugin.execute( request );\n                }\n\n                dispatcher.dispatchEnd( event, goalName );\n            }\n            catch ( PluginExecutionException e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalName, e );\n                throw e;\n            }\n            // End event monitoring.\n\n        }\n        catch ( PluginConfigurationException e )\n        {\n            throw new PluginExecutionException( \"Error configuring plugin for execution.\", e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new PluginExecutionException( \"Error looking up plugin: \", e );\n        }\n        finally\n        {\n            try\n            {\n                releaseComponents( mojoDescriptor, request );\n\n                container.release( plugin );\n            }\n            catch ( Exception e )\n            {\n                // TODO: better error handling, needed!\n                e.printStackTrace();\n            }\n        }\n    }","id":72762,"modified_method":"public void executeMojo( MavenSession session, String goalName )\n        throws PluginExecutionException\n    {\n        try\n        {\n            verifyPluginForGoal( goalName, session );\n        }\n        catch ( Exception e )\n        {\n            throw new PluginExecutionException( \"Unable to execute goal: \" + goalName, e );\n        }\n\n        PluginExecutionRequest request = null;\n\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( goalName );\n        if ( mojoDescriptor == null )\n        {\n            throw new PluginExecutionException( \"Unable to find goal: \" + goalName );\n        }\n\n        try\n        {\n            if ( mojoDescriptor.getRequiresDependencyResolution() != null )\n            {\n\n                ArtifactResolver artifactResolver = null;\n                MavenProjectBuilder mavenProjectBuilder = null;\n\n                try\n                {\n                    artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                    mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                    resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder,\n                                                   mojoDescriptor.getRequiresDependencyResolution() );\n                    downloadDependencies( session, artifactResolver );\n                }\n                finally\n                {\n                    // TODO: watch out for the exceptions being thrown\n                    if ( artifactResolver != null )\n                    {\n                        container.release( artifactResolver );\n                    }\n                    if ( mavenProjectBuilder != null )\n                    {\n                        container.release( mavenProjectBuilder );\n                    }\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new PluginExecutionException( \"Unable to resolve required dependencies for goal\", e );\n        }\n\n        Plugin plugin = null;\n\n        try\n        {\n            plugin = (Plugin) container.lookup( Plugin.ROLE, goalName );\n\n            plugin.setLog( session.getLog() );\n\n            // TODO: remove\n            boolean newMojoTechnique = checkMojoTechnique( plugin.getClass() );\n\n            String goalId = null;\n\n            // TODO: much less of this magic is needed - make the mojoDescriptor just store the first and second part\n            int index = goalName.indexOf( ':' );\n            if ( index >= 0 )\n            {\n                goalId = goalName.substring( index + 1 );\n            }\n\n            // TODO: can probable refactor these a little when only the new plugin technique is in place\n            Xpp3Dom dom = session.getProject().getGoalConfiguration( PluginDescriptor.getPluginIdFromGoal( goalName ),\n                                                                     goalId );\n\n            PlexusConfiguration configuration;\n            if ( dom == null )\n            {\n                configuration = new XmlPlexusConfiguration( \"configuration\" );\n            }\n            else\n            {\n                configuration = new XmlPlexusConfiguration( dom );\n            }\n\n            configuration = mergeConfiguration( configuration, mojoDescriptor.getConfiguration() );\n\n            PluginParameterExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session );\n            try\n            {\n                if ( newMojoTechnique )\n                {\n                    Map map = getPluginConfigurationFromExpressions( mojoDescriptor, configuration, session,\n                                                                     expressionEvaluator );\n\n                    populatePluginFields( plugin, configuration, map, expressionEvaluator );\n                }\n                else\n                {\n                    getLogger().warn( \"WARNING: The mojo \" + mojoDescriptor.getId() + \" is using the OLD API\" );\n\n                    Map map = getPluginConfigurationFromExpressions( mojoDescriptor, configuration, session,\n                                                                     expressionEvaluator );\n\n                    request = createPluginRequest( configuration, map );\n                }\n            }\n            catch ( ExpressionEvaluationException e )\n            {\n                throw new PluginExecutionException( \"Unable to configure plugin\", e );\n            }\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n\n            dispatcher.dispatchStart( event, goalName );\n            try\n            {\n                if ( newMojoTechnique )\n                {\n                    plugin.execute();\n                }\n                else\n                {\n                    plugin.execute( request );\n                }\n\n                dispatcher.dispatchEnd( event, goalName );\n            }\n            catch ( PluginExecutionException e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalName, e );\n                throw e;\n            }\n            // End event monitoring.\n\n        }\n        catch ( PluginConfigurationException e )\n        {\n            String msg = \"Error configuring plugin for execution of .\";\n            throw new PluginExecutionException( msg, e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new PluginExecutionException( \"Error looking up plugin: \", e );\n        }\n        finally\n        {\n            try\n            {\n                container.release( plugin );\n            }\n            catch ( Exception e )\n            {\n                // TODO: better error handling, needed!\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"private static PluginExecutionRequest createPluginRequest( PlexusConfiguration configuration, Map map )\n        throws PluginConfigurationException\n    {\n        try\n        {\n            Map parameters = new HashMap();\n            PlexusConfiguration[] children = configuration.getChildren();\n            for ( int i = 0; i < children.length; i++ )\n            {\n                PlexusConfiguration child = children[i];\n                parameters.put( child.getName(), child.getValue() );\n            }\n            map = CollectionUtils.mergeMaps( map, parameters );\n        }\n        catch ( PlexusConfigurationException e )\n        {\n            throw new PluginConfigurationException( \"Unable to construct map from plugin configuration\", e );\n        }\n        return new PluginExecutionRequest( map );\n    }","id":72763,"modified_method":"/**\n     * @param configuration\n     * @param map\n     * @return\n     * @deprecated\n     */\n    private static PluginExecutionRequest createPluginRequest( PlexusConfiguration configuration, Map map )\n    {\n        Map parameters = new HashMap();\n        PlexusConfiguration[] children = configuration.getChildren();\n        for ( int i = 0; i < children.length; i++ )\n        {\n            PlexusConfiguration child = children[i];\n            parameters.put( child.getName(), child.getValue( null ) );\n        }\n        map = CollectionUtils.mergeMaps( map, parameters );\n        return new PluginExecutionRequest( map );\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"private void populatePluginFields( Plugin plugin, PlexusConfiguration configuration, Map map )\n        throws PluginConfigurationException\n    {\n        try\n        {\n            configurator.configureComponent( plugin, configuration );\n        }\n        catch ( ComponentConfigurationException e )\n        {\n            throw new PluginConfigurationException( \"Unable to parse the created DOM for plugin configuration\", e );\n        }\n\n        // Configuration does not store objects, so the non-String fields are configured here\n        // TODO: we don't have converters, so \"primitives\" that -are- strings are not configured properly (eg String -> File from an expression)\n        for ( Iterator i = map.keySet().iterator(); i.hasNext(); )\n        {\n            String key = (String) i.next();\n            Object value = map.get( key );\n\n            if ( value != null )\n            {\n                Class clazz = plugin.getClass();\n                try\n                {\n                    Field f = findPluginField( clazz, key );\n                    boolean accessible = f.isAccessible();\n                    if ( !accessible )\n                    {\n                        f.setAccessible( true );\n                    }\n\n                    f.set( plugin, value );\n\n                    if ( !accessible )\n                    {\n                        f.setAccessible( false );\n                    }\n                }\n                catch ( NoSuchFieldException e )\n                {\n                    throw new PluginConfigurationException( \"Unable to set field '\" + key + \"' on '\" + clazz + \"'\" );\n                }\n                catch ( IllegalAccessException e )\n                {\n                    throw new PluginConfigurationException( \"Unable to set field '\" + key + \"' on '\" + clazz + \"'\" );\n                }\n            }\n        }\n    }","id":72764,"modified_method":"private void populatePluginFields( Plugin plugin, PlexusConfiguration configuration, Map map,\n                                       ExpressionEvaluator expressionEvaluator )\n        throws PluginConfigurationException\n    {\n        try\n        {\n            configurator.configureComponent( plugin, configuration, expressionEvaluator );\n        }\n        catch ( ComponentConfigurationException e )\n        {\n            throw new PluginConfigurationException( \"Unable to parse the created DOM for plugin configuration\", e );\n        }\n\n        // Configuration does not store objects, so the non-String fields are configured here\n        // TODO: remove - this is for plugins built with alpha-1\n        for ( Iterator i = map.keySet().iterator(); i.hasNext(); )\n        {\n            String key = (String) i.next();\n            Object value = map.get( key );\n\n            if ( value != null )\n            {\n                Class clazz = plugin.getClass();\n                try\n                {\n                    Field f = findPluginField( clazz, key );\n                    boolean accessible = f.isAccessible();\n                    if ( !accessible )\n                    {\n                        f.setAccessible( true );\n                    }\n\n                    f.set( plugin, value );\n\n                    if ( !accessible )\n                    {\n                        f.setAccessible( false );\n                    }\n                }\n                catch ( NoSuchFieldException e )\n                {\n                    throw new PluginConfigurationException( \"Unable to set field '\" + key + \"' on '\" + clazz + \"'\" );\n                }\n                catch ( IllegalAccessException e )\n                {\n                    throw new PluginConfigurationException( \"Unable to set field '\" + key + \"' on '\" + clazz + \"'\" );\n                }\n            }\n        }\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojo = new MojoDescriptor();\n\n        mojo.setId( c.getChild( \"id\" ).getValue() );\n\n        mojo.setImplementation( c.getChild( \"implementation\" ).getValue() );\n\n        PlexusConfiguration langConfig = c.getChild( \"language\" );\n\n        if ( langConfig != null )\n        {\n            mojo.setLanguage( langConfig.getValue() );\n        }\n\n        String phase = c.getChild( \"phase\" ).getValue();\n\n        if ( phase != null )\n        {\n            mojo.setPhase( phase );\n        }\n\n        mojo.setInstantiationStrategy( c.getChild( \"instantiationStrategy\" ).getValue() );\n\n        mojo.setDescription( c.getChild( \"description\" ).getValue() );\n\n        String dependencyResolution = c.getChild( \"requiresDependencyResolution\" ).getValue();\n\n        if ( dependencyResolution != null )\n        {\n            mojo.setRequiresDependencyResolution( dependencyResolution );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List parameters = new ArrayList();\n\n        for ( int i = 0; i < parameterConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = parameterConfigurations[i];\n\n            Parameter parameter = new Parameter();\n\n            parameter.setName( d.getChild( \"name\" ).getValue() );\n\n            parameter.setType( d.getChild( \"type\" ).getValue() );\n\n            String s = d.getChild( \"required\" ).getValue();\n\n            if ( s != null )\n            {\n                parameter.setRequired( s.equals( \"true\" ) ? true : false );\n            }\n\n            parameter.setValidator( d.getChild( \"validator\" ).getValue() );\n\n            parameter.setDescription( d.getChild( \"description\" ).getValue() );\n\n            parameter.setExpression( d.getChild( \"expression\" ).getValue() );\n\n            parameter.setDefaultValue( d.getChild( \"default\" ).getValue() );\n\n            parameters.add( parameter );\n        }\n\n        mojo.setParameters( parameters );\n\n        // TODO: this should not need to be handed off...\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] requirements = c.getChild( \"requirements\" ).getChildren( \"requirement\" );\n\n        for ( int i = 0; i < requirements.length; i++ )\n        {\n            PlexusConfiguration requirement = requirements[i];\n\n            ComponentRequirement cr = new ComponentRequirement();\n\n            cr.setRole( requirement.getChild( \"role\" ).getValue() );\n\n            cr.setRoleHint( requirement.getChild( \"role-hint\" ).getValue() );\n\n            cr.setFieldName( requirement.getChild( \"field-name\" ).getValue() );\n\n            mojo.addRequirement( cr );\n        }\n\n        return mojo;\n    }","id":72765,"modified_method":"public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojo = new MojoDescriptor();\n\n        mojo.setId( c.getChild( \"id\" ).getValue() );\n\n        mojo.setImplementation( c.getChild( \"implementation\" ).getValue() );\n\n        PlexusConfiguration langConfig = c.getChild( \"language\" );\n\n        if ( langConfig != null )\n        {\n            mojo.setLanguage( langConfig.getValue() );\n        }\n\n        String phase = c.getChild( \"phase\" ).getValue();\n\n        if ( phase != null )\n        {\n            mojo.setPhase( phase );\n        }\n\n        mojo.setInstantiationStrategy( c.getChild( \"instantiationStrategy\" ).getValue() );\n\n        mojo.setDescription( c.getChild( \"description\" ).getValue() );\n\n        String dependencyResolution = c.getChild( \"requiresDependencyResolution\" ).getValue();\n\n        if ( dependencyResolution != null )\n        {\n            mojo.setRequiresDependencyResolution( dependencyResolution );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List parameters = new ArrayList();\n\n        for ( int i = 0; i < parameterConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = parameterConfigurations[i];\n\n            Parameter parameter = new Parameter();\n\n            parameter.setName( d.getChild( \"name\" ).getValue() );\n\n            parameter.setType( d.getChild( \"type\" ).getValue() );\n\n            String s = d.getChild( \"required\" ).getValue();\n\n            if ( s != null )\n            {\n                parameter.setRequired( s.equals( \"true\" ) ? true : false );\n            }\n\n            parameter.setValidator( d.getChild( \"validator\" ).getValue() );\n\n            parameter.setDescription( d.getChild( \"description\" ).getValue() );\n\n            // TODO: remove\n            parameter.setExpression( d.getChild( \"expression\" ).getValue() );\n\n            // TODO: remove\n            parameter.setDefaultValue( d.getChild( \"default\" ).getValue() );\n\n            parameters.add( parameter );\n        }\n\n        mojo.setParameters( parameters );\n\n        // TODO: this should not need to be handed off...\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] requirements = c.getChild( \"requirements\" ).getChildren( \"requirement\" );\n\n        for ( int i = 0; i < requirements.length; i++ )\n        {\n            PlexusConfiguration requirement = requirements[i];\n\n            ComponentRequirement cr = new ComponentRequirement();\n\n            cr.setRole( requirement.getChild( \"role\" ).getValue() );\n\n            cr.setRoleHint( requirement.getChild( \"role-hint\" ).getValue() );\n\n            cr.setFieldName( requirement.getChild( \"field-name\" ).getValue() );\n\n            mojo.addRequirement( cr );\n        }\n\n        return mojo;\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"protected void processPluginDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w, MavenProject project )\n        throws Exception\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"id\" );\n\n        w.writeText( mojoDescriptor.getId() + \":\" + mojoDescriptor.getGoal() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getRequiresDependencyResolution() != null )\n        {\n            element( w, \"requiresDependencyResolution\", mojoDescriptor.getRequiresDependencyResolution() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n\n        w.writeText( mojoDescriptor.getImplementation() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n\n        w.writeText( mojoDescriptor.getLanguage() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Collection requirements = new ArrayList();\n        for ( int j = 0; j < parameters.size(); j++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( j );\n\n            w.startElement( \"parameter\" );\n\n            element( w, \"name\", parameter.getName() );\n\n            element( w, \"type\", parameter.getType() );\n\n            element( w, \"validator\", parameter.getValidator() );\n\n            if ( parameter.getExpression().startsWith( \"#component\" ) )\n            {\n                requirements.add( parameter );\n            }\n            else\n            {\n                element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                element( w, \"expression\", parameter.getExpression() );\n            }\n\n            element( w, \"description\", parameter.getDescription() );\n\n            element( w, \"default\", parameter.getDefaultValue() );\n\n            w.endElement();\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Iterator i = requirements.iterator(); i.hasNext(); )\n            {\n                Parameter requirement = (Parameter) i.next();\n\n                w.startElement( \"requirement\" );\n\n                element( w, \"role\", requirement.getExpression().substring( 11 ) );\n\n                element( w, \"field-name\", requirement.getName() );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","id":72766,"modified_method":"protected void processPluginDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w, MavenProject project )\n        throws Exception\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"id\" );\n\n        w.writeText( mojoDescriptor.getId() + \":\" + mojoDescriptor.getGoal() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getRequiresDependencyResolution() != null )\n        {\n            element( w, \"requiresDependencyResolution\", mojoDescriptor.getRequiresDependencyResolution() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n\n        w.writeText( mojoDescriptor.getImplementation() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n\n        w.writeText( mojoDescriptor.getLanguage() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Collection requirements = new ArrayList();\n        Map configuration = new HashMap( parameters.size() );\n        for ( int j = 0; j < parameters.size(); j++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( j );\n\n            w.startElement( \"parameter\" );\n\n            element( w, \"name\", parameter.getName() );\n\n            element( w, \"type\", parameter.getType() );\n\n            element( w, \"validator\", parameter.getValidator() );\n\n            String value = null;\n            if ( parameter.getExpression().startsWith( \"#component\" ) )\n            {\n                requirements.add( parameter );\n            }\n            else\n            {\n                element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                value = parameter.getExpression();\n            }\n\n            element( w, \"description\", parameter.getDescription() );\n\n            if ( value == null || value.length() == 0 )\n            {\n                value = parameter.getDefaultValue();\n            }\n\n            if ( value != null && value.length() > 0 )\n            {\n                configuration.put( parameter, value );\n            }\n\n            w.endElement();\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Coinfiguration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Iterator i = configuration.keySet().iterator(); i.hasNext(); )\n            {\n                Parameter parameter = (Parameter) i.next();\n\n                w.startElement( parameter.getName() );\n\n                String type = convertType( parameter.getType() );\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                w.writeText( (String) configuration.get( parameter ) );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Iterator i = requirements.iterator(); i.hasNext(); )\n            {\n                Parameter requirement = (Parameter) i.next();\n\n                w.startElement( \"requirement\" );\n\n                element( w, \"role\", requirement.getExpression().substring( 11 ) );\n\n                element( w, \"field-name\", requirement.getName() );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"private void checkParameter( Parameter parameter )\n    {\n        assertEquals( \"value\", parameter.getDefaultValue() );\n        assertEquals( \"#project.build.directory\", parameter.getExpression() );\n        assertEquals( \"dir\", parameter.getName() );\n        assertEquals( \"String\", parameter.getType() );\n        assertTrue( parameter.isRequired() );\n    }","id":72767,"modified_method":"private void checkParameter( Parameter parameter )\n    {\n        assertEquals( \"dir\", parameter.getName() );\n        assertEquals( \"String\", parameter.getType() );\n        assertTrue( parameter.isRequired() );\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"public static Object evaluate( String expression, MavenSession context )\n        throws PluginConfigurationException\n    {\n        Object value = null;\n\n        if ( expression == null )\n        {\n            // todo : verify if it's fixed with trygvis modification in Plexus\n            return null;\n        }\n        if ( expression.startsWith( \"#component\" ) )\n        {\n            context.getLog().warn( \"WARNING: plugin is using deprecated expression \" + expression );\n\n            // TODO: deprecated... and can remove the lookup method in context afterwards\n            String role = expression.substring( 11 );\n\n            try\n            {\n                value = context.lookup( role );\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new PluginConfigurationException( \"Cannot lookup component: \" + role + \".\", e );\n            }\n        }\n        else if ( expression.equals( \"#localRepository\" ) )\n        {\n            value = context.getLocalRepository();\n        }\n        else if ( expression.equals( \"#maven.final.name\" ) )\n        {\n            // TODO: remove this alias\n            value = context.getProject().getModel().getBuild().getFinalName();\n        }\n        else if ( expression.equals( \"#project\" ) )\n        {\n            value = context.getProject();\n        }\n        else if ( expression.startsWith( \"#project\" ) )\n        {\n            try\n            {\n                int pathSeparator = expression.indexOf( \"/\" );\n\n                if ( pathSeparator > 0 )\n                {\n                    value = getValue( expression.substring( 1, pathSeparator ), context.getProject() ) +\n                        expression.substring( pathSeparator );\n                }\n                else\n                {\n                    value = getValue( expression.substring( 1 ), context.getProject() );\n                }\n            }\n            catch ( Exception e )\n            {\n                throw new PluginConfigurationException( \"Error evaluating plugin parameter expression: \" + expression,\n                                                        e );\n            }\n        }\n        else if ( \"#settings\".equals( expression ) )\n        {\n            value = context.getSettings();\n        }\n        else if ( expression.equals( \"#basedir\" ) )\n        {\n            value = context.getProject().getFile().getParentFile().getAbsolutePath();\n        }\n        else if ( expression.startsWith( \"#basedir\" ) )\n        {\n            int pathSeparator = expression.indexOf( \"/\" );\n\n            if ( pathSeparator > 0 )\n            {\n                value = context.getProject().getFile().getParentFile().getAbsolutePath() +\n                    expression.substring( pathSeparator );\n            }\n            else\n            {\n                new Exception( \"Got expression '\" + expression + \"' that was not recognised\" ).printStackTrace();\n            }\n        }\n        else if ( expression.startsWith( \"#\" ) )\n        {\n            // We will attempt to get nab a system property as a way to specify a\n            // parameter to a plugins. My particular case here is allowing the surefire\n            // plugin to run a single test so I want to specify that class on the cli\n            // as a parameter.\n\n            value = System.getProperty( expression.substring( 1 ) );\n        }\n\n        if ( value instanceof String )\n        {\n            String val = (String) value;\n            int sharpSeparator = val.indexOf( \"#\" );\n\n            if ( sharpSeparator > 0 )\n            {\n                val = val.substring( 0, sharpSeparator ) + evaluate( val.substring( sharpSeparator ), context );\n                value = val;\n            }\n            else if ( sharpSeparator > 0 )\n            {\n                value = evaluate( val.substring( sharpSeparator ), context );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // If we strike and we are not dealing with an expression then we will\n        // will let the value pass through unaltered so that users can hardcode\n        // literal values. Expressions that evaluate to null will be passed\n        // through as null so that the validator can see the null value and\n        // act in accordance with the requirements laid out in the\n        // mojo descriptor.\n        // ----------------------------------------------------------------------\n\n        if ( value == null && expression.length() > 0 && !expression.startsWith( \"#\" ) )\n        {\n            value = expression;\n        }\n\n        return value;\n    }","id":72768,"modified_method":"public PluginParameterExpressionEvaluator( MavenSession context )\n    {\n        this.context = context;\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"public void testLocalRepositoryExtraction() throws Exception\n    {\n        ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE,\n                                                                                 \"legacy\" );\n\n        ArtifactRepository repo = new ArtifactRepository( \"local\", \"target/repo\", repoLayout );\n        PluginManager mgr = (PluginManager) lookup( PluginManager.ROLE );\n\n        PlexusContainer container = getContainer();\n        MavenSession session = new MavenSession( null, // don't need a project for this test.\n                                                 container, mgr, new MavenSettings(), repo,\n                                                 new DefaultEventDispatcher(), new DefaultLog( container.getLogger() ),\n                                                 Collections.EMPTY_LIST );\n\n        Object value = PluginParameterExpressionEvaluator.evaluate( \"#localRepository\", session );\n\n        assertEquals( \"local\", ( (ArtifactRepository) value ).getId() );\n    }","id":72769,"modified_method":"public void testLocalRepositoryExtraction()\n        throws Exception\n    {\n        ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE,\n                                                                                 \"legacy\" );\n\n        ArtifactRepository repo = new ArtifactRepository( \"local\", \"target/repo\", repoLayout );\n        PluginManager mgr = (PluginManager) lookup( PluginManager.ROLE );\n\n        PlexusContainer container = getContainer();\n        MavenSession session = new MavenSession( null, // don't need a project for this test.\n                                                 container, mgr, new MavenSettings(), repo,\n                                                 new DefaultEventDispatcher(), new DefaultLog( container.getLogger() ),\n                                                 Collections.EMPTY_LIST );\n\n        ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session );\n        Object value = expressionEvaluator.evaluate( \"#localRepository\" );\n\n        assertEquals( \"local\", ( (ArtifactRepository) value ).getId() );\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"public void testValueExtractionWithAPomValueContainingAPath() throws Exception\n    {\n        String expected = getTestFile( \"target/test-classes/target/classes\" ).getCanonicalPath();\n\n        ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE,\n                                                                                 \"legacy\" );\n\n        ArtifactRepository repo = new ArtifactRepository( \"local\", \"here\", repoLayout );\n        PluginManager mgr = (PluginManager) lookup( PluginManager.ROLE );\n\n        PlexusContainer container = getContainer();\n\n        Build build = new Build();\n        build.setDirectory( expected.substring( 0, expected.length() - \"/classes\".length() ) );\n\n        Model model = new Model();\n        model.setBuild( build );\n\n        MavenProject project = new MavenProject( model );\n        project.setFile( new File( \"pom.xml\" ).getCanonicalFile() );\n\n        MavenSession session = new MavenSession( project, container, mgr, new MavenSettings(), repo,\n                                                 new DefaultEventDispatcher(), new DefaultLog( container.getLogger() ),\n                                                 Collections.EMPTY_LIST );\n\n        Object value = PluginParameterExpressionEvaluator.evaluate( \"#project.build.directory/classes\", session );\n\n        String actual = new File( value.toString() ).getCanonicalPath();\n\n        System.out.println( \"Expected value: \" + expected );\n        System.out.println( \"Resolved value: \" + actual );\n\n        assertEquals( expected, actual );\n    }","id":72770,"modified_method":"public void testValueExtractionWithAPomValueContainingAPath()\n        throws Exception\n    {\n        String expected = getTestFile( \"target/test-classes/target/classes\" ).getCanonicalPath();\n\n        ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE,\n                                                                                 \"legacy\" );\n\n        ArtifactRepository repo = new ArtifactRepository( \"local\", \"here\", repoLayout );\n        PluginManager mgr = (PluginManager) lookup( PluginManager.ROLE );\n\n        PlexusContainer container = getContainer();\n\n        Build build = new Build();\n        build.setDirectory( expected.substring( 0, expected.length() - \"/classes\".length() ) );\n\n        Model model = new Model();\n        model.setBuild( build );\n\n        MavenProject project = new MavenProject( model );\n        project.setFile( new File( \"pom.xml\" ).getCanonicalFile() );\n\n        MavenSession session = new MavenSession( project, container, mgr, new MavenSettings(), repo,\n                                                 new DefaultEventDispatcher(), new DefaultLog( container.getLogger() ),\n                                                 Collections.EMPTY_LIST );\n\n        ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session );\n        Object value = expressionEvaluator.evaluate( \"#project.build.directory/classes\" );\n\n        String actual = new File( value.toString() ).getCanonicalPath();\n\n        System.out.println( \"Expected value: \" + expected );\n        System.out.println( \"Resolved value: \" + actual );\n\n        assertEquals( expected, actual );\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"public void testParameterThatIsAComponent() throws Exception\n    {\n        String role = \"#component.org.apache.maven.project.MavenProjectBuilder\";\n\n        ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE,\n                                                                                 \"legacy\" );\n\n        ArtifactRepository repo = new ArtifactRepository( \"test\", \"http://www.test.com\", repoLayout );\n        PluginManager mgr = (PluginManager) lookup( PluginManager.ROLE );\n\n        PlexusContainer container = getContainer();\n        MavenSession session = new MavenSession( null, // don't need a project for this test.\n                                                 container, mgr, new MavenSettings(), repo,\n                                                 new DefaultEventDispatcher(), new DefaultLog( container.getLogger() ),\n                                                 Collections.EMPTY_LIST );\n\n        Object value = PluginParameterExpressionEvaluator.evaluate( role, session );\n\n        assertNotNull( value );\n    }","id":72771,"modified_method":"public void testParameterThatIsAComponent()\n        throws Exception\n    {\n        String role = \"#component.org.apache.maven.project.MavenProjectBuilder\";\n\n        ArtifactRepositoryLayout repoLayout = (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE,\n                                                                                 \"legacy\" );\n\n        ArtifactRepository repo = new ArtifactRepository( \"test\", \"http://www.test.com\", repoLayout );\n        PluginManager mgr = (PluginManager) lookup( PluginManager.ROLE );\n\n        PlexusContainer container = getContainer();\n        MavenSession session = new MavenSession( null, // don't need a project for this test.\n                                                 container, mgr, new MavenSettings(), repo,\n                                                 new DefaultEventDispatcher(), new DefaultLog( container.getLogger() ),\n                                                 Collections.EMPTY_LIST );\n\n        ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session );\n        Object value = expressionEvaluator.evaluate( role );\n\n        assertNotNull( value );\n    }","commit_id":"b2e44336151665cd52778bb3278487872f02c067","url":"https://github.com/apache/maven"},{"original_method":"private boolean shouldRunExtensionsCompletion() {\n        return !(parameters.getInvocationCount() <= 1 && jetResult.getResult().getPrefixMatcher().getPrefix().length() < 3);\n    }","id":72772,"modified_method":"private boolean shouldRunExtensionsCompletion() {\n        return parameters.getInvocationCount() > 1 || jetResult.getResult().getPrefixMatcher().getPrefix().length() >= 3;\n    }","commit_id":"06b1f1ec2fc0bca8f4d6d5345cbf42777b4d89ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void addReferenceVariants(@NotNull final Condition<DeclarationDescriptor> filterCondition) {\n        addReferenceVariants(new Function1<DeclarationDescriptor, Iterable<LookupElement>>(){\n            @Override\n            public Iterable<LookupElement> invoke(DeclarationDescriptor descriptor) {\n                return filterCondition.value(descriptor)\n                       ? Collections.singletonList(\n                        DescriptorLookupConverter.createLookupElement(getResolveSession(), getExpressionBindingContext(), descriptor))\n                       : Collections.<LookupElement>emptyList();\n            }\n        });\n    }","id":72773,"modified_method":"private void addReferenceVariants(@NotNull final Condition<DeclarationDescriptor> filterCondition) {\n        Collection<DeclarationDescriptor> descriptors = TipsManager.getReferenceVariants(\n                jetReference.getExpression(), getExpressionBindingContext());\n\n        Collection<DeclarationDescriptor> filterDescriptors = Collections2.filter(descriptors, new Predicate<DeclarationDescriptor>() {\n            @Override\n            public boolean apply(@Nullable DeclarationDescriptor descriptor) {\n                return descriptor != null && filterCondition.value(descriptor);\n            }\n        });\n\n        jetResult.addAllElements(filterDescriptors);\n    }","commit_id":"06b1f1ec2fc0bca8f4d6d5345cbf42777b4d89ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public CompletionSession(\n            @NotNull CompletionParameters parameters,\n            @NotNull CompletionResultSet result,\n            @NotNull JetSimpleNameReference jetReference,\n            @NotNull PsiElement position\n    ) {\n        this.parameters = parameters;\n        this.jetReference = jetReference;\n\n        ResolveSessionForBodies resolveSession =\n                AnalyzerFacadeWithCache.getLazyResolveSessionForFile((JetFile) position.getContainingFile());\n        BindingContext expressionBindingContext = resolveSession.resolveToElement(jetReference.getExpression());\n        JetScope scope = expressionBindingContext.get(BindingContext.RESOLUTION_SCOPE, jetReference.getExpression());\n\n        inDescriptor = scope != null ? scope.getContainingDeclaration() : null;\n\n        this.jetResult = new JetCompletionResultSet(\n                WeigherPackage.addJetSorting(result, parameters),\n                resolveSession,\n                expressionBindingContext, descriptorFilter);\n    }","id":72774,"modified_method":"public CompletionSession(\n            @NotNull CompletionParameters parameters,\n            @NotNull CompletionResultSet result,\n            @NotNull JetSimpleNameReference jetReference,\n            @NotNull PsiElement position\n    ) {\n        this.parameters = parameters;\n        this.jetReference = jetReference;\n\n        ResolveSessionForBodies resolveSession =\n                AnalyzerFacadeWithCache.getLazyResolveSessionForFile((JetFile) position.getContainingFile());\n        BindingContext expressionBindingContext = resolveSession.resolveToElement(jetReference.getExpression());\n        JetScope scope = expressionBindingContext.get(BindingContext.RESOLUTION_SCOPE, jetReference.getExpression());\n\n        inDescriptor = scope != null ? scope.getContainingDeclaration() : null;\n\n        Condition<DeclarationDescriptor> descriptorFilter = new Condition<DeclarationDescriptor>() {\n            @Override\n            public boolean value(DeclarationDescriptor descriptor) {\n                return isVisibleDescriptor(descriptor);\n            }\n        };\n        this.jetResult = new JetCompletionResultSet(\n                WeigherPackage.addJetSorting(result, parameters),\n                resolveSession,\n                expressionBindingContext,\n                descriptorFilter);\n    }","commit_id":"06b1f1ec2fc0bca8f4d6d5345cbf42777b4d89ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void completeSmart() {\n        assert parameters.getCompletionType() == CompletionType.SMART;\n\n        final SmartCompletionData data = CompletionPackage.buildSmartCompletionData(jetReference.getExpression(), getResolveSession(), new Function1<DeclarationDescriptor, Boolean>() {\n            @Override\n            public Boolean invoke(DeclarationDescriptor descriptor) {\n                return isVisibleDescriptor(descriptor);\n            }\n        });\n        if (data != null) {\n            addReferenceVariants(new Function1<DeclarationDescriptor, Iterable<LookupElement>>(){\n                @Override\n                public Iterable<LookupElement> invoke(DeclarationDescriptor descriptor) {\n                    return data.toElements(descriptor);\n                }\n            });\n            for (LookupElement element : data.getAdditionalElements()) {\n                jetResult.addElement(element);\n            }\n        }\n    }","id":72775,"modified_method":"public void completeSmart() {\n        assert parameters.getCompletionType() == CompletionType.SMART;\n\n        Collection<DeclarationDescriptor> descriptors = TipsManager.getReferenceVariants(\n                jetReference.getExpression(), getExpressionBindingContext());\n        Function1<DeclarationDescriptor, Boolean> visibilityFilter = new Function1<DeclarationDescriptor, Boolean>() {\n            @Override\n            public Boolean invoke(DeclarationDescriptor descriptor) {\n                return isVisibleDescriptor(descriptor);\n            }\n        };\n        Collection<LookupElement> elements = CompletionPackage.buildSmartCompletionData(\n                jetReference.getExpression(), getResolveSession(), descriptors, visibilityFilter);\n        if (elements != null) {\n            for (LookupElement element : elements) {\n                jetResult.addElement(element);\n            }\n        }\n    }","commit_id":"06b1f1ec2fc0bca8f4d6d5345cbf42777b4d89ff","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public GrIntroduceContextImpl(@NotNull Project project,\n                                Editor editor,\n                                @Nullable GrExpression expression,\n                                @Nullable GrVariable var,\n                                @NotNull PsiElement[] occurrences,\n                                PsiElement scope) {\n    LOG.assertTrue(expression != null || var != null);\n\n    this.project = project;\n    this.editor = editor;\n    this.expression = expression;\n    this.occurrences = occurrences;\n    this.scope = scope;\n    this.var = var;\n    this.place = expression == null ? var : expression;\n  }","id":72776,"modified_method":"public GrIntroduceContextImpl(@NotNull Project project,\n                                Editor editor,\n                                @Nullable GrExpression expression,\n                                @Nullable GrVariable var,\n                                @Nullable StringPartInfo stringPart,\n                                @NotNull PsiElement[] occurrences,\n                                PsiElement scope) {\n    myStringPart = stringPart;\n    LOG.assertTrue(expression != null || var != null || stringPart != null);\n\n    this.project = project;\n    this.editor = editor;\n    this.expression = expression;\n    this.occurrences = occurrences;\n    this.scope = scope;\n    this.var = var;\n    this.place = GrIntroduceHandlerBase.getCurrentPlace(expression, var, stringPart);\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static GrVariable resolveLocalVar(GrIntroduceContext context) {\n    if (context.getVar() != null) return context.getVar();\n    return (GrVariable)((GrReferenceExpression)context.getExpression()).resolve();\n  }","id":72777,"modified_method":"@NotNull\n  protected static GrVariable resolveLocalVar(@NotNull GrIntroduceContext context) {\n    final GrVariable var = context.getVar();\n    if (var != null) {\n      return var;\n    }\n\n    final GrReferenceExpression expression = (GrReferenceExpression)context.getExpression();\n    assert expression != null;\n\n    final PsiElement resolved = expression.resolve();\n    assert resolved instanceof GrVariable;\n    return (GrVariable)resolved;\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean invoke(final Project project, final Editor editor, PsiFile file, int startOffset, int endOffset) {\n    try {\n      PsiDocumentManager.getInstance(project).commitAllDocuments();\n      if (!(file instanceof GroovyFileBase)) {\n        throw new GrRefactoringError(GroovyRefactoringBundle.message(\"only.in.groovy.files\"));\n      }\n      if (!CommonRefactoringUtil.checkReadOnlyStatus(project, file)) {\n        throw new GrRefactoringError(RefactoringBundle.message(\"readonly.occurences.found\"));\n      }\n\n      GrExpression selectedExpr = findExpression(file, startOffset, endOffset);\n      final GrVariable variable = findVariable(file, startOffset, endOffset);\n      if (variable != null) {\n        checkVariable(variable);\n      }\n      else if (selectedExpr != null) {\n        checkExpression(selectedExpr);\n      }\n      else {\n        throw new GrRefactoringError(null);\n      }\n\n      final GrIntroduceContext context = getContext(project, editor, selectedExpr, variable);\n      checkOccurrences(context.getOccurrences());\n      final Settings settings = showDialog(context);\n      if (settings == null) return false;\n\n      CommandProcessor.getInstance().executeCommand(context.getProject(), new Runnable() {\n      public void run() {\n        AccessToken accessToken = WriteAction.start();\n        try {\n          runRefactoring(context, settings);\n        }\n        finally {\n          accessToken.finish();\n        }\n      }\n    }, getRefactoringName(), null);\n\n      return true;\n    }\n    catch (GrRefactoringError e) {\n      CommonRefactoringUtil.showErrorHint(project, editor, RefactoringBundle.getCannotRefactorMessage(e.getMessage()), getRefactoringName(), getHelpID());\n      return false;\n    }\n  }","id":72778,"modified_method":"private boolean invoke(@NotNull final Project project, @NotNull final Editor editor, @NotNull PsiFile file, int startOffset, int endOffset) {\n    try {\n      PsiDocumentManager.getInstance(project).commitAllDocuments();\n      if (!(file instanceof GroovyFileBase)) {\n        throw new GrRefactoringError(GroovyRefactoringBundle.message(\"only.in.groovy.files\"));\n      }\n      if (!CommonRefactoringUtil.checkReadOnlyStatus(project, file)) {\n        throw new GrRefactoringError(RefactoringBundle.message(\"readonly.occurences.found\"));\n      }\n\n      GrExpression selectedExpr = findExpression(file, startOffset, endOffset);\n      final GrVariable variable = findVariable(file, startOffset, endOffset);\n      final StringPartInfo stringPart = findStringPart(file, startOffset, endOffset);\n      if (variable != null) {\n        checkVariable(variable);\n      }\n      else if (selectedExpr != null) {\n        checkExpression(selectedExpr);\n      }\n      else if (stringPart != null) {\n        checkStringLiteral(stringPart);\n      }\n      else {\n        throw new GrRefactoringError(null);\n      }\n\n      final GrIntroduceContext context = getContext(project, editor, selectedExpr, variable, stringPart);\n      checkOccurrences(context.getOccurrences());\n      final Settings settings = showDialog(context);\n      if (settings == null) return false;\n\n      CommandProcessor.getInstance().executeCommand(context.getProject(), new Runnable() {\n      public void run() {\n        AccessToken accessToken = WriteAction.start();\n        try {\n          runRefactoring(context, settings);\n        }\n        finally {\n          accessToken.finish();\n        }\n      }\n    }, getRefactoringName(), null);\n\n      return true;\n    }\n    catch (GrRefactoringError e) {\n      CommonRefactoringUtil.showErrorHint(project, editor, RefactoringBundle.getCannotRefactorMessage(e.getMessage()), getRefactoringName(), getHelpID());\n      return false;\n    }\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrIntroduceContext getContext(Project project, Editor editor, GrExpression expression, @Nullable GrVariable variable) {\n    final PsiElement scope = findScope(expression, variable);\n\n    if (variable == null) {\n      final PsiElement[] occurences = findOccurrences(expression, scope);\n      return new GrIntroduceContextImpl(project, editor, expression, variable, occurences, scope);\n\n    }\n    else {\n      final List<PsiElement> list = Collections.synchronizedList(new ArrayList<PsiElement>());\n      ReferencesSearch.search(variable, new LocalSearchScope(scope)).forEach(new Processor<PsiReference>() {\n        @Override\n        public boolean process(PsiReference psiReference) {\n          final PsiElement element = psiReference.getElement();\n          if (element != null) {\n            list.add(element);\n          }\n          return true;\n        }\n      });\n      return new GrIntroduceContextImpl(project, editor, variable.getInitializerGroovy(), variable, list.toArray(new PsiElement[list.size()]), scope\n      );\n    }\n  }","id":72779,"modified_method":"@NotNull\n  public GrIntroduceContext getContext(@NotNull Project project,\n                                       @NotNull Editor editor,\n                                       @Nullable GrExpression expression,\n                                       @Nullable GrVariable variable,\n                                       @Nullable StringPartInfo stringPart) {\n    final PsiElement scope = findScope(expression, variable, stringPart);\n\n    if (variable != null) {\n      final List<PsiElement> list = Collections.synchronizedList(new ArrayList<PsiElement>());\n      ReferencesSearch.search(variable, new LocalSearchScope(scope)).forEach(new Processor<PsiReference>() {\n        @Override\n        public boolean process(PsiReference psiReference) {\n          final PsiElement element = psiReference.getElement();\n          if (element != null) {\n            list.add(element);\n          }\n          return true;\n        }\n      });\n      final PsiElement[] occurrences = list.toArray(new PsiElement[list.size()]);\n      return new GrIntroduceContextImpl(project, editor, variable.getInitializerGroovy(), variable, stringPart, occurrences, scope);\n    }\n    else if (expression != null ) {\n      final PsiElement[] occurrences = findOccurrences(expression, scope);\n      return new GrIntroduceContextImpl(project, editor, expression, variable, stringPart, occurrences, scope);\n    }\n    else {\n      assert stringPart != null;\n      return new GrIntroduceContextImpl(project, editor, expression, variable, stringPart, new PsiElement[]{stringPart.getLiteral()}, scope);\n    }\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected abstract PsiElement findScope(GrExpression expression, GrVariable variable);","id":72780,"modified_method":"@NotNull\n  protected abstract PsiElement findScope(GrExpression expression, GrVariable variable, StringPartInfo stringPart);","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement findAnchor(GrIntroduceContext context,\n                                       GrIntroduceSettings settings,\n                                       PsiElement[] occurrences,\n                                       PsiElement container) {\n    if (occurrences.length == 0) return null;\n    PsiElement candidate;\n    if (occurrences.length == 1 || !settings.replaceAllOccurrences()) {\n      candidate = context.getExpression();\n      candidate = findContainingStatement(candidate);\n    }\n    else {\n      GroovyRefactoringUtil.sortOccurrences(occurrences);\n      candidate = occurrences[0];\n      while (candidate != null && !container.equals(candidate.getParent())) {\n        candidate = candidate.getParent();\n      }\n    }\n\n    final GrStringInjection injection = PsiTreeUtil.getParentOfType(candidate, GrStringInjection.class);\n    if (injection != null && !injection.getText().contains(\"\\n\")) {\n      candidate = findContainingStatement(injection);\n    }\n\n    if (candidate == null) return null;\n    \n    if ((container instanceof GrWhileStatement) &&\n        candidate.equals(((GrWhileStatement)container).getCondition())) {\n      return container;\n    }\n    if ((container instanceof GrIfStatement) &&\n        candidate.equals(((GrIfStatement)container).getCondition())) {\n      return container;\n    }\n    if ((container instanceof GrForStatement) &&\n        candidate.equals(((GrForStatement)container).getClause())) {\n      return container;\n    }\n\n    while (candidate instanceof GrIfStatement &&\n           candidate.getParent() instanceof GrIfStatement &&\n           ((GrIfStatement)candidate.getParent()).getElseBranch() == candidate) {\n      candidate = candidate.getParent();\n    }\n    return candidate;\n  }","id":72781,"modified_method":"@Nullable\n  public static PsiElement findAnchor(@NotNull GrIntroduceContext context,\n                                      @NotNull GrIntroduceSettings settings,\n                                      @NotNull PsiElement[] occurrences,\n                                      @NotNull PsiElement container) {\n    if (occurrences.length == 0) return null;\n    PsiElement candidate;\n    if (occurrences.length == 1 || !settings.replaceAllOccurrences()) {\n      candidate = occurrences[0];\n      candidate = findContainingStatement(candidate);\n    }\n    else {\n      GroovyRefactoringUtil.sortOccurrences(occurrences);\n      candidate = occurrences[0];\n      while (candidate != null && !container.equals(candidate.getParent())) {\n        candidate = candidate.getParent();\n      }\n    }\n\n    final GrStringInjection injection = PsiTreeUtil.getParentOfType(candidate, GrStringInjection.class);\n    if (injection != null && !injection.getText().contains(\"\\n\")) {\n      candidate = findContainingStatement(injection);\n    }\n\n    if (candidate == null) return null;\n    \n    if ((container instanceof GrWhileStatement) &&\n        candidate.equals(((GrWhileStatement)container).getCondition())) {\n      return container;\n    }\n    if ((container instanceof GrIfStatement) &&\n        candidate.equals(((GrIfStatement)container).getCondition())) {\n      return container;\n    }\n    if ((container instanceof GrForStatement) &&\n        candidate.equals(((GrForStatement)container).getClause())) {\n      return container;\n    }\n\n    while (candidate instanceof GrIfStatement &&\n           candidate.getParent() instanceof GrIfStatement &&\n           ((GrIfStatement)candidate.getParent()).getElseBranch() == candidate) {\n      candidate = candidate.getParent();\n    }\n    return candidate;\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MultiMap<PsiElement, String> isOKImpl(String varName, boolean replaceAllOccurrences) {\n    PsiElement firstOccurence;\n    if (replaceAllOccurrences) {\n      if (myContext.getOccurrences().length > 0) {\n        GroovyRefactoringUtil.sortOccurrences(myContext.getOccurrences());\n        firstOccurence = myContext.getOccurrences()[0];\n      }\n      else {\n        firstOccurence = myContext.getPlace();\n      }\n    }\n    else {\n      firstOccurence = myContext.getExpression();\n    }\n    final MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>();\n    assert varName != null;\n\n    final int offset = firstOccurence.getTextRange().getStartOffset();\n    validateOccurrencesDown(myContext.getScope(), conflicts, varName, offset);\n    if (!(myContext.getScope() instanceof GroovyFileBase)) {\n      validateVariableOccurrencesUp(myContext.getScope(), conflicts, varName, offset);\n    }\n    return conflicts;\n  }","id":72782,"modified_method":"private MultiMap<PsiElement, String> isOKImpl(String varName, boolean replaceAllOccurrences) {\n    PsiElement firstOccurence;\n    if (replaceAllOccurrences) {\n      if (myContext.getOccurrences().length > 0) {\n        GroovyRefactoringUtil.sortOccurrences(myContext.getOccurrences());\n        firstOccurence = myContext.getOccurrences()[0];\n      }\n      else {\n        firstOccurence = myContext.getPlace();\n      }\n    }\n    else {\n      final GrExpression expression = myContext.getExpression();\n      firstOccurence = expression != null ? expression : myContext.getStringPart().getLiteral();\n    }\n    final MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>();\n    assert varName != null;\n\n    final int offset = firstOccurence.getTextRange().getStartOffset();\n    validateOccurrencesDown(myContext.getScope(), conflicts, varName, offset);\n    if (!(myContext.getScope() instanceof GroovyFileBase)) {\n      validateVariableOccurrencesUp(myContext.getScope(), conflicts, varName, offset);\n    }\n    return conflicts;\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Inserts new variable declarations and replaces occurrences\n   */\n  public GrVariable runRefactoring(final GrIntroduceContext context, final GroovyIntroduceVariableSettings settings) {\n    // Generating variable declaration\n\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(context.getProject());\n    final String[] modifiers = settings.isDeclareFinal() ? new String[]{PsiModifier.FINAL} : null;\n    final GrVariableDeclaration varDecl = factory.createVariableDeclaration(modifiers, \"foo\", settings.getSelectedType(), settings.getName());\n    varDecl.getVariables()[0].getInitializerGroovy().replaceWithExpression(context.getExpression(), true);\n\n    // Marker for caret position\n    try {\n      /* insert new variable */\n      GroovyRefactoringUtil.sortOccurrences(context.getOccurrences());\n      if (context.getOccurrences().length == 0 || !(context.getOccurrences()[0] instanceof GrExpression)) {\n        throw new IncorrectOperationException(\"Wrong expression occurrence\");\n      }\n      GrExpression firstOccurrence;\n      if (settings.replaceAllOccurrences()) {\n        firstOccurrence = ((GrExpression)context.getOccurrences()[0]);\n      }\n      else {\n        firstOccurrence = context.getExpression();\n      }\n\n      assert varDecl.getVariables().length > 0;\n\n      resolveLocalConflicts(context.getScope(), varDecl.getVariables()[0].getName());\n      // Replace at the place of first occurrence\n\n      GrVariable insertedVar = replaceOnlyExpression(firstOccurrence, context, varDecl);\n      boolean alreadyDefined = insertedVar != null;\n      if (insertedVar == null) {\n        // Insert before first occurrence\n        insertedVar = insertVariableDefinition(context, settings, varDecl);\n      }\n\n      GrReferenceAdjuster.shortenReferences(insertedVar);\n\n      insertedVar.setType(settings.getSelectedType());\n\n      //Replace other occurrences\n      GrReferenceExpression refExpr = factory.createReferenceExpressionFromText(settings.getName());\n      if (settings.replaceAllOccurrences()) {\n        ArrayList<PsiElement> replaced = new ArrayList<PsiElement>();\n        for (PsiElement occurrence : context.getOccurrences()) {\n          if (!(alreadyDefined && firstOccurrence.equals(occurrence))) {\n            if (occurrence instanceof GrExpression) {\n              GrExpression element = (GrExpression)occurrence;\n              replaced.add(element.replaceWithExpression(refExpr, true));\n              // For caret position\n              if (occurrence.equals(context.getExpression())) {\n                refreshPositionMarker(replaced.get(replaced.size() - 1));\n              }\n              refExpr = factory.createReferenceExpressionFromText(settings.getName());\n            }\n            else {\n              throw new IncorrectOperationException(\"Expression occurrence to be replaced is not instance of GroovyPsiElement\");\n            }\n          }\n        }\n        if (context.getEditor() != null) {\n          // todo implement it...\n//              final PsiElement[] replacedOccurrences = replaced.toArray(new PsiElement[replaced.size()]);\n//              highlightReplacedOccurrences(myProject, editor, replacedOccurrences);\n        }\n      }\n      else {\n        if (!alreadyDefined) {\n          refreshPositionMarker(context.getExpression().replaceWithExpression(refExpr, true));\n        }\n      }\n      // Setting caret to logical position\n      if (context.getEditor() != null && getPositionMarker() != null) {\n        context.getEditor().getCaretModel().moveToOffset(getPositionMarker().getTextRange().getEndOffset());\n        context.getEditor().getSelectionModel().removeSelection();\n      }\n      return insertedVar;\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return null;\n  }","id":72783,"modified_method":"/**\n   * Inserts new variable declarations and replaces occurrences\n   */\n  public GrVariable runRefactoring(final GrIntroduceContext context, final GroovyIntroduceVariableSettings settings) {\n    // Generating variable declaration\n\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(context.getProject());\n    final String[] modifiers = settings.isDeclareFinal() ? new String[]{PsiModifier.FINAL} : null;\n    final GrVariableDeclaration varDecl = factory.createVariableDeclaration(modifiers, \"foo\", settings.getSelectedType(), settings.getName());\n    generateInitializer(context, varDecl.getVariables()[0]);\n\n    // Marker for caret position\n    try {\n      GrVariable insertedVar;\n      if (context.getStringPart() != null) {\n        insertedVar = processStringPart(context, settings, varDecl);\n      }\n      else {\n        insertedVar = processExpression(context, settings, factory, varDecl);\n      }\n\n\n      // Setting caret to logical position\n      if (context.getEditor() != null && getPositionMarker() != null) {\n        context.getEditor().getCaretModel().moveToOffset(getPositionMarker().getTextRange().getEndOffset());\n        context.getEditor().getSelectionModel().removeSelection();\n      }\n      return insertedVar;\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return null;\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected PsiElement findScope(GrExpression selectedExpr, GrVariable variable) {\n\n    // Get container element\n    final PsiElement scope = GroovyRefactoringUtil.getEnclosingContainer(selectedExpr);\n    if (scope == null || !(scope instanceof GroovyPsiElement)) {\n      throw new GrRefactoringError(\n        GroovyRefactoringBundle.message(\"refactoring.is.not.supported.in.the.current.context\", REFACTORING_NAME));\n    }\n    if (!GroovyRefactoringUtil.isAppropriateContainerForIntroduceVariable(scope)) {\n      throw new GrRefactoringError(\n        GroovyRefactoringBundle.message(\"refactoring.is.not.supported.in.the.current.context\", REFACTORING_NAME));\n    }\n    return scope;\n  }","id":72784,"modified_method":"@NotNull\n  @Override\n  protected PsiElement findScope(GrExpression selectedExpr, GrVariable variable, StringPartInfo stringPartInfo) {\n    // Get container element\n    final PsiElement scope = stringPartInfo != null\n                             ? GroovyRefactoringUtil.getEnclosingContainer(stringPartInfo.getLiteral())\n                             : GroovyRefactoringUtil.getEnclosingContainer(selectedExpr);\n    if (scope == null || !(scope instanceof GroovyPsiElement)) {\n      throw new GrRefactoringError(\n        GroovyRefactoringBundle.message(\"refactoring.is.not.supported.in.the.current.context\", REFACTORING_NAME));\n    }\n    if (!GroovyRefactoringUtil.isAppropriateContainerForIntroduceVariable(scope)) {\n      throw new GrRefactoringError(\n        GroovyRefactoringBundle.message(\"refactoring.is.not.supported.in.the.current.context\", REFACTORING_NAME));\n    }\n    return scope;\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GroovyIntroduceVariableDialog(GrIntroduceContext context, GrIntroduceVariableHandler.Validator validator) {\n    super(context.getProject(), true);\n    myProject = context.getProject();\n    myExpression = context.getExpression();\n    myOccurrencesCount = context.getOccurrences().length;\n    myValidator = validator;\n    init();\n  }","id":72785,"modified_method":"public GroovyIntroduceVariableDialog(GrIntroduceContext context, GrIntroduceVariableHandler.Validator validator) {\n    super(context.getProject(), true);\n    myProject = context.getProject();\n    myExpression = context.getStringPart() != null ? context.getStringPart().getLiteral() : context.getExpression();\n    myOccurrencesCount = context.getOccurrences().length;\n    myValidator = validator;\n    init();\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String processFile(String fileText) throws IncorrectOperationException, InvalidDataException, IOException {\n    String result = \"\";\n    int startOffset = fileText.indexOf(TestUtils.BEGIN_MARKER);\n    if (startOffset < 0) {\n      startOffset = fileText.indexOf(ALL_MARKER);\n      replaceAllOccurences = true;\n      fileText = IntroduceVariableTest.removeAllMarker(fileText);\n    } else {\n      replaceAllOccurences = false;\n      fileText = TestUtils.removeBeginMarker(fileText);\n    }\n    int endOffset = fileText.indexOf(TestUtils.END_MARKER);\n    fileText = TestUtils.removeEndMarker(fileText);\n    myFixture.configureByText(GroovyFileType.GROOVY_FILE_TYPE, fileText);\n\n    Editor myEditor = myFixture.getEditor();\n\n    myEditor.getSelectionModel().setSelection(startOffset, endOffset);\n\n    GrExpression selectedExpr = GroovyRefactoringUtil.findElementInRange(myFixture.getFile(), startOffset, endOffset, GrExpression.class);\n\n    Assert.assertNotNull(\"Selected expression reference points to null\", selectedExpr);\n\n    final PsiElement tempContainer = GroovyRefactoringUtil.getEnclosingContainer(selectedExpr);\n    Assert.assertTrue(tempContainer instanceof GroovyPsiElement);\n\n    PsiElement[] occurences = GroovyRefactoringUtil.getExpressionOccurrences(PsiUtil.skipParentheses(selectedExpr, false), tempContainer);\n    String varName = \"preved\";\n    GroovyVariableValidator validator =\n      new GroovyVariableValidator(new GrIntroduceContextImpl(getProject(), myEditor, selectedExpr, null, occurences, tempContainer));\n    result = validator.isOKTest(varName, replaceAllOccurences);\n    return result;\n  }","id":72786,"modified_method":"private String processFile(String fileText) throws IncorrectOperationException, InvalidDataException, IOException {\n    String result = \"\";\n    int startOffset = fileText.indexOf(TestUtils.BEGIN_MARKER);\n    if (startOffset < 0) {\n      startOffset = fileText.indexOf(ALL_MARKER);\n      replaceAllOccurences = true;\n      fileText = IntroduceVariableTest.removeAllMarker(fileText);\n    } else {\n      replaceAllOccurences = false;\n      fileText = TestUtils.removeBeginMarker(fileText);\n    }\n    int endOffset = fileText.indexOf(TestUtils.END_MARKER);\n    fileText = TestUtils.removeEndMarker(fileText);\n    myFixture.configureByText(GroovyFileType.GROOVY_FILE_TYPE, fileText);\n\n    Editor myEditor = myFixture.getEditor();\n\n    myEditor.getSelectionModel().setSelection(startOffset, endOffset);\n\n    GrExpression selectedExpr = GroovyRefactoringUtil.findElementInRange(myFixture.getFile(), startOffset, endOffset, GrExpression.class);\n\n    Assert.assertNotNull(\"Selected expression reference points to null\", selectedExpr);\n\n    final PsiElement tempContainer = GroovyRefactoringUtil.getEnclosingContainer(selectedExpr);\n    Assert.assertTrue(tempContainer instanceof GroovyPsiElement);\n\n    PsiElement[] occurences = GroovyRefactoringUtil.getExpressionOccurrences(PsiUtil.skipParentheses(selectedExpr, false), tempContainer);\n    String varName = \"preved\";\n    GroovyVariableValidator validator =\n      new GroovyVariableValidator(new GrIntroduceContextImpl(getProject(), myEditor, selectedExpr, null, null, occurences, tempContainer));\n    result = validator.isOKTest(varName, replaceAllOccurences);\n    return result;\n  }","commit_id":"a9bcc7b99dec9c759f952eb7d52c62e45f8b966e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitArrayExpression(ArrayExpression expression) {\n        int size = expression.getExpressions().size();\n        pushConstant(size);\n\n        String typeName = getClassInternalName(expression.getType());\n        cv.visitTypeInsn(ANEWARRAY, typeName);\n\n        for (int i = 0; i < size; i++) {\n            cv.visitInsn(DUP);\n            pushConstant(i);\n            expression.getExpression(i).visit(this);\n            cv.visitInsn(AASTORE);\n        }\n    }","id":72787,"modified_method":"public void visitArrayExpression(ArrayExpression expression) {\n        int size = expression.getExpressions().size();\n        pushConstant(size);\n\n        String typeName = getClassInternalName(expression.getType());\n        cv.visitTypeInsn(ANEWARRAY, typeName);\n\n        for (int i = 0; i < size; i++) {\n            cv.visitInsn(DUP);\n            pushConstant(i);\n            Expression elementExpression = expression.getExpression(i);\n            if (elementExpression == null) {\n                log.warn(\"Null expression in: \" + expression);\n                ConstantExpression.NULL.visit(this);\n            }\n            else {\n                elementExpression.visit(this);\n            }\n            cv.visitInsn(AASTORE);\n        }\n    }","commit_id":"6128d56631731f853be23c5b12c973c66ded4152","url":"https://github.com/apache/groovy"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyStringLiteralExpression string = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyStringLiteralExpression.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    if (string != null) {\n      String stringText = string.getText();\n      final int prefixLength = PyStringLiteralExpressionImpl.getPrefixLength(stringText);\n      String prefix = stringText.substring(0, prefixLength);\n      Character firstQuote = stringText.substring(prefixLength).charAt(0);\n\n      stringText = string.getStringValue();\n      List<String> subStrings = StringUtil.split(stringText, \"\\n\", false, true);\n\n\n      StringBuilder result = new StringBuilder();\n      if (subStrings.size() != 1)\n        result.append(\"(\");\n      boolean lastString = false;\n      for (String s : subStrings) {\n        result.append(prefix);\n        result.append(firstQuote);\n        String validSubstring = convertToValidSubString(s, firstQuote);\n\n        if (s.endsWith(\"'''\") || s.endsWith(\"\\\"\\\"\\\"\")) {\n          lastString = true;\n        }\n        result.append(validSubstring);\n        result.append(firstQuote);\n        if (!lastString)\n          result.append(\" \").append(\"\\n\");\n      }\n      if (subStrings.size() != 1)\n        result.append(\")\");\n      PyExpressionStatement e = elementGenerator.createFromText(LanguageLevel.forElement(string), PyExpressionStatement.class, result.toString());\n      string.replace(e.getExpression());\n    }\n  }","id":72788,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyStringLiteralExpression string = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyStringLiteralExpression.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    if (string != null) {\n      final PsiElement parent = string.getParent();\n      String stringText = string.getText();\n      final int prefixLength = PyStringLiteralExpressionImpl.getPrefixLength(stringText);\n      String prefix = stringText.substring(0, prefixLength);\n      Character firstQuote = stringText.substring(prefixLength).charAt(0);\n\n      stringText = string.getStringValue();\n      List<String> subStrings = StringUtil.split(stringText, \"\\n\", false, true);\n\n      StringBuilder result = new StringBuilder();\n      if (subStrings.size() != 1)\n        result.append(\"(\");\n      boolean lastString = false;\n      for (String s : subStrings) {\n        result.append(prefix);\n        result.append(firstQuote);\n        String validSubstring = convertToValidSubString(s, firstQuote);\n\n        if (s.endsWith(\"'''\") || s.endsWith(\"\\\"\\\"\\\"\")) {\n          lastString = true;\n        }\n        result.append(validSubstring);\n        result.append(firstQuote);\n        if (!lastString)\n          result.append(\" \").append(\"\\n\");\n      }\n      if (subStrings.size() != 1)\n        result.append(\")\");\n      PyExpressionStatement e = elementGenerator.createFromText(LanguageLevel.forElement(string), PyExpressionStatement.class, result.toString());\n\n      PyExpression expression = e.getExpression();\n      if (parent instanceof PyTupleExpression && expression instanceof PyParenthesizedExpression)\n        expression = ((PyParenthesizedExpression)expression).getContainedExpression();\n      if (expression != null)\n        string.replace(expression);\n    }\n  }","commit_id":"c0245974916a2e728c697b16f41d8abac6fb25cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void transform(XtendFunction source, JvmGenericType container, boolean allowDispatch) {\n\t\tJvmOperation operation = typesFactory.createJvmOperation();\n\t\toperation.setAbstract(source.isAbstract());\n\t\toperation.setNative(source.isNative());\n\t\toperation.setSynchronized(source.isSynchonized());\n\t\toperation.setStrictFloatingPoint(source.isStrictFloatingPoint());\n\t\tif (!source.isAbstract())\n\t\t\toperation.setFinal(source.isFinal());\n\t\tcontainer.getMembers().add(operation);\n\t\tassociator.associatePrimary(source, operation);\n\t\tString sourceName = source.getName();\n\t\tJvmVisibility visibility = source.getVisibility();\n\t\tif (allowDispatch && source.isDispatch()) {\n\t\t\tif (source.getDeclaredVisibility() == null)\n\t\t\t\tvisibility = JvmVisibility.PROTECTED;\n\t\t\tsourceName = \"_\" + sourceName;\n\t\t}\n\t\toperation.setSimpleName(sourceName);\n\t\toperation.setVisibility(visibility);\n\t\toperation.setStatic(source.isStatic());\n\t\tfor (XtendParameter parameter : source.getParameters()) {\n\t\t\ttranslateParameter(operation, parameter);\n\t\t}\n\t\tJvmTypeReference returnType = null;\n\t\tif (source.getReturnType() != null) {\n\t\t\treturnType = jvmTypesBuilder.cloneWithProxies(source.getReturnType());\n\t\t} else {\n\t\t\treturnType = jvmTypesBuilder.inferredType();\n\t\t}\n\t\toperation.setReturnType(returnType);\n\t\tcopyAndFixTypeParameters(source.getTypeParameters(), operation);\n\t\tfor (JvmTypeReference exception : source.getExceptions()) {\n\t\t\toperation.getExceptions().add(jvmTypesBuilder.cloneWithProxies(exception));\n\t\t}\n\t\ttranslateAnnotationsTo(source.getAnnotations(), operation);\n\t\tCreateExtensionInfo createExtensionInfo = source.getCreateExtensionInfo();\n\t\tif (createExtensionInfo != null) {\n\t\t\ttransformCreateExtension(source, createExtensionInfo, container, operation, returnType);\n\t\t} else {\n\t\t\tsetBody(operation, source.getExpression());\n\t\t}\n\t\tjvmTypesBuilder.copyDocumentationTo(source, operation);\n\t}","id":72789,"modified_method":"protected void transform(XtendFunction source, JvmGenericType container, boolean allowDispatch) {\n\t\tJvmOperation operation = typesFactory.createJvmOperation();\n\t\toperation.setAbstract(source.isAbstract());\n\t\toperation.setNative(source.isNative());\n\t\toperation.setSynchronized(source.isSynchonized());\n\t\toperation.setStrictFloatingPoint(source.isStrictFloatingPoint());\n\t\tif (!source.isAbstract())\n\t\t\toperation.setFinal(source.isFinal());\n\t\tcontainer.getMembers().add(operation);\n\t\tassociator.associatePrimary(source, operation);\n\t\tString sourceName = source.getName();\n\t\tJvmVisibility visibility = source.getVisibility();\n\t\tif (allowDispatch && source.isDispatch()) {\n\t\t\tif (source.getDeclaredVisibility() == null)\n\t\t\t\tvisibility = JvmVisibility.PROTECTED;\n\t\t\tsourceName = \"_\" + sourceName;\n\t\t}\n\t\toperation.setSimpleName(sourceName);\n\t\toperation.setVisibility(visibility);\n\t\toperation.setStatic(source.isStatic());\n\t\tfor (XtendParameter parameter : source.getParameters()) {\n\t\t\ttranslateParameter(operation, parameter);\n\t\t}\n\t\tXExpression expression = source.getExpression();\n\t\tCreateExtensionInfo createExtensionInfo = source.getCreateExtensionInfo();\n\t\t\n\t\tJvmTypeReference returnType = null;\n\t\tif (source.getReturnType() != null) {\n\t\t\treturnType = jvmTypesBuilder.cloneWithProxies(source.getReturnType());\n\t\t} else if (createExtensionInfo != null) {\n\t\t\treturnType = jvmTypesBuilder.inferredType(createExtensionInfo.getCreateExpression());\n\t\t} else if (expression != null) {\n\t\t\treturnType = jvmTypesBuilder.inferredType(expression);\n\t\t} else {\n\t\t\treturnType = jvmTypesBuilder.inferredType();\n\t\t}\n\t\t\n\t\toperation.setReturnType(returnType);\n\t\tcopyAndFixTypeParameters(source.getTypeParameters(), operation);\n\t\tfor (JvmTypeReference exception : source.getExceptions()) {\n\t\t\toperation.getExceptions().add(jvmTypesBuilder.cloneWithProxies(exception));\n\t\t}\n\t\ttranslateAnnotationsTo(source.getAnnotations(), operation);\n\t\tif (createExtensionInfo != null) {\n\t\t\ttransformCreateExtension(source, createExtensionInfo, container, operation, returnType);\n\t\t} else {\n\t\t\tsetBody(operation, expression);\n\t\t}\n\t\tjvmTypesBuilder.copyDocumentationTo(source, operation);\n\t}","commit_id":"5bb495d685070b272546ea1ea075b473ded77b64","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n        public void visitParenthesizedExpression(JetParenthesizedExpression expression) {\n            result = getType(scope, expression.getExpression(), false);\n        }","id":72790,"modified_method":"@Override\n        public void visitParenthesizedExpression(JetParenthesizedExpression expression) {\n            JetExpression inner = expression.getExpression();\n            if (inner != null) {\n                result = getType(scope, inner, false);\n            }\n        }","commit_id":"35f781c7139c4b8c96e61b85482fac92bc3981bc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public XLightBreakpointPropertiesPanel(Project project, XBreakpointManager breakpointManager, B breakpoint, boolean showAllOptions) {\n    myBreakpoint = breakpoint;\n    XBreakpointType<B, ?> breakpointType = XBreakpointUtil.getType(breakpoint);\n\n    mySuspendPolicyPanel.init(project, breakpointManager, breakpoint);\n    mySuspendPolicyPanel.setDelegate(this);\n\n    mySubPanels.add(mySuspendPolicyPanel);\n    myMasterBreakpointPanel.init(project, breakpointManager, breakpoint);\n    mySubPanels.add(myMasterBreakpointPanel);\n    XDebuggerEditorsProvider debuggerEditorsProvider = breakpointType.getEditorsProvider(breakpoint, project);\n\n    myActionsPanel.init(project, breakpointManager, breakpoint, debuggerEditorsProvider);\n    mySubPanels.add(myActionsPanel);\n\n    myCustomPanels = new ArrayList<XBreakpointCustomPropertiesPanel<B>>();\n    if (debuggerEditorsProvider != null) {\n      myConditionComboBox = new XDebuggerExpressionComboBox(project, debuggerEditorsProvider, CONDITION_HISTORY_ID, myBreakpoint.getSourcePosition());\n      JComponent conditionComponent = myConditionComboBox.getComponent();\n      myConditionExpressionPanel.add(conditionComponent, BorderLayout.CENTER);\n      myConditionEnabledCheckbox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          onCheckboxChanged();\n        }\n      });\n      DebuggerUIUtil.focusEditorOnCheck(myConditionEnabledCheckbox, myConditionComboBox.getEditorComponent());\n    } else {\n      myConditionPanel.setVisible(false);\n    }\n\n    myShowMoreOptions = false;\n    for (XBreakpointPropertiesSubPanel<B> panel : mySubPanels) {\n      if (panel.lightVariant(showAllOptions)) {\n        myShowMoreOptions = true;\n      }\n    }\n\n    XBreakpointCustomPropertiesPanel<B> customPropertiesPanel = breakpointType.createCustomPropertiesPanel();\n    if (customPropertiesPanel != null) {\n      myCustomPropertiesPanelWrapper.add(customPropertiesPanel.getComponent(), BorderLayout.CENTER);\n      myCustomPanels.add(customPropertiesPanel);\n    }\n\n    XBreakpointCustomPropertiesPanel<B> customConditionPanel = breakpointType.createCustomConditionsPanel();\n    if (customConditionPanel != null) {\n      myCustomConditionsPanelWrapper.add(customConditionPanel.getComponent(), BorderLayout.CENTER);\n      myCustomPanels.add(customConditionPanel);\n    }\n\n    XBreakpointCustomPropertiesPanel<B> customRightConditionPanel = breakpointType.createCustomRightPropertiesPanel(project);\n    if (customRightConditionPanel != null && (showAllOptions || customRightConditionPanel.isVisibleOnPopup(breakpoint))) {\n      myCustomRightPropertiesPanelWrapper.add(customRightConditionPanel.getComponent(), BorderLayout.CENTER);\n      myCustomPanels.add(customRightConditionPanel);\n    }\n\n    XBreakpointCustomPropertiesPanel<B> customTopPropertiesPanel = breakpointType.createCustomTopPropertiesPanel(project);\n    if (customTopPropertiesPanel != null) {\n      myCustomTopPropertiesPanelWrapper.add(customTopPropertiesPanel.getComponent(), BorderLayout.CENTER);\n      myCustomPanels.add(customTopPropertiesPanel);\n    }\n\n    myMainPanel.addFocusListener(new FocusAdapter() {\n      @Override\n      public void focusGained(FocusEvent event) {\n        if (myConditionComboBox != null) {\n          IdeFocusManager.findInstance().requestFocus(myConditionComboBox.getComponent(), false);\n        }\n      }\n    });\n\n    myEnabledCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        myBreakpoint.setEnabled(myEnabledCheckbox.isSelected());\n      }\n    });\n  }","id":72791,"modified_method":"public XLightBreakpointPropertiesPanel(Project project, XBreakpointManager breakpointManager, B breakpoint, boolean showAllOptions) {\n    myBreakpoint = breakpoint;\n    myShowAllOptions = showAllOptions;\n    XBreakpointType<B, ?> breakpointType = XBreakpointUtil.getType(breakpoint);\n\n    mySuspendPolicyPanel.init(project, breakpointManager, breakpoint);\n    mySuspendPolicyPanel.setDelegate(this);\n\n    mySubPanels.add(mySuspendPolicyPanel);\n    myMasterBreakpointPanel.init(project, breakpointManager, breakpoint);\n    mySubPanels.add(myMasterBreakpointPanel);\n    XDebuggerEditorsProvider debuggerEditorsProvider = breakpointType.getEditorsProvider(breakpoint, project);\n\n    myActionsPanel.init(project, breakpointManager, breakpoint, debuggerEditorsProvider);\n    mySubPanels.add(myActionsPanel);\n\n    myCustomPanels = new ArrayList<XBreakpointCustomPropertiesPanel<B>>();\n    if (debuggerEditorsProvider != null) {\n      myConditionEnabledCheckbox = new JBCheckBox(XDebuggerBundle.message(\"xbreakpoints.condition.checkbox\"));\n      JBLabel conditionEnabledLabel = new JBLabel(XDebuggerBundle.message(\"xbreakpoints.condition.checkbox\"));\n      conditionEnabledLabel.setBorder(new EmptyBorder(0, ((BasicRadioButtonUI)myConditionEnabledCheckbox.getUI()).getDefaultIcon().getIconWidth() +\n                                                         myConditionEnabledCheckbox.getIconTextGap() +\n                                                         myConditionEnabledCheckbox.getBorder().getBorderInsets(myConditionEnabledCheckbox).left, 0, 0));\n      myConditionEnabledPanel.add(myConditionEnabledCheckbox, CONDITION_ENABLED_CHECKBOX);\n      myConditionEnabledPanel.add(conditionEnabledLabel, CONDITION_ENABLED_LABEL);\n      myConditionComboBox = new XDebuggerExpressionComboBox(project, debuggerEditorsProvider, CONDITION_HISTORY_ID, myBreakpoint.getSourcePosition());\n      JComponent conditionComponent = myConditionComboBox.getComponent();\n      myConditionExpressionPanel.add(conditionComponent, BorderLayout.CENTER);\n      myConditionEnabledCheckbox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          onCheckboxChanged();\n        }\n      });\n      DebuggerUIUtil.focusEditorOnCheck(myConditionEnabledCheckbox, myConditionComboBox.getEditorComponent());\n    } else {\n      myConditionPanel.setVisible(false);\n    }\n\n    myShowMoreOptions = false;\n    for (XBreakpointPropertiesSubPanel<B> panel : mySubPanels) {\n      if (panel.lightVariant(showAllOptions)) {\n        myShowMoreOptions = true;\n      }\n    }\n\n    XBreakpointCustomPropertiesPanel<B> customPropertiesPanel = breakpointType.createCustomPropertiesPanel();\n    if (customPropertiesPanel != null) {\n      myCustomPropertiesPanelWrapper.add(customPropertiesPanel.getComponent(), BorderLayout.CENTER);\n      myCustomPanels.add(customPropertiesPanel);\n    }\n\n    XBreakpointCustomPropertiesPanel<B> customConditionPanel = breakpointType.createCustomConditionsPanel();\n    if (customConditionPanel != null) {\n      myCustomConditionsPanelWrapper.add(customConditionPanel.getComponent(), BorderLayout.CENTER);\n      myCustomPanels.add(customConditionPanel);\n    }\n\n    XBreakpointCustomPropertiesPanel<B> customRightConditionPanel = breakpointType.createCustomRightPropertiesPanel(project);\n    if (customRightConditionPanel != null && (showAllOptions || customRightConditionPanel.isVisibleOnPopup(breakpoint))) {\n      myCustomRightPropertiesPanelWrapper.add(customRightConditionPanel.getComponent(), BorderLayout.CENTER);\n      myCustomPanels.add(customRightConditionPanel);\n    }\n\n    XBreakpointCustomPropertiesPanel<B> customTopPropertiesPanel = breakpointType.createCustomTopPropertiesPanel(project);\n    if (customTopPropertiesPanel != null) {\n      myCustomTopPropertiesPanelWrapper.add(customTopPropertiesPanel.getComponent(), BorderLayout.CENTER);\n      myCustomPanels.add(customTopPropertiesPanel);\n    }\n\n    myMainPanel.addFocusListener(new FocusAdapter() {\n      @Override\n      public void focusGained(FocusEvent event) {\n        if (myConditionComboBox != null) {\n          IdeFocusManager.findInstance().requestFocus(myConditionComboBox.getEditorComponent(), false);\n        }\n      }\n    });\n\n    myEnabledCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        myBreakpoint.setEnabled(myEnabledCheckbox.isSelected());\n      }\n    });\n  }","commit_id":"aa68afdc9e1e39fab9c031b4cd49abcd361dbe8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void saveProperties() {\n    for (XBreakpointPropertiesSubPanel<B> panel : mySubPanels) {\n      panel.saveProperties();\n    }\n\n    if (myConditionComboBox != null) {\n      myBreakpoint.setConditionEnabled(myConditionEnabledCheckbox.isSelected());\n      myBreakpoint.setConditionExpression(myConditionComboBox.getExpression());\n      myConditionComboBox.saveTextInHistory();\n    }\n\n    for (XBreakpointCustomPropertiesPanel<B> customPanel : myCustomPanels) {\n      customPanel.saveTo(myBreakpoint);\n    }\n    myBreakpoint.setEnabled(myEnabledCheckbox.isSelected());\n  }","id":72792,"modified_method":"public void saveProperties() {\n    for (XBreakpointPropertiesSubPanel<B> panel : mySubPanels) {\n      panel.saveProperties();\n    }\n\n    if (myConditionComboBox != null) {\n      myBreakpoint.setConditionEnabled(myConditionEnabledCheckbox.isSelected());\n      XExpression expression = myConditionComboBox.getExpression();\n      myBreakpoint.setConditionExpression(expression != null && !expression.getExpression().isEmpty() ? expression : null);\n      myConditionComboBox.saveTextInHistory();\n    }\n\n    for (XBreakpointCustomPropertiesPanel<B> customPanel : myCustomPanels) {\n      customPanel.saveTo(myBreakpoint);\n    }\n    myBreakpoint.setEnabled(myEnabledCheckbox.isSelected());\n  }","commit_id":"aa68afdc9e1e39fab9c031b4cd49abcd361dbe8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadProperties() {\n    for (XBreakpointPropertiesSubPanel<B> panel : mySubPanels) {\n      panel.loadProperties();\n    }\n\n    if (myConditionComboBox != null) {\n      myConditionEnabledCheckbox.setSelected(myBreakpoint.isConditionEnabled());\n      myConditionComboBox.setExpression(myBreakpoint.getConditionExpressionInt());\n    }\n    \n    for (XBreakpointCustomPropertiesPanel<B> customPanel : myCustomPanels) {\n      customPanel.loadFrom(myBreakpoint);\n    }\n    myEnabledCheckbox.setSelected(myBreakpoint.isEnabled());\n    myEnabledCheckbox.setText(XBreakpointUtil.getShortText(myBreakpoint) + \" enabled\");\n\n    onCheckboxChanged();\n  }","id":72793,"modified_method":"public void loadProperties() {\n    for (XBreakpointPropertiesSubPanel<B> panel : mySubPanels) {\n      panel.loadProperties();\n    }\n\n    if (myConditionComboBox != null) {\n      XExpression condition = myBreakpoint.getConditionExpressionInt();\n      myConditionComboBox.setExpression(condition);\n      boolean hideCheckbox = !myShowAllOptions && condition == null;\n      myConditionEnabledCheckbox.setSelected(hideCheckbox || (myBreakpoint.isConditionEnabled() && condition != null));\n      ((CardLayout)myConditionEnabledPanel.getLayout()).show(myConditionEnabledPanel, hideCheckbox ? CONDITION_ENABLED_LABEL : CONDITION_ENABLED_CHECKBOX);\n\n      onCheckboxChanged();\n    }\n    \n    for (XBreakpointCustomPropertiesPanel<B> customPanel : myCustomPanels) {\n      customPanel.loadFrom(myBreakpoint);\n    }\n    myEnabledCheckbox.setSelected(myBreakpoint.isEnabled());\n    myEnabledCheckbox.setText(XBreakpointUtil.getShortText(myBreakpoint) + \" enabled\");\n  }","commit_id":"aa68afdc9e1e39fab9c031b4cd49abcd361dbe8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private NamesByExprInfo suggestVariableNameByExpressionOnly(@NotNull PsiExpression expr, @NotNull VariableKind variableKind, boolean correctKeywords, boolean useAllMethodNames) {\n    if (expr instanceof PsiMethodCallExpression) {\n      PsiReferenceExpression methodExpr = ((PsiMethodCallExpression)expr).getMethodExpression();\n      String methodName = methodExpr.getReferenceName();\n      if (methodName != null) {\n        if (\"of\".equals(methodName) || \"ofNullable\".equals(methodName)) {\n          if (isJavaUtilMethodCall((PsiMethodCallExpression)expr)) {\n            PsiExpression[] expressions = ((PsiMethodCallExpression)expr).getArgumentList().getExpressions();\n            if (expressions.length > 0) {\n              return suggestVariableNameByExpressionOnly(expressions[0], variableKind, correctKeywords, useAllMethodNames);\n            }\n          }\n        }\n        if (\"map\".equals(methodName) || \"flatMap\".equals(methodName) || \"filter\".equals(methodName)) {\n          if (isJavaUtilMethodCall((PsiMethodCallExpression)expr)) {\n            return new NamesByExprInfo(null);\n          }\n        }\n\n        String[] words = NameUtil.nameToWords(methodName);\n        if (words.length > 0) {\n          final String firstWord = words[0];\n          if (GET_PREFIX.equals(firstWord)\n              || IS_PREFIX.equals(firstWord)\n              || FIND_PREFIX.equals(firstWord)\n              || CREATE_PREFIX.equals(firstWord)) {\n            if (words.length > 1) {\n              final String propertyName = methodName.substring(firstWord.length());\n              String[] names = getSuggestionsByName(propertyName, variableKind, false, correctKeywords);\n              final PsiExpression qualifierExpression = methodExpr.getQualifierExpression();\n              if (qualifierExpression instanceof PsiReferenceExpression &&\n                  ((PsiReferenceExpression)qualifierExpression).resolve() instanceof PsiVariable) {\n                names = ArrayUtil.append(names, StringUtil\n                  .sanitizeJavaIdentifier(changeIfNotIdentifier(qualifierExpression.getText() + StringUtil.capitalize(propertyName))));\n              }\n              return new NamesByExprInfo(propertyName, names);\n            }\n          }\n          else if (words.length == 1 || useAllMethodNames) {\n            return new NamesByExprInfo(methodName, getSuggestionsByName(methodName, variableKind, false, correctKeywords));\n          }\n        }\n      }\n    }\n    else if (expr instanceof PsiReferenceExpression) {\n      String propertyName = ((PsiReferenceExpression)expr).getReferenceName();\n      PsiElement refElement = ((PsiReferenceExpression)expr).resolve();\n      if (refElement instanceof PsiVariable) {\n        VariableKind refVariableKind = getVariableKind((PsiVariable)refElement);\n        propertyName = variableNameToPropertyName(propertyName, refVariableKind);\n      }\n      if (refElement != null && propertyName != null) {\n        String[] names = getSuggestionsByName(propertyName, variableKind, false, correctKeywords);\n        return new NamesByExprInfo(propertyName, names);\n      }\n    }\n    else if (expr instanceof PsiArrayAccessExpression) {\n      PsiExpression arrayExpr = ((PsiArrayAccessExpression)expr).getArrayExpression();\n      if (arrayExpr instanceof PsiReferenceExpression) {\n        String arrayName = ((PsiReferenceExpression)arrayExpr).getReferenceName();\n        PsiElement refElement = ((PsiReferenceExpression)arrayExpr).resolve();\n        if (refElement instanceof PsiVariable) {\n          VariableKind refVariableKind = getVariableKind((PsiVariable)refElement);\n          arrayName = variableNameToPropertyName(arrayName, refVariableKind);\n        }\n\n        if (arrayName != null) {\n          String name = StringUtil.unpluralize(arrayName);\n          if (name != null) {\n            String[] names = getSuggestionsByName(name, variableKind, false, correctKeywords);\n            return new NamesByExprInfo(name, names);\n          }\n        }\n      }\n    }\n    else if (expr instanceof PsiLiteralExpression && variableKind == VariableKind.STATIC_FINAL_FIELD) {\n      final PsiLiteralExpression literalExpression = (PsiLiteralExpression)expr;\n      final Object value = literalExpression.getValue();\n      if (value instanceof String) {\n        final String stringValue = (String)value;\n        String[] names = getSuggestionsByValue(stringValue);\n        if (names.length > 0) {\n          return new NamesByExprInfo(null, constantValueToConstantName(names));\n        }\n      }\n    } else if (expr instanceof PsiParenthesizedExpression) {\n      return suggestVariableNameByExpressionOnly(((PsiParenthesizedExpression)expr).getExpression(), variableKind, correctKeywords, useAllMethodNames);\n    } else if (expr instanceof PsiTypeCastExpression) {\n      return suggestVariableNameByExpressionOnly(((PsiTypeCastExpression)expr).getOperand(), variableKind, correctKeywords, useAllMethodNames);\n    } else if (expr instanceof PsiLiteralExpression) {\n      final String text = StringUtil.stripQuotesAroundValue(expr.getText());\n      if (isIdentifier(text)) {\n        return new NamesByExprInfo(text, getSuggestionsByName(text, variableKind, false, correctKeywords));\n      }\n    } else if (expr instanceof PsiFunctionalExpression) {\n      final PsiType functionalInterfaceType = ((PsiFunctionalExpression)expr).getFunctionalInterfaceType();\n      if (functionalInterfaceType != null) {\n        final String[] namesByType = suggestVariableNameByType(functionalInterfaceType, variableKind, correctKeywords);\n        return new NamesByExprInfo(null, namesByType);\n      }\n    }\n\n    return new NamesByExprInfo(null, ArrayUtil.EMPTY_STRING_ARRAY);\n  }","id":72794,"modified_method":"@NotNull\n  private NamesByExprInfo suggestVariableNameByExpressionOnly(@NotNull PsiExpression expr, @NotNull VariableKind variableKind, boolean correctKeywords, boolean useAllMethodNames) {\n    if (expr instanceof PsiMethodCallExpression) {\n      PsiReferenceExpression methodExpr = ((PsiMethodCallExpression)expr).getMethodExpression();\n      String methodName = methodExpr.getReferenceName();\n      if (methodName != null) {\n        if (\"of\".equals(methodName) || \"ofNullable\".equals(methodName)) {\n          if (isJavaUtilMethodCall((PsiMethodCallExpression)expr)) {\n            PsiExpression[] expressions = ((PsiMethodCallExpression)expr).getArgumentList().getExpressions();\n            if (expressions.length > 0) {\n              return suggestVariableNameByExpressionOnly(expressions[0], variableKind, correctKeywords, useAllMethodNames);\n            }\n          }\n        }\n        if (\"map\".equals(methodName) || \"flatMap\".equals(methodName) || \"filter\".equals(methodName)) {\n          if (isJavaUtilMethodCall((PsiMethodCallExpression)expr)) {\n            return new NamesByExprInfo(null);\n          }\n        }\n\n        String[] words = NameUtil.nameToWords(methodName);\n        if (words.length > 0) {\n          final String firstWord = words[0];\n          if (GET_PREFIX.equals(firstWord)\n              || IS_PREFIX.equals(firstWord)\n              || FIND_PREFIX.equals(firstWord)\n              || CREATE_PREFIX.equals(firstWord)) {\n            if (words.length > 1) {\n              final String propertyName = methodName.substring(firstWord.length());\n              String[] names = getSuggestionsByName(propertyName, variableKind, false, correctKeywords);\n              final PsiExpression qualifierExpression = methodExpr.getQualifierExpression();\n              if (qualifierExpression instanceof PsiReferenceExpression &&\n                  ((PsiReferenceExpression)qualifierExpression).resolve() instanceof PsiVariable) {\n                names = ArrayUtil.append(names, StringUtil\n                  .sanitizeJavaIdentifier(changeIfNotIdentifier(qualifierExpression.getText() + StringUtil.capitalize(propertyName))));\n              }\n              return new NamesByExprInfo(propertyName, names);\n            }\n          }\n          else if (words.length == 1 || useAllMethodNames) {\n            return new NamesByExprInfo(methodName, getSuggestionsByName(methodName, variableKind, false, correctKeywords));\n          }\n        }\n      }\n    }\n    else if (expr instanceof PsiReferenceExpression) {\n      String propertyName = ((PsiReferenceExpression)expr).getReferenceName();\n      PsiElement refElement = ((PsiReferenceExpression)expr).resolve();\n      if (refElement instanceof PsiVariable) {\n        VariableKind refVariableKind = getVariableKind((PsiVariable)refElement);\n        propertyName = variableNameToPropertyName(propertyName, refVariableKind);\n      }\n      if (refElement != null && propertyName != null) {\n        String[] names = getSuggestionsByName(propertyName, variableKind, false, correctKeywords);\n        return new NamesByExprInfo(propertyName, names);\n      }\n    }\n    else if (expr instanceof PsiArrayAccessExpression) {\n      PsiExpression arrayExpr = ((PsiArrayAccessExpression)expr).getArrayExpression();\n      if (arrayExpr instanceof PsiReferenceExpression) {\n        String arrayName = ((PsiReferenceExpression)arrayExpr).getReferenceName();\n        PsiElement refElement = ((PsiReferenceExpression)arrayExpr).resolve();\n        if (refElement instanceof PsiVariable) {\n          VariableKind refVariableKind = getVariableKind((PsiVariable)refElement);\n          arrayName = variableNameToPropertyName(arrayName, refVariableKind);\n        }\n\n        if (arrayName != null) {\n          String name = StringUtil.unpluralize(arrayName);\n          if (name != null) {\n            String[] names = getSuggestionsByName(name, variableKind, false, correctKeywords);\n            return new NamesByExprInfo(name, names);\n          }\n        }\n      }\n    }\n    else if (expr instanceof PsiLiteralExpression && variableKind == VariableKind.STATIC_FINAL_FIELD) {\n      final PsiLiteralExpression literalExpression = (PsiLiteralExpression)expr;\n      final Object value = literalExpression.getValue();\n      if (value instanceof String) {\n        final String stringValue = (String)value;\n        String[] names = getSuggestionsByValue(stringValue);\n        if (names.length > 0) {\n          return new NamesByExprInfo(null, constantValueToConstantName(names));\n        }\n      }\n    } else if (expr instanceof PsiParenthesizedExpression) {\n      final PsiExpression expression = ((PsiParenthesizedExpression)expr).getExpression();\n      if (expression != null) {\n        return suggestVariableNameByExpressionOnly(expression, variableKind, correctKeywords, useAllMethodNames);\n      }\n    } else if (expr instanceof PsiTypeCastExpression) {\n      final PsiExpression operand = ((PsiTypeCastExpression)expr).getOperand();\n      if (operand != null) {\n        return suggestVariableNameByExpressionOnly(operand, variableKind, correctKeywords, useAllMethodNames);\n      }\n    } else if (expr instanceof PsiLiteralExpression) {\n      final String text = StringUtil.unquoteString(expr.getText());\n      if (isIdentifier(text)) {\n        return new NamesByExprInfo(text, getSuggestionsByName(text, variableKind, false, correctKeywords));\n      }\n    } else if (expr instanceof PsiFunctionalExpression) {\n      final PsiType functionalInterfaceType = ((PsiFunctionalExpression)expr).getFunctionalInterfaceType();\n      if (functionalInterfaceType != null) {\n        final String[] namesByType = suggestVariableNameByType(functionalInterfaceType, variableKind, correctKeywords);\n        return new NamesByExprInfo(null, namesByType);\n      }\n    }\n\n    return new NamesByExprInfo(null, ArrayUtil.EMPTY_STRING_ARRAY);\n  }","commit_id":"8c208d0c83745143a60b580f7e56359ddecf86bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitDoWhileStatement(PsiDoWhileStatement statement) {\n    startElement(statement);\n\n    PsiStatement body = statement.getBody();\n    if (body == null) return;\n    body.accept(this);\n    PsiExpression condition = statement.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n      addInstruction(new ConditionalGotoInstruction(getStartOffset(statement), false, condition));\n    }\n\n    finishElement(statement);\n  }","id":72795,"modified_method":"public void visitDoWhileStatement(PsiDoWhileStatement statement) {\n    startElement(statement);\n\n    PsiStatement body = statement.getBody();\n    if (body != null) {\n      body.accept(this);\n      PsiExpression condition = statement.getCondition();\n      if (condition != null) {\n        condition.accept(this);\n        addInstruction(new ConditionalGotoInstruction(getStartOffset(statement), false, condition));\n      }\n    }\n\n    finishElement(statement);\n  }","commit_id":"f692c94f11db75742052ba82f19bbf65110957c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitExpressionStatement(PsiExpressionStatement statement) {\n    startElement(statement);\n    statement.getExpression().accept(this);\n    addInstruction(new PopInstruction());\n    finishElement(statement);\n  }","id":72796,"modified_method":"public void visitExpressionStatement(PsiExpressionStatement statement) {\n    startElement(statement);\n    final PsiExpression expr = statement.getExpression();\n    if (expr != null) {\n      expr.accept(this);\n      addInstruction(new PopInstruction());\n    }\n    finishElement(statement);\n  }","commit_id":"f692c94f11db75742052ba82f19bbf65110957c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyType getType(@NotNull TypeEvalContext context) {\n    if (!TypeEvalStack.mayEvaluate(this)) {\n      return null;\n    }\n    try {\n      if (PyNames.ALL.equals(getName())) {\n        // no type for __all__, to avoid unresolved reference errors for expressions where a qualifier is a name\n        // imported via __all__\n        return null;\n      }\n      if (!context.maySwitchToAST(this)) {\n        return null;\n      }\n      PyType type = getTypeFromDocString(this);\n      if (type != null) {\n        return type;\n      }\n      final PsiElement parent = getParent();\n      if (parent instanceof PyAssignmentStatement) {\n        final PyAssignmentStatement assignmentStatement = (PyAssignmentStatement)parent;\n        final PyExpression assignedValue = assignmentStatement.getAssignedValue();\n        if (assignedValue != null) {\n          if (assignedValue instanceof PyReferenceExpressionImpl) {\n            final PyReferenceExpressionImpl refex = (PyReferenceExpressionImpl)assignedValue;\n            PyType maybe_type = PyUtil.getSpecialAttributeType(refex, context);\n            if (maybe_type != null) return maybe_type;\n            final PyResolveContext resolveContext = PyResolveContext.noImplicits().withTypeEvalContext(context);\n            final ResolveResult[] resolveResult = refex.getReference(resolveContext).multiResolve(false);\n            if (resolveResult.length == 1) {\n              PsiElement target = resolveResult[0].getElement();\n              if (target == this || target == null) {\n                return null;  // fix SOE on \"a = a\"\n              }\n              final PyType typeFromTarget = PyReferenceExpressionImpl.getTypeFromTarget(target, context, refex);\n              if (target instanceof PyTargetExpression && typeFromTarget instanceof PyNoneType) {\n                // this usually means that the variable is initialized to a non-None value somewhere else where we haven't looked\n                return null;\n              }\n              Ref<PyType> typeOfProperty = refex.getTypeOfProperty(context);\n              if (typeOfProperty != null) {\n                return typeOfProperty.get();\n              }\n              return typeFromTarget;\n            }\n          }\n          return context.getType(assignedValue);\n        }\n      }\n      if (parent instanceof PyTupleExpression) {\n        final PyType typeFromTupleAssignment = getTypeFromTupleAssignment(context);\n        if (typeFromTupleAssignment != null) {\n          return typeFromTupleAssignment;\n        }\n      }\n      if (parent instanceof PyWithItem) {\n        final PyWithItem item = (PyWithItem)parent;\n        final PyType exprType = item.getExpression().getType(context);\n        if (exprType instanceof PyClassType) {\n          final PyClass cls = ((PyClassType)exprType).getPyClass();\n          if (cls != null) {\n            final PyFunction enter = cls.findMethodByName(PyNames.ENTER, true);\n            if (enter != null) {\n              return enter.getReturnType(context, null);\n            }\n          }\n        }\n        return null;\n      }\n      PyType iterType = getTypeFromIteration(context);\n      if (iterType != null) {\n        return iterType;\n      }\n      PyType excType = getTypeFromExcept();\n      if (excType != null) {\n        return excType;\n      }\n      return null;\n    }\n    finally {\n      TypeEvalStack.evaluated(this);\n    }\n  }","id":72797,"modified_method":"public PyType getType(@NotNull TypeEvalContext context) {\n    if (!TypeEvalStack.mayEvaluate(this)) {\n      return null;\n    }\n    try {\n      if (PyNames.ALL.equals(getName())) {\n        // no type for __all__, to avoid unresolved reference errors for expressions where a qualifier is a name\n        // imported via __all__\n        return null;\n      }\n      if (!context.maySwitchToAST(this)) {\n        return null;\n      }\n      PyType type = getTypeFromDocString(this);\n      if (type != null) {\n        return type;\n      }\n      final PsiElement parent = getParent();\n      if (parent instanceof PyAssignmentStatement) {\n        final PyAssignmentStatement assignmentStatement = (PyAssignmentStatement)parent;\n        final PyExpression assignedValue = assignmentStatement.getAssignedValue();\n        if (assignedValue != null) {\n          if (assignedValue instanceof PyReferenceExpressionImpl) {\n            final PyReferenceExpressionImpl refex = (PyReferenceExpressionImpl)assignedValue;\n            PyType maybe_type = PyUtil.getSpecialAttributeType(refex, context);\n            if (maybe_type != null) return maybe_type;\n            final PyResolveContext resolveContext = PyResolveContext.noImplicits().withTypeEvalContext(context);\n            final ResolveResult[] resolveResult = refex.getReference(resolveContext).multiResolve(false);\n            if (resolveResult.length == 1) {\n              PsiElement target = resolveResult[0].getElement();\n              if (target == this || target == null) {\n                return null;  // fix SOE on \"a = a\"\n              }\n              final PyType typeFromTarget = PyReferenceExpressionImpl.getTypeFromTarget(target, context, refex);\n              if (target instanceof PyTargetExpression && typeFromTarget instanceof PyNoneType) {\n                // this usually means that the variable is initialized to a non-None value somewhere else where we haven't looked\n                return null;\n              }\n              Ref<PyType> typeOfProperty = refex.getTypeOfProperty(context);\n              if (typeOfProperty != null) {\n                return typeOfProperty.get();\n              }\n              return typeFromTarget;\n            }\n          }\n          return context.getType(assignedValue);\n        }\n      }\n      if (parent instanceof PyTupleExpression) {\n        final PyType typeFromTupleAssignment = getTypeFromTupleAssignment(context);\n        if (typeFromTupleAssignment != null) {\n          return typeFromTupleAssignment;\n        }\n      }\n      if (parent instanceof PyWithItem) {\n        final PyWithItem item = (PyWithItem)parent;\n        final PyExpression expression = item.getExpression();\n        if (expression != null) {\n          final PyType exprType = expression.getType(context);\n          if (exprType instanceof PyClassType) {\n            final PyClass cls = ((PyClassType)exprType).getPyClass();\n            if (cls != null) {\n              final PyFunction enter = cls.findMethodByName(PyNames.ENTER, true);\n              if (enter != null) {\n                return enter.getReturnType(context, null);\n              }\n            }\n          }\n        }\n        return null;\n      }\n      PyType iterType = getTypeFromIteration(context);\n      if (iterType != null) {\n        return iterType;\n      }\n      PyType excType = getTypeFromExcept();\n      if (excType != null) {\n        return excType;\n      }\n      return null;\n    }\n    finally {\n      TypeEvalStack.evaluated(this);\n    }\n  }","commit_id":"8fafc6684a2247b27b738bb327fffd23b3d19ba0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Add user name to provided XWiki group.\n     * \n     * @param xwikiUserName the full name of the user.\n     * @param groupName the name of the group.\n     * @param context the XWiki context.\n     */\n    // TODO move this methods in a toolkit for all platform.\n    protected void addUserToXWikiGroup(String xwikiUserName, String groupName, XWikiContext context)\n    {\n        try {\n            LOGGER.debug(\"Adding user [{}] to xwiki group [{}]\", xwikiUserName, groupName);\n\n            BaseClass groupClass = context.getWiki().getGroupClass(context);\n\n            // Get document representing group\n            XWikiDocument groupDoc = context.getWiki().getDocument(groupName, context);\n\n            synchronized (groupDoc) {\n                // Make extra sure the group cannot contain duplicate (even if this method is not supposed to be called\n                // in this case)\n                for (BaseObject memberObj : groupDoc.getXObjects(groupClass.getDocumentReference())) {\n                    if (memberObj != null) {\n                        String existingMember = memberObj.getStringValue(XWIKI_GROUP_MEMBERFIELD);\n                        if (existingMember != null && existingMember.equals(xwikiUserName)) {\n                            LOGGER.warn(\"User [{}] already exist in group [{}]\", xwikiUserName,\n                                groupDoc.getDocumentReference());\n                            return ;\n                        }\n                    }\n                }\n\n                // Add a member object to document\n                BaseObject memberObj = groupDoc.newXObject(groupClass.getDocumentReference(), context);\n                Map<String, String> map = new HashMap<String, String>();\n                map.put(XWIKI_GROUP_MEMBERFIELD, xwikiUserName);\n                groupClass.fromMap(map, memberObj);\n\n                // If the document is new, set its content\n                if (groupDoc.isNew()) {\n                    groupDoc.setSyntax(Syntax.XWIKI_2_0);\n                    groupDoc.setContent(\"{{include reference='XWiki.XWikiGroupSheet' /}}\");\n                }\n\n                // Save modifications\n                context.getWiki().saveDocument(groupDoc, context);\n            }\n\n            LOGGER.debug(\"Finished adding user [{}] to xwiki group [{}]\", xwikiUserName, groupName);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to add a user [{}] to a group [{}]\", new Object[] {xwikiUserName, groupName, e});\n        }\n    }","id":72798,"modified_method":"/**\n     * Add user name to provided XWiki group.\n     * \n     * @param xwikiUserName the full name of the user.\n     * @param groupName the name of the group.\n     * @param context the XWiki context.\n     */\n    // TODO move this methods in a toolkit for all platform.\n    protected void addUserToXWikiGroup(String xwikiUserName, String groupName, XWikiContext context)\n    {\n        try {\n            LOGGER.debug(\"Adding user [{}] to xwiki group [{}]\", xwikiUserName, groupName);\n\n            BaseClass groupClass = context.getWiki().getGroupClass(context);\n\n            // Get document representing group\n            XWikiDocument groupDoc = context.getWiki().getDocument(groupName, context);\n\n            synchronized (groupDoc) {\n                // Make extra sure the group cannot contain duplicate (even if this method is not supposed to be called\n                // in this case)\n                List<BaseObject> xobjects = groupDoc.getXObjects(groupClass.getDocumentReference());\n                if (xobjects != null) {\n                    for (BaseObject memberObj : xobjects) {\n                        if (memberObj != null) {\n                            String existingMember = memberObj.getStringValue(XWIKI_GROUP_MEMBERFIELD);\n                            if (existingMember != null && existingMember.equals(xwikiUserName)) {\n                                LOGGER.warn(\"User [{}] already exist in group [{}]\", xwikiUserName,\n                                    groupDoc.getDocumentReference());\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                // Add a member object to document\n                BaseObject memberObj = groupDoc.newXObject(groupClass.getDocumentReference(), context);\n                Map<String, String> map = new HashMap<String, String>();\n                map.put(XWIKI_GROUP_MEMBERFIELD, xwikiUserName);\n                groupClass.fromMap(map, memberObj);\n\n                // If the document is new, set its content\n                if (groupDoc.isNew()) {\n                    groupDoc.setSyntax(Syntax.XWIKI_2_0);\n                    groupDoc.setContent(\"{{include reference='XWiki.XWikiGroupSheet' /}}\");\n                }\n\n                // Save modifications\n                context.getWiki().saveDocument(groupDoc, context);\n            }\n\n            LOGGER.debug(\"Finished adding user [{}] to xwiki group [{}]\", xwikiUserName, groupName);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to add a user [{}] to a group [{}]\", new Object[] {xwikiUserName, groupName, e});\n        }\n    }","commit_id":"17036a353a10ce1815b74993b15230e6a62b009a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Compare all version located in a document to find the last one.\n     * \n     * @param document the extension document\n     * @return the last version\n     */\n    private String findLastVersion(XWikiDocument document)\n    {\n        DocumentReference versionClassReference =\n            getClassReference(document, XWikiRepositoryModel.EXTENSIONVERSION_CLASSREFERENCE);\n\n        List<BaseObject> versionObjects = document.getXObjects(versionClassReference);\n\n        String lastVersion = null;\n        for (BaseObject versionObject : versionObjects) {\n            String version = versionObject.getStringValue(XWikiRepositoryModel.PROP_VERSION_VERSION);\n            if (version != null) {\n                if (lastVersion == null || this.versionManager.compareVersions(version, lastVersion) > 0) {\n                    lastVersion = version;\n                }\n            }\n        }\n\n        return lastVersion;\n    }","id":72799,"modified_method":"/**\n     * Compare all version located in a document to find the last one.\n     * \n     * @param document the extension document\n     * @return the last version\n     */\n    private String findLastVersion(XWikiDocument document)\n    {\n        DocumentReference versionClassReference =\n            getClassReference(document, XWikiRepositoryModel.EXTENSIONVERSION_CLASSREFERENCE);\n\n        List<BaseObject> versionObjects = document.getXObjects(versionClassReference);\n\n        String lastVersion = null;\n        if (versionObjects != null) {\n            for (BaseObject versionObject : versionObjects) {\n                String version = versionObject.getStringValue(XWikiRepositoryModel.PROP_VERSION_VERSION);\n                if (version != null) {\n                    if (lastVersion == null || this.versionManager.compareVersions(version, lastVersion) > 0) {\n                        lastVersion = version;\n                    }\n                }\n            }\n        }\n\n        return lastVersion;\n    }","commit_id":"029826d7afe73b6d250518f506177445903500f0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void validateExtension(XWikiDocument document, XWikiContext context)\n    {\n        BaseObject extension = document.getXObject(XWikiRepositoryModel.EXTENSION_CLASSREFERENCE);\n\n        if (extension != null) {\n            boolean valid = !StringUtils.isBlank(extension.getStringValue(XWikiRepositoryModel.PROP_EXTENSION_ID));\n            if (valid) {\n                int nbVersions = 0;\n                for (BaseObject extensionVersion : document.getXObjects(XWikiRepositoryModel.EXTENSIONVERSION_CLASSREFERENCE)) {\n                    if (extensionVersion != null) {\n                        valid &=\n                            !StringUtils.isBlank(extensionVersion\n                                .getStringValue(XWikiRepositoryModel.PROP_VERSION_VERSION));\n\n                        ++nbVersions;\n                    }\n                }\n\n                valid &= nbVersions > 0;\n            }\n\n            int currentValue = extension.getIntValue(XWikiRepositoryModel.PROP_EXTENSION_VALIDEXTENSION, 0);\n\n            if ((currentValue == 1) != valid) {\n                try {\n                    // FIXME: We can't save directly the provided document coming from the event\n                    document = context.getWiki().getDocument(document, context);\n                    extension = document.getXObject(XWikiRepositoryModel.EXTENSION_CLASSREFERENCE);\n\n                    extension.setIntValue(XWikiRepositoryModel.PROP_EXTENSION_VALIDEXTENSION, valid ? 1 : 0);\n\n                    context.getWiki().saveDocument(document, \"Validate extension\", context);\n                } catch (XWikiException e) {\n                    this.logger.error(\"Failed to validate extension [{}]\", document, e);\n                }\n            }\n        }\n    }","id":72800,"modified_method":"private void validateExtension(XWikiDocument document, XWikiContext context)\n    {\n        BaseObject extension = document.getXObject(XWikiRepositoryModel.EXTENSION_CLASSREFERENCE);\n\n        if (extension != null) {\n            boolean valid = !StringUtils.isBlank(extension.getStringValue(XWikiRepositoryModel.PROP_EXTENSION_ID));\n            if (valid) {\n                int nbVersions = 0;\n                List<BaseObject> extensionVersions =\n                    document.getXObjects(XWikiRepositoryModel.EXTENSIONVERSION_CLASSREFERENCE);\n                if (extensionVersions != null) {\n                    for (BaseObject extensionVersion : extensionVersions) {\n                        if (extensionVersion != null) {\n                            valid &=\n                                !StringUtils.isBlank(extensionVersion\n                                    .getStringValue(XWikiRepositoryModel.PROP_VERSION_VERSION));\n\n                            ++nbVersions;\n                        }\n                    }\n                }\n\n                valid &= nbVersions > 0;\n            }\n\n            int currentValue = extension.getIntValue(XWikiRepositoryModel.PROP_EXTENSION_VALIDEXTENSION, 0);\n\n            if ((currentValue == 1) != valid) {\n                try {\n                    // FIXME: We can't save directly the provided document coming from the event\n                    document = context.getWiki().getDocument(document, context);\n                    extension = document.getXObject(XWikiRepositoryModel.EXTENSION_CLASSREFERENCE);\n\n                    extension.setIntValue(XWikiRepositoryModel.PROP_EXTENSION_VALIDEXTENSION, valid ? 1 : 0);\n\n                    context.getWiki().saveDocument(document, \"Validate extension\", context);\n                } catch (XWikiException e) {\n                    this.logger.error(\"Failed to validate extension [{}]\", document, e);\n                }\n            }\n        }\n    }","commit_id":"029826d7afe73b6d250518f506177445903500f0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public DefaultWikiDescriptor buildDescriptorObject(List<BaseObject> serverClassObjects, XWikiDocument document)\n    {\n        // Create a Wiki object with the first XWikiServerClass object\n        DefaultWikiDescriptor descriptor = extractWikiDescriptor(serverClassObjects.get(0), document);\n\n        if (descriptor != null) {\n            // Create WikiAlias instances for the other XWikiServerClass objects\n            for (int i = 1; i < serverClassObjects.size(); i++) {\n                String descriptorAlias = extractWikiAlias(serverClassObjects.get(i));\n                descriptor.addAlias(descriptorAlias);\n            }\n\n            // load properties\n            BaseObject object = serverClassObjects.get(0);\n            descriptor.setMainPageReference(referenceResolver.resolve(\n                    object.getStringValue(XWikiServerClassDocumentInitializer.FIELD_HOMEPAGE)));\n            //descriptor.setHidden(object.getIntValue(XWikiServerClassDocumentInitializer.FI));\n            descriptor.setPrettyName(object.getStringValue(XWikiServerClassDocumentInitializer.FIELD_WIKIPRETTYNAME));\n            descriptor.setOwnerId(object.getStringValue(XWikiServerClassDocumentInitializer.FIELD_OWNER));\n            descriptor.setDescription(object.getStringValue(XWikiServerClassDocumentInitializer.FIELD_DESCRIPTION));\n\n            // load the property groups\n            try {\n                WikiPropertyGroupManager wikiPropertyGroupManager = wikiPropertyGroupManagerProvider.get();\n                wikiPropertyGroupManager.loadForDescriptor(descriptor);\n            } catch (WikiPropertyGroupException e) {\n                // log\n            }\n        }\n\n        return descriptor;\n    }","id":72801,"modified_method":"@Override\n    public DefaultWikiDescriptor buildDescriptorObject(List<BaseObject> serverClassObjects, XWikiDocument document)\n    {\n        // Create a Wiki object with the first XWikiServerClass object\n        DefaultWikiDescriptor descriptor = extractWikiDescriptor(serverClassObjects.get(0), document);\n\n        if (descriptor != null) {\n            // Create WikiAlias instances for the other XWikiServerClass objects\n            for (int i = 1; i < serverClassObjects.size(); ++i) {\n                BaseObject serverClassObject = serverClassObjects.get(i);\n                if (serverClassObject == null) {\n                    continue;\n                }\n                String descriptorAlias = extractWikiAlias(serverClassObject);\n                descriptor.addAlias(descriptorAlias);\n            }\n\n            // load properties\n            BaseObject object = serverClassObjects.get(0);\n            descriptor.setMainPageReference(referenceResolver.resolve(\n                    object.getStringValue(XWikiServerClassDocumentInitializer.FIELD_HOMEPAGE)));\n            //descriptor.setHidden(object.getIntValue(XWikiServerClassDocumentInitializer.FI));\n            descriptor.setPrettyName(object.getStringValue(XWikiServerClassDocumentInitializer.FIELD_WIKIPRETTYNAME));\n            descriptor.setOwnerId(object.getStringValue(XWikiServerClassDocumentInitializer.FIELD_OWNER));\n            descriptor.setDescription(object.getStringValue(XWikiServerClassDocumentInitializer.FIELD_DESCRIPTION));\n\n            // load the property groups\n            try {\n                WikiPropertyGroupManager wikiPropertyGroupManager = wikiPropertyGroupManagerProvider.get();\n                wikiPropertyGroupManager.loadForDescriptor(descriptor);\n            } catch (WikiPropertyGroupException e) {\n                logger.error(\"Failed to load wiki property groups for wiki [{}].\", descriptor.getId(), e);\n            }\n        }\n\n        return descriptor;\n    }","commit_id":"0a01e1022b33be9bc6e2366fef0c1a3d9abb06a1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private DefaultWikiDescriptor buildDescriptorFromDocument(XWikiDocument document)\n    {\n        DefaultWikiDescriptor descriptor = wikiDescriptorBuilder.buildDescriptorObject(\n                document.getXObjects(DefaultWikiDescriptor.SERVER_CLASS), document);\n        // Add to the cache\n        if (descriptor != null) {\n            cache.add(descriptor);\n        }\n        return descriptor;\n    }","id":72802,"modified_method":"private DefaultWikiDescriptor buildDescriptorFromDocument(XWikiDocument document)\n    {\n        DefaultWikiDescriptor descriptor = null;\n        List<BaseObject> serverClassObjects = document.getXObjects(DefaultWikiDescriptor.SERVER_CLASS);\n        if (serverClassObjects != null) {\n            descriptor = wikiDescriptorBuilder.buildDescriptorObject(serverClassObjects, document);\n            // Add to the cache\n            if (descriptor != null) {\n                cache.add(descriptor);\n            }\n        }\n        return descriptor;\n    }","commit_id":"0a01e1022b33be9bc6e2366fef0c1a3d9abb06a1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Collection<WikiDescriptor> getAll() throws WikiManagerException\n    {\n        // Note: Ideally to improve performance we could imagine loading all XWikiServerClasses at initialization time\n        // (in initialize()) and thereafter only use the cache. The problem with this approach is that our Cache will\n        // need to be unbounded which is not the case right now. This would mean being able to put all descriptors in\n        // the cache and thus it might not scale if there were a very large number of wikis.\n\n        List<WikiDescriptor> result = new ArrayList<WikiDescriptor>();\n\n        try {\n            List<XWikiDocument> documents = descriptorDocumentHelper.getAllXWikiServerClassDocument();\n            for (XWikiDocument document : documents) {\n                // Extract the Wiki\n                DefaultWikiDescriptor descriptor = buildDescriptorFromDocument(document);\n                // Add it to the result list\n                result.add(descriptor);\n            }\n        } catch (Exception e) {\n            throw new WikiManagerException(\"Failed to locate XWiki.XWikiServerClass documents\", e);\n        }\n\n        return result;\n    }","id":72803,"modified_method":"@Override\n    public Collection<WikiDescriptor> getAll() throws WikiManagerException\n    {\n        // Note: Ideally to improve performance we could imagine loading all XWikiServerClasses at initialization time\n        // (in initialize()) and thereafter only use the cache. The problem with this approach is that our Cache will\n        // need to be unbounded which is not the case right now. This would mean being able to put all descriptors in\n        // the cache and thus it might not scale if there were a very large number of wikis.\n\n        List<WikiDescriptor> result = new ArrayList<WikiDescriptor>();\n\n        try {\n            List<XWikiDocument> documents = descriptorDocumentHelper.getAllXWikiServerClassDocument();\n            for (XWikiDocument document : documents) {\n                // Extract the Wiki\n                DefaultWikiDescriptor descriptor = buildDescriptorFromDocument(document);\n                // Add it to the result list\n                if (descriptor != null) {\n                    result.add(descriptor);\n                }\n            }\n        } catch (Exception e) {\n            throw new WikiManagerException(\"Failed to locate XWiki.XWikiServerClass documents\", e);\n        }\n\n        return result;\n    }","commit_id":"0a01e1022b33be9bc6e2366fef0c1a3d9abb06a1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public DocumentReference importExtension(String extensionId, ExtensionRepository repository, Type type)\n        throws QueryException, XWikiException, ResolveException\n    {\n        IterableResult<Version> versionsIterable = repository.resolveVersions(extensionId, 0, -1);\n\n        Version lastVersion = null;\n\n        Set<Version> versions = new LinkedHashSet<Version>(versionsIterable.getSize());\n        for (Version version : versionsIterable) {\n            if (type == null || version.getType() == type) {\n                versions.add(version);\n            }\n\n            lastVersion = version;\n        }\n\n        Extension extension = repository.resolve(new ExtensionId(extensionId, lastVersion));\n\n        XWikiContext xcontext = getXWikiContext();\n\n        boolean needSave = false;\n\n        XWikiDocument document = getExistingExtensionDocumentById(extensionId);\n\n        if (document == null) {\n            // Create document\n            document =\n                xcontext.getWiki().getDocument(\n                    new DocumentReference(xcontext.getDatabase(), \"Extension\", extension.getName()), xcontext);\n\n            for (int i = 1; !document.isNew(); ++i) {\n                document =\n                    xcontext.getWiki().getDocument(\n                        new DocumentReference(xcontext.getDatabase(), \"Extension\", extension.getName() + ' ' + i),\n                        xcontext);\n            }\n\n            XWikiDocument template =\n                xcontext.getWiki().getDocument(\n                    this.currentResolver.resolve(XWikiRepositoryModel.EXTENSION_TEMPLATEREFERENCE), xcontext);\n\n            if (!template.isNew()) {\n                document.apply(template);\n            }\n\n            needSave = true;\n        }\n\n        // Update document\n\n        BaseObject extensionObject = document.getXObject(XWikiRepositoryModel.EXTENSION_CLASSREFERENCE);\n        if (extensionObject == null) {\n            extensionObject = document.newXObject(XWikiRepositoryModel.EXTENSION_CLASSREFERENCE, xcontext);\n            needSave = true;\n        }\n\n        if (!StringUtils.equals(extensionId,\n            getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ID, (String) null))) {\n            extensionObject.set(XWikiRepositoryModel.PROP_EXTENSION_ID, extensionId, xcontext);\n            needSave = true;\n        }\n\n        // Update extension informations\n\n        needSave |= updateExtension(extension, extensionObject, xcontext);\n\n        // Remove unexisting version\n\n        for (BaseObject versionObject : document.getXObjects(XWikiRepositoryModel.EXTENSIONVERSION_CLASSREFERENCE)) {\n            if (versionObject != null) {\n                String version = getValue(versionObject, XWikiRepositoryModel.PROP_VERSION_VERSION);\n\n                if (version == null || !versions.contains(new DefaultVersion(version))) {\n                    document.removeXObject(versionObject);\n                    needSave = true;\n                }\n            }\n        }\n        for (BaseObject dependencyObject : document\n            .getXObjects(XWikiRepositoryModel.EXTENSIONDEPENDENCY_CLASSREFERENCE)) {\n            if (dependencyObject != null) {\n                String version = getValue(dependencyObject, XWikiRepositoryModel.PROP_DEPENDENCY_EXTENSIONVERSION);\n\n                if (version == null || !versions.contains(new DefaultVersion(version))) {\n                    document.removeXObject(dependencyObject);\n                    needSave = true;\n                }\n            }\n        }\n\n        // Update versions\n\n        for (Version version : versions) {\n            try {\n                Extension versionExtension;\n                if (version.equals(extension.getId().getVersion())) {\n                    versionExtension = extension;\n                } else {\n                    versionExtension = repository.resolve(new ExtensionId(extensionId, version));\n                }\n\n                // Update version related informations\n                needSave |= updateExtensionVersion(document, versionExtension);\n            } catch (Exception e) {\n                this.logger.error(\"Failed to resolve extension with id [\" + extensionId + \"] and version [\" + version\n                    + \"] on repository [\" + repository + \"]\", e);\n            }\n        }\n\n        // Proxy marker\n\n        BaseObject extensionProxyObject = document.getXObject(XWikiRepositoryModel.EXTENSIONPROXY_CLASSREFERENCE);\n        if (extensionProxyObject == null) {\n            extensionProxyObject = document.newXObject(XWikiRepositoryModel.EXTENSIONPROXY_CLASSREFERENCE, xcontext);\n            needSave = true;\n        }\n\n        needSave |=\n            update(extensionProxyObject, XWikiRepositoryModel.PROP_PROXY_REPOSITORYID, repository.getId().getId());\n        needSave |=\n            update(extensionProxyObject, XWikiRepositoryModel.PROP_PROXY_REPOSITORYTYPE, repository.getId().getType());\n        needSave |=\n            update(extensionProxyObject, XWikiRepositoryModel.PROP_PROXY_REPOSITORYURI, repository.getId().getURI()\n                .toString());\n\n        if (needSave) {\n            xcontext.getWiki()\n                .saveDocument(document,\n                    \"Imported extension [\" + extensionId + \"] from repository [\" + repository.getId() + \"]\", true,\n                    xcontext);\n        }\n\n        return document.getDocumentReference();\n    }","id":72804,"modified_method":"@Override\n    public DocumentReference importExtension(String extensionId, ExtensionRepository repository, Type type)\n        throws QueryException, XWikiException, ResolveException\n    {\n        IterableResult<Version> versionsIterable = repository.resolveVersions(extensionId, 0, -1);\n\n        Version lastVersion = null;\n\n        Set<Version> versions = new LinkedHashSet<Version>(versionsIterable.getSize());\n        for (Version version : versionsIterable) {\n            if (type == null || version.getType() == type) {\n                versions.add(version);\n            }\n\n            lastVersion = version;\n        }\n\n        if (lastVersion == null) {\n            throw new ResolveException(\"Can't find any verison for the extension [\" + extensionId + \"] on repository [\"\n                + repository + \"]\");\n        } else if (versions.isEmpty()) {\n            versions.add(lastVersion);\n        }\n\n        Extension extension = repository.resolve(new ExtensionId(extensionId, lastVersion));\n\n        XWikiContext xcontext = getXWikiContext();\n\n        boolean needSave = false;\n\n        XWikiDocument document = getExistingExtensionDocumentById(extensionId);\n\n        if (document == null) {\n            // Create document\n            document =\n                xcontext.getWiki().getDocument(\n                    new DocumentReference(xcontext.getDatabase(), \"Extension\", extension.getName()), xcontext);\n\n            for (int i = 1; !document.isNew(); ++i) {\n                document =\n                    xcontext.getWiki().getDocument(\n                        new DocumentReference(xcontext.getDatabase(), \"Extension\", extension.getName() + ' ' + i),\n                        xcontext);\n            }\n\n            XWikiDocument template =\n                xcontext.getWiki().getDocument(\n                    this.currentResolver.resolve(XWikiRepositoryModel.EXTENSION_TEMPLATEREFERENCE), xcontext);\n\n            if (!template.isNew()) {\n                document.apply(template);\n            }\n\n            needSave = true;\n        }\n\n        // Update document\n\n        BaseObject extensionObject = document.getXObject(XWikiRepositoryModel.EXTENSION_CLASSREFERENCE);\n        if (extensionObject == null) {\n            extensionObject = document.newXObject(XWikiRepositoryModel.EXTENSION_CLASSREFERENCE, xcontext);\n            needSave = true;\n        }\n\n        if (!StringUtils.equals(extensionId,\n            getValue(extensionObject, XWikiRepositoryModel.PROP_EXTENSION_ID, (String) null))) {\n            extensionObject.set(XWikiRepositoryModel.PROP_EXTENSION_ID, extensionId, xcontext);\n            needSave = true;\n        }\n\n        // Update extension informations\n\n        needSave |= updateExtension(extension, extensionObject, xcontext);\n\n        // Remove unexisting version\n\n        List<BaseObject> versionObjects = document.getXObjects(XWikiRepositoryModel.EXTENSIONVERSION_CLASSREFERENCE);\n        if (versionObjects != null) {\n            for (BaseObject versionObject : versionObjects) {\n                if (versionObject != null) {\n                    String version = getValue(versionObject, XWikiRepositoryModel.PROP_VERSION_VERSION);\n\n                    if (version == null || !versions.contains(new DefaultVersion(version))) {\n                        document.removeXObject(versionObject);\n                        needSave = true;\n                    }\n                }\n            }\n        }\n        List<BaseObject> dependencyObjects =\n            document.getXObjects(XWikiRepositoryModel.EXTENSIONDEPENDENCY_CLASSREFERENCE);\n        if (dependencyObjects != null) {\n            for (BaseObject dependencyObject : dependencyObjects) {\n                if (dependencyObject != null) {\n                    String version = getValue(dependencyObject, XWikiRepositoryModel.PROP_DEPENDENCY_EXTENSIONVERSION);\n\n                    if (version == null || !versions.contains(new DefaultVersion(version))) {\n                        document.removeXObject(dependencyObject);\n                        needSave = true;\n                    }\n                }\n            }\n        }\n\n        // Update versions\n\n        for (Version version : versions) {\n            try {\n                Extension versionExtension;\n                if (version.equals(extension.getId().getVersion())) {\n                    versionExtension = extension;\n                } else {\n                    versionExtension = repository.resolve(new ExtensionId(extensionId, version));\n                }\n\n                // Update version related informations\n                needSave |= updateExtensionVersion(document, versionExtension);\n            } catch (Exception e) {\n                this.logger.error(\"Failed to resolve extension with id [\" + extensionId + \"] and version [\" + version\n                    + \"] on repository [\" + repository + \"]\", e);\n            }\n        }\n\n        // Proxy marker\n\n        BaseObject extensionProxyObject = document.getXObject(XWikiRepositoryModel.EXTENSIONPROXY_CLASSREFERENCE);\n        if (extensionProxyObject == null) {\n            extensionProxyObject = document.newXObject(XWikiRepositoryModel.EXTENSIONPROXY_CLASSREFERENCE, xcontext);\n            needSave = true;\n        }\n\n        needSave |=\n            update(extensionProxyObject, XWikiRepositoryModel.PROP_PROXY_REPOSITORYID, repository.getId().getId());\n        needSave |=\n            update(extensionProxyObject, XWikiRepositoryModel.PROP_PROXY_REPOSITORYTYPE, repository.getId().getType());\n        needSave |=\n            update(extensionProxyObject, XWikiRepositoryModel.PROP_PROXY_REPOSITORYURI, repository.getId().getURI()\n                .toString());\n\n        if (needSave) {\n            xcontext.getWiki()\n                .saveDocument(document,\n                    \"Imported extension [\" + extensionId + \"] from repository [\" + repository.getId() + \"]\", true,\n                    xcontext);\n        }\n\n        return document.getDocumentReference();\n    }","commit_id":"87571bf8a30f28e1aa9248f730c32849b337f012","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n  public String toString( ) {\n    return String\n                 .format(\n                          \"VmInstance [imageInfo=%s, instanceId=%s, keyInfo=%s, launchIndex=%s, launchTime=%s, networkConfig=%s, networks=%s, ownerId=%s, placement=%s, privateNetwork=%s, reason=%s, reservationId=%s, state=%s, stopWatch=%s, userData=%s, vmTypeInfo=%s, volumes=%s, bundleTask=%s]\",\n                          this.imageInfo, this.instanceId, this.keyInfo, this.launchIndex, this.launchTime, this.networkConfig, this.networks, this.ownerId,\n                          this.placement, this.privateNetwork, this.reason, this.reservationId, this.state, this.stopWatch, this.userData, this.vmTypeInfo,\n                          this.volumes, LogUtil.dumpObject( this.getBundleTask( ) ) );\n  }","id":72805,"modified_method":"@Override\n  public String toString( ) {\n    return String\n                 .format(\n                          \"VmInstance [imageInfo=%s, instanceId=%s, keyInfo=%s, launchIndex=%s, launchTime=%s, networkConfig=%s, networks=%s, ownerId=%s, placement=%s, privateNetwork=%s, reason=%s, reservationId=%s, state=%s, stopWatch=%s, userData=%s, vmTypeInfo=%s, volumes=%s, bundleTask=%s]\",\n                          this.imageInfo, this.instanceId, this.keyInfo, this.launchIndex, this.launchTime, this.networkConfig, this.networks, this.ownerId,\n                          this.placement, this.privateNetwork, this.reason, this.reservationId, this.state, this.stopWatch, this.userData, this.vmTypeInfo,\n                          this.volumes, this.getBundleTask( )!=null?LogUtil.dumpObject( this.getBundleTask( ) ):\"null\" );\n  }","commit_id":"c1e7117a140b1a5fe4741d9a0bdcd010c152fa36","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Boolean startBundleTask( BundleTask task ) {\n    if( !this.bundleTask.compareAndSet( null, task, false, true ) ) {\n      if( this.getBundleTask( ) != null && BundleState.failed.equals( BundleState.valueOf( this.getBundleTask( ).getState( ) ) ) ) {\n        this.resetBundleTask( );\n        this.bundleTask.set( task, true );\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return true;\n    }\n  }","id":72806,"modified_method":"public Boolean startBundleTask( BundleTask task ) {\n    if( this.bundleTask.compareAndSet( null, task, false, true ) ) {\n      return true;\n    } else {\n      if( this.getBundleTask( ) != null && BundleState.failed.equals( BundleState.valueOf( this.getBundleTask( ).getState( ) ) ) ) {\n        this.resetBundleTask( );\n        this.bundleTask.set( task, true );\n        return true;\n      } else {\n        return false;\n      }      \n    }\n  }","commit_id":"c1e7117a140b1a5fe4741d9a0bdcd010c152fa36","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public TYPE getUnique( TYPE example ) throws EucalyptusCloudException {\n    if ( LogLevels.EXTREME ) LOG.debug( Joiner.on(\":\").join(  EventType.PERSISTENCE, DbEvent.UNIQUE.begin( ), this.tx.getTxUuid( ) ) );\n    List<TYPE> res = this.query( example );\n    if ( res.size( ) != 1 ) {\n      String msg = null;\n      try {\n        msg = LogUtil.dumpObject( example );\n      } catch ( Exception e ) {\n        msg = example.toString( );\n      }\n      if ( LogLevels.EXTREME ) LOG.debug( Joiner.on(\":\").join(  EventType.PERSISTENCE, DbEvent.QUERY.fail( ), Long.toString( this.tx.splitOperation( ) ),\n                                     this.tx.getTxUuid( ) ) );\n      throw new EucalyptusCloudException( \"Error locating information for \" + msg );\n    }\n    if ( LogLevels.EXTREME ) LOG.debug( Joiner.on(\":\").join(  EventType.PERSISTENCE, DbEvent.QUERY.end( ), Long.toString( this.tx.splitOperation( ) ),\n                                   this.tx.getTxUuid( ) ) );\n    return res.get( 0 );\n  }","id":72807,"modified_method":"public TYPE getUnique( TYPE example ) throws EucalyptusCloudException {\n    if ( LogLevels.EXTREME ) LOG.debug( Joiner.on(\":\").join( EventType.PERSISTENCE, DbEvent.UNIQUE.begin( ), this.tx.getTxUuid( ) ) );\n    Object id = null;\n    try {\n      id = this.getEntityManager( ).getEntityManagerFactory( ).getPersistenceUnitUtil( ).getIdentifier( example );\n    } catch ( Exception ex ) {\n    }\n    if( id != null ) {\n      TYPE res = ( TYPE ) this.getEntityManager( ).find( example.getClass( ), id );\n      if( res == null ) {\n        throw new EucalyptusCloudException( \"Get unique failed (returning 0 results for \" + LogUtil.dumpObject( example ) );\n      } else {\n        return res;\n      }\n    } else {\n      List<TYPE> res = this.query( example );\n      if ( res.size( ) != 1 ) {\n        throw new EucalyptusCloudException( \"Get unique failed (returning \" + res.size( ) + \" results for \" + LogUtil.dumpObject( example ) );\n      }\n      return res.get( 0 );\n    }\n  }","commit_id":"b76b5845f52b4bac3d76aa7bc6291b8ece7e991a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public TYPE getUnique( TYPE example ) throws EucalyptusCloudException {\n    if ( LogLevels.EXTREME ) LOG.debug( Joiner.on(\":\").join(  EventType.PERSISTENCE, DbEvent.UNIQUE.begin( ), this.tx.getTxUuid( ) ) );\n    Object id = null;\n    try {\n      id = this.getEntityManager( ).getEntityManagerFactory( ).getPersistenceUnitUtil( ).getIdentifier( example );\n    } catch ( Exception ex ) {\n    }\n    if( id != null ) {\n      return ( TYPE ) this.getEntityManager( ).find( example.getClass( ), id );\n    } else {\n      List<TYPE> res = this.query( example );\n      if ( res.size( ) != 1 ) {\n        String msg = null;\n        try {\n          msg = LogUtil.dumpObject( example );\n        } catch ( Exception e ) {\n          msg = example.toString( );\n        }\n        throw new EucalyptusCloudException( \"Get unique failed (returning \" + res.size( ) + \" results for \" + msg );\n      }\n    return res.get( 0 );\n    }\n  }","id":72808,"modified_method":"public TYPE getUnique( TYPE example ) throws EucalyptusCloudException {\n    if ( LogLevels.EXTREME ) LOG.debug( Joiner.on(\":\").join(  EventType.PERSISTENCE, DbEvent.UNIQUE.begin( ), this.tx.getTxUuid( ) ) );\n    Object id = null;\n    try {\n      id = this.getEntityManager( ).getEntityManagerFactory( ).getPersistenceUnitUtil( ).getIdentifier( example );\n    } catch ( Exception ex ) {\n    }\n    if( id != null ) {\n      TYPE res = ( TYPE ) this.getEntityManager( ).find( example.getClass( ), id );\n      if( res == null ) {\n        throw new EucalyptusCloudException( \"Get unique failed (returning 0 results for \" + LogUtil.dumpObject( example ) );\n      } else {\n        return res;\n      }\n    } else {\n      List<TYPE> res = this.query( example );\n      if ( res.size( ) != 1 ) {\n        throw new EucalyptusCloudException( \"Get unique failed (returning \" + res.size( ) + \" results for \" + LogUtil.dumpObject( example ) );\n      }\n    return res.get( 0 );\n    }\n  }","commit_id":"4982f10f6c35ebcfecf4e07c6d208f829512ffbb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void main(String[] args) throws IOException {\n\t\tBinaryInspector in = new BinaryInspector();\n\t\t// test cases show info\n\t\tif(args.length == 1 && \"test\".equals(args[0])) {\n\t\t\tin.inspector(new String[]{\n//\t\t\t\t\"-vpoi\",\n\t\t\t\t\"-vmap\", \"-vmapobjects\", \n//\t\t\t\t\"-vrouting\",\n//\t\t\t\t\"-vaddress\", \"-vcities\", \"-vstreets\", \"-vstreetgroups\",\"-vbuildings\", \n//\t\t\t\t\"-zoom=16\",\n//\t\t\t\t\"-bbox=1.74,51.17,1.75,51.16\", \n\t\t\t\t\"/home/victor/projects/osmand/osm-gen/Map.obf\"\n\t\t\t\t\t});\n\t\t} else {\n\t\t\tin.inspector(args);\n\t\t}\n\t}","id":72809,"modified_method":"public static void main(String[] args) throws IOException {\n\t\tBinaryInspector in = new BinaryInspector();\n\t\t// test cases show info\n\t\tif(args.length == 1 && \"test\".equals(args[0])) {\n\t\t\tin.inspector(new String[]{\n\t\t\t\t\"-vpoi\",\n//\t\t\t\t\"-vmap\", \"-vmapobjects\", \n//\t\t\t\t\"-vrouting\",\n//\t\t\t\t\"-vaddress\", \"-vcities\", \"-vstreets\", \"-vstreetgroups\",\"-vbuildings\", \n//\t\t\t\t\"-zoom=16\",\n//\t\t\t\t\"-bbox=1.74,51.17,1.75,51.16\", \n\t\t\t\t\"/home/victor/projects/osmand/osm-gen/Map.obf\"\n\t\t\t\t\t});\n\t\t} else {\n\t\t\tin.inspector(args);\n\t\t}\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private TurnType attachKeepLeftInfoAndLanes(boolean leftSide, RouteSegmentResult prevSegm, RouteSegmentResult currentSegm, TurnType t) {\n\t\t// keep left/right\n\t\tboolean kl = false;\n\t\tboolean kr = false;\n\t\tList<RouteSegmentResult> attachedRoutes = currentSegm.getAttachedRoutes(currentSegm.getStartPointIndex());\n\t\tint ls = prevSegm.getObject().getLanes();\n\t\tif(ls >= 0 && prevSegm.getObject().getOneway() == 0) {\n\t\t\tls = (ls + 1) / 2;\n\t\t}\n\t\tint left = 0;\n\t\tint right = 0;\n\t\tboolean speak = false;\n\t\tint speakPriority = Math.max(highwaySpeakPriority(prevSegm.getObject().getHighway()), highwaySpeakPriority(currentSegm.getObject().getHighway()));\n\t\tboolean otherRoutesExist = false;\n\t\tif (attachedRoutes != null) {\n\t\t\tfor (RouteSegmentResult attached : attachedRoutes) {\n\t\t\t\tdouble ex = MapUtils.degreesDiff(attached.getBearingBegin(), currentSegm.getBearingBegin());\n\t\t\t\tdouble mpi = Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(), attached.getBearingBegin()));\n\t\t\t\tint rsSpeakPriority = highwaySpeakPriority(attached.getObject().getHighway());\n\t\t\t\tif (rsSpeakPriority != MAX_SPEAK_PRIORITY || speakPriority == MAX_SPEAK_PRIORITY) {\n\t\t\t\t\tif ((ex < TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex >= 0) {\n\t\t\t\t\t\tkl = true;\n\t\t\t\t\t\tright += countLanesMinOne(attached);\n\t\t\t\t\t\tspeak = speak || rsSpeakPriority <= speakPriority;\n\t\t\t\t\t} else if ((ex > -TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex <= 0) {\n\t\t\t\t\t\tkr = true;\n\t\t\t\t\t\tleft += countLanesMinOne(attached);\n\t\t\t\t\t\tspeak = speak || rsSpeakPriority <= speakPriority;\n\t\t\t\t\t} else if (mpi >= TURN_DEGREE_MIN) {\n\t\t\t\t\t\t// Indicate that there are other turns at this intersection, and displaying the lanes may be helpful here.\n\t\t\t\t\t\totherRoutesExist = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(kr && left == 0) {\n\t\t\tleft = 1;\n\t\t} else if(kl && right == 0) {\n\t\t\tright = 1;\n\t\t}\n\t\tint current = countLanesMinOne(currentSegm);\n\t\tint[] lanes = new int[current + left + right];\n\t\tls = current + left + right;\n\t\tfor (int it = 0; it < ls; it++) {\n\t\t\tif (it < left || it >= left + current) {\n\t\t\t\tlanes[it] = 0;\n\t\t\t} else {\n\t\t\t\tlanes[it] = 1;\n\t\t\t}\n\t\t}\n\t\t// sometimes links are\n\t\tif ((current <= left + right) && (left > 1 || right > 1)) {\n\t\t\tspeak = true;\n\t\t}\n\n\t\tdouble devation = Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(), currentSegm.getBearingBegin()));\n\t\tboolean makeSlightTurn = devation > 5 && (!isMotorway(prevSegm) || !isMotorway(currentSegm));\n\t\tif (kl && kr) {\n\t\t\tt = TurnType.valueOf(TurnType.C, leftSide);\n\t\t\tt.setSkipToSpeak(!speak);\n\t\t} else if (kl) {\n\t\t\tt = TurnType.valueOf(makeSlightTurn ? TurnType.TSLL : TurnType.KL, leftSide);\n\t\t\tt.setSkipToSpeak(!speak);\n\t\t} else if (kr) {\n\t\t\tt = TurnType.valueOf(makeSlightTurn ? TurnType.TSLR : TurnType.KR, leftSide);\n\t\t\tt.setSkipToSpeak(!speak);\n\t\t} else if (otherRoutesExist && getTurnLanesString(prevSegm) != null) {\n\t\t\t// Maybe going straight at a 90-degree intersection\n\t\t\tt = TurnType.valueOf(TurnType.C, leftSide);\n\t\t\tt.setSkipToSpeak(true);\n\n\t\t\t// When going straight, the lanes have to be calculated from the previous segment, not the current/next segment.\n\t\t\tint prevLanes = countLanesMinOne(prevSegm);\n\n\t\t\tt.setLanes(attachTurnLanesData(prevSegm, new int[prevLanes]));\n\n\t\t\t// Manually set the allowed lanes based on the turn type\n\t\t\tfor (int i = 0; i < t.getLanes().length; i++) {\n\t\t\t\tif (TurnType.getPrimaryTurn(t.getLanes()[i]) == TurnType.C) {\n\t\t\t\t\tt.getLanes()[i] |= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn t;\n\t\t}\n\t\tif (t != null && lanes != null) {\n\t\t\tint[] calcLanes = attachTurnLanesData(prevSegm, lanes);\n\t\t\tif(calcLanes != lanes) {\n\t\t\t\tint tp = inferTurnFromLanes(calcLanes);\n\t\t\t\tif (tp != 0 && tp != t.getValue()) {\n\t\t\t\t\tTurnType derivedTurnType = TurnType.valueOf(tp, leftSide);\n\t\t\t\t\tderivedTurnType.setLanes(calcLanes);\n\t\t\t\t\tderivedTurnType.setSkipToSpeak(t.isSkipToSpeak());\n\t\t\t\t\t// Because only the primary turn is displayed, if the turn to be taken is currently set as the\n\t\t\t\t\t// secondary turn, then that needs to be switched around.\n\t\t\t\t\tfor (int i = 0; i < calcLanes.length; i++) {\n\t\t\t\t\t\tif (TurnType.getSecondaryTurn(calcLanes[i]) == tp) {\n\t\t\t\t\t\t\tderivedTurnType.setSecondaryTurn(i, TurnType.getPrimaryTurn(calcLanes[i]));\n\t\t\t\t\t\t\tderivedTurnType.setPrimaryTurn(i, tp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.setLanes(calcLanes);\n\t\t\t\n\t\t}\n\t\treturn t;\n\t}","id":72810,"modified_method":"private TurnType attachKeepLeftInfoAndLanes(boolean leftSide, RouteSegmentResult prevSegm, RouteSegmentResult currentSegm) {\n\t\tList<RouteSegmentResult> attachedRoutes = currentSegm.getAttachedRoutes(currentSegm.getStartPointIndex());\n\t\tif(attachedRoutes == null || attachedRoutes.size() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t// keep left/right\n\t\tRoadSplitStructure rs = calculateRoadSplitStructure(prevSegm, currentSegm, attachedRoutes);\n\t\tif(rs.roadsOnLeft  + rs.roadsOnRight == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// turn lanes exist\n\t\tString turnLanes = getTurnLanesString(prevSegm);\n\t\tif (turnLanes != null) {\n\t\t\treturn createKeepLeftRightTurnBasedOnTurnTypes(rs, prevSegm, currentSegm, turnLanes, leftSide);\n\t\t}\n\n\t\t// turn lanes don't exist\n\t\tif (rs.keepLeft || rs.keepRight) {\n\t\t\treturn createSimpleKeepLeftRightTurn(leftSide, prevSegm, currentSegm, rs);\n\t\t\t\n\t\t}\n\t\treturn null;\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static int[] parseTurnLanes(RouteDataObject ro, double dirToNorthEastPi) {\n\t\tString turnLanes = null;\n\t\tif (ro.getOneway() == 0) {\n\t\t\t// we should get direction to detect forward or backward\n\t\t\tdouble cmp = ro.directionRoute(0, true);\n\t\t\tif(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {\n\t\t\t\tturnLanes = ro.getValue(\"turn:lanes:forward\");\n\t\t\t} else {\n\t\t\t\tturnLanes = ro.getValue(\"turn:lanes:backward\");\n\t\t\t}\n\t\t} else {\n\t\t\tturnLanes = ro.getValue(\"turn:lanes\");\n\t\t}\n\t\tif(turnLanes == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString[] splitLaneOptions = turnLanes.split(\"\\\\|\", -1);\n\t\treturn calculateRawTurnLanes(splitLaneOptions, 0);\n\t}","id":72811,"modified_method":"public static int[] parseTurnLanes(RouteDataObject ro, double dirToNorthEastPi) {\n\t\tString turnLanes = null;\n\t\tif (ro.getOneway() == 0) {\n\t\t\t// we should get direction to detect forward or backward\n\t\t\tdouble cmp = ro.directionRoute(0, true);\n\t\t\tif(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {\n\t\t\t\tturnLanes = ro.getValue(\"turn:lanes:forward\");\n\t\t\t} else {\n\t\t\t\tturnLanes = ro.getValue(\"turn:lanes:backward\");\n\t\t\t}\n\t\t} else {\n\t\t\tturnLanes = ro.getValue(\"turn:lanes\");\n\t\t}\n\t\tif(turnLanes == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn calculateRawTurnLanes(turnLanes, 0);\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private TurnType getTurnInfo(List<RouteSegmentResult> result, int i, boolean leftSide) {\n\t\tif (i == 0) {\n\t\t\treturn TurnType.valueOf(TurnType.C, false);\n\t\t}\n\t\tRouteSegmentResult prev = result.get(i - 1) ;\n\t\tif(prev.getObject().roundabout()) {\n\t\t\t// already analyzed!\n\t\t\treturn null;\n\t\t}\n\t\tRouteSegmentResult rr = result.get(i);\n\t\tif (rr.getObject().roundabout()) {\n\t\t\treturn processRoundaboutTurn(result, i, leftSide, prev, rr);\n\t\t}\n\t\tTurnType t = null;\n\t\tif (prev != null) {\n\t\t\tboolean noAttachedRoads = rr.getAttachedRoutes(rr.getStartPointIndex()).size() == 0;\n\t\t\t// add description about turn\n\t\t\tdouble mpi = MapUtils.degreesDiff(prev.getBearingEnd(), rr.getBearingBegin());\n\t\t\tif(noAttachedRoads){\n\t\t\t\t// TODO VICTOR : look at the comment inside direction route\n\t\t\t\t// ? avoid small zigzags is covered at (search for \"zigzags\") \n//\t\t\t\tdouble begin = rr.getObject().directionRoute(rr.getStartPointIndex(), rr.getStartPointIndex() < \n//\t\t\t\t\t\trr.getEndPointIndex(), 25);\n//\t\t\t\tmpi = MapUtils.degreesDiff(prev.getBearingEnd(), begin);\n\t\t\t}\n\t\t\tif (mpi >= TURN_DEGREE_MIN) {\n\t\t\t\tif (mpi < 60) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TSLL, leftSide);\n\t\t\t\t} else if (mpi < 120) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TL, leftSide);\n\t\t\t\t} else if (mpi < 135 || leftSide) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TSHL, leftSide);\n\t\t\t\t} else {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TU, leftSide);\n\t\t\t\t}\n\t\t\t\tint[] lanes = getTurnLanesInfo(prev, t.getValue(), leftSide, true);\n\t\t\t\tif(lanes != null) {\n\t\t\t\t\tt.setLanes(lanes);\n\t\t\t\t}\n\t\t\t} else if (mpi < -TURN_DEGREE_MIN) {\n\t\t\t\tif (mpi > -60) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TSLR, leftSide);\n\t\t\t\t} else if (mpi > -120) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TR, leftSide);\n\t\t\t\t} else if (mpi > -135 || !leftSide) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TSHR, leftSide);\n\t\t\t\t} else {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TU, leftSide);\n\t\t\t\t}\n\t\t\t\tint[] lanes = getTurnLanesInfo(prev, t.getValue(), leftSide, false);\n\t\t\t\tif(lanes != null) {\n\t\t\t\t\tt.setLanes(lanes);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = attachKeepLeftInfoAndLanes(leftSide, prev, rr, t);\n\t\t\t}\n\t\t\tif (t != null) {\n\t\t\t\tt.setTurnAngle((float) -mpi);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}","id":72812,"modified_method":"private TurnType getTurnInfo(List<RouteSegmentResult> result, int i, boolean leftSide) {\n\t\tif (i == 0) {\n\t\t\treturn TurnType.valueOf(TurnType.C, false);\n\t\t}\n\t\tRouteSegmentResult prev = result.get(i - 1) ;\n\t\tif(prev.getObject().roundabout()) {\n\t\t\t// already analyzed!\n\t\t\treturn null;\n\t\t}\n\t\tRouteSegmentResult rr = result.get(i);\n\t\tif (rr.getObject().roundabout()) {\n\t\t\treturn processRoundaboutTurn(result, i, leftSide, prev, rr);\n\t\t}\n\t\tTurnType t = null;\n\t\tif (prev != null) {\n\t\t\tboolean noAttachedRoads = rr.getAttachedRoutes(rr.getStartPointIndex()).size() == 0;\n\t\t\t// add description about turn\n\t\t\tdouble mpi = MapUtils.degreesDiff(prev.getBearingEnd(), rr.getBearingBegin());\n\t\t\tif(noAttachedRoads){\n\t\t\t\t// TODO VICTOR : look at the comment inside direction route\n\t\t\t\t// ? avoid small zigzags is covered at (search for \"zigzags\") \n//\t\t\t\tdouble begin = rr.getObject().directionRoute(rr.getStartPointIndex(), rr.getStartPointIndex() < \n//\t\t\t\t\t\trr.getEndPointIndex(), 25);\n//\t\t\t\tmpi = MapUtils.degreesDiff(prev.getBearingEnd(), begin);\n\t\t\t}\n\t\t\tif (mpi >= TURN_DEGREE_MIN) {\n\t\t\t\tif (mpi < 60) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TSLL, leftSide);\n\t\t\t\t} else if (mpi < 120) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TL, leftSide);\n\t\t\t\t} else if (mpi < 135 || leftSide) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TSHL, leftSide);\n\t\t\t\t} else {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TU, leftSide);\n\t\t\t\t}\n\t\t\t\tint[] lanes = getTurnLanesInfo(prev, t.getValue());\n\t\t\t\tt.setLanes(lanes);\n\t\t\t} else if (mpi < -TURN_DEGREE_MIN) {\n\t\t\t\tif (mpi > -60) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TSLR, leftSide);\n\t\t\t\t} else if (mpi > -120) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TR, leftSide);\n\t\t\t\t} else if (mpi > -135 || !leftSide) {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TSHR, leftSide);\n\t\t\t\t} else {\n\t\t\t\t\tt = TurnType.valueOf(TurnType.TRU, leftSide);\n\t\t\t\t}\n\t\t\t\tint[] lanes = getTurnLanesInfo(prev, t.getValue());\n\t\t\t\tt.setLanes(lanes);\n\t\t\t} else {\n\t\t\t\tt = attachKeepLeftInfoAndLanes(leftSide, prev, rr);\n\t\t\t}\n\t\t\tif (t != null) {\n\t\t\t\tt.setTurnAngle((float) -mpi);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void addTurnInfoDescriptions(List<RouteSegmentResult> result) {\n\t\tint prevSegment = -1;\n\t\tfloat dist = 0;\n\t\tfor (int i = 0; i <= result.size(); i++) {\n\t\t\tif (i == result.size() || result.get(i).getTurnType() != null) {\n\t\t\t\tif (prevSegment >= 0) {\n\t\t\t\t\tString turn = result.get(prevSegment).getTurnType().toString();\n\t\t\t\t\tif (result.get(prevSegment).getTurnType().getLanes() != null) {\n\t\t\t\t\t\tturn += Arrays.toString(result.get(prevSegment).getTurnType().getLanes());\n\t\t\t\t\t}\n\t\t\t\t\tresult.get(prevSegment).setDescription(\n\t\t\t\t\t\t\tturn + MessageFormat.format(\" and go {0,number,#.##} meters\", dist));\n\t\t\t\t\tif (result.get(prevSegment).getTurnType().isSkipToSpeak()) {\n\t\t\t\t\t\tresult.get(prevSegment).setDescription(\"-*\" + result.get(prevSegment).getDescription());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprevSegment = i;\n\t\t\t\tdist = 0;\n\t\t\t}\n\t\t\tif (i < result.size()) {\n\t\t\t\tdist += result.get(i).getDistance();\n\t\t\t}\n\t\t}\n\t}","id":72813,"modified_method":"protected void addTurnInfoDescriptions(List<RouteSegmentResult> result) {\n\t\tint prevSegment = -1;\n\t\tfloat dist = 0;\n\t\tfor (int i = 0; i <= result.size(); i++) {\n\t\t\tif (i == result.size() || result.get(i).getTurnType() != null) {\n\t\t\t\tif (prevSegment >= 0) {\n\t\t\t\t\tString turn = result.get(prevSegment).getTurnType().toString();\n\t\t\t\t\tfinal int[] lns = result.get(prevSegment).getTurnType().getLanes();\n\t\t\t\t\tif (lns != null) {\n\t\t\t\t\t\tString s = \"[ \";\n\t\t\t\t\t\tfor (int h = 0; h < lns.length; h++) {\n\t\t\t\t\t\t\tif (h > 0) {\n\t\t\t\t\t\t\t\ts += \", \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (lns[h] % 2 == 1) {\n\t\t\t\t\t\t\t\ts += \"+\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint pt = TurnType.getPrimaryTurn(lns[h]);\n\t\t\t\t\t\t\tif (pt == 0) {\n\t\t\t\t\t\t\t\tpt = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts += TurnType.valueOf(pt, false).toXmlString();\n\t\t\t\t\t\t\tint st = TurnType.getSecondaryTurn(lns[h]);\n\t\t\t\t\t\t\tif (st != 0) {\n\t\t\t\t\t\t\t\ts += \";\" + TurnType.valueOf(st, false).toXmlString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts += \"]\";\n\t\t\t\t\t\tturn += s;\n\t\t\t\t\t}\n\t\t\t\t\tresult.get(prevSegment).setDescription(\n\t\t\t\t\t\t\tturn + MessageFormat.format(\" and go {0,number,#.##} meters\", dist));\n\t\t\t\t\tif (result.get(prevSegment).getTurnType().isSkipToSpeak()) {\n\t\t\t\t\t\tresult.get(prevSegment).setDescription(\"-*\" + result.get(prevSegment).getDescription());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprevSegment = i;\n\t\t\t\tdist = 0;\n\t\t\t}\n\t\t\tif (i < result.size()) {\n\t\t\t\tdist += result.get(i).getDistance();\n\t\t\t}\n\t\t}\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private static int[] calculateRawTurnLanes(String[] splitLaneOptions, int calcTurnType) {\n\t\tint[] lanes = new int[splitLaneOptions.length];\n\t\tfor (int i = 0; i < splitLaneOptions.length; i++) {\n\t\t\tString[] laneOptions = splitLaneOptions[i].split(\";\");\n\n\t\t\tfor (int j = 0; j < laneOptions.length; j++) {\n\t\t\t\tint turn;\n\t\t\t\tif (laneOptions[j].equals(\"none\") || laneOptions[j].equals(\"through\")) {\n\t\t\t\t\tturn = TurnType.C;\n\t\t\t\t} else if (laneOptions[j].equals(\"slight_right\")) {\n\t\t\t\t\tturn = TurnType.TSLR;\n\t\t\t\t} else if (laneOptions[j].equals(\"slight_left\")) {\n\t\t\t\t\tturn = TurnType.TSLL;\n\t\t\t\t} else if (laneOptions[j].equals(\"right\")) {\n\t\t\t\t\tturn = TurnType.TR;\n\t\t\t\t} else if (laneOptions[j].equals(\"left\")) {\n\t\t\t\t\tturn = TurnType.TL;\n\t\t\t\t} else if (laneOptions[j].equals(\"sharp_right\")) {\n\t\t\t\t\tturn = TurnType.TSHR;\n\t\t\t\t} else if (laneOptions[j].equals(\"sharp_left\")) {\n\t\t\t\t\tturn = TurnType.TSHL;\n\t\t\t\t} else if (laneOptions[j].equals(\"reverse\")) {\n\t\t\t\t\tturn = TurnType.TU;\n\t\t\t\t} else {\n\t\t\t\t\t// Unknown string\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (TurnType.getPrimaryTurn(lanes[i]) == 0) {\n\t\t\t\t\tTurnType.setPrimaryTurn(lanes, i, turn);\n\t\t\t\t} else {\n                    if (turn == calcTurnType) {\n                        TurnType.setSecondaryTurn(lanes, i, TurnType.getPrimaryTurn(lanes[i]));\n                        TurnType.setPrimaryTurn(lanes, i, turn);\n                    } else {\n                        TurnType.setSecondaryTurn(lanes, i, turn);\n                    }\n\t\t\t\t\tbreak; // Move on to the next lane\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lanes;\n\t}","id":72814,"modified_method":"private static int[] calculateRawTurnLanes(String turnLanes, int calcTurnType) {\n\t\tString[] splitLaneOptions = turnLanes.split(\"\\\\|\", -1);\n\t\tint[] lanes = new int[splitLaneOptions.length];\n\t\tfor (int i = 0; i < splitLaneOptions.length; i++) {\n\t\t\tString[] laneOptions = splitLaneOptions[i].split(\";\");\n\n\t\t\tfor (int j = 0; j < laneOptions.length; j++) {\n\t\t\t\tint turn;\n\t\t\t\tif (laneOptions[j].equals(\"none\") || laneOptions[j].equals(\"through\")) {\n\t\t\t\t\tturn = TurnType.C;\n\t\t\t\t} else if (laneOptions[j].equals(\"slight_right\")) {\n\t\t\t\t\tturn = TurnType.TSLR;\n\t\t\t\t} else if (laneOptions[j].equals(\"slight_left\")) {\n\t\t\t\t\tturn = TurnType.TSLL;\n\t\t\t\t} else if (laneOptions[j].equals(\"right\")) {\n\t\t\t\t\tturn = TurnType.TR;\n\t\t\t\t} else if (laneOptions[j].equals(\"left\")) {\n\t\t\t\t\tturn = TurnType.TL;\n\t\t\t\t} else if (laneOptions[j].equals(\"sharp_right\")) {\n\t\t\t\t\tturn = TurnType.TSHR;\n\t\t\t\t} else if (laneOptions[j].equals(\"sharp_left\")) {\n\t\t\t\t\tturn = TurnType.TSHL;\n\t\t\t\t} else if (laneOptions[j].equals(\"reverse\")) {\n\t\t\t\t\tturn = TurnType.TU;\n\t\t\t\t} else {\n\t\t\t\t\t// Unknown string\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfinal int primary = TurnType.getPrimaryTurn(lanes[i]);\n\t\t\t\tif (primary == 0) {\n\t\t\t\t\tTurnType.setPrimaryTurnAndReset(lanes, i, turn);\n\t\t\t\t} else {\n                    if (turn == calcTurnType || \n                    \t(TurnType.isRightTurn(calcTurnType) && TurnType.isRightTurn(turn)) || \n                    \t(TurnType.isLeftTurn(calcTurnType) && TurnType.isLeftTurn(turn)) \n                    \t) {\n                    \tTurnType.setPrimaryTurnAndReset(lanes, i, turn);\n                        TurnType.setSecondaryTurn(lanes, i, primary);\n                    } else {\n                        TurnType.setSecondaryTurn(lanes, i, turn);\n                    }\n\t\t\t\t\tbreak; // Move on to the next lane\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lanes;\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private int[] getTurnLanesInfo(RouteSegmentResult prevSegm, int mainTurnType, boolean leftSide,\n\t\t\tboolean leftTurn) {\n\t\tString turnLanes = getTurnLanesString(prevSegm);\n\t\tif (turnLanes == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString[] splitLaneOptions = turnLanes.split(\"\\\\|\", -1);\n\t\tif (splitLaneOptions.length != countLanesMinOne(prevSegm)) {\n\t\t\t// Error in data or missing data\n\t\t\treturn null;\n\t\t}\n\t\tint[] lanesArray = calculateRawTurnLanes(splitLaneOptions, mainTurnType);\n\t\t// Manually set the allowed lanes.\n\t\tboolean isSet = setAllowedLanes(mainTurnType, lanesArray);\n\t\tif(!isSet && lanesArray.length > 0) {\n\t\t\t// In some cases (at least in the US), the rightmost lane might not have a right turn indicated as per turn:lanes,\n\t\t\t// but is allowed and being used here. This section adds in that indicator.  The same applies for where leftSide is true.\n\t\t\tint ind = leftTurn? 0 : lanesArray.length - 1;\n\t\t\tfinal int tt = TurnType.getPrimaryTurn(lanesArray[ind]);\n\t\t\tif (leftTurn) {\n\t\t\t\tif (!TurnType.isLeftTurn(tt)) {\n\t\t\t\t\t// This was just to make sure that there's no bad data.\n\t\t\t\t\tTurnType.setSecondaryTurn(lanesArray, ind, tt);\n\t\t\t\t\tTurnType.setPrimaryTurn(lanesArray, ind, TurnType.TL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!TurnType.isRightTurn(tt)) {\n\t\t\t\t\t// This was just to make sure that there's no bad data.\n\t\t\t\t\tTurnType.setSecondaryTurn(lanesArray, ind, tt);\n\t\t\t\t\tTurnType.setPrimaryTurn(lanesArray, ind, TurnType.TR);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetAllowedLanes(lanesArray[ind], lanesArray);\n\t\t}\n\t\treturn lanesArray;\n\t}","id":72815,"modified_method":"private int[] getTurnLanesInfo(RouteSegmentResult prevSegm, int mainTurnType) {\n\t\tString turnLanes = getTurnLanesString(prevSegm);\n\t\tif (turnLanes == null) {\n\t\t\treturn null;\n\t\t}\n\t\tint[] lanesArray = calculateRawTurnLanes(turnLanes, mainTurnType);\n\t\t// Manually set the allowed lanes.\n\t\tboolean isSet = setAllowedLanes(mainTurnType, lanesArray);\n\t\tif(!isSet && lanesArray.length > 0) {\n\t\t\t// In some cases (at least in the US), the rightmost lane might not have a right turn indicated as per turn:lanes,\n\t\t\t// but is allowed and being used here. This section adds in that indicator.  The same applies for where leftSide is true.\n\t\t\tboolean leftTurn = TurnType.isLeftTurn(mainTurnType);\n\t\t\tint ind = leftTurn? 0 : lanesArray.length - 1;\n\t\t\tfinal int tt = TurnType.getPrimaryTurn(lanesArray[ind]);\n\t\t\tif (leftTurn) {\n\t\t\t\tif (!TurnType.isLeftTurn(tt)) {\n\t\t\t\t\t// This was just to make sure that there's no bad data.\n\t\t\t\t\tTurnType.setPrimaryTurnAndReset(lanesArray, ind, TurnType.TL);\n\t\t\t\t\tTurnType.setSecondaryTurn(lanesArray, ind, tt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!TurnType.isRightTurn(tt)) {\n\t\t\t\t\t// This was just to make sure that there's no bad data.\n\t\t\t\t\tTurnType.setPrimaryTurnAndReset(lanesArray, ind, TurnType.TR);\n\t\t\t\t\tTurnType.setSecondaryTurn(lanesArray, ind, tt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetAllowedLanes(tt, lanesArray);\n\t\t}\n\t\treturn lanesArray;\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void addTurnInfo(boolean leftside, List<RouteSegmentResult> result) {\n\t\tint next = 1;\n\t\tfor (int i = 0; i <= result.size(); i = next) {\n\t\t\tTurnType t = null;\n\t\t\tnext = i + 1;\n\t\t\tif (i < result.size()) {\n\t\t\t\tt = getTurnInfo(result, i, leftside);\n\t\t\t\t// justify turn\n\t\t\t\tif(t != null && i < result.size() - 1) {\n\t\t\t\t\tTurnType jt = justifyUTurn(leftside, result, i, t);\n\t\t\t\t\tif(jt != null) {\n\t\t\t\t\t\tt = jt;\n\t\t\t\t\t\tnext = i + 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.get(i).setTurnType(t);\n\t\t\t}\n\t\t}\n\t}","id":72816,"modified_method":"private void justifyUTurns(boolean leftSide, List<RouteSegmentResult> result) {\n\t\tint next;\n\t\tfor (int i = 0; i < result.size() - 1; i = next) {\n\t\t\tnext = i + 1;\n\t\t\tTurnType t = result.get(i).getTurnType();\n\t\t\t// justify turn\n\t\t\tif (t != null) {\n\t\t\t\tTurnType jt = justifyUTurn(leftSide, result, i, t);\n\t\t\t\tif (jt != null) {\n\t\t\t\t\tresult.get(i).setTurnType(jt);\n\t\t\t\t\tnext = i + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void mergeTurnLanes(boolean leftSide, RouteSegmentResult currentSegment, RouteSegmentResult nextSegment) {\n\t\tTurnType currentTurn = currentSegment.getTurnType();\n\t\tTurnType nextTurn = nextSegment.getTurnType();\n\t\tboolean isUsingTurnLanes = TurnType.getPrimaryTurn(currentTurn.getLanes()[0]) != 0\n\t\t\t&& TurnType.getPrimaryTurn(nextTurn.getLanes()[0]) != 0;\n\t\tif (isUsingTurnLanes) {\n\t\t\tint[] lanes = new int[currentTurn.getLanes().length];\n\t\t\tint activeIndex = -1;\n\t\t\tint activeLen = 0;\n\t\t\t// define enabled lanes \n\t\t\tfor(int i = 0; i < lanes.length; i++) {\n\t\t\t\tint ln = currentTurn.getLanes()[i];\n\t\t\t\tlanes[i] = ln & ~1;\n\t\t\t\tif((ln & 1) > 0) {\n\t\t\t\t\tif(activeIndex == -1) {\n\t\t\t\t\t\tactiveIndex = i;\n\t\t\t\t\t\tactiveLen++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactiveLen++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(activeLen < 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint targetActiveIndex = -1;\n\t\t\tint targetActiveLen = 0;\n\t\t\tint[] nextLanes = nextTurn.getLanes();\n\t\t\tfor(int i = 0; i < nextLanes.length; i++) {\n\t\t\t\tint ln = nextLanes[i];\n\t\t\t\tif((ln & 1) > 0) {\n\t\t\t\t\tif(targetActiveIndex == -1) {\n\t\t\t\t\t\ttargetActiveIndex = i;\n\t\t\t\t\t\ttargetActiveLen++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetActiveLen++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(targetActiveIndex == -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean changed = false;\n\t\t\t// next turn is left\n\t\t\tif(targetActiveIndex == 0) {\n\t\t\t\t// let only the most left lanes be enabled\n\t\t\t\tif(targetActiveLen <= activeLen) {\n\t\t\t\t\tactiveLen = targetActiveLen;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t} else if(targetActiveIndex + targetActiveLen == nextLanes.length) {\n\t\t\t\t// next turn is right\n\t\t\t\t// let only the most right lanes be enabled\n\t\t\t\tif(targetActiveLen <= activeLen) {\n\t\t\t\t\tactiveIndex += (activeLen - targetActiveLen);\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// next turn is get through (take out the left and the right turn) \n\t\t\t\tif(nextLanes.length >= activeLen) {\n\t\t\t\t\tfloat ratio = (nextLanes.length / (float)activeLen); \n\t\t\t\t\tactiveLen =  (int) Math.ceil(targetActiveLen * ratio);\n\t\t\t\t\tactiveIndex = (int) Math.floor(targetActiveIndex / ratio);\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!changed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// set the allowed lane bit\n\t\t\tfor (int i = 0; i < lanes.length; i++) {\n\t\t\t\tif(i >= activeIndex && i < activeIndex + activeLen) {\n\t\t\t\t\tlanes[i] |= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentTurn.setLanes(lanes);\n\t\t\tint turn = inferTurnFromLanes(lanes);\n\t\t\tif (turn != 0 && turn != currentTurn.getValue()) {\n\t\t\t\tTurnType newTurnType = TurnType.valueOf(turn, leftSide);\n\t\t\t\tnewTurnType.setLanes(lanes);\n\t\t\t\tnewTurnType.setSkipToSpeak(currentTurn.isSkipToSpeak());\n\t\t\t\tcurrentSegment.setTurnType(newTurnType);\n\t\t\t}\n\t\t}\n\t}","id":72817,"modified_method":"private void mergeTurnLanes(boolean leftSide, RouteSegmentResult currentSegment, RouteSegmentResult nextSegment) {\n\t\tMergeTurnLaneTurn active = new MergeTurnLaneTurn(currentSegment);\n\t\tMergeTurnLaneTurn target = new MergeTurnLaneTurn(nextSegment);\n\t\tif (active.activeLen < 2) {\n\t\t\treturn;\n\t\t}\n\t\tif (target.activeStartIndex == -1) {\n\t\t\treturn;\n\t\t}\n\t\tboolean changed = false;\n\t\tif (target.isActiveTurnMostLeft()) {\n\t\t\t// let only the most left lanes be enabled\n\t\t\tif (target.activeLen <= active.activeLen) {\n\t\t\t\tactive.activeEndIndex -= (active.activeLen - target.activeLen);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else if (target.isActiveTurnMostRight()) {\n\t\t\t// next turn is right\n\t\t\t// let only the most right lanes be enabled\n\t\t\tif (target.activeLen < active.activeLen) {\n\t\t\t\tactive.activeStartIndex += (active.activeLen - target.activeLen);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\t// next turn is get through (take out the left and the right turn)\n\t\t\tif (target.originalLanes.length >= active.activeLen) {\n\t\t\t\tfloat ratio = (target.originalLanes.length / (float) active.activeLen);\n\t\t\t\tactive.activeEndIndex = (int) Math.ceil(target.activeEndIndex * ratio);\n\t\t\t\tactive.activeStartIndex = (int) Math.floor(target.activeStartIndex / ratio);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\tif (!changed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// set the allowed lane bit\n\t\tfor (int i = 0; i < active.disabledLanes.length; i++) {\n\t\t\tif (i >= active.activeStartIndex && i <= active.activeEndIndex) {\n\t\t\t\tactive.disabledLanes[i] |= 1;\n\t\t\t}\n\t\t}\n\t\tTurnType currentTurn = currentSegment.getTurnType();\n\t\tcurrentTurn.setLanes(active.disabledLanes);\n\t\tint turn = inferTurnFromLanes(active.disabledLanes);\n\t\tif (turn != 0 && turn != currentTurn.getValue()) {\n\t\t\tTurnType newTurnType = TurnType.valueOf(turn, leftSide);\n\t\t\tnewTurnType.setLanes(active.disabledLanes);\n\t\t\tnewTurnType.setSkipToSpeak(currentTurn.isSkipToSpeak());\n\t\t\tcurrentSegment.setTurnType(newTurnType);\n\t\t}\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"List<RouteSegmentResult> prepareResult(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {\n\t\tvalidateAllPointsConnected(result);\n\t\tsplitRoadsAndAttachRoadSegments(ctx, result);\n\t\t// calculate time\n\t\tcalculateTimeSpeed(ctx, result);\n\t\t\n\t\taddTurnInfo(ctx.leftSideNavigation, result);\n\t\tdetermineTurnsToMerge(ctx.leftSideNavigation, result);\n\t\taddTurnInfoDescriptions(result);\n\t\treturn result;\n\t}","id":72818,"modified_method":"List<RouteSegmentResult> prepareResult(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {\n\t\tvalidateAllPointsConnected(result);\n\t\tsplitRoadsAndAttachRoadSegments(ctx, result);\n\t\tcalculateTimeSpeed(ctx, result);\n\t\t\n\t\tfor (int i = 0; i < result.size(); i ++) {\n\t\t\tTurnType turnType = getTurnInfo(result, i, ctx.leftSideNavigation);\n\t\t\tresult.get(i).setTurnType(turnType);\n\t\t}\n\t\t\n\t\tdetermineTurnsToMerge(ctx.leftSideNavigation, result);\n\t\tjustifyUTurns(ctx.leftSideNavigation, result);\n\t\taddTurnInfoDescriptions(result);\n\t\treturn result;\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void determineTurnsToMerge(boolean leftside, List<RouteSegmentResult> result) {\n\t\tfor (int i = result.size() - 2; i >= 0; i--) {\n\t\t\tRouteSegmentResult currentSegment = result.get(i);\n\t\t\tRouteSegmentResult nextSegment = null;\n\n\t\t\t// We need to get the next segment that has a turn and lanes attached.\n\t\t\tfor (int j = i + 1; j < result.size(); j++) {\n\t\t\t\tRouteSegmentResult possibleSegment = result.get(j);\n\t\t\t\tif (possibleSegment.getTurnType() != null && possibleSegment.getTurnType().getLanes() != null) {\n\t\t\t\t\tnextSegment = possibleSegment;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nextSegment == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTurnType currentTurn = currentSegment.getTurnType();\n\t\t\tTurnType nextTurn = nextSegment.getTurnType();\n\n\t\t\tif (currentTurn == null || currentTurn.getLanes() == null || nextTurn == null || nextTurn.getLanes() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Only allow slight turns that are nearby to be merged. \n\t\t\t// [disabled cause it is valuable for two consequent sharp turns as well]\n\t\t\t// the distance could be longer on highways and shorter in city\n\t\t\tString hw = currentSegment.getObject().getHighway();\n\t\t\tdouble mergeDistance = 200;\n\t\t\tif(hw != null && (hw.startsWith(\"trunk\") || hw.startsWith(\"motorway\"))) {\n\t\t\t\tmergeDistance = 400;\n\t\t\t}\n\t\t\tif (currentSegment.getDistance() < mergeDistance/* \n\t\t\t\t\t&& TurnType.isSlightTurn(currentTurn.getValue())*/) {\n\t\t\t\tmergeTurnLanes(leftside, currentSegment, nextSegment);\n\t\t\t}\n\t\t}\n\t}","id":72819,"modified_method":"private void determineTurnsToMerge(boolean leftside, List<RouteSegmentResult> result) {\n\t\tRouteSegmentResult nextSegment = null;\n\t\tdouble dist = 0;\n\t\tfor (int i = result.size() - 1; i >= 0; i--) {\n\t\t\tRouteSegmentResult currentSegment = result.get(i);\n\t\t\tTurnType currentTurn = currentSegment.getTurnType();\n\t\t\tdist += currentSegment.getDistance();\n\t\t\tif (currentTurn == null || currentTurn.getLanes() == null) {\n\t\t\t\t// skip\n\t\t\t} else {\n\t\t\t\tif (nextSegment != null) {\n\t\t\t\t\tString hw = currentSegment.getObject().getHighway();\n\t\t\t\t\tdouble mergeDistance = 200;\n\t\t\t\t\tif (hw != null && (hw.startsWith(\"trunk\") || hw.startsWith(\"motorway\"))) {\n\t\t\t\t\t\tmergeDistance = 400;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist < mergeDistance) {\n\t\t\t\t\t\tmergeTurnLanes(leftside, currentSegment, nextSegment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextSegment = currentSegment;\n\t\t\t\tdist = 0;\n\t\t\t}\n\t\t}\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected TurnType justifyUTurn(boolean leftside, List<RouteSegmentResult> result, int i, TurnType t) {\n\t\tboolean tl = TurnType.TL == t.getValue();\n\t\tboolean tr = TurnType.TR == t.getValue();\n\t\tif(tl || tr) {\n\t\t\tTurnType tnext = getTurnInfo(result, i + 1, leftside);\n\t\t\tif (tnext != null && result.get(i).getDistance() < 35) { //\n\t\t\t\tboolean ut = true;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tdouble uTurn = MapUtils.degreesDiff(result.get(i - 1).getBearingEnd(), result\n\t\t\t\t\t\t\t.get(i + 1).getBearingBegin());\n\t\t\t\t\tif (Math.abs(uTurn) < 120) {\n\t\t\t\t\t\tut = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString highway = result.get(i).getObject().getHighway();\n\t\t\t\tif(highway == null || highway.endsWith(\"track\") || highway.endsWith(\"services\") || highway.endsWith(\"service\")\n\t\t\t\t\t\t|| highway.endsWith(\"path\")) {\n\t\t\t\t\tut = false;\n\t\t\t\t}\n\t\t\t\tif (ut) {\n\t\t\t\t\tif (tl && TurnType.TL == tnext.getValue()) {\n\t\t\t\t\t\treturn TurnType.valueOf(TurnType.TU, false);\n\t\t\t\t\t} else if (tr && TurnType.TR == tnext.getValue()) {\n\t\t\t\t\t\treturn TurnType.valueOf(TurnType.TU, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":72820,"modified_method":"protected TurnType justifyUTurn(boolean leftside, List<RouteSegmentResult> result, int i, TurnType t) {\n\t\tboolean tl = TurnType.TL == t.getValue();\n\t\tboolean tr = TurnType.TR == t.getValue();\n\t\tif(tl || tr) {\n\t\t\tTurnType tnext = result.get(i + 1).getTurnType();\n\t\t\tif (tnext != null && result.get(i).getDistance() < 35) { //\n\t\t\t\tboolean ut = true;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tdouble uTurn = MapUtils.degreesDiff(result.get(i - 1).getBearingEnd(), result\n\t\t\t\t\t\t\t.get(i + 1).getBearingBegin());\n\t\t\t\t\tif (Math.abs(uTurn) < 120) {\n\t\t\t\t\t\tut = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString highway = result.get(i).getObject().getHighway();\n\t\t\t\tif(highway == null || highway.endsWith(\"track\") || highway.endsWith(\"services\") || highway.endsWith(\"service\")\n\t\t\t\t\t\t|| highway.endsWith(\"path\")) {\n\t\t\t\t\tut = false;\n\t\t\t\t}\n\t\t\t\tif (ut) {\n\t\t\t\t\ttnext.setSkipToSpeak(true);\n\t\t\t\t\tif (tl && TurnType.TL == tnext.getValue()) {\n\t\t\t\t\t\treturn TurnType.valueOf(TurnType.TU, false);\n\t\t\t\t\t} else if (tr && TurnType.TR == tnext.getValue()) {\n\t\t\t\t\t\treturn TurnType.valueOf(TurnType.TU, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void setPrimaryTurn(int[] lanes, int lane, int turnType) {\n\t\tlanes[lane] |= (turnType << 1);\n\t}","id":72821,"modified_method":"public static void setPrimaryTurnAndReset(int[] lanes, int lane, int turnType) {\n\t\tlanes[lane] = (turnType << 1);\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static boolean isLeftTurn(int type) {\n\t\treturn type == TL || type == TSHL || type == TSLL;\n\t}","id":72822,"modified_method":"public static boolean isLeftTurn(int type) {\n\t\treturn type == TL || type == TSHL || type == TSLL || type == TRU;\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static boolean isRightTurn(int type) {\n\t\treturn type == TR || type == TSHR || type == TSLR;\n\t}","id":72823,"modified_method":"public static boolean isRightTurn(int type) {\n\t\treturn type == TR || type == TSHR || type == TSLR || type == TU;\n\t}","commit_id":"1756e3961697215311959bb9cc138b038597ac11","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Test\n    @Category(ProblematicTest.class)\n    public void testMapRecordEviction() throws InterruptedException {\n        int size = 100000;\n        Config cfg = new Config();\n        MapConfig mc = cfg.getMapConfig(\"testMapRecordEviction\");\n        mc.setTimeToLiveSeconds(1);\n        final CountDownLatch latch = new CountDownLatch(size);\n        mc.addEntryListenerConfig(new EntryListenerConfig().setImplementation(new EntryAdapter() {\n            public void entryEvicted(EntryEvent event) {\n                latch.countDown();\n            }\n        }).setLocal(true));\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance[] instances = factory.newInstances(cfg);\n\n        IMap map = instances[0].getMap(\"testMapRecordEviction\");\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        assertTrue(\"map size is : \" + map.size(), latch.await(5, TimeUnit.MINUTES));\n        assertEquals(0, map.size());\n    }","id":72824,"modified_method":"@Test\n    @Category(ProblematicTest.class)\n    public void testMapRecordEviction() throws InterruptedException {\n        int size = 1000;\n        Config cfg = new Config();\n        MapConfig mc = cfg.getMapConfig(\"testMapRecordEviction\");\n        mc.setTimeToLiveSeconds(1);\n        final CountDownLatch latch = new CountDownLatch(size);\n        mc.addEntryListenerConfig(new EntryListenerConfig().setImplementation(new EntryAdapter() {\n            public void entryEvicted(EntryEvent event) {\n                latch.countDown();\n            }\n        }).setLocal(true));\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance[] instances = factory.newInstances(cfg);\n\n        IMap map = instances[0].getMap(\"testMapRecordEviction\");\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        //wait until eviction is complete\n        assertOpenEventually(latch);\n        assertEquals(0, map.size());\n    }","commit_id":"221df54efc52ab8283d401400aa29502c01a26e0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    @Category(ProblematicTest.class)\n    public void testIssue1085EvictionBackup() throws InterruptedException {\n        Config config = new Config();\n        config.getMapConfig(\"testIssue1085EvictionBackup\").setTimeToLiveSeconds(3);\n        int size = 1000;\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n        HazelcastInstance instance = factory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = factory.newHazelcastInstance(config);\n        HazelcastInstance instance3 = factory.newHazelcastInstance(config);\n        final CountDownLatch latch = new CountDownLatch(size);\n        final IMap map = instance.getMap(\"testIssue1085EvictionBackup\");\n        map.addEntryListener(new EntryAdapter() {\n            @Override\n            public void entryEvicted(EntryEvent event) {\n                super.entryEvicted(event);\n                latch.countDown();\n            }\n        }, false);\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        instance2.shutdown();\n        instance3.shutdown();\n        assertTrue(\"map size:\" + map.size(), latch.await(30, TimeUnit.SECONDS));\n    }","id":72825,"modified_method":"@Test\n    public void testIssue1085EvictionBackup() throws InterruptedException {\n        Config config = new Config();\n        config.getMapConfig(\"testIssue1085EvictionBackup\").setTimeToLiveSeconds(3);\n\n        HazelcastInstance[] instances = createHazelcastInstanceFactory(3).newInstances(config);\n\n        int size = 1000;\n        final CountDownLatch latch = new CountDownLatch(size);\n\n        final IMap map = instances[0].getMap(\"testIssue1085EvictionBackup\");\n        map.addEntryListener(new EntryAdapter() {\n            @Override\n            public void entryEvicted(EntryEvent event) {\n                super.entryEvicted(event);\n                latch.countDown();\n            }\n        }, false);\n\n        // put some sample data\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n\n        // shutdown instances so we can check eviction happens in case backup process\n        instances[1].shutdown();\n        instances[2].shutdown();\n\n        //wait until eviction is complete\n        assertOpenEventually(latch);\n\n        assertEquals(\"not all values evicted!\",0,map.size());\n    }","commit_id":"221df54efc52ab8283d401400aa29502c01a26e0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    @Category(ProblematicTest.class)\n    public void testMapPutTtlWithListener() throws InterruptedException {\n        Config cfg = new Config();\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance[] instances = factory.newInstances(cfg);\n        warmUpPartitions(instances);\n\n        final int k = 10;\n        final int putCount = 10000;\n        final CountDownLatch latch = new CountDownLatch(k * putCount);\n        final IMap map = instances[0].getMap(\"testMapEvictionTtlWithListener\");\n\n        final AtomicBoolean error = new AtomicBoolean(false);\n        final Set<Long> times = Collections.newSetFromMap(new ConcurrentHashMap<Long, Boolean>());\n\n        map.addEntryListener(new EntryAdapter() {\n            public void entryEvicted(final EntryEvent event) {\n                final Long expectedEvictionTime = (Long) (event.getOldValue());\n                long timeDifference = System.currentTimeMillis() - expectedEvictionTime;\n                if (timeDifference > 5000) {\n                    error.set(true);\n                    times.add(timeDifference);\n                }\n                latch.countDown();\n            }\n        }, true);\n\n        for (int i = 0; i < k; i++) {\n            final int threadId = i;\n            int ttl = (int) (Math.random() * 5000 + 3000);\n            for (int j = 0; j < putCount; j++) {\n                final long expectedEvictionTime = ttl + System.currentTimeMillis();\n                map.put(j + putCount * threadId, expectedEvictionTime, ttl, TimeUnit.MILLISECONDS);\n            }\n        }\n\n        assertTrue(latch.await(1, TimeUnit.MINUTES));\n        assertFalse(\"Some evictions took more than 3 seconds! -> \" + times, error.get());\n    }","id":72826,"modified_method":"@Test\n    public void testMapPutTTLWithListener() throws InterruptedException {\n        Config cfg = new Config();\n        final HazelcastInstance[] instances = createHazelcastInstanceFactory(2).newInstances(cfg);\n        warmUpPartitions(instances);\n\n        final int k = 10;\n        final int putCount = 1000;\n        final CountDownLatch latch = new CountDownLatch(k * putCount);\n        final IMap map = instances[0].getMap(\"testMapPutTTLWithListener\");\n\n        final AtomicBoolean error = new AtomicBoolean(false);\n        final Set<Long> times = Collections.newSetFromMap(new ConcurrentHashMap<Long, Boolean>());\n\n        map.addEntryListener(new EntryAdapter() {\n            public void entryEvicted(final EntryEvent event) {\n                final Long expectedEvictionTime = (Long) (event.getOldValue());\n                long timeDifference = System.currentTimeMillis() - expectedEvictionTime;\n                if (timeDifference > 5000) {\n                    error.set(true);\n                    times.add(timeDifference);\n                }\n                latch.countDown();\n            }\n        }, true);\n\n        for (int i = 0; i < k; i++) {\n            final int threadId = i;\n            int ttl = (int) (Math.random() * 5000 + 3000);\n            for (int j = 0; j < putCount; j++) {\n                final long expectedEvictionTime = ttl + System.currentTimeMillis();\n                map.put(j + putCount * threadId, expectedEvictionTime, ttl, TimeUnit.MILLISECONDS);\n            }\n        }\n\n        // wait until eviction is completed.\n        assertOpenEventually(latch);\n        assertFalse(\"Some evictions took more than 5 seconds! -> late eviction count:\" + times.size(), error.get());\n    }","commit_id":"221df54efc52ab8283d401400aa29502c01a26e0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    @Category(ProblematicTest.class)\n    public void testMapRecordIdleEvictionOnMigration() throws InterruptedException {\n        Config cfg = new Config();\n        final String name = \"testMapRecordIdleEvictionOnMigration\";\n        MapConfig mc = cfg.getMapConfig(name);\n        int maxIdleSeconds = 10;\n        int size = 100;\n        final int nsize = size / 5;\n        mc.setMaxIdleSeconds(maxIdleSeconds);\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n\n        HazelcastInstance instance1 = factory.newHazelcastInstance(cfg);\n        final IMap map = instance1.getMap(name);\n        final CountDownLatch latch = new CountDownLatch(size - nsize);\n        map.addEntryListener(new EntryAdapter() {\n            public void entryEvicted(EntryEvent event) {\n                latch.countDown();\n            }\n        }, false);\n\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        final Thread thread = new Thread(new Runnable() {\n            public void run() {\n                while (!Thread.currentThread().isInterrupted()) {\n                    try {\n                        for (int i = 0; i < nsize; i++) {\n                            map.get(i);\n                        }\n                        Thread.sleep(1000);\n                    } catch (HazelcastInstanceNotActiveException e) {\n                        return;\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n            }\n        });\n        thread.start();\n        HazelcastInstance instance2 = factory.newHazelcastInstance(cfg);\n        HazelcastInstance instance3 = factory.newHazelcastInstance(cfg);\n\n        assertTrue(latch.await(1, TimeUnit.MINUTES));\n\n        assertEquals(nsize, map.size());\n\n        thread.interrupt();\n        thread.join(5000);\n    }","id":72827,"modified_method":"@Test\n    public void testMapRecordIdleEvictionOnMigration() {\n        Config cfg = new Config();\n        final String name = \"testMapRecordIdleEvictionOnMigration\";\n        MapConfig mc = cfg.getMapConfig(name);\n        int maxIdleSeconds = 30;\n        int size = 100;\n        final int nsize = size / 5;\n        mc.setMaxIdleSeconds(maxIdleSeconds);\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n\n        HazelcastInstance instance1 = factory.newHazelcastInstance(cfg);\n        final IMap map = instance1.getMap(name);\n        final CountDownLatch latch = new CountDownLatch(size - nsize);\n        map.addEntryListener(new EntryAdapter() {\n            public void entryEvicted(EntryEvent event) {\n                latch.countDown();\n            }\n        }, false);\n\n        // put sample data\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n\n        // wait until some time that is close to eviction\n        sleepSeconds(maxIdleSeconds - 5);\n\n        // touch the ones you dont want to be evicted.\n        for (int i = 0; i < nsize; i++) {\n            map.get(i);\n        }\n\n        HazelcastInstance instance2 = factory.newHazelcastInstance(cfg);\n        HazelcastInstance instance3 = factory.newHazelcastInstance(cfg);\n\n        //wait until eviction is complete\n        assertOpenEventually(latch);\n\n        assertEquals(\"not all idle values evicted!\",nsize, map.size());\n\n    }","commit_id":"221df54efc52ab8283d401400aa29502c01a26e0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    @Category(ProblematicTest.class)\n    public void testEvictionSpeedTestPerPartition() throws InterruptedException {\n        final int k = 2;\n        final int size = 100;\n        final CountDownLatch latch = new CountDownLatch(k);\n        final String mapName = \"testEvictionSpeedTestPerPartition\";\n        Config cfg = new Config();\n        final MapConfig mc = cfg.getMapConfig(mapName);\n        mc.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);\n        mc.setEvictionPercentage(25);\n        final MaxSizeConfig msc = new MaxSizeConfig();\n        msc.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_PARTITION);\n        msc.setSize(size);\n        mc.setMaxSizeConfig(msc);\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(cfg);\n        final int pnum = instances[0].getPartitionService().getPartitions().size();\n        final AtomicInteger failCount = new AtomicInteger(0);\n\n        new Thread() {\n            final IMap map = instances[0].getMap(mapName);\n\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                    while (latch.getCount() != 0) {\n                        try {\n                            int msize = map.size();\n                            if (msize > (size * pnum * 1.2)) {\n                                failCount.incrementAndGet();\n                            }\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n\n        for (int i = 0; i < k; i++) {\n            final IMap map = instances[i].getMap(mapName);\n            new Thread() {\n                public void run() {\n                    for (int j = 0; j < 100000; j++) {\n                        map.put(k + \"-\" + j, j);\n                    }\n                    latch.countDown();\n                }\n            }.start();\n        }\n\n        assertEquals(latch.await(10, TimeUnit.MINUTES), true);\n        assertEquals(0, failCount.get());\n    }","id":72828,"modified_method":"@Test\n    public void testEvictionSpeedTestPerPartition() throws InterruptedException {\n        final int k = 2;\n        final int size = 100;\n        final CountDownLatch latch = new CountDownLatch(k);\n        final String mapName = \"testEvictionSpeedTestPerPartition\";\n        Config cfg = new Config();\n        final MapConfig mc = cfg.getMapConfig(mapName);\n        mc.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);\n        mc.setEvictionPercentage(25);\n        final MaxSizeConfig msc = new MaxSizeConfig();\n        msc.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_PARTITION);\n        msc.setSize(size);\n        mc.setMaxSizeConfig(msc);\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(k);\n        final HazelcastInstance[] instances = factory.newInstances(cfg);\n        final int pnum = instances[0].getPartitionService().getPartitions().size();\n        final AtomicBoolean error = new AtomicBoolean(false);\n\n        new Thread() {\n            final IMap map = instances[0].getMap(mapName);\n\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                    while (latch.getCount() != 0) {\n                        try {\n                            int msize = map.size();\n                            if (msize > (size * pnum * 1.2)) {\n                                error.set(true);\n                            }\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n\n        for (int i = 0; i < k; i++) {\n            final IMap map = instances[i].getMap(mapName);\n            new Thread() {\n                public void run() {\n                    for (int j = 0; j < 10000; j++) {\n                        map.put(k + \"-\" + j, j);\n                    }\n                    latch.countDown();\n                }\n            }.start();\n        }\n\n        assertOpenEventually(latch);\n        assertFalse(\"map was not evicted properly!\", error.get());\n    }","commit_id":"221df54efc52ab8283d401400aa29502c01a26e0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private SelectorExecutionPlan getBestSelectorExecutionPlan(\n            NodeState rootState, FilterImpl filter,\n            QueryIndexProvider indexProvider, boolean traversalEnabled) {\n        QueryIndex best = null;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"cost using filter \" + filter);\n        }\n\n        double bestCost = Double.POSITIVE_INFINITY;\n        for (QueryIndex index : indexProvider.getQueryIndexes(rootState)) {\n            double cost;\n            if (index instanceof AdvancedQueryIndex) {\n                AdvancedQueryIndex advIndex = (AdvancedQueryIndex) index;\n                List<OrderEntry> sortOrder = null;\n                if (orderings != null) {\n                    sortOrder = new ArrayList<OrderEntry>();\n                    for (OrderingImpl o : orderings) {\n                        DynamicOperandImpl op = o.getOperand();\n                        if (!(op instanceof PropertyValueImpl)) {\n                            // ordered by a function: currently not supported\n                            break;\n                        }\n                        PropertyValueImpl p = (PropertyValueImpl) op;\n                        SelectorImpl s = p.getSelectors().iterator().next();\n                        if (!s.equals(filter.getSelector())) {\n                            // ordered by a different selector\n                            continue;\n                        }\n                        OrderEntry e = new OrderEntry(\n                                p.getPropertyName(), \n                                Type.UNDEFINED, \n                                o.isDescending() ? \n                                OrderEntry.Order.DESCENDING : OrderEntry.Order.ASCENDING);\n                        sortOrder.add(e);\n                    }\n                    if (sortOrder.size() == 0) {\n                        sortOrder = null;\n                    }\n                }\n                long maxEntryCount = limit;\n                if (offset > 0) {\n                    if (offset + limit < 0) {\n                        // long overflow\n                        maxEntryCount = Long.MAX_VALUE;\n                    } else {\n                        maxEntryCount = offset + limit;\n                    }\n                }\n                List<IndexPlan> ipList = advIndex.getPlans(\n                        filter, sortOrder, rootState);\n                cost = Double.POSITIVE_INFINITY;\n                for (IndexPlan p : ipList) {\n                    long entryCount = Math.min(maxEntryCount, p.getEstimatedEntryCount());\n                    double c = p.getCostPerExecution() + entryCount * p.getCostPerEntry();\n                    if (c < cost) {\n                        cost = c;\n                    }\n                }\n            } else {\n                cost = index.getCost(filter, rootState);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n            }\n            if (cost < bestCost) {\n                bestCost = cost;\n                best = index;\n            }\n        }\n\n        if (traversalEnabled) {\n            QueryIndex traversal = new TraversingIndex();\n            double cost = traversal.getCost(filter, rootState);\n            if (cost < bestCost || bestCost == Double.POSITIVE_INFINITY) {\n                bestCost = cost;\n                best = traversal;\n            }\n        }\n        return new SelectorExecutionPlan(filter.getSelector(), best, bestCost);\n    }","id":72829,"modified_method":"private SelectorExecutionPlan getBestSelectorExecutionPlan(\n            NodeState rootState, FilterImpl filter,\n            QueryIndexProvider indexProvider, boolean traversalEnabled) {\n        QueryIndex bestIndex = null;\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"cost using filter \" + filter);\n        }\n\n        double bestCost = Double.POSITIVE_INFINITY;\n        IndexPlan bestPlan = null;\n        for (QueryIndex index : indexProvider.getQueryIndexes(rootState)) {\n            double cost;\n            IndexPlan indexPlan = null;\n            if (index instanceof AdvancedQueryIndex) {\n                AdvancedQueryIndex advIndex = (AdvancedQueryIndex) index;\n                List<OrderEntry> sortOrder = null;\n                if (orderings != null) {\n                    sortOrder = new ArrayList<OrderEntry>();\n                    for (OrderingImpl o : orderings) {\n                        DynamicOperandImpl op = o.getOperand();\n                        if (!(op instanceof PropertyValueImpl)) {\n                            // ordered by a function: currently not supported\n                            break;\n                        }\n                        PropertyValueImpl p = (PropertyValueImpl) op;\n                        SelectorImpl s = p.getSelectors().iterator().next();\n                        if (!s.equals(filter.getSelector())) {\n                            // ordered by a different selector\n                            continue;\n                        }\n                        OrderEntry e = new OrderEntry(\n                                p.getPropertyName(), \n                                Type.UNDEFINED, \n                                o.isDescending() ? \n                                OrderEntry.Order.DESCENDING : OrderEntry.Order.ASCENDING);\n                        sortOrder.add(e);\n                    }\n                    if (sortOrder.size() == 0) {\n                        sortOrder = null;\n                    }\n                }\n                long maxEntryCount = limit;\n                if (offset > 0) {\n                    if (offset + limit < 0) {\n                        // long overflow\n                        maxEntryCount = Long.MAX_VALUE;\n                    } else {\n                        maxEntryCount = offset + limit;\n                    }\n                }\n                List<IndexPlan> ipList = advIndex.getPlans(\n                        filter, sortOrder, rootState);\n                cost = Double.POSITIVE_INFINITY;\n                for (IndexPlan p : ipList) {\n                    long entryCount = Math.min(maxEntryCount, p.getEstimatedEntryCount());\n                    double c = p.getCostPerExecution() + entryCount * p.getCostPerEntry();\n                    if (c < cost) {\n                        cost = c;\n                        indexPlan = p;\n                    }\n                }\n            } else {\n                cost = index.getCost(filter, rootState);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n            }\n            if (cost < bestCost) {\n                bestCost = cost;\n                bestIndex = index;\n                bestPlan = indexPlan;\n            }\n        }\n\n        if (traversalEnabled) {\n            QueryIndex traversal = new TraversingIndex();\n            double cost = traversal.getCost(filter, rootState);\n            if (cost < bestCost || bestCost == Double.POSITIVE_INFINITY) {\n                bestCost = cost;\n                bestIndex = traversal;\n            }\n        }\n        return new SelectorExecutionPlan(filter.getSelector(), bestIndex, bestPlan, bestCost);\n    }","commit_id":"53566136323ea59fe8f83900c5aec6768d49348c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SelectorExecutionPlan(SelectorImpl selector, QueryIndex index, double estimatedCost) {\n        this.selector = selector;\n        this.index = index;\n        this.estimatedCost = estimatedCost;\n    }","id":72830,"modified_method":"public SelectorExecutionPlan(SelectorImpl selector, QueryIndex index, IndexPlan plan, double estimatedCost) {\n        this.selector = selector;\n        this.index = index;\n        this.estimatedCost = estimatedCost;\n        this.plan = plan;\n    }","commit_id":"53566136323ea59fe8f83900c5aec6768d49348c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void execute(NodeState rootState) {\n        if (plan.getIndex() != null) {\n            cursor = plan.getIndex().query(createFilter(false), rootState);\n        } else {\n            cursor = Cursors.newPathCursor(new ArrayList<String>());\n        }\n    }","id":72831,"modified_method":"@Override\n    public void execute(NodeState rootState) {\n        QueryIndex index = plan.getIndex();\n        if (index == null) {\n            cursor = Cursors.newPathCursor(new ArrayList<String>());\n            return;\n        }\n        IndexPlan p = plan.getIndexPlan();\n        if (p != null) {\n            p.setFilter(createFilter(false));\n            AdvancedQueryIndex adv = (AdvancedQueryIndex) index;\n            cursor = adv.query(p, rootState);\n        } else {\n            cursor = index.query(createFilter(false), rootState);\n        }\n    }","commit_id":"53566136323ea59fe8f83900c5aec6768d49348c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n  public void enqueue(List<IndexAction> actions) {\n\n    int bcount = 0;\n    int ecount = 0;\n    List<String> refreshes = Lists.newArrayList();\n    Set<String> types = Sets.newHashSet();\n    long all_start = System.currentTimeMillis();\n    long indexTime;\n    long refreshTime;\n    long embeddedTime;\n\n    if (actions.size() == 1) {\n      /* Atomic update here */\n      CountDownLatch latch = new CountDownLatch(1);\n      IndexAction action = actions.get(0);\n      action.setLatch(latch);\n      try {\n        indexTime = System.currentTimeMillis();\n        this.offer(action, 1000, TimeUnit.SECONDS);\n        latch.await(1000, TimeUnit.MILLISECONDS);\n        bcount ++;\n        indexTime = System.currentTimeMillis() - indexTime;\n        // refresh the index.\n        refreshTime = System.currentTimeMillis();\n        action.getIndex().refresh();\n        refreshTime = System.currentTimeMillis() - refreshTime;\n        refreshes.add(action.getIndex().getIndexName());\n        types.add(action.getPayloadClass().getSimpleName());\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"ES update has been interrupted\", e);\n      }\n    } else if (actions.size() > 1) {\n\n      /* Purge actions that would be overridden  */\n      Long purgeStart = System.currentTimeMillis();\n      List<IndexAction> itemActions = Lists.newArrayList();\n      List<IndexAction> embeddedActions = Lists.newArrayList();\n\n      for (IndexAction action : actions) {\n        if(action.getClass().isAssignableFrom(EmbeddedIndexAction.class)){\n          embeddedActions.add(action);\n        } else {\n          itemActions.add(action);\n        }\n      }\n\n      LOGGER.debug(\"INDEX - compressed {} items into {} in {}ms,\",\n        actions.size(), itemActions.size() + embeddedActions.size(), System.currentTimeMillis() - purgeStart);\n\n      try {\n        /* execute all item actions */\n        CountDownLatch itemLatch = new CountDownLatch(itemActions.size());\n        indexTime = System.currentTimeMillis();\n        for (IndexAction action : itemActions) {\n          action.setLatch(itemLatch);\n          this.offer(action, 1000, TimeUnit.SECONDS);\n          types.add(action.getPayloadClass().getSimpleName());\n          bcount++;\n\n        }\n        itemLatch.await(2000, TimeUnit.MILLISECONDS);\n        indexTime = System.currentTimeMillis() - indexTime;\n\n        /* and now push the embedded */\n        CountDownLatch embeddedLatch = new CountDownLatch(embeddedActions.size());\n        embeddedTime = System.currentTimeMillis();\n        for (IndexAction action : embeddedActions) {\n          action.setLatch(embeddedLatch);\n          this.offer(action, 1000, TimeUnit.SECONDS);\n          types.add(action.getPayloadClass().getSimpleName());\n          ecount ++;\n        }\n        embeddedLatch.await(1500, TimeUnit.MILLISECONDS);\n        embeddedTime = System.currentTimeMillis() - embeddedTime;\n\n        /* Finally refresh affected indexes */\n        Set<String> refreshedIndexes = new HashSet<String>();\n        refreshTime = System.currentTimeMillis();\n        for (IndexAction action : actions) {\n          if (action.getIndex() != null &&\n            !refreshedIndexes.contains(action.getIndex().getIndexName())){\n            refreshedIndexes.add(action.getIndex().getIndexName());\n            action.getIndex().refresh();\n            refreshes.add(action.getIndex().getIndexName());\n          }\n        }\n        refreshTime = System.currentTimeMillis() - refreshTime;\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"ES update has been interrupted\", e);\n      }\n      LOGGER.debug(\"INDEX - time:{}ms ({}ms index, {}ms embedded, {}ms refresh)\\ttypes:[{}],\\tbulk:{}\\tembedded:{}\\trefresh:[{}]\",\n        (System.currentTimeMillis() - all_start), indexTime, embeddedTime, refreshTime,\n        StringUtils.join(types,\",\"),\n        bcount, ecount, StringUtils.join(refreshes, \",\"));\n    }\n  }","id":72832,"modified_method":"@Override\n  public void enqueue(List<IndexAction> actions) {\n\n    int bcount = 0;\n    int ecount = 0;\n    List<String> refreshes = Lists.newArrayList();\n    Set<String> types = Sets.newHashSet();\n    long all_start = System.currentTimeMillis();\n    long indexTime;\n    long refreshTime;\n    long embeddedTime;\n\n    if (actions.size() == 1) {\n      /* Atomic update here */\n      CountDownLatch latch = new CountDownLatch(1);\n      IndexAction action = actions.get(0);\n      action.setLatch(latch);\n      try {\n        indexTime = System.currentTimeMillis();\n        this.offer(action, 1000, TimeUnit.SECONDS);\n        latch.await(1000, TimeUnit.MILLISECONDS);\n        bcount++;\n        indexTime = System.currentTimeMillis() - indexTime;\n        // refresh the index.\n        Index<?, ?, ?> index = action.getIndex();\n        if (index != null) {\n          refreshTime = System.currentTimeMillis();\n          index.refresh();\n          refreshTime = System.currentTimeMillis() - refreshTime;\n          refreshes.add(action.getIndex().getIndexName());\n        }\n        types.add(action.getPayloadClass().getSimpleName());\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"ES update has been interrupted\", e);\n      }\n    } else if (actions.size() > 1) {\n\n      /* Purge actions that would be overridden  */\n      Long purgeStart = System.currentTimeMillis();\n      List<IndexAction> itemActions = Lists.newArrayList();\n      List<IndexAction> embeddedActions = Lists.newArrayList();\n\n      for (IndexAction action : actions) {\n        if (action.getClass().isAssignableFrom(EmbeddedIndexAction.class)) {\n          embeddedActions.add(action);\n        } else {\n          itemActions.add(action);\n        }\n      }\n\n      LOGGER.debug(\"INDEX - compressed {} items into {} in {}ms,\",\n        actions.size(), itemActions.size() + embeddedActions.size(), System.currentTimeMillis() - purgeStart);\n\n      try {\n        /* execute all item actions */\n        CountDownLatch itemLatch = new CountDownLatch(itemActions.size());\n        indexTime = System.currentTimeMillis();\n        for (IndexAction action : itemActions) {\n          action.setLatch(itemLatch);\n          this.offer(action, 1000, TimeUnit.SECONDS);\n          types.add(action.getPayloadClass().getSimpleName());\n          bcount++;\n\n        }\n        itemLatch.await(2000, TimeUnit.MILLISECONDS);\n        indexTime = System.currentTimeMillis() - indexTime;\n\n        /* and now push the embedded */\n        CountDownLatch embeddedLatch = new CountDownLatch(embeddedActions.size());\n        embeddedTime = System.currentTimeMillis();\n        for (IndexAction action : embeddedActions) {\n          action.setLatch(embeddedLatch);\n          this.offer(action, 1000, TimeUnit.SECONDS);\n          types.add(action.getPayloadClass().getSimpleName());\n          ecount++;\n        }\n        embeddedLatch.await(1500, TimeUnit.MILLISECONDS);\n        embeddedTime = System.currentTimeMillis() - embeddedTime;\n\n        /* Finally refresh affected indexes */\n        Set<String> refreshedIndexes = new HashSet<String>();\n        refreshTime = System.currentTimeMillis();\n        for (IndexAction action : actions) {\n          if (action.getIndex() != null &&\n            !refreshedIndexes.contains(action.getIndex().getIndexName())) {\n            refreshedIndexes.add(action.getIndex().getIndexName());\n            action.getIndex().refresh();\n            refreshes.add(action.getIndex().getIndexName());\n          }\n        }\n        refreshTime = System.currentTimeMillis() - refreshTime;\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"ES update has been interrupted\", e);\n      }\n      LOGGER.debug(\"INDEX - time:{}ms ({}ms index, {}ms embedded, {}ms refresh)\\ttypes:[{}],\\tbulk:{}\\tembedded:{}\\trefresh:[{}]\",\n        (System.currentTimeMillis() - all_start), indexTime, embeddedTime, refreshTime,\n        StringUtils.join(types, \",\"),\n        bcount, ecount, StringUtils.join(refreshes, \",\"));\n    }\n  }","commit_id":"6086a6ea7b314b50dfdf617f9f2de3e1a8129601","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Style(EditorCell contextCell) {\n    myEditorCell = contextCell;\n    updateCache();\n  }","id":72833,"modified_method":"public Style(EditorCell contextCell) {\n    myEditorCell = contextCell;\n  }","commit_id":"c8c08f5bf5f3fb67c6ca50a878dd73f9c388b06f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public <T> T get(StyleAttribute<T> attribute) {\n    return (T) myCachedAttributeValues[attribute.getIndex()];\n  }","id":72834,"modified_method":"public <T> T get(StyleAttribute<T> attribute) {\n    int index = attribute.getIndex();\n    T value = (T) myCachedAttributeValues[index];\n    if (value != null) {\n      return value;\n    } else {\n      T result = attribute.combine(null, null);\n      myCachedAttributeValues[index] = result;\n      return result;\n    }\n  }","commit_id":"c8c08f5bf5f3fb67c6ca50a878dd73f9c388b06f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void updateCache() {    \n    Object[] oldCachedValues = myCachedAttributeValues;\n    myCachedAttributeValues = new Object[StyleAttributes.getAttributesCount()];\n\n    Set<StyleAttribute> changedAttributes = new HashSet<StyleAttribute>();\n\n    for (StyleAttribute attribute : StyleAttributes.getAttributes()) {\n      Object parentValue = getParentStyle() == null ? null : getParentStyle().get(attribute);\n      Object currentValue = myAttributeValues[attribute.getIndex()];\n\n      if (currentValue instanceof AttributeCalculator) {\n        currentValue = ((AttributeCalculator) currentValue).calculate(myEditorCell);\n      }\n      Object newValue = attribute.combine(parentValue, currentValue);\n\n      if (!EqualUtil.equals(newValue, oldCachedValues[attribute.getIndex()])) {\n        changedAttributes.add(attribute);\n      }\n\n      myCachedAttributeValues[attribute.getIndex()] =  newValue;\n    }\n\n    if (!changedAttributes.isEmpty()) {\n      for (Style style : myChildren) {\n        style.updateCache();\n      }\n\n      fireStyleChanged(new StyleChangeEvent(this, changedAttributes));\n    }\n  }","id":72835,"modified_method":"private void updateCache() {    \n    Object[] oldCachedValues = myCachedAttributeValues;\n    myCachedAttributeValues = new Object[StyleAttributes.getAttributesCount()];\n\n    Set<StyleAttribute> changedAttributes = new HashSet<StyleAttribute>();\n\n    for (StyleAttribute attribute : StyleAttributes.getAttributes()) {\n      Object parentValue = getParentStyle() == null ? null : getParentStyle().get(attribute);\n      Object currentValue = myAttributeValues[attribute.getIndex()];\n\n      if (parentValue != null || currentValue != null) {\n        if (currentValue instanceof AttributeCalculator) {\n          currentValue = ((AttributeCalculator) currentValue).calculate(myEditorCell);\n        }\n\n        Object newValue = attribute.combine(parentValue, currentValue);\n\n        if (!EqualUtil.equals(newValue, oldCachedValues[attribute.getIndex()])) {\n          changedAttributes.add(attribute);\n        }\n\n        myCachedAttributeValues[attribute.getIndex()] =  newValue;\n      }\n    }\n\n    if (!changedAttributes.isEmpty()) {\n      for (Style style : myChildren) {\n        style.updateCache();\n      }\n\n      fireStyleChanged(new StyleChangeEvent(this, changedAttributes));\n    }\n  }","commit_id":"c8c08f5bf5f3fb67c6ca50a878dd73f9c388b06f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void enqueue(List<IndexAction> actions) {\n\n    int bcount = 0;\n    int ecount = 0;\n    List<String> refreshes = Lists.newArrayList();\n    Set<String> types = Sets.newHashSet();\n    long all_start = System.currentTimeMillis();\n    long indexTime;\n    long refreshTime;\n    long embeddedTime;\n\n    if (actions.size() == 1) {\n      /* Atomic update here */\n      CountDownLatch latch = new CountDownLatch(1);\n      IndexAction action = actions.get(0);\n      action.setLatch(latch);\n      try {\n        indexTime = System.currentTimeMillis();\n        this.offer(action, 1000, TimeUnit.SECONDS);\n        latch.await(1000, TimeUnit.MILLISECONDS);\n        bcount ++;\n        indexTime = System.currentTimeMillis() - indexTime;\n        // refresh the index.\n        refreshTime = System.currentTimeMillis();\n        action.getIndex().refresh();\n        refreshTime = System.currentTimeMillis() - refreshTime;\n        refreshes.add(action.getIndex().getIndexName());\n        types.add(action.getPayloadClass().getSimpleName());\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"ES update has been interrupted\", e);\n      }\n    } else if (actions.size() > 1) {\n\n      /* Purge actions that would be overridden  */\n      Long purgeStart = System.currentTimeMillis();\n      List<IndexAction> itemActions = Lists.newArrayList();\n      List<IndexAction> embeddedActions = Lists.newArrayList();\n\n      for (IndexAction action : actions) {\n        if(action.getClass().isAssignableFrom(EmbeddedIndexAction.class)){\n          embeddedActions.add(action);\n        } else {\n          itemActions.add(action);\n        }\n      }\n\n      LOGGER.debug(\"INDEX - compressed {} items into {} in {}ms,\",\n        actions.size(), itemActions.size() + embeddedActions.size(), System.currentTimeMillis() - purgeStart);\n\n      try {\n        /* execute all item actions */\n        CountDownLatch itemLatch = new CountDownLatch(itemActions.size());\n        indexTime = System.currentTimeMillis();\n        for (IndexAction action : itemActions) {\n          action.setLatch(itemLatch);\n          this.offer(action, 1000, TimeUnit.SECONDS);\n          types.add(action.getPayloadClass().getSimpleName());\n          bcount++;\n\n        }\n        itemLatch.await(2000, TimeUnit.MILLISECONDS);\n        indexTime = System.currentTimeMillis() - indexTime;\n\n        /* and now push the embedded */\n        CountDownLatch embeddedLatch = new CountDownLatch(embeddedActions.size());\n        embeddedTime = System.currentTimeMillis();\n        for (IndexAction action : embeddedActions) {\n          action.setLatch(embeddedLatch);\n          this.offer(action, 1000, TimeUnit.SECONDS);\n          types.add(action.getPayloadClass().getSimpleName());\n          ecount ++;\n        }\n        embeddedLatch.await(1500, TimeUnit.MILLISECONDS);\n        embeddedTime = System.currentTimeMillis() - embeddedTime;\n\n        /* Finally refresh affected indexes */\n        Set<String> refreshedIndexes = new HashSet<String>();\n        refreshTime = System.currentTimeMillis();\n        for (IndexAction action : actions) {\n          if (action.getIndex() != null &&\n            !refreshedIndexes.contains(action.getIndex().getIndexName())){\n            refreshedIndexes.add(action.getIndex().getIndexName());\n            action.getIndex().refresh();\n            refreshes.add(action.getIndex().getIndexName());\n          }\n        }\n        refreshTime = System.currentTimeMillis() - refreshTime;\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"ES update has been interrupted\", e);\n      }\n      LOGGER.debug(\"INDEX - time:{}ms ({}ms index, {}ms embedded, {}ms refresh)\\ttypes:[{}],\\tbulk:{}\\tembedded:{}\\trefresh:[{}]\",\n        (System.currentTimeMillis() - all_start), indexTime, embeddedTime, refreshTime,\n        StringUtils.join(types,\",\"),\n        bcount, ecount, StringUtils.join(refreshes, \",\"));\n    }\n  }","id":72836,"modified_method":"@Override\n  public void enqueue(List<IndexAction> actions) {\n\n    int bcount = 0;\n    int ecount = 0;\n    List<String> refreshes = Lists.newArrayList();\n    Set<String> types = Sets.newHashSet();\n    long all_start = System.currentTimeMillis();\n    long indexTime;\n    long refreshTime;\n    long embeddedTime;\n\n    if (actions.size() == 1) {\n      /* Atomic update here */\n      CountDownLatch latch = new CountDownLatch(1);\n      IndexAction action = actions.get(0);\n      action.setLatch(latch);\n      try {\n        indexTime = System.currentTimeMillis();\n        this.offer(action, 1000, TimeUnit.SECONDS);\n        latch.await(1000, TimeUnit.MILLISECONDS);\n        bcount++;\n        indexTime = System.currentTimeMillis() - indexTime;\n        // refresh the index.\n        Index<?, ?, ?> index = action.getIndex();\n        if (index != null) {\n          refreshTime = System.currentTimeMillis();\n          index.refresh();\n          refreshTime = System.currentTimeMillis() - refreshTime;\n          refreshes.add(action.getIndex().getIndexName());\n        }\n        types.add(action.getPayloadClass().getSimpleName());\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"ES update has been interrupted\", e);\n      }\n    } else if (actions.size() > 1) {\n\n      /* Purge actions that would be overridden  */\n      Long purgeStart = System.currentTimeMillis();\n      List<IndexAction> itemActions = Lists.newArrayList();\n      List<IndexAction> embeddedActions = Lists.newArrayList();\n\n      for (IndexAction action : actions) {\n        if (action.getClass().isAssignableFrom(EmbeddedIndexAction.class)) {\n          embeddedActions.add(action);\n        } else {\n          itemActions.add(action);\n        }\n      }\n\n      LOGGER.debug(\"INDEX - compressed {} items into {} in {}ms,\",\n        actions.size(), itemActions.size() + embeddedActions.size(), System.currentTimeMillis() - purgeStart);\n\n      try {\n        /* execute all item actions */\n        CountDownLatch itemLatch = new CountDownLatch(itemActions.size());\n        indexTime = System.currentTimeMillis();\n        for (IndexAction action : itemActions) {\n          action.setLatch(itemLatch);\n          this.offer(action, 1000, TimeUnit.SECONDS);\n          types.add(action.getPayloadClass().getSimpleName());\n          bcount++;\n\n        }\n        itemLatch.await(2000, TimeUnit.MILLISECONDS);\n        indexTime = System.currentTimeMillis() - indexTime;\n\n        /* and now push the embedded */\n        CountDownLatch embeddedLatch = new CountDownLatch(embeddedActions.size());\n        embeddedTime = System.currentTimeMillis();\n        for (IndexAction action : embeddedActions) {\n          action.setLatch(embeddedLatch);\n          this.offer(action, 1000, TimeUnit.SECONDS);\n          types.add(action.getPayloadClass().getSimpleName());\n          ecount++;\n        }\n        embeddedLatch.await(1500, TimeUnit.MILLISECONDS);\n        embeddedTime = System.currentTimeMillis() - embeddedTime;\n\n        /* Finally refresh affected indexes */\n        Set<String> refreshedIndexes = new HashSet<String>();\n        refreshTime = System.currentTimeMillis();\n        for (IndexAction action : actions) {\n          if (action.getIndex() != null &&\n            !refreshedIndexes.contains(action.getIndex().getIndexName())) {\n            refreshedIndexes.add(action.getIndex().getIndexName());\n            action.getIndex().refresh();\n            refreshes.add(action.getIndex().getIndexName());\n          }\n        }\n        refreshTime = System.currentTimeMillis() - refreshTime;\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"ES update has been interrupted\", e);\n      }\n      LOGGER.debug(\"INDEX - time:{}ms ({}ms index, {}ms embedded, {}ms refresh)\\ttypes:[{}],\\tbulk:{}\\tembedded:{}\\trefresh:[{}]\",\n        (System.currentTimeMillis() - all_start), indexTime, embeddedTime, refreshTime,\n        StringUtils.join(types, \",\"),\n        bcount, ecount, StringUtils.join(refreshes, \",\"));\n    }\n  }","commit_id":"426b079905ae3ba2cd7f44c020387be3634dddc0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(CommonDataKeys.PROJECT);\n    if (project == null) {\n      return;\n    }\n    final PsiFile file = CommonDataKeys.PSI_FILE.getData(e.getDataContext());\n    if (file == null) return;\n    final Editor editor = CommonDataKeys.EDITOR.getData(e.getDataContext());\n    if (editor == null) return;\n\n    final SelectionModel model = editor.getSelectionModel();\n    final Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    if (document == null) return;\n    final int start = model.getSelectionStart();\n    final int end = model.getSelectionEnd();\n    final int lineNumber = document.getLineNumber(start);\n    final int length = end - start;\n    int realStart = start - document.getLineStartOffset(lineNumber);\n\n    final CCProjectService service = CCProjectService.getInstance(project);\n    final Course course = service.getCourse();\n    final PsiDirectory taskDir = file.getContainingDirectory();\n    final PsiDirectory lessonDir = taskDir.getParent();\n    if (lessonDir == null) return;\n\n    final Lesson lesson = course.getLesson(lessonDir.getName());\n    final Task task = lesson.getTask(taskDir.getName());\n    final TaskFile taskFile = task.getTaskFile(file.getName());\n    final TaskWindow taskWindow = new TaskWindow(lineNumber, realStart, length, model.getSelectedText());\n    CreateTaskWindowDialog dlg = new CreateTaskWindowDialog(project, taskWindow, lesson.getIndex(), task.getIndex(), file.getVirtualFile().getNameWithoutExtension(), taskFile.getTaskWindows().size() + 1);\n    dlg.show();\n    if (dlg.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n      return;\n    }\n    int index = taskFile.getTaskWindows().size() + 1;\n    taskFile.addTaskWindow(taskWindow, index);\n    taskWindow.drawHighlighter(editor, false);\n    taskWindow.createGuardedBlocks(editor);\n    DaemonCodeAnalyzerImpl.getInstance(project).restart(file);\n  }","id":72837,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(CommonDataKeys.PROJECT);\n    if (project == null) {\n      return;\n    }\n    final PsiFile file = CommonDataKeys.PSI_FILE.getData(e.getDataContext());\n    if (file == null) return;\n    final Editor editor = CommonDataKeys.EDITOR.getData(e.getDataContext());\n    if (editor == null) return;\n\n    final SelectionModel model = editor.getSelectionModel();\n    final Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    if (document == null) return;\n    final int start = model.getSelectionStart();\n    final int end = model.getSelectionEnd();\n    final int lineNumber = document.getLineNumber(start);\n    final int length = end - start;\n    int realStart = start - document.getLineStartOffset(lineNumber);\n\n    final CCProjectService service = CCProjectService.getInstance(project);\n    final Course course = service.getCourse();\n    final PsiDirectory taskDir = file.getContainingDirectory();\n    final PsiDirectory lessonDir = taskDir.getParent();\n    if (lessonDir == null) return;\n\n    final Lesson lesson = course.getLesson(lessonDir.getName());\n    final Task task = lesson.getTask(taskDir.getName());\n    final TaskFile taskFile = task.getTaskFile(file.getName());\n    final TaskWindow taskWindow = new TaskWindow(lineNumber, realStart, length, model.getSelectedText());\n    CreateTaskWindowDialog dlg = new CreateTaskWindowDialog(project, taskWindow, lesson.getIndex(), task.getIndex(), file.getVirtualFile().getNameWithoutExtension(), taskFile.getTaskWindows().size() + 1);\n    dlg.show();\n    if (dlg.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n      return;\n    }\n    int index = taskFile.getTaskWindows().size() + 1;\n    taskFile.addTaskWindow(taskWindow, index);\n    taskWindow.drawHighlighter(editor, false);\n    taskWindow.createGuardedBlocks(editor);\n  }","commit_id":"3d534f1c93bd697a7fa6d74f7e79688fc933caed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CCDeleteTaskWindow(@NotNull final TaskWindow taskWindow) {\n    super(\"Delete task window\",\"Delete task window\", null);\n    myTaskWindow = taskWindow;\n  }","id":72838,"modified_method":"public CCDeleteTaskWindow() {\n    super(\"Delete task window\",\"Delete task window\", null);\n  }","commit_id":"3d534f1c93bd697a7fa6d74f7e79688fc933caed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setHintText(Project project, TaskWindow taskWindow) {\n    VirtualFile hints = project.getBaseDir().findChild(\"hints\");\n    if (hints != null) {\n      File file = new File(hints.getPath(), taskWindow.getHintName());\n      StringBuilder hintText = new StringBuilder();\n      if (file.exists()) {\n        try {\n          BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n          String line;\n          while ((line = bufferedReader.readLine()) != null) {\n            hintText.append(line).append(\"\\n\");\n          }\n          myPanel.doClick();\n          //myPanel.enableHint(true);\n          myPanel.setHintText(hintText.toString());\n        }\n        catch (FileNotFoundException e) {\n          LOG.error(\"created hint was not found\", e);\n        }\n        catch (IOException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","id":72839,"modified_method":"@SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n  private void setHintText(Project project, TaskWindow taskWindow) {\n    VirtualFile hints = project.getBaseDir().findChild(\"hints\");\n    if (hints != null) {\n      File file = new File(hints.getPath(), taskWindow.getHintName());\n      StringBuilder hintText = new StringBuilder();\n      if (file.exists()) {\n        BufferedReader bufferedReader =  null;\n        try {\n          bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n          String line;\n          while ((line = bufferedReader.readLine()) != null) {\n            hintText.append(line).append(\"\\n\");\n          }\n          myPanel.doClick();\n          //myPanel.enableHint(true);\n          myPanel.setHintText(hintText.toString());\n        }\n        catch (FileNotFoundException e) {\n          LOG.error(\"created hint was not found\", e);\n        }\n        catch (IOException e) {\n          LOG.error(e);\n        }\n        finally {\n          if (bufferedReader != null) {\n            try {\n              bufferedReader.close();\n            }\n            catch (IOException e) {\n              //close silently\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"3d534f1c93bd697a7fa6d74f7e79688fc933caed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(@NotNull final TaskFile source) {\n    for (TaskWindow taskWindow : source.getTaskWindows()) {\n      TaskWindow taskWindowUpdated = task_windows.get(taskWindow.getIndex() - 1);\n      taskWindowUpdated.setLine(taskWindow.getLine());\n      taskWindowUpdated.setStart(taskWindow.getStart());\n    }\n  }","id":72840,"modified_method":"public void update(@NotNull final TaskFile source) {\n    for (TaskWindow taskWindow : source.getTaskWindows()) {\n      TaskWindow taskWindowUpdated = getTaskWindow(taskWindow.getIndex());\n      if (taskWindowUpdated == null) {\n        break;\n      }\n      taskWindowUpdated.setLine(taskWindow.getLine());\n      taskWindowUpdated.setStart(taskWindow.getStart());\n    }\n  }","commit_id":"3d534f1c93bd697a7fa6d74f7e79688fc933caed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Sets the rebuild mode for the requested index. Allowing to disable indexing during module import.<p>\n     * This setting will not be written to the XML configuration file and will only take effect within the current shell instance.<p>\n     *\n     * @param searchIndex the search index\n     * @param mode the rebuild mode to set\n     */\n    public void setIndexRebuildMode(String searchIndex, String mode) {\n\n        OpenCms.getSearchManager().getIndex(searchIndex).setRebuildMode(mode);\n        // required for this setting to take effect\n        OpenCms.getSearchManager().initOfflineIndexes();\n    }","id":72841,"modified_method":"/**\n     * Sets the rebuild mode for the requested index. Allowing to disable indexing during module import.<p>\n     * This setting will not be written to the XML configuration file and will only take effect within the current shell instance.<p>\n     *\n     * @param searchIndex the search index\n     * @param mode the rebuild mode to set\n     */\n    public void setIndexRebuildMode(String searchIndex, String mode) {\n\n        CmsSearchIndex index = OpenCms.getSearchManager().getIndex(searchIndex);\n        if (index != null) {\n            index.setRebuildMode(mode);\n            // required for this setting to take effect\n            OpenCms.getSearchManager().initOfflineIndexes();\n        }\n    }","commit_id":"b8b32672a5c2c017da2f094b6f491e65293c8ffe","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {\n\t\tint skewConstant = (int) getDensityValue(rc, 16);\n\t\tint iconsW = rc.width / skewConstant;\n\t\tint iconsH = rc.height / skewConstant;\n\t\tint[] alreadyDrawnIcons = new int[iconsW * iconsH / 32];\n\t\tfor (IconDrawInfo icon : rc.iconsToDraw) {\n\t\t\tif (icon.resId != 0) {\n\t\t\t\tif (cachedIcons.get(icon.resId) == null) {\n\t\t\t\t\tcachedIcons.put(icon.resId, UnscaledBitmapLoader.loadFromResource(context.getResources(), icon.resId, null, dm));\n\t\t\t\t}\n\t\t\t\tBitmap ico = cachedIcons.get(icon.resId);\n\t\t\t\tif (ico != null) {\n\t\t\t\t\tif (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {\n\t\t\t\t\t\tint z = (((int) icon.x / skewConstant) + ((int) icon.y / skewConstant) * iconsW);\n\t\t\t\t\t\tint i = z / 32;\n\t\t\t\t\t\tif (i >= alreadyDrawnIcons.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ind = alreadyDrawnIcons[i];\n\t\t\t\t\t\tint b = z % 32;\n\t\t\t\t\t\t// check bit b if it is set\n\t\t\t\t\t\tif (((ind >> b) & 1) == 0) {\n\t\t\t\t\t\t\talreadyDrawnIcons[i] = ind | (1 << b);\n\t\t\t\t\t\t\tcv.drawBitmap(ico, icon.x - ico.getWidth() / 2, icon.y - ico.getHeight() / 2, paintIcon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc.interrupted) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","id":72842,"modified_method":"private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {\n\t\tint skewConstant = (int) getDensityValue(rc, 16);\n\t\tint iconsW = rc.width / skewConstant;\n\t\tint iconsH = rc.height / skewConstant;\n\t\tint[] alreadyDrawnIcons = new int[iconsW * iconsH / 32];\n\t\tfor (IconDrawInfo icon : rc.iconsToDraw) {\n\t\t\tif (icon.resId != null) {\n\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, icon.resId);\n\t\t\t\tif (ico != null) {\n\t\t\t\t\tif (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {\n\t\t\t\t\t\tint z = (((int) icon.x / skewConstant) + ((int) icon.y / skewConstant) * iconsW);\n\t\t\t\t\t\tint i = z / 32;\n\t\t\t\t\t\tif (i >= alreadyDrawnIcons.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ind = alreadyDrawnIcons[i];\n\t\t\t\t\t\tint b = z % 32;\n\t\t\t\t\t\t// check bit b if it is set\n\t\t\t\t\t\tif (((ind >> b) & 1) == 0) {\n\t\t\t\t\t\t\talreadyDrawnIcons[i] = ind | (1 << b);\n\t\t\t\t\t\t\tcv.drawBitmap(ico, icon.x - ico.getWidth() / 2, icon.y - ico.getHeight() / 2, paintIcon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc.interrupted) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, boolean area, RenderingContext rc){\n\t\tRenderingRuleProperty rColor;\n\t\tRenderingRuleProperty rStrokeW;\n\t\tRenderingRuleProperty rCap;\n\t\tRenderingRuleProperty rPathEff;\n\t\tif(ind == 0){\n\t\t\trColor = req.ALL.R_COLOR;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH;\n\t\t\trCap = req.ALL.R_CAP;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT;\n\t\t} else if(ind == 1){\n\t\t\trColor = req.ALL.R_COLOR_2;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_2;\n\t\t\trCap = req.ALL.R_CAP_2;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_2;\n\t\t} else {\n\t\t\trColor = req.ALL.R_COLOR_3;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_3;\n\t\t\trCap = req.ALL.R_CAP_3;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_3;\n\t\t}\n\t\tif(area){\n\t\t\tif(!req.isSpecified(rColor) && !req.isSpecified(req.ALL.R_SHADER)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp.setStyle(Style.FILL_AND_STROKE);\n\t\t\tp.setStrokeWidth(0);\n\t\t} else {\n\t\t\tif(!req.isSpecified(rStrokeW)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp.setStyle(Style.STROKE);\n\t\t\tp.setStrokeWidth(req.getFloatPropertyValue(rStrokeW));\n\t\t\tString cap = req.getStringPropertyValue(rCap);\n\t\t\tif(!Algoritms.isEmpty(cap)){\n\t\t\t\tp.setStrokeCap(Cap.valueOf(cap.toUpperCase()));\n\t\t\t} else {\n\t\t\t\tp.setStrokeCap(Cap.BUTT);\n\t\t\t}\n\t\t\tString pathEffect = req.getStringPropertyValue(rPathEff);\n\t\t\tif (!Algoritms.isEmpty(pathEffect)) {\n\t\t\t\tp.setPathEffect(getDashEffect(pathEffect));\n\t\t\t} else {\n\t\t\t\tp.setPathEffect(null);\n\t\t\t}\n\t\t}\n\t\tp.setColor(req.getIntPropertyValue(rColor));\n\t\t\n\t\tif(ind == 0){\n\t\t\tInteger resId = RenderingIcons.getIcons().get(req.getStringPropertyValue(req.ALL.R_SHADER));\n\t\t\tif(resId != null){\n\t\t\t\tp.setColor(Color.BLACK);\n\t\t\t\tp.setShader(getShader(resId));\n\t\t\t} else {\n\t\t\t\tp.setShader(null);\n\t\t\t}\n\t\t\t\n\t\t\t// do not check shadow color here\n\t\t\tif(rc.shadowRenderingMode != 1) {\n\t\t\t\tpaint.clearShadowLayer();\n\t\t\t} else {\n\t\t\t\tint shadowColor = req.getIntPropertyValue(req.ALL.R_SHADOW_COLOR);\n\t\t\t\tint shadowLayer = req.getIntPropertyValue(req.ALL.R_SHADOW_RADIUS);\n\t\t\t\tif (shadowColor == 0) {\n\t\t\t\t\tshadowLayer = 0;\n\t\t\t\t}\n\t\t\t\tp.setShadowLayer(shadowLayer, 0, 0, shadowColor);\n\t\t\t}\n\t\t} else {\n\t\t\tp.setShader(null);\n\t\t\tp.clearShadowLayer();\n\t\t}\n\t\treturn true;\n\t\t\n\t}","id":72843,"modified_method":"private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, boolean area, RenderingContext rc){\n\t\tRenderingRuleProperty rColor;\n\t\tRenderingRuleProperty rStrokeW;\n\t\tRenderingRuleProperty rCap;\n\t\tRenderingRuleProperty rPathEff;\n\t\tif(ind == 0){\n\t\t\trColor = req.ALL.R_COLOR;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH;\n\t\t\trCap = req.ALL.R_CAP;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT;\n\t\t} else if(ind == 1){\n\t\t\trColor = req.ALL.R_COLOR_2;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_2;\n\t\t\trCap = req.ALL.R_CAP_2;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_2;\n\t\t} else {\n\t\t\trColor = req.ALL.R_COLOR_3;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_3;\n\t\t\trCap = req.ALL.R_CAP_3;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_3;\n\t\t}\n\t\tif(area){\n\t\t\tif(!req.isSpecified(rColor) && !req.isSpecified(req.ALL.R_SHADER)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp.setStyle(Style.FILL_AND_STROKE);\n\t\t\tp.setStrokeWidth(0);\n\t\t} else {\n\t\t\tif(!req.isSpecified(rStrokeW)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp.setStyle(Style.STROKE);\n\t\t\tp.setStrokeWidth(req.getFloatPropertyValue(rStrokeW));\n\t\t\tString cap = req.getStringPropertyValue(rCap);\n\t\t\tif(!Algoritms.isEmpty(cap)){\n\t\t\t\tp.setStrokeCap(Cap.valueOf(cap.toUpperCase()));\n\t\t\t} else {\n\t\t\t\tp.setStrokeCap(Cap.BUTT);\n\t\t\t}\n\t\t\tString pathEffect = req.getStringPropertyValue(rPathEff);\n\t\t\tif (!Algoritms.isEmpty(pathEffect)) {\n\t\t\t\tp.setPathEffect(getDashEffect(pathEffect));\n\t\t\t} else {\n\t\t\t\tp.setPathEffect(null);\n\t\t\t}\n\t\t}\n\t\tp.setColor(req.getIntPropertyValue(rColor));\n\t\t\n\t\tif(ind == 0){\n\t\t\tString resId = req.getStringPropertyValue(req.ALL.R_SHADER);\n\t\t\tif(resId != null){\n\t\t\t\tp.setColor(Color.BLACK);\n\t\t\t\tp.setShader(getShader(resId));\n\t\t\t} else {\n\t\t\t\tp.setShader(null);\n\t\t\t}\n\t\t\t\n\t\t\t// do not check shadow color here\n\t\t\tif(rc.shadowRenderingMode != 1) {\n\t\t\t\tpaint.clearShadowLayer();\n\t\t\t} else {\n\t\t\t\tint shadowColor = req.getIntPropertyValue(req.ALL.R_SHADOW_COLOR);\n\t\t\t\tint shadowLayer = req.getIntPropertyValue(req.ALL.R_SHADOW_RADIUS);\n\t\t\t\tif (shadowColor == 0) {\n\t\t\t\t\tshadowLayer = 0;\n\t\t\t\t}\n\t\t\t\tp.setShadowLayer(shadowLayer, 0, 0, shadowColor);\n\t\t\t}\n\t\t} else {\n\t\t\tp.setShader(null);\n\t\t\tp.clearShadowLayer();\n\t\t}\n\t\treturn true;\n\t\t\n\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void fillProperties(RenderingRuleSearchRequest render, float centerX, float centerY){\n\t\t\tthis.centerX = centerX;\n\t\t\tthis.centerY = centerY + render.getIntPropertyValue(render.ALL.R_TEXT_DY, 0);\n\t\t\ttextColor = render.getIntPropertyValue(render.ALL.R_TEXT_COLOR);\n\t\t\tif(textColor == 0){\n\t\t\t\ttextColor = Color.BLACK;\n\t\t\t}\n\t\t\ttextSize = render.getIntPropertyValue(render.ALL.R_TEXT_SIZE);\n\t\t\ttextShadow = render.getIntPropertyValue(render.ALL.R_TEXT_HALO_RADIUS, 0);\n\t\t\ttextWrap = render.getIntPropertyValue(render.ALL.R_TEXT_WRAP_WIDTH, 0);\n\t\t\tbold = render.getIntPropertyValue(render.ALL.R_TEXT_BOLD, 0) > 0;\n\t\t\tminDistance = render.getIntPropertyValue(render.ALL.R_TEXT_MIN_DISTANCE,0);\n\t\t\tif(render.isSpecified(render.ALL.R_TEXT_SHIELD)) {\n\t\t\t\tshieldRes = RenderingIcons.getIcons().get(render.getStringPropertyValue(render.ALL.R_TEXT_SHIELD));\n\t\t\t}\n\t\t\ttextOrder = render.getIntPropertyValue(render.ALL.R_TEXT_ORDER, 20);\n\t\t}","id":72844,"modified_method":"public void fillProperties(RenderingRuleSearchRequest render, float centerX, float centerY){\n\t\t\tthis.centerX = centerX;\n\t\t\tthis.centerY = centerY + render.getIntPropertyValue(render.ALL.R_TEXT_DY, 0);\n\t\t\ttextColor = render.getIntPropertyValue(render.ALL.R_TEXT_COLOR);\n\t\t\tif(textColor == 0){\n\t\t\t\ttextColor = Color.BLACK;\n\t\t\t}\n\t\t\ttextSize = render.getIntPropertyValue(render.ALL.R_TEXT_SIZE);\n\t\t\ttextShadow = render.getIntPropertyValue(render.ALL.R_TEXT_HALO_RADIUS, 0);\n\t\t\ttextWrap = render.getIntPropertyValue(render.ALL.R_TEXT_WRAP_WIDTH, 0);\n\t\t\tbold = render.getIntPropertyValue(render.ALL.R_TEXT_BOLD, 0) > 0;\n\t\t\tminDistance = render.getIntPropertyValue(render.ALL.R_TEXT_MIN_DISTANCE,0);\n\t\t\tif(render.isSpecified(render.ALL.R_TEXT_SHIELD)) {\n\t\t\t\tshieldRes = render.getStringPropertyValue(render.ALL.R_TEXT_SHIELD);\n\t\t\t}\n\t\t\ttextOrder = render.getIntPropertyValue(render.ALL.R_TEXT_ORDER, 20);\n\t\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void clearCachedResources(){\n\t\tcachedIcons.clear();\n\t\tshaders.clear();\n\t}","id":72845,"modified_method":"public void clearCachedResources(){\n\t\tshaders.clear();\n\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawPoint(BinaryMapDataObject obj, RenderingRuleSearchRequest render, Canvas canvas, RenderingContext rc, TagValuePair pair, boolean renderText) {\n\t\tif(render == null || pair == null){\n\t\t\treturn;\n\t\t}\n\t\trender.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);\n\t\trender.search(RenderingRulesStorage.POINT_RULES);\n\t\t\n\t\tInteger resId = RenderingIcons.getIcons().get(render.getStringPropertyValue(render.ALL.R_ICON));\n\t\tString name = null;\n\t\tif (renderText) {\n\t\t\tname = obj.getName();\n\t\t}\n\t\tif((resId == null || resId == 0) && name == null){\n\t\t\treturn;\n\t\t}\n\t\tint len = obj.getPointsLength();\n\t\trc.visible++;\n\t\tPointF ps = new PointF(0, 0);\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tPointF p = calcPoint(obj, i, rc);\n\t\t\tps.x += p.x;\n\t\t\tps.y += p.y;\n\t\t}\n\t\tif(len > 1){\n\t\t\tps.x /= len;\n\t\t\tps.y /= len;\n\t\t}\n\n\t\tif(resId != null && resId != 0){\n\t\t\tIconDrawInfo ico = new IconDrawInfo();\n\t\t\tico.x = ps.x;\n\t\t\tico.y = ps.y;\n\t\t\tico.resId = resId;\n\t\t\trc.iconsToDraw.add(ico);\n\t\t}\n\t\tif (name != null) {\n\t\t\tdrawPointText(render, rc, pair, ps.x, ps.y, name);\n\t\t}\n\n\t}","id":72846,"modified_method":"private void drawPoint(BinaryMapDataObject obj, RenderingRuleSearchRequest render, Canvas canvas, RenderingContext rc, TagValuePair pair, boolean renderText) {\n\t\tif(render == null || pair == null){\n\t\t\treturn;\n\t\t}\n\t\trender.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);\n\t\trender.search(RenderingRulesStorage.POINT_RULES);\n\t\t\n\t\tString resId = render.getStringPropertyValue(render.ALL.R_ICON);\n\t\tString name = null;\n\t\tif (renderText) {\n\t\t\tname = obj.getName();\n\t\t}\n\t\tif(resId == null && name == null){\n\t\t\treturn;\n\t\t}\n\t\tint len = obj.getPointsLength();\n\t\trc.visible++;\n\t\tPointF ps = new PointF(0, 0);\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tPointF p = calcPoint(obj, i, rc);\n\t\t\tps.x += p.x;\n\t\t\tps.y += p.y;\n\t\t}\n\t\tif(len > 1){\n\t\t\tps.x /= len;\n\t\t\tps.y /= len;\n\t\t}\n\n\t\tif(resId != null){\n\t\t\tIconDrawInfo ico = new IconDrawInfo();\n\t\t\tico.x = ps.x;\n\t\t\tico.y = ps.y;\n\t\t\tico.resId = resId;\n\t\t\trc.iconsToDraw.add(ico);\n\t\t}\n\t\tif (name != null) {\n\t\t\tdrawPointText(render, rc, pair, ps.x, ps.y, name);\n\t\t}\n\n\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void drawTextOverCanvas(RenderingContext rc, Canvas cv, boolean useEnglishNames) {\n\t\tList<RectF> boundsNotPathIntersect = new ArrayList<RectF>();\n\t\tList<RectF> boundsPathIntersect = new ArrayList<RectF>();\n\t\tint size = rc.textToDraw.size();\n\t\tComparator<RectF> c = new Comparator<RectF>(){\n\t\t\t@Override\n\t\t\tpublic int compare(RectF object1, RectF object2) {\n\t\t\t\treturn Float.compare(object1.left, object2.left);\n\t\t\t}\n\n\t\t};\n\t\t\n\t\t// 1. Sort text using text order \n\t\tCollections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(TextDrawInfo object1, TextDrawInfo object2) {\n\t\t\t\treturn object1.textOrder - object2.textOrder;\n\t\t\t}\n\t\t});\n\t\t\n\t\tnextText: for (int i = 0; i < size; i++) {\n\t\t\tTextDrawInfo text  = rc.textToDraw.get(i);\n\t\t\tif(text.text != null){\n\t\t\t\tint d = text.text.indexOf(MapRenderingTypes.DELIM_CHAR);\n\t\t\t\t// not used now functionality \n\t\t\t\t// possibly it will be used specifying english names after that character\n\t\t\t\tif(d > 0){\n\t\t\t\t\ttext.text = text.text.substring(0, d);\n\t\t\t\t}\n\t\t\t\tif(useEnglishNames){\n\t\t\t\t\ttext.text = Junidecode.unidecode(text.text);\n\t\t\t\t}\n\n\n\t\t\t\t// sest text size before finding intersection (it is used there)\n\t\t\t\tfloat textSize = getDensityValue(rc, text.textSize);\n\t\t\t\tpaintText.setTextSize(textSize);\n\t\t\t\tpaintText.setFakeBoldText(text.bold);\n\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t// align center y\n\t\t\t\ttext.centerY += (-paintText.ascent());\n\n\t\t\t\t// calculate if there is intersection\n\t\t\t\tboolean intersects = findTextIntersection(rc, boundsNotPathIntersect, boundsPathIntersect, c, text);\n\t\t\t\tif(intersects){\n\t\t\t\t\tcontinue nextText;\n\t\t\t\t}\n\n\n\t\t\t\tif(text.drawOnPath != null){\n\t\t\t\t\tif(text.textShadow > 0){\n\t\t\t\t\t\tpaintText.setColor(Color.WHITE);\n\t\t\t\t\t\tpaintText.setStyle(Style.STROKE);\n\t\t\t\t\t\tpaintText.setStrokeWidth(2 + text.textShadow);\n\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t\t// reset\n\t\t\t\t\t\tpaintText.setStyle(Style.FILL);\n\t\t\t\t\t\tpaintText.setStrokeWidth(2);\n\t\t\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t\t}\n\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t} else {\n\t\t\t\t\tif (text.shieldRes != 0) {\n\t\t\t\t\t\tif (cachedIcons.get(text.shieldRes) == null) {\n\t\t\t\t\t\t\tcachedIcons.put(text.shieldRes, BitmapFactory.decodeResource(context.getResources(), text.shieldRes));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tBitmap ico = cachedIcons.get(text.shieldRes);\n\t\t\t\t\t\tif (ico != null) {\n\t\t\t\t\t\t\tcv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - 0.5f, text.centerY\n\t\t\t\t\t\t\t\t\t- ico.getHeight() / 2 - getDensityValue(rc, 4.5f) \n\t\t\t\t\t\t\t\t\t, paintIcon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdrawWrappedText(cv, text, textSize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":72847,"modified_method":"public void drawTextOverCanvas(RenderingContext rc, Canvas cv, boolean useEnglishNames) {\n\t\tList<RectF> boundsNotPathIntersect = new ArrayList<RectF>();\n\t\tList<RectF> boundsPathIntersect = new ArrayList<RectF>();\n\t\tint size = rc.textToDraw.size();\n\t\tComparator<RectF> c = new Comparator<RectF>(){\n\t\t\t@Override\n\t\t\tpublic int compare(RectF object1, RectF object2) {\n\t\t\t\treturn Float.compare(object1.left, object2.left);\n\t\t\t}\n\n\t\t};\n\t\t\n\t\t// 1. Sort text using text order \n\t\tCollections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(TextDrawInfo object1, TextDrawInfo object2) {\n\t\t\t\treturn object1.textOrder - object2.textOrder;\n\t\t\t}\n\t\t});\n\t\t\n\t\tnextText: for (int i = 0; i < size; i++) {\n\t\t\tTextDrawInfo text  = rc.textToDraw.get(i);\n\t\t\tif(text.text != null){\n\t\t\t\tint d = text.text.indexOf(MapRenderingTypes.DELIM_CHAR);\n\t\t\t\t// not used now functionality \n\t\t\t\t// possibly it will be used specifying english names after that character\n\t\t\t\tif(d > 0){\n\t\t\t\t\ttext.text = text.text.substring(0, d);\n\t\t\t\t}\n\t\t\t\tif(useEnglishNames){\n\t\t\t\t\ttext.text = Junidecode.unidecode(text.text);\n\t\t\t\t}\n\n\n\t\t\t\t// sest text size before finding intersection (it is used there)\n\t\t\t\tfloat textSize = getDensityValue(rc, text.textSize);\n\t\t\t\tpaintText.setTextSize(textSize);\n\t\t\t\tpaintText.setFakeBoldText(text.bold);\n\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t// align center y\n\t\t\t\ttext.centerY += (-paintText.ascent());\n\n\t\t\t\t// calculate if there is intersection\n\t\t\t\tboolean intersects = findTextIntersection(rc, boundsNotPathIntersect, boundsPathIntersect, c, text);\n\t\t\t\tif(intersects){\n\t\t\t\t\tcontinue nextText;\n\t\t\t\t}\n\n\n\t\t\t\tif(text.drawOnPath != null){\n\t\t\t\t\tif(text.textShadow > 0){\n\t\t\t\t\t\tpaintText.setColor(Color.WHITE);\n\t\t\t\t\t\tpaintText.setStyle(Style.STROKE);\n\t\t\t\t\t\tpaintText.setStrokeWidth(2 + text.textShadow);\n\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t\t// reset\n\t\t\t\t\t\tpaintText.setStyle(Style.FILL);\n\t\t\t\t\t\tpaintText.setStrokeWidth(2);\n\t\t\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t\t}\n\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t} else {\n\t\t\t\t\tif (text.shieldRes != null) {\n\t\t\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, text.shieldRes);\n\t\t\t\t\t\tif (ico != null) {\n\t\t\t\t\t\t\tcv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - 0.5f, text.centerY\n\t\t\t\t\t\t\t\t\t- ico.getHeight() / 2 - getDensityValue(rc, 4.5f) \n\t\t\t\t\t\t\t\t\t, paintIcon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdrawWrappedText(cv, text, textSize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public Shader getShader(int resId){\n\t\tif(shaders.get(resId) == null){\n\t\t\tShader sh = new BitmapShader(\n\t\t\t\t\tBitmapFactory.decodeResource(context.getResources(), resId), TileMode.REPEAT, TileMode.REPEAT);\n\t\t\tshaders.put(resId, sh);\n\t\t}\t\n\t\treturn shaders.get(resId);\n\t}","id":72848,"modified_method":"public Shader getShader(String resId){\n\t\t\n\t\tif(shaders.get(resId) == null){\n\t\t\tBitmap bmp = RenderingIcons.getIcon(context, resId);\n\t\t\tif(bmp != null){\n\t\t\t\tShader sh = new BitmapShader(bmp, TileMode.REPEAT, TileMode.REPEAT);\n\t\t\t\tshaders.put(resId, sh);\n\t\t\t} else {\n\t\t\t\tshaders.put(resId, null);\n\t\t\t}\n\t\t}\t\n\t\treturn shaders.get(resId);\n\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onDraw(Canvas canvas, RectF latLonBounds, RectF tilesRect, boolean nightMode) {\n\t\t\n\t\tif (view.getZoom() >= startZoom) {\n\t\t\tMap<String, Integer> icons = RenderingIcons.getIcons();\n\t\t\tobjects.clear();\n\t\t\tresourceManager.searchAmenitiesAsync(latLonBounds.top, latLonBounds.left, latLonBounds.bottom, latLonBounds.right, view.getZoom(), filter, objects);\n\t\t\tint r = getRadiusPoi(view.getZoom());\n\t\t\tfor (Amenity o : objects) {\n\t\t\t\tint x = view.getRotatedMapXForPoint(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\tint y = view.getRotatedMapYForPoint(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\tcanvas.drawCircle(x, y, r, pointAltUI);\n\t\t\t\tcanvas.drawCircle(x, y, r, point);\n\t\t\t\tString id = null;\n\t\t\t\tif(icons.containsKey(o.getSubType())){\n\t\t\t\t\tid = o.getSubType();\n\t\t\t\t} else if (icons.containsKey(o.getType().getDefaultTag() + \"_\" + o.getSubType())) {\n\t\t\t\t\tid = o.getType().getDefaultTag() + \"_\" + o.getSubType();\n\t\t\t\t}\n\t\t\t\tif(id != null){\n\t\t\t\t\tint resId = icons.get(id);\n\t\t\t\t\tBitmap bmp = getCachedImg(resId);\n\t\t\t\t\tif(bmp != null){\n\t\t\t\t\t\tcanvas.drawBitmap(bmp, x - bmp.getWidth() / 2, y - bmp.getHeight() / 2, paintIcon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (view.getSettings().SHOW_POI_LABEL.get()) {\n\t\t\t\tTIntHashSet set = new TIntHashSet();\n\t\t\t\tfor (Amenity o : objects) {\n\t\t\t\t\tint x = view.getRotatedMapXForPoint(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\t\tint y = view.getRotatedMapYForPoint(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\t\tint tx = view.getMapXForPoint(o.getLocation().getLongitude());\n\t\t\t\t\tint ty = view.getMapYForPoint(o.getLocation().getLatitude());\n\t\t\t\t\tString name = o.getName(view.getSettings().USE_ENGLISH_NAMES.get());\n\t\t\t\t\tif (name != null && name.length() > 0) {\n\t\t\t\t\t\tint lines = 0;\n\t\t\t\t\t\twhile (lines < TEXT_LINES) {\n\t\t\t\t\t\t\tif (set.contains(division(tx, ty, 0, lines)) ||\n\t\t\t\t\t\t\t\t\tset.contains(division(tx, ty, -1, lines)) || set.contains(division(tx, ty, +1, lines))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlines++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lines == 0) {\n\t\t\t\t\t\t\t// drawWrappedText(canvas, \"...\", paintTextIcon.getTextSize(), x, y + r + 2 + paintTextIcon.getTextSize() / 2, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdrawWrappedText(canvas, name, paintTextIcon.getTextSize(), x, y + r + 2 + paintTextIcon.getTextSize() / 2,\n\t\t\t\t\t\t\t\t\tlines);\n\t\t\t\t\t\t\twhile (lines > 0) {\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, 1, lines - 1));\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, -1, lines - 1));\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, 0, lines - 1));\n\t\t\t\t\t\t\t\tlines--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","id":72849,"modified_method":"@Override\n\tpublic void onDraw(Canvas canvas, RectF latLonBounds, RectF tilesRect, boolean nightMode) {\n\t\t\n\t\tif (view.getZoom() >= startZoom) {\n\t\t\tobjects.clear();\n\t\t\tresourceManager.searchAmenitiesAsync(latLonBounds.top, latLonBounds.left, latLonBounds.bottom, latLonBounds.right, view.getZoom(), filter, objects);\n\t\t\tint r = getRadiusPoi(view.getZoom());\n\t\t\tfor (Amenity o : objects) {\n\t\t\t\tint x = view.getRotatedMapXForPoint(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\tint y = view.getRotatedMapYForPoint(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\tcanvas.drawCircle(x, y, r, pointAltUI);\n\t\t\t\tcanvas.drawCircle(x, y, r, point);\n\t\t\t\tString id = null;\n\t\t\t\tif(RenderingIcons.containsIcon(o.getSubType())){\n\t\t\t\t\tid = o.getSubType();\n\t\t\t\t} else if (RenderingIcons.containsIcon(o.getType().getDefaultTag() + \"_\" + o.getSubType())) {\n\t\t\t\t\tid = o.getType().getDefaultTag() + \"_\" + o.getSubType();\n\t\t\t\t}\n\t\t\t\tif(id != null){\n\t\t\t\t\tBitmap bmp = RenderingIcons.getIcon(view.getContext(), id);\n\t\t\t\t\tif(bmp != null){\n\t\t\t\t\t\tcanvas.drawBitmap(bmp, x - bmp.getWidth() / 2, y - bmp.getHeight() / 2, paintIcon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (view.getSettings().SHOW_POI_LABEL.get()) {\n\t\t\t\tTIntHashSet set = new TIntHashSet();\n\t\t\t\tfor (Amenity o : objects) {\n\t\t\t\t\tint x = view.getRotatedMapXForPoint(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\t\tint y = view.getRotatedMapYForPoint(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\t\tint tx = view.getMapXForPoint(o.getLocation().getLongitude());\n\t\t\t\t\tint ty = view.getMapYForPoint(o.getLocation().getLatitude());\n\t\t\t\t\tString name = o.getName(view.getSettings().USE_ENGLISH_NAMES.get());\n\t\t\t\t\tif (name != null && name.length() > 0) {\n\t\t\t\t\t\tint lines = 0;\n\t\t\t\t\t\twhile (lines < TEXT_LINES) {\n\t\t\t\t\t\t\tif (set.contains(division(tx, ty, 0, lines)) ||\n\t\t\t\t\t\t\t\t\tset.contains(division(tx, ty, -1, lines)) || set.contains(division(tx, ty, +1, lines))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlines++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lines == 0) {\n\t\t\t\t\t\t\t// drawWrappedText(canvas, \"...\", paintTextIcon.getTextSize(), x, y + r + 2 + paintTextIcon.getTextSize() / 2, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdrawWrappedText(canvas, name, paintTextIcon.getTextSize(), x, y + r + 2 + paintTextIcon.getTextSize() / 2,\n\t\t\t\t\t\t\t\t\tlines);\n\t\t\t\t\t\t\twhile (lines > 0) {\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, 1, lines - 1));\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, -1, lines - 1));\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, 0, lines - 1));\n\t\t\t\t\t\t\t\tlines--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void destroyLayer() {\n\t\tcachedIcons.clear();\n\t}","id":72850,"modified_method":"@Override\n\tpublic void destroyLayer() {\n\t}","commit_id":"dfe0380714c0e71268f4f6caa759b35f8b1b3186","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@NotNull\n    public SearchScope getEffectiveSearchScope () {\n      SearchScope accessScope = PsiSearchHelper.SERVICE.getInstance(myMethod.getProject()).getUseScope(myMethod);\n      return myScope.intersectWith(accessScope);\n    }","id":72851,"modified_method":"@NotNull\n    public SearchScope getEffectiveSearchScope () {\n      SearchScope scope = myEffectiveScope;\n      if (scope == null) {\n        myEffectiveScope = scope = myScope.intersectWith(PsiSearchHelper.SERVICE.getInstance(myMethod.getProject()).getUseScope(myMethod));\n      }\n      return scope;\n    }","commit_id":"fa2142d2ea4edec1c886d1bf1df4646e69c9848c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public SearchScope getEffectiveSearchScope () {\n      if (myIgnoreAccessScope) {\n        return myScope;\n      }\n      SearchScope accessScope = PsiSearchHelper.SERVICE.getInstance(myElementToSearch.getProject()).getUseScope(myElementToSearch);\n      return myScope.intersectWith(accessScope);\n    }","id":72852,"modified_method":"@NotNull\n    public SearchScope getEffectiveSearchScope () {\n      if (myIgnoreAccessScope) {\n        return myScope;\n      }\n\n      SearchScope scope = myEffectiveScope;\n      if (scope == null) {\n        SearchScope useScope = PsiSearchHelper.SERVICE.getInstance(myElementToSearch.getProject()).getUseScope(myElementToSearch);\n        myEffectiveScope = scope = myScope.intersectWith(useScope);\n      }\n      return scope;\n    }","commit_id":"fa2142d2ea4edec1c886d1bf1df4646e69c9848c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Check method call at given location to see if it unconditionally\n\t * dereferences a parameter.  Mark any such arguments as derefs.\n\t * \n\t * @param location the Location of the method call\n\t * @param vnaFrame ValueNumberFrame at the Location\n\t * @param fact     the dataflow value to modify\n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void checkUnconditionalDerefDatabase(\n\t\t\tLocation location,\n\t\t\tValueNumberFrame vnaFrame,\n\t\t\tUnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\t\n\t\tParameterNullnessPropertyDatabase database =\n\t\t\tAnalysisContext.currentAnalysisContext().getUnconditionalDerefParamDatabase();\n\t\tif (database == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tInvokeInstruction inv = (InvokeInstruction) location.getHandle().getInstruction();\n\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\tif (!typeFrame.isValid()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSignatureParser sigParser = new SignatureParser(inv.getSignature(methodGen.getConstantPool()));\n\t\tint numParams = sigParser.getNumParameters();\n\t\t\n\t\ttry {\n\t\t\tSet<JavaClassAndMethod> targetSet = Hierarchy.resolveMethodCallTargets(\n\t\t\t\t\tinv,\n\t\t\t\t\ttypeFrame,\n\t\t\t\t\tmethodGen.getConstantPool());\n\t\t\t\n\t\t\t// Compute the intersection of all properties\n\t\t\tParameterNullnessProperty derefParamSet = new ParameterNullnessProperty();\n\t\t\tfor (JavaClassAndMethod target : targetSet) {\n\t\t\t\tParameterNullnessProperty targetDerefParamSet = database.getProperty(target.toXMethod());\n\t\t\t\tif (targetDerefParamSet == null) {\n\t\t\t\t\t// Hmm...no information for this target.\n\t\t\t\t\t// Just ignore it.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tderefParamSet.intersectWith(targetDerefParamSet);\n\t\t\t}\n\t\t\t\n\t\t\tif (derefParamSet.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t\n\t\t\tIsNullValueFrame invFrame = null;\n\t\t\tif (IGNORE_DEREF_OF_NONNULL && invDataflow != null) {\n\t\t\t\tinvFrame = invDataflow.getFactAfterLocation(location);\n\t\t\t\tif (!invFrame.isValid()) {\n\t\t\t\t\tinvFrame = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tint numParams = target.\n\t\t\tfor (int i = 0; i < numParams; i++) {\n\t\t\t\tif (!derefParamSet.isNonNull(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint argSlot = invFrame.getArgumentSlot(i, numParams);\n\n\t\t\t\tif (invFrame != null) {\n\t\t\t\t\tIsNullValue val = invFrame.getValue(argSlot);\n\t\t\t\t\tif (val.isDefinitelyNotNull()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfact.addDeref(vnaFrame.getValue(argSlot), location);\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t}\n\t}","id":72853,"modified_method":"/**\n\t * Check method call at given location to see if it unconditionally\n\t * dereferences a parameter.  Mark any such arguments as derefs.\n\t * \n\t * @param location the Location of the method call\n\t * @param vnaFrame ValueNumberFrame at the Location\n\t * @param fact     the dataflow value to modify\n\t * @throws DataflowAnalysisException \n\t */\n\tprivate void checkUnconditionalDerefDatabase(\n\t\t\tLocation location,\n\t\t\tValueNumberFrame vnaFrame,\n\t\t\tUnconditionalValueDerefSet fact) throws DataflowAnalysisException {\n\t\t\n\t\tParameterNullnessPropertyDatabase database =\n\t\t\tAnalysisContext.currentAnalysisContext().getUnconditionalDerefParamDatabase();\n\t\tif (database == null) {\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"no database!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tInvokeInstruction inv = (InvokeInstruction) location.getHandle().getInstruction();\n\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\tif (!typeFrame.isValid()) {\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"invalid type frame!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSignatureParser sigParser = new SignatureParser(inv.getSignature(methodGen.getConstantPool()));\n\t\tint numParams = sigParser.getNumParameters();\n\t\t\n\t\ttry {\n\t\t\tSet<JavaClassAndMethod> targetSet = Hierarchy.resolveMethodCallTargets(\n\t\t\t\t\tinv,\n\t\t\t\t\ttypeFrame,\n\t\t\t\t\tmethodGen.getConstantPool());\n\t\t\t\n\t\t\tif (targetSet.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Compute the intersection of all properties\n\t\t\tParameterNullnessProperty derefParamSet = null;\n\t\t\tfor (JavaClassAndMethod target : targetSet) {\n\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\tSystem.out.print(\"Checking \" + target + \": \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tParameterNullnessProperty targetDerefParamSet = database.getProperty(target.toXMethod());\n\t\t\t\tif (targetDerefParamSet == null) {\n\t\t\t\t\t// Hmm...no information for this target.\n\t\t\t\t\t// Just ignore it.\n\t\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\t\tSystem.out.println(\" ==> unknown\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\tSystem.out.println(\"==> \" + targetDerefParamSet);\n\t\t\t\t}\n\t\t\t\tif (derefParamSet == null) {\n\t\t\t\t\tderefParamSet = new ParameterNullnessProperty();\n\t\t\t\t\tderefParamSet.copyFrom(targetDerefParamSet);\n\t\t\t\t} else {\n\t\t\t\t\tderefParamSet.intersectWith(targetDerefParamSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (derefParamSet == null || derefParamSet.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\tSystem.out.println(\"** Summary of call: \" + derefParamSet);\n\t\t\t}\n\t\t\t\n\t\t\tIsNullValueFrame invFrame = null;\n\t\t\tif (IGNORE_DEREF_OF_NONNULL && invDataflow != null) {\n\t\t\t\tinvFrame = invDataflow.getFactAfterLocation(location);\n\t\t\t\tif (!invFrame.isValid()) {\n\t\t\t\t\tinvFrame = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < numParams; i++) {\n\t\t\t\tif (!derefParamSet.isNonNull(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint argSlot = invFrame.getArgumentSlot(i, numParams);\n\n\t\t\t\tif (invFrame != null) {\n\t\t\t\t\tIsNullValue val = invFrame.getValue(argSlot);\n\t\t\t\t\tif (val.isDefinitelyNotNull()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfact.addDeref(vnaFrame.getValue(argSlot), location);\n\t\t\t\tif (DEBUG_CHECK_CALLS) {\n\t\t\t\t\tSystem.out.println(\"Adding deref of \" + vnaFrame.getValue(argSlot) + \" at location \" + location);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t}\n\t}","commit_id":"b7b3560591c0362a112b0f8c5019f9a070b0fcfd","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@NotNull\n  public static SearchScope getMemberUseScope(@NotNull PsiMember member) {\n    final GlobalSearchScope maximalUseScope = ResolveScopeManager.getElementUseScope(member);\n    PsiFile file = member.getContainingFile();\n    if (isInServerPage(file)) return maximalUseScope;\n\n    PsiClass aClass = member.getContainingClass();\n    if (aClass instanceof PsiAnonymousClass) {\n      //member from anonymous class can be called from outside the class\n      PsiElement methodCallExpr = PsiUtil.isLanguageLevel8OrHigher(aClass) ? PsiTreeUtil.getTopmostParentOfType(aClass, PsiStatement.class) \n                                                                           : PsiTreeUtil.getParentOfType(aClass, PsiMethodCallExpression.class);\n      return new LocalSearchScope(methodCallExpr != null ? methodCallExpr : aClass);\n    }\n\n    if (member.hasModifierProperty(PsiModifier.PUBLIC)) {\n      return maximalUseScope; // class use scope doesn't matter, since another very visible class can inherit from aClass\n    }\n    else if (member.hasModifierProperty(PsiModifier.PROTECTED)) {\n      return maximalUseScope; // class use scope doesn't matter, since another very visible class can inherit from aClass\n    }\n    else if (member.hasModifierProperty(PsiModifier.PRIVATE)) {\n      PsiClass topClass = PsiUtil.getTopLevelClass(member);\n      return topClass != null ? new LocalSearchScope(topClass) : file != null ? new LocalSearchScope(file) : maximalUseScope;\n    }\n    else {\n      if (file instanceof PsiJavaFile) {\n        PsiPackage aPackage = JavaPsiFacade.getInstance(member.getProject()).findPackage(((PsiJavaFile)file).getPackageName());\n        if (aPackage != null) {\n          SearchScope scope = PackageScope.packageScope(aPackage, false);\n          scope = scope.intersectWith(maximalUseScope);\n          return scope;\n        }\n      }\n\n      return maximalUseScope;\n    }\n  }","id":72854,"modified_method":"@NotNull\n  public static SearchScope getMemberUseScope(@NotNull PsiMember member) {\n    PsiFile file = member.getContainingFile();\n    PsiElement topElement = file == null ? member : file;\n    Project project = topElement.getProject();\n    final GlobalSearchScope maximalUseScope = ResolveScopeManager.getInstance(project).getUseScope(topElement);\n    if (isInServerPage(file)) return maximalUseScope;\n\n    PsiClass aClass = member.getContainingClass();\n    if (aClass instanceof PsiAnonymousClass) {\n      //member from anonymous class can be called from outside the class\n      PsiElement methodCallExpr = PsiUtil.isLanguageLevel8OrHigher(aClass) ? PsiTreeUtil.getTopmostParentOfType(aClass, PsiStatement.class) \n                                                                           : PsiTreeUtil.getParentOfType(aClass, PsiMethodCallExpression.class);\n      return new LocalSearchScope(methodCallExpr != null ? methodCallExpr : aClass);\n    }\n\n    PsiModifierList modifierList = member.getModifierList();\n    int accessLevel = modifierList == null ? PsiUtil.ACCESS_LEVEL_PUBLIC : PsiUtil.getAccessLevel(modifierList);\n    if (accessLevel == PsiUtil.ACCESS_LEVEL_PUBLIC || accessLevel == PsiUtil.ACCESS_LEVEL_PROTECTED) {\n      return maximalUseScope; // class use scope doesn't matter, since another very visible class can inherit from aClass\n    }\n    if (accessLevel == PsiUtil.ACCESS_LEVEL_PRIVATE) {\n      PsiClass topClass = PsiUtil.getTopLevelClass(member);\n      return topClass != null ? new LocalSearchScope(topClass) : file == null ? maximalUseScope : new LocalSearchScope(file);\n    }\n    if (file instanceof PsiJavaFile) {\n      PsiPackage aPackage = JavaPsiFacade.getInstance(project).findPackage(((PsiJavaFile)file).getPackageName());\n      if (aPackage != null) {\n        SearchScope scope = PackageScope.packageScope(aPackage, false);\n        return scope.intersectWith(maximalUseScope);\n      }\n    }\n    return maximalUseScope;\n  }","commit_id":"118dcacda8f5c392dd906998b91843554f0ab0c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Result acceptChar(char c, int pefixLength, Lookup lookup) {\n    if (!lookup.getPsiFile().getViewProvider().getLanguages().contains(GroovyFileType.GROOVY_LANGUAGE)) return null;\n\n    if (Character.isJavaIdentifierPart(c) || c == '\\'') {\n      return Result.ADD_TO_PREFIX;\n    }\n    if (c == '\\n' || c == '\\t') {\n      return Result.SELECT_ITEM_AND_FINISH_LOOKUP;\n    }\n\n    return null;\n  }","id":72855,"modified_method":"@Nullable\n  public Result acceptChar(char c, int pefixLength, Lookup lookup) {\n    final PsiFile psiFile = lookup.getPsiFile();\n    if (psiFile != null && !psiFile.getViewProvider().getLanguages().contains(GroovyFileType.GROOVY_LANGUAGE)) return null;\n\n    if (Character.isJavaIdentifierPart(c) || c == '\\'') {\n      return Result.ADD_TO_PREFIX;\n    }\n    if (c == '\\n' || c == '\\t') {\n      return Result.SELECT_ITEM_AND_FINISH_LOOKUP;\n    }\n\n    return null;\n  }","commit_id":"c935756fd660280d0cdab51f6fd41b3412462e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void createPredefinedScopeDescriptors(DefaultComboBoxModel model) {\n    model.addElement(new ScopeDescriptor(GlobalSearchScope.projectScope(myProject)));\n    if (mySuggestSearchInLibs) {\n      model.addElement(new ScopeDescriptor(GlobalSearchScope.allScope(myProject)));\n    }\n    model.addElement(new ScopeDescriptor(GlobalSearchScope.projectProductionScope(myProject, true)));\n    model.addElement(new ScopeDescriptor(GlobalSearchScope.projectTestScope(myProject, true)));\n\n    FileEditorManager fileEditorManager = FileEditorManager.getInstance(getProject());\n    if (fileEditorManager.getSelectedTextEditor() != null) {\n      model.addElement(new ScopeDescriptor(new LocalSearchScope(PsiDocumentManager.getInstance(getProject()).getPsiFile(\n        fileEditorManager.getSelectedTextEditor().getDocument()), \"Current File\")));\n\n      if (fileEditorManager.getSelectedTextEditor().getSelectionModel().hasSelection()) {\n        PsiElement[] elements = CodeInsightUtil.findStatementsInRange(\n          PsiDocumentManager.getInstance(getProject()).getPsiFile(fileEditorManager.getSelectedTextEditor().getDocument()),\n          fileEditorManager.getSelectedTextEditor().getSelectionModel().getSelectionStart(),\n          fileEditorManager.getSelectedTextEditor().getSelectionModel().getSelectionEnd()\n        );\n\n        if (elements != null) {\n          model.addElement(new ScopeDescriptor(new LocalSearchScope(elements, \"Selection\")));\n        }\n      }\n    }\n\n    UsageView selectedUsageView = UsageViewManager.getInstance(getProject()).getSelectedUsageView();\n\n    if (selectedUsageView != null && !selectedUsageView.isSearchInProgress()) {\n      final Set<Usage> usages = selectedUsageView.getUsages();\n      if (usages != null) {\n        final java.util.List<PsiElement> results = new ArrayList<PsiElement>(usages.size());\n\n        if (myPrevSearchFiles) {\n          final Set<VirtualFile> files = new HashSet<VirtualFile>();\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              PsiElement psiElement = ((PsiElementUsage)usage).getElement();\n              if (psiElement != null && psiElement.isValid()) {\n                PsiFile psiFile = psiElement.getContainingFile();\n                if (psiFile != null) {\n                  VirtualFile file = psiFile.getVirtualFile();\n                  if (file != null) files.add(file);\n                }\n              }\n            }\n          }\n          if (files.size() > 0) {\n            model.addElement(new ScopeDescriptor(new GlobalSearchScope() {\n              public String getDisplayName() {\n                return \"Files in Previous Search Result\";\n              }\n\n              public boolean contains(VirtualFile file) {\n                return files.contains(file);\n              }\n\n              public int compare(VirtualFile file1, VirtualFile file2) {\n                return 0;\n              }\n\n              public boolean isSearchInModuleContent(Module aModule) {\n                return true;\n              }\n\n              public boolean isSearchInLibraries() {\n                return true;\n              }\n            }));\n          }\n        }\n        else {\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              final PsiElement element = ((PsiElementUsage)usage).getElement();\n              if (element != null && element.isValid()) {\n                results.add(element);\n              }\n            }\n          }\n\n          if (results.size() > 0) {\n            model.addElement(new ScopeDescriptor(new LocalSearchScope(results.toArray(new PsiElement[results.size()]),\n                                                                      \"Previous Search Results\")));\n          }\n        }\n      }\n    }\n\n    model.addElement(new ClassHierarchyScopeDescriptor());\n  }","id":72856,"modified_method":"protected void createPredefinedScopeDescriptors(DefaultComboBoxModel model) {\n    model.addElement(new ScopeDescriptor(GlobalSearchScope.projectScope(myProject)));\n    if (mySuggestSearchInLibs) {\n      model.addElement(new ScopeDescriptor(GlobalSearchScope.allScope(myProject)));\n    }\n    model.addElement(new ScopeDescriptor(GlobalSearchScope.projectProductionScope(myProject, true)));\n    model.addElement(new ScopeDescriptor(GlobalSearchScope.projectTestScope(myProject, true)));\n\n    FileEditorManager fileEditorManager = FileEditorManager.getInstance(getProject());\n    if (fileEditorManager.getSelectedTextEditor() != null) {\n      final PsiFile psiFile = PsiDocumentManager.getInstance(getProject()).getPsiFile(fileEditorManager.getSelectedTextEditor().getDocument());\n      if (psiFile != null) {\n        model.addElement(new ScopeDescriptor(new LocalSearchScope(psiFile, \"Current File\")));\n\n        if (fileEditorManager.getSelectedTextEditor().getSelectionModel().hasSelection()) {\n          PsiElement[] elements = CodeInsightUtil.findStatementsInRange(\n            psiFile,\n            fileEditorManager.getSelectedTextEditor().getSelectionModel().getSelectionStart(),\n            fileEditorManager.getSelectedTextEditor().getSelectionModel().getSelectionEnd()\n          );\n\n          if (elements != null) {\n            model.addElement(new ScopeDescriptor(new LocalSearchScope(elements, \"Selection\")));\n          }\n        }\n      }\n    }\n\n    UsageView selectedUsageView = UsageViewManager.getInstance(getProject()).getSelectedUsageView();\n\n    if (selectedUsageView != null && !selectedUsageView.isSearchInProgress()) {\n      final Set<Usage> usages = selectedUsageView.getUsages();\n      if (usages != null) {\n        final java.util.List<PsiElement> results = new ArrayList<PsiElement>(usages.size());\n\n        if (myPrevSearchFiles) {\n          final Set<VirtualFile> files = new HashSet<VirtualFile>();\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              PsiElement psiElement = ((PsiElementUsage)usage).getElement();\n              if (psiElement != null && psiElement.isValid()) {\n                PsiFile psiFile = psiElement.getContainingFile();\n                if (psiFile != null) {\n                  VirtualFile file = psiFile.getVirtualFile();\n                  if (file != null) files.add(file);\n                }\n              }\n            }\n          }\n          if (files.size() > 0) {\n            model.addElement(new ScopeDescriptor(new GlobalSearchScope() {\n              public String getDisplayName() {\n                return \"Files in Previous Search Result\";\n              }\n\n              public boolean contains(VirtualFile file) {\n                return files.contains(file);\n              }\n\n              public int compare(VirtualFile file1, VirtualFile file2) {\n                return 0;\n              }\n\n              public boolean isSearchInModuleContent(Module aModule) {\n                return true;\n              }\n\n              public boolean isSearchInLibraries() {\n                return true;\n              }\n            }));\n          }\n        }\n        else {\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              final PsiElement element = ((PsiElementUsage)usage).getElement();\n              if (element != null && element.isValid()) {\n                results.add(element);\n              }\n            }\n          }\n\n          if (results.size() > 0) {\n            model.addElement(new ScopeDescriptor(new LocalSearchScope(results.toArray(new PsiElement[results.size()]),\n                                                                      \"Previous Search Results\")));\n          }\n        }\n      }\n    }\n\n    model.addElement(new ClassHierarchyScopeDescriptor());\n  }","commit_id":"716b475e7056ebc494143fffd806e8989d114040","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public List<SearchScope> getPredefinedScopes(@NotNull final Project project,\n                                               @Nullable final DataContext dataContext,\n                                               boolean suggestSearchInLibs,\n                                               boolean prevSearchFiles,\n                                               boolean currentSelection,\n                                               boolean usageView) {\n    Collection<SearchScope> result = ContainerUtil.newLinkedHashSet();\n    result.add(GlobalSearchScope.projectScope(project));\n    if (suggestSearchInLibs) {\n      result.add(GlobalSearchScope.allScope(project));\n    }\n\n    if (ModuleUtil.isSupportedRootType(project, JavaSourceRootType.TEST_SOURCE)) {\n      result.add(GlobalSearchScopesCore.projectProductionScope(project));\n      result.add(GlobalSearchScopesCore.projectTestScope(project));\n    }\n\n    result.add(GlobalSearchScopes.openFilesScope(project));\n\n    if (dataContext != null) {\n      PsiElement dataContextElement = CommonDataKeys.PSI_FILE.getData(dataContext);\n      if (dataContextElement == null) {\n        dataContextElement = CommonDataKeys.PSI_ELEMENT.getData(dataContext);\n      }\n\n      if (dataContextElement == null) {\n        final Editor selectedTextEditor = FileEditorManager.getInstance(project).getSelectedTextEditor();\n        if (selectedTextEditor != null) {\n          dataContextElement = PsiDocumentManager.getInstance(project).getPsiFile(selectedTextEditor.getDocument());\n        }\n      }\n\n      if (dataContextElement != null) {\n        if (!PlatformUtils.isCidr()) { // TODO: have an API to disable module scopes.\n          Module module = ModuleUtilCore.findModuleForPsiElement(dataContextElement);\n          if (module == null) {\n            module = LangDataKeys.MODULE.getData(dataContext);\n          }\n          if (module != null && !(ModuleType.get(module) instanceof InternalModuleType)) {\n            result.add(module.getModuleScope());\n          }\n        }\n        if (dataContextElement.getContainingFile() != null) {\n          result.add(new LocalSearchScope(dataContextElement, IdeBundle.message(\"scope.current.file\")));\n        }\n      }\n    }\n\n    if (currentSelection) {\n      FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);\n      final Editor selectedTextEditor = fileEditorManager.getSelectedTextEditor();\n      if (selectedTextEditor != null) {\n        final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(selectedTextEditor.getDocument());\n        if (psiFile != null) {\n          SelectionModel selectionModel = selectedTextEditor.getSelectionModel();\n          if (selectionModel.hasSelection()) {\n            int start = selectionModel.getSelectionStart();\n            final PsiElement startElement = psiFile.findElementAt(start);\n            if (startElement != null) {\n              int end = selectionModel.getSelectionEnd();\n              final PsiElement endElement = psiFile.findElementAt(end);\n              if (endElement != null) {\n                final PsiElement parent = PsiTreeUtil.findCommonParent(startElement, endElement);\n                if (parent != null) {\n                  final List<PsiElement> elements = new ArrayList<PsiElement>();\n                  final PsiElement[] children = parent.getChildren();\n                  TextRange selection = new TextRange(start, end);\n                  for (PsiElement child : children) {\n                    if (!(child instanceof PsiWhiteSpace) &&\n                        child.getContainingFile() != null &&\n                        selection.contains(child.getTextOffset())) {\n                      elements.add(child);\n                    }\n                  }\n                  if (!elements.isEmpty()) {\n                    SearchScope local = new LocalSearchScope(PsiUtilCore.toPsiElementArray(elements), IdeBundle.message(\"scope.selection\"));\n                    result.add(local);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (usageView) {\n      addHierarchyScope(project, result);\n      UsageView selectedUsageView = UsageViewManager.getInstance(project).getSelectedUsageView();\n      if (selectedUsageView != null && !selectedUsageView.isSearchInProgress()) {\n        final Set<Usage> usages = ContainerUtil.newTroveSet(selectedUsageView.getUsages());\n        usages.removeAll(selectedUsageView.getExcludedUsages());\n        final List<PsiElement> results = new ArrayList<PsiElement>(usages.size());\n\n        if (prevSearchFiles) {\n          final Set<VirtualFile> files = collectFiles(usages, true);\n          if (!files.isEmpty()) {\n            GlobalSearchScope prev = new GlobalSearchScope(project) {\n              private Set<VirtualFile> myFiles = null;\n\n              @NotNull\n              @Override\n              public String getDisplayName() {\n                return IdeBundle.message(\"scope.files.in.previous.search.result\");\n              }\n\n              @Override\n              public synchronized boolean contains(@NotNull VirtualFile file) {\n                if (myFiles == null) {\n                  myFiles = collectFiles(usages, false);\n                }\n                return myFiles.contains(file);\n              }\n\n              @Override\n              public int compare(@NotNull VirtualFile file1, @NotNull VirtualFile file2) {\n                return 0;\n              }\n\n              @Override\n              public boolean isSearchInModuleContent(@NotNull Module aModule) {\n                return true;\n              }\n\n              @Override\n              public boolean isSearchInLibraries() {\n                return true;\n              }\n            };\n            result.add(prev);\n          }\n        }\n        else {\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              final PsiElement element = ((PsiElementUsage)usage).getElement();\n              if (element != null && element.isValid() && element.getContainingFile() != null) {\n                results.add(element);\n              }\n            }\n          }\n\n          if (!results.isEmpty()) {\n            result.add(new LocalSearchScope(PsiUtilCore.toPsiElementArray(results), IdeBundle.message(\"scope.previous.search.results\")));\n          }\n        }\n      }\n    }\n\n    final FavoritesManager favoritesManager = FavoritesManager.getInstance(project);\n    if (favoritesManager != null) {\n      for (final String favorite : favoritesManager.getAvailableFavoritesListNames()) {\n        final Collection<TreeItem<Pair<AbstractUrl, String>>> rootUrls = favoritesManager.getFavoritesListRootUrls(favorite);\n        if (rootUrls.isEmpty()) continue;  // ignore unused root\n        result.add(new GlobalSearchScope(project) {\n          @NotNull\n          @Override\n          public String getDisplayName() {\n            return \"Favorite \\'\" + favorite + \"\\'\";\n          }\n\n          @Override\n          public boolean contains(@NotNull final VirtualFile file) {\n            return ApplicationManager.getApplication().runReadAction((Computable<Boolean>)() -> favoritesManager.contains(favorite, file));\n          }\n\n          @Override\n          public int compare(@NotNull final VirtualFile file1, @NotNull final VirtualFile file2) {\n            return 0;\n          }\n\n          @Override\n          public boolean isSearchInModuleContent(@NotNull final Module aModule) {\n            return true;\n          }\n\n          @Override\n          public boolean isSearchInLibraries() {\n            return true;\n          }\n        });\n      }\n    }\n\n    ContainerUtil.addIfNotNull(result, getSelectedFilesScope(project, dataContext));\n\n    return ContainerUtil.newArrayList(result);\n  }","id":72857,"modified_method":"@NotNull\n  @Override\n  public List<SearchScope> getPredefinedScopes(@NotNull final Project project,\n                                               @Nullable final DataContext dataContext,\n                                               boolean suggestSearchInLibs,\n                                               boolean prevSearchFiles,\n                                               boolean currentSelection,\n                                               boolean usageView) {\n    Collection<SearchScope> result = ContainerUtil.newLinkedHashSet();\n    result.add(GlobalSearchScope.projectScope(project));\n    if (suggestSearchInLibs) {\n      result.add(GlobalSearchScope.allScope(project));\n    }\n\n    if (ModuleUtil.isSupportedRootType(project, JavaSourceRootType.TEST_SOURCE)) {\n      result.add(GlobalSearchScopesCore.projectProductionScope(project));\n      result.add(GlobalSearchScopesCore.projectTestScope(project));\n    }\n\n    result.add(GlobalSearchScopes.openFilesScope(project));\n\n    final Editor selectedTextEditor = ApplicationManager.getApplication().isDispatchThread()\n                                      ? FileEditorManager.getInstance(project).getSelectedTextEditor()\n                                      : null;\n    final PsiFile psiFile =\n      (selectedTextEditor != null) ? PsiDocumentManager.getInstance(project).getPsiFile(selectedTextEditor.getDocument()) : null;\n    if (psiFile != null) {\n      result.add(new LocalSearchScope(psiFile, IdeBundle.message(\"scope.current.file\")));\n    }\n\n    if (dataContext != null) {\n      PsiElement dataContextElement = CommonDataKeys.PSI_FILE.getData(dataContext);\n      if (dataContextElement == null) {\n        dataContextElement = CommonDataKeys.PSI_ELEMENT.getData(dataContext);\n      }\n\n      if (dataContextElement == null && psiFile != null) {\n        dataContextElement = psiFile;\n      }\n\n      if (dataContextElement != null) {\n        if (!PlatformUtils.isCidr()) { // TODO: have an API to disable module scopes.\n          Module module = ModuleUtilCore.findModuleForPsiElement(dataContextElement);\n          if (module == null) {\n            module = LangDataKeys.MODULE.getData(dataContext);\n          }\n          if (module != null && !(ModuleType.get(module) instanceof InternalModuleType)) {\n            result.add(module.getModuleScope());\n          }\n        }\n        if (psiFile == null && dataContextElement.getContainingFile() != null) {\n          result.add(new LocalSearchScope(dataContextElement, IdeBundle.message(\"scope.current.file\")));\n        }\n      }\n    }\n\n    if (currentSelection && selectedTextEditor != null && psiFile != null) {\n      SelectionModel selectionModel = selectedTextEditor.getSelectionModel();\n      if (selectionModel.hasSelection()) {\n        int start = selectionModel.getSelectionStart();\n        final PsiElement startElement = psiFile.findElementAt(start);\n        if (startElement != null) {\n          int end = selectionModel.getSelectionEnd();\n          final PsiElement endElement = psiFile.findElementAt(end);\n          if (endElement != null) {\n            final PsiElement parent = PsiTreeUtil.findCommonParent(startElement, endElement);\n            if (parent != null) {\n              final List<PsiElement> elements = new ArrayList<PsiElement>();\n              final PsiElement[] children = parent.getChildren();\n              TextRange selection = new TextRange(start, end);\n              for (PsiElement child : children) {\n                if (!(child instanceof PsiWhiteSpace) &&\n                    child.getContainingFile() != null &&\n                    selection.contains(child.getTextOffset())) {\n                  elements.add(child);\n                }\n              }\n              if (!elements.isEmpty()) {\n                SearchScope local = new LocalSearchScope(PsiUtilCore.toPsiElementArray(elements), IdeBundle.message(\"scope.selection\"));\n                result.add(local);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (usageView) {\n      addHierarchyScope(project, result);\n      UsageView selectedUsageView = UsageViewManager.getInstance(project).getSelectedUsageView();\n      if (selectedUsageView != null && !selectedUsageView.isSearchInProgress()) {\n        final Set<Usage> usages = ContainerUtil.newTroveSet(selectedUsageView.getUsages());\n        usages.removeAll(selectedUsageView.getExcludedUsages());\n        final List<PsiElement> results = new ArrayList<PsiElement>(usages.size());\n\n        if (prevSearchFiles) {\n          final Set<VirtualFile> files = collectFiles(usages, true);\n          if (!files.isEmpty()) {\n            GlobalSearchScope prev = new GlobalSearchScope(project) {\n              private Set<VirtualFile> myFiles = null;\n\n              @NotNull\n              @Override\n              public String getDisplayName() {\n                return IdeBundle.message(\"scope.files.in.previous.search.result\");\n              }\n\n              @Override\n              public synchronized boolean contains(@NotNull VirtualFile file) {\n                if (myFiles == null) {\n                  myFiles = collectFiles(usages, false);\n                }\n                return myFiles.contains(file);\n              }\n\n              @Override\n              public int compare(@NotNull VirtualFile file1, @NotNull VirtualFile file2) {\n                return 0;\n              }\n\n              @Override\n              public boolean isSearchInModuleContent(@NotNull Module aModule) {\n                return true;\n              }\n\n              @Override\n              public boolean isSearchInLibraries() {\n                return true;\n              }\n            };\n            result.add(prev);\n          }\n        }\n        else {\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              final PsiElement element = ((PsiElementUsage)usage).getElement();\n              if (element != null && element.isValid() && element.getContainingFile() != null) {\n                results.add(element);\n              }\n            }\n          }\n\n          if (!results.isEmpty()) {\n            result.add(new LocalSearchScope(PsiUtilCore.toPsiElementArray(results), IdeBundle.message(\"scope.previous.search.results\")));\n          }\n        }\n      }\n    }\n\n    final FavoritesManager favoritesManager = FavoritesManager.getInstance(project);\n    if (favoritesManager != null) {\n      for (final String favorite : favoritesManager.getAvailableFavoritesListNames()) {\n        final Collection<TreeItem<Pair<AbstractUrl, String>>> rootUrls = favoritesManager.getFavoritesListRootUrls(favorite);\n        if (rootUrls.isEmpty()) continue;  // ignore unused root\n        result.add(new GlobalSearchScope(project) {\n          @NotNull\n          @Override\n          public String getDisplayName() {\n            return \"Favorite \\'\" + favorite + \"\\'\";\n          }\n\n          @Override\n          public boolean contains(@NotNull final VirtualFile file) {\n            return ApplicationManager.getApplication().runReadAction((Computable<Boolean>)() -> favoritesManager.contains(favorite, file));\n          }\n\n          @Override\n          public int compare(@NotNull final VirtualFile file1, @NotNull final VirtualFile file2) {\n            return 0;\n          }\n\n          @Override\n          public boolean isSearchInModuleContent(@NotNull final Module aModule) {\n            return true;\n          }\n\n          @Override\n          public boolean isSearchInLibraries() {\n            return true;\n          }\n        });\n      }\n    }\n\n    ContainerUtil.addIfNotNull(result, getSelectedFilesScope(project, dataContext));\n\n    return ContainerUtil.newArrayList(result);\n  }","commit_id":"28e54aa60726e1538f7f73f1a01c23daecd18bab","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected PsiCodeFragment createCodeFragment(Project project, String text, @Nullable PsiElement context) {\n    GroovyCodeFragment result = new GroovyCodeFragment(project, text);\n    result.setContext(context);\n    return result;\n  }","id":72858,"modified_method":"@Override\n  public PsiCodeFragment createCodeFragment(Project project, String text, @Nullable PsiElement context) {\n    GroovyCodeFragment result = new GroovyCodeFragment(project, text);\n    result.setContext(context);\n    return result;\n  }","commit_id":"431d77f9c633df9b891d412922e87b5c930d629a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiCodeFragment createCodeFragment(Project project, String text, PsiElement context) {\n    final JavaCodeFragmentFactory factory = JavaCodeFragmentFactory.getInstance(project);\n    return factory.createCodeBlockCodeFragment(text, context, true);\n  }","id":72859,"modified_method":"public PsiCodeFragment createCodeFragment(Project project, String text, PsiElement context) {\n    final JavaCodeFragmentFactory factory = JavaCodeFragmentFactory.getInstance(project);\n    return factory.createCodeBlockCodeFragment(text, context, true);\n  }","commit_id":"431d77f9c633df9b891d412922e87b5c930d629a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ReplacementPreviewDialog(final Project project, UsageInfo info, String replacementString) {\n    super(project,true);\n\n    setTitle(SSRBundle.message(\"structural.replace.preview.dialog.title\"));\n    setOKButtonText(SSRBundle.message(\"replace.preview.oktext\"));\n    this.project = project;\n    init();\n\n    final PsiElement element = info.getElement();\n    Segment range = info.getSegment();\n    hilight(element.getContainingFile().getVirtualFile(), range.getStartOffset(), range.getEndOffset());\n    UIUtil.setContent(replacement, replacementString,0,-1,project);\n\n    final StructuralSearchProfile profile = StructuralSearchUtil.getProfileByPsiElement(element);\n    if (profile != null) {\n      UIUtil.updateHighlighter(replacement, profile);\n    }\n  }","id":72860,"modified_method":"public ReplacementPreviewDialog(final Project project, UsageInfo info, String replacementString) {\n    super(project,true);\n\n    setTitle(SSRBundle.message(\"structural.replace.preview.dialog.title\"));\n    setOKButtonText(SSRBundle.message(\"replace.preview.oktext\"));\n    this.project = project;\n    final PsiElement element = info.getElement();\n    final VirtualFile virtualFile = PsiUtilCore.getVirtualFile(element);\n    myFileType = virtualFile != null ? virtualFile.getFileType() : FileTypes.PLAIN_TEXT;\n    init();\n\n    Segment range = info.getSegment();\n    hilight(virtualFile, range.getStartOffset(), range.getEndOffset());\n    UIUtil.setContent(replacement, replacementString,0,-1,project);\n\n    final StructuralSearchProfile profile = StructuralSearchUtil.getProfileByPsiElement(element);\n    if (profile != null) {\n      UIUtil.updateHighlighter(replacement, profile);\n    }\n  }","commit_id":"431d77f9c633df9b891d412922e87b5c930d629a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n    DaemonCodeAnalyzer.getInstance(project).setHighlightingEnabled(\n      PsiDocumentManager.getInstance(project).getPsiFile(replacement.getDocument()),\n      true\n    );\n\n    EditorFactory.getInstance().releaseEditor(replacement);\n    removeHilighter();\n\n    super.dispose();\n  }","id":72861,"modified_method":"public void dispose() {\n    final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(replacement.getDocument());\n    if (file != null) {\n      DaemonCodeAnalyzer.getInstance(project).setHighlightingEnabled(file, true);\n    }\n\n    EditorFactory.getInstance().releaseEditor(replacement);\n    removeHilighter();\n\n    super.dispose();\n  }","commit_id":"431d77f9c633df9b891d412922e87b5c930d629a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n    JComponent centerPanel = new JPanel( new BorderLayout() );\n\n    PsiFile file;\n    replacement = UIUtil.createEditor(\n      PsiDocumentManager.getInstance(project).getDocument(\n        file = JavaCodeFragmentFactory.getInstance(project).createCodeBlockCodeFragment(\"\", null, true)\n      ),\n      project,\n      true,\n      null\n    );\n\n    DaemonCodeAnalyzer.getInstance(project).setHighlightingEnabled(file,false);\n\n    centerPanel.add(BorderLayout.NORTH,new JLabel(SSRBundle.message(\"replacement.code\")) );\n    centerPanel.add(BorderLayout.CENTER,replacement.getComponent() );\n    centerPanel.setMaximumSize(new Dimension(640,480));\n\n    return centerPanel;\n  }","id":72862,"modified_method":"protected JComponent createCenterPanel() {\n    JComponent centerPanel = new JPanel( new BorderLayout() );\n\n    PsiFile file = null;\n    final StructuralSearchProfile profile = StructuralSearchUtil.getProfileByFileType(myFileType);\n    if (profile != null) {\n      file = profile.createCodeFragment(project, \"\", null);\n    }\n\n    if (file != null) {\n      final Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n      replacement = UIUtil.createEditor(document, project, true, null);\n      DaemonCodeAnalyzer.getInstance(project).setHighlightingEnabled(file,false);\n    } else {\n      final EditorFactory factory = EditorFactory.getInstance();\n      final Document document = factory.createDocument(\"\");\n      replacement = factory.createEditor(document, project, myFileType, false);\n    }\n\n    centerPanel.add(BorderLayout.NORTH,new JLabel(SSRBundle.message(\"replacement.code\")) );\n    centerPanel.add(BorderLayout.CENTER,replacement.getComponent() );\n    centerPanel.setMaximumSize(new Dimension(640,480));\n\n    return centerPanel;\n  }","commit_id":"431d77f9c633df9b891d412922e87b5c930d629a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected PsiCodeFragment createCodeFragment(Project project, String text, @Nullable PsiElement context) {\n    return null;\n  }","id":72863,"modified_method":"@Nullable\n  public PsiCodeFragment createCodeFragment(Project project, String text, @Nullable PsiElement context) {\n    return null;\n  }","commit_id":"431d77f9c633df9b891d412922e87b5c930d629a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TextChunk[] initChunks() {\n    TextChunk[] chunks = ChunkExtractor.extractChunks(getPsiFile(), this);\n    myTextChunks = new SoftReference<TextChunk[]>(chunks);\n    return chunks;\n  }","id":72864,"modified_method":"private TextChunk[] initChunks() {\n    PsiFile file = getPsiFile();\n    TextChunk[] chunks = file == null ? TextChunk.EMPTY_ARRAY : ChunkExtractor.extractChunks(file, this);\n    myTextChunks = new SoftReference<TextChunk[]>(chunks);\n    return chunks;\n  }","commit_id":"c7ce764cffa5363727b5bf21f13d73fe9448dd5c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {\n      DomManagerImpl.getInvocationStack().push(method, proxy);\n      try {\n        if (Object.class.equals(method.getDeclaringClass())) {\n          @NonNls String methodName = method.getName();\n          if (\"toString\".equals(methodName)) {\n            return \"Merger: \" + Arrays.asList(myImplementations);\n          }\n          if (\"hashCode\".equals(methodName)) {\n            return Arrays.hashCode(myImplementations);\n          }\n          if (\"equals\".equals(methodName)) {\n            final Object arg = args[0];\n            return arg != null && arg instanceof MergedObject &&\n                   ((MergedObject)arg).getImplementations().equals(Arrays.asList(myImplementations));\n\n          }\n          return null;\n        }\n\n        try {\n          if (MergedObject.class.equals(method.getDeclaringClass())) {\n            @NonNls String methodName = method.getName();\n            if (\"getImplementations\".equals(methodName)) {\n              return Arrays.asList(myImplementations);\n            }\n            else assert false;\n          }\n          final Class returnType = method.getReturnType();\n          if (signaturesNotToMerge.size() > 0) {\n            final JavaMethodSignature signature = JavaMethodSignature.getSignature(method);\n            if (signaturesNotToMerge.contains(signature)) {\n              for (final T t : myImplementations) {\n                final Object o = method.invoke(t, args);\n                if (o != null) return o;\n              }\n              return null;\n            }\n          }\n          if (Collection.class.isAssignableFrom(returnType)) {\n            return getMergedImplementations(method, args,\n                                            DomUtil.getRawType(DomImplUtil.extractCollectionElementType(method.getGenericReturnType())));\n          }\n\n          if (GenericValue.class.isAssignableFrom(returnType)) {\n            return new MergedGenericValue(method, args);\n          }\n\n          if (void.class == returnType) {\n            for (final T t : myImplementations) {\n              method.invoke(t, args);\n            }\n            return null;\n          }\n\n          List<Object> results = getMergedImplementations(method, args, method.getReturnType());\n\n          return results.isEmpty() ? null : results.get(0);\n        }\n        catch (InvocationTargetException ex) {\n          throw ex.getTargetException();\n        }\n      }\n      finally {\n        DomManagerImpl.getInvocationStack().pop();\n      }\n    }","id":72865,"modified_method":"public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {\n      DomManagerImpl.getInvocationStack().push(method, proxy);\n      try {\n        if (Object.class.equals(method.getDeclaringClass())) {\n          @NonNls String methodName = method.getName();\n          if (\"toString\".equals(methodName)) {\n            return \"Merger: \" + Arrays.asList(myImplementations);\n          }\n          if (\"hashCode\".equals(methodName)) {\n            return Arrays.hashCode(myImplementations);\n          }\n          if (\"equals\".equals(methodName)) {\n            final Object arg = args[0];\n            return arg != null && arg instanceof MergedObject &&\n                   ((MergedObject)arg).getImplementations().equals(Arrays.asList(myImplementations));\n\n          }\n          return null;\n        }\n\n        try {\n          if (MergedObject.class.equals(method.getDeclaringClass())) {\n            @NonNls String methodName = method.getName();\n            if (\"getImplementations\".equals(methodName)) {\n              return Arrays.asList(myImplementations);\n            }\n            else assert false;\n          }\n          final Class returnType = method.getReturnType();\n          if (signaturesNotToMerge.size() > 0) {\n            final JavaMethodSignature signature = JavaMethodSignature.getSignature(method);\n            if (signaturesNotToMerge.contains(signature)) {\n              for (final T t : myImplementations) {\n                final Object o = method.invoke(t, args);\n                if (o != null) return o;\n              }\n              return null;\n            }\n          }\n          if (Collection.class.isAssignableFrom(returnType)) {\n            return getMergedImplementations(method, args,\n                                            DomUtil.getRawType(DomImplUtil.extractCollectionElementType(method.getGenericReturnType())));\n          }\n\n          //if (GenericValue.class.isAssignableFrom(returnType)) {\n          //  return new MergedGenericValue(method, args);\n          //}\n\n          if (void.class == returnType) {\n            for (final T t : myImplementations) {\n              method.invoke(t, args);\n            }\n            return null;\n          }\n\n          List<Object> results = getMergedImplementations(method, args, method.getReturnType());\n\n          return results.isEmpty() ? null : results.get(0);\n        }\n        catch (InvocationTargetException ex) {\n          throw ex.getTargetException();\n        }\n      }\n      finally {\n        DomManagerImpl.getInvocationStack().pop();\n      }\n    }","commit_id":"4b54ae6246115e2c433213263b142c2ec47b1901","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Object getPrimaryKey(Object implementation) throws IllegalAccessException, InvocationTargetException {\n      if (implementation instanceof GenericValue) return ((GenericValue)implementation).getValue();\n      final Method method = getPrimaryKeyMethod(implementation.getClass());\n      if (method == null) return null;\n\n      final Object o = method.invoke(implementation);\n      return GenericValue.class.isAssignableFrom(method.getReturnType()) ? ((GenericValue)o).getValue() : o;\n    }","id":72866,"modified_method":"protected Object getPrimaryKey(Object implementation) throws IllegalAccessException, InvocationTargetException {\n      if (implementation instanceof GenericValue) return Boolean.TRUE; // ((GenericValue)implementation).getValue();\n      final Method method = getPrimaryKeyMethod(implementation.getClass());\n      if (method == null) return null;\n\n      final Object o = method.invoke(implementation);\n      return GenericValue.class.isAssignableFrom(method.getReturnType()) ? ((GenericValue)o).getValue() : o;\n    }","commit_id":"4b54ae6246115e2c433213263b142c2ec47b1901","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected DomElement getSelectedDomElementFromTextEditor(final TextEditor textEditor) {\n    final PsiElement psiElement = getPsiFile().findElementAt(textEditor.getEditor().getCaretModel().getOffset());\n\n    if(psiElement == null) return null;\n\n    final XmlTag xmlTag = PsiTreeUtil.getParentOfType(psiElement, XmlTag.class);\n\n    return DomManager.getDomManager(myProject).getDomElement(xmlTag);\n  }","id":72867,"modified_method":"protected DomElement getSelectedDomElementFromTextEditor(final TextEditor textEditor) {\n    final PsiFile psiFile = getPsiFile();\n    if (psiFile == null) return null;\n    final PsiElement psiElement = psiFile.findElementAt(textEditor.getEditor().getCaretModel().getOffset());\n\n    if(psiElement == null) return null;\n\n    final XmlTag xmlTag = PsiTreeUtil.getParentOfType(psiElement, XmlTag.class);\n\n    return DomManager.getDomManager(myProject).getDomElement(xmlTag);\n  }","commit_id":"4b54ae6246115e2c433213263b142c2ec47b1901","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private FileStatus(PsiElement dirtyScope) {\n      this.dirtyScope = dirtyScope;\n      localInspectionsDirtyScope = dirtyScope;\n      externalDirtyScope = dirtyScope;\n      TextEditorHighlightingPassRegistrarImpl registrar = (TextEditorHighlightingPassRegistrarImpl) TextEditorHighlightingPassRegistrar.getInstance(dirtyScope.getProject());\n      for(DirtyScopeTrackingHighlightingPassFactory factory: registrar.getDirtyScopeTrackingFactories()) {\n        customPassDirtyScopes.put(factory.getPassId(), dirtyScope);\n      }\n    }","id":72868,"modified_method":"private FileStatus(PsiFile file) {\n      TextRange range = file.getTextRange();\n      dirtyScope = range;\n      localInspectionsDirtyScope = range;\n      externalDirtyScope = range;\n      TextEditorHighlightingPassRegistrarImpl registrar = (TextEditorHighlightingPassRegistrarImpl) TextEditorHighlightingPassRegistrar.getInstance(file.getProject());\n      for(DirtyScopeTrackingHighlightingPassFactory factory: registrar.getDirtyScopeTrackingFactories()) {\n        customPassDirtyScopes.put(factory.getPassId(), range);\n      }\n    }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void markFileScopeDirty(@NotNull Document document, @NotNull PsiElement scope) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"********************************* Mark dirty: \"+scope);\n    }\n    synchronized(myDocumentToStatusMap) {\n      FileStatus status = myDocumentToStatusMap.get(document);\n      if (status == null) return; // all dirty already\n      if (status.defensivelyMarked) {\n        status.defensivelyMarked = false;\n      }\n      status.dirtyScope = combineScopes(status.dirtyScope, scope, document, myProject);\n      status.localInspectionsDirtyScope = combineScopes(status.localInspectionsDirtyScope, scope, document, myProject);\n      status.externalDirtyScope = combineScopes(status.externalDirtyScope, scope, document, myProject);\n    }\n  }","id":72869,"modified_method":"public void markFileScopeDirty(@NotNull Document document, @NotNull TextRange scope) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"********************************* Mark dirty: \"+scope);\n    }\n    synchronized(myDocumentToStatusMap) {\n      FileStatus status = myDocumentToStatusMap.get(document);\n      if (status == null) return; // all dirty already\n      if (status.defensivelyMarked) {\n        status.defensivelyMarked = false;\n      }\n      status.dirtyScope = combineScopes(status.dirtyScope, scope, document, myProject);\n      status.localInspectionsDirtyScope = combineScopes(status.localInspectionsDirtyScope, scope, document, myProject);\n      status.externalDirtyScope = combineScopes(status.externalDirtyScope, scope, document, myProject);\n    }\n  }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  static TextRange getDirtyTextRange(Editor editor, int part) {\n    Document document = editor.getDocument();\n\n    PsiElement dirtyScope = ((DaemonCodeAnalyzerImpl)DaemonCodeAnalyzer.getInstance(editor.getProject())).getFileStatusMap().getFileDirtyScope(document, part);\n    if (dirtyScope == null || !dirtyScope.isValid()) {\n      return null;\n    }\n    PsiFile file = dirtyScope.getContainingFile();\n    if (file.getTextLength() != document.getTextLength()) {\n      LOG.error(\"Length wrong! dirtyScope:\" + dirtyScope,\n                \"file length:\" + file.getTextLength(),\n                \"document length:\" + document.getTextLength(),\n                \"file stamp:\" + file.getModificationStamp(),\n                \"document stamp:\" + document.getModificationStamp()\n                );\n    }\n    return dirtyScope.getTextRange();\n  }","id":72870,"modified_method":"@Nullable\n  static TextRange getDirtyTextRange(Editor editor, int part) {\n    Document document = editor.getDocument();\n    TextRange documentRange = TextRange.from(0, document.getTextLength());\n\n    TextRange dirtyScope = ((DaemonCodeAnalyzerImpl)DaemonCodeAnalyzer.getInstance(editor.getProject())).getFileStatusMap().getFileDirtyScope(document, part);\n    if (dirtyScope == null || !documentRange.contains(dirtyScope)) {\n      return null;\n    }\n    return dirtyScope;\n  }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiElement combineScopes(PsiElement scope1, PsiElement scope2, Document document, Project project) {\n    if (scope1 == null) return scope2;\n    if (scope2 == null) return scope1;\n    final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n    if (!scope1.isValid() || !scope2.isValid()) return documentManager.getPsiFile(document);\n    final PsiElement commonParent = PsiTreeUtil.findCommonParent(scope1, scope2);\n    return commonParent == null || commonParent instanceof PsiDirectory ? documentManager.getPsiFile(document) : commonParent;\n  }","id":72871,"modified_method":"private static TextRange combineScopes(TextRange scope1, TextRange scope2, Document document, Project project) {\n    if (scope1 == null) return scope2;\n    if (scope2 == null) return scope1;\n    TextRange documentRange = TextRange.from(0, document.getTextLength());\n    if (!documentRange.contains(scope1) || !documentRange.contains(scope2)) return documentRange;\n    return scope1.union(scope2);\n  }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param document\n   * @param passId\n   * @return null for processed file, whole file for untouched or entirely dirty file, PsiElement(usually code block) for dirty region (optimization)\n   */\n  @Nullable\n  public PsiElement getFileDirtyScope(@NotNull Document document, int passId) {\n    synchronized(myDocumentToStatusMap){\n      FileStatus status = myDocumentToStatusMap.get(document);\n      if (status == null){\n        return PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n      }\n      if (status.defensivelyMarked) {\n        status.dirtyScope = status.localInspectionsDirtyScope = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n        status.defensivelyMarked = false;\n      }\n      switch (passId) {\n        case Pass.UPDATE_ALL:\n          return status.dirtyScope;\n        case Pass.LOCAL_INSPECTIONS:\n          return status.localInspectionsDirtyScope;\n        case Pass.EXTERNAL_TOOLS:\n          return status.externalDirtyScope;\n        default:\n          if (status.customPassDirtyScopes.containsKey(passId)) {\n            return status.customPassDirtyScopes.get(passId);\n          }\n          LOG.assertTrue(false);\n          return null;\n      }\n    }\n  }","id":72872,"modified_method":"/**\n   * @param document\n   * @param passId\n   * @return null for processed file, whole file for untouched or entirely dirty file, range(usually code block) for dirty region (optimization)\n   */\n  @Nullable\n  public TextRange getFileDirtyScope(@NotNull Document document, int passId) {\n    synchronized(myDocumentToStatusMap){\n      FileStatus status = myDocumentToStatusMap.get(document);\n      if (status == null){\n        PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n        return file == null ? null : file.getTextRange();\n      }\n      if (status.defensivelyMarked) {\n        PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n        status.dirtyScope = status.localInspectionsDirtyScope = file == null ? null : file.getTextRange();\n        status.defensivelyMarked = false;\n      }\n      switch (passId) {\n        case Pass.UPDATE_ALL:\n          return status.dirtyScope;\n        case Pass.LOCAL_INSPECTIONS:\n          return status.localInspectionsDirtyScope;\n        case Pass.EXTERNAL_TOOLS:\n          return status.externalDirtyScope;\n        default:\n          if (status.customPassDirtyScopes.containsKey(passId)) {\n            return status.customPassDirtyScopes.get(passId);\n          }\n          LOG.assertTrue(false);\n          return null;\n      }\n    }\n  }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitParameterList(PsiParameterList list) {\n    if (list.getParent() instanceof PsiAnnotationMethod && list.getParametersCount() > 0) {\n      myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                     list,\n                                                     JavaErrorMessages.message(\"annotation.interface.members.may.not.have.parameters\")));\n    }\n  }","id":72873,"modified_method":"@Override public void visitParameterList(PsiParameterList list) {\n    PsiElement parent = list.getParent();\n    if (parent instanceof PsiAnnotationMethod && list.getParametersCount() > 0) {\n      myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                     list,\n                                                     JavaErrorMessages.message(\"annotation.interface.members.may.not.have.parameters\")));\n    }\n  }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean init(final boolean updateWholeFile, final PsiFile file) {\n    assert released;\n    released = false;\n    boolean success = true;\n    RefCountHolder refCountHolder;\n    if (updateWholeFile) {\n      Project project = file.getProject();\n      DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n      FileStatusMap fileStatusMap = ((DaemonCodeAnalyzerImpl)daemonCodeAnalyzer).getFileStatusMap();\n      refCountHolder = RefCountHolder.getInstance(file);\n      success = refCountHolder.startAnalyzing();\n      if (success) {\n        Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n        PsiElement dirtyScope = document == null ? file : fileStatusMap.getFileDirtyScope(document, Pass.UPDATE_ALL);\n        if (dirtyScope != null) {\n          if (dirtyScope instanceof PsiFile) {\n            refCountHolder.clear();\n          }\n          else {\n            refCountHolder.removeInvalidRefs();\n          }\n        }\n      }\n    }\n    else {\n      refCountHolder = null;\n    }\n\n    myRefCountHolder = refCountHolder;\n    return success;\n  }","id":72874,"modified_method":"public boolean init(final boolean updateWholeFile, final PsiFile file) {\n    assert released;\n    released = false;\n    boolean success = true;\n    RefCountHolder refCountHolder;\n    if (updateWholeFile) {\n      Project project = file.getProject();\n      DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer.getInstance(project);\n      FileStatusMap fileStatusMap = ((DaemonCodeAnalyzerImpl)daemonCodeAnalyzer).getFileStatusMap();\n      refCountHolder = RefCountHolder.getInstance(file);\n      success = refCountHolder.startAnalyzing();\n      if (success) {\n        Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n        TextRange fileRange = file.getTextRange();\n        TextRange dirtyScope = document == null ? fileRange : fileStatusMap.getFileDirtyScope(document, Pass.UPDATE_ALL);\n        if (dirtyScope != null) {\n          if (dirtyScope.equals(fileRange)) {\n            refCountHolder.clear();\n          }\n          else {\n            refCountHolder.removeInvalidRefs();\n          }\n        }\n      }\n    }\n    else {\n      refCountHolder = null;\n    }\n\n    myRefCountHolder = refCountHolder;\n    return success;\n  }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateByChange(PsiElement child, final boolean whitespaceOptimizationAllowed) {\n    final Editor editor = FileEditorManager.getInstance(myProject).getSelectedTextEditor();\n    if (editor != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          if (myProject.isDisposed()) return;\n          EditorMarkupModel markupModel = (EditorMarkupModel)editor.getMarkupModel();\n          markupModel.setErrorStripeRenderer(markupModel.getErrorStripeRenderer());\n        }\n      }, ModalityState.stateForComponent(editor.getComponent()));\n    }\n\n    final FileStatusMap fileStatusMap = myDaemonCodeAnalyzer.getFileStatusMap();\n\n    PsiFile file = child.getContainingFile();\n    if (file == null || file instanceof PsiCompiledElement) {\n      fileStatusMap.markAllFilesDirty();\n      return;\n    }\n\n    Document document = PsiDocumentManager.getInstance(myProject).getCachedDocument(file);\n    if (document == null) return;\n\n    // optimization\n    if (whitespaceOptimizationAllowed && UpdateHighlightersUtil.isWhitespaceOptimizationAllowed(document)) {\n      if (child instanceof PsiWhiteSpace || child instanceof PsiComment) {\n        fileStatusMap.markFileScopeDirty(document, child);\n        return;\n      }\n    }\n\n    PsiElement element = child;\n    while (true) {\n      if (element instanceof PsiFile || element instanceof PsiDirectory) {\n        fileStatusMap.markAllFilesDirty();\n        return;\n      }\n\n      final PsiElement scope = getChangeHighlightingScope(element);\n      if (scope != null) {\n        fileStatusMap.markFileScopeDirty(document, scope);\n        return;\n      }\n\n      element = element.getParent();\n    }\n  }","id":72875,"modified_method":"private void updateByChange(PsiElement child, final boolean whitespaceOptimizationAllowed) {\n    final Editor editor = FileEditorManager.getInstance(myProject).getSelectedTextEditor();\n    if (editor != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          if (myProject.isDisposed()) return;\n          EditorMarkupModel markupModel = (EditorMarkupModel)editor.getMarkupModel();\n          markupModel.setErrorStripeRenderer(markupModel.getErrorStripeRenderer());\n        }\n      }, ModalityState.stateForComponent(editor.getComponent()));\n    }\n\n    final FileStatusMap fileStatusMap = myDaemonCodeAnalyzer.getFileStatusMap();\n\n    PsiFile file = child.getContainingFile();\n    if (file == null || file instanceof PsiCompiledElement) {\n      fileStatusMap.markAllFilesDirty();\n      return;\n    }\n\n    Document document = PsiDocumentManager.getInstance(myProject).getCachedDocument(file);\n    if (document == null) return;\n\n    // optimization\n    if (whitespaceOptimizationAllowed && UpdateHighlightersUtil.isWhitespaceOptimizationAllowed(document)) {\n      if (child instanceof PsiWhiteSpace || child instanceof PsiComment) {\n        fileStatusMap.markFileScopeDirty(document, child.getTextRange());\n        return;\n      }\n    }\n\n    PsiElement element = child;\n    while (true) {\n      if (element instanceof PsiFile || element instanceof PsiDirectory) {\n        fileStatusMap.markAllFilesDirty();\n        return;\n      }\n\n      final PsiElement scope = getChangeHighlightingScope(element);\n      if (scope != null) {\n        fileStatusMap.markFileScopeDirty(document, scope.getTextRange());\n        return;\n      }\n\n      element = element.getParent();\n    }\n  }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void updateHighlightersByTyping(@NotNull Project project, @NotNull DocumentEvent e) {\n    Document document = e.getDocument();\n    if (document instanceof DocumentEx && ((DocumentEx)document).isInBulkUpdate()) return;\n\n    HighlightInfo[] highlights = DaemonCodeAnalyzerImpl.getHighlights(document, project);\n\n    if (highlights == null || highlights.length == 0) return;\n    int offset = e.getOffset();\n    Editor[] editors = EditorFactory.getInstance().getEditors(document, project);\n    if (editors.length == 0) return;\n    Editor editor = editors[0]; // use any editor - just to fetch SelectInEditorManager\n    HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(Math.max(0, offset - 1));\n    if (iterator.atEnd()) return;\n    int start = iterator.getStart();\n    while (iterator.getEnd() < e.getOffset() + e.getNewLength()) {\n      iterator.advance();\n      if (iterator.atEnd()) return;\n    }\n    int end = iterator.getEnd();\n\n    List<HighlightInfo> array = new ArrayList<HighlightInfo>(highlights.length);\n    boolean changed = false;\n    for (HighlightInfo info : highlights) {\n      RangeHighlighter highlighter = info.highlighter;\n      boolean toRemove = false;\n\n      if (info.needUpdateOnTyping()) {\n        int highlighterStart = highlighter.getStartOffset();\n        int highlighterEnd = highlighter.getEndOffset();\n        if (info.isAfterEndOfLine) {\n          if (highlighterStart < document.getTextLength()) {\n            highlighterStart += 1;\n          }\n          if (highlighterEnd < document.getTextLength()) {\n            highlighterEnd += 1;\n          }\n        }\n\n        if (!highlighter.isValid()) {\n          toRemove = true;\n        }\n        else if (start < highlighterEnd && highlighterStart < end) {\n          LOG.assertTrue(0 <= highlighterStart);\n          LOG.assertTrue(highlighterStart < document.getTextLength());\n          HighlighterIterator iterator1 = ((EditorEx)editor).getHighlighter().createIterator(highlighterStart);\n          int start1 = iterator1.getStart();\n          while (iterator1.getEnd() < highlighterEnd) {\n            iterator1.advance();\n          }\n          int end1 = iterator1.getEnd();\n          CharSequence chars = document.getCharsSequence();\n          String token = chars.subSequence(start1, end1).toString();\n          if (start1 != highlighterStart || end1 != highlighterEnd || !token.equals(info.text)) {\n            toRemove = true;\n            disableWhiteSpaceOptimization(document);\n          }\n        }\n      }\n\n      if (toRemove) {\n        document.getMarkupModel(project).removeHighlighter(highlighter);\n        changed = true;\n      }\n      else {\n        array.add(info);\n      }\n    }\n\n    if (changed) {\n      HighlightInfo[] newHighlights = array.toArray(new HighlightInfo[array.size()]);\n      DaemonCodeAnalyzerImpl.setHighlights(document, newHighlights, project);\n    }\n  }","id":72876,"modified_method":"public static void updateHighlightersByTyping(@NotNull Project project, @NotNull DocumentEvent e) {\n    Document document = e.getDocument();\n    if (document instanceof DocumentEx && ((DocumentEx)document).isInBulkUpdate()) return;\n\n    HighlightInfo[] highlights = DaemonCodeAnalyzerImpl.getHighlights(document, project);\n\n    if (highlights == null || highlights.length == 0) return;\n    int offset = e.getOffset();\n    Editor[] editors = EditorFactory.getInstance().getEditors(document, project);\n    if (editors.length == 0) return;\n    Editor editor = editors[0]; // use any editor - just to fetch SelectInEditorManager\n    HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(Math.max(0, offset - 1));\n    if (iterator.atEnd()) return;\n    int start = iterator.getStart();\n    while (iterator.getEnd() < e.getOffset() + e.getNewLength()) {\n      iterator.advance();\n      if (iterator.atEnd()) return;\n    }\n    int end = iterator.getEnd();\n\n    List<HighlightInfo> array = new ArrayList<HighlightInfo>(highlights.length);\n    boolean highlightersChanged = false;\n    boolean documentChangedInsideHighlighter = false;\n    for (HighlightInfo info : highlights) {\n      RangeHighlighter highlighter = info.highlighter;\n      boolean toRemove = false;\n\n      if (info.needUpdateOnTyping()) {\n        int highlighterStart = highlighter.getStartOffset();\n        int highlighterEnd = highlighter.getEndOffset();\n        if (info.isAfterEndOfLine) {\n          if (highlighterStart < document.getTextLength()) {\n            highlighterStart += 1;\n          }\n          if (highlighterEnd < document.getTextLength()) {\n            highlighterEnd += 1;\n          }\n        }\n\n        if (!highlighter.isValid()) {\n          toRemove = true;\n        }\n        else if (start < highlighterEnd && highlighterStart < end) {\n          LOG.assertTrue(0 <= highlighterStart);\n          LOG.assertTrue(highlighterStart < document.getTextLength());\n          documentChangedInsideHighlighter = true;\n\n          HighlighterIterator iterator1 = ((EditorEx)editor).getHighlighter().createIterator(highlighterStart);\n          int start1 = iterator1.getStart();\n          while (iterator1.getEnd() < highlighterEnd) {\n            iterator1.advance();\n          }\n          int end1 = iterator1.getEnd();\n          CharSequence chars = document.getCharsSequence();\n          if (start1 != highlighterStart || end1 != highlighterEnd || !CharArrayUtil.regionMatches(chars, start1, end1, info.text)) {\n            toRemove = true;\n          }\n        }\n      }\n\n      if (toRemove) {\n        document.getMarkupModel(project).removeHighlighter(highlighter);\n        highlightersChanged = true;\n      }\n      else {\n        array.add(info);\n      }\n    }\n\n    if (highlightersChanged || documentChangedInsideHighlighter) {\n      disableWhiteSpaceOptimization(document);\n    }\n    if (highlightersChanged) {\n      HighlightInfo[] newHighlights = array.toArray(new HighlightInfo[array.size()]);\n      DaemonCodeAnalyzerImpl.setHighlights(document, newHighlights, project);\n    }\n  }","commit_id":"be9732efdc6fb936320dff52803030ece529a776","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getCurrentEditorElement() {\n    if (myEditor == null) return null;\n    final int offset = myEditor.getCaretModel().getOffset();\n    FileViewProvider viewProvider = getPsiFile().getViewProvider();\n    PsiElement element = viewProvider.findElementAt(offset, getPsiFile().getLanguage());\n    while (element != null && !(element instanceof PsiFile)) {\n      if (isSuitable(element)) return element;\n      element = element.getParent();\n    }\n    return null;\n  }","id":72877,"modified_method":"public Object getCurrentEditorElement() {\n    if (myEditor == null) return null;\n    final int offset = myEditor.getCaretModel().getOffset();\n    final PsiFile file = getPsiFile();\n    FileViewProvider viewProvider = file.getViewProvider();\n\n    PsiElement element = viewProvider.findElementAt(offset, file.getLanguage());\n    if (element == null) {\n      final LanguageDialect languageDialect = file.getLanguageDialect();\n      if (languageDialect != null) element = viewProvider.findElementAt(offset, languageDialect);\n    }\n    \n    while (element != null && !(element instanceof PsiFile)) {\n      if (isSuitable(element)) return element;\n      element = element.getParent();\n    }\n    return null;\n  }","commit_id":"38d4ceb1c2896ae3111de74124ea73412ae42032","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean shouldEnterElement(final Object element) {\n    return element instanceof XmlTag;\n  }","id":72878,"modified_method":"public boolean shouldEnterElement(final Object element) {\n    return element instanceof XmlTag && ((XmlTag)element).getSubTags().length > 0;\n  }","commit_id":"38d4ceb1c2896ae3111de74124ea73412ae42032","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ConnectCompletion connect(Address destinationAddress) throws ConnectException {\n        if (!(destinationAddress instanceof InetEndpoint)) {\n            throw new IllegalArgumentException(String.format(\"Cannot create a connection to address of unknown type: %s.\", destinationAddress));\n        }\n        InetEndpoint address = (InetEndpoint) destinationAddress;\n        LOGGER.debug(\"Attempting to connect to {}.\", address);\n\n        // Try each address in turn. Not all of them are necessarily reachable (eg when socket option IPV6_V6ONLY\n        // is on - the default for debian and others), so we will try each of them until we can connect\n        List<InetAddress> candidateAddresses = address.getCandidates();\n\n        // Now try each address\n        try {\n            Exception lastFailure = null;\n            for (InetAddress candidate : candidateAddresses) {\n                LOGGER.debug(\"Trying to connect to address {}.\", candidate);\n                SocketChannel socketChannel;\n                try {\n                    socketChannel = SocketChannel.open(new InetSocketAddress(candidate, address.getPort()));\n                } catch (SocketException e) {\n                    LOGGER.debug(\"Cannot connect to address {}, skipping.\", candidate);\n                    lastFailure = e;\n                    continue;\n                }\n                LOGGER.debug(\"Connected to address {}.\", socketChannel.socket().getRemoteSocketAddress());\n                return new SocketConnectCompletion(socketChannel);\n            }\n            throw new ConnectException(String.format(\"Could not connect to server %s. Tried addresses: %s.\",\n                    destinationAddress, candidateAddresses), lastFailure);\n        } catch (ConnectException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Could not connect to server %s. Tried addresses: %s.\",\n                    destinationAddress, candidateAddresses), e);\n        }\n    }","id":72879,"modified_method":"public ConnectCompletion connect(Address destinationAddress) throws ConnectException {\n        if (!(destinationAddress instanceof InetEndpoint)) {\n            throw new IllegalArgumentException(String.format(\"Cannot create a connection to address of unknown type: %s.\", destinationAddress));\n        }\n        InetEndpoint address = (InetEndpoint) destinationAddress;\n        LOGGER.debug(\"Attempting to connect to {}.\", address);\n\n        // Try each address in turn. Not all of them are necessarily reachable (eg when socket option IPV6_V6ONLY\n        // is on - the default for debian and others), so we will try each of them until we can connect\n        List<InetAddress> candidateAddresses = address.getCandidates();\n\n        // Now try each address\n        try {\n            Exception lastFailure = null;\n            for (InetAddress candidate : candidateAddresses) {\n                LOGGER.debug(\"Trying to connect to address {}.\", candidate);\n                SocketChannel socketChannel;\n                try {\n                    socketChannel = SocketChannel.open();\n                    socketChannel.socket().connect(new InetSocketAddress(candidate, address.getPort()), CONNECT_TIMEOUT);\n                } catch (SocketException e) {\n                    LOGGER.debug(\"Cannot connect to address {}, skipping.\", candidate);\n                    lastFailure = e;\n                    continue;\n                } catch (SocketTimeoutException e) {\n                    LOGGER.debug(\"Timeout connecting to address {}, skipping.\", candidate);\n                    lastFailure = e;\n                    continue;\n                }\n                LOGGER.debug(\"Connected to address {}.\", socketChannel.socket().getRemoteSocketAddress());\n                return new SocketConnectCompletion(socketChannel);\n            }\n            throw new ConnectException(String.format(\"Could not connect to server %s. Tried addresses: %s.\",\n                    destinationAddress, candidateAddresses), lastFailure);\n        } catch (ConnectException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(String.format(\"Could not connect to server %s. Tried addresses: %s.\",\n                    destinationAddress, candidateAddresses), e);\n        }\n    }","commit_id":"fafd0253a21dc021a5b7cf23a2cfa01d2dfa7916","url":"https://github.com/gradle/gradle"},{"original_method":"public static Socket newSocket(InetAddress endpoint) throws IOException\n    {\n        // zero means 'bind on any available port.'\n        if (isEncryptedChannel(endpoint))\n        {\n            if (Config.getOutboundBindAny())\n                return SSLFactory.getSocket(DatabaseDescriptor.getServerEncryptionOptions(), endpoint, DatabaseDescriptor.getSSLStoragePort());\n            else\n                return SSLFactory.getSocket(DatabaseDescriptor.getServerEncryptionOptions(), endpoint, DatabaseDescriptor.getSSLStoragePort(), FBUtilities.getLocalAddress(), 0);\n        }\n        else\n        {\n            Socket socket = SocketChannel.open(new InetSocketAddress(endpoint, DatabaseDescriptor.getStoragePort())).socket();\n            if (Config.getOutboundBindAny() && !socket.isBound())\n                socket.bind(new InetSocketAddress(FBUtilities.getLocalAddress(), 0));\n            return socket;\n        }\n    }","id":72880,"modified_method":"public static Socket newSocket(InetAddress endpoint) throws IOException\n    {\n        // zero means 'bind on any available port.'\n        if (isEncryptedChannel(endpoint))\n        {\n            if (Config.getOutboundBindAny())\n                return SSLFactory.getSocket(DatabaseDescriptor.getServerEncryptionOptions(), endpoint, DatabaseDescriptor.getSSLStoragePort());\n            else\n                return SSLFactory.getSocket(DatabaseDescriptor.getServerEncryptionOptions(), endpoint, DatabaseDescriptor.getSSLStoragePort(), FBUtilities.getLocalAddress(), 0);\n        }\n        else\n        {\n            SocketChannel channel = SocketChannel.open();\n            if (!Config.getOutboundBindAny())\n                channel.bind(new InetSocketAddress(FBUtilities.getLocalAddress(), 0));\n            channel.connect(new InetSocketAddress(endpoint, DatabaseDescriptor.getStoragePort()));\n            return channel.socket();\n        }\n    }","commit_id":"a55fd76ddd96e3ed2d967910f0572804fcfacc2f","url":"https://github.com/apache/cassandra"},{"original_method":"public void runMayThrow() throws IOException\n    {\n        SocketChannel channel = SocketChannel.open(new InetSocketAddress(to, DatabaseDescriptor.getStoragePort()));\n        try\n        {\n            stream(channel);\n        }\n        finally\n        {\n            try\n            {\n                channel.close();\n            }\n            catch (IOException e)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"error closing socket\", e);\n            }\n        }\n        if (logger.isDebugEnabled())\n          logger.debug(\"Done streaming \" + file);\n    }","id":72881,"modified_method":"public void runMayThrow() throws IOException\n    {\n        SocketChannel channel = SocketChannel.open();\n        // force local binding on correctly specified interface.\n        channel.socket().bind(new InetSocketAddress(FBUtilities.getLocalAddress(), 0));\n        // obey the unwritten law that all nodes on a cluster must use the same storage port.\n        channel.connect(new InetSocketAddress(to, DatabaseDescriptor.getStoragePort()));\n        try\n        {\n            stream(channel);\n        }\n        finally\n        {\n            try\n            {\n                channel.close();\n            }\n            catch (IOException e)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"error closing socket\", e);\n            }\n        }\n        if (logger.isDebugEnabled())\n          logger.debug(\"Done streaming \" + file);\n    }","commit_id":"1fec6d186b5bfb11dc3d2384c59506af3f81396c","url":"https://github.com/apache/cassandra"},{"original_method":"private boolean connect()\r\n    {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"attempting to connect to \" + endpoint);\r\n        long start = System.currentTimeMillis();\r\n        while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout())\r\n        {\r\n            try\r\n            {\r\n                socket = new Socket(endpoint, DatabaseDescriptor.getStoragePort());\r\n                socket.setTcpNoDelay(true);\r\n                output = new DataOutputStream(socket.getOutputStream());\r\n                return true;\r\n            }\r\n            catch (IOException e)\r\n            {\r\n                socket = null;\r\n                if (logger.isTraceEnabled())\r\n                    logger.trace(\"unable to connect to \" + endpoint, e);\r\n                try\r\n                {\r\n                    Thread.sleep(OPEN_RETRY_DELAY);\r\n                }\r\n                catch (InterruptedException e1)\r\n                {\r\n                    throw new AssertionError(e1);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":72882,"modified_method":"private boolean connect()\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"attempting to connect to \" + endpoint);\n        long start = System.currentTimeMillis();\n        while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout())\n        {\n            try\n            {\n                // zero means 'bind on any available port.'\n                socket = new Socket(endpoint, DatabaseDescriptor.getStoragePort(), FBUtilities.getLocalAddress(), 0);\n                socket.setTcpNoDelay(true);\n                output = new DataOutputStream(socket.getOutputStream());\n                return true;\n            }\n            catch (IOException e)\n            {\n                socket = null;\n                if (logger.isTraceEnabled())\n                    logger.trace(\"unable to connect to \" + endpoint, e);\n                try\n                {\n                    Thread.sleep(OPEN_RETRY_DELAY);\n                }\n                catch (InterruptedException e1)\n                {\n                    throw new AssertionError(e1);\n                }\n            }\n        }\n        return false;\n    }","commit_id":"1fec6d186b5bfb11dc3d2384c59506af3f81396c","url":"https://github.com/apache/cassandra"},{"original_method":"protected void div(float N) {\n      for (float[] weight : weights) Utils.div(weight, N);\n      for (float[] bias : biases) Utils.div(bias, N);\n      if (has_momenta()) {\n        for (float[] weight_momenta : weights_momenta) Utils.div(weight_momenta, N);\n        for (float[] bias_momenta : biases_momenta) Utils.div(bias_momenta, N);\n      }\n      if (adaDelta()) {\n        for (float[] dx2 : E_dx2) Utils.div(dx2, (float) N);\n        for (float[] g2 : E_g2) Utils.div(g2, (float) N);\n      }\n    }","id":72883,"modified_method":"protected void div(float N) {\n      for (float[] weight : weights) Utils.div(weight, N);\n      for (float[] bias : biases) Utils.div(bias, N);\n      if (has_momenta()) {\n        for (float[] weight_momenta : weights_momenta) Utils.div(weight_momenta, N);\n        for (float[] bias_momenta : biases_momenta) Utils.div(bias_momenta, N);\n      }\n      if (adaDelta()) {\n        for (float[] dx2 : ada) Utils.div(dx2, N);\n      }\n    }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void computeStats() {\n      float[][] rate = parameters.adaptive_rate ? new float[units.length-1][] : null;\n      for( int y = 1; y < units.length; y++ ) {\n        mean_rate[y] = rms_rate[y] = 0;\n        mean_bias[y] = rms_bias[y] = 0;\n        mean_weight[y] = rms_weight[y] = 0;\n        for(int u = 0; u < biases[y-1].length; u++) {\n          mean_bias[y] += biases[y-1][u];\n        }\n        if (rate != null) rate[y-1] = new float[weights[y-1].length];\n        for(int u = 0; u < weights[y-1].length; u++) {\n          mean_weight[y] += weights[y-1][u];\n          if (rate != null) {\n            final double RMS_dx = Math.sqrt(E_dx2[y-1][u]+parameters.epsilon);\n            final double RMS_g = Math.sqrt(E_g2[y-1][u]+parameters.epsilon);\n            rate[y-1][u] = (float)(RMS_dx/RMS_g); //not exactly right, RMS_dx should be from the previous time step -> but close enough for diagnostics.\n            mean_rate[y] += rate[y-1][u];\n          }\n        }\n        mean_bias[y] /= biases[y-1].length;\n        mean_weight[y] /= weights[y-1].length;\n        if (rate != null) mean_rate[y] /= rate[y-1].length;\n\n        for(int u = 0; u < biases[y-1].length; u++) {\n          final double db = biases[y-1][u] - mean_bias[y];\n          rms_bias[y] += db * db;\n        }\n        for(int u = 0; u < weights[y-1].length; u++) {\n          final double dw = weights[y-1][u] - mean_weight[y];\n          rms_weight[y] += dw * dw;\n          if (rate != null) {\n            final double drate = rate[y-1][u] - mean_rate[y];\n            rms_rate[y] += drate * drate;\n          }\n        }\n        rms_bias[y] = (float)Math.sqrt(rms_bias[y]/biases[y-1].length);\n        rms_weight[y] = (float)Math.sqrt(rms_weight[y]/weights[y-1].length);\n        if (rate != null) rms_rate[y] = (float)Math.sqrt(rms_rate[y]/rate[y-1].length);\n\n        unstable |= isNaN(mean_bias[y])  || isNaN(rms_bias[y])\n                || isNaN(mean_weight[y]) || isNaN(rms_weight[y]);\n\n        // Abort the run if weights or biases are unreasonably large (Note that all input values are normalized upfront)\n        // This can happen with Rectifier units when L1/L2/max_w2 are all set to 0, especially when using more than 1 hidden layer.\n        final double thresh = 1e10;\n        unstable |= mean_bias[y] > thresh  || isNaN(mean_bias[y])\n                || rms_bias[y] > thresh    || isNaN(rms_bias[y])\n                || mean_weight[y] > thresh || isNaN(mean_weight[y])\n                || rms_weight[y] > thresh  || isNaN(rms_weight[y]);\n      }\n    }","id":72884,"modified_method":"public void computeStats() {\n      float[][] rate = parameters.adaptive_rate ? new float[units.length-1][] : null;\n      for( int y = 1; y < units.length; y++ ) {\n        mean_rate[y] = rms_rate[y] = 0;\n        mean_bias[y] = rms_bias[y] = 0;\n        mean_weight[y] = rms_weight[y] = 0;\n        for(int u = 0; u < biases[y-1].length; u++) {\n          mean_bias[y] += biases[y-1][u];\n        }\n        if (rate != null) rate[y-1] = new float[weights[y-1].length];\n        for(int u = 0; u < weights[y-1].length; u++) {\n          mean_weight[y] += weights[y-1][u];\n          if (rate != null) {\n//            final float RMS_dx = (float)Math.sqrt(ada[y-1][2*u]+(float)parameters.epsilon);\n//            final float invRMS_g = (float)(1/Math.sqrt(ada[y-1][2*u+1]+(float)parameters.epsilon));\n            final float RMS_dx = Utils.approxSqrt(ada[y-1][2*u]+(float)parameters.epsilon);\n            final float invRMS_g = Utils.approxInvSqrt(ada[y-1][2*u+1]+(float)parameters.epsilon);\n            rate[y-1][u] = RMS_dx*invRMS_g; //not exactly right, RMS_dx should be from the previous time step -> but close enough for diagnostics.\n            mean_rate[y] += rate[y-1][u];\n          }\n        }\n        mean_bias[y] /= biases[y-1].length;\n        mean_weight[y] /= weights[y-1].length;\n        if (rate != null) mean_rate[y] /= rate[y-1].length;\n\n        for(int u = 0; u < biases[y-1].length; u++) {\n          final double db = biases[y-1][u] - mean_bias[y];\n          rms_bias[y] += db * db;\n        }\n        for(int u = 0; u < weights[y-1].length; u++) {\n          final double dw = weights[y-1][u] - mean_weight[y];\n          rms_weight[y] += dw * dw;\n          if (rate != null) {\n            final double drate = rate[y-1][u] - mean_rate[y];\n            rms_rate[y] += drate * drate;\n          }\n        }\n        rms_bias[y] = Utils.approxSqrt(rms_bias[y]/biases[y-1].length);\n        rms_weight[y] = Utils.approxSqrt(rms_weight[y]/weights[y-1].length);\n        if (rate != null) rms_rate[y] = Utils.approxSqrt(rms_rate[y]/rate[y-1].length);\n//        rms_bias[y] = (float)Math.sqrt(rms_bias[y]/biases[y-1].length);\n//        rms_weight[y] = (float)Math.sqrt(rms_weight[y]/weights[y-1].length);\n//        if (rate != null) rms_rate[y] = (float)Math.sqrt(rms_rate[y]/rate[y-1].length);\n\n        unstable |= isNaN(mean_bias[y])  || isNaN(rms_bias[y])\n                || isNaN(mean_weight[y]) || isNaN(rms_weight[y]);\n\n        // Abort the run if weights or biases are unreasonably large (Note that all input values are normalized upfront)\n        // This can happen with Rectifier units when L1/L2/max_w2 are all set to 0, especially when using more than 1 hidden layer.\n        final double thresh = 1e10;\n        unstable |= mean_bias[y] > thresh  || isNaN(mean_bias[y])\n                || rms_bias[y] > thresh    || isNaN(rms_bias[y])\n                || mean_weight[y] > thresh || isNaN(mean_weight[y])\n                || rms_weight[y] > thresh  || isNaN(rms_weight[y]);\n      }\n    }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public final float[] get_E_g2(int i) { return E_g2[i]; }","id":72885,"modified_method":"public final float[] get_ada(int i) { return ada[i]; }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"void fillHelpers() {\n      if (has_momenta()) {\n        if (weights_momenta != null) return;\n        weights_momenta = new float[weights.length][];\n        for (int i=0; i<weights_momenta.length; ++i) weights_momenta[i] = new float[units[i]*units[i+1]];\n        biases_momenta = new float[biases.length][];\n        for (int i=0; i<biases_momenta.length; ++i) biases_momenta[i] = new float[units[i+1]];\n      }\n      else if (adaDelta()) {\n        //AdaGrad\n        if (E_dx2 != null) return;\n        E_dx2 = new float[weights.length][];\n        for (int i=0; i<E_dx2.length; ++i) E_dx2[i] = new float[units[i]*units[i+1]];\n        E_g2 = new float[weights.length][];\n        for (int i=0; i<E_g2.length; ++i) E_g2[i] = new float[units[i]*units[i+1]];\n      }\n    }","id":72886,"modified_method":"void fillHelpers() {\n      if (has_momenta()) {\n        if (weights_momenta != null) return;\n        weights_momenta = new float[weights.length][];\n        for (int i=0; i<weights_momenta.length; ++i) weights_momenta[i] = new float[units[i]*units[i+1]];\n        biases_momenta = new float[biases.length][];\n        for (int i=0; i<biases_momenta.length; ++i) biases_momenta[i] = new float[units[i+1]];\n      }\n      else if (adaDelta()) {\n        //AdaGrad\n        if (ada != null) return;\n        ada = new float[weights.length][];\n        for (int i=0; i<ada.length; ++i) ada[i] = new float[2*units[i]*units[i+1]];\n      }\n    }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"void randomizeWeights() {\n      for (int i=0; i<weights.length; ++i) {\n        final Random rng = water.util.Utils.getDeterRNG(get_params().seed + 0xBAD5EED + i+1); //to match NeuralNet behavior\n        for( int j = 0; j < weights[i].length; j++ ) {\n          if (parameters.initial_weight_distribution == DeepLearning.InitialWeightDistribution.UniformAdaptive) {\n            // cf. http://machinelearning.wustl.edu/mlpapers/paper_files/AISTATS2010_GlorotB10.pdf\n            final double range = Math.sqrt(6. / (units[i] + units[i+1]));\n            weights[i][j] = (float)uniformDist(rng, -range, range);\n            if (i==weights.length-1 && parameters.classification) weights[i][j] *= 4; //Softmax might need an extra factor 4, since it's like a sigmoid\n          }\n          else if (parameters.initial_weight_distribution == DeepLearning.InitialWeightDistribution.Uniform) {\n            weights[i][j] = (float)uniformDist(rng, -parameters.initial_weight_scale, parameters.initial_weight_scale);\n          }\n          else if (parameters.initial_weight_distribution == DeepLearning.InitialWeightDistribution.Normal) {\n            weights[i][j] = (float)(rng.nextGaussian() * parameters.initial_weight_scale);\n          }\n        }\n      }\n    }","id":72887,"modified_method":"void randomizeWeights() {\n      for (int i=0; i<weights.length; ++i) {\n        final Random rng = water.util.Utils.getDeterRNG(get_params().seed + 0xBAD5EED + i+1); //to match NeuralNet behavior\n        final double range = Math.sqrt(6. / (units[i] + units[i+1]));\n        for( int j = 0; j < weights[i].length; j++ ) {\n          if (parameters.initial_weight_distribution == DeepLearning.InitialWeightDistribution.UniformAdaptive) {\n            // cf. http://machinelearning.wustl.edu/mlpapers/paper_files/AISTATS2010_GlorotB10.pdf\n            weights[i][j] = (float)uniformDist(rng, -range, range);\n            if (i==weights.length-1 && parameters.classification) weights[i][j] *= 4; //Softmax might need an extra factor 4, since it's like a sigmoid\n          }\n          else if (parameters.initial_weight_distribution == DeepLearning.InitialWeightDistribution.Uniform) {\n            weights[i][j] = (float)uniformDist(rng, -parameters.initial_weight_scale, parameters.initial_weight_scale);\n          }\n          else if (parameters.initial_weight_distribution == DeepLearning.InitialWeightDistribution.Normal) {\n            weights[i][j] = (float)(rng.nextGaussian() * parameters.initial_weight_scale);\n          }\n        }\n      }\n    }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void add(DeepLearningModelInfo other) {\n      Utils.add(weights, other.weights);\n      Utils.add(biases,  other.biases);\n      if (has_momenta()) {\n        assert(other.has_momenta());\n        Utils.add(weights_momenta, other.weights_momenta);\n        Utils.add(biases_momenta,  other.biases_momenta);\n      }\n      if (adaDelta()) {\n        assert(other.adaDelta());\n        Utils.add(E_dx2, other.E_dx2);\n        Utils.add(E_g2,  other.E_g2);\n      }\n      add_processed_local(other.get_processed_local());\n    }","id":72888,"modified_method":"public void add(DeepLearningModelInfo other) {\n      Utils.add(weights, other.weights);\n      Utils.add(biases,  other.biases);\n      if (has_momenta()) {\n        assert(other.has_momenta());\n        Utils.add(weights_momenta, other.weights_momenta);\n        Utils.add(biases_momenta,  other.biases_momenta);\n      }\n      if (adaDelta()) {\n        assert(other.adaDelta());\n        Utils.add(ada, other.ada);\n      }\n      add_processed_local(other.get_processed_local());\n    }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Initialization of the parameters and connectivity of a Neuron layer\n   * @param neurons Array of all neuron layers, to establish feed-forward connectivity\n   * @param index Which layer am I?\n   * @param p User-given parameters (Job parental object hierarchy is not used)\n   * @param minfo Model information (weights/biases and their momenta)\n   * @param training Whether training is done or just testing (no need for dropout)\n   */\n  public final void init(Neurons[] neurons, int index, DeepLearning p, final DeepLearningModel.DeepLearningModelInfo minfo, boolean training) {\n    params = (DeepLearning)p.clone();\n    params.rate *= Math.pow(params.rate_decay, index-1);\n    _a = new float[units];\n    if (!(this instanceof Output) && !(this instanceof Input)) {\n      _e = new float[units];\n    }\n    if (training && (this instanceof MaxoutDropout || this instanceof TanhDropout\n            || this instanceof RectifierDropout || this instanceof Input) ) {\n      _dropout = new Dropout(units);\n    }\n    if (!(this instanceof Input)) {\n      _previous = neurons[index-1]; //incoming neurons\n      _minfo = minfo;\n      _w = minfo.get_weights(index-1); //incoming weights\n      _b = minfo.get_biases(index-1); //bias for this layer (starting at hidden layer)\n      if (minfo.has_momenta()) {\n        _wm = minfo.get_weights_momenta(index-1); //incoming weights\n        _bm = minfo.get_biases_momenta(index-1); //bias for this layer (starting at hidden layer)\n      }\n      if (minfo.adaDelta()) {\n        _E_dx2 = minfo.get_E_dx2(index-1);\n        _E_g2 = minfo.get_E_g2(index - 1);\n      }\n    }\n    sanityCheck(training);\n  }","id":72889,"modified_method":"/**\n   * Initialization of the parameters and connectivity of a Neuron layer\n   * @param neurons Array of all neuron layers, to establish feed-forward connectivity\n   * @param index Which layer am I?\n   * @param p User-given parameters (Job parental object hierarchy is not used)\n   * @param minfo Model information (weights/biases and their momenta)\n   * @param training Whether training is done or just testing (no need for dropout)\n   */\n  public final void init(Neurons[] neurons, int index, DeepLearning p, final DeepLearningModel.DeepLearningModelInfo minfo, boolean training) {\n    params = (DeepLearning)p.clone();\n    params.rate *= Math.pow(params.rate_decay, index-1);\n    _a = new float[units];\n    if (!(this instanceof Output) && !(this instanceof Input)) {\n      _e = new float[units];\n    }\n    if (training && (this instanceof MaxoutDropout || this instanceof TanhDropout\n            || this instanceof RectifierDropout || this instanceof Input) ) {\n      _dropout = new Dropout(units);\n    }\n    if (!(this instanceof Input)) {\n      _previous = neurons[index-1]; //incoming neurons\n      _minfo = minfo;\n      _w = minfo.get_weights(index-1); //incoming weights\n      _b = minfo.get_biases(index-1); //bias for this layer (starting at hidden layer)\n      if (minfo.has_momenta()) {\n        _wm = minfo.get_weights_momenta(index-1); //incoming weights\n        _bm = minfo.get_biases_momenta(index-1); //bias for this layer (starting at hidden layer)\n      }\n      if (minfo.adaDelta()) {\n        _ada = minfo.get_ada(index-1);\n      }\n    }\n    sanityCheck(training);\n  }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Backpropagation: w -= rate * dE/dw, where dE/dw = dE/dy * dy/dnet * dnet/dw\n   * This method adds the dnet/dw = activation term per unit\n   * @param u unit (which neuron)\n   * @param g partial derivative dE/dnet = dE/dy * dy/net\n   * @param r rate\n   * @param m momentum\n   */\n  final void bprop(int u, float g, float r, float m) {\n    // only correct weights if the gradient is large enough\n    if (params.fast_mode || (\n            // not doing fast mode, but also don't have anything else to update (neither momentum nor ADADELTA history), and no L1/L2\n            !_minfo.get_params().adaptive_rate && !_minfo.has_momenta() && params.l1 == 0.0 && params.l2 == 0.0)) {\n      if (Math.abs(g) <= 1e-10) return;\n    }\n\n//    Log.info(\"bprop(u=\" + u + \", g=\" + g + \", r=\" + r + \", m=\" + m);\n    double r2 = 0;\n    final float rho = (float)params.rho;\n    final float eps = (float)params.epsilon;\n    final int off = u * _previous._a.length;\n    for( int i = 0; i < _previous._a.length; i++ ) {\n      int w = off + i;\n      // propagate the error dE/dnet to the previous layer, via connecting weights\n      if( _previous._e != null ) _previous._e[i] += g * _w[w];\n\n      //this is the actual gradient dE/dw\n      float grad = g * _previous._a[i] - (float)(_w[w] * params.l2) - (float)(Math.signum(_w[w]) * params.l1);\n\n      // adaptive learning rate r from ADADELTA\n      // http://www.matthewzeiler.com/pubs/googleTR2012/googleTR2012.pdf\n      if (_E_dx2 != null && _E_g2 != null) {\n        assert(_wm == null && _bm == null);\n        final float grad2 = grad*grad;\n        _E_g2[w] *= rho;\n        _E_g2[w] += (1f-rho)*grad2;\n        final float RMS_dx = approxSqrt(_E_dx2[w] + eps);\n        final float invRMS_g = approxInvSqrt(_E_g2[w] + eps);\n        r = RMS_dx*invRMS_g;\n        _E_dx2[w] = rho * _E_dx2[w] + (1f-rho)*r*r*grad2;\n      }\n\n      // TODO finish per-weight acceleration, doesn't help for now\n//        if( _wp != null && d != 0 ) {\n//          boolean sign = _wp[w] >= 0;\n//          double mult = Math.abs(_wp[w]);\n//          // If the gradient kept its sign, increase\n//          if( (d >= 0) == sign )\n//            mult += .05f;\n//          else {\n//            if( mult > 1 )\n//              mult *= .95f;\n//            else\n//              sign = !sign;\n//          }\n//          d *= mult;\n//          _wp[w] = sign ? mult : -mult;\n//        }\n\n      if (!params.nesterov_accelerated_gradient) {\n        final float delta = r * grad;\n        _w[w] += delta;\n        if( _wm != null ) {\n          _w[w] += m * _wm[w];\n          _wm[w] = delta;\n        }\n      } else {\n        if( _wm != null ) {\n          _wm[w] *= m;\n          _wm[w] += grad;\n          grad = _wm[w];\n        }\n        _w[w] += r * grad;\n//        Log.info(\"w[\" + w + \"] += \" + r + \" * \" + d + \" = \" + _w[w]);\n      }\n      if (params.max_w2 != Double.POSITIVE_INFINITY)\n        r2 += _w[w] * _w[w];\n    }\n    if( params.max_w2 != Double.POSITIVE_INFINITY && r2 > params.max_w2 ) { // C.f. Improving neural networks by preventing co-adaptation of feature detectors\n      final double scale = approxSqrt((float)(params.max_w2 / r2));\n      for( int i = 0; i < _previous._a.length; i++ ) _w[off + i] *= scale;\n    }\n\n    if (!params.nesterov_accelerated_gradient) {\n      final float delta = r * g;\n      _b[u] += delta;\n      if( _bm != null ) {\n        _b[u] += m * _bm[u];\n        _bm[u] = delta;\n      }\n    } else {\n      float d = g;\n      if( _bm != null ) {\n        _bm[u] *= m;\n        _bm[u] += d;\n        d = _bm[u];\n      }\n      _b[u] += r * d;\n    }\n    if (Float.isInfinite(_b[u])) _minfo.set_unstable();\n  }","id":72890,"modified_method":"/**\n   * Backpropagation: w -= rate * dE/dw, where dE/dw = dE/dy * dy/dnet * dnet/dw\n   * This method adds the dnet/dw = activation term per unit\n   * @param u unit (which neuron)\n   * @param g partial derivative dE/dnet = dE/dy * dy/net\n   * @param r rate\n   * @param m momentum\n   */\n  final void bprop(int u, float g, float r, float m) {\n    // only correct weights if the gradient is large enough\n    if (params.fast_mode || (\n            // not doing fast mode, but also don't have anything else to update (neither momentum nor ADADELTA history), and no L1/L2\n            !_minfo.get_params().adaptive_rate && !_minfo.has_momenta() && params.l1 == 0.0 && params.l2 == 0.0)) {\n      if (Math.abs(g) <= 1e-10) return;\n    }\n\n//    Log.info(\"bprop(u=\" + u + \", g=\" + g + \", r=\" + r + \", m=\" + m);\n    double r2 = 0;\n    final float rho = (float)params.rho;\n    final float eps = (float)params.epsilon;\n    final int off = u * _previous._a.length;\n    for( int i = 0; i < _previous._a.length; i++ ) {\n      int w = off + i;\n      // propagate the error dE/dnet to the previous layer, via connecting weights\n      if( _previous._e != null ) _previous._e[i] += g * _w[w];\n\n      //this is the actual gradient dE/dw\n      float grad = g * _previous._a[i] - (float)(_w[w] * params.l2) - (float)(Math.signum(_w[w]) * params.l1);\n\n      // adaptive learning rate r from ADADELTA\n      // http://www.matthewzeiler.com/pubs/googleTR2012/googleTR2012.pdf\n      if (_ada != null) {\n        assert(_wm == null && _bm == null);\n        final float grad2 = grad*grad;\n        _ada[2*w+1] *= rho;\n        _ada[2*w+1] += (1f-rho)*grad2;\n        final float RMS_dx = Utils.approxSqrt(_ada[2*w] + eps);\n        final float invRMS_g = Utils.approxInvSqrt(_ada[2*w+1] + eps);\n        r = RMS_dx*invRMS_g;\n        _ada[2*w] = rho * _ada[2*w] + (1f-rho)*r*r*grad2;\n      }\n      if (!params.nesterov_accelerated_gradient) {\n        final float delta = r * grad;\n        _w[w] += delta;\n        if( _wm != null ) {\n          _w[w] += m * _wm[w];\n          _wm[w] = delta;\n        }\n      } else {\n        if( _wm != null ) {\n          _wm[w] *= m;\n          _wm[w] += grad;\n          grad = _wm[w];\n        }\n        _w[w] += r * grad;\n//        Log.info(\"w[\" + w + \"] += \" + r + \" * \" + d + \" = \" + _w[w]);\n      }\n      if (params.max_w2 != Double.POSITIVE_INFINITY)\n        r2 += _w[w] * _w[w];\n    }\n    if( params.max_w2 != Double.POSITIVE_INFINITY && r2 > params.max_w2 ) { // C.f. Improving neural networks by preventing co-adaptation of feature detectors\n      final double scale = Utils.approxSqrt((float)(params.max_w2 / r2));\n      for( int i = 0; i < _previous._a.length; i++ ) _w[off + i] *= scale;\n    }\n\n    if (!params.nesterov_accelerated_gradient) {\n      final float delta = r * g;\n      _b[u] += delta;\n      if( _bm != null ) {\n        _b[u] += m * _bm[u];\n        _bm[u] = delta;\n      }\n    } else {\n      float d = g;\n      if( _bm != null ) {\n        _bm[u] *= m;\n        _bm[u] += d;\n        d = _bm[u];\n      }\n      _b[u] += r * d;\n    }\n    if (Float.isInfinite(_b[u])) _minfo.set_unstable();\n  }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Helper to check sanity of Neuron layers\n   * @param training whether training or testing is done\n   */\n  void sanityCheck(boolean training) {\n    if (this instanceof Input) {\n      assert(_previous == null);\n      assert (!training || _dropout != null);\n    } else {\n      assert(_previous != null);\n      if (_minfo.has_momenta()) {\n        assert(_wm != null);\n        assert(_bm != null);\n        assert(_E_dx2 == null);\n        assert(_E_g2 == null);\n      }\n      if (_minfo.adaDelta()) {\n        if (params.rho == 0) throw new IllegalArgumentException(\"rho must be > 0 if epsilon is >0.\");\n        if (params.epsilon == 0) throw new IllegalArgumentException(\"epsilon must be > 0 if rho is >0.\");\n        assert(_minfo.adaDelta());\n        assert(_E_dx2 != null);\n        assert(_E_g2 != null);\n        assert(_wm == null);\n        assert(_bm == null);\n      }\n      if (this instanceof MaxoutDropout || this instanceof TanhDropout || this instanceof RectifierDropout) {\n        assert (!training || _dropout != null);\n      }\n    }\n  }","id":72891,"modified_method":"/**\n   * Helper to check sanity of Neuron layers\n   * @param training whether training or testing is done\n   */\n  void sanityCheck(boolean training) {\n    if (this instanceof Input) {\n      assert(_previous == null);\n      assert (!training || _dropout != null);\n    } else {\n      assert(_previous != null);\n      if (_minfo.has_momenta()) {\n        assert(_wm != null);\n        assert(_bm != null);\n        assert(_ada == null);\n      }\n      if (_minfo.adaDelta()) {\n        if (params.rho == 0) throw new IllegalArgumentException(\"rho must be > 0 if epsilon is >0.\");\n        if (params.epsilon == 0) throw new IllegalArgumentException(\"epsilon must be > 0 if rho is >0.\");\n        assert(_minfo.adaDelta());\n        assert(_ada != null);\n        assert(_wm == null);\n        assert(_bm == null);\n      }\n      if (this instanceof MaxoutDropout || this instanceof TanhDropout || this instanceof RectifierDropout) {\n        assert (!training || _dropout != null);\n      }\n    }\n  }","commit_id":"794b6b22fc8bf6ae2932a35b861f5fe1849328aa","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void createDependency(TachyonFS tachyonClient) throws IOException {\n    long startTimeMs = CommonUtils.getCurrentMs();\n    List<String> children = new ArrayList<String>();\n    for (int k = 0; k < mNumFiles; k ++) {\n      children.add(mFileFolder + \"/part-\" + k);\n    }\n    List<ByteBuffer> data = new ArrayList<ByteBuffer>();\n    data.add(ByteBuffer.allocate(10));\n    int depId =\n        tachyonClient.createDependency(new ArrayList<String>(), children, \"fake command\", data,\n            \"BasicCheckpoint Dependency\", \"Tachyon Examples\", \"0.3\",\n            DependencyType.Narrow.getValue(), 512 * Constants.MB);\n\n    FormatUtils.printTimeTakenMs(startTimeMs, LOG, \"createDependency with depId \" + depId);\n  }","id":72892,"modified_method":"private void createDependency(TachyonFS tachyonClient) throws IOException {\n    long startTimeMs = CommonUtils.getCurrentMs();\n    List<String> children = new ArrayList<String>();\n    for (int k = 0; k < mNumFiles; k ++) {\n      children.add(mFileFolder + \"/part-\" + k);\n    }\n    List<ByteBuffer> data = new ArrayList<ByteBuffer>();\n    data.add(ByteBuffer.allocate(10));\n    int depId =\n        tachyonClient.createDependency(new ArrayList<String>(), children, \"fake command\", data,\n            \"BasicCheckpoint Dependency\", \"Tachyon Examples\", \"0.3\",\n            DependencyType.Narrow.getValue(), 512 * Constants.MB);\n\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"createDependency with depId \" + depId));\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"private void writeFile(TachyonFS tachyonClient) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(mNumbers * 4);\n    buf.order(ByteOrder.nativeOrder());\n    for (int k = 0; k < mNumbers; k ++) {\n      buf.putInt(k);\n    }\n\n    buf.flip();\n    LOG.debug(\"Writing data...\");\n    buf.flip();\n\n    long startTimeMs = CommonUtils.getCurrentMs();\n    TachyonFile file = tachyonClient.getFile(mFilePath);\n    OutStream os = file.getOutStream(mWriteType);\n    os.write(buf.array());\n    os.close();\n\n    FormatUtils.printTimeTakenMs(startTimeMs, LOG, \"writeFile to file \" + mFilePath);\n  }","id":72893,"modified_method":"private void writeFile(TachyonFS tachyonClient) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(mNumbers * 4);\n    buf.order(ByteOrder.nativeOrder());\n    for (int k = 0; k < mNumbers; k ++) {\n      buf.putInt(k);\n    }\n\n    buf.flip();\n    LOG.debug(\"Writing data...\");\n    buf.flip();\n\n    long startTimeMs = CommonUtils.getCurrentMs();\n    TachyonFile file = tachyonClient.getFile(mFilePath);\n    OutStream os = file.getOutStream(mWriteType);\n    os.write(buf.array());\n    os.close();\n\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"writeFile to file \" + mFilePath));\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"private void createFile(TachyonFS tachyonClient) throws IOException {\n    LOG.debug(\"Creating file...\");\n    long startTimeMs = CommonUtils.getCurrentMs();\n    int fileId = tachyonClient.createFile(mFilePath);\n    FormatUtils.printTimeTakenMs(startTimeMs, LOG, \"createFile with fileId \" + fileId);\n  }","id":72894,"modified_method":"private void createFile(TachyonFS tachyonClient) throws IOException {\n    LOG.debug(\"Creating file...\");\n    long startTimeMs = CommonUtils.getCurrentMs();\n    int fileId = tachyonClient.createFile(mFilePath);\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"createFile with fileId \" + fileId));\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean readFile(TachyonFS tachyonClient) throws IOException {\n    boolean pass = true;\n    LOG.debug(\"Reading data...\");\n\n    final long startTimeMs = CommonUtils.getCurrentMs();\n    TachyonFile file = tachyonClient.getFile(mFilePath);\n    TachyonByteBuffer buf = file.readByteBuffer(0);\n    if (buf == null) {\n      file.recache();\n      buf = file.readByteBuffer(0);\n    }\n    buf.mData.order(ByteOrder.nativeOrder());\n    for (int k = 0; k < mNumbers; k ++) {\n      pass = pass && (buf.mData.getInt() == k);\n    }\n    buf.close();\n\n    FormatUtils.printTimeTakenMs(startTimeMs, LOG, \"readFile file \" + mFilePath);\n    return pass;\n  }","id":72895,"modified_method":"private boolean readFile(TachyonFS tachyonClient) throws IOException {\n    boolean pass = true;\n    LOG.debug(\"Reading data...\");\n\n    final long startTimeMs = CommonUtils.getCurrentMs();\n    TachyonFile file = tachyonClient.getFile(mFilePath);\n    TachyonByteBuffer buf = file.readByteBuffer(0);\n    if (buf == null) {\n      file.recache();\n      buf = file.readByteBuffer(0);\n    }\n    buf.mData.order(ByteOrder.nativeOrder());\n    for (int k = 0; k < mNumbers; k ++) {\n      pass = pass && (buf.mData.getInt() == k);\n    }\n    buf.close();\n\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"readFile file \" + mFilePath));\n    return pass;\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"public static void printTimeTakenMs(long startTimeMs, Logger logger, String message) {\n    logger.info(message + \" took \" + (CommonUtils.getCurrentMs() - startTimeMs) + \" ms.\");\n  }","id":72896,"modified_method":"public static String formatTimeTakenMs(long startTimeMs, String message) {\n    return message + \" took \" + (CommonUtils.getCurrentMs() - startTimeMs) + \" ms.\";\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"public static void printTimeTakenNs(long startTimeNs, Logger logger, String message) {\n    logger.info(message + \" took \" + (System.nanoTime() - startTimeNs) + \" ns.\");\n  }","id":72897,"modified_method":"public static String formatTimeTakenNs(long startTimeNs, String message) {\n    return message + \" took \" + (System.nanoTime() - startTimeNs) + \" ns.\";\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"public static String parametersToString(Object... objs) {\n    StringBuilder sb = new StringBuilder(\"(\");\n    for (int k = 0; k < objs.length; k ++) {\n      if (k != 0) {\n        sb.append(\", \");\n      }\n      sb.append(objs[k].toString());\n    }\n    sb.append(\")\");\n    return sb.toString();\n  }","id":72898,"modified_method":"public static String parametersToString(Object... objs) {\n    StringBuilder sb = new StringBuilder(\"(\");\n    for (Object obj : objs) {\n      if (sb.length() != 1) {\n        sb.append(\", \");\n      }\n      sb.append(obj.toString());\n    }\n    sb.append(\")\");\n    return sb.toString();\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Return a human-readable version of bytes 10GB 2048KB etc.\n   *\n   * @param bytes the number of bytes\n   * @return human readable version\n   */\n  public static String getSizeFromBytes(long bytes) {\n    double ret = bytes;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f B\", ret);\n    }\n    ret /= 1024;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f KB\", ret);\n    }\n    ret /= 1024;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f MB\", ret);\n    }\n    ret /= 1024;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f GB\", ret);\n    }\n    ret /= 1024;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f TB\", ret);\n    }\n    return String.format(\"%.2f PB\", ret);\n  }","id":72899,"modified_method":"/**\n   * Return a human-readable version of bytes 10GB 2048KB etc.\n   *\n   * @param bytes the number of bytes\n   * @return human readable version\n   */\n  public static String getSizeFromBytes(long bytes) {\n    double ret = bytes;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f B\", ret);\n    }\n    ret /= 1024;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f KB\", ret);\n    }\n    ret /= 1024;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f MB\", ret);\n    }\n    ret /= 1024;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f GB\", ret);\n    }\n    ret /= 1024;\n    if (ret <= 1024 * 5) {\n      return String.format(\"%.2f TB\", ret);\n    }\n    ret /= 1024;\n    return String.format(\"%.2f PB\", ret);\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"public void readPartition() throws IOException {\n      TachyonByteBuffer buf;\n      if (sDebugMode) {\n        LOG.info(\"Verifying the reading data...\");\n\n        for (int pId = mLeft; pId < mRight; pId ++) {\n          TachyonFile file = mTC.getFile(new TachyonURI(sFileName + (pId + sBaseFileNumber)));\n          buf = file.readByteBuffer(0);\n          IntBuffer intBuf;\n          intBuf = buf.mData.order(ByteOrder.nativeOrder()).asIntBuffer();\n          for (int i = 0; i < sBlocksPerFile; i ++) {\n            for (int k = 0; k < sBlockSizeBytes / 4; k ++) {\n              int tmp = intBuf.get();\n              if ((k == 0 && tmp == (i + mWorkerId)) || (k != 0 && tmp == k)) {\n                LOG.debug(\"Partition at {} is {}\", k, tmp);\n              } else {\n                throw new IllegalStateException(\"WHAT? \" + tmp + \" \" + k);\n              }\n            }\n          }\n          buf.close();\n        }\n      }\n\n      long sum = 0;\n      if (sTachyonStreamingRead) {\n        for (int pId = mLeft; pId < mRight; pId ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          TachyonFile file = mTC.getFile(new TachyonURI(sFileName + (pId + sBaseFileNumber)));\n          InputStream is = file.getInStream(ReadType.CACHE);\n          long len = sBlocksPerFile * sBlockSizeBytes;\n\n          while (len > 0) {\n            int r = is.read(mBuf.array());\n            len -= r;\n            Preconditions.checkState(r != -1, \"R == -1\");\n          }\n          is.close();\n          logPerIteration(startTimeMs, pId, \"th ReadTachyonFile @ Worker \", pId);\n        }\n      } else {\n        for (int pId = mLeft; pId < mRight; pId ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          TachyonFile file = mTC.getFile(new TachyonURI(sFileName + (pId + sBaseFileNumber)));\n          buf = file.readByteBuffer(0);\n          for (int i = 0; i < sBlocksPerFile; i ++) {\n            buf.mData.get(mBuf.array());\n          }\n          sum += mBuf.get(pId % 16);\n\n          if (sDebugMode) {\n            buf.mData.order(ByteOrder.nativeOrder()).flip();\n            FormatUtils.printByteBuffer(LOG, buf.mData);\n          }\n          buf.mData.clear();\n          logPerIteration(startTimeMs, pId, \"th ReadTachyonFile @ Worker \", pId);\n          buf.close();\n        }\n      }\n      sResults[mWorkerId] = sum;\n    }","id":72900,"modified_method":"public void readPartition() throws IOException {\n      TachyonByteBuffer buf;\n      if (sDebugMode) {\n        LOG.info(\"Verifying the reading data...\");\n\n        for (int pId = mLeft; pId < mRight; pId ++) {\n          TachyonFile file = mTC.getFile(new TachyonURI(sFileName + (pId + sBaseFileNumber)));\n          buf = file.readByteBuffer(0);\n          IntBuffer intBuf;\n          intBuf = buf.mData.order(ByteOrder.nativeOrder()).asIntBuffer();\n          for (int i = 0; i < sBlocksPerFile; i ++) {\n            for (int k = 0; k < sBlockSizeBytes / 4; k ++) {\n              int tmp = intBuf.get();\n              if ((k == 0 && tmp == (i + mWorkerId)) || (k != 0 && tmp == k)) {\n                LOG.debug(\"Partition at {} is {}\", k, tmp);\n              } else {\n                throw new IllegalStateException(\"WHAT? \" + tmp + \" \" + k);\n              }\n            }\n          }\n          buf.close();\n        }\n      }\n\n      long sum = 0;\n      if (sTachyonStreamingRead) {\n        for (int pId = mLeft; pId < mRight; pId ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          TachyonFile file = mTC.getFile(new TachyonURI(sFileName + (pId + sBaseFileNumber)));\n          InputStream is = file.getInStream(ReadType.CACHE);\n          long len = sBlocksPerFile * sBlockSizeBytes;\n\n          while (len > 0) {\n            int r = is.read(mBuf.array());\n            len -= r;\n            Preconditions.checkState(r != -1, \"R == -1\");\n          }\n          is.close();\n          logPerIteration(startTimeMs, pId, \"th ReadTachyonFile @ Worker \", pId);\n        }\n      } else {\n        for (int pId = mLeft; pId < mRight; pId ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          TachyonFile file = mTC.getFile(new TachyonURI(sFileName + (pId + sBaseFileNumber)));\n          buf = file.readByteBuffer(0);\n          for (int i = 0; i < sBlocksPerFile; i ++) {\n            buf.mData.get(mBuf.array());\n          }\n          sum += mBuf.get(pId % 16);\n\n          if (sDebugMode) {\n            buf.mData.order(ByteOrder.nativeOrder()).flip();\n            LOG.info(FormatUtils.byteBufferToString(buf.mData));\n          }\n          buf.mData.clear();\n          logPerIteration(startTimeMs, pId, \"th ReadTachyonFile @ Worker \", pId);\n          buf.close();\n        }\n      }\n      sResults[mWorkerId] = sum;\n    }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"public void writeParition() throws IOException {\n      if (sDebugMode) {\n        mBuf.flip();\n        FormatUtils.printByteBuffer(LOG, mBuf);\n      }\n\n      mBuf.flip();\n      for (int pId = mLeft; pId < mRight; pId ++) {\n        final long startTimeMs = System.currentTimeMillis();\n        TachyonFile file = mTC.getFile(new TachyonURI(sFileName + (pId + sBaseFileNumber)));\n        OutStream os = file.getOutStream(WriteType.MUST_CACHE);\n        for (int k = 0; k < sBlocksPerFile; k ++) {\n          mBuf.putInt(0, k + mWorkerId);\n          os.write(mBuf.array());\n        }\n        os.close();\n        logPerIteration(startTimeMs, pId, \"th WriteTachyonFile @ Worker \", pId);\n      }\n    }","id":72901,"modified_method":"public void writeParition() throws IOException {\n      if (sDebugMode) {\n        mBuf.flip();\n        LOG.info(FormatUtils.byteBufferToString(mBuf));\n      }\n\n      mBuf.flip();\n      for (int pId = mLeft; pId < mRight; pId ++) {\n        final long startTimeMs = System.currentTimeMillis();\n        TachyonFile file = mTC.getFile(new TachyonURI(sFileName + (pId + sBaseFileNumber)));\n        OutStream os = file.getOutStream(WriteType.MUST_CACHE);\n        for (int k = 0; k < sBlocksPerFile; k ++) {\n          mBuf.putInt(0, k + mWorkerId);\n          os.write(mBuf.array());\n        }\n        os.close();\n        logPerIteration(startTimeMs, pId, \"th WriteTachyonFile @ Worker \", pId);\n      }\n    }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"public void memoryCopyParition() throws IOException {\n      if (sDebugMode) {\n        mBuf.flip();\n        FormatUtils.printByteBuffer(LOG, mBuf);\n      }\n      mBuf.flip();\n      long sum = 0;\n      String str = \"th \" + mMsg + \" @ Worker \";\n\n      if (mOneToMany) {\n        ByteBuffer dst = null;\n        RandomAccessFile file = null;\n        if (mMemoryOnly) {\n          dst = ByteBuffer.allocateDirect((int) sFileBytes);\n        }\n        for (int times = mLeft; times < mRight; times ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          if (!mMemoryOnly) {\n            file = new RandomAccessFile(FOLDER + (times + sBaseFileNumber), \"rw\");\n            dst = file.getChannel().map(MapMode.READ_WRITE, 0, sFileBytes);\n          }\n          dst.order(ByteOrder.nativeOrder());\n          for (int k = 0; k < sBlocksPerFile; k ++) {\n            mBuf.putInt(0, k + mWorkerId);\n            dst.put(mBuf.array());\n          }\n          dst.clear();\n          sum += dst.get(times);\n          dst.clear();\n          if (!mMemoryOnly) {\n            file.close();\n          }\n          logPerIteration(startTimeMs, times, str, mWorkerId);\n        }\n      } else {\n        ByteBuffer dst = null;\n        RandomAccessFile file = null;\n        if (mMemoryOnly) {\n          dst = ByteBuffer.allocateDirect((int) sFileBytes);\n        }\n        for (int times = mLeft; times < mRight; times ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          if (!mMemoryOnly) {\n            file = new RandomAccessFile(FOLDER + (times + sBaseFileNumber), \"rw\");\n            dst = file.getChannel().map(MapMode.READ_WRITE, 0, sFileBytes);\n          }\n          dst.order(ByteOrder.nativeOrder());\n          for (int k = 0; k < sBlocksPerFile; k ++) {\n            dst.get(mBuf.array());\n          }\n          sum += mBuf.get(times % 16);\n          dst.clear();\n          if (!mMemoryOnly) {\n            file.close();\n          }\n          logPerIteration(startTimeMs, times, str, mWorkerId);\n        }\n      }\n      sResults[mWorkerId] = sum;\n    }","id":72902,"modified_method":"public void memoryCopyParition() throws IOException {\n      if (sDebugMode) {\n        mBuf.flip();\n        LOG.info(FormatUtils.byteBufferToString(mBuf));\n      }\n      mBuf.flip();\n      long sum = 0;\n      String str = \"th \" + mMsg + \" @ Worker \";\n\n      if (mOneToMany) {\n        ByteBuffer dst = null;\n        RandomAccessFile file = null;\n        if (mMemoryOnly) {\n          dst = ByteBuffer.allocateDirect((int) sFileBytes);\n        }\n        for (int times = mLeft; times < mRight; times ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          if (!mMemoryOnly) {\n            file = new RandomAccessFile(FOLDER + (times + sBaseFileNumber), \"rw\");\n            dst = file.getChannel().map(MapMode.READ_WRITE, 0, sFileBytes);\n          }\n          dst.order(ByteOrder.nativeOrder());\n          for (int k = 0; k < sBlocksPerFile; k ++) {\n            mBuf.putInt(0, k + mWorkerId);\n            dst.put(mBuf.array());\n          }\n          dst.clear();\n          sum += dst.get(times);\n          dst.clear();\n          if (!mMemoryOnly) {\n            file.close();\n          }\n          logPerIteration(startTimeMs, times, str, mWorkerId);\n        }\n      } else {\n        ByteBuffer dst = null;\n        RandomAccessFile file = null;\n        if (mMemoryOnly) {\n          dst = ByteBuffer.allocateDirect((int) sFileBytes);\n        }\n        for (int times = mLeft; times < mRight; times ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          if (!mMemoryOnly) {\n            file = new RandomAccessFile(FOLDER + (times + sBaseFileNumber), \"rw\");\n            dst = file.getChannel().map(MapMode.READ_WRITE, 0, sFileBytes);\n          }\n          dst.order(ByteOrder.nativeOrder());\n          for (int k = 0; k < sBlocksPerFile; k ++) {\n            dst.get(mBuf.array());\n          }\n          sum += mBuf.get(times % 16);\n          dst.clear();\n          if (!mMemoryOnly) {\n            file.close();\n          }\n          logPerIteration(startTimeMs, times, str, mWorkerId);\n        }\n      }\n      sResults[mWorkerId] = sum;\n    }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"public void io() throws IOException {\n      if (sDebugMode) {\n        mBuf.flip();\n        FormatUtils.printByteBuffer(LOG, mBuf);\n      }\n      mBuf.flip();\n      long sum = 0;\n      String str = \"th \" + mMsg + \" @ Worker \";\n\n      if (mWrite) {\n        for (int times = mLeft; times < mRight; times ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          String filePath = sFileName + (times + sBaseFileNumber);\n          OutputStream os = mHdfsFs.create(new Path(filePath));\n          for (int k = 0; k < sBlocksPerFile; k ++) {\n            mBuf.putInt(0, k + mWorkerId);\n            os.write(mBuf.array());\n          }\n          os.close();\n          logPerIteration(startTimeMs, times, str, mWorkerId);\n        }\n      } else {\n        for (int times = mLeft; times < mRight; times ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          String filePath = sFileName + (times + sBaseFileNumber);\n          InputStream is = mHdfsFs.open(new Path(filePath));\n          long len = sBlocksPerFile * sBlockSizeBytes;\n\n          while (len > 0) {\n            int r = is.read(mBuf.array());\n            len -= r;\n            Preconditions.checkState(r != -1, \"R == -1\");\n          }\n          is.close();\n          logPerIteration(startTimeMs, times, str, mWorkerId);\n        }\n      }\n      sResults[mWorkerId] = sum;\n    }","id":72903,"modified_method":"public void io() throws IOException {\n      if (sDebugMode) {\n        mBuf.flip();\n        LOG.info(FormatUtils.byteBufferToString(mBuf));\n      }\n      mBuf.flip();\n      long sum = 0;\n      String str = \"th \" + mMsg + \" @ Worker \";\n\n      if (mWrite) {\n        for (int times = mLeft; times < mRight; times ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          String filePath = sFileName + (times + sBaseFileNumber);\n          OutputStream os = mHdfsFs.create(new Path(filePath));\n          for (int k = 0; k < sBlocksPerFile; k ++) {\n            mBuf.putInt(0, k + mWorkerId);\n            os.write(mBuf.array());\n          }\n          os.close();\n          logPerIteration(startTimeMs, times, str, mWorkerId);\n        }\n      } else {\n        for (int times = mLeft; times < mRight; times ++) {\n          final long startTimeMs = System.currentTimeMillis();\n          String filePath = sFileName + (times + sBaseFileNumber);\n          InputStream is = mHdfsFs.open(new Path(filePath));\n          long len = sBlocksPerFile * sBlockSizeBytes;\n\n          while (len > 0) {\n            int r = is.read(mBuf.array());\n            len -= r;\n            Preconditions.checkState(r != -1, \"R == -1\");\n          }\n          is.close();\n          logPerIteration(startTimeMs, times, str, mWorkerId);\n        }\n      }\n      sResults[mWorkerId] = sum;\n    }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"public static void createFiles() throws IOException {\n    final long startTimeMs = CommonUtils.getCurrentMs();\n    for (int k = 0; k < sFiles; k ++) {\n      int fileId = sMtc.createFile(new TachyonURI(sFileName + (k + sBaseFileNumber)));\n      FormatUtils.printTimeTakenMs(startTimeMs, LOG, \"user_createFiles with fileId \" + fileId);\n    }\n  }","id":72904,"modified_method":"public static void createFiles() throws IOException {\n    final long startTimeMs = CommonUtils.getCurrentMs();\n    for (int k = 0; k < sFiles; k ++) {\n      int fileId = sMtc.createFile(new TachyonURI(sFileName + (k + sBaseFileNumber)));\n      LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs,\n          \"user_createFiles with fileId \" + fileId));\n    }\n  }","commit_id":"7977bd0e710f3dffae1782353ffde40532e2a52d","url":"https://github.com/amplab/tachyon"},{"original_method":"private static void checkMemoryUsage(File file) {\n    final Runtime rt = Runtime.getRuntime();\n    final long allocatedMem = rt.maxMemory();\n    final long unusedMem = rt.freeMemory();\n    if (unusedMem < allocatedMem / 5) {\n      LOG.info(\"High memory usage (free \" + unusedMem / 1024 / 1024 +\n               \" of \" + allocatedMem / 1024 / 1024 +\n               \" MB) while dumping threads to \" + file);\n    }\n  }","id":72905,"modified_method":"private static void checkMemoryUsage(File file) {\n    Runtime rt = Runtime.getRuntime();\n    long maxMemory = rt.maxMemory();\n    long usedMemory = rt.totalMemory() - rt.freeMemory();\n    long freeMemory = maxMemory - usedMemory;\n    if (freeMemory < maxMemory / 5) {\n      LOG.info(\"High memory usage (free \" + freeMemory / 1024 / 1024 +\n               \" of \" + maxMemory / 1024 / 1024 +\n               \" MB) while dumping threads to \" + file);\n    }\n  }","commit_id":"1d157152c12f0b28bf729a241eaa74dc8cebf2cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final LogOffset fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    // If latest logs are not requested, try reading from file.\n    if (fromOffset != LogOffset.LATEST_OFFSET) {\n      long checkpointTime = getCheckpointTime(loggingContext);\n      // Read from file only if logs are saved for the loggingContext until fromTime\n      if (fromOffset.getTime() < checkpointTime) {\n        fileLogReader.getLogPrev(loggingContext, fromOffset, maxEvents, filter, callback);\n        return;\n      }\n    }\n\n    kafkaLogReader.getLogPrev(loggingContext, fromOffset, maxEvents, filter, callback);\n  }","id":72906,"modified_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final ReadRange readRange, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    // If latest logs are not requested, try reading from file.\n    if (readRange != ReadRange.LATEST) {\n      long checkpointTime = getCheckpointTime(loggingContext);\n      // Read from file only if logs are saved for the loggingContext until fromTime\n      if (readRange.getToMillis() < checkpointTime) {\n        fileLogReader.getLogPrev(loggingContext, readRange, maxEvents, filter, callback);\n        return;\n      }\n    }\n\n    kafkaLogReader.getLogPrev(loggingContext, readRange, maxEvents, filter, callback);\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final LogOffset fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    // If latest logs are not requested, try reading from file.\n    if (fromOffset != LogOffset.LATEST_OFFSET) {\n      long checkpointTime = getCheckpointTime(loggingContext);\n      // Read from file only if logs are saved for the loggingContext until fromTime\n      if (fromOffset.getTime() < checkpointTime) {\n        fileLogReader.getLogNext(loggingContext, fromOffset, maxEvents, filter, callback);\n        // If there are events from fileLogReader, return. Otherwise try in kafkaLogReader.\n        if (callback.getCount() != 0) {\n          return;\n        }\n      }\n    }\n\n    kafkaLogReader.getLogNext(loggingContext, fromOffset, maxEvents, filter, callback);\n  }","id":72907,"modified_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final ReadRange readRange, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    // If latest logs are not requested, try reading from file.\n    if (readRange != ReadRange.LATEST) {\n      long checkpointTime = getCheckpointTime(loggingContext);\n      // Read from file only if logs are saved for the loggingContext until fromTime\n      if (readRange.getFromMillis() < checkpointTime) {\n        fileLogReader.getLogNext(loggingContext, readRange, maxEvents, filter, callback);\n        // If there are events from fileLogReader, return. Otherwise try in kafkaLogReader.\n        if (callback.getCount() != 0) {\n          return;\n        }\n      }\n    }\n\n    kafkaLogReader.getLogNext(loggingContext, readRange, maxEvents, filter, callback);\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final LogOffset fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    callback.init();\n    try {\n      Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                        filter));\n\n      SortedMap<Long, Location> sortedFiles =\n        ImmutableSortedMap.copyOf(fileMetaDataManager.listFiles(loggingContext), Collections.<Long>reverseOrder());\n      if (sortedFiles.isEmpty()) {\n        return;\n      }\n\n      long fromTimeMs = fromOffset.getTime() >= 0 ? fromOffset.getTime() - 1 : System.currentTimeMillis();\n\n      List<Location> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n      for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n        if (entry.getKey() <= fromTimeMs) {\n          tailFiles.add(entry.getValue());\n        }\n      }\n\n      List<Collection<LogEvent>> logSegments = Lists.newLinkedList();\n      AvroFileReader logReader = new AvroFileReader(schema);\n      int count = 0;\n      for (Location file : tailFiles) {\n        Collection<LogEvent> events = logReader.readLogPrev(file, logFilter, fromTimeMs,\n                                                            maxEvents - count);\n        logSegments.add(events);\n        count += events.size();\n        if (count >= maxEvents) {\n          break;\n        }\n      }\n\n      for (LogEvent event : Iterables.concat(Lists.reverse(logSegments))) {\n        callback.handle(event);\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception: \", e);\n      throw  Throwables.propagate(e);\n    } finally {\n      callback.close();\n    }\n  }","id":72908,"modified_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final ReadRange readRange, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    callback.init();\n    try {\n      Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                        filter));\n\n      SortedMap<Long, Location> sortedFiles =\n        ImmutableSortedMap.copyOf(fileMetaDataManager.listFiles(loggingContext), Collections.<Long>reverseOrder());\n      if (sortedFiles.isEmpty()) {\n        return;\n      }\n\n      long fromTimeMs = readRange != ReadRange.LATEST ? readRange.getToMillis() - 1 : System.currentTimeMillis();\n\n      List<Location> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n      for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n        if (entry.getKey() >= readRange.getFromMillis() && entry.getKey() <= readRange.getToMillis()) {\n          tailFiles.add(entry.getValue());\n        }\n      }\n\n      List<Collection<LogEvent>> logSegments = Lists.newLinkedList();\n      AvroFileReader logReader = new AvroFileReader(schema);\n      int count = 0;\n      for (Location file : tailFiles) {\n        Collection<LogEvent> events = logReader.readLogPrev(file, logFilter, fromTimeMs, maxEvents - count);\n        logSegments.add(events);\n        count += events.size();\n        if (count >= maxEvents) {\n          break;\n        }\n      }\n\n      for (LogEvent event : Iterables.concat(Lists.reverse(logSegments))) {\n        callback.handle(event);\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception: \", e);\n      throw  Throwables.propagate(e);\n    } finally {\n      callback.close();\n    }\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final LogOffset fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    if (fromOffset.getTime() < 0) {\n      getLogPrev(loggingContext, fromOffset, maxEvents, filter, callback);\n      return;\n    }\n\n    callback.init();\n\n    try {\n      Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                        filter));\n      long fromTimeMs = fromOffset.getTime() + 1;\n\n      SortedMap<Long, Location> sortedFiles = fileMetaDataManager.listFiles(loggingContext);\n      if (sortedFiles.isEmpty()) {\n        return;\n      }\n\n      long prevInterval = -1;\n      Location prevPath = null;\n      List<Location> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n      for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n        if (entry.getKey() >= fromTimeMs && prevPath != null) {\n          tailFiles.add(prevPath);\n        }\n        prevInterval = entry.getKey();\n        prevPath = entry.getValue();\n      }\n\n      if (prevInterval != -1) {\n        tailFiles.add(prevPath);\n      }\n\n      AvroFileReader logReader = new AvroFileReader(schema);\n      for (Location file : tailFiles) {\n        logReader.readLog(file, logFilter, fromTimeMs, Long.MAX_VALUE, maxEvents - callback.getCount(), callback);\n        if (callback.getCount() >= maxEvents) {\n          break;\n        }\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception: \", e);\n      throw  Throwables.propagate(e);\n    } finally {\n      callback.close();\n    }\n  }","id":72909,"modified_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final ReadRange readRange, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    if (readRange == ReadRange.LATEST) {\n      getLogPrev(loggingContext, readRange, maxEvents, filter, callback);\n      return;\n    }\n\n    callback.init();\n\n    try {\n      Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                        filter));\n      long fromTimeMs = readRange.getFromMillis() + 1;\n\n      SortedMap<Long, Location> sortedFiles = fileMetaDataManager.listFiles(loggingContext);\n      if (sortedFiles.isEmpty()) {\n        return;\n      }\n\n      long prevInterval = -1;\n      Location prevPath = null;\n      List<Location> tailFiles = Lists.newArrayListWithExpectedSize(sortedFiles.size());\n      for (Map.Entry<Long, Location> entry : sortedFiles.entrySet()) {\n        if (entry.getKey() >= readRange.getFromMillis() &&\n          prevPath != null && entry.getKey() <= readRange.getToMillis()) {\n          tailFiles.add(prevPath);\n        }\n        prevInterval = entry.getKey();\n        prevPath = entry.getValue();\n      }\n\n      if (prevInterval != -1) {\n        tailFiles.add(prevPath);\n      }\n\n      AvroFileReader logReader = new AvroFileReader(schema);\n      for (Location file : tailFiles) {\n        logReader.readLog(file, logFilter, fromTimeMs, Long.MAX_VALUE, maxEvents - callback.getCount(), callback);\n        if (callback.getCount() >= maxEvents) {\n          break;\n        }\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception: \", e);\n      throw  Throwables.propagate(e);\n    } finally {\n      callback.close();\n    }\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"public long getLastOffset() {\n      return lastOffset;\n    }","id":72910,"modified_method":"public LogOffset getLastOffset() {\n      return lastOffset;\n    }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogPrev(LoggingContext loggingContext, LogOffset fromOffset, int maxEvents,\n                         Filter filter, Callback callback) {\n    if (fromOffset.getKafkaOffset() == LogOffset.INVALID_KAFKA_OFFSET) {\n      fromOffset = LogOffset.LATEST_OFFSET;\n    }\n\n    int partition = partitioner.partition(loggingContext.getLogPartition(), -1);\n\n    callback.init();\n\n    KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, KAFKA_FETCH_TIMEOUT_MS);\n    try {\n      Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                        filter));\n\n      long latestOffset = kafkaConsumer.fetchOffsetBefore(KafkaConsumer.LATEST_OFFSET);\n      long earliestOffset = kafkaConsumer.fetchOffsetBefore(KafkaConsumer.EARLIEST_OFFSET);\n      long stopOffset;\n      long startOffset;\n\n      if (fromOffset.getKafkaOffset() < 0)  {\n        stopOffset = latestOffset;\n      } else {\n        stopOffset = fromOffset.getKafkaOffset();\n      }\n      startOffset = stopOffset - maxEvents;\n\n      if (startOffset < earliestOffset) {\n        startOffset = earliestOffset;\n      }\n\n      if (startOffset >= stopOffset || startOffset >= latestOffset) {\n        // At end of kafka events, nothing to return\n        return;\n      }\n\n      // Events between startOffset and stopOffset may not have the required logs we are looking for,\n      // we'll need to return at least 1 log offset for next getLogPrev call to work.\n      int fetchCount = 0;\n      while (fetchCount == 0) {\n        fetchCount = fetchLogEvents(kafkaConsumer, logFilter, startOffset, stopOffset, maxEvents, callback,\n                                    Long.MIN_VALUE);\n        stopOffset = startOffset;\n        if (stopOffset <= earliestOffset) {\n          // Truly no log messages found.\n          break;\n        }\n\n        startOffset = stopOffset - maxEvents;\n        if (startOffset < earliestOffset) {\n          startOffset = earliestOffset;\n        }\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception: \", e);\n      throw  Throwables.propagate(e);\n    } finally {\n      try {\n        try {\n          callback.close();\n        } finally {\n          kafkaConsumer.close();\n        }\n      } catch (IOException e) {\n        LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                topic, partition), e);\n      }\n    }\n  }","id":72911,"modified_method":"@Override\n  public void getLogPrev(LoggingContext loggingContext, ReadRange readRange, int maxEvents,\n                         Filter filter, Callback callback) {\n    if (readRange.getKafkaOffset() == LogOffset.INVALID_KAFKA_OFFSET) {\n      readRange = ReadRange.LATEST;\n    }\n\n    int partition = partitioner.partition(loggingContext.getLogPartition(), -1);\n\n    callback.init();\n\n    KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, KAFKA_FETCH_TIMEOUT_MS);\n    try {\n      Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                        filter));\n\n      long latestOffset = kafkaConsumer.fetchOffsetBefore(KafkaConsumer.LATEST_OFFSET);\n      long earliestOffset = kafkaConsumer.fetchOffsetBefore(KafkaConsumer.EARLIEST_OFFSET);\n      long stopOffset;\n      long startOffset;\n\n      if (readRange.getKafkaOffset() < 0)  {\n        stopOffset = latestOffset;\n      } else {\n        stopOffset = readRange.getKafkaOffset();\n      }\n      startOffset = stopOffset - maxEvents;\n\n      if (startOffset < earliestOffset) {\n        startOffset = earliestOffset;\n      }\n\n      if (startOffset >= stopOffset || startOffset >= latestOffset) {\n        // At end of kafka events, nothing to return\n        return;\n      }\n\n      // Events between startOffset and stopOffset may not have the required logs we are looking for,\n      // we'll need to return at least 1 log offset for next getLogPrev call to work.\n      int fetchCount = 0;\n      while (fetchCount == 0) {\n        fetchCount = fetchLogEvents(kafkaConsumer, logFilter, startOffset, stopOffset, maxEvents, callback, readRange);\n        stopOffset = startOffset;\n        if (stopOffset <= earliestOffset) {\n          // Truly no log messages found.\n          break;\n        }\n\n        startOffset = stopOffset - maxEvents;\n        if (startOffset < earliestOffset) {\n          startOffset = earliestOffset;\n        }\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception: \", e);\n      throw  Throwables.propagate(e);\n    } finally {\n      try {\n        try {\n          callback.close();\n        } finally {\n          kafkaConsumer.close();\n        }\n      } catch (IOException e) {\n        LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                topic, partition), e);\n      }\n    }\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"private int fetchLogEvents(KafkaConsumer kafkaConsumer, Filter logFilter, long startOffset, long stopOffset,\n                             int maxEvents, Callback callback, long fromTimeMs) {\n    KafkaCallback kafkaCallback = new KafkaCallback(logFilter, serializer, stopOffset, maxEvents, callback, fromTimeMs);\n\n    while (kafkaCallback.getCount() < maxEvents && startOffset < stopOffset) {\n      kafkaConsumer.fetchMessages(startOffset, kafkaCallback);\n      long lastOffset = kafkaCallback.getLastOffset();\n\n      // No more Kafka messages\n      if (lastOffset == -1) {\n        break;\n      }\n      startOffset = kafkaCallback.getLastOffset() + 1;\n    }\n\n    return kafkaCallback.getCount();\n  }","id":72912,"modified_method":"private int fetchLogEvents(KafkaConsumer kafkaConsumer, Filter logFilter, long startOffset, long stopOffset,\n                             int maxEvents, Callback callback, ReadRange readRange) {\n    KafkaCallback kafkaCallback = new KafkaCallback(logFilter, serializer, stopOffset, maxEvents, callback,\n                                                    readRange.getFromMillis());\n\n    while (kafkaCallback.getCount() < maxEvents && startOffset < stopOffset) {\n      kafkaConsumer.fetchMessages(startOffset, kafkaCallback);\n      LogOffset lastOffset = kafkaCallback.getLastOffset();\n      LogOffset firstOffset = kafkaCallback.getFirstOffset();\n\n      // No more Kafka messages\n      if (lastOffset == null) {\n        break;\n      }\n      // If out of range, break\n      if (firstOffset.getTime() < readRange.getFromMillis() || lastOffset.getTime() > readRange.getToMillis()) {\n        break;\n      }\n      startOffset = kafkaCallback.getLastOffset().getKafkaOffset() + 1;\n    }\n\n    return kafkaCallback.getCount();\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void handle(long offset, ByteBuffer msgBuffer) {\n      ILoggingEvent event = serializer.fromBytes(msgBuffer);\n      if (offset < stopOffset && count < maxEvents && logFilter.match(event) && event.getTimeStamp() > fromTimeMs) {\n        ++count;\n        callback.handle(new LogEvent(event, new LogOffset(offset, event.getTimeStamp())));\n      }\n      lastOffset = offset;\n    }","id":72913,"modified_method":"@Override\n    public void handle(long offset, ByteBuffer msgBuffer) {\n      ILoggingEvent event = serializer.fromBytes(msgBuffer);\n      LogOffset logOffset = new LogOffset(offset, event.getTimeStamp());\n\n      if (offset < stopOffset && count < maxEvents && logFilter.match(event) && event.getTimeStamp() > fromTimeMs) {\n        ++count;\n        callback.handle(new LogEvent(event, logOffset));\n      }\n\n      if (firstOffset == null) {\n        firstOffset = logOffset;\n      }\n      lastOffset = logOffset;\n    }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogNext(LoggingContext loggingContext, LogOffset fromOffset, int maxEvents,\n                         Filter filter, Callback callback) {\n    if (fromOffset == LogOffset.LATEST_OFFSET) {\n      getLogPrev(loggingContext, fromOffset, maxEvents, filter, callback);\n      return;\n    }\n\n    int partition = partitioner.partition(loggingContext.getLogPartition(), -1);\n\n    callback.init();\n\n    KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, KAFKA_FETCH_TIMEOUT_MS);\n    long fromTimeMs = Long.MIN_VALUE;\n    try {\n      // If Kafka offset is not valid, then we might be rolling over from file while reading.\n      // Try to get the offset corresponding to fromOffset.getTime()\n      if (fromOffset.getKafkaOffset() == LogOffset.INVALID_KAFKA_OFFSET) {\n        fromOffset =\n          new LogOffset(kafkaConsumer.fetchOffsetBefore(fromOffset.getTime()), fromOffset.getTime());\n        fromTimeMs = fromOffset.getTime();\n      }\n\n      Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                        filter));\n\n      long latestOffset = kafkaConsumer.fetchOffsetBefore(KafkaConsumer.LATEST_OFFSET);\n      long startOffset = fromOffset.getKafkaOffset() + 1;\n\n      if (startOffset >= latestOffset) {\n        // At end of events, nothing to return\n        return;\n      }\n\n      fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback, fromTimeMs);\n    } catch (Throwable e) {\n      LOG.error(\"Got exception: \", e);\n      throw  Throwables.propagate(e);\n    } finally {\n      try {\n        try {\n          callback.close();\n        } finally {\n          kafkaConsumer.close();\n        }\n      } catch (IOException e) {\n        LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                topic, partition), e);\n      }\n    }\n  }","id":72914,"modified_method":"@Override\n  public void getLogNext(LoggingContext loggingContext, ReadRange readRange, int maxEvents,\n                         Filter filter, Callback callback) {\n    if (readRange == ReadRange.LATEST) {\n      getLogPrev(loggingContext, readRange, maxEvents, filter, callback);\n      return;\n    }\n\n    int partition = partitioner.partition(loggingContext.getLogPartition(), -1);\n\n    callback.init();\n\n    KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, KAFKA_FETCH_TIMEOUT_MS);\n    try {\n      // If Kafka offset is not valid, then we might be rolling over from file while reading.\n      // Try to get the offset corresponding to fromOffset.getTime()\n      if (readRange.getKafkaOffset() == LogOffset.INVALID_KAFKA_OFFSET) {\n        readRange = new ReadRange(readRange.getFromMillis(), readRange.getToMillis(),\n                                  kafkaConsumer.fetchOffsetBefore(readRange.getFromMillis()));\n      }\n\n      Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                        filter));\n\n      long latestOffset = kafkaConsumer.fetchOffsetBefore(KafkaConsumer.LATEST_OFFSET);\n      long startOffset = readRange.getKafkaOffset() + 1;\n\n      if (startOffset >= latestOffset) {\n        // At end of events, nothing to return\n        return;\n      }\n\n      fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback, readRange);\n    } catch (Throwable e) {\n      LOG.error(\"Got exception: \", e);\n      throw  Throwables.propagate(e);\n    } finally {\n      try {\n        try {\n          callback.close();\n        } finally {\n          kafkaConsumer.close();\n        }\n      } catch (IOException e) {\n        LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                topic, partition), e);\n      }\n    }\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"private void doNext(HttpResponder responder, LoggingContext loggingContext, int maxEvents,\n                      String fromOffsetStr, boolean escape, String filterStr) {\n    try {\n      Filter filter = FilterParser.parse(filterStr);\n\n      LogReaderCallback logCallback = new LogReaderCallback(responder, logPattern, escape);\n\n      logReader.getLogNext(loggingContext, FormattedLogEvent.parseLogOffset(fromOffsetStr),\n                           maxEvents, filter, logCallback);\n    } catch (SecurityException e) {\n      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n    } catch (IllegalArgumentException e) {\n      responder.sendString(HttpResponseStatus.BAD_REQUEST, e.getMessage());\n    } catch (Throwable e) {\n      LOG.error(\"Caught exception\", e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","id":72915,"modified_method":"private void doNext(HttpResponder responder, LoggingContext loggingContext, int maxEvents,\n                      String fromOffsetStr, boolean escape, String filterStr) {\n    try {\n      Filter filter = FilterParser.parse(filterStr);\n\n      LogReaderCallback logCallback = new LogReaderCallback(responder, logPattern, escape);\n\n      LogOffset logOffset = FormattedLogEvent.parseLogOffset(fromOffsetStr);\n      ReadRange readRange = ReadRange.createFromRange(logOffset);\n      logReader.getLogNext(loggingContext, readRange, maxEvents, filter, logCallback);\n    } catch (SecurityException e) {\n      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n    } catch (IllegalArgumentException e) {\n      responder.sendString(HttpResponseStatus.BAD_REQUEST, e.getMessage());\n    } catch (Throwable e) {\n      LOG.error(\"Caught exception\", e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"private void doPrev(HttpResponder responder, LoggingContext loggingContext,\n                      int maxEvents, String fromOffsetStr, boolean escape, String filterStr) {\n    try {\n      Filter filter = FilterParser.parse(filterStr);\n\n      LogReaderCallback logCallback = new LogReaderCallback(responder, logPattern, escape);\n      logReader.getLogPrev(loggingContext, FormattedLogEvent.parseLogOffset(fromOffsetStr),\n                           maxEvents, filter, logCallback);\n    } catch (SecurityException e) {\n      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n    } catch (IllegalArgumentException e) {\n      responder.sendString(HttpResponseStatus.BAD_REQUEST, e.getMessage());\n    } catch (Throwable e) {\n      LOG.error(\"Caught exception\", e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","id":72916,"modified_method":"private void doPrev(HttpResponder responder, LoggingContext loggingContext,\n                      int maxEvents, String fromOffsetStr, boolean escape, String filterStr) {\n    try {\n      Filter filter = FilterParser.parse(filterStr);\n\n      LogReaderCallback logCallback = new LogReaderCallback(responder, logPattern, escape);\n      LogOffset logOffset = FormattedLogEvent.parseLogOffset(fromOffsetStr);\n      ReadRange readRange = ReadRange.createToRange(logOffset);\n      logReader.getLogPrev(loggingContext, readRange,\n                           maxEvents, filter, logCallback);\n    } catch (SecurityException e) {\n      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n    } catch (IllegalArgumentException e) {\n      responder.sendString(HttpResponseStatus.BAD_REQUEST, e.getMessage());\n    } catch (Throwable e) {\n      LOG.error(\"Caught exception\", e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"public void testGetNext(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogNext(loggingContext, LogOffset.LATEST_OFFSET, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogOffset ultimateOffset =  events.get(9).getOffset();\n    LogOffset penultimateOffset = events.get(8).getOffset();\n\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback1.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getLastOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 31 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogNext(loggingContext, ultimateOffset, 20, Filter.EMPTY_FILTER,\n                         logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogNext(loggingContext, getNextOffset(ultimateOffset), 20, Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogNext(loggingContext, penultimateOffset, 20, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(1, events.size());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n\n    // Try with a different run\n    LogCallback logCallback10 = new LogCallback();\n    logReader.getLogPrev(replaceTag(loggingContext, new Entry(ApplicationLoggingContext.TAG_RUNID_ID, \"RUN2\")),\n                         LogOffset.LATEST_OFFSET, 20, Filter.EMPTY_FILTER, logCallback10);\n    events = logCallback10.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"RUN2 Test log message 40 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"RUN2 Test log message 59 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    // Try with a null runid, should return all events with or without runid\n    LogCallback logCallback11 = new LogCallback();\n    logReader.getLogPrev(replaceTag(loggingContext, new Entry(ApplicationLoggingContext.TAG_RUNID_ID, null)),\n                         LogOffset.LATEST_OFFSET, 35, Filter.EMPTY_FILTER, logCallback11);\n    events = logCallback11.getEvents();\n    Assert.assertEquals(35, events.size());\n    Assert.assertEquals(\"RUN2 Test log message 45 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"NULL Test log message 59 arg1 arg2\", events.get(34).getLoggingEvent().getFormattedMessage());\n  }","id":72917,"modified_method":"public void testGetNext(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogNext(loggingContext, ReadRange.LATEST, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogOffset ultimateOffset =  events.get(9).getOffset();\n    LogOffset penultimateOffset = events.get(8).getOffset();\n\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ReadRange.createToRange(logCallback1.getFirstOffset()), 20,\n                         Filter.EMPTY_FILTER, logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, ReadRange.createFromRange(logCallback2.getLastOffset()), 20,\n                         Filter.EMPTY_FILTER, logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogNext(loggingContext, ReadRange.createFromRange(logCallback2.getFirstOffset()), 20,\n                         Filter.EMPTY_FILTER, logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 31 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogNext(loggingContext, ReadRange.createFromRange(ultimateOffset), 20, Filter.EMPTY_FILTER,\n                         logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogNext(loggingContext, ReadRange.createFromRange(getNextOffset(ultimateOffset)), 20,\n                         Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogNext(loggingContext, ReadRange.createFromRange(penultimateOffset), 20, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(1, events.size());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n\n    // Try with a different run\n    LogCallback logCallback10 = new LogCallback();\n    logReader.getLogPrev(replaceTag(loggingContext, new Entry(ApplicationLoggingContext.TAG_RUNID_ID, \"RUN2\")),\n                         ReadRange.LATEST, 20, Filter.EMPTY_FILTER, logCallback10);\n    events = logCallback10.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"RUN2 Test log message 40 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"RUN2 Test log message 59 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    // Try with a null runid, should return all events with or without runid\n    LogCallback logCallback11 = new LogCallback();\n    logReader.getLogPrev(replaceTag(loggingContext, new Entry(ApplicationLoggingContext.TAG_RUNID_ID, null)),\n                         ReadRange.LATEST, 35, Filter.EMPTY_FILTER, logCallback11);\n    events = logCallback11.getEvents();\n    Assert.assertEquals(35, events.size());\n    Assert.assertEquals(\"RUN2 Test log message 45 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"NULL Test log message 59 arg1 arg2\", events.get(34).getLoggingEvent().getFormattedMessage());\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"public void testGetPrev(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogPrev(loggingContext, LogOffset.LATEST_OFFSET, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogOffset ultimateOffset =  events.get(9).getOffset();\n\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback1.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getLastOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback2.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback4);\n    events = logCallback4.getEvents();\n    // In kafka mode, we'll get only 10 lines, need to run the call again.\n    if (events.size() < 15) {\n      LogCallback logCallback41 = new LogCallback();\n      logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 5, Filter.EMPTY_FILTER,\n                           logCallback41);\n      events.addAll(0, logCallback41.getEvents());\n      logCallback4 = logCallback41;\n    }\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 15 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 29 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogPrev(loggingContext, new LogOffset(0, 0), 15, Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 25, Filter.EMPTY_FILTER,\n                         logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback9 = new LogCallback();\n    logReader.getLogPrev(loggingContext, getNextOffset(ultimateOffset), 15, Filter.EMPTY_FILTER, logCallback9);\n    events = logCallback9.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 45 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    // Try with a different run\n    LogCallback logCallback10 = new LogCallback();\n    logReader.getLogPrev(replaceTag(loggingContext, new Entry(ApplicationLoggingContext.TAG_RUNID_ID, \"RUN2\")),\n                         LogOffset.LATEST_OFFSET, 20, Filter.EMPTY_FILTER, logCallback10);\n    events = logCallback10.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"RUN2 Test log message 40 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"RUN2 Test log message 59 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    // Try with a null runid, should return all events with or without runid\n    LogCallback logCallback11 = new LogCallback();\n    logReader.getLogPrev(replaceTag(loggingContext, new Entry(ApplicationLoggingContext.TAG_RUNID_ID, null)),\n                         LogOffset.LATEST_OFFSET, 40, Filter.EMPTY_FILTER, logCallback11);\n    events = logCallback11.getEvents();\n    Assert.assertEquals(40, events.size());\n    Assert.assertEquals(\"RUN2 Test log message 40 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"NULL Test log message 59 arg1 arg2\", events.get(39).getLoggingEvent().getFormattedMessage());\n  }","id":72918,"modified_method":"public void testGetPrev(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ReadRange.LATEST, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogOffset ultimateOffset =  events.get(9).getOffset();\n\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ReadRange.createToRange(logCallback1.getFirstOffset()), 20,\n                         Filter.EMPTY_FILTER, logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, ReadRange.createFromRange(logCallback2.getLastOffset()), 20,\n                         Filter.EMPTY_FILTER, logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ReadRange.createToRange(logCallback2.getFirstOffset()), 15,\n                         Filter.EMPTY_FILTER, logCallback4);\n    events = logCallback4.getEvents();\n    // In kafka mode, we'll get only 10 lines, need to run the call again.\n    if (events.size() < 15) {\n      LogCallback logCallback41 = new LogCallback();\n      logReader.getLogPrev(loggingContext, ReadRange.createToRange(logCallback4.getFirstOffset()), 5,\n                           Filter.EMPTY_FILTER, logCallback41);\n      events.addAll(0, logCallback41.getEvents());\n      logCallback4 = logCallback41;\n    }\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 15 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 29 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ReadRange.createToRange(logCallback4.getFirstOffset()), 25,\n                         Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ReadRange.createToRange(logCallback6.getFirstOffset()), 15,\n                         Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ReadRange.createToRange(logCallback4.getFirstOffset()), 15,\n                         Filter.EMPTY_FILTER, logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback9 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ReadRange.createToRange(getNextOffset(ultimateOffset)), 15,\n                         Filter.EMPTY_FILTER, logCallback9);\n    events = logCallback9.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 45 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    // Try with a different run\n    LogCallback logCallback10 = new LogCallback();\n    logReader.getLogPrev(replaceTag(loggingContext, new Entry(ApplicationLoggingContext.TAG_RUNID_ID, \"RUN2\")),\n                         ReadRange.LATEST, 20, Filter.EMPTY_FILTER, logCallback10);\n    events = logCallback10.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"RUN2 Test log message 40 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"RUN2 Test log message 59 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    // Try with a null runid, should return all events with or without runid\n    LogCallback logCallback11 = new LogCallback();\n    logReader.getLogPrev(replaceTag(loggingContext, new Entry(ApplicationLoggingContext.TAG_RUNID_ID, null)),\n                         ReadRange.LATEST, 40, Filter.EMPTY_FILTER, logCallback11);\n    events = logCallback11.getEvents();\n    Assert.assertEquals(40, events.size());\n    Assert.assertEquals(\"RUN2 Test log message 40 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"NULL Test log message 59 arg1 arg2\", events.get(39).getLoggingEvent().getFormattedMessage());\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLog(LoggingContext loggingContext, long fromTimeMs, long toTimeMs, Filter filter,\n                     Callback callback) {\n    long fromOffset = fromTimeMs / 1000;\n    getLogNext(loggingContext, new LogOffset(fromOffset, fromOffset),\n               (int) (toTimeMs - fromTimeMs) / 1000, filter, callback);\n  }","id":72919,"modified_method":"@Override\n  public void getLog(LoggingContext loggingContext, long fromTimeMs, long toTimeMs, Filter filter,\n                     Callback callback) {\n    long fromOffset = fromTimeMs / 1000;\n    getLogNext(loggingContext, ReadRange.createFromRange(new LogOffset(fromOffset, fromOffset)),\n               (int) (toTimeMs - fromTimeMs) / 1000, filter, callback);\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogNext(LoggingContext loggingContext, LogOffset fromOffset, int maxEvents, Filter filter,\n                         Callback callback) {\n    if (fromOffset.getKafkaOffset() < 0) {\n      getLogPrev(loggingContext, fromOffset, maxEvents, filter, callback);\n      return;\n    }\n\n    Filter contextFilter = LoggingContextHelper.createFilter(loggingContext);\n\n    callback.init();\n    try {\n      int count = 0;\n      for (LogEvent logLine : logEvents) {\n        if (logLine.getOffset().getKafkaOffset() >= fromOffset.getKafkaOffset()) {\n          if (!contextFilter.match(logLine.getLoggingEvent())) {\n            continue;\n          }\n\n          if (++count > maxEvents) {\n            break;\n          }\n\n          if (filter != Filter.EMPTY_FILTER && logLine.getOffset().getKafkaOffset() % 2 != 0) {\n            continue;\n          }\n\n          callback.handle(logLine);\n        }\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception\", e);\n    } finally {\n      callback.close();\n    }\n  }","id":72920,"modified_method":"@Override\n  public void getLogNext(LoggingContext loggingContext, ReadRange readRange, int maxEvents, Filter filter,\n                         Callback callback) {\n    if (readRange.getKafkaOffset() < 0) {\n      getLogPrev(loggingContext, readRange, maxEvents, filter, callback);\n      return;\n    }\n\n    Filter contextFilter = LoggingContextHelper.createFilter(loggingContext);\n\n    callback.init();\n    try {\n      int count = 0;\n      for (LogEvent logLine : logEvents) {\n        if (logLine.getOffset().getKafkaOffset() >= readRange.getKafkaOffset()) {\n          if (!contextFilter.match(logLine.getLoggingEvent())) {\n            continue;\n          }\n\n          if (++count > maxEvents) {\n            break;\n          }\n\n          if (filter != Filter.EMPTY_FILTER && logLine.getOffset().getKafkaOffset() % 2 != 0) {\n            continue;\n          }\n\n          callback.handle(logLine);\n        }\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception\", e);\n    } finally {\n      callback.close();\n    }\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogPrev(LoggingContext loggingContext, LogOffset fromOffset, int maxEvents, Filter filter,\n                         Callback callback) {\n    if (fromOffset.getKafkaOffset() < 0) {\n      fromOffset = new LogOffset(MAX, MAX);\n    }\n\n    Filter contextFilter = LoggingContextHelper.createFilter(loggingContext);\n\n    callback.init();\n    try {\n      int count = 0;\n      long startOffset = fromOffset.getKafkaOffset() - maxEvents;\n      for (LogEvent logLine : logEvents) {\n        if (!contextFilter.match(logLine.getLoggingEvent())) {\n          continue;\n        }\n\n        if (logLine.getOffset().getKafkaOffset() >= startOffset &&\n          logLine.getOffset().getKafkaOffset() < fromOffset.getKafkaOffset()) {\n          if (++count > maxEvents) {\n            break;\n          }\n\n          if (filter != Filter.EMPTY_FILTER && logLine.getOffset().getKafkaOffset() % 2 != 0) {\n            continue;\n          }\n\n          callback.handle(logLine);\n        }\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception\", e);\n    } finally {\n      callback.close();\n    }\n  }","id":72921,"modified_method":"@Override\n  public void getLogPrev(LoggingContext loggingContext, ReadRange readRange, int maxEvents, Filter filter,\n                         Callback callback) {\n    if (readRange.getKafkaOffset() < 0) {\n      readRange = ReadRange.createToRange(new LogOffset(MAX, MAX));\n    }\n\n    Filter contextFilter = LoggingContextHelper.createFilter(loggingContext);\n\n    callback.init();\n    try {\n      int count = 0;\n      long startOffset = readRange.getKafkaOffset() - maxEvents;\n      for (LogEvent logLine : logEvents) {\n        if (!contextFilter.match(logLine.getLoggingEvent())) {\n          continue;\n        }\n\n        if (logLine.getOffset().getKafkaOffset() >= startOffset &&\n          logLine.getOffset().getKafkaOffset() < readRange.getKafkaOffset()) {\n          if (++count > maxEvents) {\n            break;\n          }\n\n          if (filter != Filter.EMPTY_FILTER && logLine.getOffset().getKafkaOffset() % 2 != 0) {\n            continue;\n          }\n\n          callback.handle(logLine);\n        }\n      }\n    } catch (Throwable e) {\n      LOG.error(\"Got exception\", e);\n    } finally {\n      callback.close();\n    }\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testDistributedLogPrev() throws Exception {\n    DistributedLogReader distributedLogReader = injector.getInstance(DistributedLogReader.class);\n    int count = 60;\n    LogOffset firstOffset = LogOffset.LATEST_OFFSET;\n    for (int i = 0; i < 15; ++i) {\n      LoggingTester.LogCallback callback = new LoggingTester.LogCallback();\n      distributedLogReader.getLogPrev(LOGGING_CONTEXT, firstOffset, 4, Filter.EMPTY_FILTER, callback);\n      List<LogEvent> events = callback.getEvents();\n      firstOffset = events.get(0).getOffset();\n\n      Collections.reverse(events);\n      for (LogEvent event : events) {\n        Assert.assertEquals(\"TestDistributedLogReader Log message \" + --count,\n                            event.getLoggingEvent().getFormattedMessage());\n      }\n    }\n    Assert.assertEquals(0, count);\n  }","id":72922,"modified_method":"@Test\n  public void testDistributedLogPrev() throws Exception {\n    DistributedLogReader distributedLogReader = injector.getInstance(DistributedLogReader.class);\n    int count = 60;\n    ReadRange readRange = ReadRange.LATEST;\n    for (int i = 0; i < 15; ++i) {\n      LoggingTester.LogCallback callback = new LoggingTester.LogCallback();\n      distributedLogReader.getLogPrev(LOGGING_CONTEXT, readRange, 4, Filter.EMPTY_FILTER, callback);\n      List<LogEvent> events = callback.getEvents();\n      Assert.assertFalse(events.isEmpty());\n      readRange = ReadRange.createToRange(events.get(0).getOffset());\n\n      Collections.reverse(events);\n      for (LogEvent event : events) {\n        Assert.assertEquals(\"TestDistributedLogReader Log message \" + --count,\n                            event.getLoggingEvent().getFormattedMessage());\n      }\n    }\n    Assert.assertEquals(0, count);\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testDistributedLogNext() throws Exception {\n    DistributedLogReader distributedLogReader = injector.getInstance(DistributedLogReader.class);\n    int count = 0;\n    LogOffset firstOffset = new LogOffset(LogOffset.INVALID_KAFKA_OFFSET, 0);\n    for (int i = 0; i < 20; ++i) {\n      LoggingTester.LogCallback callback = new LoggingTester.LogCallback();\n      distributedLogReader.getLogNext(LOGGING_CONTEXT, firstOffset, 3, Filter.EMPTY_FILTER, callback);\n      List<LogEvent> events = callback.getEvents();\n      firstOffset = events.get(events.size() - 1).getOffset();\n\n      for (LogEvent event : events) {\n        Assert.assertEquals(\"TestDistributedLogReader Log message \" + count++,\n                            event.getLoggingEvent().getFormattedMessage());\n      }\n    }\n    Assert.assertEquals(60, count);\n  }","id":72923,"modified_method":"@Test\n  public void testDistributedLogNext() throws Exception {\n    DistributedLogReader distributedLogReader = injector.getInstance(DistributedLogReader.class);\n    int count = 0;\n    ReadRange readRange = new ReadRange(0, Long.MAX_VALUE, LogOffset.INVALID_KAFKA_OFFSET);\n    for (int i = 0; i < 20; ++i) {\n      LoggingTester.LogCallback callback = new LoggingTester.LogCallback();\n      distributedLogReader.getLogNext(LOGGING_CONTEXT, readRange, 3, Filter.EMPTY_FILTER, callback);\n      List<LogEvent> events = callback.getEvents();\n      Assert.assertFalse(events.isEmpty());\n      readRange = ReadRange.createFromRange(events.get(events.size() - 1).getOffset());\n\n      for (LogEvent event : events) {\n        Assert.assertEquals(\"TestDistributedLogReader Log message \" + count++,\n                            event.getLoggingEvent().getFormattedMessage());\n      }\n    }\n    Assert.assertEquals(60, count);\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetLog() throws Exception {\n    // LogReader.getLog is tested in LogSaverTest for distributed mode\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TFL_NS_1\", \"APP_1\", \"FLOW_1\", \"\", \"RUN1\", \"INSTANCE1\");\n    FileLogReader logTail = injector.getInstance(FileLogReader.class);\n    LoggingTester.LogCallback logCallback1 = new LoggingTester.LogCallback();\n    logTail.getLogPrev(loggingContext, LogOffset.LATEST_OFFSET, 60, Filter.EMPTY_FILTER,\n                       logCallback1);\n    List<LogEvent> allEvents = logCallback1.getEvents();\n    Assert.assertEquals(60, allEvents.size());\n\n    LoggingTester.LogCallback logCallback2 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(10).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(15).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback2);\n    List<LogEvent> events = logCallback2.getEvents();\n    Assert.assertEquals(5, events.size());\n    Assert.assertEquals(allEvents.get(10).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(14).getLoggingEvent().getFormattedMessage(),\n                        events.get(4).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback3 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(0).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(59, events.size());\n    Assert.assertEquals(allEvents.get(0).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(58).getLoggingEvent().getFormattedMessage(),\n                        events.get(58).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback4 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(12).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(41).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(29, events.size());\n    Assert.assertEquals(allEvents.get(12).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(40).getLoggingEvent().getFormattedMessage(),\n                        events.get(28).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback5 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(22).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(38).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(16, events.size());\n    Assert.assertEquals(allEvents.get(22).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(37).getLoggingEvent().getFormattedMessage(),\n                        events.get(15).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback6 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(41).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(18, events.size());\n    Assert.assertEquals(allEvents.get(41).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(58).getLoggingEvent().getFormattedMessage(),\n                        events.get(17).getLoggingEvent().getFormattedMessage());\n\n    // Try with null run id, should get all logs for FLOW_1\n    LoggingContext loggingContext1 = new FlowletLoggingContext(\"TFL_NS_1\", \"APP_1\", \"FLOW_1\", \"\", null, \"INSTANCE1\");\n    LoggingTester.LogCallback logCallback7 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext1, 0, Long.MAX_VALUE, Filter.EMPTY_FILTER, logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(100, events.size());\n  }","id":72924,"modified_method":"@Test\n  public void testGetLog() throws Exception {\n    // LogReader.getLog is tested in LogSaverTest for distributed mode\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TFL_NS_1\", \"APP_1\", \"FLOW_1\", \"\", \"RUN1\", \"INSTANCE1\");\n    FileLogReader logTail = injector.getInstance(FileLogReader.class);\n    LoggingTester.LogCallback logCallback1 = new LoggingTester.LogCallback();\n    logTail.getLogPrev(loggingContext, ReadRange.LATEST, 60, Filter.EMPTY_FILTER,\n                       logCallback1);\n    List<LogEvent> allEvents = logCallback1.getEvents();\n    Assert.assertEquals(60, allEvents.size());\n\n    LoggingTester.LogCallback logCallback2 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(10).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(15).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback2);\n    List<LogEvent> events = logCallback2.getEvents();\n    Assert.assertEquals(5, events.size());\n    Assert.assertEquals(allEvents.get(10).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(14).getLoggingEvent().getFormattedMessage(),\n                        events.get(4).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback3 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(0).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(59, events.size());\n    Assert.assertEquals(allEvents.get(0).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(58).getLoggingEvent().getFormattedMessage(),\n                        events.get(58).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback4 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(12).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(41).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(29, events.size());\n    Assert.assertEquals(allEvents.get(12).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(40).getLoggingEvent().getFormattedMessage(),\n                        events.get(28).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback5 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(22).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(38).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(16, events.size());\n    Assert.assertEquals(allEvents.get(22).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(37).getLoggingEvent().getFormattedMessage(),\n                        events.get(15).getLoggingEvent().getFormattedMessage());\n\n    LoggingTester.LogCallback logCallback6 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext, allEvents.get(41).getLoggingEvent().getTimeStamp(),\n                   allEvents.get(59).getLoggingEvent().getTimeStamp(), Filter.EMPTY_FILTER, logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(18, events.size());\n    Assert.assertEquals(allEvents.get(41).getLoggingEvent().getFormattedMessage(),\n                        events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(allEvents.get(58).getLoggingEvent().getFormattedMessage(),\n                        events.get(17).getLoggingEvent().getFormattedMessage());\n\n    // Try with null run id, should get all logs for FLOW_1\n    LoggingContext loggingContext1 = new FlowletLoggingContext(\"TFL_NS_1\", \"APP_1\", \"FLOW_1\", \"\", null, \"INSTANCE1\");\n    LoggingTester.LogCallback logCallback7 = new LoggingTester.LogCallback();\n    logTail.getLog(loggingContext1, 0, Long.MAX_VALUE, Filter.EMPTY_FILTER, logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(100, events.size());\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testResilientLogging() throws Exception {\n    Configuration hConf = new Configuration();\n    CConfiguration cConf = CConfiguration.create();\n\n    File datasetDir = new File(tmpFolder.newFolder(), \"datasetUser\");\n    //noinspection ResultOfMethodCallIgnored\n    datasetDir.mkdirs();\n\n    cConf.set(Constants.Dataset.Manager.OUTPUT_DIR, datasetDir.getAbsolutePath());\n    cConf.set(Constants.Dataset.Manager.ADDRESS, \"localhost\");\n\n    cConf.set(Constants.Dataset.Executor.ADDRESS, \"localhost\");\n    cConf.setInt(Constants.Dataset.Executor.PORT, Networks.getRandomPort());\n\n    cConf.set(Constants.CFG_LOCAL_DATA_DIR, tmpFolder.newFolder().getAbsolutePath());\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new IOModule(), new ZKClientModule(),\n      new KafkaClientModule(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new DataSetsModules().getStandaloneModules(),\n      new DataSetServiceModules().getInMemoryModules(),\n      new AuthModule(),\n      new TransactionMetricsModule(),\n      new ExploreClientModule(),\n      new LoggingModules().getInMemoryModules());\n\n    TransactionManager txManager = injector.getInstance(TransactionManager.class);\n    txManager.startAndWait();\n\n    DatasetOpExecutorService opExecutorService = injector.getInstance(DatasetOpExecutorService.class);\n    opExecutorService.startAndWait();\n\n    // Start the logging before starting the service.\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TRL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\",\n                                                                       \"RUN\", \"INSTANCE\"));\n    String logBaseDir = \"trl-log/log_files_\" + new Random(System.currentTimeMillis()).nextLong();\n\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, logBaseDir);\n    cConf.setInt(LoggingConfiguration.LOG_MAX_FILE_SIZE_BYTES, 20 * 1024);\n    LogAppender appender = new AsyncLogAppender(injector.getInstance(FileLogAppender.class));\n    new LogAppenderInitializer(appender).initialize(\"TestResilientLogging\");\n\n    Logger logger = LoggerFactory.getLogger(\"TestResilientLogging\");\n    for (int i = 0; i < 5; ++i) {\n      Exception e1 = new Exception(\"Test Exception1\");\n      Exception e2 = new Exception(\"Test Exception2\", e1);\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    StatusPrinter.setPrintStream(new PrintStream(bos));\n    StatusPrinter.print((LoggerContext) LoggerFactory.getILoggerFactory());\n    System.out.println(bos.toString());\n\n    // Start dataset service, wait for it to be discoverable\n    DatasetService dsService = injector.getInstance(DatasetService.class);\n    dsService.startAndWait();\n\n    final CountDownLatch startLatch = new CountDownLatch(1);\n    DiscoveryServiceClient discoveryClient = injector.getInstance(DiscoveryServiceClient.class);\n    discoveryClient.discover(Constants.Service.DATASET_MANAGER).watchChanges(new ServiceDiscovered.ChangeListener() {\n      @Override\n      public void onChange(ServiceDiscovered serviceDiscovered) {\n        if (!Iterables.isEmpty(serviceDiscovered)) {\n          startLatch.countDown();\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    startLatch.await(5, TimeUnit.SECONDS);\n\n    // Do some more logging after the service is started.\n    for (int i = 5; i < 10; ++i) {\n      Exception e1 = new Exception(\"Test Exception1\");\n      Exception e2 = new Exception(\"Test Exception2\", e1);\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    appender.stop();\n\n    // Verify - we should have at least 5 events.\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TRL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"\", \"RUN\", \"INSTANCE\");\n    FileLogReader logTail = injector.getInstance(FileLogReader.class);\n    LoggingTester.LogCallback logCallback1 = new LoggingTester.LogCallback();\n    logTail.getLogPrev(loggingContext, LogOffset.LATEST_OFFSET, 10, Filter.EMPTY_FILTER,\n                       logCallback1);\n    List<LogEvent> allEvents = logCallback1.getEvents();\n    Assert.assertTrue(allEvents.toString(), allEvents.size() >= 5);\n\n    // Finally - stop all services\n    Services.chainStop(dsService, opExecutorService, txManager);\n  }","id":72925,"modified_method":"@Test\n  public void testResilientLogging() throws Exception {\n    Configuration hConf = new Configuration();\n    CConfiguration cConf = CConfiguration.create();\n\n    File datasetDir = new File(tmpFolder.newFolder(), \"datasetUser\");\n    //noinspection ResultOfMethodCallIgnored\n    datasetDir.mkdirs();\n\n    cConf.set(Constants.Dataset.Manager.OUTPUT_DIR, datasetDir.getAbsolutePath());\n    cConf.set(Constants.Dataset.Manager.ADDRESS, \"localhost\");\n\n    cConf.set(Constants.Dataset.Executor.ADDRESS, \"localhost\");\n    cConf.setInt(Constants.Dataset.Executor.PORT, Networks.getRandomPort());\n\n    cConf.set(Constants.CFG_LOCAL_DATA_DIR, tmpFolder.newFolder().getAbsolutePath());\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new IOModule(), new ZKClientModule(),\n      new KafkaClientModule(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new DataSetsModules().getStandaloneModules(),\n      new DataSetServiceModules().getInMemoryModules(),\n      new AuthModule(),\n      new TransactionMetricsModule(),\n      new ExploreClientModule(),\n      new LoggingModules().getInMemoryModules());\n\n    TransactionManager txManager = injector.getInstance(TransactionManager.class);\n    txManager.startAndWait();\n\n    DatasetOpExecutorService opExecutorService = injector.getInstance(DatasetOpExecutorService.class);\n    opExecutorService.startAndWait();\n\n    // Start the logging before starting the service.\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TRL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\",\n                                                                       \"RUN\", \"INSTANCE\"));\n    String logBaseDir = \"trl-log/log_files_\" + new Random(System.currentTimeMillis()).nextLong();\n\n    cConf.set(LoggingConfiguration.LOG_BASE_DIR, logBaseDir);\n    cConf.setInt(LoggingConfiguration.LOG_MAX_FILE_SIZE_BYTES, 20 * 1024);\n    LogAppender appender = new AsyncLogAppender(injector.getInstance(FileLogAppender.class));\n    new LogAppenderInitializer(appender).initialize(\"TestResilientLogging\");\n\n    Logger logger = LoggerFactory.getLogger(\"TestResilientLogging\");\n    for (int i = 0; i < 5; ++i) {\n      Exception e1 = new Exception(\"Test Exception1\");\n      Exception e2 = new Exception(\"Test Exception2\", e1);\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    StatusPrinter.setPrintStream(new PrintStream(bos));\n    StatusPrinter.print((LoggerContext) LoggerFactory.getILoggerFactory());\n    System.out.println(bos.toString());\n\n    // Start dataset service, wait for it to be discoverable\n    DatasetService dsService = injector.getInstance(DatasetService.class);\n    dsService.startAndWait();\n\n    final CountDownLatch startLatch = new CountDownLatch(1);\n    DiscoveryServiceClient discoveryClient = injector.getInstance(DiscoveryServiceClient.class);\n    discoveryClient.discover(Constants.Service.DATASET_MANAGER).watchChanges(new ServiceDiscovered.ChangeListener() {\n      @Override\n      public void onChange(ServiceDiscovered serviceDiscovered) {\n        if (!Iterables.isEmpty(serviceDiscovered)) {\n          startLatch.countDown();\n        }\n      }\n    }, Threads.SAME_THREAD_EXECUTOR);\n\n    startLatch.await(5, TimeUnit.SECONDS);\n\n    // Do some more logging after the service is started.\n    for (int i = 5; i < 10; ++i) {\n      Exception e1 = new Exception(\"Test Exception1\");\n      Exception e2 = new Exception(\"Test Exception2\", e1);\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    appender.stop();\n\n    // Verify - we should have at least 5 events.\n    LoggingContext loggingContext = new FlowletLoggingContext(\"TRL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"\", \"RUN\", \"INSTANCE\");\n    FileLogReader logTail = injector.getInstance(FileLogReader.class);\n    LoggingTester.LogCallback logCallback1 = new LoggingTester.LogCallback();\n    logTail.getLogPrev(loggingContext, ReadRange.LATEST, 10, Filter.EMPTY_FILTER,\n                       logCallback1);\n    List<LogEvent> allEvents = logCallback1.getEvents();\n    Assert.assertTrue(allEvents.toString(), allEvents.size() >= 5);\n\n    // Finally - stop all services\n    Services.chainStop(dsService, opExecutorService, txManager);\n  }","commit_id":"d99cbc036e087e0c65a9022ba826a5c6b3f0923c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          int partition = partitioner.partition(loggingContext.getLogPartition(), numPartitions);\n\n          callback.init();\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long earliestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.EARLIEST);\n            long startOffset = fromOffset + 1;\n\n            if (fromOffset < 0) {\n              startOffset = latestOffset - maxEvents;\n              if (startOffset < earliestOffset) {\n                startOffset = earliestOffset;\n              }\n            }\n\n            if (startOffset <= fromOffset || startOffset >= latestOffset) {\n              // At end of events, nothing to return\n              return;\n            }\n\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback);\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","id":72926,"modified_method":"@Override\n  public void getLogNext(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    if (fromOffset < 0) {\n      getLogPrev(loggingContext, fromOffset, maxEvents, filter, callback);\n      return;\n    }\n\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          int partition = partitioner.partition(loggingContext.getLogPartition(), numPartitions);\n\n          callback.init();\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long startOffset = fromOffset + 1;\n\n            if (startOffset >= latestOffset) {\n              // At end of events, nothing to return\n              return;\n            }\n\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, latestOffset, maxEvents, callback);\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","commit_id":"f17668586c3caa0417a6a9b8effd84ade46d8670","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          int partition = partitioner.partition(loggingContext.getLogPartition(), numPartitions);\n\n          callback.init();\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long earliestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.EARLIEST);\n            long startOffset = fromOffset - maxEvents;\n            long stopOffset = fromOffset;\n            int adjMaxEvents = maxEvents;\n\n            if (fromOffset < 0)  {\n              startOffset = latestOffset - maxEvents;\n              stopOffset = latestOffset;\n            }\n\n            if (startOffset < earliestOffset) {\n              startOffset = earliestOffset;\n              adjMaxEvents = (int) (fromOffset - startOffset);\n            }\n\n            if (startOffset >= stopOffset || startOffset >= latestOffset) {\n              // At end of kafka events, nothing to return\n              return;\n            }\n\n            fetchLogEvents(kafkaConsumer, logFilter, startOffset, stopOffset, adjMaxEvents, callback);\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","id":72927,"modified_method":"@Override\n  public void getLogPrev(final LoggingContext loggingContext, final long fromOffset, final int maxEvents,\n                              final Filter filter, final Callback callback) {\n    executor.submit(\n      new Runnable() {\n        @Override\n        public void run() {\n          int partition = partitioner.partition(loggingContext.getLogPartition(), numPartitions);\n\n          callback.init();\n\n          KafkaConsumer kafkaConsumer = new KafkaConsumer(seedBrokers, topic, partition, kafkaTailFetchTimeoutMs);\n          try {\n            Filter logFilter = new AndFilter(ImmutableList.of(LoggingContextHelper.createFilter(loggingContext),\n                                                              filter));\n\n            long latestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.LATEST);\n            long earliestOffset = kafkaConsumer.fetchOffset(KafkaConsumer.Offset.EARLIEST);\n            long startOffset = fromOffset - maxEvents;\n            long stopOffset = fromOffset;\n            int adjMaxEvents = maxEvents;\n\n            if (fromOffset < 0)  {\n              startOffset = latestOffset - maxEvents;\n              stopOffset = latestOffset;\n            }\n\n            if (startOffset < earliestOffset) {\n              startOffset = earliestOffset;\n              adjMaxEvents = (int) (fromOffset - startOffset);\n            }\n\n            if (startOffset >= stopOffset || startOffset >= latestOffset) {\n              // At end of kafka events, nothing to return\n              return;\n            }\n\n            // Events between startOffset and stopOffset may not have the required logs we are looking for,\n            // we'll need to return at least 1 log offset for next getLogPrev call to work.\n            int fetchCount = 0;\n            while (fetchCount == 0) {\n              fetchCount = fetchLogEvents(kafkaConsumer, logFilter, startOffset, stopOffset, adjMaxEvents, callback);\n              stopOffset = startOffset;\n              if (stopOffset <= earliestOffset) {\n                // Truly no log messages found.\n                break;\n              }\n\n              startOffset = startOffset - adjMaxEvents;\n              if (startOffset < earliestOffset) {\n                startOffset = earliestOffset;\n              }\n            }\n          } catch (Throwable e) {\n            LOG.error(\"Got exception: \", e);\n            throw  Throwables.propagate(e);\n          } finally {\n            try {\n              try {\n                callback.close();\n              } finally {\n                kafkaConsumer.close();\n              }\n            } catch (IOException e) {\n              LOG.error(String.format(\"Caught exception when closing KafkaConsumer for topic %s, partition %d\",\n                                      topic, partition), e);\n            }\n          }\n        }\n      }\n    );\n  }","commit_id":"f17668586c3caa0417a6a9b8effd84ade46d8670","url":"https://github.com/caskdata/cdap"},{"original_method":"private KafkaCallback(Filter logFilter, LoggingEventSerializer serializer, int maxEvents, Callback callback) {\n      this.logFilter = logFilter;\n      this.serializer = serializer;\n      this.maxEvents = maxEvents;\n      this.callback = callback;\n    }","id":72928,"modified_method":"private KafkaCallback(Filter logFilter, LoggingEventSerializer serializer, long stopOffset, int maxEvents,\n                          Callback callback) {\n      this.logFilter = logFilter;\n      this.serializer = serializer;\n      this.stopOffset = stopOffset;\n      this.maxEvents = maxEvents;\n      this.callback = callback;\n    }","commit_id":"f17668586c3caa0417a6a9b8effd84ade46d8670","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void handle(long offset, ByteBuffer msgBuffer) {\n      ++count;\n      ILoggingEvent event = serializer.fromBytes(msgBuffer);\n      if (count <= maxEvents && logFilter.match(event)) {\n        callback.handle(new LogEvent(event, offset));\n      }\n      lastOffset = offset;\n    }","id":72929,"modified_method":"@Override\n    public void handle(long offset, ByteBuffer msgBuffer) {\n      ILoggingEvent event = serializer.fromBytes(msgBuffer);\n      if (offset < stopOffset && count < maxEvents && logFilter.match(event)) {\n        ++count;\n        callback.handle(new LogEvent(event, offset));\n      }\n      lastOffset = offset;\n    }","commit_id":"f17668586c3caa0417a6a9b8effd84ade46d8670","url":"https://github.com/caskdata/cdap"},{"original_method":"private void fetchLogEvents(KafkaConsumer kafkaConsumer, Filter logFilter, long startOffset, long stopOffset,\n                              int maxEvents, Callback callback) {\n    KafkaCallback kafkaCallback = new KafkaCallback(logFilter, serializer, maxEvents, callback);\n\n    while (kafkaCallback.getCount() < maxEvents && startOffset < stopOffset) {\n      kafkaConsumer.fetchMessages(startOffset, kafkaCallback);\n      long lastOffset = kafkaCallback.getLastOffset();\n\n      // No more Kafka messages\n      if (lastOffset == -1) {\n        break;\n      }\n      startOffset = kafkaCallback.getLastOffset() + 1;\n    }\n  }","id":72930,"modified_method":"private int fetchLogEvents(KafkaConsumer kafkaConsumer, Filter logFilter, long startOffset, long stopOffset,\n                              int maxEvents, Callback callback) {\n    KafkaCallback kafkaCallback = new KafkaCallback(logFilter, serializer, stopOffset, maxEvents, callback);\n\n    while (kafkaCallback.getCount() < maxEvents && startOffset < stopOffset) {\n      kafkaConsumer.fetchMessages(startOffset, kafkaCallback);\n      long lastOffset = kafkaCallback.getLastOffset();\n\n      // No more Kafka messages\n      if (lastOffset == -1) {\n        break;\n      }\n      startOffset = kafkaCallback.getLastOffset() + 1;\n    }\n\n    return kafkaCallback.getCount();\n  }","commit_id":"f17668586c3caa0417a6a9b8effd84ade46d8670","url":"https://github.com/caskdata/cdap"},{"original_method":"public void testGetPrev(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogPrev(loggingContext, -1, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    long ultimateOffset =  events.get(9).getOffset();\n\n    loggingContext = new GenericLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\");\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback1.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getLastOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback2.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback4);\n    events = logCallback4.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 15 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 29 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogPrev(loggingContext, 0, 15, Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 25, Filter.EMPTY_FILTER,\n                         logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback9 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ultimateOffset + 1, 15, Filter.EMPTY_FILTER,\n                         logCallback9);\n    events = logCallback9.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 45 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n  }","id":72931,"modified_method":"public void testGetPrev(LogReader logReader, LoggingContext loggingContext) throws Exception {\n    LogCallback logCallback1 = new LogCallback();\n    logReader.getLogPrev(loggingContext, -1, 10, Filter.EMPTY_FILTER, logCallback1);\n    List<LogEvent> events = logCallback1.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    long ultimateOffset =  events.get(9).getOffset();\n\n    loggingContext = new GenericLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\");\n    LogCallback logCallback2 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback1.getFirstOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback2);\n    events = logCallback2.getEvents();\n    Assert.assertEquals(20, events.size());\n    Assert.assertEquals(\"Test log message 30 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 49 arg1 arg2\", events.get(19).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback3 = new LogCallback();\n    logReader.getLogNext(loggingContext, logCallback2.getLastOffset(), 20, Filter.EMPTY_FILTER,\n                         logCallback3);\n    events = logCallback3.getEvents();\n    Assert.assertEquals(10, events.size());\n    Assert.assertEquals(\"Test log message 50 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(9).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback4 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback2.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback4);\n    events = logCallback4.getEvents();\n    LogCallback logCallback41 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback4.getFirstOffset(), 5, Filter.EMPTY_FILTER,\n                         logCallback41);\n    events.addAll(0, logCallback41.getEvents());\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 15 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 29 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback5 = new LogCallback();\n    logReader.getLogPrev(loggingContext, 0, 15, Filter.EMPTY_FILTER, logCallback5);\n    events = logCallback5.getEvents();\n    Assert.assertEquals(0, events.size());\n\n    LogCallback logCallback6 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback41.getFirstOffset(), 25, Filter.EMPTY_FILTER,\n                         logCallback6);\n    events = logCallback6.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback7 = new LogCallback();\n    logReader.getLogPrev(loggingContext, logCallback41.getFirstOffset(), 15, Filter.EMPTY_FILTER,\n                         logCallback7);\n    events = logCallback7.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 0 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 14 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n\n    LogCallback logCallback9 = new LogCallback();\n    logReader.getLogPrev(loggingContext, ultimateOffset + 1, 15, Filter.EMPTY_FILTER,\n                         logCallback9);\n    events = logCallback9.getEvents();\n    Assert.assertEquals(15, events.size());\n    Assert.assertEquals(\"Test log message 45 arg1 arg2\", events.get(0).getLoggingEvent().getFormattedMessage());\n    Assert.assertEquals(\"Test log message 59 arg1 arg2\", events.get(14).getLoggingEvent().getFormattedMessage());\n  }","commit_id":"f17668586c3caa0417a6a9b8effd84ade46d8670","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n    InMemoryTransactionManager txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    txClient = new InMemoryTxSystemClient(txManager);\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n\n    CConfiguration conf = CConfiguration.create();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + KafkaTestBase.getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.KAFKA_PRODUCER_TYPE, \"async\");\n    LogAppender appender = new LogAppenderInitializer(new KafkaLogAppender(conf)).initialize(\"TestKafkaLogging\");\n\n    Logger logger = LoggerFactory.getLogger(\"TestKafkaLogging\");\n    Exception e1 = new Exception(\"Test Exception1\");\n    Exception e2 = new Exception(\"Test Exception2\", e1);\n    for (int i = 0; i < 60; ++i) {\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    StatusPrinter.setPrintStream(new PrintStream(bos));\n    StatusPrinter.print((LoggerContext) LoggerFactory.getILoggerFactory());\n    System.out.println(bos.toString());\n\n    appender.stop();\n  }","id":72932,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n    InMemoryTransactionManager txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    txClient = new InMemoryTxSystemClient(txManager);\n\n    CConfiguration conf = CConfiguration.create();\n    conf.set(LoggingConfiguration.KAFKA_SEED_BROKERS, \"localhost:\" + KafkaTestBase.getKafkaPort());\n    conf.set(LoggingConfiguration.NUM_PARTITIONS, \"2\");\n    conf.set(LoggingConfiguration.KAFKA_PRODUCER_TYPE, \"async\");\n    LogAppender appender = new LogAppenderInitializer(new KafkaLogAppender(conf)).initialize(\"TestKafkaLogging\");\n\n    Logger logger = LoggerFactory.getLogger(\"TestKafkaLogging\");\n    Exception e1 = new Exception(\"Test Exception1\");\n    Exception e2 = new Exception(\"Test Exception2\", e1);\n\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_2\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n    for (int i = 0; i < 40; ++i) {\n      logger.warn(\"ACCT_2 Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n    for (int i = 0; i < 20; ++i) {\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_2\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n    for (int i = 40; i < 80; ++i) {\n      logger.warn(\"ACCT_2 Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n    for (int i = 20; i < 40; ++i) {\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_1\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n    for (int i = 40; i < 60; ++i) {\n      logger.warn(\"Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    LoggingContextAccessor.setLoggingContext(new FlowletLoggingContext(\"TFL_ACCT_2\", \"APP_1\", \"FLOW_1\", \"FLOWLET_1\"));\n    for (int i = 80; i < 120; ++i) {\n      logger.warn(\"ACCT_2 Test log message \" + i + \" {} {}\", \"arg1\", \"arg2\", e2);\n    }\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    StatusPrinter.setPrintStream(new PrintStream(bos));\n    StatusPrinter.print((LoggerContext) LoggerFactory.getILoggerFactory());\n    System.out.println(bos.toString());\n\n    appender.stop();\n  }","commit_id":"f17668586c3caa0417a6a9b8effd84ade46d8670","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<UpdateRequest> normalize(RuleDto rule) {\n\n    DbSession session = db.openSession(false);\n    try {\n\n      /** Update Fields */\n      Map<String, Object> update = new HashMap<String, Object>();\n\n      update.put(RuleField.ID.field(), rule.getId());\n\n      update.put(RuleField.KEY.field(), rule.getKey().toString());\n      update.put(RuleField._KEY.field(), ImmutableList.of(rule.getKey().repository(), rule.getKey().rule()));\n\n      update.put(RuleField.REPOSITORY.field(), rule.getRepositoryKey());\n      update.put(RuleField.RULE_KEY.field(), rule.getRuleKey());\n      update.put(RuleField.NAME.field(), rule.getName());\n      update.put(RuleField.CREATED_AT.field(), rule.getCreatedAt());\n      update.put(RuleField.UPDATED_AT.field(), rule.getUpdatedAt());\n      update.put(RuleField.HTML_DESCRIPTION.field(), rule.getDescription());\n      update.put(RuleField.FIX_DESCRIPTION.field(), rule.getEffortToFixDescription());\n      update.put(RuleField.SEVERITY.field(), rule.getSeverityString());\n      update.put(RuleField.STATUS.field(), rule.getStatus().name());\n      update.put(RuleField.LANGUAGE.field(), rule.getLanguage());\n      update.put(RuleField.INTERNAL_KEY.field(), rule.getConfigKey());\n      update.put(RuleField.IS_TEMPLATE.field(), rule.isTemplate());\n\n      update.put(RuleField.NOTE.field(), rule.getNoteData());\n      update.put(RuleField.NOTE_LOGIN.field(), rule.getNoteUserLogin());\n      update.put(RuleField.NOTE_CREATED_AT.field(), rule.getNoteCreatedAt());\n      update.put(RuleField.NOTE_UPDATED_AT.field(), rule.getNoteUpdatedAt());\n\n      //TODO Legacy PARENT_ID in DTO should be parent_key\n      Integer templateId = rule.getTemplateId();\n      if (templateId != null) {\n        RuleDto templateRule = db.ruleDao().getById(session, templateId);\n        RuleKey templateKey = templateRule.getKey();\n        update.put(RuleField.TEMPLATE_KEY.field(), templateKey != null ? templateKey.toString() : null);\n      } else {\n        update.put(RuleField.TEMPLATE_KEY.field(), null);\n      }\n\n      //TODO Legacy ID in DTO should be Key\n      update.put(RuleField.CHARACTERISTIC.field(), null);\n      update.put(RuleField.SUB_CHARACTERISTIC.field(), null);\n      update.put(RuleField.DEFAULT_CHARACTERISTIC.field(), null);\n      update.put(RuleField.DEFAULT_SUB_CHARACTERISTIC.field(), null);\n\n      update.put(RuleField.DEFAULT_CHARACTERISTIC.field(), null);\n      update.put(RuleField.DEFAULT_SUB_CHARACTERISTIC.field(), null);\n\n      Integer defaultSubCharacteristicId = rule.getDefaultSubCharacteristicId();\n      if (defaultSubCharacteristicId != null) {\n        CharacteristicDto characteristic, subCharacteristic = null;\n        subCharacteristic = db.debtCharacteristicDao().selectById(defaultSubCharacteristicId, session);\n        if (subCharacteristic != null) {\n          Integer characteristicId = subCharacteristic.getParentId();\n          if (characteristicId != null) {\n            characteristic = db.debtCharacteristicDao().selectById(characteristicId);\n            if (characteristic != null) {\n              update.put(RuleField.DEFAULT_CHARACTERISTIC.field(), characteristic.getKey());\n              update.put(RuleField.DEFAULT_SUB_CHARACTERISTIC.field(), subCharacteristic.getKey());\n            }\n          }\n        }\n      }\n\n      Integer subCharacteristicId = rule.getSubCharacteristicId();\n      if (subCharacteristicId != null) {\n        if (subCharacteristicId.equals(-1)) {\n          update.put(RuleField.CHARACTERISTIC.field(), DebtCharacteristic.NONE);\n          update.put(RuleField.SUB_CHARACTERISTIC.field(), DebtCharacteristic.NONE);\n        } else {\n          CharacteristicDto characteristic, subCharacteristic = null;\n          subCharacteristic = db.debtCharacteristicDao().selectById(subCharacteristicId, session);\n          Integer characteristicId = subCharacteristic.getParentId();\n          if (characteristicId != null) {\n            characteristic = db.debtCharacteristicDao().selectById(characteristicId);\n            if (characteristic != null) {\n              update.put(RuleField.CHARACTERISTIC.field(), characteristic.getKey());\n              update.put(RuleField.SUB_CHARACTERISTIC.field(), subCharacteristic.getKey());\n            }\n          }\n        }\n      } else {\n        update.put(RuleField.CHARACTERISTIC.field(), null);\n        update.put(RuleField.SUB_CHARACTERISTIC.field(), null);\n      }\n\n\n      if (rule.getDefaultRemediationFunction() != null) {\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_TYPE.field(), rule.getDefaultRemediationFunction());\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_COEFFICIENT.field(), rule.getDefaultRemediationCoefficient());\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_OFFSET.field(), rule.getDefaultRemediationOffset());\n      } else {\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_TYPE.field(), null);\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_COEFFICIENT.field(), null);\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_OFFSET.field(), null);\n      }\n\n      if (rule.getRemediationFunction() != null) {\n        update.put(RuleField.DEBT_FUNCTION_TYPE.field(), rule.getRemediationFunction());\n        update.put(RuleField.DEBT_FUNCTION_COEFFICIENT.field(), rule.getRemediationCoefficient());\n        update.put(RuleField.DEBT_FUNCTION_OFFSET.field(), rule.getRemediationOffset());\n      } else {\n        update.put(RuleField.DEBT_FUNCTION_TYPE.field(), null);\n        update.put(RuleField.DEBT_FUNCTION_COEFFICIENT.field(), null);\n        update.put(RuleField.DEBT_FUNCTION_OFFSET.field(), null);\n      }\n\n\n      update.put(RuleField.TAGS.field(), rule.getTags());\n      update.put(RuleField.SYSTEM_TAGS.field(), rule.getSystemTags());\n      update.put(RuleField._TAGS.field(), Sets.union(rule.getSystemTags(), rule.getTags()));\n\n\n      /** Upsert elements */\n      Map<String, Object> upsert = new HashMap<String, Object>(update);\n      upsert.put(RuleField.KEY.field(), rule.getKey().toString());\n      upsert.put(RuleField.PARAMS.field(), new ArrayList<String>());\n\n\n      /** Creating updateRequest */\n      return ImmutableList.of(new UpdateRequest()\n        .replicationType(ReplicationType.ASYNC)\n        .consistencyLevel(WriteConsistencyLevel.QUORUM)\n        .id(rule.getKey().toString())\n        .doc(update)\n        .upsert(upsert));\n\n    } finally {\n      session.close();\n    }\n  }","id":72933,"modified_method":"@Override\n  public List<UpdateRequest> normalize(RuleDto rule) {\n\n    DbSession session = db.openSession(false);\n    try {\n\n      /** Update Fields */\n      Map<String, Object> update = new HashMap<String, Object>();\n\n      update.put(RuleField.ID.field(), rule.getId());\n\n      update.put(RuleField.KEY.field(), rule.getKey().toString());\n      update.put(RuleField._KEY.field(), ImmutableList.of(rule.getKey().repository(), rule.getKey().rule()));\n\n      update.put(RuleField.REPOSITORY.field(), rule.getRepositoryKey());\n      update.put(RuleField.RULE_KEY.field(), rule.getRuleKey());\n      update.put(RuleField.NAME.field(), rule.getName());\n      update.put(RuleField.CREATED_AT.field(), rule.getCreatedAt());\n      update.put(RuleField.UPDATED_AT.field(), rule.getUpdatedAt());\n      update.put(RuleField.HTML_DESCRIPTION.field(), rule.getDescription());\n      update.put(RuleField.FIX_DESCRIPTION.field(), rule.getEffortToFixDescription());\n      update.put(RuleField.SEVERITY.field(), rule.getSeverityString());\n      update.put(RuleField.STATUS.field(), rule.getStatus().name());\n      update.put(RuleField.LANGUAGE.field(), rule.getLanguage());\n      update.put(RuleField.INTERNAL_KEY.field(), rule.getConfigKey());\n      update.put(RuleField.IS_TEMPLATE.field(), rule.isTemplate());\n\n      update.put(RuleField.NOTE.field(), rule.getNoteData());\n      update.put(RuleField.NOTE_LOGIN.field(), rule.getNoteUserLogin());\n      update.put(RuleField.NOTE_CREATED_AT.field(), rule.getNoteCreatedAt());\n      update.put(RuleField.NOTE_UPDATED_AT.field(), rule.getNoteUpdatedAt());\n\n      // TODO Legacy PARENT_ID in DTO should be parent_key\n      Integer templateId = rule.getTemplateId();\n      if (templateId != null) {\n        RuleDto templateRule = db.ruleDao().getById(session, templateId);\n        RuleKey templateKey = templateRule.getKey();\n        update.put(RuleField.TEMPLATE_KEY.field(), templateKey != null ? templateKey.toString() : null);\n      } else {\n        update.put(RuleField.TEMPLATE_KEY.field(), null);\n      }\n\n      // TODO Legacy ID in DTO should be Key\n      update.put(RuleField.CHARACTERISTIC.field(), null);\n      update.put(RuleField.SUB_CHARACTERISTIC.field(), null);\n      update.put(RuleField.DEFAULT_CHARACTERISTIC.field(), null);\n      update.put(RuleField.DEFAULT_SUB_CHARACTERISTIC.field(), null);\n\n      update.put(RuleField.DEFAULT_CHARACTERISTIC.field(), null);\n      update.put(RuleField.DEFAULT_SUB_CHARACTERISTIC.field(), null);\n\n      Integer defaultSubCharacteristicId = rule.getDefaultSubCharacteristicId();\n      if (defaultSubCharacteristicId != null) {\n        CharacteristicDto subCharacteristic = db.debtCharacteristicDao().selectById(defaultSubCharacteristicId, session);\n        if (subCharacteristic != null) {\n          Integer characteristicId = subCharacteristic.getParentId();\n          if (characteristicId != null) {\n            CharacteristicDto characteristic = db.debtCharacteristicDao().selectById(characteristicId);\n            if (characteristic != null) {\n              update.put(RuleField.DEFAULT_CHARACTERISTIC.field(), characteristic.getKey());\n              update.put(RuleField.DEFAULT_SUB_CHARACTERISTIC.field(), subCharacteristic.getKey());\n            }\n          }\n        }\n      }\n\n      Integer subCharacteristicId = rule.getSubCharacteristicId();\n      if (subCharacteristicId != null) {\n        if (subCharacteristicId.equals(-1)) {\n          update.put(RuleField.CHARACTERISTIC.field(), DebtCharacteristic.NONE);\n          update.put(RuleField.SUB_CHARACTERISTIC.field(), DebtCharacteristic.NONE);\n        } else {\n          CharacteristicDto subCharacteristic = db.debtCharacteristicDao().selectById(subCharacteristicId, session);\n          if (subCharacteristic != null) {\n            Integer characteristicId = subCharacteristic.getParentId();\n            if (characteristicId != null) {\n              CharacteristicDto characteristic = db.debtCharacteristicDao().selectById(characteristicId);\n              if (characteristic != null) {\n                update.put(RuleField.CHARACTERISTIC.field(), characteristic.getKey());\n                update.put(RuleField.SUB_CHARACTERISTIC.field(), subCharacteristic.getKey());\n              }\n            }\n          }\n        }\n      } else {\n        update.put(RuleField.CHARACTERISTIC.field(), null);\n        update.put(RuleField.SUB_CHARACTERISTIC.field(), null);\n      }\n\n      if (rule.getDefaultRemediationFunction() != null) {\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_TYPE.field(), rule.getDefaultRemediationFunction());\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_COEFFICIENT.field(), rule.getDefaultRemediationCoefficient());\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_OFFSET.field(), rule.getDefaultRemediationOffset());\n      } else {\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_TYPE.field(), null);\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_COEFFICIENT.field(), null);\n        update.put(RuleField.DEFAULT_DEBT_FUNCTION_OFFSET.field(), null);\n      }\n\n      if (rule.getRemediationFunction() != null) {\n        update.put(RuleField.DEBT_FUNCTION_TYPE.field(), rule.getRemediationFunction());\n        update.put(RuleField.DEBT_FUNCTION_COEFFICIENT.field(), rule.getRemediationCoefficient());\n        update.put(RuleField.DEBT_FUNCTION_OFFSET.field(), rule.getRemediationOffset());\n      } else {\n        update.put(RuleField.DEBT_FUNCTION_TYPE.field(), null);\n        update.put(RuleField.DEBT_FUNCTION_COEFFICIENT.field(), null);\n        update.put(RuleField.DEBT_FUNCTION_OFFSET.field(), null);\n      }\n\n      update.put(RuleField.TAGS.field(), rule.getTags());\n      update.put(RuleField.SYSTEM_TAGS.field(), rule.getSystemTags());\n      update.put(RuleField._TAGS.field(), Sets.union(rule.getSystemTags(), rule.getTags()));\n\n      /** Upsert elements */\n      Map<String, Object> upsert = new HashMap<String, Object>(update);\n      upsert.put(RuleField.KEY.field(), rule.getKey().toString());\n      upsert.put(RuleField.PARAMS.field(), new ArrayList<String>());\n\n      /** Creating updateRequest */\n      return ImmutableList.of(new UpdateRequest()\n        .replicationType(ReplicationType.ASYNC)\n        .consistencyLevel(WriteConsistencyLevel.QUORUM)\n        .id(rule.getKey().toString())\n        .doc(update)\n        .upsert(upsert));\n\n    } finally {\n      session.close();\n    }\n  }","commit_id":"eace062d3e1490aefe9b6270c1a315470dda082a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void update(RuleParamDto param, DbSession session) {\n    getMapper(session).updateParameter(param);\n    session.enqueue(new EmbeddedIndexAction<RuleKey>(this.getIndexName(),\n      IndexAction.Method.UPDATE, param,\n      this.selectById(param.getRuleId(), session).getKey()));\n  }","id":72934,"modified_method":"public void update(RuleParamDto param, DbSession session) {\n    getMapper(session).updateParameter(param);\n    RuleDto dto = this.selectById(param.getRuleId(), session);\n    if(dto != null) {\n      session.enqueue(new EmbeddedIndexAction<RuleKey>(this.getIndexName(),\n        IndexAction.Method.UPDATE, param,\n        dto.getKey()));\n    }\n  }","commit_id":"dc35542f2609c0377dc2a634df1dbd9684427561","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void insert(RuleParamDto param, DbSession session) {\n    getMapper(session).insertParameter(param);\n    session.enqueue(new EmbeddedIndexAction<RuleKey>(this.getIndexName(),\n      IndexAction.Method.INSERT, param,\n      this.selectById(param.getRuleId(), session).getKey()));\n  }","id":72935,"modified_method":"public void insert(RuleParamDto param, DbSession session) {\n    getMapper(session).insertParameter(param);\n    RuleDto dto = this.selectById(param.getRuleId(), session);\n    if(dto != null){\n      session.enqueue(new EmbeddedIndexAction<RuleKey>(this.getIndexName(),\n        IndexAction.Method.INSERT, param,\n        dto.getKey()));\n    }\n  }","commit_id":"dc35542f2609c0377dc2a634df1dbd9684427561","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the AlarmFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets the <em>alarms<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAcknowledgeType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = AlarmUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        AlarmQueryParms parms = new AlarmQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        AlarmCriteria queryCriteria = new AlarmCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        AlarmCriteria countCriteria = new AlarmCriteria(ackType, filters);\n\n        Alarm[] alarms = m_webAlarmRepository.getMatchingAlarms(queryCriteria);\n        \n        // get the total alarm count\n        int alarmCount = m_webAlarmRepository.countMatchingAlarms(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"alarms\", alarms);\n        modelAndView.addObject(\"alarmCount\", alarmCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","id":72936,"modified_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the AlarmFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets the <em>alarms<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAcknowledgeType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = AlarmUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        AlarmQueryParms parms = new AlarmQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        AlarmCriteria queryCriteria = new AlarmCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        AlarmCriteria countCriteria = new AlarmCriteria(ackType, filters);\n\n        Alarm[] alarms = m_webAlarmRepository.getMatchingAlarms(queryCriteria);\n        \n        // get the total alarm count\n        int alarmCount = m_webAlarmRepository.countMatchingAlarms(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"alarms\", alarms);\n        modelAndView.addObject(\"alarmCount\", alarmCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","commit_id":"d9d7eb193ff6ba6132d1aa5f851221b23ac2dddb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     * \n     * <p>\n     * Sets the <em>events<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        List<Filter> filterList = new ArrayList<Filter>();\n        AcknowledgeType ackType = m_defaultEventType;\n\n        String display = request.getParameter(\"display\");\n\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        String idString = request.getParameter(\"id\");\n        if (idString != null) {\n            // asking for a specific ID; only filter should be event ID\n            filterList.add(new EventIdFilter(WebSecurityUtils.safeParseInt(idString)));\n            ackType = null;\n        } else {\n            // otherwise, apply filters/acktype/etc.\n\n            String ackTypeString = request.getParameter(\"acktype\");\n            if (ackTypeString != null) {\n                AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n                if (temp != null) {\n                    ackType = temp;\n                }\n            }\n\n            String[] filterStrings = request.getParameterValues(\"filter\");\n            if (filterStrings != null) {\n                for (String filterString : filterStrings) {\n                    Filter filter = EventUtil.getFilter(filterString);\n                    if (filter != null) {\n                        filterList.add(filter);\n                    }\n                }\n            }\n\n        }\n\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        EventQueryParms parms = new EventQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        EventCriteria queryCriteria = new EventCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        EventCriteria countCriteria = new EventCriteria(ackType, filters);\n\n        Event[] events = m_webEventRepository.getMatchingEvents(queryCriteria);\n        \n        // get the total event count\n        int eventCount = m_webEventRepository.countMatchingEvents(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"eventCount\", eventCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","id":72937,"modified_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     * \n     * <p>\n     * Sets the <em>events<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        List<Filter> filterList = new ArrayList<Filter>();\n        AcknowledgeType ackType = m_defaultEventType;\n\n        String display = request.getParameter(\"display\");\n\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        String idString = request.getParameter(\"id\");\n        if (idString != null) {\n            // asking for a specific ID; only filter should be event ID\n            filterList.add(new EventIdFilter(WebSecurityUtils.safeParseInt(idString)));\n            ackType = null;\n        } else {\n            // otherwise, apply filters/acktype/etc.\n\n            String ackTypeString = request.getParameter(\"acktype\");\n            if (ackTypeString != null) {\n                AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n                if (temp != null) {\n                    ackType = temp;\n                }\n            }\n\n            String[] filterStrings = request.getParameterValues(\"filter\");\n            if (filterStrings != null) {\n                for (String filterString : filterStrings) {\n                    Filter filter = EventUtil.getFilter(filterString);\n                    if (filter != null) {\n                        filterList.add(filter);\n                    }\n                }\n            }\n\n        }\n\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        EventQueryParms parms = new EventQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        EventCriteria queryCriteria = new EventCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        EventCriteria countCriteria = new EventCriteria(ackType, filters);\n\n        Event[] events = m_webEventRepository.getMatchingEvents(queryCriteria);\n        \n        // get the total event count\n        int eventCount = m_webEventRepository.countMatchingEvents(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"eventCount\", eventCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","commit_id":"d9d7eb193ff6ba6132d1aa5f851221b23ac2dddb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of notification filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAckType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = EventUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? m_defaultLongLimit : m_defaultShortLimit;\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        NoticeQueryParms parms = new NoticeQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n\n        NotificationCriteria queryCriteria = new NotificationCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        NotificationCriteria countCriteria = new NotificationCriteria(ackType, filters);\n\n        Notification[] notices = m_webNotificationRepository.getMatchingNotifications(queryCriteria);\n        int noticeCount = m_webNotificationRepository.countMatchingNotifications(countCriteria);\n        Map<Integer,String[]> nodeLabels = new HashMap<Integer,String[]>();\n        Set<Integer> eventIds = new TreeSet<Integer>();\n        \n        // really inefficient, is there a better way to do this?\n        for (Notification notice : notices) {\n            eventIds.add(notice.getEventId());\n            if (!nodeLabels.containsKey(notice.getNodeId())) {\n                String[] labels = null;\n                OnmsNode node = m_nodeDao.get(notice.getNodeId());\n                if (node != null) {\n                    String longLabel = node.getLabel();\n                    if( longLabel == null ) {\n                        labels = new String[] { \"&lt;No Node Label&gt;\", \"&lt;No Node Label&gt;\" };\n                    } else {\n                        if ( longLabel.length() > 32 ) {\n                            String shortLabel = longLabel.substring( 0, 31 ) + \"...\";                        \n                            labels = new String[] { shortLabel, longLabel };\n                        } else {\n                            labels = new String[] { longLabel, longLabel };\n                        }\n                    }\n                }\n                nodeLabels.put( notice.getNodeId(), labels );\n            }\n        }\n        \n        Map<Integer,Event> events = new HashMap<Integer,Event>();\n        if (eventIds.size() > 0) {\n            for (Event e : m_webEventRepository.getMatchingEvents(new EventCriteria(new EventIdListFilter(eventIds)))) {\n                events.put(e.getId(), e);\n            }\n        }\n    \n        ModelAndView modelAndView = new ModelAndView(m_successView);\n        modelAndView.addObject(\"notices\", notices);\n        modelAndView.addObject(\"noticeCount\", noticeCount);\n        modelAndView.addObject(\"nodeLabels\", nodeLabels);\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","id":72938,"modified_method":"/**\n     * Parses the query string to determine what types of notification filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAckType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = EventUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? m_defaultLongLimit : m_defaultShortLimit;\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        NoticeQueryParms parms = new NoticeQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n\n        NotificationCriteria queryCriteria = new NotificationCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        NotificationCriteria countCriteria = new NotificationCriteria(ackType, filters);\n\n        Notification[] notices = m_webNotificationRepository.getMatchingNotifications(queryCriteria);\n        int noticeCount = m_webNotificationRepository.countMatchingNotifications(countCriteria);\n        Map<Integer,String[]> nodeLabels = new HashMap<Integer,String[]>();\n        Set<Integer> eventIds = new TreeSet<Integer>();\n        \n        // really inefficient, is there a better way to do this?\n        for (Notification notice : notices) {\n            eventIds.add(notice.getEventId());\n            if (!nodeLabels.containsKey(notice.getNodeId())) {\n                String[] labels = null;\n                OnmsNode node = m_nodeDao.get(notice.getNodeId());\n                if (node != null) {\n                    String longLabel = node.getLabel();\n                    if( longLabel == null ) {\n                        labels = new String[] { \"&lt;No Node Label&gt;\", \"&lt;No Node Label&gt;\" };\n                    } else {\n                        if ( longLabel.length() > 32 ) {\n                            String shortLabel = longLabel.substring( 0, 31 ) + \"...\";                        \n                            labels = new String[] { shortLabel, longLabel };\n                        } else {\n                            labels = new String[] { longLabel, longLabel };\n                        }\n                    }\n                }\n                nodeLabels.put( notice.getNodeId(), labels );\n            }\n        }\n        \n        Map<Integer,Event> events = new HashMap<Integer,Event>();\n        if (eventIds.size() > 0) {\n            for (Event e : m_webEventRepository.getMatchingEvents(new EventCriteria(new EventIdListFilter(eventIds)))) {\n                events.put(e.getId(), e);\n            }\n        }\n    \n        ModelAndView modelAndView = new ModelAndView(m_successView);\n        modelAndView.addObject(\"notices\", notices);\n        modelAndView.addObject(\"noticeCount\", noticeCount);\n        modelAndView.addObject(\"nodeLabels\", nodeLabels);\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","commit_id":"d9d7eb193ff6ba6132d1aa5f851221b23ac2dddb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the OutageFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets request attributes for the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the outage type parameter\n        String outageTypeString = request.getParameter(\"outtype\");\n        OutageType outageType = m_defaultOutageType;\n        if (outageTypeString != null) {\n            OutageType temp = OutageType.getOutageType(outageTypeString);\n            if (temp != null) {\n                outageType = temp;\n            } else {\n                try {\n                    // handle old URLs which used numeric constants\n                    int outageTypeInt = Integer.parseInt(outageTypeString);\n                    outageType = OutageType.values()[outageTypeInt - 1];\n                } catch (Exception e) {\n                    // nothing else to try, leave it at the default\n                }\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = OutageUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        OutageQueryParms parms = new OutageQueryParms();\n        parms.outageType = outageType;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        OutageCriteria queryCriteria = new OutageCriteria(filters, sortStyle, outageType, limit, limit * multiple);\n        OutageCriteria countCriteria = new OutageCriteria(outageType, filters);\n\n        Outage[] outages = m_webOutageRepository.getMatchingOutages(queryCriteria);\n        \n        // get the total outage count\n        int outageCount = m_webOutageRepository.countMatchingOutages(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"outages\", outages);\n        modelAndView.addObject(\"outageCount\", outageCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","id":72939,"modified_method":"/**\n     * Parses the query string to determine what types of filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the OutageFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets request attributes for the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the outage type parameter\n        String outageTypeString = request.getParameter(\"outtype\");\n        OutageType outageType = m_defaultOutageType;\n        if (outageTypeString != null) {\n            OutageType temp = OutageType.getOutageType(outageTypeString);\n            if (temp != null) {\n                outageType = temp;\n            } else {\n                try {\n                    // handle old URLs which used numeric constants\n                    int outageTypeInt = Integer.parseInt(outageTypeString);\n                    outageType = OutageType.values()[outageTypeInt - 1];\n                } catch (Exception e) {\n                    // nothing else to try, leave it at the default\n                }\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = OutageUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        OutageQueryParms parms = new OutageQueryParms();\n        parms.outageType = outageType;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        OutageCriteria queryCriteria = new OutageCriteria(filters, sortStyle, outageType, limit, limit * multiple);\n        OutageCriteria countCriteria = new OutageCriteria(outageType, filters);\n\n        Outage[] outages = m_webOutageRepository.getMatchingOutages(queryCriteria);\n        \n        // get the total outage count\n        int outageCount = m_webOutageRepository.countMatchingOutages(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"outages\", outages);\n        modelAndView.addObject(\"outageCount\", outageCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","commit_id":"d9d7eb193ff6ba6132d1aa5f851221b23ac2dddb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of filters to use (for\n     * example, what to filter on or sort by), then does the database query\n     * (through the VulnerabilityFactory) and then forwards the results to a JSP\n     * for display.\n     * \n     * <p>\n     * Sets the <em>vuls<\/em> and <em>parms<\/em> request attributes for the\n     * forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        VulnerabilityFactory.SortStyle sortStyle = DEFAULT_SORT_STYLE;\n        if (sortStyleString != null) {\n            Object temp = VulnerabilityUtil.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = (VulnerabilityFactory.SortStyle) temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String resTypeString = request.getParameter(\"restype\");\n        VulnerabilityFactory.ResolutionType resType = DEFAULT_RESOLUTION_TYPE;\n        if (resTypeString != null) {\n            Object temp = VulnerabilityUtil.getResolutionType(resTypeString);\n            if (temp != null) {\n                resType = (VulnerabilityFactory.ResolutionType) temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterArray = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = VulnerabilityUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterArray.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = DEFAULT_LIMIT;\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        try {\n            // put the parameters in a convenient struct\n            VulnerabilityQueryParms parms = new VulnerabilityQueryParms();\n            parms.sortStyle = sortStyle;\n            parms.resType = resType;\n            parms.filters = filterArray;\n            parms.limit = limit;\n            parms.multiple = multiple;\n\n            // query the vulnerabilities with the new filters array\n            Vulnerability[] vuls = VulnerabilityFactory.getVulnerabilities(sortStyle, resType, parms.getFilters(), limit, multiple * limit);\n\n            // add the necessary data to the request so the\n            // JSP (or whatever gets called) can create the view correctly\n            request.setAttribute(\"vuls\", vuls);\n            request.setAttribute(\"parms\", parms);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/vulnerability/list.jsp\");\n            dispatcher.forward(request, response);\n        } catch (SQLException e) {\n            throw new ServletException(\"\", e);\n        }\n    }","id":72940,"modified_method":"/**\n     * Parses the query string to determine what types of filters to use (for\n     * example, what to filter on or sort by), then does the database query\n     * (through the VulnerabilityFactory) and then forwards the results to a JSP\n     * for display.\n     * \n     * <p>\n     * Sets the <em>vuls<\/em> and <em>parms<\/em> request attributes for the\n     * forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        VulnerabilityFactory.SortStyle sortStyle = DEFAULT_SORT_STYLE;\n        if (sortStyleString != null) {\n            Object temp = VulnerabilityUtil.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = (VulnerabilityFactory.SortStyle) temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String resTypeString = request.getParameter(\"restype\");\n        VulnerabilityFactory.ResolutionType resType = DEFAULT_RESOLUTION_TYPE;\n        if (resTypeString != null) {\n            Object temp = VulnerabilityUtil.getResolutionType(resTypeString);\n            if (temp != null) {\n                resType = (VulnerabilityFactory.ResolutionType) temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterArray = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = VulnerabilityUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterArray.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = DEFAULT_LIMIT;\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        try {\n            // put the parameters in a convenient struct\n            VulnerabilityQueryParms parms = new VulnerabilityQueryParms();\n            parms.sortStyle = sortStyle;\n            parms.resType = resType;\n            parms.filters = filterArray;\n            parms.limit = limit;\n            parms.multiple = multiple;\n\n            // query the vulnerabilities with the new filters array\n            Vulnerability[] vuls = VulnerabilityFactory.getVulnerabilities(sortStyle, resType, parms.getFilters(), limit, multiple * limit);\n\n            // add the necessary data to the request so the\n            // JSP (or whatever gets called) can create the view correctly\n            request.setAttribute(\"vuls\", vuls);\n            request.setAttribute(\"parms\", parms);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/vulnerability/list.jsp\");\n            dispatcher.forward(request, response);\n        } catch (SQLException e) {\n            throw new ServletException(\"\", e);\n        }\n    }","commit_id":"d9d7eb193ff6ba6132d1aa5f851221b23ac2dddb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the AlarmFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets the <em>alarms<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAcknowledgeType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = AlarmUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        AlarmQueryParms parms = new AlarmQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        AlarmCriteria queryCriteria = new AlarmCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        AlarmCriteria countCriteria = new AlarmCriteria(ackType, filters);\n\n        Alarm[] alarms = m_webAlarmRepository.getMatchingAlarms(queryCriteria);\n        \n        // get the total alarm count\n        int alarmCount = m_webAlarmRepository.countMatchingAlarms(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"alarms\", alarms);\n        modelAndView.addObject(\"alarmCount\", alarmCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","id":72941,"modified_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the AlarmFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets the <em>alarms<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAcknowledgeType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = AlarmUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        AlarmQueryParms parms = new AlarmQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        AlarmCriteria queryCriteria = new AlarmCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        AlarmCriteria countCriteria = new AlarmCriteria(ackType, filters);\n\n        Alarm[] alarms = m_webAlarmRepository.getMatchingAlarms(queryCriteria);\n        \n        // get the total alarm count\n        int alarmCount = m_webAlarmRepository.countMatchingAlarms(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"alarms\", alarms);\n        modelAndView.addObject(\"alarmCount\", alarmCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","commit_id":"75cf19a7963ead565890c7d76891657c43de7e53","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     * \n     * <p>\n     * Sets the <em>events<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        List<Filter> filterList = new ArrayList<Filter>();\n        AcknowledgeType ackType = m_defaultEventType;\n\n        String display = request.getParameter(\"display\");\n\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        String idString = request.getParameter(\"id\");\n        if (idString != null) {\n            // asking for a specific ID; only filter should be event ID\n            filterList.add(new EventIdFilter(WebSecurityUtils.safeParseInt(idString)));\n            ackType = null;\n        } else {\n            // otherwise, apply filters/acktype/etc.\n\n            String ackTypeString = request.getParameter(\"acktype\");\n            if (ackTypeString != null) {\n                AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n                if (temp != null) {\n                    ackType = temp;\n                }\n            }\n\n            String[] filterStrings = request.getParameterValues(\"filter\");\n            if (filterStrings != null) {\n                for (String filterString : filterStrings) {\n                    Filter filter = EventUtil.getFilter(filterString);\n                    if (filter != null) {\n                        filterList.add(filter);\n                    }\n                }\n            }\n\n        }\n\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        EventQueryParms parms = new EventQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        EventCriteria queryCriteria = new EventCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        EventCriteria countCriteria = new EventCriteria(ackType, filters);\n\n        Event[] events = m_webEventRepository.getMatchingEvents(queryCriteria);\n        \n        // get the total event count\n        int eventCount = m_webEventRepository.countMatchingEvents(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"eventCount\", eventCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","id":72942,"modified_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     * \n     * <p>\n     * Sets the <em>events<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        List<Filter> filterList = new ArrayList<Filter>();\n        AcknowledgeType ackType = m_defaultEventType;\n\n        String display = request.getParameter(\"display\");\n\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        String idString = request.getParameter(\"id\");\n        if (idString != null) {\n            // asking for a specific ID; only filter should be event ID\n            filterList.add(new EventIdFilter(WebSecurityUtils.safeParseInt(idString)));\n            ackType = null;\n        } else {\n            // otherwise, apply filters/acktype/etc.\n\n            String ackTypeString = request.getParameter(\"acktype\");\n            if (ackTypeString != null) {\n                AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n                if (temp != null) {\n                    ackType = temp;\n                }\n            }\n\n            String[] filterStrings = request.getParameterValues(\"filter\");\n            if (filterStrings != null) {\n                for (String filterString : filterStrings) {\n                    Filter filter = EventUtil.getFilter(filterString);\n                    if (filter != null) {\n                        filterList.add(filter);\n                    }\n                }\n            }\n\n        }\n\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        EventQueryParms parms = new EventQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        EventCriteria queryCriteria = new EventCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        EventCriteria countCriteria = new EventCriteria(ackType, filters);\n\n        Event[] events = m_webEventRepository.getMatchingEvents(queryCriteria);\n        \n        // get the total event count\n        int eventCount = m_webEventRepository.countMatchingEvents(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"eventCount\", eventCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","commit_id":"75cf19a7963ead565890c7d76891657c43de7e53","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of notification filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAckType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = EventUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? m_defaultLongLimit : m_defaultShortLimit;\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        NoticeQueryParms parms = new NoticeQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n\n        NotificationCriteria queryCriteria = new NotificationCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        NotificationCriteria countCriteria = new NotificationCriteria(ackType, filters);\n\n        Notification[] notices = m_webNotificationRepository.getMatchingNotifications(queryCriteria);\n        int noticeCount = m_webNotificationRepository.countMatchingNotifications(countCriteria);\n        Map<Integer,String[]> nodeLabels = new HashMap<Integer,String[]>();\n        Set<Integer> eventIds = new TreeSet<Integer>();\n        \n        // really inefficient, is there a better way to do this?\n        for (Notification notice : notices) {\n            eventIds.add(notice.getEventId());\n            if (!nodeLabels.containsKey(notice.getNodeId())) {\n                String[] labels = null;\n                OnmsNode node = m_nodeDao.get(notice.getNodeId());\n                if (node != null) {\n                    String longLabel = node.getLabel();\n                    if( longLabel == null ) {\n                        labels = new String[] { \"&lt;No Node Label&gt;\", \"&lt;No Node Label&gt;\" };\n                    } else {\n                        if ( longLabel.length() > 32 ) {\n                            String shortLabel = longLabel.substring( 0, 31 ) + \"...\";                        \n                            labels = new String[] { shortLabel, longLabel };\n                        } else {\n                            labels = new String[] { longLabel, longLabel };\n                        }\n                    }\n                }\n                nodeLabels.put( notice.getNodeId(), labels );\n            }\n        }\n        \n        Map<Integer,Event> events = new HashMap<Integer,Event>();\n        if (eventIds.size() > 0) {\n            for (Event e : m_webEventRepository.getMatchingEvents(new EventCriteria(new EventIdListFilter(eventIds)))) {\n                events.put(e.getId(), e);\n            }\n        }\n    \n        ModelAndView modelAndView = new ModelAndView(m_successView);\n        modelAndView.addObject(\"notices\", notices);\n        modelAndView.addObject(\"noticeCount\", noticeCount);\n        modelAndView.addObject(\"nodeLabels\", nodeLabels);\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","id":72943,"modified_method":"/**\n     * Parses the query string to determine what types of notification filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAckType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = EventUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? m_defaultLongLimit : m_defaultShortLimit;\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        NoticeQueryParms parms = new NoticeQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n\n        NotificationCriteria queryCriteria = new NotificationCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        NotificationCriteria countCriteria = new NotificationCriteria(ackType, filters);\n\n        Notification[] notices = m_webNotificationRepository.getMatchingNotifications(queryCriteria);\n        int noticeCount = m_webNotificationRepository.countMatchingNotifications(countCriteria);\n        Map<Integer,String[]> nodeLabels = new HashMap<Integer,String[]>();\n        Set<Integer> eventIds = new TreeSet<Integer>();\n        \n        // really inefficient, is there a better way to do this?\n        for (Notification notice : notices) {\n            eventIds.add(notice.getEventId());\n            if (!nodeLabels.containsKey(notice.getNodeId())) {\n                String[] labels = null;\n                OnmsNode node = m_nodeDao.get(notice.getNodeId());\n                if (node != null) {\n                    String longLabel = node.getLabel();\n                    if( longLabel == null ) {\n                        labels = new String[] { \"&lt;No Node Label&gt;\", \"&lt;No Node Label&gt;\" };\n                    } else {\n                        if ( longLabel.length() > 32 ) {\n                            String shortLabel = longLabel.substring( 0, 31 ) + \"...\";                        \n                            labels = new String[] { shortLabel, longLabel };\n                        } else {\n                            labels = new String[] { longLabel, longLabel };\n                        }\n                    }\n                }\n                nodeLabels.put( notice.getNodeId(), labels );\n            }\n        }\n        \n        Map<Integer,Event> events = new HashMap<Integer,Event>();\n        if (eventIds.size() > 0) {\n            for (Event e : m_webEventRepository.getMatchingEvents(new EventCriteria(new EventIdListFilter(eventIds)))) {\n                events.put(e.getId(), e);\n            }\n        }\n    \n        ModelAndView modelAndView = new ModelAndView(m_successView);\n        modelAndView.addObject(\"notices\", notices);\n        modelAndView.addObject(\"noticeCount\", noticeCount);\n        modelAndView.addObject(\"nodeLabels\", nodeLabels);\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","commit_id":"75cf19a7963ead565890c7d76891657c43de7e53","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the OutageFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets request attributes for the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the outage type parameter\n        String outageTypeString = request.getParameter(\"outtype\");\n        OutageType outageType = m_defaultOutageType;\n        if (outageTypeString != null) {\n            OutageType temp = OutageType.getOutageType(outageTypeString);\n            if (temp != null) {\n                outageType = temp;\n            } else {\n                try {\n                    // handle old URLs which used numeric constants\n                    int outageTypeInt = Integer.parseInt(outageTypeString);\n                    outageType = OutageType.values()[outageTypeInt - 1];\n                } catch (Exception e) {\n                    // nothing else to try, leave it at the default\n                }\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = OutageUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        OutageQueryParms parms = new OutageQueryParms();\n        parms.outageType = outageType;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        OutageCriteria queryCriteria = new OutageCriteria(filters, sortStyle, outageType, limit, limit * multiple);\n        OutageCriteria countCriteria = new OutageCriteria(outageType, filters);\n\n        Outage[] outages = m_webOutageRepository.getMatchingOutages(queryCriteria);\n        \n        // get the total outage count\n        int outageCount = m_webOutageRepository.countMatchingOutages(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"outages\", outages);\n        modelAndView.addObject(\"outageCount\", outageCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","id":72944,"modified_method":"/**\n     * Parses the query string to determine what types of filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the OutageFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets request attributes for the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the outage type parameter\n        String outageTypeString = request.getParameter(\"outtype\");\n        OutageType outageType = m_defaultOutageType;\n        if (outageTypeString != null) {\n            OutageType temp = OutageType.getOutageType(outageTypeString);\n            if (temp != null) {\n                outageType = temp;\n            } else {\n                try {\n                    // handle old URLs which used numeric constants\n                    int outageTypeInt = Integer.parseInt(outageTypeString);\n                    outageType = OutageType.values()[outageTypeInt - 1];\n                } catch (Exception e) {\n                    // nothing else to try, leave it at the default\n                }\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = OutageUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        OutageQueryParms parms = new OutageQueryParms();\n        parms.outageType = outageType;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        OutageCriteria queryCriteria = new OutageCriteria(filters, sortStyle, outageType, limit, limit * multiple);\n        OutageCriteria countCriteria = new OutageCriteria(outageType, filters);\n\n        Outage[] outages = m_webOutageRepository.getMatchingOutages(queryCriteria);\n        \n        // get the total outage count\n        int outageCount = m_webOutageRepository.countMatchingOutages(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"outages\", outages);\n        modelAndView.addObject(\"outageCount\", outageCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","commit_id":"75cf19a7963ead565890c7d76891657c43de7e53","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of filters to use (for\n     * example, what to filter on or sort by), then does the database query\n     * (through the VulnerabilityFactory) and then forwards the results to a JSP\n     * for display.\n     * \n     * <p>\n     * Sets the <em>vuls<\/em> and <em>parms<\/em> request attributes for the\n     * forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        VulnerabilityFactory.SortStyle sortStyle = DEFAULT_SORT_STYLE;\n        if (sortStyleString != null) {\n            Object temp = VulnerabilityUtil.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = (VulnerabilityFactory.SortStyle) temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String resTypeString = request.getParameter(\"restype\");\n        VulnerabilityFactory.ResolutionType resType = DEFAULT_RESOLUTION_TYPE;\n        if (resTypeString != null) {\n            Object temp = VulnerabilityUtil.getResolutionType(resTypeString);\n            if (temp != null) {\n                resType = (VulnerabilityFactory.ResolutionType) temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterArray = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = VulnerabilityUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterArray.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = DEFAULT_LIMIT;\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        try {\n            // put the parameters in a convenient struct\n            VulnerabilityQueryParms parms = new VulnerabilityQueryParms();\n            parms.sortStyle = sortStyle;\n            parms.resType = resType;\n            parms.filters = filterArray;\n            parms.limit = limit;\n            parms.multiple = multiple;\n\n            // query the vulnerabilities with the new filters array\n            Vulnerability[] vuls = VulnerabilityFactory.getVulnerabilities(sortStyle, resType, parms.getFilters(), limit, multiple * limit);\n\n            // add the necessary data to the request so the\n            // JSP (or whatever gets called) can create the view correctly\n            request.setAttribute(\"vuls\", vuls);\n            request.setAttribute(\"parms\", parms);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/vulnerability/list.jsp\");\n            dispatcher.forward(request, response);\n        } catch (SQLException e) {\n            throw new ServletException(\"\", e);\n        }\n    }","id":72945,"modified_method":"/**\n     * Parses the query string to determine what types of filters to use (for\n     * example, what to filter on or sort by), then does the database query\n     * (through the VulnerabilityFactory) and then forwards the results to a JSP\n     * for display.\n     * \n     * <p>\n     * Sets the <em>vuls<\/em> and <em>parms<\/em> request attributes for the\n     * forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        VulnerabilityFactory.SortStyle sortStyle = DEFAULT_SORT_STYLE;\n        if (sortStyleString != null) {\n            Object temp = VulnerabilityUtil.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = (VulnerabilityFactory.SortStyle) temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String resTypeString = request.getParameter(\"restype\");\n        VulnerabilityFactory.ResolutionType resType = DEFAULT_RESOLUTION_TYPE;\n        if (resTypeString != null) {\n            Object temp = VulnerabilityUtil.getResolutionType(resTypeString);\n            if (temp != null) {\n                resType = (VulnerabilityFactory.ResolutionType) temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterArray = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = VulnerabilityUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterArray.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = DEFAULT_LIMIT;\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        try {\n            // put the parameters in a convenient struct\n            VulnerabilityQueryParms parms = new VulnerabilityQueryParms();\n            parms.sortStyle = sortStyle;\n            parms.resType = resType;\n            parms.filters = filterArray;\n            parms.limit = limit;\n            parms.multiple = multiple;\n\n            // query the vulnerabilities with the new filters array\n            Vulnerability[] vuls = VulnerabilityFactory.getVulnerabilities(sortStyle, resType, parms.getFilters(), limit, multiple * limit);\n\n            // add the necessary data to the request so the\n            // JSP (or whatever gets called) can create the view correctly\n            request.setAttribute(\"vuls\", vuls);\n            request.setAttribute(\"parms\", parms);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/vulnerability/list.jsp\");\n            dispatcher.forward(request, response);\n        } catch (SQLException e) {\n            throw new ServletException(\"\", e);\n        }\n    }","commit_id":"75cf19a7963ead565890c7d76891657c43de7e53","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * Extracts the key parameters from the parameter set, translates them into\n     * filter-based parameters, and then passes the modified parameter set to\n     * the event filter.\n     */\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        List<Filter> filterArray = new ArrayList<Filter>();\n\n        // convenient syntax for LogMessageSubstringFilter\n        String msgSubstring = WebSecurityUtils.sanitizeString(request.getParameter(\"msgsub\"));\n        if (msgSubstring != null && msgSubstring.length() > 0) {\n            filterArray.add(new LogMessageSubstringFilter(msgSubstring));\n        }\n\n        // convenient syntax for LogMessageMatchesAnyFilter\n        String msgMatchAny = WebSecurityUtils.sanitizeString(request.getParameter(\"msgmatchany\"));\n        if (msgMatchAny != null && msgMatchAny.length() > 0) {\n            filterArray.add(new LogMessageMatchesAnyFilter(msgMatchAny));\n        }\n\n        // convenient syntax for NodeNameContainingFilter\n        String nodeNameLike = WebSecurityUtils.sanitizeString(request.getParameter(\"nodenamelike\"));\n        if (nodeNameLike != null && nodeNameLike.length() > 0) {\n            filterArray.add(new NodeNameLikeFilter(nodeNameLike));\n        }\n\n        // convenient syntax for ExactUEIFilter\n        String exactUEI = WebSecurityUtils.sanitizeString(request.getParameter(\"exactuei\"));\n        if (exactUEI != null && exactUEI.length() > 0) {\n            filterArray.add(new ExactUEIFilter(exactUEI));\n        }\n\n        // convenient syntax for ServiceFilter\n        String service = WebSecurityUtils.sanitizeString(request.getParameter(\"service\"));\n        if (service != null && !service.equalsIgnoreCase(\"any\")) {\n            filterArray.add(new ServiceFilter(WebSecurityUtils.safeParseInt(service), this.getServletContext()));\n        }\n\n        // convenient syntax for IPLikeFilter\n        String ipLikePattern = WebSecurityUtils.sanitizeString(request.getParameter(\"iplike\"));\n        if (ipLikePattern != null && !ipLikePattern.equals(\"\")) {\n            filterArray.add(new IPAddrLikeFilter(ipLikePattern));\n        }\n\n        // convenient syntax for SeverityFilter\n        String severity = WebSecurityUtils.sanitizeString(request.getParameter(\"severity\"));\n        if (severity != null && !severity.equalsIgnoreCase(\"any\")) {\n            filterArray.add(new SeverityFilter(WebSecurityUtils.safeParseInt(severity)));\n        }\n\n        // convenient syntax for AfterDateFilter as relative to current time\n        String relativeTime = WebSecurityUtils.sanitizeString(request.getParameter(\"relativetime\"));\n        if (relativeTime != null && !relativeTime.equalsIgnoreCase(\"any\")) {\n            try {\n                filterArray.add(EventUtil.getRelativeTimeFilter(WebSecurityUtils.safeParseInt(relativeTime)));\n            } catch (IllegalArgumentException e) {\n                // ignore the relative time if it is an illegal value\n                this.log(\"Illegal relativetime value\", e);\n            }\n        }\n\n        String useBeforeTime = WebSecurityUtils.sanitizeString(request.getParameter(\"usebeforetime\"));\n        if (useBeforeTime != null && useBeforeTime.equals(\"1\")) {\n            try {\n                filterArray.add(this.getBeforeDateFilter(request));\n            } catch (IllegalArgumentException e) {\n                // ignore the before time if it is an illegal value\n                this.log(\"Illegal before time value\", e);\n            } catch (MissingParameterException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        String useAfterTime = WebSecurityUtils.sanitizeString(request.getParameter(\"useaftertime\"));\n        if (useAfterTime != null && useAfterTime.equals(\"1\")) {\n            try {\n                filterArray.add(this.getAfterDateFilter(request));\n            } catch (IllegalArgumentException e) {\n                // ignore the after time if it is an illegal value\n                this.log(\"Illegal after time value\", e);\n            } catch (MissingParameterException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        String queryString = \"\";\n\n        if (filterArray.size() > 0) {\n            String[] filterStrings = new String[filterArray.size()];\n\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = filterArray.get(i);\n                filterStrings[i] = EventUtil.getFilterString(filter);\n            }\n\n            Map<String, Object> paramAdditions = new HashMap<String, Object>();\n            paramAdditions.put(\"filter\", filterStrings);\n\n            queryString = WebSecurityUtils.sanitizeString(Util.makeQueryString(request, paramAdditions, IGNORE_LIST));\n        } else {\n            queryString = WebSecurityUtils.sanitizeString(Util.makeQueryString(request, IGNORE_LIST));\n        }\n\n        response.sendRedirect(redirectUrl + \"?\" + queryString);\n    }","id":72946,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * Extracts the key parameters from the parameter set, translates them into\n     * filter-based parameters, and then passes the modified parameter set to\n     * the event filter.\n     */\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        List<Filter> filterArray = new ArrayList<Filter>();\n\n        // convenient syntax for LogMessageSubstringFilter\n        String msgSubstring = WebSecurityUtils.sanitizeString(request.getParameter(\"msgsub\"));\n        if (msgSubstring != null && msgSubstring.length() > 0) {\n            filterArray.add(new LogMessageSubstringFilter(msgSubstring));\n        }\n\n        // convenient syntax for LogMessageMatchesAnyFilter\n        String msgMatchAny = WebSecurityUtils.sanitizeString(request.getParameter(\"msgmatchany\"));\n        if (msgMatchAny != null && msgMatchAny.length() > 0) {\n            filterArray.add(new LogMessageMatchesAnyFilter(msgMatchAny));\n        }\n\n        // convenient syntax for NodeNameContainingFilter\n        String nodeNameLike = WebSecurityUtils.sanitizeString(request.getParameter(\"nodenamelike\"));\n        if (nodeNameLike != null && nodeNameLike.length() > 0) {\n            filterArray.add(new NodeNameLikeFilter(nodeNameLike));\n        }\n\n        // convenient syntax for ExactUEIFilter\n        String exactUEI = WebSecurityUtils.sanitizeString(request.getParameter(\"exactuei\"));\n        if (exactUEI != null && exactUEI.length() > 0) {\n            filterArray.add(new ExactUEIFilter(exactUEI));\n        }\n\n        // convenient syntax for ServiceFilter\n        String service = WebSecurityUtils.sanitizeString(request.getParameter(\"service\"));\n        if (service != null && !service.equalsIgnoreCase(\"any\")) {\n            filterArray.add(new ServiceFilter(WebSecurityUtils.safeParseInt(service), this.getServletContext()));\n        }\n\n        // convenient syntax for IPLikeFilter\n        String ipLikePattern = WebSecurityUtils.sanitizeString(request.getParameter(\"iplike\"));\n        if (ipLikePattern != null && !ipLikePattern.equals(\"\")) {\n            filterArray.add(new IPAddrLikeFilter(ipLikePattern));\n        }\n\n        // convenient syntax for SeverityFilter\n        String severity = WebSecurityUtils.sanitizeString(request.getParameter(\"severity\"));\n        if (severity != null && !severity.equalsIgnoreCase(\"any\")) {\n            filterArray.add(new SeverityFilter(WebSecurityUtils.safeParseInt(severity)));\n        }\n\n        // convenient syntax for AfterDateFilter as relative to current time\n        String relativeTime = WebSecurityUtils.sanitizeString(request.getParameter(\"relativetime\"));\n        if (relativeTime != null && !relativeTime.equalsIgnoreCase(\"any\")) {\n            int timeInt = WebSecurityUtils.safeParseInt(relativeTime);\n            if (timeInt > 0) {\n                try {\n                    filterArray.add(EventUtil.getRelativeTimeFilter(timeInt));\n                } catch (IllegalArgumentException e) {\n                    // ignore the relative time if it is an illegal value\n                    this.log(\"Illegal relativetime value\", e);\n                }\n            }\n        }\n\n        String useBeforeTime = WebSecurityUtils.sanitizeString(request.getParameter(\"usebeforetime\"));\n        if (useBeforeTime != null && useBeforeTime.equals(\"1\")) {\n            try {\n                filterArray.add(this.getBeforeDateFilter(request));\n            } catch (IllegalArgumentException e) {\n                // ignore the before time if it is an illegal value\n                this.log(\"Illegal before time value\", e);\n            } catch (MissingParameterException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        String useAfterTime = WebSecurityUtils.sanitizeString(request.getParameter(\"useaftertime\"));\n        if (useAfterTime != null && useAfterTime.equals(\"1\")) {\n            try {\n                filterArray.add(this.getAfterDateFilter(request));\n            } catch (IllegalArgumentException e) {\n                // ignore the after time if it is an illegal value\n                this.log(\"Illegal after time value\", e);\n            } catch (MissingParameterException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        String queryString = \"\";\n\n        if (filterArray.size() > 0) {\n            String[] filterStrings = new String[filterArray.size()];\n\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = filterArray.get(i);\n                filterStrings[i] = EventUtil.getFilterString(filter);\n            }\n\n            Map<String, Object> paramAdditions = new HashMap<String, Object>();\n            paramAdditions.put(\"filter\", filterStrings);\n\n            queryString = WebSecurityUtils.sanitizeString(Util.makeQueryString(request, paramAdditions, IGNORE_LIST));\n        } else {\n            queryString = WebSecurityUtils.sanitizeString(Util.makeQueryString(request, IGNORE_LIST));\n        }\n\n        response.sendRedirect(redirectUrl + \"?\" + queryString);\n    }","commit_id":"5fbb0b64aae9e25c0572f73b4d4b667dfb8f5a55","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the AlarmFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets the <em>alarms<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAcknowledgeType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = AlarmUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        AlarmQueryParms parms = new AlarmQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        AlarmCriteria queryCriteria = new AlarmCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        AlarmCriteria countCriteria = new AlarmCriteria(ackType, filters);\n\n        Alarm[] alarms = m_webAlarmRepository.getMatchingAlarms(queryCriteria);\n        \n        // get the total alarm count\n        int alarmCount = m_webAlarmRepository.countMatchingAlarms(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"alarms\", alarms);\n        modelAndView.addObject(\"alarmCount\", alarmCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","id":72947,"modified_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the AlarmFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets the <em>alarms<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAcknowledgeType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = AlarmUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        AlarmQueryParms parms = new AlarmQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        AlarmCriteria queryCriteria = new AlarmCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        AlarmCriteria countCriteria = new AlarmCriteria(ackType, filters);\n\n        Alarm[] alarms = m_webAlarmRepository.getMatchingAlarms(queryCriteria);\n        \n        // get the total alarm count\n        int alarmCount = m_webAlarmRepository.countMatchingAlarms(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"alarms\", alarms);\n        modelAndView.addObject(\"alarmCount\", alarmCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","commit_id":"aa0b62116e726501721c9f6d8740bb2ffc8d1675","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     * \n     * <p>\n     * Sets the <em>events<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        List<Filter> filterList = new ArrayList<Filter>();\n        AcknowledgeType ackType = m_defaultEventType;\n\n        String display = request.getParameter(\"display\");\n\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        String idString = request.getParameter(\"id\");\n        if (idString != null) {\n            // asking for a specific ID; only filter should be event ID\n            filterList.add(new EventIdFilter(WebSecurityUtils.safeParseInt(idString)));\n            ackType = null;\n        } else {\n            // otherwise, apply filters/acktype/etc.\n\n            String ackTypeString = request.getParameter(\"acktype\");\n            if (ackTypeString != null) {\n                AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n                if (temp != null) {\n                    ackType = temp;\n                }\n            }\n\n            String[] filterStrings = request.getParameterValues(\"filter\");\n            if (filterStrings != null) {\n                for (String filterString : filterStrings) {\n                    Filter filter = EventUtil.getFilter(filterString);\n                    if (filter != null) {\n                        filterList.add(filter);\n                    }\n                }\n            }\n\n        }\n\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        EventQueryParms parms = new EventQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        EventCriteria queryCriteria = new EventCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        EventCriteria countCriteria = new EventCriteria(ackType, filters);\n\n        Event[] events = m_webEventRepository.getMatchingEvents(queryCriteria);\n        \n        // get the total event count\n        int eventCount = m_webEventRepository.countMatchingEvents(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"eventCount\", eventCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","id":72948,"modified_method":"/**\n     * Parses the query string to determine what types of event filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     * \n     * <p>\n     * Sets the <em>events<\/em> and <em>parms<\/em> request attributes for\n     * the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        List<Filter> filterList = new ArrayList<Filter>();\n        AcknowledgeType ackType = m_defaultEventType;\n\n        String display = request.getParameter(\"display\");\n\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        String idString = request.getParameter(\"id\");\n        if (idString != null) {\n            // asking for a specific ID; only filter should be event ID\n            filterList.add(new EventIdFilter(WebSecurityUtils.safeParseInt(idString)));\n            ackType = null;\n        } else {\n            // otherwise, apply filters/acktype/etc.\n\n            String ackTypeString = request.getParameter(\"acktype\");\n            if (ackTypeString != null) {\n                AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n                if (temp != null) {\n                    ackType = temp;\n                }\n            }\n\n            String[] filterStrings = request.getParameterValues(\"filter\");\n            if (filterStrings != null) {\n                for (String filterString : filterStrings) {\n                    Filter filter = EventUtil.getFilter(filterString);\n                    if (filter != null) {\n                        filterList.add(filter);\n                    }\n                }\n            }\n\n        }\n\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        EventQueryParms parms = new EventQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        EventCriteria queryCriteria = new EventCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        EventCriteria countCriteria = new EventCriteria(ackType, filters);\n\n        Event[] events = m_webEventRepository.getMatchingEvents(queryCriteria);\n        \n        // get the total event count\n        int eventCount = m_webEventRepository.countMatchingEvents(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"eventCount\", eventCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","commit_id":"aa0b62116e726501721c9f6d8740bb2ffc8d1675","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of notification filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAckType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = EventUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? m_defaultLongLimit : m_defaultShortLimit;\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        NoticeQueryParms parms = new NoticeQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n\n        NotificationCriteria queryCriteria = new NotificationCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        NotificationCriteria countCriteria = new NotificationCriteria(ackType, filters);\n\n        Notification[] notices = m_webNotificationRepository.getMatchingNotifications(queryCriteria);\n        int noticeCount = m_webNotificationRepository.countMatchingNotifications(countCriteria);\n        Map<Integer,String[]> nodeLabels = new HashMap<Integer,String[]>();\n        Set<Integer> eventIds = new TreeSet<Integer>();\n        \n        // really inefficient, is there a better way to do this?\n        for (Notification notice : notices) {\n            eventIds.add(notice.getEventId());\n            if (!nodeLabels.containsKey(notice.getNodeId())) {\n                String[] labels = null;\n                OnmsNode node = m_nodeDao.get(notice.getNodeId());\n                if (node != null) {\n                    String longLabel = node.getLabel();\n                    if( longLabel == null ) {\n                        labels = new String[] { \"&lt;No Node Label&gt;\", \"&lt;No Node Label&gt;\" };\n                    } else {\n                        if ( longLabel.length() > 32 ) {\n                            String shortLabel = longLabel.substring( 0, 31 ) + \"...\";                        \n                            labels = new String[] { shortLabel, longLabel };\n                        } else {\n                            labels = new String[] { longLabel, longLabel };\n                        }\n                    }\n                }\n                nodeLabels.put( notice.getNodeId(), labels );\n            }\n        }\n        \n        Map<Integer,Event> events = new HashMap<Integer,Event>();\n        if (eventIds.size() > 0) {\n            for (Event e : m_webEventRepository.getMatchingEvents(new EventCriteria(new EventIdListFilter(eventIds)))) {\n                events.put(e.getId(), e);\n            }\n        }\n    \n        ModelAndView modelAndView = new ModelAndView(m_successView);\n        modelAndView.addObject(\"notices\", notices);\n        modelAndView.addObject(\"noticeCount\", noticeCount);\n        modelAndView.addObject(\"nodeLabels\", nodeLabels);\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","id":72949,"modified_method":"/**\n     * Parses the query string to determine what types of notification filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * and then forwards the results to a JSP for display.\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the acknowledgment type parameter\n        String ackTypeString = request.getParameter(\"acktype\");\n        AcknowledgeType ackType = m_defaultAckType;\n        if (ackTypeString != null) {\n            AcknowledgeType temp = AcknowledgeType.getAcknowledgeType(ackTypeString);\n            if (temp != null) {\n                ackType = temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = EventUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? m_defaultLongLimit : m_defaultShortLimit;\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is already set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        NoticeQueryParms parms = new NoticeQueryParms();\n        parms.ackType = ackType;\n        parms.display = display;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n\n        NotificationCriteria queryCriteria = new NotificationCriteria(filters, sortStyle, ackType, limit, limit * multiple);\n        NotificationCriteria countCriteria = new NotificationCriteria(ackType, filters);\n\n        Notification[] notices = m_webNotificationRepository.getMatchingNotifications(queryCriteria);\n        int noticeCount = m_webNotificationRepository.countMatchingNotifications(countCriteria);\n        Map<Integer,String[]> nodeLabels = new HashMap<Integer,String[]>();\n        Set<Integer> eventIds = new TreeSet<Integer>();\n        \n        // really inefficient, is there a better way to do this?\n        for (Notification notice : notices) {\n            eventIds.add(notice.getEventId());\n            if (!nodeLabels.containsKey(notice.getNodeId())) {\n                String[] labels = null;\n                OnmsNode node = m_nodeDao.get(notice.getNodeId());\n                if (node != null) {\n                    String longLabel = node.getLabel();\n                    if( longLabel == null ) {\n                        labels = new String[] { \"&lt;No Node Label&gt;\", \"&lt;No Node Label&gt;\" };\n                    } else {\n                        if ( longLabel.length() > 32 ) {\n                            String shortLabel = longLabel.substring( 0, 31 ) + \"...\";                        \n                            labels = new String[] { shortLabel, longLabel };\n                        } else {\n                            labels = new String[] { longLabel, longLabel };\n                        }\n                    }\n                }\n                nodeLabels.put( notice.getNodeId(), labels );\n            }\n        }\n        \n        Map<Integer,Event> events = new HashMap<Integer,Event>();\n        if (eventIds.size() > 0) {\n            for (Event e : m_webEventRepository.getMatchingEvents(new EventCriteria(new EventIdListFilter(eventIds)))) {\n                events.put(e.getId(), e);\n            }\n        }\n    \n        ModelAndView modelAndView = new ModelAndView(m_successView);\n        modelAndView.addObject(\"notices\", notices);\n        modelAndView.addObject(\"noticeCount\", noticeCount);\n        modelAndView.addObject(\"nodeLabels\", nodeLabels);\n        modelAndView.addObject(\"events\", events);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n    }","commit_id":"aa0b62116e726501721c9f6d8740bb2ffc8d1675","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the OutageFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets request attributes for the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the outage type parameter\n        String outageTypeString = request.getParameter(\"outtype\");\n        OutageType outageType = m_defaultOutageType;\n        if (outageTypeString != null) {\n            OutageType temp = OutageType.getOutageType(outageTypeString);\n            if (temp != null) {\n                outageType = temp;\n            } else {\n                try {\n                    // handle old URLs which used numeric constants\n                    int outageTypeInt = Integer.parseInt(outageTypeString);\n                    outageType = OutageType.values()[outageTypeInt - 1];\n                } catch (Exception e) {\n                    // nothing else to try, leave it at the default\n                }\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = OutageUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        OutageQueryParms parms = new OutageQueryParms();\n        parms.outageType = outageType;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        OutageCriteria queryCriteria = new OutageCriteria(filters, sortStyle, outageType, limit, limit * multiple);\n        OutageCriteria countCriteria = new OutageCriteria(outageType, filters);\n\n        Outage[] outages = m_webOutageRepository.getMatchingOutages(queryCriteria);\n        \n        // get the total outage count\n        int outageCount = m_webOutageRepository.countMatchingOutages(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"outages\", outages);\n        modelAndView.addObject(\"outageCount\", outageCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","id":72950,"modified_method":"/**\n     * Parses the query string to determine what types of filters to use\n     * (for example, what to filter on or sort by), then does the database query\n     * (through the OutageFactory) and then forwards the results to a JSP for\n     * display.\n     * \n     * <p>\n     * Sets request attributes for the forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String display = request.getParameter(\"display\");\n\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        SortStyle sortStyle = m_defaultSortStyle;\n        if (sortStyleString != null) {\n            SortStyle temp = SortStyle.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = temp;\n            }\n        }\n\n        // handle the outage type parameter\n        String outageTypeString = request.getParameter(\"outtype\");\n        OutageType outageType = m_defaultOutageType;\n        if (outageTypeString != null) {\n            OutageType temp = OutageType.getOutageType(outageTypeString);\n            if (temp != null) {\n                outageType = temp;\n            } else {\n                try {\n                    // handle old URLs which used numeric constants\n                    int outageTypeInt = Integer.parseInt(outageTypeString);\n                    outageType = OutageType.values()[outageTypeInt - 1];\n                } catch (Exception e) {\n                    // nothing else to try, leave it at the default\n                }\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterList = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (String filterString : filterStrings) {\n                Filter filter = OutageUtil.getFilter(filterString);\n                if (filter != null) {\n                    filterList.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = \"long\".equals(display) ? getDefaultLongLimit() : getDefaultShortLimit();\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        // put the parameters in a convenient struct\n        \n        Filter[] filters = filterList.toArray(new Filter[0]);\n        \n        OutageQueryParms parms = new OutageQueryParms();\n        parms.outageType = outageType;\n        parms.filters = filterList;\n        parms.limit = limit;\n        parms.multiple =  multiple;\n        parms.sortStyle = sortStyle;\n        \n        OutageCriteria queryCriteria = new OutageCriteria(filters, sortStyle, outageType, limit, limit * multiple);\n        OutageCriteria countCriteria = new OutageCriteria(outageType, filters);\n\n        Outage[] outages = m_webOutageRepository.getMatchingOutages(queryCriteria);\n        \n        // get the total outage count\n        int outageCount = m_webOutageRepository.countMatchingOutages(countCriteria);\n        \n        ModelAndView modelAndView = new ModelAndView(getSuccessView());\n        modelAndView.addObject(\"outages\", outages);\n        modelAndView.addObject(\"outageCount\", outageCount);\n        modelAndView.addObject(\"parms\", parms);\n        return modelAndView;\n\n    }","commit_id":"aa0b62116e726501721c9f6d8740bb2ffc8d1675","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the query string to determine what types of filters to use (for\n     * example, what to filter on or sort by), then does the database query\n     * (through the VulnerabilityFactory) and then forwards the results to a JSP\n     * for display.\n     * \n     * <p>\n     * Sets the <em>vuls<\/em> and <em>parms<\/em> request attributes for the\n     * forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        VulnerabilityFactory.SortStyle sortStyle = DEFAULT_SORT_STYLE;\n        if (sortStyleString != null) {\n            Object temp = VulnerabilityUtil.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = (VulnerabilityFactory.SortStyle) temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String resTypeString = request.getParameter(\"restype\");\n        VulnerabilityFactory.ResolutionType resType = DEFAULT_RESOLUTION_TYPE;\n        if (resTypeString != null) {\n            Object temp = VulnerabilityUtil.getResolutionType(resTypeString);\n            if (temp != null) {\n                resType = (VulnerabilityFactory.ResolutionType) temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterArray = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = VulnerabilityUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterArray.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = DEFAULT_LIMIT;\n\n        if (limitString != null) {\n            try {\n                limit = WebSecurityUtils.safeParseInt(limitString);\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = WebSecurityUtils.safeParseInt(multipleString);\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        try {\n            // put the parameters in a convenient struct\n            VulnerabilityQueryParms parms = new VulnerabilityQueryParms();\n            parms.sortStyle = sortStyle;\n            parms.resType = resType;\n            parms.filters = filterArray;\n            parms.limit = limit;\n            parms.multiple = multiple;\n\n            // query the vulnerabilities with the new filters array\n            Vulnerability[] vuls = VulnerabilityFactory.getVulnerabilities(sortStyle, resType, parms.getFilters(), limit, multiple * limit);\n\n            // add the necessary data to the request so the\n            // JSP (or whatever gets called) can create the view correctly\n            request.setAttribute(\"vuls\", vuls);\n            request.setAttribute(\"parms\", parms);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/vulnerability/list.jsp\");\n            dispatcher.forward(request, response);\n        } catch (SQLException e) {\n            throw new ServletException(\"\", e);\n        }\n    }","id":72951,"modified_method":"/**\n     * Parses the query string to determine what types of filters to use (for\n     * example, what to filter on or sort by), then does the database query\n     * (through the VulnerabilityFactory) and then forwards the results to a JSP\n     * for display.\n     * \n     * <p>\n     * Sets the <em>vuls<\/em> and <em>parms<\/em> request attributes for the\n     * forwardee JSP (or whatever gets called).\n     * <\/p>\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // handle the style sort parameter\n        String sortStyleString = request.getParameter(\"sortby\");\n        VulnerabilityFactory.SortStyle sortStyle = DEFAULT_SORT_STYLE;\n        if (sortStyleString != null) {\n            Object temp = VulnerabilityUtil.getSortStyle(sortStyleString);\n            if (temp != null) {\n                sortStyle = (VulnerabilityFactory.SortStyle) temp;\n            }\n        }\n\n        // handle the acknowledgement type parameter\n        String resTypeString = request.getParameter(\"restype\");\n        VulnerabilityFactory.ResolutionType resType = DEFAULT_RESOLUTION_TYPE;\n        if (resTypeString != null) {\n            Object temp = VulnerabilityUtil.getResolutionType(resTypeString);\n            if (temp != null) {\n                resType = (VulnerabilityFactory.ResolutionType) temp;\n            }\n        }\n\n        // handle the filter parameters\n        String[] filterStrings = request.getParameterValues(\"filter\");\n        List<Filter> filterArray = new ArrayList<Filter>();\n        if (filterStrings != null) {\n            for (int i = 0; i < filterStrings.length; i++) {\n                Filter filter = VulnerabilityUtil.getFilter(filterStrings[i]);\n                if (filter != null) {\n                    filterArray.add(filter);\n                }\n            }\n        }\n\n        // handle the optional limit parameter\n        String limitString = request.getParameter(\"limit\");\n        int limit = DEFAULT_LIMIT;\n\n        if (limitString != null) {\n            try {\n                int newlimit = WebSecurityUtils.safeParseInt(limitString);\n                if (newlimit > 0) {\n                    limit = newlimit;\n                }\n            } catch (NumberFormatException e) {\n                // do nothing, the default is aready set\n            }\n        }\n\n        // handle the optional multiple parameter\n        String multipleString = request.getParameter(\"multiple\");\n        int multiple = DEFAULT_MULTIPLE;\n        if (multipleString != null) {\n            try {\n                multiple = Math.max(0, WebSecurityUtils.safeParseInt(multipleString));\n            } catch (NumberFormatException e) {\n            }\n        }\n\n        try {\n            // put the parameters in a convenient struct\n            VulnerabilityQueryParms parms = new VulnerabilityQueryParms();\n            parms.sortStyle = sortStyle;\n            parms.resType = resType;\n            parms.filters = filterArray;\n            parms.limit = limit;\n            parms.multiple = multiple;\n\n            // query the vulnerabilities with the new filters array\n            Vulnerability[] vuls = VulnerabilityFactory.getVulnerabilities(sortStyle, resType, parms.getFilters(), limit, multiple * limit);\n\n            // add the necessary data to the request so the\n            // JSP (or whatever gets called) can create the view correctly\n            request.setAttribute(\"vuls\", vuls);\n            request.setAttribute(\"parms\", parms);\n\n            // forward the request for proper display\n            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(\"/vulnerability/list.jsp\");\n            dispatcher.forward(request, response);\n        } catch (SQLException e) {\n            throw new ServletException(\"\", e);\n        }\n    }","commit_id":"aa0b62116e726501721c9f6d8740bb2ffc8d1675","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(super.toString());\n    sb.append(\",\").append(cost).append(\")\");\n    return sb.toString();\n  }","id":72952,"modified_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(super.toString());\n    sb.append(\",\").append(cost);\n    if (alignments != null) {\n      sb.append(\", [\").append(StringUtils.join(alignments, \", \")).append(\"]\");\n    }\n    sb.append(\")\");\n    return sb.toString();\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public double cost(K k1, K k2) {\n    if (k1 != null) {\n      return (k1.equals(k2))? 0:1;\n    } else if (k2 != null) {\n      return (k2 == null)? 0:1;\n    } else return 0;\n  }","id":72953,"modified_method":"@Override\n  public double cost(K k1, K k2) {\n    if (k1 != null) {\n      if (k2 == null) return delCost;\n      return (k1.equals(k2))? 0:mismatchCost;\n    } else {\n      return (k2 == null)? 0:insCost;\n    }\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int hashCode() {\n    int result = matched != null ? matched.hashCode() : 0;\n    result = 31 * result + (value != null ? value.hashCode() : 0);\n    result = 31 * result + begin;\n    result = 31 * result + end;\n    return result;\n  }","id":72954,"modified_method":"@Override\n  public int hashCode() {\n    int result = matched != null ? matched.hashCode() : 0;\n    result = 31 * result + begin;\n    result = 31 * result + end;\n    return result;\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public <F> double score(Classifier<L,F> classifier, GeneralDataset<L,F> data) {\n    setLabelIndex(data.labelIndex);\n    clearCounts();\n    int[] labelsArr = data.getLabelsArray();\n    for (int i = 0; i < data.size(); i++) {\n      Datum<L, F> d = data.getRVFDatum(i);\n      L guess = classifier.classOf(d);\n      addGuess(guess, labelIndex.get(labelsArr[i]));\n    }\n    finalizeCounts();\n\n    return getFMeasure();\n  }","id":72955,"modified_method":"public <F> double score(Classifier<L,F> classifier, GeneralDataset<L,F> data) {\n    labelIndex = new HashIndex<L>();\n    labelIndex.addAll(classifier.labels());\n    labelIndex.addAll(data.labelIndex.objectsList());\n    clearCounts();\n    int[] labelsArr = data.getLabelsArray();\n    for (int i = 0; i < data.size(); i++) {\n      Datum<L, F> d = data.getRVFDatum(i);\n      L guess = classifier.classOf(d);\n      addGuess(guess, labelIndex.get(labelsArr[i]));\n    }\n    finalizeCounts();\n\n    return getFMeasure();\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public MultiMatch(List<K> matched, V value, int begin, int end, List<List<K>> multimatched, List<V> multivalues) {\n    this.matched = matched;\n    this.value = value;\n    this.begin = begin;\n    this.end = end;\n    this.multimatched = multimatched;\n    this.multivalues = multivalues;\n  }","id":72956,"modified_method":"public MultiMatch(List<K> matched, V value, int begin, int end, List<Match<K,V>> multimatches) {\n    this.matched = matched;\n    this.value = value;\n    this.begin = begin;\n    this.end = end;\n    this.multimatches = multimatches;\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    if (multimatched != null && multivalues != null) {\n      sb.append(\"[\" + StringUtils.join(multimatched, \"-\") + \"]\");\n      sb.append(\" -> \").append(StringUtils.join(multivalues, \"-\"));\n      sb.append(\" at (\").append(begin);\n      sb.append(\",\").append(end).append(\")\");\n    } else {\n      sb.append(super.toString());\n    }\n    return sb.toString();\n  }","id":72957,"modified_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    if (multimatches != null) {\n      sb.append(\"[\" + StringUtils.join(getMultimatches(), \", \") + \"]\");\n    } else {\n      sb.append(super.toString());\n    }\n    return sb.toString();\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<List<K>> getMultimatched() {\n    return multimatched;\n  }","id":72958,"modified_method":"public List<List<K>> getMultimatched() {\n    if (multimatches == null) return null;\n    List<List<K>> multimatched = new ArrayList<List<K>>(multimatches.size());\n    for (Match<K,V> m:multimatches) {\n      multimatched.add(m.getMatched());\n    }\n    return multimatched;\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<V> getMultivalues() {\n    return multivalues;\n  }","id":72959,"modified_method":"public List<V> getMultivalues() {\n    if (multimatches == null) return null;\n    List<V> multivalues = new ArrayList<V>(multimatches.size());\n    for (Match<K,V> m:multimatches) {\n      multivalues.add(m.getValue());\n    }\n    return multivalues;\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    MultiMatch that = (MultiMatch) o;\n\n    if (multimatched != null ? !multimatched.equals(that.multimatched) : that.multimatched != null) return false;\n    if (multivalues != null ? !multivalues.equals(that.multivalues) : that.multivalues != null) return false;\n\n    return true;\n  }","id":72960,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    MultiMatch that = (MultiMatch) o;\n\n    if (multimatches != null ? !multimatches.equals(that.multimatches) : that.multimatches != null) return false;\n\n    return true;\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void add(PartialApproxMatch<K,V> pam) {\n      Match<K,V> m = new MultiMatch<K,V>(pam.matched, pam.value, pam.begin, pam.end, pam.multimatched, pam.multivalues);\n      queue.put(m, pam);\n    }","id":72961,"modified_method":"public void add(PartialApproxMatch<K,V> pam) {\n      List<Match<K,V>> multiMatchesWithoutOffsets = null;\n      if (pam.multimatches != null) {\n        multiMatchesWithoutOffsets = new ArrayList<Match<K, V>>(pam.multimatches.size());\n        for (Match<K,V> m:pam.multimatches) {\n          multiMatchesWithoutOffsets.add( new Match<K, V>(m.matched, m.value, 0, 0));\n        }\n      }\n      Match<K,V> m = new MultiMatch<K,V>(pam.matched, pam.value, pam.begin, pam.end, multiMatchesWithoutOffsets);\n      queue.put(m, pam);\n    }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TrieMapMatcher(TrieMap<K, V> root) {\n    this.root = root;\n  }","id":72962,"modified_method":"public TrieMapMatcher(TrieMap<K, V> root) {\n    this.root = root;\n    this.rootWithDelimiter = root;\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie\n   *  based on the cost function (lower cost mean better match).\n   * @param target Target sequence to match\n   * @param costFunction Cost function to use\n   * @param maxCost Matches with a cost higher than this are discarded\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, MatchCostFunction<K,V> costFunction,\n                                                   double maxCost, int n, boolean multimatch) {\n    if (root.isEmpty()) return null;\n    int extra = 3;\n    // Find the closest n options to the key in the trie based on the given cost function for substitution\n    // matches[i][j] stores the top n partial matches for i elements from the target\n    //   and j elements from the partial matches from trie keys\n    MatchQueue<K,V> best = new MatchQueue<K, V>(n, maxCost);\n    List<PartialApproxMatch<K,V>>[][] matches = new List[target.size()+1][];\n    for (int i = 0; i <= target.size(); i++) {\n      for (int j = 0; j <= target.size()+extra; j++) {\n        if (j > 0) {\n          boolean complete = (i == target.size()) && (j >= target.size());\n          // Try to pick best match from trie\n          K t = (i > 0 && i <= target.size())? target.get(i-1):null;\n          // Look at the top n choices we saved away and pick n new options\n          MatchQueue<K,V> queue = (multimatch)? new MultiMatchQueue<K, V>(n, maxCost):new MatchQueue<K, V>(n, maxCost);\n          if (i > 0) {\n            for (PartialApproxMatch<K,V> pam:matches[i-1][j-1]) {\n              if (pam.trie != null) {\n                if (pam.trie.children != null) {\n                  for (K k:pam.trie.children.keySet()) {\n                    addToQueue(queue, best, costFunction, pam, t, k, multimatch, complete);\n                  }\n                }\n              }\n            }\n          }\n          for (PartialApproxMatch<K,V> pam:matches[i][j-1]) {\n            if (pam.trie != null) {\n              if (pam.trie.children != null) {\n                for (K k:pam.trie.children.keySet()) {\n                  addToQueue(queue, best, costFunction, pam, null, k, multimatch, complete);\n                }\n              }\n            }\n          }\n          if (i > 0) {\n            for (PartialApproxMatch<K,V> pam:matches[i-1][j]) {\n              addToQueue(queue, best, costFunction, pam, t, null, multimatch, complete);\n            }\n          }\n          matches[i][j] = queue.toSortedList();\n        } else {\n          matches[i] = new List[target.size()+1+extra];\n          matches[i][0] = new ArrayList<PartialApproxMatch<K,V>>();\n          if (i > 0) {\n            K t = (i < target.size())? target.get(i-1):null;\n            for (PartialApproxMatch<K,V> pam:matches[i-1][0]) {\n              PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, costFunction.cost(t, null), t, null);\n              if (npam.cost <= maxCost) {\n                matches[i][0].add(npam);\n              }\n            }\n          } else {\n            matches[i][0].add(new PartialApproxMatch<K,V>(0, root));\n          }\n        }\n//        System.out.println(\"i=\" + i + \",j=\" + j + \",\" + matches[i][j]);\n      }\n    }\n    // Get the best matches\n    List<ApproxMatch<K,V>> res = new ArrayList<ApproxMatch<K,V>>();\n    for (ApproxMatch<K,V> m:best.toSortedList()) {\n      res.add(m);\n    }\n    return res;\n  }","id":72963,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie\n   *  based on the cost function (lower cost mean better match).\n   * @param target Target sequence to match\n   * @param costFunction Cost function to use\n   * @param maxCost Matches with a cost higher than this are discarded\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @param keepAlignments If true, alignment information is returned\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, MatchCostFunction<K,V> costFunction,\n                                                   double maxCost, int n, boolean multimatch, boolean keepAlignments) {\n    if (root.isEmpty()) return null;\n    int extra = 3;\n    // Find the closest n options to the key in the trie based on the given cost function for substitution\n    // matches[i][j] stores the top n partial matches for i elements from the target\n    //   and j elements from the partial matches from trie keys\n\n    // At any time, we only keep track of the last two rows\n    // (prevMatches (matches[i-1][j]), curMatches (matches[i][j]) that we are working on\n    MatchQueue<K,V> best = new MatchQueue<K, V>(n, maxCost);\n    List<PartialApproxMatch<K,V>>[] prevMatches = null;\n    List<PartialApproxMatch<K,V>>[] curMatches;\n    for (int i = 0; i <= target.size(); i++) {\n      curMatches = new List[target.size()+1+extra];\n      for (int j = 0; j <= target.size()+extra; j++) {\n        if (j > 0) {\n          boolean complete = (i == target.size());\n          // Try to pick best match from trie\n          K t = (i > 0 && i <= target.size())? target.get(i-1):null;\n          // Look at the top n choices we saved away and pick n new options\n          MatchQueue<K,V> queue = (multimatch)? new MultiMatchQueue<K, V>(n, maxCost):new MatchQueue<K, V>(n, maxCost);\n          if (i > 0) {\n            for (PartialApproxMatch<K,V> pam:prevMatches[j-1]) {\n              if (pam.trie != null) {\n                if (pam.trie.children != null) {\n                  for (K k:pam.trie.children.keySet()) {\n                    addToQueue(queue, best, costFunction, pam, t, k, multimatch, complete);\n                  }\n                }\n              }\n            }\n          }\n          for (PartialApproxMatch<K,V> pam:curMatches[j-1]) {\n            if (pam.trie != null) {\n              if (pam.trie.children != null) {\n                for (K k:pam.trie.children.keySet()) {\n                  addToQueue(queue, best, costFunction, pam, null, k, multimatch, complete);\n                }\n              }\n            }\n          }\n          if (i > 0) {\n            for (PartialApproxMatch<K,V> pam:prevMatches[j]) {\n              addToQueue(queue, best, costFunction, pam, t, null, multimatch, complete);\n            }\n          }\n          curMatches[j] = queue.toSortedList();\n        } else {\n          curMatches[0] = new ArrayList<PartialApproxMatch<K,V>>();\n          if (i > 0) {\n            K t = (i < target.size())? target.get(i-1):null;\n            for (PartialApproxMatch<K,V> pam:prevMatches[0]) {\n              PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, costFunction.cost(t, null), t, null);\n              if (npam.cost <= maxCost) {\n                curMatches[0].add(npam);\n              }\n            }\n          } else {\n            curMatches[0].add(new PartialApproxMatch<K,V>(0, root, keepAlignments? target.size():0));\n          }\n        }\n//        System.out.println(\"i=\" + i + \",j=\" + j + \",\" + matches[i][j]);\n      }\n      prevMatches = curMatches;\n    }\n    // Get the best matches\n    List<ApproxMatch<K,V>> res = new ArrayList<ApproxMatch<K,V>>();\n    for (PartialApproxMatch<K,V> m:best.toSortedList()) {\n      res.add(m.toApproxMatch());\n    }\n    return res;\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public PartialApproxMatch(double cost, TrieMap<K,V> trie) {\n      this.trie = trie;\n      this.cost = cost;\n      this.value = this.trie.value;\n    }","id":72964,"modified_method":"private PartialApproxMatch(double cost, TrieMap<K,V> trie, int alignmentLength) {\n      this.trie = trie;\n      this.cost = cost;\n      this.value = (trie != null)? this.trie.value:null;\n      if (alignmentLength > 0) {\n        this.alignments = new Interval[alignmentLength];\n      }\n    }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void add(PartialApproxMatch<K,V> pam) {\n      Match<K,V> m = new MultiMatch<K,V>(\n              pam.matched, pam.value, pam.begin, pam.end, pam.multimatched, pam.multivalues);\n      Integer key = (pam.multimatched != null)? pam.multimatched.size():0;\n      if (pam.value == null) key = key + 1;\n      BoundedCostOrderedMap<Match<K,V>, PartialApproxMatch<K,V>> mq = multimatchQueues.get(key);\n      if (mq == null) {\n        multimatchQueues.put(key, mq = new BoundedCostOrderedMap<Match<K,V>, PartialApproxMatch<K,V>>(\n                MATCH_COST_FUNCTION, maxSize, maxCost));\n      }\n      mq.put(m, pam);\n    }","id":72965,"modified_method":"public void add(PartialApproxMatch<K,V> pam) {\n      Match<K,V> m = new MultiMatch<K,V>(\n              pam.matched, pam.value, pam.begin, pam.end, pam.multimatches);\n      Integer key = (pam.multimatches != null)? pam.multimatches.size():0;\n      if (pam.value == null) key = key + 1;\n      BoundedCostOrderedMap<Match<K,V>, PartialApproxMatch<K,V>> mq = multimatchQueues.get(key);\n      if (mq == null) {\n        multimatchQueues.put(key, mq = new BoundedCostOrderedMap<Match<K,V>, PartialApproxMatch<K,V>>(\n                MATCH_COST_FUNCTION, maxSize, maxCost));\n      }\n      mq.put(m, pam);\n    }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n    public int hashCode() {\n      int result = super.hashCode();\n      result = 31 * result + (trie != null ? trie.hashCode() : 0);\n      result = 31 * result + lastMultimatchedStartIndex;\n      return result;\n    }","id":72966,"modified_method":"@Override\n    public int hashCode() {\n      int result = super.hashCode();\n      result = 31 * result + lastMultimatchedMatchedStartIndex;\n      result = 31 * result + lastMultimatchedOriginalStartIndex;\n      return result;\n    }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, int n, boolean multimatch) {\n    return findClosestMatches(target, TrieMapMatcher.<K,V>defaultCost(), Double.MAX_VALUE, n, multimatch);\n  }","id":72967,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @param keepAlignments If true, alignment information is returned\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, int n, boolean multimatch, boolean keepAlignments) {\n    return findClosestMatches(target, TrieMapMatcher.<K,V>defaultCost(), Double.MAX_VALUE, n, multimatch, keepAlignments);\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public PartialApproxMatch() {}","id":72968,"modified_method":"private PartialApproxMatch() {}","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, int n) {\n    return findClosestMatches(target, TrieMapMatcher.<K,V>defaultCost(), Double.MAX_VALUE, n, false);\n  }","id":72969,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, int n) {\n    return findClosestMatches(target, TrieMapMatcher.<K,V>defaultCost(), Double.MAX_VALUE, n, false, false);\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private PartialApproxMatch<K,V> withMatch(MatchCostFunction<K,V> costFunction, double deltaCost, K t, K k) {\n      PartialApproxMatch<K,V> res = new PartialApproxMatch<K,V>();\n      res.matched = matched;\n      if (k != null) {\n        if (res.matched == null) {\n          res.matched = new ArrayList<K>(1);\n        } else {\n          res.matched = new ArrayList<K>(matched.size() + 1);\n          res.matched.addAll(matched);\n        }\n        res.matched.add(k);\n      }\n      res.begin = begin;\n      res.end = (t != null)? end + 1: end;\n      res.cost = cost + deltaCost;\n      res.trie = (k != null)? trie.getChildTrie(k):trie;\n      res.value = res.trie.value;\n      res.multimatched = multimatched;\n      res.multivalues = multivalues;\n      res.lastMultimatchedStartIndex = lastMultimatchedStartIndex;\n      return res;\n    }","id":72970,"modified_method":"private PartialApproxMatch<K,V> withMatch(MatchCostFunction<K,V> costFunction, double deltaCost, K t, K k) {\n      PartialApproxMatch<K,V> res = new PartialApproxMatch<K,V>();\n      res.matched = matched;\n      if (k != null) {\n        if (res.matched == null) {\n          res.matched = new ArrayList<K>(1);\n        } else {\n          res.matched = new ArrayList<K>(matched.size() + 1);\n          res.matched.addAll(matched);\n        }\n        res.matched.add(k);\n      }\n      res.begin = begin;\n      res.end = (t != null)? end + 1: end;\n      res.cost = cost + deltaCost;\n      res.trie = (k != null)? trie.getChildTrie(k):trie;\n      res.value = (res.trie != null)? res.trie.value:null;\n      res.multimatches = multimatches;\n      res.lastMultimatchedMatchedStartIndex = lastMultimatchedMatchedStartIndex;\n      res.lastMultimatchedOriginalStartIndex = lastMultimatchedOriginalStartIndex;\n      if (res.lastMultimatchedOriginalStartIndex == end  && k == null && t != null) {\n        res.lastMultimatchedOriginalStartIndex++;\n      }\n      // Update alignments\n      if (alignments != null) {\n        res.alignments = new Interval[alignments.length];\n        System.arraycopy(alignments, 0, res.alignments, 0, alignments.length);\n        if (k != null && res.end > 0) {\n          int p = res.end-1;\n          if (res.alignments[p] == null) {\n            res.alignments[p] = Interval.toInterval(res.matched.size()-1, res.matched.size());\n          } else {\n            res.alignments[p] = Interval.toInterval(res.alignments[p].getBegin(), res.alignments[p].getEnd() + 1);\n          }\n        }\n      }\n      return res;\n    }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      if (!super.equals(o)) return false;\n\n      PartialApproxMatch that = (PartialApproxMatch) o;\n\n      if (lastMultimatchedStartIndex != that.lastMultimatchedStartIndex) return false;\n      if (trie != null ? !trie.equals(that.trie) : that.trie != null) return false;\n\n      return true;\n    }","id":72971,"modified_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      if (!super.equals(o)) return false;\n\n      PartialApproxMatch that = (PartialApproxMatch) o;\n\n      if (lastMultimatchedMatchedStartIndex != that.lastMultimatchedMatchedStartIndex) return false;\n      if (lastMultimatchedOriginalStartIndex != that.lastMultimatchedOriginalStartIndex) return false;\n      if (trie != null ? !trie.equals(that.trie) : that.trie != null) return false;\n\n      return true;\n    }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(K[] target, int n, boolean multimatch) {\n    return findClosestMatches(Arrays.asList(target), n, multimatch);\n  }","id":72972,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @param keepAlignments If true, alignment information is returned\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(K[] target, int n, boolean multimatch, boolean keepAlignments) {\n    return findClosestMatches(Arrays.asList(target), n, multimatch, keepAlignments);\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private boolean addToQueue(MatchQueue<K,V> queue,\n                             MatchQueue<K,V> best,\n                             MatchCostFunction<K,V> costFunction,\n                             PartialApproxMatch<K,V> pam, K a, K b,\n                             boolean multimatch, boolean complete) {\n    double deltaCost = costFunction.cost(a,b);\n    double newCost = pam.cost + deltaCost;\n    if (newCost > queue.maxCost) return false;\n    if (best.size() >= queue.maxSize && newCost > best.topCost()) return false;\n\n    PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, deltaCost, a, b);\n    if (!multimatch || npam.trie.children != null) {\n      if (!multimatch && complete && npam.value != null) {\n        best.add(npam);\n      }\n      queue.add(npam);\n    }\n\n    if (multimatch && npam.value != null) {\n      npam = pam.withMatch(costFunction, deltaCost, a, b, multimatch, rootWithDelimiter);\n      if (complete && npam.value != null) {\n        best.add(npam);\n      }\n      queue.add(npam);\n    }\n    return true;\n  }","id":72973,"modified_method":"private boolean addToQueue(MatchQueue<K,V> queue,\n                             MatchQueue<K,V> best,\n                             MatchCostFunction<K,V> costFunction,\n                             PartialApproxMatch<K,V> pam, K a, K b,\n                             boolean multimatch, boolean complete) {\n    double deltaCost = costFunction.cost(a,b);\n    double newCost = pam.cost + deltaCost;\n    if (queue.maxCost != Double.MAX_VALUE && newCost > queue.maxCost) return false;\n    if (best.size() >= queue.maxSize && newCost > best.topCost()) return false;\n\n    PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, deltaCost, a, b);\n    if (!multimatch || (npam.trie != null && npam.trie.children != null)) {\n      if (!multimatch && complete && npam.value != null) {\n        best.add(npam);\n      }\n      queue.add(npam);\n    }\n\n    if (multimatch && npam.value != null) {\n      npam = pam.withMatch(costFunction, deltaCost, a, b, multimatch, rootWithDelimiter);\n      if (complete && npam.value != null) {\n        best.add(npam);\n      }\n      queue.add(npam);\n    }\n    return true;\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private PartialApproxMatch<K,V> withMatch(MatchCostFunction<K,V> costFunction, double deltaCost,\n                                              K t, K k, boolean multimatch, TrieMap<K,V> root) {\n      PartialApproxMatch<K,V> res = withMatch(costFunction, deltaCost, t, k);\n      if (multimatch && res.matched != null && res.value != null) {\n        // Update tracking of matched keys and values for multiple entry matches\n        if (res.multivalues == null) {\n          res.multivalues = new ArrayList<V>(1);\n        } else {\n          res.multivalues = new ArrayList<V>(multivalues.size()+1);\n          res.multivalues.addAll(multivalues);\n        }\n        res.multivalues.add(res.value);\n        if (res.multimatched == null) {\n          res.multimatched = new ArrayList<List<K>>(1);\n        } else {\n          res.multimatched = new ArrayList<List<K>>(multimatched.size()+1);\n          res.multimatched.addAll(multimatched);\n        }\n        res.multimatched.add(res.matched.subList(lastMultimatchedStartIndex, res.matched.size()));\n        res.cost += costFunction.multiMatchDeltaCost(res.multimatched.get(res.multimatched.size()-1), res.value, res.multimatched.size());\n        res.lastMultimatchedStartIndex = res.matched.size();\n        // Reset current value/key being matched\n        res.trie = root;\n      }\n      return res;\n    }","id":72974,"modified_method":"private PartialApproxMatch<K,V> withMatch(MatchCostFunction<K,V> costFunction, double deltaCost,\n                                              K t, K k, boolean multimatch, TrieMap<K,V> root) {\n      PartialApproxMatch<K,V> res = withMatch(costFunction, deltaCost, t, k);\n      if (multimatch && res.matched != null && res.value != null) {\n        // Update tracking of matched keys and values for multiple entry matches\n        if (res.multimatches == null) {\n          res.multimatches = new ArrayList<Match<K,V>>(1);\n        } else {\n          res.multimatches = new ArrayList<Match<K,V>>(multimatches.size()+1);\n          res.multimatches.addAll(multimatches);\n        }\n        List<K> newlyMatched = res.matched.subList(lastMultimatchedMatchedStartIndex, res.matched.size());\n        res.multimatches.add( new Match<K, V>(\n                newlyMatched,\n                res.value,\n                lastMultimatchedOriginalStartIndex, res.end\n        ));\n        res.cost += costFunction.multiMatchDeltaCost(newlyMatched, res.value, res.multimatches.size());\n        res.lastMultimatchedMatchedStartIndex = res.matched.size();\n        res.lastMultimatchedOriginalStartIndex = res.end;\n        // Reset current value/key being matched\n        res.trie = root;\n      }\n      return res;\n    }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie\n   *  based on the cost function (lower cost mean better match).\n   * @param target Target sequence to match\n   * @param costFunction Cost function to use\n   * @param maxCost Matches with a cost higher than this are discarded\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(K[] target, MatchCostFunction<K,V> costFunction,\n                                                   Double maxCost, int n, boolean multimatch) {\n    return findClosestMatches(Arrays.asList(target), costFunction, maxCost, n, multimatch);\n  }","id":72975,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie\n   *  based on the cost function (lower cost mean better match).\n   * @param target Target sequence to match\n   * @param costFunction Cost function to use\n   * @param maxCost Matches with a cost higher than this are discarded\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @param keepAlignments If true, alignment information is returned\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(K[] target, MatchCostFunction<K,V> costFunction,\n                                                   Double maxCost, int n, boolean multimatch, boolean keepAlignments) {\n    return findClosestMatches(Arrays.asList(target), costFunction, maxCost, n, multimatch, keepAlignments);\n  }","commit_id":"505f5f46d83e17929652bdc6a7ea0b74f99af592","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(super.toString());\n    sb.append(\",\").append(cost).append(\")\");\n    return sb.toString();\n  }","id":72976,"modified_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(\");\n    sb.append(super.toString());\n    sb.append(\",\").append(cost);\n    if (alignments != null) {\n      sb.append(\", [\").append(StringUtils.join(alignments, \", \")).append(\"]\");\n    }\n    sb.append(\")\");\n    return sb.toString();\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public double cost(K k1, K k2) {\n    if (k1 != null) {\n      return (k1.equals(k2))? 0:1;\n    } else if (k2 != null) {\n      return (k2 == null)? 0:1;\n    } else return 0;\n  }","id":72977,"modified_method":"@Override\n  public double cost(K k1, K k2) {\n    if (k1 != null) {\n      if (k2 == null) return delCost;\n      return (k1.equals(k2))? 0:mismatchCost;\n    } else {\n      return (k2 == null)? 0:insCost;\n    }\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int hashCode() {\n    int result = matched != null ? matched.hashCode() : 0;\n    result = 31 * result + (value != null ? value.hashCode() : 0);\n    result = 31 * result + begin;\n    result = 31 * result + end;\n    return result;\n  }","id":72978,"modified_method":"@Override\n  public int hashCode() {\n    int result = matched != null ? matched.hashCode() : 0;\n    result = 31 * result + begin;\n    result = 31 * result + end;\n    return result;\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public <F> double score(Classifier<L,F> classifier, GeneralDataset<L,F> data) {\n    setLabelIndex(data.labelIndex);\n    clearCounts();\n    int[] labelsArr = data.getLabelsArray();\n    for (int i = 0; i < data.size(); i++) {\n      Datum<L, F> d = data.getRVFDatum(i);\n      L guess = classifier.classOf(d);\n      addGuess(guess, labelIndex.get(labelsArr[i]));\n    }\n    finalizeCounts();\n\n    return getFMeasure();\n  }","id":72979,"modified_method":"public <F> double score(Classifier<L,F> classifier, GeneralDataset<L,F> data) {\n    labelIndex = new HashIndex<L>();\n    labelIndex.addAll(classifier.labels());\n    labelIndex.addAll(data.labelIndex.objectsList());\n    clearCounts();\n    int[] labelsArr = data.getLabelsArray();\n    for (int i = 0; i < data.size(); i++) {\n      Datum<L, F> d = data.getRVFDatum(i);\n      L guess = classifier.classOf(d);\n      addGuess(guess, labelIndex.get(labelsArr[i]));\n    }\n    finalizeCounts();\n\n    return getFMeasure();\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<List<K>> getMultimatched() {\n    return multimatched;\n  }","id":72980,"modified_method":"public List<List<K>> getMultimatched() {\n    if (multimatches == null) return null;\n    List<List<K>> multimatched = new ArrayList<List<K>>(multimatches.size());\n    for (Match<K,V> m:multimatches) {\n      multimatched.add(m.getMatched());\n    }\n    return multimatched;\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public MultiMatch(List<K> matched, V value, int begin, int end, List<List<K>> multimatched, List<V> multivalues) {\n    this.matched = matched;\n    this.value = value;\n    this.begin = begin;\n    this.end = end;\n    this.multimatched = multimatched;\n    this.multivalues = multivalues;\n  }","id":72981,"modified_method":"public MultiMatch(List<K> matched, V value, int begin, int end, List<Match<K,V>> multimatches) {\n    this.matched = matched;\n    this.value = value;\n    this.begin = begin;\n    this.end = end;\n    this.multimatches = multimatches;\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    if (multimatched != null && multivalues != null) {\n      sb.append(\"[\" + StringUtils.join(multimatched, \"-\") + \"]\");\n      sb.append(\" -> \").append(StringUtils.join(multivalues, \"-\"));\n      sb.append(\" at (\").append(begin);\n      sb.append(\",\").append(end).append(\")\");\n    } else {\n      sb.append(super.toString());\n    }\n    return sb.toString();\n  }","id":72982,"modified_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    if (multimatches != null) {\n      sb.append(\"[\" + StringUtils.join(getMultimatches(), \", \") + \"]\");\n    } else {\n      sb.append(super.toString());\n    }\n    return sb.toString();\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    MultiMatch that = (MultiMatch) o;\n\n    if (multimatched != null ? !multimatched.equals(that.multimatched) : that.multimatched != null) return false;\n    if (multivalues != null ? !multivalues.equals(that.multivalues) : that.multivalues != null) return false;\n\n    return true;\n  }","id":72983,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n\n    MultiMatch that = (MultiMatch) o;\n\n    if (multimatches != null ? !multimatches.equals(that.multimatches) : that.multimatches != null) return false;\n\n    return true;\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<V> getMultivalues() {\n    return multivalues;\n  }","id":72984,"modified_method":"public List<V> getMultivalues() {\n    if (multimatches == null) return null;\n    List<V> multivalues = new ArrayList<V>(multimatches.size());\n    for (Match<K,V> m:multimatches) {\n      multivalues.add(m.getValue());\n    }\n    return multivalues;\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public PartialApproxMatch() {}","id":72985,"modified_method":"private PartialApproxMatch() {}","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, int n, boolean multimatch) {\n    return findClosestMatches(target, TrieMapMatcher.<K,V>defaultCost(), Double.MAX_VALUE, n, multimatch);\n  }","id":72986,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @param keepAlignments If true, alignment information is returned\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, int n, boolean multimatch, boolean keepAlignments) {\n    return findClosestMatches(target, TrieMapMatcher.<K,V>defaultCost(), Double.MAX_VALUE, n, multimatch, keepAlignments);\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, int n) {\n    return findClosestMatches(target, TrieMapMatcher.<K,V>defaultCost(), Double.MAX_VALUE, n, false);\n  }","id":72987,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, int n) {\n    return findClosestMatches(target, TrieMapMatcher.<K,V>defaultCost(), Double.MAX_VALUE, n, false, false);\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie\n   *  based on the cost function (lower cost mean better match).\n   * @param target Target sequence to match\n   * @param costFunction Cost function to use\n   * @param maxCost Matches with a cost higher than this are discarded\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(K[] target, MatchCostFunction<K,V> costFunction,\n                                                   Double maxCost, int n, boolean multimatch) {\n    return findClosestMatches(Arrays.asList(target), costFunction, maxCost, n, multimatch);\n  }","id":72988,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie\n   *  based on the cost function (lower cost mean better match).\n   * @param target Target sequence to match\n   * @param costFunction Cost function to use\n   * @param maxCost Matches with a cost higher than this are discarded\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @param keepAlignments If true, alignment information is returned\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(K[] target, MatchCostFunction<K,V> costFunction,\n                                                   Double maxCost, int n, boolean multimatch, boolean keepAlignments) {\n    return findClosestMatches(Arrays.asList(target), costFunction, maxCost, n, multimatch, keepAlignments);\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n    public int hashCode() {\n      int result = super.hashCode();\n      result = 31 * result + (trie != null ? trie.hashCode() : 0);\n      result = 31 * result + lastMultimatchedStartIndex;\n      return result;\n    }","id":72989,"modified_method":"@Override\n    public int hashCode() {\n      int result = super.hashCode();\n      result = 31 * result + lastMultimatchedMatchedStartIndex;\n      result = 31 * result + lastMultimatchedOriginalStartIndex;\n      return result;\n    }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private PartialApproxMatch<K,V> withMatch(MatchCostFunction<K,V> costFunction, double deltaCost, K t, K k) {\n      PartialApproxMatch<K,V> res = new PartialApproxMatch<K,V>();\n      res.matched = matched;\n      if (k != null) {\n        if (res.matched == null) {\n          res.matched = new ArrayList<K>(1);\n        } else {\n          res.matched = new ArrayList<K>(matched.size() + 1);\n          res.matched.addAll(matched);\n        }\n        res.matched.add(k);\n      }\n      res.begin = begin;\n      res.end = (t != null)? end + 1: end;\n      res.cost = cost + deltaCost;\n      res.trie = (k != null)? trie.getChildTrie(k):trie;\n      res.value = res.trie.value;\n      res.multimatched = multimatched;\n      res.multivalues = multivalues;\n      res.lastMultimatchedStartIndex = lastMultimatchedStartIndex;\n      return res;\n    }","id":72990,"modified_method":"private PartialApproxMatch<K,V> withMatch(MatchCostFunction<K,V> costFunction, double deltaCost, K t, K k) {\n      PartialApproxMatch<K,V> res = new PartialApproxMatch<K,V>();\n      res.matched = matched;\n      if (k != null) {\n        if (res.matched == null) {\n          res.matched = new ArrayList<K>(1);\n        } else {\n          res.matched = new ArrayList<K>(matched.size() + 1);\n          res.matched.addAll(matched);\n        }\n        res.matched.add(k);\n      }\n      res.begin = begin;\n      res.end = (t != null)? end + 1: end;\n      res.cost = cost + deltaCost;\n      res.trie = (k != null)? trie.getChildTrie(k):trie;\n      res.value = (res.trie != null)? res.trie.value:null;\n      res.multimatches = multimatches;\n      res.lastMultimatchedMatchedStartIndex = lastMultimatchedMatchedStartIndex;\n      res.lastMultimatchedOriginalStartIndex = lastMultimatchedOriginalStartIndex;\n      if (res.lastMultimatchedOriginalStartIndex == end  && k == null && t != null) {\n        res.lastMultimatchedOriginalStartIndex++;\n      }\n      // Update alignments\n      if (alignments != null) {\n        res.alignments = new Interval[alignments.length];\n        System.arraycopy(alignments, 0, res.alignments, 0, alignments.length);\n        if (k != null && res.end > 0) {\n          int p = res.end-1;\n          if (res.alignments[p] == null) {\n            res.alignments[p] = Interval.toInterval(res.matched.size()-1, res.matched.size());\n          } else {\n            res.alignments[p] = Interval.toInterval(res.alignments[p].getBegin(), res.alignments[p].getEnd() + 1);\n          }\n        }\n      }\n      return res;\n    }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      if (!super.equals(o)) return false;\n\n      PartialApproxMatch that = (PartialApproxMatch) o;\n\n      if (lastMultimatchedStartIndex != that.lastMultimatchedStartIndex) return false;\n      if (trie != null ? !trie.equals(that.trie) : that.trie != null) return false;\n\n      return true;\n    }","id":72991,"modified_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      if (!super.equals(o)) return false;\n\n      PartialApproxMatch that = (PartialApproxMatch) o;\n\n      if (lastMultimatchedMatchedStartIndex != that.lastMultimatchedMatchedStartIndex) return false;\n      if (lastMultimatchedOriginalStartIndex != that.lastMultimatchedOriginalStartIndex) return false;\n      if (trie != null ? !trie.equals(that.trie) : that.trie != null) return false;\n\n      return true;\n    }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(K[] target, int n, boolean multimatch) {\n    return findClosestMatches(Arrays.asList(target), n, multimatch);\n  }","id":72992,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.\n   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)\n   * @param target Target sequence to match\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @param keepAlignments If true, alignment information is returned\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(K[] target, int n, boolean multimatch, boolean keepAlignments) {\n    return findClosestMatches(Arrays.asList(target), n, multimatch, keepAlignments);\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void add(PartialApproxMatch<K,V> pam) {\n      Match<K,V> m = new MultiMatch<K,V>(pam.matched, pam.value, pam.begin, pam.end, pam.multimatched, pam.multivalues);\n      queue.put(m, pam);\n    }","id":72993,"modified_method":"public void add(PartialApproxMatch<K,V> pam) {\n      List<Match<K,V>> multiMatchesWithoutOffsets = null;\n      if (pam.multimatches != null) {\n        multiMatchesWithoutOffsets = new ArrayList<Match<K, V>>(pam.multimatches.size());\n        for (Match<K,V> m:pam.multimatches) {\n          multiMatchesWithoutOffsets.add( new Match<K, V>(m.matched, m.value, 0, 0));\n        }\n      }\n      Match<K,V> m = new MultiMatch<K,V>(pam.matched, pam.value, pam.begin, pam.end, multiMatchesWithoutOffsets);\n      queue.put(m, pam);\n    }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie\n   *  based on the cost function (lower cost mean better match).\n   * @param target Target sequence to match\n   * @param costFunction Cost function to use\n   * @param maxCost Matches with a cost higher than this are discarded\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, MatchCostFunction<K,V> costFunction,\n                                                   double maxCost, int n, boolean multimatch) {\n    if (root.isEmpty()) return null;\n    int extra = 3;\n    // Find the closest n options to the key in the trie based on the given cost function for substitution\n    // matches[i][j] stores the top n partial matches for i elements from the target\n    //   and j elements from the partial matches from trie keys\n    MatchQueue<K,V> best = new MatchQueue<K, V>(n, maxCost);\n    List<PartialApproxMatch<K,V>>[][] matches = new List[target.size()+1][];\n    for (int i = 0; i <= target.size(); i++) {\n      for (int j = 0; j <= target.size()+extra; j++) {\n        if (j > 0) {\n          boolean complete = (i == target.size()) && (j >= target.size());\n          // Try to pick best match from trie\n          K t = (i > 0 && i <= target.size())? target.get(i-1):null;\n          // Look at the top n choices we saved away and pick n new options\n          MatchQueue<K,V> queue = (multimatch)? new MultiMatchQueue<K, V>(n, maxCost):new MatchQueue<K, V>(n, maxCost);\n          if (i > 0) {\n            for (PartialApproxMatch<K,V> pam:matches[i-1][j-1]) {\n              if (pam.trie != null) {\n                if (pam.trie.children != null) {\n                  for (K k:pam.trie.children.keySet()) {\n                    addToQueue(queue, best, costFunction, pam, t, k, multimatch, complete);\n                  }\n                }\n              }\n            }\n          }\n          for (PartialApproxMatch<K,V> pam:matches[i][j-1]) {\n            if (pam.trie != null) {\n              if (pam.trie.children != null) {\n                for (K k:pam.trie.children.keySet()) {\n                  addToQueue(queue, best, costFunction, pam, null, k, multimatch, complete);\n                }\n              }\n            }\n          }\n          if (i > 0) {\n            for (PartialApproxMatch<K,V> pam:matches[i-1][j]) {\n              addToQueue(queue, best, costFunction, pam, t, null, multimatch, complete);\n            }\n          }\n          matches[i][j] = queue.toSortedList();\n        } else {\n          matches[i] = new List[target.size()+1+extra];\n          matches[i][0] = new ArrayList<PartialApproxMatch<K,V>>();\n          if (i > 0) {\n            K t = (i < target.size())? target.get(i-1):null;\n            for (PartialApproxMatch<K,V> pam:matches[i-1][0]) {\n              PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, costFunction.cost(t, null), t, null);\n              if (npam.cost <= maxCost) {\n                matches[i][0].add(npam);\n              }\n            }\n          } else {\n            matches[i][0].add(new PartialApproxMatch<K,V>(0, root));\n          }\n        }\n//        System.out.println(\"i=\" + i + \",j=\" + j + \",\" + matches[i][j]);\n      }\n    }\n    // Get the best matches\n    List<ApproxMatch<K,V>> res = new ArrayList<ApproxMatch<K,V>>();\n    for (ApproxMatch<K,V> m:best.toSortedList()) {\n      res.add(m);\n    }\n    return res;\n  }","id":72994,"modified_method":"/**\n   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie\n   *  based on the cost function (lower cost mean better match).\n   * @param target Target sequence to match\n   * @param costFunction Cost function to use\n   * @param maxCost Matches with a cost higher than this are discarded\n   * @param n Number of matches to return. The actual number of matches may be less.\n   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.\n   *                   Otherwise, only each match will contain one element from the trie.\n   * @param keepAlignments If true, alignment information is returned\n   * @return List of approximate matches\n   */\n  public List<ApproxMatch<K,V>> findClosestMatches(List<K> target, MatchCostFunction<K,V> costFunction,\n                                                   double maxCost, int n, boolean multimatch, boolean keepAlignments) {\n    if (root.isEmpty()) return null;\n    int extra = 3;\n    // Find the closest n options to the key in the trie based on the given cost function for substitution\n    // matches[i][j] stores the top n partial matches for i elements from the target\n    //   and j elements from the partial matches from trie keys\n\n    // At any time, we only keep track of the last two rows\n    // (prevMatches (matches[i-1][j]), curMatches (matches[i][j]) that we are working on\n    MatchQueue<K,V> best = new MatchQueue<K, V>(n, maxCost);\n    List<PartialApproxMatch<K,V>>[] prevMatches = null;\n    List<PartialApproxMatch<K,V>>[] curMatches;\n    for (int i = 0; i <= target.size(); i++) {\n      curMatches = new List[target.size()+1+extra];\n      for (int j = 0; j <= target.size()+extra; j++) {\n        if (j > 0) {\n          boolean complete = (i == target.size());\n          // Try to pick best match from trie\n          K t = (i > 0 && i <= target.size())? target.get(i-1):null;\n          // Look at the top n choices we saved away and pick n new options\n          MatchQueue<K,V> queue = (multimatch)? new MultiMatchQueue<K, V>(n, maxCost):new MatchQueue<K, V>(n, maxCost);\n          if (i > 0) {\n            for (PartialApproxMatch<K,V> pam:prevMatches[j-1]) {\n              if (pam.trie != null) {\n                if (pam.trie.children != null) {\n                  for (K k:pam.trie.children.keySet()) {\n                    addToQueue(queue, best, costFunction, pam, t, k, multimatch, complete);\n                  }\n                }\n              }\n            }\n          }\n          for (PartialApproxMatch<K,V> pam:curMatches[j-1]) {\n            if (pam.trie != null) {\n              if (pam.trie.children != null) {\n                for (K k:pam.trie.children.keySet()) {\n                  addToQueue(queue, best, costFunction, pam, null, k, multimatch, complete);\n                }\n              }\n            }\n          }\n          if (i > 0) {\n            for (PartialApproxMatch<K,V> pam:prevMatches[j]) {\n              addToQueue(queue, best, costFunction, pam, t, null, multimatch, complete);\n            }\n          }\n          curMatches[j] = queue.toSortedList();\n        } else {\n          curMatches[0] = new ArrayList<PartialApproxMatch<K,V>>();\n          if (i > 0) {\n            K t = (i < target.size())? target.get(i-1):null;\n            for (PartialApproxMatch<K,V> pam:prevMatches[0]) {\n              PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, costFunction.cost(t, null), t, null);\n              if (npam.cost <= maxCost) {\n                curMatches[0].add(npam);\n              }\n            }\n          } else {\n            curMatches[0].add(new PartialApproxMatch<K,V>(0, root, keepAlignments? target.size():0));\n          }\n        }\n//        System.out.println(\"i=\" + i + \",j=\" + j + \",\" + matches[i][j]);\n      }\n      prevMatches = curMatches;\n    }\n    // Get the best matches\n    List<ApproxMatch<K,V>> res = new ArrayList<ApproxMatch<K,V>>();\n    for (PartialApproxMatch<K,V> m:best.toSortedList()) {\n      res.add(m.toApproxMatch());\n    }\n    return res;\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private PartialApproxMatch<K,V> withMatch(MatchCostFunction<K,V> costFunction, double deltaCost,\n                                              K t, K k, boolean multimatch, TrieMap<K,V> root) {\n      PartialApproxMatch<K,V> res = withMatch(costFunction, deltaCost, t, k);\n      if (multimatch && res.matched != null && res.value != null) {\n        // Update tracking of matched keys and values for multiple entry matches\n        if (res.multivalues == null) {\n          res.multivalues = new ArrayList<V>(1);\n        } else {\n          res.multivalues = new ArrayList<V>(multivalues.size()+1);\n          res.multivalues.addAll(multivalues);\n        }\n        res.multivalues.add(res.value);\n        if (res.multimatched == null) {\n          res.multimatched = new ArrayList<List<K>>(1);\n        } else {\n          res.multimatched = new ArrayList<List<K>>(multimatched.size()+1);\n          res.multimatched.addAll(multimatched);\n        }\n        res.multimatched.add(res.matched.subList(lastMultimatchedStartIndex, res.matched.size()));\n        res.cost += costFunction.multiMatchDeltaCost(res.multimatched.get(res.multimatched.size()-1), res.value, res.multimatched.size());\n        res.lastMultimatchedStartIndex = res.matched.size();\n        // Reset current value/key being matched\n        res.trie = root;\n      }\n      return res;\n    }","id":72995,"modified_method":"private PartialApproxMatch<K,V> withMatch(MatchCostFunction<K,V> costFunction, double deltaCost,\n                                              K t, K k, boolean multimatch, TrieMap<K,V> root) {\n      PartialApproxMatch<K,V> res = withMatch(costFunction, deltaCost, t, k);\n      if (multimatch && res.matched != null && res.value != null) {\n        // Update tracking of matched keys and values for multiple entry matches\n        if (res.multimatches == null) {\n          res.multimatches = new ArrayList<Match<K,V>>(1);\n        } else {\n          res.multimatches = new ArrayList<Match<K,V>>(multimatches.size()+1);\n          res.multimatches.addAll(multimatches);\n        }\n        List<K> newlyMatched = res.matched.subList(lastMultimatchedMatchedStartIndex, res.matched.size());\n        res.multimatches.add( new Match<K, V>(\n                newlyMatched,\n                res.value,\n                lastMultimatchedOriginalStartIndex, res.end\n        ));\n        res.cost += costFunction.multiMatchDeltaCost(newlyMatched, res.value, res.multimatches.size());\n        res.lastMultimatchedMatchedStartIndex = res.matched.size();\n        res.lastMultimatchedOriginalStartIndex = res.end;\n        // Reset current value/key being matched\n        res.trie = root;\n      }\n      return res;\n    }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void add(PartialApproxMatch<K,V> pam) {\n      Match<K,V> m = new MultiMatch<K,V>(\n              pam.matched, pam.value, pam.begin, pam.end, pam.multimatched, pam.multivalues);\n      Integer key = (pam.multimatched != null)? pam.multimatched.size():0;\n      if (pam.value == null) key = key + 1;\n      BoundedCostOrderedMap<Match<K,V>, PartialApproxMatch<K,V>> mq = multimatchQueues.get(key);\n      if (mq == null) {\n        multimatchQueues.put(key, mq = new BoundedCostOrderedMap<Match<K,V>, PartialApproxMatch<K,V>>(\n                MATCH_COST_FUNCTION, maxSize, maxCost));\n      }\n      mq.put(m, pam);\n    }","id":72996,"modified_method":"public void add(PartialApproxMatch<K,V> pam) {\n      Match<K,V> m = new MultiMatch<K,V>(\n              pam.matched, pam.value, pam.begin, pam.end, pam.multimatches);\n      Integer key = (pam.multimatches != null)? pam.multimatches.size():0;\n      if (pam.value == null) key = key + 1;\n      BoundedCostOrderedMap<Match<K,V>, PartialApproxMatch<K,V>> mq = multimatchQueues.get(key);\n      if (mq == null) {\n        multimatchQueues.put(key, mq = new BoundedCostOrderedMap<Match<K,V>, PartialApproxMatch<K,V>>(\n                MATCH_COST_FUNCTION, maxSize, maxCost));\n      }\n      mq.put(m, pam);\n    }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private boolean addToQueue(MatchQueue<K,V> queue,\n                             MatchQueue<K,V> best,\n                             MatchCostFunction<K,V> costFunction,\n                             PartialApproxMatch<K,V> pam, K a, K b,\n                             boolean multimatch, boolean complete) {\n    double deltaCost = costFunction.cost(a,b);\n    double newCost = pam.cost + deltaCost;\n    if (newCost > queue.maxCost) return false;\n    if (best.size() >= queue.maxSize && newCost > best.topCost()) return false;\n\n    PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, deltaCost, a, b);\n    if (!multimatch || npam.trie.children != null) {\n      if (!multimatch && complete && npam.value != null) {\n        best.add(npam);\n      }\n      queue.add(npam);\n    }\n\n    if (multimatch && npam.value != null) {\n      npam = pam.withMatch(costFunction, deltaCost, a, b, multimatch, rootWithDelimiter);\n      if (complete && npam.value != null) {\n        best.add(npam);\n      }\n      queue.add(npam);\n    }\n    return true;\n  }","id":72997,"modified_method":"private boolean addToQueue(MatchQueue<K,V> queue,\n                             MatchQueue<K,V> best,\n                             MatchCostFunction<K,V> costFunction,\n                             PartialApproxMatch<K,V> pam, K a, K b,\n                             boolean multimatch, boolean complete) {\n    double deltaCost = costFunction.cost(a,b);\n    double newCost = pam.cost + deltaCost;\n    if (queue.maxCost != Double.MAX_VALUE && newCost > queue.maxCost) return false;\n    if (best.size() >= queue.maxSize && newCost > best.topCost()) return false;\n\n    PartialApproxMatch<K,V> npam = pam.withMatch(costFunction, deltaCost, a, b);\n    if (!multimatch || (npam.trie != null && npam.trie.children != null)) {\n      if (!multimatch && complete && npam.value != null) {\n        best.add(npam);\n      }\n      queue.add(npam);\n    }\n\n    if (multimatch && npam.value != null) {\n      npam = pam.withMatch(costFunction, deltaCost, a, b, multimatch, rootWithDelimiter);\n      if (complete && npam.value != null) {\n        best.add(npam);\n      }\n      queue.add(npam);\n    }\n    return true;\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public PartialApproxMatch(double cost, TrieMap<K,V> trie) {\n      this.trie = trie;\n      this.cost = cost;\n      this.value = this.trie.value;\n    }","id":72998,"modified_method":"private PartialApproxMatch(double cost, TrieMap<K,V> trie, int alignmentLength) {\n      this.trie = trie;\n      this.cost = cost;\n      this.value = (trie != null)? this.trie.value:null;\n      if (alignmentLength > 0) {\n        this.alignments = new Interval[alignmentLength];\n      }\n    }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TrieMapMatcher(TrieMap<K, V> root) {\n    this.root = root;\n  }","id":72999,"modified_method":"public TrieMapMatcher(TrieMap<K, V> root) {\n    this.root = root;\n    this.rootWithDelimiter = root;\n  }","commit_id":"4d359078baaf62bce483a5a7192d32a0939341c0","url":"https://github.com/stanfordnlp/CoreNLP"}]