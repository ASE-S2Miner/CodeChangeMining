[{"original_method":"private Object dslObject(final String name)\n\t\t\tthrows DSLException {\n\t\tfinal DSLObjectInitializerData data = getDSLInitializers().get(name);\n\t\tif (data == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.activeObject == null) {\n\t\t\t// root node\n\t\t\tif (!data.isAllowRootNode()) {\n\t\t\t\tthrow new DSLException(\"Elements of  type \" + name + \" may not be used as the root node of a DSL\");\n\t\t\t}\n\t\t} else {\n\t\t\t// internal node\n\t\t\tif (data.isAllowInternalNode()) {\n\t\t\t\t// check that node is nested under allowed element\n\t\t\t\tif (data.getParentElement() != null && !data.getParentElement().isEmpty()) {\n\t\t\t\t\tfinal DSLObjectInitializerData parentType = getDSLInitializers().get(data.getParentElement());\n\t\t\t\t\tif (parentType == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"The DSL type \" + name + \" has a declared parent type of \"\n\t\t\t\t\t\t\t\t+ data.getParentElement() + \" which is not a known type. This should not happen.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!parentType.getClazz().isAssignableFrom(this.activeObject.getClass())) {\n\t\t\t\t\t\tthrow new DSLException(\"The type: \" + name + \" may only be nested under elements of type \"\n\t\t\t\t\t\t\t\t+ parentType.getName());\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new DSLException(\"Elements of type: \" + name + \" may not be placed in internal nodes\");\n\t\t\t}\n\n\t\t}\n\n\t\ttry {\n\t\t\t// Check if this is in extend mode. The active object should already\n\t\t\t// contain a value\n\t\t\t// for this object, simply clone it so we keep its content.\n\n\t\t\tif (this.activeObject != null && !(this.activeObject instanceof Application)\n\t\t\t\t\t&& isProperyExistsInBean(this.activeObject, name)) {\n\t\t\t\tfinal Object existingPropertyValue = PropertyUtils.getProperty(this.activeObject, name);\n\t\t\t\tif (existingPropertyValue != null) {\n\t\t\t\t\treturn BeanUtils.cloneBean(existingPropertyValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn data.clazz.newInstance();\n\t\t} catch (final InstantiationException e) {\n\t\t\tthrow new DSLException(\"Failed to create new element of type \" + data.getName() + \" with class: \"\n\t\t\t\t\t+ data.clazz, e);\n\t\t} catch (final IllegalAccessException e) {\n\t\t\tthrow new DSLException(\"Failed to create new element of type \" + data.getName() + \" with class: \"\n\t\t\t\t\t+ data.clazz, e);\n\t\t} catch (final InvocationTargetException e) {\n\t\t\tthrow new DSLException(\"Failed to copy existing element of type \" + data.getName() + \" with class: \"\n\t\t\t\t\t+ data.clazz, e);\n\t\t} catch (final NoSuchMethodException e) {\n\t\t\tthrow new DSLException(\"Failed to copy existing element of type \" + data.getName() + \" with class: \"\n\t\t\t\t\t+ data.clazz, e);\n\t\t}\n\t}","id":43000,"modified_method":"private Object dslObject(final String name)\n\t\t\tthrows DSLException {\n\t\tfinal DSLObjectInitializerData data = getDSLInitializers().get(name);\n\t\tif (data == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (isDuplicateProcessingUnit(name)){\n\t\t\tthrow new DSLException(\"There may only be one type of processing unit defined. Found more than one: \"\n\t\t\t\t\t\t\t\t+ \"[\" + name + \", \" + this.processingUnitType + \"]\");\n\t\t}\n\n\t\tif (this.activeObject == null) {\n\t\t\t// root node\n\t\t\tif (!data.isAllowRootNode()) {\n\t\t\t\tthrow new DSLException(\"Elements of  type \" + name + \" may not be used as the root node of a DSL\");\n\t\t\t}\n\t\t} else {\n\t\t\t// internal node\n\t\t\tif (data.isAllowInternalNode()) {\n\t\t\t\t// check that node is nested under allowed element\n\t\t\t\tif (data.getParentElement() != null && !data.getParentElement().isEmpty()) {\n\t\t\t\t\tfinal DSLObjectInitializerData parentType = getDSLInitializers().get(data.getParentElement());\n\t\t\t\t\tif (parentType == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"The DSL type \" + name + \" has a declared parent type of \"\n\t\t\t\t\t\t\t\t+ data.getParentElement() + \" which is not a known type. This should not happen.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!parentType.getClazz().isAssignableFrom(this.activeObject.getClass())) {\n\t\t\t\t\t\tthrow new DSLException(\"The type: \" + name + \" may only be nested under elements of type \"\n\t\t\t\t\t\t\t\t+ parentType.getName());\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new DSLException(\"Elements of type: \" + name + \" may not be placed in internal nodes\");\n\t\t\t}\n\n\t\t}\n\n\t\ttry {\n\t\t\t// Check if this is in extend mode. The active object should already\n\t\t\t// contain a value\n\t\t\t// for this object, simply clone it so we keep its content.\n\n\t\t\tif (this.activeObject != null && !(this.activeObject instanceof Application)\n\t\t\t\t\t&& isProperyExistsInBean(this.activeObject, name)) {\n\t\t\t\tfinal Object existingPropertyValue = PropertyUtils.getProperty(this.activeObject, name);\n\t\t\t\tif (existingPropertyValue != null) {\n\t\t\t\t\treturn BeanUtils.cloneBean(existingPropertyValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn data.clazz.newInstance();\n\t\t} catch (final InstantiationException e) {\n\t\t\tthrow new DSLException(\"Failed to create new element of type \" + data.getName() + \" with class: \"\n\t\t\t\t\t+ data.clazz, e);\n\t\t} catch (final IllegalAccessException e) {\n\t\t\tthrow new DSLException(\"Failed to create new element of type \" + data.getName() + \" with class: \"\n\t\t\t\t\t+ data.clazz, e);\n\t\t} catch (final InvocationTargetException e) {\n\t\t\tthrow new DSLException(\"Failed to copy existing element of type \" + data.getName() + \" with class: \"\n\t\t\t\t\t+ data.clazz, e);\n\t\t} catch (final NoSuchMethodException e) {\n\t\t\tthrow new DSLException(\"Failed to copy existing element of type \" + data.getName() + \" with class: \"\n\t\t\t\t\t+ data.clazz, e);\n\t\t}\n\t}","commit_id":"816998e08397b6006f221c1260d6c724bb58e135","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private static synchronized Map<String, DSLObjectInitializerData> getDSLInitializers() {\n\t\tif (dslObjectInitializersByName == null) {\n\t\t\tdslObjectInitializersByName = new HashMap<String, BaseDslScript.DSLObjectInitializerData>();\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Application.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, DataGrid.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Memcached.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, PluginDescriptor.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Service.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ServiceLifecycle.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ServiceNetwork.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, MirrorProcessingUnit.class);\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Cloud.class);\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, CloudProvider.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, CloudUser.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, CloudTemplate.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, CloudConfiguration.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Sla.class);\n\n\t\t\tdslObjectInitializersByName.put(\"userInterface\", new DSLObjectInitializerData(\"userInterface\",\n\t\t\t\t\tUserInterface.class, false, true, \"service\"));\n\n\t\t\tdslObjectInitializersByName.put(\"metricGroup\", new DSLObjectInitializerData(\"metricGroup\",\n\t\t\t\t\tMetricGroup.class, false, true, \"userInterface\"));\n\t\t\tdslObjectInitializersByName.put(\"widgetGroup\", new DSLObjectInitializerData(\"widgetGroup\",\n\t\t\t\t\tWidgetGroup.class, false, true, \"userInterface\"));\n\t\t\tdslObjectInitializersByName.put(\"balanceGauge\", new DSLObjectInitializerData(\"balanceGauge\",\n\t\t\t\t\tBalanceGauge.class, false, true, \"widgetGroup\"));\n\t\t\tdslObjectInitializersByName.put(\"barLineChart\", new DSLObjectInitializerData(\"barLineChart\",\n\t\t\t\t\tBarLineChart.class, false, true, \"widgetGroup\"));\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ScalingRuleDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, HighThresholdDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, LowThresholdDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ServiceStatisticsDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, PerInstanceStatisticsDetails.class);\n\t\t}\n\t\treturn dslObjectInitializersByName;\n\n\t}","id":43001,"modified_method":"private static synchronized Map<String, DSLObjectInitializerData> getDSLInitializers() {\n\t\tif (dslObjectInitializersByName == null) {\n\t\t\tdslObjectInitializersByName = new HashMap<String, BaseDslScript.DSLObjectInitializerData>();\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Application.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Service.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, PluginDescriptor.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ServiceNetwork.class);\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, DataGrid.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Memcached.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ServiceLifecycle.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, MirrorProcessingUnit.class);\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Cloud.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, CloudProvider.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, CloudUser.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, CloudTemplate.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, CloudConfiguration.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, Sla.class);\n\n\t\t\tdslObjectInitializersByName.put(\"userInterface\", new DSLObjectInitializerData(\"userInterface\",\n\t\t\t\t\tUserInterface.class, false, true, \"service\"));\n\n\t\t\tdslObjectInitializersByName.put(\"metricGroup\", new DSLObjectInitializerData(\"metricGroup\",\n\t\t\t\t\tMetricGroup.class, false, true, \"userInterface\"));\n\t\t\tdslObjectInitializersByName.put(\"widgetGroup\", new DSLObjectInitializerData(\"widgetGroup\",\n\t\t\t\t\tWidgetGroup.class, false, true, \"userInterface\"));\n\t\t\tdslObjectInitializersByName.put(\"balanceGauge\", new DSLObjectInitializerData(\"balanceGauge\",\n\t\t\t\t\tBalanceGauge.class, false, true, \"widgetGroup\"));\n\t\t\tdslObjectInitializersByName.put(\"barLineChart\", new DSLObjectInitializerData(\"barLineChart\",\n\t\t\t\t\tBarLineChart.class, false, true, \"widgetGroup\"));\n\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ScalingRuleDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, HighThresholdDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, LowThresholdDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, ServiceStatisticsDetails.class);\n\t\t\taddObjectInitializerForClass(dslObjectInitializersByName, PerInstanceStatisticsDetails.class);\n\t\t}\n\t\treturn dslObjectInitializersByName;\n\n\t}","commit_id":"816998e08397b6006f221c1260d6c724bb58e135","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void saveXWikiDoc(XWikiDocument doc, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null)\n                monitor.startTimer(\"hibernate\");\n            doc.setStore(this);\n            // Make sure the database name is stored\n            doc.setDatabase(context.getDatabase());\n\n            if (bTransaction) {\n                checkHibernate(context);\n\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                bTransaction = beginTransaction(sfactory, context);\n            }\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            // These informations will allow to not look for attachments and objects on loading\n            doc.setElement(XWikiDocument.HAS_ATTACHMENTS, (doc.getAttachmentList().size() != 0));\n            doc.setElement(XWikiDocument.HAS_OBJECTS, (doc.getxWikiObjects().size() != 0));\n\n            // Let's update the class XML since this is the new way to store it\n            // TODO If all the properties are removed, the old xml stays?\n            BaseClass bclass = doc.getxWikiClass();\n            if ((bclass != null) && (bclass.getFieldList().size() > 0)) {\n                doc.setxWikiClassXML(bclass.toXMLString());\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS))\n                saveAttachmentList(doc, context, false);\n\n            // Handle the latest text file\n            if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                Date ndate = new Date();\n                doc.setDate(ndate);\n                if (doc.isContentDirty()) {\n                    doc.setContentUpdateDate(ndate);\n                    doc.setContentAuthor(doc.getAuthor());\n                }\n                doc.incrementVersion();\n                if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                    context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false,\n                        context);\n\n                doc.setContentDirty(false);\n                doc.setMetaDataDirty(false);\n            } else {\n                if (doc.getDocumentArchive() != null) {\n                    // Let's make sure we save the archive if we have one\n                    // This is especially needed if we load a document from XML\n                    if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                        context.getWiki().getVersioningStore().saveXWikiDocArchive(\n                            doc.getDocumentArchive(), false, context);\n                } else {\n                    // Make sure the getArchive call has been made once\n                    // with a valid context\n                    try {\n                        if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                            doc.getDocumentArchive(context);\n                    } catch (XWikiException e) {\n                        // this is a non critical error\n                    }\n                }\n            }\n\n            // Verify if the document already exists\n            Query query =\n                session\n                    .createQuery(\"select xwikidoc.id from XWikiDocument as xwikidoc where xwikidoc.id = :id\");\n            query.setLong(\"id\", doc.getId());\n            if (query.uniqueResult() == null)\n                session.save(doc);\n            else\n                session.update(doc);\n            // TODO: this is slower!! How can it be improved?\n            // session.saveOrUpdate(doc);\n\n            // Remove properties planned for removal\n            if (doc.getObjectsToRemove().size() > 0) {\n                for (int i = 0; i < doc.getObjectsToRemove().size(); i++) {\n                    BaseObject bobj = (BaseObject) doc.getObjectsToRemove().get(i);\n                    if (bobj != null)\n                        deleteXWikiObject(bobj, context, false);\n                }\n                doc.setObjectsToRemove(new ArrayList<BaseObject>());\n            }\n\n            // We should only save the class if we are using the class table mode\n            if (bclass != null) {\n                bclass.setName(doc.getFullName());\n                if ((bclass.getFieldList().size() > 0) && (useClassesTable(true, context)))\n                    saveXWikiClass(bclass, context, false);\n                // Store this XWikiClass in the context so that we can use it in case of recursive\n                // usage of classes\n                context.addBaseClass(bclass);\n                // update objects of the class\n                for (Iterator itf = bclass.getFieldList().iterator(); itf.hasNext();) {\n                    PropertyClass prop = (PropertyClass) itf.next();\n                    // migrate values of list properties\n                    if (prop instanceof StaticListClass || prop instanceof DBListClass) {\n                        ListClass lc = (ListClass) prop;\n                        String[] classes =\n                            {DBStringListProperty.class.getName(),\n                            StringListProperty.class.getName(), StringProperty.class.getName()}; // @see\n                                                                                                    // ListClass#newProperty()\n                        for (int i = 0; i < classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(lc.newProperty().getClass().getName())) {\n                                Query q =\n                                    session.createQuery(\n                                        \"select p from \" + oldclass + \" as p, BaseObject as o\"\n                                            + \" where o.className=?\"\n                                            + \"  and p.id=o.id and p.name=?\").setString(0,\n                                        bclass.getName()).setString(1, lc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext();) {\n                                    BaseProperty lp = (BaseProperty) it.next();\n                                    BaseProperty lp1 = lc.newProperty();\n                                    lp1.setId(lp.getId());\n                                    lp1.setName(lp.getName());\n                                    if (lc.isMultiSelect()) {\n                                        List tmp;\n                                        if (lp.getValue() instanceof List) {\n                                            tmp = (List) lp.getValue();\n                                        } else {\n                                            tmp = new ArrayList(1);\n                                            tmp.add(lp.getValue());\n                                        }\n                                        lp1.setValue(tmp);\n                                    } else {\n                                        Object tmp = lp.getValue();\n                                        if (tmp instanceof List)\n                                            tmp = ((List) tmp).get(0);\n                                        lp1.setValue(tmp);\n                                    }\n                                    session.delete(lp);\n                                    session.save(lp1);\n                                }\n                            }\n                        }\n                    }\n                    // migrate values of list properties\n                    else if (prop instanceof NumberClass) {\n                        NumberClass nc = (NumberClass) prop;\n                        // @see NumberClass#newProperty()\n                        String[] classes =\n                            {IntegerProperty.class.getName(), LongProperty.class.getName(),\n                            FloatProperty.class.getName(), DoubleProperty.class.getName()};\n                        for (int i = 0; i < classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(nc.newProperty().getClass().getName())) {\n                                Query q =\n                                    session.createQuery(\n                                        \"select p from \" + oldclass + \" as p, BaseObject as o\"\n                                            + \" where o.className=?\"\n                                            + \"  and p.id=o.id and p.name=?\").setString(0,\n                                        bclass.getName()).setString(1, nc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext();) {\n                                    BaseProperty np = (BaseProperty) it.next();\n                                    BaseProperty np1 = nc.newProperty();\n                                    np1.setId(np.getId());\n                                    np1.setName(np.getName());\n                                    if (nc.getNumberType().equals(\"integer\")) {\n                                        np1.setValue(new Integer(((Number) np.getValue())\n                                            .intValue()));\n                                    } else if (nc.getNumberType().equals(\"float\")) {\n                                        np1.setValue(new Float(((Number) np.getValue())\n                                            .floatValue()));\n                                    } else if (nc.getNumberType().equals(\"double\")) {\n                                        np1.setValue(new Double(((Number) np.getValue())\n                                            .doubleValue()));\n                                    } else if (nc.getNumberType().equals(\"long\")) {\n                                        np1.setValue(new Long(((Number) np.getValue())\n                                            .longValue()));\n                                    }\n                                    session.delete(np);\n                                    session.save(np1);\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                // TODO: Remove existing class\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                // TODO: Delete all objects for which we don't have a name in the Map..\n                for (Vector<BaseObject> objects : doc.getxWikiObjects().values()) {\n                    for (BaseCollection obj : objects) {\n                        if (obj != null) {\n                            obj.setName(doc.getFullName());\n                            saveXWikiCollection(obj, context, false);\n                        }\n                    }\n                }\n            }\n\n            if (context.getWiki().hasBacklinks(context)) {\n                saveLinks(doc, context, true);\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n\n            doc.setNew(false);\n\n            // We need to ensure that the saved document becomes the original document\n            doc.setOriginalDocument((XWikiDocument) doc.clone());\n\n        } catch (Exception e) {\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                \"Exception while saving document {0}\",\n                e,\n                args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null)\n                monitor.endTimer(\"hibernate\");\n        }\n    }","id":43002,"modified_method":"public void saveXWikiDoc(XWikiDocument doc, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null) {\n                monitor.startTimer(\"hibernate\");\n            }\n            doc.setStore(this);\n            // Make sure the database name is stored\n            doc.setDatabase(context.getDatabase());\n\n            if (bTransaction) {\n                checkHibernate(context);\n\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                bTransaction = beginTransaction(sfactory, context);\n            }\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            // These informations will allow to not look for attachments and objects on loading\n            doc.setElement(XWikiDocument.HAS_ATTACHMENTS, (doc.getAttachmentList().size() != 0));\n            doc.setElement(XWikiDocument.HAS_OBJECTS, (doc.getxWikiObjects().size() != 0));\n\n            // Let's update the class XML since this is the new way to store it\n            // TODO If all the properties are removed, the old xml stays?\n            BaseClass bclass = doc.getxWikiClass();\n            if ((bclass != null) && (bclass.getFieldList().size() > 0)) {\n                doc.setxWikiClassXML(bclass.toXMLString());\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS)) {\n                saveAttachmentList(doc, context, false);\n            }\n\n            // Handle the latest text file\n            if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                Date ndate = new Date();\n                doc.setDate(ndate);\n                if (doc.isContentDirty()) {\n                    doc.setContentUpdateDate(ndate);\n                    doc.setContentAuthor(doc.getAuthor());\n                }\n                doc.incrementVersion();\n                if (context.getWiki().hasVersioning(doc.getFullName(), context)) {\n                    context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                }\n\n                doc.setContentDirty(false);\n                doc.setMetaDataDirty(false);\n            } else {\n                if (doc.getDocumentArchive() != null) {\n                    // Let's make sure we save the archive if we have one\n                    // This is especially needed if we load a document from XML\n                    if (context.getWiki().hasVersioning(doc.getFullName(), context)) {\n                        context.getWiki().getVersioningStore().saveXWikiDocArchive(doc.getDocumentArchive(), false,\n                            context);\n                    }\n                } else {\n                    // Make sure the getArchive call has been made once\n                    // with a valid context\n                    try {\n                        if (context.getWiki().hasVersioning(doc.getFullName(), context)) {\n                            doc.getDocumentArchive(context);\n                        }\n                    } catch (XWikiException e) {\n                        // this is a non critical error\n                    }\n                }\n            }\n\n            // Verify if the document already exists\n            Query query =\n                session.createQuery(\"select xwikidoc.id from XWikiDocument as xwikidoc where xwikidoc.id = :id\");\n            query.setLong(\"id\", doc.getId());\n            if (query.uniqueResult() == null) {\n                session.save(doc);\n            } else {\n                session.update(doc);\n                // TODO: this is slower!! How can it be improved?\n                // session.saveOrUpdate(doc);\n            }\n\n            // Remove properties planned for removal\n            if (doc.getObjectsToRemove().size() > 0) {\n                for (int i = 0; i < doc.getObjectsToRemove().size(); i++) {\n                    BaseObject bobj = doc.getObjectsToRemove().get(i);\n                    if (bobj != null) {\n                        deleteXWikiObject(bobj, context, false);\n                    }\n                }\n                doc.setObjectsToRemove(new ArrayList<BaseObject>());\n            }\n\n            // We should only save the class if we are using the class table mode\n            if (bclass != null) {\n                bclass.setName(doc.getFullName());\n                if ((bclass.getFieldList().size() > 0) && (useClassesTable(true, context))) {\n                    saveXWikiClass(bclass, context, false);\n                }\n                // Store this XWikiClass in the context so that we can use it in case of recursive\n                // usage of classes\n                context.addBaseClass(bclass);\n                // update objects of the class\n                for (Iterator itf = bclass.getFieldList().iterator(); itf.hasNext();) {\n                    PropertyClass prop = (PropertyClass) itf.next();\n                    // migrate values of list properties\n                    if (prop instanceof StaticListClass || prop instanceof DBListClass) {\n                        ListClass lc = (ListClass) prop;\n                        String[] classes =\n                            {DBStringListProperty.class.getName(), StringListProperty.class.getName(),\n                            StringProperty.class.getName()}; // @see\n                        // ListClass#newProperty()\n                        for (int i = 0; i < classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(lc.newProperty().getClass().getName())) {\n                                Query q =\n                                    session.createQuery(\n                                        \"select p from \" + oldclass + \" as p, BaseObject as o\" + \" where o.className=?\"\n                                            + \"  and p.id=o.id and p.name=?\").setString(0, bclass.getName()).setString(\n                                        1, lc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext();) {\n                                    BaseProperty lp = (BaseProperty) it.next();\n                                    BaseProperty lp1 = lc.newProperty();\n                                    lp1.setId(lp.getId());\n                                    lp1.setName(lp.getName());\n                                    if (lc.isMultiSelect()) {\n                                        List tmp;\n                                        if (lp.getValue() instanceof List) {\n                                            tmp = (List) lp.getValue();\n                                        } else {\n                                            tmp = new ArrayList(1);\n                                            tmp.add(lp.getValue());\n                                        }\n                                        lp1.setValue(tmp);\n                                    } else {\n                                        Object tmp = lp.getValue();\n                                        if (tmp instanceof List) {\n                                            tmp = ((List) tmp).get(0);\n                                        }\n                                        lp1.setValue(tmp);\n                                    }\n                                    session.delete(lp);\n                                    session.save(lp1);\n                                }\n                            }\n                        }\n                    }\n                    // migrate values of list properties\n                    else if (prop instanceof NumberClass) {\n                        NumberClass nc = (NumberClass) prop;\n                        // @see NumberClass#newProperty()\n                        String[] classes =\n                            {IntegerProperty.class.getName(), LongProperty.class.getName(),\n                            FloatProperty.class.getName(), DoubleProperty.class.getName()};\n                        for (int i = 0; i < classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(nc.newProperty().getClass().getName())) {\n                                Query q =\n                                    session.createQuery(\n                                        \"select p from \" + oldclass + \" as p, BaseObject as o\" + \" where o.className=?\"\n                                            + \"  and p.id=o.id and p.name=?\").setString(0, bclass.getName()).setString(\n                                        1, nc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext();) {\n                                    BaseProperty np = (BaseProperty) it.next();\n                                    BaseProperty np1 = nc.newProperty();\n                                    np1.setId(np.getId());\n                                    np1.setName(np.getName());\n                                    if (nc.getNumberType().equals(\"integer\")) {\n                                        np1.setValue(new Integer(((Number) np.getValue()).intValue()));\n                                    } else if (nc.getNumberType().equals(\"float\")) {\n                                        np1.setValue(new Float(((Number) np.getValue()).floatValue()));\n                                    } else if (nc.getNumberType().equals(\"double\")) {\n                                        np1.setValue(new Double(((Number) np.getValue()).doubleValue()));\n                                    } else if (nc.getNumberType().equals(\"long\")) {\n                                        np1.setValue(new Long(((Number) np.getValue()).longValue()));\n                                    }\n                                    session.delete(np);\n                                    session.save(np1);\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                // TODO: Remove existing class\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                // TODO: Delete all objects for which we don't have a name in the Map..\n                for (Vector<BaseObject> objects : doc.getxWikiObjects().values()) {\n                    for (BaseCollection obj : objects) {\n                        if (obj != null) {\n                            obj.setName(doc.getFullName());\n                            saveXWikiCollection(obj, context, false);\n                        }\n                    }\n                }\n            }\n\n            if (context.getWiki().hasBacklinks(context)) {\n                saveLinks(doc, context, true);\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n\n            doc.setNew(false);\n\n            // We need to ensure that the saved document becomes the original document\n            doc.setOriginalDocument((XWikiDocument) doc.clone());\n\n        } catch (Exception e) {\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC, \"Exception while saving document {0}\", e, args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null) {\n                monitor.endTimer(\"hibernate\");\n            }\n        }\n    }","commit_id":"a2fb6b88d882b07dcdff5a21d2c6b06f92e3dd41","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean isValidColumnType(String name, String className)\n    {\n        String[] validtypes = (String[]) validTypesMap.get(className);\n        if (validtypes == null)\n            return true;\n        else\n            return ArrayUtils.contains(validtypes, name);\n    }","id":43003,"modified_method":"private boolean isValidColumnType(String name, String className)\n    {\n        String[] validtypes = this.validTypesMap.get(className);\n        if (validtypes == null) {\n            return true;\n        } else {\n            return ArrayUtils.contains(validtypes, name);\n        }\n    }","commit_id":"a2fb6b88d882b07dcdff5a21d2c6b06f92e3dd41","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void deleteXWikiDoc(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = true;\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null)\n                monitor.startTimer(\"hibernate\");\n            checkHibernate(context);\n            SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n            bTransaction = bTransaction && beginTransaction(sfactory, context);\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            if (doc.getStore() == null) {\n                Object[] args = {doc.getFullName()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CANNOT_DELETE_UNLOADED_DOC,\n                    \"Impossible to delete document {0} if it is not loaded\",\n                    null,\n                    args);\n            }\n\n            // Let's delete any attachment this document might have\n            List attachlist = doc.getAttachmentList();\n            for (int i = 0; i < attachlist.size(); i++) {\n                XWikiAttachment attachment = (XWikiAttachment) attachlist.get(i);\n                context.getWiki().getAttachmentStore().deleteXWikiAttachment(attachment, false,\n                    context, false);\n            }\n\n            // deleting XWikiLinks\n            if (context.getWiki().hasBacklinks(context)) {\n                deleteLinks(doc.getId(), context, true);\n            }\n\n            BaseClass bclass = doc.getxWikiClass();\n            if ((bclass.getFieldList().size() > 0) && (useClassesTable(true, context))) {\n                deleteXWikiClass(bclass, context, false);\n            }\n\n            // Find the list of classes for which we have an object\n            // Remove properties planned for removal\n            if (doc.getObjectsToRemove().size() > 0) {\n                for (int i = 0; i < doc.getObjectsToRemove().size(); i++) {\n                    BaseObject bobj = (BaseObject) doc.getObjectsToRemove().get(i);\n                    if (bobj != null)\n                        deleteXWikiObject(bobj, context, false);\n                }\n                doc.setObjectsToRemove(new ArrayList<BaseObject>());\n            }\n            for (Vector<BaseObject> objects : doc.getxWikiObjects().values()) {\n                for (BaseObject obj : objects) {\n                    if (obj != null) {\n                        deleteXWikiObject(obj, context, false);\n                    }\n                }\n            }\n            context.getWiki().getVersioningStore().deleteArchive(doc, false, context);\n\n            session.delete(doc);\n\n            // We need to ensure that the deleted document becomes the original document\n            doc.setOriginalDocument((XWikiDocument) doc.clone());\n\n            if (bTransaction)\n                endTransaction(context, true);\n        } catch (Exception e) {\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                \"Exception while deleting document {0}\",\n                e,\n                args);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false);\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null)\n                monitor.endTimer(\"hibernate\");\n        }\n    }","id":43004,"modified_method":"public void deleteXWikiDoc(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = true;\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null) {\n                monitor.startTimer(\"hibernate\");\n            }\n            checkHibernate(context);\n            SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n            bTransaction = bTransaction && beginTransaction(sfactory, context);\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            if (doc.getStore() == null) {\n                Object[] args = {doc.getFullName()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CANNOT_DELETE_UNLOADED_DOC,\n                    \"Impossible to delete document {0} if it is not loaded\", null, args);\n            }\n\n            // Let's delete any attachment this document might have\n            List attachlist = doc.getAttachmentList();\n            for (int i = 0; i < attachlist.size(); i++) {\n                XWikiAttachment attachment = (XWikiAttachment) attachlist.get(i);\n                context.getWiki().getAttachmentStore().deleteXWikiAttachment(attachment, false, context, false);\n            }\n\n            // deleting XWikiLinks\n            if (context.getWiki().hasBacklinks(context)) {\n                deleteLinks(doc.getId(), context, true);\n            }\n\n            BaseClass bclass = doc.getxWikiClass();\n            if ((bclass.getFieldList().size() > 0) && (useClassesTable(true, context))) {\n                deleteXWikiClass(bclass, context, false);\n            }\n\n            // Find the list of classes for which we have an object\n            // Remove properties planned for removal\n            if (doc.getObjectsToRemove().size() > 0) {\n                for (int i = 0; i < doc.getObjectsToRemove().size(); i++) {\n                    BaseObject bobj = doc.getObjectsToRemove().get(i);\n                    if (bobj != null) {\n                        deleteXWikiObject(bobj, context, false);\n                    }\n                }\n                doc.setObjectsToRemove(new ArrayList<BaseObject>());\n            }\n            for (Vector<BaseObject> objects : doc.getxWikiObjects().values()) {\n                for (BaseObject obj : objects) {\n                    if (obj != null) {\n                        deleteXWikiObject(obj, context, false);\n                    }\n                }\n            }\n            context.getWiki().getVersioningStore().deleteArchive(doc, false, context);\n\n            session.delete(doc);\n\n            // We need to ensure that the deleted document becomes the original document\n            doc.setOriginalDocument((XWikiDocument) doc.clone());\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC, \"Exception while deleting document {0}\", e,\n                args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null) {\n                monitor.endTimer(\"hibernate\");\n            }\n        }\n    }","commit_id":"a2fb6b88d882b07dcdff5a21d2c6b06f92e3dd41","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void deleteXWikiCollection(BaseCollection object, XWikiContext context,\n        boolean bTransaction, boolean evict) throws XWikiException\n    {\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            Session session = getSession(context);\n\n            // Let's check if the class has a custom mapping\n            BaseClass bclass = object.getxWikiClass(context);\n            List handledProps = new ArrayList();\n            if ((bclass != null) && (bclass.hasCustomMapping())\n                && context.getWiki().hasCustomMappings()) {\n                handledProps = bclass.getCustomMappingPropertyList(context);\n                Session dynamicSession = session.getSession(EntityMode.MAP);\n                Object map =\n                    dynamicSession.get((String) bclass.getName(), new Integer(object.getId()));\n                if (map != null) {\n                    if (evict)\n                        dynamicSession.evict(map);\n                    dynamicSession.delete((Object) map);\n                }\n            }\n\n            if (!object.getClassName().equals(\"internal\")) {\n                for (Iterator it = object.getFieldList().iterator(); it.hasNext();) {\n                    BaseElement property = (BaseElement) it.next();\n                    if (!handledProps.contains(property.getName())) {\n                        if (evict)\n                            session.evict(property);\n                        if (session.get(property.getClass(), property) != null)\n                            session.delete(property);\n                    }\n                }\n            }\n\n            // In case of custom class we need to force it as BaseObject\n            // to delete the xwikiobject row\n            if (!\"\".equals(bclass.getCustomClass())) {\n                BaseObject cobject = new BaseObject();\n                cobject.setName(object.getName());\n                cobject.setClassName(object.getClassName());\n                cobject.setNumber(object.getNumber());\n                cobject.setId(object.getId());\n                if (evict)\n                    session.evict(cobject);\n                session.delete(cobject);\n            } else {\n                if (evict)\n                    session.evict(object);\n                session.delete(object);\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {object.getName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_OBJECT,\n                \"Exception while deleting object {0}\",\n                e,\n                args);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false);\n            } catch (Exception e) {\n            }\n        }\n    }","id":43005,"modified_method":"public void deleteXWikiCollection(BaseCollection object, XWikiContext context, boolean bTransaction, boolean evict)\n        throws XWikiException\n    {\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            Session session = getSession(context);\n\n            // Let's check if the class has a custom mapping\n            BaseClass bclass = object.getxWikiClass(context);\n            List handledProps = new ArrayList();\n            if ((bclass != null) && (bclass.hasCustomMapping()) && context.getWiki().hasCustomMappings()) {\n                handledProps = bclass.getCustomMappingPropertyList(context);\n                Session dynamicSession = session.getSession(EntityMode.MAP);\n                Object map = dynamicSession.get(bclass.getName(), new Integer(object.getId()));\n                if (map != null) {\n                    if (evict) {\n                        dynamicSession.evict(map);\n                    }\n                    dynamicSession.delete(map);\n                }\n            }\n\n            if (!object.getClassName().equals(\"internal\")) {\n                for (Iterator it = object.getFieldList().iterator(); it.hasNext();) {\n                    BaseElement property = (BaseElement) it.next();\n                    if (!handledProps.contains(property.getName())) {\n                        if (evict) {\n                            session.evict(property);\n                        }\n                        if (session.get(property.getClass(), property) != null) {\n                            session.delete(property);\n                        }\n                    }\n                }\n            }\n\n            // In case of custom class we need to force it as BaseObject\n            // to delete the xwikiobject row\n            if (!\"\".equals(bclass.getCustomClass())) {\n                BaseObject cobject = new BaseObject();\n                cobject.setName(object.getName());\n                cobject.setClassName(object.getClassName());\n                cobject.setNumber(object.getNumber());\n                cobject.setId(object.getId());\n                if (evict) {\n                    session.evict(cobject);\n                }\n                session.delete(cobject);\n            } else {\n                if (evict) {\n                    session.evict(object);\n                }\n                session.delete(object);\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {object.getName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_OBJECT, \"Exception while deleting object {0}\", e,\n                args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }","commit_id":"a2fb6b88d882b07dcdff5a21d2c6b06f92e3dd41","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * This initializes the valid custom types Used for Custom Mapping\n     */\n    private void initValidColumTypes()\n    {\n        String[] string_types = {\"string\", \"text\", \"clob\"};\n        String[] number_types =\n            {\"integer\", \"long\", \"float\", \"double\", \"big_decimal\", \"big_integer\", \"yes_no\",\n            \"true_false\"};\n        String[] date_types = {\"date\", \"time\", \"timestamp\"};\n        String[] boolean_types = {\"boolean\", \"yes_no\", \"true_false\", \"integer\"};\n        validTypesMap = new HashMap<String, String[]>();\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.StringClass\", string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.TextAreaClass\", string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.PasswordClass\", string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.NumberClass\", number_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.DateClass\", date_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.BooleanClass\", boolean_types);\n    }","id":43006,"modified_method":"/**\n     * This initializes the valid custom types Used for Custom Mapping\n     */\n    private void initValidColumTypes()\n    {\n        String[] string_types = {\"string\", \"text\", \"clob\"};\n        String[] number_types =\n            {\"integer\", \"long\", \"float\", \"double\", \"big_decimal\", \"big_integer\", \"yes_no\", \"true_false\"};\n        String[] date_types = {\"date\", \"time\", \"timestamp\"};\n        String[] boolean_types = {\"boolean\", \"yes_no\", \"true_false\", \"integer\"};\n        this.validTypesMap = new HashMap<String, String[]>();\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.StringClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.TextAreaClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.PasswordClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.NumberClass\", number_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.DateClass\", date_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.BooleanClass\", boolean_types);\n    }","commit_id":"a2fb6b88d882b07dcdff5a21d2c6b06f92e3dd41","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = true;\n        try {\n            checkHibernate(context);\n            bTransaction = beginTransaction(false, context);\n            Session session = getSession(context);\n\n            Query query =\n                session\n                    .createQuery(\"select doc.fullName from XWikiDocument as doc where (doc.xWikiClassXML is not null and doc.xWikiClassXML like '%')\");\n            Iterator<String> it = query.list().iterator();\n            List<String> list = new ArrayList<String>();\n            while (it.hasNext()) {\n                String name = it.next();\n                list.add(name);\n            }\n\n            if (useClassesTable(false, context)) {\n                query = session.createQuery(\"select bclass.name from BaseClass as bclass\");\n                it = query.list().iterator();\n                while (it.hasNext()) {\n                    String name = (String) it.next();\n                    if (!list.contains(name))\n                        list.add(name);\n                }\n            }\n            if (bTransaction)\n                endTransaction(context, false, false);\n            return list;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                \"Exception while searching class list\",\n                e);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false, false);\n            } catch (Exception e) {\n            }\n        }\n    }","id":43007,"modified_method":"public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = true;\n        try {\n            checkHibernate(context);\n            bTransaction = beginTransaction(false, context);\n            Session session = getSession(context);\n\n            Query query =\n                session\n                    .createQuery(\"select doc.fullName from XWikiDocument as doc where (doc.xWikiClassXML is not null and doc.xWikiClassXML like '%')\");\n            Iterator<String> it = query.list().iterator();\n            List<String> list = new ArrayList<String>();\n            while (it.hasNext()) {\n                String name = it.next();\n                list.add(name);\n            }\n\n            if (useClassesTable(false, context)) {\n                query = session.createQuery(\"select bclass.name from BaseClass as bclass\");\n                it = query.list().iterator();\n                while (it.hasNext()) {\n                    String name = it.next();\n                    if (!list.contains(name)) {\n                        list.add(name);\n                    }\n                }\n            }\n            if (bTransaction) {\n                endTransaction(context, false, false);\n            }\n            return list;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH, \"Exception while searching class list\", e);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }","commit_id":"a2fb6b88d882b07dcdff5a21d2c6b06f92e3dd41","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List getTranslationList(XWikiDocument doc, XWikiContext context) throws XWikiException {\n        String hql = \"select doc.language from XWikiDocument as doc where doc.web = '\"\n            + Utils.SQLFilter(doc.getSpace()) + \"' and doc.name = '\"\n            + Utils.SQLFilter(doc.getName()) + \"' and doc.language <> ''\";\n        List list = context.getWiki().search(hql, context);\n        return (list == null) ? new ArrayList() : list;\n\t}","id":43008,"modified_method":"public List<String> getTranslationList(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        String hql =\n            \"select doc.language from XWikiDocument as doc where doc.web = '\"\n                + Utils.SQLFilter(doc.getSpace()) + \"' and doc.name = '\"\n                + Utils.SQLFilter(doc.getName()) + \"' and doc.language <> ''\";\n        List<String> list = context.getWiki().search(hql, context);\n        return (list == null) ? new ArrayList<String>() : list;\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Verifies if a wiki document exists\n     * @param doc\n     * @param context\n     * @return\n     * @throws XWikiException\n     */\n    public boolean exists(XWikiDocument doc, XWikiContext context) throws XWikiException {\n        boolean bTransaction = true;\n        MonitorPlugin monitor  = Util.getMonitorPlugin(context);\n        try {\n\n            doc.setStore(this);\n            checkHibernate(context);\n\n            // Start monitoring timer\n            if (monitor!=null)\n                monitor.startTimer(\"hibernate\");\n\n            bTransaction = bTransaction && beginTransaction(false, context);\n            Session session = getSession(context);\n            String fullName = doc.getFullName();\n\n            String sql = \"select doc.fullName from XWikiDocument as doc where doc.fullName=:fullName\";\n            if (monitor!=null)\n                monitor.setTimerDesc(\"hibernate\", sql);\n            Query query = session.createQuery(sql);\n            query.setString(\"fullName\", fullName);\n            Iterator it = query.list().iterator();\n            while (it.hasNext()) {\n                if (fullName.equals(it.next()))\n                    return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Object[] args = { doc.getFullName() };\n            throw new XWikiException( XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CHECK_EXISTS_DOC,\n                    \"Exception while reading document {0}\", e, args);\n        } finally {\n            // End monitoring timer\n            if (monitor!=null)\n                monitor.endTimer(\"hibernate\");\n\n            try {\n                if (bTransaction)\n                    endTransaction(context, false, false);\n            } catch (Exception e) {}\n        }\n    }","id":43009,"modified_method":"/**\n     * Verifies if a wiki document exists\n     * \n     * @param doc\n     * @param context\n     * @return\n     * @throws XWikiException\n     */\n    public boolean exists(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = true;\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n\n            doc.setStore(this);\n            checkHibernate(context);\n\n            // Start monitoring timer\n            if (monitor != null)\n                monitor.startTimer(\"hibernate\");\n\n            bTransaction = bTransaction && beginTransaction(false, context);\n            Session session = getSession(context);\n            String fullName = doc.getFullName();\n\n            String sql =\n                \"select doc.fullName from XWikiDocument as doc where doc.fullName=:fullName\";\n            if (monitor != null)\n                monitor.setTimerDesc(\"hibernate\", sql);\n            Query query = session.createQuery(sql);\n            query.setString(\"fullName\", fullName);\n            Iterator<String> it = query.list().iterator();\n            while (it.hasNext()) {\n                if (fullName.equals(it.next()))\n                    return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CHECK_EXISTS_DOC,\n                \"Exception while reading document {0}\",\n                e,\n                args);\n        } finally {\n            // End monitoring timer\n            if (monitor != null)\n                monitor.endTimer(\"hibernate\");\n\n            try {\n                if (bTransaction)\n                    endTransaction(context, false, false);\n            } catch (Exception e) {\n            }\n        }\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void saveXWikiDoc(XWikiDocument doc, XWikiContext context, boolean bTransaction) throws XWikiException {\n        MonitorPlugin monitor  = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor!=null)\n                monitor.startTimer(\"hibernate\");\n            doc.setStore(this);\n            // Make sure the database name is stored\n            doc.setDatabase(context.getDatabase());\n\n            if (bTransaction) {\n                checkHibernate(context);\n\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                bTransaction = beginTransaction(sfactory, context);\n            }\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            // These informations will allow to not look for attachments and objects on loading\n            doc.setElement(XWikiDocument.HAS_ATTACHMENTS, (doc.getAttachmentList().size()!=0));\n            doc.setElement(XWikiDocument.HAS_OBJECTS, (doc.getxWikiObjects().size()!=0));\n\n            // Let's update the class XML since this is the new way to store it\n            // TODO If all the properties are removed, the old xml stays?\n            BaseClass bclass = doc.getxWikiClass();\n            if ((bclass!=null)&&(bclass.getFieldList().size()>0)) {\n               doc.setxWikiClassXML(bclass.toXMLString());\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS))\n             saveAttachmentList(doc, context, false);\n\n            // Handle the latest text file\n            if (doc.isContentDirty()||doc.isMetaDataDirty()) {\n                Date ndate = new Date();\n                doc.setDate(ndate);\n                if (doc.isContentDirty()) {\n                    doc.setContentUpdateDate(ndate);\n                    doc.setContentAuthor(doc.getAuthor());\n                }\n                doc.incrementVersion();\n                if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                 context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n\n                doc.setContentDirty(false);\n                doc.setMetaDataDirty(false);\n            } else {\n                if (doc.getDocumentArchive()!=null) {\n                    // Let's make sure we save the archive if we have one\n                    // This is especially needed if we load a document from XML\n                    if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                     context.getWiki().getVersioningStore().saveXWikiDocArchive(doc.getDocumentArchive(),false, context);\n                } else {\n                    // Make sure the getArchive call has been made once\n                    // with a valid context\n                    try {\n                        if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                         doc.getDocumentArchive(context);\n                    } catch (XWikiException e) {\n                        // this is a non critical error\n                    }\n                }\n            }\n\n            // Verify if the document already exists\n            Query query = session.createQuery(\"select xwikidoc.id from XWikiDocument as xwikidoc where xwikidoc.id = :id\");\n            query.setLong(\"id\", doc.getId());\n            if (query.uniqueResult()==null)\n                session.save(doc);\n            else\n                session.update(doc);\n            // TODO: this is slower!! How can it be improved?\n//            session.saveOrUpdate(doc);\n\n            // Remove properties planned for removal\n            if (doc.getObjectsToRemove().size()>0) {\n                for (int i=0;i<doc.getObjectsToRemove().size();i++) {\n                    BaseObject bobj = (BaseObject)doc.getObjectsToRemove().get(i);\n                    if (bobj!=null)\n                     deleteXWikiObject(bobj, context, false);\n                }\n                doc.setObjectsToRemove(new ArrayList());\n            }\n\n            // We should only save the class if we are using the class table mode\n            if (bclass!=null) {\n                bclass.setName(doc.getFullName());\n                if ((bclass.getFieldList().size()>0)&&(useClassesTable(true, context)))\n                    saveXWikiClass(bclass, context, false);\n                // Store this XWikiClass in the context so that we can use it in case of recursive usage of classes\n                context.addBaseClass(bclass);\n                // update objects of the class\n                for (Iterator itf=bclass.getFieldList().iterator(); itf.hasNext(); ) {\n                    PropertyClass prop = (PropertyClass) itf.next();\n                    // migrate values of list properties\n                    if (prop instanceof StaticListClass || prop instanceof DBListClass) {\n                        ListClass lc = (ListClass) prop;\n                        String[] classes = {DBStringListProperty.class.getName(), StringListProperty.class.getName(), StringProperty.class.getName()}; // @see ListClass#newProperty()\n                        for (int i=0; i<classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(lc.newProperty().getClass().getName())) {\n                                Query q = session.createQuery(\"select p from \"+oldclass+\" as p, BaseObject as o\" +\n                                    \" where o.className=?\" +\n                                    \"  and p.id=o.id and p.name=?\")\n                                    .setString(0, bclass.getName())\n                                    .setString(1, lc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext(); ) {\n                                    BaseProperty lp = (BaseProperty) it.next();\n                                    BaseProperty lp1 = lc.newProperty();\n                                    lp1.setId(lp.getId());\n                                    lp1.setName(lp.getName());\n                                    if (lc.isMultiSelect()) {\n                                        List tmp;\n                                        if (lp.getValue() instanceof List) {\n                                            tmp = (List) lp.getValue();\n                                        } else {\n                                            tmp = new ArrayList(1);\n                                            tmp.add(lp.getValue());\n                                        }\n                                        lp1.setValue(tmp);\n                                    } else {\n                                        Object tmp = lp.getValue();\n                                        if (tmp instanceof List)\n                                            tmp = ((List)tmp).get(0);\n                                        lp1.setValue(tmp);\n                                    }\n                                    session.delete(lp);\n                                    session.save(lp1);\n                                }\n                            }\n                        }\n                    }\n                    // migrate values of list properties\n                    else if (prop instanceof NumberClass) {\n                        NumberClass nc = (NumberClass) prop;\n                        // @see NumberClass#newProperty()\n                        String[] classes =\n                            {IntegerProperty.class.getName(), LongProperty.class.getName(),\n                            FloatProperty.class.getName(), DoubleProperty.class.getName()};\n                        for (int i=0; i<classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(nc.newProperty().getClass().getName())) {\n                                Query q = session.createQuery(\"select p from \"+oldclass+\" as p, BaseObject as o\" +\n                                    \" where o.className=?\" +\n                                    \"  and p.id=o.id and p.name=?\")\n                                    .setString(0, bclass.getName())\n                                    .setString(1, nc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext(); ) {\n                                    BaseProperty np = (BaseProperty) it.next();\n                                    BaseProperty np1 = nc.newProperty();\n                                    np1.setId(np.getId());\n                                    np1.setName(np.getName());\n                                    if (nc.getNumberType().equals(\"integer\")) {\n                                        np1.setValue(new Integer(((Number)np.getValue()).intValue()));\n                                    } else if (nc.getNumberType().equals(\"float\")) {\n                                        np1.setValue(new Float(((Number)np.getValue()).floatValue()));\n                                    } else if (nc.getNumberType().equals(\"double\")) {\n                                        np1.setValue(new Double(((Number)np.getValue()).doubleValue()));\n                                    } else if (nc.getNumberType().equals(\"long\")) {\n                                        np1.setValue(new Long(((Number)np.getValue()).longValue()));\n                                    }\n                                    session.delete(np);\n                                    session.save(np1);\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                // TODO: Remove existing class\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                // TODO: Delete all objects for which we don't have a name in the Map..\n                Iterator it = doc.getxWikiObjects().values().iterator();\n                while (it.hasNext()) {\n                    Vector objects = (Vector) it.next();\n                    for (int i=0;i<objects.size();i++) {\n                        BaseCollection obj = (BaseCollection)objects.get(i);\n                        if (obj!=null){\n                            obj.setName(doc.getFullName());\n                            saveXWikiCollection(obj, context, false);\n                        }\n                    }\n                }\n            }\n\n            if (context.getWiki().hasBacklinks(context)){\n                saveLinks(doc, context, true);\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n\n            doc.setNew(false);\n\n            // We need to ensure that the saved document becomes the original document\n            doc.setOriginalDocument((XWikiDocument) doc.clone());\n\n        } catch (Exception e) {\n            Object[] args = { doc.getFullName() };\n            throw new XWikiException( XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                    \"Exception while saving document {0}\", e, args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {}\n\n            // End monitoring timer\n            if (monitor!=null)\n                monitor.endTimer(\"hibernate\");\n        }\n    }","id":43010,"modified_method":"public void saveXWikiDoc(XWikiDocument doc, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null)\n                monitor.startTimer(\"hibernate\");\n            doc.setStore(this);\n            // Make sure the database name is stored\n            doc.setDatabase(context.getDatabase());\n\n            if (bTransaction) {\n                checkHibernate(context);\n\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                bTransaction = beginTransaction(sfactory, context);\n            }\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            // These informations will allow to not look for attachments and objects on loading\n            doc.setElement(XWikiDocument.HAS_ATTACHMENTS, (doc.getAttachmentList().size() != 0));\n            doc.setElement(XWikiDocument.HAS_OBJECTS, (doc.getxWikiObjects().size() != 0));\n\n            // Let's update the class XML since this is the new way to store it\n            // TODO If all the properties are removed, the old xml stays?\n            BaseClass bclass = doc.getxWikiClass();\n            if ((bclass != null) && (bclass.getFieldList().size() > 0)) {\n                doc.setxWikiClassXML(bclass.toXMLString());\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS))\n                saveAttachmentList(doc, context, false);\n\n            // Handle the latest text file\n            if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                Date ndate = new Date();\n                doc.setDate(ndate);\n                if (doc.isContentDirty()) {\n                    doc.setContentUpdateDate(ndate);\n                    doc.setContentAuthor(doc.getAuthor());\n                }\n                doc.incrementVersion();\n                if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                    context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false,\n                        context);\n\n                doc.setContentDirty(false);\n                doc.setMetaDataDirty(false);\n            } else {\n                if (doc.getDocumentArchive() != null) {\n                    // Let's make sure we save the archive if we have one\n                    // This is especially needed if we load a document from XML\n                    if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                        context.getWiki().getVersioningStore().saveXWikiDocArchive(\n                            doc.getDocumentArchive(), false, context);\n                } else {\n                    // Make sure the getArchive call has been made once\n                    // with a valid context\n                    try {\n                        if (context.getWiki().hasVersioning(doc.getFullName(), context))\n                            doc.getDocumentArchive(context);\n                    } catch (XWikiException e) {\n                        // this is a non critical error\n                    }\n                }\n            }\n\n            // Verify if the document already exists\n            Query query =\n                session\n                    .createQuery(\"select xwikidoc.id from XWikiDocument as xwikidoc where xwikidoc.id = :id\");\n            query.setLong(\"id\", doc.getId());\n            if (query.uniqueResult() == null)\n                session.save(doc);\n            else\n                session.update(doc);\n            // TODO: this is slower!! How can it be improved?\n            // session.saveOrUpdate(doc);\n\n            // Remove properties planned for removal\n            if (doc.getObjectsToRemove().size() > 0) {\n                for (int i = 0; i < doc.getObjectsToRemove().size(); i++) {\n                    BaseObject bobj = (BaseObject) doc.getObjectsToRemove().get(i);\n                    if (bobj != null)\n                        deleteXWikiObject(bobj, context, false);\n                }\n                doc.setObjectsToRemove(new ArrayList<BaseObject>());\n            }\n\n            // We should only save the class if we are using the class table mode\n            if (bclass != null) {\n                bclass.setName(doc.getFullName());\n                if ((bclass.getFieldList().size() > 0) && (useClassesTable(true, context)))\n                    saveXWikiClass(bclass, context, false);\n                // Store this XWikiClass in the context so that we can use it in case of recursive\n                // usage of classes\n                context.addBaseClass(bclass);\n                // update objects of the class\n                for (Iterator itf = bclass.getFieldList().iterator(); itf.hasNext();) {\n                    PropertyClass prop = (PropertyClass) itf.next();\n                    // migrate values of list properties\n                    if (prop instanceof StaticListClass || prop instanceof DBListClass) {\n                        ListClass lc = (ListClass) prop;\n                        String[] classes =\n                            {DBStringListProperty.class.getName(),\n                            StringListProperty.class.getName(), StringProperty.class.getName()}; // @see\n                                                                                                    // ListClass#newProperty()\n                        for (int i = 0; i < classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(lc.newProperty().getClass().getName())) {\n                                Query q =\n                                    session.createQuery(\n                                        \"select p from \" + oldclass + \" as p, BaseObject as o\"\n                                            + \" where o.className=?\"\n                                            + \"  and p.id=o.id and p.name=?\").setString(0,\n                                        bclass.getName()).setString(1, lc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext();) {\n                                    BaseProperty lp = (BaseProperty) it.next();\n                                    BaseProperty lp1 = lc.newProperty();\n                                    lp1.setId(lp.getId());\n                                    lp1.setName(lp.getName());\n                                    if (lc.isMultiSelect()) {\n                                        List tmp;\n                                        if (lp.getValue() instanceof List) {\n                                            tmp = (List) lp.getValue();\n                                        } else {\n                                            tmp = new ArrayList(1);\n                                            tmp.add(lp.getValue());\n                                        }\n                                        lp1.setValue(tmp);\n                                    } else {\n                                        Object tmp = lp.getValue();\n                                        if (tmp instanceof List)\n                                            tmp = ((List) tmp).get(0);\n                                        lp1.setValue(tmp);\n                                    }\n                                    session.delete(lp);\n                                    session.save(lp1);\n                                }\n                            }\n                        }\n                    }\n                    // migrate values of list properties\n                    else if (prop instanceof NumberClass) {\n                        NumberClass nc = (NumberClass) prop;\n                        // @see NumberClass#newProperty()\n                        String[] classes =\n                            {IntegerProperty.class.getName(), LongProperty.class.getName(),\n                            FloatProperty.class.getName(), DoubleProperty.class.getName()};\n                        for (int i = 0; i < classes.length; i++) {\n                            String oldclass = classes[i];\n                            if (!oldclass.equals(nc.newProperty().getClass().getName())) {\n                                Query q =\n                                    session.createQuery(\n                                        \"select p from \" + oldclass + \" as p, BaseObject as o\"\n                                            + \" where o.className=?\"\n                                            + \"  and p.id=o.id and p.name=?\").setString(0,\n                                        bclass.getName()).setString(1, nc.getName());\n                                for (Iterator it = q.list().iterator(); it.hasNext();) {\n                                    BaseProperty np = (BaseProperty) it.next();\n                                    BaseProperty np1 = nc.newProperty();\n                                    np1.setId(np.getId());\n                                    np1.setName(np.getName());\n                                    if (nc.getNumberType().equals(\"integer\")) {\n                                        np1.setValue(new Integer(((Number) np.getValue())\n                                            .intValue()));\n                                    } else if (nc.getNumberType().equals(\"float\")) {\n                                        np1.setValue(new Float(((Number) np.getValue())\n                                            .floatValue()));\n                                    } else if (nc.getNumberType().equals(\"double\")) {\n                                        np1.setValue(new Double(((Number) np.getValue())\n                                            .doubleValue()));\n                                    } else if (nc.getNumberType().equals(\"long\")) {\n                                        np1.setValue(new Long(((Number) np.getValue())\n                                            .longValue()));\n                                    }\n                                    session.delete(np);\n                                    session.save(np1);\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                // TODO: Remove existing class\n            }\n\n            if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                // TODO: Delete all objects for which we don't have a name in the Map..\n                for (Vector<BaseObject> objects : doc.getxWikiObjects().values()) {\n                    for (BaseCollection obj : objects) {\n                        if (obj != null) {\n                            obj.setName(doc.getFullName());\n                            saveXWikiCollection(obj, context, false);\n                        }\n                    }\n                }\n            }\n\n            if (context.getWiki().hasBacklinks(context)) {\n                saveLinks(doc, context, true);\n            }\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n\n            doc.setNew(false);\n\n            // We need to ensure that the saved document becomes the original document\n            doc.setOriginalDocument((XWikiDocument) doc.clone());\n\n        } catch (Exception e) {\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                \"Exception while saving document {0}\",\n                e,\n                args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null)\n                monitor.endTimer(\"hibernate\");\n        }\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private List searchDocumentsNamesInternal(String sql, int nb, int start, List parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = false;\n        MonitorPlugin monitor  = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor!=null)\n                monitor.startTimer(\"hibernate\", sql);\n\n            checkHibernate(context);\n            bTransaction = beginTransaction(false, context);\n            Session session = getSession(context);\n            Query query = session.createQuery(sql);\n\n            injectParameterListToQuery(0, query, parameterValues);\n\n            if (start!=0)\n                query.setFirstResult(start);\n            if (nb!=0)\n                query.setMaxResults(nb);\n            Iterator it = query.list().iterator();\n            List list = new ArrayList();\n            while (it.hasNext()) {\n                Object[] result = (Object[]) it.next();\n                String name = (String) result[0] + \".\" + (String)result[1];\n                list.add(name);\n            }\n            return list;\n        }\n        catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                \"Exception while searching documents with SQL [{0}]\", e, new Object[]{ sql });\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false, false);\n            } catch (Exception e) {}\n\n            // End monitoring timer\n            if (monitor!=null)\n                monitor.endTimer(\"hibernate\");\n        }\n    }","id":43011,"modified_method":"private List<String> searchDocumentsNamesInternal(String sql, int nb, int start,\n        List parameterValues, XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = false;\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null) {\n                monitor.startTimer(\"hibernate\", sql);\n            }\n\n            checkHibernate(context);\n            bTransaction = beginTransaction(false, context);\n            Session session = getSession(context);\n            Query query = session.createQuery(sql);\n\n            injectParameterListToQuery(0, query, parameterValues);\n\n            if (start != 0) {\n                query.setFirstResult(start);\n            }\n            if (nb != 0) {\n                query.setMaxResults(nb);\n            }\n            Iterator it = query.list().iterator();\n            List<String> list = new ArrayList<String>();\n            while (it.hasNext()) {\n                Object[] result = (Object[]) it.next();\n                String name = (String) result[0] + \".\" + (String) result[1];\n                list.add(name);\n            }\n            return list;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                \"Exception while searching documents with SQL [{0}]\",\n                e,\n                new Object[] {sql});\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false, false);\n                }\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null) {\n                monitor.endTimer(\"hibernate\");\n            }\n        }\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List getClassList(XWikiContext context) throws XWikiException {\n        boolean bTransaction = true;\n        try {\n            checkHibernate(context);\n            bTransaction = beginTransaction(false, context);\n            Session session = getSession(context);\n\n            Query query = session.createQuery(\"select doc.fullName from XWikiDocument as doc where (doc.xWikiClassXML is not null and doc.xWikiClassXML like '%')\");\n            Iterator it = query.list().iterator();\n            List list = new ArrayList();\n            while (it.hasNext()) {\n                String name = (String)it.next();\n                list.add(name);\n            }\n\n            if (useClassesTable(false, context)) {\n                query = session.createQuery(\"select bclass.name from BaseClass as bclass\");\n                it = query.list().iterator();\n                while (it.hasNext()) {\n                    String name = (String)it.next();\n                    if (!list.contains(name))\n                        list.add(name);\n                }\n            }\n            if (bTransaction)\n                endTransaction(context, false, false);\n            return list;\n        }\n        catch (Exception e) {\n            throw new XWikiException( XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                    \"Exception while searching class list\", e);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false, false);\n            } catch (Exception e) {}\n        }\n    }","id":43012,"modified_method":"public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = true;\n        try {\n            checkHibernate(context);\n            bTransaction = beginTransaction(false, context);\n            Session session = getSession(context);\n\n            Query query =\n                session\n                    .createQuery(\"select doc.fullName from XWikiDocument as doc where (doc.xWikiClassXML is not null and doc.xWikiClassXML like '%')\");\n            Iterator<String> it = query.list().iterator();\n            List<String> list = new ArrayList<String>();\n            while (it.hasNext()) {\n                String name = it.next();\n                list.add(name);\n            }\n\n            if (useClassesTable(false, context)) {\n                query = session.createQuery(\"select bclass.name from BaseClass as bclass\");\n                it = query.list().iterator();\n                while (it.hasNext()) {\n                    String name = (String) it.next();\n                    if (!list.contains(name))\n                        list.add(name);\n                }\n            }\n            if (bTransaction)\n                endTransaction(context, false, false);\n            return list;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                \"Exception while searching class list\",\n                e);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false, false);\n            } catch (Exception e) {\n            }\n        }\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List loadLinks(long docId, XWikiContext context, boolean bTransaction) throws XWikiException {\n        List links=new ArrayList();\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(false, context);\n            }\n            Session session = getSession(context);\n\n            Query query = session.createQuery(\" from XWikiLink as link where link.id.docId = :docId\");\n            query.setLong(\"docId\", docId);\n\n            links = query.list();\n\n            if (bTransaction)\n                endTransaction(context, false, false);\n        }\n        catch (Exception e) {\n            throw new XWikiException( XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_LINKS,\n                    \"Exception while loading links\", e);\n        }\n        finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false, false);\n            } catch (Exception e) {}\n        }\n        return links;\n    }","id":43013,"modified_method":"public List<XWikiLink> loadLinks(long docId, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        List<XWikiLink> links = new ArrayList<XWikiLink>();\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(false, context);\n            }\n            Session session = getSession(context);\n\n            Query query =\n                session.createQuery(\" from XWikiLink as link where link.id.docId = :docId\");\n            query.setLong(\"docId\", docId);\n\n            links = query.list();\n\n            if (bTransaction) {\n                endTransaction(context, false, false);\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_LINKS,\n                \"Exception while loading links\",\n                e);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false, false);\n            } catch (Exception e) {\n            }\n        }\n        return links;\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void loadAttachmentList(XWikiDocument doc, XWikiContext context, boolean bTransaction) throws XWikiException {\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(false, context);\n            }\n            Session session = getSession(context);\n\n            Query query = session.createQuery(\"from XWikiAttachment as attach where attach.docId=:docid\");\n            query.setLong(\"docid\", doc.getId());\n            List list = query.list();\n            for (int i=0;i<list.size();i++) {\n                ((XWikiAttachment)list.get(i)).setDoc(doc);\n            }\n            doc.setAttachmentList(list);\n            if (bTransaction) {\n                endTransaction(context, false, false);\n                bTransaction = false;\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            Object[] args = { doc.getFullName() };\n            throw new XWikiException( XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCHING_ATTACHMENT,\n                    \"Exception while searching attachments for documents {0}\", e, args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false, false);\n                }\n            } catch (Exception e) {}\n        }\n    }","id":43014,"modified_method":"public void loadAttachmentList(XWikiDocument doc, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(false, context);\n            }\n            Session session = getSession(context);\n\n            Query query =\n                session.createQuery(\"from XWikiAttachment as attach where attach.docId=:docid\");\n            query.setLong(\"docid\", doc.getId());\n            List<XWikiAttachment> list = query.list();\n            for (XWikiAttachment attachment : list) {\n                attachment.setDoc(doc);\n            }\n            doc.setAttachmentList(list);\n            if (bTransaction) {\n                endTransaction(context, false, false);\n                bTransaction = false;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCHING_ATTACHMENT,\n                \"Exception while searching attachments for documents {0}\",\n                e,\n                args);\n        } finally {\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void deleteXWikiDoc(XWikiDocument doc, XWikiContext context) throws XWikiException {\n        boolean bTransaction = true;\n        MonitorPlugin monitor  = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor!=null)\n                monitor.startTimer(\"hibernate\");\n            checkHibernate(context);\n            SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n            bTransaction = bTransaction && beginTransaction(sfactory, context);\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            if (doc.getStore()==null) {\n                Object[] args = { doc.getFullName() };\n                throw new XWikiException( XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CANNOT_DELETE_UNLOADED_DOC,\n                        \"Impossible to delete document {0} if it is not loaded\", null, args);\n            }\n\n            // Let's delete any attachment this document might have\n            List attachlist = doc.getAttachmentList();\n            for (int i=0;i<attachlist.size();i++) {\n                XWikiAttachment attachment = (XWikiAttachment) attachlist.get(i);\n                context.getWiki().getAttachmentStore().deleteXWikiAttachment(attachment, false, context, false);\n            }\n\n            // deleting XWikiLinks\n            if (context.getWiki().hasBacklinks(context)){\n                deleteLinks(doc.getId(),context,true);\n            }\n\n            BaseClass bclass = doc.getxWikiClass();\n            if ((bclass.getFieldList().size()>0)&&(useClassesTable(true, context))) {\n                deleteXWikiClass(bclass, context, false);\n            }\n\n            // Find the list of classes for which we have an object\n            // Remove properties planned for removal\n            if (doc.getObjectsToRemove().size()>0) {\n                for (int i=0;i<doc.getObjectsToRemove().size();i++) {\n                    BaseObject bobj = (BaseObject)doc.getObjectsToRemove().get(i);\n                    if (bobj!=null)\n                     deleteXWikiObject(bobj, context, false);\n                }\n                doc.setObjectsToRemove(new ArrayList());\n            }\n            Iterator it = doc.getxWikiObjects().values().iterator();\n            while (it.hasNext()) {\n                Vector objects = (Vector) it.next();\n                for (int i=0;i<objects.size();i++) {\n                    BaseObject obj = (BaseObject)objects.get(i);\n                    if (obj!=null)\n                        deleteXWikiObject(obj, context, false);\n                }\n            }\n            context.getWiki().getVersioningStore().deleteArchive(doc, false, context);\n            \n            session.delete(doc);\n            \n            // We need to ensure that the deleted document becomes the original document\n            doc.setOriginalDocument((XWikiDocument) doc.clone());\n            \n            if (bTransaction)\n                endTransaction(context, true);\n        } catch (Exception e) {\n            Object[] args = { doc.getFullName() };\n            throw new XWikiException( XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                    \"Exception while deleting document {0}\", e, args);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false);\n            } catch (Exception e) {}\n\n            // End monitoring timer\n            if (monitor!=null)\n                monitor.endTimer(\"hibernate\");\n        }\n    }","id":43015,"modified_method":"public void deleteXWikiDoc(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        boolean bTransaction = true;\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            // Start monitoring timer\n            if (monitor != null)\n                monitor.startTimer(\"hibernate\");\n            checkHibernate(context);\n            SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n            bTransaction = bTransaction && beginTransaction(sfactory, context);\n            Session session = getSession(context);\n            session.setFlushMode(FlushMode.COMMIT);\n\n            if (doc.getStore() == null) {\n                Object[] args = {doc.getFullName()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CANNOT_DELETE_UNLOADED_DOC,\n                    \"Impossible to delete document {0} if it is not loaded\",\n                    null,\n                    args);\n            }\n\n            // Let's delete any attachment this document might have\n            List attachlist = doc.getAttachmentList();\n            for (int i = 0; i < attachlist.size(); i++) {\n                XWikiAttachment attachment = (XWikiAttachment) attachlist.get(i);\n                context.getWiki().getAttachmentStore().deleteXWikiAttachment(attachment, false,\n                    context, false);\n            }\n\n            // deleting XWikiLinks\n            if (context.getWiki().hasBacklinks(context)) {\n                deleteLinks(doc.getId(), context, true);\n            }\n\n            BaseClass bclass = doc.getxWikiClass();\n            if ((bclass.getFieldList().size() > 0) && (useClassesTable(true, context))) {\n                deleteXWikiClass(bclass, context, false);\n            }\n\n            // Find the list of classes for which we have an object\n            // Remove properties planned for removal\n            if (doc.getObjectsToRemove().size() > 0) {\n                for (int i = 0; i < doc.getObjectsToRemove().size(); i++) {\n                    BaseObject bobj = (BaseObject) doc.getObjectsToRemove().get(i);\n                    if (bobj != null)\n                        deleteXWikiObject(bobj, context, false);\n                }\n                doc.setObjectsToRemove(new ArrayList<BaseObject>());\n            }\n            for (Vector<BaseObject> objects : doc.getxWikiObjects().values()) {\n                for (BaseObject obj : objects) {\n                    if (obj != null) {\n                        deleteXWikiObject(obj, context, false);\n                    }\n                }\n            }\n            context.getWiki().getVersioningStore().deleteArchive(doc, false, context);\n\n            session.delete(doc);\n\n            // We need to ensure that the deleted document becomes the original document\n            doc.setOriginalDocument((XWikiDocument) doc.clone());\n\n            if (bTransaction)\n                endTransaction(context, true);\n        } catch (Exception e) {\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                \"Exception while deleting document {0}\",\n                e,\n                args);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false);\n            } catch (Exception e) {\n            }\n\n            // End monitoring timer\n            if (monitor != null)\n                monitor.endTimer(\"hibernate\");\n        }\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void saveAttachmentList(XWikiDocument doc, XWikiContext context, boolean bTransaction) throws XWikiException {\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            getSession(context);\n\n            List list = doc.getAttachmentList();\n            for (int i=0;i<list.size();i++) {\n                XWikiAttachment attachment = (XWikiAttachment) list.get(i);\n                attachment.setDoc(doc);\n                saveAttachment(attachment, false, context, false);\n            }\n\n            if (bTransaction) {\n                // The session is closed here, too.\n                endTransaction(context, true);\n            }\n        }\n        catch (Exception e) {\n            Object[] args = { doc.getFullName() };\n            throw new XWikiException( XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_ATTACHMENT_LIST,\n                    \"Exception while saving attachments attachment list of document {0}\", e, args);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false);\n            } catch (Exception e) {}\n        }\n    }","id":43016,"modified_method":"public void saveAttachmentList(XWikiDocument doc, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            getSession(context);\n\n            List<XWikiAttachment> list = doc.getAttachmentList();\n            for (XWikiAttachment attachment : list) {\n                attachment.setDoc(doc);\n                saveAttachment(attachment, false, context, false);\n            }\n\n            if (bTransaction) {\n                // The session is closed here, too.\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {doc.getFullName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_ATTACHMENT_LIST,\n                \"Exception while saving attachments attachment list of document {0}\",\n                e,\n                args);\n        } finally {\n            try {\n                if (bTransaction)\n                    endTransaction(context, false);\n            } catch (Exception e) {\n            }\n        }\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * This initializes the valid custom types\n     * Used for Custom Mapping\n     */\n    private void initValidColumTypes() {\n        String[] string_types = { \"string\" , \"text\" , \"clob\" };\n        String[] number_types = { \"integer\" , \"long\" , \"float\", \"double\", \"big_decimal\", \"big_integer\", \"yes_no\", \"true_false\" };\n        String[] date_types = { \"date\" , \"time\" , \"timestamp\" };\n        String[] boolean_types = { \"boolean\" , \"yes_no\" , \"true_false\", \"integer\" };\n        validTypesMap = new HashMap();\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.StringClass\" , string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.TextAreaClass\" , string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.PasswordClass\" , string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.NumberClass\" , number_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.DateClass\" , date_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.BooleanClass\" , boolean_types);\n    }","id":43017,"modified_method":"/**\n     * This initializes the valid custom types Used for Custom Mapping\n     */\n    private void initValidColumTypes()\n    {\n        String[] string_types = {\"string\", \"text\", \"clob\"};\n        String[] number_types =\n            {\"integer\", \"long\", \"float\", \"double\", \"big_decimal\", \"big_integer\", \"yes_no\",\n            \"true_false\"};\n        String[] date_types = {\"date\", \"time\", \"timestamp\"};\n        String[] boolean_types = {\"boolean\", \"yes_no\", \"true_false\", \"integer\"};\n        validTypesMap = new HashMap<String, String[]>();\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.StringClass\", string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.TextAreaClass\", string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.PasswordClass\", string_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.NumberClass\", number_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.DateClass\", date_types);\n        validTypesMap.put(\"com.xpn.xwiki.objects.classes.BooleanClass\", boolean_types);\n    }","commit_id":"bb2796355b180ab3abdd2ad3bf226b49a31c12bf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        return calculateIC(vc);\n    }","id":43018,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        //If available, get the founder IDs and cache them. the IC will only be computed on founders then.\n        if(founderIds == null)\n            founderIds =  ((Walker)walker).getSampleDB().getFounderIds();\n        return calculateIC(vc);\n    }","commit_id":"96e5a26223d39f27e58a044894983f4aa9a22956","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Map<String, Object> calculateIC(final VariantContext vc) {\n        final GenotypesContext genotypes = vc.getGenotypes();\n        if ( genotypes == null || genotypes.size() < MIN_SAMPLES )\n            return null;\n\n        int idxAA = 0, idxAB = 1, idxBB = 2;\n\n        if (!vc.isBiallelic()) {\n            // for non-bliallelic case, do test with most common alt allele.\n            // Get then corresponding indeces in GL vectors to retrieve GL of AA,AB and BB.\n            int[] idxVector = vc.getGLIndecesOfAlternateAllele(vc.getAltAlleleWithHighestAlleleCount());\n            idxAA = idxVector[0];\n            idxAB = idxVector[1];\n            idxBB = idxVector[2];\n        }\n\n        double refCount = 0.0;\n        double hetCount = 0.0;\n        double homCount = 0.0;\n        int N = 0; // number of samples that have likelihoods\n        for ( final Genotype g : genotypes ) {\n            if ( g.isNoCall() || !g.hasLikelihoods() )\n                continue;\n\n            N++;\n            final double[] normalizedLikelihoods = MathUtils.normalizeFromLog10( g.getLikelihoods().getAsVector() );\n            refCount += normalizedLikelihoods[idxAA];\n            hetCount += normalizedLikelihoods[idxAB];\n            homCount += normalizedLikelihoods[idxBB];\n        }\n\n        if( N < MIN_SAMPLES ) {\n            return null;\n        }\n\n        final double p = ( 2.0 * refCount + hetCount ) / ( 2.0 * (refCount + hetCount + homCount) ); // expected reference allele frequency\n        final double q = 1.0 - p; // expected alternative allele frequency\n        final double F = 1.0 - ( hetCount / ( 2.0 * p * q * (double)N ) ); // inbreeding coefficient\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", F));\n        return map;\n    }","id":43019,"modified_method":"private Map<String, Object> calculateIC(final VariantContext vc) {\n        final GenotypesContext genotypes = (founderIds == null || founderIds.isEmpty()) ? vc.getGenotypes() : vc.getGenotypes(founderIds);\n        if ( genotypes == null || genotypes.size() < MIN_SAMPLES )\n            return null;\n\n        int idxAA = 0, idxAB = 1, idxBB = 2;\n\n        if (!vc.isBiallelic()) {\n            // for non-bliallelic case, do test with most common alt allele.\n            // Get then corresponding indeces in GL vectors to retrieve GL of AA,AB and BB.\n            int[] idxVector = vc.getGLIndecesOfAlternateAllele(vc.getAltAlleleWithHighestAlleleCount());\n            idxAA = idxVector[0];\n            idxAB = idxVector[1];\n            idxBB = idxVector[2];\n        }\n\n        double refCount = 0.0;\n        double hetCount = 0.0;\n        double homCount = 0.0;\n        int N = 0; // number of samples that have likelihoods\n        for ( final Genotype g : genotypes ) {\n            if ( g.isNoCall() || !g.hasLikelihoods() )\n                continue;\n\n            N++;\n            final double[] normalizedLikelihoods = MathUtils.normalizeFromLog10( g.getLikelihoods().getAsVector() );\n            refCount += normalizedLikelihoods[idxAA];\n            hetCount += normalizedLikelihoods[idxAB];\n            homCount += normalizedLikelihoods[idxBB];\n        }\n\n        if( N < MIN_SAMPLES ) {\n            return null;\n        }\n\n        final double p = ( 2.0 * refCount + hetCount ) / ( 2.0 * (refCount + hetCount + homCount) ); // expected reference allele frequency\n        final double q = 1.0 - p; // expected alternative allele frequency\n        final double F = 1.0 - ( hetCount / ( 2.0 * p * q * (double)N ) ); // inbreeding coefficient\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", F));\n        return map;\n    }","commit_id":"96e5a26223d39f27e58a044894983f4aa9a22956","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static void linearExactMultiAllelic(final GenotypesContext GLs,\n                                               final int numAlternateAlleles,\n                                               final double[] log10AlleleFrequencyPriors,\n                                               final AlleleFrequencyCalculationResult result) {\n\n        final ArrayList<double[]> genotypeLikelihoods = getGLs(GLs);\n        final int numSamples = genotypeLikelihoods.size()-1;\n        final int numChr = 2*numSamples;\n\n        // queue of AC conformations to process\n        final LinkedList<ExactACset> ACqueue = new LinkedList<ExactACset>();\n\n        // mapping of ExactACset indexes to the objects\n        final HashMap<ExactACcounts, ExactACset> indexesToACset = new HashMap<ExactACcounts, ExactACset>(numChr+1);\n\n        // add AC=0 to the queue\n        int[] zeroCounts = new int[numAlternateAlleles];\n        ExactACset zeroSet = new ExactACset(numSamples+1, new ExactACcounts(zeroCounts));\n        ACqueue.add(zeroSet);\n        indexesToACset.put(zeroSet.ACcounts, zeroSet);\n\n        // keep processing while we have AC conformations that need to be calculated\n        MaxLikelihoodSeen maxLikelihoodSeen = new MaxLikelihoodSeen();\n        while ( !ACqueue.isEmpty() ) {\n            result.incNEvaluations(); // keep track of the number of evaluations\n\n            // compute log10Likelihoods\n            final ExactACset set = ACqueue.remove();\n            final double log10LofKs = calculateAlleleCountConformation(set, genotypeLikelihoods, maxLikelihoodSeen, numChr, ACqueue, indexesToACset, log10AlleleFrequencyPriors, result);\n\n            // adjust max likelihood seen if needed\n            if ( log10LofKs > maxLikelihoodSeen.maxLog10L )\n                maxLikelihoodSeen.update(log10LofKs, set.ACcounts);\n\n            // clean up memory\n            indexesToACset.remove(set.ACcounts);\n            //if ( DEBUG )\n            //    System.out.printf(\" *** removing used set=%s%n\", set.ACcounts);\n        }\n    }","id":43020,"modified_method":"public static void linearExactMultiAllelic(final GenotypesContext GLs,\n                                               final int numAlternateAlleles,\n                                               final double[] log10AlleleFrequencyPriors,\n                                               final AlleleFrequencyCalculationResult result) {\n\n        final ArrayList<double[]> genotypeLikelihoods = getGLs(GLs);\n        final int numSamples = genotypeLikelihoods.size()-1;\n        final int numChr = 2*numSamples;\n\n        // queue of AC conformations to process\n        final LinkedList<ExactACset> ACqueue = new LinkedList<ExactACset>();\n\n        // mapping of ExactACset indexes to the objects\n        final HashMap<ExactACcounts, ExactACset> indexesToACset = new HashMap<ExactACcounts, ExactACset>(numChr+1);\n\n        // add AC=0 to the queue\n        int[] zeroCounts = new int[numAlternateAlleles];\n        ExactACset zeroSet = new ExactACset(numSamples+1, new ExactACcounts(zeroCounts));\n        ACqueue.add(zeroSet);\n        indexesToACset.put(zeroSet.ACcounts, zeroSet);\n\n        // keep processing while we have AC conformations that need to be calculated\n        OldMaxLikelihoodSeen maxLikelihoodSeen = new OldMaxLikelihoodSeen();\n        while ( !ACqueue.isEmpty() ) {\n            result.incNEvaluations(); // keep track of the number of evaluations\n\n            // compute log10Likelihoods\n            final ExactACset set = ACqueue.remove();\n            final double log10LofKs = calculateAlleleCountConformation(set, genotypeLikelihoods, maxLikelihoodSeen, numChr, ACqueue, indexesToACset, log10AlleleFrequencyPriors, result);\n\n            // adjust max likelihood seen if needed\n            if ( log10LofKs > maxLikelihoodSeen.maxLog10L )\n                maxLikelihoodSeen.update(log10LofKs, set.ACcounts);\n\n            // clean up memory\n            indexesToACset.remove(set.ACcounts);\n            //if ( DEBUG )\n            //    System.out.printf(\" *** removing used set=%s%n\", set.ACcounts);\n        }\n    }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static double calculateAlleleCountConformation(final ExactACset set,\n                                                           final ArrayList<double[]> genotypeLikelihoods,\n                                                           final MaxLikelihoodSeen maxLikelihoodSeen,\n                                                           final int numChr,\n                                                           final LinkedList<ExactACset> ACqueue,\n                                                           final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                                           final double[] log10AlleleFrequencyPriors,\n                                                           final AlleleFrequencyCalculationResult result) {\n\n        //if ( DEBUG )\n        //    System.out.printf(\" *** computing LofK for set=%s%n\", set.ACcounts);\n\n        // compute the log10Likelihoods\n        computeLofK(set, genotypeLikelihoods, log10AlleleFrequencyPriors, result);\n\n        final double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // can we abort early because the log10Likelihoods are so small?\n        if ( log10LofK < maxLikelihoodSeen.maxLog10L - MAX_LOG10_ERROR_TO_STOP_EARLY && maxLikelihoodSeen.isLowerAC(set.ACcounts) ) {\n            //if ( DEBUG )\n            //    System.out.printf(\" *** breaking early set=%s log10L=%.2f maxLog10L=%.2f%n\", set.ACcounts, log10LofK, maxLog10L);\n            return log10LofK;\n        }\n\n        // iterate over higher frequencies if possible\n        final int ACwiggle = numChr - set.getACsum();\n        if ( ACwiggle == 0 ) // all alternate alleles already sum to 2N so we cannot possibly go to higher frequencies\n            return log10LofK;\n\n        final int numAltAlleles = set.ACcounts.getCounts().length;\n\n        // add conformations for the k+1 case\n        for ( int allele = 0; allele < numAltAlleles; allele++ ) {\n            final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n            ACcountsClone[allele]++;\n            // to get to this conformation, a sample would need to be AB (remember that ref=0)\n            final int PLindex = GenotypeLikelihoods.calculatePLindex(0, allele+1);\n            updateACset(ACcountsClone, numChr, set, PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        // add conformations for the k+2 case if it makes sense; note that the 2 new alleles may be the same or different\n        if ( ACwiggle > 1 ) {\n            final ArrayList<DependentSet> differentAlleles = new ArrayList<DependentSet>(numAltAlleles * numAltAlleles);\n            final ArrayList<DependentSet> sameAlleles = new ArrayList<DependentSet>(numAltAlleles);\n\n            for ( int allele_i = 0; allele_i < numAltAlleles; allele_i++ ) {\n                for ( int allele_j = allele_i; allele_j < numAltAlleles; allele_j++ ) {\n                    final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n                    ACcountsClone[allele_i]++;\n                    ACcountsClone[allele_j]++;\n\n                    // to get to this conformation, a sample would need to be BB or BC (remember that ref=0, so add one to the index)\n                    final int PLindex = GenotypeLikelihoods.calculatePLindex(allele_i+1, allele_j+1);\n                    if ( allele_i == allele_j )\n                        sameAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                    else\n                        differentAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                }\n            }\n\n            // IMPORTANT: we must first add the cases where the 2 new alleles are different so that the queue maintains its ordering\n            for ( DependentSet dependent : differentAlleles )\n                updateACset(dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n            for ( DependentSet dependent : sameAlleles )\n                updateACset(dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        return log10LofK;\n    }","id":43021,"modified_method":"private static double calculateAlleleCountConformation(final ExactACset set,\n                                                           final ArrayList<double[]> genotypeLikelihoods,\n                                                           final OldMaxLikelihoodSeen maxLikelihoodSeen,\n                                                           final int numChr,\n                                                           final LinkedList<ExactACset> ACqueue,\n                                                           final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                                           final double[] log10AlleleFrequencyPriors,\n                                                           final AlleleFrequencyCalculationResult result) {\n\n        //if ( DEBUG )\n        //    System.out.printf(\" *** computing LofK for set=%s%n\", set.ACcounts);\n\n        // compute the log10Likelihoods\n        computeLofK(set, genotypeLikelihoods, log10AlleleFrequencyPriors, result);\n\n        final double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // can we abort early because the log10Likelihoods are so small?\n        if ( log10LofK < maxLikelihoodSeen.maxLog10L - MAX_LOG10_ERROR_TO_STOP_EARLY && maxLikelihoodSeen.isLowerAC(set.ACcounts) ) {\n            //if ( DEBUG )\n            //    System.out.printf(\" *** breaking early set=%s log10L=%.2f maxLog10L=%.2f%n\", set.ACcounts, log10LofK, maxLog10L);\n            return log10LofK;\n        }\n\n        // iterate over higher frequencies if possible\n        final int ACwiggle = numChr - set.getACsum();\n        if ( ACwiggle == 0 ) // all alternate alleles already sum to 2N so we cannot possibly go to higher frequencies\n            return log10LofK;\n\n        final int numAltAlleles = set.ACcounts.getCounts().length;\n\n        // add conformations for the k+1 case\n        for ( int allele = 0; allele < numAltAlleles; allele++ ) {\n            final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n            ACcountsClone[allele]++;\n            // to get to this conformation, a sample would need to be AB (remember that ref=0)\n            final int PLindex = GenotypeLikelihoods.calculatePLindex(0, allele+1);\n            updateACset(ACcountsClone, numChr, set, PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        // add conformations for the k+2 case if it makes sense; note that the 2 new alleles may be the same or different\n        if ( ACwiggle > 1 ) {\n            final ArrayList<DependentSet> differentAlleles = new ArrayList<DependentSet>(numAltAlleles * numAltAlleles);\n            final ArrayList<DependentSet> sameAlleles = new ArrayList<DependentSet>(numAltAlleles);\n\n            for ( int allele_i = 0; allele_i < numAltAlleles; allele_i++ ) {\n                for ( int allele_j = allele_i; allele_j < numAltAlleles; allele_j++ ) {\n                    final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n                    ACcountsClone[allele_i]++;\n                    ACcountsClone[allele_j]++;\n\n                    // to get to this conformation, a sample would need to be BB or BC (remember that ref=0, so add one to the index)\n                    final int PLindex = GenotypeLikelihoods.calculatePLindex(allele_i+1, allele_j+1);\n                    if ( allele_i == allele_j )\n                        sameAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                    else\n                        differentAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                }\n            }\n\n            // IMPORTANT: we must first add the cases where the 2 new alleles are different so that the queue maintains its ordering\n            for ( DependentSet dependent : differentAlleles )\n                updateACset(dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n            for ( DependentSet dependent : sameAlleles )\n                updateACset(dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        return log10LofK;\n    }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void update(final double maxLog10L, final ExactACcounts ACs) {\n            this.maxLog10L = maxLog10L;\n            this.ACs = ACs;\n        }","id":43022,"modified_method":"/**\n         * Update the maximum log10L seen, if log10LofKs is higher\n         *\n         * @param log10LofKs the likelihood of our current configuration state\n         */\n        public void update(final double log10LofKs) {\n            if ( log10LofKs > maxLog10L )\n                this.maxLog10L = log10LofKs;\n        }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void computeLog10PNonRef(final VariantContext vc,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AlleleFrequencyCalculationResult result) {\n        linearExactMultiAllelic(vc.getGenotypes(), vc.getNAlleles() - 1, log10AlleleFrequencyPriors, result);\n    }","id":43023,"modified_method":"@Override\n    public void computeLog10PNonRef(final VariantContext vc,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AlleleFrequencyCalculationResult result) {\n        final int numAlternateAlleles = vc.getNAlleles() - 1;\n        final ArrayList<double[]> genotypeLikelihoods = getGLs(vc.getGenotypes());\n        final int numSamples = genotypeLikelihoods.size()-1;\n        final int numChr = 2*numSamples;\n\n        // queue of AC conformations to process\n        final LinkedList<ExactACset> ACqueue = new LinkedList<ExactACset>();\n\n        // mapping of ExactACset indexes to the objects\n        final HashMap<ExactACcounts, ExactACset> indexesToACset = new HashMap<ExactACcounts, ExactACset>(numChr+1);\n\n        // add AC=0 to the queue\n        final int[] zeroCounts = new int[numAlternateAlleles];\n        ExactACset zeroSet = new ExactACset(numSamples+1, new ExactACcounts(zeroCounts));\n        ACqueue.add(zeroSet);\n        indexesToACset.put(zeroSet.ACcounts, zeroSet);\n\n        // keep processing while we have AC conformations that need to be calculated\n        final int[] maxACsToConsider = computeMaxACs(vc);\n        result.setAClimits(maxACsToConsider);\n        final MaxLikelihoodSeen maxLikelihoodSeen = new MaxLikelihoodSeen(maxACsToConsider);\n\n        while ( !ACqueue.isEmpty() ) {\n            result.incNEvaluations(); // keep track of the number of evaluations\n\n            // compute log10Likelihoods\n            final ExactACset set = ACqueue.remove();\n\n            if ( maxLikelihoodSeen.withinMaxACs(set.ACcounts) ) {\n                final double log10LofKs = calculateAlleleCountConformation(set, genotypeLikelihoods, maxLikelihoodSeen, numChr, ACqueue, indexesToACset, log10AlleleFrequencyPriors, result);\n\n                // adjust max likelihood seen if needed\n                maxLikelihoodSeen.update(log10LofKs);\n\n                // clean up memory\n                indexesToACset.remove(set.ACcounts);\n                //if ( DEBUG )\n                //    System.out.printf(\" *** removing used set=%s%n\", set.ACcounts);\n            }\n        }\n    }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static double determineCoefficient(int PLindex, final int j, final int[] ACcounts, final int totalK) {\n\n        // the closed form representation generalized for multiple alleles is as follows:\n        // AA: (2j - totalK) * (2j - totalK - 1)\n        // AB: 2k_b * (2j - totalK)\n        // AC: 2k_c * (2j - totalK)\n        // BB: k_b * (k_b - 1)\n        // BC: 2 * k_b * k_c\n        // CC: k_c * (k_c - 1)\n\n        // find the 2 alleles that are represented by this PL index\n        GenotypeLikelihoods.GenotypeLikelihoodsAllelePair alleles = GenotypeLikelihoods.getAllelePair(PLindex);\n\n        // *** note that throughout this method we subtract one from the alleleIndex because ACcounts ***\n        // *** doesn't consider the reference allele whereas the GenotypeLikelihoods PL cache does.   ***\n\n        // the AX het case\n        if ( alleles.alleleIndex1 == 0 )\n            return MathUtils.log10Cache[2*ACcounts[alleles.alleleIndex2-1]] + MathUtils.log10Cache[2*j-totalK];\n\n        final int k_i = ACcounts[alleles.alleleIndex1-1];\n\n        // the hom var case (e.g. BB, CC, DD)\n        final double coeff;\n        if ( alleles.alleleIndex1 == alleles.alleleIndex2 ) {\n            coeff = MathUtils.log10Cache[k_i] + MathUtils.log10Cache[k_i - 1];\n        }\n        // the het non-ref case (e.g. BC, BD, CD)\n        else {\n            final int k_j = ACcounts[alleles.alleleIndex2-1];\n            coeff = MathUtils.log10Cache[2] + MathUtils.log10Cache[k_i] + MathUtils.log10Cache[k_j];\n        }\n\n        return coeff;\n    }","id":43024,"modified_method":"private double determineCoefficient(int PLindex, final int j, final int[] ACcounts, final int totalK) {\n        // the closed form representation generalized for multiple alleles is as follows:\n        // AA: (2j - totalK) * (2j - totalK - 1)\n        // AB: 2k_b * (2j - totalK)\n        // AC: 2k_c * (2j - totalK)\n        // BB: k_b * (k_b - 1)\n        // BC: 2 * k_b * k_c\n        // CC: k_c * (k_c - 1)\n\n        // find the 2 alleles that are represented by this PL index\n        GenotypeLikelihoods.GenotypeLikelihoodsAllelePair alleles = GenotypeLikelihoods.getAllelePair(PLindex);\n\n        // *** note that throughout this method we subtract one from the alleleIndex because ACcounts ***\n        // *** doesn't consider the reference allele whereas the GenotypeLikelihoods PL cache does.   ***\n\n        // the AX het case\n        if ( alleles.alleleIndex1 == 0 )\n            return MathUtils.log10Cache[2*ACcounts[alleles.alleleIndex2-1]] + MathUtils.log10Cache[2*j-totalK];\n\n        final int k_i = ACcounts[alleles.alleleIndex1-1];\n\n        // the hom var case (e.g. BB, CC, DD)\n        final double coeff;\n        if ( alleles.alleleIndex1 == alleles.alleleIndex2 ) {\n            coeff = MathUtils.log10Cache[k_i] + MathUtils.log10Cache[k_i - 1];\n        }\n        // the het non-ref case (e.g. BC, BD, CD)\n        else {\n            final int k_j = ACcounts[alleles.alleleIndex2-1];\n            coeff = MathUtils.log10Cache[2] + MathUtils.log10Cache[k_i] + MathUtils.log10Cache[k_j];\n        }\n\n        return coeff;\n    }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static double calculateAlleleCountConformation(final ExactACset set,\n                                                           final ArrayList<double[]> genotypeLikelihoods,\n                                                           final MaxLikelihoodSeen maxLikelihoodSeen,\n                                                           final int numChr,\n                                                           final LinkedList<ExactACset> ACqueue,\n                                                           final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                                           final double[] log10AlleleFrequencyPriors,\n                                                           final AlleleFrequencyCalculationResult result) {\n\n        //if ( DEBUG )\n        //    System.out.printf(\" *** computing LofK for set=%s%n\", set.ACcounts);\n\n        // compute the log10Likelihoods\n        computeLofK(set, genotypeLikelihoods, log10AlleleFrequencyPriors, result);\n\n        final double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // can we abort early because the log10Likelihoods are so small?\n        if ( log10LofK < maxLikelihoodSeen.maxLog10L - MAX_LOG10_ERROR_TO_STOP_EARLY && maxLikelihoodSeen.isLowerAC(set.ACcounts) ) {\n            //if ( DEBUG )\n            //    System.out.printf(\" *** breaking early set=%s log10L=%.2f maxLog10L=%.2f%n\", set.ACcounts, log10LofK, maxLog10L);\n            return log10LofK;\n        }\n\n        // iterate over higher frequencies if possible\n        final int ACwiggle = numChr - set.getACsum();\n        if ( ACwiggle == 0 ) // all alternate alleles already sum to 2N so we cannot possibly go to higher frequencies\n            return log10LofK;\n\n        final int numAltAlleles = set.ACcounts.getCounts().length;\n\n        // add conformations for the k+1 case\n        for ( int allele = 0; allele < numAltAlleles; allele++ ) {\n            final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n            ACcountsClone[allele]++;\n            // to get to this conformation, a sample would need to be AB (remember that ref=0)\n            final int PLindex = GenotypeLikelihoods.calculatePLindex(0, allele+1);\n            updateACset(ACcountsClone, numChr, set, PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        // add conformations for the k+2 case if it makes sense; note that the 2 new alleles may be the same or different\n        if ( ACwiggle > 1 ) {\n            final ArrayList<DependentSet> differentAlleles = new ArrayList<DependentSet>(numAltAlleles * numAltAlleles);\n            final ArrayList<DependentSet> sameAlleles = new ArrayList<DependentSet>(numAltAlleles);\n\n            for ( int allele_i = 0; allele_i < numAltAlleles; allele_i++ ) {\n                for ( int allele_j = allele_i; allele_j < numAltAlleles; allele_j++ ) {\n                    final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n                    ACcountsClone[allele_i]++;\n                    ACcountsClone[allele_j]++;\n\n                    // to get to this conformation, a sample would need to be BB or BC (remember that ref=0, so add one to the index)\n                    final int PLindex = GenotypeLikelihoods.calculatePLindex(allele_i+1, allele_j+1);\n                    if ( allele_i == allele_j )\n                        sameAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                    else\n                        differentAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                }\n            }\n\n            // IMPORTANT: we must first add the cases where the 2 new alleles are different so that the queue maintains its ordering\n            for ( DependentSet dependent : differentAlleles )\n                updateACset(dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n            for ( DependentSet dependent : sameAlleles )\n                updateACset(dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        return log10LofK;\n    }","id":43025,"modified_method":"private double calculateAlleleCountConformation(final ExactACset set,\n                                                    final ArrayList<double[]> genotypeLikelihoods,\n                                                    final MaxLikelihoodSeen maxLikelihoodSeen,\n                                                    final int numChr,\n                                                    final LinkedList<ExactACset> ACqueue,\n                                                    final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                                    final double[] log10AlleleFrequencyPriors,\n                                                    final AlleleFrequencyCalculationResult result) {\n\n        //if ( DEBUG )\n        //    System.out.printf(\" *** computing LofK for set=%s%n\", set.ACcounts);\n\n        // compute the log10Likelihoods\n        computeLofK(set, genotypeLikelihoods, log10AlleleFrequencyPriors, result);\n\n        final double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // can we abort early because the log10Likelihoods are so small?\n        if ( maxLikelihoodSeen.tooLowLikelihood(log10LofK) ) {\n            //if ( DEBUG )\n            //    System.out.printf(\" *** breaking early set=%s log10L=%.2f maxLog10L=%.2f%n\", set.ACcounts, log10LofK, maxLog10L);\n            return log10LofK;\n        }\n\n        // iterate over higher frequencies if possible\n        final int ACwiggle = numChr - set.getACsum();\n        if ( ACwiggle == 0 ) // all alternate alleles already sum to 2N so we cannot possibly go to higher frequencies\n            return log10LofK;\n\n        final int numAltAlleles = set.ACcounts.getCounts().length;\n\n        // add conformations for the k+1 case\n        for ( int allele = 0; allele < numAltAlleles; allele++ ) {\n            final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n            ACcountsClone[allele]++;\n            // to get to this conformation, a sample would need to be AB (remember that ref=0)\n            final int PLindex = GenotypeLikelihoods.calculatePLindex(0, allele+1);\n            updateACset(maxLikelihoodSeen, ACcountsClone, numChr, set, PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        // add conformations for the k+2 case if it makes sense; note that the 2 new alleles may be the same or different\n        if ( ACwiggle > 1 ) {\n            final ArrayList<DependentSet> differentAlleles = new ArrayList<DependentSet>(numAltAlleles * numAltAlleles);\n            final ArrayList<DependentSet> sameAlleles = new ArrayList<DependentSet>(numAltAlleles);\n\n            for ( int allele_i = 0; allele_i < numAltAlleles; allele_i++ ) {\n                for ( int allele_j = allele_i; allele_j < numAltAlleles; allele_j++ ) {\n                    final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n                    ACcountsClone[allele_i]++;\n                    ACcountsClone[allele_j]++;\n\n                    // to get to this conformation, a sample would need to be BB or BC (remember that ref=0, so add one to the index)\n                    final int PLindex = GenotypeLikelihoods.calculatePLindex(allele_i+1, allele_j+1);\n                    if ( allele_i == allele_j )\n                        sameAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                    else\n                        differentAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                }\n            }\n\n            // IMPORTANT: we must first add the cases where the 2 new alleles are different so that the queue maintains its ordering\n            for ( DependentSet dependent : differentAlleles )\n                updateACset(maxLikelihoodSeen, dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n            for ( DependentSet dependent : sameAlleles )\n                updateACset(maxLikelihoodSeen, dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        return log10LofK;\n    }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void updateACset(final int[] newSetCounts,\n                                    final int numChr,\n                                    final ExactACset dependentSet,\n                                    final int PLsetIndex,\n                                    final Queue<ExactACset> ACqueue,\n                                    final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                    final ArrayList<double[]> genotypeLikelihoods) {\n        final ExactACcounts index = new ExactACcounts(newSetCounts);\n        if ( !indexesToACset.containsKey(index) ) {\n            ExactACset set = new ExactACset(numChr/2 +1, index);\n            indexesToACset.put(index, set);\n            ACqueue.add(set);\n        }\n\n        // push data from the dependency to the new set\n        //if ( DEBUG )\n        //    System.out.println(\" *** pushing data from \" + index + \" to \" + dependencySet.ACcounts);\n        pushData(indexesToACset.get(index), dependentSet, PLsetIndex, genotypeLikelihoods);\n    }","id":43026,"modified_method":"private void updateACset(final MaxLikelihoodSeen maxLikelihoodSeen,\n                             final int[] newSetCounts,\n                             final int numChr,\n                             final ExactACset dependentSet,\n                             final int PLsetIndex,\n                             final Queue<ExactACset> ACqueue,\n                             final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                             final ArrayList<double[]> genotypeLikelihoods) {\n        final ExactACcounts index = new ExactACcounts(newSetCounts);\n        if ( !indexesToACset.containsKey(index) ) {\n            ExactACset set = new ExactACset(numChr/2 +1, index);\n            indexesToACset.put(index, set);\n            ACqueue.add(set);\n        }\n\n        // push data from the dependency to the new set\n        //if ( DEBUG )\n        //    System.out.println(\" *** pushing data from \" + index + \" to \" + dependencySet.ACcounts);\n        pushData(indexesToACset.get(index), dependentSet, PLsetIndex, genotypeLikelihoods);\n    }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void pushData(final ExactACset targetSet,\n                                 final ExactACset dependentSet,\n                                 final int PLsetIndex,\n                                 final ArrayList<double[]> genotypeLikelihoods) {\n        final int totalK = targetSet.getACsum();\n\n        for ( int j = 1; j < targetSet.log10Likelihoods.length; j++ ) {\n\n            if ( totalK <= 2*j ) { // skip impossible conformations\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue =\n                        determineCoefficient(PLsetIndex, j, targetSet.ACcounts.getCounts(), totalK) + dependentSet.log10Likelihoods[j-1] + gl[PLsetIndex];\n                targetSet.log10Likelihoods[j] = MathUtils.approximateLog10SumLog10(targetSet.log10Likelihoods[j], conformationValue);\n            }\n        }        \n    }","id":43027,"modified_method":"private void pushData(final ExactACset targetSet,\n                          final ExactACset dependentSet,\n                          final int PLsetIndex,\n                          final ArrayList<double[]> genotypeLikelihoods) {\n        final int totalK = targetSet.getACsum();\n\n        for ( int j = 1; j < targetSet.log10Likelihoods.length; j++ ) {\n\n            if ( totalK <= 2*j ) { // skip impossible conformations\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue =\n                        determineCoefficient(PLsetIndex, j, targetSet.ACcounts.getCounts(), totalK) + dependentSet.log10Likelihoods[j-1] + gl[PLsetIndex];\n                targetSet.log10Likelihoods[j] = MathUtils.approximateLog10SumLog10(targetSet.log10Likelihoods[j], conformationValue);\n            }\n        }\n    }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void computeLofK(final ExactACset set,\n                                    final ArrayList<double[]> genotypeLikelihoods,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AlleleFrequencyCalculationResult result) {\n\n        set.log10Likelihoods[0] = 0.0; // the zero case\n        final int totalK = set.getACsum();\n\n        // special case for k = 0 over all k\n        if ( totalK == 0 ) {\n            for ( int j = 1; j < set.log10Likelihoods.length; j++ )\n                set.log10Likelihoods[j] = set.log10Likelihoods[j-1] + genotypeLikelihoods.get(j)[HOM_REF_INDEX];\n\n            final double log10Lof0 = set.log10Likelihoods[set.log10Likelihoods.length-1];\n            result.setLog10LikelihoodOfAFzero(log10Lof0);\n            result.setLog10PosteriorOfAFzero(log10Lof0 + log10AlleleFrequencyPriors[0]);\n            return;\n        }\n\n        // if we got here, then k > 0 for at least one k.\n        // the non-AA possible conformations were already dealt with by pushes from dependent sets;\n        // now deal with the AA case (which depends on previous cells in this column) and then update the L(j,k) value\n        for ( int j = 1; j < set.log10Likelihoods.length; j++ ) {\n\n            if ( totalK < 2*j-1 ) {\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue = MathUtils.log10Cache[2*j-totalK] + MathUtils.log10Cache[2*j-totalK-1] + set.log10Likelihoods[j-1] + gl[HOM_REF_INDEX];\n                set.log10Likelihoods[j] = MathUtils.approximateLog10SumLog10(set.log10Likelihoods[j], conformationValue);\n            }\n\n            final double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n            set.log10Likelihoods[j] = set.log10Likelihoods[j] - logDenominator;\n        }\n\n        double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // update the MLE if necessary\n        result.updateMLEifNeeded(log10LofK, set.ACcounts.counts);\n\n        // apply the priors over each alternate allele\n        for ( final int ACcount : set.ACcounts.getCounts() ) {\n            if ( ACcount > 0 )\n                log10LofK += log10AlleleFrequencyPriors[ACcount];\n        }\n        result.updateMAPifNeeded(log10LofK, set.ACcounts.counts);\n    }","id":43028,"modified_method":"private void computeLofK(final ExactACset set,\n                             final ArrayList<double[]> genotypeLikelihoods,\n                             final double[] log10AlleleFrequencyPriors,\n                             final AlleleFrequencyCalculationResult result) {\n\n        set.log10Likelihoods[0] = 0.0; // the zero case\n        final int totalK = set.getACsum();\n\n        // special case for k = 0 over all k\n        if ( totalK == 0 ) {\n            for ( int j = 1; j < set.log10Likelihoods.length; j++ )\n                set.log10Likelihoods[j] = set.log10Likelihoods[j-1] + genotypeLikelihoods.get(j)[HOM_REF_INDEX];\n\n            final double log10Lof0 = set.log10Likelihoods[set.log10Likelihoods.length-1];\n            result.setLog10LikelihoodOfAFzero(log10Lof0);\n            result.setLog10PosteriorOfAFzero(log10Lof0 + log10AlleleFrequencyPriors[0]);\n            return;\n        }\n\n        // if we got here, then k > 0 for at least one k.\n        // the non-AA possible conformations were already dealt with by pushes from dependent sets;\n        // now deal with the AA case (which depends on previous cells in this column) and then update the L(j,k) value\n        for ( int j = 1; j < set.log10Likelihoods.length; j++ ) {\n\n            if ( totalK < 2*j-1 ) {\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue = MathUtils.log10Cache[2*j-totalK] + MathUtils.log10Cache[2*j-totalK-1] + set.log10Likelihoods[j-1] + gl[HOM_REF_INDEX];\n                set.log10Likelihoods[j] = MathUtils.approximateLog10SumLog10(set.log10Likelihoods[j], conformationValue);\n            }\n\n            final double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n            set.log10Likelihoods[j] = set.log10Likelihoods[j] - logDenominator;\n        }\n\n        double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // update the MLE if necessary\n        result.updateMLEifNeeded(log10LofK, set.ACcounts.counts);\n\n        // apply the priors over each alternate allele\n        for ( final int ACcount : set.ACcounts.getCounts() ) {\n            if ( ACcount > 0 )\n                log10LofK += log10AlleleFrequencyPriors[ACcount];\n        }\n        result.updateMAPifNeeded(log10LofK, set.ACcounts.counts);\n    }","commit_id":"cd8753efbe8050f7988cd5c63ba72b51cf2a27d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static void linearExactMultiAllelic(final GenotypesContext GLs,\n                                               final int numAlternateAlleles,\n                                               final double[] log10AlleleFrequencyPriors,\n                                               final AlleleFrequencyCalculationResult result) {\n\n        final ArrayList<double[]> genotypeLikelihoods = getGLs(GLs);\n        final int numSamples = genotypeLikelihoods.size()-1;\n        final int numChr = 2*numSamples;\n\n        // queue of AC conformations to process\n        final LinkedList<ExactACset> ACqueue = new LinkedList<ExactACset>();\n\n        // mapping of ExactACset indexes to the objects\n        final HashMap<ExactACcounts, ExactACset> indexesToACset = new HashMap<ExactACcounts, ExactACset>(numChr+1);\n\n        // add AC=0 to the queue\n        int[] zeroCounts = new int[numAlternateAlleles];\n        ExactACset zeroSet = new ExactACset(numSamples+1, new ExactACcounts(zeroCounts));\n        ACqueue.add(zeroSet);\n        indexesToACset.put(zeroSet.ACcounts, zeroSet);\n\n        // keep processing while we have AC conformations that need to be calculated\n        OldMaxLikelihoodSeen maxLikelihoodSeen = new OldMaxLikelihoodSeen();\n        while ( !ACqueue.isEmpty() ) {\n            result.incNEvaluations(); // keep track of the number of evaluations\n\n            // compute log10Likelihoods\n            final ExactACset set = ACqueue.remove();\n            final double log10LofKs = calculateAlleleCountConformation(set, genotypeLikelihoods, maxLikelihoodSeen, numChr, ACqueue, indexesToACset, log10AlleleFrequencyPriors, result);\n\n            // adjust max likelihood seen if needed\n            if ( log10LofKs > maxLikelihoodSeen.maxLog10L )\n                maxLikelihoodSeen.update(log10LofKs, set.ACcounts);\n\n            // clean up memory\n            indexesToACset.remove(set.ACcounts);\n            //if ( DEBUG )\n            //    System.out.printf(\" *** removing used set=%s%n\", set.ACcounts);\n        }\n    }","id":43029,"modified_method":"protected abstract MaxLikelihoodSeen makeMaxLikelihood(final VariantContext vc, final AlleleFrequencyCalculationResult result);","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void computeLofK(final ExactACset set,\n                                    final ArrayList<double[]> genotypeLikelihoods,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AlleleFrequencyCalculationResult result) {\n\n        set.log10Likelihoods[0] = 0.0; // the zero case\n        final int totalK = set.getACsum();\n\n        // special case for k = 0 over all k\n        if ( totalK == 0 ) {\n            for ( int j = 1; j < set.log10Likelihoods.length; j++ )\n                set.log10Likelihoods[j] = set.log10Likelihoods[j-1] + genotypeLikelihoods.get(j)[HOM_REF_INDEX];\n\n            final double log10Lof0 = set.log10Likelihoods[set.log10Likelihoods.length-1];\n            result.setLog10LikelihoodOfAFzero(log10Lof0);\n            result.setLog10PosteriorOfAFzero(log10Lof0 + log10AlleleFrequencyPriors[0]);\n            return;\n        }\n\n        // if we got here, then k > 0 for at least one k.\n        // the non-AA possible conformations were already dealt with by pushes from dependent sets;\n        // now deal with the AA case (which depends on previous cells in this column) and then update the L(j,k) value\n        for ( int j = 1; j < set.log10Likelihoods.length; j++ ) {\n\n            if ( totalK < 2*j-1 ) {\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue = MathUtils.log10Cache[2*j-totalK] + MathUtils.log10Cache[2*j-totalK-1] + set.log10Likelihoods[j-1] + gl[HOM_REF_INDEX];\n                set.log10Likelihoods[j] = MathUtils.approximateLog10SumLog10(set.log10Likelihoods[j], conformationValue);\n            }\n\n            final double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n            set.log10Likelihoods[j] = set.log10Likelihoods[j] - logDenominator;\n        }\n\n        double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // update the MLE if necessary\n        result.updateMLEifNeeded(log10LofK, set.ACcounts.counts);\n\n        // apply the priors over each alternate allele\n        for ( final int ACcount : set.ACcounts.getCounts() ) {\n            if ( ACcount > 0 )\n                log10LofK += log10AlleleFrequencyPriors[ACcount];\n        }\n        result.updateMAPifNeeded(log10LofK, set.ACcounts.counts);\n    }","id":43030,"modified_method":"private void computeLofK(final ExactACset set,\n                             final ArrayList<double[]> genotypeLikelihoods,\n                             final double[] log10AlleleFrequencyPriors,\n                             final AlleleFrequencyCalculationResult result) {\n\n        set.log10Likelihoods[0] = 0.0; // the zero case\n        final int totalK = set.getACsum();\n\n        // special case for k = 0 over all k\n        if ( totalK == 0 ) {\n            for ( int j = 1; j < set.log10Likelihoods.length; j++ )\n                set.log10Likelihoods[j] = set.log10Likelihoods[j-1] + genotypeLikelihoods.get(j)[HOM_REF_INDEX];\n\n            final double log10Lof0 = set.log10Likelihoods[set.log10Likelihoods.length-1];\n            result.setLog10LikelihoodOfAFzero(log10Lof0);\n            result.setLog10PosteriorOfAFzero(log10Lof0 + log10AlleleFrequencyPriors[0]);\n            return;\n        }\n\n        // if we got here, then k > 0 for at least one k.\n        // the non-AA possible conformations were already dealt with by pushes from dependent sets;\n        // now deal with the AA case (which depends on previous cells in this column) and then update the L(j,k) value\n        for ( int j = 1; j < set.log10Likelihoods.length; j++ ) {\n\n            if ( totalK < 2*j-1 ) {\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue = MathUtils.log10Cache[2*j-totalK] + MathUtils.log10Cache[2*j-totalK-1] + set.log10Likelihoods[j-1] + gl[HOM_REF_INDEX];\n                set.log10Likelihoods[j] = MathUtils.approximateLog10SumLog10(set.log10Likelihoods[j], conformationValue);\n            }\n\n            final double logDenominator = MathUtils.log10Cache[2*j] + MathUtils.log10Cache[2*j-1];\n            set.log10Likelihoods[j] = set.log10Likelihoods[j] - logDenominator;\n        }\n\n        double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // update the MLE if necessary\n        result.updateMLEifNeeded(log10LofK, set.ACcounts.counts);\n\n        // apply the priors over each alternate allele\n        for ( final int ACcount : set.ACcounts.getCounts() ) {\n            if ( ACcount > 0 )\n                log10LofK += log10AlleleFrequencyPriors[ACcount];\n        }\n        result.updateMAPifNeeded(log10LofK, set.ACcounts.counts);\n    }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void pushData(final ExactACset targetSet,\n                                 final ExactACset dependentSet,\n                                 final int PLsetIndex,\n                                 final ArrayList<double[]> genotypeLikelihoods) {\n        final int totalK = targetSet.getACsum();\n\n        for ( int j = 1; j < targetSet.log10Likelihoods.length; j++ ) {\n\n            if ( totalK <= 2*j ) { // skip impossible conformations\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue =\n                        determineCoefficient(PLsetIndex, j, targetSet.ACcounts.getCounts(), totalK) + dependentSet.log10Likelihoods[j-1] + gl[PLsetIndex];\n                targetSet.log10Likelihoods[j] = MathUtils.approximateLog10SumLog10(targetSet.log10Likelihoods[j], conformationValue);\n            }\n        }        \n    }","id":43031,"modified_method":"private void pushData(final ExactACset targetSet,\n                          final ExactACset dependentSet,\n                          final int PLsetIndex,\n                          final ArrayList<double[]> genotypeLikelihoods) {\n        final int totalK = targetSet.getACsum();\n\n        for ( int j = 1; j < targetSet.log10Likelihoods.length; j++ ) {\n\n            if ( totalK <= 2*j ) { // skip impossible conformations\n                final double[] gl = genotypeLikelihoods.get(j);\n                final double conformationValue =\n                        determineCoefficient(PLsetIndex, j, targetSet.ACcounts.getCounts(), totalK) + dependentSet.log10Likelihoods[j-1] + gl[PLsetIndex];\n                targetSet.log10Likelihoods[j] = MathUtils.approximateLog10SumLog10(targetSet.log10Likelihoods[j], conformationValue);\n            }\n        }\n    }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static double determineCoefficient(int PLindex, final int j, final int[] ACcounts, final int totalK) {\n\n        // the closed form representation generalized for multiple alleles is as follows:\n        // AA: (2j - totalK) * (2j - totalK - 1)\n        // AB: 2k_b * (2j - totalK)\n        // AC: 2k_c * (2j - totalK)\n        // BB: k_b * (k_b - 1)\n        // BC: 2 * k_b * k_c\n        // CC: k_c * (k_c - 1)\n\n        // find the 2 alleles that are represented by this PL index\n        GenotypeLikelihoods.GenotypeLikelihoodsAllelePair alleles = GenotypeLikelihoods.getAllelePair(PLindex);\n\n        // *** note that throughout this method we subtract one from the alleleIndex because ACcounts ***\n        // *** doesn't consider the reference allele whereas the GenotypeLikelihoods PL cache does.   ***\n\n        // the AX het case\n        if ( alleles.alleleIndex1 == 0 )\n            return MathUtils.log10Cache[2*ACcounts[alleles.alleleIndex2-1]] + MathUtils.log10Cache[2*j-totalK];\n\n        final int k_i = ACcounts[alleles.alleleIndex1-1];\n\n        // the hom var case (e.g. BB, CC, DD)\n        final double coeff;\n        if ( alleles.alleleIndex1 == alleles.alleleIndex2 ) {\n            coeff = MathUtils.log10Cache[k_i] + MathUtils.log10Cache[k_i - 1];\n        }\n        // the het non-ref case (e.g. BC, BD, CD)\n        else {\n            final int k_j = ACcounts[alleles.alleleIndex2-1];\n            coeff = MathUtils.log10Cache[2] + MathUtils.log10Cache[k_i] + MathUtils.log10Cache[k_j];\n        }\n\n        return coeff;\n    }","id":43032,"modified_method":"private double determineCoefficient(int PLindex, final int j, final int[] ACcounts, final int totalK) {\n        // the closed form representation generalized for multiple alleles is as follows:\n        // AA: (2j - totalK) * (2j - totalK - 1)\n        // AB: 2k_b * (2j - totalK)\n        // AC: 2k_c * (2j - totalK)\n        // BB: k_b * (k_b - 1)\n        // BC: 2 * k_b * k_c\n        // CC: k_c * (k_c - 1)\n\n        // find the 2 alleles that are represented by this PL index\n        GenotypeLikelihoods.GenotypeLikelihoodsAllelePair alleles = GenotypeLikelihoods.getAllelePair(PLindex);\n\n        // *** note that throughout this method we subtract one from the alleleIndex because ACcounts ***\n        // *** doesn't consider the reference allele whereas the GenotypeLikelihoods PL cache does.   ***\n\n        // the AX het case\n        if ( alleles.alleleIndex1 == 0 )\n            return MathUtils.log10Cache[2*ACcounts[alleles.alleleIndex2-1]] + MathUtils.log10Cache[2*j-totalK];\n\n        final int k_i = ACcounts[alleles.alleleIndex1-1];\n\n        // the hom var case (e.g. BB, CC, DD)\n        final double coeff;\n        if ( alleles.alleleIndex1 == alleles.alleleIndex2 ) {\n            coeff = MathUtils.log10Cache[k_i] + MathUtils.log10Cache[k_i - 1];\n        }\n        // the het non-ref case (e.g. BC, BD, CD)\n        else {\n            final int k_j = ACcounts[alleles.alleleIndex2-1];\n            coeff = MathUtils.log10Cache[2] + MathUtils.log10Cache[k_i] + MathUtils.log10Cache[k_j];\n        }\n\n        return coeff;\n    }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static double calculateAlleleCountConformation(final ExactACset set,\n                                                           final ArrayList<double[]> genotypeLikelihoods,\n                                                           final OldMaxLikelihoodSeen maxLikelihoodSeen,\n                                                           final int numChr,\n                                                           final LinkedList<ExactACset> ACqueue,\n                                                           final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                                           final double[] log10AlleleFrequencyPriors,\n                                                           final AlleleFrequencyCalculationResult result) {\n\n        //if ( DEBUG )\n        //    System.out.printf(\" *** computing LofK for set=%s%n\", set.ACcounts);\n\n        // compute the log10Likelihoods\n        computeLofK(set, genotypeLikelihoods, log10AlleleFrequencyPriors, result);\n\n        final double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // can we abort early because the log10Likelihoods are so small?\n        if ( log10LofK < maxLikelihoodSeen.maxLog10L - MAX_LOG10_ERROR_TO_STOP_EARLY && maxLikelihoodSeen.isLowerAC(set.ACcounts) ) {\n            //if ( DEBUG )\n            //    System.out.printf(\" *** breaking early set=%s log10L=%.2f maxLog10L=%.2f%n\", set.ACcounts, log10LofK, maxLog10L);\n            return log10LofK;\n        }\n\n        // iterate over higher frequencies if possible\n        final int ACwiggle = numChr - set.getACsum();\n        if ( ACwiggle == 0 ) // all alternate alleles already sum to 2N so we cannot possibly go to higher frequencies\n            return log10LofK;\n\n        final int numAltAlleles = set.ACcounts.getCounts().length;\n\n        // add conformations for the k+1 case\n        for ( int allele = 0; allele < numAltAlleles; allele++ ) {\n            final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n            ACcountsClone[allele]++;\n            // to get to this conformation, a sample would need to be AB (remember that ref=0)\n            final int PLindex = GenotypeLikelihoods.calculatePLindex(0, allele+1);\n            updateACset(ACcountsClone, numChr, set, PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        // add conformations for the k+2 case if it makes sense; note that the 2 new alleles may be the same or different\n        if ( ACwiggle > 1 ) {\n            final ArrayList<DependentSet> differentAlleles = new ArrayList<DependentSet>(numAltAlleles * numAltAlleles);\n            final ArrayList<DependentSet> sameAlleles = new ArrayList<DependentSet>(numAltAlleles);\n\n            for ( int allele_i = 0; allele_i < numAltAlleles; allele_i++ ) {\n                for ( int allele_j = allele_i; allele_j < numAltAlleles; allele_j++ ) {\n                    final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n                    ACcountsClone[allele_i]++;\n                    ACcountsClone[allele_j]++;\n\n                    // to get to this conformation, a sample would need to be BB or BC (remember that ref=0, so add one to the index)\n                    final int PLindex = GenotypeLikelihoods.calculatePLindex(allele_i+1, allele_j+1);\n                    if ( allele_i == allele_j )\n                        sameAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                    else\n                        differentAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                }\n            }\n\n            // IMPORTANT: we must first add the cases where the 2 new alleles are different so that the queue maintains its ordering\n            for ( DependentSet dependent : differentAlleles )\n                updateACset(dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n            for ( DependentSet dependent : sameAlleles )\n                updateACset(dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        return log10LofK;\n    }","id":43033,"modified_method":"private double calculateAlleleCountConformation(final ExactACset set,\n                                                    final ArrayList<double[]> genotypeLikelihoods,\n                                                    final MaxLikelihoodSeen maxLikelihoodSeen,\n                                                    final int numChr,\n                                                    final LinkedList<ExactACset> ACqueue,\n                                                    final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                                    final double[] log10AlleleFrequencyPriors,\n                                                    final AlleleFrequencyCalculationResult result) {\n\n        //if ( DEBUG )\n        //    System.out.printf(\" *** computing LofK for set=%s%n\", set.ACcounts);\n\n        // compute the log10Likelihoods\n        computeLofK(set, genotypeLikelihoods, log10AlleleFrequencyPriors, result);\n\n        final double log10LofK = set.log10Likelihoods[set.log10Likelihoods.length-1];\n\n        // can we abort early because the log10Likelihoods are so small?\n        if ( maxLikelihoodSeen.abort(log10LofK, set.ACcounts) ) {\n            //if ( DEBUG )\n            //    System.out.printf(\" *** breaking early set=%s log10L=%.2f maxLog10L=%.2f%n\", set.ACcounts, log10LofK, maxLog10L);\n            return log10LofK;\n        }\n\n        // iterate over higher frequencies if possible\n        final int ACwiggle = numChr - set.getACsum();\n        if ( ACwiggle == 0 ) // all alternate alleles already sum to 2N so we cannot possibly go to higher frequencies\n            return log10LofK;\n\n        final int numAltAlleles = set.ACcounts.getCounts().length;\n\n        // add conformations for the k+1 case\n        for ( int allele = 0; allele < numAltAlleles; allele++ ) {\n            final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n            ACcountsClone[allele]++;\n            // to get to this conformation, a sample would need to be AB (remember that ref=0)\n            final int PLindex = GenotypeLikelihoods.calculatePLindex(0, allele+1);\n            updateACset(maxLikelihoodSeen, ACcountsClone, numChr, set, PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        // add conformations for the k+2 case if it makes sense; note that the 2 new alleles may be the same or different\n        if ( ACwiggle > 1 ) {\n            final ArrayList<DependentSet> differentAlleles = new ArrayList<DependentSet>(numAltAlleles * numAltAlleles);\n            final ArrayList<DependentSet> sameAlleles = new ArrayList<DependentSet>(numAltAlleles);\n\n            for ( int allele_i = 0; allele_i < numAltAlleles; allele_i++ ) {\n                for ( int allele_j = allele_i; allele_j < numAltAlleles; allele_j++ ) {\n                    final int[] ACcountsClone = set.ACcounts.getCounts().clone();\n                    ACcountsClone[allele_i]++;\n                    ACcountsClone[allele_j]++;\n\n                    // to get to this conformation, a sample would need to be BB or BC (remember that ref=0, so add one to the index)\n                    final int PLindex = GenotypeLikelihoods.calculatePLindex(allele_i+1, allele_j+1);\n                    if ( allele_i == allele_j )\n                        sameAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                    else\n                        differentAlleles.add(new DependentSet(ACcountsClone, PLindex));\n                }\n            }\n\n            // IMPORTANT: we must first add the cases where the 2 new alleles are different so that the queue maintains its ordering\n            for ( DependentSet dependent : differentAlleles )\n                updateACset(maxLikelihoodSeen, dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n            for ( DependentSet dependent : sameAlleles )\n                updateACset(maxLikelihoodSeen, dependent.ACcounts, numChr, set, dependent.PLindex, ACqueue, indexesToACset, genotypeLikelihoods);\n        }\n\n        return log10LofK;\n    }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Dynamically found in UnifiedGenotyperEngine\n     *\n     * @param UAC\n     * @param N\n     * @param logger\n     * @param verboseWriter\n     */\n    public DiploidExactAFCalculation(UnifiedArgumentCollection UAC, int N, Logger logger, PrintStream verboseWriter) {\n        super(UAC, N, logger, verboseWriter);\n    }","id":43034,"modified_method":"public DiploidExactAFCalculation(UnifiedArgumentCollection UAC, int N, Logger logger, PrintStream verboseWriter) {\n        super(UAC, N, logger, verboseWriter);\n    }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void updateACset(final int[] newSetCounts,\n                                    final int numChr,\n                                    final ExactACset dependentSet,\n                                    final int PLsetIndex,\n                                    final Queue<ExactACset> ACqueue,\n                                    final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                                    final ArrayList<double[]> genotypeLikelihoods) {\n        final ExactACcounts index = new ExactACcounts(newSetCounts);\n        if ( !indexesToACset.containsKey(index) ) {\n            ExactACset set = new ExactACset(numChr/2 +1, index);\n            indexesToACset.put(index, set);\n            ACqueue.add(set);\n        }\n\n        // push data from the dependency to the new set\n        //if ( DEBUG )\n        //    System.out.println(\" *** pushing data from \" + index + \" to \" + dependencySet.ACcounts);\n        pushData(indexesToACset.get(index), dependentSet, PLsetIndex, genotypeLikelihoods);\n    }","id":43035,"modified_method":"private void updateACset(final MaxLikelihoodSeen maxLikelihoodSeen,\n                             final int[] newSetCounts,\n                             final int numChr,\n                             final ExactACset dependentSet,\n                             final int PLsetIndex,\n                             final Queue<ExactACset> ACqueue,\n                             final HashMap<ExactACcounts, ExactACset> indexesToACset,\n                             final ArrayList<double[]> genotypeLikelihoods) {\n        final ExactACcounts index = new ExactACcounts(newSetCounts);\n        if ( !indexesToACset.containsKey(index) ) {\n            ExactACset set = new ExactACset(numChr/2 +1, index);\n            indexesToACset.put(index, set);\n            ACqueue.add(set);\n        }\n\n        // push data from the dependency to the new set\n        //if ( DEBUG )\n        //    System.out.println(\" *** pushing data from \" + index + \" to \" + dependencySet.ACcounts);\n        pushData(indexesToACset.get(index), dependentSet, PLsetIndex, genotypeLikelihoods);\n    }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void computeLog10PNonRef(final VariantContext vc,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AlleleFrequencyCalculationResult result) {\n        linearExactMultiAllelic(vc.getGenotypes(), vc.getNAlleles() - 1, log10AlleleFrequencyPriors, result);\n    }","id":43036,"modified_method":"@Override\n    public void computeLog10PNonRef(final VariantContext vc,\n                                    final double[] log10AlleleFrequencyPriors,\n                                    final AlleleFrequencyCalculationResult result) {\n        final int numAlternateAlleles = vc.getNAlleles() - 1;\n        final ArrayList<double[]> genotypeLikelihoods = getGLs(vc.getGenotypes());\n        final int numSamples = genotypeLikelihoods.size()-1;\n        final int numChr = 2*numSamples;\n\n        // queue of AC conformations to process\n        final LinkedList<ExactACset> ACqueue = new LinkedList<ExactACset>();\n\n        // mapping of ExactACset indexes to the objects\n        final HashMap<ExactACcounts, ExactACset> indexesToACset = new HashMap<ExactACcounts, ExactACset>(numChr+1);\n\n        // add AC=0 to the queue\n        final int[] zeroCounts = new int[numAlternateAlleles];\n        ExactACset zeroSet = new ExactACset(numSamples+1, new ExactACcounts(zeroCounts));\n        ACqueue.add(zeroSet);\n        indexesToACset.put(zeroSet.ACcounts, zeroSet);\n\n        // keep processing while we have AC conformations that need to be calculated\n        final MaxLikelihoodSeen maxLikelihoodSeen = makeMaxLikelihood(vc, result);\n\n        while ( !ACqueue.isEmpty() ) {\n            result.incNEvaluations(); // keep track of the number of evaluations\n\n            // compute log10Likelihoods\n            final ExactACset set = ACqueue.remove();\n\n            if ( maxLikelihoodSeen.withinMaxACs(set.ACcounts) ) {\n                final double log10LofKs = calculateAlleleCountConformation(set, genotypeLikelihoods, maxLikelihoodSeen, numChr, ACqueue, indexesToACset, log10AlleleFrequencyPriors, result);\n\n                // adjust max likelihood seen if needed\n                maxLikelihoodSeen.update(log10LofKs, set.ACcounts);\n\n                // clean up memory\n                indexesToACset.remove(set.ACcounts);\n                //if ( DEBUG )\n                //    System.out.printf(\" *** removing used set=%s%n\", set.ACcounts);\n            }\n        }\n    }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n         * Are all ACs in otherACs less than or equal to their corresponding ACs in the maxACsToConsider?\n         *\n         * @param otherACs the set of otherACs that we want to know if we should consider analyzing\n         * @return true if otherACs is a state worth considering, or false otherwise\n         */\n        public boolean withinMaxACs(final ExactACcounts otherACs) {\n            final int[] otherACcounts = otherACs.getCounts();\n\n            for ( int i = 0; i < maxACsToConsider.length; i++ ) {\n                // consider one more than the max AC to collect a bit more likelihood mass\n                if ( otherACcounts[i] > maxACsToConsider[i] + 1 )\n                    return false;\n            }\n\n            return true;\n        }","id":43037,"modified_method":"/**\n         * Are all ACs in otherACs less than or equal to their corresponding ACs in the maxACsToConsider?\n         *\n         * @param otherACs the set of otherACs that we want to know if we should consider analyzing\n         * @return true if otherACs is a state worth considering, or false otherwise\n         */\n        public boolean withinMaxACs(final ExactACcounts otherACs) {\n            if ( maxACsToConsider == null )\n                return true;\n\n            final int[] otherACcounts = otherACs.getCounts();\n\n            for ( int i = 0; i < maxACsToConsider.length; i++ ) {\n                // consider one more than the max AC to collect a bit more likelihood mass\n                if ( otherACcounts[i] > maxACsToConsider[i] + 1 )\n                    return false;\n            }\n\n            return true;\n        }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n         * Update the maximum log10L seen, if log10LofKs is higher\n         *\n         * @param log10LofKs the likelihood of our current configuration state\n         */\n        public void update(final double log10LofKs) {\n            if ( log10LofKs > maxLog10L )\n                this.maxLog10L = log10LofKs;\n        }","id":43038,"modified_method":"/**\n         * Update the maximum log10L seen, if log10LofKs is higher\n         *\n         * @param log10LofKs the likelihood of our current configuration state\n         */\n        public void update(final double log10LofKs, final ExactACcounts ACs) {\n            if ( log10LofKs > maxLog10L ) {\n                this.maxLog10L = log10LofKs;\n                this.ACsAtMax = ACs;\n            }\n        }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean selectSiteInSamples(VariantContext vc) {\n        if ( samples == null || samples.isEmpty() )\n            return true;\n        // want to include a site in the given samples if it is *likely* to be variant (via the EXACT model)\n        // first subset to the samples\n        VariantContext subContext = vc.subContextFromSamples(samples);\n\n        // now check to see (using EXACT model) whether this should be variant\n        // do we want to apply a prior? maybe user-spec?\n        if ( flatPriors == null ) {\n            flatPriors = new double[1+2*samples.size()];\n        }\n        AlleleFrequencyCalculationResult result = new AlleleFrequencyCalculationResult(vc.getAlternateAlleles().size());\n        DiploidExactAFCalculation.linearExactMultiAllelic(subContext.getGenotypes(), vc.getAlternateAlleles().size(), flatPriors, result);\n        // do we want to let this qual go up or down?\n        if ( result.getLog10PosteriorOfAFzero() < referenceLikelihood ) {\n            return true;\n        }\n\n        return false;\n    }","id":43039,"modified_method":"public boolean selectSiteInSamples(VariantContext vc) {\n        if ( samples == null || samples.isEmpty() )\n            return true;\n        // want to include a site in the given samples if it is *likely* to be variant (via the EXACT model)\n        // first subset to the samples\n        VariantContext subContext = vc.subContextFromSamples(samples);\n\n        // now check to see (using EXACT model) whether this should be variant\n        // do we want to apply a prior? maybe user-spec?\n        if ( flatPriors == null ) {\n            flatPriors = new double[1+2*samples.size()];\n            AFCalculator = new ReferenceDiploidExactAFCalculation(samples.size(), 4);\n        }\n        AlleleFrequencyCalculationResult result = new AlleleFrequencyCalculationResult(vc.getAlternateAlleles().size());\n        AFCalculator.computeLog10PNonRef(subContext, flatPriors, result);\n        // do we want to let this qual go up or down?\n        if ( result.getLog10PosteriorOfAFzero() < referenceLikelihood ) {\n            return true;\n        }\n\n        return false;\n    }","commit_id":"e6d23a5129d57ddbf57fa685fda1591ea389c8d9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void sendJFKMessage2(byte[] nonceInitator, byte[] hisExponential, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) throws NoContextsException {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(2) message to \"+pn);\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint nonceSize = getNonceSize(negType);\n\t\t// g^r\n\t    DiffieHellmanLightContext dhLctx = getLightDiffieHellmanContext();\n\t    ECDHLightContext ecdhLctx = getECDHLightContext();\n\t\t    \n\t\t// Nr\n\t\tbyte[] myNonce = new byte[nonceSize];\n\t\tnode.random.nextBytes(myNonce);\n\t    byte[] myExponential = (negType < 8 ? dhLctx : ecdhLctx).getPublicKeyNetworkFormat();\n\t    byte[] sig = (negType < 9 ? dhLctx.dsaSig : ecdhLctx.ecdsaSig);\n\t    if(sig.length != getSignatureLength(negType))\n\t        throw new IllegalStateException(\"This shouldn't happen: please report! We are attempting to send \"+sig.length+\" bytes of signature in JFK2! \"+pn.getPeer());\n\t    byte[] authenticator = HMAC.macWithSHA256(getTransientKey(),assembleJFKAuthenticator(myExponential, hisExponential, myNonce, nonceInitator, replyTo.getAddress().getAddress()), HASH_LENGTH);\n\t\tif(logDEBUG) Logger.debug(this, \"We are using the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n        if(logDEBUG) Logger.debug(this, \"We have Ni' : \" + HexUtil.bytesToHex(nonceInitator));\n\t\tbyte[] message2 = new byte[nonceInitator.length + nonceSize+modulusLength+\n\t\t                           sig.length+\n\t\t                           HASH_LENGTH];\n\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nonceInitator, 0, message2, offset, nonceInitator.length);\n\t\toffset += nonceInitator.length;\n\t\tSystem.arraycopy(myNonce, 0, message2, offset, myNonce.length);\n\t\toffset += myNonce.length;\n\t\tSystem.arraycopy(myExponential, 0, message2, offset, modulusLength);\n\t\toffset += modulusLength;\n\n\t    System.arraycopy(sig, 0, message2, offset, sig.length);\n\t    offset += sig.length;\n\t\t\n\t\tSystem.arraycopy(authenticator, 0, message2, offset, HASH_LENGTH);\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1,negType,1,setupType,message2,pn,replyTo,crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,1,message2,pn,replyTo);\n\t\t}\n\t}","id":43040,"modified_method":"private void sendJFKMessage2(byte[] nonceInitator, byte[] hisExponential, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) throws NoContextsException {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(2) message to \"+pn);\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint nonceSize = getNonceSize(negType);\n\t\t// g^r\n\t\t// Neg type 8 and later use ECDH for generating the keys.\n\t\tKeyAgreementSchemeContext ctx = negType < 8 ? getLightDiffieHellmanContext() : getECDHLightContext();\n\t\t\n\t\t// Nr\n\t\tbyte[] myNonce = new byte[nonceSize];\n\t\tnode.random.nextBytes(myNonce);\n\t\tbyte[] myExponential = ctx.getPublicKeyNetworkFormat();\n\t\t// Neg type 9 and later use ECDSA signature.\n\t\tbyte[] sig = (negType < 9 ? ctx.dsaSig : ctx.ecdsaSig);\n\t    if(sig.length != getSignatureLength(negType))\n\t        throw new IllegalStateException(\"This shouldn't happen: please report! We are attempting to send \"+sig.length+\" bytes of signature in JFK2! \"+pn.getPeer());\n\t    byte[] authenticator = HMAC.macWithSHA256(getTransientKey(),assembleJFKAuthenticator(myExponential, hisExponential, myNonce, nonceInitator, replyTo.getAddress().getAddress()), HASH_LENGTH);\n\t\tif(logDEBUG) Logger.debug(this, \"We are using the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n        if(logDEBUG) Logger.debug(this, \"We have Ni' : \" + HexUtil.bytesToHex(nonceInitator));\n\t\tbyte[] message2 = new byte[nonceInitator.length + nonceSize+modulusLength+\n\t\t                           sig.length+\n\t\t                           HASH_LENGTH];\n\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nonceInitator, 0, message2, offset, nonceInitator.length);\n\t\toffset += nonceInitator.length;\n\t\tSystem.arraycopy(myNonce, 0, message2, offset, myNonce.length);\n\t\toffset += myNonce.length;\n\t\tSystem.arraycopy(myExponential, 0, message2, offset, modulusLength);\n\t\toffset += modulusLength;\n\n\t    System.arraycopy(sig, 0, message2, offset, sig.length);\n\t    offset += sig.length;\n\t\t\n\t\tSystem.arraycopy(authenticator, 0, message2, offset, HASH_LENGTH);\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1,negType,1,setupType,message2,pn,replyTo,crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,1,message2,pn,replyTo);\n\t\t}\n\t}","commit_id":"3724b95ae968ef98a9e2f3551692758e84ad25de","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage3(int version,final int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, final PeerNode pn, final Peer replyTo, final boolean unknownInitiator, final int setupType)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn.getPeer());\n\t\tint modulusLength = getModulusLength(negType);\n\t\tlong t1=System.currentTimeMillis();\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\t\tKeyAgreementSchemeContext ctx = pn.getKeyAgreementSchemeContext();\n\t\tif(ctx == null) return;\n\t\tbyte[] ourExponential = ctx.getPublicKeyNetworkFormat();\n\t\tpn.jfkMyRef = unknownInitiator ? crypto.myCompressedHeavySetupRef() : crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + 8 + pn.jfkMyRef.length];\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = pn.getReusableTrackerID();\n\t\tSystem.arraycopy(Fields.longToBytes(trackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tif(logMINOR) Logger.minor(this, \"Sending tracker ID \"+trackerID+\" in JFK(3)\");\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, data, ptr, pn.jfkMyRef.length);\n\t\tfinal byte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           modulusLength*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 + // Signature (R,S)\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, ourExponential, hisExponential, pn.identity, data);\n\t\tpn.setJFKBuffer(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tbyte[] computedExponential;\n\t\tif (negType < 8 ) { // Legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    computedExponential= ((DiffieHellmanLightContext)ctx).getHMACKey(_hisExponential);\n\t\t}else {\n\t\t    computedExponential = ((ECDHLightContext)ctx).getHMACKey(ECDH.getPublicKey(hisExponential, ecdhCurveToUse)).getEncoded();\n\t\t}\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential)+ \" for \" + pn);\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tpn.outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tpn.incommingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"7\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\n\t\tpn.hmacKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"3\");\n\t\tpn.ivKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"4\");\n\t\tpn.ivNonce = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the initiator */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"6\");\n\t\tpn.ourInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tpn.theirInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tif(negType >= 7) {\n\t\t\tpn.theirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tpn.ourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\tpn.ourInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tpn.theirInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\t\t\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+pn.theirInitialMsgID+\" ours \"+pn.ourInitialMsgID);\n\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pcfb = PCFBMode.create(c, iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] cleartext = new byte[JFK_PREFIX_INITIATOR.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, cleartext, cleartextOffset, JFK_PREFIX_INITIATOR.length);\n\t\tcleartextOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_INITIATOR.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tbyte[] hmac = HMAC.macWithSHA256(pn.jfkKa, cleartext, HASH_LENGTH);\n\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator),message3);\n\t\t}\n\t\tfinal long timeSent = System.currentTimeMillis();\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t}\n\n\t\t/* Re-send the packet after 5sec if we don't get any reply */\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif(pn.timeLastConnectionCompleted() < timeSent) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Resending JFK(3) to \"+pn+\" for \"+node.getDarknetPortNumber());\n\t\t\t\t\tif(unknownInitiator) {\n\t\t\t\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, 5*1000);\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for \"+pn.getPeer());\n\t}","id":43041,"modified_method":"private void sendJFKMessage3(int version,final int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, final PeerNode pn, final Peer replyTo, final boolean unknownInitiator, final int setupType)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn.getPeer());\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint signLength = getSignatureLength(negType);\n\t\tlong t1=System.currentTimeMillis();\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\t\tKeyAgreementSchemeContext ctx = pn.getKeyAgreementSchemeContext();\n\t\tif(ctx == null) return;\n\t\tbyte[] ourExponential = ctx.getPublicKeyNetworkFormat();\n\t\tpn.jfkMyRef = unknownInitiator ? crypto.myCompressedHeavySetupRef() : crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + 8 + pn.jfkMyRef.length];\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = pn.getReusableTrackerID();\n\t\tSystem.arraycopy(Fields.longToBytes(trackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tif(logMINOR) Logger.minor(this, \"Sending tracker ID \"+trackerID+\" in JFK(3)\");\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, data, ptr, pn.jfkMyRef.length);\n\t\tfinal byte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           modulusLength*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           signLength + // Signature\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, ourExponential, hisExponential, pn.identity, data);\n\t\tpn.setJFKBuffer(toSign);\n\t\tbyte[] sig = (negType < 9 ? crypto.sign(SHA256.digest(toSign)) : crypto.ecdsaSign(toSign));\n\n\t\tbyte[] computedExponential;\n\t\tif (negType < 8 ) { // Legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    computedExponential= ((DiffieHellmanLightContext)ctx).getHMACKey(_hisExponential);\n\t\t}else {\n\t\t    computedExponential = ((ECDHLightContext)ctx).getHMACKey(ECDH.getPublicKey(hisExponential, ecdhCurveToUse)).getEncoded();\n\t\t}\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential)+ \" for \" + pn);\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tpn.outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tpn.incommingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"7\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\n\t\tpn.hmacKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"3\");\n\t\tpn.ivKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"4\");\n\t\tpn.ivNonce = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the initiator */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"6\");\n\t\tpn.ourInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tpn.theirInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tif(negType >= 7) {\n\t\t\tpn.theirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tpn.ourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\tpn.ourInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tpn.theirInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\t\t\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+pn.theirInitialMsgID+\" ours \"+pn.ourInitialMsgID);\n\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pcfb = PCFBMode.create(c, iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] cleartext = new byte[JFK_PREFIX_INITIATOR.length + ivLength + sig.length + data.length];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, cleartext, cleartextOffset, JFK_PREFIX_INITIATOR.length);\n\t\tcleartextOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(sig, 0, cleartext, cleartextOffset, sig.length);\n\t\tcleartextOffset += sig.length;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_INITIATOR.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tbyte[] hmac = HMAC.macWithSHA256(pn.jfkKa, cleartext, HASH_LENGTH);\n\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator),message3);\n\t\t}\n\t\tfinal long timeSent = System.currentTimeMillis();\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t}\n\n\t\t/* Re-send the packet after 5sec if we don't get any reply */\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif(pn.timeLastConnectionCompleted() < timeSent) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Resending JFK(3) to \"+pn+\" for \"+node.getDarknetPortNumber());\n\t\t\t\t\tif(unknownInitiator) {\n\t\t\t\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, 5*1000);\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for \"+pn.getPeer());\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"private void processDecryptedAuthAnonReply(final byte[] payload, final Peer replyTo, final PeerNode pn) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" for \"+pn+\" length \"+payload.length);\n\n\t\t/** Protocol version. Should be 1. */\n\t\tfinal int version = payload[0];\n\t\t/** Negotiation type.\n\t\t *   2 = JFK.\n\t\t *   3 = JFK, reuse PacketTracker\n\t\t * Other types might indicate other DH variants, or even non-DH-based\n\t\t * algorithms such as password based key setup. */\n\t\tfinal int negType = payload[1];\n\t\t/** Packet phase. */\n\t\tfinal int packetType = payload[2];\n\t\t/** Setup type. See above. */\n\t\tfinal int setupType = payload[3];\n\n\t\tif(logMINOR) Logger.minor(this, \"Received anonymous auth packet (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\", setup type=\"+setupType+\") from \"+replyTo+\"\");\n\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\t\tif(!(negType == 6 || negType == 7 || negType == 8)) {\n\t\t\tif(negType > 8)\n\t\t\t\tLogger.error(this, \"Unknown neg type: \"+negType);\n\t\t\telse\n\t\t\t\tLogger.warning(this, \"Received a setup packet with unsupported obsolete neg type: \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// Known setup types\n\t\tif(setupType != SETUP_OPENNET_SEEDNODE) {\n\t\t\tLogger.error(this, \"Unknown setup type \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// We are the INITIATOR.\n\t\t// Therefore, we can only get packets of phase 2 and 4 here.\n\n\t\tif(packetType == 1 || packetType == 3) {\n\t\t\tauthHandlingThread.execute(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif(packetType == 1) {\n\t\t\t\t\t\t// Phase 2\n\t\t\t\t\t\tprocessJFKMessage2(payload, 4, pn, replyTo, true, setupType, negType);\n\t\t\t\t\t} else if(packetType == 3) {\n\t\t\t\t\t\t// Phase 4\n\t\t\t\t\t\tprocessJFKMessage4(payload, 4, pn, replyTo, false, true, setupType, negType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t} else {\n\t\t\tLogger.error(this, \"Invalid phase \"+packetType+\" for anonymous-initiator (we are the initiator) from \"+replyTo);\n\t\t}\n\t\t\n\t}","id":43042,"modified_method":"private void processDecryptedAuthAnonReply(final byte[] payload, final Peer replyTo, final PeerNode pn) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" for \"+pn+\" length \"+payload.length);\n\n\t\t/** Protocol version. Should be 1. */\n\t\tfinal int version = payload[0];\n\t\t/** Negotiation type.\n\t\t *   2 = JFK.\n\t\t *   3 = JFK, reuse PacketTracker\n\t\t * Other types might indicate other DH variants, or even non-DH-based\n\t\t * algorithms such as password based key setup. */\n\t\tfinal int negType = payload[1];\n\t\t/** Packet phase. */\n\t\tfinal int packetType = payload[2];\n\t\t/** Setup type. See above. */\n\t\tfinal int setupType = payload[3];\n\n\t\tif(logMINOR) Logger.minor(this, \"Received anonymous auth packet (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\", setup type=\"+setupType+\") from \"+replyTo+\"\");\n\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\t\tif(!(negType == 6 || negType == 7 || negType == 8 || negType == 9)) {\n\t\t\tif(negType > 8)\n\t\t\t\tLogger.error(this, \"Unknown neg type: \"+negType);\n\t\t\telse\n\t\t\t\tLogger.warning(this, \"Received a setup packet with unsupported obsolete neg type: \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// Known setup types\n\t\tif(setupType != SETUP_OPENNET_SEEDNODE) {\n\t\t\tLogger.error(this, \"Unknown setup type \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// We are the INITIATOR.\n\t\t// Therefore, we can only get packets of phase 2 and 4 here.\n\n\t\tif(packetType == 1 || packetType == 3) {\n\t\t\tauthHandlingThread.execute(new Runnable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif(packetType == 1) {\n\t\t\t\t\t\t// Phase 2\n\t\t\t\t\t\tprocessJFKMessage2(payload, 4, pn, replyTo, true, setupType, negType);\n\t\t\t\t\t} else if(packetType == 3) {\n\t\t\t\t\t\t// Phase 4\n\t\t\t\t\t\tprocessJFKMessage4(payload, 4, pn, replyTo, false, true, setupType, negType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t} else {\n\t\t\tLogger.error(this, \"Invalid phase \"+packetType+\" for anonymous-initiator (we are the initiator) from \"+replyTo);\n\t\t}\n\t\t\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"private ECDHLightContext _genECDHLightContext() {\n        final ECDHLightContext ctx = new ECDHLightContext(ecdhCurveToUse);\n        ctx.setSignature(crypto.sign(SHA256.digest(assembleDHParams(ctx.getPublicKeyNetworkFormat(), crypto.getCryptoGroup()))));\n\n        return ctx;\n    }","id":43043,"modified_method":"private ECDHLightContext _genECDHLightContext() {\n        final ECDHLightContext ctx = new ECDHLightContext(ecdhCurveToUse);\n        ctx.setSignature(crypto.ecdsaSign(ctx.getPublicKeyNetworkFormat()));\n\n        return ctx;\n    }","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"private boolean processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tif(pn.jfkMyRef == null) {\n\t\t\tString error = \"Got a JFK(4) message but no pn.jfkMyRef for \"+pn;\n\t\t\tif(node.getUptime() < 60*1000) {\n\t\t\t\tLogger.minor(this, error);\n\t\t\t} else {\n\t\t\t\tLogger.error(this, error);\n\t\t\t}\n\t\t}\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tNode.SIGNATURE_PARAMETER_LENGTH * 2 + // the signature\n\t\t\t9 + // ID of packet tracker, plus boolean byte\n\t\t\t8+ // bootID\n\t\t\t1; // znoderefR\n\n\t\tif(payload.length - inputOffset < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn false;\n\t\t}\n\n\t\tbyte[] hmac = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = Arrays.copyOf(JFK_PREFIX_RESPONDER, JFK_PREFIX_RESPONDER.length + payload.length - inputOffset);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tif(!HMAC.verifyWithSHA256(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn false;\n\t\t}\n\n\t\t// Try to find the HMAC in the cache:\n\t\t// If it is already present it indicates duplicate/replayed message4 and we can discard\n\t\t// If it's not, we can add it with a timestamp\n\t\tbyte[] message4Timestamp = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tByteArrayWrapper hmacBAW = new ByteArrayWrapper(hmac);\n\t\t\tmessage4Timestamp = authenticatorCache.get(hmacBAW);\n\t\t\tif(message4Timestamp == null) { // normal behaviour\n\t\t\t\tauthenticatorCache.put(hmacBAW, Fields.longToBytes(t1));\n\t\t\t}\n\t\t}\n\t\tif(message4Timestamp != null) {\n\t\t\tLogger.normal(this, \"We got a replayed message4 (first handled at \"+TimeUtil.formatTime(t1-Fields.bytesToLong(message4Timestamp))+\") from - \"+pn);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the IV\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n\t\tbyte[] r = Arrays.copyOfRange(decypheredPayload, decypheredPayloadOffset, decypheredPayloadOffset+Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = Arrays.copyOfRange(decypheredPayload, decypheredPayloadOffset, decypheredPayloadOffset+Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = Arrays.copyOfRange(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\tboolean reusedTracker;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\treusedTracker = data[ptr++] != 0;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = Arrays.copyOfRange(data, ptr, data.length);\n\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tint dataLen = hisRef.length + 8 + 9;\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + modulusLength * 2 + crypto.myIdentity.length + dataLen + pn.jfkMyRef.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + modulusLength*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tbyte[] identity = crypto.getIdentity(unknownInitiator);\n\t\tSystem.arraycopy(identity, 0, locallyGeneratedText, bufferOffset, identity.length);\n\t\tbufferOffset += identity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, dataLen);\n\t\tbufferOffset += dataLen;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t\tbyte[] messageHash = SHA256.digest(locallyGeneratedText);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, messageHash), false)) {\n\t\t\tString error = \"The signature verification has failed!! JFK(4) -\"+pn.getPeer()+\" message hash \"+HexUtil.bytesToHex(messageHash)+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID;\n\t\t\tLogger.error(this, error);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Received a packet\n\t\tpn.receivedPacket(true, false);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\t// We change the key\n\t\tBlockCipher ivCipher = null;\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\ttry {\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t\toutgoingCipher.initialize(pn.outgoingKey);\n\t\tincommingCipher.initialize(pn.incommingKey);\n\t\tivCipher.initialize(pn.ivKey);\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, pn.outgoingKey, incommingCipher,\n\t\t\t\tpn.incommingKey, replyTo, false, negType, trackerID, true, reusedTracker, pn.hmacKey,\n\t\t\t\tivCipher, pn.ivNonce, pn.ourInitialSeqNum, pn.theirInitialSeqNum, pn.ourInitialMsgID,\n\t\t\t\tpn.theirInitialMsgID);\n\t\tif(newTrackerID >= 0) {\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true);\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\n\t\t// cleanup\n\t\t// FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.outgoingKey = null;\n\t\tpn.incommingKey = null;\n\t\tpn.hmacKey = null;\n\t\tpn.ivKey = null;\n\t\tpn.ivNonce = null;\n\t\tpn.ourInitialSeqNum = 0;\n\t\tpn.theirInitialSeqNum = 0;\n\t\tpn.ourInitialMsgID = 0;\n\t\tpn.theirInitialMsgID = 0;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t\treturn true;\n\t}","id":43044,"modified_method":"private boolean processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tint signLength = getSignatureLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tif(pn.jfkMyRef == null) {\n\t\t\tString error = \"Got a JFK(4) message but no pn.jfkMyRef for \"+pn;\n\t\t\tif(node.getUptime() < 60*1000) {\n\t\t\t\tLogger.minor(this, error);\n\t\t\t} else {\n\t\t\t\tLogger.error(this, error);\n\t\t\t}\n\t\t}\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tsignLength + // the signature\n\t\t\t9 + // ID of packet tracker, plus boolean byte\n\t\t\t8+ // bootID\n\t\t\t1; // znoderefR\n\n\t\tif(payload.length - inputOffset < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn false;\n\t\t}\n\n\t\tbyte[] hmac = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = Arrays.copyOf(JFK_PREFIX_RESPONDER, JFK_PREFIX_RESPONDER.length + payload.length - inputOffset);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tif(!HMAC.verifyWithSHA256(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn false;\n\t\t}\n\n\t\t// Try to find the HMAC in the cache:\n\t\t// If it is already present it indicates duplicate/replayed message4 and we can discard\n\t\t// If it's not, we can add it with a timestamp\n\t\tbyte[] message4Timestamp = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tByteArrayWrapper hmacBAW = new ByteArrayWrapper(hmac);\n\t\t\tmessage4Timestamp = authenticatorCache.get(hmacBAW);\n\t\t\tif(message4Timestamp == null) { // normal behaviour\n\t\t\t\tauthenticatorCache.put(hmacBAW, Fields.longToBytes(t1));\n\t\t\t}\n\t\t}\n\t\tif(message4Timestamp != null) {\n\t\t\tLogger.normal(this, \"We got a replayed message4 (first handled at \"+TimeUtil.formatTime(t1-Fields.bytesToLong(message4Timestamp))+\") from - \"+pn);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the IV\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n        byte[] sig = new byte[signLength];\n        System.arraycopy(decypheredPayload, decypheredPayloadOffset, sig, 0, signLength);\n        decypheredPayloadOffset += signLength;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\tboolean reusedTracker;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\treusedTracker = data[ptr++] != 0;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = Arrays.copyOfRange(data, ptr, data.length);\n\n\t\t// verify the signature\n\t\tint dataLen = hisRef.length + 8 + 9;\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + modulusLength * 2 + crypto.myIdentity.length + dataLen + pn.jfkMyRef.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + modulusLength*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tbyte[] identity = crypto.getIdentity(unknownInitiator);\n\t\tSystem.arraycopy(identity, 0, locallyGeneratedText, bufferOffset, identity.length);\n\t\tbufferOffset += identity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, dataLen);\n\t\tbufferOffset += dataLen;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t    if(negType < 9) { // DSA sig     \n\t        byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t        System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t        byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t        System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t        DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t        byte[] messageHash = SHA256.digest(locallyGeneratedText);\n\t        if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, messageHash), false)) {\n\t            String error = \"The signature verification has failed!! JFK(4) -\"+pn.getPeer()+\" message hash \"+HexUtil.bytesToHex(messageHash)+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID;\n\t            Logger.error(this, error);\n\t            return true;\n\t        }\n\t    } else { // ECDSA sig\n\t        if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, locallyGeneratedText)) {\n\t            Logger.error(this, \"The ECDSA signature verification has failed!! JFK(4) - \"+pn.getPeer()+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID);\n\t            return true;\n\t        }\n\t    }\n\n\t\t// Received a packet\n\t\tpn.receivedPacket(true, false);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\t// We change the key\n\t\tBlockCipher ivCipher = null;\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\ttry {\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t\toutgoingCipher.initialize(pn.outgoingKey);\n\t\tincommingCipher.initialize(pn.incommingKey);\n\t\tivCipher.initialize(pn.ivKey);\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, pn.outgoingKey, incommingCipher,\n\t\t\t\tpn.incommingKey, replyTo, false, negType, trackerID, true, reusedTracker, pn.hmacKey,\n\t\t\t\tivCipher, pn.ivNonce, pn.ourInitialSeqNum, pn.theirInitialSeqNum, pn.ourInitialMsgID,\n\t\t\t\tpn.theirInitialMsgID);\n\t\tif(newTrackerID >= 0) {\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true);\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\n\t\t// cleanup\n\t\t// FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.outgoingKey = null;\n\t\tpn.incommingKey = null;\n\t\tpn.hmacKey = null;\n\t\tpn.ivKey = null;\n\t\tpn.ivNonce = null;\n\t\tpn.ourInitialSeqNum = 0;\n\t\tpn.theirInitialSeqNum = 0;\n\t\tpn.ourInitialMsgID = 0;\n\t\tpn.theirInitialMsgID = 0;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t\treturn true;\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage2(byte[] payload,int inputOffset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn.getPeer());\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = NONCE_SIZE*2 + modulusLength + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] nonceInitiator = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tbyte[] nonceResponder = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tbyte[] r = Arrays.copyOfRange(payload, inputOffset, inputOffset+Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = Arrays.copyOfRange(payload, inputOffset, inputOffset+Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tbyte[] authenticator = Arrays.copyOfRange(payload, inputOffset, inputOffset + HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn.getPeer());\n\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message3, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\n\t\t// sanity check\n\t\tbyte[] myNi = null;\n\t\tsynchronized (pn) {\n\t\t\tfor(byte[] buf : pn.jfkNoncesSent) {\n\t\t\t\tif(Arrays.equals(nonceInitiator, buf))\n\t\t\t\t\tmyNi = buf;\n\t\t\t}\n\t\t}\n\t\t// We don't except such a message;\n\t\tif(myNi == null) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"We received an unexpected JFK(2) message from \"+pn.getPeer()+\" (time since added: \"+pn.timeSinceAddedOrRestarted()+\" time last receive:\"+pn.lastReceivedPacketTime()+')');\n\t\t\t}\n\t\t\treturn;\n\t\t} else if(!Arrays.equals(myNi, nonceInitiator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"Ignoring old JFK(2) (different nonce to the one we sent - either a timing artefact or an attempt to change the nonce)\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType < 8) { // legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    if(!DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t        Logger.error(this, \"We can't accept the exponential \"+pn.getPeer()+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t        return;\n\t\t    }\n\t\t\t// JFK protects us from weak key attacks on ECDH, so we don't need to check.\n\t\t}\n\n\t\t// Verify the DSA signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t// At that point we don't know if it's \"him\"; let's check it out\n\t\tbyte[] locallyExpectedExponentials =  assembleDHParams(hisExponential, pn.peerCryptoGroup);\n\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tsendJFKMessage3(1, negType, 3, nonceInitiator, nonceResponder, hisExponential, authenticator, pn, replyTo, unknownInitiator, setupType);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message2 timeout error:Processing packet for \"+pn.getPeer());\n\t\t}\n\t}","id":43045,"modified_method":"private void processJFKMessage2(byte[] payload,int inputOffset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn.getPeer());\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = NONCE_SIZE*2 + modulusLength + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] nonceInitiator = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tbyte[] nonceResponder = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tint sigLength = getSignatureLength(negType);\n\t\tbyte[] sig = new byte[sigLength];\n\t\tSystem.arraycopy(payload, inputOffset, sig, 0, sigLength);\n\t\tinputOffset += sigLength;\n\n\t\tbyte[] authenticator = Arrays.copyOfRange(payload, inputOffset, inputOffset + HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn.getPeer());\n\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message3, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\n\t\t// sanity check\n\t\tbyte[] myNi = null;\n\t\tsynchronized (pn) {\n\t\t\tfor(byte[] buf : pn.jfkNoncesSent) {\n\t\t\t\tif(Arrays.equals(nonceInitiator, buf))\n\t\t\t\t\tmyNi = buf;\n\t\t\t}\n\t\t}\n\t\t// We don't except such a message;\n\t\tif(myNi == null) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"We received an unexpected JFK(2) message from \"+pn.getPeer()+\" (time since added: \"+pn.timeSinceAddedOrRestarted()+\" time last receive:\"+pn.lastReceivedPacketTime()+')');\n\t\t\t}\n\t\t\treturn;\n\t\t} else if(!Arrays.equals(myNi, nonceInitiator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"Ignoring old JFK(2) (different nonce to the one we sent - either a timing artefact or an attempt to change the nonce)\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType < 8) { // legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    if(!DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t        Logger.error(this, \"We can't accept the exponential \"+pn.getPeer()+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t        return;\n\t\t    }\n\t\t\t// JFK protects us from weak key attacks on ECDH, so we don't need to check.\n\t\t}\n\n\t\tif(negType < 9) {\n\t\t    // Verify the DSA signature\n\t\t    byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t    // At that point we don't know if it's \"him\"; let's check it out\n\t\t    byte[] locallyExpectedExponentials =  assembleDHParams(hisExponential, pn.peerCryptoGroup);\n\n\t\t    if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t        Logger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t\t        return;\n\t\t    }\n\t\t} else {\n\t\t    // Verify the ECDSA signature ; We are assuming that it's the curve we expect\n\t\t    if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, hisExponential)) {\n\t              Logger.error(this, \"The ECDSA signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t                return;\n\t\t    }\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tsendJFKMessage3(1, negType, 3, nonceInitiator, nonceResponder, hisExponential, authenticator, pn, replyTo, unknownInitiator, setupType);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message2 timeout error:Processing packet for \"+pn.getPeer());\n\t\t}\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tNONCE_SIZE*2 + // Ni, Nr\n\t\t\tmodulusLength*2 + // g^i, g^r\n\t\t\tHASH_LENGTH + // authenticator\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t8 +\t      // a bootid\n\t\t\t8 + // packet tracker ID\n\t\t\t1;\t      // znoderefI* is at least 1 byte long\n\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\t// Ni\n\t\tbyte[] nonceInitiator = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\t\t// g^r\n\t\tbyte[] responderExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tbyte[] authenticator = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// We *WANT* to check the hmac before we do the lookup on the hashmap\n\t\t// @see https://bugs.freenetproject.org/view.php?id=1604\n\t\tif(!HMAC.verifyWithSHA256(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\t// We are replaying a JFK(4).\n\t\t\t// Therefore if it is anon-initiator it is encrypted with our setup key.\n\t\t\tif(unknownInitiator) {\n\t\t\t\tsendAnonAuthPacket(1,negType,3,setupType, (byte[]) message4, null, replyTo, crypto.anonSetupCipher);\n\t\t\t} else {\n\t\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message4, pn, replyTo);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(logDEBUG) Logger.debug(this, \"No message4 found for \"+HexUtil.bytesToHex(authenticator)+\" responderExponential \"+Fields.hashCode(responderExponential)+\" initiatorExponential \"+Fields.hashCode(initiatorExponential)+\" nonceResponder \"+Fields.hashCode(nonceResponder)+\" nonceInitiator \"+Fields.hashCode(nonceInitiator)+\" address \"+HexUtil.bytesToHex(replyTo.getAddress().getAddress()));\n\t\t}\n\n\t\tbyte[] hmac = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tbyte[] computedExponential;\n\t\tif(negType < 8) { // Legacy DH\n\t\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\n\t\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\t\tif(ctx == null) {\n\t\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n\t\t\t\t// Possible this is a replay or severely delayed? We don't keep every exponential we ever use.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomputedExponential = ctx.getHMACKey(_hisExponential);\n        } else {\n            ECPublicKey initiatorKey = ECDH.getPublicKey(initiatorExponential, ecdhCurveToUse);\n            ECPublicKey responderKey = ECDH.getPublicKey(responderExponential, ecdhCurveToUse);\n            ECDHLightContext ctx = findECDHContextByPubKey(responderKey);\n            if (ctx == null) {\n                Logger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n                // Possible this is a replay or severely delayed? We don't keep\n                // every exponential we ever use.\n                return;\n            }\n            computedExponential = ctx.getHMACKey(initiatorKey).getEncoded();\n        }\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential) +\" for \" + pn);\n\t\t\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tbyte[] outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"7\");\n\t\tbyte[] incommingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\n\t\tbyte[] hmacKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"3\");\n\t\tbyte[] ivKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"4\");\n\t\tbyte[] ivNonce = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the responder */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"6\");\n\t\tint theirInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tint ourInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tint theirInitialMsgID, ourInitialMsgID;\n\t\tif(negType >= 7) {\n\t\t\ttheirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\ttheirInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tourInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+theirInitialMsgID+\" ours \"+ourInitialMsgID);\n\n\t\tc.initialize(Ke);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = Arrays.copyOf(JFK_PREFIX_INITIATOR, JFK_PREFIX_INITIATOR.length + payload.length - inputOffset);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!HMAC.verifyWithSHA256(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\t// Get the IV\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tbyte[] r = Arrays.copyOfRange(decypheredPayload, decypheredPayloadOffset, decypheredPayloadOffset+Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = Arrays.copyOfRange(decypheredPayload, decypheredPayloadOffset, decypheredPayloadOffset+Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = Arrays.copyOfRange(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tif(trackerID < 0) trackerID = -1;\n\t\tptr += 8;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = Arrays.copyOfRange(data, ptr, data.length);\n\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn, replyTo);\n\t\t}\n\t\tif(pn == null) {\n\t\t\tif(unknownInitiator) {\n\t\t\t\t// Reject\n\t\t\t\tLogger.normal(this, \"Rejecting... unable to construct PeerNode\");\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"PeerNode is null and unknownInitiator is false!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, initiatorExponential, responderExponential, crypto.myIdentity, data))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\tBlockCipher ivCipher = null;\n\t\ttry {\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\toutgoingCipher.initialize(outgoingKey);\n\t\tincommingCipher.initialize(incommingKey);\n\t\tivCipher.initialize(ivKey);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tif(pn instanceof DarknetPeerNode) {\n\t\t\t\tLogger.error(this, \"Dropping peer \"+pn+\" because don't want connection due to others on the same IP address!\");\n\t\t\t\tSystem.out.println(\"Disconnecting permanently from your friend \\\"\"+((DarknetPeerNode)pn).getName()+\"\\\" because other peers are using the same IP address!\");\n\t\t\t}\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, outgoingKey, incommingCipher,\n\t\t\t\tincommingKey, replyTo, true, negType, trackerID, false, false, hmacKey, ivCipher,\n\t\t\t\tivNonce, ourInitialSeqNum, theirInitialSeqNum, ourInitialMsgID, theirInitialMsgID);\n\n\t\tif(newTrackerID > 0) {\n\n\t\t\t// Send reply\n\t\t\tsendJFKMessage4(1, negType, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential,\n\t\t\t\t\tc, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType, newTrackerID, newTrackerID == trackerID);\n\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true); // Let it connect then tell it to remove it.\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t\t// Don't send the JFK(4). We have not successfully connected.\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message3 Processing packet for \"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t\t}\n\t}","id":43046,"modified_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tNONCE_SIZE*2 + // Ni, Nr\n\t\t\tmodulusLength*2 + // g^i, g^r\n\t\t\tHASH_LENGTH + // authenticator\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t8 +\t      // a bootid\n\t\t\t8 + // packet tracker ID\n\t\t\t1;\t      // znoderefI* is at least 1 byte long\n\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\t// Ni\n\t\tbyte[] nonceInitiator = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = Arrays.copyOfRange(payload, inputOffset, inputOffset+NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\t\t// g^r\n\t\tbyte[] responderExponential = Arrays.copyOfRange(payload, inputOffset, inputOffset+modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tbyte[] authenticator = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// We *WANT* to check the hmac before we do the lookup on the hashmap\n\t\t// @see https://bugs.freenetproject.org/view.php?id=1604\n\t\tif(!HMAC.verifyWithSHA256(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\t// We are replaying a JFK(4).\n\t\t\t// Therefore if it is anon-initiator it is encrypted with our setup key.\n\t\t\tif(unknownInitiator) {\n\t\t\t\tsendAnonAuthPacket(1,negType,3,setupType, (byte[]) message4, null, replyTo, crypto.anonSetupCipher);\n\t\t\t} else {\n\t\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message4, pn, replyTo);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(logDEBUG) Logger.debug(this, \"No message4 found for \"+HexUtil.bytesToHex(authenticator)+\" responderExponential \"+Fields.hashCode(responderExponential)+\" initiatorExponential \"+Fields.hashCode(initiatorExponential)+\" nonceResponder \"+Fields.hashCode(nonceResponder)+\" nonceInitiator \"+Fields.hashCode(nonceInitiator)+\" address \"+HexUtil.bytesToHex(replyTo.getAddress().getAddress()));\n\t\t}\n\n\t\tbyte[] hmac = Arrays.copyOfRange(payload, inputOffset, inputOffset+HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tbyte[] computedExponential;\n\t\tif(negType < 8) { // Legacy DH\n\t\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\n\t\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\t\tif(ctx == null) {\n\t\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n\t\t\t\t// Possible this is a replay or severely delayed? We don't keep every exponential we ever use.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomputedExponential = ctx.getHMACKey(_hisExponential);\n        } else {\n            ECPublicKey initiatorKey = ECDH.getPublicKey(initiatorExponential, ecdhCurveToUse);\n            ECPublicKey responderKey = ECDH.getPublicKey(responderExponential, ecdhCurveToUse);\n            ECDHLightContext ctx = findECDHContextByPubKey(responderKey);\n            if (ctx == null) {\n                Logger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n                // Possible this is a replay or severely delayed? We don't keep\n                // every exponential we ever use.\n                return;\n            }\n            computedExponential = ctx.getHMACKey(initiatorKey).getEncoded();\n        }\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential) +\" for \" + pn);\n\t\t\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tbyte[] outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"7\");\n\t\tbyte[] incommingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\n\t\tbyte[] hmacKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"3\");\n\t\tbyte[] ivKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"4\");\n\t\tbyte[] ivNonce = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the responder */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"6\");\n\t\tint theirInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tint ourInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tint theirInitialMsgID, ourInitialMsgID;\n\t\tif(negType >= 7) {\n\t\t\ttheirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\ttheirInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tourInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+theirInitialMsgID+\" ours \"+ourInitialMsgID);\n\n\t\tc.initialize(Ke);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = Arrays.copyOf(JFK_PREFIX_INITIATOR, JFK_PREFIX_INITIATOR.length + payload.length - inputOffset);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!HMAC.verifyWithSHA256(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\t// Get the IV\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tint sigLength = getSignatureLength(negType);\n\t\tbyte[] sig = new byte[sigLength];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, sig, 0, sigLength);\n\t\tdecypheredPayloadOffset += sigLength;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tif(trackerID < 0) trackerID = -1;\n\t\tptr += 8;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = Arrays.copyOfRange(data, ptr, data.length);\n\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn, replyTo);\n\t\t}\n\t\tif(pn == null) {\n\t\t\tif(unknownInitiator) {\n\t\t\t\t// Reject\n\t\t\t\tLogger.normal(this, \"Rejecting... unable to construct PeerNode\");\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"PeerNode is null and unknownInitiator is false!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify the signature\n\t\tbyte[] toVerify = assembleDHParams(nonceInitiator, nonceResponder, initiatorExponential, responderExponential, crypto.myIdentity, data);\n\t\tif(negType < 9) {\n\t\t    byte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\t    System.arraycopy(sig, 0, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n            byte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n            System.arraycopy(sig, Node.SIGNATURE_PARAMETER_LENGTH, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t    DSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t    if(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(toVerify)), false)) {\n\t\t        Logger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t        return;\n\t\t    }\n\t\t} else {\n\t\t    if(!ECDSA.verify(Curves.P256, pn.peerECDSAPubKey, sig, toVerify)) {\n\t              Logger.error(this, \"The ECDSA signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t                return;\n\t\t    }\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\tBlockCipher ivCipher = null;\n\t\ttry {\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\toutgoingCipher.initialize(outgoingKey);\n\t\tincommingCipher.initialize(incommingKey);\n\t\tivCipher.initialize(ivKey);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tif(pn instanceof DarknetPeerNode) {\n\t\t\t\tLogger.error(this, \"Dropping peer \"+pn+\" because don't want connection due to others on the same IP address!\");\n\t\t\t\tSystem.out.println(\"Disconnecting permanently from your friend \\\"\"+((DarknetPeerNode)pn).getName()+\"\\\" because other peers are using the same IP address!\");\n\t\t\t}\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, outgoingKey, incommingCipher,\n\t\t\t\tincommingKey, replyTo, true, negType, trackerID, false, false, hmacKey, ivCipher,\n\t\t\t\tivNonce, ourInitialSeqNum, theirInitialSeqNum, ourInitialMsgID, theirInitialMsgID);\n\n\t\tif(newTrackerID > 0) {\n\n\t\t\t// Send reply\n\t\t\tsendJFKMessage4(1, negType, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential,\n\t\t\t\t\tc, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType, newTrackerID, newTrackerID == trackerID);\n\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true); // Let it connect then tell it to remove it.\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t\t// Don't send the JFK(4). We have not successfully connected.\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message3 Processing packet for \"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t\t}\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage4(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential,byte[] responderExponential, BlockCipher c, byte[] Ke, byte[] Ka, byte[] authenticator, byte[] hisRef, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, long newTrackerID, boolean sameAsOldTrackerID)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn.getPeer());\n\t\tlong t1=System.currentTimeMillis();\n\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[9 + 8 + myRef.length + hisRef.length];\n\t\tint ptr = 0;\n\t\tSystem.arraycopy(Fields.longToBytes(newTrackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tdata[ptr++] = (byte) (sameAsOldTrackerID ? 1 : 0);\n\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(myRef, 0, data, ptr, myRef.length);\n\t\tptr += myRef.length;\n\t\tSystem.arraycopy(hisRef, 0, data, ptr, hisRef.length);\n\n\t\tbyte[] params = assembleDHParams(nonceInitiator, nonceResponder, initiatorExponential, responderExponential, pn.identity, data);\n\t\tbyte[] messageHash = SHA256.digest(params);\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Message hash: \"+HexUtil.bytesToHex(messageHash)+\" length \"+params.length+\" myRef: \"+myRef.length+\" hash \"+Fields.hashCode(myRef)+\" hisRef: \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" boot ID \"+node.bootID);\n\t\tDSASignature localSignature = crypto.sign(messageHash);\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pk=PCFBMode.create(c, iv);\n\t\t// Don't include the last bit\n\t\tint dataLength = data.length - hisRef.length;\n\t\tbyte[] cyphertext = new byte[JFK_PREFIX_RESPONDER.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 +\n\t\t                             dataLength];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, cyphertext, cleartextOffset, JFK_PREFIX_RESPONDER.length);\n\t\tcleartextOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(iv, 0, cyphertext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cyphertext, cleartextOffset, dataLength);\n\t\tcleartextOffset += dataLength;\n\t\t// Now encrypt the cleartext[Signature]\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_RESPONDER.length + ivLength;\n\t\tpk.blockEncipher(cyphertext, cleartextToEncypherOffset, cyphertext.length - cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + iv + signature)\n\t\tbyte[] hmac = HMAC.macWithSHA256(Ka, cyphertext, HASH_LENGTH);\n\n\t\t// Message4 = hmac + IV + encryptedSignature\n\t\tbyte[] message4 = new byte[HASH_LENGTH + ivLength + (cyphertext.length - cleartextToEncypherOffset)];\n\t\tint offset = 0;\n\t\tSystem.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cyphertext, cleartextToEncypherOffset, message4, offset, cyphertext.length - cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator), message4);\n\t\t\tif(logDEBUG) Logger.debug(this, \"Storing JFK(4) for \"+HexUtil.bytesToHex(authenticator));\n\t\t}\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 3, setupType, message4, pn, replyTo, crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 3, message4, pn, replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Sending packet for \"+pn.getPeer());\n\t}","id":43047,"modified_method":"private void sendJFKMessage4(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential,byte[] responderExponential, BlockCipher c, byte[] Ke, byte[] Ka, byte[] authenticator, byte[] hisRef, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, long newTrackerID, boolean sameAsOldTrackerID)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn.getPeer());\n\t\tlong t1=System.currentTimeMillis();\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[9 + 8 + myRef.length + hisRef.length];\n\t\tint ptr = 0;\n\t\tSystem.arraycopy(Fields.longToBytes(newTrackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tdata[ptr++] = (byte) (sameAsOldTrackerID ? 1 : 0);\n\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(myRef, 0, data, ptr, myRef.length);\n\t\tptr += myRef.length;\n\t\tSystem.arraycopy(hisRef, 0, data, ptr, hisRef.length);\n\n\t\tbyte[] params = assembleDHParams(nonceInitiator, nonceResponder, initiatorExponential, responderExponential, pn.identity, data);\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Message length \"+params.length+\" myRef: \"+myRef.length+\" hash \"+Fields.hashCode(myRef)+\" hisRef: \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" boot ID \"+node.bootID);\n\t\tbyte[] sig = (negType < 9 ? crypto.sign(SHA256.digest(params)) : crypto.ecdsaSign(params));\n\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pk=PCFBMode.create(c, iv);\n\t\t// Don't include the last bit\n\t\tint dataLength = data.length - hisRef.length;\n\t\tbyte[] cyphertext = new byte[JFK_PREFIX_RESPONDER.length + ivLength + sig.length + dataLength];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, cyphertext, cleartextOffset, JFK_PREFIX_RESPONDER.length);\n\t\tcleartextOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(iv, 0, cyphertext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(sig, 0, cyphertext, cleartextOffset, sig.length);\n\t\tcleartextOffset += sig.length;\n\t\tSystem.arraycopy(data, 0, cyphertext, cleartextOffset, dataLength);\n\t\tcleartextOffset += dataLength;\n\t\t// Now encrypt the cleartext[Signature]\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_RESPONDER.length + ivLength;\n\t\tpk.blockEncipher(cyphertext, cleartextToEncypherOffset, cyphertext.length - cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + iv + signature)\n\t\tbyte[] hmac = HMAC.macWithSHA256(Ka, cyphertext, HASH_LENGTH);\n\n\t\t// Message4 = hmac + IV + encryptedSignature\n\t\tbyte[] message4 = new byte[HASH_LENGTH + ivLength + (cyphertext.length - cleartextToEncypherOffset)];\n\t\tint offset = 0;\n\t\tSystem.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cyphertext, cleartextToEncypherOffset, message4, offset, cyphertext.length - cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator), message4);\n\t\t\tif(logDEBUG) Logger.debug(this, \"Storing JFK(4) for \"+HexUtil.bytesToHex(authenticator));\n\t\t}\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 3, setupType, message4, pn, replyTo, crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 3, message4, pn, replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Sending packet for \"+pn.getPeer());\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic int[] supportedNegTypes(boolean forPublic) {\n\t\tif(forPublic)\n\t\t\treturn new int[] { 6, 7, 8 };\n\t\telse\n\t\t\treturn new int[] { 7, 8 };\n\t}","id":43048,"modified_method":"@Override\n\tpublic int[] supportedNegTypes(boolean forPublic) {\n\t\tif(forPublic)\n\t\t\treturn new int[] { 6, 7, 8, 9 };\n\t\telse\n\t\t\treturn new int[] { 7, 8, 9 };\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Process a decrypted, authenticated auth packet.\n\t * @param payload The packet payload, after it has been decrypted.\n\t */\n\tprivate void processDecryptedAuth(final byte[] payload, final PeerNode pn, final Peer replyTo, final boolean oldOpennetPeer) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" for \"+pn);\n\t\tif(pn.isDisabled()) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Won't connect to a disabled peer (\"+pn+ ')');\n\t\t\treturn;  // We don't connect to disabled peers\n\t\t}\n\n\t\tfinal int negType = payload[1];\n\t\tfinal int packetType = payload[2];\n\t\tfinal int version = payload[0];\n\n\t\tif(logMINOR) {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tlong last = pn.lastSentPacketTime();\n\t\t\tString delta = \"never\";\n\t\t\tif (last>0) {\n\t\t\t\tdelta = TimeUtil.formatTime(now-last, 2, true)+\" ago\";\n\t\t\t}\n\t\t\tLogger.minor(this, \"Received auth packet for \"+pn.getPeer()+\" (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\") (last packet sent \"+delta+\") from \"+replyTo+\"\");\n\t\t}\n\n\t\t/* Format:\n\t\t * 1 byte - version number (1)\n\t\t * 1 byte - negotiation type (0 = simple DH, will not be supported when implement JFKi || 1 = StS)\n\t\t * 1 byte - packet type (0-3)\n\t\t */\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType >= 0 && negType < 6) {\n\t\t\t// negType 0 through 5 no longer supported, used old FNP.\n\t\t\tLogger.warning(this, \"Old neg type \"+negType+\" not supported\");\n\t\t\treturn;\n\t\t} else if (negType == 6 || negType == 7 || negType == 8) {\n\t\t    // negType == 8 => use ECDH with secp256r1 instead of DH\n\t\t\t// negType == 7 => same as 6, but determine the initial sequence number by hashing the identity\n\t\t\t// instead of negotiating it\n\t\t\t/*\n\t\t\t * We implement Just Fast Keying key management protocol with active identity protection\n\t\t\t * for the initiator and no identity protection for the responder\n\t\t\t * M1:\n\t\t\t * This is a straightforward DiffieHellman exponential.\n\t\t\t * The Initiator Nonce serves two purposes;it allows the initiator to use the same\n\t\t\t * exponentials during different sessions while ensuring that the resulting session\n\t\t\t * key will be different,can be used to differentiate between parallel sessions\n\t\t\t * M2:\n\t\t\t * Responder replies with a signed copy of his own exponential, a random nonce and\n\t\t\t * an authenticator which provides sufficient defense against forgeries,replays\n\t\t\t * We slightly deviate JFK here;we do not send any public key information as specified in the JFK docs\n\t\t\t * M3:\n\t\t\t * Initiator echoes the data sent by the responder including the authenticator.\n\t\t\t * This helps the responder verify the authenticity of the returned data.\n\t\t\t * M4:\n\t\t\t * Encrypted message of the signature on both nonces, both exponentials using the same keys as in the previous message\n\t\t\t */\n\t\t\tif(packetType<0 || packetType>3) {\n\t\t\t\tLogger.error(this,\"Unknown PacketType\" + packetType + \"from\" + replyTo + \"from\" +pn);\n\t\t\t\treturn ;\n\t\t\t} else authHandlingThread.execute(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif(packetType==0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Initiator- This is a straightforward DiffieHellman exponential.\n\t\t\t\t\t\t * The Initiator Nonce serves two purposes;it allows the initiator to use the same\n\t\t\t\t\t\t * exponentials during different sessions while ensuring that the resulting\n\t\t\t\t\t\t * session key will be different,can be used to differentiate between\n\t\t\t\t\t\t * parallel sessions\n\t\t\t\t\t\t */\n\t\t\t\t\t\tprocessJFKMessage1(payload,3,pn,replyTo,false,-1,negType);\n\n\t\t\t\t\t} else if(packetType==1) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Responder replies with a signed copy of his own exponential, a random\n\t\t\t\t\t\t * nonce and an authenticator calculated from a transient hash key private\n\t\t\t\t\t\t * to the responder.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tprocessJFKMessage2(payload,3,pn,replyTo,false,-1,negType);\n\t\t\t\t\t} else if(packetType==2) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Initiator echoes the data sent by the responder.These messages are\n\t\t\t\t\t\t * cached by the Responder.Receiving a duplicate message simply causes\n\t\t\t\t\t\t * the responder to Re-transmit the corresponding message4\n\t\t\t\t\t\t */\n\t\t\t\t\t\tprocessJFKMessage3(payload, 3, pn, replyTo, oldOpennetPeer, false, -1, negType);\n\t\t\t\t\t} else if(packetType==3) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Encrypted message of the signature on both nonces, both exponentials\n\t\t\t\t\t\t * using the same keys as in the previous message.\n\t\t\t\t\t\t * The signature is non-message recovering\n\t\t\t\t\t\t */\n\t\t\t\t\t\tprocessJFKMessage4(payload, 3, pn, replyTo, oldOpennetPeer, false, -1, negType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tLogger.error(this, \"Decrypted auth packet but unknown negotiation type \"+negType+\" from \"+replyTo+\" possibly from \"+pn);\n\t\t\treturn;\n\t\t}\n\t}","id":43049,"modified_method":"/**\n\t * Process a decrypted, authenticated auth packet.\n\t * @param payload The packet payload, after it has been decrypted.\n\t */\n\tprivate void processDecryptedAuth(final byte[] payload, final PeerNode pn, final Peer replyTo, final boolean oldOpennetPeer) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" for \"+pn);\n\t\tif(pn.isDisabled()) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Won't connect to a disabled peer (\"+pn+ ')');\n\t\t\treturn;  // We don't connect to disabled peers\n\t\t}\n\n\t\tfinal int negType = payload[1];\n\t\tfinal int packetType = payload[2];\n\t\tfinal int version = payload[0];\n\n\t\tif(logMINOR) {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tlong last = pn.lastSentPacketTime();\n\t\t\tString delta = \"never\";\n\t\t\tif (last>0) {\n\t\t\t\tdelta = TimeUtil.formatTime(now-last, 2, true)+\" ago\";\n\t\t\t}\n\t\t\tLogger.minor(this, \"Received auth packet for \"+pn.getPeer()+\" (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\") (last packet sent \"+delta+\") from \"+replyTo+\"\");\n\t\t}\n\n\t\t/* Format:\n\t\t * 1 byte - version number (1)\n\t\t * 1 byte - negotiation type (0 = simple DH, will not be supported when implement JFKi || 1 = StS)\n\t\t * 1 byte - packet type (0-3)\n\t\t */\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType >= 0 && negType < 6) {\n\t\t\t// negType 0 through 5 no longer supported, used old FNP.\n\t\t\tLogger.warning(this, \"Old neg type \"+negType+\" not supported\");\n\t\t\treturn;\n\t\t} else if (negType == 6 || negType == 7 || negType == 8 || negType == 9) {\n\t\t    // negType == 9 => use ECDSA with P256 instead of DSA2048\n\t\t    // negType == 8 => use ECDH with P256 instead of DH1024\n\t\t\t// negType == 7 => same as 6, but determine the initial sequence number by hashing the identity\n\t\t\t// instead of negotiating it\n\t\t\t/*\n\t\t\t * We implement Just Fast Keying key management protocol with active identity protection\n\t\t\t * for the initiator and no identity protection for the responder\n\t\t\t * M1:\n\t\t\t * This is a straightforward DiffieHellman exponential.\n\t\t\t * The Initiator Nonce serves two purposes;it allows the initiator to use the same\n\t\t\t * exponentials during different sessions while ensuring that the resulting session\n\t\t\t * key will be different,can be used to differentiate between parallel sessions\n\t\t\t * M2:\n\t\t\t * Responder replies with a signed copy of his own exponential, a random nonce and\n\t\t\t * an authenticator which provides sufficient defense against forgeries,replays\n\t\t\t * We slightly deviate JFK here;we do not send any public key information as specified in the JFK docs\n\t\t\t * M3:\n\t\t\t * Initiator echoes the data sent by the responder including the authenticator.\n\t\t\t * This helps the responder verify the authenticity of the returned data.\n\t\t\t * M4:\n\t\t\t * Encrypted message of the signature on both nonces, both exponentials using the same keys as in the previous message\n\t\t\t */\n\t\t\tif(packetType<0 || packetType>3) {\n\t\t\t\tLogger.error(this,\"Unknown PacketType\" + packetType + \"from\" + replyTo + \"from\" +pn);\n\t\t\t\treturn ;\n\t\t\t} else authHandlingThread.execute(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif(packetType==0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Initiator- This is a straightforward DiffieHellman exponential.\n\t\t\t\t\t\t * The Initiator Nonce serves two purposes;it allows the initiator to use the same\n\t\t\t\t\t\t * exponentials during different sessions while ensuring that the resulting\n\t\t\t\t\t\t * session key will be different,can be used to differentiate between\n\t\t\t\t\t\t * parallel sessions\n\t\t\t\t\t\t */\n\t\t\t\t\t\tprocessJFKMessage1(payload,3,pn,replyTo,false,-1,negType);\n\n\t\t\t\t\t} else if(packetType==1) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Responder replies with a signed copy of his own exponential, a random\n\t\t\t\t\t\t * nonce and an authenticator calculated from a transient hash key private\n\t\t\t\t\t\t * to the responder.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tprocessJFKMessage2(payload,3,pn,replyTo,false,-1,negType);\n\t\t\t\t\t} else if(packetType==2) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Initiator echoes the data sent by the responder.These messages are\n\t\t\t\t\t\t * cached by the Responder.Receiving a duplicate message simply causes\n\t\t\t\t\t\t * the responder to Re-transmit the corresponding message4\n\t\t\t\t\t\t */\n\t\t\t\t\t\tprocessJFKMessage3(payload, 3, pn, replyTo, oldOpennetPeer, false, -1, negType);\n\t\t\t\t\t} else if(packetType==3) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Encrypted message of the signature on both nonces, both exponentials\n\t\t\t\t\t\t * using the same keys as in the previous message.\n\t\t\t\t\t\t * The signature is non-message recovering\n\t\t\t\t\t\t */\n\t\t\t\t\t\tprocessJFKMessage4(payload, 3, pn, replyTo, oldOpennetPeer, false, -1, negType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tLogger.error(this, \"Decrypted auth packet but unknown negotiation type \"+negType+\" from \"+replyTo+\" possibly from \"+pn);\n\t\t\treturn;\n\t\t}\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Process an anonymous-initiator connection setup packet. For a normal setup\n\t * (@see processDecryptedAuth()), we know the node that is trying to contact us.\n\t * But in this case, we don't know the node yet, and we are doing a\n\t * special-purpose connection setup. At the moment the only type supported is\n\t * for a new node connecting to a seednode in order to announce. In future,\n\t * nodes may support other anonymous-initiator connection types such as when a\n\t * node (which is certain of its connectivity) issues one-time invites which\n\t * allow a new node to connect to it.\n\t * @param payload The decrypted payload of the packet.\n\t * @param replyTo The address the packet came in from.\n\t */\n\tprivate void processDecryptedAuthAnon(final byte[] payload, final Peer replyTo) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" length \"+payload.length);\n\n\t\t/** Protocol version. Should be 1. */\n\t\tfinal int version = payload[0];\n\t\t/** Negotiation type. Common to anonymous-initiator auth and normal setup.\n\t\t *   2 = JFK.\n\t\t *   3 = JFK, reuse PacketTracker\n\t\t * Other types might indicate other DH variants, or even non-DH-based\n\t\t * algorithms such as password based key setup. */\n\t\tfinal int negType = payload[1];\n\t\t/** Packet phase. */\n\t\tfinal int packetType = payload[2];\n\t\t/** Setup type. This is specific to anonymous-initiator setup, and specifies the\n\t\t * purpose of the connection. At the moment it is SETUP_OPENNET_SEEDNODE to indicate\n\t\t * we are connecting to a seednode (which doesn't know us). Invites might require\n\t\t * a different setupType. */\n\t\tfinal int setupType = payload[3];\n\n\t\tif(logMINOR) Logger.minor(this, \"Received anonymous auth packet (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\", setup type=\"+setupType+\") from \"+replyTo+\"\");\n\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\t\tif(!(negType == 6 || negType == 7 || negType == 8)) {\n\t\t\tif(negType > 8)\n\t\t\t\tLogger.error(this, \"Unknown neg type: \"+negType);\n\t\t\telse\n\t\t\t\tLogger.warning(this, \"Received a setup packet with unsupported obsolete neg type: \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// Known setup types\n\t\tif(setupType != SETUP_OPENNET_SEEDNODE) {\n\t\t\tLogger.error(this, \"Unknown setup type \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// We are the RESPONDER.\n\t\t// Therefore, we can only get packets of phase 1 and 3 here.\n\n\t\tif(packetType == 0 || packetType == 2) {\n\t\t\tthis.authHandlingThread.execute(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif(packetType == 0) {\n\t\t\t\t\t\t// Phase 1\n\t\t\t\t\t\tprocessJFKMessage1(payload,4,null,replyTo, true, setupType, negType);\n\t\t\t\t\t} else if(packetType == 2) {\n\t\t\t\t\t\t// Phase 3\n\t\t\t\t\t\tprocessJFKMessage3(payload, 4, null, replyTo, false, true, setupType, negType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t} else {\n\t\t\tLogger.error(this, \"Invalid phase \"+packetType+\" for anonymous-initiator (we are the responder) from \"+replyTo);\n\t\t}\n\t\t\n\t}","id":43050,"modified_method":"/**\n\t * Process an anonymous-initiator connection setup packet. For a normal setup\n\t * (@see processDecryptedAuth()), we know the node that is trying to contact us.\n\t * But in this case, we don't know the node yet, and we are doing a\n\t * special-purpose connection setup. At the moment the only type supported is\n\t * for a new node connecting to a seednode in order to announce. In future,\n\t * nodes may support other anonymous-initiator connection types such as when a\n\t * node (which is certain of its connectivity) issues one-time invites which\n\t * allow a new node to connect to it.\n\t * @param payload The decrypted payload of the packet.\n\t * @param replyTo The address the packet came in from.\n\t */\n\tprivate void processDecryptedAuthAnon(final byte[] payload, final Peer replyTo) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" length \"+payload.length);\n\n\t\t/** Protocol version. Should be 1. */\n\t\tfinal int version = payload[0];\n\t\t/** Negotiation type. Common to anonymous-initiator auth and normal setup.\n\t\t *   2 = JFK.\n\t\t *   3 = JFK, reuse PacketTracker\n\t\t * Other types might indicate other DH variants, or even non-DH-based\n\t\t * algorithms such as password based key setup. */\n\t\tfinal int negType = payload[1];\n\t\t/** Packet phase. */\n\t\tfinal int packetType = payload[2];\n\t\t/** Setup type. This is specific to anonymous-initiator setup, and specifies the\n\t\t * purpose of the connection. At the moment it is SETUP_OPENNET_SEEDNODE to indicate\n\t\t * we are connecting to a seednode (which doesn't know us). Invites might require\n\t\t * a different setupType. */\n\t\tfinal int setupType = payload[3];\n\n\t\tif(logMINOR) Logger.minor(this, \"Received anonymous auth packet (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\", setup type=\"+setupType+\") from \"+replyTo+\"\");\n\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\t\tif(!(negType == 6 || negType == 7 || negType == 8 || negType == 9)) {\n\t\t\tif(negType > 8)\n\t\t\t\tLogger.error(this, \"Unknown neg type: \"+negType);\n\t\t\telse\n\t\t\t\tLogger.warning(this, \"Received a setup packet with unsupported obsolete neg type: \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// Known setup types\n\t\tif(setupType != SETUP_OPENNET_SEEDNODE) {\n\t\t\tLogger.error(this, \"Unknown setup type \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// We are the RESPONDER.\n\t\t// Therefore, we can only get packets of phase 1 and 3 here.\n\n\t\tif(packetType == 0 || packetType == 2) {\n\t\t\tthis.authHandlingThread.execute(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif(packetType == 0) {\n\t\t\t\t\t\t// Phase 1\n\t\t\t\t\t\tprocessJFKMessage1(payload,4,null,replyTo, true, setupType, negType);\n\t\t\t\t\t} else if(packetType == 2) {\n\t\t\t\t\t\t// Phase 3\n\t\t\t\t\t\tprocessJFKMessage3(payload, 4, null, replyTo, false, true, setupType, negType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t} else {\n\t\t\tLogger.error(this, \"Invalid phase \"+packetType+\" for anonymous-initiator (we are the responder) from \"+replyTo);\n\t\t}\n\t\t\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage2(byte[] nonceInitator, byte[] hisExponential, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) throws NoContextsException {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(2) message to \"+pn);\n\t\tint modulusLength = getModulusLength(negType);\n\n\t\t// g^r\n\t\tKeyAgreementSchemeContext ctx = (negType < 8 ? getLightDiffieHellmanContext() : getECDHLightContext());\n\t    DSASignature sig = ctx.signature;\n\t\t    \n\t\t// Nr\n\t\tbyte[] myNonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(myNonce);\n\t    byte[] myExponential = ctx.getPublicKeyNetworkFormat();\n\t\tbyte[] r = sig.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = sig.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] authenticator = HMAC.macWithSHA256(getTransientKey(),assembleJFKAuthenticator(myExponential, hisExponential, myNonce, nonceInitator, replyTo.getAddress().getAddress()), HASH_LENGTH);\n\t\tif(logMINOR) Logger.minor(this, \"We are using the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\n\t\tbyte[] message2 = new byte[NONCE_SIZE*2+modulusLength+\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH*2+\n\t\t                           HASH_LENGTH];\n\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nonceInitator, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myNonce, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message2, offset, modulusLength);\n\t\toffset += modulusLength;\n\n\t\tSystem.arraycopy(r, 0, message2, offset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\toffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, message2, offset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\toffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tSystem.arraycopy(authenticator, 0, message2, offset, HASH_LENGTH);\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1,negType,1,setupType,message2,pn,replyTo,crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,1,message2,pn,replyTo);\n\t\t}\n\t}","id":43051,"modified_method":"private void sendJFKMessage2(byte[] nonceInitator, byte[] hisExponential, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) throws NoContextsException {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(2) message to \"+pn);\n\t\tint modulusLength = getModulusLength(negType);\n\n\t\t// g^r\n\t    DiffieHellmanLightContext dhLctx = getLightDiffieHellmanContext();\n\t    ECDHLightContext ecdhLctx = getECDHLightContext();\n\t\t    \n\t\t// Nr\n\t\tbyte[] myNonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(myNonce);\n\t    byte[] myExponential = (negType < 8 ? dhLctx : ecdhLctx).getPublicKeyNetworkFormat();\n\t    byte[] sig = (negType < 9 ? dhLctx.dsaSig : ecdhLctx.ecdsaSig);\n\t    if(sig.length != getSignatureLength(negType))\n\t        throw new IllegalStateException(\"This shouldn't happen: please report! We are attempting to send \"+sig.length+\" bytes of signature in JFK2! \"+pn.getPeer());\n\t    byte[] authenticator = HMAC.macWithSHA256(getTransientKey(),assembleJFKAuthenticator(myExponential, hisExponential, myNonce, nonceInitator, replyTo.getAddress().getAddress()), HASH_LENGTH);\n\t\tif(logMINOR) Logger.minor(this, \"We are using the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\t\tbyte[] message2 = new byte[NONCE_SIZE*2+modulusLength+\n\t\t                           sig.length+\n\t\t                           HASH_LENGTH];\n\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nonceInitator, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myNonce, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message2, offset, modulusLength);\n\t\toffset += modulusLength;\n\n\t    System.arraycopy(sig, 0, message2, offset, sig.length);\n\t    offset += sig.length;\n\t\t\n\t\tSystem.arraycopy(authenticator, 0, message2, offset, HASH_LENGTH);\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1,negType,1,setupType,message2,pn,replyTo,crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,1,message2,pn,replyTo);\n\t\t}\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"/** Sign a hash */\n\tDSASignature sign(byte[] hash) {\n\t\treturn DSA.sign(cryptoGroup, privKey, new NativeBigInteger(1, hash), random);\n\t}","id":43052,"modified_method":"/** Sign a hash */\n\tbyte[] sign(byte[] hash) {\n        byte[] sig = new byte[Node.SIGNATURE_PARAMETER_LENGTH*2];\n        DSASignature s = DSA.sign(cryptoGroup, privKey, new NativeBigInteger(1, hash), random);\n        System.arraycopy(s.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH), 0, sig, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n        System.arraycopy(s.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH), 0, sig, Node.SIGNATURE_PARAMETER_LENGTH, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\treturn sig;\n\t}","commit_id":"e833eb4f3790f498816857504508bc299e115f63","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * @return The length in bytes of the modulus. Exponentials will fit into\n\t * this length.\n\t */\n\tpublic static int modulusLengthInBytes() {\n\t\tint bitLength = getGroup().getP().bitLength();\n\t\treturn (bitLength/8) + ((bitLength % 8) > 0 ? 1 : 0);\n\t}","id":43053,"modified_method":"/**\n\t * @return The length in bytes of the modulus. Exponentials will fit into\n\t * this length.\n\t */\n\tpublic static int modulusLengthInBytes() {\n\t    DHGroup g = getGroup();\n\t    if(g == Global.DHgroupA)\n\t        return 128;\n\t\tint bitLength = g.getP().bitLength();\n\t\treturn (bitLength/8) + ((bitLength % 8) > 0 ? 1 : 0);\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Create a DiffieHellmanLightContext.\n\t */\n\tpublic static DiffieHellmanLightContext generateLightContext() {\n\t\tlong time1 = System.currentTimeMillis();\n\t\tNativeBigInteger[] params = getParams();\n\t\tlong time2 = System.currentTimeMillis();\n\t\tif((time2 - time1) > 300) {\n\t\t\tLogger.error(null, \"DiffieHellman.generateLightContext(): time2 is more than 300ms after time1 (\"+(time2 - time1)+ ')');\n\t\t}\n\t\treturn new DiffieHellmanLightContext(params[0], params[1]);\n\t}","id":43054,"modified_method":"/**\n\t * Create a DiffieHellmanLightContext.\n\t */\n\tpublic static DiffieHellmanLightContext generateLightContext(DHGroup group) {\n\t\tlong time1 = System.currentTimeMillis();\n\t\tNativeBigInteger[] params = getParams();\n\t\tlong time2 = System.currentTimeMillis();\n\t\tif((time2 - time1) > 300) {\n\t\t\tLogger.error(null, \"DiffieHellman.generateLightContext(): time2 is more than 300ms after time1 (\"+(time2 - time1)+ ')');\n\t\t}\n\t\treturn new DiffieHellmanLightContext(group, params[0], params[1]);\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"public NativeBigInteger getHMACKey(NativeBigInteger peerExponential, DHGroup group) {\n\t\tlastUsedTime = System.currentTimeMillis();\n\t\tBigInteger P = group.getP();\n\t\tNativeBigInteger sharedSecret =\n\t\t\t(NativeBigInteger) peerExponential.modPow(myExponent, P);\n\n\t\tif(logMINOR) {\n\t\t\tLogger.minor(this, \"P: \"+HexUtil.biToHex(P));\n\t\t\tLogger.minor(this, \"My exponent: \"+HexUtil.toHexString(myExponent));\n\t\t\tLogger.minor(this, \"My exponential: \"+HexUtil.toHexString(myExponential));\n\t\t\tLogger.minor(this, \"Peer's exponential: \"+HexUtil.toHexString(peerExponential));\n\t\t\tLogger.minor(this, \"g^ir mod p = \" + HexUtil.toHexString(sharedSecret));\n\t\t}\n\t\t\n\t\treturn sharedSecret;\n\t}","id":43055,"modified_method":"public byte[] getHMACKey(NativeBigInteger peerExponential) {\n\t\tlastUsedTime = System.currentTimeMillis();\n\t\tBigInteger P = group.getP();\n\t\tNativeBigInteger sharedSecret =\n\t\t\t(NativeBigInteger) peerExponential.modPow(myExponent, P);\n\n\t\tif(logMINOR) {\n\t\t\tLogger.minor(this, \"P: \"+HexUtil.biToHex(P));\n\t\t\tLogger.minor(this, \"My exponent: \"+HexUtil.toHexString(myExponent));\n\t\t\tLogger.minor(this, \"My exponential: \"+HexUtil.toHexString(myExponential));\n\t\t\tLogger.minor(this, \"Peer's exponential: \"+HexUtil.toHexString(peerExponential));\n\t\t\tLogger.minor(this, \"g^ir mod p = \" + HexUtil.toHexString(sharedSecret));\n\t\t}\n\t\t\n\t\treturn sharedSecret.toByteArray();\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"public DiffieHellmanLightContext(NativeBigInteger myExponent, NativeBigInteger myExponential) {\n\t\tthis.myExponent = myExponent;\n\t\tthis.myExponential = myExponential;\n\t\tthis.lastUsedTime = System.currentTimeMillis();\n\t\tthis.logMINOR = Logger.shouldLog(LogLevel.MINOR, this);\n\t}","id":43056,"modified_method":"public DiffieHellmanLightContext(DHGroup group, NativeBigInteger myExponent, NativeBigInteger myExponential) {\n\t\tthis.myExponent = myExponent;\n\t\tthis.myExponential = myExponential;\n        this.group = group;\n\t\tthis.lastUsedTime = System.currentTimeMillis();\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void _fillJFKDHFIFOOffThread() {\n\t\t// do it off-thread\n\t\tnode.executor.execute(new PrioRunnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t_fillJFKDHFIFO();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int getPriority() {\n\t\t\t\treturn NativeThread.HIGH_PRIORITY;\n\t\t\t}\n\t\t}, \"DiffieHellman exponential signing\");\n\t}","id":43057,"modified_method":"private void _fillJFKDHFIFOOffThread() {\n\t\t// do it off-thread\n\t\tnode.executor.execute(new PrioRunnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t_fillJFKDHFIFO();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int getPriority() {\n\t\t\t\treturn NativeThread.MIN_PRIORITY;\n\t\t\t}\n\t\t}, \"DiffieHellman exponential signing\");\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private byte[] assembleDHParams(BigInteger exponential, DSAGroup group) {\n\t\tbyte[] _myExponential = stripBigIntegerToNetworkFormat(exponential);\n\t\tbyte[] _myGroup = group.getP().toByteArray();\n\t\tbyte[] toSign = new byte[_myExponential.length + _myGroup.length];\n\n\t\tSystem.arraycopy(_myExponential, 0, toSign, 0, _myExponential.length);\n\t\tSystem.arraycopy(_myGroup, 0, toSign, _myExponential.length, _myGroup.length);\n\n\t\treturn toSign;\n\t}","id":43058,"modified_method":"private byte[] assembleDHParams(byte[] exponential, DSAGroup group) {\n\t\tbyte[] _myGroup = group.getP().toByteArray();\n\t\tbyte[] toSign = new byte[exponential.length + _myGroup.length];\n\n\t\tSystem.arraycopy(exponential, 0, toSign, 0, exponential.length);\n\t\tSystem.arraycopy(_myGroup, 0, toSign, exponential.length, _myGroup.length);\n\n\t\treturn toSign;\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void processDecryptedAuthAnonReply(byte[] payload, Peer replyTo, PeerNode pn) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" for \"+pn+\" length \"+payload.length);\n\n\t\t/** Protocol version. Should be 1. */\n\t\tint version = payload[0];\n\t\t/** Negotiation type.\n\t\t *   2 = JFK.\n\t\t *   3 = JFK, reuse PacketTracker\n\t\t * Other types might indicate other DH variants, or even non-DH-based\n\t\t * algorithms such as password based key setup. */\n\t\tint negType = payload[1];\n\t\t/** Packet phase. */\n\t\tint packetType = payload[2];\n\t\t/** Setup type. See above. */\n\t\tint setupType = payload[3];\n\n\t\tif(logMINOR) Logger.minor(this, \"Received anonymous auth packet (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\", setup type=\"+setupType+\") from \"+replyTo+\"\");\n\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\t\tif(!(negType == 6 || negType == 7)) {\n\t\t\tif(negType > 7)\n\t\t\t\tLogger.error(this, \"Unknown neg type: \"+negType);\n\t\t\telse\n\t\t\t\tLogger.warning(this, \"Received a setup packet with unsupported obsolete neg type: \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// Known setup types\n\t\tif(setupType != SETUP_OPENNET_SEEDNODE) {\n\t\t\tLogger.error(this, \"Unknown setup type \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// We are the INITIATOR.\n\t\t// Therefore, we can only get packets of phase 2 and 4 here.\n\n\t\tif(packetType == 1) {\n\t\t\t// Phase 2\n\t\t\tprocessJFKMessage2(payload, 4, pn, replyTo, true, setupType, negType);\n\t\t} else if(packetType == 3) {\n\t\t\t// Phase 4\n\t\t\tprocessJFKMessage4(payload, 4, pn, replyTo, false, true, setupType, negType);\n\t\t} else {\n\t\t\tLogger.error(this, \"Invalid phase \"+packetType+\" for anonymous-initiator (we are the initiator) from \"+replyTo);\n\t\t}\n\t}","id":43059,"modified_method":"private void processDecryptedAuthAnonReply(byte[] payload, Peer replyTo, PeerNode pn) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" for \"+pn+\" length \"+payload.length);\n\n\t\t/** Protocol version. Should be 1. */\n\t\tint version = payload[0];\n\t\t/** Negotiation type.\n\t\t *   2 = JFK.\n\t\t *   3 = JFK, reuse PacketTracker\n\t\t * Other types might indicate other DH variants, or even non-DH-based\n\t\t * algorithms such as password based key setup. */\n\t\tint negType = payload[1];\n\t\t/** Packet phase. */\n\t\tint packetType = payload[2];\n\t\t/** Setup type. See above. */\n\t\tint setupType = payload[3];\n\n\t\tif(logMINOR) Logger.minor(this, \"Received anonymous auth packet (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\", setup type=\"+setupType+\") from \"+replyTo+\"\");\n\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\t\tif(!(negType == 6 || negType == 7 || negType == 8)) {\n\t\t\tif(negType > 8)\n\t\t\t\tLogger.error(this, \"Unknown neg type: \"+negType);\n\t\t\telse\n\t\t\t\tLogger.warning(this, \"Received a setup packet with unsupported obsolete neg type: \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// Known setup types\n\t\tif(setupType != SETUP_OPENNET_SEEDNODE) {\n\t\t\tLogger.error(this, \"Unknown setup type \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// We are the INITIATOR.\n\t\t// Therefore, we can only get packets of phase 2 and 4 here.\n\n\t\tif(packetType == 1) {\n\t\t\t// Phase 2\n\t\t\tprocessJFKMessage2(payload, 4, pn, replyTo, true, setupType, negType);\n\t\t} else if(packetType == 3) {\n\t\t\t// Phase 4\n\t\t\tprocessJFKMessage4(payload, 4, pn, replyTo, false, true, setupType, negType);\n\t\t} else {\n\t\t\tLogger.error(this, \"Invalid phase \"+packetType+\" for anonymous-initiator (we are the initiator) from \"+replyTo);\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic int[] supportedNegTypes(boolean forPublic) {\n\t\tif(forPublic)\n\t\t\treturn new int[] { 6, 7 };\n\t\telse\n\t\t\treturn new int[] { 6, 7 };\n\t}","id":43060,"modified_method":"@Override\n\tpublic int[] supportedNegTypes(boolean forPublic) {\n\t\tif(forPublic)\n\t\t\treturn new int[] { 6, 7, 8 };\n\t\telse\n\t\t\treturn new int[] { 7, 8 };\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage4(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential,byte[] responderExponential, BlockCipher c, byte[] Ke, byte[] Ka, byte[] authenticator, byte[] hisRef, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, long newTrackerID, boolean sameAsOldTrackerID)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn.getPeer());\n\t\tlong t1=System.currentTimeMillis();\n\t\tNativeBigInteger _responderExponential = new NativeBigInteger(1,responderExponential);\n\t\tNativeBigInteger _initiatorExponential = new NativeBigInteger(1,initiatorExponential);\n\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[9 + 8 + myRef.length + hisRef.length];\n\t\tint ptr = 0;\n\t\tSystem.arraycopy(Fields.longToBytes(newTrackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tdata[ptr++] = (byte) (sameAsOldTrackerID ? 1 : 0);\n\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(myRef, 0, data, ptr, myRef.length);\n\t\tptr += myRef.length;\n\t\tSystem.arraycopy(hisRef, 0, data, ptr, hisRef.length);\n\n\t\tbyte[] params = assembleDHParams(nonceInitiator, nonceResponder, _initiatorExponential, _responderExponential, pn.identity, data);\n\t\tbyte[] messageHash = SHA256.digest(params);\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Message hash: \"+HexUtil.bytesToHex(messageHash)+\" length \"+params.length+\" myRef: \"+myRef.length+\" hash \"+Fields.hashCode(myRef)+\" hisRef: \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" boot ID \"+node.bootID);\n\t\tDSASignature localSignature = crypto.sign(messageHash);\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pk=PCFBMode.create(c, iv);\n\t\t// Don't include the last bit\n\t\tint dataLength = data.length - hisRef.length;\n\t\tbyte[] cyphertext = new byte[JFK_PREFIX_RESPONDER.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 +\n\t\t                             dataLength];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, cyphertext, cleartextOffset, JFK_PREFIX_RESPONDER.length);\n\t\tcleartextOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(iv, 0, cyphertext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cyphertext, cleartextOffset, dataLength);\n\t\tcleartextOffset += dataLength;\n\t\t// Now encrypt the cleartext[Signature]\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_RESPONDER.length + ivLength;\n\t\tpk.blockEncipher(cyphertext, cleartextToEncypherOffset, cyphertext.length - cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + iv + signature)\n\t\tbyte[] hmac = HMAC.macWithSHA256(Ka, cyphertext, HASH_LENGTH);\n\n\t\t// Message4 = hmac + IV + encryptedSignature\n\t\tbyte[] message4 = new byte[HASH_LENGTH + ivLength + (cyphertext.length - cleartextToEncypherOffset)];\n\t\tint offset = 0;\n\t\tSystem.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cyphertext, cleartextToEncypherOffset, message4, offset, cyphertext.length - cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator), message4);\n\t\t\tif(logDEBUG) Logger.debug(this, \"Storing JFK(4) for \"+HexUtil.bytesToHex(authenticator));\n\t\t}\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 3, setupType, message4, pn, replyTo, crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 3, message4, pn, replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Sending packet for \"+pn.getPeer());\n\t}","id":43061,"modified_method":"private void sendJFKMessage4(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential,byte[] responderExponential, BlockCipher c, byte[] Ke, byte[] Ka, byte[] authenticator, byte[] hisRef, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, long newTrackerID, boolean sameAsOldTrackerID)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn.getPeer());\n\t\tlong t1=System.currentTimeMillis();\n\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[9 + 8 + myRef.length + hisRef.length];\n\t\tint ptr = 0;\n\t\tSystem.arraycopy(Fields.longToBytes(newTrackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tdata[ptr++] = (byte) (sameAsOldTrackerID ? 1 : 0);\n\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(myRef, 0, data, ptr, myRef.length);\n\t\tptr += myRef.length;\n\t\tSystem.arraycopy(hisRef, 0, data, ptr, hisRef.length);\n\n\t\tbyte[] params = assembleDHParams(nonceInitiator, nonceResponder, initiatorExponential, responderExponential, pn.identity, data);\n\t\tbyte[] messageHash = SHA256.digest(params);\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Message hash: \"+HexUtil.bytesToHex(messageHash)+\" length \"+params.length+\" myRef: \"+myRef.length+\" hash \"+Fields.hashCode(myRef)+\" hisRef: \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" boot ID \"+node.bootID);\n\t\tDSASignature localSignature = crypto.sign(messageHash);\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pk=PCFBMode.create(c, iv);\n\t\t// Don't include the last bit\n\t\tint dataLength = data.length - hisRef.length;\n\t\tbyte[] cyphertext = new byte[JFK_PREFIX_RESPONDER.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 +\n\t\t                             dataLength];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, cyphertext, cleartextOffset, JFK_PREFIX_RESPONDER.length);\n\t\tcleartextOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(iv, 0, cyphertext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cyphertext, cleartextOffset, dataLength);\n\t\tcleartextOffset += dataLength;\n\t\t// Now encrypt the cleartext[Signature]\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_RESPONDER.length + ivLength;\n\t\tpk.blockEncipher(cyphertext, cleartextToEncypherOffset, cyphertext.length - cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + iv + signature)\n\t\tbyte[] hmac = HMAC.macWithSHA256(Ka, cyphertext, HASH_LENGTH);\n\n\t\t// Message4 = hmac + IV + encryptedSignature\n\t\tbyte[] message4 = new byte[HASH_LENGTH + ivLength + (cyphertext.length - cleartextToEncypherOffset)];\n\t\tint offset = 0;\n\t\tSystem.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cyphertext, cleartextToEncypherOffset, message4, offset, cyphertext.length - cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator), message4);\n\t\t\tif(logDEBUG) Logger.debug(this, \"Storing JFK(4) for \"+HexUtil.bytesToHex(authenticator));\n\t\t}\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 3, setupType, message4, pn, replyTo, crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 3, message4, pn, replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Sending packet for \"+pn.getPeer());\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private byte[] assembleDHParams(byte[] nonceInitiator,byte[] nonceResponder,BigInteger initiatorExponential, BigInteger responderExponential, byte[] id, byte[] sa) {\n\t\tbyte[] _initiatorExponential = stripBigIntegerToNetworkFormat(initiatorExponential);\n\t\tbyte[] _responderExponential = stripBigIntegerToNetworkFormat(responderExponential);\n\t\tbyte[] result = new byte[nonceInitiator.length + nonceResponder.length + _initiatorExponential.length + _responderExponential.length + id.length + sa.length];\n\t\tint offset = 0;\n\n\t\tSystem.arraycopy(nonceInitiator, 0,result,offset,nonceInitiator.length);\n\t\toffset += nonceInitiator.length;\n\t\tSystem.arraycopy(nonceResponder,0 ,result,offset,nonceResponder.length);\n\t\toffset += nonceResponder.length;\n\t\tSystem.arraycopy(_initiatorExponential, 0, result,offset, _initiatorExponential.length);\n\t\toffset += _initiatorExponential.length;\n\t\tSystem.arraycopy(_responderExponential, 0, result, offset, _responderExponential.length);\n\t\toffset += _responderExponential.length;\n\t\tSystem.arraycopy(id, 0, result , offset,id.length);\n\t\toffset += id.length;\n\t\tSystem.arraycopy(sa, 0, result , offset,sa.length);\n\n\t\treturn result;\n\t}","id":43062,"modified_method":"private byte[] assembleDHParams(byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential, byte[] responderExponential, byte[] id, byte[] sa) {\n\t\tbyte[] result = new byte[nonceInitiator.length + nonceResponder.length + initiatorExponential.length + responderExponential.length + id.length + sa.length];\n\t\tint offset = 0;\n\n\t\tSystem.arraycopy(nonceInitiator, 0,result,offset,nonceInitiator.length);\n\t\toffset += nonceInitiator.length;\n\t\tSystem.arraycopy(nonceResponder,0 ,result,offset,nonceResponder.length);\n\t\toffset += nonceResponder.length;\n\t\tSystem.arraycopy(initiatorExponential, 0, result,offset, initiatorExponential.length);\n\t\toffset += initiatorExponential.length;\n\t\tSystem.arraycopy(responderExponential, 0, result, offset, responderExponential.length);\n\t\toffset += responderExponential.length;\n\t\tSystem.arraycopy(id, 0, result , offset,id.length);\n\t\toffset += id.length;\n\t\tSystem.arraycopy(sa, 0, result , offset,sa.length);\n\n\t\treturn result;\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private boolean processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tif(pn.jfkMyRef == null) {\n\t\t\tString error = \"Got a JFK(4) message but no pn.jfkMyRef for \"+pn;\n\t\t\tif(node.getUptime() < 60*1000) {\n\t\t\t\tLogger.minor(this, error);\n\t\t\t} else {\n\t\t\t\tLogger.error(this, error);\n\t\t\t}\n\t\t}\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tNode.SIGNATURE_PARAMETER_LENGTH * 2 + // the signature\n\t\t\t9 + // ID of packet tracker, plus boolean byte\n\t\t\t8+ // bootID\n\t\t\t1; // znoderefR\n\n\t\tif(payload.length - inputOffset < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn false;\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_RESPONDER.length + (payload.length-inputOffset)];\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_RESPONDER.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tif(!HMAC.verifyWithSHA256(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn false;\n\t\t}\n\n\t\t// Try to find the HMAC in the cache:\n\t\t// If it is already present it indicates duplicate/replayed message4 and we can discard\n\t\t// If it's not, we can add it with a timestamp\n\t\tbyte[] message4Timestamp = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tByteArrayWrapper hmacBAW = new ByteArrayWrapper(hmac);\n\t\t\tmessage4Timestamp = authenticatorCache.get(hmacBAW);\n\t\t\tif(message4Timestamp == null) { // normal behaviour\n\t\t\t\tauthenticatorCache.put(hmacBAW, Fields.longToBytes(t1));\n\t\t\t}\n\t\t}\n\t\tif(message4Timestamp != null) {\n\t\t\tLogger.normal(this, \"We got a replayed message4 (first handled at \"+TimeUtil.formatTime(t1-Fields.bytesToLong(message4Timestamp))+\") from - \"+pn);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the IV\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\tboolean reusedTracker;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\treusedTracker = data[ptr++] != 0;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = new byte[data.length - ptr];\n\t\tSystem.arraycopy(data, ptr, hisRef, 0, hisRef.length);\n\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tint dataLen = hisRef.length + 8 + 9;\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes() * 2 + crypto.myIdentity.length + dataLen + pn.jfkMyRef.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes()*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tbyte[] identity = crypto.getIdentity(unknownInitiator);\n\t\tSystem.arraycopy(identity, 0, locallyGeneratedText, bufferOffset, identity.length);\n\t\tbufferOffset += identity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, dataLen);\n\t\tbufferOffset += dataLen;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t\tbyte[] messageHash = SHA256.digest(locallyGeneratedText);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, messageHash), false)) {\n\t\t\tString error = \"The signature verification has failed!! JFK(4) -\"+pn.getPeer()+\" message hash \"+HexUtil.bytesToHex(messageHash)+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID;\n\t\t\tLogger.error(this, error);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Received a packet\n\t\tpn.receivedPacket(true, false);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\t// We change the key\n\t\tBlockCipher ivCipher = null;\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\ttry {\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t\toutgoingCipher.initialize(pn.outgoingKey);\n\t\tincommingCipher.initialize(pn.incommingKey);\n\t\tivCipher.initialize(pn.ivKey);\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, pn.outgoingKey, incommingCipher,\n\t\t\t\tpn.incommingKey, replyTo, false, negType, trackerID, true, reusedTracker, pn.hmacKey,\n\t\t\t\tivCipher, pn.ivNonce, pn.ourInitialSeqNum, pn.theirInitialSeqNum, pn.ourInitialMsgID,\n\t\t\t\tpn.theirInitialMsgID);\n\t\tif(newTrackerID >= 0) {\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true);\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\n\t\t// cleanup\n\t\t// FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.outgoingKey = null;\n\t\tpn.incommingKey = null;\n\t\tpn.hmacKey = null;\n\t\tpn.ivKey = null;\n\t\tpn.ivNonce = null;\n\t\tpn.ourInitialSeqNum = 0;\n\t\tpn.theirInitialSeqNum = 0;\n\t\tpn.ourInitialMsgID = 0;\n\t\tpn.theirInitialMsgID = 0;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t\treturn true;\n\t}","id":43063,"modified_method":"private boolean processJFKMessage4(byte[] payload, int inputOffset, PeerNode pn, Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn.getPeer());\n\t\tif(pn.jfkMyRef == null) {\n\t\t\tString error = \"Got a JFK(4) message but no pn.jfkMyRef for \"+pn;\n\t\t\tif(node.getUptime() < 60*1000) {\n\t\t\t\tLogger.minor(this, error);\n\t\t\t} else {\n\t\t\t\tLogger.error(this, error);\n\t\t\t}\n\t\t}\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tNode.SIGNATURE_PARAMETER_LENGTH * 2 + // the signature\n\t\t\t9 + // ID of packet tracker, plus boolean byte\n\t\t\t8+ // bootID\n\t\t\t1; // znoderefR\n\n\t\tif(payload.length - inputOffset < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn false;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn false;\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"R\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_RESPONDER.length + (payload.length-inputOffset)];\n\t\tSystem.arraycopy(JFK_PREFIX_RESPONDER, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_RESPONDER.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_RESPONDER.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tif(!HMAC.verifyWithSHA256(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.normal(this, \"The digest-HMAC doesn't match; let's discard the packet - \"+pn.getPeer());\n\t\t\treturn false;\n\t\t}\n\n\t\t// Try to find the HMAC in the cache:\n\t\t// If it is already present it indicates duplicate/replayed message4 and we can discard\n\t\t// If it's not, we can add it with a timestamp\n\t\tbyte[] message4Timestamp = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tByteArrayWrapper hmacBAW = new ByteArrayWrapper(hmac);\n\t\t\tmessage4Timestamp = authenticatorCache.get(hmacBAW);\n\t\t\tif(message4Timestamp == null) { // normal behaviour\n\t\t\t\tauthenticatorCache.put(hmacBAW, Fields.longToBytes(t1));\n\t\t\t}\n\t\t}\n\t\tif(message4Timestamp != null) {\n\t\t\tLogger.normal(this, \"We got a replayed message4 (first handled at \"+TimeUtil.formatTime(t1-Fields.bytesToLong(message4Timestamp))+\") from - \"+pn);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the IV\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\tboolean reusedTracker;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\treusedTracker = data[ptr++] != 0;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = new byte[data.length - ptr];\n\t\tSystem.arraycopy(data, ptr, hisRef, 0, hisRef.length);\n\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tint dataLen = hisRef.length + 8 + 9;\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + modulusLength * 2 + crypto.myIdentity.length + dataLen + pn.jfkMyRef.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + modulusLength*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tbyte[] identity = crypto.getIdentity(unknownInitiator);\n\t\tSystem.arraycopy(identity, 0, locallyGeneratedText, bufferOffset, identity.length);\n\t\tbufferOffset += identity.length;\n\t\t// bootID\n\t\tSystem.arraycopy(data, 0, locallyGeneratedText, bufferOffset, dataLen);\n\t\tbufferOffset += dataLen;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, locallyGeneratedText, bufferOffset, pn.jfkMyRef.length);\n\t\tbyte[] messageHash = SHA256.digest(locallyGeneratedText);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, messageHash), false)) {\n\t\t\tString error = \"The signature verification has failed!! JFK(4) -\"+pn.getPeer()+\" message hash \"+HexUtil.bytesToHex(messageHash)+\" length \"+locallyGeneratedText.length+\" hisRef \"+hisRef.length+\" hash \"+Fields.hashCode(hisRef)+\" myRef \"+pn.jfkMyRef.length+\" hash \"+Fields.hashCode(pn.jfkMyRef)+\" boot ID \"+bootID;\n\t\t\tLogger.error(this, error);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Received a packet\n\t\tpn.receivedPacket(true, false);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\t// We change the key\n\t\tBlockCipher ivCipher = null;\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\ttry {\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t\toutgoingCipher.initialize(pn.outgoingKey);\n\t\tincommingCipher.initialize(pn.incommingKey);\n\t\tivCipher.initialize(pn.ivKey);\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, pn.outgoingKey, incommingCipher,\n\t\t\t\tpn.incommingKey, replyTo, false, negType, trackerID, true, reusedTracker, pn.hmacKey,\n\t\t\t\tivCipher, pn.ivNonce, pn.ourInitialSeqNum, pn.theirInitialSeqNum, pn.ourInitialMsgID,\n\t\t\t\tpn.theirInitialMsgID);\n\t\tif(newTrackerID >= 0) {\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true);\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\n\t\t// cleanup\n\t\t// FIXME: maybe we should copy zeros/garbage into it before leaving it to the GC\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.outgoingKey = null;\n\t\tpn.incommingKey = null;\n\t\tpn.hmacKey = null;\n\t\tpn.ivKey = null;\n\t\tpn.ivNonce = null;\n\t\tpn.ourInitialSeqNum = 0;\n\t\tpn.theirInitialSeqNum = 0;\n\t\tpn.ourInitialMsgID = 0;\n\t\tpn.theirInitialMsgID = 0;\n\t\t// We want to clear it here so that new handshake requests\n\t\t// will be sent with a different DH pair\n\t\tpn.setKeyAgreementSchemeContext(null);\n\t\tsynchronized (pn) {\n\t\t\t// FIXME TRUE MULTI-HOMING: winner-takes-all, kill all other connection attempts since we can't deal with multiple active connections\n\t\t\t// Also avoids leaking\n\t\t\tpn.jfkNoncesSent.clear();\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message4 timeout error:Processing packet from \"+pn.getPeer());\n\t\treturn true;\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Process an anonymous-initiator connection setup packet. For a normal setup\n\t * (@see processDecryptedAuth()), we know the node that is trying to contact us.\n\t * But in this case, we don't know the node yet, and we are doing a\n\t * special-purpose connection setup. At the moment the only type supported is\n\t * for a new node connecting to a seednode in order to announce. In future,\n\t * nodes may support other anonymous-initiator connection types such as when a\n\t * node (which is certain of its connectivity) issues one-time invites which\n\t * allow a new node to connect to it.\n\t * @param payload The decrypted payload of the packet.\n\t * @param replyTo The address the packet came in from.\n\t */\n\tprivate void processDecryptedAuthAnon(byte[] payload, Peer replyTo) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" length \"+payload.length);\n\n\t\t/** Protocol version. Should be 1. */\n\t\tint version = payload[0];\n\t\t/** Negotiation type. Common to anonymous-initiator auth and normal setup.\n\t\t *   2 = JFK.\n\t\t *   3 = JFK, reuse PacketTracker\n\t\t * Other types might indicate other DH variants, or even non-DH-based\n\t\t * algorithms such as password based key setup. */\n\t\tint negType = payload[1];\n\t\t/** Packet phase. */\n\t\tint packetType = payload[2];\n\t\t/** Setup type. This is specific to anonymous-initiator setup, and specifies the\n\t\t * purpose of the connection. At the moment it is SETUP_OPENNET_SEEDNODE to indicate\n\t\t * we are connecting to a seednode (which doesn't know us). Invites might require\n\t\t * a different setupType. */\n\t\tint setupType = payload[3];\n\n\t\tif(logMINOR) Logger.minor(this, \"Received anonymous auth packet (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\", setup type=\"+setupType+\") from \"+replyTo+\"\");\n\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\t\tif(!(negType == 6 || negType == 7)) {\n\t\t\tif(negType > 7)\n\t\t\t\tLogger.error(this, \"Unknown neg type: \"+negType);\n\t\t\telse\n\t\t\t\tLogger.warning(this, \"Received a setup packet with unsupported obsolete neg type: \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// Known setup types\n\t\tif(setupType != SETUP_OPENNET_SEEDNODE) {\n\t\t\tLogger.error(this, \"Unknown setup type \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// We are the RESPONDER.\n\t\t// Therefore, we can only get packets of phase 1 and 3 here.\n\n\t\tif(packetType == 0) {\n\t\t\t// Phase 1\n\t\t\tprocessJFKMessage1(payload,4,null,replyTo, true, setupType, negType);\n\t\t} else if(packetType == 2) {\n\t\t\t// Phase 3\n\t\t\tprocessJFKMessage3(payload, 4, null, replyTo, false, true, setupType, negType);\n\t\t} else {\n\t\t\tLogger.error(this, \"Invalid phase \"+packetType+\" for anonymous-initiator (we are the responder) from \"+replyTo);\n\t\t}\n\t}","id":43064,"modified_method":"/**\n\t * Process an anonymous-initiator connection setup packet. For a normal setup\n\t * (@see processDecryptedAuth()), we know the node that is trying to contact us.\n\t * But in this case, we don't know the node yet, and we are doing a\n\t * special-purpose connection setup. At the moment the only type supported is\n\t * for a new node connecting to a seednode in order to announce. In future,\n\t * nodes may support other anonymous-initiator connection types such as when a\n\t * node (which is certain of its connectivity) issues one-time invites which\n\t * allow a new node to connect to it.\n\t * @param payload The decrypted payload of the packet.\n\t * @param replyTo The address the packet came in from.\n\t */\n\tprivate void processDecryptedAuthAnon(byte[] payload, Peer replyTo) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" length \"+payload.length);\n\n\t\t/** Protocol version. Should be 1. */\n\t\tint version = payload[0];\n\t\t/** Negotiation type. Common to anonymous-initiator auth and normal setup.\n\t\t *   2 = JFK.\n\t\t *   3 = JFK, reuse PacketTracker\n\t\t * Other types might indicate other DH variants, or even non-DH-based\n\t\t * algorithms such as password based key setup. */\n\t\tint negType = payload[1];\n\t\t/** Packet phase. */\n\t\tint packetType = payload[2];\n\t\t/** Setup type. This is specific to anonymous-initiator setup, and specifies the\n\t\t * purpose of the connection. At the moment it is SETUP_OPENNET_SEEDNODE to indicate\n\t\t * we are connecting to a seednode (which doesn't know us). Invites might require\n\t\t * a different setupType. */\n\t\tint setupType = payload[3];\n\n\t\tif(logMINOR) Logger.minor(this, \"Received anonymous auth packet (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\", setup type=\"+setupType+\") from \"+replyTo+\"\");\n\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\t\tif(!(negType == 6 || negType == 7 || negType == 8)) {\n\t\t\tif(negType > 8)\n\t\t\t\tLogger.error(this, \"Unknown neg type: \"+negType);\n\t\t\telse\n\t\t\t\tLogger.warning(this, \"Received a setup packet with unsupported obsolete neg type: \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// Known setup types\n\t\tif(setupType != SETUP_OPENNET_SEEDNODE) {\n\t\t\tLogger.error(this, \"Unknown setup type \"+negType);\n\t\t\treturn;\n\t\t}\n\n\t\t// We are the RESPONDER.\n\t\t// Therefore, we can only get packets of phase 1 and 3 here.\n\n\t\tif(packetType == 0) {\n\t\t\t// Phase 1\n\t\t\tprocessJFKMessage1(payload,4,null,replyTo, true, setupType, negType);\n\t\t} else if(packetType == 2) {\n\t\t\t// Phase 3\n\t\t\tprocessJFKMessage3(payload, 4, null, replyTo, false, true, setupType, negType);\n\t\t} else {\n\t\t\tLogger.error(this, \"Invalid phase \"+packetType+\" for anonymous-initiator (we are the responder) from \"+replyTo);\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private DiffieHellmanLightContext _genLightDiffieHellmanContext() {\n\t\tfinal DiffieHellmanLightContext ctx = DiffieHellman.generateLightContext();\n\t\tctx.setSignature(crypto.sign(SHA256.digest(assembleDHParams(ctx.myExponential, crypto.getCryptoGroup()))));\n\n\t\treturn ctx;\n\t}","id":43065,"modified_method":"private DiffieHellmanLightContext _genLightDiffieHellmanContext() {\n\t\tfinal DiffieHellmanLightContext ctx = DiffieHellman.generateLightContext(dhGroupToUse);\n\t\tctx.setSignature(crypto.sign(SHA256.digest(assembleDHParams(ctx.getPublicKeyNetworkFormat(), crypto.getCryptoGroup()))));\n\n\t\treturn ctx;\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tNONCE_SIZE*2 + // Ni, Nr\n\t\t\tDiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t\tHASH_LENGTH + // authenticator\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t8 +\t      // a bootid\n\t\t\t8 + // packet tracker ID\n\t\t\t1;\t      // znoderefI* is at least 1 byte long\n\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// We *WANT* to check the hmac before we do the lookup on the hashmap\n\t\t// @see https://bugs.freenetproject.org/view.php?id=1604\n\t\tif(!HMAC.verifyWithSHA256(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\t// We are replaying a JFK(4).\n\t\t\t// Therefore if it is anon-initiator it is encrypted with our setup key.\n\t\t\tif(unknownInitiator) {\n\t\t\t\tsendAnonAuthPacket(1,negType,3,setupType, (byte[]) message4, null, replyTo, crypto.anonSetupCipher);\n\t\t\t} else {\n\t\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message4, pn, replyTo);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(logDEBUG) Logger.debug(this, \"No message4 found for \"+HexUtil.bytesToHex(authenticator)+\" responderExponential \"+Fields.hashCode(responderExponential)+\" initiatorExponential \"+Fields.hashCode(initiatorExponential)+\" nonceResponder \"+Fields.hashCode(nonceResponder)+\" nonceInitiator \"+Fields.hashCode(nonceInitiator)+\" address \"+HexUtil.bytesToHex(replyTo.getAddress().getAddress()));\n\t\t}\n\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\tif(ctx == null) {\n\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n\t\t\t// Possible this is a replay or severely delayed? We don't keep every exponential we ever use.\n\t\t\treturn;\n\t\t}\n\t\tBigInteger computedExponential = ctx.getHMACKey(_hisExponential, Global.DHgroupA);\n\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tbyte[] outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"7\");\n\t\tbyte[] incommingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\n\t\tbyte[] hmacKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"3\");\n\t\tbyte[] ivKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"4\");\n\t\tbyte[] ivNonce = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the responder */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"6\");\n\t\tint theirInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tint ourInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tint theirInitialMsgID, ourInitialMsgID;\n\t\tif(negType >= 7) {\n\t\t\ttheirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\ttheirInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tourInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+theirInitialMsgID+\" ours \"+ourInitialMsgID);\n\n\t\tc.initialize(Ke);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_INITIATOR.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_INITIATOR.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!HMAC.verifyWithSHA256(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\t// Get the IV\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tif(trackerID < 0) trackerID = -1;\n\t\tptr += 8;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = new byte[data.length - ptr];\n\t\tSystem.arraycopy(data, ptr, hisRef, 0, hisRef.length);\n\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn, replyTo);\n\t\t}\n\t\tif(pn == null) {\n\t\t\tif(unknownInitiator) {\n\t\t\t\t// Reject\n\t\t\t\tLogger.normal(this, \"Rejecting... unable to construct PeerNode\");\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"PeerNode is null and unknownInitiator is false!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity, data))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\tBlockCipher ivCipher = null;\n\t\ttry {\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\toutgoingCipher.initialize(outgoingKey);\n\t\tincommingCipher.initialize(incommingKey);\n\t\tivCipher.initialize(ivKey);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tif(pn instanceof DarknetPeerNode) {\n\t\t\t\tLogger.error(this, \"Dropping peer \"+pn+\" because don't want connection due to others on the same IP address!\");\n\t\t\t\tSystem.out.println(\"Disconnecting permanently from your friend \\\"\"+((DarknetPeerNode)pn).getName()+\"\\\" because other peers are using the same IP address!\");\n\t\t\t}\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, outgoingKey, incommingCipher,\n\t\t\t\tincommingKey, replyTo, true, negType, trackerID, false, false, hmacKey, ivCipher,\n\t\t\t\tivNonce, ourInitialSeqNum, theirInitialSeqNum, ourInitialMsgID, theirInitialMsgID);\n\n\t\tif(newTrackerID > 0) {\n\n\t\t\t// Send reply\n\t\t\tsendJFKMessage4(1, negType, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential,\n\t\t\t\t\tc, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType, newTrackerID, newTrackerID == trackerID);\n\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true); // Let it connect then tell it to remove it.\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t\t// Don't send the JFK(4). We have not successfully connected.\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message3 Processing packet for \"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t\t}\n\t}","id":43066,"modified_method":"private void processJFKMessage3(byte[] payload, int inputOffset, PeerNode pn,Peer replyTo, boolean oldOpennetPeer, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\n\t\tfinal int expectedLength =\n\t\t\tNONCE_SIZE*2 + // Ni, Nr\n\t\t\tmodulusLength*2 + // g^i, g^r\n\t\t\tHASH_LENGTH + // authenticator\n\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t8 +\t      // a bootid\n\t\t\t8 + // packet tracker ID\n\t\t\t1;\t      // znoderefI* is at least 1 byte long\n\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[modulusLength];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, modulusLength);\n\t\tinputOffset += modulusLength;\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[modulusLength];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// We *WANT* to check the hmac before we do the lookup on the hashmap\n\t\t// @see https://bugs.freenetproject.org/view.php?id=1604\n\t\tif(!HMAC.verifyWithSHA256(getTransientKey(), assembleJFKAuthenticator(responderExponential, initiatorExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery) - JFK3 - \"+pn);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\t// We are replaying a JFK(4).\n\t\t\t// Therefore if it is anon-initiator it is encrypted with our setup key.\n\t\t\tif(unknownInitiator) {\n\t\t\t\tsendAnonAuthPacket(1,negType,3,setupType, (byte[]) message4, null, replyTo, crypto.anonSetupCipher);\n\t\t\t} else {\n\t\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message4, pn, replyTo);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(logDEBUG) Logger.debug(this, \"No message4 found for \"+HexUtil.bytesToHex(authenticator)+\" responderExponential \"+Fields.hashCode(responderExponential)+\" initiatorExponential \"+Fields.hashCode(initiatorExponential)+\" nonceResponder \"+Fields.hashCode(nonceResponder)+\" nonceInitiator \"+Fields.hashCode(nonceInitiator)+\" address \"+HexUtil.bytesToHex(replyTo.getAddress().getAddress()));\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\tbyte[] computedExponential;\n\t\tif(negType < 8) { // Legacy DH\n\t\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\n\t\t\tDiffieHellmanLightContext ctx = findContextByExponential(_ourExponential);\n\t\t\tif(ctx == null) {\n\t\t\t\tLogger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n\t\t\t\t// Possible this is a replay or severely delayed? We don't keep every exponential we ever use.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomputedExponential = ctx.getHMACKey(_hisExponential);\n        } else {\n            ECPublicKey initiatorKey = ECDH.getPublicKey(initiatorExponential);\n            ECPublicKey responderKey = ECDH.getPublicKey(responderExponential);\n            ECDHLightContext ctx = findECDHContextByPubKey(responderKey);\n            if (ctx == null) {\n                Logger.error(this, \"WTF? the HMAC verified but we don't know about that exponential! SHOULDN'T HAPPEN! - JFK3 - \"+pn);\n                // Possible this is a replay or severely delayed? We don't keep\n                // every exponential we ever use.\n                return;\n            }\n            computedExponential = ctx.getHMACKey(initiatorKey).getEncoded();\n        }\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential) +\" for \" + pn);\n\t\t\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tbyte[] outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"7\");\n\t\tbyte[] incommingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\n\t\tbyte[] hmacKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"3\");\n\t\tbyte[] ivKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"4\");\n\t\tbyte[] ivNonce = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the responder */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"6\");\n\t\tint theirInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tint ourInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tint theirInitialMsgID, ourInitialMsgID;\n\t\tif(negType >= 7) {\n\t\t\ttheirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(crypto.myIdentity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\ttheirInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tourInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+theirInitialMsgID+\" ours \"+ourInitialMsgID);\n\n\t\tc.initialize(Ke);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] decypheredPayload = new byte[JFK_PREFIX_INITIATOR.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, decypheredPayload, decypheredPayloadOffset, JFK_PREFIX_INITIATOR.length);\n\t\tdecypheredPayloadOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!HMAC.verifyWithSHA256(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The inner-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PCFBMode pk = PCFBMode.create(c, decypheredPayload, decypheredPayloadOffset);\n\t\t// Get the IV\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * Node Data (starting with BootID)\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = Fields.bytesToLong(data, ptr);\n\t\tif(trackerID < 0) trackerID = -1;\n\t\tptr += 8;\n\t\tlong bootID = Fields.bytesToLong(data, ptr);\n\t\tptr += 8;\n\t\tbyte[] hisRef = new byte[data.length - ptr];\n\t\tSystem.arraycopy(data, ptr, hisRef, 0, hisRef.length);\n\n\t\t// construct the peernode\n\t\tif(unknownInitiator) {\n\t\t\tpn = getPeerNodeFromUnknownInitiator(hisRef, setupType, pn, replyTo);\n\t\t}\n\t\tif(pn == null) {\n\t\t\tif(unknownInitiator) {\n\t\t\t\t// Reject\n\t\t\t\tLogger.normal(this, \"Rejecting... unable to construct PeerNode\");\n\t\t\t} else {\n\t\t\t\tLogger.error(this, \"PeerNode is null and unknownInitiator is false!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, initiatorExponential, responderExponential, crypto.myIdentity, data))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tBlockCipher outgoingCipher = null;\n\t\tBlockCipher incommingCipher = null;\n\t\tBlockCipher ivCipher = null;\n\t\ttry {\n\t\t\toutgoingCipher = new Rijndael(256, 256);\n\t\t\tincommingCipher = new Rijndael(256, 256);\n\t\t\tivCipher = new Rijndael(256, 256);\n\t\t} catch (UnsupportedCipherException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\toutgoingCipher.initialize(outgoingKey);\n\t\tincommingCipher.initialize(incommingKey);\n\t\tivCipher.initialize(ivKey);\n\n\t\t// Promote if necessary\n\t\tboolean dontWant = false;\n\t\tif(oldOpennetPeer) {\n\t\t\tOpennetManager opennet = node.getOpennet();\n\t\t\tif(opennet == null) {\n\t\t\t\tLogger.normal(this, \"Dumping incoming old-opennet peer as opennet just turned off: \"+pn+\".\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* When an old-opennet-peer connects, add it at the top of the LRU, so that it isn't\n\t\t\t * immediately dropped when there is no droppable peer to drop. If it was dropped\n\t\t\t * from the bottom of the LRU list, we would not have added it to the LRU; so it was\n\t\t\t * somewhere in the middle. */\n\t\t\tif(!opennet.wantPeer(pn, false, false, true, ConnectionType.RECONNECT)) {\n\t\t\t\tLogger.normal(this, \"No longer want peer \"+pn+\" - dumping it after connecting\");\n\t\t\t\tdontWant = true;\n\t\t\t\topennet.purgeOldOpennetPeer(pn);\n\t\t\t}\n\t\t\t// wantPeer will call node.peers.addPeer(), we don't have to.\n\t\t}\n\t\tif((!dontWant) && !crypto.allowConnection(pn, replyTo.getFreenetAddress())) {\n\t\t\tif(pn instanceof DarknetPeerNode) {\n\t\t\t\tLogger.error(this, \"Dropping peer \"+pn+\" because don't want connection due to others on the same IP address!\");\n\t\t\t\tSystem.out.println(\"Disconnecting permanently from your friend \\\"\"+((DarknetPeerNode)pn).getName()+\"\\\" because other peers are using the same IP address!\");\n\t\t\t}\n\t\t\tLogger.normal(this, \"Rejecting connection because already have something with the same IP\");\n\t\t\tdontWant = true;\n\t\t}\n\n\t\tlong newTrackerID = pn.completedHandshake(\n\t\t\t\tbootID, hisRef, 0, hisRef.length, outgoingCipher, outgoingKey, incommingCipher,\n\t\t\t\tincommingKey, replyTo, true, negType, trackerID, false, false, hmacKey, ivCipher,\n\t\t\t\tivNonce, ourInitialSeqNum, theirInitialSeqNum, ourInitialMsgID, theirInitialMsgID);\n\n\t\tif(newTrackerID > 0) {\n\n\t\t\t// Send reply\n\t\t\tsendJFKMessage4(1, negType, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential,\n\t\t\t\t\tc, Ke, Ka, authenticator, hisRef, pn, replyTo, unknownInitiator, setupType, newTrackerID, newTrackerID == trackerID);\n\n\t\t\tif(dontWant) {\n\t\t\t\tnode.peers.disconnectAndRemove(pn, true, true, true); // Let it connect then tell it to remove it.\n\t\t\t} else {\n\t\t\t\tpn.maybeSendInitialMessages();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn.getPeer());\n\t\t\t// Don't send the JFK(4). We have not successfully connected.\n\t\t}\n\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message3 Processing packet for \"+pn.getPeer()+\" took \"+TimeUtil.formatTime(t2-t1, 3, true));\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Process a decrypted, authenticated auth packet.\n\t * @param payload The packet payload, after it has been decrypted.\n\t */\n\tprivate void processDecryptedAuth(byte[] payload, PeerNode pn, Peer replyTo, boolean oldOpennetPeer) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" for \"+pn);\n\t\tif(pn.isDisabled()) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Won't connect to a disabled peer (\"+pn+ ')');\n\t\t\treturn;  // We don't connect to disabled peers\n\t\t}\n\n\t\tint negType = payload[1];\n\t\tint packetType = payload[2];\n\t\tint version = payload[0];\n\n\t\tif(logMINOR) {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tlong last = pn.lastSentPacketTime();\n\t\t\tString delta = \"never\";\n\t\t\tif (last>0) {\n\t\t\t\tdelta = TimeUtil.formatTime(now-last, 2, true)+\" ago\";\n\t\t\t}\n\t\t\tLogger.minor(this, \"Received auth packet for \"+pn.getPeer()+\" (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\") (last packet sent \"+delta+\") from \"+replyTo+\"\");\n\t\t}\n\n\t\t/* Format:\n\t\t * 1 byte - version number (1)\n\t\t * 1 byte - negotiation type (0 = simple DH, will not be supported when implement JFKi || 1 = StS)\n\t\t * 1 byte - packet type (0-3)\n\t\t */\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType >= 0 && negType < 6) {\n\t\t\t// negType 0 through 5 no longer supported, used old FNP.\n\t\t\tLogger.warning(this, \"Old neg type \"+negType+\" not supported\");\n\t\t\treturn;\n\t\t} else if (negType == 6 || negType == 7) {\n\t\t\t// negType == 7 => same as 6, but determine the initial sequence number by hashing the identity\n\t\t\t// instead of negotiating it\n\t\t\t/*\n\t\t\t * We implement Just Fast Keying key management protocol with active identity protection\n\t\t\t * for the initiator and no identity protection for the responder\n\t\t\t * M1:\n\t\t\t * This is a straightforward DiffieHellman exponential.\n\t\t\t * The Initiator Nonce serves two purposes;it allows the initiator to use the same\n\t\t\t * exponentials during different sessions while ensuring that the resulting session\n\t\t\t * key will be different,can be used to differentiate between parallel sessions\n\t\t\t * M2:\n\t\t\t * Responder replies with a signed copy of his own exponential, a random nonce and\n\t\t\t * an authenticator which provides sufficient defense against forgeries,replays\n\t\t\t * We slightly deviate JFK here;we do not send any public key information as specified in the JFK docs\n\t\t\t * M3:\n\t\t\t * Initiator echoes the data sent by the responder including the authenticator.\n\t\t\t * This helps the responder verify the authenticity of the returned data.\n\t\t\t * M4:\n\t\t\t * Encrypted message of the signature on both nonces, both exponentials using the same keys as in the previous message\n\t\t\t */\n\t\t\tif(packetType<0 || packetType>3) {\n\t\t\t\tLogger.error(this,\"Unknown PacketType\" + packetType + \"from\" + replyTo + \"from\" +pn);\n\t\t\t\treturn ;\n\t\t\t} else if(packetType==0) {\n\t\t\t\t/*\n\t\t\t\t * Initiator- This is a straightforward DiffieHellman exponential.\n\t\t\t\t * The Initiator Nonce serves two purposes;it allows the initiator to use the same\n\t\t\t\t * exponentials during different sessions while ensuring that the resulting\n\t\t\t\t * session key will be different,can be used to differentiate between\n\t\t\t\t * parallel sessions\n\t\t\t\t */\n\t\t\t\tprocessJFKMessage1(payload,3,pn,replyTo,false,-1,negType);\n\n\t\t\t} else if(packetType==1) {\n\t\t\t\t/*\n\t\t\t\t * Responder replies with a signed copy of his own exponential, a random\n\t\t\t\t * nonce and an authenticator calculated from a transient hash key private\n\t\t\t\t * to the responder.\n\t\t\t\t */\n\t\t\t\tprocessJFKMessage2(payload,3,pn,replyTo,false,-1,negType);\n\t\t\t} else if(packetType==2) {\n\t\t\t\t/*\n\t\t\t\t * Initiator echoes the data sent by the responder.These messages are\n\t\t\t\t * cached by the Responder.Receiving a duplicate message simply causes\n\t\t\t\t * the responder to Re-transmit the corresponding message4\n\t\t\t\t */\n\t\t\t\tprocessJFKMessage3(payload, 3, pn, replyTo, oldOpennetPeer, false, -1, negType);\n\t\t\t} else if(packetType==3) {\n\t\t\t\t/*\n\t\t\t\t * Encrypted message of the signature on both nonces, both exponentials\n\t\t\t\t * using the same keys as in the previous message.\n\t\t\t\t * The signature is non-message recovering\n\t\t\t\t */\n\t\t\t\tprocessJFKMessage4(payload, 3, pn, replyTo, oldOpennetPeer, false, -1, negType);\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Decrypted auth packet but unknown negotiation type \"+negType+\" from \"+replyTo+\" possibly from \"+pn);\n\t\t\treturn;\n\t\t}\n\t}","id":43067,"modified_method":"/**\n\t * Process a decrypted, authenticated auth packet.\n\t * @param payload The packet payload, after it has been decrypted.\n\t */\n\tprivate void processDecryptedAuth(byte[] payload, PeerNode pn, Peer replyTo, boolean oldOpennetPeer) {\n\t\tif(logMINOR) Logger.minor(this, \"Processing decrypted auth packet from \"+replyTo+\" for \"+pn);\n\t\tif(pn.isDisabled()) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Won't connect to a disabled peer (\"+pn+ ')');\n\t\t\treturn;  // We don't connect to disabled peers\n\t\t}\n\n\t\tint negType = payload[1];\n\t\tint packetType = payload[2];\n\t\tint version = payload[0];\n\n\t\tif(logMINOR) {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tlong last = pn.lastSentPacketTime();\n\t\t\tString delta = \"never\";\n\t\t\tif (last>0) {\n\t\t\t\tdelta = TimeUtil.formatTime(now-last, 2, true)+\" ago\";\n\t\t\t}\n\t\t\tLogger.minor(this, \"Received auth packet for \"+pn.getPeer()+\" (phase=\"+packetType+\", v=\"+version+\", nt=\"+negType+\") (last packet sent \"+delta+\") from \"+replyTo+\"\");\n\t\t}\n\n\t\t/* Format:\n\t\t * 1 byte - version number (1)\n\t\t * 1 byte - negotiation type (0 = simple DH, will not be supported when implement JFKi || 1 = StS)\n\t\t * 1 byte - packet type (0-3)\n\t\t */\n\t\tif(version != 1) {\n\t\t\tLogger.error(this, \"Decrypted auth packet but invalid version: \"+version);\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType >= 0 && negType < 6) {\n\t\t\t// negType 0 through 5 no longer supported, used old FNP.\n\t\t\tLogger.warning(this, \"Old neg type \"+negType+\" not supported\");\n\t\t\treturn;\n\t\t} else if (negType == 6 || negType == 7 || negType == 8) {\n\t\t    // negType == 8 => use ECDH with P384 instead of DH\n\t\t\t// negType == 7 => same as 6, but determine the initial sequence number by hashing the identity\n\t\t\t// instead of negotiating it\n\t\t\t/*\n\t\t\t * We implement Just Fast Keying key management protocol with active identity protection\n\t\t\t * for the initiator and no identity protection for the responder\n\t\t\t * M1:\n\t\t\t * This is a straightforward DiffieHellman exponential.\n\t\t\t * The Initiator Nonce serves two purposes;it allows the initiator to use the same\n\t\t\t * exponentials during different sessions while ensuring that the resulting session\n\t\t\t * key will be different,can be used to differentiate between parallel sessions\n\t\t\t * M2:\n\t\t\t * Responder replies with a signed copy of his own exponential, a random nonce and\n\t\t\t * an authenticator which provides sufficient defense against forgeries,replays\n\t\t\t * We slightly deviate JFK here;we do not send any public key information as specified in the JFK docs\n\t\t\t * M3:\n\t\t\t * Initiator echoes the data sent by the responder including the authenticator.\n\t\t\t * This helps the responder verify the authenticity of the returned data.\n\t\t\t * M4:\n\t\t\t * Encrypted message of the signature on both nonces, both exponentials using the same keys as in the previous message\n\t\t\t */\n\t\t\tif(packetType<0 || packetType>3) {\n\t\t\t\tLogger.error(this,\"Unknown PacketType\" + packetType + \"from\" + replyTo + \"from\" +pn);\n\t\t\t\treturn ;\n\t\t\t} else if(packetType==0) {\n\t\t\t\t/*\n\t\t\t\t * Initiator- This is a straightforward DiffieHellman exponential.\n\t\t\t\t * The Initiator Nonce serves two purposes;it allows the initiator to use the same\n\t\t\t\t * exponentials during different sessions while ensuring that the resulting\n\t\t\t\t * session key will be different,can be used to differentiate between\n\t\t\t\t * parallel sessions\n\t\t\t\t */\n\t\t\t\tprocessJFKMessage1(payload,3,pn,replyTo,false,-1,negType);\n\n\t\t\t} else if(packetType==1) {\n\t\t\t\t/*\n\t\t\t\t * Responder replies with a signed copy of his own exponential, a random\n\t\t\t\t * nonce and an authenticator calculated from a transient hash key private\n\t\t\t\t * to the responder.\n\t\t\t\t */\n\t\t\t\tprocessJFKMessage2(payload,3,pn,replyTo,false,-1,negType);\n\t\t\t} else if(packetType==2) {\n\t\t\t\t/*\n\t\t\t\t * Initiator echoes the data sent by the responder.These messages are\n\t\t\t\t * cached by the Responder.Receiving a duplicate message simply causes\n\t\t\t\t * the responder to Re-transmit the corresponding message4\n\t\t\t\t */\n\t\t\t\tprocessJFKMessage3(payload, 3, pn, replyTo, oldOpennetPeer, false, -1, negType);\n\t\t\t} else if(packetType==3) {\n\t\t\t\t/*\n\t\t\t\t * Encrypted message of the signature on both nonces, both exponentials\n\t\t\t\t * using the same keys as in the previous message.\n\t\t\t\t * The signature is non-message recovering\n\t\t\t\t */\n\t\t\t\tprocessJFKMessage4(payload, 3, pn, replyTo, oldOpennetPeer, false, -1, negType);\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"Decrypted auth packet but unknown negotiation type \"+negType+\" from \"+replyTo+\" possibly from \"+pn);\n\t\t\treturn;\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Change the DH Exponents on a regular basis but at most once every 30sec\n\t *\n\t * @return {@link DiffieHellmanLightContext}\n\t */\n\tprivate DiffieHellmanLightContext getLightDiffieHellmanContext() {\n\t\tfinal long now = System.currentTimeMillis();\n\t\tDiffieHellmanLightContext result = null;\n\n\t\tsynchronized (dhContextFIFO) {\n\t\t\tresult = dhContextFIFO.removeFirst();\n\n\t\t\t// Shall we replace one element of the queue ?\n\t\t\tif((jfkDHLastGenerationTimestamp + DH_GENERATION_INTERVAL) < now) {\n\t\t\t\tjfkDHLastGenerationTimestamp = now;\n\t\t\t\t_fillJFKDHFIFOOffThread();\n\t\t\t}\n\n\t\t\tdhContextFIFO.addLast(result);\n\t\t}\n\n\t\tLogger.minor(this, \"getLightDiffieHellmanContext() is serving \"+result.hashCode());\n\t\treturn result;\n\t}","id":43068,"modified_method":"/**\n\t * Change the DH Exponents on a regular basis but at most once every 30sec\n\t *\n\t * @return {@link DiffieHellmanLightContext}\n\t */\n\tprivate DiffieHellmanLightContext getLightDiffieHellmanContext() {\n\t\tfinal long now = System.currentTimeMillis();\n\t\tDiffieHellmanLightContext result = null;\n\n\t\tsynchronized (dhContextFIFO) {\n\t\t\tresult = dhContextFIFO.removeFirst();\n\n\t\t\t// Shall we replace one element of the queue ?\n\t\t\tif((jfkDHLastGenerationTimestamp + DH_GENERATION_INTERVAL) < now) {\n\t\t\t\tjfkDHLastGenerationTimestamp = now;\n\t\t\t\t_fillJFKDHFIFOOffThread();\n\t\t\t}\n\n\t\t\tdhContextFIFO.addLast(result);\n\t\t}\n\n\t\tif(logMINOR) Logger.minor(this, \"getLightDiffieHellmanContext() is serving \"+result.hashCode());\n\t\treturn result;\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage1(PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(1) message to \"+replyTo+\" for \"+pn.getPeer());\n\t\tfinal long now = System.currentTimeMillis();\n\t\tDiffieHellmanLightContext ctx = (DiffieHellmanLightContext) pn.getKeyAgreementSchemeContext();\n\t\tif((ctx == null) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n\t\t\tpn.jfkContextLifetime = now;\n\t\t\tpn.setKeyAgreementSchemeContext(ctx = getLightDiffieHellmanContext());\n\t\t}\n\t\tint offset = 0;\n\t\tbyte[] myExponential = stripBigIntegerToNetworkFormat(ctx.myExponential);\n\t\tbyte[] nonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(nonce);\n\n\t\tsynchronized (pn) {\n\t\t\tpn.jfkNoncesSent.add(nonce);\n\t\t\tif(pn.jfkNoncesSent.size() > MAX_NONCES_PER_PEER)\n\t\t\t\tpn.jfkNoncesSent.removeFirst();\n\t\t}\n\n\t\tint modulusLength = DiffieHellman.modulusLengthInBytes();\n\t\tbyte[] message1 = new byte[NONCE_SIZE+modulusLength+(unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)];\n\n\t\tSystem.arraycopy(nonce, 0, message1, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message1, offset, modulusLength);\n\n\t\tif(unknownInitiator) {\n\t\t\toffset += modulusLength;\n\t\t\tSystem.arraycopy(pn.identityHash, 0, message1, offset, pn.identityHash.length);\n\t\t\tsendAnonAuthPacket(1,negType,0,setupType,message1,pn,replyTo,pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,0,message1,pn,replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-now)>500) {\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for \"+pn.getPeer());\n\t\t}\n\t}","id":43069,"modified_method":"private void sendJFKMessage1(PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(1) message to \"+replyTo+\" for \"+pn.getPeer());\n\t\tfinal long now = System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\t\n\t\t\n\t\tKeyAgreementSchemeContext ctx = pn.getKeyAgreementSchemeContext();\n\t\tif(negType < 8) { // Legacy DH\n\t\t    if((ctx == null) || !(ctx instanceof DiffieHellmanLightContext) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n\t\t\t    pn.jfkContextLifetime = now;\n\t\t\t    pn.setKeyAgreementSchemeContext(ctx = getLightDiffieHellmanContext());\n\t\t    }\n\t\t} else {\n            if((ctx == null) || !(ctx instanceof ECDHLightContext) || ((pn.jfkContextLifetime + DH_GENERATION_INTERVAL*DH_CONTEXT_BUFFER_SIZE) < now)) {\n                pn.jfkContextLifetime = now;\n                pn.setKeyAgreementSchemeContext(ctx = getECDHLightContext());\n            }\n\t\t}\n\t\t\n\t\tint offset = 0;\n\t\tbyte[] nonce = new byte[NONCE_SIZE];\n\t\tbyte[] myExponential = ctx.getPublicKeyNetworkFormat();\n\t\tnode.random.nextBytes(nonce);\n\n\t\tsynchronized (pn) {\n\t\t\tpn.jfkNoncesSent.add(nonce);\n\t\t\tif(pn.jfkNoncesSent.size() > MAX_NONCES_PER_PEER)\n\t\t\t\tpn.jfkNoncesSent.removeFirst();\n\t\t}\n\n\t\tbyte[] message1 = new byte[NONCE_SIZE+modulusLength+(unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)];\n\n\t\tSystem.arraycopy(nonce, 0, message1, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message1, offset, modulusLength);\n\n\t\tif(unknownInitiator) {\n\t\t\toffset += modulusLength;\n\t\t\tSystem.arraycopy(pn.identityHash, 0, message1, offset, pn.identityHash.length);\n\t\t\tsendAnonAuthPacket(1,negType,0,setupType,message1,pn,replyTo,pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,0,message1,pn,replyTo);\n\t\t}\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-now)>500) {\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for \"+pn.getPeer());\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Start up the FNPPacketMangler. By the time this is called, all objects will have been constructed,\n\t * but not all will have been started yet.\n\t */\n\tpublic void start() {\n\t\t// Run it directly so that the transient key is set.\n\t\tmaybeResetTransientKey();\n\t\t// Fill the DH FIFO on-thread\n\t\tfor(int i=0;i<DH_CONTEXT_BUFFER_SIZE;i++) {\n\t\t\t_fillJFKDHFIFO();\n\t\t}\n\t}","id":43070,"modified_method":"/**\n\t * Start up the FNPPacketMangler. By the time this is called, all objects will have been constructed,\n\t * but not all will have been started yet.\n\t */\n\tpublic void start() {\n\t\t// Run it directly so that the transient key is set.\n\t\tmaybeResetTransientKey();\n\t\t// Fill the DH FIFO on-thread\n\t\tfor(int i=0;i<DH_CONTEXT_BUFFER_SIZE;i++) {\n\t\t\t_fillJFKDHFIFO();\n\t\t\t_fillJFKECDHFIFO();\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage2(byte[] payload,int inputOffset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn.getPeer());\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = NONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes() + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, hisExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn.getPeer());\n\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message3, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\n\t\t// sanity check\n\t\tbyte[] myNi = null;\n\t\tsynchronized (pn) {\n\t\t\tfor(byte[] buf : pn.jfkNoncesSent) {\n\t\t\t\tif(Arrays.equals(nonceInitiator, buf))\n\t\t\t\t\tmyNi = buf;\n\t\t\t}\n\t\t}\n\t\t// We don't except such a message;\n\t\tif(myNi == null) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"We received an unexpected JFK(2) message from \"+pn.getPeer()+\" (time since added: \"+pn.timeSinceAddedOrRestarted()+\" time last receive:\"+pn.lastReceivedPacketTime()+')');\n\t\t\t}\n\t\t\treturn;\n\t\t} else if(!Arrays.equals(myNi, nonceInitiator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"Ignoring old JFK(2) (different nonce to the one we sent - either a timing artefact or an attempt to change the nonce)\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif(!DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn.getPeer()+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Verify the DSA signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t// At that point we don't know if it's \"him\"; let's check it out\n\t\tbyte[] locallyExpectedExponentials = assembleDHParams(_hisExponential, pn.peerCryptoGroup);\n\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tsendJFKMessage3(1, negType, 3, nonceInitiator, nonceResponder, hisExponential, authenticator, pn, replyTo, unknownInitiator, setupType);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message2 timeout error:Processing packet for \"+pn.getPeer());\n\t\t}\n\t}","id":43071,"modified_method":"private void processJFKMessage2(byte[] payload,int inputOffset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tint modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn.getPeer());\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = NONCE_SIZE*2 + modulusLength + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn.getPeer()+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = new byte[modulusLength];\n\t\tSystem.arraycopy(payload, inputOffset, hisExponential, 0, modulusLength);\n\t\tinputOffset += modulusLength;\n\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(new ByteArrayWrapper(authenticator));\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn.getPeer());\n\t\t\tsendAuthPacket(1, negType, 3, (byte[]) message3, pn, replyTo);\n\t\t\treturn;\n\t\t}\n\n\t\t// sanity check\n\t\tbyte[] myNi = null;\n\t\tsynchronized (pn) {\n\t\t\tfor(byte[] buf : pn.jfkNoncesSent) {\n\t\t\t\tif(Arrays.equals(nonceInitiator, buf))\n\t\t\t\t\tmyNi = buf;\n\t\t\t}\n\t\t}\n\t\t// We don't except such a message;\n\t\tif(myNi == null) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"We received an unexpected JFK(2) message from \"+pn.getPeer()+\" (time since added: \"+pn.timeSinceAddedOrRestarted()+\" time last receive:\"+pn.lastReceivedPacketTime()+')');\n\t\t\t}\n\t\t\treturn;\n\t\t} else if(!Arrays.equals(myNi, nonceInitiator)) {\n\t\t\tif(shouldLogErrorInHandshake(t1)) {\n\t\t\t\tLogger.normal(this, \"Ignoring old JFK(2) (different nonce to the one we sent - either a timing artefact or an attempt to change the nonce)\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif(negType < 8) { // legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    if(!DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t        Logger.error(this, \"We can't accept the exponential \"+pn.getPeer()+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t        return;\n\t\t    }\n\t\t}\n\n\t\t// Verify the DSA signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t// At that point we don't know if it's \"him\"; let's check it out\n\t\tbyte[] locallyExpectedExponentials =  assembleDHParams(hisExponential, pn.peerCryptoGroup);\n\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn.getPeer());\n\t\t\treturn;\n\t\t}\n\n\t\t// At this point we know it's from the peer, so we can report a packet received.\n\t\tpn.receivedPacket(true, false);\n\n\t\tsendJFKMessage3(1, negType, 3, nonceInitiator, nonceResponder, hisExponential, authenticator, pn, replyTo, unknownInitiator, setupType);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message2 timeout error:Processing packet for \"+pn.getPeer());\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage3(int version,final int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, final PeerNode pn, final Peer replyTo, final boolean unknownInitiator, final int setupType)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn.getPeer());\n\t\tlong t1=System.currentTimeMillis();\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\t\tDiffieHellmanLightContext ctx = (DiffieHellmanLightContext) pn.getKeyAgreementSchemeContext();\n\t\tif(ctx == null) return;\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(ctx.myExponential);\n\t\tpn.jfkMyRef = unknownInitiator ? crypto.myCompressedHeavySetupRef() : crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + 8 + pn.jfkMyRef.length];\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = pn.getReusableTrackerID();\n\t\tSystem.arraycopy(Fields.longToBytes(trackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tif(logMINOR) Logger.minor(this, \"Sending tracker ID \"+trackerID+\" in JFK(3)\");\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, data, ptr, pn.jfkMyRef.length);\n\t\tfinal byte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 + // Signature (R,S)\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity, data);\n\t\tpn.setJFKBuffer(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tBigInteger computedExponential = ctx.getHMACKey(_hisExponential, Global.DHgroupA);\n\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tpn.outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tpn.incommingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"7\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\n\t\tpn.hmacKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"3\");\n\t\tpn.ivKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"4\");\n\t\tpn.ivNonce = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the initiator */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"6\");\n\t\tpn.ourInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tpn.theirInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tif(negType >= 7) {\n\t\t\tpn.theirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tpn.ourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\tpn.ourInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tpn.theirInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\t\t\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+pn.theirInitialMsgID+\" ours \"+pn.ourInitialMsgID);\n\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pcfb = PCFBMode.create(c, iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] cleartext = new byte[JFK_PREFIX_INITIATOR.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, cleartext, cleartextOffset, JFK_PREFIX_INITIATOR.length);\n\t\tcleartextOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_INITIATOR.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tbyte[] hmac = HMAC.macWithSHA256(pn.jfkKa, cleartext, HASH_LENGTH);\n\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator),message3);\n\t\t}\n\t\tfinal long timeSent = System.currentTimeMillis();\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t}\n\n\t\t/* Re-send the packet after 5sec if we don't get any reply */\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif(pn.timeLastConnectionCompleted() < timeSent) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Resending JFK(3) to \"+pn+\" for \"+node.getDarknetPortNumber());\n\t\t\t\t\tif(unknownInitiator) {\n\t\t\t\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, 5*1000);\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for \"+pn.getPeer());\n\t}","id":43072,"modified_method":"private void sendJFKMessage3(int version,final int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, final PeerNode pn, final Peer replyTo, final boolean unknownInitiator, final int setupType)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn.getPeer());\n\t\tint modulusLength = getModulusLength(negType);\n\t\tlong t1=System.currentTimeMillis();\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) { throw new RuntimeException(e); }\n\t\tKeyAgreementSchemeContext ctx = pn.getKeyAgreementSchemeContext();\n\t\tif(ctx == null) return;\n\t\tbyte[] ourExponential = ctx.getPublicKeyNetworkFormat();\n\t\tpn.jfkMyRef = unknownInitiator ? crypto.myCompressedHeavySetupRef() : crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + 8 + pn.jfkMyRef.length];\n\t\tint ptr = 0;\n\t\tlong trackerID;\n\t\ttrackerID = pn.getReusableTrackerID();\n\t\tSystem.arraycopy(Fields.longToBytes(trackerID), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tif(logMINOR) Logger.minor(this, \"Sending tracker ID \"+trackerID+\" in JFK(3)\");\n\t\tSystem.arraycopy(Fields.longToBytes(pn.getOutgoingBootID()), 0, data, ptr, 8);\n\t\tptr += 8;\n\t\tSystem.arraycopy(pn.jfkMyRef, 0, data, ptr, pn.jfkMyRef.length);\n\t\tfinal byte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           modulusLength*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 + // Signature (R,S)\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, ourExponential, hisExponential, pn.identity, data);\n\t\tpn.setJFKBuffer(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tbyte[] computedExponential;\n\t\tif (negType < 8 ) { // Legacy DH\n\t\t    NativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t    computedExponential= ((DiffieHellmanLightContext)ctx).getHMACKey(_hisExponential);\n\t\t}else {\n\t\t    computedExponential = ((ECDHLightContext)ctx).getHMACKey(ECDH.getPublicKey(hisExponential)).getEncoded();\n\t\t}\n\t\tif(logDEBUG) Logger.debug(this, \"The shared Master secret is : \"+HexUtil.bytesToHex(computedExponential)+ \" for \" + pn);\n\t\t/* 0 is the outgoing key for the initiator, 7 for the responder */\n\t\tpn.outgoingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tpn.incommingKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"7\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\n\t\tpn.hmacKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"3\");\n\t\tpn.ivKey = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"4\");\n\t\tpn.ivNonce = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"5\");\n\n\t\t/* Bytes  1-4:  Initial sequence number for the initiator\n\t\t * Bytes  5-8:  Initial sequence number for the responder\n\t\t * Bytes  9-12: Initial message id for the initiator\n\t\t * Bytes 13-16: Initial message id for the responder\n\t\t * Note that we are the initiator */\n\t\tbyte[] sharedData = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"6\");\n\t\tpn.ourInitialSeqNum = ((sharedData[0] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[1] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[2] & 0xFF) << 8)\n\t\t\t\t| (sharedData[3] & 0xFF);\n\t\tpn.theirInitialSeqNum = ((sharedData[4] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[5] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[6] & 0xFF) << 8)\n\t\t\t\t| (sharedData[7] & 0xFF);\n\t\tif(negType >= 7) {\n\t\t\tpn.theirInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(pn.identity, crypto.myIdentity);\n\t\t\tpn.ourInitialMsgID =\n\t\t\t\tunknownInitiator ? getInitialMessageID(pn.identity) :\n\t\t\t\t\tgetInitialMessageID(crypto.myIdentity, pn.identity);\n\t\t} else {\n\t\t\tpn.ourInitialMsgID= ((sharedData[8] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[9] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[10] & 0xFF) << 8)\n\t\t\t\t| (sharedData[11] & 0xFF);\n\t\t\tpn.theirInitialMsgID= ((sharedData[12] & 0xFF) << 24)\n\t\t\t\t| ((sharedData[13] & 0xFF) << 16)\n\t\t\t\t| ((sharedData[14] & 0xFF) << 8)\n\t\t\t\t| (sharedData[15] & 0xFF);\n\t\t}\n\t\t\t\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Their initial message ID: \"+pn.theirInitialMsgID+\" ours \"+pn.ourInitialMsgID);\n\n\n\t\tc.initialize(pn.jfkKe);\n\t\tint ivLength = PCFBMode.lengthIV(c);\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tPCFBMode pcfb = PCFBMode.create(c, iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] cleartext = new byte[JFK_PREFIX_INITIATOR.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tSystem.arraycopy(JFK_PREFIX_INITIATOR, 0, cleartext, cleartextOffset, JFK_PREFIX_INITIATOR.length);\n\t\tcleartextOffset += JFK_PREFIX_INITIATOR.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\n\t\tint cleartextToEncypherOffset = JFK_PREFIX_INITIATOR.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tbyte[] hmac = HMAC.macWithSHA256(pn.jfkKa, cleartext, HASH_LENGTH);\n\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(!maybeResetTransientKey())\n\t\t\t\tauthenticatorCache.put(new ByteArrayWrapper(authenticator),message3);\n\t\t}\n\t\tfinal long timeSent = System.currentTimeMillis();\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t}\n\n\t\t/* Re-send the packet after 5sec if we don't get any reply */\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif(pn.timeLastConnectionCompleted() < timeSent) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Resending JFK(3) to \"+pn+\" for \"+node.getDarknetPortNumber());\n\t\t\t\t\tif(unknownInitiator) {\n\t\t\t\t\t\tsendAnonAuthPacket(1, negType, 2, setupType, message3, pn, replyTo, pn.anonymousInitiatorSetupCipher);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsendAuthPacket(1, negType, 2, message3, pn, replyTo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, 5*1000);\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for \"+pn.getPeer());\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void processJFKMessage1(byte[] payload,int offset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(1) message, processing it - \"+pn);\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tif(payload.length < NONCE_SIZE + DiffieHellman.modulusLengthInBytes() + 3 + (unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(1), should be \"+(NONCE_SIZE + DiffieHellman.modulusLengthInBytes()));\n\t\t\treturn;\n\t\t}\n\t\t// get Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, offset, nonceInitiator, 0, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\n\t\t// get g^i\n\t\tint modulusLength = DiffieHellman.modulusLengthInBytes();\n\t\tbyte[] hisExponential = new byte[modulusLength];\n\t\tSystem.arraycopy(payload, offset, hisExponential, 0, modulusLength);\n\t\tif(unknownInitiator) {\n\t\t\t// Check IDr'\n\t\t\toffset += DiffieHellman.modulusLengthInBytes();\n\t\t\tbyte[] expectedIdentityHash = new byte[NodeCrypto.IDENTITY_LENGTH];\n\t\t\tSystem.arraycopy(payload, offset, expectedIdentityHash, 0, expectedIdentityHash.length);\n\t\t\tif(!Arrays.equals(expectedIdentityHash, crypto.identityHash)) {\n\t\t\t\tLogger.error(this, \"Invalid unknown-initiator JFK(1), IDr' is \"+HexUtil.bytesToHex(expectedIdentityHash)+\" should be \"+HexUtil.bytesToHex(crypto.identityHash));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(throttleRekey(pn, replyTo)) return;\n\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tif(DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t\tsendJFKMessage2(nonceInitiator, hisExponential, pn, replyTo, unknownInitiator, setupType, negType);\n\t\t} else {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t}\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message1 timeout error:Processing packet for \"+pn);\n\t\t}\n\t}","id":43073,"modified_method":"private void processJFKMessage1(byte[] payload,int offset,PeerNode pn,Peer replyTo, boolean unknownInitiator, int setupType, int negType)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n        int modulusLength = getModulusLength(negType);\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(1) message, processing it - \"+pn);\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tif(payload.length < NONCE_SIZE + modulusLength + 3 + (unknownInitiator ? NodeCrypto.IDENTITY_LENGTH : 0)) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(1), should be \"+(NONCE_SIZE + modulusLength));\n\t\t\treturn;\n\t\t}\n\t\t// get Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE]; \n\t\tSystem.arraycopy(payload, offset, nonceInitiator, 0, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\n\t\t// get g^i\n\t\tbyte[] hisExponential = new byte[modulusLength];\n\t\tSystem.arraycopy(payload, offset, hisExponential, 0, modulusLength);\n\t\tif(unknownInitiator) {\n\t\t\t// Check IDr'\n\t\t\toffset += modulusLength;\n\t\t\tbyte[] expectedIdentityHash = new byte[NodeCrypto.IDENTITY_LENGTH];\n\t\t\tSystem.arraycopy(payload, offset, expectedIdentityHash, 0, expectedIdentityHash.length);\n\t\t\tif(!Arrays.equals(expectedIdentityHash, crypto.identityHash)) {\n\t\t\t\tLogger.error(this, \"Invalid unknown-initiator JFK(1), IDr' is \"+HexUtil.bytesToHex(expectedIdentityHash)+\" should be \"+HexUtil.bytesToHex(crypto.identityHash));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(throttleRekey(pn, replyTo)) return;\n\t\t   \n\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tif(negType < 8 || DiffieHellman.checkDHExponentialValidity(this.getClass(), _hisExponential)) {\n\t\t    sendJFKMessage2(nonceInitiator, hisExponential, pn, replyTo, unknownInitiator, setupType, negType);\n\t\t} else {\n\t\t    Logger.error(this, \"We can't accept the exponential \"+pn+\" sent us!! REDFLAG: IT CAN'T HAPPEN UNLESS AGAINST AN ACTIVE ATTACKER!!\");\n\t\t}\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500) {\n\t\t\tLogger.error(this,\"Message1 timeout error:Processing packet for \"+pn);\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private byte[] computeJFKSharedKey(BigInteger exponential, byte[] nI, byte[] nR, String what) {\n\t\tassert(\"0\".equals(what) || \"1\".equals(what) || \"2\".equals(what) || \"3\".equals(what)\n\t\t\t\t|| \"4\".equals(what) || \"5\".equals(what) || \"6\".equals(what) || \"7\".equals(what));\n\t\tbyte[] number = null;\n\t\ttry {\n\t\t\tnumber = what.getBytes(\"UTF-8\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new Error(\"Impossible: JVM doesn't support UTF-8: \" + e, e);\n\t\t}\n\n\t\tbyte[] toHash = new byte[NONCE_SIZE * 2 + number.length];\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nI, 0, toHash, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(nR, 0, toHash, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(number, 0, toHash, offset, number.length);\n\n\t\treturn HMAC.macWithSHA256(exponential.toByteArray(), toHash, HASH_LENGTH);\n\t}","id":43074,"modified_method":"private byte[] computeJFKSharedKey(byte[] exponential, byte[] nI, byte[] nR, String what) {\n\t\tassert(\"0\".equals(what) || \"1\".equals(what) || \"2\".equals(what) || \"3\".equals(what)\n\t\t\t\t|| \"4\".equals(what) || \"5\".equals(what) || \"6\".equals(what) || \"7\".equals(what));\n\t\tbyte[] number = null;\n\t\ttry {\n\t\t\tnumber = what.getBytes(\"UTF-8\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new Error(\"Impossible: JVM doesn't support UTF-8: \" + e, e);\n\t\t}\n\n\t\tbyte[] toHash = new byte[NONCE_SIZE * 2 + number.length];\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nI, 0, toHash, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(nR, 0, toHash, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(number, 0, toHash, offset, number.length);\n\n\t\treturn HMAC.macWithSHA256(exponential, toHash, HASH_LENGTH);\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private void sendJFKMessage2(byte[] nonceInitator, byte[] hisExponential, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(2) message to \"+pn);\n\t\tDiffieHellmanLightContext ctx = getLightDiffieHellmanContext();\n\t\t// g^r\n\t\tbyte[] myExponential = stripBigIntegerToNetworkFormat(ctx.myExponential);\n\t\t// Nr\n\t\tbyte[] myNonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(myNonce);\n\t\tbyte[] r = ctx.signature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = ctx.signature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] authenticator = HMAC.macWithSHA256(getTransientKey(),assembleJFKAuthenticator(myExponential, hisExponential, myNonce, nonceInitator, replyTo.getAddress().getAddress()), HASH_LENGTH);\n\t\tif(logMINOR) Logger.minor(this, \"We are using the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\n\t\tbyte[] message2 = new byte[NONCE_SIZE*2+DiffieHellman.modulusLengthInBytes()+\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH*2+\n\t\t                           HASH_LENGTH];\n\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nonceInitator, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myNonce, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message2, offset, DiffieHellman.modulusLengthInBytes());\n\t\toffset += DiffieHellman.modulusLengthInBytes();\n\n\t\tSystem.arraycopy(r, 0, message2, offset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\toffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, message2, offset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\toffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tSystem.arraycopy(authenticator, 0, message2, offset, HASH_LENGTH);\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1,negType,1,setupType,message2,pn,replyTo,crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,1,message2,pn,replyTo);\n\t\t}\n\t}","id":43075,"modified_method":"private void sendJFKMessage2(byte[] nonceInitator, byte[] hisExponential, PeerNode pn, Peer replyTo, boolean unknownInitiator, int setupType, int negType) {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(2) message to \"+pn);\n\t\tint modulusLength = getModulusLength(negType);\n\n\t\t// g^r\n\t\tKeyAgreementSchemeContext ctx = (negType < 8 ? getLightDiffieHellmanContext() : getECDHLightContext());\n\t    DSASignature sig = ctx.signature;\n\t\t    \n\t\t// Nr\n\t\tbyte[] myNonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(myNonce);\n\t    byte[] myExponential = ctx.getPublicKeyNetworkFormat();\n\t\tbyte[] r = sig.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = sig.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] authenticator = HMAC.macWithSHA256(getTransientKey(),assembleJFKAuthenticator(myExponential, hisExponential, myNonce, nonceInitator, replyTo.getAddress().getAddress()), HASH_LENGTH);\n\t\tif(logMINOR) Logger.minor(this, \"We are using the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\n\t\tbyte[] message2 = new byte[NONCE_SIZE*2+modulusLength+\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH*2+\n\t\t                           HASH_LENGTH];\n\n\t\tint offset = 0;\n\t\tSystem.arraycopy(nonceInitator, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myNonce, 0, message2, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message2, offset, modulusLength);\n\t\toffset += modulusLength;\n\n\t\tSystem.arraycopy(r, 0, message2, offset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\toffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, message2, offset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\toffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tSystem.arraycopy(authenticator, 0, message2, offset, HASH_LENGTH);\n\n\t\tif(unknownInitiator) {\n\t\t\tsendAnonAuthPacket(1,negType,1,setupType,message2,pn,replyTo,crypto.anonSetupCipher);\n\t\t} else {\n\t\t\tsendAuthPacket(1,negType,1,message2,pn,replyTo);\n\t\t}\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"private NodeStarter() {\n\t}","id":43076,"modified_method":"private NodeStarter() {\n        Security.addProvider(new BouncyCastleProvider());\n\t}","commit_id":"1d463835ebb1dadf799b49c02de7fa9bcef8c56d","url":"https://github.com/freenet/fred"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n        MockUtil.println(\"------------ Begin Test \"+getName()+\" --------------------------\");\n        MockLogAppender.setupLogging();\n        \n        if (m_runSupers) {\n        \n            m_network = new MockNetwork();\n            m_network.setCriticalService(\"ICMP\");\n            m_network.addNode(1, \"Router\");\n            m_network.addInterface(\"192.168.1.1\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"SMTP\");\n            m_network.addInterface(\"192.168.1.2\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"SMTP\");\n            m_network.addNode(2, \"Server\");\n            m_network.addInterface(\"192.168.1.3\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"HTTP\");\n            m_network.addNode(3, \"Firewall\");\n            m_network.addInterface(\"192.168.1.4\");\n            m_network.addService(\"SMTP\");\n            m_network.addService(\"HTTP\");\n            m_network.addInterface(\"192.168.1.5\");\n            m_network.addService(\"SMTP\");\n            m_network.addService(\"HTTP\");\n            \n            m_db = new MockDatabase();\n            m_db.populate(m_network);\n            \n            DataSourceFactory.setInstance(m_db);\n\n            Reader rdr = new StringReader(getSnmpConfig());\n            SnmpPeerFactory.setInstance(new SnmpPeerFactory(rdr));\n            \n            if (isStartEventd()) {\n                m_eventd = new Eventd();\n                m_eventd.setDataSource(m_db);\n                m_eventdConfigMgr = new MockEventConfigManager(MOCK_EVENT_CONFIG);\n                m_eventd.setConfigManager(m_eventdConfigMgr);\n                \n                \n                Reader configRdr = new StringReader(MOCK_EVENT_CONF);\n                EventConfigurationManager.loadConfiguration(configRdr);\n                \n                \n                m_eventdIpcMgr = new EventIpcManagerDefaultImpl(m_eventdConfigMgr);\n                m_eventProxy = new EventProxy() {\n\n                    public void send(Event event) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(event);\n                    }\n\n                    public void send(Log eventLog) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(eventLog);\n                    }\n                    \n                };\n                \n                EventIpcManagerFactory.setIpcManager(m_eventdIpcMgr);\n                m_eventd.setEventIpcManager(m_eventdIpcMgr);\n                m_eventd.init();\n                m_eventd.start();\n            }\n        \n        }\n\n    }","id":43077,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n        MockUtil.println(\"------------ Begin Test \"+getName()+\" --------------------------\");\n        MockLogAppender.setupLogging();\n        \n        if (m_runSupers) {\n        \n            createMockNetwork();\n            \n            populateDatabase();\n            \n            DataSourceFactory.setInstance(m_db);\n\n            Reader rdr = new StringReader(getSnmpConfig());\n            SnmpPeerFactory.setInstance(new SnmpPeerFactory(rdr));\n            \n            if (isStartEventd()) {\n                m_eventd = new Eventd();\n                m_eventd.setDataSource(m_db);\n                m_eventdConfigMgr = new MockEventConfigManager(MOCK_EVENT_CONFIG);\n                m_eventd.setConfigManager(m_eventdConfigMgr);\n                \n                \n                Reader configRdr = new StringReader(MOCK_EVENT_CONF);\n                EventConfigurationManager.loadConfiguration(configRdr);\n                \n                \n                m_eventdIpcMgr = new EventIpcManagerDefaultImpl(m_eventdConfigMgr);\n                m_eventProxy = new EventProxy() {\n\n                    public void send(Event event) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(event);\n                    }\n\n                    public void send(Log eventLog) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(eventLog);\n                    }\n                    \n                };\n                \n                EventIpcManagerFactory.setIpcManager(m_eventdIpcMgr);\n                m_eventd.setEventIpcManager(m_eventdIpcMgr);\n                m_eventd.init();\n                m_eventd.start();\n            }\n        \n        }\n\n    }","commit_id":"9b86ad1c3c4b4d3bd6813639b621c3329d1093f5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * String representing snmp-config.xml\n     */\n    public String getSnmpConfig() {\n        return \"<?xml version=\\\"1.0\\\"?>\\n\" + \n                \"<snmp-config \"+ \n                \" retry=\\\"3\\\" timeout=\\\"3000\\\"\\n\" + \n                \" read-community=\\\"public\\\"\" +\n                \" write-community=\\\"private\\\"\\n\" + \n                \" port=\\\"161\\\"\\n\" +\n                \" version=\\\"v1\\\">\\n\" +\n                \"\\n\" +\n                \"   <definition port=\\\"9161\\\" version=\\\"\"+myVersion()+\"\\\" \" +\n                \"       security-name=\\\"opennmsUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" \\n\" +\n                \"       privacy-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <specific>\"+myLocalHost()+\"<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\">\\n\" + \n                \"       <specific>10.0.0.1<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\" max-request-size=\\\"434\\\">\\n\" + \n                \"       <specific>10.0.0.2<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\" proxy-host=\\\"127.0.0.1\\\">\\n\" + \n                \"       <specific>10.0.0.3<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v3\\\" \" +\n                \"       security-name=\\\"opennmsUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <specific>20.20.20.20<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"   <definition version=\\\"v3\\\" \" +\n                \"       security-name=\\\"opennmsRangeUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <range begin=\\\"1.1.1.1\\\" end=\\\"1.1.1.100\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"rangev1\\\" max-vars-per-pdu=\\\"55\\\"> \\n\" + \n                \"       <range begin=\\\"10.0.0.101\\\" end=\\\"10.0.0.200\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"rangev2c\\\">\\n\" + \n                \"       <range begin=\\\"10.0.1.100\\\" end=\\\"10.0.5.100\\\"/>\\n\" +\n                \"       <range begin=\\\"10.7.20.100\\\" end=\\\"10.7.25.100\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"specificv2c\\\">\\n\" + \n                \"       <specific>192.168.0.50<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"ipmatch\\\" max-vars-per-pdu=\\\"128\\\">\\n\" + \n                \"       <ip-match>77.5-12,15.1-255.255<\/ip-match>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"<\/snmp-config>\";\n    }","id":43078,"modified_method":"/**\n     * String representing snmp-config.xml\n     */\n    public String getSnmpConfig() {\n        return \"<?xml version=\\\"1.0\\\"?>\\n\" + \n                \"<snmp-config \"+ \n                \" retry=\\\"3\\\" timeout=\\\"3000\\\"\\n\" + \n                \" read-community=\\\"public\\\"\" +\n                \" write-community=\\\"private\\\"\\n\" + \n                \" port=\\\"161\\\"\\n\" +\n                \" version=\\\"v1\\\">\\n\" +\n                \"\\n\" +\n                \"   <definition port=\\\"9161\\\" version=\\\"\"+myVersion()+\"\\\" \" +\n                \"       security-name=\\\"opennmsUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" \\n\" +\n                \"       privacy-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <specific>\"+myLocalHost()+\"<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\">\\n\" + \n                \"       <specific>10.0.0.1<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\" max-request-size=\\\"434\\\">\\n\" + \n                \"       <specific>10.0.0.2<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\" proxy-host=\\\"\"+myLocalHost()+\"\\\">\\n\" + \n                \"       <specific>10.0.0.3<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v3\\\" \" +\n                \"       security-name=\\\"opennmsUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <specific>20.20.20.20<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"   <definition version=\\\"v3\\\" \" +\n                \"       security-name=\\\"opennmsRangeUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <range begin=\\\"1.1.1.1\\\" end=\\\"1.1.1.100\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"rangev1\\\" max-vars-per-pdu=\\\"55\\\"> \\n\" + \n                \"       <range begin=\\\"10.0.0.101\\\" end=\\\"10.0.0.200\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"rangev2c\\\">\\n\" + \n                \"       <range begin=\\\"10.0.1.100\\\" end=\\\"10.0.5.100\\\"/>\\n\" +\n                \"       <range begin=\\\"10.7.20.100\\\" end=\\\"10.7.25.100\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"specificv2c\\\">\\n\" + \n                \"       <specific>192.168.0.50<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"ipmatch\\\" max-vars-per-pdu=\\\"128\\\">\\n\" + \n                \"       <ip-match>77.5-12,15.1-255.255<\/ip-match>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"<\/snmp-config>\";\n    }","commit_id":"9b86ad1c3c4b4d3bd6813639b621c3329d1093f5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * String representing snmp-config.xml\n     */\n    public String getSnmpConfig() {\n        return \"<?xml version=\\\"1.0\\\"?>\\n\" + \n                \"<snmp-config \"+ \n                \" retry=\\\"3\\\" timeout=\\\"3000\\\"\\n\" + \n                \" read-community=\\\"public\\\"\" +\n                \" write-community=\\\"private\\\"\\n\" + \n                \" port=\\\"161\\\"\\n\" +\n                \" version=\\\"v1\\\">\\n\" +\n                \"\\n\" +\n                \"   <definition port=\\\"9161\\\" version=\\\"\"+myVersion()+\"\\\" \" +\n                \"       security-name=\\\"opennmsUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" \\n\" +\n                \"       privacy-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <specific>\"+myLocalHost()+\"<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\">\\n\" + \n                \"       <specific>10.0.0.1<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\" max-request-size=\\\"434\\\">\\n\" + \n                \"       <specific>10.0.0.2<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\" proxy-host=\\\"127.0.0.1\\\">\\n\" + \n                \"       <specific>10.0.0.3<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v3\\\" \" +\n                \"       security-name=\\\"opennmsUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <specific>20.20.20.20<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"   <definition version=\\\"v3\\\" \" +\n                \"       security-name=\\\"opennmsRangeUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <range begin=\\\"1.1.1.1\\\" end=\\\"1.1.1.100\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"rangev1\\\" max-vars-per-pdu=\\\"55\\\"> \\n\" + \n                \"       <range begin=\\\"10.0.0.101\\\" end=\\\"10.0.0.200\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"rangev2c\\\">\\n\" + \n                \"       <range begin=\\\"10.0.1.100\\\" end=\\\"10.0.5.100\\\"/>\\n\" +\n                \"       <range begin=\\\"10.7.20.100\\\" end=\\\"10.7.25.100\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"specificv2c\\\">\\n\" + \n                \"       <specific>192.168.0.50<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"ipmatch\\\" max-vars-per-pdu=\\\"128\\\">\\n\" + \n                \"       <ip-match>77.5-12,15.1-255.255<\/ip-match>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"<\/snmp-config>\";\n    }","id":43079,"modified_method":"/**\n     * String representing snmp-config.xml\n     */\n    public String getSnmpConfig() {\n        return \"<?xml version=\\\"1.0\\\"?>\\n\" + \n                \"<snmp-config \"+ \n                \" retry=\\\"3\\\" timeout=\\\"3000\\\"\\n\" + \n                \" read-community=\\\"public\\\"\" +\n                \" write-community=\\\"private\\\"\\n\" + \n                \" port=\\\"161\\\"\\n\" +\n                \" version=\\\"v1\\\">\\n\" +\n                \"\\n\" +\n                \"   <definition port=\\\"9161\\\" version=\\\"\"+myVersion()+\"\\\" \" +\n                \"       security-name=\\\"opennmsUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" \\n\" +\n                \"       privacy-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <specific>\"+myLocalHost()+\"<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\">\\n\" + \n                \"       <specific>10.0.0.1<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\" max-request-size=\\\"434\\\">\\n\" + \n                \"       <specific>10.0.0.2<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"specificv1\\\" proxy-host=\\\"\"+myLocalHost()+\"\\\">\\n\" + \n                \"       <specific>10.0.0.3<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v3\\\" \" +\n                \"       security-name=\\\"opennmsUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <specific>20.20.20.20<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"   <definition version=\\\"v3\\\" \" +\n                \"       security-name=\\\"opennmsRangeUser\\\" \\n\" + \n                \"       auth-passphrase=\\\"0p3nNMSv3\\\" >\\n\" +\n                \"       <range begin=\\\"1.1.1.1\\\" end=\\\"1.1.1.100\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v1\\\" read-community=\\\"rangev1\\\" max-vars-per-pdu=\\\"55\\\"> \\n\" + \n                \"       <range begin=\\\"10.0.0.101\\\" end=\\\"10.0.0.200\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"rangev2c\\\">\\n\" + \n                \"       <range begin=\\\"10.0.1.100\\\" end=\\\"10.0.5.100\\\"/>\\n\" +\n                \"       <range begin=\\\"10.7.20.100\\\" end=\\\"10.7.25.100\\\"/>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"specificv2c\\\">\\n\" + \n                \"       <specific>192.168.0.50<\/specific>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"   <definition version=\\\"v2c\\\" read-community=\\\"ipmatch\\\" max-vars-per-pdu=\\\"128\\\">\\n\" + \n                \"       <ip-match>77.5-12,15.1-255.255<\/ip-match>\\n\" +\n                \"   <\/definition>\\n\" + \n                \"\\n\" + \n                \"<\/snmp-config>\";\n    }","commit_id":"4d68007c929ca75a40c1f2f6576655020f28830c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n        MockUtil.println(\"------------ Begin Test \"+getName()+\" --------------------------\");\n        MockLogAppender.setupLogging();\n        \n        if (m_runSupers) {\n        \n            m_network = new MockNetwork();\n            m_network.setCriticalService(\"ICMP\");\n            m_network.addNode(1, \"Router\");\n            m_network.addInterface(\"192.168.1.1\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"SMTP\");\n            m_network.addInterface(\"192.168.1.2\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"SMTP\");\n            m_network.addNode(2, \"Server\");\n            m_network.addInterface(\"192.168.1.3\");\n            m_network.addService(\"ICMP\");\n            m_network.addService(\"HTTP\");\n            m_network.addNode(3, \"Firewall\");\n            m_network.addInterface(\"192.168.1.4\");\n            m_network.addService(\"SMTP\");\n            m_network.addService(\"HTTP\");\n            m_network.addInterface(\"192.168.1.5\");\n            m_network.addService(\"SMTP\");\n            m_network.addService(\"HTTP\");\n            \n            m_db = new MockDatabase();\n            m_db.populate(m_network);\n            \n            DataSourceFactory.setInstance(m_db);\n\n            Reader rdr = new StringReader(getSnmpConfig());\n            SnmpPeerFactory.setInstance(new SnmpPeerFactory(rdr));\n            \n            if (isStartEventd()) {\n                m_eventd = new Eventd();\n                m_eventd.setDataSource(m_db);\n                m_eventdConfigMgr = new MockEventConfigManager(MOCK_EVENT_CONFIG);\n                m_eventd.setConfigManager(m_eventdConfigMgr);\n                \n                \n                Reader configRdr = new StringReader(MOCK_EVENT_CONF);\n                EventConfigurationManager.loadConfiguration(configRdr);\n                \n                \n                m_eventdIpcMgr = new EventIpcManagerDefaultImpl(m_eventdConfigMgr);\n                m_eventProxy = new EventProxy() {\n\n                    public void send(Event event) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(event);\n                    }\n\n                    public void send(Log eventLog) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(eventLog);\n                    }\n                    \n                };\n                \n                EventIpcManagerFactory.setIpcManager(m_eventdIpcMgr);\n                m_eventd.setEventIpcManager(m_eventdIpcMgr);\n                m_eventd.init();\n                m_eventd.start();\n            }\n        \n        }\n\n    }","id":43080,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n        MockUtil.println(\"------------ Begin Test \"+getName()+\" --------------------------\");\n        MockLogAppender.setupLogging();\n        \n        if (m_runSupers) {\n        \n            createMockNetwork();\n            \n            populateDatabase();\n            \n            DataSourceFactory.setInstance(m_db);\n\n            Reader rdr = new StringReader(getSnmpConfig());\n            SnmpPeerFactory.setInstance(new SnmpPeerFactory(rdr));\n            \n            if (isStartEventd()) {\n                m_eventd = new Eventd();\n                m_eventd.setDataSource(m_db);\n                m_eventdConfigMgr = new MockEventConfigManager(MOCK_EVENT_CONFIG);\n                m_eventd.setConfigManager(m_eventdConfigMgr);\n                \n                \n                Reader configRdr = new StringReader(MOCK_EVENT_CONF);\n                EventConfigurationManager.loadConfiguration(configRdr);\n                \n                \n                m_eventdIpcMgr = new EventIpcManagerDefaultImpl(m_eventdConfigMgr);\n                m_eventProxy = new EventProxy() {\n\n                    public void send(Event event) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(event);\n                    }\n\n                    public void send(Log eventLog) throws EventProxyException {\n                        m_eventdIpcMgr.sendNow(eventLog);\n                    }\n                    \n                };\n                \n                EventIpcManagerFactory.setIpcManager(m_eventdIpcMgr);\n                m_eventd.setEventIpcManager(m_eventdIpcMgr);\n                m_eventd.init();\n                m_eventd.start();\n            }\n        \n        }\n\n    }","commit_id":"4d68007c929ca75a40c1f2f6576655020f28830c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void tearDown() throws Exception {\n        super.tearDown();\n        MockUtil.println(\"Sleeping for \"+m_tearDownWaitMillis+\" millis in tearDown...\");\n        Thread.sleep(m_tearDownWaitMillis);\n    }","id":43081,"modified_method":"protected void tearDown() throws Exception {\n        super.tearDown();\n        MockUtil.println(\"Sleeping for \"+TEAR_DOWN_WAIT_MILLIS+\" millis in tearDown...\");\n        Thread.sleep(TEAR_DOWN_WAIT_MILLIS);\n    }","commit_id":"032c6a691de9e6cbe1c43620a90f9a62fc2e6221","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() throws Exception {\n        \n        super.setUp();\n        Reader rdr = new StringReader(VACUUMD_CONFIG);\n        VacuumdConfigFactory.setInstance(new VacuumdConfigFactory(rdr));\n        m_vacuumd = Vacuumd.getSingleton();\n        m_vacuumd.setEventManager(m_eventdIpcMgr);\n        m_vacuumd.init();\n        \n        //The rdr is closed by init, too, but doesn't hurt\n        rdr.close();\n\n        MockUtil.println(\"------------ Finished setup for: \"+getName()+\" --------------------------\");\n        \n    }","id":43082,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n        \n        Reader rdr = ConfigurationTestUtils.getReaderForResource(this, \"/org/opennms/netmgt/vacuumd/vacuumd-configuration.xml\");\n        try {\n            VacuumdConfigFactory.setInstance(new VacuumdConfigFactory(rdr));\n        } finally {\n            IOUtils.closeQuietly(rdr);\n        }\n\n        m_vacuumd = Vacuumd.getSingleton();\n        m_vacuumd.setEventManager(m_eventdIpcMgr);\n        m_vacuumd.init();\n\n        MockUtil.println(\"------------ Finished setup for: \"+getName()+\" --------------------------\");\n    }","commit_id":"032c6a691de9e6cbe1c43620a90f9a62fc2e6221","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void tearDown() throws Exception {\n        super.tearDown();\n        MockUtil.println(\"Sleeping for \"+m_tearDownWaitMillis+\" millis in tearDown...\");\n        Thread.sleep(m_tearDownWaitMillis);\n    }","id":43083,"modified_method":"protected void tearDown() throws Exception {\n        super.tearDown();\n        MockUtil.println(\"Sleeping for \"+TEAR_DOWN_WAIT_MILLIS+\" millis in tearDown...\");\n        Thread.sleep(TEAR_DOWN_WAIT_MILLIS);\n    }","commit_id":"96e47d055ca78eb84f671a92c90ed1c0e77c6611","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() throws Exception {\n        \n        super.setUp();\n        Reader rdr = new StringReader(VACUUMD_CONFIG);\n        VacuumdConfigFactory.setInstance(new VacuumdConfigFactory(rdr));\n        m_vacuumd = Vacuumd.getSingleton();\n        m_vacuumd.setEventManager(m_eventdIpcMgr);\n        m_vacuumd.init();\n        \n        //The rdr is closed by init, too, but doesn't hurt\n        rdr.close();\n\n        MockUtil.println(\"------------ Finished setup for: \"+getName()+\" --------------------------\");\n        \n    }","id":43084,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n        \n        Reader rdr = ConfigurationTestUtils.getReaderForResource(this, \"/org/opennms/netmgt/vacuumd/vacuumd-configuration.xml\");\n        try {\n            VacuumdConfigFactory.setInstance(new VacuumdConfigFactory(rdr));\n        } finally {\n            IOUtils.closeQuietly(rdr);\n        }\n\n        m_vacuumd = Vacuumd.getSingleton();\n        m_vacuumd.setEventManager(m_eventdIpcMgr);\n        m_vacuumd.init();\n\n        MockUtil.println(\"------------ Finished setup for: \"+getName()+\" --------------------------\");\n    }","commit_id":"96e47d055ca78eb84f671a92c90ed1c0e77c6611","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getFrameLabel()\n   {\n      if (frame_.getShinyFunctionLabel().isEmpty())\n      {\n         return frame_.getFunctionName() +\n                \"(\" + frame_.getArgumentList() + \")\";\n      }\n      else\n      {\n         return \"[Shiny: \" + frame_.getShinyFunctionLabel() + \"]\";\n      }\n         \n   }","id":43085,"modified_method":"private String getFrameLabel()\n   {\n      if (frame_.getShinyFunctionLabel().isEmpty())\n      {\n         String functionName = frame_.getFunctionName();\n         // Don't show the argument list for the debug source function\n         if (!functionName.equals(\"[Debug source]\"))\n            functionName += \"(\" + frame_.getArgumentList() + \")\";\n         return functionName;\n      }\n      else\n      {\n         return \"[Shiny: \" + frame_.getShinyFunctionLabel() + \"]\";\n      }\n         \n   }","commit_id":"df8283ef7ea884aa9151f3e8c2c1c3f575d144c3","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public CodeSearch(Display display, \n                     final Session session, \n                     final FileTypeRegistry fileTypeRegistry,\n                     final EventBus eventBus)\n   {\n      display_ = display;\n      \n      display_.getSearchDisplay().addSelectionHandler(\n                                    new SelectionHandler<Suggestion>() {\n\n         @Override\n         public void onSelection(SelectionEvent<Suggestion> event)\n         {\n            // map back to a code search result\n            CodeSearchResult result = \n               display_.getSearchOracle().resultFromSuggestion(\n                                                event.getSelectedItem());\n            \n            // get the active project directory\n            SessionInfo sessionInfo = session.getSessionInfo();\n            FileSystemItem projDir = sessionInfo.getActiveProjectDir(); \n            \n            // calculate full file path and position\n            String srcFile = projDir.completePath(result.getContext());\n            FileSystemItem srcFileItem = FileSystemItem.createFile(srcFile);\n            FilePosition pos = FilePosition.create(result.getLine(), \n                                                   result.getColumn());\n            \n            // fire editing event\n            fileTypeRegistry.editFile(srcFileItem, pos);\n         }\n         \n      });\n   }","id":43086,"modified_method":"@Inject\n   public CodeSearch(Display display, \n                     final Session session, \n                     final FileTypeRegistry fileTypeRegistry,\n                     final EventBus eventBus)\n   {\n      display_ = display;\n      \n      SearchDisplay searchDisplay = display_.getSearchDisplay();\n      searchDisplay.setAutoSelectEnabled(true);\n      \n      searchDisplay.addSelectionHandler(new SelectionHandler<Suggestion>() {\n\n         @Override\n         public void onSelection(SelectionEvent<Suggestion> event)\n         {\n            // map back to a code search result\n            CodeSearchResult result = \n               display_.getSearchOracle().resultFromSuggestion(\n                                                event.getSelectedItem());\n            \n            // get the active project directory\n            SessionInfo sessionInfo = session.getSessionInfo();\n            FileSystemItem projDir = sessionInfo.getActiveProjectDir(); \n            \n            // calculate full file path and position\n            String srcFile = projDir.completePath(result.getContext());\n            FileSystemItem srcFileItem = FileSystemItem.createFile(srcFile);\n            FilePosition pos = FilePosition.create(result.getLine(), \n                                                   result.getColumn());\n            \n            // fire editing event\n            fileTypeRegistry.editFile(srcFileItem, pos);\n         }\n         \n      });\n   }","commit_id":"3720bf186ff1420303c0f9bb3e1eafeffccc0688","url":"https://github.com/rstudio/rstudio"},{"original_method":"public CodeSearchResult resultFromSuggestion(Suggestion suggestion)\n   {\n      int index = lastSuggestions_.indexOf(suggestion);\n      if (index != -1)\n         return lastSuggestions_.get(index).getResult();\n      else\n         return null;\n   }","id":43087,"modified_method":"public CodeSearchResult resultFromSuggestion(Suggestion suggestion)\n   {\n      return ((SearchSuggestion)suggestion).getResult();\n   }","commit_id":"3720bf186ff1420303c0f9bb3e1eafeffccc0688","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void requestSuggestions(final Request request, \n                                  final Callback callback)\n   {\n      String query = request.getQuery() ;\n      \n      lastQuery_ = query;\n      \n      server_.searchCode(\n            query,\n            new SimpleRequestCallback<JsArray<CodeSearchResult>>() {\n         \n         @Override\n         public void onResponseReceived(JsArray<CodeSearchResult> results)\n         {\n            int maxCount = Math.min(results.length(), request.getLimit());\n\n            lastSuggestions_.clear();\n            for (int i = 0; i< maxCount; i++)\n               lastSuggestions_.add(new SearchSuggestion(results.get(i))) ;\n            \n            callback.onSuggestionsReady(request, new Response(lastSuggestions_)) ;\n         }\n      }); ;\n   }","id":43088,"modified_method":"@Override\n   public void requestSuggestions(final Request request, \n                                  final Callback callback)\n   {\n      final CodeSearchResources.Styles styles = \n         CodeSearchResources.INSTANCE.styles();\n      \n      String query = request.getQuery() ;\n      \n      lastQuery_ = query;\n      \n      server_.searchCode(\n            query,\n            new SimpleRequestCallback<JsArray<CodeSearchResult>>() {\n         \n         @Override\n         public void onResponseReceived(JsArray<CodeSearchResult> results)\n         {\n            int maxCount = Math.min(results.length(), request.getLimit());\n\n            int maxNameChars = 0;\n            maxNameWidth_ = 0;\n            \n            lastSuggestions_.clear();\n            for (int i = 0; i< maxCount; i++)\n            {   \n               String name = results.get(i).getFunctionName();\n               if (name.length() > maxNameChars)\n               {\n                  Size size = DomMetrics.measureHTML(name, styles.functionName());\n                  if (size.width > maxNameWidth_)\n                  {\n                     maxNameWidth_ = size.width;\n                     maxNameChars = name.length();\n                  }\n               }\n               \n               \n               lastSuggestions_.add(new SearchSuggestion(results.get(i))) ;\n               \n            }\n            \n            \n            \n            callback.onSuggestionsReady(request, new Response(lastSuggestions_)) ;\n         }\n      }); ;\n   }","commit_id":"3720bf186ff1420303c0f9bb3e1eafeffccc0688","url":"https://github.com/rstudio/rstudio"},{"original_method":"public String getDisplayString()\n      {\n         return result_.getFunctionName();\n      }","id":43089,"modified_method":"public String getDisplayString()\n      {\n         CodeSearchResources.Styles styles = CodeSearchResources.INSTANCE.styles();\n         \n         SafeHtmlBuilder sb = new SafeHtmlBuilder();\n         appendSpan(sb, result_.getFunctionName(), styles.functionName());                   \n         appendSpan(sb, result_.getContext(), styles.functionContext());\n         return sb.toSafeHtml().asString();\n      }","commit_id":"3720bf186ff1420303c0f9bb3e1eafeffccc0688","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public CodeSearchWidget(CodeSearchOracle oracle)\n   {\n      super(oracle);\n      oracle_ = oracle;      \n   }","id":43090,"modified_method":"@Inject\n   public CodeSearchWidget(CodeSearchOracle oracle)\n   {\n      super(oracle, new CodeSearchSuggestionDisplay());\n      oracle_ = oracle;      \n   }","commit_id":"3720bf186ff1420303c0f9bb3e1eafeffccc0688","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void load(final Command dismissProgressAnimation)\n   {\n      ThemeResources.INSTANCE.themeStyles().ensureInjected();\n      CoreResources.INSTANCE.styles().ensureInjected();\n      StudioResources.INSTANCE.styles().ensureInjected();\n      ConsoleResources.INSTANCE.consoleStyles().ensureInjected();\n      FileDialogResources.INSTANCE.styles().ensureInjected();\n      ManipulatorResources.INSTANCE.manipulatorStyles().ensureInjected();\n      PackagesCellTableResources.INSTANCE.cellTableStyle().ensureInjected();\n      FilesListCellTableResources.INSTANCE.cellTableStyle().ensureInjected();\n      ExportPlotResources.INSTANCE.styles().ensureInjected();\n      \n      SupportPopupMenu.ensureStylesInjected();\n      SlideLabel.ensureStylesInjected();\n      ThemedButton.ensureStylesInjected();\n      ThemedPopupPanel.ensureStylesInjected();\n      InstallPackageDialog.ensureStylesInjected();\n      PublishPdfDialog.ensureStylesInjected();\n      ApplicationEndedPopupPanel.ensureStylesInjected();\n      ApplicationSerializationProgress.ensureStylesInjected();\n      HistoryPane.ensureStylesInjected();\n      Shelf.ensureStylesInjected();\n      ImportFileSettingsDialog.ensureStylesInjected();\n      ImportGoogleSpreadsheetDialog.ensureStylesInjected();\n      FindReplaceBar.ensureStylesInjected();\n      FontSizer.ensureStylesInjected();\n      PreferencesDialog.ensureStylesInjected();\n      LinkColumn.ensureStylesInjected();\n      CheckForUpdatesDialog.ensureStylesInjected();\n      UnsavedChangesDialog.ensureStylesInjected();\n      ChooseMirrorDialog.ensureStylesInjected();\n      ResizeGripper.ensureStylesInjected();\n      LineTableView.ensureStylesInjected();\n      ProjectOptionsDialog.ensureStylesInjected();\n      NewProjectDialog.ensureStylesInjected();\n\n      StyleInjector.inject(\n            \"button::-moz-focus-inner {border:0}\");\n\n      RStudioGinjector.INSTANCE.getApplication().go(RootLayoutPanel.get(),\n                                                    dismissProgressAnimation);\n   }","id":43091,"modified_method":"private void load(final Command dismissProgressAnimation)\n   {\n      ThemeResources.INSTANCE.themeStyles().ensureInjected();\n      CoreResources.INSTANCE.styles().ensureInjected();\n      StudioResources.INSTANCE.styles().ensureInjected();\n      ConsoleResources.INSTANCE.consoleStyles().ensureInjected();\n      FileDialogResources.INSTANCE.styles().ensureInjected();\n      ManipulatorResources.INSTANCE.manipulatorStyles().ensureInjected();\n      PackagesCellTableResources.INSTANCE.cellTableStyle().ensureInjected();\n      FilesListCellTableResources.INSTANCE.cellTableStyle().ensureInjected();\n      ExportPlotResources.INSTANCE.styles().ensureInjected();\n      CodeSearchResources.INSTANCE.styles().ensureInjected();\n      \n      SupportPopupMenu.ensureStylesInjected();\n      SlideLabel.ensureStylesInjected();\n      ThemedButton.ensureStylesInjected();\n      ThemedPopupPanel.ensureStylesInjected();\n      InstallPackageDialog.ensureStylesInjected();\n      PublishPdfDialog.ensureStylesInjected();\n      ApplicationEndedPopupPanel.ensureStylesInjected();\n      ApplicationSerializationProgress.ensureStylesInjected();\n      HistoryPane.ensureStylesInjected();\n      Shelf.ensureStylesInjected();\n      ImportFileSettingsDialog.ensureStylesInjected();\n      ImportGoogleSpreadsheetDialog.ensureStylesInjected();\n      FindReplaceBar.ensureStylesInjected();\n      FontSizer.ensureStylesInjected();\n      PreferencesDialog.ensureStylesInjected();\n      LinkColumn.ensureStylesInjected();\n      CheckForUpdatesDialog.ensureStylesInjected();\n      UnsavedChangesDialog.ensureStylesInjected();\n      ChooseMirrorDialog.ensureStylesInjected();\n      ResizeGripper.ensureStylesInjected();\n      LineTableView.ensureStylesInjected();\n      ProjectOptionsDialog.ensureStylesInjected();\n      NewProjectDialog.ensureStylesInjected();\n\n      StyleInjector.inject(\n            \"button::-moz-focus-inner {border:0}\");\n\n      RStudioGinjector.INSTANCE.getApplication().go(RootLayoutPanel.get(),\n                                                    dismissProgressAnimation);\n   }","commit_id":"3720bf186ff1420303c0f9bb3e1eafeffccc0688","url":"https://github.com/rstudio/rstudio"},{"original_method":"public SearchWidget(SuggestOracle oracle)\n   {\n      suggestBox_ = new FocusSuggestBox(oracle);\n      initWidget(uiBinder.createAndBindUi(this));\n      close_.setVisible(false);\n\n      ThemeStyles styles = ThemeResources.INSTANCE.themeStyles();\n\n      suggestBox_.setStylePrimaryName(styles.searchBox());\n      suggestBox_.setAutoSelectEnabled(false) ;\n      suggestBox_.addKeyDownHandler(new KeyDownHandler() {\n         public void onKeyDown(KeyDownEvent event)\n         {\n            switch (event.getNativeKeyCode())\n            {\n            case KeyCodes.KEY_ENTER:\n               Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n                  public void execute()\n                  {\n                     SelectionCommitEvent.fire(SearchWidget.this, \n                                               suggestBox_.getText()) ;\n                  }\n               }) ;\n               break ;\n            case KeyCodes.KEY_ESCAPE:\n               suggestBox_.setText(\"\") ;\n               break ;\n            }\n         }\n      }) ;\n\n      // Unlike SuggestBox's ValueChangeEvent impl, we want the\n      // event to fire as soon as the value changes\n      suggestBox_.addKeyUpHandler(new KeyUpHandler() {\n         public void onKeyUp(KeyUpEvent event)\n         {\n            String value = suggestBox_.getText();\n            if (!value.equals(lastValueSent_))\n            {\n               updateLastValue(value);\n               ValueChangeEvent.fire(SearchWidget.this, value);\n            }\n         }\n      });\n      suggestBox_.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n         public void onValueChange(ValueChangeEvent<String> evt)\n         {\n            if (!evt.getValue().equals(lastValueSent_))\n            {\n               updateLastValue(evt.getValue());\n               delegateEvent(SearchWidget.this, evt);\n            }\n         }\n      });\n\n      close_.addMouseDownHandler(new MouseDownHandler()\n      {\n         public void onMouseDown(MouseDownEvent event)\n         {\n            event.preventDefault();\n            \n            suggestBox_.setText(\"\");\n            ValueChangeEvent.fire(suggestBox_, \"\");\n         }\n      });\n   }","id":43092,"modified_method":"public SearchWidget(SuggestOracle oracle)\n   {\n      this(oracle, null);\n   }","commit_id":"3720bf186ff1420303c0f9bb3e1eafeffccc0688","url":"https://github.com/rstudio/rstudio"},{"original_method":"private String getFrameLabel()\n   {\n      if (frame_.getShinyFunctionLabel().isEmpty())\n      {\n         String functionName = frame_.getFunctionName();\n         // Don't show the argument list for the debug source function\n         if (!functionName.equals(\"[Debug source]\"))\n            functionName += \"(\" + frame_.getArgumentList() + \")\";\n         return functionName;\n      }\n      else\n      {\n         return \"[Shiny: \" + frame_.getShinyFunctionLabel() + \"]\";\n      }\n         \n   }","id":43093,"modified_method":"private String getFrameLabel()\n   {\n      if (frame_.isSourceEquiv())\n      {\n         return \"[Debug source]\";\n      }\n      if (frame_.getShinyFunctionLabel().isEmpty())\n      {\n         return frame_.getFunctionName() + \"(\" + frame_.getArgumentList() + \")\";\n      }\n      else\n      {\n         return \"[Shiny: \" + frame_.getShinyFunctionLabel() + \"]\";\n      }\n   }","commit_id":"61936c9b760b6c772f34145e8e17aeff571aec5e","url":"https://github.com/rstudio/rstudio"},{"original_method":"public CallFrameItem(CallFrame frame, \n                        EnvironmentObjectsObserver observer, boolean hidden)\n   {\n      isActive_ = false;\n      isVisible_ = true;\n      observer_ = observer;\n      frame_ = frame;\n      initWidget(GWT.<Binder>create(Binder.class).createAndBindUi(this));\n      functionName.addClickHandler(this);\n      if (!frame.isNavigable())\n      {\n         functionName.addStyleName(style.noSourceFrame());\n         \n         // hide call frames for which we don't have usable sources--but leave\n         // them in the DOM (we may want to easily show/hide these at the user's\n         // request)\n         if (hidden)\n         {\n            functionName.addStyleName(style.hiddenFrame());\n            isVisible_ = false;\n         }\n      }\n      setDisplayText(frame_.getLineNumber());\n      \n      FontSizer.applyNormalFontSize(this);\n   }","id":43094,"modified_method":"public CallFrameItem(CallFrame frame, \n                        EnvironmentObjectsObserver observer, boolean hidden)\n   {\n      isActive_ = false;\n      isVisible_ = true;\n      observer_ = observer;\n      frame_ = frame;\n      initWidget(GWT.<Binder>create(Binder.class).createAndBindUi(this));\n      functionName.addClickHandler(this);\n      if (!frame.isNavigable() || hidden)\n      {\n         functionName.addStyleName(style.noSourceFrame());\n         \n         // hide call frames for which we don't have usable sources--but leave\n         // them in the DOM (we may want to easily show/hide these at the user's\n         // request)\n         if (hidden)\n         {\n            functionName.addStyleName(style.hiddenFrame());\n            isVisible_ = false;\n         }\n      }\n      setDisplayText(frame_.getLineNumber());\n      \n      FontSizer.applyNormalFontSize(this);\n   }","commit_id":"61936c9b760b6c772f34145e8e17aeff571aec5e","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void setCallFrames(JsArray<CallFrame> frameList, int contextDepth)\n   {\n      clearCallFrames();\n      \n      // Check to see whether every function on the stack is internal. \n      // If it is, the traceback window may appear empty, so show everything\n      // to give the user some context.\n      boolean allInternal = true;\n      for (int idx = 0; idx < frameList.length(); idx++)\n      {\n         if (frameList.get(idx).isNavigable()) {\n            allInternal = false;\n            break;\n         }\n      }\n      \n      for (int idx = frameList.length() - 1; idx >= 0; idx--)\n      {\n         CallFrame frame = frameList.get(idx);\n         // Always show the first frame, since that's where execution is \n         // actually halted. From the remaining frames, show them if they are\n         // \"navigable\" (user) frames, or if the user has elected to show all\n         // frames.\n         CallFrameItem item = new CallFrameItem(\n               frame, \n               observer_, \n               !panelHost_.getShowInternalFunctions() && \n                  !frame.isNavigable() &&\n                  !allInternal && \n                  idx > 0);\n         if (contextDepth == frame.getContextDepth())\n         {\n            item.setActive();\n         }\n         callFrameItems_.add(item);\n      }\n      \n      // now walk forwards through the frames and add each to the UI\n      Collections.reverse(callFrameItems_);\n      for (CallFrameItem item: callFrameItems_)\n      {\n         callFramePanel.add(item);\n      }\n      \n   }","id":43095,"modified_method":"public void setCallFrames(JsArray<CallFrame> frameList, int contextDepth)\n   {\n      clearCallFrames();\n      \n      // Check to see whether every function on the stack is internal. \n      // If it is, the traceback window may appear empty, so show everything\n      // to give the user some context.\n      boolean allInternal = true;\n      int idxSourceEquiv = -1;\n      for (int idx = 0; idx < frameList.length(); idx++)\n      {\n         CallFrame frame = frameList.get(idx);\n         if (frame.isNavigable()) {\n            allInternal = false;\n         }\n         if (frame.isSourceEquiv())\n            idxSourceEquiv = idx;\n      }\n      \n      for (int idx = frameList.length() - 1; idx >= 0; idx--)\n      {\n         CallFrame frame = frameList.get(idx);\n         // Always show the first frame, since that's where execution is \n         // actually halted. From the remaining frames, show them if they are\n         // \"navigable\" (user) frames, or if the user has elected to show all\n         // frames.\n         CallFrameItem item = new CallFrameItem(\n               frame, \n               observer_, \n               !panelHost_.getShowInternalFunctions() && \n                  ((!frame.isNavigable()) || idx > idxSourceEquiv) &&\n                  !allInternal &&\n                  idx > 0);\n         if (contextDepth == frame.getContextDepth())\n         {\n            item.setActive();\n         }\n         callFrameItems_.add(item);\n      }\n      \n      // now walk forwards through the frames and add each to the UI\n      Collections.reverse(callFrameItems_);\n      for (CallFrameItem item: callFrameItems_)\n      {\n         callFramePanel.add(item);\n      }\n   }","commit_id":"61936c9b760b6c772f34145e8e17aeff571aec5e","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void put(String index, String type, String id, BytesStream source) {\n    client.prepareIndex(index, type, id).setSource(source.bytes()).execute();\n  }","id":43096,"modified_method":"public void put(String index, String type, String id, BytesStream source) {\n    client.prepareIndex(index, type, id).setSource(source.bytes()).execute().actionGet();\n  }","commit_id":"7569d68ee31cd13d69c883571b9782d3c37b9841","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addMapping(String index, String type, String mapping) {\n    IndicesAdminClient indices = client.admin().indices();\n    try {\n      if (! indices.exists(new IndicesExistsRequest(index)).get().isExists()) {\n        indices.prepareCreate(index).get();\n      }\n    } catch (Exception e) {\n      LOG.error(\"While checking for index existence\", e);\n    }\n    indices.preparePutMapping(index).setType(type).setSource(mapping).execute();\n  }","id":43097,"modified_method":"private void addMapping(String index, String type, String mapping) {\n    IndicesAdminClient indices = client.admin().indices();\n    try {\n      if (! indices.exists(new IndicesExistsRequest(index)).get().isExists()) {\n        indices.prepareCreate(index).execute().actionGet();\n      }\n    } catch (Exception e) {\n      LOG.error(\"While checking for index existence\", e);\n    }\n    indices.putMapping(Requests.putMappingRequest(index).type(type).source(mapping)).actionGet();\n  }","commit_id":"7569d68ee31cd13d69c883571b9782d3c37b9841","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void put(String index, String type, String id, BytesStream source, String parent) {\n    client.prepareIndex(index, type, id).setParent(parent).setSource(source.bytes()).execute();\n  }","id":43098,"modified_method":"public void put(String index, String type, String id, BytesStream source, String parent) {\n    client.prepareIndex(index, type, id).setParent(parent).setSource(source.bytes()).execute().actionGet();\n  }","commit_id":"7569d68ee31cd13d69c883571b9782d3c37b9841","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SearchResponse find(SearchQuery query) {\n    return query.toBuilder(client).get();\n  }","id":43099,"modified_method":"public SearchResponse find(SearchQuery query) {\n    return query.toBuilder(client).execute().actionGet();\n  }","commit_id":"7569d68ee31cd13d69c883571b9782d3c37b9841","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void stats(String index) {\n    LOG.info(\n      String.format(\n        \"Index %s contains %d elements\", index,\n        client.prepareSearch(index).setQuery(QueryBuilders.matchAllQuery()).get().getHits().totalHits()));\n  }","id":43100,"modified_method":"public void stats(String index) {\n    LOG.info(\n      String.format(\n        \"Index %s contains %d elements\", index,\n        client.prepareSearch(index).setQuery(QueryBuilders.matchAllQuery()).execute().actionGet().getHits().totalHits()));\n  }","commit_id":"7569d68ee31cd13d69c883571b9782d3c37b9841","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@org.junit.Test\n    public void testRESTResourceTruncatedURI() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        MessageImpl msg = new MessageImpl();\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        String resourceURI = \"/doubleit\";\n        msg.put(Message.REQUEST_URI, resourceURI);\n        \n        XACMLRequestBuilder builder = new OpenSAMLXACMLRequestBuilder();\n        ((OpenSAMLXACMLRequestBuilder)builder).setSendFullRequestURL(false);\n        RequestType request = \n            (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        \n        List<ResourceType> resources = request.getResources();\n        assertNotNull(resources);\n        assertEquals(1, resources.size());\n        \n        ResourceType resource = resources.get(0);\n        assertEquals(1, resource.getAttributes().size());\n        \n        for (AttributeType attribute : resource.getAttributes()) {\n            String attributeValue = attribute.getAttributeValues().get(0).getValue();\n            assertEquals(attributeValue, resourceURI);\n        }\n    }","id":43101,"modified_method":"@org.junit.Test\n    public void testRESTResourceTruncatedURI() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        MessageImpl msg = new MessageImpl();\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        String resourceURI = \"/doubleit\";\n        msg.put(Message.REQUEST_URI, resourceURI);\n        \n        XACMLRequestBuilder builder = new DefaultXACMLRequestBuilder();\n        ((DefaultXACMLRequestBuilder)builder).setSendFullRequestURL(false);\n        RequestType request = \n            builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        \n        List<ResourceType> resources = request.getResources();\n        assertNotNull(resources);\n        assertEquals(1, resources.size());\n        \n        ResourceType resource = resources.get(0);\n        assertEquals(1, resource.getAttributes().size());\n        \n        for (AttributeType attribute : resource.getAttributes()) {\n            String attributeValue = attribute.getAttributeValues().get(0).getValue();\n            assertEquals(attributeValue, resourceURI);\n        }\n    }","commit_id":"280487512eb1c34a6c05bcfe3e2e182388359a25","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSOAPResource() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleIt}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        \n        XACMLRequestBuilder builder = new OpenSAMLXACMLRequestBuilder();\n        RequestType request = \n            (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        \n        List<ResourceType> resources = request.getResources();\n        assertNotNull(resources);\n        assertEquals(1, resources.size());\n        \n        ResourceType resource = resources.get(0);\n        assertEquals(4, resource.getAttributes().size());\n        \n        boolean resourceIdSatisfied = false;\n        boolean soapServiceSatisfied = false;\n        boolean soapOperationSatisfied = false;\n        boolean resourceURISatisfied = false;\n        for (AttributeType attribute : resource.getAttributes()) {\n            String attributeValue = attribute.getAttributeValues().get(0).getValue();\n            if (XACMLConstants.RESOURCE_ID.equals(attribute.getAttributeId())\n                && \"{http://www.example.org/contract/DoubleIt}DoubleItService#DoubleIt\".equals(\n                    attributeValue)) {\n                resourceIdSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_SERVICE_ID.equals(attribute.getAttributeId())\n                && service.equals(attributeValue)) {\n                soapServiceSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_OPERATION_ID.equals(attribute.getAttributeId())\n                && operation.equals(attributeValue)) {\n                soapOperationSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_ENDPOINT.equals(attribute.getAttributeId())\n                && resourceURL.equals(attributeValue)) {\n                resourceURISatisfied = true;\n            }\n        }\n        \n        assertTrue(resourceIdSatisfied && soapServiceSatisfied && soapOperationSatisfied\n                   && resourceURISatisfied);\n    }","id":43102,"modified_method":"@org.junit.Test\n    public void testSOAPResource() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleIt}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        \n        XACMLRequestBuilder builder = new DefaultXACMLRequestBuilder();\n        RequestType request = \n            builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        \n        List<ResourceType> resources = request.getResources();\n        assertNotNull(resources);\n        assertEquals(1, resources.size());\n        \n        ResourceType resource = resources.get(0);\n        assertEquals(4, resource.getAttributes().size());\n        \n        boolean resourceIdSatisfied = false;\n        boolean soapServiceSatisfied = false;\n        boolean soapOperationSatisfied = false;\n        boolean resourceURISatisfied = false;\n        for (AttributeType attribute : resource.getAttributes()) {\n            String attributeValue = attribute.getAttributeValues().get(0).getValue();\n            if (XACMLConstants.RESOURCE_ID.equals(attribute.getAttributeId())\n                && \"{http://www.example.org/contract/DoubleIt}DoubleItService#DoubleIt\".equals(\n                    attributeValue)) {\n                resourceIdSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_SERVICE_ID.equals(attribute.getAttributeId())\n                && service.equals(attributeValue)) {\n                soapServiceSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_OPERATION_ID.equals(attribute.getAttributeId())\n                && operation.equals(attributeValue)) {\n                soapOperationSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_ENDPOINT.equals(attribute.getAttributeId())\n                && resourceURL.equals(attributeValue)) {\n                resourceURISatisfied = true;\n            }\n        }\n        \n        assertTrue(resourceIdSatisfied && soapServiceSatisfied && soapOperationSatisfied\n                   && resourceURISatisfied);\n    }","commit_id":"280487512eb1c34a6c05bcfe3e2e182388359a25","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testXACMLRequestBuilder() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleIt}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URI, resourceURL);\n        \n        XACMLRequestBuilder builder = new OpenSAMLXACMLRequestBuilder();\n        RequestType request = \n            (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n    }","id":43103,"modified_method":"@org.junit.Test\n    public void testXACMLRequestBuilder() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleIt}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URI, resourceURL);\n        \n        XACMLRequestBuilder builder = new DefaultXACMLRequestBuilder();\n        RequestType request = \n            builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n    }","commit_id":"280487512eb1c34a6c05bcfe3e2e182388359a25","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testRESTResource() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        MessageImpl msg = new MessageImpl();\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        \n        XACMLRequestBuilder builder = new OpenSAMLXACMLRequestBuilder();\n        RequestType request = \n            (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        \n        List<ResourceType> resources = request.getResources();\n        assertNotNull(resources);\n        assertEquals(1, resources.size());\n        \n        ResourceType resource = resources.get(0);\n        assertEquals(1, resource.getAttributes().size());\n        \n        for (AttributeType attribute : resource.getAttributes()) {\n            String attributeValue = attribute.getAttributeValues().get(0).getValue();\n            assertEquals(attributeValue, resourceURL);\n        }\n    }","id":43104,"modified_method":"@org.junit.Test\n    public void testRESTResource() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        MessageImpl msg = new MessageImpl();\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        \n        XACMLRequestBuilder builder = new DefaultXACMLRequestBuilder();\n        RequestType request = \n            builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        \n        List<ResourceType> resources = request.getResources();\n        assertNotNull(resources);\n        assertEquals(1, resources.size());\n        \n        ResourceType resource = resources.get(0);\n        assertEquals(1, resource.getAttributes().size());\n        \n        for (AttributeType attribute : resource.getAttributes()) {\n            String attributeValue = attribute.getAttributeValues().get(0).getValue();\n            assertEquals(attributeValue, resourceURL);\n        }\n    }","commit_id":"280487512eb1c34a6c05bcfe3e2e182388359a25","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testAction() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleIt}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URI, resourceURL);\n        \n        OpenSAMLXACMLRequestBuilder builder = new OpenSAMLXACMLRequestBuilder();\n        RequestType request = \n            (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request); \n        \n        String action = \n            request.getAction().getAttributes().get(0).getAttributeValues().get(0).getValue();\n        assertEquals(\"execute\", action);\n        \n        builder.setAction(\"write\");\n        request = (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request); \n        \n        action = \n            request.getAction().getAttributes().get(0).getAttributeValues().get(0).getValue();\n        assertEquals(\"write\", action);\n    }","id":43105,"modified_method":"@org.junit.Test\n    public void testAction() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleIt}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URI, resourceURL);\n        \n        DefaultXACMLRequestBuilder builder = new DefaultXACMLRequestBuilder();\n        RequestType request = \n            builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request); \n        \n        String action = \n            request.getAction().getAttributes().get(0).getAttributeValues().get(0).getValue();\n        assertEquals(\"execute\", action);\n        \n        builder.setAction(\"write\");\n        request = builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request); \n        \n        action = \n            request.getAction().getAttributes().get(0).getAttributeValues().get(0).getValue();\n        assertEquals(\"write\", action);\n    }","commit_id":"280487512eb1c34a6c05bcfe3e2e182388359a25","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSOAPResourceDifferentNamespace() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleItService}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        \n        XACMLRequestBuilder builder = new OpenSAMLXACMLRequestBuilder();\n        RequestType request = \n            (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        \n        List<ResourceType> resources = request.getResources();\n        assertNotNull(resources);\n        assertEquals(1, resources.size());\n        \n        ResourceType resource = resources.get(0);\n        assertEquals(4, resource.getAttributes().size());\n        \n        boolean resourceIdSatisfied = false;\n        boolean soapServiceSatisfied = false;\n        boolean soapOperationSatisfied = false;\n        boolean resourceURISatisfied = false;\n        String expectedResourceId = \n            service + \"#\" + operation;\n        for (AttributeType attribute : resource.getAttributes()) {\n            String attributeValue = attribute.getAttributeValues().get(0).getValue();\n            if (XACMLConstants.RESOURCE_ID.equals(attribute.getAttributeId())\n                && expectedResourceId.equals(attributeValue)) {\n                resourceIdSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_SERVICE_ID.equals(attribute.getAttributeId())\n                && service.equals(attributeValue)) {\n                soapServiceSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_OPERATION_ID.equals(attribute.getAttributeId())\n                && operation.equals(attributeValue)) {\n                soapOperationSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_ENDPOINT.equals(attribute.getAttributeId())\n                && resourceURL.equals(attributeValue)) {\n                resourceURISatisfied = true;\n            }\n        }\n        \n        assertTrue(resourceIdSatisfied && soapServiceSatisfied && soapOperationSatisfied\n                   && resourceURISatisfied);\n    }","id":43106,"modified_method":"@org.junit.Test\n    public void testSOAPResourceDifferentNamespace() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleItService}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        \n        XACMLRequestBuilder builder = new DefaultXACMLRequestBuilder();\n        RequestType request = \n            builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        \n        List<ResourceType> resources = request.getResources();\n        assertNotNull(resources);\n        assertEquals(1, resources.size());\n        \n        ResourceType resource = resources.get(0);\n        assertEquals(4, resource.getAttributes().size());\n        \n        boolean resourceIdSatisfied = false;\n        boolean soapServiceSatisfied = false;\n        boolean soapOperationSatisfied = false;\n        boolean resourceURISatisfied = false;\n        String expectedResourceId = \n            service + \"#\" + operation;\n        for (AttributeType attribute : resource.getAttributes()) {\n            String attributeValue = attribute.getAttributeValues().get(0).getValue();\n            if (XACMLConstants.RESOURCE_ID.equals(attribute.getAttributeId())\n                && expectedResourceId.equals(attributeValue)) {\n                resourceIdSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_SERVICE_ID.equals(attribute.getAttributeId())\n                && service.equals(attributeValue)) {\n                soapServiceSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_OPERATION_ID.equals(attribute.getAttributeId())\n                && operation.equals(attributeValue)) {\n                soapOperationSatisfied = true;\n            } else if (XACMLConstants.RESOURCE_WSDL_ENDPOINT.equals(attribute.getAttributeId())\n                && resourceURL.equals(attributeValue)) {\n                resourceURISatisfied = true;\n            }\n        }\n        \n        assertTrue(resourceIdSatisfied && soapServiceSatisfied && soapOperationSatisfied\n                   && resourceURISatisfied);\n    }","commit_id":"280487512eb1c34a6c05bcfe3e2e182388359a25","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testEnvironment() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleIt}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        \n        XACMLRequestBuilder builder = new OpenSAMLXACMLRequestBuilder();\n        RequestType request = \n            (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        assertFalse(request.getEnvironment().getAttributes().isEmpty());\n        \n        ((OpenSAMLXACMLRequestBuilder)builder).setSendDateTime(false);\n        request = (RequestType)builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        assertTrue(request.getEnvironment().getAttributes().isEmpty());\n    }","id":43107,"modified_method":"@org.junit.Test\n    public void testEnvironment() throws Exception {\n        // Mock up a request\n        Principal principal = new Principal() {\n            public String getName() {\n                return \"alice\";\n            }\n        };\n        \n        String operation = \"{http://www.example.org/contract/DoubleIt}DoubleIt\";\n        MessageImpl msg = new MessageImpl();\n        msg.put(Message.WSDL_OPERATION, QName.valueOf(operation));\n        String service = \"{http://www.example.org/contract/DoubleIt}DoubleItService\";\n        msg.put(Message.WSDL_SERVICE, QName.valueOf(service));\n        String resourceURL = \"https://localhost:8080/doubleit\";\n        msg.put(Message.REQUEST_URL, resourceURL);\n        \n        XACMLRequestBuilder builder = new DefaultXACMLRequestBuilder();\n        RequestType request = \n            builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        assertFalse(request.getEnvironment().getAttributes().isEmpty());\n        \n        ((DefaultXACMLRequestBuilder)builder).setSendDateTime(false);\n        request = builder.createRequest(principal, Collections.singletonList(\"manager\"), msg);\n        assertNotNull(request);\n        assertTrue(request.getEnvironment().getAttributes().isEmpty());\n    }","commit_id":"280487512eb1c34a6c05bcfe3e2e182388359a25","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Service method.\n     */\n    public void service(org.apache.coyote.Request req, \n    \t                org.apache.coyote.Response res)\n        throws Exception {\n\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n\n        if (request == null) {\n\n            // Create objects\n            request = (Request) connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = (Response) connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            // Link objects\n            request.setResponse(response);\n            response.setRequest(request);\n\n            // Set as notes\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            // Set query string encoding\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n\n        }\n\n        if (connector.getXpoweredBy()) {\n            response.addHeader(\"X-Powered-By\", \"Servlet/2.5\");\n        }\n\n        boolean comet = false;\n        \n        try {\n\n            // Parse and set Catalina and configuration specific \n            // request parameters\n            req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());\n            if (postParseRequest(req, request, res, response)) {\n                // Calling the container\n                connector.getContainer().getPipeline().getFirst().invoke(request, response);\n\n                if (request.isComet()) {\n                    if (!response.isClosed() && !response.isError()) {\n                        if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {\n                            // Invoke a read event right away if there are available bytes\n                            if (event(req, res, SocketStatus.OPEN)) {\n                                comet = true;\n                                res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                            }\n                        } else {\n                            comet = true;\n                            res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                        }\n                    } else {\n                        // Clear the filter chain, as otherwise it will not be reset elsewhere\n                        // since this is a Comet request\n                        request.setFilterChain(null);\n                    }\n                }\n\n            }\n\n            if (!comet) {\n                response.finishResponse();\n                req.action(ActionCode.ACTION_POST_REQUEST , null);\n            }\n\n        } catch (IOException e) {\n            ;\n        } catch (Throwable t) {\n            log.error(sm.getString(\"coyoteAdapter.service\"), t);\n        } finally {\n            req.getRequestProcessor().setWorkerThreadName(null);\n            // Recycle the wrapper request and response\n            if (!comet) {\n                request.recycle();\n                response.recycle();\n            } else {\n                // Clear converters so that the minimum amount of memory \n                // is used by this processor\n                request.clearEncoders();\n                response.clearEncoders();\n            }\n        }\n\n    }","id":43108,"modified_method":"/**\n     * Service method.\n     */\n    public void service(org.apache.coyote.Request req, \n    \t                org.apache.coyote.Response res)\n        throws Exception {\n\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n\n        if (request == null) {\n\n            // Create objects\n            request = connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            // Link objects\n            request.setResponse(response);\n            response.setRequest(request);\n\n            // Set as notes\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            // Set query string encoding\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n\n        }\n\n        if (connector.getXpoweredBy()) {\n            response.addHeader(\"X-Powered-By\", \"Servlet/2.5\");\n        }\n\n        boolean comet = false;\n        \n        try {\n\n            // Parse and set Catalina and configuration specific \n            // request parameters\n            req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());\n            if (postParseRequest(req, request, res, response)) {\n                // Calling the container\n                connector.getContainer().getPipeline().getFirst().invoke(request, response);\n\n                if (request.isComet()) {\n                    if (!response.isClosed() && !response.isError()) {\n                        if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {\n                            // Invoke a read event right away if there are available bytes\n                            if (event(req, res, SocketStatus.OPEN)) {\n                                comet = true;\n                                res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                            }\n                        } else {\n                            comet = true;\n                            res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                        }\n                    } else {\n                        // Clear the filter chain, as otherwise it will not be reset elsewhere\n                        // since this is a Comet request\n                        request.setFilterChain(null);\n                    }\n                }\n\n            }\n\n            if (!comet) {\n                response.finishResponse();\n                req.action(ActionCode.ACTION_POST_REQUEST , null);\n            }\n\n        } catch (IOException e) {\n            // Ignore\n        } catch (Throwable t) {\n            log.error(sm.getString(\"coyoteAdapter.service\"), t);\n        } finally {\n            req.getRequestProcessor().setWorkerThreadName(null);\n            // Recycle the wrapper request and response\n            if (!comet) {\n                request.recycle();\n                response.recycle();\n            } else {\n                // Clear converters so that the minimum amount of memory \n                // is used by this processor\n                request.clearEncoders();\n                response.clearEncoders();\n            }\n        }\n\n    }","commit_id":"943ce7c4662f5de34cd3d2af0c1a6f97753f262e","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Character conversion of the URI.\n     */\n    protected void convertURI(MessageBytes uri, Request request) \n        throws Exception {\n\n        ByteChunk bc = uri.getByteChunk();\n        int length = bc.getLength();\n        CharChunk cc = uri.getCharChunk();\n        cc.allocate(length, -1);\n\n        String enc = connector.getURIEncoding();\n        if (enc != null) {\n            B2CConverter conv = request.getURIConverter();\n            try {\n                if (conv == null) {\n                    conv = new B2CConverter(enc);\n                    request.setURIConverter(conv);\n                }\n            } catch (IOException e) {\n                // Ignore\n                log.error(\"Invalid URI encoding; using HTTP default\");\n                connector.setURIEncoding(null);\n            }\n            if (conv != null) {\n                try {\n                    conv.convert(bc, cc);\n                    uri.setChars(cc.getBuffer(), cc.getStart(), \n                                 cc.getLength());\n                    return;\n                } catch (IOException e) {\n                    log.error(\"Invalid URI character encoding; trying ascii\");\n                    cc.recycle();\n                }\n            }\n        }\n\n        // Default encoding: fast conversion\n        byte[] bbuf = bc.getBuffer();\n        char[] cbuf = cc.getBuffer();\n        int start = bc.getStart();\n        for (int i = 0; i < length; i++) {\n            cbuf[i] = (char) (bbuf[i + start] & 0xff);\n        }\n        uri.setChars(cbuf, 0, length);\n\n    }","id":43109,"modified_method":"/**\n     * Character conversion of the URI.\n     */\n    protected void convertURI(MessageBytes uri, Request request) \n        throws Exception {\n\n        ByteChunk bc = uri.getByteChunk();\n        int length = bc.getLength();\n        CharChunk cc = uri.getCharChunk();\n        cc.allocate(length, -1);\n\n        String enc = connector.getURIEncoding();\n        if (enc != null) {\n            B2CConverter conv = request.getURIConverter();\n            try {\n                if (conv == null) {\n                    conv = new B2CConverter(enc);\n                    request.setURIConverter(conv);\n                }\n            } catch (IOException e) {\n                // Ignore\n                log.error(\"Invalid URI encoding; using HTTP default\");\n                connector.setURIEncoding(null);\n            }\n            if (conv != null) {\n                try {\n                    conv.convert(bc, cc, cc.getBuffer().length - cc.getEnd());\n                    uri.setChars(cc.getBuffer(), cc.getStart(), \n                                 cc.getLength());\n                    return;\n                } catch (IOException e) {\n                    log.error(\"Invalid URI character encoding; trying ascii\");\n                    cc.recycle();\n                }\n            }\n        }\n\n        // Default encoding: fast conversion\n        byte[] bbuf = bc.getBuffer();\n        char[] cbuf = cc.getBuffer();\n        int start = bc.getStart();\n        for (int i = 0; i < length; i++) {\n            cbuf[i] = (char) (bbuf[i + start] & 0xff);\n        }\n        uri.setChars(cbuf, 0, length);\n\n    }","commit_id":"943ce7c4662f5de34cd3d2af0c1a6f97753f262e","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n  public Result checkAutoPopup(char charTyped, Project project, Editor editor, PsiFile file) {\n    return LookupManager.getActiveLookup(editor) != null ? Result.STOP : Result.CONTINUE;\n  }","id":43110,"modified_method":"@Override\n  public Result checkAutoPopup(char charTyped, Project project, final Editor editor, PsiFile file) {\n    LookupImpl lookup = (LookupImpl)LookupManager.getActiveLookup(editor);\n    if (lookup != null && editor.getSelectionModel().hasSelection()) {\n      lookup.performGuardedChange(new Runnable() {\n        @Override\n        public void run() {\n          EditorModificationUtil.deleteSelectedText(editor);\n        }\n      });\n    }\n    \n    return lookup != null ? Result.STOP : Result.CONTINUE;\n  }","commit_id":"50656c50b59a9e1a64e25d2599af824ecb598faf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(@NotNull Editor editor, char charTyped, @NotNull DataContext dataContext) {\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null || editor.isColumnMode()){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n\n    if (file == null){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    if (editor.isViewer()) return;\n\n    if (!FileDocumentManager.getInstance().requestWriting(editor.getDocument(), project)) {\n       return;\n    }\n\n    Editor injectedEditor = injectedEditorIfCharTypedIsSignificant(charTyped, editor, file);\n    if (injectedEditor != editor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n      editor = injectedEditor;\n    }\n\n    final TypedHandlerDelegate[] delegates = Extensions.getExtensions(TypedHandlerDelegate.EP_NAME);\n    AutoPopupController autoPopupController = AutoPopupController.getInstance(project);\n\n    boolean handled = false;\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.checkAutoPopup(charTyped, project, editor, file);\n      handled = result == TypedHandlerDelegate.Result.STOP;\n      if (result != TypedHandlerDelegate.Result.CONTINUE) break;\n    }\n\n    if (!handled) {\n      if (charTyped == '.') {\n        autoPopupController.autoPopupMemberLookup(editor, null);\n      }\n\n      if (charTyped == '(' && !isInsideStringLiteral(editor, file)) {\n        autoPopupController.autoPopupParameterInfo(editor, null);\n      }\n    }\n\n    if (!editor.isInsertMode()){\n      myOriginalHandler.execute(editor, charTyped, dataContext);\n      return;\n    }\n\n    if (editor.getSelectionModel().hasSelection()){\n      //todo[peter] a better way of clearing selection in a guarded way\n      final Editor finalEditor = editor;\n      Runnable runnable = new Runnable() {\n        public void run() {\n          EditorModificationUtil.deleteSelectedText(finalEditor);\n        }\n      };\n      final LookupImpl lookup = (LookupImpl)LookupManager.getActiveLookup(editor);\n      if (lookup == null) {\n        runnable.run();\n      } else {\n        lookup.performGuardedChange(runnable);\n      }\n    }\n\n    FileType fileType = getFileType(file, editor);\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.beforeCharTyped(charTyped, project, editor, file, fileType);\n      if (result == TypedHandlerDelegate.Result.STOP) {\n        return;\n      }\n      if (result == TypedHandlerDelegate.Result.DEFAULT) {\n        break;\n      }\n    }\n\n    if (!editor.getSelectionModel().hasBlockSelection()) {\n      if (')' == charTyped || ']' == charTyped || '}' == charTyped) {\n        if (StdFileTypes.PLAIN_TEXT != fileType) {\n          if (handleRParen(editor, fileType, charTyped)) return;\n        }\n      }\n      else if ('\"' == charTyped || '\\'' == charTyped || '`' == charTyped) {\n        if (handleQuote(editor, charTyped, dataContext, file)) return;\n      }\n    }\n\n    long modificationStampBeforeTyping = editor.getDocument().getModificationStamp();\n    myOriginalHandler.execute(editor, charTyped, dataContext);\n    AutoHardWrapHandler.getInstance().wrapLineIfNecessary(editor, dataContext, modificationStampBeforeTyping);\n\n    if (('(' == charTyped || '[' == charTyped || '{' == charTyped) &&\n        CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET &&\n        !editor.getSelectionModel().hasBlockSelection() && fileType != StdFileTypes.PLAIN_TEXT) {\n      handleAfterLParen(editor, fileType, charTyped);\n    }\n    else if ('}' == charTyped) {\n      indentClosingBrace(project, editor);\n    }\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.charTyped(charTyped, project, editor, file);\n      if (result == TypedHandlerDelegate.Result.STOP) {\n        return;\n      }\n      if (result == TypedHandlerDelegate.Result.DEFAULT) {\n        break;\n      }\n    }\n    if ('{' == charTyped) {\n      indentOpenedBrace(project, editor);\n    }\n  }","id":43111,"modified_method":"public void execute(@NotNull Editor editor, char charTyped, @NotNull DataContext dataContext) {\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null || editor.isColumnMode()){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    PsiFile file = PsiUtilBase.getPsiFileInEditor(editor, project);\n\n    if (file == null){\n      if (myOriginalHandler != null){\n        myOriginalHandler.execute(editor, charTyped, dataContext);\n      }\n      return;\n    }\n\n    if (editor.isViewer()) return;\n\n    if (!FileDocumentManager.getInstance().requestWriting(editor.getDocument(), project)) {\n       return;\n    }\n\n    Editor injectedEditor = injectedEditorIfCharTypedIsSignificant(charTyped, editor, file);\n    if (injectedEditor != editor) {\n      file = PsiDocumentManager.getInstance(project).getPsiFile(injectedEditor.getDocument());\n      editor = injectedEditor;\n    }\n\n    final TypedHandlerDelegate[] delegates = Extensions.getExtensions(TypedHandlerDelegate.EP_NAME);\n    AutoPopupController autoPopupController = AutoPopupController.getInstance(project);\n\n    boolean handled = false;\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.checkAutoPopup(charTyped, project, editor, file);\n      handled = result == TypedHandlerDelegate.Result.STOP;\n      if (result != TypedHandlerDelegate.Result.CONTINUE) break;\n    }\n\n    if (!handled) {\n      if (charTyped == '.') {\n        autoPopupController.autoPopupMemberLookup(editor, null);\n      }\n\n      if (charTyped == '(' && !isInsideStringLiteral(editor, file)) {\n        autoPopupController.autoPopupParameterInfo(editor, null);\n      }\n    }\n\n    if (!editor.isInsertMode()){\n      myOriginalHandler.execute(editor, charTyped, dataContext);\n      return;\n    }\n\n    if (editor.getSelectionModel().hasSelection()){\n      EditorModificationUtil.deleteSelectedText(editor);\n    }\n\n    FileType fileType = getFileType(file, editor);\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.beforeCharTyped(charTyped, project, editor, file, fileType);\n      if (result == TypedHandlerDelegate.Result.STOP) {\n        return;\n      }\n      if (result == TypedHandlerDelegate.Result.DEFAULT) {\n        break;\n      }\n    }\n\n    if (!editor.getSelectionModel().hasBlockSelection()) {\n      if (')' == charTyped || ']' == charTyped || '}' == charTyped) {\n        if (StdFileTypes.PLAIN_TEXT != fileType) {\n          if (handleRParen(editor, fileType, charTyped)) return;\n        }\n      }\n      else if ('\"' == charTyped || '\\'' == charTyped || '`' == charTyped) {\n        if (handleQuote(editor, charTyped, dataContext, file)) return;\n      }\n    }\n\n    long modificationStampBeforeTyping = editor.getDocument().getModificationStamp();\n    myOriginalHandler.execute(editor, charTyped, dataContext);\n    AutoHardWrapHandler.getInstance().wrapLineIfNecessary(editor, dataContext, modificationStampBeforeTyping);\n\n    if (('(' == charTyped || '[' == charTyped || '{' == charTyped) &&\n        CodeInsightSettings.getInstance().AUTOINSERT_PAIR_BRACKET &&\n        !editor.getSelectionModel().hasBlockSelection() && fileType != StdFileTypes.PLAIN_TEXT) {\n      handleAfterLParen(editor, fileType, charTyped);\n    }\n    else if ('}' == charTyped) {\n      indentClosingBrace(project, editor);\n    }\n\n    for(TypedHandlerDelegate delegate: delegates) {\n      final TypedHandlerDelegate.Result result = delegate.charTyped(charTyped, project, editor, file);\n      if (result == TypedHandlerDelegate.Result.STOP) {\n        return;\n      }\n      if (result == TypedHandlerDelegate.Result.DEFAULT) {\n        break;\n      }\n    }\n    if ('{' == charTyped) {\n      indentOpenedBrace(project, editor);\n    }\n  }","commit_id":"50656c50b59a9e1a64e25d2599af824ecb598faf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StatisticsInfo serialize(final LookupElement element, final CompletionLocation location) {\n    final Object o = element.getObject();\n    PsiType qualifierType = JavaCompletionUtil.getQualifierType((LookupItem) element);\n    if (qualifierType == null) {\n      final ExpectedTypeInfo[] infos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n      if (infos != null && infos.length > 0) {\n        qualifierType = infos[0].getDefaultType();\n      }\n    }\n\n    final CompletionType type = location.getCompletionType();\n    if (o instanceof PsiMember) {\n      final boolean isClass = o instanceof PsiClass;\n      if (qualifierType != null) {\n        if (isClass && type == CompletionType.SMART) return JavaStatisticsManager.createInfo(qualifierType, (PsiMember)o);\n        if (!isClass && type == CompletionType.BASIC) return JavaStatisticsManager.createInfo(qualifierType, (PsiMember)o);\n        return StatisticsInfo.EMPTY;\n      }\n\n      if (type == CompletionType.CLASS_NAME && isClass) {\n        final String qualifiedName = ((PsiClass)o).getQualifiedName();\n        if (qualifiedName != null) {\n          return new StatisticsInfo(CLASS_NAME_COMPLETION_PREFIX + PrefixMatchingWeigher.PREFIX_CAPITALS.getValue(location), qualifiedName);\n        }\n      }\n    }\n\n    if (qualifierType != null) return StatisticsInfo.EMPTY;\n\n    return null;\n  }","id":43112,"modified_method":"public StatisticsInfo serialize(final LookupElement element, final CompletionLocation location) {\n    final Object o = element.getObject();\n    PsiType qualifierType = JavaCompletionUtil.getQualifierType((LookupItem) element);\n    if (qualifierType == null) {\n      final ExpectedTypeInfo[] infos = JavaCompletionUtil.EXPECTED_TYPES.getValue(location);\n      if (infos != null && infos.length > 0) {\n        qualifierType = infos[0].getDefaultType();\n      }\n    }\n\n    final CompletionType type = location.getCompletionType();\n    if (o instanceof PsiMember) {\n      final boolean isClass = o instanceof PsiClass;\n      if (qualifierType != null) {\n        if (!(o instanceof PsiField) && type == CompletionType.SMART) return JavaStatisticsManager.createInfo(qualifierType, (PsiMember)o);\n        if (!isClass && type == CompletionType.BASIC) return JavaStatisticsManager.createInfo(qualifierType, (PsiMember)o);\n        return StatisticsInfo.EMPTY;\n      }\n\n      if (type == CompletionType.CLASS_NAME && isClass) {\n        final String qualifiedName = ((PsiClass)o).getQualifiedName();\n        if (qualifiedName != null) {\n          return new StatisticsInfo(CLASS_NAME_COMPLETION_PREFIX + PrefixMatchingWeigher.PREFIX_CAPITALS.getValue(location), qualifiedName);\n        }\n      }\n    }\n\n    if (qualifierType != null) return StatisticsInfo.EMPTY;\n\n    return null;\n  }","commit_id":"298184800d56bc7c9650579222006c2adc9d37e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void initOffsets(final PsiFile file, final Project project, final OffsetMap offsetMap){\n    final int selectionEndOffset = offsetMap.getOffset(CompletionInitializationContext.SELECTION_END_OFFSET);\n\n    PsiElement element = file.findElementAt(selectionEndOffset);\n    if (element == null) return;\n\n    final PsiReference reference = file.findReferenceAt(selectionEndOffset);\n    if(reference != null){\n      if(reference instanceof PsiJavaCodeReferenceElement){\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getParent().getTextRange().getEndOffset());\n      }\n      else{\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET,\n                                 reference.getElement().getTextRange().getStartOffset() + reference.getRangeInElement().getEndOffset());\n      }\n\n      element = file.findElementAt(offsetMap.getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n    }\n    else if (isWord(element)){\n      if(element instanceof PsiIdentifier && element.getParent() instanceof PsiJavaCodeReferenceElement){\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getParent().getTextRange().getEndOffset());\n      }\n      else{\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getTextRange().getEndOffset());\n      }\n\n      element = file.findElementAt(offsetMap.getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n      if (element == null) return;\n    }\n\n    if (element instanceof PsiWhiteSpace &&\n        ( !element.textContains('\\n') ||\n          CodeStyleSettingsManager.getInstance(project).getCurrentSettings().METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE\n        )\n       ){\n      element = file.findElementAt(element.getTextRange().getEndOffset());\n    }\n\n    if (element instanceof PsiJavaToken\n        && ((PsiJavaToken)element).getTokenType() == JavaTokenType.LPARENTH){\n\n      if(element.getParent() instanceof PsiExpressionList || \".\".equals(file.findElementAt(selectionEndOffset - 1).getText())\n        || PlatformPatterns.psiElement().afterLeaf(PlatformPatterns.psiElement(JavaTokenType.NEW_KEYWORD)).accepts(element)) {\n        offsetMap.addOffset(LPAREN_OFFSET, element.getTextRange().getStartOffset());\n        PsiElement list = element.getParent();\n        PsiElement last = list.getLastChild();\n        if (last instanceof PsiJavaToken && ((PsiJavaToken)last).getTokenType() == JavaTokenType.RPARENTH){\n          offsetMap.addOffset(RPAREN_OFFSET, last.getTextRange().getStartOffset());\n        }\n\n\n        offsetMap.addOffset(ARG_LIST_END_OFFSET, list.getTextRange().getEndOffset());\n      }\n    }\n  }","id":43113,"modified_method":"public static void initOffsets(final PsiFile file, final Project project, final OffsetMap offsetMap){\n    int selectionEndOffset = offsetMap.getOffset(CompletionInitializationContext.SELECTION_END_OFFSET);\n\n    PsiElement element = file.findElementAt(selectionEndOffset);\n    if (element == null) return;\n\n    if (LEFT_PAREN.accepts(element)) {\n      selectionEndOffset--;\n      element = file.findElementAt(selectionEndOffset);\n      if (element == null) return;\n    }\n\n    final PsiReference reference = file.findReferenceAt(selectionEndOffset);\n    if(reference != null) {\n      if(reference instanceof PsiJavaCodeReferenceElement){\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getParent().getTextRange().getEndOffset());\n      }\n      else{\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET,\n                                 reference.getElement().getTextRange().getStartOffset() + reference.getRangeInElement().getEndOffset());\n      }\n\n      element = file.findElementAt(offsetMap.getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n    }\n    else if (isWord(element)){\n      if(element instanceof PsiIdentifier && element.getParent() instanceof PsiJavaCodeReferenceElement){\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getParent().getTextRange().getEndOffset());\n      }\n      else{\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getTextRange().getEndOffset());\n      }\n\n      element = file.findElementAt(offsetMap.getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n      if (element == null) return;\n    }\n\n    if (element instanceof PsiWhiteSpace &&\n        ( !element.textContains('\\n') ||\n          CodeStyleSettingsManager.getInstance(project).getCurrentSettings().METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE\n        )\n       ){\n      element = file.findElementAt(element.getTextRange().getEndOffset());\n    }\n\n    if (LEFT_PAREN.accepts(element)) {\n      offsetMap.addOffset(LPAREN_OFFSET, element.getTextRange().getStartOffset());\n      PsiElement list = element.getParent();\n      PsiElement last = list.getLastChild();\n      if (last instanceof PsiJavaToken && ((PsiJavaToken)last).getTokenType() == JavaTokenType.RPARENTH) {\n        offsetMap.addOffset(RPAREN_OFFSET, last.getTextRange().getStartOffset());\n      }\n\n\n      offsetMap.addOffset(ARG_LIST_END_OFFSET, list.getTextRange().getEndOffset());\n    }\n  }","commit_id":"298184800d56bc7c9650579222006c2adc9d37e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Comparable weigh(@NotNull final LookupElement<?> item, final CompletionLocation location) {\n    final Object object = item.getObject();\n    if (object instanceof PsiMember) {\n      final PsiMember member = (PsiMember)object;\n      if (!JavaPsiFacade.getInstance(member.getProject()).getResolveHelper().isAccessible(member, location.getCompletionParameters().getPosition(), null)) return -2;\n    }\n\n    return 0;\n  }","id":43114,"modified_method":"public MyEnum weigh(@NotNull final LookupElement<?> item, final CompletionLocation location) {\n    final Object object = item.getObject();\n    if (object instanceof PsiDocCommentOwner) {\n      final PsiDocCommentOwner member = (PsiDocCommentOwner)object;\n      if (!JavaPsiFacade.getInstance(member.getProject()).getResolveHelper().isAccessible(member, location.getCompletionParameters().getPosition(), null)) return MyEnum.INACCESSIBLE;\n      if (member.isDeprecated()) return MyEnum.DEPRECATED;\n    }\n    return MyEnum.NORMAL;\n  }","commit_id":"298184800d56bc7c9650579222006c2adc9d37e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    final Editor editor = PlatformDataKeys.EDITOR.getData(dataContext);\n    final PsiElement element = LangDataKeys.PSI_ELEMENT.getData(dataContext);\n\n    if (project != null && editor != null) {\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(CODEASSISTS_QUICKJAVADOC_FEATURE);\n      if (LookupManager.getInstance(project).getActiveLookup() != null) {\n        FeatureUsageTracker.getInstance().triggerFeatureUsed(CODEASSISTS_QUICKJAVADOC_LOOKUP_FEATURE);\n      }\n      actionPerformedImpl(project, editor);\n    }\n    else if (project != null) {\n      if (DocumentationManager.getProviderFromElement(element) != null) {\n        FeatureUsageTracker.getInstance().triggerFeatureUsed(\"codeassists.quickjavadoc.ctrln\");\n        CommandProcessor.getInstance().executeCommand(project,\n                                                      new Runnable() {\n                                                        public void run() {\n                                                          DocumentationManager.getInstance(project).showJavaDocInfo(element);\n                                                        }\n                                                      },\n                                                      getCommandName(),\n                                                      null);\n      }\n    }\n  }","id":43115,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    final Editor editor = PlatformDataKeys.EDITOR.getData(dataContext);\n    final PsiElement element = LangDataKeys.PSI_ELEMENT.getData(dataContext);\n\n    if (project != null && editor != null) {\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(CODEASSISTS_QUICKJAVADOC_FEATURE);\n      final LookupImpl lookup = (LookupImpl)LookupManager.getInstance(project).getActiveLookup();\n      if (lookup != null) {\n        dumpLookupElementWeights(lookup);\n        FeatureUsageTracker.getInstance().triggerFeatureUsed(CODEASSISTS_QUICKJAVADOC_LOOKUP_FEATURE);\n      }\n      actionPerformedImpl(project, editor);\n    }\n    else if (project != null) {\n      if (DocumentationManager.getProviderFromElement(element) != null) {\n        FeatureUsageTracker.getInstance().triggerFeatureUsed(\"codeassists.quickjavadoc.ctrln\");\n        CommandProcessor.getInstance().executeCommand(project,\n                                                      new Runnable() {\n                                                        public void run() {\n                                                          DocumentationManager.getInstance(project).showJavaDocInfo(element);\n                                                        }\n                                                      },\n                                                      getCommandName(),\n                                                      null);\n      }\n    }\n  }","commit_id":"298184800d56bc7c9650579222006c2adc9d37e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doComplete(final int offset1,\n                            final int offset2,\n                            final CompletionContext context,\n                            final String dummyIdentifier, final Editor editor) {\n    final Pair<CompletionContext, PsiElement> insertedInfo = new WriteCommandAction<Pair<CompletionContext, PsiElement>>(context.project) {\n      protected void run(Result<Pair<CompletionContext, PsiElement>> result) throws Throwable {\n        result.setResult(insertDummyIdentifier(context, dummyIdentifier));\n      }\n    }.execute().getResultObject();\n\n    final PsiElement insertedElement = insertedInfo.getSecond();\n    insertedElement.putUserData(CompletionContext.COMPLETION_CONTEXT_KEY, insertedInfo.getFirst());\n\n    final CompletionParametersImpl parameters = new CompletionParametersImpl(insertedInfo.getSecond(), insertedInfo.getFirst().file, myCompletionType);\n    final String adText = CompletionService.getCompletionService().getAdvertisementText(parameters);\n\n    final CompletionProgressIndicator indicator = new CompletionProgressIndicator(editor, parameters, adText, this, insertedInfo.getFirst());\n\n    final Runnable computeRunnable = new Runnable() {\n      public void run() {\n        ProgressManager.getInstance().runProcess(new Runnable() {\n          public void run() {\n            try {\n              final LookupData data = computeLookupData(insertedElement, insertedInfo.getFirst(), parameters, indicator);\n              if (data == null) {\n                indicator.cancel();\n                return; //cancelled\n              }\n\n              final LookupItem[] items = data.items;\n              if (items.length == 0) {\n                indicator.cancel();\n                invokeAndWait(new Runnable() {\n                  public void run() {\n                    handleEmptyLookup(context, data, parameters);\n                  }\n                }, context.editor);\n                return;\n              }\n\n              final String prefix = data.prefix;\n              context.setPrefix(data.prefix);\n              context.setStartOffset(offset1 - prefix.length());\n\n              if (shouldAutoComplete(items, context)) {\n                LookupItem item = items[0];\n                computingFinished(data, null, prefix, item.getLookupString(), item, false, indicator, offset2, context, offset1);\n              } else {\n                computingFinished(data, items, prefix, null, null, true, indicator, offset2, context, offset1);\n              }\n            }\n            catch (ProcessCanceledException e) {\n            }\n            finally {\n              insertedElement.putUserData(CompletionContext.COMPLETION_CONTEXT_KEY, null);\n            }\n          }\n        }, indicator);\n      }\n    };\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      computeRunnable.run();\n    } else {\n      ApplicationManager.getApplication().executeOnPooledThread(computeRunnable);\n    }\n  }","id":43116,"modified_method":"protected void doComplete(final int offset1,\n                            final int offset2,\n                            final CompletionContext context,\n                            final String dummyIdentifier, final Editor editor) {\n    final Pair<CompletionContext, PsiElement> insertedInfo = new WriteCommandAction<Pair<CompletionContext, PsiElement>>(context.project) {\n      protected void run(Result<Pair<CompletionContext, PsiElement>> result) throws Throwable {\n        result.setResult(insertDummyIdentifier(context, dummyIdentifier));\n      }\n    }.execute().getResultObject();\n\n    final PsiElement insertedElement = insertedInfo.getSecond();\n    insertedElement.putUserData(CompletionContext.COMPLETION_CONTEXT_KEY, insertedInfo.getFirst());\n\n    final CompletionParametersImpl parameters = new CompletionParametersImpl(insertedInfo.getSecond(), insertedInfo.getFirst().file, myCompletionType);\n    final String adText = CompletionService.getCompletionService().getAdvertisementText(parameters);\n\n    final CompletionProgressIndicator indicator = new CompletionProgressIndicator(editor, parameters, adText, this, insertedInfo.getFirst());\n\n    final Runnable computeRunnable = new Runnable() {\n      public void run() {\n        ProgressManager.getInstance().runProcess(new Runnable() {\n          public void run() {\n            try {\n              final LookupData data = computeLookupData(insertedElement, insertedInfo.getFirst(), parameters, indicator);\n              if (data == null) {\n                indicator.cancel();\n                return; //cancelled\n              }\n\n              final LookupItem[] items = data.items;\n              if (items.length == 0) {\n                indicator.cancel();\n                invokeAndWait(new Runnable() {\n                  public void run() {\n                    HintManager.getInstance().hideAllHints();\n                    handleEmptyLookup(context, data, parameters);\n                  }\n                }, context.editor);\n                return;\n              }\n\n              final String prefix = data.prefix;\n              context.setPrefix(data.prefix);\n              context.setStartOffset(offset1 - prefix.length());\n\n              if (shouldAutoComplete(items, context)) {\n                LookupItem item = items[0];\n                computingFinished(data, null, prefix, item.getLookupString(), item, false, indicator, offset2, context, offset1);\n              } else {\n                computingFinished(data, items, prefix, null, null, true, indicator, offset2, context, offset1);\n              }\n            }\n            catch (ProcessCanceledException e) {\n            }\n            finally {\n              insertedElement.putUserData(CompletionContext.COMPLETION_CONTEXT_KEY, null);\n            }\n          }\n        }, indicator);\n      }\n    };\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      computeRunnable.run();\n    } else {\n      ApplicationManager.getApplication().executeOnPooledThread(computeRunnable);\n    }\n  }","commit_id":"2a021f05eccd84f79efbd1be0c18c5f8e20ce42c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getData(final String dataId) {\n      if (DataConstants.DOMINANT_HINT_AREA_RECTANGLE.equals(dataId)) {\n        final Lookup lookup = LookupManager.getInstance(myProject).getActiveLookup();\n        if (lookup != null) {\n          return lookup.getBounds();\n        }\n      }\n      return super.getData(dataId);\n    }","id":43117,"modified_method":"public Object getData(final String dataId) {\n      if (DataConstants.DOMINANT_HINT_AREA_RECTANGLE.equals(dataId)) {\n        final LookupImpl lookup = (LookupImpl)LookupManager.getInstance(myProject).getActiveLookup();\n        if (lookup != null && lookup.isVisible()) {\n          return lookup.getBounds();\n        }\n      }\n      return super.getData(dataId);\n    }","commit_id":"2a021f05eccd84f79efbd1be0c18c5f8e20ce42c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void eventDispatched(AWTEvent event) {\n    if (!isShown()) {\n      return;\n    }\n    MouseEvent mouseEvent = (MouseEvent)event;\n    if (mouseEvent.getClickCount() == 0 && !(event instanceof MouseWheelEvent)) {\n      return;\n    }\n\n    final int id = mouseEvent.getID();\n    if (id == MouseEvent.MOUSE_WHEEL) {\n      cancelEditing();\n      return;\n    }\n\n    if (id != MouseEvent.MOUSE_PRESSED && id != MouseEvent.MOUSE_RELEASED && id != MouseEvent.MOUSE_CLICKED) {\n      return;\n    }\n    \n    final Component sourceComponent = mouseEvent.getComponent();\n    final Point originalPoint = mouseEvent.getPoint();\n\n    final Editor editor = getEditor();\n    if (editor == null) return;\n    \n    final Lookup activeLookup = LookupManager.getInstance(editor.getProject()).getActiveLookup();\n    if (activeLookup != null){\n      final JLayeredPane layeredPane = getTree().getRootPane().getLayeredPane();\n      final Point layeredPoint = SwingUtilities.convertPoint(sourceComponent, originalPoint, layeredPane);\n      if (activeLookup.getBounds().contains(layeredPoint)){\n        return; //mouse click inside lookup\n      } else {\n        ((LookupImpl)activeLookup).hide(); //hide popup on mouse position changed\n      }\n    }\n\n    final Point point = SwingUtilities.convertPoint(sourceComponent, originalPoint, myInplaceEditorComponent);\n    if (myInplaceEditorComponent.contains(point)) {\n      return;\n    }\n    final Component componentAtPoint = SwingUtilities.getDeepestComponentAt(sourceComponent, originalPoint.x, originalPoint.y);\n    for (Component comp = componentAtPoint; comp != null; comp = comp.getParent()) {\n      if (comp instanceof ComboPopup) {\n        doOKAction();\n        return;\n      }\n    }\n    cancelEditing();\n  }","id":43118,"modified_method":"public void eventDispatched(AWTEvent event) {\n    if (!isShown()) {\n      return;\n    }\n    MouseEvent mouseEvent = (MouseEvent)event;\n    if (mouseEvent.getClickCount() == 0 && !(event instanceof MouseWheelEvent)) {\n      return;\n    }\n\n    final int id = mouseEvent.getID();\n    if (id == MouseEvent.MOUSE_WHEEL) {\n      cancelEditing();\n      return;\n    }\n\n    if (id != MouseEvent.MOUSE_PRESSED && id != MouseEvent.MOUSE_RELEASED && id != MouseEvent.MOUSE_CLICKED) {\n      return;\n    }\n    \n    final Component sourceComponent = mouseEvent.getComponent();\n    final Point originalPoint = mouseEvent.getPoint();\n\n    final Editor editor = getEditor();\n    if (editor == null) return;\n    \n    final LookupImpl activeLookup = (LookupImpl)LookupManager.getInstance(editor.getProject()).getActiveLookup();\n    if (activeLookup != null){\n      final Point lookupPoint = SwingUtilities.convertPoint(sourceComponent, originalPoint, activeLookup.getComponent());\n      if (activeLookup.getComponent().getBounds().contains(lookupPoint)){\n        return; //mouse click inside lookup\n      } else {\n        activeLookup.hide(); //hide popup on mouse position changed\n      }\n    }\n\n    final Point point = SwingUtilities.convertPoint(sourceComponent, originalPoint, myInplaceEditorComponent);\n    if (myInplaceEditorComponent.contains(point)) {\n      return;\n    }\n    final Component componentAtPoint = SwingUtilities.getDeepestComponentAt(sourceComponent, originalPoint.x, originalPoint.y);\n    for (Component comp = componentAtPoint; comp != null; comp = comp.getParent()) {\n      if (comp instanceof ComboPopup) {\n        doOKAction();\n        return;\n      }\n    }\n    cancelEditing();\n  }","commit_id":"6a6cb56ddf70fcea650bcd03fe832b22cebcc718","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void generateModels(List<SModel> _sourceModels, Language targetLanguage, IOperationContext invocationContext, boolean generateText, IAdaptiveProgressMonitor progress) {\n    invocationContext.getProject().saveModels();\n    List<SModelDescriptor> sourceModels = new ArrayList<SModelDescriptor>();\n    for (SModel model : _sourceModels) {\n      sourceModels.add(model.getModelDescriptor());\n    }\n    clearMessages();\n    addMessage(MessageKind.INFORMATION, \"generating \" + (generateText ? \"text\" : \"files\"));\n    addMessage(MessageKind.INFORMATION, \"    target language: \\\"\" + targetLanguage.getNamespace() + \"\\\"\");\n    String outputFolder = invocationContext.getModule().getGeneratorOutputPath();\n\n    if (!new File(outputFolder).exists()) {\n      new File(outputFolder).mkdirs();\n\n      try {\n        MPSPlugin.getInstance().addSource(outputFolder);\n      } catch (Exception e) {\n        addMessage(MessageKind.WARNING, \"Can't add output folder to IDEA as sources\");\n      }\n    }\n\n    if (!generateText) {\n      addMessage(MessageKind.INFORMATION, \"    target root folder: \\\"\" + outputFolder + \"\\\"\");\n    }\n\n    boolean ideaPresent = MPSPlugin.getInstance().isIDEAPresent();\n    boolean compile = myCompileOnGeneration && ideaPresent;\n    long totalJob = ModelsProgressUtil.estimateTotalGenerationJobMillis(compile, generateText, sourceModels);\n\n    progress.start(\"generating\", totalJob);\n\n    try {\n      if (!myCompileOnGeneration) {\n        progress.addText(\"compilation in IntelliJ IDEA on generation is turned off\");\n      } else if (!ideaPresent) {\n        progress.addText(\"IntelliJ IDEA with installed MPS is not present\");\n      } else {\n        // -- compile sources before generation\n        checkMonitorCanceled(progress);\n        progress.addText(\"compiling in IntelliJ IDEA...\");\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        MPSPlugin.getInstance().refreshFS();\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        checkMonitorCanceled(progress);\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        MPSPlugin.getInstance().buildModule(outputFolder);\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        checkMonitorCanceled(progress);\n      }\n\n      // re-load classes anyway (to be sure that java_stub are up-to-date)\n      progress.addText(\"reloading MPS classes...\");\n      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n      ReloadUtils.reloadAll();\n\n      progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n      checkMonitorCanceled(progress);\n\n      //++ generation\n      GenerationSession generationSession = new GenerationSession(targetLanguage, invocationContext, progress);\n      GenerationStatus status = null;\n      for (SModelDescriptor sourceModelDescriptor : sourceModels) {\n        SModel sourceModel = sourceModelDescriptor.getSModel();\n        progress.addText(\"\");\n        String taskName = ModelsProgressUtil.generationModelTaskName(sourceModelDescriptor);\n        progress.startLeafTask(taskName, ModelsProgressUtil.generationModelTaskKind());\n\n        status = generationSession.generateModel(sourceModelDescriptor);\n        checkMonitorCanceled(progress);\n        if (status.getOutputModel() != null) {\n          if (generateText) {\n            progress.addText(\"generate text to Output view\");\n            generateText(status.getOutputModel(), invocationContext);\n          } else {\n            addProgressMessage(MessageKind.INFORMATION, \"generate files to folder: \\\"\" + getOutputFolderPath(outputFolder, sourceModel) + \"\\\"\", progress);\n            generateFile(outputFolder, sourceModel, status.getOutputModel());\n          }\n        }\n\n        progress.finishTask(taskName);\n        if (!status.isOk()) {\n          break;\n        }\n      }\n      //-- generation\n\n      //update generated sources timestamp\n      updateLanguagesGenerationRequiredStatus(invocationContext);\n\n      if (isSaveTransientModels()) {\n        generationSession.saveTransientModels();\n        addProgressMessage(MessageKind.INFORMATION, \"adding module \\\"\" + generationSession.getSessionModuleName() + \"\\\"\", progress);\n        File sessionDescriptorFile = generationSession.getSessionDescriptorFile();\n        generationSession.dispose(); // unregister transient models\n        myProject.addProjectSolution(sessionDescriptorFile);\n      } else if (!status.isError()) {\n        // if ERROR - keep transient models: we need them to navigate to from error messages\n        generationSession.dispose(); // unregister transient models\n      }\n\n      checkMonitorCanceled(progress);\n      progress.addText(\"\");\n      if (status.isOk()) {\n        if (compile && !generateText) {\n          // -- compile after generation\n          progress.addText(\"compiling in IntelliJ IDEA...\");\n\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          MPSPlugin.getInstance().refreshFS();\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          checkMonitorCanceled(progress);\n\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          MPSPlugin.getInstance().buildModule(outputFolder);\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          checkMonitorCanceled(progress);\n\n          progress.addText(\"reloading MPS classes...\");\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n          ReloadUtils.reloadAll();\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n          checkMonitorCanceled(progress);\n        }\n        addProgressMessage(MessageKind.INFORMATION, \"generation completed successfully\", progress);\n        progress.finish();\n      } else if (status.isError()) {\n        addProgressMessage(MessageKind.WARNING, \"generation finished with errors\", progress);\n        progress.finishAnyway();\n      }\n      showMessageView();\n    } catch (GenerationCanceledException gce) {\n      addProgressMessage(MessageKind.WARNING, \"generation canceled\", progress);\n      progress.finishAnyway();\n      showMessageView();\n    } catch (Throwable t) {\n      LOG.error(t);\n      addProgressMessage(MessageKind.ERROR, t.toString(), progress);\n    } finally {\n      progress.finishAnyway();\n      System.gc();\n    }\n  }","id":43119,"modified_method":"public void generateModels(List<SModel> _sourceModels, Language targetLanguage, IOperationContext invocationContext, boolean generateText, IAdaptiveProgressMonitor progress) {\n    invocationContext.getProject().saveModels();\n    List<SModelDescriptor> sourceModels = new ArrayList<SModelDescriptor>();\n    for (SModel model : _sourceModels) {\n      sourceModels.add(model.getModelDescriptor());\n    }\n    clearMessages();\n    addMessage(MessageKind.INFORMATION, \"generating \" + (generateText ? \"text\" : \"files\"));\n    addMessage(MessageKind.INFORMATION, \"    target language: \\\"\" + targetLanguage.getNamespace() + \"\\\"\");\n    String outputFolder = invocationContext.getModule().getGeneratorOutputPath();\n\n    if (!new File(outputFolder).exists()) {\n      new File(outputFolder).mkdirs();\n\n      try {\n        MPSPlugin.getInstance().addSource(outputFolder);\n      } catch (Exception e) {\n        addMessage(MessageKind.WARNING, \"Can't add output folder to IDEA as sources\");\n      }\n    }\n\n    if (!generateText) {\n      addMessage(MessageKind.INFORMATION, \"    target root folder: \\\"\" + outputFolder + \"\\\"\");\n    }\n\n    boolean ideaPresent = MPSPlugin.getInstance().isIDEAPresent();\n    boolean compile = myCompileOnGeneration && ideaPresent;\n    long totalJob = ModelsProgressUtil.estimateTotalGenerationJobMillis(compile, generateText, sourceModels);\n\n    progress.start(\"generating\", totalJob);\n\n    try {\n      if (!myCompileOnGeneration) {\n        progress.addText(\"compilation in IntelliJ IDEA on generation is turned off\");\n      } else if (!ideaPresent) {\n        progress.addText(\"IntelliJ IDEA with installed MPS is not present\");\n      } else {\n        // -- compile sources before generation\n        checkMonitorCanceled(progress);\n        progress.addText(\"compiling in IntelliJ IDEA...\");\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        MPSPlugin.getInstance().refreshFS();\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        checkMonitorCanceled(progress);\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        progress.addText(MPSPlugin.getInstance().buildModule(outputFolder));\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        checkMonitorCanceled(progress);\n      }\n\n      // re-load classes anyway (to be sure that java_stub are up-to-date)\n      progress.addText(\"reloading MPS classes...\");\n      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n      ReloadUtils.reloadAll();\n\n      progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n      checkMonitorCanceled(progress);\n\n      //++ generation\n      GenerationSession generationSession = new GenerationSession(targetLanguage, invocationContext, progress);\n      GenerationStatus status = null;\n      for (SModelDescriptor sourceModelDescriptor : sourceModels) {\n        SModel sourceModel = sourceModelDescriptor.getSModel();\n        progress.addText(\"\");\n        String taskName = ModelsProgressUtil.generationModelTaskName(sourceModelDescriptor);\n        progress.startLeafTask(taskName, ModelsProgressUtil.generationModelTaskKind());\n\n        status = generationSession.generateModel(sourceModelDescriptor);\n        checkMonitorCanceled(progress);\n        if (status.getOutputModel() != null) {\n          if (generateText) {\n            progress.addText(\"generate text to Output view\");\n            generateText(status.getOutputModel(), invocationContext);\n          } else {\n            addProgressMessage(MessageKind.INFORMATION, \"generate files to folder: \\\"\" + getOutputFolderPath(outputFolder, sourceModel) + \"\\\"\", progress);\n            generateFile(outputFolder, sourceModel, status.getOutputModel());\n          }\n        }\n\n        progress.finishTask(taskName);\n        if (!status.isOk()) {\n          break;\n        }\n      }\n      //-- generation\n\n      //update generated sources timestamp\n      updateLanguagesGenerationRequiredStatus(invocationContext);\n\n      if (isSaveTransientModels()) {\n        generationSession.saveTransientModels();\n        addProgressMessage(MessageKind.INFORMATION, \"adding module \\\"\" + generationSession.getSessionModuleName() + \"\\\"\", progress);\n        File sessionDescriptorFile = generationSession.getSessionDescriptorFile();\n        generationSession.dispose(); // unregister transient models\n        myProject.addProjectSolution(sessionDescriptorFile);\n      } else if (!status.isError()) {\n        // if ERROR - keep transient models: we need them to navigate to from error messages\n        generationSession.dispose(); // unregister transient models\n      }\n\n      checkMonitorCanceled(progress);\n      progress.addText(\"\");\n      if (status.isOk()) {\n        if (compile && !generateText) {\n          // -- compile after generation\n          progress.addText(\"compiling in IntelliJ IDEA...\");\n\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          MPSPlugin.getInstance().refreshFS();\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          checkMonitorCanceled(progress);\n\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          progress.addText(MPSPlugin.getInstance().buildModule(outputFolder));\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          checkMonitorCanceled(progress);\n\n          progress.addText(\"reloading MPS classes...\");\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n          ReloadUtils.reloadAll();\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n          checkMonitorCanceled(progress);\n        }\n        addProgressMessage(MessageKind.INFORMATION, \"generation completed successfully\", progress);\n        progress.finish();\n      } else if (status.isError()) {\n        addProgressMessage(MessageKind.WARNING, \"generation finished with errors\", progress);\n        progress.finishAnyway();\n      }\n      showMessageView();\n    } catch (GenerationCanceledException gce) {\n      addProgressMessage(MessageKind.WARNING, \"generation canceled\", progress);\n      progress.finishAnyway();\n      showMessageView();\n    } catch (Throwable t) {\n      LOG.error(t);\n      addProgressMessage(MessageKind.ERROR, t.toString(), progress);\n    } finally {\n      progress.finishAnyway();\n      System.gc();\n    }\n  }","commit_id":"aa6c219bd0e6d5a244a13466034d6f36d1336cbe","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void buildModule(String path) throws RemoteException {\n    getMPSupportHandler().buildModule(path);\n  }","id":43120,"modified_method":"public String buildModule(String path) throws RemoteException {\n    return getMPSupportHandler().buildModule(path);\n  }","commit_id":"aa6c219bd0e6d5a244a13466034d6f36d1336cbe","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void buildModule(final String path) {\n    final Object lock = new Object() { };\n    synchronized(lock) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                Module module = findModule(path);\n                if (module == null) {\n                  synchronized(lock) {\n                    lock.notifyAll();\n                  }\n                  return;\n                }\n\n                CompilerManager compilerManager = myProject.getComponent(CompilerManager.class);\n                compilerManager.make(module, new CompileStatusNotification() {\n                  public void finished(boolean b, int i, int i1) {\n                    synchronized(lock) {\n                      lock.notifyAll();\n                    }\n                  }\n\n                  public void finished(boolean b, int i, int i1, CompileContext compileContext) {\n                    synchronized(lock) {\n                      lock.notifyAll();\n                    }\n                  }\n                });\n              }\n            });\n          }\n      });\n      try {\n        lock.wait();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n  }","id":43121,"modified_method":"public String buildModule(final String path) {\n    final Object lock = new Object() { };\n    final StringBuilder result = new StringBuilder();\n    synchronized(lock) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                Module module = findModule(path);\n                if (module == null) {\n                  synchronized(lock) {\n                    lock.notifyAll();\n                  }\n                  return;\n                }\n\n                CompilerManager compilerManager = myProject.getComponent(CompilerManager.class);\n                compilerManager.make(module, new CompileStatusNotification() {\n                  public void finished(boolean aborted, int errors, int warnings) {\n                    compilationFinished(aborted, errors, warnings);\n                  }\n\n                  public void finished(boolean aborted, int errors, int warnings, CompileContext compileContext) {\n                    compilationFinished(aborted, errors, warnings);\n                  }\n\n                  private void compilationFinished(boolean aborted, int errorsNumber, int warningsNumber) {\n                    synchronized(lock) {\n                      if (aborted) {\n                        result.append(\"Compilation aborted\");\n                      } else {\n                        result.append(\"Compilation finished : \");\n                        result.append(errorsNumber).append(\" errors \");\n                        result.append(warningsNumber).append(\" warnings\");\n                      }                      \n                      lock.notifyAll();\n                    }\n                  }\n                });\n              }\n            });\n          }\n      });\n      try {\n        lock.wait();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n    return result.toString();\n  }","commit_id":"aa6c219bd0e6d5a244a13466034d6f36d1336cbe","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void generateModels(List<SModel> _sourceModels, Language targetLanguage, IOperationContext invocationContext, boolean generateText, IAdaptiveProgressMonitor progress) {\n    invocationContext.getProject().saveModels();\n    List<SModelDescriptor> sourceModels = new ArrayList<SModelDescriptor>();\n    for (SModel model : _sourceModels) {\n      sourceModels.add(model.getModelDescriptor());\n    }\n    clearMessages();\n    addMessage(MessageKind.INFORMATION, \"generating \" + (generateText ? \"text\" : \"files\"));\n    addMessage(MessageKind.INFORMATION, \"    target language: \\\"\" + targetLanguage.getNamespace() + \"\\\"\");\n    String outputFolder = invocationContext.getModule().getGeneratorOutputPath();\n\n    if (!new File(outputFolder).exists()) {\n      new File(outputFolder).mkdirs();\n\n      try {\n\n        myProject.getProjectHandler().addSourceRoot(outputFolder);\n      } catch (Exception e) {\n        addMessage(MessageKind.WARNING, \"Can't add output folder to IDEA as sources\");\n      }\n    }\n\n    if (!generateText) {\n      addMessage(MessageKind.INFORMATION, \"    target root folder: \\\"\" + outputFolder + \"\\\"\");\n    }\n\n    boolean ideaPresent = MPSPlugin.getInstance().isIDEAPresent();\n    boolean compile = myCompileOnGeneration && ideaPresent;\n    long totalJob = ModelsProgressUtil.estimateTotalGenerationJobMillis(compile, generateText, sourceModels);\n\n    progress.start(\"generating\", totalJob);\n\n    try {\n      if (!myCompileOnGeneration) {\n        progress.addText(\"compilation in IntelliJ IDEA on generation is turned off\");\n      } else if (!ideaPresent) {\n        progress.addText(\"IntelliJ IDEA with installed MPS is not present\");\n      } else {\n        // -- compile sources before generation\n        checkMonitorCanceled(progress);\n        progress.addText(\"compiling in IntelliJ IDEA...\");\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        myProject.getProjectHandler().refreshFS();\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        checkMonitorCanceled(progress);\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        progress.addText(myProject.getProjectHandler().buildModule(outputFolder));\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        checkMonitorCanceled(progress);\n      }\n\n      // re-load classes anyway (to be sure that java_stub are up-to-date)\n      progress.addText(\"reloading MPS classes...\");\n      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n      ReloadUtils.reloadAll();\n\n      progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n      checkMonitorCanceled(progress);\n\n      //++ generation\n      GenerationSession generationSession = new GenerationSession(targetLanguage, invocationContext, progress);\n      GenerationStatus status = null;\n      for (SModelDescriptor sourceModelDescriptor : sourceModels) {\n        SModel sourceModel = sourceModelDescriptor.getSModel();\n        progress.addText(\"\");\n        String taskName = ModelsProgressUtil.generationModelTaskName(sourceModelDescriptor);\n        progress.startLeafTask(taskName, ModelsProgressUtil.generationModelTaskKind());\n\n        status = generationSession.generateModel(sourceModelDescriptor);\n        checkMonitorCanceled(progress);\n        if (status.getOutputModel() != null) {\n          if (generateText) {\n            progress.addText(\"generate text to Output view\");\n            generateText(status.getOutputModel(), invocationContext);\n          } else {\n            addProgressMessage(MessageKind.INFORMATION, \"generate files to folder: \\\"\" + getOutputFolderPath(outputFolder, sourceModel) + \"\\\"\", progress);\n            generateFile(outputFolder, sourceModel, status.getOutputModel());\n          }\n        }\n\n        progress.finishTask(taskName);\n        if (!status.isOk()) {\n          break;\n        }\n      }\n      //-- generation\n\n      //update generated sources timestamp\n      updateLanguagesGenerationRequiredStatus(invocationContext);\n\n      if (isSaveTransientModels()) {\n        generationSession.saveTransientModels();\n        addProgressMessage(MessageKind.INFORMATION, \"adding module \\\"\" + generationSession.getSessionModuleName() + \"\\\"\", progress);\n        File sessionDescriptorFile = generationSession.getSessionDescriptorFile();\n        generationSession.dispose(); // unregister transient models\n        myProject.addProjectSolution(sessionDescriptorFile);\n      } else if (!status.isError()) {\n        // if ERROR - keep transient models: we need them to navigate to from error messages\n        generationSession.dispose(); // unregister transient models\n      }\n\n      checkMonitorCanceled(progress);\n      progress.addText(\"\");\n      if (status.isOk()) {\n        if (compile && !generateText) {\n          // -- compile after generation\n          progress.addText(\"compiling in IntelliJ IDEA...\");\n\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          myProject.getProjectHandler().refreshFS();\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          checkMonitorCanceled(progress);\n\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          progress.addText(myProject.getProjectHandler().buildModule(outputFolder));\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          checkMonitorCanceled(progress);\n\n          progress.addText(\"reloading MPS classes...\");\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n          ReloadUtils.reloadAll();\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n          checkMonitorCanceled(progress);\n        }\n        addProgressMessage(MessageKind.INFORMATION, \"generation completed successfully\", progress);\n        progress.finish();\n      } else if (status.isError()) {\n        addProgressMessage(MessageKind.WARNING, \"generation finished with errors\", progress);\n        progress.finishAnyway();\n      }\n      showMessageView();\n    } catch (GenerationCanceledException gce) {\n      addProgressMessage(MessageKind.WARNING, \"generation canceled\", progress);\n      progress.finishAnyway();\n      showMessageView();\n    } catch (Throwable t) {\n      LOG.error(t);\n      addProgressMessage(MessageKind.ERROR, t.toString(), progress);\n    } finally {\n      progress.finishAnyway();\n      System.gc();\n    }\n  }","id":43122,"modified_method":"public void generateModels(List<SModel> _sourceModels, Language targetLanguage, IOperationContext invocationContext, boolean generateText, IAdaptiveProgressMonitor progress) {\n    invocationContext.getProject().saveModels();\n    List<SModelDescriptor> sourceModels = new ArrayList<SModelDescriptor>();\n    for (SModel model : _sourceModels) {\n      sourceModels.add(model.getModelDescriptor());\n    }\n    clearMessages();\n    addMessage(MessageKind.INFORMATION, \"generating \" + (generateText ? \"text\" : \"files\"));\n    addMessage(MessageKind.INFORMATION, \"    target language: \\\"\" + targetLanguage.getNamespace() + \"\\\"\");\n    String outputFolder = invocationContext.getModule().getGeneratorOutputPath();\n\n    if (!new File(outputFolder).exists()) {\n      new File(outputFolder).mkdirs();\n\n      try {\n\n        myProject.getProjectHandler().addSourceRoot(outputFolder);\n      } catch (Exception e) {\n        addMessage(MessageKind.WARNING, \"Can't add output folder to IDEA as sources\");\n      }\n    }\n\n    if (!generateText) {\n      addMessage(MessageKind.INFORMATION, \"    target root folder: \\\"\" + outputFolder + \"\\\"\");\n    }\n\n    boolean ideaPresent = MPSPlugin.getInstance().isIDEAPresent();\n    boolean compile = myCompileOnGeneration && ideaPresent;\n    long totalJob = ModelsProgressUtil.estimateTotalGenerationJobMillis(compile, generateText, sourceModels);\n\n    progress.start(\"generating\", totalJob);\n\n    try {\n\n      boolean reloadClasses = true;\n\n      if (!myCompileOnGeneration) {\n        progress.addText(\"compilation in IntelliJ IDEA on generation is turned off\");\n      } else if (!ideaPresent) {\n        progress.addText(\"IntelliJ IDEA with installed MPS is not present\");\n      } else {\n        // -- compile sources before generation\n        checkMonitorCanceled(progress);\n        progress.addText(\"compiling in IntelliJ IDEA...\");\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        myProject.getProjectHandler().refreshFS();\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n        checkMonitorCanceled(progress);\n\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        CompilationResult compilationResult = myProject.getProjectHandler().buildModule(outputFolder);\n        progress.addText(\"\" + compilationResult);\n        if (!compilationResult.isOk()) {\n          reloadClasses = false;\n        }\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n        checkMonitorCanceled(progress);\n      }\n\n      // re-load classes anyway (to be sure that java_stub are up-to-date)\n      if (reloadClasses) {\n        progress.addText(\"reloading MPS classes...\");\n        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n        ReloadUtils.reloadAll();\n        progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n        checkMonitorCanceled(progress);\n      }\n\n      //++ generation\n      GenerationSession generationSession = new GenerationSession(targetLanguage, invocationContext, progress);\n      GenerationStatus status = null;\n      for (SModelDescriptor sourceModelDescriptor : sourceModels) {\n        SModel sourceModel = sourceModelDescriptor.getSModel();\n        progress.addText(\"\");\n        String taskName = ModelsProgressUtil.generationModelTaskName(sourceModelDescriptor);\n        progress.startLeafTask(taskName, ModelsProgressUtil.generationModelTaskKind());\n\n        status = generationSession.generateModel(sourceModelDescriptor);\n        checkMonitorCanceled(progress);\n        if (status.getOutputModel() != null) {\n          if (generateText) {\n            progress.addText(\"generate text to Output view\");\n            generateText(status.getOutputModel(), invocationContext);\n          } else {\n            addProgressMessage(MessageKind.INFORMATION, \"generate files to folder: \\\"\" + getOutputFolderPath(outputFolder, sourceModel) + \"\\\"\", progress);\n            generateFile(outputFolder, sourceModel, status.getOutputModel());\n          }\n        }\n\n        progress.finishTask(taskName);\n        if (!status.isOk()) {\n          break;\n        }\n      }\n      //-- generation\n\n      //update generated sources timestamp\n      updateLanguagesGenerationRequiredStatus(invocationContext);\n\n      if (isSaveTransientModels()) {\n        generationSession.saveTransientModels();\n        addProgressMessage(MessageKind.INFORMATION, \"adding module \\\"\" + generationSession.getSessionModuleName() + \"\\\"\", progress);\n        File sessionDescriptorFile = generationSession.getSessionDescriptorFile();\n        generationSession.dispose(); // unregister transient models\n        myProject.addProjectSolution(sessionDescriptorFile);\n      } else if (!status.isError()) {\n        // if ERROR - keep transient models: we need them to navigate to from error messages\n        generationSession.dispose(); // unregister transient models\n      }\n\n      checkMonitorCanceled(progress);\n      progress.addText(\"\");\n      if (status.isOk()) {\n        if (compile && !generateText) {\n          // -- compile after generation\n          progress.addText(\"compiling in IntelliJ IDEA...\");\n\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          myProject.getProjectHandler().refreshFS();\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);\n          checkMonitorCanceled(progress);\n          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          CompilationResult compilationResult = myProject.getProjectHandler().buildModule(outputFolder);\n          progress.addText(\"\" + compilationResult);\n          progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);\n          checkMonitorCanceled(progress);\n\n\n          if (compilationResult.isOk()) {\n            progress.addText(\"reloading MPS classes...\");\n            progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n            ReloadUtils.reloadAll();\n            progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);\n            checkMonitorCanceled(progress);\n          }\n        }\n        addProgressMessage(MessageKind.INFORMATION, \"generation completed successfully\", progress);\n        progress.finish();\n      } else if (status.isError()) {\n        addProgressMessage(MessageKind.WARNING, \"generation finished with errors\", progress);\n        progress.finishAnyway();\n      }\n      showMessageView();\n    } catch (GenerationCanceledException gce) {\n      addProgressMessage(MessageKind.WARNING, \"generation canceled\", progress);\n      progress.finishAnyway();\n      showMessageView();\n    } catch (Throwable t) {\n      LOG.error(t);\n      addProgressMessage(MessageKind.ERROR, t.toString(), progress);\n    } finally {\n      progress.finishAnyway();\n      System.gc();\n    }\n  }","commit_id":"7eb6e4987d8515ffb3da8fe2cb35947d3fbf0513","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String buildModule(final String path) {\n    final Object lock = new Object() { };\n    final StringBuilder result = new StringBuilder();\n    synchronized(lock) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                Module module = findModule(path);\n                if (module == null) {\n                  synchronized(lock) {\n                    lock.notifyAll();\n                  }\n                  return;\n                }\n\n                CompilerManager compilerManager = myProject.getComponent(CompilerManager.class);\n                compilerManager.make(module, new CompileStatusNotification() {\n                  public void finished(boolean aborted, int errors, int warnings) {\n                    compilationFinished(aborted, errors, warnings);\n                  }\n\n                  public void finished(boolean aborted, int errors, int warnings, CompileContext compileContext) {\n                    compilationFinished(aborted, errors, warnings);\n                  }\n\n                  private void compilationFinished(boolean aborted, int errorsNumber, int warningsNumber) {\n                    synchronized(lock) {\n                      if (aborted) {\n                        result.append(\"compilation aborted\");\n                      } else {\n                        result.append(\"compilation finished : \");\n                        result.append(errorsNumber).append(\" errors \");\n                        result.append(warningsNumber).append(\" warnings\");\n                      }                      \n                      lock.notifyAll();\n                    }\n                  }\n                });\n              }\n            });\n          }\n      });\n      try {\n        lock.wait();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n    return result.toString();\n  }","id":43123,"modified_method":"public CompilationResult buildModule(final String path) {\n    final Object lock = new Object() { };\n    final CompilationResult[] result = new CompilationResult[1];\n    synchronized(lock) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                Module module = findModule(path);\n                if (module == null) {\n                  synchronized(lock) {\n                    lock.notifyAll();\n                  }\n                  return;\n                }\n\n                CompilerManager compilerManager = myProject.getComponent(CompilerManager.class);\n                compilerManager.make(module, new CompileStatusNotification() {\n                  public void finished(boolean aborted, int errors, int warnings) {\n                    compilationFinished(aborted, errors, warnings);\n                  }\n\n                  public void finished(boolean aborted, int errors, int warnings, CompileContext compileContext) {\n                    compilationFinished(aborted, errors, warnings);\n                  }\n\n                  private void compilationFinished(boolean aborted, int errorsNumber, int warningsNumber) {\n                    synchronized(lock) {\n                      result[0] = new CompilationResult(errorsNumber, warningsNumber, aborted);\n                      lock.notifyAll();\n                    }\n                  }\n                });\n              }\n            });\n          }\n      });\n      try {\n        lock.wait();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n    return result[0];\n  }","commit_id":"7eb6e4987d8515ffb3da8fe2cb35947d3fbf0513","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void moveEntryToTrash(HttpPrincipal httpPrincipal,\n\t\tlong entryId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\ttry {\n\t\t\tMethodKey methodKey = new MethodKey(BlogsEntryServiceUtil.class,\n\t\t\t\t\t\"moveEntryToTrash\", _moveEntryToTrashParameterTypes16);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(methodKey, entryId);\n\n\t\t\ttry {\n\t\t\t\tTunnelUtil.invoke(httpPrincipal, methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)e;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.SystemException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.SystemException)e;\n\t\t\t\t}\n\n\t\t\t\tthrow new com.liferay.portal.kernel.exception.SystemException(e);\n\t\t\t}\n\t\t}\n\t\tcatch (com.liferay.portal.kernel.exception.SystemException se) {\n\t\t\t_log.error(se, se);\n\n\t\t\tthrow se;\n\t\t}\n\t}","id":43124,"modified_method":"public static com.liferay.portlet.blogs.model.BlogsEntry moveEntryToTrash(\n\t\tHttpPrincipal httpPrincipal, long entryId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\ttry {\n\t\t\tMethodKey methodKey = new MethodKey(BlogsEntryServiceUtil.class,\n\t\t\t\t\t\"moveEntryToTrash\", _moveEntryToTrashParameterTypes16);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(methodKey, entryId);\n\n\t\t\tObject returnObj = null;\n\n\t\t\ttry {\n\t\t\t\treturnObj = TunnelUtil.invoke(httpPrincipal, methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)e;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.SystemException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.SystemException)e;\n\t\t\t\t}\n\n\t\t\t\tthrow new com.liferay.portal.kernel.exception.SystemException(e);\n\t\t\t}\n\n\t\t\treturn (com.liferay.portlet.blogs.model.BlogsEntry)returnObj;\n\t\t}\n\t\tcatch (com.liferay.portal.kernel.exception.SystemException se) {\n\t\t\t_log.error(se, se);\n\n\t\t\tthrow se;\n\t\t}\n\t}","commit_id":"56d4eb7374e75c6b2ad4f45bd4093e4d26fffe9a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void moveEntryToTrash(long entryId) throws RemoteException {\n\t\ttry {\n\t\t\tBlogsEntryServiceUtil.moveEntryToTrash(entryId);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new RemoteException(e.getMessage());\n\t\t}\n\t}","id":43125,"modified_method":"public static com.liferay.portlet.blogs.model.BlogsEntrySoap moveEntryToTrash(\n\t\tlong entryId) throws RemoteException {\n\t\ttry {\n\t\t\tcom.liferay.portlet.blogs.model.BlogsEntry returnValue = BlogsEntryServiceUtil.moveEntryToTrash(entryId);\n\n\t\t\treturn com.liferay.portlet.blogs.model.BlogsEntrySoap.toSoapModel(returnValue);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new RemoteException(e.getMessage());\n\t\t}\n\t}","commit_id":"56d4eb7374e75c6b2ad4f45bd4093e4d26fffe9a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void moveEntryToTrash(long entryId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tgetService().moveEntryToTrash(entryId);\n\t}","id":43126,"modified_method":"public static com.liferay.portlet.blogs.model.BlogsEntry moveEntryToTrash(\n\t\tlong entryId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().moveEntryToTrash(entryId);\n\t}","commit_id":"56d4eb7374e75c6b2ad4f45bd4093e4d26fffe9a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void moveEntryToTrash(long entryId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\t_blogsEntryService.moveEntryToTrash(entryId);\n\t}","id":43127,"modified_method":"@Override\n\tpublic com.liferay.portlet.blogs.model.BlogsEntry moveEntryToTrash(\n\t\tlong entryId)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _blogsEntryService.moveEntryToTrash(entryId);\n\t}","commit_id":"56d4eb7374e75c6b2ad4f45bd4093e4d26fffe9a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void moveEntryToTrash(long entryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBlogsEntryPermission.check(\n\t\t\tgetPermissionChecker(), entryId, ActionKeys.DELETE);\n\n\t\tblogsEntryLocalService.moveEntryToTrash(getUserId(), entryId);\n\t}","id":43128,"modified_method":"@Override\n\tpublic BlogsEntry moveEntryToTrash(long entryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBlogsEntryPermission.check(\n\t\t\tgetPermissionChecker(), entryId, ActionKeys.DELETE);\n\n\t\treturn blogsEntryLocalService.moveEntryToTrash(getUserId(), entryId);\n\t}","commit_id":"c3bd5c0d481100029bc1c15a7e852fbf020c96b6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest httprequest, ToadletContext ctx) \n\t\t\tthrows ToadletContextClosedException, IOException, RedirectException {\n\n\t\tString ks = uri.getPath();\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif (ks.equals(\"/\")) {\n\t\t\tif (httprequest.isParameterSet(\"key\")) {\n\t\t\t\tString k = httprequest.getParam(\"key\");\n\t\t\t\tFreenetURI newURI;\n\t\t\t\ttry {\n\t\t\t\t\tnewURI = new FreenetURI(k);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.normal(this, \"Invalid key: \"+e+\" for \"+k, e);\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"notFoundTitle\"), L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to FreenetURI: \"+newURI);\n\t\t\t\tString type = httprequest.getParam(\"type\");\n\t\t\t\tString location;\n\t\t\t\tif ((type != null) && (type.length() > 0)) {\n\t\t\t\t\tlocation =  \"/\"+newURI + \"?type=\" + type;\n\t\t\t\t} else {\n\t\t\t\t\tlocation =  \"/\"+newURI;\n\t\t\t\t}\n\t\t\t\twriteTemporaryRedirect(ctx, null, location);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString querystring = uri.getQuery();\n\t\t\t\t\n\t\t\t\tif (querystring == null) {\n\t\t\t\t\tthrow new RedirectException(welcome);\n\t\t\t\t} else {\n\t\t\t\t\t// TODP possibly a proper URLEncode method\n\t\t\t\t\tquerystring = querystring.replace(' ', '+');\n\t\t\t\t\tthrow new RedirectException(\"/welcome/?\" + querystring);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}else if(ks.equals(\"/favicon.ico\")){\n\t\t\tbyte[] buf = new byte[1024];\n\t\t\tint len;\n\t\t\tInputStream strm = getClass().getResourceAsStream(\"staticfiles/favicon.ico\");\n\t\t\t\n\t\t\tif (strm == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/x-icon\", strm.available());\n\t\t\t\n\t\t\twhile ( (len = strm.read(buf)) > 0) {\n\t\t\t\tctx.writeData(buf, 0, len);\n\t\t\t}\n\t\t\treturn;\n\t\t}else if(ks.equals(\"/robots.txt\") && ctx.doRobots()){\n\t\t\tthis.writeTextReply(ctx, 200, \"Ok\", \"User-agent: *\\nDisallow: /\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/darknet/\") || ks.equals(\"/darknet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/friends/\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/opennet/\") || ks.equals(\"/opennet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/strangers/\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\t\n\t\tlong maxSize;\n\t\t\n\t\tboolean restricted = (container.publicGatewayMode() && !ctx.isAllowedFullAccess());\n\t\t\n\t\tif(restricted)\n\t\t\tmaxSize = MAX_LENGTH;\n\t\telse \n\t\t\tmaxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\n\t\tFreenetURI key;\n\t\ttry {\n\t\t\tkey = new FreenetURI(ks);\n\t\t} catch (MalformedURLException e) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"invalidKeyTitle\"), ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\n\t\t\tHTMLNode errorInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\terrorInfobox.addChild(\"div\", \"class\", \"infobox-header\", L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\tHTMLNode errorContent = errorInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\terrorContent.addChild(\"#\", l10n(\"expectedKeyButGot\"));\n\t\t\terrorContent.addChild(\"code\", ks);\n\t\t\terrorContent.addChild(\"br\");\n\t\t\terrorContent.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBack\")));\n\t\t\terrorContent.addChild(\"br\");\n\t\t\taddHomepageLink(errorContent);\n\n\t\t\tthis.writeHTMLReply(ctx, 400, l10n(\"invalidKeyTitle\"), pageNode.generate());\n\t\t\treturn;\n\t\t}\n\t\tString requestedMimeType = httprequest.getParam(\"type\", null);\n\t\tString override = (requestedMimeType == null) ? \"\" : \"?type=\"+URLEncoder.encode(requestedMimeType,true);\n\t\t// No point passing ?force= across a redirect, since the key will change.\n\t\t// However, there is every point in passing ?forcedownload.\n\t\tif(httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tif(override.length() == 0) override = \"?forcedownload\";\n\t\t\telse override = override+\"&forcedownload\";\n\t\t}\n\t\tBucket data = null;\n\t\ttry {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"FProxy fetching \"+key+\" (\"+maxSize+ ')');\n\t\t\tFetchResult result = fetch(key, maxSize, httprequest /* fixme replace if HTTPRequest ever becomes comparable */); \n\t\t\t\n\t\t\t// Now, is it safe?\n\t\t\t\n\t\t\tdata = result.asBucket();\n\t\t\tString mimeType = result.getMimeType();\n\t\t\t\n\t\t\tString referer = sanitizeReferer(ctx);\n\t\t\t\n\t\t\t\n\t\t\thandleDownload(ctx, data, ctx.getBucketFactory(), mimeType, requestedMimeType, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"), \"/\", key, uri, maxSize != MAX_LENGTH ? \"&max-size=\"+SizeUtil.formatSizeWithoutSpace(maxSize) : \"\", referer, true, ctx, core);\n\t\t\t\n\t\t} catch (FetchException e) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Failed to fetch \"+uri+\" : \"+e);\n\t\t\tif(e.newURI != null) {\n\t\t\t\tToadlet.writePermanentRedirect(ctx, msg, ctx.fixLink('/' +e.newURI.toASCIIString() + override));\n\t\t\t} else if(e.mode == FetchException.TOO_BIG) {\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"fileInformationTitle\"), ctx);\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\t\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"largeFile\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", ctx.fixLink('/' + key.toString()), getFilename(e, key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"largeFileExplanationAndOptions\"));\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\tif(!restricted) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\toption.addChild(\"a\", \"href\", ctx.fixLink(\"/\" + key.toString() + \"?max-size=\"+String.valueOf(e.expectedSize == -1 ? Long.MAX_VALUE : e.expectedSize*2)), l10n(\"fetchLargeFileAnywayAndDisplay\"));\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/queue/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\") });\n\t\t\t\t}\n\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { ctx.fixLink(\"/\"), L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(FetchException.getShortMessage(e.mode), ctx);\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"errorWithReason\", \"error\", FetchException.getShortMessage(e.mode)));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", ctx.fixLink('/' + key.toString()), getFilename(e, key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"unableToRetrieve\"));\n\t\t\t\tif(e.isFatal())\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"errorIsFatal\"));\n\t\t\t\tinfoboxContent.addChild(\"p\", msg);\n\t\t\t\tif(e.errorCodes != null) {\n\t\t\t\t\tinfoboxContent.addChild(\"p\").addChild(\"pre\").addChild(\"#\", e.errorCodes.toVerboseString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"options\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tif((e.mode == FetchException.NOT_IN_ARCHIVE) && (core.node.pluginManager.isPluginLoaded(\"plugins.KeyExplorer.KeyExplorer\"))) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openWithKeyExplorer\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+ctx.fixLink(\"/plugins/plugins.KeyExplorer.KeyExplorer/?key=\" + key.toString()) + \"\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!e.isFatal() && (ctx.isAllowedFullAccess() || !container.publicGatewayMode())) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/queue/\", \"dnfQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\")});\n\t\t\t\t\t\n\t\t\t\t\toptionList.addChild(\"li\").\n\t\t\t\t\t\taddChild(\"a\", \"href\", ctx.fixLink(getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\")))).addChild(\"#\", l10n(\"retryNow\"));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { ctx.fixLink(\"/\"), L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tthis.writeHTMLReply(ctx, (e.mode == 10) ? 404 : 500 /* close enough - FIXME probably should depend on status code */,\n\t\t\t\t\t\t\"Internal Error\", pageNode.generate());\n\t\t\t}\n\t\t} catch (SocketException e) {\n\t\t\t// Probably irrelevant\n\t\t\tif(e.getMessage().equals(\"Broken pipe\")) {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Caught \"+e+\" while handling GET\", e);\n\t\t\t} else {\n\t\t\t\tLogger.normal(this, \"Caught \"+e);\n\t\t\t}\n\t\t\tthrow e;\n\t\t} catch (Throwable t) {\n\t\t\twriteInternalError(t, ctx);\n\t\t} finally {\n\t\t\tif(data != null) data.free();\n\t\t}\n\t}","id":43129,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest httprequest, ToadletContext ctx) \n\t\t\tthrows ToadletContextClosedException, IOException, RedirectException {\n\n\t\tString ks = uri.getPath();\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif (ks.equals(\"/\")) {\n\t\t\tif (httprequest.isParameterSet(\"key\")) {\n\t\t\t\tString k = httprequest.getParam(\"key\");\n\t\t\t\tFreenetURI newURI;\n\t\t\t\ttry {\n\t\t\t\t\tnewURI = new FreenetURI(k);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.normal(this, \"Invalid key: \"+e+\" for \"+k, e);\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"notFoundTitle\"), L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to FreenetURI: \"+newURI);\n\t\t\t\tString type = httprequest.getParam(\"type\");\n\t\t\t\tString location;\n\t\t\t\tif ((type != null) && (type.length() > 0)) {\n\t\t\t\t\tlocation =  \"/\"+newURI + \"?type=\" + type;\n\t\t\t\t} else {\n\t\t\t\t\tlocation =  \"/\"+newURI;\n\t\t\t\t}\n\t\t\t\twriteTemporaryRedirect(ctx, null, location);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString querystring = uri.getQuery();\n\t\t\t\t\n\t\t\t\tif (querystring == null) {\n\t\t\t\t\tthrow new RedirectException(welcome);\n\t\t\t\t} else {\n\t\t\t\t\t// TODP possibly a proper URLEncode method\n\t\t\t\t\tquerystring = querystring.replace(' ', '+');\n\t\t\t\t\tthrow new RedirectException(\"/welcome/?\" + querystring);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}else if(ks.equals(\"/favicon.ico\")){\n\t\t\tbyte[] buf = new byte[1024];\n\t\t\tint len;\n\t\t\tInputStream strm = getClass().getResourceAsStream(\"staticfiles/favicon.ico\");\n\t\t\t\n\t\t\tif (strm == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/x-icon\", strm.available());\n\t\t\t\n\t\t\twhile ( (len = strm.read(buf)) > 0) {\n\t\t\t\tctx.writeData(buf, 0, len);\n\t\t\t}\n\t\t\treturn;\n\t\t}else if(ks.equals(\"/robots.txt\") && ctx.doRobots()){\n\t\t\tthis.writeTextReply(ctx, 200, \"Ok\", \"User-agent: *\\nDisallow: /\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/darknet/\") || ks.equals(\"/darknet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/friends/\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/opennet/\") || ks.equals(\"/opennet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/strangers/\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\t\n\t\tlong maxSize;\n\t\t\n\t\tboolean restricted = (container.publicGatewayMode() && !ctx.isAllowedFullAccess());\n\t\t\n\t\tif(restricted)\n\t\t\tmaxSize = MAX_LENGTH;\n\t\telse \n\t\t\tmaxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\n\t\tFreenetURI key;\n\t\ttry {\n\t\t\tkey = new FreenetURI(ks);\n\t\t} catch (MalformedURLException e) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"invalidKeyTitle\"), ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\n\t\t\tHTMLNode errorInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\terrorInfobox.addChild(\"div\", \"class\", \"infobox-header\", L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\tHTMLNode errorContent = errorInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\terrorContent.addChild(\"#\", l10n(\"expectedKeyButGot\"));\n\t\t\terrorContent.addChild(\"code\", ks);\n\t\t\terrorContent.addChild(\"br\");\n\t\t\terrorContent.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBack\")));\n\t\t\terrorContent.addChild(\"br\");\n\t\t\taddHomepageLink(errorContent);\n\n\t\t\tthis.writeHTMLReply(ctx, 400, l10n(\"invalidKeyTitle\"), pageNode.generate());\n\t\t\treturn;\n\t\t}\n\t\tString requestedMimeType = httprequest.getParam(\"type\", null);\n\t\tString override = (requestedMimeType == null) ? \"\" : \"?type=\"+URLEncoder.encode(requestedMimeType,true);\n\t\t// No point passing ?force= across a redirect, since the key will change.\n\t\t// However, there is every point in passing ?forcedownload.\n\t\tif(httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tif(override.length() == 0) override = \"?forcedownload\";\n\t\t\telse override = override+\"&forcedownload\";\n\t\t}\n\t\tBucket data = null;\n\t\ttry {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"FProxy fetching \"+key+\" (\"+maxSize+ ')');\n\t\t\tFetchResult result = fetch(key, maxSize, httprequest /* fixme replace if HTTPRequest ever becomes comparable */); \n\t\t\t\n\t\t\t// Now, is it safe?\n\t\t\t\n\t\t\tdata = result.asBucket();\n\t\t\tString mimeType = result.getMimeType();\n\t\t\t\n\t\t\tString referer = sanitizeReferer(ctx);\n\t\t\t\n\t\t\t\n\t\t\thandleDownload(ctx, data, ctx.getBucketFactory(), mimeType, requestedMimeType, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"), \"/\", key, uri, maxSize != MAX_LENGTH ? \"&max-size=\"+SizeUtil.formatSizeWithoutSpace(maxSize) : \"\", referer, true, ctx, core);\n\t\t\t\n\t\t} catch (FetchException e) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Failed to fetch \"+uri+\" : \"+e);\n\t\t\tif(e.newURI != null) {\n\t\t\t\tToadlet.writePermanentRedirect(ctx, msg, ctx.fixLink('/' +e.newURI.toASCIIString() + override));\n\t\t\t} else if(e.mode == FetchException.TOO_BIG) {\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"fileInformationTitle\"), ctx);\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\t\t\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"largeFile\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", ctx.fixLink('/' + key.toString()), getFilename(e, key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"largeFileExplanationAndOptions\"));\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\tif(!restricted) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/\" + key.toString(), \"fetchLargeFileDirectlyForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"max-size\", String.valueOf(e.expectedSize == -1 ? Long.MAX_VALUE : e.expectedSize*2) });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"fetch\", l10n(\"fetchLargeFileAnywayAndDisplay\") });\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\toptionForm = ctx.addFormChild(option, \"/queue/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\") });\n\t\t\t\t}\n\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { ctx.fixLink(\"/\"), L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(FetchException.getShortMessage(e.mode), ctx);\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"errorWithReason\", \"error\", FetchException.getShortMessage(e.mode)));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", ctx.fixLink('/' + key.toString()), getFilename(e, key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"unableToRetrieve\"));\n\t\t\t\tif(e.isFatal())\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"errorIsFatal\"));\n\t\t\t\tinfoboxContent.addChild(\"p\", msg);\n\t\t\t\tif(e.errorCodes != null) {\n\t\t\t\t\tinfoboxContent.addChild(\"p\").addChild(\"pre\").addChild(\"#\", e.errorCodes.toVerboseString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"options\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tif((e.mode == FetchException.NOT_IN_ARCHIVE) && (core.node.pluginManager.isPluginLoaded(\"plugins.KeyExplorer.KeyExplorer\"))) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openWithKeyExplorer\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+ctx.fixLink(\"/plugins/plugins.KeyExplorer.KeyExplorer/?key=\" + key.toString()) + \"\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!e.isFatal() && (ctx.isAllowedFullAccess() || !container.publicGatewayMode())) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/queue/\", \"dnfQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\")});\n\t\t\t\t\t\n\t\t\t\t\toptionList.addChild(\"li\").\n\t\t\t\t\t\taddChild(\"a\", \"href\", ctx.fixLink(getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\")))).addChild(\"#\", l10n(\"retryNow\"));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { ctx.fixLink(\"/\"), L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tthis.writeHTMLReply(ctx, (e.mode == 10) ? 404 : 500 /* close enough - FIXME probably should depend on status code */,\n\t\t\t\t\t\t\"Internal Error\", pageNode.generate());\n\t\t\t}\n\t\t} catch (SocketException e) {\n\t\t\t// Probably irrelevant\n\t\t\tif(e.getMessage().equals(\"Broken pipe\")) {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Caught \"+e+\" while handling GET\", e);\n\t\t\t} else {\n\t\t\t\tLogger.normal(this, \"Caught \"+e);\n\t\t\t}\n\t\t\tthrow e;\n\t\t} catch (Throwable t) {\n\t\t\twriteInternalError(t, ctx);\n\t\t} finally {\n\t\t\tif(data != null) data.free();\n\t\t}\n\t}","commit_id":"d3bacee2cd53184397c5062d2201efc478b8c87e","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void handlePost(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tString ks = uri.getPath();\n\t\t\n\t\tif (ks.equals(\"/\")||ks.startsWith(\"/servlet/\")) {\n\t\t\ttry {\n\t            throw new RedirectException(\"/welcome/\");\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}\t\t\n\t}","id":43130,"modified_method":"@Override\n\tpublic void handlePost(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tString ks = uri.getPath();\n\t\t\n\t\tString maxSize = req.isPartSet(\"max-size\") ? req.getPartAsString(\"max-size\", 30) : null;\n\t\tString type = req.isPartSet(\"type\") ? req.getPartAsString(\"type\", 30) : null;\n\t\tboolean forceDownload = req.isPartSet(\"forcedownload\");\n\t\tString force = req.isPartSet(\"force\") ? req.getPartAsString(\"force\", 30) : null;\n\t\t\n\t\tString pass = req.getPartAsString(\"formPassword\", 32);\n\t\tif ((pass.length() == 0) || !pass.equals(core.formPassword)) {\n\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t\theaders.put(\"Location\", ctx.fixLink(\"/\"));\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tif(maxSize != null || type != null || (!forceDownload) || force != null) {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tboolean first = true;\n\t\t\tif(maxSize != null) {\n\t\t\t\tsb.append(\"max-size=\");\n\t\t\t\tsb.append(URLEncoder.encode(maxSize, false));\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tif(type != null) {\n\t\t\t\tif(!first) sb.append('&');\n\t\t\t\tsb.append(\"type=\");\n\t\t\t\tsb.append(URLEncoder.encode(type, false));\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tif(forceDownload) {\n\t\t\t\tif(!first) sb.append('&');\n\t\t\t\tsb.append(\"forcedownload\");\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tif(force != null) {\n\t\t\t\tif(!first) sb.append('&');\n\t\t\t\tsb.append(\"force=\");\n\t\t\t\tsb.append(URLEncoder.encode(force, false));\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tString params = sb.toString();\n\t\t\ttry {\n\t\t\t\turi = new URI(null, null, null, 80, uri.getPath(), params, null);\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tLogger.error(this, \"Impossible: \"+e, e);\n\t\t\t\tthis.writeInternalError(e, ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handleGet(uri, new HTTPRequestImpl(uri), ctx);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tif (ks.equals(\"/\")||ks.startsWith(\"/servlet/\")) {\n\t\t\ttry {\n\t            throw new RedirectException(\"/welcome/\");\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}\t\t\n\t}","commit_id":"d3bacee2cd53184397c5062d2201efc478b8c87e","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic String postStep(HTTPRequest request)  {\n\n\t\t//Custom limit given\n\t\tif (request.isPartSet(\"customSelect\")) {\n\t\t\tString down = request.getPartAsStringFailsafe(\"customDown\", 20);\n\t\t\tString up = request.getPartAsStringFailsafe(\"customUp\", 20);\n\t\t\t//Remove per second indicator so that it can be parsed.\n\t\t\tdown = down.replace(WizardL10n.l10n(\"bandwidthPerSecond\"), \"\");\n\t\t\tup = up.replace(WizardL10n.l10n(\"bandwidthPerSecond\"), \"\");\n\n\t\t\tString failedLimits = attemptSet(up, down);\n\n\t\t\tif (!failedLimits.isEmpty()) {\n\t\t\t\t//Some at least one limit failed to parse.\n\t\t\t\treturn FirstTimeWizardToadlet.TOADLET_URL+\"?step=BANDWIDTH_RATE&parseError=true&parseTarget=\"+\n\t\t\t\t        URLEncoder.encode(failedLimits, true);\n\t\t\t}\n\n\t\t\t//Success\n\t\t\tsetWizardComplete();\n\t\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.COMPLETE.name();\n\t\t}\n\n\t\t//Pre-defined limit selected.\n\t\tString preset = attemptSet(request.getPartAsStringFailsafe(\"upBytes\", 20),\n\t\t        request.getPartAsStringFailsafe(\"downBytes\", 20));\n\n\t\tif(!preset.isEmpty()) {\n\t\t\t//Error parsing predefined limit.\n\t\t\t//This should not happen, as there are no units to confound the parser.\n\t\t\tLogger.error(this, \"Failed to parse pre-defined limit! Please report.\");\n\t\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.BANDWIDTH_RATE+\"&parseError=true&parseTarget=\"+\n\t\t\t\t        URLEncoder.encode(preset, true);\n\t\t}\n\n\t\tsetWizardComplete();\n\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.COMPLETE.name();\n\t}","id":43131,"modified_method":"@Override\n\tpublic String postStep(HTTPRequest request)  {\n\n\t\tString limitSelected = request.getPartAsStringFailsafe(\"bandwidth\", 100);\n\t\t\n\t\tif(\"custom\".equals(limitSelected)) {\n\t\t\t//Custom limit given\n\t\t\tString down = request.getPartAsStringFailsafe(\"customDown\", 20);\n\t\t\tString up = request.getPartAsStringFailsafe(\"customUp\", 20);\n\t\t\t//Remove per second indicator so that it can be parsed.\n\t\t\tdown = down.replace(WizardL10n.l10n(\"bandwidthPerSecond\"), \"\");\n\t\t\tup = up.replace(WizardL10n.l10n(\"bandwidthPerSecond\"), \"\");\n\n\t\t\tString failedLimits = attemptSet(up, down);\n\n\t\t\tif (!failedLimits.isEmpty()) {\n\t\t\t\t//Some at least one limit failed to parse.\n\t\t\t\treturn FirstTimeWizardToadlet.TOADLET_URL+\"?step=BANDWIDTH_RATE&parseError=true&parseTarget=\"+\n\t\t\t\t        URLEncoder.encode(failedLimits, true);\n\t\t\t}\n\n\t\t\t//Success\n\t\t\tsetWizardComplete();\n\t\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.COMPLETE.name();\n\t\t}\n\n\t\tif(!limitSelected.isEmpty()) {\n\t\t\tint x = limitSelected.indexOf('/');\n\t\t\tif(x != -1) {\n\t\t\t\tString downString = limitSelected.substring(0, x);\n\t\t\t\tString upString = limitSelected.substring(x+1);\n\t\t\t\t//Pre-defined limit selected.\n\t\t\t\tString preset = attemptSet(upString, downString);\n\t\t\t\tif(!preset.isEmpty()) {\n\t\t\t\t\t//Error parsing predefined limit.\n\t\t\t\t\t//This should not happen, as there are no units to confound the parser.\n\t\t\t\t\tLogger.error(this, \"Failed to parse pre-defined limit! Please report.\");\n\t\t\t\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.BANDWIDTH_RATE+\"&parseError=true&parseTarget=\"+\n\t\t\t\t\t\t\tURLEncoder.encode(preset, true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.error(this, \"No bandwidth limit set!\");\n\t\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.BANDWIDTH_RATE.name();\n\t\t}\n\t\t\n\t\tsetWizardComplete();\n\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.COMPLETE.name();\n\t}","commit_id":"88c419bcc669019c26e2df0f16f4c3383b83f12a","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Adds a row to the table for the given limit. Adds download limit, upload limit, and selection button.\n\t * @param table Table to add a row to.\n\t * @param helper To make a form for the button and hidden fields.\n\t * @param limit Limit to display.\n\t * @param recommended Whether to mark the limit with (Recommended) next to the select button.\n\t */\n\tprivate void addLimitRow(HTMLNode table, PageHelper helper, BandwidthLimit limit, boolean recommended) {\n\t\tHTMLNode row = table.addChild(\"tr\");\n\t\trow.addChild(\"td\", WizardL10n.l10n(limit.descriptionKey));\n\t\tString downColumn = SizeUtil.formatSize(limit.downBytes)+WizardL10n.l10n(\"bandwidthPerSecond\");\n\t\tif(limit.downBytes >= 32*1024) {\n\t\t\tdownColumn += \" (= \";\n\t\t\tif(limit.downBytes < 256*1024)\n\t\t\t\tdownColumn += new DecimalFormat(\"0.0\").format(((double)((limit.downBytes*8)))/(1024*1024));\n\t\t\telse\n\t\t\t\tdownColumn += ((limit.downBytes*8)/(1024*1024));\n\t\t\tdownColumn+=\"Mbps)\";\n\t\t}\n\t\trow.addChild(\"td\", downColumn);\n\t\trow.addChild(\"td\", SizeUtil.formatSize(limit.upBytes)+WizardL10n.l10n(\"bandwidthPerSecond\"));\n\n\t\tHTMLNode buttonCell = row.addChild(\"td\");\n\t\tHTMLNode form = helper.addFormChild(buttonCell, \".\", \"limit\");\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"hidden\", \"downBytes\", String.valueOf(limit.downBytes)});\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"hidden\", \"upBytes\", String.valueOf(limit.upBytes)});\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"select\", WizardL10n.l10n(\"bandwidthSelect\")});\n\t\tif (recommended) {\n\t\t\tbuttonCell.addChild(\"#\", WizardL10n.l10n(\"autodetectedSuggestedLimit\"));\n\t\t}\n\t}","id":43132,"modified_method":"/**\n\t * Adds a row to the table for the given limit. Adds download limit, upload limit, and selection button.\n\t * @param table Table to add a row to.\n\t * @param helper To make a form for the button and hidden fields.\n\t * @param limit Limit to display.\n\t * @param recommended Whether to mark the limit with (Recommended) next to the select button.\n\t */\n\tprivate void addLimitRow(HTMLNode table, PageHelper helper, BandwidthLimit limit, boolean recommended) {\n\t\tHTMLNode row = table.addChild(\"tr\");\n\t\trow.addChild(\"td\", WizardL10n.l10n(limit.descriptionKey));\n\t\tString downColumn = SizeUtil.formatSize(limit.downBytes)+WizardL10n.l10n(\"bandwidthPerSecond\");\n\t\tif(limit.downBytes >= 32*1024) {\n\t\t\tdownColumn += \" (= \";\n\t\t\tif(limit.downBytes < 256*1024)\n\t\t\t\tdownColumn += new DecimalFormat(\"0.0\").format(((double)((limit.downBytes*8)))/(1024*1024));\n\t\t\telse\n\t\t\t\tdownColumn += ((limit.downBytes*8)/(1024*1024));\n\t\t\tdownColumn+=\"Mbps)\";\n\t\t}\n\t\trow.addChild(\"td\", downColumn);\n\t\trow.addChild(\"td\", SizeUtil.formatSize(limit.upBytes)+WizardL10n.l10n(\"bandwidthPerSecond\"));\n\n\t\tHTMLNode buttonCell = row.addChild(\"td\");\n\t\t\n\t\tHTMLNode radio = \n\t\t\tbuttonCell.addChild(\"input\",\n\t\t\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t\tnew String[] { \"radio\", \"bandwidth\", limit.downBytes+\"/\"+limit.upBytes });\n\t\tif (recommended) {\n\t\t\tradio.addAttribute(\"checked\", \"checked\");\n\t\t\tbuttonCell.addChild(\"#\", WizardL10n.l10n(\"autodetectedSuggestedLimit\"));\n\t\t}\n\t}","commit_id":"88c419bcc669019c26e2df0f16f4c3383b83f12a","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void getStep(HTTPRequest request, PageHelper helper) {\n\t\tHTMLNode contentNode = helper.getPageContent(WizardL10n.l10n(\"bandwidthLimit\"));\n\n\t\tif (request.isParameterSet(\"parseError\")) {\n\t\t\tparseErrorBox(contentNode, helper, request.getParam(\"parseTarget\"));\n\t\t}\n\n\t\tHTMLNode infoBox = helper.getInfobox(\"infobox-normal\", WizardL10n.l10n(\"bandwidthLimitRateTitle\"),\n\t\t        contentNode, null, false);\n\t\tNodeL10n.getBase().addL10nSubstitution(infoBox, \"FirstTimeWizardToadlet.bandwidthLimitRate\",\n\t\t        new String[] { \"bold\", \"coreSettings\" }, new HTMLNode[] { HTMLNode.STRONG, \n\t\t                new HTMLNode(\"#\", NodeL10n.getBase().getString(\"ConfigToadlet.node\"))});\n\n\t\t//Table header\n\t\tHTMLNode table = infoBox.addChild(\"table\");\n\t\tHTMLNode headerRow = table.addChild(\"tr\");\n\t\theaderRow.addChild(\"th\", WizardL10n.l10n(\"bandwidthConnectionHeader\"));\n\t\theaderRow.addChild(\"th\", WizardL10n.l10n(\"bandwidthDownloadHeader\"));\n\t\theaderRow.addChild(\"th\", WizardL10n.l10n(\"bandwidthUploadHeader\"));\n\t\theaderRow.addChild(\"th\", WizardL10n.l10n(\"bandwidthSelect\"));\n\n\t\tBandwidthLimit detected = detectBandwidthLimits();\n\t\tif (detected.downBytes > 0 && detected.upBytes > 0) {\n\t\t\t//Detected limits reasonable; add half of both as recommended option.\n\t\t\tBandwidthLimit usable = new BandwidthLimit(detected.downBytes/2, detected.upBytes/2, \"bandwidthDetected\");\n\t\t\taddLimitRow(table, helper, usable, true);\n\t\t}\n\n\t\tfor (BandwidthLimit limit : limits) {\n\t\t\taddLimitRow(table, helper, limit, false);\n\t\t}\n\n\t\t//Add custom option.\n\t\tHTMLNode customForm = helper.addFormChild(table.addChild(\"tr\"), \".\", \"custom-limit\");\n\t\tcustomForm.addChild(\"td\", WizardL10n.l10n(\"bandwidthCustom\"));\n\t\tcustomForm.addChild(\"td\").addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\" },\n\t\t        new String[] { \"text\", \"customDown\" });\n\t\tcustomForm.addChild(\"td\").addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\" },\n\t\t        new String[] { \"text\", \"customUp\" });\n\t\tcustomForm.addChild(\"td\").addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"customSelect\", WizardL10n.l10n(\"bandwidthSelect\")});\n\n\t\tHTMLNode backForm = helper.addFormChild(infoBox, \".\", \"backForm\");\n\t\tbackForm.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"back\", NodeL10n.getBase().getString(\"Toadlet.back\")});\n\t}","id":43133,"modified_method":"@Override\n\tpublic void getStep(HTTPRequest request, PageHelper helper) {\n\t\tHTMLNode contentNode = helper.getPageContent(WizardL10n.l10n(\"bandwidthLimit\"));\n\t\t\n\t\tHTMLNode formNode = helper.addFormChild(contentNode, \".\", \"limit\");\n\n\t\tif (request.isParameterSet(\"parseError\")) {\n\t\t\tparseErrorBox(contentNode, helper, request.getParam(\"parseTarget\"));\n\t\t}\n\n\t\tHTMLNode infoBox = helper.getInfobox(\"infobox-normal\", WizardL10n.l10n(\"bandwidthLimitRateTitle\"),\n\t\t        formNode, null, false);\n\t\tNodeL10n.getBase().addL10nSubstitution(infoBox, \"FirstTimeWizardToadlet.bandwidthLimitRate\",\n\t\t        new String[] { \"bold\", \"coreSettings\" }, new HTMLNode[] { HTMLNode.STRONG, \n\t\t                new HTMLNode(\"#\", NodeL10n.getBase().getString(\"ConfigToadlet.node\"))});\n\n\t\t//Table header\n\t\tHTMLNode table = infoBox.addChild(\"table\");\n\t\tHTMLNode headerRow = table.addChild(\"tr\");\n\t\theaderRow.addChild(\"th\", WizardL10n.l10n(\"bandwidthConnectionHeader\"));\n\t\theaderRow.addChild(\"th\", WizardL10n.l10n(\"bandwidthDownloadHeader\"));\n\t\theaderRow.addChild(\"th\", WizardL10n.l10n(\"bandwidthUploadHeader\"));\n\t\theaderRow.addChild(\"th\", WizardL10n.l10n(\"bandwidthSelect\"));\n\n\t\tBandwidthLimit detected = detectBandwidthLimits();\n\t\tif (detected.downBytes > 0 && detected.upBytes > 0) {\n\t\t\t//Detected limits reasonable; add half of both as recommended option.\n\t\t\tBandwidthLimit usable = new BandwidthLimit(detected.downBytes/2, detected.upBytes/2, \"bandwidthDetected\");\n\t\t\taddLimitRow(table, helper, usable, true);\n\t\t}\n\n\t\tfor (BandwidthLimit limit : limits) {\n\t\t\taddLimitRow(table, helper, limit, false);\n\t\t}\n\n\t\t//Add custom option.\n\t\tHTMLNode customForm = table.addChild(\"tr\");\n\t\tcustomForm.addChild(\"td\", WizardL10n.l10n(\"bandwidthCustom\"));\n\t\tcustomForm.addChild(\"td\").addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\" },\n\t\t        new String[] { \"text\", \"customDown\" });\n\t\tcustomForm.addChild(\"td\").addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\" },\n\t\t        new String[] { \"text\", \"customUp\" });\n\t\tcustomForm.addChild(\"td\").addChild(\"input\",\n\t\t\t\tnew String[] { \"type\", \"name\", \"value\" },\n\t\t\t\tnew String[] { \"radio\", \"bandwidth\", \"custom\" });\n\n\t\tinfoBox.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"back\", NodeL10n.getBase().getString(\"Toadlet.back\")});\n\t\tinfoBox.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"next\", NodeL10n.getBase().getString(\"Toadlet.next\")});\n\t}","commit_id":"88c419bcc669019c26e2df0f16f4c3383b83f12a","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodPOST(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\n\t\tString passwd = request.getPartAsStringFailsafe(\"formPassword\", 32);\n\t\tboolean noPassword = (passwd == null) || !passwd.equals(core.formPassword);\n\t\tif(noPassword) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No password (\"+passwd+\" should be \"+core.formPassword+ ')');\n\t\t\tsuper.writeTemporaryRedirect(ctx, \"invalid/unhandled data\", \"/\");\n\t\t\treturn;\n\t\t}\n\n\t\tWIZARD_STEP currentStep;\n\t\ttry {\n\t\t\t//Attempt to parse the current step, defaulting to WELCOME if unspecified or invalid.\n\t\t\tString currentValue = request.getPartAsStringFailsafe(\"step\", 20);\n\t\t\tcurrentStep = currentValue.isEmpty() ? WIZARD_STEP.WELCOME : WIZARD_STEP.valueOf(currentValue);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\t//Failed to parse enum value, default to welcome.\n\t\t\t//TODO: Should this be an error page instead?\n\t\t\tcurrentStep = WIZARD_STEP.WELCOME;\n\t\t}\n\n\t\tPersistFields persistFields = new PersistFields(request);\n\t\tString redirectTarget;\n\n\t\tif (currentStep.equals(WIZARD_STEP.WELCOME) &&\n\t\t        (request.isPartSet(\"presetLow\") || request.isPartSet(\"presetHigh\") || request.isPartSet(\"presetNone\"))) {\n\n\t\t\t/*Apply presets and UPnP is enabled first to allow it time to load (and thus enable\n\t\t\t  autodetection) before hitting the bandwidth page. This also effectively sets the preset field.*/\n\t\t\tStringBuilder redirectTo = new StringBuilder(TOADLET_URL+\"?step=BROWSER_WARNING&incognito=\");\n\t\t\tredirectTo.append(request.getPartAsStringFailsafe(\"incognito\", 5));\n\n\t\t\t//Translate button name to preset value on the query string.\n\t\t\tif (request.isPartSet(\"presetLow\")) {\n\t\t\t\t//Low security preset\n\t\t\t\tstepMISC.setUPnP(true);\n\t\t\t\tstepMISC.setAutoUpdate(true);\n\t\t\t\tredirectTo.append(\"&preset=LOW&opennet=true\");\n\t\t\t\tstepSECURITY_NETWORK.setThreatLevel(SecurityLevels.NETWORK_THREAT_LEVEL.LOW);\n\t\t\t\tstepSECURITY_PHYSICAL.setThreatLevel(SecurityLevels.PHYSICAL_THREAT_LEVEL.NORMAL,\n\t\t\t\t        stepSECURITY_PHYSICAL.getCurrentLevel());\n\t\t\t} else if (request.isPartSet(\"presetHigh\")) {\n\t\t\t\t//High security preset\n\t\t\t\tstepMISC.setUPnP(true);\n\t\t\t\tstepMISC.setAutoUpdate(true);\n\t\t\t\tredirectTo.append(\"&preset=HIGH&opennet=false\");\n\t\t\t}\n\n\t\t\tsuper.writeTemporaryRedirect(ctx, \"Wizard redirecting.\", redirectTo.toString());\n\t\t\treturn;\n\t\t} else if (request.isPartSet(\"back\")) {\n\t\t\t//User chose back, return to previous page.\n\t\t\tredirectTarget = getPreviousStep(currentStep, persistFields.preset).name();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tredirectTarget = steps.get(currentStep).postStep(request);\n\n\t\t\t\t//Opennet step can change the persisted value for opennet.\n\t\t\t\tif (currentStep == WIZARD_STEP.OPENNET) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tHTTPRequest newRequest = new HTTPRequestImpl(new URI(redirectTarget), \"GET\");\n\t\t\t\t\t\tredirectTarget = WIZARD_STEP.SECURITY_NETWORK.name();\n\t\t\t\t\t\tpersistFields = new PersistFields(persistFields.preset, newRequest);\n\t\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\t\tLogger.error(this, \"Unexpected invalid query string from OPENNET step! \"+e, e);\n\t\t\t\t\t\tredirectTarget = WIZARD_STEP.WELCOME.name();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tString title;\n\t\t\t\tif (e.getMessage().equals(\"cantWriteNewMasterKeysFile\")) {\n\t\t\t\t\t//Recognized as being unable to write to the master keys file.\n\t\t\t\t\ttitle = NodeL10n.getBase().getString(\"SecurityLevels.cantWriteNewMasterKeysFileTitle\");\n\t\t\t\t} else {\n\t\t\t\t\t//Some other error.\n\t\t\t\t\ttitle = NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\");\n\t\t\t\t}\n\n\t\t\t\t//Very loud error message, with descriptive title and header if possible.\n\t\t\t\tStringBuilder msg = new StringBuilder(\"<html><head><title>\").append(title).\n\t\t\t\t        append(\"<\/title><\/head><body><h1>\").append(title).append(\"<\/h1><pre>\");\n\n\t\t\t\t//Print stack trace.\n\t\t\t\tStringWriter sw = new StringWriter();\n\t\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\t\te.printStackTrace(pw);\n\t\t\t\tpw.flush();\n\t\t\t\tmsg.append(sw.toString()).append(\"<\/pre>\");\n\n\t\t\t\t//Include internal exception if one exists.\n\t\t\t\tThrowable internal = e.getCause();\n\t\t\t\tif (internal != null) {\n\t\t\t\t\tmsg.append(\"<h1>\").\n\t\t\t\t\t        append(NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\")).\n\t\t\t\t\t        append(\"<\/h1>\").append(\"<pre>\");\n\n\t\t\t\t\tsw = new StringWriter();\n\t\t\t\t\tpw = new PrintWriter(sw);\n\t\t\t\t\tinternal.printStackTrace(pw);\n\t\t\t\t\tpw.flush();\n\t\t\t\t\tmsg.append(sw.toString()).append(\"<\/pre>\");\n\t\t\t\t}\n\t\t\t\tmsg.append(\"<\/body><\/html>\");\n\t\t\t\twriteHTMLReply(ctx, 500, \"Internal Error\", msg.toString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.writeTemporaryRedirect(ctx, \"Wizard redirecting.\", TOADLET_URL+\"?step=\"+persistFields.appendTo(redirectTarget));\n\t}","id":43134,"modified_method":"public void handleMethodPOST(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\n\t\tString passwd = request.getPartAsStringFailsafe(\"formPassword\", 32);\n\t\tboolean noPassword = (passwd == null) || !passwd.equals(core.formPassword);\n\t\tif(noPassword) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No password (\"+passwd+\" should be \"+core.formPassword+ ')');\n\t\t\tsuper.writeTemporaryRedirect(ctx, \"invalid/unhandled data\", \"/\");\n\t\t\treturn;\n\t\t}\n\n\t\tWIZARD_STEP currentStep;\n\t\ttry {\n\t\t\t//Attempt to parse the current step, defaulting to WELCOME if unspecified or invalid.\n\t\t\tString currentValue = request.getPartAsStringFailsafe(\"step\", 20);\n\t\t\tcurrentStep = currentValue.isEmpty() ? WIZARD_STEP.WELCOME : WIZARD_STEP.valueOf(currentValue);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\t//Failed to parse enum value, default to welcome.\n\t\t\t//TODO: Should this be an error page instead?\n\t\t\tcurrentStep = WIZARD_STEP.WELCOME;\n\t\t}\n\n\t\tPersistFields persistFields = new PersistFields(request);\n\t\tString redirectTarget;\n\n\t\tif (currentStep.equals(WIZARD_STEP.WELCOME) &&\n\t\t        (request.isPartSet(\"presetLow\") || request.isPartSet(\"presetHigh\") || request.isPartSet(\"presetNone\"))) {\n\n\t\t\t/*Apply presets and UPnP is enabled first to allow it time to load (and thus enable\n\t\t\t  autodetection) before hitting the bandwidth page. This also effectively sets the preset field.*/\n\t\t\tStringBuilder redirectTo = new StringBuilder(TOADLET_URL+\"?step=BROWSER_WARNING&incognito=\");\n\t\t\tredirectTo.append(request.getPartAsStringFailsafe(\"incognito\", 5));\n\n\t\t\t//Translate button name to preset value on the query string.\n\t\t\tif (request.isPartSet(\"presetLow\")) {\n\t\t\t\t//Low security preset\n\t\t\t\tstepMISC.setUPnP(true);\n\t\t\t\tstepMISC.setAutoUpdate(true);\n\t\t\t\tredirectTo.append(\"&preset=LOW&opennet=true\");\n\t\t\t\tstepSECURITY_NETWORK.setThreatLevel(SecurityLevels.NETWORK_THREAT_LEVEL.LOW);\n\t\t\t\tstepSECURITY_PHYSICAL.setThreatLevel(SecurityLevels.PHYSICAL_THREAT_LEVEL.NORMAL,\n\t\t\t\t        stepSECURITY_PHYSICAL.getCurrentLevel());\n\t\t\t} else if (request.isPartSet(\"presetHigh\")) {\n\t\t\t\t//High security preset\n\t\t\t\tstepMISC.setUPnP(true);\n\t\t\t\tstepMISC.setAutoUpdate(true);\n\t\t\t\tredirectTo.append(\"&preset=HIGH&opennet=false\");\n\t\t\t}\n\n\t\t\tsuper.writeTemporaryRedirect(ctx, \"Wizard redirecting.\", redirectTo.toString());\n\t\t\treturn;\n\t\t} else if (request.isPartSet(\"back\")) {\n\t\t\t//User chose back, return to previous page.\n\t\t\tredirectTarget = getPreviousStep(currentStep, persistFields.preset).name();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tredirectTarget = steps.get(currentStep).postStep(request);\n\n\t\t\t\t//Opennet step can change the persisted value for opennet.\n\t\t\t\tif (currentStep == WIZARD_STEP.OPENNET) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tHTTPRequest newRequest = new HTTPRequestImpl(new URI(\n\t\t\t\t\t\t        stepURL(redirectTarget)), \"GET\");\n\t\t\t\t\t\t//Only continue if a value for opennet has been selected.\n\t\t\t\t\t\tif (newRequest.isPartSet(\"opennet\")) {\n\t\t\t\t\t\t\tredirectTarget = WIZARD_STEP.SECURITY_NETWORK.name();\n\t\t\t\t\t\t\tpersistFields = new PersistFields(persistFields.preset, newRequest);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\t\tLogger.error(this, \"Unexpected invalid query string from OPENNET step! \"+e, e);\n\t\t\t\t\t\tredirectTarget = WIZARD_STEP.WELCOME.name();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tString title;\n\t\t\t\tif (e.getMessage().equals(\"cantWriteNewMasterKeysFile\")) {\n\t\t\t\t\t//Recognized as being unable to write to the master keys file.\n\t\t\t\t\ttitle = NodeL10n.getBase().getString(\"SecurityLevels.cantWriteNewMasterKeysFileTitle\");\n\t\t\t\t} else {\n\t\t\t\t\t//Some other error.\n\t\t\t\t\ttitle = NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\");\n\t\t\t\t}\n\n\t\t\t\t//Very loud error message, with descriptive title and header if possible.\n\t\t\t\tStringBuilder msg = new StringBuilder(\"<html><head><title>\").append(title).\n\t\t\t\t        append(\"<\/title><\/head><body><h1>\").append(title).append(\"<\/h1><pre>\");\n\n\t\t\t\t//Print stack trace.\n\t\t\t\tStringWriter sw = new StringWriter();\n\t\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\t\te.printStackTrace(pw);\n\t\t\t\tpw.flush();\n\t\t\t\tmsg.append(sw.toString()).append(\"<\/pre>\");\n\n\t\t\t\t//Include internal exception if one exists.\n\t\t\t\tThrowable internal = e.getCause();\n\t\t\t\tif (internal != null) {\n\t\t\t\t\tmsg.append(\"<h1>\").\n\t\t\t\t\t        append(NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\")).\n\t\t\t\t\t        append(\"<\/h1>\").append(\"<pre>\");\n\n\t\t\t\t\tsw = new StringWriter();\n\t\t\t\t\tpw = new PrintWriter(sw);\n\t\t\t\t\tinternal.printStackTrace(pw);\n\t\t\t\t\tpw.flush();\n\t\t\t\t\tmsg.append(sw.toString()).append(\"<\/pre>\");\n\t\t\t\t}\n\t\t\t\tmsg.append(\"<\/body><\/html>\");\n\t\t\t\twriteHTMLReply(ctx, 500, \"Internal Error\", msg.toString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.writeTemporaryRedirect(ctx, \"Wizard redirect\", stepURL(persistFields.appendTo(redirectTarget)));\n\t}","commit_id":"77b38f72fdc5a57fabdeceba6b1a9a99d06f03ca","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void getStep(HTTPRequest request, PageHelper helper) {\n\t\tHTMLNode contentNode = helper.getPageContent(WizardL10n.l10n(\"opennetChoicePageTitle\"));\n\t\tHTMLNode infoboxContent = helper.getInfobox(\"infobox-normal\", WizardL10n.l10n(\"opennetChoiceTitle\"),\n\t\t        contentNode, null, false);\n\n\t\tinfoboxContent.addChild(\"p\", WizardL10n.l10n(\"opennetChoiceIntroduction\"));\n\n\t\tHTMLNode form = helper.addFormChild(infoboxContent, \".\", \"opennetForm\");\n\n\t\tHTMLNode p = form.addChild(\"p\");\n\t\tHTMLNode input = p.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"radio\", \"opennet\", \"false\" });\n\t\tinput.addChild(\"b\", WizardL10n.l10n(\"opennetChoiceConnectFriends\")+\":\");\n\t\tp.addChild(\"br\");\n\t\tp.addChild(\"i\", WizardL10n.l10n(\"opennetChoicePro\"));\n\t\tp.addChild(\"#\", \": \"+WizardL10n.l10n(\"opennetChoiceConnectFriendsPRO\") + \"¹\");\n\t\tp.addChild(\"br\");\n\t\tp.addChild(\"i\", WizardL10n.l10n(\"opennetChoiceCon\"));\n\t\tp.addChild(\"#\", \": \"+WizardL10n.l10n(\"opennetChoiceConnectFriendsCON\", \"minfriends\", \"5\"));\n\n\t\tp = form.addChild(\"p\");\n\t\tinput = p.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"radio\", \"opennet\", \"true\" });\n\t\tinput.addChild(\"b\", WizardL10n.l10n(\"opennetChoiceConnectStrangers\")+\":\");\n\t\tp.addChild(\"br\");\n\t\tp.addChild(\"i\", WizardL10n.l10n(\"opennetChoicePro\"));\n\t\tp.addChild(\"#\", \": \"+WizardL10n.l10n(\"opennetChoiceConnectStrangersPRO\"));\n\t\tp.addChild(\"br\");\n\t\tp.addChild(\"i\", WizardL10n.l10n(\"opennetChoiceCon\"));\n\t\tp.addChild(\"#\", \": \"+WizardL10n.l10n(\"opennetChoiceConnectStrangersCON\"));\n\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"back\", NodeL10n.getBase().getString(\"Toadlet.back\")});\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"next\", NodeL10n.getBase().getString(\"Toadlet.next\")});\n\n\t\tHTMLNode foot = infoboxContent.addChild(\"div\", \"class\", \"toggleable\");\n\t\tfoot.addChild(\"i\", \"¹: \" + WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetToggle\"));\n\t\tHTMLNode footHidden = foot.addChild(\"div\", \"class\", \"hidden\");\n\t\tHTMLNode footList = footHidden.addChild(\"ol\");\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetStupid\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetFriends\") + \"²\");\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetTrustworthy\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetNoSuspect\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetChangeID\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetSSK\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetOS\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetBigPriv\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetDistant\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetBugs\"));\n\t\tHTMLNode foot2 = footHidden.addChild(\"p\");\n\t\tfoot2.addChild(\"#\", \"²: \" + WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetFoot2\"));\n\t}","id":43135,"modified_method":"@Override\n\tpublic void getStep(HTTPRequest request, PageHelper helper) {\n\t\tHTMLNode contentNode = helper.getPageContent(WizardL10n.l10n(\"opennetChoicePageTitle\"));\n\t\tHTMLNode infoboxContent = helper.getInfobox(\"infobox-normal\", WizardL10n.l10n(\"opennetChoiceTitle\"),\n\t\t        contentNode, null, false);\n\n\t\tinfoboxContent.addChild(\"p\", WizardL10n.l10n(\"opennetChoiceIntroduction\"));\n\n\t\tHTMLNode form = helper.addFormChild(infoboxContent, \".\", \"opennetForm\", false);\n\n\t\tHTMLNode p = form.addChild(\"p\");\n\t\tHTMLNode input = p.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"radio\", \"opennet\", \"false\" });\n\t\tinput.addChild(\"b\", WizardL10n.l10n(\"opennetChoiceConnectFriends\")+\":\");\n\t\tp.addChild(\"br\");\n\t\tp.addChild(\"i\", WizardL10n.l10n(\"opennetChoicePro\"));\n\t\tp.addChild(\"#\", \": \"+WizardL10n.l10n(\"opennetChoiceConnectFriendsPRO\") + \"¹\");\n\t\tp.addChild(\"br\");\n\t\tp.addChild(\"i\", WizardL10n.l10n(\"opennetChoiceCon\"));\n\t\tp.addChild(\"#\", \": \"+WizardL10n.l10n(\"opennetChoiceConnectFriendsCON\", \"minfriends\", \"5\"));\n\n\t\tp = form.addChild(\"p\");\n\t\tinput = p.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"radio\", \"opennet\", \"true\" });\n\t\tinput.addChild(\"b\", WizardL10n.l10n(\"opennetChoiceConnectStrangers\")+\":\");\n\t\tp.addChild(\"br\");\n\t\tp.addChild(\"i\", WizardL10n.l10n(\"opennetChoicePro\"));\n\t\tp.addChild(\"#\", \": \"+WizardL10n.l10n(\"opennetChoiceConnectStrangersPRO\"));\n\t\tp.addChild(\"br\");\n\t\tp.addChild(\"i\", WizardL10n.l10n(\"opennetChoiceCon\"));\n\t\tp.addChild(\"#\", \": \"+WizardL10n.l10n(\"opennetChoiceConnectStrangersCON\"));\n\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"back\", NodeL10n.getBase().getString(\"Toadlet.back\")});\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"next\", NodeL10n.getBase().getString(\"Toadlet.next\")});\n\n\t\tHTMLNode foot = infoboxContent.addChild(\"div\", \"class\", \"toggleable\");\n\t\tfoot.addChild(\"i\", \"¹: \" + WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetToggle\"));\n\t\tHTMLNode footHidden = foot.addChild(\"div\", \"class\", \"hidden\");\n\t\tHTMLNode footList = footHidden.addChild(\"ol\");\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetStupid\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetFriends\") + \"²\");\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetTrustworthy\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetNoSuspect\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetChangeID\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetSSK\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetOS\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetBigPriv\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetDistant\"));\n\t\tfootList.addChild(\"li\", WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetBugs\"));\n\t\tHTMLNode foot2 = footHidden.addChild(\"p\");\n\t\tfoot2.addChild(\"#\", \"²: \" + WizardL10n.l10n(\"opennetChoiceHowSafeIsFreenetFoot2\"));\n\t}","commit_id":"77b38f72fdc5a57fabdeceba6b1a9a99d06f03ca","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Generates a form that includes persistence for inter-step fields. This is currently opennet, preset, and step.\n\t * Opennet is whether the user enabled opennet, preset is what preset they're using, and step is what POST step\n\t * will be used to process the form.\n\t * @param parentNode node to add form to\n\t * @param target where form should POST to\n\t * @param id ID attribute (in HTML) of form\n\t * @return form node to add buttons, inputs, and whatnot to.\n\t */\n\tpublic HTMLNode addFormChild(HTMLNode parentNode, String target, String id) {\n\t\tHTMLNode form = toadletContext.addFormChild(parentNode, target, id);\n\t\tif (persistFields.isUsingPreset()) {\n\t\t\tform.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"hidden\", \"preset\", persistFields.preset.name() });\n\t\t}\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"hidden\", \"opennet\", String.valueOf(persistFields.opennet) });\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"hidden\", \"step\", step.name() });\n\t\treturn form;\n\t}","id":43136,"modified_method":"public HTMLNode addFormChild(HTMLNode parentNode, String target, String id) {\n\t\treturn addFormChild(parentNode, target, id, true);\n\t}","commit_id":"77b38f72fdc5a57fabdeceba6b1a9a99d06f03ca","url":"https://github.com/freenet/fred"},{"original_method":"public AbstractSelectionHandler(final TcpIpConnection connection) {\n        this.connection = connection;\n        this.socketChannel = connection.getSocketChannelWrapper();\n        this.connectionManager = connection.getConnectionManager();\n        this.logger = connectionManager.ioService.getLogger(this.getClass().getName());\n    }","id":43137,"modified_method":"public AbstractSelectionHandler(TcpIpConnection connection, IOSelector ioSelector, int ops) {\n        this.connection = connection;\n        this.ioSelector = ioSelector;\n        this.selector = ioSelector.getSelector();\n        this.socketChannel = connection.getSocketChannelWrapper();\n        this.connectionManager = connection.getConnectionManager();\n        this.logger = connectionManager.ioService.getLogger(this.getClass().getName());\n        this.ops = ops;\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"final void handleSocketException(Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n            connectionManager.ioService.onOutOfMemory((OutOfMemoryError) e);\n        }\n        if (sk != null) {\n            sk.cancel();\n        }\n        connection.close(e);\n        final ConnectionType connectionType = connection.getType();\n        if (connectionType.isClient() && !connectionType.isBinary()) {\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(Thread.currentThread().getName());\n        sb.append(\" Closing socket to endpoint \");\n        sb.append(connection.getEndPoint());\n        sb.append(\", Cause:\").append(e);\n        final Level level = connectionManager.ioService.isActive() ? Level.WARNING : Level.FINEST;\n        if (e instanceof IOException) {\n            logger.log(level, sb.toString());\n        } else {\n            logger.log(level, sb.toString(), e);\n        }\n    }","id":43138,"modified_method":"final void handleSocketException(Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n            connectionManager.ioService.onOutOfMemory((OutOfMemoryError) e);\n        }\n        if (selectionKey != null) {\n            selectionKey.cancel();\n        }\n        connection.close(e);\n        ConnectionType connectionType = connection.getType();\n        if (connectionType.isClient() && !connectionType.isBinary()) {\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(Thread.currentThread().getName());\n        sb.append(\" Closing socket to endpoint \");\n        sb.append(connection.getEndPoint());\n        sb.append(\", Cause:\").append(e);\n        Level level = connectionManager.ioService.isActive() ? Level.WARNING : Level.FINEST;\n        if (e instanceof IOException) {\n            logger.log(level, sb.toString());\n        } else {\n            logger.log(level, sb.toString(), e);\n        }\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"final void registerOp(final Selector selector, final int operation) {\n        try {\n            if (!connection.isAlive()) {\n                return;\n            }\n            if (sk == null) {\n                sk = socketChannel.keyFor(selector);\n            }\n            if (sk == null) {\n                sk = socketChannel.register(selector, operation, this);\n            } else {\n                sk.interestOps(sk.interestOps() | operation);\n                if (sk.attachment() != this) {\n                    sk.attach(this);\n                }\n            }\n        } catch (Throwable e) {\n            handleSocketException(e);\n        }\n    }","id":43139,"modified_method":"final void registerOp(int operation) {\n        SelectionKey selectionKey = getSelectionKey();\n\n        try {\n            selectionKey.interestOps(selectionKey.interestOps() | operation);\n        } catch (Throwable e) {\n            handleSocketException(e);\n        }\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings({\"VO_VOLATILE_INCREMENT\" })\n    protected void handleSelectionKey(SelectionKey sk) {\n        if (sk.isValid() && sk.isWritable()) {\n            writeEvents++;\n            sk.interestOps(sk.interestOps() & ~SelectionKey.OP_WRITE);\n            SelectionHandler handler = (SelectionHandler) sk.attachment();\n            handler.handle();\n        }\n    }","id":43140,"modified_method":"@Override\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings({\"VO_VOLATILE_INCREMENT\" })\n    protected void handleSelectionKey(SelectionKey sk) {\n        if (sk.isValid() && sk.isWritable()) {\n            writeEvents++;\n            SelectionHandler handler = (SelectionHandler) sk.attachment();\n            handler.handle();\n        }\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public ReadHandler(TcpIpConnection connection, IOSelector ioSelector) {\n        super(connection);\n        this.ioSelector = ioSelector;\n        buffer = ByteBuffer.allocate(connectionManager.socketReceiveBufferSize);\n    }","id":43141,"modified_method":"public ReadHandler(TcpIpConnection connection, IOSelector ioSelector) {\n        super(connection, ioSelector, SelectionKey.OP_READ);\n        this.ioSelector = ioSelector;\n        this.inputBuffer = ByteBuffer.allocate(connectionManager.socketReceiveBufferSize);\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void initializeSocketReader() throws IOException {\n        if (socketReader == null) {\n            final ByteBuffer protocolBuffer = ByteBuffer.allocate(3);\n            int readBytes = socketChannel.read(protocolBuffer);\n            if (readBytes == -1) {\n                throw new EOFException(\"Could not read protocol type!\");\n            }\n            if (readBytes == 0 && connectionManager.isSSLEnabled()) {\n                // when using SSL, we can read 0 bytes since data read from socket can be handshake packets.\n                return;\n            }\n            if (!protocolBuffer.hasRemaining()) {\n                String protocol = bytesToString(protocolBuffer.array());\n                WriteHandler writeHandler = connection.getWriteHandler();\n                if (Protocols.CLUSTER.equals(protocol)) {\n                    connection.setType(ConnectionType.MEMBER);\n                    writeHandler.setProtocol(Protocols.CLUSTER);\n                    socketReader = new SocketPacketReader(connection);\n                } else if (Protocols.CLIENT_BINARY.equals(protocol)) {\n                    writeHandler.setProtocol(Protocols.CLIENT_BINARY);\n                    socketReader = new SocketClientDataReader(connection);\n                } else {\n                    writeHandler.setProtocol(Protocols.TEXT);\n                    buffer.put(protocolBuffer.array());\n                    socketReader = new SocketTextReader(connection);\n                    connection.getConnectionManager().incrementTextConnections();\n                }\n            }\n            if (socketReader == null) {\n                throw new IOException(\"Could not initialize SocketReader!\");\n            }\n        }\n    }","id":43142,"modified_method":"private void initializeSocketReader() throws IOException {\n        if (socketReader == null) {\n            final ByteBuffer protocolBuffer = ByteBuffer.allocate(3);\n            int readBytes = socketChannel.read(protocolBuffer);\n            if (readBytes == -1) {\n                throw new EOFException(\"Could not read protocol type!\");\n            }\n            if (readBytes == 0 && connectionManager.isSSLEnabled()) {\n                // when using SSL, we can read 0 bytes since data read from socket can be handshake packets.\n                return;\n            }\n            if (!protocolBuffer.hasRemaining()) {\n                String protocol = bytesToString(protocolBuffer.array());\n                WriteHandler writeHandler = connection.getWriteHandler();\n                if (Protocols.CLUSTER.equals(protocol)) {\n                    connection.setType(ConnectionType.MEMBER);\n                    writeHandler.setProtocol(Protocols.CLUSTER);\n                    socketReader = new SocketPacketReader(connection);\n                } else if (Protocols.CLIENT_BINARY.equals(protocol)) {\n                    writeHandler.setProtocol(Protocols.CLIENT_BINARY);\n                    socketReader = new SocketClientDataReader(connection);\n                } else {\n                    writeHandler.setProtocol(Protocols.TEXT);\n                    inputBuffer.put(protocolBuffer.array());\n                    socketReader = new SocketTextReader(connection);\n                    connection.getConnectionManager().incrementTextConnections();\n                }\n            }\n            if (socketReader == null) {\n                throw new IOException(\"Could not initialize SocketReader!\");\n            }\n        }\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void handle() {\n        lastHandle = Clock.currentTimeMillis();\n        if (!connection.isAlive()) {\n            String message = \"We are being asked to read, but connection is not live so we won't\";\n            logger.finest(message);\n            return;\n        }\n        try {\n            if (socketReader == null) {\n                initializeSocketReader();\n                if (socketReader == null) {\n                    // when using SSL, we can read 0 bytes since data read from socket can be handshake packets.\n                    return;\n                }\n            }\n            int readBytes = socketChannel.read(buffer);\n            if (readBytes == -1) {\n                throw new EOFException(\"Remote socket closed!\");\n            }\n        } catch (Throwable e) {\n            handleSocketException(e);\n            return;\n        }\n        try {\n            if (buffer.position() == 0) {\n                return;\n            }\n            buffer.flip();\n            socketReader.read(buffer);\n            if (buffer.hasRemaining()) {\n                buffer.compact();\n            } else {\n                buffer.clear();\n            }\n        } catch (Throwable t) {\n            handleSocketException(t);\n        }\n    }","id":43143,"modified_method":"@Override\n    public void handle() {\n        lastHandle = Clock.currentTimeMillis();\n        if (!connection.isAlive()) {\n            String message = \"We are being asked to read, but connection is not live so we won't\";\n            logger.finest(message);\n            return;\n        }\n        try {\n            if (socketReader == null) {\n                initializeSocketReader();\n                if (socketReader == null) {\n                    // when using SSL, we can read 0 bytes since data read from socket can be handshake packets.\n                    return;\n                }\n            }\n            int readBytes = socketChannel.read(inputBuffer);\n            if (readBytes == -1) {\n                throw new EOFException(\"Remote socket closed!\");\n            }\n        } catch (Throwable e) {\n            handleSocketException(e);\n            return;\n        }\n        try {\n            if (inputBuffer.position() == 0) {\n                return;\n            }\n            inputBuffer.flip();\n            socketReader.read(inputBuffer);\n            if (inputBuffer.hasRemaining()) {\n                inputBuffer.compact();\n            } else {\n                inputBuffer.clear();\n            }\n        } catch (Throwable t) {\n            handleSocketException(t);\n        }\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean write(SocketWritable packet) {\n        if (!live) {\n            if (logger.isFinestEnabled()) {\n                logger.finest(\"Connection is closed, won't write packet -> \" + packet);\n            }\n            return false;\n        }\n        writeHandler.enqueueSocketWritable(packet);\n        return true;\n    }","id":43144,"modified_method":"@Override\n    public boolean write(SocketWritable packet) {\n        if (!live) {\n            if (logger.isFinestEnabled()) {\n                logger.finest(\"Connection is closed, won't write packet -> \" + packet);\n            }\n            return false;\n        }\n        writeHandler.offer(packet);\n        return true;\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public TcpIpConnection(TcpIpConnectionManager connectionManager, IOSelector in, IOSelector out,\n                           int connectionId, SocketChannelWrapper socketChannel) {\n        this.connectionId = connectionId;\n        this.logger = connectionManager.ioService.getLogger(TcpIpConnection.class.getName());\n        this.connectionManager = connectionManager;\n        this.socketChannel = socketChannel;\n        this.readHandler = new ReadHandler(this, in);\n        this.writeHandler = new WriteHandler(this, out);\n    }","id":43145,"modified_method":"public TcpIpConnection(TcpIpConnectionManager connectionManager, IOSelector in, IOSelector out,\n                           int connectionId, SocketChannelWrapper socketChannel) {\n        this.connectionId = connectionId;\n        this.logger = connectionManager.ioService.getLogger(TcpIpConnection.class.getName());\n        this.connectionManager = connectionManager;\n        this.socketChannel = socketChannel;\n        this.writeHandler = new WriteHandler(this, out);\n        this.readHandler = new ReadHandler(this, in);\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"TcpIpConnection assignSocketChannel(SocketChannelWrapper channel, Address endpoint) {\n        InetSocketAddress remoteSocketAddress = (InetSocketAddress) channel.socket().getRemoteSocketAddress();\n        String remoteHost = remoteSocketAddress.getHostName();\n        int index = getSelectorIndex(remoteHost);\n\n        final TcpIpConnection connection = new TcpIpConnection(this, inSelectors[index],\n                outSelectors[index], connectionIdGen.incrementAndGet(), channel);\n        connection.setEndPoint(endpoint);\n        activeConnections.add(connection);\n        acceptedSockets.remove(channel);\n        connection.getReadHandler().register();\n\n        logConnectionEstablished(channel, remoteSocketAddress, index);\n\n        return connection;\n    }","id":43146,"modified_method":"TcpIpConnection assignSocketChannel(SocketChannelWrapper channel, Address endpoint) {\n        InetSocketAddress remoteSocketAddress = (InetSocketAddress) channel.socket().getRemoteSocketAddress();\n        String remoteHost = remoteSocketAddress.getHostName();\n        int index = getSelectorIndex(remoteHost);\n\n        final TcpIpConnection connection = new TcpIpConnection(this, inSelectors[index],\n                outSelectors[index], connectionIdGen.incrementAndGet(), channel);\n        connection.setEndPoint(endpoint);\n        activeConnections.add(connection);\n        acceptedSockets.remove(channel);\n\n        connection.start();\n\n        logConnectionEstablished(channel, remoteSocketAddress, index);\n\n        return connection;\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"WriteHandler(TcpIpConnection connection, IOSelector ioSelector) {\n        super(connection);\n        this.ioSelector = ioSelector;\n        buffer = ByteBuffer.allocate(connectionManager.socketSendBufferSize);\n    }","id":43147,"modified_method":"WriteHandler(TcpIpConnection connection, IOSelector ioSelector) {\n        // We register for write, but this is only done to trigger the creation of the selection key.\n        // So we get one unwanted write-event even if we have nothing to write. After that things are back to normal\n        super(connection, ioSelector, SelectionKey.OP_WRITE);\n        this.outputBuffer = ByteBuffer.allocate(connectionManager.socketSendBufferSize);\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void shutdown() {\n        writeQueue.clear();\n        urgencyWriteQueue.clear();\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        ioSelector.addTask(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    socketChannel.closeOutbound();\n                } catch (IOException e) {\n                    logger.finest(\"Error while closing outbound\", e);\n                } finally {\n                    latch.countDown();\n                }\n            }\n        });\n        ioSelector.wakeup();\n        try {\n            latch.await(TIMEOUT, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            EmptyStatement.ignore(e);\n        }\n    }","id":43148,"modified_method":"public void shutdown() {\n        writeQueue.clear();\n        urgentWriteQueue.clear();\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        ioSelector.addTask(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    socketChannel.closeOutbound();\n                } catch (IOException e) {\n                    logger.finest(\"Error while closing outbound\", e);\n                } finally {\n                    latch.countDown();\n                }\n            }\n        });\n        ioSelector.wakeup();\n        try {\n            latch.await(TIMEOUT, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            EmptyStatement.ignore(e);\n        }\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void enqueueSocketWritable(SocketWritable socketWritable) {\n        if (socketWritable.isUrgent()) {\n            urgencyWriteQueue.offer(socketWritable);\n        } else {\n            writeQueue.offer(socketWritable);\n        }\n        if (informSelector.compareAndSet(true, false)) {\n            // we don't have to call wake up if this WriteHandler is\n            // already in the task queue.\n            // we can have a counter to check this later on.\n            // for now, wake up regardless.\n            ioSelector.addTask(this);\n            ioSelector.wakeup();\n        }\n    }","id":43149,"modified_method":"public void offer(SocketWritable packet) {\n        if (packet.isUrgent()) {\n            urgentWriteQueue.offer(packet);\n        } else {\n            writeQueue.offer(packet);\n        }\n\n        schedule();\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void createWriter(String protocol) {\n        if (socketWriter == null) {\n            if (Protocols.CLUSTER.equals(protocol)) {\n                socketWriter = new SocketPacketWriter(connection);\n                buffer.put(stringToBytes(Protocols.CLUSTER));\n                registerWrite();\n            } else if (Protocols.CLIENT_BINARY.equals(protocol)) {\n                socketWriter = new SocketClientDataWriter();\n            } else {\n                socketWriter = new SocketTextWriter(connection);\n            }\n        }\n    }","id":43150,"modified_method":"private void createWriter(String protocol) {\n        if (socketWriter == null) {\n            if (Protocols.CLUSTER.equals(protocol)) {\n                socketWriter = new SocketPacketWriter(connection);\n                outputBuffer.put(stringToBytes(Protocols.CLUSTER));\n                registerOp(SelectionKey.OP_WRITE);\n            } else if (Protocols.CLIENT_BINARY.equals(protocol)) {\n                socketWriter = new SocketClientDataWriter();\n            } else {\n                socketWriter = new SocketTextWriter(connection);\n            }\n        }\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"void setProtocol(final String protocol) {\n        final CountDownLatch latch = new CountDownLatch(1);\n        ioSelector.addTask(new Runnable() {\n            public void run() {\n                createWriter(protocol);\n                latch.countDown();\n            }\n        });\n        ioSelector.wakeup();\n        try {\n            latch.await(TIMEOUT, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Logger.getLogger(WriteHandler.class).finest(\"CountDownLatch::await interrupted\", e);\n        }\n    }","id":43151,"modified_method":"void setProtocol(final String protocol) {\n        final CountDownLatch latch = new CountDownLatch(1);\n        ioSelector.addTask(new Runnable() {\n            public void run() {\n                createWriter(protocol);\n                latch.countDown();\n            }\n        });\n        ioSelector.wakeup();\n        try {\n            latch.await(TIMEOUT, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            logger.finest(\"CountDownLatch::await interrupted\", e);\n        }\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private SocketWritable poll() {\n        SocketWritable writable = urgencyWriteQueue.poll();\n        if (writable == null) {\n            writable = writeQueue.poll();\n        }\n\n        return writable;\n    }","id":43152,"modified_method":"private SocketWritable poll() {\n        SocketWritable writable = urgentWriteQueue.poll();\n        if (writable == null) {\n            writable = writeQueue.poll();\n        }\n\n        return writable;\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public void handle() {\n        lastHandle = Clock.currentTimeMillis();\n        if (!connection.isAlive()) {\n            return;\n        }\n        if (socketWriter == null) {\n            logger.log(Level.WARNING, \"SocketWriter is not set, creating SocketWriter with CLUSTER protocol!\");\n            createWriter(Protocols.CLUSTER);\n        }\n        if (lastWritable == null) {\n            lastWritable = poll();\n            if (lastWritable == null && buffer.position() == 0) {\n                ready = true;\n                return;\n            }\n        }\n        try {\n            writeBuffer();\n        } catch (Throwable t) {\n            logger.severe(\"Fatal Error at WriteHandler for endPoint: \" + connection.getEndPoint(), t);\n        } finally {\n            ready = false;\n            registerWrite();\n        }\n    }","id":43153,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    public void handle() {\n        lastHandle = Clock.currentTimeMillis();\n        if (!connection.isAlive()) {\n            return;\n        }\n\n        if (socketWriter == null) {\n            logger.log(Level.WARNING, \"SocketWriter is not set, creating SocketWriter with CLUSTER protocol!\");\n            createWriter(Protocols.CLUSTER);\n        }\n\n        try {\n            fillOutputBuffer();\n\n            if (dirtyOutputBuffer()) {\n                writeOutputBufferToSocket();\n            }\n        } catch (Throwable t) {\n            logger.severe(\"Fatal Error at WriteHandler for endPoint: \" + connection.getEndPoint(), t);\n        }\n\n        unschedule();\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void run() {\n        informSelector.set(true);\n        if (ready) {\n            handle();\n        } else {\n            registerWrite();\n        }\n        ready = false;\n    }","id":43154,"modified_method":"@Override\n    public void run() {\n        handle();\n    }","commit_id":"de557b4b1700a72f7a55f7a894cad95af689f24a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     *  OP_WRITE will always be set before this is called.\n     *  This method will disable the interest if no more writes remain.\n     *  High-frequency path in thread.\n     */\n    private void processWrite(SelectionKey key) {\n        //int totalWritten = 0;\n        //int buffers = 0;\n        //long before = System.currentTimeMillis();\n        NTCPConnection con = (NTCPConnection)key.attachment();\n        try {\n            while (true) {\n                ByteBuffer buf = con.getNextWriteBuf();\n                if (buf != null) {\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(\"writing \" + buf.remaining()+\"...\");\n                    if (buf.remaining() <= 0) {\n                        //long beforeRem = System.currentTimeMillis();\n                        con.removeWriteBuf(buf);\n                        //long afterRem = System.currentTimeMillis();\n                        //if (_log.shouldLog(Log.DEBUG))\n                        //    _log.debug(\"buffer was already fully written and removed after \" + (afterRem-beforeRem) + \"...\");\n                        //buffers++;\n                        continue;                    \n                    }\n                    int written = con.getChannel().write(buf);\n                    //totalWritten += written;\n                    if (written == 0) {\n                        if ( (buf.remaining() > 0) || (!con.isWriteBufEmpty()) ) {\n                            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"done writing, but data remains...\");\n                            // stay interested\n                            //key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);\n                        } else {\n                            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"done writing, no data remains...\");\n                            key.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE);\n                        }\n                        break;\n                    } else if (buf.remaining() > 0) {\n                        //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"buffer data remaining...\");\n                        // stay interested\n                        //key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);\n                        break;\n                    } else {\n                        //long beforeRem = System.currentTimeMillis();\n                        con.removeWriteBuf(buf);\n                        //long afterRem = System.currentTimeMillis();\n                        //if (_log.shouldLog(Log.DEBUG))\n                        //    _log.debug(\"buffer \"+ buffers+\"/\"+written+\"/\"+totalWritten+\" fully written after \" +\n                        //               (beforeRem-before) + \", then removed after \" + (afterRem-beforeRem) + \"...\");\n                        //releaseBuf(buf);\n                        //buffers++;\n                        //if (buffer time is too much, add OP_WRITe to the interest ops and break?)\n                        // LOOP\n                    }\n                } else {\n                    // Nothing more to write\n                    key.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE);\n                    break;\n                }\n            }\n        } catch (CancelledKeyException cke) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"error writing on \" + con, cke);\n            _context.statManager().addRateData(\"ntcp.writeError\", 1);\n            con.close();\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"error writing on \" + con, ioe);\n            _context.statManager().addRateData(\"ntcp.writeError\", 1);\n            con.close();\n        }\n        //long after = System.currentTimeMillis();\n        //if (_log.shouldLog(Log.INFO))\n        //    _log.info(\"Wrote \" + totalWritten + \" in \" + buffers + \" buffers on \" + con \n        //              + \" after \" + (after-before));\n    }","id":43155,"modified_method":"/**\n     *  OP_WRITE will always be set before this is called.\n     *  This method will disable the interest if no more writes remain.\n     *  High-frequency path in thread.\n     */\n    private void processWrite(SelectionKey key) {\n        //int totalWritten = 0;\n        //int buffers = 0;\n        //long before = System.currentTimeMillis();\n        NTCPConnection con = (NTCPConnection)key.attachment();\n        try {\n            while (true) {\n                ByteBuffer buf = con.getNextWriteBuf();\n                if (buf != null) {\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(\"writing \" + buf.remaining()+\"...\");\n                    if (buf.remaining() <= 0) {\n                        //long beforeRem = System.currentTimeMillis();\n                        con.removeWriteBuf(buf);\n                        //long afterRem = System.currentTimeMillis();\n                        //if (_log.shouldLog(Log.DEBUG))\n                        //    _log.debug(\"buffer was already fully written and removed after \" + (afterRem-beforeRem) + \"...\");\n                        //buffers++;\n                        continue;                    \n                    }\n                    int written = con.getChannel().write(buf);\n                    //totalWritten += written;\n                    if (written == 0) {\n                        if ( (buf.remaining() > 0) || (!con.isWriteBufEmpty()) ) {\n                            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"done writing, but data remains...\");\n                            // stay interested\n                            //key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);\n                        } else {\n                            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"done writing, no data remains...\");\n                            key.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE);\n                        }\n                        break;\n                    } else if (buf.remaining() > 0) {\n                        //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"buffer data remaining...\");\n                        // stay interested\n                        //key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);\n                        break;\n                    } else {\n                        //long beforeRem = System.currentTimeMillis();\n                        con.removeWriteBuf(buf);\n                        //long afterRem = System.currentTimeMillis();\n                        //if (_log.shouldLog(Log.DEBUG))\n                        //    _log.debug(\"buffer \"+ buffers+\"/\"+written+\"/\"+totalWritten+\" fully written after \" +\n                        //               (beforeRem-before) + \", then removed after \" + (afterRem-beforeRem) + \"...\");\n                        //releaseBuf(buf);\n                        //buffers++;\n                        //if (buffer time is too much, add OP_WRITe to the interest ops and break?)\n                        // LOOP\n                    }\n                } else {\n                    // Nothing more to write\n\t\t    if (key.isValid())\n                    \tkey.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE);\n                    break;\n                }\n            }\n        } catch (CancelledKeyException cke) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"error writing on \" + con, cke);\n            _context.statManager().addRateData(\"ntcp.writeError\", 1);\n            con.close();\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN)) _log.warn(\"error writing on \" + con, ioe);\n            _context.statManager().addRateData(\"ntcp.writeError\", 1);\n            con.close();\n        }\n        //long after = System.currentTimeMillis();\n        //if (_log.shouldLog(Log.INFO))\n        //    _log.info(\"Wrote \" + totalWritten + \" in \" + buffers + \" buffers on \" + con \n        //              + \" after \" + (after-before));\n    }","commit_id":"47c3a56acadbcc06e837c27fd882884b190c73da","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected void registerForEvent(int event) {\n        final NioEndpoint.KeyAttachment attach =\n                (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n        attach.interestOps(attach.interestOps() | event);\n    }","id":43156,"modified_method":"protected void registerForEvent(int event) {\n        final NioEndpoint.KeyAttachment attach =\n                (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(\n                        false);\n        if (attach != null) {\n            attach.interestOps(attach.interestOps() | event);\n        }\n    }","commit_id":"bb7dc641c2c6a641fc848f841201820835327171","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public SocketState process(SocketWrapper<NioChannel> socketWrapper)\n            throws IOException {\n        SocketState state = super.process(socketWrapper);\n        final NioEndpoint.KeyAttachment attach =\n                (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(\n                        false);\n        if (attach != null) {\n            registerForWrite();\n        }\n        return state;\n    }","id":43157,"modified_method":"@Override\n    public SocketState process(SocketWrapper<NioChannel> socketWrapper)\n            throws IOException {\n        SocketState state = super.process(socketWrapper);\n        registerForWrite();\n        return state;\n    }","commit_id":"bb7dc641c2c6a641fc848f841201820835327171","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Performs a blocking write using the bytebuffer for data to be written\n     * If the <code>selector<\/code> parameter is null, then it will perform a busy write that could\n     * take up a lot of CPU cycles.\n     * @param buf ByteBuffer - the buffer containing the data, we will write as long as <code>(buf.hasRemaining()==true)<\/code>\n     * @param socket SocketChannel - the socket to write data to\n     * @param writeTimeout long - the timeout for this write operation in milliseconds, -1 means no timeout\n     * @return int - returns the number of bytes written\n     * @throws EOFException if write returns -1\n     * @throws SocketTimeoutException if the write times out\n     * @throws IOException if an IO Exception occurs in the underlying socket logic\n     */\n    public static int write(ByteBuffer buf, NioChannel socket, long writeTimeout,MutableInteger lastWrite) throws IOException {\n        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n        int written = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) && buf.hasRemaining()) {\n                if (keycount > 0) { //only write if we were registered for a write\n                    int cnt = socket.write(buf); //write the data\n                    lastWrite.set(cnt);\n                    if (cnt == -1)\n                        throw new EOFException();\n                    written += cnt;\n                    if (cnt > 0) {\n                        time = System.currentTimeMillis(); //reset our timeout timer\n                        continue; //we successfully wrote, try again without a selector\n                    }\n                }\n                if ( key == null ) throw new IOException(\"Key no longer registered\");\n                KeyAttachment att = (KeyAttachment) key.attachment();\n                try {\n                    if ( att.getWriteLatch()==null || att.getWriteLatch().getCount()==0) att.startWriteLatch(1);\n                    //only register for write if a write has not yet been issued\n                    if ( (att.interestOps() & SelectionKey.OP_WRITE) == 0) socket.getPoller().add(socket,SelectionKey.OP_WRITE);\n                    att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);\n                }catch (InterruptedException ignore) {\n                    Thread.interrupted();\n                }\n                if ( att.getWriteLatch()!=null && att.getWriteLatch().getCount()> 0) {\n                    //we got interrupted, but we haven't received notification from the poller.\n                    keycount = 0;\n                }else {\n                    //latch countdown has happened\n                    keycount = 1;\n                    att.resetWriteLatch();\n                }\n\n                if (writeTimeout > 0 && (keycount == 0))\n                    timedout = (System.currentTimeMillis() - time) >= writeTimeout;\n            } //while\n            if (timedout) \n                throw new SocketTimeoutException();\n        } finally {\n            if (timedout && key != null) {\n                cancelKey(socket, key);\n            }\n        }\n        return written;\n    }","id":43158,"modified_method":"/**\n     * Performs a blocking write using the bytebuffer for data to be written\n     * If the <code>selector<\/code> parameter is null, then it will perform a busy write that could\n     * take up a lot of CPU cycles.\n     * @param buf ByteBuffer - the buffer containing the data, we will write as long as <code>(buf.hasRemaining()==true)<\/code>\n     * @param socket SocketChannel - the socket to write data to\n     * @param writeTimeout long - the timeout for this write operation in milliseconds, -1 means no timeout\n     * @return int - returns the number of bytes written\n     * @throws EOFException if write returns -1\n     * @throws SocketTimeoutException if the write times out\n     * @throws IOException if an IO Exception occurs in the underlying socket logic\n     */\n    public static int write(ByteBuffer buf, NioChannel socket, long writeTimeout,MutableInteger lastWrite) throws IOException {\n        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n        if ( key == null ) throw new IOException(\"Key no longer registered\");\n        KeyAttachment att = (KeyAttachment) key.attachment();\n        int prevOps = att.interestOps() | (att.getCometOps()&NioEndpoint.OP_CALLBACK);\n        int written = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) && buf.hasRemaining()) {\n                if (keycount > 0) { //only write if we were registered for a write\n                    int cnt = socket.write(buf); //write the data\n                    lastWrite.set(cnt);\n                    if (cnt == -1)\n                        throw new EOFException();\n                    written += cnt;\n                    if (cnt > 0) {\n                        time = System.currentTimeMillis(); //reset our timeout timer\n                        continue; //we successfully wrote, try again without a selector\n                    }\n                }\n                try {\n                    if ( att.getWriteLatch()==null || att.getWriteLatch().getCount()==0) att.startWriteLatch(1);\n                    //only register for write if a write has not yet been issued\n                    if ( (att.interestOps() & SelectionKey.OP_WRITE) == 0) socket.getPoller().add(socket,prevOps|SelectionKey.OP_WRITE);\n                    att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);\n                }catch (InterruptedException ignore) {\n                    Thread.interrupted();\n                }\n                if ( att.getWriteLatch()!=null && att.getWriteLatch().getCount()> 0) {\n                    //we got interrupted, but we haven't received notification from the poller.\n                    keycount = 0;\n                }else {\n                    //latch countdown has happened\n                    keycount = 1;\n                    att.resetWriteLatch();\n                }\n\n                if (writeTimeout > 0 && (keycount == 0))\n                    timedout = (System.currentTimeMillis() - time) >= writeTimeout;\n            } //while\n            if (timedout) \n                throw new SocketTimeoutException();\n        } finally {\n            if (timedout && key != null) {\n                cancelKey(socket, key);\n            }\n        }\n        socket.getPoller().add(socket,prevOps);\n        return written;\n    }","commit_id":"bc12d3903b9164c3c2c91e396b8c0c85d027df2c","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Performs a blocking read using the bytebuffer for data to be read\n     * If the <code>selector<\/code> parameter is null, then it will perform a busy read that could\n     * take up a lot of CPU cycles.\n     * @param buf ByteBuffer - the buffer containing the data, we will read as until we have read at least one byte or we timed out\n     * @param socket SocketChannel - the socket to write data to\n     * @param selector Selector - the selector to use for blocking, if null then a busy read will be initiated\n     * @param readTimeout long - the timeout for this read operation in milliseconds, -1 means no timeout\n     * @return int - returns the number of bytes read\n     * @throws EOFException if read returns -1\n     * @throws SocketTimeoutException if the read times out\n     * @throws IOException if an IO Exception occurs in the underlying socket logic\n     */\n    public static int read(ByteBuffer buf, NioChannel socket, long readTimeout) throws IOException {\n        final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) && read == 0) {\n                if (keycount > 0) { //only read if we were registered for a read\n                    int cnt = socket.read(buf);\n                    if (cnt == -1)\n                        throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0)\n                        break;\n                }\n                KeyAttachment att = (KeyAttachment) key.attachment();\n                try {\n                    if ( att.getReadLatch()==null || att.getReadLatch().getCount()==0) att.startReadLatch(1);\n                    if ( att.interestOps() == 0) socket.getPoller().add(socket,SelectionKey.OP_READ);\n                    att.awaitReadLatch(readTimeout,TimeUnit.MILLISECONDS);\n                }catch (InterruptedException ignore) {\n                    Thread.interrupted();\n                }\n                if ( att.getReadLatch()!=null && att.getReadLatch().getCount()> 0) {\n                    //we got interrupted, but we haven't received notification from the poller.\n                    keycount = 0;\n                }else {\n                    //latch countdown has happened\n                    keycount = 1;\n                    att.resetReadLatch();\n                }\n                if (readTimeout > 0 && (keycount == 0))\n                    timedout = (System.currentTimeMillis() - time) >= readTimeout;\n            } //while\n            if (timedout)\n                throw new SocketTimeoutException();\n        } finally {\n            if (timedout && key != null) {\n                cancelKey(socket,key);\n            }\n        }\n        return read;\n    }","id":43159,"modified_method":"/**\n     * Performs a blocking read using the bytebuffer for data to be read\n     * If the <code>selector<\/code> parameter is null, then it will perform a busy read that could\n     * take up a lot of CPU cycles.\n     * @param buf ByteBuffer - the buffer containing the data, we will read as until we have read at least one byte or we timed out\n     * @param socket SocketChannel - the socket to write data to\n     * @param selector Selector - the selector to use for blocking, if null then a busy read will be initiated\n     * @param readTimeout long - the timeout for this read operation in milliseconds, -1 means no timeout\n     * @return int - returns the number of bytes read\n     * @throws EOFException if read returns -1\n     * @throws SocketTimeoutException if the read times out\n     * @throws IOException if an IO Exception occurs in the underlying socket logic\n     */\n    public static int read(ByteBuffer buf, NioChannel socket, long readTimeout) throws IOException {\n        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n        if ( key == null ) throw new IOException(\"Key no longer registered\");\n        KeyAttachment att = (KeyAttachment) key.attachment();\n        int prevOps = att.interestOps() | (att.getCometOps()&NioEndpoint.OP_CALLBACK);\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) && read == 0) {\n                if (keycount > 0) { //only read if we were registered for a read\n                    int cnt = socket.read(buf);\n                    if (cnt == -1)\n                        throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0)\n                        break;\n                }\n                try {\n                    if ( att.getReadLatch()==null || att.getReadLatch().getCount()==0) att.startReadLatch(1);\n                    if ( (att.interestOps() & SelectionKey.OP_READ) == 0) socket.getPoller().add(socket,prevOps|SelectionKey.OP_READ);\n                    att.awaitReadLatch(readTimeout,TimeUnit.MILLISECONDS);\n                }catch (InterruptedException ignore) {\n                    Thread.interrupted();\n                }\n                if ( att.getReadLatch()!=null && att.getReadLatch().getCount()> 0) {\n                    //we got interrupted, but we haven't received notification from the poller.\n                    keycount = 0;\n                }else {\n                    //latch countdown has happened\n                    keycount = 1;\n                    att.resetReadLatch();\n                }\n                if (readTimeout > 0 && (keycount == 0))\n                    timedout = (System.currentTimeMillis() - time) >= readTimeout;\n            } //while\n            if (timedout)\n                throw new SocketTimeoutException();\n        } finally {\n            if (timedout && key != null) {\n                cancelKey(socket,key);\n            }\n        }\n        socket.getPoller().add(socket,prevOps);\n        return read;\n    }","commit_id":"bc12d3903b9164c3c2c91e396b8c0c85d027df2c","url":"https://github.com/apache/tomcat"},{"original_method":"protected void timeout(int keyCount, boolean hasEvents) {\n            long now = System.currentTimeMillis();\n            // This method is called on every loop of the Poller. Don't process\n            // timeouts on every loop of the Poller since that would create too\n            // much load and timeouts can afford to wait a few seconds.\n            // However, do process timeouts if any of the following are true:\n            // - the selector simply timed out (suggests there isn't much load)\n            // - the nextExpiration time has passed\n            // - the server socket is being closed\n            if (nextExpiration > 0 && (keyCount > 0 || hasEvents) && (now < nextExpiration) && !close) {\n                return;\n            }\n            //timeout\n            Set<SelectionKey> keys = selector.keys();\n            int keycount = 0;\n            for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext();) {\n                SelectionKey key = iter.next();\n                keycount++;\n                try {\n                    KeyAttachment ka = (KeyAttachment) key.attachment();\n                    if ( ka == null ) {\n                        cancelledKey(key); //we don't support any keys without attachments\n                    } else if ( ka.getError() ) {\n                        cancelledKey(key);//TODO this is not yet being used\n                    } else if ((ka.interestOps()&SelectionKey.OP_READ) == SelectionKey.OP_READ ||\n                              (ka.interestOps()&SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {\n                        //only timeout sockets that we are waiting for a read from\n                        long delta = now - ka.getLastAccess();\n                        long timeout = ka.getTimeout();\n                        boolean isTimedout = timeout > 0 && delta > timeout;\n                        if ( close ) {\n                            key.interestOps(0);\n                            ka.interestOps(0); //avoid duplicate stop calls\n                            processKey(key,ka);\n                        } else if (isTimedout) {\n                            key.interestOps(0);\n                            ka.interestOps(0); //avoid duplicate timeout calls\n                            cancelledKey(key);\n                        }\n                    } else if (ka.isAsync()) {\n                        if (close) {\n                            key.interestOps(0);\n                            ka.interestOps(0); //avoid duplicate stop calls\n                            processKey(key,ka);\n                        } else if (!ka.isAsync() || ka.getTimeout() > 0) {\n                            // Async requests with a timeout of 0 or less never timeout\n                            long delta = now - ka.getLastAccess();\n                            long timeout = (ka.getTimeout()==-1)?((long) socketProperties.getSoTimeout()):(ka.getTimeout());\n                            boolean isTimedout = delta > timeout;\n                            if (isTimedout) {\n                                // Prevent subsequent timeouts if the timeout event takes a while to process\n                                ka.access(Long.MAX_VALUE);\n                                processSocket(ka, SocketStatus.TIMEOUT, true);\n                            }\n                        }\n                    }//end if\n                }catch ( CancelledKeyException ckx ) {\n                    cancelledKey(key);\n                }\n            }//for\n            long prevExp = nextExpiration; //for logging purposes only\n            nextExpiration = System.currentTimeMillis() +\n                    socketProperties.getTimeoutInterval();\n            if (log.isTraceEnabled()) {\n                log.trace(\"timeout completed: keys processed=\" + keycount +\n                        \"; now=\" + now + \"; nextExpiration=\" + prevExp +\n                        \"; keyCount=\" + keyCount + \"; hasEvents=\" + hasEvents +\n                        \"; eval=\" + ((now < prevExp) && (keyCount>0 || hasEvents) && (!close) ));\n            }\n\n        }","id":43160,"modified_method":"protected void timeout(int keyCount, boolean hasEvents) {\n            long now = System.currentTimeMillis();\n            // This method is called on every loop of the Poller. Don't process\n            // timeouts on every loop of the Poller since that would create too\n            // much load and timeouts can afford to wait a few seconds.\n            // However, do process timeouts if any of the following are true:\n            // - the selector simply timed out (suggests there isn't much load)\n            // - the nextExpiration time has passed\n            // - the server socket is being closed\n            if (nextExpiration > 0 && (keyCount > 0 || hasEvents) && (now < nextExpiration) && !close) {\n                return;\n            }\n            //timeout\n            Set<SelectionKey> keys = selector.keys();\n            int keycount = 0;\n            for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext();) {\n                SelectionKey key = iter.next();\n                keycount++;\n                try {\n                    KeyAttachment ka = (KeyAttachment) key.attachment();\n                    if ( ka == null ) {\n                        cancelledKey(key); //we don't support any keys without attachments\n                    } else if ( ka.getError() ) {\n                        cancelledKey(key);//TODO this is not yet being used\n                    } else if (ka.getCometNotify() ) {\n                        ka.setCometNotify(false);\n                        int ops = ka.interestOps() & ~OP_CALLBACK;\n                        reg(key,ka,0);//avoid multiple calls, this gets re-registered after invocation\n                        ka.interestOps(ops);\n                        if (!processSocket(ka, SocketStatus.OPEN_READ, true)) processSocket(ka, SocketStatus.DISCONNECT, true);\n                    } else if ((ka.interestOps()&SelectionKey.OP_READ) == SelectionKey.OP_READ ||\n                              (ka.interestOps()&SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {\n                        //only timeout sockets that we are waiting for a read from\n                        long delta = now - ka.getLastAccess();\n                        long timeout = ka.getTimeout();\n                        boolean isTimedout = timeout > 0 && delta > timeout;\n                        if ( close ) {\n                            key.interestOps(0);\n                            ka.interestOps(0); //avoid duplicate stop calls\n                            processKey(key,ka);\n                        } else if (isTimedout) {\n                            key.interestOps(0);\n                            ka.interestOps(0); //avoid duplicate timeout calls\n                            cancelledKey(key);\n                        }\n                    } else if (ka.isAsync()) {\n                        if (close) {\n                            key.interestOps(0);\n                            ka.interestOps(0); //avoid duplicate stop calls\n                            processKey(key,ka);\n                        } else if (!ka.isAsync() || ka.getTimeout() > 0) {\n                            // Async requests with a timeout of 0 or less never timeout\n                            long delta = now - ka.getLastAccess();\n                            long timeout = (ka.getTimeout()==-1)?((long) socketProperties.getSoTimeout()):(ka.getTimeout());\n                            boolean isTimedout = delta > timeout;\n                            if (isTimedout) {\n                                // Prevent subsequent timeouts if the timeout event takes a while to process\n                                ka.access(Long.MAX_VALUE);\n                                processSocket(ka, SocketStatus.TIMEOUT, true);\n                            }\n                        }\n                    }//end if\n                }catch ( CancelledKeyException ckx ) {\n                    cancelledKey(key);\n                }\n            }//for\n            long prevExp = nextExpiration; //for logging purposes only\n            nextExpiration = System.currentTimeMillis() +\n                    socketProperties.getTimeoutInterval();\n            if (log.isTraceEnabled()) {\n                log.trace(\"timeout completed: keys processed=\" + keycount +\n                        \"; now=\" + now + \"; nextExpiration=\" + prevExp +\n                        \"; keyCount=\" + keyCount + \"; hasEvents=\" + hasEvents +\n                        \"; eval=\" + ((now < prevExp) && (keyCount>0 || hasEvents) && (!close) ));\n            }\n\n        }","commit_id":"48762d46a56e290c4398851aaffffb37755ec7ba","url":"https://github.com/apache/tomcat"},{"original_method":"protected boolean processSocket(KeyAttachment attachment, SocketStatus status, boolean dispatch) {\n        try {\n            if (attachment == null) {\n                return false;\n            }\n            SocketProcessor sc = processorCache.pop();\n            if ( sc == null ) sc = new SocketProcessor(attachment, status);\n            else sc.reset(attachment, status);\n            Executor executor = getExecutor();\n            if (dispatch && executor != null) {\n                executor.execute(sc);\n            } else {\n                sc.run();\n            }\n        } catch (RejectedExecutionException ree) {\n            log.warn(sm.getString(\"endpoint.executor.fail\", attachment.getSocket()), ree);\n            return false;\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            // This means we got an OOM or similar creating a thread, or that\n            // the pool and its queue are full\n            log.error(sm.getString(\"endpoint.process.fail\"), t);\n            return false;\n        }\n        return true;\n    }","id":43161,"modified_method":"protected boolean processSocket(KeyAttachment attachment, SocketStatus status, boolean dispatch) {\n        try {\n            if (attachment == null) {\n                return false;\n            }\n            attachment.setCometNotify(false); //will get reset upon next reg\n            SocketProcessor sc = processorCache.pop();\n            if ( sc == null ) sc = new SocketProcessor(attachment, status);\n            else sc.reset(attachment, status);\n            Executor executor = getExecutor();\n            if (dispatch && executor != null) {\n                executor.execute(sc);\n            } else {\n                sc.run();\n            }\n        } catch (RejectedExecutionException ree) {\n            log.warn(sm.getString(\"endpoint.executor.fail\", attachment.getSocket()), ree);\n            return false;\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            // This means we got an OOM or similar creating a thread, or that\n            // the pool and its queue are full\n            log.error(sm.getString(\"endpoint.process.fail\"), t);\n            return false;\n        }\n        return true;\n    }","commit_id":"48762d46a56e290c4398851aaffffb37755ec7ba","url":"https://github.com/apache/tomcat"},{"original_method":"public void reset(Poller poller, NioChannel channel, long soTimeout) {\n            super.reset(channel, soTimeout);\n\n            interestOps = 0;\n            this.poller = poller;\n            sendfileData = null;\n            if (readLatch != null) {\n                try {\n                    for (int i = 0; i < (int) readLatch.getCount(); i++) {\n                        readLatch.countDown();\n                    }\n                } catch (Exception ignore) {\n                }\n            }\n            readLatch = null;\n            sendfileData = null;\n            if (writeLatch != null) {\n                try {\n                    for (int i = 0; i < (int) writeLatch.getCount(); i++) {\n                        writeLatch.countDown();\n                    }\n                } catch (Exception ignore) {\n                }\n            }\n            writeLatch = null;\n            setWriteTimeout(soTimeout);\n        }","id":43162,"modified_method":"public void reset(Poller poller, NioChannel channel, long soTimeout) {\n            super.reset(channel, soTimeout);\n\n            cometNotify = false;\n            interestOps = 0;\n            this.poller = poller;\n            sendfileData = null;\n            if (readLatch != null) {\n                try {\n                    for (int i = 0; i < (int) readLatch.getCount(); i++) {\n                        readLatch.countDown();\n                    }\n                } catch (Exception ignore) {\n                }\n            }\n            readLatch = null;\n            sendfileData = null;\n            if (writeLatch != null) {\n                try {\n                    for (int i = 0; i < (int) writeLatch.getCount(); i++) {\n                        writeLatch.countDown();\n                    }\n                } catch (Exception ignore) {\n                }\n            }\n            writeLatch = null;\n            setWriteTimeout(soTimeout);\n        }","commit_id":"48762d46a56e290c4398851aaffffb37755ec7ba","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public void run() {\n            if ( interestOps == OP_REGISTER ) {\n                try {\n                    socket.getIOChannel().register(socket.getPoller().getSelector(), SelectionKey.OP_READ, key);\n                } catch (Exception x) {\n                    log.error(\"\", x);\n                }\n            } else {\n                final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n                try {\n                    boolean cancel = false;\n                    if (key != null) {\n                        final KeyAttachment att = (KeyAttachment) key.attachment();\n                        if ( att!=null ) {\n                            //handle callback flag\n                            interestOps = (interestOps & (~OP_CALLBACK));//remove the callback flag\n                            att.access();//to prevent timeout\n                            //we are registering the key to start with, reset the fairness counter.\n                            int ops = key.interestOps() | interestOps;\n                            att.interestOps(ops);\n                            key.interestOps(ops);\n                        } else {\n                            cancel = true;\n                        }\n                    } else {\n                        cancel = true;\n                    }\n                    if ( cancel ) socket.getPoller().cancelledKey(key);\n                }catch (CancelledKeyException ckx) {\n                    try {\n                        socket.getPoller().cancelledKey(key);\n                    }catch (Exception ignore) {}\n                }\n            }//end if\n        }","id":43163,"modified_method":"@Override\n        public void run() {\n            if ( interestOps == OP_REGISTER ) {\n                try {\n                    socket.getIOChannel().register(socket.getPoller().getSelector(), SelectionKey.OP_READ, key);\n                } catch (Exception x) {\n                    log.error(\"\", x);\n                }\n            } else {\n                final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n                try {\n                    boolean cancel = false;\n                    if (key != null) {\n                        final KeyAttachment att = (KeyAttachment) key.attachment();\n                        if ( att!=null ) {\n                            //handle callback flag\n                            if ((interestOps & OP_CALLBACK) == OP_CALLBACK ) {\n                                att.setCometNotify(true);\n                            } else {\n                                att.setCometNotify(false);\n                            }\n                            interestOps = (interestOps & (~OP_CALLBACK));//remove the callback flag\n                            att.access();//to prevent timeout\n                            //we are registering the key to start with, reset the fairness counter.\n                            int ops = key.interestOps() | interestOps;\n                            att.interestOps(ops);\n                            if (att.getCometNotify()) key.interestOps(0);\n                            else key.interestOps(ops);\n                        } else {\n                            cancel = true;\n                        }\n                    } else {\n                        cancel = true;\n                    }\n                    if ( cancel ) socket.getPoller().cancelledKey(key);\n                }catch (CancelledKeyException ckx) {\n                    try {\n                        socket.getPoller().cancelledKey(key);\n                    }catch (Exception ignore) {}\n                }\n            }//end if\n        }","commit_id":"48762d46a56e290c4398851aaffffb37755ec7ba","url":"https://github.com/apache/tomcat"},{"original_method":"protected static <T> T invokeProcessStdErr(\n\t\tOutputProcessor<T, ?> outputProcessor, InputStream inputStream) {\n\n\t\treturn (T)ReflectionTestUtil.invokeBridge(\n\t\t\toutputProcessor, \"processStdErr\",\n\t\t\tnew Class<?>[] {InputStream.class}, inputStream);\n\t}","id":43164,"modified_method":"protected static <T> T invokeProcessStdErr(\n\t\tOutputProcessor<T, ?> outputProcessor, InputStream inputStream) {\n\n\t\treturn ReflectionTestUtil.invokeBridge(\n\t\t\toutputProcessor, \"processStdErr\",\n\t\t\tnew Class<?>[] {InputStream.class}, inputStream);\n\t}","commit_id":"135e90a7176819ec33560924e3c4948b05c78188","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static <T> T invokeProcessStdOut(\n\t\tOutputProcessor<?, T> outputProcessor, InputStream inputStream) {\n\n\t\treturn (T)ReflectionTestUtil.invokeBridge(\n\t\t\toutputProcessor, \"processStdOut\",\n\t\t\tnew Class<?>[] {InputStream.class}, inputStream);\n\t}","id":43165,"modified_method":"protected static <T> T invokeProcessStdOut(\n\t\tOutputProcessor<?, T> outputProcessor, InputStream inputStream) {\n\n\t\treturn ReflectionTestUtil.invokeBridge(\n\t\t\toutputProcessor, \"processStdOut\",\n\t\t\tnew Class<?>[] {InputStream.class}, inputStream);\n\t}","commit_id":"135e90a7176819ec33560924e3c4948b05c78188","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testCall() throws Exception {\n\t\tfinal AtomicBoolean throwIOException = new AtomicBoolean();\n\n\t\t// Sucess\n\n\t\tProcessOutputStream processOutputStream = new ProcessOutputStream(\n\t\t\tnew ObjectOutputStream(new UnsyncByteArrayOutputStream())) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void writeProcessCallable(\n\t\t\t\t\t\tProcessCallable<?> processCallable)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\tif (throwIOException.get()) {\n\t\t\t\t\t\tthrow new IOException();\n\t\t\t\t\t}\n\n\t\t\t\t\tsuper.writeProcessCallable(processCallable);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\tReflectionTestUtil.setFieldValue(\n\t\t\tProcessContext.class, \"_processOutputStream\", processOutputStream);\n\n\t\tConcurrentMap<String, Object> attributes =\n\t\t\tProcessContext.getAttributes();\n\n\t\tSPI spi = (SPI)ReflectionTestUtil.invokeBridge(\n\t\t\t_mockRemoteSPI, \"call\", new Class<?>[0]);\n\n\t\tAssert.assertSame(spi, UnicastRemoteObject.toStub(_mockRemoteSPI));\n\n\t\tAssert.assertTrue(ProcessContext.isAttached());\n\n\t\tProcessContext.detach();\n\n\t\tAssert.assertSame(\n\t\t\t_mockRemoteSPI,\n\t\t\tattributes.remove(SPI.SPI_INSTANCE_PUBLICATION_KEY));\n\n\t\t// Duplicate export\n\n\t\ttry {\n\t\t\t_mockRemoteSPI.call();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ProcessException pe) {\n\t\t\tThrowable throwable = pe.getCause();\n\n\t\t\tAssert.assertSame(ExportException.class, throwable.getClass());\n\t\t}\n\n\t\tAssert.assertTrue(ProcessContext.isAttached());\n\n\t\tProcessContext.detach();\n\n\t\tAssert.assertNull(attributes.remove(SPI.SPI_INSTANCE_PUBLICATION_KEY));\n\n\t\t// Unable to write process callable\n\n\t\tUnicastRemoteObject.unexportObject(_mockRemoteSPI, true);\n\n\t\tthrowIOException.set(true);\n\n\t\ttry {\n\t\t\t_mockRemoteSPI.call();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ProcessException pe) {\n\t\t\tThrowable throwable = pe.getCause();\n\n\t\t\tAssert.assertSame(IOException.class, throwable.getClass());\n\t\t}\n\n\t\tAssert.assertTrue(ProcessContext.isAttached());\n\n\t\tProcessContext.detach();\n\n\t\tAssert.assertNull(attributes.remove(SPI.SPI_INSTANCE_PUBLICATION_KEY));\n\n\t\tUnicastRemoteObject.unexportObject(_mockRemoteSPI, true);\n\t}","id":43166,"modified_method":"@Test\n\tpublic void testCall() throws Exception {\n\t\tfinal AtomicBoolean throwIOException = new AtomicBoolean();\n\n\t\t// Sucess\n\n\t\tProcessOutputStream processOutputStream = new ProcessOutputStream(\n\t\t\tnew ObjectOutputStream(new UnsyncByteArrayOutputStream())) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void writeProcessCallable(\n\t\t\t\t\t\tProcessCallable<?> processCallable)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\tif (throwIOException.get()) {\n\t\t\t\t\t\tthrow new IOException();\n\t\t\t\t\t}\n\n\t\t\t\t\tsuper.writeProcessCallable(processCallable);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\tReflectionTestUtil.setFieldValue(\n\t\t\tProcessContext.class, \"_processOutputStream\", processOutputStream);\n\n\t\tConcurrentMap<String, Object> attributes =\n\t\t\tProcessContext.getAttributes();\n\n\t\tSPI spi = ReflectionTestUtil.invokeBridge(\n\t\t\t_mockRemoteSPI, \"call\", new Class<?>[0]);\n\n\t\tAssert.assertSame(spi, UnicastRemoteObject.toStub(_mockRemoteSPI));\n\n\t\tAssert.assertTrue(ProcessContext.isAttached());\n\n\t\tProcessContext.detach();\n\n\t\tAssert.assertSame(\n\t\t\t_mockRemoteSPI,\n\t\t\tattributes.remove(SPI.SPI_INSTANCE_PUBLICATION_KEY));\n\n\t\t// Duplicate export\n\n\t\ttry {\n\t\t\t_mockRemoteSPI.call();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ProcessException pe) {\n\t\t\tThrowable throwable = pe.getCause();\n\n\t\t\tAssert.assertSame(ExportException.class, throwable.getClass());\n\t\t}\n\n\t\tAssert.assertTrue(ProcessContext.isAttached());\n\n\t\tProcessContext.detach();\n\n\t\tAssert.assertNull(attributes.remove(SPI.SPI_INSTANCE_PUBLICATION_KEY));\n\n\t\t// Unable to write process callable\n\n\t\tUnicastRemoteObject.unexportObject(_mockRemoteSPI, true);\n\n\t\tthrowIOException.set(true);\n\n\t\ttry {\n\t\t\t_mockRemoteSPI.call();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (ProcessException pe) {\n\t\t\tThrowable throwable = pe.getCause();\n\n\t\t\tAssert.assertSame(IOException.class, throwable.getClass());\n\t\t}\n\n\t\tAssert.assertTrue(ProcessContext.isAttached());\n\n\t\tProcessContext.detach();\n\n\t\tAssert.assertNull(attributes.remove(SPI.SPI_INSTANCE_PUBLICATION_KEY));\n\n\t\tUnicastRemoteObject.unexportObject(_mockRemoteSPI, true);\n\t}","commit_id":"135e90a7176819ec33560924e3c4948b05c78188","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ByteBuffer buf() {\n    r.lock();\n    try {\n      myAccessCounter++;\n\n      ByteBuffer buffer = myBuffer;\n      if (buffer == null) {\n        synchronized (LOCK) {\n          buffer = map();\n\n          ourMappedWrappers.add(this);\n          myBuffer = buffer;\n        }\n      }\n\n      return buffer;\n    }\n    finally {\n      r.unlock();\n    }\n  }","id":43167,"modified_method":"public ByteBuffer buf() {\n    lock();\n    try {\n      myAccessCounter++;\n\n      ByteBuffer buffer = myBuffer;\n      if (buffer == null) {\n        synchronized (LOCK) {\n          buffer = myBuffer;\n          if (buffer == null) { // Double checking\n            buffer = map();\n\n            ourMappedWrappers.add(this);\n            myBuffer = buffer;\n          }\n        }\n      }\n\n      return buffer;\n    }\n    finally {\n      unlock();\n    }\n  }","commit_id":"913a5c306be9468ca8a341b032e7629857fd9b5e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void put(int index, byte[] src, int offset, int length) {\n    final ByteBuffer buffer = getBuffer();\n    buffer.position(index);\n    buffer.put(src, offset, length);\n  }","id":43168,"modified_method":"public void put(int index, byte[] src, int offset, int length) {\n    final ByteBuffer buffer = getBuffer().duplicate();\n    buffer.position(index);\n    buffer.put(src, offset, length);\n  }","commit_id":"913a5c306be9468ca8a341b032e7629857fd9b5e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void get(int index, byte[] dst, int offset, int length) {\n    final ByteBuffer buffer = getBuffer();\n    buffer.position(index);\n    buffer.get(dst, offset, length);\n  }","id":43169,"modified_method":"public void get(int index, byte[] dst, int offset, int length) {\n    final ByteBuffer buffer = getBuffer().duplicate();\n    buffer.position(index);\n    buffer.get(dst, offset, length);\n  }","commit_id":"913a5c306be9468ca8a341b032e7629857fd9b5e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"AbstractPersistenceWindow( long position, int recordSize, int totalSize, \n        FileChannel channel, ByteBuffer byteBuffer )\n    {\n        super( channel );\n        assert position >= 0 : \"Illegal position[\" + position + \"]\";\n        assert recordSize > 0 : \"Illegal recordSize[\" + recordSize + \"]\";\n        assert channel != null : \"Null file channel\";\n        assert totalSize >= recordSize;\n        \n        this.position = position;\n        this.recordSize = recordSize;\n        this.totalSize = totalSize;\n        this.windowSize = totalSize / recordSize;\n        this.buffer = new Buffer( this, byteBuffer );\n        // this.buffer.setByteBuffer( byteBuffer );\n    }","id":43170,"modified_method":"AbstractPersistenceWindow( long position, int recordSize, int totalSize, \n        FileChannel channel, ByteBuffer byteBuffer )\n    {\n        super( channel );\n        assert position >= 0 : \"Illegal position[\" + position + \"]\";\n        assert recordSize > 0 : \"Illegal recordSize[\" + recordSize + \"]\";\n        assert channel != null : \"Null file channel\";\n        assert totalSize >= recordSize;\n        \n        this.position = position;\n        this.recordSize = recordSize;\n        this.windowSize = totalSize / recordSize;\n        this.buffer = new Buffer( this, byteBuffer );\n        // this.buffer.setByteBuffer( byteBuffer );\n    }","commit_id":"478fa17d393614183aef87a4ddf90de9ec8f4bc3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void writeContents()\n    {\n        ByteBuffer byteBuffer = buffer.getBuffer().duplicate();\n        byteBuffer.clear();\n\n        try\n        {\n            int written = 0;\n\n            while ( byteBuffer.hasRemaining() ) {\n                int writtenThisTime = getFileChannel().write( byteBuffer, position * recordSize + written );\n\n                if (writtenThisTime == 0)\n                    throw new IOException( \"Unable to write to disk, reported bytes written was \" + writtenThisTime );\n\n                written += writtenThisTime;\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( \"Unable to write record[\"\n                + position + \"] @[\" + position * recordSize + \"]\", e );\n        }\n    }","id":43171,"modified_method":"private void writeContents()\n    {\n        ByteBuffer byteBuffer = buffer.getBuffer().duplicate();\n        byteBuffer.clear();\n\n        try\n        {\n            int written = 0;\n\n            while ( byteBuffer.hasRemaining() ) {\n                int writtenThisTime = getFileChannel().write( byteBuffer, position * recordSize + written );\n\n                if (writtenThisTime == 0)\n                    throw new IOException( \"Unable to write to disk, reported bytes written was 0\" );\n\n                written += writtenThisTime;\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( \"Unable to write record[\"\n                + position + \"] @[\" + position * recordSize + \"]\", e );\n        }\n    }","commit_id":"478fa17d393614183aef87a4ddf90de9ec8f4bc3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void writeContents()\n    {\n        ByteBuffer byteBuffer = buffer.getBuffer();\n        if ( isDirty() )\n        {\n            byteBuffer.clear();\n            try\n            {\n                int count = getFileChannel().write( byteBuffer,\n                    position * recordSize );\n                assert count == recordSize;\n            }\n            catch ( IOException e )\n            {\n                throw new UnderlyingStorageException( \"Unable to write record[\"\n                    + position + \"] @[\" + position * recordSize + \"]\", e );\n            }\n        }\n        byteBuffer.clear();\n    }","id":43172,"modified_method":"private void writeContents()\n    {\n        if ( isDirty() )\n        {\n            ByteBuffer byteBuffer = buffer.getBuffer().duplicate();\n            byteBuffer.clear();\n            try\n            {\n                int written = 0;\n\n                while ( byteBuffer.hasRemaining() )\n                {\n                    int writtenThisTime = getFileChannel().write( byteBuffer, position * recordSize + written );\n\n                    if ( writtenThisTime == 0 )\n                    {\n                        throw new IOException( \"Unable to write to disk, reported bytes written was 0\" );\n                    }\n\n                    written += writtenThisTime;\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new UnderlyingStorageException( \"Unable to write record[\"\n                        + position + \"] @[\" + position * recordSize + \"]\", e );\n            }\n        }\n    }","commit_id":"478fa17d393614183aef87a4ddf90de9ec8f4bc3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void writeContents()\n    {\n        ByteBuffer byteBuffer = buffer.getBuffer();\n        byteBuffer.clear();\n\n        try\n        {\n            int written = 0;\n\n            while ( byteBuffer.hasRemaining() ) {\n                int writtenThisTime = getFileChannel().write( byteBuffer, position * recordSize + written );\n\n                if (writtenThisTime == 0)\n                    throw new IOException( \"Unable to write to disk, reported bytes written was \" + writtenThisTime );\n\n                written += writtenThisTime;\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( \"Unable to write record[\"\n                + position + \"] @[\" + position * recordSize + \"]\", e );\n        }\n    }","id":43173,"modified_method":"private void writeContents()\n    {\n        ByteBuffer byteBuffer = buffer.getBuffer().duplicate();\n        byteBuffer.clear();\n\n        try\n        {\n            int written = 0;\n\n            while ( byteBuffer.hasRemaining() ) {\n                int writtenThisTime = getFileChannel().write( byteBuffer, position * recordSize + written );\n\n                if (writtenThisTime == 0)\n                    throw new IOException( \"Unable to write to disk, reported bytes written was \" + writtenThisTime );\n\n                written += writtenThisTime;\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( \"Unable to write record[\"\n                + position + \"] @[\" + position * recordSize + \"]\", e );\n        }\n    }","commit_id":"63bb175f3b1b70928d47c4cef21c6ade8364bbe7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public long rotateLogicalLog() throws IOException\n    {\n        return logicalLog.rotate();\n    }","id":43174,"modified_method":"@Override\n    public long rotateLogicalLog() throws IOException\n    {\n        // Go through XaResourceManager so that all paths which rotates the\n        // logical log will go through its lock\n        return getXaContainer().getResourceManager().rotateLogicalLog();\n    }","commit_id":"63bb175f3b1b70928d47c4cef21c6ade8364bbe7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void performUndo() {\n    exchangeStrings(uncompressCharSequence(myNewString, myCharset), uncompressCharSequence(myOldString, myCharset));\n  }","id":43175,"modified_method":"public void performUndo() {\n    CharSequence oldString = CompressionUtil.uncompressCharSequence(myOldString, myCharset);\n    CharSequence newString = CompressionUtil.uncompressCharSequence(myNewString, myCharset);\n    exchangeStrings(newString, oldString);\n  }","commit_id":"e0cb4c01db0e77aae2f80a55b38c8c25c4ebe2d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EditorChangeAction(@NotNull DocumentEx document,\n                            int offset,\n                            CharSequence oldString,\n                            CharSequence newString,\n                            long oldTimeStamp) {\n    super(document);\n\n    Charset charset = EncodingManager.getInstance().getEncoding(FileDocumentManager.getInstance().getFile(document), true);\n    if (charset == null) charset = EncodingManager.getInstance().getDefaultCharset();\n    if (charset == null) charset = Charset.defaultCharset();\n    myCharset = charset;\n\n    myOffset = offset;\n    myOldString = oldString == null ? \"\" : compressCharSequence(oldString, myCharset);\n    myNewString = newString == null ? \"\" : compressCharSequence(newString, myCharset);\n    myOldTimeStamp = oldTimeStamp;\n    myNewTimeStamp = document.getModificationStamp();\n  }","id":43176,"modified_method":"public EditorChangeAction(@NotNull DocumentEx document,\n                            int offset,\n                            @NotNull CharSequence oldString,\n                            @NotNull CharSequence newString,\n                            long oldTimeStamp) {\n    super(document);\n    myOffset = offset;\n    myOldString = CompressionUtil.compressCharSequence(oldString, myCharset);\n    myNewString = CompressionUtil.compressCharSequence(newString, myCharset);\n    myOldTimeStamp = oldTimeStamp;\n    myNewTimeStamp = document.getModificationStamp();\n  }","commit_id":"e0cb4c01db0e77aae2f80a55b38c8c25c4ebe2d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void redo() {\n    DocumentUndoProvider.startDocumentUndo(getDocument());\n    try {\n      exchangeStrings(uncompressCharSequence(myOldString, myCharset), uncompressCharSequence(myNewString, myCharset));\n    }\n    finally {\n      DocumentUndoProvider.finishDocumentUndo(getDocument());\n    }\n    getDocument().setModificationStamp(myNewTimeStamp);\n    refreshFileStatus();\n  }","id":43177,"modified_method":"@Override\n  public void redo() {\n    DocumentUndoProvider.startDocumentUndo(getDocument());\n    try {\n      CharSequence oldString = CompressionUtil.uncompressCharSequence(myOldString, myCharset);\n      CharSequence newString = CompressionUtil.uncompressCharSequence(myNewString, myCharset);\n      exchangeStrings(oldString, newString);\n    }\n    finally {\n      DocumentUndoProvider.finishDocumentUndo(getDocument());\n    }\n    getDocument().setModificationStamp(myNewTimeStamp);\n    refreshFileStatus();\n  }","commit_id":"e0cb4c01db0e77aae2f80a55b38c8c25c4ebe2d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isIncrement(Cell cell) {\n    return cell.getValueLength() == IncrementHandler.DELTA_FULL_LENGTH &&\n      Bytes.equals(cell.getValueArray(), cell.getValueOffset(), IncrementHandler.DELTA_MAGIC_PREFIX.length,\n                   IncrementHandler.DELTA_MAGIC_PREFIX, 0, IncrementHandler.DELTA_MAGIC_PREFIX.length);\n  }","id":43178,"modified_method":"public static boolean isIncrement(Cell cell) {\n    return !CellUtil.isDelete(cell) && cell.getValueLength() == IncrementHandler.DELTA_FULL_LENGTH &&\n      Bytes.equals(cell.getValueArray(), cell.getValueOffset(), IncrementHandler.DELTA_MAGIC_PREFIX.length,\n                   IncrementHandler.DELTA_MAGIC_PREFIX, 0, IncrementHandler.DELTA_MAGIC_PREFIX.length);\n  }","commit_id":"20e44cf3feb50328f2856969a4898fa3e07238f3","url":"https://github.com/caskdata/cdap"},{"original_method":"public static boolean isIncrement(KeyValue kv) {\n    return kv.getValueLength() == IncrementHandler.DELTA_FULL_LENGTH &&\n      Bytes.equals(kv.getBuffer(), kv.getValueOffset(), IncrementHandler.DELTA_MAGIC_PREFIX.length,\n                   IncrementHandler.DELTA_MAGIC_PREFIX, 0, IncrementHandler.DELTA_MAGIC_PREFIX.length);\n  }","id":43179,"modified_method":"public static boolean isIncrement(KeyValue kv) {\n    return !KeyValue.isDelete(kv.getType()) && kv.getValueLength() == IncrementHandler.DELTA_FULL_LENGTH &&\n      Bytes.equals(kv.getBuffer(), kv.getValueOffset(), IncrementHandler.DELTA_MAGIC_PREFIX.length,\n                   IncrementHandler.DELTA_MAGIC_PREFIX, 0, IncrementHandler.DELTA_MAGIC_PREFIX.length);\n  }","commit_id":"20e44cf3feb50328f2856969a4898fa3e07238f3","url":"https://github.com/caskdata/cdap"},{"original_method":"public static boolean isIncrement(Cell cell) {\n    return cell.getValueLength() == IncrementHandler.DELTA_FULL_LENGTH &&\n      Bytes.equals(cell.getValueArray(), cell.getValueOffset(), IncrementHandler.DELTA_MAGIC_PREFIX.length,\n                   IncrementHandler.DELTA_MAGIC_PREFIX, 0, IncrementHandler.DELTA_MAGIC_PREFIX.length);\n  }","id":43180,"modified_method":"public static boolean isIncrement(Cell cell) {\n    return !CellUtil.isDelete(cell) && cell.getValueLength() == IncrementHandler.DELTA_FULL_LENGTH &&\n      Bytes.equals(cell.getValueArray(), cell.getValueOffset(), IncrementHandler.DELTA_MAGIC_PREFIX.length,\n                   IncrementHandler.DELTA_MAGIC_PREFIX, 0, IncrementHandler.DELTA_MAGIC_PREFIX.length);\n  }","commit_id":"20e44cf3feb50328f2856969a4898fa3e07238f3","url":"https://github.com/caskdata/cdap"},{"original_method":"private boolean nextInternal(List<Cell> cells, int limit) throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"nextInternal called with limit=\" + limit);\n    }\n    Cell previousIncrement = null;\n    long runningSum = 0;\n    int addedCnt = 0;\n    baseScanner.startNext();\n    Cell cell = null;\n    while ((cell = baseScanner.peekNextCell(limit)) != null && (limit <= 0 || addedCnt < limit)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Checking cell \" + cell);\n      }\n      // any cells visible to in-progress transactions must be kept unchanged\n      if (cell.getTimestamp() > compactionUpperBound) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including cell visible to in-progress, cell=\" + cell);\n        }\n        cells.add(cell);\n        addedCnt++;\n        baseScanner.nextCell(limit);\n        continue;\n      }\n\n      // compact any delta writes\n      if (IncrementHandler.isIncrement(cell)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Found increment for row=\" + Bytes.toStringBinary(CellUtil.cloneRow(cell)) + \", \" +\n              \"column=\" + Bytes.toStringBinary(CellUtil.cloneQualifier(cell)));\n        }\n        if (!sameCell(previousIncrement, cell)) {\n          if (previousIncrement != null) {\n            // if different qualifier, and prev qualifier non-null\n            // emit the previous sum\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n            }\n            cells.add(newCell(previousIncrement, runningSum));\n            previousIncrement = null;\n            addedCnt++;\n            // continue without advancing, current cell will be consumed on the next iteration\n            continue;\n          }\n          previousIncrement = cell;\n          runningSum = 0;\n        }\n        // add this increment to the tally\n        runningSum += Bytes.toLong(cell.getValueArray(),\n            cell.getValueOffset() + IncrementHandler.DELTA_MAGIC_PREFIX.length);\n      } else {\n        // otherwise (not an increment)\n        if (previousIncrement != null) {\n          if (sameCell(previousIncrement, cell)) {\n            // if qualifier matches previous and this is a long, add to running sum, emit\n            runningSum += Bytes.toLong(cell.getValueArray(), cell.getValueOffset());\n            // this cell already processed as part of the previous increment\n            baseScanner.nextCell(limit);\n          }\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n          }\n          cells.add(newCell(previousIncrement, runningSum));\n          addedCnt++;\n          previousIncrement = null;\n          runningSum = 0;\n\n          continue;\n        }\n        // otherwise emit the current cell\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including raw cell: \" + cell);\n        }\n\n        cells.add(cell);\n        addedCnt++;\n      }\n      // if we made it this far, consume the current cell\n      baseScanner.nextCell(limit);\n    }\n    // emit any left over increment, if we hit the end\n    if (previousIncrement != null) {\n      // in any situation where we exited due to limit, previousIncrement should already be null\n      Preconditions.checkState(limit <= 0 || addedCnt < limit);\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Including leftover increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n      }\n      cells.add(newCell(previousIncrement, runningSum));\n    }\n\n    return baseScanner.hasMore();\n  }","id":43181,"modified_method":"private boolean nextInternal(List<Cell> cells, int limit) throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"nextInternal called with limit=\" + limit);\n    }\n    Cell previousIncrement = null;\n    long runningSum = 0;\n    int addedCnt = 0;\n    baseScanner.startNext();\n    Cell cell = null;\n    while ((cell = baseScanner.peekNextCell(limit)) != null && (limit <= 0 || addedCnt < limit)) {\n      // we use the \"peek\" semantics so that only once cell is ever emitted per iteration\n      // this makes is clearer and easier to enforce that the returned results are <= limit\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Checking cell \" + cell);\n      }\n      // any cells visible to in-progress transactions must be kept unchanged\n      if (cell.getTimestamp() > compactionUpperBound) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including cell visible to in-progress, cell=\" + cell);\n        }\n        cells.add(cell);\n        addedCnt++;\n        baseScanner.nextCell(limit);\n        continue;\n      }\n\n      // compact any delta writes\n      if (IncrementHandler.isIncrement(cell)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Found increment for row=\" + Bytes.toStringBinary(CellUtil.cloneRow(cell)) + \", \" +\n              \"column=\" + Bytes.toStringBinary(CellUtil.cloneQualifier(cell)));\n        }\n        if (!sameCell(previousIncrement, cell)) {\n          if (previousIncrement != null) {\n            // if different qualifier, and prev qualifier non-null\n            // emit the previous sum\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n            }\n            cells.add(newCell(previousIncrement, runningSum));\n            previousIncrement = null;\n            addedCnt++;\n            // continue without advancing, current cell will be consumed on the next iteration\n            continue;\n          }\n          previousIncrement = cell;\n          runningSum = 0;\n        }\n        // add this increment to the tally\n        runningSum += Bytes.toLong(cell.getValueArray(),\n            cell.getValueOffset() + IncrementHandler.DELTA_MAGIC_PREFIX.length);\n      } else {\n        // otherwise (not an increment)\n        if (previousIncrement != null) {\n          if (sameCell(previousIncrement, cell) && !CellUtil.isDelete(cell)) {\n            // if qualifier matches previous and this is a long, add to running sum, emit\n            runningSum += Bytes.toLong(cell.getValueArray(), cell.getValueOffset());\n            // this cell already processed as part of the previous increment's sum, so consume it\n            baseScanner.nextCell(limit);\n          }\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n          }\n          // if this put is a different cell from the previous increment, then\n          // we only emit the previous increment, reset it, and continue.\n          // the current cell will be consumed on the next iteration, if we have not yet reached the limit\n          cells.add(newCell(previousIncrement, runningSum));\n          addedCnt++;\n          previousIncrement = null;\n          runningSum = 0;\n\n          continue;\n        }\n        // otherwise emit the current cell\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including raw cell: \" + cell);\n        }\n\n        cells.add(cell);\n        addedCnt++;\n      }\n      // if we made it this far, consume the current cell\n      baseScanner.nextCell(limit);\n    }\n    // emit any left over increment, if we hit the end\n    if (previousIncrement != null) {\n      // in any situation where we exited due to limit, previousIncrement should already be null\n      Preconditions.checkState(limit <= 0 || addedCnt < limit);\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Including leftover increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n      }\n      cells.add(newCell(previousIncrement, runningSum));\n    }\n\n    return baseScanner.hasMore();\n  }","commit_id":"20e44cf3feb50328f2856969a4898fa3e07238f3","url":"https://github.com/caskdata/cdap"},{"original_method":"private boolean nextInternal(List<KeyValue> cells, int limit, String metric) throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"nextInternal called with limit=\" + limit);\n    }\n    KeyValue previousIncrement = null;\n    long runningSum = 0;\n    int addedCnt = 0;\n    baseScanner.startNext();\n    KeyValue cell = null;\n    while ((cell = baseScanner.peekNextCell(limit)) != null && (limit <= 0 || addedCnt < limit)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Checking cell \" + cell);\n      }\n      // any cells visible to in-progress transactions must be kept unchanged\n      if (cell.getTimestamp() > compactionUpperBound) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including cell visible to in-progress, cell=\" + cell);\n        }\n        cells.add(cell);\n        addedCnt++;\n        baseScanner.nextCell(limit);\n        continue;\n      }\n\n      // compact any delta writes\n      if (IncrementHandler.isIncrement(cell)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Found increment for row=\" + Bytes.toStringBinary(cell.getRow()) + \", \" +\n              \"column=\" + Bytes.toStringBinary(cell.getQualifier()));\n        }\n        if (!sameCell(previousIncrement, cell)) {\n          if (previousIncrement != null) {\n            // if different qualifier, and prev qualifier non-null\n            // emit the previous sum\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n            }\n            cells.add(newCell(previousIncrement, runningSum));\n            previousIncrement = null;\n            addedCnt++;\n            // continue without advancing, current cell will be consumed on the next iteration\n            continue;\n          }\n          previousIncrement = cell;\n          runningSum = 0;\n        }\n        // add this increment to the tally\n        runningSum += Bytes.toLong(cell.getBuffer(),\n            cell.getValueOffset() + IncrementHandler.DELTA_MAGIC_PREFIX.length);\n      } else {\n        // otherwise (not an increment)\n        if (previousIncrement != null) {\n          if (sameCell(previousIncrement, cell)) {\n            // if qualifier matches previous and this is a long, add to running sum, emit\n            runningSum += Bytes.toLong(cell.getBuffer(), cell.getValueOffset());\n            // this cell already processed as part of the previous increment\n            baseScanner.nextCell(limit);\n          }\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n          }\n          cells.add(newCell(previousIncrement, runningSum));\n          addedCnt++;\n          previousIncrement = null;\n          runningSum = 0;\n\n          continue;\n        }\n        // otherwise emit the current cell\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including raw cell: \" + cell);\n        }\n\n        cells.add(cell);\n        addedCnt++;\n      }\n      // if we made it this far, consume the current cell\n      baseScanner.nextCell(limit);\n    }\n    // emit any left over increment, if we hit the end\n    if (previousIncrement != null) {\n      // in any situation where we exited due to limit, previousIncrement should already be null\n      Preconditions.checkState(limit <= 0 || addedCnt < limit);\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Including leftover increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n      }\n      cells.add(newCell(previousIncrement, runningSum));\n    }\n\n    return baseScanner.hasMore();\n  }","id":43182,"modified_method":"private boolean nextInternal(List<KeyValue> cells, int limit, String metric) throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"nextInternal called with limit=\" + limit);\n    }\n    KeyValue previousIncrement = null;\n    long runningSum = 0;\n    int addedCnt = 0;\n    baseScanner.startNext();\n    KeyValue cell = null;\n    while ((cell = baseScanner.peekNextCell(limit)) != null && (limit <= 0 || addedCnt < limit)) {\n      // we use the \"peek\" semantics so that only once cell is ever emitted per iteration\n      // this makes is clearer and easier to enforce that the returned results are <= limit\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Checking cell \" + cell);\n      }\n      // any cells visible to in-progress transactions must be kept unchanged\n      if (cell.getTimestamp() > compactionUpperBound) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including cell visible to in-progress, cell=\" + cell);\n        }\n        cells.add(cell);\n        addedCnt++;\n        baseScanner.nextCell(limit);\n        continue;\n      }\n\n      // compact any delta writes\n      if (IncrementHandler.isIncrement(cell)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Found increment for row=\" + Bytes.toStringBinary(cell.getRow()) + \", \" +\n              \"column=\" + Bytes.toStringBinary(cell.getQualifier()));\n        }\n        if (!sameCell(previousIncrement, cell)) {\n          if (previousIncrement != null) {\n            // if different qualifier, and prev qualifier non-null\n            // emit the previous sum\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n            }\n            cells.add(newCell(previousIncrement, runningSum));\n            previousIncrement = null;\n            addedCnt++;\n            // continue without advancing, current cell will be consumed on the next iteration\n            continue;\n          }\n          previousIncrement = cell;\n          runningSum = 0;\n        }\n        // add this increment to the tally\n        runningSum += Bytes.toLong(cell.getBuffer(),\n            cell.getValueOffset() + IncrementHandler.DELTA_MAGIC_PREFIX.length);\n      } else {\n        // otherwise (not an increment)\n        if (previousIncrement != null) {\n          if (sameCell(previousIncrement, cell) && !KeyValue.isDelete(cell.getType())) {\n            // if qualifier matches previous and this is a long, add to running sum, emit\n            runningSum += Bytes.toLong(cell.getBuffer(), cell.getValueOffset());\n            // this cell already processed as part of the previous increment's sum, so consume it\n            baseScanner.nextCell(limit);\n          }\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n          }\n          // if this put is a different cell from the previous increment, then\n          // we only emit the previous increment, reset it, and continue.\n          // the current cell will be consumed on the next iteration, if we have not yet reached the limit\n          cells.add(newCell(previousIncrement, runningSum));\n          addedCnt++;\n          previousIncrement = null;\n          runningSum = 0;\n\n          continue;\n        }\n        // otherwise emit the current cell\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including raw cell: \" + cell);\n        }\n\n        cells.add(cell);\n        addedCnt++;\n      }\n      // if we made it this far, consume the current cell\n      baseScanner.nextCell(limit);\n    }\n    // emit any left over increment, if we hit the end\n    if (previousIncrement != null) {\n      // in any situation where we exited due to limit, previousIncrement should already be null\n      Preconditions.checkState(limit <= 0 || addedCnt < limit);\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Including leftover increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n      }\n      cells.add(newCell(previousIncrement, runningSum));\n    }\n\n    return baseScanner.hasMore();\n  }","commit_id":"20e44cf3feb50328f2856969a4898fa3e07238f3","url":"https://github.com/caskdata/cdap"},{"original_method":"private boolean nextInternal(List<Cell> cells, int limit) throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"nextInternal called with limit=\" + limit);\n    }\n    Cell previousIncrement = null;\n    long runningSum = 0;\n    int addedCnt = 0;\n    baseScanner.startNext();\n    Cell cell = null;\n    while ((cell = baseScanner.peekNextCell(limit)) != null && (limit <= 0 || addedCnt < limit)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Checking cell \" + cell);\n      }\n      // any cells visible to in-progress transactions must be kept unchanged\n      if (cell.getTimestamp() > compactionUpperBound) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including cell visible to in-progress, cell=\" + cell);\n        }\n        cells.add(cell);\n        addedCnt++;\n        baseScanner.nextCell(limit);\n        continue;\n      }\n\n      // compact any delta writes\n      if (IncrementHandler.isIncrement(cell)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Found increment for row=\" + Bytes.toStringBinary(CellUtil.cloneRow(cell)) + \", \" +\n              \"column=\" + Bytes.toStringBinary(CellUtil.cloneQualifier(cell)));\n        }\n        if (!sameCell(previousIncrement, cell)) {\n          if (previousIncrement != null) {\n            // if different qualifier, and prev qualifier non-null\n            // emit the previous sum\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n            }\n            cells.add(newCell(previousIncrement, runningSum));\n            previousIncrement = null;\n            addedCnt++;\n            // continue without advancing, current cell will be consumed on the next iteration\n            continue;\n          }\n          previousIncrement = cell;\n          runningSum = 0;\n        }\n        // add this increment to the tally\n        runningSum += Bytes.toLong(cell.getValueArray(),\n            cell.getValueOffset() + IncrementHandler.DELTA_MAGIC_PREFIX.length);\n      } else {\n        // otherwise (not an increment)\n        if (previousIncrement != null) {\n          if (sameCell(previousIncrement, cell)) {\n            // if qualifier matches previous and this is a long, add to running sum, emit\n            runningSum += Bytes.toLong(cell.getValueArray(), cell.getValueOffset());\n            // this cell already processed as part of the previous increment\n            baseScanner.nextCell(limit);\n          }\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n          }\n          cells.add(newCell(previousIncrement, runningSum));\n          addedCnt++;\n          previousIncrement = null;\n          runningSum = 0;\n\n          continue;\n        }\n        // otherwise emit the current cell\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including raw cell: \" + cell);\n        }\n\n        cells.add(cell);\n        addedCnt++;\n      }\n      // if we made it this far, consume the current cell\n      baseScanner.nextCell(limit);\n    }\n    // emit any left over increment, if we hit the end\n    if (previousIncrement != null) {\n      // in any situation where we exited due to limit, previousIncrement should already be null\n      Preconditions.checkState(limit <= 0 || addedCnt < limit);\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Including leftover increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n      }\n      cells.add(newCell(previousIncrement, runningSum));\n    }\n\n    return baseScanner.hasMore();\n  }","id":43183,"modified_method":"private boolean nextInternal(List<Cell> cells, int limit) throws IOException {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"nextInternal called with limit=\" + limit);\n    }\n    Cell previousIncrement = null;\n    long runningSum = 0;\n    int addedCnt = 0;\n    baseScanner.startNext();\n    Cell cell = null;\n    while ((cell = baseScanner.peekNextCell(limit)) != null && (limit <= 0 || addedCnt < limit)) {\n      // we use the \"peek\" semantics so that only once cell is ever emitted per iteration\n      // this makes is clearer and easier to enforce that the returned results are <= limit\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Checking cell \" + cell);\n      }\n      // any cells visible to in-progress transactions must be kept unchanged\n      if (cell.getTimestamp() > compactionUpperBound) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including cell visible to in-progress, cell=\" + cell);\n        }\n        cells.add(cell);\n        addedCnt++;\n        baseScanner.nextCell(limit);\n        continue;\n      }\n\n      // compact any delta writes\n      if (IncrementHandler.isIncrement(cell)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Found increment for row=\" + Bytes.toStringBinary(CellUtil.cloneRow(cell)) + \", \" +\n              \"column=\" + Bytes.toStringBinary(CellUtil.cloneQualifier(cell)));\n        }\n        if (!sameCell(previousIncrement, cell)) {\n          if (previousIncrement != null) {\n            // if different qualifier, and prev qualifier non-null\n            // emit the previous sum\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n            }\n            cells.add(newCell(previousIncrement, runningSum));\n            previousIncrement = null;\n            addedCnt++;\n            // continue without advancing, current cell will be consumed on the next iteration\n            continue;\n          }\n          previousIncrement = cell;\n          runningSum = 0;\n        }\n        // add this increment to the tally\n        runningSum += Bytes.toLong(cell.getValueArray(),\n            cell.getValueOffset() + IncrementHandler.DELTA_MAGIC_PREFIX.length);\n      } else {\n        // otherwise (not an increment)\n        if (previousIncrement != null) {\n          if (sameCell(previousIncrement, cell) && !CellUtil.isDelete(cell)) {\n            // if qualifier matches previous and this is a long, add to running sum, emit\n            runningSum += Bytes.toLong(cell.getValueArray(), cell.getValueOffset());\n            // this cell already processed as part of the previous increment's sum, so consume it\n            baseScanner.nextCell(limit);\n          }\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Including increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n          }\n          // if this put is a different cell from the previous increment, then\n          // we only emit the previous increment, reset it, and continue.\n          // the current cell will be consumed on the next iteration, if we have not yet reached the limit\n          cells.add(newCell(previousIncrement, runningSum));\n          addedCnt++;\n          previousIncrement = null;\n          runningSum = 0;\n\n          continue;\n        }\n        // otherwise emit the current cell\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Including raw cell: \" + cell);\n        }\n\n        cells.add(cell);\n        addedCnt++;\n      }\n      // if we made it this far, consume the current cell\n      baseScanner.nextCell(limit);\n    }\n    // emit any left over increment, if we hit the end\n    if (previousIncrement != null) {\n      // in any situation where we exited due to limit, previousIncrement should already be null\n      Preconditions.checkState(limit <= 0 || addedCnt < limit);\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Including leftover increment: sum=\" + runningSum + \", cell=\" + previousIncrement);\n      }\n      cells.add(newCell(previousIncrement, runningSum));\n    }\n\n    return baseScanner.hasMore();\n  }","commit_id":"20e44cf3feb50328f2856969a4898fa3e07238f3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final ResourceBundle resourceBundle = extractResourceBundle(e);\n    assert resourceBundle != null;\n    final Project project = resourceBundle.getProject();\n    final FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);\n    fileEditorManager.closeFile(new ResourceBundleAsVirtualFile(resourceBundle));\n    for (final PropertiesFile propertiesFile : resourceBundle.getPropertiesFiles()) {\n      fileEditorManager.closeFile(propertiesFile.getVirtualFile());\n    }\n    ResourceBundleManager.getInstance(e.getProject()).dissociateResourceBundle(resourceBundle);\n    ProjectView.getInstance(project).refresh();\n  }","id":43184,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getProject();\n    if (project == null) {\n      return;\n    }\n    final Collection<ResourceBundle> resourceBundles = extractResourceBundles(e);\n    assert resourceBundles.size() > 0;\n    final FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);\n    for (ResourceBundle resourceBundle : resourceBundles) {\n      fileEditorManager.closeFile(new ResourceBundleAsVirtualFile(resourceBundle));\n      for (final PropertiesFile propertiesFile : resourceBundle.getPropertiesFiles()) {\n        fileEditorManager.closeFile(propertiesFile.getVirtualFile());\n      }\n      ResourceBundleManager.getInstance(e.getProject()).dissociateResourceBundle(resourceBundle);\n    }\n    ProjectView.getInstance(project).refresh();\n  }","commit_id":"0be64e4e88a8b3095f3d561771d35acc9aeb7271","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(final AnActionEvent e) {\n    final ResourceBundle resourceBundle = extractResourceBundle(e);\n    if (resourceBundle != null) {\n      e.getPresentation().setText(String.format(PRESENTATION_TEXT_TEMPLATE, resourceBundle.getBaseName()), false);\n      e.getPresentation().setVisible(true);\n    } else {\n      e.getPresentation().setVisible(false);\n    }\n  }","id":43185,"modified_method":"@Override\n  public void update(final AnActionEvent e) {\n    final Collection<ResourceBundle> resourceBundles = extractResourceBundles(e);\n    if (!resourceBundles.isEmpty()) {\n      if (resourceBundles.size() == 1) {\n        e.getPresentation().setText(String.format(SINGLE_RB_PRESENTATION_TEXT_TEMPLATE, ContainerUtil.getFirstItem(resourceBundles).getBaseName()), false);\n      } else {\n        e.getPresentation().setText(String.format(MULTIPLE_RB_PRESENTATION_TEXT_TEMPLATE, resourceBundles.size()), false);\n      }\n      e.getPresentation().setVisible(true);\n    } else {\n      e.getPresentation().setVisible(false);\n    }\n  }","commit_id":"0be64e4e88a8b3095f3d561771d35acc9aeb7271","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static ResourceBundle extractResourceBundle(final AnActionEvent event) {\n    final ResourceBundle[] data = event.getData(ResourceBundle.ARRAY_DATA_KEY);\n    if (data != null && data.length == 1 && data[0].getPropertiesFiles().size() > 1) {\n      return data[0];\n    }\n    final PropertiesFile propertiesFile = PropertiesImplUtil.getPropertiesFile(event.getData(PlatformDataKeys.PSI_FILE));\n    if (propertiesFile == null) {\n      return null;\n    }\n    final ResourceBundle resourceBundle = propertiesFile.getResourceBundle();\n    return resourceBundle.getPropertiesFiles().size() > 1 ? resourceBundle : null;\n  }","id":43186,"modified_method":"@NotNull\n  private static Collection<ResourceBundle> extractResourceBundles(final AnActionEvent event) {\n    final Set<ResourceBundle> targetResourceBundles = new HashSet<ResourceBundle>();\n    final ResourceBundle[] chosenResourceBundles = event.getData(ResourceBundle.ARRAY_DATA_KEY);\n    if (chosenResourceBundles != null) {\n      for (ResourceBundle resourceBundle : chosenResourceBundles) {\n        if (resourceBundle.getPropertiesFiles().size() > 1) {\n          targetResourceBundles.add(resourceBundle);\n        }\n      }\n    }\n    final PsiElement[] psiElements = event.getData(LangDataKeys.PSI_ELEMENT_ARRAY);\n    if (psiElements != null) {\n      for (PsiElement element : psiElements) {\n        if (element instanceof PsiFile) {\n          final PropertiesFile propertiesFile = PropertiesImplUtil.getPropertiesFile((PsiFile)element);\n          if (propertiesFile != null) {\n            final ResourceBundle bundle = propertiesFile.getResourceBundle();\n            if (bundle.getPropertiesFiles().size() > 1) {\n              targetResourceBundles.add(bundle);\n            }\n          }\n        }\n      }\n    }\n    return targetResourceBundles;\n  }","commit_id":"0be64e4e88a8b3095f3d561771d35acc9aeb7271","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void layoutContainer(@NotNull final Container parent) {\n      final int componentCount = parent.getComponentCount();\n      if (componentCount == 0) {\n        return;\n      }\n\n      final EditorEx history = myHistoryViewer;\n      final EditorEx input = componentCount == 2 ? myConsoleEditor : null;\n      if (input == null) {\n        parent.getComponent(0).setBounds(parent.getBounds());\n        return;\n      }\n\n      final Dimension panelSize = parent.getSize();\n      if (panelSize.getHeight() <= 0) {\n        return;\n      }\n      final Dimension historySize = history.getContentSize();\n      final Dimension inputSize = input.getContentSize();\n\n      int newInputHeight;\n      // deal with width\n      final int width = Math.max(inputSize.width, historySize.width);\n      if (isHistoryViewerForceAdditionalColumnsUsage()) {\n        history.getSoftWrapModel().forceAdditionalColumnsUsage();\n        input.getSettings().setAdditionalColumnsCount(2 + (width - inputSize.width) / EditorUtil.getSpaceWidth(Font.PLAIN, input));\n        history.getSettings().setAdditionalColumnsCount(2 + (width - historySize.width) / EditorUtil.getSpaceWidth(Font.PLAIN, history));\n      }\n\n      // deal with height, WEB-11122 we cannot trust editor width - it could be 0 in case of soft wrap even if editor has text\n      if (history.getDocument().getLineCount() == 0) {\n        historySize.height = 0;\n      }\n\n      int minHistoryHeight = historySize.height > 0 ? getMinHistoryLineCount() * history.getLineHeight() : 0;\n      int minInputHeight = input.isViewer() ? 0 : input.getLineHeight();\n      final int inputPreferredHeight = input.isViewer() ? 0 : Math.max(minInputHeight, inputSize.height);\n      final int historyPreferredHeight = Math.max(minHistoryHeight, historySize.height);\n      if (panelSize.height < minInputHeight) {\n        newInputHeight = panelSize.height;\n      }\n      else if (panelSize.height < inputPreferredHeight) {\n        newInputHeight = panelSize.height - minHistoryHeight;\n      }\n      else if (panelSize.height < (inputPreferredHeight + historyPreferredHeight) || inputPreferredHeight == 0) {\n        newInputHeight = inputPreferredHeight;\n      }\n      else {\n        newInputHeight = panelSize.height - historyPreferredHeight;\n      }\n\n      int oldHistoryHeight = history.getComponent().getHeight();\n      int newHistoryHeight = panelSize.height - newInputHeight;\n      int delta = newHistoryHeight - ((newHistoryHeight / history.getLineHeight()) * history.getLineHeight());\n      newHistoryHeight -= delta;\n      newInputHeight += delta;\n\n      // apply new bounds & scroll history viewer\n      input.getComponent().setBounds(0, newHistoryHeight, panelSize.width, newInputHeight);\n      history.getComponent().setBounds(0, 0, panelSize.width, newHistoryHeight);\n      input.getComponent().doLayout();\n      history.getComponent().doLayout();\n      if (newHistoryHeight < oldHistoryHeight) {\n        JViewport viewport = history.getScrollPane().getViewport();\n        Point position = viewport.getViewPosition();\n        position.translate(0, oldHistoryHeight - newHistoryHeight);\n        viewport.setViewPosition(position);\n      }\n    }","id":43187,"modified_method":"@Override\n    public void layoutContainer(@NotNull final Container parent) {\n      final int componentCount = parent.getComponentCount();\n      if (componentCount == 0) {\n        return;\n      }\n\n      final EditorEx history = myHistoryViewer;\n      final EditorEx input = isConsoleEditorEnabled() ? myConsoleEditor : null;\n      if (input == null) {\n        parent.getComponent(0).setBounds(parent.getBounds());\n        return;\n      }\n\n      final Dimension panelSize = parent.getSize();\n      if (myScrollBar.isVisible()) {\n        Dimension size = myScrollBar.getPreferredSize();\n        if (panelSize.height < size.height) return;\n        panelSize.height -= size.height;\n        myScrollBar.setBounds(0, panelSize.height, panelSize.width, size.height);\n      }\n      if (panelSize.getHeight() <= 0) {\n        return;\n      }\n      final Dimension historySize = history.getContentSize();\n      final Dimension inputSize = input.getContentSize();\n\n      int newInputHeight;\n      // deal with height, WEB-11122 we cannot trust editor width - it could be 0 in case of soft wrap even if editor has text\n      if (history.getDocument().getLineCount() == 0) {\n        historySize.height = 0;\n      }\n\n      int minHistoryHeight = historySize.height > 0 ? getMinHistoryLineCount() * history.getLineHeight() : 0;\n      int minInputHeight = input.isViewer() ? 0 : input.getLineHeight();\n      final int inputPreferredHeight = input.isViewer() ? 0 : Math.max(minInputHeight, inputSize.height);\n      final int historyPreferredHeight = Math.max(minHistoryHeight, historySize.height);\n      if (panelSize.height < minInputHeight) {\n        newInputHeight = panelSize.height;\n      }\n      else if (panelSize.height < inputPreferredHeight) {\n        newInputHeight = panelSize.height - minHistoryHeight;\n      }\n      else if (panelSize.height < (inputPreferredHeight + historyPreferredHeight) || inputPreferredHeight == 0) {\n        newInputHeight = inputPreferredHeight;\n      }\n      else {\n        newInputHeight = panelSize.height - historyPreferredHeight;\n      }\n\n      int oldHistoryHeight = history.getComponent().getHeight();\n      int newHistoryHeight = panelSize.height - newInputHeight;\n      int delta = newHistoryHeight - ((newHistoryHeight / history.getLineHeight()) * history.getLineHeight());\n      newHistoryHeight -= delta;\n      newInputHeight += delta;\n\n      // apply new bounds & scroll history viewer\n      input.getComponent().setBounds(0, newHistoryHeight, panelSize.width, newInputHeight);\n      history.getComponent().setBounds(0, 0, panelSize.width, newHistoryHeight);\n      input.getComponent().doLayout();\n      history.getComponent().doLayout();\n      if (newHistoryHeight < oldHistoryHeight) {\n        JViewport viewport = history.getScrollPane().getViewport();\n        Point position = viewport.getViewPosition();\n        position.translate(0, oldHistoryHeight - newHistoryHeight);\n        viewport.setViewPosition(position);\n      }\n    }","commit_id":"19de7f4a859a92b54c46725ca86d055564533d81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setupComponents() {\n    myHelper.setupEditor(myConsoleEditor);\n    myHelper.setupEditor(myHistoryViewer);\n\n    myHistoryViewer.getComponent().setMinimumSize(JBUI.emptySize());\n    myHistoryViewer.getComponent().setPreferredSize(JBUI.emptySize());\n    myHistoryViewer.setCaretEnabled(false);\n\n    myConsoleEditor.setContextMenuGroupId(IdeActions.GROUP_CONSOLE_EDITOR_POPUP);\n    myConsoleEditor.setHighlighter(\n      EditorHighlighterFactory.getInstance().createEditorHighlighter(getVirtualFile(), myConsoleEditor.getColorsScheme(), getProject()));\n\n    myConsoleEditor.getScrollPane().getHorizontalScrollBar().setModel(\n      myHistoryViewer.getScrollPane().getHorizontalScrollBar().getModel());\n    setHistoryScrollBarVisible(false);\n\n    myHistoryViewer.getContentComponent().addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyTyped(KeyEvent event) {\n        if (isConsoleEditorEnabled() && UIUtil.isReallyTypedEvent(event)) {\n          myConsoleEditor.getContentComponent().requestFocus();\n          myConsoleEditor.processKeyTyped(event);\n        }\n      }\n    });\n\n    EmptyAction.registerActionShortcuts(myHistoryViewer.getComponent(), myConsoleEditor.getComponent());\n  }","id":43188,"modified_method":"private void setupComponents() {\n    myHelper.setupEditor(myConsoleEditor);\n    myHelper.setupEditor(myHistoryViewer);\n\n    myHistoryViewer.getComponent().setMinimumSize(JBUI.emptySize());\n    myHistoryViewer.getComponent().setPreferredSize(JBUI.emptySize());\n    myHistoryViewer.setCaretEnabled(false);\n\n    myConsoleEditor.setContextMenuGroupId(IdeActions.GROUP_CONSOLE_EDITOR_POPUP);\n    myConsoleEditor.setHighlighter(\n      EditorHighlighterFactory.getInstance().createEditorHighlighter(getVirtualFile(), myConsoleEditor.getColorsScheme(), getProject()));\n\n    setHistoryScrollBarVisible(false);\n\n    myHistoryViewer.getContentComponent().addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyTyped(KeyEvent event) {\n        if (isConsoleEditorEnabled() && UIUtil.isReallyTypedEvent(event)) {\n          myConsoleEditor.getContentComponent().requestFocus();\n          myConsoleEditor.processKeyTyped(event);\n        }\n      }\n    });\n\n    EmptyAction.registerActionShortcuts(myHistoryViewer.getComponent(), myConsoleEditor.getComponent());\n  }","commit_id":"19de7f4a859a92b54c46725ca86d055564533d81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final boolean isConsoleEditorEnabled() {\n    return myPanel.getComponentCount() > 1;\n  }","id":43189,"modified_method":"public final boolean isConsoleEditorEnabled() {\n    return myConsoleEditor.getComponent().isVisible();\n  }","commit_id":"19de7f4a859a92b54c46725ca86d055564533d81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LanguageConsoleImpl(@NotNull Helper helper) {\n    super(helper.project, GlobalSearchScope.allScope(helper.project), true, true);\n    myHelper = helper;\n    EditorFactory editorFactory = EditorFactory.getInstance();\n    myEditorDocument = helper.getDocument();\n    myConsoleEditor = (EditorEx)editorFactory.createEditor(myEditorDocument, getProject());\n    myConsoleEditor.addFocusListener(myFocusListener);\n    myCurrentEditor = myConsoleEditor;\n    Document historyDocument = ((EditorFactoryImpl)editorFactory).createDocument(true);\n    UndoUtil.disableUndoFor(historyDocument);\n    myHistoryViewer = (EditorEx)editorFactory.createViewer(historyDocument, getProject());\n\n    myBusConnection = getProject().getMessageBus().connect();\n    // action shortcuts are not yet registered\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        installEditorFactoryListener();\n      }\n    }, getProject().getDisposed());\n  }","id":43190,"modified_method":"public LanguageConsoleImpl(@NotNull Helper helper) {\n    super(helper.project, GlobalSearchScope.allScope(helper.project), true, true);\n    myHelper = helper;\n    EditorFactory editorFactory = EditorFactory.getInstance();\n    myEditorDocument = helper.getDocument();\n    myConsoleEditor = (EditorEx)editorFactory.createEditor(myEditorDocument, getProject());\n    myConsoleEditor.getScrollPane().getHorizontalScrollBar().setEnabled(false);\n    myConsoleEditor.addFocusListener(myFocusListener);\n    myCurrentEditor = myConsoleEditor;\n    Document historyDocument = ((EditorFactoryImpl)editorFactory).createDocument(true);\n    UndoUtil.disableUndoFor(historyDocument);\n    myHistoryViewer = (EditorEx)editorFactory.createViewer(historyDocument, getProject());\n\n    myScrollBar.setOpaque(false);\n    myScrollBar.setModel(new MyModel(myScrollBar, myHistoryViewer, myConsoleEditor));\n    myScrollBar.putClientProperty(Alignment.class, Alignment.BOTTOM);\n\n    myBusConnection = getProject().getMessageBus().connect();\n    // action shortcuts are not yet registered\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        installEditorFactoryListener();\n      }\n    }, getProject().getDisposed());\n  }","commit_id":"19de7f4a859a92b54c46725ca86d055564533d81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initComponents() {\n    setupComponents();\n\n    myPanel.add(myHistoryViewer.getComponent());\n    myPanel.add(myConsoleEditor.getComponent());\n\n    DataManager.registerDataProvider(myPanel, this);\n    setPromptInner(myPrompt);\n  }","id":43191,"modified_method":"private void initComponents() {\n    setupComponents();\n\n    myPanel.add(myHistoryViewer.getComponent());\n    myPanel.add(myConsoleEditor.getComponent());\n    myPanel.add(myScrollBar);\n    myPanel.setBackground(myConsoleEditor.getBackgroundColor());\n\n    DataManager.registerDataProvider(myPanel, this);\n    setPromptInner(myPrompt);\n  }","commit_id":"19de7f4a859a92b54c46725ca86d055564533d81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setConsoleEditorEnabled(boolean consoleEditorEnabled) {\n    if (isConsoleEditorEnabled() == consoleEditorEnabled) {\n      return;\n    }\n\n    myPanel.removeAll();\n\n    if (consoleEditorEnabled) {\n      FileEditorManager.getInstance(getProject()).closeFile(getVirtualFile());\n\n      setHistoryScrollBarVisible(false);\n      myPanel.add(myHistoryViewer.getComponent());\n      myPanel.add(myConsoleEditor.getComponent());\n\n      myCurrentEditor = myConsoleEditor;\n    }\n    else {\n      setHistoryScrollBarVisible(true);\n      myPanel.add(myHistoryViewer.getComponent(), BorderLayout.CENTER);\n    }\n  }","id":43192,"modified_method":"public void setConsoleEditorEnabled(boolean consoleEditorEnabled) {\n    if (isConsoleEditorEnabled() == consoleEditorEnabled) {\n      return;\n    }\n    if (consoleEditorEnabled) {\n      FileEditorManager.getInstance(getProject()).closeFile(getVirtualFile());\n      myCurrentEditor = myConsoleEditor;\n    }\n    setHistoryScrollBarVisible(!consoleEditorEnabled);\n    myScrollBar.setVisible(consoleEditorEnabled);\n    myConsoleEditor.getComponent().setVisible(consoleEditorEnabled);\n  }","commit_id":"19de7f4a859a92b54c46725ca86d055564533d81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n     * Write a value to Excel, increasing data.positionX with one afterwards.\r\n     * @param v The value to write\r\n     * @param vMeta The valueMeta to write\r\n     * @param excelField the field information (if any, otherwise : null)\r\n     * @param column the excel column for getting the template format\r\n     * @param isHeader true if this is part of the header/footer\r\n     * @return\r\n     */\r\n\tprivate boolean writeField(Object v, ValueMetaInterface vMeta, ExcelField excelField, int column, boolean isHeader)\r\n\t{\r\n\r\n\t\tWritableFont writableFont = new WritableFont(WritableFont.ARIAL, 10, WritableFont.NO_BOLD);\r\n\t\ttry\r\n\t\t{\r\n            String hashName = vMeta.getName();\r\n            if (isHeader) hashName = \"____header_field____\"; // all strings, can map to the same format.\r\n            \r\n            WritableCellFormat cellFormat=(WritableCellFormat) data.formats.get(hashName);\r\n\r\n            // when template is used, take over the column format\r\n            if (cellFormat==null && meta.isTemplateEnabled() && !isHeader)\r\n            {\r\n            \ttry {\r\n            \t\tif (column<data.templateColumns)\r\n            \t\t{\r\n            \t\t    CellFormat format = data.sheet.getColumnView(column).getFormat();\r\n            \t\t    if (format!=null) {\r\n                \t\t\tcellFormat=new WritableCellFormat(format);\r\n                \t\t\tdata.formats.put(hashName, cellFormat); // save for next time around...\r\n            \t\t    }\r\n            \t\t}\r\n\t\t\t\t} catch (RuntimeException e) {\r\n\t\t\t\t\t//ignore if the column is not found, format as usual\r\n\t\t\t\t}\r\n            }\r\n            if(meta.isAutoSizeColums())\r\n            {\r\n\t            // prepare auto size colums\r\n\t            int vlen=vMeta.getName().length();\r\n\t            if(!isHeader && v!=null) vlen=v.toString().trim().length();\r\n\t        \tif(vlen>0 && vlen>data.fieldsWidth[column]) data.fieldsWidth[column]=vlen+1;\r\n            }\r\n            \r\n            switch(vMeta.getType())\r\n            {\r\n            case ValueMetaInterface.TYPE_DATE:\r\n                {\r\n                    if (v!=null && vMeta.getDate(v)!=null)\r\n                    {\r\n                        if (cellFormat==null)\r\n                        {\r\n                            if (excelField!=null && excelField.getFormat()!=null)\r\n                            {\r\n                                DateFormat dateFormat = new DateFormat(excelField.getFormat());\r\n                                cellFormat=new WritableCellFormat(dateFormat);\r\n                            }\r\n                            else\r\n                            {\r\n                                cellFormat =  new WritableCellFormat(DateFormats.FORMAT9);\r\n                            }\r\n                            data.formats.put(hashName, cellFormat); // save for next time around...\r\n                        }\r\n                        DateTime dateTime = new DateTime(data.positionX, data.positionY, vMeta.getDate(v), cellFormat);\r\n                        data.sheet.addCell(dateTime);\r\n                    }\r\n                    else if (!meta.isNullBlank())\r\n                    {\r\n                        data.sheet.addCell(new Label(data.positionX, data.positionY, \"\"));\r\n                    }\r\n                }\r\n                break;\r\n            case ValueMetaInterface.TYPE_STRING:\r\n            case ValueMetaInterface.TYPE_BOOLEAN:\r\n            case ValueMetaInterface.TYPE_BINARY:\r\n                {\r\n                    if (v!=null)\r\n                    {\r\n                        if (cellFormat==null)\r\n                        {\r\n                            cellFormat = new WritableCellFormat(writableFont);\r\n                            data.formats.put(hashName, cellFormat);\r\n                        }\r\n                        Label label = new Label(data.positionX, data.positionY, vMeta.getString(v), cellFormat);\r\n                        data.sheet.addCell(label);\r\n                    }\r\n                    else if (!meta.isNullBlank())\r\n                    {\r\n                        data.sheet.addCell(new Label(data.positionX, data.positionY, \"\"));\r\n                    }\r\n                }\r\n                break;\r\n            case ValueMetaInterface.TYPE_NUMBER:\r\n            case ValueMetaInterface.TYPE_BIGNUMBER:\r\n            case ValueMetaInterface.TYPE_INTEGER:\r\n                {\r\n\t                if (v!=null)\r\n\t                {\r\n\t\t            \tif (cellFormat==null)\r\n\t                    {\r\n\t                        String format;\r\n\t                        if (excelField!=null && excelField.getFormat()!=null)\r\n\t                        {\r\n\t                            format=excelField.getFormat();\r\n\t                        }\r\n\t                        else\r\n\t                        {\r\n\t                            format = \"###,###.00\";\r\n\t                        }\r\n\t                        NumberFormat numberFormat = new NumberFormat(format);\r\n\t                        cellFormat = new WritableCellFormat(numberFormat);\r\n\t                        data.formats.put(vMeta.getName(), cellFormat); // save for next time around...\r\n\t                    }\r\n\t                    jxl.write.Number number = new jxl.write.Number(data.positionX, data.positionY, vMeta.getNumber(v), cellFormat);\r\n\t                    data.sheet.addCell(number);\r\n\t                }\r\n\t                else if (!meta.isNullBlank())\r\n\t                {\r\n\t                    data.sheet.addCell(new Label(data.positionX, data.positionY, \"\"));\r\n\t                }\r\n                }\r\n                break;\r\n            default: break;\r\n            }\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing field (\"+data.positionX+\",\"+data.positionY+\") : \"+e.toString());\r\n            logError(Const.getStackTracker(e));\r\n\t\t\treturn false;\r\n\t\t}\r\n        finally\r\n        {\r\n            data.positionX++; // always advance :-)\r\n        }\r\n\t\treturn true;\r\n\t}","id":43193,"modified_method":"/**\r\n     * Write a value to Excel, increasing data.positionX with one afterwards.\r\n     * @param v The value to write\r\n     * @param vMeta The valueMeta to write\r\n     * @param excelField the field information (if any, otherwise : null)\r\n     * @param column the excel column for getting the template format\r\n     * @param isHeader true if this is part of the header/footer\r\n     * @return\r\n     */\r\n\tprivate boolean writeField(Object v, ValueMetaInterface vMeta, ExcelField excelField, int column, boolean isHeader)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n            String hashName = vMeta.getName();\r\n            if (isHeader) hashName = \"____header_field____\"; // all strings, can map to the same format.\r\n            \r\n            WritableCellFormat cellFormat=(WritableCellFormat) data.formats.get(hashName);\r\n\r\n            // when template is used, take over the column format\r\n            if (cellFormat==null && meta.isTemplateEnabled() && !isHeader)\r\n            {\r\n            \ttry {\r\n            \t\tif (column<data.templateColumns)\r\n            \t\t{\r\n            \t\t    CellFormat format = data.sheet.getColumnView(column).getFormat();\r\n            \t\t    if (format!=null) {\r\n                \t\t\tcellFormat=new WritableCellFormat(format);\r\n                \t\t\tdata.formats.put(hashName, cellFormat); // save for next time around...\r\n            \t\t    }\r\n            \t\t}\r\n\t\t\t\t} catch (RuntimeException e) {\r\n\t\t\t\t\t//ignore if the column is not found, format as usual\r\n\t\t\t\t}\r\n            }\r\n            if(meta.isAutoSizeColums())\r\n            {\r\n\t            // prepare auto size colums\r\n\t            int vlen=vMeta.getName().length();\r\n\t            if(!isHeader && v!=null) vlen=v.toString().trim().length();\r\n\t        \tif(vlen>0 && vlen>data.fieldsWidth[column]) data.fieldsWidth[column]=vlen+1;\r\n            }\r\n            \r\n            // Do we need to use a specific format to header?\r\n            if(isHeader)// && cellFormat==null)  \r\n            {\r\n            \t// Set font for header and footer+\r\n            \tdata.sheet.addCell(new Label(data.positionX, data.positionY, vMeta.getName(),data.headerCellFormat));\r\n            \tif(cellFormat==null) data.formats.put(hashName, data.headerCellFormat);  // save for next time around...\r\n            }\r\n           else\r\n           {\r\n\t            switch(vMeta.getType())\r\n\t            {\r\n\t            case ValueMetaInterface.TYPE_DATE:\r\n\t                {\r\n\t                    if (v!=null && vMeta.getDate(v)!=null)\r\n\t                    {\r\n\t                        if (cellFormat==null)\r\n\t                        {\r\n\t                            if (excelField!=null && excelField.getFormat()!=null)\r\n\t                            {\r\n\t                                DateFormat dateFormat = new DateFormat(excelField.getFormat());\r\n\r\n\t                            \tif(data.writableFont!=null)\r\n\t                            \t{\r\n\t                            \t\tcellFormat = new WritableCellFormat(data.writableFont,dateFormat);\r\n\t                            \t\tif(data.rowFontBackgoundColour!=null) cellFormat.setBackground(data.rowFontBackgoundColour);\r\n\t                            \t}\r\n\t                            \telse\r\n\t                            \t\tcellFormat=new WritableCellFormat(dateFormat);   \r\n\t                            }\r\n\t                            else\r\n\t                            {\r\n\t                                if(data.writableFont!=null)\r\n\t                            \t{\r\n\t                            \t\tcellFormat = new WritableCellFormat(data.writableFont,DateFormats.FORMAT9);\r\n\t                            \t\tif(data.rowFontBackgoundColour!=null) cellFormat.setBackground(data.rowFontBackgoundColour);\r\n\t                            \t}\r\n\t                            \telse\r\n\t                            \t\tcellFormat =  new WritableCellFormat(DateFormats.FORMAT9);\r\n\t                            }\r\n\t                            data.formats.put(hashName, cellFormat); // save for next time around...\r\n\t                        }\r\n\t                        DateTime dateTime = new DateTime(data.positionX, data.positionY, vMeta.getDate(v), cellFormat);\r\n\t                        data.sheet.addCell(dateTime);\r\n\t                    }\r\n\t                    else if (!meta.isNullBlank())\r\n\t                    {\r\n\t                        data.sheet.addCell(new Label(data.positionX, data.positionY, \"\"));\r\n\t                    }\r\n\t                }\r\n\t                break;\r\n\t            case ValueMetaInterface.TYPE_STRING:\r\n\t            case ValueMetaInterface.TYPE_BOOLEAN:\r\n\t            case ValueMetaInterface.TYPE_BINARY:\r\n\t                {\r\n                        if (cellFormat==null)\r\n                        {\t                            \r\n                            cellFormat = new WritableCellFormat(data.writableFont);\r\n                            if(data.rowFontBackgoundColour!=null) cellFormat.setBackground(data.rowFontBackgoundColour);\r\n                            data.formats.put(hashName, cellFormat);  \r\n                        }\r\n\t                    if (v!=null)\r\n\t                    {\r\n\t                        Label label = new Label(data.positionX, data.positionY, vMeta.getString(v), cellFormat);\r\n\t                        data.sheet.addCell(label);\r\n\t                    }\r\n\t                    else if (!meta.isNullBlank())\r\n\t                    {\r\n\t                        data.sheet.addCell(new Label(data.positionX, data.positionY, \"\"));\r\n\t                    }\r\n\t                }\r\n\t                break;\r\n\t            case ValueMetaInterface.TYPE_NUMBER:\r\n\t            case ValueMetaInterface.TYPE_BIGNUMBER:\r\n\t            case ValueMetaInterface.TYPE_INTEGER:\r\n\t                {\r\n\t\t                if (v!=null)\r\n\t\t                {\r\n\t\t\t            \tif (cellFormat==null)\r\n\t\t                    {\r\n\t\t                        String format;\r\n\t\t                        if (excelField!=null && excelField.getFormat()!=null)\r\n\t\t                        {\r\n\t\t                            format=excelField.getFormat();\r\n\t\t                        }\r\n\t\t                        else\r\n\t\t                        {\r\n\t\t                            format = \"###,###.00\";\r\n\t\t                        }\r\n\t\t                        NumberFormat numberFormat = new NumberFormat(format);\r\n\r\n\t\t                        if(data.writableFont!=null)\r\n\t\t                        {\r\n\t\t                        \tcellFormat = new WritableCellFormat(data.writableFont,numberFormat);\r\n\t\t                        \tif(data.rowFontBackgoundColour!=null) cellFormat.setBackground(data.rowFontBackgoundColour);\r\n\t\t                        }\r\n\t\t                        else\r\n\t\t                        \tcellFormat = new WritableCellFormat(numberFormat);\r\n\t\t                        \r\n\t\t                        data.formats.put(vMeta.getName(), cellFormat); // save for next time around...\r\n\t\t                    }\r\n\t\t                    jxl.write.Number number = new jxl.write.Number(data.positionX, data.positionY, vMeta.getNumber(v), cellFormat);\r\n\t\t                    data.sheet.addCell(number);\r\n\t\t                }\r\n\t\t                else if (!meta.isNullBlank())\r\n\t\t                {\r\n\t\t                    data.sheet.addCell(new Label(data.positionX, data.positionY, \"\"));\r\n\t\t                }\r\n\t                }\r\n\t                break;\r\n\t            default: break;\r\n\t            }\r\n           }\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing field (\"+data.positionX+\",\"+data.positionY+\") : \"+e.toString());\r\n            logError(Const.getStackTracker(e));\r\n\t\t\treturn false;\r\n\t\t}\r\n        finally\r\n        {\r\n            data.positionX++; // always advance :-)\r\n        }\r\n\t\treturn true;\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean closeFile()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tString filename=null;\r\n\t\ttry\r\n\t\t{\r\n\t\t\tif (meta.isFooterEnabled())\r\n\t\t\t{\r\n\t\t\t\twriteHeader();\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.workbook != null )\r\n\t\t\t{\r\n\t\t\t\tif(data.fieldsWidth!=null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(meta.isAutoSizeColums())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// auto resize columns\r\n\t\t\t\t\t\tint nrfields=data.fieldsWidth.length;\r\n\t\t\t\t\t\tfor(int i=0;i<nrfields;i++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdata.sheet.setColumnView(i,data.fieldsWidth[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata.fieldsWidth=null;\r\n\t\t\t\t}\r\n\t\t\t    data.workbook.write();\r\n                data.workbook.close();\r\n                data.workbook = null;\r\n                if(data.outputStream!=null) \r\n                {\t\r\n                \tdata.outputStream.close();\r\n                \tdata.outputStream=null;\r\n                }\r\n                \r\n                if (data.sheet!=null) {\r\n                \tdata.sheet = null;\r\n                }\r\n                if(data.file!=null)\r\n                {\r\n                \tfilename=data.file.toString();\r\n                \tdata.file.close();\r\n                \tdata.file=null;\r\n                }\r\n               \r\n\t\t\t}\r\n            //data.formats.clear();\r\n\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"ExcelOutput.Log.FileClosed\",filename));\r\n            \r\n\t\t\tretval=true;\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n            logError(\"Unable to close openFile file : \" + data.file.toString(), e);\r\n\t\t\tsetErrors(1);\r\n\t\t}\r\n\r\n\t\treturn retval;\r\n\t}","id":43194,"modified_method":"private boolean closeFile()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tString filename=null;\r\n\t\ttry\r\n\t\t{\r\n\t\t\tif (meta.isFooterEnabled())\r\n\t\t\t{\r\n\t\t\t\twriteHeader();\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.workbook != null )\r\n\t\t\t{\r\n\t\t\t\tif(data.fieldsWidth!=null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(meta.isAutoSizeColums())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// auto resize columns\r\n\t\t\t\t\t\tint nrfields=data.fieldsWidth.length;\r\n\t\t\t\t\t\tfor(int i=0;i<nrfields;i++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdata.sheet.setColumnView(i,data.fieldsWidth[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata.fieldsWidth=null;\r\n\t\t\t\t}\r\n\t\t\t    data.workbook.write();\r\n                data.workbook.close();\r\n                data.workbook = null;\r\n                if(data.outputStream!=null) \r\n                {\t\r\n                \tdata.outputStream.close();\r\n                \tdata.outputStream=null;\r\n                }\r\n                \r\n                if (data.sheet!=null) {\r\n                \tdata.sheet = null;\r\n                }\r\n                if(data.file!=null)\r\n                {\r\n                \tfilename=data.file.toString();\r\n                \tdata.file.close();\r\n                \tdata.file=null;\r\n                }\r\n               \r\n\t\t\t}\r\n            //data.formats.clear();\r\n\t\t\tif(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"ExcelOutput.Log.FileClosed\",filename));\r\n            \r\n\t\t\tretval=true;\r\n\t\t\tdata.oneFileOpened=false;\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n            logError(\"Unable to close openFile file : \" + data.file.toString(), e);\r\n\t\t\tsetErrors(1);\r\n\t\t}\r\n\r\n\t\treturn retval;\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(ExcelOutputMeta)smi;\r\n\t\tdata=(ExcelOutputData)sdi;\r\n\r\n\t\tObject[] r=getRow();       // This also waits for a row to be finished.\r\n\t\tif (first && r != null) {\r\n\t\t\t// get the RowMeta, rowMeta is only set when a row is read\r\n\t\t\tdata.previousMeta = getInputRowMeta().clone();\r\n\t\t\t//do not set first=false, below is another part that uses first\r\n\t\t\t\r\n\t\t\tif (meta.isAutoSizeColums())\r\n\t\t\t{\r\n\t\t\t\tif(meta.getOutputFields()!=null && meta.getOutputFields().length>0)\r\n\t\t\t\t\tdata.fieldsWidth = new int[meta.getOutputFields().length];\r\n\t\t\t\telse\r\n\t\t\t\t\tdata.fieldsWidth = new int[data.previousMeta.size()];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(meta.isDoNotOpenNewFileInit())\r\n\t\t\t{\r\n\t\t\t\t data.oneFileOpened=true;\r\n\t\t\t\r\n                 addFilenameToResult();\r\n\r\n\t\t         if (!openNewFile())\r\n\t\t\t\t {\r\n\t\t\t\t\t logError(\"Couldn't open file \"+buildFilename());\r\n\t\t\t\t\t return false;\r\n\t\t\t\t }\r\n\t\t          // If we need to write a header, do so...\r\n\t\t          //\r\n\t\t         if(meta.isHeaderEnabled() && !data.headerWrote)\r\n\t\t\t\t {\r\n\t\t        \t writeHeader();\r\n\t\t        \t data.headerWrote=true;\r\n\t\t\t\t }\r\n\t\t\t}else\r\n\t\t\t{\r\n\t\t\t\t  // If we need to write a header, do so...\r\n\t\t          //\r\n\t\t         if(meta.isHeaderEnabled() && !data.headerWrote)\r\n\t\t\t\t {\r\n\t\t        \t writeHeader();\r\n\t\t        \t data.headerWrote=true;\r\n\t\t\t\t }\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// If we split the data stream in small XLS files, we need to do this here...\r\n\t\t//\r\n\t\tif ( r!=null && getLinesOutput()>0 && meta.getSplitEvery()>0 && ((getLinesOutput()+1)%meta.getSplitEvery())==0)\r\n\t\t{\r\n\t\t\t// Not finished: open another file...\r\n\t\t\tif (r!=null)\r\n\t\t\t{\r\n\t\t\t\tcloseFile();\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file (split #\"+data.splitnr+\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t          // If we need to write a header, do so...\r\n\t\t          //\r\n\t\t         if(meta.isHeaderEnabled() && !data.headerWrote)\r\n\t\t\t\t {\r\n\t\t        \t writeHeader();\r\n\t\t        \t data.headerWrote=true;\r\n\t\t\t\t }\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tboolean result=writeRowToFile(r);\r\n\t\tif (!result)\r\n\t\t{\r\n\t\t\tsetErrors(1);\r\n\t\t\tstopAll();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tputRow(data.previousMeta, r);       // in case we want it to go further...\r\n\t\t\r\n        if (checkFeedback(getLinesOutput())) \r\n        {\r\n        \tif(log.isBasic()) logBasic(\"linenr \"+getLinesOutput());\r\n        }\r\n\t\t\r\n\t\treturn result;\r\n\t}","id":43195,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(ExcelOutputMeta)smi;\r\n\t\tdata=(ExcelOutputData)sdi;\r\n\r\n\t\tObject[] r=getRow();       // This also waits for a row to be finished.\r\n\t\tif (first && r != null) {\r\n\t\t\t// get the RowMeta, rowMeta is only set when a row is read\r\n\t\t\tdata.previousMeta = getInputRowMeta().clone();\r\n\t\t\t//do not set first=false, below is another part that uses first\r\n\t\t\t\r\n\t\t\tif (meta.isAutoSizeColums())\r\n\t\t\t{\r\n\t\t\t\tif(meta.getOutputFields()!=null && meta.getOutputFields().length>0)\r\n\t\t\t\t\tdata.fieldsWidth = new int[meta.getOutputFields().length];\r\n\t\t\t\telse\r\n\t\t\t\t\tdata.fieldsWidth = new int[data.previousMeta.size()];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(meta.isDoNotOpenNewFileInit())\r\n\t\t\t{\r\n\t\t\t\t data.oneFileOpened=true;\r\n\r\n\t\t         if (!openNewFile())\r\n\t\t\t\t {\r\n\t\t\t\t\t logError(\"Couldn't open file \"+buildFilename());\r\n\t\t\t\t\t return false;\r\n\t\t\t\t }\r\n\t\t          // If we need to write a header, do so...\r\n\t\t          //\r\n\t\t         if(meta.isHeaderEnabled() && !data.headerWrote)\r\n\t\t\t\t {\r\n\t\t        \t writeHeader();\r\n\t\t        \t data.headerWrote=true;\r\n\t\t\t\t }\r\n\t\t\t}else\r\n\t\t\t{\r\n\t\t\t\t  // If we need to write a header, do so...\r\n\t\t          //\r\n\t\t         if(meta.isHeaderEnabled() && !data.headerWrote)\r\n\t\t\t\t {\r\n\t\t        \t writeHeader();\r\n\t\t        \t data.headerWrote=true;\r\n\t\t\t\t }\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If we split the data stream in small XLS files, we need to do this here...\r\n\t\t//\r\n\t\tif ((getLinesOutput()>0 && meta.getSplitEvery()>0 && ((getLinesOutput())%meta.getSplitEvery())==0))\r\n\t\t{\r\n\t\t\t// Not finished: open another file...\r\n\t\t\tif (r!=null)\r\n\t\t\t{\r\n\t\t\t\tif(data.oneFileOpened) closeFile();\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file (split #\"+data.splitnr+\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t          // If we need to write a header, do so...\r\n\t\t          //\r\n\t\t         if(meta.isHeaderEnabled() && !data.headerWrote)\r\n\t\t\t\t {\r\n\t\t        \t writeHeader();\r\n\t\t        \t data.headerWrote=true;\r\n\t\t\t\t }\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tboolean result=writeRowToFile(r);\r\n\t\tif (!result)\r\n\t\t{\r\n\t\t\tsetErrors(1);\r\n\t\t\tstopAll();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tputRow(data.previousMeta, r);       // in case we want it to go further...\r\n\t\t\r\n        if (checkFeedback(getLinesOutput())) \r\n        {\r\n        \tif(log.isBasic()) logBasic(\"linenr \"+getLinesOutput());\r\n        }\r\n\t\t\r\n\t\treturn result;\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean writeHeader()\r\n\t{\r\n        boolean retval=false;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// If we have fields specified: list them in this order!\r\n\t\t\tif (meta.getOutputFields()!=null && meta.getOutputFields().length>0)\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n                    String fieldName = meta.getOutputFields()[i].getName();\r\n                    ValueMetaInterface vMeta=new ValueMeta(fieldName, ValueMetaInterface.TYPE_STRING);\r\n                    writeField(fieldName, vMeta, null, i, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif (data.previousMeta!=null)  // Just put all field names in the header/footer\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<data.previousMeta.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tString fieldName = data.previousMeta.getFieldNames()[i];\r\n\t\t\t\t\tValueMetaInterface vMeta=new ValueMeta(fieldName, ValueMetaInterface.TYPE_STRING);\r\n                    writeField(fieldName, vMeta, null, i, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing header line: \"+e.toString());\r\n\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\tretval=true;\r\n\t\t}\r\n        finally\r\n        {\r\n            data.positionX=0;\r\n            data.positionY++;\r\n        }\r\n        incrementLinesOutput();\r\n\t\treturn retval;\r\n\t}","id":43196,"modified_method":"private boolean writeHeader()\r\n\t{\r\n        boolean retval=false;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// If we have fields specified: list them in this order!\r\n\t\t\tif (meta.getOutputFields()!=null && meta.getOutputFields().length>0)\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n                    String fieldName = meta.getOutputFields()[i].getName();\r\n                    ValueMetaInterface vMeta=new ValueMeta(fieldName, ValueMetaInterface.TYPE_STRING);\r\n                    writeField(fieldName, vMeta, null, i, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (data.previousMeta!=null)  // Just put all field names in the header/footer\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int i=0;i<data.previousMeta.size();i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tString fieldName = data.previousMeta.getFieldNames()[i];\r\n\t\t\t\t\t\tValueMetaInterface vMeta=new ValueMeta(fieldName, ValueMetaInterface.TYPE_STRING);\r\n\t                    writeField(fieldName, vMeta, null, i, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing header line: \"+e.toString());\r\n\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\tretval=true;\r\n\t\t}\r\n        finally\r\n        {\r\n            data.positionX=0;\r\n            data.positionY++;\r\n        }\r\n\r\n\t\treturn retval;\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void dispose(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(ExcelOutputMeta)smi;\r\n\t\tdata=(ExcelOutputData)sdi;\r\n\r\n\t\tif(data.oneFileOpened) closeFile();\r\n        if(data.file!=null)\r\n        {\r\n        \ttry{\r\n        \t\tdata.file.close();\r\n        \t\tdata.file=null;\r\n        \t}catch(Exception e){}\r\n        }\r\n        super.dispose(smi, sdi);\r\n\t}","id":43197,"modified_method":"public void dispose(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(ExcelOutputMeta)smi;\r\n\t\tdata=(ExcelOutputData)sdi;\r\n\r\n\t\tif(data.oneFileOpened) closeFile();\r\n        if(data.file!=null)\r\n        {\r\n        \ttry{\r\n        \t\tdata.file.close();\r\n        \t\tdata.file=null;\r\n        \t}catch(Exception e){}\r\n        }\r\n        data.fieldsWidth=null;\r\n        data.headerImage=null;\r\n        data.writableFont=null;\r\n        data.ws=null;\r\n        super.dispose(smi, sdi);\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(ExcelOutputMeta)smi;\r\n\t\tdata=(ExcelOutputData)sdi;\r\n\r\n\t\tif (super.init(smi, sdi))\r\n\t\t{\r\n\t\t\tdata.splitnr=0;\r\n\t\t\tdata.realSheetname=environmentSubstitute(meta.getSheetname());\r\n\t\t\t\r\n\t\t\t// See if we need to add the filename to the result.\r\n\t\t\t// If the file doesn't exist we report the problem.\r\n\t\t\t//\r\n\t\t\tif (!addFilenameToResult()) {\r\n\t\t\t  return false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(!meta.isDoNotOpenNewFileInit())\r\n\t\t\t{\r\n\t\t\t\tdata.oneFileOpened=true;\r\n\t\t\t\t\r\n\t\t\t\taddFilenameToResult();\r\n\t\t\t\t\r\n\t\t\t\tif (openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Couldn't open file \"+meta.getFileName());\r\n\t\t\t\t\tsetErrors(1L);\r\n\t\t\t\t\tstopAll();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}else\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":43198,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(ExcelOutputMeta)smi;\r\n\t\tdata=(ExcelOutputData)sdi;\r\n\r\n\t\tif (super.init(smi, sdi))\r\n\t\t{\r\n\t\t\tdata.splitnr=0;\r\n\t\t\tdata.realSheetname=environmentSubstitute(meta.getSheetname());\r\n\t\t\t\r\n\t        data.ws = new WorkbookSettings();\r\n            data.ws.setLocale(Locale.getDefault());\r\n            data.Headerrowheight=Const.toInt(environmentSubstitute(meta.getHeaderRowHeight()),-1);\r\n            data.realHeaderImage=environmentSubstitute(meta.getHeaderImage());\r\n            if (!Const.isEmpty(meta.getEncoding()))  data.ws.setEncoding(meta.getEncoding());\r\n\t\t\t\r\n            try {\r\n\t\t\t\t setFonts();\r\n\t         } catch(Exception we) {\r\n\t             logError(\"Erreur preparing fonts, colors for header and rows: \"+we.toString());\r\n\t             return false;\r\n\t         }\r\n  \r\n\t\t\tif(!meta.isDoNotOpenNewFileInit())\r\n\t\t\t{\r\n\t\t\t\tdata.oneFileOpened=true;\r\n\t\t\t\t\r\n\t\t\t\taddFilenameToResult();\r\n\t\t\t\t\r\n\t\t\t\tif (openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Couldn't open file \"+meta.getFileName());\r\n\t\t\t\t\tsetErrors(1L);\r\n\t\t\t\t\tstopAll();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}else\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean openNewFile()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t   if(meta.isCreateParentFolder()) {\r\n            \tif(!createParentFolder(data.file)) return retval;\r\n            }\r\n\t\t   \r\n\t\t\tWorkbookSettings ws = new WorkbookSettings();\r\n            ws.setLocale(Locale.getDefault());\r\n            \r\n            if (!Const.isEmpty(meta.getEncoding()))\r\n            {\r\n                ws.setEncoding(meta.getEncoding());\r\n            }\r\n            \r\n            if(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"ExcelOutput.Log.OpeningFile\", data.file.toString()));\r\n            \r\n            // Create the workbook\r\n            if (!meta.isTemplateEnabled())\r\n            {\t\t\t\t\r\n            \tFile fle = new File(KettleVFS.getFilename(data.file));\r\n               \tif(meta.isAppend() && fle.exists())\r\n            \t{ \r\n            \t\tWorkbook workbook = Workbook.getWorkbook(fle);\r\n                    data.workbook =Workbook.createWorkbook(fle,workbook);\r\n                    if(workbook!=null) workbook.close();\r\n                    \r\n                    if(data.workbook.getSheet(data.realSheetname)!=null) \r\n                    {    \r\n\t            \t\t// get available sheets\r\n\t            \t\tString listSheets[]=data.workbook.getSheetNames();\r\n\t            \r\n\t            \t\t// Let's see if this sheet already exist...\r\n\t            \t\tfor (int i=0;i<listSheets.length;i++) \r\n\t            \t\t{\r\n\t            \t\t\tif(listSheets[i].equals(data.realSheetname))\r\n\t            \t\t\t{\r\n\t                \t\t\t// let's remove sheet\r\n\t                \t\t\tdata.workbook.removeSheet(i);\r\n\t            \t\t\t}\t\r\n\t            \t\t}\r\n                    }\r\n                \t// and now .. we create the sheet\r\n                \tdata.sheet = data.workbook.createSheet(data.realSheetname,data.workbook.getNumberOfSheets());\r\n            \t}else{\r\n            \t\t// Create a new Workbook\r\n    \t\t\t\tdata.outputStream = KettleVFS.getOutputStream(data.file, false);\r\n\t\t\t\t\tdata.workbook = Workbook.createWorkbook(data.outputStream, ws);\r\n    \t\t\t\t\r\n    \t\t\t\t// Create a sheet?\r\n    \t\t\t\tString sheetname = \"Sheet1\";\r\n                \tdata.sheet = data.workbook.getSheet(sheetname);\r\n                \tif (data.sheet==null)\r\n                \t{\r\n                \t\tdata.sheet = data.workbook.createSheet(sheetname, 0);\r\n                \t} \r\n            \t}\r\n            } else {\r\n\r\n            \tFileObject fo = KettleVFS.getFileObject(environmentSubstitute(meta.getTemplateFileName()), getTransMeta());\r\n\t\t\t\t// create the openFile from the template\r\n\r\n\t\t\t\tWorkbook tmpWorkbook=Workbook.getWorkbook(KettleVFS.getInputStream(fo), ws);\r\n\t\t\t\tdata.outputStream = KettleVFS.getOutputStream(data.file,false);\r\n\t\t\t\tdata.workbook = Workbook.createWorkbook(data.outputStream, tmpWorkbook);\r\n\t\t\t\t\r\n            \ttmpWorkbook.close();\r\n            \tfo.close();\r\n            \t// use only the first sheet as template\r\n            \tdata.sheet = data.workbook.getSheet(0);\r\n            \t// save initial number of columns\r\n            \tdata.templateColumns = data.sheet.getColumns();\r\n            }\r\n\t\t\t\r\n            // Rename Sheet\r\n\t\t\tif (!Const.isEmpty(data.realSheetname)) \r\n\t\t\t{\r\n\t\t\t\tdata.sheet.setName(data.realSheetname); \r\n\t\t\t}\r\n\r\n\t\t\tif (meta.isSheetProtected())\r\n\t\t\t{\r\n\t\t\t\t// Protect Sheet by setting password\r\n\t\t\t\tdata.sheet.getSettings().setProtected(true); \r\n\t\t\t\tdata.sheet.getSettings().setPassword(environmentSubstitute(meta.getPassword()));\r\n\t\t\t}\r\n            \r\n\r\n            // Set the initial position...\r\n            \r\n            data.positionX = 0;\r\n            if (meta.isTemplateEnabled() && meta.isTemplateAppend())\r\n            {\r\n            \tdata.positionY = data.sheet.getRows();\r\n            } else {\r\n            \tdata.positionY = 0;\r\n            }\r\n            \r\n            data.headerWrote=false;\r\n            \r\n            if(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"ExcelOutput.Log.FileOpened\", data.file.toString()));\r\n\t\t\tretval=true;\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error opening new file\", e);\r\n\t\t\tsetErrors(1);\r\n\t\t}\r\n\t\t// System.out.println(\"end of newFile(), splitnr=\"+splitnr);\r\n\r\n\t\tdata.splitnr++;\r\n\r\n\t\treturn retval;\r\n\t}","id":43199,"modified_method":"public boolean openNewFile()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t   if(meta.isCreateParentFolder()) {\r\n            \tif(!createParentFolder(data.file)) return retval;\r\n            }\r\n\t\t   \r\n            \r\n\t\t\t// Static filename\r\n\t\t\tdata.realFilename=buildFilename();\r\n\t\t    data.file = KettleVFS.getFileObject(data.realFilename, getTransMeta());\r\n\t\t\tif(meta.isCreateParentFolder()) {\r\n\t           \tif(!createParentFolder(data.file)) return retval;\r\n\t        }\r\n\t\t    data.realFilename=KettleVFS.getFilename(data.file);\r\n\t\t\t\r\n            addFilenameToResult();\r\n            \r\n            if(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"ExcelOutput.Log.OpeningFile\", data.realFilename));\r\n            \r\n            // Create the workbook\r\n            if (!meta.isTemplateEnabled())\r\n            {\t\t\t\t\r\n            \tFile fle = new File(KettleVFS.getFilename(data.file));\r\n               \tif(meta.isAppend() && fle.exists())\r\n            \t{ \r\n            \t\tWorkbook workbook = Workbook.getWorkbook(fle);\r\n                    data.workbook =Workbook.createWorkbook(fle,workbook);\r\n                    if(workbook!=null) workbook.close();\r\n                    \r\n                    if(data.workbook.getSheet(data.realSheetname)!=null) \r\n                    {    \r\n\t            \t\t// get available sheets\r\n\t            \t\tString listSheets[]=data.workbook.getSheetNames();\r\n\t            \r\n\t            \t\t// Let's see if this sheet already exist...\r\n\t            \t\tfor (int i=0;i<listSheets.length;i++) \r\n\t            \t\t{\r\n\t            \t\t\tif(listSheets[i].equals(data.realSheetname))\r\n\t            \t\t\t{\r\n\t                \t\t\t// let's remove sheet\r\n\t                \t\t\tdata.workbook.removeSheet(i);\r\n\t            \t\t\t}\t\r\n\t            \t\t}\r\n                    }\r\n                \t// and now .. we create the sheet\r\n                \tdata.sheet = data.workbook.createSheet(data.realSheetname,data.workbook.getNumberOfSheets());\r\n            \t}else{\r\n            \t\t// Create a new Workbook\r\n    \t\t\t\tdata.outputStream = KettleVFS.getOutputStream(data.file, false);\r\n\t\t\t\t\tdata.workbook = Workbook.createWorkbook(data.outputStream, data.ws);\r\n    \t\t\t\t\r\n    \t\t\t\t// Create a sheet?\r\n    \t\t\t\tString sheetname = \"Sheet1\";\r\n                \tdata.sheet = data.workbook.getSheet(sheetname);\r\n                \tif (data.sheet==null)\r\n                \t{\r\n                \t\tdata.sheet = data.workbook.createSheet(sheetname, 0);\r\n                \t} \r\n            \t}\r\n            } else {\r\n\r\n            \tFileObject fo = KettleVFS.getFileObject(environmentSubstitute(meta.getTemplateFileName()), getTransMeta());\r\n\t\t\t\t// create the openFile from the template\r\n\r\n\t\t\t\tWorkbook tmpWorkbook=Workbook.getWorkbook(KettleVFS.getInputStream(fo), data.ws);\r\n\t\t\t\tdata.outputStream = KettleVFS.getOutputStream(data.file,false);\r\n\t\t\t\tdata.workbook = Workbook.createWorkbook(data.outputStream, tmpWorkbook);\r\n\t\t\t\t\r\n            \ttmpWorkbook.close();\r\n            \tfo.close();\r\n            \t// use only the first sheet as template\r\n            \tdata.sheet = data.workbook.getSheet(0);\r\n            \t// save initial number of columns\r\n            \tdata.templateColumns = data.sheet.getColumns();\r\n            }\r\n\t\t\t\r\n            // Rename Sheet\r\n\t\t\tif (!Const.isEmpty(data.realSheetname)) \r\n\t\t\t{\r\n\t\t\t\tdata.sheet.setName(data.realSheetname); \r\n\t\t\t}\r\n\r\n\t\t\tif (meta.isSheetProtected())\r\n\t\t\t{\r\n\t\t\t\t// Protect Sheet by setting password\r\n\t\t\t\tdata.sheet.getSettings().setProtected(true); \r\n\t\t\t\tdata.sheet.getSettings().setPassword(environmentSubstitute(meta.getPassword()));\r\n\t\t\t}\r\n            \r\n\r\n            // Set the initial position...\r\n            \r\n            data.positionX = 0;\r\n            if (meta.isTemplateEnabled() && meta.isTemplateAppend()) {\r\n            \tdata.positionY = data.sheet.getRows();\r\n            } else {\r\n            \tdata.positionY = 0;\r\n            }\r\n            \r\n\r\n            if(data.headerImage!=null) {\r\n\t            // Put an image (LEFT TOP Corner)\r\n\t            data.sheet.addImage(data.headerImage);\r\n\t            data.positionY+=Math.round(data.headerImageHeight);\r\n            }\r\n            \r\n            \r\n            // Sets the height of the specified row, as well as its collapse status\r\n            // height the row height in characters\r\n            if(data.Headerrowheight>0 && data.Headerrowheight!=ExcelOutputMeta.DEFAULT_ROW_HEIGHT) \r\n            \tdata.sheet.setRowView(data.positionY,data.Headerrowheight);\r\n\r\n            \r\n            \r\n            data.headerWrote=false;\r\n    \t\tdata.splitnr++;\r\n    \t\tdata.oneFileOpened=true;\r\n            if(log.isDebug()) logDebug(BaseMessages.getString(PKG, \"ExcelOutput.Log.FileOpened\", data.file.toString()));\r\n\t\t\tretval=true;\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error opening new file\", e);\r\n\t\t\tsetErrors(1);\r\n\t\t}\r\n\r\n\t\treturn retval;\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean addFilenameToResult() {\r\n\t  try {\r\n        String buildFilename=buildFilename();\r\n        data.file = KettleVFS.getFileObject(buildFilename, getTransMeta());\r\n\r\n        if(meta.isAddToResultFiles())\r\n        {\r\n            // Add this to the result file names...\r\n            ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, data.file, getTransMeta().getName(), getStepname());\r\n            resultFile.setComment(\"This file was created with an Excel output step by Pentaho Data Integration\");\r\n            addResultFile(resultFile);\r\n        }\r\n        \r\n        return true;\r\n\r\n\t  } catch(Exception e) {\r\n\t    log.logError(\"Unable to add filename to the result\", e);\r\n\t    return false;\r\n\t  }\r\n    }","id":43200,"modified_method":"private boolean addFilenameToResult() {\r\n\t  try {\r\n\t        if(meta.isAddToResultFiles()) {\r\n\t            // Add this to the result file names...\r\n\t            ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, data.file, getTransMeta().getName(), getStepname());\r\n\t            resultFile.setComment(\"This file was created with an Excel output step by Pentaho Data Integration\");\r\n\t            addResultFile(resultFile);\r\n\t        }\r\n        \r\n\t        return true;\r\n\r\n\t  } catch(Exception e) {\r\n\t    log.logError(\"Unable to add filename to the result\", e);\r\n\t    return false;\r\n\t  }\r\n    }","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n\t * Copy information from the meta-data input to the dialog fields.\r\n\t */ \r\n\tpublic void getData()\r\n\t{\r\n\t\tif (input.getFileName()  != null) wFilename.setText(input.getFileName());\r\n\t\twDoNotOpenNewFileInit.setSelection(input.isDoNotOpenNewFileInit());\r\n\t\tif (input.getExtension() != null) wExtension.setText(input.getExtension());\r\n        if (input.getEncoding()  !=null) wEncoding.setText(input.getEncoding());\r\n\t\tif (input.getTemplateFileName()  != null) wTemplateFilename.setText(input.getTemplateFileName());\r\n\t\t\r\n\t\twSplitEvery.setText(\"\"+input.getSplitEvery());\r\n\t\twAppend.setSelection(input.isAppend());\r\n\t\twHeader.setSelection(input.isHeaderEnabled());\r\n\t\twFooter.setSelection(input.isFooterEnabled());\r\n\t\twAddDate.setSelection(input.isDateInFilename());\r\n\t\twAddTime.setSelection(input.isTimeInFilename());\r\n\t\t\r\n\t\tif (input.getDateTimeFormat()!= null) wDateTimeFormat.setText( input.getDateTimeFormat() );\r\n\t\twSpecifyFormat.setSelection(input.isSpecifyFormat());\r\n\t\t\r\n\t\twCreateParentFolder.setSelection(wCreateParentFolder.getSelection());\r\n\t\twAddToResult.setSelection(input.isAddToResultFiles());\r\n\t\twAutoSize.setSelection(input.isAutoSizeColums());\r\n\t\twNullIsBlank.setSelection(input.isNullBlank());\r\n\r\n\t\twAddStepnr.setSelection(input.isStepNrInFilename());\r\n\t\twTemplate.setSelection(input.isTemplateEnabled());\r\n\t\twTemplateAppend.setSelection(input.isTemplateAppend());\r\n\t\tif (input.getSheetname() != null) \r\n\t\t{\r\n\t\t\twSheetname.setText(input.getSheetname());\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twSheetname.setText(\"Sheet1\");\r\n\t\t}\r\n\t\twProtectSheet.setSelection(input.isSheetProtected());\r\n\t\r\n\t\tEnablePassword();\r\n\t\tEnableTemplate();\r\n\r\n\t\tif (input.getPassword() != null) wPassword.setText(input.getPassword());\r\n\t\tif(isDebug()) logDebug(\"getting fields info...\");\r\n\t\t\r\n\t\tfor (int i=0;i<input.getOutputFields().length;i++)\r\n\t\t{\r\n\t\t    ExcelField field = input.getOutputFields()[i];\r\n\t\t    \r\n\t\t\tTableItem item = wFields.table.getItem(i);\r\n\t\t\tif (field.getName()!=null) item.setText(1, field.getName());\r\n\t\t\titem.setText(2, field.getTypeDesc());\r\n\t\t\tif (field.getFormat()!=null) item.setText(3, field.getFormat());\r\n\t\t}\r\n\t\t\r\n\t\twFields.optWidth(true);\r\n\t\twStepname.selectAll();\r\n\t}","id":43201,"modified_method":"/**\r\n\t * Copy information from the meta-data input to the dialog fields.\r\n\t */ \r\n\tpublic void getData()\r\n\t{\r\n\t\tif (input.getFileName()  != null) wFilename.setText(input.getFileName());\r\n\t\twDoNotOpenNewFileInit.setSelection(input.isDoNotOpenNewFileInit());\r\n\t\tif (input.getExtension() != null) wExtension.setText(input.getExtension());\r\n        if (input.getEncoding()  !=null) wEncoding.setText(input.getEncoding());\r\n\t\tif (input.getTemplateFileName()  != null) wTemplateFilename.setText(input.getTemplateFileName());\r\n\t\t\r\n\t\twSplitEvery.setText(\"\"+input.getSplitEvery());\r\n\t\twAppend.setSelection(input.isAppend());\r\n\t\twHeader.setSelection(input.isHeaderEnabled());\r\n\t\twFooter.setSelection(input.isFooterEnabled());\r\n\t\twAddDate.setSelection(input.isDateInFilename());\r\n\t\twAddTime.setSelection(input.isTimeInFilename());\r\n\t\t\r\n\t\tif (input.getDateTimeFormat()!= null) wDateTimeFormat.setText( input.getDateTimeFormat() );\r\n\t\twSpecifyFormat.setSelection(input.isSpecifyFormat());\r\n\t\t\r\n\t\twCreateParentFolder.setSelection(wCreateParentFolder.getSelection());\r\n\t\twAddToResult.setSelection(input.isAddToResultFiles());\r\n\t\twAutoSize.setSelection(input.isAutoSizeColums());\r\n\t\twNullIsBlank.setSelection(input.isNullBlank());\r\n\r\n\t\twAddStepnr.setSelection(input.isStepNrInFilename());\r\n\t\twTemplate.setSelection(input.isTemplateEnabled());\r\n\t\twTemplateAppend.setSelection(input.isTemplateAppend());\r\n\t\tif (input.getSheetname() != null) \r\n\t\t{\r\n\t\t\twSheetname.setText(input.getSheetname());\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twSheetname.setText(\"Sheet1\");\r\n\t\t}\r\n\t\twProtectSheet.setSelection(input.isSheetProtected());\r\n\t\r\n\t\tEnablePassword();\r\n\t\tEnableTemplate();\r\n\r\n\t\tif (input.getPassword() != null) wPassword.setText(input.getPassword());\r\n\t\tif(isDebug()) logDebug(\"getting fields info...\");\r\n\t\t\r\n\t\tfor (int i=0;i<input.getOutputFields().length;i++)\r\n\t\t{\r\n\t\t    ExcelField field = input.getOutputFields()[i];\r\n\t\t    \r\n\t\t\tTableItem item = wFields.table.getItem(i);\r\n\t\t\tif (field.getName()!=null) item.setText(1, field.getName());\r\n\t\t\titem.setText(2, field.getTypeDesc());\r\n\t\t\tif (field.getFormat()!=null) item.setText(3, field.getFormat());\r\n\t\t}\r\n\t\t\r\n\t\twFields.optWidth(true);\r\n\t\t\r\n\t\t// Header Font settings\r\n\t\twHeaderFontName.setText(ExcelOutputMeta.getFontNameDesc(input.getHeaderFontName()));\r\n\t\twHeaderFontSize.setText(input.getHeaderFontSize());\r\n\t\twHeaderFontBold.setSelection(input.isHeaderFontBold());\r\n\t\twHeaderFontItalic.setSelection(input.isHeaderFontItalic());\r\n\t\twHeaderFontUnderline.setText(ExcelOutputMeta.getFontUnderlineDesc(input.getHeaderFontUnderline()));\r\n\t\twHeaderFontOrientation.setText(ExcelOutputMeta.getFontOrientationDesc(input.getHeaderFontOrientation()));\r\n\t\twHeaderFontColor.setText(ExcelOutputMeta.getFontColorDesc(input.getHeaderFontColor()));\r\n\t\twHeaderBackGroundColor.setText(ExcelOutputMeta.getFontColorDesc(input.getHeaderBackGroundColor()));\r\n\t\twHeaderRowHeight.setText(Const.NVL(input.getHeaderRowHeight(),\"\"+ExcelOutputMeta.DEFAULT_ROW_HEIGHT));\r\n\t\twHeaderAlignment.setText(ExcelOutputMeta.getFontAlignmentDesc(input.getHeaderAlignment()));\r\n\t\tif(input.getHeaderImage()!=null) wImage.setText(input.getHeaderImage());\r\n\t\t\r\n\t\t// Row font settings\r\n\t\twRowFontName.setText(ExcelOutputMeta.getFontNameDesc(input.getRowFontName()));\r\n\t\twRowFontSize.setText(input.getRowFontSize());\r\n\t\twRowFontColor.setText(ExcelOutputMeta.getFontColorDesc(input.getRowFontColor()));\r\n\t\twRowBackGroundColor.setText(ExcelOutputMeta.getFontColorDesc(input.getRowBackGroundColor()));\r\n\t\t\r\n\t\t\r\n\t\twStepname.selectAll();\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void EnableTemplate()\r\n\t{\r\n\t\tinput.setChanged();\r\n\t\n\t\twTemplateFilename.setEnabled(wTemplate.getSelection());\n\t\twTemplateAppend.setEnabled(wTemplate.getSelection());\n\t\r\n\t\r\n\t}","id":43202,"modified_method":"private void EnableTemplate()\r\n\t{\r\n\t\tinput.setChanged();\r\n\t\n\t\twlTemplateFilename.setEnabled(wTemplate.getSelection());\r\n\t\twTemplateFilename.setEnabled(wTemplate.getSelection());\r\n\t\twbTemplateFilename.setEnabled(wTemplate.getSelection());\n\t\twlTemplateAppend.setEnabled(wTemplate.getSelection());\n\t\twTemplateAppend.setEnabled(wTemplate.getSelection());\r\n\t\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(ExcelOutputMeta tfoi)\r\n\t{\r\n\t\ttfoi.setFileName(   wFilename.getText() );\r\n        tfoi.setEncoding( wEncoding.getText() );\r\n        tfoi.setDoNotOpenNewFileInit(wDoNotOpenNewFileInit.getSelection() );\r\n\t\ttfoi.setExtension(  wExtension.getText() );\r\n\t\ttfoi.setTemplateFileName(  wTemplateFilename.getText() );\r\n\t\ttfoi.setSplitEvery( Const.toInt(wSplitEvery.getText(), 0) );\r\n\t\ttfoi.setAppend( wAppend.getSelection() ); \r\n\t\ttfoi.setHeaderEnabled( wHeader.getSelection() ); \r\n\t\ttfoi.setFooterEnabled( wFooter.getSelection() );\r\n\t\ttfoi.setStepNrInFilename( wAddStepnr.getSelection() );\r\n\t\ttfoi.setDateInFilename( wAddDate.getSelection() );\r\n\t\ttfoi.setTimeInFilename( wAddTime.getSelection() );\r\n\t\t\r\n\t\ttfoi.setDateTimeFormat(wDateTimeFormat.getText());\r\n\t\ttfoi.setSpecifyFormat(wSpecifyFormat.getSelection());\r\n\t\ttfoi.setAutoSizeColums(wAutoSize.getSelection());\r\n\t\ttfoi.setNullIsBlank(wNullIsBlank.getSelection());\r\n        \r\n\t\ttfoi.setAddToResultFiles( wAddToResult.getSelection() );\r\n\t\ttfoi.setCreateParentFolder(wCreateParentFolder.getSelection());\r\n\t\ttfoi.setProtectSheet( wProtectSheet.getSelection() );\r\n\t\ttfoi.setPassword(   wPassword.getText() );\r\n\t\ttfoi.setTemplateEnabled( wTemplate.getSelection() );\r\n\t\ttfoi.setTemplateAppend( wTemplateAppend.getSelection() );\r\n\t\tif (wSheetname.getText()!=null)\r\n\t\t{\r\n\t\t\ttfoi.setSheetname(   wSheetname.getText() );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ttfoi.setSheetname( \"Sheet 1\" );\r\n\t\t}\r\n\r\n\t\tint i;\r\n\t\t//Table table = wFields.table;\r\n\t\t\r\n\t\tint nrfields = wFields.nrNonEmpty();\r\n\r\n\t\ttfoi.allocate(nrfields);\r\n\t\t\r\n\t\tfor (i=0;i<nrfields;i++)\r\n\t\t{\r\n\t\t    ExcelField field = new ExcelField();\r\n\t\t    \r\n\t\t\tTableItem item = wFields.getNonEmpty(i);\r\n\t\t\tfield.setName( item.getText(1) );\r\n\t\t\tfield.setType( item.getText(2) );\r\n\t\t\tfield.setFormat( item.getText(3) );\r\n\t\t\t\r\n\t\t\ttfoi.getOutputFields()[i]  = field;\r\n\t\t}\r\n\t}","id":43203,"modified_method":"private void getInfo(ExcelOutputMeta tfoi)\r\n\t{\r\n\t\ttfoi.setFileName(   wFilename.getText() );\r\n        tfoi.setEncoding( wEncoding.getText() );\r\n        tfoi.setDoNotOpenNewFileInit(wDoNotOpenNewFileInit.getSelection() );\r\n\t\ttfoi.setExtension(  wExtension.getText() );\r\n\t\ttfoi.setTemplateFileName(  wTemplateFilename.getText() );\r\n\t\ttfoi.setSplitEvery( Const.toInt(wSplitEvery.getText(), 0) );\r\n\t\ttfoi.setAppend( wAppend.getSelection() ); \r\n\t\ttfoi.setHeaderEnabled( wHeader.getSelection() ); \r\n\t\ttfoi.setFooterEnabled( wFooter.getSelection() );\r\n\t\ttfoi.setStepNrInFilename( wAddStepnr.getSelection() );\r\n\t\ttfoi.setDateInFilename( wAddDate.getSelection() );\r\n\t\ttfoi.setTimeInFilename( wAddTime.getSelection() );\r\n\t\t\r\n\t\ttfoi.setDateTimeFormat(wDateTimeFormat.getText());\r\n\t\ttfoi.setSpecifyFormat(wSpecifyFormat.getSelection());\r\n\t\ttfoi.setAutoSizeColums(wAutoSize.getSelection());\r\n\t\ttfoi.setNullIsBlank(wNullIsBlank.getSelection());\r\n        \r\n\t\ttfoi.setAddToResultFiles( wAddToResult.getSelection() );\r\n\t\ttfoi.setCreateParentFolder(wCreateParentFolder.getSelection());\r\n\t\ttfoi.setProtectSheet( wProtectSheet.getSelection() );\r\n\t\ttfoi.setPassword(   wPassword.getText() );\r\n\t\ttfoi.setTemplateEnabled( wTemplate.getSelection() );\r\n\t\ttfoi.setTemplateAppend( wTemplateAppend.getSelection() );\r\n\t\tif (wSheetname.getText()!=null)\r\n\t\t{\r\n\t\t\ttfoi.setSheetname(   wSheetname.getText() );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ttfoi.setSheetname( \"Sheet 1\" );\r\n\t\t}\r\n\r\n\t\tint i;\r\n\t\t//Table table = wFields.table;\r\n\t\t\r\n\t\tint nrfields = wFields.nrNonEmpty();\r\n\r\n\t\ttfoi.allocate(nrfields);\r\n\t\t\r\n\t\tfor (i=0;i<nrfields;i++)\r\n\t\t{\r\n\t\t    ExcelField field = new ExcelField();\r\n\t\t    \r\n\t\t\tTableItem item = wFields.getNonEmpty(i);\r\n\t\t\tfield.setName( item.getText(1) );\r\n\t\t\tfield.setType( item.getText(2) );\r\n\t\t\tfield.setFormat( item.getText(3) );\r\n\t\t\t\r\n\t\t\ttfoi.getOutputFields()[i]  = field;\r\n\t\t}\r\n\t\t// Header font\r\n\t\ttfoi.setHeaderFontName(ExcelOutputMeta.getFontNameByDesc(wHeaderFontName.getText()));\r\n\t\ttfoi.setHeaderFontSize(wHeaderFontSize.getText());\r\n\t\ttfoi.setHeaderFontBold(wHeaderFontBold.getSelection() );\r\n\t\ttfoi.setHeaderFontItalic(wHeaderFontItalic.getSelection() );\r\n\t\ttfoi.setHeaderFontUnderline(ExcelOutputMeta.getFontUnderlineByDesc(wHeaderFontUnderline.getText()));\r\n\t\ttfoi.setHeaderFontOrientation(ExcelOutputMeta.getFontOrientationByDesc(wHeaderFontOrientation.getText()));\r\n\t\ttfoi.setHeaderFontColor(ExcelOutputMeta.getFontColorByDesc(wHeaderFontColor.getText()));\r\n\t\ttfoi.setHeaderBackGroundColor(ExcelOutputMeta.getFontColorByDesc(wHeaderBackGroundColor.getText()));\r\n\t\ttfoi.setHeaderRowHeight(wHeaderRowHeight.getText());\r\n\t\ttfoi.setHeaderAlignment(ExcelOutputMeta.getFontAlignmentByDesc(wHeaderAlignment.getText()));\r\n\t\ttfoi.setHeaderImage(wImage.getText());\t\r\n\t\t\r\n\t\t// Row font\r\n\t\ttfoi.setRowFontName(ExcelOutputMeta.getFontNameByDesc(wRowFontName.getText()));\r\n\t\ttfoi.setRowFontSize(wRowFontSize.getText());\r\n\t\ttfoi.setRowFontColor(ExcelOutputMeta.getFontColorByDesc(wRowFontColor.getText()));\r\n\t\ttfoi.setRowBackGroundColor(ExcelOutputMeta.getFontColorByDesc(wRowBackGroundColor.getText()));\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\r\n\t{\r\n        Shell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\t\t\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.DialogTitle\"));\r\n\t\t\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Stepname line\r\n\t\twlStepname=new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\r\n \t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname=new FormData();\r\n\t\tfdlStepname.left  = new FormAttachment(0, 0);\r\n\t\tfdlStepname.top   = new FormAttachment(0, margin);\r\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n \t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname=new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top  = new FormAttachment(0, margin);\r\n\t\tfdStepname.right= new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\t\t\r\n\t\t//////////////////////////\r\n\t\t// START OF FILE TAB///\r\n\t\t///\r\n\t\twFileTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFileTab.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.FileTab.TabTitle\"));\r\n\t\t\r\n\t\tComposite wFileComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wFileComp);\r\n\r\n\t\tFormLayout fileLayout = new FormLayout();\r\n\t\tfileLayout.marginWidth  = 3;\r\n\t\tfileLayout.marginHeight = 3;\r\n\t\twFileComp.setLayout(fileLayout);\r\n\r\n\t\t// Filename line\r\n\t\twlFilename=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlFilename.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Filename.Label\"));\r\n \t\tprops.setLook(wlFilename);\r\n\t\tfdlFilename=new FormData();\r\n\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlFilename.top  = new FormAttachment(0, margin);\r\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\twlFilename.setLayoutData(fdlFilename);\r\n\r\n\t\twbFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbFilename);\r\n\t\twbFilename.setText(BaseMessages.getString(PKG, \"System.Button.Browse\"));\r\n\t\tfdbFilename=new FormData();\r\n\t\tfdbFilename.right= new FormAttachment(100, 0);\r\n\t\tfdbFilename.top  = new FormAttachment(0, 0);\r\n\t\twbFilename.setLayoutData(fdbFilename);\r\n\r\n\t\twFilename=new TextVar(transMeta, wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wFilename);\r\n\t\twFilename.addModifyListener(lsMod);\r\n\t\tfdFilename=new FormData();\r\n\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdFilename.top  = new FormAttachment(0, margin);\r\n\t\tfdFilename.right= new FormAttachment(wbFilename, -margin);\r\n\t\twFilename.setLayoutData(fdFilename);\r\n\t\t\r\n\r\n\t\t// Create Parent Folder\r\n\t\twlCreateParentFolder=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlCreateParentFolder.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.CreateParentFolder.Label\"));\r\n \t\tprops.setLook(wlCreateParentFolder);\r\n\t\tfdlCreateParentFolder=new FormData();\r\n\t\tfdlCreateParentFolder.left = new FormAttachment(0, 0);\r\n\t\tfdlCreateParentFolder.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdlCreateParentFolder.right= new FormAttachment(middle, -margin);\r\n\t\twlCreateParentFolder.setLayoutData(fdlCreateParentFolder);\r\n\t\twCreateParentFolder=new Button(wFileComp, SWT.CHECK );\r\n\t\twCreateParentFolder.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.CreateParentFolder.Tooltip\"));\r\n \t\tprops.setLook(wCreateParentFolder);\r\n\t\tfdCreateParentFolder=new FormData();\r\n\t\tfdCreateParentFolder.left = new FormAttachment(middle, 0);\r\n\t\tfdCreateParentFolder.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdCreateParentFolder.right= new FormAttachment(100, 0);\r\n\t\twCreateParentFolder.setLayoutData(fdCreateParentFolder);\r\n\t\twCreateParentFolder.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// Open new File at Init\r\n\t\twlDoNotOpenNewFileInit=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlDoNotOpenNewFileInit.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.DoNotOpenNewFileInit.Label\"));\r\n \t\tprops.setLook(wlDoNotOpenNewFileInit);\r\n\t\tfdlDoNotOpenNewFileInit=new FormData();\r\n\t\tfdlDoNotOpenNewFileInit.left = new FormAttachment(0, 0);\r\n\t\tfdlDoNotOpenNewFileInit.top  = new FormAttachment(wCreateParentFolder, margin);\r\n\t\tfdlDoNotOpenNewFileInit.right= new FormAttachment(middle, -margin);\r\n\t\twlDoNotOpenNewFileInit.setLayoutData(fdlDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit=new Button(wFileComp, SWT.CHECK );\r\n\t\twDoNotOpenNewFileInit.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.DoNotOpenNewFileInit.Tooltip\"));\r\n \t\tprops.setLook(wDoNotOpenNewFileInit);\r\n\t\tfdDoNotOpenNewFileInit=new FormData();\r\n\t\tfdDoNotOpenNewFileInit.left = new FormAttachment(middle, 0);\r\n\t\tfdDoNotOpenNewFileInit.top  = new FormAttachment(wCreateParentFolder, margin);\r\n\t\tfdDoNotOpenNewFileInit.right= new FormAttachment(100, 0);\r\n\t\twDoNotOpenNewFileInit.setLayoutData(fdDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t\r\n\t\t// Extension line\r\n\t\twlExtension=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlExtension.setText(BaseMessages.getString(PKG, \"System.Label.Extension\"));\r\n \t\tprops.setLook(wlExtension);\r\n\t\tfdlExtension=new FormData();\r\n\t\tfdlExtension.left = new FormAttachment(0, 0);\r\n\t\tfdlExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdlExtension.right= new FormAttachment(middle, -margin);\r\n\t\twlExtension.setLayoutData(fdlExtension);\r\n\t\twExtension=new TextVar(transMeta,wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twExtension.setText(\"\");\r\n \t\tprops.setLook(wExtension);\r\n\t\twExtension.addModifyListener(lsMod);\r\n\t\tfdExtension=new FormData();\r\n\t\tfdExtension.left = new FormAttachment(middle, 0);\r\n\t\tfdExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdExtension.right= new FormAttachment(wbFilename, -margin);\r\n\t\twExtension.setLayoutData(fdExtension);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddStepnr=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddStepnr.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddStepnr.Label\"));\r\n \t\tprops.setLook(wlAddStepnr);\r\n\t\tfdlAddStepnr=new FormData();\r\n\t\tfdlAddStepnr.left = new FormAttachment(0, 0);\r\n\t\tfdlAddStepnr.top  = new FormAttachment(wExtension, margin);\r\n\t\tfdlAddStepnr.right= new FormAttachment(middle, -margin);\r\n\t\twlAddStepnr.setLayoutData(fdlAddStepnr);\r\n\t\twAddStepnr=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddStepnr);\r\n\t\tfdAddStepnr=new FormData();\r\n\t\tfdAddStepnr.left = new FormAttachment(middle, 0);\r\n\t\tfdAddStepnr.top  = new FormAttachment(wExtension, margin);\r\n\t\tfdAddStepnr.right= new FormAttachment(100, 0);\r\n\t\twAddStepnr.setLayoutData(fdAddStepnr);\r\n\t\twAddStepnr.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddDate=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddDate.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddDate.Label\"));\r\n \t\tprops.setLook(wlAddDate);\r\n\t\tfdlAddDate=new FormData();\r\n\t\tfdlAddDate.left = new FormAttachment(0, 0);\r\n\t\tfdlAddDate.top  = new FormAttachment(wAddStepnr, margin);\r\n\t\tfdlAddDate.right= new FormAttachment(middle, -margin);\r\n\t\twlAddDate.setLayoutData(fdlAddDate);\r\n\t\twAddDate=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddDate);\r\n\t\tfdAddDate=new FormData();\r\n\t\tfdAddDate.left = new FormAttachment(middle, 0);\r\n\t\tfdAddDate.top  = new FormAttachment(wAddStepnr, margin);\r\n\t\tfdAddDate.right= new FormAttachment(100, 0);\r\n\t\twAddDate.setLayoutData(fdAddDate);\r\n\t\twAddDate.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\t// System.out.println(\"wAddDate.getSelection()=\"+wAddDate.getSelection());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Create multi-part file?\r\n\t\twlAddTime=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddTime.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddTime.Label\"));\r\n \t\tprops.setLook(wlAddTime);\r\n\t\tfdlAddTime=new FormData();\r\n\t\tfdlAddTime.left = new FormAttachment(0, 0);\r\n\t\tfdlAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdlAddTime.right= new FormAttachment(middle, -margin);\r\n\t\twlAddTime.setLayoutData(fdlAddTime);\r\n\t\twAddTime=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddTime);\r\n\t\tfdAddTime=new FormData();\r\n\t\tfdAddTime.left = new FormAttachment(middle, 0);\r\n\t\tfdAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdAddTime.right= new FormAttachment(100, 0);\r\n\t\twAddTime.setLayoutData(fdAddTime);\r\n\t\twAddTime.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Specify date time format?\r\n\t\twlSpecifyFormat=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlSpecifyFormat.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.SpecifyFormat.Label\"));\r\n\t\tprops.setLook(wlSpecifyFormat);\r\n\t\tfdlSpecifyFormat=new FormData();\r\n\t\tfdlSpecifyFormat.left = new FormAttachment(0, 0);\r\n\t\tfdlSpecifyFormat.top  = new FormAttachment(wAddTime, margin);\r\n\t\tfdlSpecifyFormat.right= new FormAttachment(middle, -margin);\r\n\t\twlSpecifyFormat.setLayoutData(fdlSpecifyFormat);\r\n\t\twSpecifyFormat=new Button(wFileComp, SWT.CHECK);\r\n\t\tprops.setLook(wSpecifyFormat);\r\n\t\twSpecifyFormat.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.SpecifyFormat.Tooltip\"));\r\n\t    fdSpecifyFormat=new FormData();\r\n\t\tfdSpecifyFormat.left = new FormAttachment(middle, 0);\r\n\t\tfdSpecifyFormat.top  = new FormAttachment(wAddTime, margin);\r\n\t\tfdSpecifyFormat.right= new FormAttachment(100, 0);\r\n\t\twSpecifyFormat.setLayoutData(fdSpecifyFormat);\r\n\t\twSpecifyFormat.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\tsetDateTimeFormat();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t\r\n\t\t//\tPrepare a list of possible DateTimeFormats...\r\n\t\tString dats[] = Const.getDateFormats();\r\n\t\t\r\n \t\t// DateTimeFormat\r\n\t\twlDateTimeFormat=new Label(wFileComp, SWT.RIGHT);\r\n        wlDateTimeFormat.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.DateTimeFormat.Label\"));\r\n        props.setLook(wlDateTimeFormat);\r\n        fdlDateTimeFormat=new FormData();\r\n        fdlDateTimeFormat.left = new FormAttachment(0, 0);\r\n        fdlDateTimeFormat.top  = new FormAttachment(wSpecifyFormat, margin);\r\n        fdlDateTimeFormat.right= new FormAttachment(middle, -margin);\r\n        wlDateTimeFormat.setLayoutData(fdlDateTimeFormat);\r\n        wDateTimeFormat=new CCombo(wFileComp, SWT.BORDER | SWT.READ_ONLY);\r\n        wDateTimeFormat.setEditable(true);\r\n        props.setLook(wDateTimeFormat);\r\n        wDateTimeFormat.addModifyListener(lsMod);\r\n        fdDateTimeFormat=new FormData();\r\n        fdDateTimeFormat.left = new FormAttachment(middle, 0);\r\n        fdDateTimeFormat.top  = new FormAttachment(wSpecifyFormat, margin);\r\n        fdDateTimeFormat.right= new FormAttachment(100, 0);\r\n        wDateTimeFormat.setLayoutData(fdDateTimeFormat);\r\n        for (int x=0;x<dats.length;x++) wDateTimeFormat.add(dats[x]);\r\n        \r\n\r\n\r\n\t\twbShowFiles=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\r\n\t\tprops.setLook(wbShowFiles);\r\n\t\twbShowFiles.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.ShowFiles.Button\"));\r\n\t\tfdbShowFiles=new FormData();\r\n\t\tfdbShowFiles.left = new FormAttachment(middle, 0);\r\n\t\tfdbShowFiles.top  = new FormAttachment(wDateTimeFormat, margin*3);\r\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\r\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tExcelOutputMeta tfoi = new ExcelOutputMeta();\r\n\t\t\t\tgetInfo(tfoi);\r\n\t\t\t\tString files[] = tfoi.getFiles(transMeta);\r\n\t\t\t\tif (files!=null && files.length>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, files, BaseMessages.getString(PKG, \"ExcelOutputDialog.SelectOutputFiles.DialogTitle\"), BaseMessages.getString(PKG, \"ExcelOutputDialog.SelectOutputFiles.DialogMessage\"));\r\n\t\t\t\t\tesd.setViewOnly();\r\n\t\t\t\t\tesd.open();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\r\n\t\t\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"ExcelOutputDialog.NoFilesFound.DialogMessage\"));\r\n\t\t\t\t\tmb.setText(BaseMessages.getString(PKG, \"System.Dialog.Error.Title\"));\r\n\t\t\t\t\tmb.open(); \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t);\r\n\t\t\r\n\t\t\r\n\t\t// Add File to the result files name\r\n\t\twlAddToResult=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddToResult.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddFileToResult.Label\"));\r\n\t\tprops.setLook(wlAddToResult);\r\n\t\tfdlAddToResult=new FormData();\r\n\t\tfdlAddToResult.left  = new FormAttachment(0, 0);\r\n\t\tfdlAddToResult.top   = new FormAttachment(wbShowFiles, 2*margin);\r\n\t\tfdlAddToResult.right = new FormAttachment(middle, -margin);\r\n\t\twlAddToResult.setLayoutData(fdlAddToResult);\r\n\t\twAddToResult=new Button(wFileComp, SWT.CHECK);\r\n\t\twAddToResult.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddFileToResult.Tooltip\"));\r\n \t\tprops.setLook(wAddToResult);\r\n\t\tfdAddToResult=new FormData();\r\n\t\tfdAddToResult.left  = new FormAttachment(middle, 0);\r\n\t\tfdAddToResult.top   = new FormAttachment(wbShowFiles, 2*margin);\r\n\t\tfdAddToResult.right = new FormAttachment(100, 0);\r\n\t\twAddToResult.setLayoutData(fdAddToResult);\r\n\t\tSelectionAdapter lsSelR = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n\t\twAddToResult.addSelectionListener(lsSelR);\r\n\r\n\t\r\n\t\tfdFileComp=new FormData();\r\n\t\tfdFileComp.left  = new FormAttachment(0, 0);\r\n\t\tfdFileComp.top   = new FormAttachment(0, 0);\r\n\t\tfdFileComp.right = new FormAttachment(100, 0);\r\n\t\tfdFileComp.bottom= new FormAttachment(100, 0);\r\n\t\twFileComp.setLayoutData(fdFileComp);\r\n\t\r\n\t\twFileComp.layout();\r\n\t\twFileTab.setControl(wFileComp);\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF FILE TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n\t\t//////////////////////////\r\n\t\t// START OF CONTENT TAB///\r\n\t\t///\r\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twContentTab.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.ContentTab.TabTitle\"));\r\n\r\n\t\tFormLayout contentLayout = new FormLayout ();\r\n\t\tcontentLayout.marginWidth  = 3;\r\n\t\tcontentLayout.marginHeight = 3;\r\n\t\t\r\n\t\tComposite wContentComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wContentComp);\r\n\t\twContentComp.setLayout(contentLayout);\r\n\t\t\r\n\t\t// Append checkbox\r\n\t\twlAppend=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlAppend.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Append.Label\"));\r\n \t\tprops.setLook(wlAppend);\r\n\t\tfdlAppend=new FormData();\r\n\t\tfdlAppend.left = new FormAttachment(0, 0);\r\n\t\tfdlAppend.top  = new FormAttachment(0, 0);\r\n\t\tfdlAppend.right= new FormAttachment(middle, -margin);\r\n\t\twlAppend.setLayoutData(fdlAppend);\r\n\t\twAppend=new Button(wContentComp, SWT.CHECK);\r\n \t\tprops.setLook(wAppend);\r\n \t\twAppend.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Append.Tooltip\"));\r\n\t\tfdAppend=new FormData();\r\n\t\tfdAppend.left = new FormAttachment(middle, 0);\r\n\t\tfdAppend.top  = new FormAttachment(0, 0);\r\n\t\tfdAppend.right= new FormAttachment(100, 0);\r\n\t\twAppend.setLayoutData(fdAppend);\r\n\t\twAppend.addSelectionListener(new SelectionAdapter() \r\n\t        {\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent arg0)\r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\r\n\t\t\r\n\r\n\r\n\t\twlHeader=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlHeader.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Header.Label\"));\r\n \t\tprops.setLook(wlHeader);\r\n\t\tfdlHeader=new FormData();\r\n\t\tfdlHeader.left = new FormAttachment(0, 0);\r\n\t\tfdlHeader.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdlHeader.right= new FormAttachment(middle, -margin);\r\n\t\twlHeader.setLayoutData(fdlHeader);\r\n\t\twHeader=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wHeader);\r\n\t\tfdHeader=new FormData();\r\n\t\tfdHeader.left = new FormAttachment(middle, 0);\r\n\t\tfdHeader.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdHeader.right= new FormAttachment(100, 0);\r\n\t\twHeader.setLayoutData(fdHeader);\r\n\t\twHeader.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twlFooter=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlFooter.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Footer.Label\"));\r\n \t\tprops.setLook(wlFooter);\r\n\t\tfdlFooter=new FormData();\r\n\t\tfdlFooter.left = new FormAttachment(0, 0);\r\n\t\tfdlFooter.top  = new FormAttachment(wHeader, margin);\r\n\t\tfdlFooter.right= new FormAttachment(middle, -margin);\r\n\t\twlFooter.setLayoutData(fdlFooter);\r\n\t\twFooter=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wFooter);\r\n\t\tfdFooter=new FormData();\r\n\t\tfdFooter.left = new FormAttachment(middle, 0);\r\n\t\tfdFooter.top  = new FormAttachment(wHeader, margin);\r\n\t\tfdFooter.right= new FormAttachment(100, 0);\r\n\t\twFooter.setLayoutData(fdFooter);\r\n\t\twFooter.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n        wlEncoding=new Label(wContentComp, SWT.RIGHT);\r\n        wlEncoding.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Encoding.Label\"));\r\n        props.setLook(wlEncoding);\r\n        fdlEncoding=new FormData();\r\n        fdlEncoding.left = new FormAttachment(0, 0);\r\n        fdlEncoding.top  = new FormAttachment(wFooter, margin);\r\n        fdlEncoding.right= new FormAttachment(middle, -margin);\r\n        wlEncoding.setLayoutData(fdlEncoding);\r\n        wEncoding=new CCombo(wContentComp, SWT.BORDER | SWT.READ_ONLY);\r\n        wEncoding.setEditable(true);\r\n        props.setLook(wEncoding);\r\n        wEncoding.addModifyListener(lsMod);\r\n        fdEncoding=new FormData();\r\n        fdEncoding.left = new FormAttachment(middle, 0);\r\n        fdEncoding.top  = new FormAttachment(wFooter, margin);\r\n        fdEncoding.right= new FormAttachment(100, 0);\r\n        wEncoding.setLayoutData(fdEncoding);\r\n        wEncoding.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                    shell.setCursor(busy);\r\n                    setEncodings();\r\n                    shell.setCursor(null);\r\n                    busy.dispose();\r\n                }\r\n            }\r\n        );\r\n\r\n\t\twlSplitEvery=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlSplitEvery.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.SplitEvery.Label\"));\r\n \t\tprops.setLook(wlSplitEvery);\r\n\t\tfdlSplitEvery=new FormData();\r\n\t\tfdlSplitEvery.left = new FormAttachment(0, 0);\r\n\t\tfdlSplitEvery.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdlSplitEvery.right= new FormAttachment(middle, -margin);\r\n\t\twlSplitEvery.setLayoutData(fdlSplitEvery);\r\n\t\twSplitEvery=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wSplitEvery);\r\n\t\twSplitEvery.addModifyListener(lsMod);\r\n\t\tfdSplitEvery=new FormData();\r\n\t\tfdSplitEvery.left = new FormAttachment(middle, 0);\r\n\t\tfdSplitEvery.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdSplitEvery.right= new FormAttachment(100, 0);\r\n\t\twSplitEvery.setLayoutData(fdSplitEvery);\r\n\t\t\r\n\r\n\r\n\r\n\t\t// Sheet name line\n\t\twlSheetname=new Label(wContentComp, SWT.RIGHT);\n\t\twlSheetname.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Sheetname.Label\"));\n\t\tprops.setLook(wlSheetname);\n\t\tfdlSheetname=new FormData();\n\t\tfdlSheetname.left = new FormAttachment(0, 0);\n\t\tfdlSheetname.top  = new FormAttachment(wSplitEvery, margin);\n\t\tfdlSheetname.right= new FormAttachment(middle, -margin);\n\t\twlSheetname.setLayoutData(fdlSheetname);\n\t\twSheetname=new TextVar(transMeta, wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSheetname.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Sheetname.Tooltip\"));\n\t\tprops.setLook(wSheetname);\n\t\twSheetname.addModifyListener(lsMod);\n\t\tfdSheetname=new FormData();\n\t\tfdSheetname.left = new FormAttachment(middle, 0);\n\t\tfdSheetname.top  = new FormAttachment(wSplitEvery, margin);\n\t\tfdSheetname.right= new FormAttachment(100, 0);\n\t\twSheetname.setLayoutData(fdSheetname);\r\n\r\n\r\n\t\t// Protect Sheet?\r\n\t\twlProtectSheet=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlProtectSheet.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.ProtectSheet.Label\"));\r\n\t\tprops.setLook(wlProtectSheet);\r\n\t\tfdlProtectSheet=new FormData();\r\n\t\tfdlProtectSheet.left = new FormAttachment(0, 0);\r\n\t\tfdlProtectSheet.top  = new FormAttachment(wSheetname, margin);\r\n\t\tfdlProtectSheet.right= new FormAttachment(middle, -margin);\r\n\t\twlProtectSheet.setLayoutData(fdlProtectSheet);\r\n\t\twProtectSheet=new Button(wContentComp, SWT.CHECK);\r\n\t\tprops.setLook(wProtectSheet);\r\n\t\tfdProtectSheet=new FormData();\r\n\t\tfdProtectSheet.left = new FormAttachment(middle, 0);\r\n\t\tfdProtectSheet.top  = new FormAttachment(wSheetname, margin);\r\n\t\tfdProtectSheet.right= new FormAttachment(100, 0);\r\n\t\twProtectSheet.setLayoutData(fdProtectSheet);\r\n\t\twProtectSheet.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tEnablePassword();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t);\r\n\r\n\n\t\t// Password line\n\t\twlPassword=new Label(wContentComp, SWT.RIGHT);\n\t\twlPassword.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Password.Label\"));\n\t\tprops.setLook(wlPassword);\n\t\tfdlPassword=new FormData();\n\t\tfdlPassword.left = new FormAttachment(0, 0);\n\t\tfdlPassword.top  = new FormAttachment(wProtectSheet, margin);\n\t\tfdlPassword.right= new FormAttachment(middle, -margin);\n\t\twlPassword.setLayoutData(fdlPassword);\n\t\twPassword=new TextVar(transMeta, wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.PASSWORD);\n\t\twPassword.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Password.Tooltip\"));\n\t\tprops.setLook(wPassword);\n\t\twPassword.setEchoChar('*');\n\t\twPassword.addModifyListener(lsMod);\n\t\tfdPassword=new FormData();\n\t\tfdPassword.left = new FormAttachment(middle, 0);\n\t\tfdPassword.top  = new FormAttachment(wProtectSheet, margin);\n\t\tfdPassword.right= new FormAttachment(100, 0);\n\t\twPassword.setLayoutData(fdPassword);\r\n\r\n\t\t// auto size columns?\r\n\t\twlAutoSize=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlAutoSize.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AutoSize.Label\"));\r\n\t\tprops.setLook(wlAutoSize);\r\n\t\tfdlAutoSize=new FormData();\r\n\t\tfdlAutoSize.left = new FormAttachment(0, 0);\r\n\t\tfdlAutoSize.top  = new FormAttachment(wPassword, margin);\r\n\t\tfdlAutoSize.right= new FormAttachment(middle, -margin);\r\n\t\twlAutoSize.setLayoutData(fdlAutoSize);\r\n\t\twAutoSize=new Button(wContentComp, SWT.CHECK);\r\n\t\tprops.setLook(wAutoSize);\r\n\t\twAutoSize.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AutoSize.Tooltip\"));\r\n\t    fdAutoSize=new FormData();\r\n\t\tfdAutoSize.left = new FormAttachment(middle, 0);\r\n\t\tfdAutoSize.top  = new FormAttachment(wPassword, margin);\r\n\t\tfdAutoSize.right= new FormAttachment(100, 0);\r\n\t\twAutoSize.setLayoutData(fdAutoSize);\r\n\t\twAutoSize.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tEnableAutoSize();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\t\t\r\n\t    // write null values as blank cells ?\r\n\t\twlNullIsBlank=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlNullIsBlank.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.NullIsBlank.Label\"));\r\n        props.setLook(wlNullIsBlank);\r\n        fdlNullIsBlank=new FormData();\r\n        fdlNullIsBlank.left = new FormAttachment(0, 0);\r\n        fdlNullIsBlank.top  = new FormAttachment(wAutoSize, margin);\r\n        fdlNullIsBlank.right= new FormAttachment(middle, -margin);\r\n        wlNullIsBlank.setLayoutData(fdlNullIsBlank);\r\n        wNullIsBlank=new Button(wContentComp, SWT.CHECK);\r\n        props.setLook(wNullIsBlank);\r\n        wNullIsBlank.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.NullIsBlank.Tooltip\"));\r\n        fdNullIsBlank=new FormData();\r\n        fdNullIsBlank.left = new FormAttachment(middle, 0);\r\n        fdNullIsBlank.top  = new FormAttachment(wAutoSize, margin);\r\n        fdNullIsBlank.right= new FormAttachment(100, 0);\r\n        wNullIsBlank.setLayoutData(fdNullIsBlank);\t\t\r\n\t\t\r\n\t\t\r\n\t\t// ///////////////////////////////\r\n\t\t// START OF Template Group GROUP //\r\n\t\t///////////////////////////////// \r\n\r\n\t\twTemplateGroup= new Group(wContentComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wTemplateGroup);\r\n\t\twTemplateGroup.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.TemplateGroup.Label\"));\r\n\t\t\r\n\t\tFormLayout TemplateGroupgroupLayout = new FormLayout();\r\n\t\tTemplateGroupgroupLayout.marginWidth = 10;\r\n\t\tTemplateGroupgroupLayout.marginHeight = 10;\r\n\t\twTemplateGroup.setLayout(TemplateGroupgroupLayout);\r\n\t\t\r\n\t\t// Use template\r\n\t\twlTemplate=new Label(wTemplateGroup, SWT.RIGHT);\r\n\t\twlTemplate.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Template.Label\"));\r\n \t\tprops.setLook(wlTemplate);\r\n\t\tfdlTemplate=new FormData();\r\n\t\tfdlTemplate.left = new FormAttachment(0, 0);\r\n\t\tfdlTemplate.top  = new FormAttachment(wNullIsBlank, margin);\r\n\t\tfdlTemplate.right= new FormAttachment(middle, -margin);\r\n\t\twlTemplate.setLayoutData(fdlTemplate);\r\n\t\twTemplate=new Button(wTemplateGroup, SWT.CHECK );\r\n \t\tprops.setLook(wTemplate);\r\n\t\tfdTemplate=new FormData();\r\n\t\tfdTemplate.left = new FormAttachment(middle, 0);\r\n\t\tfdTemplate.top  = new FormAttachment(wNullIsBlank, margin);\r\n\t\tfdTemplate.right= new FormAttachment(100, 0);\r\n\t\twTemplate.setLayoutData(fdTemplate);\r\n\t\twTemplate.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tEnableTemplate();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// TemplateFilename line\r\n\t\twlTemplateFilename=new Label(wTemplateGroup, SWT.RIGHT);\r\n\t\twlTemplateFilename.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.TemplateFilename.Label\"));\r\n \t\tprops.setLook(wlTemplateFilename);\r\n\t\tfdlTemplateFilename=new FormData();\r\n\t\tfdlTemplateFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlTemplateFilename.top  = new FormAttachment(wTemplate, margin);\r\n\t\tfdlTemplateFilename.right= new FormAttachment(middle, -margin);\r\n\t\twlTemplateFilename.setLayoutData(fdlTemplateFilename);\r\n\r\n\t\twbTemplateFilename=new Button(wTemplateGroup, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbTemplateFilename);\r\n\t\twbTemplateFilename.setText(BaseMessages.getString(PKG, \"System.Button.Browse\"));\r\n\t\tfdbTemplateFilename=new FormData();\r\n\t\tfdbTemplateFilename.right= new FormAttachment(100, 0);\r\n\t\tfdbTemplateFilename.top  = new FormAttachment(wTemplate, 0);\r\n\t\twbTemplateFilename.setLayoutData(fdbTemplateFilename);\r\n\r\n\t\twTemplateFilename=new TextVar(transMeta, wTemplateGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wTemplateFilename);\r\n\t\twTemplateFilename.addModifyListener(lsMod);\r\n\t\tfdTemplateFilename=new FormData();\r\n\t\tfdTemplateFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdTemplateFilename.top  = new FormAttachment(wTemplate, margin);\r\n\t\tfdTemplateFilename.right= new FormAttachment(wbTemplateFilename, -margin);\r\n\t\twTemplateFilename.setLayoutData(fdTemplateFilename);\r\n\r\n\t\t// Template Append\r\n\t\twlTemplateAppend=new Label(wTemplateGroup, SWT.RIGHT);\r\n\t\twlTemplateAppend.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.TemplateAppend.Label\"));\r\n \t\tprops.setLook(wlTemplateAppend);\r\n\t\tfdlTemplateAppend=new FormData();\r\n\t\tfdlTemplateAppend.left = new FormAttachment(0, 0);\r\n\t\tfdlTemplateAppend.top  = new FormAttachment(wTemplateFilename, margin);\r\n\t\tfdlTemplateAppend.right= new FormAttachment(middle, -margin);\r\n\t\twlTemplateAppend.setLayoutData(fdlTemplateAppend);\r\n\t\twTemplateAppend=new Button(wTemplateGroup, SWT.CHECK );\r\n \t\tprops.setLook(wTemplateAppend);\r\n\t\tfdTemplateAppend=new FormData();\r\n\t\tfdTemplateAppend.left = new FormAttachment(middle, 0);\r\n\t\tfdTemplateAppend.top  = new FormAttachment(wTemplateFilename, margin);\r\n\t\tfdTemplateAppend.right= new FormAttachment(100, 0);\r\n\t\twTemplateAppend.setLayoutData(fdTemplateAppend);\r\n\t\twTemplateAppend.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tfdTemplateGroup= new FormData();\r\n\t\tfdTemplateGroup.left = new FormAttachment(0, margin);\r\n\t\tfdTemplateGroup.top = new FormAttachment(wNullIsBlank, margin);\r\n\t\tfdTemplateGroup.right = new FormAttachment(100, -margin);\r\n\t\twTemplateGroup.setLayoutData(fdTemplateGroup);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Template Group GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\t\r\n\r\n\r\n\t\tfdContentComp = new FormData();\r\n\t\tfdContentComp.left  = new FormAttachment(0, 0);\r\n\t\tfdContentComp.top   = new FormAttachment(0, 0);\r\n\t\tfdContentComp.right = new FormAttachment(100, 0);\r\n\t\tfdContentComp.bottom= new FormAttachment(100, 0);\r\n\t\twContentComp.setLayoutData(fdContentComp);\r\n\r\n\t\twContentComp.layout();\r\n\t\twContentTab.setControl(wContentComp);\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF CONTENT TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n\t\t// Fields tab...\r\n\t\t//\r\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFieldsTab.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.FieldsTab.TabTitle\"));\r\n\t\t\r\n\t\tFormLayout fieldsLayout = new FormLayout ();\r\n\t\tfieldsLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tComposite wFieldsComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\twFieldsComp.setLayout(fieldsLayout);\r\n \t\tprops.setLook(wFieldsComp);\r\n\r\n\t\twGet=new Button(wFieldsComp, SWT.PUSH);\r\n\t\twGet.setText(BaseMessages.getString(PKG, \"System.Button.GetFields\"));\r\n\t\twGet.setToolTipText(BaseMessages.getString(PKG, \"System.Tooltip.GetFields\"));\r\n\r\n\t\twMinWidth =new Button(wFieldsComp, SWT.PUSH);\r\n\t\twMinWidth.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.MinWidth.Button\"));\r\n\t\twMinWidth.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.MinWidth.Tooltip\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wGet, wMinWidth}, margin, null);\r\n\r\n\t\tfinal int FieldsRows=input.getOutputFields().length;\r\n\t\t\r\n\t\t// Prepare a list of possible formats...\r\n        String[] formats = new String[] \r\n           {\r\n                // Numbers\r\n                \"#\",\r\n                \"0\",\r\n                \"0.00\",\r\n                \"#,##0\",\r\n                \"#,##0.00\",\r\n                \"$#,##0;($#,##0)\",\r\n                \"$#,##0;($#,##0)\",\r\n                \"$#,##0;($#,##0)\",\r\n                \"$#,##0;($#,##0)\",\r\n                \"0%\",\r\n                \"0.00%\",\r\n                \"0.00E00\",\r\n                \"#,##0;(#,##0)\",\r\n                \"#,##0;(#,##0)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"#,##0;(#,##0)\",\r\n                \"#,##0;(#,##0)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"##0.0E0\",\r\n                \r\n                // Forces text\r\n                \"@\",\r\n                \r\n                // Dates\r\n                \"M/d/yy\",\r\n                \"d-MMM-yy\",\r\n                \"d-MMM\",\r\n                \"MMM-yy\",\r\n                \"h:mm a\",\r\n                \"h:mm:ss a\",\r\n                \"H:mm\",\r\n                \"H:mm:ss\",\r\n                \"M/d/yy H:mm\",\r\n                \"mm:ss\",\r\n                \"H:mm:ss\",\r\n                \"H:mm:ss\",\r\n           };\r\n        \r\n        colinf=new ColumnInfo[] \r\n\t\t    {\r\n\t\t        new ColumnInfo(BaseMessages.getString(PKG, \"ExcelOutputDialog.NameColumn.Column\"),      ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false),\r\n\t\t        new ColumnInfo(BaseMessages.getString(PKG, \"ExcelOutputDialog.TypeColumn.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes() ),\r\n\t\t        new ColumnInfo(BaseMessages.getString(PKG, \"ExcelOutputDialog.FormatColumn.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, formats),\r\n            };\r\n\t\t\r\n\t\twFields=new TableView(transMeta, wFieldsComp, \r\n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \r\n\t\t\t\t\t\t      colinf, \r\n\t\t\t\t\t\t      FieldsRows,  \r\n\t\t\t\t\t\t      lsMod,\r\n\t\t\t\t\t\t\t  props\r\n\t\t\t\t\t\t      );\r\n\r\n\t\tfdFields=new FormData();\r\n\t\tfdFields.left  = new FormAttachment(0, 0);\r\n\t\tfdFields.top   = new FormAttachment(0, 0);\r\n\t\tfdFields.right = new FormAttachment(100, 0);\r\n\t\tfdFields.bottom= new FormAttachment(wGet, -margin);\r\n\t\twFields.setLayoutData(fdFields);\r\n\t\t\r\n\t\t  // \r\n        // Search the fields in the background\r\n\t\t\r\n        final Runnable runnable = new Runnable()\r\n        {\r\n            public void run()\r\n            {\r\n                StepMeta stepMeta = transMeta.findStep(stepname);\r\n                if (stepMeta!=null)\r\n                {\r\n                    try\r\n                    {\r\n                    \tRowMetaInterface row = transMeta.getPrevStepFields(stepMeta);\r\n                       \r\n                        // Remember these fields...\r\n                        for (int i=0;i<row.size();i++)\r\n                        {\r\n                            inputFields.put(row.getValueMeta(i).getName(), Integer.valueOf(i));\r\n                        }\r\n                        setComboBoxes();\r\n                    }\r\n                    catch(KettleException e)\r\n                    {\r\n                    \tlogError(BaseMessages.getString(PKG, \"System.Dialog.GetFieldsFailed.Message\"));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        new Thread(runnable).start();\r\n\r\n\t\tfdFieldsComp=new FormData();\r\n\t\tfdFieldsComp.left  = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.top   = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\r\n\t\tfdFieldsComp.bottom= new FormAttachment(100, 0);\r\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\r\n\r\n\t\twFieldsComp.layout();\r\n\t\twFieldsTab.setControl(wFieldsComp);\r\n\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\t\t\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\r\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, wTabFolder);\r\n\r\n\t\t// Add listeners\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();       } };\r\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();      } };\r\n\t\tlsMinWidth    = new Listener() { public void handleEvent(Event e) { setMinimalWidth(); } };\r\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();   } };\r\n\t\t\r\n\t\twOK.addListener    (SWT.Selection, lsOK    );\r\n\t\twGet.addListener   (SWT.Selection, lsGet   );\r\n\t\twMinWidth.addListener (SWT.Selection, lsMinWidth );\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\r\n\t\twStepname.addSelectionListener( lsDef );\r\n\t\twFilename.addSelectionListener( lsDef );\r\n\t\twTemplateFilename.addSelectionListener( lsDef );\r\n\r\n\t\t// Whenever something changes, set the tooltip to the expanded version:\r\n\t\twFilename.addModifyListener(new ModifyListener()\r\n\t\t\t{\r\n\t\t\t\tpublic void modifyText(ModifyEvent e)\r\n\t\t\t\t{\r\n\t\t\t\t\twFilename.setToolTipText(transMeta.environmentSubstitute( wFilename.getText() ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\twTemplateFilename.addModifyListener(new ModifyListener()\r\n\t\t\t{\r\n\t\t\t\tpublic void modifyText(ModifyEvent e)\r\n\t\t\t\t{\r\n\t\t\t\t\twTemplateFilename.setToolTipText(transMeta.environmentSubstitute( wTemplateFilename.getText() ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\twbFilename.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.SAVE);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xls\", \"*.*\"});\r\n\t\t\t\t\tif (wFilename.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {BaseMessages.getString(PKG, \"System.FileType.ExcelFiles\"), BaseMessages.getString(PKG, \"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twbTemplateFilename.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xls\", \"*.*\"});\r\n\t\t\t\t\tif (wTemplateFilename.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wTemplateFilename.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {BaseMessages.getString(PKG, \"System.FileType.ExcelFiles\"), BaseMessages.getString(PKG, \"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twTemplateFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n\t\tlsResize = new Listener() \r\n\t\t{\r\n\t\t\tpublic void handleEvent(Event event) \r\n\t\t\t{\r\n\t\t\t\tPoint size = shell.getSize();\r\n\t\t\t\twFields.setSize(size.x-10, size.y-50);\r\n\t\t\t\twFields.table.setSize(size.x-10, size.y-50);\r\n\t\t\t\twFields.redraw();\r\n\t\t\t}\r\n\t\t};\r\n\t\tshell.addListener(SWT.Resize, lsResize);\r\n\r\n\t\twTabFolder.setSelection(0);\r\n\t\t\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\t\r\n\t\tgetData();\r\n\t\tsetDateTimeFormat();\r\n\t\tEnableAutoSize();\r\n\t\tinput.setChanged(changed);\r\n\t\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","id":43204,"modified_method":"public String open()\r\n\t{\r\n        Shell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\t\t\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.DialogTitle\"));\r\n\t\t\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Stepname line\r\n\t\twlStepname=new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\r\n \t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname=new FormData();\r\n\t\tfdlStepname.left  = new FormAttachment(0, 0);\r\n\t\tfdlStepname.top   = new FormAttachment(0, margin);\r\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n \t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname=new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top  = new FormAttachment(0, margin);\r\n\t\tfdStepname.right= new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\t\t\r\n\t\t//////////////////////////\r\n\t\t// START OF FILE TAB///\r\n\t\t///\r\n\t\twFileTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFileTab.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.FileTab.TabTitle\"));\r\n\t\t\r\n\t\tComposite wFileComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wFileComp);\r\n\r\n\t\tFormLayout fileLayout = new FormLayout();\r\n\t\tfileLayout.marginWidth  = 3;\r\n\t\tfileLayout.marginHeight = 3;\r\n\t\twFileComp.setLayout(fileLayout);\r\n\r\n\t\t// Filename line\r\n\t\twlFilename=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlFilename.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Filename.Label\"));\r\n \t\tprops.setLook(wlFilename);\r\n\t\tfdlFilename=new FormData();\r\n\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlFilename.top  = new FormAttachment(0, margin);\r\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\twlFilename.setLayoutData(fdlFilename);\r\n\r\n\t\twbFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbFilename);\r\n\t\twbFilename.setText(BaseMessages.getString(PKG, \"System.Button.Browse\"));\r\n\t\tfdbFilename=new FormData();\r\n\t\tfdbFilename.right= new FormAttachment(100, 0);\r\n\t\tfdbFilename.top  = new FormAttachment(0, 0);\r\n\t\twbFilename.setLayoutData(fdbFilename);\r\n\r\n\t\twFilename=new TextVar(transMeta, wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wFilename);\r\n\t\twFilename.addModifyListener(lsMod);\r\n\t\tfdFilename=new FormData();\r\n\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdFilename.top  = new FormAttachment(0, margin);\r\n\t\tfdFilename.right= new FormAttachment(wbFilename, -margin);\r\n\t\twFilename.setLayoutData(fdFilename);\r\n\t\t\r\n\r\n\t\t// Create Parent Folder\r\n\t\twlCreateParentFolder=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlCreateParentFolder.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.CreateParentFolder.Label\"));\r\n \t\tprops.setLook(wlCreateParentFolder);\r\n\t\tfdlCreateParentFolder=new FormData();\r\n\t\tfdlCreateParentFolder.left = new FormAttachment(0, 0);\r\n\t\tfdlCreateParentFolder.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdlCreateParentFolder.right= new FormAttachment(middle, -margin);\r\n\t\twlCreateParentFolder.setLayoutData(fdlCreateParentFolder);\r\n\t\twCreateParentFolder=new Button(wFileComp, SWT.CHECK );\r\n\t\twCreateParentFolder.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.CreateParentFolder.Tooltip\"));\r\n \t\tprops.setLook(wCreateParentFolder);\r\n\t\tfdCreateParentFolder=new FormData();\r\n\t\tfdCreateParentFolder.left = new FormAttachment(middle, 0);\r\n\t\tfdCreateParentFolder.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdCreateParentFolder.right= new FormAttachment(100, 0);\r\n\t\twCreateParentFolder.setLayoutData(fdCreateParentFolder);\r\n\t\twCreateParentFolder.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// Open new File at Init\r\n\t\twlDoNotOpenNewFileInit=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlDoNotOpenNewFileInit.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.DoNotOpenNewFileInit.Label\"));\r\n \t\tprops.setLook(wlDoNotOpenNewFileInit);\r\n\t\tfdlDoNotOpenNewFileInit=new FormData();\r\n\t\tfdlDoNotOpenNewFileInit.left = new FormAttachment(0, 0);\r\n\t\tfdlDoNotOpenNewFileInit.top  = new FormAttachment(wCreateParentFolder, margin);\r\n\t\tfdlDoNotOpenNewFileInit.right= new FormAttachment(middle, -margin);\r\n\t\twlDoNotOpenNewFileInit.setLayoutData(fdlDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit=new Button(wFileComp, SWT.CHECK );\r\n\t\twDoNotOpenNewFileInit.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.DoNotOpenNewFileInit.Tooltip\"));\r\n \t\tprops.setLook(wDoNotOpenNewFileInit);\r\n\t\tfdDoNotOpenNewFileInit=new FormData();\r\n\t\tfdDoNotOpenNewFileInit.left = new FormAttachment(middle, 0);\r\n\t\tfdDoNotOpenNewFileInit.top  = new FormAttachment(wCreateParentFolder, margin);\r\n\t\tfdDoNotOpenNewFileInit.right= new FormAttachment(100, 0);\r\n\t\twDoNotOpenNewFileInit.setLayoutData(fdDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t\r\n\t\t// Extension line\r\n\t\twlExtension=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlExtension.setText(BaseMessages.getString(PKG, \"System.Label.Extension\"));\r\n \t\tprops.setLook(wlExtension);\r\n\t\tfdlExtension=new FormData();\r\n\t\tfdlExtension.left = new FormAttachment(0, 0);\r\n\t\tfdlExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdlExtension.right= new FormAttachment(middle, -margin);\r\n\t\twlExtension.setLayoutData(fdlExtension);\r\n\t\twExtension=new TextVar(transMeta,wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twExtension.setText(\"\");\r\n \t\tprops.setLook(wExtension);\r\n\t\twExtension.addModifyListener(lsMod);\r\n\t\tfdExtension=new FormData();\r\n\t\tfdExtension.left = new FormAttachment(middle, 0);\r\n\t\tfdExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdExtension.right= new FormAttachment(wbFilename, -margin);\r\n\t\twExtension.setLayoutData(fdExtension);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddStepnr=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddStepnr.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddStepnr.Label\"));\r\n \t\tprops.setLook(wlAddStepnr);\r\n\t\tfdlAddStepnr=new FormData();\r\n\t\tfdlAddStepnr.left = new FormAttachment(0, 0);\r\n\t\tfdlAddStepnr.top  = new FormAttachment(wExtension, margin);\r\n\t\tfdlAddStepnr.right= new FormAttachment(middle, -margin);\r\n\t\twlAddStepnr.setLayoutData(fdlAddStepnr);\r\n\t\twAddStepnr=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddStepnr);\r\n\t\tfdAddStepnr=new FormData();\r\n\t\tfdAddStepnr.left = new FormAttachment(middle, 0);\r\n\t\tfdAddStepnr.top  = new FormAttachment(wExtension, margin);\r\n\t\tfdAddStepnr.right= new FormAttachment(100, 0);\r\n\t\twAddStepnr.setLayoutData(fdAddStepnr);\r\n\t\twAddStepnr.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddDate=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddDate.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddDate.Label\"));\r\n \t\tprops.setLook(wlAddDate);\r\n\t\tfdlAddDate=new FormData();\r\n\t\tfdlAddDate.left = new FormAttachment(0, 0);\r\n\t\tfdlAddDate.top  = new FormAttachment(wAddStepnr, margin);\r\n\t\tfdlAddDate.right= new FormAttachment(middle, -margin);\r\n\t\twlAddDate.setLayoutData(fdlAddDate);\r\n\t\twAddDate=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddDate);\r\n\t\tfdAddDate=new FormData();\r\n\t\tfdAddDate.left = new FormAttachment(middle, 0);\r\n\t\tfdAddDate.top  = new FormAttachment(wAddStepnr, margin);\r\n\t\tfdAddDate.right= new FormAttachment(100, 0);\r\n\t\twAddDate.setLayoutData(fdAddDate);\r\n\t\twAddDate.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\t// System.out.println(\"wAddDate.getSelection()=\"+wAddDate.getSelection());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Create multi-part file?\r\n\t\twlAddTime=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddTime.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddTime.Label\"));\r\n \t\tprops.setLook(wlAddTime);\r\n\t\tfdlAddTime=new FormData();\r\n\t\tfdlAddTime.left = new FormAttachment(0, 0);\r\n\t\tfdlAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdlAddTime.right= new FormAttachment(middle, -margin);\r\n\t\twlAddTime.setLayoutData(fdlAddTime);\r\n\t\twAddTime=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddTime);\r\n\t\tfdAddTime=new FormData();\r\n\t\tfdAddTime.left = new FormAttachment(middle, 0);\r\n\t\tfdAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdAddTime.right= new FormAttachment(100, 0);\r\n\t\twAddTime.setLayoutData(fdAddTime);\r\n\t\twAddTime.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Specify date time format?\r\n\t\twlSpecifyFormat=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlSpecifyFormat.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.SpecifyFormat.Label\"));\r\n\t\tprops.setLook(wlSpecifyFormat);\r\n\t\tfdlSpecifyFormat=new FormData();\r\n\t\tfdlSpecifyFormat.left = new FormAttachment(0, 0);\r\n\t\tfdlSpecifyFormat.top  = new FormAttachment(wAddTime, margin);\r\n\t\tfdlSpecifyFormat.right= new FormAttachment(middle, -margin);\r\n\t\twlSpecifyFormat.setLayoutData(fdlSpecifyFormat);\r\n\t\twSpecifyFormat=new Button(wFileComp, SWT.CHECK);\r\n\t\tprops.setLook(wSpecifyFormat);\r\n\t\twSpecifyFormat.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.SpecifyFormat.Tooltip\"));\r\n\t    fdSpecifyFormat=new FormData();\r\n\t\tfdSpecifyFormat.left = new FormAttachment(middle, 0);\r\n\t\tfdSpecifyFormat.top  = new FormAttachment(wAddTime, margin);\r\n\t\tfdSpecifyFormat.right= new FormAttachment(100, 0);\r\n\t\twSpecifyFormat.setLayoutData(fdSpecifyFormat);\r\n\t\twSpecifyFormat.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\tsetDateTimeFormat();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t\r\n\t\t//\tPrepare a list of possible DateTimeFormats...\r\n\t\tString dats[] = Const.getDateFormats();\r\n\t\t\r\n \t\t// DateTimeFormat\r\n\t\twlDateTimeFormat=new Label(wFileComp, SWT.RIGHT);\r\n        wlDateTimeFormat.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.DateTimeFormat.Label\"));\r\n        props.setLook(wlDateTimeFormat);\r\n        fdlDateTimeFormat=new FormData();\r\n        fdlDateTimeFormat.left = new FormAttachment(0, 0);\r\n        fdlDateTimeFormat.top  = new FormAttachment(wSpecifyFormat, margin);\r\n        fdlDateTimeFormat.right= new FormAttachment(middle, -margin);\r\n        wlDateTimeFormat.setLayoutData(fdlDateTimeFormat);\r\n        wDateTimeFormat=new CCombo(wFileComp, SWT.BORDER | SWT.READ_ONLY);\r\n        wDateTimeFormat.setEditable(true);\r\n        props.setLook(wDateTimeFormat);\r\n        wDateTimeFormat.addModifyListener(lsMod);\r\n        fdDateTimeFormat=new FormData();\r\n        fdDateTimeFormat.left = new FormAttachment(middle, 0);\r\n        fdDateTimeFormat.top  = new FormAttachment(wSpecifyFormat, margin);\r\n        fdDateTimeFormat.right= new FormAttachment(100, 0);\r\n        wDateTimeFormat.setLayoutData(fdDateTimeFormat);\r\n        for (int x=0;x<dats.length;x++) wDateTimeFormat.add(dats[x]);\r\n        \r\n\r\n\r\n\t\twbShowFiles=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\r\n\t\tprops.setLook(wbShowFiles);\r\n\t\twbShowFiles.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.ShowFiles.Button\"));\r\n\t\tfdbShowFiles=new FormData();\r\n\t\tfdbShowFiles.left = new FormAttachment(middle, 0);\r\n\t\tfdbShowFiles.top  = new FormAttachment(wDateTimeFormat, margin*3);\r\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\r\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tExcelOutputMeta tfoi = new ExcelOutputMeta();\r\n\t\t\t\tgetInfo(tfoi);\r\n\t\t\t\tString files[] = tfoi.getFiles(transMeta);\r\n\t\t\t\tif (files!=null && files.length>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, files, BaseMessages.getString(PKG, \"ExcelOutputDialog.SelectOutputFiles.DialogTitle\"), BaseMessages.getString(PKG, \"ExcelOutputDialog.SelectOutputFiles.DialogMessage\"));\r\n\t\t\t\t\tesd.setViewOnly();\r\n\t\t\t\t\tesd.open();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\r\n\t\t\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"ExcelOutputDialog.NoFilesFound.DialogMessage\"));\r\n\t\t\t\t\tmb.setText(BaseMessages.getString(PKG, \"System.Dialog.Error.Title\"));\r\n\t\t\t\t\tmb.open(); \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t);\r\n\t\t\r\n\t\t\r\n\t\t// Add File to the result files name\r\n\t\twlAddToResult=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddToResult.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddFileToResult.Label\"));\r\n\t\tprops.setLook(wlAddToResult);\r\n\t\tfdlAddToResult=new FormData();\r\n\t\tfdlAddToResult.left  = new FormAttachment(0, 0);\r\n\t\tfdlAddToResult.top   = new FormAttachment(wbShowFiles, 2*margin);\r\n\t\tfdlAddToResult.right = new FormAttachment(middle, -margin);\r\n\t\twlAddToResult.setLayoutData(fdlAddToResult);\r\n\t\twAddToResult=new Button(wFileComp, SWT.CHECK);\r\n\t\twAddToResult.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddFileToResult.Tooltip\"));\r\n \t\tprops.setLook(wAddToResult);\r\n\t\tfdAddToResult=new FormData();\r\n\t\tfdAddToResult.left  = new FormAttachment(middle, 0);\r\n\t\tfdAddToResult.top   = new FormAttachment(wbShowFiles, 2*margin);\r\n\t\tfdAddToResult.right = new FormAttachment(100, 0);\r\n\t\twAddToResult.setLayoutData(fdAddToResult);\r\n\t\tSelectionAdapter lsSelR = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n\t\twAddToResult.addSelectionListener(lsSelR);\r\n\r\n\t\r\n\t\tfdFileComp=new FormData();\r\n\t\tfdFileComp.left  = new FormAttachment(0, 0);\r\n\t\tfdFileComp.top   = new FormAttachment(0, 0);\r\n\t\tfdFileComp.right = new FormAttachment(100, 0);\r\n\t\tfdFileComp.bottom= new FormAttachment(100, 0);\r\n\t\twFileComp.setLayoutData(fdFileComp);\r\n\t\r\n\t\twFileComp.layout();\r\n\t\twFileTab.setControl(wFileComp);\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF FILE TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n\t\t//////////////////////////\r\n\t\t// START OF CONTENT TAB///\r\n\t\t///\r\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twContentTab.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.ContentTab.TabTitle\"));\r\n\r\n\t\tFormLayout contentLayout = new FormLayout ();\r\n\t\tcontentLayout.marginWidth  = 3;\r\n\t\tcontentLayout.marginHeight = 3;\r\n\t\t\r\n\t\tComposite wContentComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wContentComp);\r\n\t\twContentComp.setLayout(contentLayout);\r\n\t\t\r\n\t\t// Append checkbox\r\n\t\twlAppend=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlAppend.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Append.Label\"));\r\n \t\tprops.setLook(wlAppend);\r\n\t\tfdlAppend=new FormData();\r\n\t\tfdlAppend.left = new FormAttachment(0, 0);\r\n\t\tfdlAppend.top  = new FormAttachment(0, 0);\r\n\t\tfdlAppend.right= new FormAttachment(middle, -margin);\r\n\t\twlAppend.setLayoutData(fdlAppend);\r\n\t\twAppend=new Button(wContentComp, SWT.CHECK);\r\n \t\tprops.setLook(wAppend);\r\n \t\twAppend.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Append.Tooltip\"));\r\n\t\tfdAppend=new FormData();\r\n\t\tfdAppend.left = new FormAttachment(middle, 0);\r\n\t\tfdAppend.top  = new FormAttachment(0, 0);\r\n\t\tfdAppend.right= new FormAttachment(100, 0);\r\n\t\twAppend.setLayoutData(fdAppend);\r\n\t\twAppend.addSelectionListener(new SelectionAdapter() \r\n\t        {\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent arg0)\r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\r\n\t\t\r\n\r\n\r\n\t\twlHeader=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlHeader.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Header.Label\"));\r\n \t\tprops.setLook(wlHeader);\r\n\t\tfdlHeader=new FormData();\r\n\t\tfdlHeader.left = new FormAttachment(0, 0);\r\n\t\tfdlHeader.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdlHeader.right= new FormAttachment(middle, -margin);\r\n\t\twlHeader.setLayoutData(fdlHeader);\r\n\t\twHeader=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wHeader);\r\n\t\tfdHeader=new FormData();\r\n\t\tfdHeader.left = new FormAttachment(middle, 0);\r\n\t\tfdHeader.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdHeader.right= new FormAttachment(100, 0);\r\n\t\twHeader.setLayoutData(fdHeader);\r\n\t\twHeader.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twlFooter=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlFooter.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Footer.Label\"));\r\n \t\tprops.setLook(wlFooter);\r\n\t\tfdlFooter=new FormData();\r\n\t\tfdlFooter.left = new FormAttachment(0, 0);\r\n\t\tfdlFooter.top  = new FormAttachment(wHeader, margin);\r\n\t\tfdlFooter.right= new FormAttachment(middle, -margin);\r\n\t\twlFooter.setLayoutData(fdlFooter);\r\n\t\twFooter=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wFooter);\r\n\t\tfdFooter=new FormData();\r\n\t\tfdFooter.left = new FormAttachment(middle, 0);\r\n\t\tfdFooter.top  = new FormAttachment(wHeader, margin);\r\n\t\tfdFooter.right= new FormAttachment(100, 0);\r\n\t\twFooter.setLayoutData(fdFooter);\r\n\t\twFooter.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n        wlEncoding=new Label(wContentComp, SWT.RIGHT);\r\n        wlEncoding.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Encoding.Label\"));\r\n        props.setLook(wlEncoding);\r\n        fdlEncoding=new FormData();\r\n        fdlEncoding.left = new FormAttachment(0, 0);\r\n        fdlEncoding.top  = new FormAttachment(wFooter, margin);\r\n        fdlEncoding.right= new FormAttachment(middle, -margin);\r\n        wlEncoding.setLayoutData(fdlEncoding);\r\n        wEncoding=new CCombo(wContentComp, SWT.BORDER | SWT.READ_ONLY);\r\n        wEncoding.setEditable(true);\r\n        props.setLook(wEncoding);\r\n        wEncoding.addModifyListener(lsMod);\r\n        fdEncoding=new FormData();\r\n        fdEncoding.left = new FormAttachment(middle, 0);\r\n        fdEncoding.top  = new FormAttachment(wFooter, margin);\r\n        fdEncoding.right= new FormAttachment(100, 0);\r\n        wEncoding.setLayoutData(fdEncoding);\r\n        wEncoding.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                    shell.setCursor(busy);\r\n                    setEncodings();\r\n                    shell.setCursor(null);\r\n                    busy.dispose();\r\n                }\r\n            }\r\n        );\r\n\r\n\t\twlSplitEvery=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlSplitEvery.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.SplitEvery.Label\"));\r\n \t\tprops.setLook(wlSplitEvery);\r\n\t\tfdlSplitEvery=new FormData();\r\n\t\tfdlSplitEvery.left = new FormAttachment(0, 0);\r\n\t\tfdlSplitEvery.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdlSplitEvery.right= new FormAttachment(middle, -margin);\r\n\t\twlSplitEvery.setLayoutData(fdlSplitEvery);\r\n\t\twSplitEvery=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wSplitEvery);\r\n\t\twSplitEvery.addModifyListener(lsMod);\r\n\t\tfdSplitEvery=new FormData();\r\n\t\tfdSplitEvery.left = new FormAttachment(middle, 0);\r\n\t\tfdSplitEvery.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdSplitEvery.right= new FormAttachment(100, 0);\r\n\t\twSplitEvery.setLayoutData(fdSplitEvery);\r\n\t\t\r\n\r\n\r\n\r\n\t\t// Sheet name line\n\t\twlSheetname=new Label(wContentComp, SWT.RIGHT);\n\t\twlSheetname.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Sheetname.Label\"));\n\t\tprops.setLook(wlSheetname);\n\t\tfdlSheetname=new FormData();\n\t\tfdlSheetname.left = new FormAttachment(0, 0);\n\t\tfdlSheetname.top  = new FormAttachment(wSplitEvery, margin);\n\t\tfdlSheetname.right= new FormAttachment(middle, -margin);\n\t\twlSheetname.setLayoutData(fdlSheetname);\n\t\twSheetname=new TextVar(transMeta, wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSheetname.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Sheetname.Tooltip\"));\n\t\tprops.setLook(wSheetname);\n\t\twSheetname.addModifyListener(lsMod);\n\t\tfdSheetname=new FormData();\n\t\tfdSheetname.left = new FormAttachment(middle, 0);\n\t\tfdSheetname.top  = new FormAttachment(wSplitEvery, margin);\n\t\tfdSheetname.right= new FormAttachment(100, 0);\n\t\twSheetname.setLayoutData(fdSheetname);\r\n\r\n\r\n\t\t// Protect Sheet?\r\n\t\twlProtectSheet=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlProtectSheet.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.ProtectSheet.Label\"));\r\n\t\tprops.setLook(wlProtectSheet);\r\n\t\tfdlProtectSheet=new FormData();\r\n\t\tfdlProtectSheet.left = new FormAttachment(0, 0);\r\n\t\tfdlProtectSheet.top  = new FormAttachment(wSheetname, margin);\r\n\t\tfdlProtectSheet.right= new FormAttachment(middle, -margin);\r\n\t\twlProtectSheet.setLayoutData(fdlProtectSheet);\r\n\t\twProtectSheet=new Button(wContentComp, SWT.CHECK);\r\n\t\tprops.setLook(wProtectSheet);\r\n\t\tfdProtectSheet=new FormData();\r\n\t\tfdProtectSheet.left = new FormAttachment(middle, 0);\r\n\t\tfdProtectSheet.top  = new FormAttachment(wSheetname, margin);\r\n\t\tfdProtectSheet.right= new FormAttachment(100, 0);\r\n\t\twProtectSheet.setLayoutData(fdProtectSheet);\r\n\t\twProtectSheet.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tEnablePassword();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t);\r\n\r\n\n\t\t// Password line\n\t\twlPassword=new Label(wContentComp, SWT.RIGHT);\n\t\twlPassword.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Password.Label\"));\n\t\tprops.setLook(wlPassword);\n\t\tfdlPassword=new FormData();\n\t\tfdlPassword.left = new FormAttachment(0, 0);\n\t\tfdlPassword.top  = new FormAttachment(wProtectSheet, margin);\n\t\tfdlPassword.right= new FormAttachment(middle, -margin);\n\t\twlPassword.setLayoutData(fdlPassword);\n\t\twPassword=new TextVar(transMeta, wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.PASSWORD);\n\t\twPassword.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Password.Tooltip\"));\n\t\tprops.setLook(wPassword);\n\t\twPassword.setEchoChar('*');\n\t\twPassword.addModifyListener(lsMod);\n\t\tfdPassword=new FormData();\n\t\tfdPassword.left = new FormAttachment(middle, 0);\n\t\tfdPassword.top  = new FormAttachment(wProtectSheet, margin);\n\t\tfdPassword.right= new FormAttachment(100, 0);\n\t\twPassword.setLayoutData(fdPassword);\r\n\r\n\t\t// auto size columns?\r\n\t\twlAutoSize=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlAutoSize.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AutoSize.Label\"));\r\n\t\tprops.setLook(wlAutoSize);\r\n\t\tfdlAutoSize=new FormData();\r\n\t\tfdlAutoSize.left = new FormAttachment(0, 0);\r\n\t\tfdlAutoSize.top  = new FormAttachment(wPassword, margin);\r\n\t\tfdlAutoSize.right= new FormAttachment(middle, -margin);\r\n\t\twlAutoSize.setLayoutData(fdlAutoSize);\r\n\t\twAutoSize=new Button(wContentComp, SWT.CHECK);\r\n\t\tprops.setLook(wAutoSize);\r\n\t\twAutoSize.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AutoSize.Tooltip\"));\r\n\t    fdAutoSize=new FormData();\r\n\t\tfdAutoSize.left = new FormAttachment(middle, 0);\r\n\t\tfdAutoSize.top  = new FormAttachment(wPassword, margin);\r\n\t\tfdAutoSize.right= new FormAttachment(100, 0);\r\n\t\twAutoSize.setLayoutData(fdAutoSize);\r\n\t\twAutoSize.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tEnableAutoSize();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\t\t\r\n\t    // write null values as blank cells ?\r\n\t\twlNullIsBlank=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlNullIsBlank.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.NullIsBlank.Label\"));\r\n        props.setLook(wlNullIsBlank);\r\n        fdlNullIsBlank=new FormData();\r\n        fdlNullIsBlank.left = new FormAttachment(0, 0);\r\n        fdlNullIsBlank.top  = new FormAttachment(wAutoSize, margin);\r\n        fdlNullIsBlank.right= new FormAttachment(middle, -margin);\r\n        wlNullIsBlank.setLayoutData(fdlNullIsBlank);\r\n        wNullIsBlank=new Button(wContentComp, SWT.CHECK);\r\n        props.setLook(wNullIsBlank);\r\n        wNullIsBlank.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.NullIsBlank.Tooltip\"));\r\n        fdNullIsBlank=new FormData();\r\n        fdNullIsBlank.left = new FormAttachment(middle, 0);\r\n        fdNullIsBlank.top  = new FormAttachment(wAutoSize, margin);\r\n        fdNullIsBlank.right= new FormAttachment(100, 0);\r\n        wNullIsBlank.setLayoutData(fdNullIsBlank);\t\t\r\n\t\t\r\n\t\t\r\n\t\t// ///////////////////////////////\r\n\t\t// START OF Template Group GROUP //\r\n\t\t///////////////////////////////// \r\n\r\n\t\twTemplateGroup= new Group(wContentComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wTemplateGroup);\r\n\t\twTemplateGroup.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.TemplateGroup.Label\"));\r\n\t\t\r\n\t\tFormLayout TemplateGroupgroupLayout = new FormLayout();\r\n\t\tTemplateGroupgroupLayout.marginWidth = 10;\r\n\t\tTemplateGroupgroupLayout.marginHeight = 10;\r\n\t\twTemplateGroup.setLayout(TemplateGroupgroupLayout);\r\n\t\t\r\n\t\t// Use template\r\n\t\twlTemplate=new Label(wTemplateGroup, SWT.RIGHT);\r\n\t\twlTemplate.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Template.Label\"));\r\n \t\tprops.setLook(wlTemplate);\r\n\t\tfdlTemplate=new FormData();\r\n\t\tfdlTemplate.left = new FormAttachment(0, 0);\r\n\t\tfdlTemplate.top  = new FormAttachment(wNullIsBlank, margin);\r\n\t\tfdlTemplate.right= new FormAttachment(middle, -margin);\r\n\t\twlTemplate.setLayoutData(fdlTemplate);\r\n\t\twTemplate=new Button(wTemplateGroup, SWT.CHECK );\r\n \t\tprops.setLook(wTemplate);\r\n\t\tfdTemplate=new FormData();\r\n\t\tfdTemplate.left = new FormAttachment(middle, 0);\r\n\t\tfdTemplate.top  = new FormAttachment(wNullIsBlank, margin);\r\n\t\tfdTemplate.right= new FormAttachment(100, 0);\r\n\t\twTemplate.setLayoutData(fdTemplate);\r\n\t\twTemplate.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tEnableTemplate();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// TemplateFilename line\r\n\t\twlTemplateFilename=new Label(wTemplateGroup, SWT.RIGHT);\r\n\t\twlTemplateFilename.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.TemplateFilename.Label\"));\r\n \t\tprops.setLook(wlTemplateFilename);\r\n\t\tfdlTemplateFilename=new FormData();\r\n\t\tfdlTemplateFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlTemplateFilename.top  = new FormAttachment(wTemplate, margin);\r\n\t\tfdlTemplateFilename.right= new FormAttachment(middle, -margin);\r\n\t\twlTemplateFilename.setLayoutData(fdlTemplateFilename);\r\n\r\n\t\twbTemplateFilename=new Button(wTemplateGroup, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbTemplateFilename);\r\n\t\twbTemplateFilename.setText(BaseMessages.getString(PKG, \"System.Button.Browse\"));\r\n\t\tfdbTemplateFilename=new FormData();\r\n\t\tfdbTemplateFilename.right= new FormAttachment(100, 0);\r\n\t\tfdbTemplateFilename.top  = new FormAttachment(wTemplate, 0);\r\n\t\twbTemplateFilename.setLayoutData(fdbTemplateFilename);\r\n\r\n\t\twTemplateFilename=new TextVar(transMeta, wTemplateGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wTemplateFilename);\r\n\t\twTemplateFilename.addModifyListener(lsMod);\r\n\t\tfdTemplateFilename=new FormData();\r\n\t\tfdTemplateFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdTemplateFilename.top  = new FormAttachment(wTemplate, margin);\r\n\t\tfdTemplateFilename.right= new FormAttachment(wbTemplateFilename, -margin);\r\n\t\twTemplateFilename.setLayoutData(fdTemplateFilename);\r\n\r\n\t\t// Template Append\r\n\t\twlTemplateAppend=new Label(wTemplateGroup, SWT.RIGHT);\r\n\t\twlTemplateAppend.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.TemplateAppend.Label\"));\r\n \t\tprops.setLook(wlTemplateAppend);\r\n\t\tfdlTemplateAppend=new FormData();\r\n\t\tfdlTemplateAppend.left = new FormAttachment(0, 0);\r\n\t\tfdlTemplateAppend.top  = new FormAttachment(wTemplateFilename, margin);\r\n\t\tfdlTemplateAppend.right= new FormAttachment(middle, -margin);\r\n\t\twlTemplateAppend.setLayoutData(fdlTemplateAppend);\r\n\t\twTemplateAppend=new Button(wTemplateGroup, SWT.CHECK );\r\n \t\tprops.setLook(wTemplateAppend);\r\n\t\tfdTemplateAppend=new FormData();\r\n\t\tfdTemplateAppend.left = new FormAttachment(middle, 0);\r\n\t\tfdTemplateAppend.top  = new FormAttachment(wTemplateFilename, margin);\r\n\t\tfdTemplateAppend.right= new FormAttachment(100, 0);\r\n\t\twTemplateAppend.setLayoutData(fdTemplateAppend);\r\n\t\twTemplateAppend.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tfdTemplateGroup= new FormData();\r\n\t\tfdTemplateGroup.left = new FormAttachment(0, margin);\r\n\t\tfdTemplateGroup.top = new FormAttachment(wNullIsBlank, margin);\r\n\t\tfdTemplateGroup.right = new FormAttachment(100, -margin);\r\n\t\twTemplateGroup.setLayoutData(fdTemplateGroup);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Template Group GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\t\r\n\r\n\r\n\t\tfdContentComp = new FormData();\r\n\t\tfdContentComp.left  = new FormAttachment(0, 0);\r\n\t\tfdContentComp.top   = new FormAttachment(0, 0);\r\n\t\tfdContentComp.right = new FormAttachment(100, 0);\r\n\t\tfdContentComp.bottom= new FormAttachment(100, 0);\r\n\t\twContentComp.setLayoutData(fdContentComp);\r\n\r\n\t\twContentComp.layout();\r\n\t\twContentTab.setControl(wContentComp);\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF CONTENT TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n\t\t\r\n\t\t// Custom tab...\r\n\t\t//\r\n\t\twCustomTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twCustomTab.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.CustomTab.TabTitle\"));\r\n\t\t\r\n\t\tFormLayout CustomLayout = new FormLayout ();\r\n\t\tCustomLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tCustomLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tComposite wCustomComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\twCustomComp.setLayout(CustomLayout);\r\n \t\tprops.setLook(wCustomComp);\r\n \t\t\r\n \t\t\r\n \t   // ///////////////////////////////\r\n\t\t// START OF Header Font GROUP //\r\n\t\t///////////////////////////////// \r\n\r\n\t\twFontHeaderGroup= new Group(wCustomComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wFontHeaderGroup);\r\n\t\twFontHeaderGroup.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.FontHeaderGroup.Label\"));\r\n\r\n\t\tFormLayout FontHeadergroupLayout = new FormLayout();\r\n\t\tFontHeadergroupLayout.marginWidth = 10;\r\n\t\tFontHeadergroupLayout.marginHeight = 10;\r\n\t\twFontHeaderGroup.setLayout(FontHeadergroupLayout);\r\n\t\t\r\n\t\t// Header font name\r\n\t\twlHeaderFontName=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n        wlHeaderFontName.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderFontName.Label\"));\r\n        props.setLook(wlHeaderFontName);\r\n        fdlHeaderFontName=new FormData();\r\n        fdlHeaderFontName.left = new FormAttachment(0, 0);\r\n        fdlHeaderFontName.top  = new FormAttachment(0, margin);\r\n        fdlHeaderFontName.right= new FormAttachment(middle, -margin);\r\n        wlHeaderFontName.setLayoutData(fdlHeaderFontName);\r\n        wHeaderFontName=new CCombo(wFontHeaderGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wHeaderFontName.setItems(ExcelOutputMeta.font_name_desc);\r\n        props.setLook(wHeaderFontName);\r\n        wHeaderFontName.addModifyListener(lsMod);\r\n        fdHeaderFontName=new FormData();\r\n        fdHeaderFontName.left = new FormAttachment(middle, 0);\r\n        fdHeaderFontName.top  = new FormAttachment(0, margin);\r\n        fdHeaderFontName.right= new FormAttachment(100, 0);\r\n        wHeaderFontName.setLayoutData(fdHeaderFontName);\r\n        \r\n    \t// Header font size\r\n\t\twlHeaderFontSize=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n\t\twlHeaderFontSize.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderFontSize.Label\"));\r\n\t\tprops.setLook(wlHeaderFontSize);\r\n\t\tfdlHeaderFontSize=new FormData();\r\n\t\tfdlHeaderFontSize.left = new FormAttachment(0, 0);\r\n\t\tfdlHeaderFontSize.top  = new FormAttachment(wHeaderFontName, margin);\r\n\t\tfdlHeaderFontSize.right= new FormAttachment(middle, -margin);\r\n\t\twlHeaderFontSize.setLayoutData(fdlHeaderFontSize);\r\n\t\twHeaderFontSize=new TextVar(transMeta, wFontHeaderGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twHeaderFontSize.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderFontSize.Tooltip\"));\r\n\t\tprops.setLook(wHeaderFontSize);\r\n\t\twHeaderFontSize.addModifyListener(lsMod);\r\n\t\tfdHeaderFontSize=new FormData();\r\n\t\tfdHeaderFontSize.left = new FormAttachment(middle, 0);\r\n\t\tfdHeaderFontSize.top  = new FormAttachment(wHeaderFontName, margin);\r\n\t\tfdHeaderFontSize.right= new FormAttachment(100, 0);\r\n\t\twHeaderFontSize.setLayoutData(fdHeaderFontSize);\r\n\t\t\r\n\t\t// Header font bold?\r\n\t\twlHeaderFontBold=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n\t\twlHeaderFontBold.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderFontBold.Label\"));\r\n \t\tprops.setLook(wlHeaderFontBold);\r\n\t\tfdlHeaderFontBold=new FormData();\r\n\t\tfdlHeaderFontBold.left = new FormAttachment(0, 0);\r\n\t\tfdlHeaderFontBold.top  = new FormAttachment(wHeaderFontSize, margin);\r\n\t\tfdlHeaderFontBold.right= new FormAttachment(middle, -margin);\r\n\t\twlHeaderFontBold.setLayoutData(fdlHeaderFontBold);\r\n\t\twHeaderFontBold=new Button(wFontHeaderGroup, SWT.CHECK);\r\n \t\tprops.setLook(wHeaderFontBold);\r\n\t\tfdHeaderFontBold=new FormData();\r\n\t\tfdHeaderFontBold.left = new FormAttachment(middle, 0);\r\n\t\tfdHeaderFontBold.top  = new FormAttachment(wHeaderFontSize, margin);\r\n\t\tfdHeaderFontBold.right= new FormAttachment(100, 0);\r\n\t\twHeaderFontBold.setLayoutData(fdHeaderFontBold);\r\n\t\twHeaderFontBold.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Header font bold?\r\n\t\twlHeaderFontItalic=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n\t\twlHeaderFontItalic.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderFontItalic.Label\"));\r\n \t\tprops.setLook(wlHeaderFontItalic);\r\n\t\tfdlHeaderFontItalic=new FormData();\r\n\t\tfdlHeaderFontItalic.left = new FormAttachment(0, 0);\r\n\t\tfdlHeaderFontItalic.top  = new FormAttachment(wHeaderFontBold, margin);\r\n\t\tfdlHeaderFontItalic.right= new FormAttachment(middle, -margin);\r\n\t\twlHeaderFontItalic.setLayoutData(fdlHeaderFontItalic);\r\n\t\twHeaderFontItalic=new Button(wFontHeaderGroup, SWT.CHECK);\r\n \t\tprops.setLook(wHeaderFontItalic);\r\n\t\tfdHeaderFontItalic=new FormData();\r\n\t\tfdHeaderFontItalic.left = new FormAttachment(middle, 0);\r\n\t\tfdHeaderFontItalic.top  = new FormAttachment(wHeaderFontBold, margin);\r\n\t\tfdHeaderFontItalic.right= new FormAttachment(100, 0);\r\n\t\twHeaderFontItalic.setLayoutData(fdHeaderFontItalic);\r\n\t\twHeaderFontItalic.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t\r\n\t\t// Font header uderline?\r\n\t\twlHeaderFontUnderline=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n        wlHeaderFontUnderline.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderFontUnderline.Label\"));\r\n        props.setLook(wlHeaderFontUnderline);\r\n        fdlHeaderFontUnderline=new FormData();\r\n        fdlHeaderFontUnderline.left = new FormAttachment(0, 0);\r\n        fdlHeaderFontUnderline.top  = new FormAttachment(wHeaderFontItalic, margin);\r\n        fdlHeaderFontUnderline.right= new FormAttachment(middle, -margin);\r\n        wlHeaderFontUnderline.setLayoutData(fdlHeaderFontUnderline);\r\n        wHeaderFontUnderline=new CCombo(wFontHeaderGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wHeaderFontUnderline.setItems(ExcelOutputMeta.font_underline_desc);\r\n        props.setLook(wHeaderFontUnderline);\r\n        wHeaderFontUnderline.addModifyListener(lsMod);\r\n        fdHeaderFontUnderline=new FormData();\r\n        fdHeaderFontUnderline.left = new FormAttachment(middle, 0);\r\n        fdHeaderFontUnderline.top  = new FormAttachment(wHeaderFontItalic, margin);\r\n        fdHeaderFontUnderline.right= new FormAttachment(100, 0);\r\n        wHeaderFontUnderline.setLayoutData(fdHeaderFontUnderline);\r\n        \r\n\t\t// Font header orientation\r\n\t\twlHeaderFontOrientation=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n        wlHeaderFontOrientation.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderFontOrientation.Label\"));\r\n        props.setLook(wlHeaderFontOrientation);\r\n        fdlHeaderFontOrientation=new FormData();\r\n        fdlHeaderFontOrientation.left = new FormAttachment(0, 0);\r\n        fdlHeaderFontOrientation.top  = new FormAttachment(wHeaderFontUnderline, margin);\r\n        fdlHeaderFontOrientation.right= new FormAttachment(middle, -margin);\r\n        wlHeaderFontOrientation.setLayoutData(fdlHeaderFontOrientation);\r\n        wHeaderFontOrientation=new CCombo(wFontHeaderGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wHeaderFontOrientation.setItems(ExcelOutputMeta.font_orientation_desc);\r\n        props.setLook(wHeaderFontOrientation);\r\n        wHeaderFontOrientation.addModifyListener(lsMod);\r\n        fdHeaderFontOrientation=new FormData();\r\n        fdHeaderFontOrientation.left = new FormAttachment(middle, 0);\r\n        fdHeaderFontOrientation.top  = new FormAttachment(wHeaderFontUnderline, margin);\r\n        fdHeaderFontOrientation.right= new FormAttachment(100, 0);\r\n        wHeaderFontOrientation.setLayoutData(fdHeaderFontOrientation);\r\n\t\t\r\n\t\t\r\n\t\t// Font header color\r\n\t\twlHeaderFontColor=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n        wlHeaderFontColor.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderFontColor.Label\"));\r\n        props.setLook(wlHeaderFontColor);\r\n        fdlHeaderFontColor=new FormData();\r\n        fdlHeaderFontColor.left = new FormAttachment(0, 0);\r\n        fdlHeaderFontColor.top  = new FormAttachment(wHeaderFontOrientation, margin);\r\n        fdlHeaderFontColor.right= new FormAttachment(middle, -margin);\r\n        wlHeaderFontColor.setLayoutData(fdlHeaderFontColor);\r\n        \r\n\t\twHeaderFontColor=new CCombo(wFontHeaderGroup, SWT.BORDER | SWT.READ_ONLY);\r\n\t\tprops.setLook(wHeaderFontColor);\r\n\t\tfdHeaderFontColor=new FormData();\r\n\t\tfdHeaderFontColor.left = new FormAttachment(middle, 0);\r\n\t\tfdHeaderFontColor.top  = new FormAttachment(wHeaderFontOrientation, margin);\r\n\t\tfdHeaderFontColor.right= new FormAttachment(100, 0);\r\n\t\twHeaderFontColor.setLayoutData(fdHeaderFontColor);\r\n\t\twHeaderFontColor.setItems(ExcelOutputMeta.font_color_desc);\r\n\t\t\r\n\t\t// Font header background color\r\n\t\twlHeaderBackGroundColor=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n        wlHeaderBackGroundColor.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderBackGroundColor.Label\"));\r\n        props.setLook(wlHeaderBackGroundColor);\r\n        fdlHeaderBackGroundColor=new FormData();\r\n        fdlHeaderBackGroundColor.left = new FormAttachment(0, 0);\r\n        fdlHeaderBackGroundColor.top  = new FormAttachment(wHeaderFontColor, margin);\r\n        fdlHeaderBackGroundColor.right= new FormAttachment(middle, -margin);\r\n        wlHeaderBackGroundColor.setLayoutData(fdlHeaderBackGroundColor);\r\n        \r\n\t\twHeaderBackGroundColor=new CCombo(wFontHeaderGroup, SWT.BORDER | SWT.READ_ONLY);\r\n\t\tprops.setLook(wHeaderBackGroundColor);\r\n\t\tfdHeaderBackGroundColor=new FormData();\r\n\t\tfdHeaderBackGroundColor.left = new FormAttachment(middle, 0);\r\n\t\tfdHeaderBackGroundColor.top  = new FormAttachment(wHeaderFontColor, margin);\r\n\t\tfdHeaderBackGroundColor.right= new FormAttachment(100, 0);\r\n\t\twHeaderBackGroundColor.setLayoutData(fdHeaderBackGroundColor);\r\n\t\twHeaderBackGroundColor.setItems(ExcelOutputMeta.font_color_desc);\r\n\r\n        \r\n    \t// Header font size\r\n\t\twlHeaderRowHeight=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n\t\twlHeaderRowHeight.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderRowHeight.Label\"));\r\n\t\tprops.setLook(wlHeaderRowHeight);\r\n\t\tfdlHeaderRowHeight=new FormData();\r\n\t\tfdlHeaderRowHeight.left = new FormAttachment(0, 0);\r\n\t\tfdlHeaderRowHeight.top  = new FormAttachment(wHeaderBackGroundColor, margin);\r\n\t\tfdlHeaderRowHeight.right= new FormAttachment(middle, -margin);\r\n\t\twlHeaderRowHeight.setLayoutData(fdlHeaderRowHeight);\r\n\t\twHeaderRowHeight=new TextVar(transMeta, wFontHeaderGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twHeaderRowHeight.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderRowHeight.Tooltip\"));\r\n\t\tprops.setLook(wHeaderRowHeight);\r\n\t\twHeaderRowHeight.addModifyListener(lsMod);\r\n\t\tfdHeaderRowHeight=new FormData();\r\n\t\tfdHeaderRowHeight.left = new FormAttachment(middle, 0);\r\n\t\tfdHeaderRowHeight.top  = new FormAttachment(wHeaderBackGroundColor, margin);\r\n\t\tfdHeaderRowHeight.right= new FormAttachment(100, 0);\r\n\t\twHeaderRowHeight.setLayoutData(fdHeaderRowHeight);\r\n\t\t\r\n\t\t// Header Alignment\r\n\t\twlHeaderAlignment=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n        wlHeaderAlignment.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.HeaderAlignment.Label\"));\r\n        props.setLook(wlHeaderAlignment);\r\n        fdlHeaderAlignment=new FormData();\r\n        fdlHeaderAlignment.left = new FormAttachment(0, 0);\r\n        fdlHeaderAlignment.top  = new FormAttachment(wHeaderRowHeight, margin);\r\n        fdlHeaderAlignment.right= new FormAttachment(middle, -margin);\r\n        wlHeaderAlignment.setLayoutData(fdlHeaderAlignment);\r\n        wHeaderAlignment=new CCombo(wFontHeaderGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wHeaderAlignment.setItems(ExcelOutputMeta.font_alignment_desc);\r\n        props.setLook(wHeaderAlignment);\r\n        wHeaderAlignment.addModifyListener(lsMod);\r\n        fdHeaderAlignment=new FormData();\r\n        fdHeaderAlignment.left = new FormAttachment(middle, 0);\r\n        fdHeaderAlignment.top  = new FormAttachment(wHeaderRowHeight, margin);\r\n        fdHeaderAlignment.right= new FormAttachment(100, 0);\r\n        wHeaderAlignment.setLayoutData(fdHeaderAlignment);\r\n\t\t\r\n\r\n\r\n        // Select Image\r\n \t\twbImage=new Button(wFontHeaderGroup, SWT.PUSH| SWT.CENTER);\r\n  \t\tprops.setLook(wbImage);\r\n \t\twbImage.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.AddImage\"));\r\n \t\tfdbImage=new FormData();\r\n \t\tfdbImage.right= new FormAttachment(100, 0);\r\n \t\tfdbImage.top  = new FormAttachment(wHeaderAlignment, margin);\r\n \t\twbImage.setLayoutData(fdbImage);\r\n \t\twbImage.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.png\", \"*.*\"});\r\n\t\t\t\t\tif (wImage.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wImage.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {BaseMessages.getString(PKG, \"ExcelOutputDialog.FileType.PNGFiles\"), BaseMessages.getString(PKG, \"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twImage.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Image line\r\n\t\twlImage=new Label(wFontHeaderGroup, SWT.RIGHT);\r\n\t\twlImage.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.Image.Label\"));\r\n \t\tprops.setLook(wlImage);\r\n\t\tfdlImage=new FormData();\r\n\t\tfdlImage.left = new FormAttachment(0, 0);\r\n\t\tfdlImage.top  = new FormAttachment(wHeaderAlignment, margin);\r\n\t\tfdlImage.right= new FormAttachment(middle, -margin);\r\n\t\twlImage.setLayoutData(fdlImage);\r\n \t\t\r\n \t\t\r\n \t\twImage=new TextVar(transMeta, wFontHeaderGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n  \t\tprops.setLook(wImage);\r\n \t\twImage.addModifyListener(lsMod);\r\n \t\tfdImage=new FormData();\r\n \t\tfdImage.left = new FormAttachment(middle, 0);\r\n \t\tfdImage.top  = new FormAttachment(wHeaderAlignment, margin);\r\n \t\tfdImage.right= new FormAttachment(wbImage, -margin);\r\n \t\twImage.setLayoutData(fdImage);\r\n\t\t\r\n        fdFontHeaderGroup= new FormData();\r\n        fdFontHeaderGroup.left = new FormAttachment(0, margin);\r\n        fdFontHeaderGroup.top = new FormAttachment(0, margin);\r\n\t\tfdFontHeaderGroup.right = new FormAttachment(100, -margin);\r\n\t\twFontHeaderGroup.setLayoutData(fdFontHeaderGroup);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Font Group GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\t\r\n\r\n\t \t // ///////////////////////////////\r\n\t\t// START OF Row Font GROUP //\r\n\t\t///////////////////////////////// \r\n\r\n\t\twFontRowGroup= new Group(wCustomComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wFontRowGroup);\r\n\t\twFontRowGroup.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.FontRowGroup.Label\"));\r\n\t\tFormLayout FontRowGroupLayout = new FormLayout();\r\n\t\tFontRowGroupLayout.marginWidth = 10;\r\n\t\tFontRowGroupLayout.marginHeight = 10;\r\n\t\twFontRowGroup.setLayout(FontRowGroupLayout);\r\n\r\n\t\t// Font Row name\r\n\t\twlRowFontName=new Label(wFontRowGroup, SWT.RIGHT);\r\n        wlRowFontName.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.RowFontName.Label\"));\r\n        props.setLook(wlRowFontName);\r\n        fdlRowFontName=new FormData();\r\n        fdlRowFontName.left = new FormAttachment(0, 0);\r\n        fdlRowFontName.top  = new FormAttachment(0, margin);\r\n        fdlRowFontName.right= new FormAttachment(middle, -margin);\r\n        wlRowFontName.setLayoutData(fdlRowFontName);\r\n        wRowFontName=new CCombo(wFontRowGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wRowFontName.setItems(ExcelOutputMeta.font_name_desc);\r\n        props.setLook(wRowFontName);\r\n        wRowFontName.addModifyListener(lsMod);\r\n        fdRowFontName=new FormData();\r\n        fdRowFontName.left = new FormAttachment(middle, 0);\r\n        fdRowFontName.top  = new FormAttachment(0, margin);\r\n        fdRowFontName.right= new FormAttachment(100, 0);\r\n        wRowFontName.setLayoutData(fdRowFontName);\r\n        \r\n\r\n        // Row font size\r\n\t\twlRowFontSize=new Label(wFontRowGroup, SWT.RIGHT);\r\n\t\twlRowFontSize.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.RowFontSize.Label\"));\r\n\t\tprops.setLook(wlRowFontSize);\r\n\t\tfdlRowFontSize=new FormData();\r\n\t\tfdlRowFontSize.left = new FormAttachment(0, 0);\r\n\t\tfdlRowFontSize.top  = new FormAttachment(wRowFontName, margin);\r\n\t\tfdlRowFontSize.right= new FormAttachment(middle, -margin);\r\n\t\twlRowFontSize.setLayoutData(fdlRowFontSize);\r\n\t\twRowFontSize=new TextVar(transMeta, wFontRowGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twRowFontSize.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.RowFontSize.Tooltip\"));\r\n\t\tprops.setLook(wRowFontSize);\r\n\t\twRowFontSize.addModifyListener(lsMod);\r\n\t\tfdRowFontSize=new FormData();\r\n\t\tfdRowFontSize.left = new FormAttachment(middle, 0);\r\n\t\tfdRowFontSize.top  = new FormAttachment(wRowFontName, margin);\r\n\t\tfdRowFontSize.right= new FormAttachment(100, 0);\r\n\t\twRowFontSize.setLayoutData(fdRowFontSize);\r\n\t\t\r\n\t\t// Font Row color\r\n\t\twlRowFontColor=new Label(wFontRowGroup, SWT.RIGHT);\r\n        wlRowFontColor.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.RowFontColor.Label\"));\r\n        props.setLook(wlRowFontColor);\r\n        fdlRowFontColor=new FormData();\r\n        fdlRowFontColor.left = new FormAttachment(0, 0);\r\n        fdlRowFontColor.top  = new FormAttachment(wRowFontSize, margin);\r\n        fdlRowFontColor.right= new FormAttachment(middle, -margin);\r\n        wlRowFontColor.setLayoutData(fdlRowFontColor);\r\n\t\twRowFontColor=new CCombo(wFontRowGroup, SWT.BORDER | SWT.READ_ONLY);\r\n\t\tprops.setLook(wRowFontColor);\r\n\t\tfdRowFontColor=new FormData();\r\n\t\tfdRowFontColor.left = new FormAttachment(middle, 0);\r\n\t\tfdRowFontColor.top  = new FormAttachment(wRowFontSize, margin);\r\n\t\tfdRowFontColor.right= new FormAttachment(100, 0);\r\n\t\twRowFontColor.setLayoutData(fdRowFontColor);\r\n\t\twRowFontColor.setItems(ExcelOutputMeta.font_color_desc);\r\n\t\t\r\n\t\t\r\n\t\t// Font Row background color\r\n\t\twlRowBackGroundColor=new Label(wFontRowGroup, SWT.RIGHT);\r\n        wlRowBackGroundColor.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.RowBackGroundColor.Label\"));\r\n        props.setLook(wlRowBackGroundColor);\r\n        fdlRowBackGroundColor=new FormData();\r\n        fdlRowBackGroundColor.left = new FormAttachment(0, 0);\r\n        fdlRowBackGroundColor.top  = new FormAttachment(wRowFontColor, margin);\r\n        fdlRowBackGroundColor.right= new FormAttachment(middle, -margin);\r\n        wlRowBackGroundColor.setLayoutData(fdlRowBackGroundColor);\r\n        \r\n\t\twRowBackGroundColor=new CCombo(wFontRowGroup, SWT.BORDER | SWT.READ_ONLY);\r\n\t\tprops.setLook(wRowBackGroundColor);\r\n\t\tfdRowBackGroundColor=new FormData();\r\n\t\tfdRowBackGroundColor.left = new FormAttachment(middle, 0);\r\n\t\tfdRowBackGroundColor.top  = new FormAttachment(wRowFontColor, margin);\r\n\t\tfdRowBackGroundColor.right= new FormAttachment(100, 0);\r\n\t\twRowBackGroundColor.setLayoutData(fdRowBackGroundColor);\r\n\t\twRowBackGroundColor.setItems(ExcelOutputMeta.font_color_desc);\r\n\r\n\r\n\t\t\r\n        fdFontRowGroup= new FormData();\r\n        fdFontRowGroup.left = new FormAttachment(0, margin);\r\n        fdFontRowGroup.top = new FormAttachment(wFontHeaderGroup, margin);\r\n\t\tfdFontRowGroup.right = new FormAttachment(100, -margin);\r\n\t\twFontRowGroup.setLayoutData(fdFontRowGroup);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Row Font Group\r\n\t\t// ///////////////////////////////////////////////////////////\t\t\r\n\r\n\t\t\r\n\t\t\r\n \t\t\r\n \t\t\r\n \t\tfdCustomComp=new FormData();\r\n\t\tfdCustomComp.left  = new FormAttachment(0, 0);\r\n\t\tfdCustomComp.top   = new FormAttachment(0, 0);\r\n\t\tfdCustomComp.right = new FormAttachment(100, 0);\r\n\t\tfdCustomComp.bottom= new FormAttachment(100, 0);\r\n\t\twCustomComp.setLayoutData(fdCustomComp);\r\n\r\n\t\twCustomComp.layout();\r\n\t\twCustomTab.setControl(wCustomComp);\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF customer TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n \t\t\r\n\t\t\r\n\t\t// Fields tab...\r\n\t\t//\r\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFieldsTab.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.FieldsTab.TabTitle\"));\r\n\t\t\r\n\t\tFormLayout fieldsLayout = new FormLayout ();\r\n\t\tfieldsLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tComposite wFieldsComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\twFieldsComp.setLayout(fieldsLayout);\r\n \t\tprops.setLook(wFieldsComp);\r\n\r\n\t\twGet=new Button(wFieldsComp, SWT.PUSH);\r\n\t\twGet.setText(BaseMessages.getString(PKG, \"System.Button.GetFields\"));\r\n\t\twGet.setToolTipText(BaseMessages.getString(PKG, \"System.Tooltip.GetFields\"));\r\n\r\n\t\twMinWidth =new Button(wFieldsComp, SWT.PUSH);\r\n\t\twMinWidth.setText(BaseMessages.getString(PKG, \"ExcelOutputDialog.MinWidth.Button\"));\r\n\t\twMinWidth.setToolTipText(BaseMessages.getString(PKG, \"ExcelOutputDialog.MinWidth.Tooltip\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wGet, wMinWidth}, margin, null);\r\n\r\n\t\tfinal int FieldsRows=input.getOutputFields().length;\r\n\t\t\r\n\t\t// Prepare a list of possible formats...\r\n        String[] formats = new String[] \r\n           {\r\n                // Numbers\r\n                \"#\",\r\n                \"0\",\r\n                \"0.00\",\r\n                \"#,##0\",\r\n                \"#,##0.00\",\r\n                \"$#,##0;($#,##0)\",\r\n                \"$#,##0;($#,##0)\",\r\n                \"$#,##0;($#,##0)\",\r\n                \"$#,##0;($#,##0)\",\r\n                \"0%\",\r\n                \"0.00%\",\r\n                \"0.00E00\",\r\n                \"#,##0;(#,##0)\",\r\n                \"#,##0;(#,##0)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"#,##0;(#,##0)\",\r\n                \"#,##0;(#,##0)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"#,##0.00;(#,##0.00)\",\r\n                \"##0.0E0\",\r\n                \r\n                // Forces text\r\n                \"@\",\r\n                \r\n                // Dates\r\n                \"M/d/yy\",\r\n                \"d-MMM-yy\",\r\n                \"d-MMM\",\r\n                \"MMM-yy\",\r\n                \"h:mm a\",\r\n                \"h:mm:ss a\",\r\n                \"H:mm\",\r\n                \"H:mm:ss\",\r\n                \"M/d/yy H:mm\",\r\n                \"mm:ss\",\r\n                \"H:mm:ss\",\r\n                \"H:mm:ss\",\r\n           };\r\n        \r\n        colinf=new ColumnInfo[] \r\n\t\t    {\r\n\t\t        new ColumnInfo(BaseMessages.getString(PKG, \"ExcelOutputDialog.NameColumn.Column\"),      ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false),\r\n\t\t        new ColumnInfo(BaseMessages.getString(PKG, \"ExcelOutputDialog.TypeColumn.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes() ),\r\n\t\t        new ColumnInfo(BaseMessages.getString(PKG, \"ExcelOutputDialog.FormatColumn.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, formats),\r\n            };\r\n\t\t\r\n\t\twFields=new TableView(transMeta, wFieldsComp, \r\n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \r\n\t\t\t\t\t\t      colinf, \r\n\t\t\t\t\t\t      FieldsRows,  \r\n\t\t\t\t\t\t      lsMod,\r\n\t\t\t\t\t\t\t  props\r\n\t\t\t\t\t\t      );\r\n\r\n\t\tfdFields=new FormData();\r\n\t\tfdFields.left  = new FormAttachment(0, 0);\r\n\t\tfdFields.top   = new FormAttachment(0, 0);\r\n\t\tfdFields.right = new FormAttachment(100, 0);\r\n\t\tfdFields.bottom= new FormAttachment(wGet, -margin);\r\n\t\twFields.setLayoutData(fdFields);\r\n\t\t\r\n\t\t  // \r\n        // Search the fields in the background\r\n\t\t\r\n        final Runnable runnable = new Runnable()\r\n        {\r\n            public void run()\r\n            {\r\n                StepMeta stepMeta = transMeta.findStep(stepname);\r\n                if (stepMeta!=null)\r\n                {\r\n                    try\r\n                    {\r\n                    \tRowMetaInterface row = transMeta.getPrevStepFields(stepMeta);\r\n                       \r\n                        // Remember these fields...\r\n                        for (int i=0;i<row.size();i++)\r\n                        {\r\n                            inputFields.put(row.getValueMeta(i).getName(), Integer.valueOf(i));\r\n                        }\r\n                        setComboBoxes();\r\n                    }\r\n                    catch(KettleException e)\r\n                    {\r\n                    \tlogError(BaseMessages.getString(PKG, \"System.Dialog.GetFieldsFailed.Message\"));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        new Thread(runnable).start();\r\n\r\n\t\tfdFieldsComp=new FormData();\r\n\t\tfdFieldsComp.left  = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.top   = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\r\n\t\tfdFieldsComp.bottom= new FormAttachment(100, 0);\r\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\r\n\r\n\t\twFieldsComp.layout();\r\n\t\twFieldsTab.setControl(wFieldsComp);\r\n\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\t\t\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\r\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, wTabFolder);\r\n\r\n\t\t// Add listeners\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();       } };\r\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();      } };\r\n\t\tlsMinWidth    = new Listener() { public void handleEvent(Event e) { setMinimalWidth(); } };\r\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();   } };\r\n\t\t\r\n\t\twOK.addListener    (SWT.Selection, lsOK    );\r\n\t\twGet.addListener   (SWT.Selection, lsGet   );\r\n\t\twMinWidth.addListener (SWT.Selection, lsMinWidth );\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\r\n\t\twStepname.addSelectionListener( lsDef );\r\n\t\twFilename.addSelectionListener( lsDef );\r\n\t\twTemplateFilename.addSelectionListener( lsDef );\r\n\r\n\t\t// Whenever something changes, set the tooltip to the expanded version:\r\n\t\twFilename.addModifyListener(new ModifyListener()\r\n\t\t\t{\r\n\t\t\t\tpublic void modifyText(ModifyEvent e)\r\n\t\t\t\t{\r\n\t\t\t\t\twFilename.setToolTipText(transMeta.environmentSubstitute( wFilename.getText() ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\twTemplateFilename.addModifyListener(new ModifyListener()\r\n\t\t\t{\r\n\t\t\t\tpublic void modifyText(ModifyEvent e)\r\n\t\t\t\t{\r\n\t\t\t\t\twTemplateFilename.setToolTipText(transMeta.environmentSubstitute( wTemplateFilename.getText() ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\twbFilename.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.SAVE);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xls\", \"*.*\"});\r\n\t\t\t\t\tif (wFilename.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {BaseMessages.getString(PKG, \"System.FileType.ExcelFiles\"), BaseMessages.getString(PKG, \"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twbTemplateFilename.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xls\", \"*.*\"});\r\n\t\t\t\t\tif (wTemplateFilename.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wTemplateFilename.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {BaseMessages.getString(PKG, \"System.FileType.ExcelFiles\"), BaseMessages.getString(PKG, \"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twTemplateFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n\t\tlsResize = new Listener() \r\n\t\t{\r\n\t\t\tpublic void handleEvent(Event event) \r\n\t\t\t{\r\n\t\t\t\tPoint size = shell.getSize();\r\n\t\t\t\twFields.setSize(size.x-10, size.y-50);\r\n\t\t\t\twFields.table.setSize(size.x-10, size.y-50);\r\n\t\t\t\twFields.redraw();\r\n\t\t\t}\r\n\t\t};\r\n\t\tshell.addListener(SWT.Resize, lsResize);\r\n\r\n\t\twTabFolder.setSelection(0);\r\n\t\t\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\t\r\n\t\tgetData();\r\n\t\tsetDateTimeFormat();\r\n\t\tEnableAutoSize();\r\n\t\tinput.setChanged(changed);\r\n\t\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\theaderEnabled    =      rep.getStepAttributeBoolean(id_step, \"header\");\r\n\t\t\tfooterEnabled    =      rep.getStepAttributeBoolean(id_step, \"footer\");   \r\n            encoding         =      rep.getStepAttributeString (id_step, \"encoding\");\r\n            append   =      rep.getStepAttributeBoolean(id_step, \"append\");\r\n            \r\n            String addToResult=rep.getStepAttributeString (id_step, \"add_to_result_filenames\");\r\n\t\t\tif(Const.isEmpty(addToResult)) \r\n\t\t\t\taddToResultFilenames = true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames =  rep.getStepAttributeBoolean(id_step, \"add_to_result_filenames\");\r\n            \r\n            \r\n\t\t\tfileName         =      rep.getStepAttributeString (id_step, \"file_name\");  \r\n\t\t\textension        =      rep.getStepAttributeString (id_step, \"file_extention\");\r\n\t\t\t\r\n\t\t\tdoNotOpenNewFileInit =      rep.getStepAttributeBoolean(id_step, \"do_not_open_newfile_init\");\r\n\t\t\tcreateparentfolder        =      rep.getStepAttributeBoolean(id_step, \"create_parent_folder\");\r\n\t\t\tsplitEvery       = (int)rep.getStepAttributeInteger(id_step, \"file_split\");\r\n\t\t\tstepNrInFilename =      rep.getStepAttributeBoolean(id_step, \"file_add_stepnr\");\r\n\t\t\tdateInFilename   =      rep.getStepAttributeBoolean(id_step, \"file_add_date\");\r\n\t\t\ttimeInFilename   =      rep.getStepAttributeBoolean(id_step, \"file_add_time\");\r\n\t\t\tSpecifyFormat   =      rep.getStepAttributeBoolean(id_step, \"SpecifyFormat\");\r\n\t\t\tdate_time_format  =      rep.getStepAttributeString (id_step, \"date_time_format\");  \r\n\t\t\t\r\n\t\t\tautosizecolums        = rep.getStepAttributeBoolean(id_step, \"autosizecolums\");\r\n\t\t\tnullIsBlank           = rep.getStepAttributeBoolean(id_step, \"nullisblank\");\r\n            protectsheet          = rep.getStepAttributeBoolean(id_step, \"protect_sheet\");\r\n\t\t\tpassword              = Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString (id_step, \"password\") );\r\n\r\n\t\t\ttemplateEnabled       = rep.getStepAttributeBoolean(id_step, \"template_enabled\");\r\n\t\t\ttemplateAppend        = rep.getStepAttributeBoolean(id_step, \"template_append\");\r\n\t\t\ttemplateFileName      = rep.getStepAttributeString(id_step, \"template_filename\");\r\n\t\t\tsheetname             = rep.getStepAttributeString(id_step, \"sheetname\");\r\n\t\t\tint nrfields          = rep.countNrStepAttributes(id_step, \"field_name\");\r\n\t\t\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t    outputFields[i] = new ExcelField();\r\n\r\n\t\t\t    outputFields[i].setName(    \t\trep.getStepAttributeString (id_step, i, \"field_name\") );\r\n\t\t\t    outputFields[i].setType( \t\t\trep.getStepAttributeString (id_step, i, \"field_type\") );\r\n\t\t\t    outputFields[i].setFormat(  \t\trep.getStepAttributeString (id_step, i, \"field_format\") );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\r\n\t\t}\r\n\t}","id":43205,"modified_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\theaderEnabled    =      rep.getStepAttributeBoolean(id_step, \"header\");\r\n\t\t\tfooterEnabled    =      rep.getStepAttributeBoolean(id_step, \"footer\");   \r\n            encoding         =      rep.getStepAttributeString (id_step, \"encoding\");\r\n            append   =      rep.getStepAttributeBoolean(id_step, \"append\");\r\n            \r\n            String addToResult=rep.getStepAttributeString (id_step, \"add_to_result_filenames\");\r\n\t\t\tif(Const.isEmpty(addToResult)) \r\n\t\t\t\taddToResultFilenames = true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames =  rep.getStepAttributeBoolean(id_step, \"add_to_result_filenames\");\r\n            \r\n            \r\n\t\t\tfileName         =      rep.getStepAttributeString (id_step, \"file_name\");  \r\n\t\t\textension        =      rep.getStepAttributeString (id_step, \"file_extention\");\r\n\t\t\t\r\n\t\t\tdoNotOpenNewFileInit =      rep.getStepAttributeBoolean(id_step, \"do_not_open_newfile_init\");\r\n\t\t\tcreateparentfolder        =      rep.getStepAttributeBoolean(id_step, \"create_parent_folder\");\r\n\t\t\tsplitEvery       = (int)rep.getStepAttributeInteger(id_step, \"file_split\");\r\n\t\t\tstepNrInFilename =      rep.getStepAttributeBoolean(id_step, \"file_add_stepnr\");\r\n\t\t\tdateInFilename   =      rep.getStepAttributeBoolean(id_step, \"file_add_date\");\r\n\t\t\ttimeInFilename   =      rep.getStepAttributeBoolean(id_step, \"file_add_time\");\r\n\t\t\tSpecifyFormat   =      rep.getStepAttributeBoolean(id_step, \"SpecifyFormat\");\r\n\t\t\tdate_time_format  =      rep.getStepAttributeString (id_step, \"date_time_format\");  \r\n\t\t\t\r\n\t\t\tautosizecolums        = rep.getStepAttributeBoolean(id_step, \"autosizecolums\");\r\n\t\t\tnullIsBlank           = rep.getStepAttributeBoolean(id_step, \"nullisblank\");\r\n            protectsheet          = rep.getStepAttributeBoolean(id_step, \"protect_sheet\");\r\n\t\t\tpassword              = Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString (id_step, \"password\") );\r\n\r\n\t\t\ttemplateEnabled       = rep.getStepAttributeBoolean(id_step, \"template_enabled\");\r\n\t\t\ttemplateAppend        = rep.getStepAttributeBoolean(id_step, \"template_append\");\r\n\t\t\ttemplateFileName      = rep.getStepAttributeString(id_step, \"template_filename\");\r\n\t\t\tsheetname             = rep.getStepAttributeString(id_step, \"sheetname\");\r\n\t\t\tint nrfields          = rep.countNrStepAttributes(id_step, \"field_name\");\r\n\t\t\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t    outputFields[i] = new ExcelField();\r\n\r\n\t\t\t    outputFields[i].setName(    \t\trep.getStepAttributeString (id_step, i, \"field_name\") );\r\n\t\t\t    outputFields[i].setType( \t\t\trep.getStepAttributeString (id_step, i, \"field_type\") );\r\n\t\t\t    outputFields[i].setFormat(  \t\trep.getStepAttributeString (id_step, i, \"field_format\") );\r\n\t\t\t}\r\n\t\t\t// Header font\r\n\t\t\theader_font_name = getFontNameByCode(Const.NVL(rep.getStepAttributeString(id_step, \"header_font_name\"), \"\"));\r\n\t\t\theader_font_size = Const.NVL(rep.getStepAttributeString(id_step, \"header_font_size\"),\"\"+DEFAULT_FONT_SIZE);\r\n\t\t\theader_font_bold   =      rep.getStepAttributeBoolean(id_step, \"header_font_bold\");\r\n\t\t\theader_font_italic   =      rep.getStepAttributeBoolean(id_step, \"header_font_italic\");\r\n\t\t\theader_font_underline = getFontUnderlineByCode(Const.NVL(rep.getStepAttributeString(id_step, \"header_font_underline\"), \"\"));\r\n\t\t\theader_font_orientation = getFontOrientationByCode(Const.NVL(rep.getStepAttributeString(id_step, \"header_font_orientation\"), \"\"));\r\n\t\t\theader_font_color = getFontColorByCode(Const.NVL(rep.getStepAttributeString(id_step, \"header_font_color\"), \"\"+FONT_COLOR_BLACK));\r\n\t\t\theader_background_color = getFontColorByCode(Const.NVL(rep.getStepAttributeString(id_step, \"header_background_color\"), \"\"+FONT_COLOR_NONE));\r\n\t\t\theader_row_height = rep.getStepAttributeString(id_step, \"header_row_height\");\r\n\t\t\theader_alignment=getFontAlignmentByCode(Const.NVL(rep.getStepAttributeString(id_step, \"header_alignment\"), \"\"));\r\n\t\t\theader_image = rep.getStepAttributeString(id_step, \"header_image\");\r\n\t\t\t// row font\r\n\t\t\trow_font_name = getFontNameByCode(Const.NVL(rep.getStepAttributeString(id_step, \"row_font_name\"), \"\"));\r\n\t\t\trow_font_size = Const.NVL(rep.getStepAttributeString(id_step, \"row_font_size\"),\"\"+DEFAULT_FONT_SIZE);\r\n\t\t\trow_font_color = getFontColorByCode(Const.NVL(rep.getStepAttributeString(id_step, \"row_font_color\"), \"\"+FONT_COLOR_BLACK));\r\n\t\t\trow_background_color = getFontColorByCode(Const.NVL(rep.getStepAttributeString(id_step, \"row_background_color\"), \"\"+FONT_COLOR_NONE));\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\r\n\t\t}\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, ObjectId id_transformation, ObjectId id_step)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\",           headerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"footer\",           footerEnabled);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"encoding\",         encoding);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"append\",           append);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"add_to_result_filenames\",    addToResultFilenames);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_name\",        fileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"do_not_open_newfile_init\",  doNotOpenNewFileInit);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"create_parent_folder\",    createparentfolder);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_extention\",   extension);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_split\",       splitEvery);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_stepnr\",  stepNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_date\",    dateInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_time\",    timeInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"SpecifyFormat\",    SpecifyFormat);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"date_time_format\",   date_time_format);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"autosizecolums\",    autosizecolums);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"nullisblank\",    nullIsBlank);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"protect_sheet\",    protectsheet);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"password\",  Encr.encryptPasswordIfNotUsingVariables(password) );\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"template_enabled\",  templateEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"template_append\",   templateAppend);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"template_filename\", templateFileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"sheetname\", sheetname);\r\n\t\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t\t{\r\n\t\t\t    ExcelField field = outputFields[i];\r\n\t\t\t    \r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field.getName());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      field.getTypeDesc());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",    field.getFormat());\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\r\n\t\t}\r\n\t}","id":43206,"modified_method":"public void saveRep(Repository rep, ObjectId id_transformation, ObjectId id_step)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\",           headerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"footer\",           footerEnabled);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"encoding\",         encoding);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"append\",           append);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"add_to_result_filenames\",    addToResultFilenames);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_name\",        fileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"do_not_open_newfile_init\",  doNotOpenNewFileInit);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"create_parent_folder\",    createparentfolder);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_extention\",   extension);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_split\",       splitEvery);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_stepnr\",  stepNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_date\",    dateInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_time\",    timeInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"SpecifyFormat\",    SpecifyFormat);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"date_time_format\",   date_time_format);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"autosizecolums\",    autosizecolums);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"nullisblank\",    nullIsBlank);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"protect_sheet\",    protectsheet);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"password\",  Encr.encryptPasswordIfNotUsingVariables(password) );\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"template_enabled\",  templateEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"template_append\",   templateAppend);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"template_filename\", templateFileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"sheetname\", sheetname);\r\n\t\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t\t{\r\n\t\t\t    ExcelField field = outputFields[i];\r\n\t\t\t    \r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field.getName());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      field.getTypeDesc());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",    field.getFormat());\r\n\t\t\t}\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_font_name\", getFontNameCode(header_font_name));\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_font_size\", header_font_size);\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_font_bold\",           header_font_bold);\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_font_italic\",           header_font_italic);\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_font_underline\",    getFontUnderlineCode(header_font_underline));\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_font_orientation\",  getFontOrientationCode(header_font_orientation));\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_font_color\", getFontColorCode(header_font_color));\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_background_color\", getFontColorCode(header_background_color));\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_row_height\", header_row_height);\t\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_alignment\",    getFontAlignmentCode(header_alignment));\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"header_image\", header_image);\r\n\t\t\t // row font\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"row_font_name\", getFontNameCode(row_font_name));\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"row_font_size\", row_font_size);\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"row_font_color\", getFontColorCode(row_font_color));\r\n\t\t\t rep.saveStepAttribute(id_transformation, id_step, \"row_background_color\", getFontColorCode(row_background_color));\r\n\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\r\n\t\t}\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\r\n\t{\r\n\t\tStringBuffer retval=new StringBuffer(800);\r\n\t\t\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\",    headerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"footer\",    footerEnabled));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"encoding\",  encoding));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"append\",    append));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"add_to_result_filenames\",   addToResultFilenames));\r\n        \r\n\t\tretval.append(\"    <file>\").append(Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"name\",       fileName));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"extention\",  extension));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"do_not_open_newfile_init\",   doNotOpenNewFileInit));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"create_parent_folder\",   createparentfolder));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"split\",      stepNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",   dateInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",   timeInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"SpecifyFormat\",   SpecifyFormat));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"date_time_format\",  date_time_format));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"sheetname\", sheetname));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"autosizecolums\",   autosizecolums));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"nullisblank\",   nullIsBlank));\r\n        retval.append(\"      \").append(XMLHandler.addTagValue(\"protect_sheet\",   protectsheet));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"password\",  Encr.encryptPasswordIfNotUsingVariables(password)));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"splitevery\", splitEvery));\r\n\t\t\r\n\t\tretval.append(\"      <\/file>\").append(Const.CR);\r\n\t\t\r\n\t\tretval.append(\"    <template>\").append(Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"enabled\",  templateEnabled));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"append\",   templateAppend));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename\", templateFileName));\r\n\t\tretval.append(\"    <\/template>\").append(Const.CR);\r\n\t\t\r\n\t\tretval.append(\"    <fields>\").append(Const.CR);\r\n\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t{\r\n\t\t    ExcelField field = outputFields[i];\r\n\t\t    \r\n\t\t\tif (field.getName()!= null && field.getName().length()!= 0)\r\n\t\t\t{\r\n\t\t\t\tretval.append(\"      <field>\").append(Const.CR);\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\",      field.getName()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\",      field.getTypeDesc()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\",    field.getFormat()));\r\n\t\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\r\n\t\t\t}\r\n\t\t}\r\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\r\n\r\n\t\treturn retval.toString();\r\n\t}","id":43207,"modified_method":"public String getXML()\r\n\t{\r\n\t\tStringBuffer retval=new StringBuffer(800);\r\n\t\t\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\",    headerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"footer\",    footerEnabled));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"encoding\",  encoding));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"append\",    append));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"add_to_result_filenames\",   addToResultFilenames));\r\n        \r\n\t\tretval.append(\"    <file>\").append(Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"name\",       fileName));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"extention\",  extension));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"do_not_open_newfile_init\",   doNotOpenNewFileInit));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"create_parent_folder\",   createparentfolder));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"split\",      stepNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",   dateInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",   timeInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"SpecifyFormat\",   SpecifyFormat));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"date_time_format\",  date_time_format));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"sheetname\", sheetname));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"autosizecolums\",   autosizecolums));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"nullisblank\",   nullIsBlank));\r\n        retval.append(\"      \").append(XMLHandler.addTagValue(\"protect_sheet\",   protectsheet));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"password\",  Encr.encryptPasswordIfNotUsingVariables(password)));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"splitevery\", splitEvery));\r\n\t\t\r\n\t\tretval.append(\"      <\/file>\").append(Const.CR);\r\n\t\t\r\n\t\tretval.append(\"    <template>\").append(Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"enabled\",  templateEnabled));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"append\",   templateAppend));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename\", templateFileName));\r\n\t\tretval.append(\"    <\/template>\").append(Const.CR);\r\n\t\t\r\n\t\tretval.append(\"    <fields>\").append(Const.CR);\r\n\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t{\r\n\t\t    ExcelField field = outputFields[i];\r\n\t\t    \r\n\t\t\tif (field.getName()!= null && field.getName().length()!= 0)\r\n\t\t\t{\r\n\t\t\t\tretval.append(\"      <field>\").append(Const.CR);\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\",      field.getName()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\",      field.getTypeDesc()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\",    field.getFormat()));\r\n\t\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\r\n\t\t\t}\r\n\t\t}\r\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\r\n\t\t\r\n\t\tretval.append(\"    <custom>\"+Const.CR);\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_font_name\",getFontNameCode(header_font_name)));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_font_size\",header_font_size));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_font_bold\",   header_font_bold));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_font_italic\",   header_font_italic));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_font_underline\", getFontUnderlineCode(header_font_underline)));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_font_orientation\", getFontOrientationCode(header_font_orientation)));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_font_color\", getFontColorCode(header_font_color)));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_background_color\", getFontColorCode(header_background_color)));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_row_height\",header_row_height));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_alignment\", getFontAlignmentCode(header_alignment)));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"header_image\",header_image));\r\n\t\t// row font\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"row_font_name\",getFontNameCode(row_font_name)));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"row_font_size\",row_font_size));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"row_font_color\", getFontColorCode(row_font_color)));\r\n\t\tretval.append(\"    \"+XMLHandler.addTagValue(\"row_background_color\", getFontColorCode(row_background_color)));\r\n\t\tretval.append(\"      <\/custom>\"+Const.CR);\r\n\t\treturn retval.toString();\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\r\n\t{\r\n\t\tautosizecolums=false;\r\n\t\theaderEnabled    = true;\r\n\t\tfooterEnabled    = false;\r\n\t\tfileName         = \"file\";\r\n\t\textension        = \"xls\";\r\n\t\tdoNotOpenNewFileInit=false;\r\n\t\tcreateparentfolder = false;\r\n\t\tstepNrInFilename = false;\r\n\t\tdateInFilename   = false;\r\n\t\ttimeInFilename   = false;\r\n\t\tdate_time_format  =null;\r\n\t\tSpecifyFormat\t= false;\r\n\t\taddToResultFilenames=true;\r\n\t\tprotectsheet\t = false;\r\n\t\tsplitEvery       = 0;\r\n\t\ttemplateEnabled  = false;\r\n\t\ttemplateAppend   = false;\r\n\t\ttemplateFileName = \"template.xls\";\r\n\t\tsheetname=\"Sheet1\";\t\r\n\t\tappend   \t\t = false;\r\n\t\tnullIsBlank      = false;\r\n\t\tint i, nrfields=0;\r\n\t\tallocate(nrfields);\r\n\t\t\t\t\t\r\n\t\tfor (i=0;i<nrfields;i++)\r\n\t\t{\r\n\t\t\toutputFields[i] = new ExcelField();\r\n\r\n\t\t\toutputFields[i].setName( \"field\"+i );\t\t\t\t\r\n\t\t\toutputFields[i].setType( \"Number\" );\r\n\t\t\toutputFields[i].setFormat( \" 0,000,000.00;-0,000,000.00\" );\r\n\t\t}\r\n\t}","id":43208,"modified_method":"public void setDefault()\r\n\t{\r\n\t\theader_font_name=FONT_NAME_ARIAL;\r\n\t\theader_font_size=\"\"+DEFAULT_FONT_SIZE;\r\n\t\theader_font_bold=false;\r\n\t\theader_font_italic=false;\r\n\t\theader_font_underline=FONT_UNDERLINE_NO;\r\n\t\theader_font_orientation=FONT_ORIENTATION_HORIZONTAL;\r\n\t\theader_font_color=FONT_COLOR_BLACK;\r\n\t\theader_background_color=FONT_COLOR_NONE;\r\n\t\theader_row_height=\"\"+DEFAULT_ROW_HEIGHT;\r\n\t\theader_alignment=FONT_ALIGNMENT_LEFT;\r\n\t\theader_image=null;\r\n\t\t\r\n\t\trow_font_name=FONT_NAME_ARIAL;\r\n\t\trow_font_size=\"\"+DEFAULT_FONT_SIZE;\r\n\t\trow_font_color=FONT_COLOR_BLACK;\r\n\t\trow_background_color=FONT_COLOR_NONE;\r\n\t\t\r\n\t\tautosizecolums=false;\r\n\t\theaderEnabled    = true;\r\n\t\tfooterEnabled    = false;\r\n\t\tfileName         = \"file\";\r\n\t\textension        = \"xls\";\r\n\t\tdoNotOpenNewFileInit=false;\r\n\t\tcreateparentfolder = false;\r\n\t\tstepNrInFilename = false;\r\n\t\tdateInFilename   = false;\r\n\t\ttimeInFilename   = false;\r\n\t\tdate_time_format  =null;\r\n\t\tSpecifyFormat\t= false;\r\n\t\taddToResultFilenames=true;\r\n\t\tprotectsheet\t = false;\r\n\t\tsplitEvery       = 0;\r\n\t\ttemplateEnabled  = false;\r\n\t\ttemplateAppend   = false;\r\n\t\ttemplateFileName = \"template.xls\";\r\n\t\tsheetname=\"Sheet1\";\t\r\n\t\tappend   \t\t = false;\r\n\t\tnullIsBlank      = false;\r\n\t\tint i, nrfields=0;\r\n\t\tallocate(nrfields);\r\n\t\t\t\t\t\r\n\t\tfor (i=0;i<nrfields;i++)\r\n\t\t{\r\n\t\t\toutputFields[i] = new ExcelField();\r\n\r\n\t\t\toutputFields[i].setName( \"field\"+i );\t\t\t\t\r\n\t\t\toutputFields[i].setType( \"Number\" );\r\n\t\t\toutputFields[i].setFormat( \" 0,000,000.00;-0,000,000.00\" );\r\n\t\t}\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\r\n\t\tthrows KettleXMLException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\t\r\n\t\t\theaderEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\r\n\t\t\tfooterEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"footer\"));\r\n\t\t\tencoding         = XMLHandler.getTagValue(stepnode, \"encoding\");\r\n\t\t\tappend    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"append\"));\r\n\t\t\tString addToResult=XMLHandler.getTagValue(stepnode,  \"add_to_result_filenames\");\r\n\t\t\tif(Const.isEmpty(addToResult)) \r\n\t\t\t\taddToResultFilenames = true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames = \"Y\".equalsIgnoreCase(addToResult);\r\n\t\t\r\n            fileName             = XMLHandler.getTagValue(stepnode, \"file\", \"name\");\r\n\t\t\textension            = XMLHandler.getTagValue(stepnode, \"file\", \"extention\");\r\n\t\t\t\r\n\t\t\tdoNotOpenNewFileInit       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"do_not_open_newfile_init\"));\r\n\t\t\tcreateparentfolder = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"create_parent_folder\"));\r\n\t\t\t\r\n\t\t\tstepNrInFilename     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"split\"));\r\n\t\t\tdateInFilename       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_date\"));\r\n\t\t\ttimeInFilename       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_time\"));\r\n\t\t\tSpecifyFormat       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"SpecifyFormat\"));\r\n\t\t\tdate_time_format         = XMLHandler.getTagValue(stepnode, \"file\",\"date_time_format\");\r\n\t\t\t\r\n\t\t\tautosizecolums = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"autosizecolums\"));\r\n\t\t\tnullIsBlank = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"nullisblank\"));\r\n            protectsheet = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"protect_sheet\"));\r\n\t\t\tpassword     = Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue(stepnode, \"file\", \"password\") );\r\n\t\t\tsplitEvery   = Const.toInt(XMLHandler.getTagValue(stepnode, \"file\", \"splitevery\"), 0);\r\n\t\t\t\r\n\t\t\ttemplateEnabled   = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"template\", \"enabled\"));\r\n\t\t\ttemplateAppend    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"template\", \"append\"));\r\n\t\t\ttemplateFileName  = XMLHandler.getTagValue(stepnode, \"template\", \"filename\");\r\n\t\t\tsheetname         = XMLHandler.getTagValue(stepnode, \"file\", \"sheetname\");\r\n\t\t\tNode fields       = XMLHandler.getSubNode(stepnode, \"fields\");\r\n\t\t\tint nrfields      = XMLHandler.countNodes(fields, \"field\");\r\n\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\r\n\t\t\t\r\n\t\t\t\toutputFields[i] = new ExcelField();\r\n\t\t\t\toutputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\r\n\t\t\t\toutputFields[i].setType( XMLHandler.getTagValue(fnode, \"type\") );\r\n\t\t\t\toutputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\r\n\t\t}\r\n\t}","id":43209,"modified_method":"private void readData(Node stepnode)\r\n\t\tthrows KettleXMLException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\t\r\n\t\t\theaderEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\r\n\t\t\tfooterEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"footer\"));\r\n\t\t\tencoding         = XMLHandler.getTagValue(stepnode, \"encoding\");\r\n\t\t\tappend    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"append\"));\r\n\t\t\tString addToResult=XMLHandler.getTagValue(stepnode,  \"add_to_result_filenames\");\r\n\t\t\tif(Const.isEmpty(addToResult)) \r\n\t\t\t\taddToResultFilenames = true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames = \"Y\".equalsIgnoreCase(addToResult);\r\n\t\t\r\n            fileName             = XMLHandler.getTagValue(stepnode, \"file\", \"name\");\r\n\t\t\textension            = XMLHandler.getTagValue(stepnode, \"file\", \"extention\");\r\n\t\t\t\r\n\t\t\tdoNotOpenNewFileInit       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"do_not_open_newfile_init\"));\r\n\t\t\tcreateparentfolder = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"create_parent_folder\"));\r\n\t\t\t\r\n\t\t\tstepNrInFilename     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"split\"));\r\n\t\t\tdateInFilename       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_date\"));\r\n\t\t\ttimeInFilename       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_time\"));\r\n\t\t\tSpecifyFormat       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"SpecifyFormat\"));\r\n\t\t\tdate_time_format         = XMLHandler.getTagValue(stepnode, \"file\",\"date_time_format\");\r\n\t\t\t\r\n\t\t\tautosizecolums = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"autosizecolums\"));\r\n\t\t\tnullIsBlank = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"nullisblank\"));\r\n            protectsheet = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"protect_sheet\"));\r\n\t\t\tpassword     = Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue(stepnode, \"file\", \"password\") );\r\n\t\t\tsplitEvery   = Const.toInt(XMLHandler.getTagValue(stepnode, \"file\", \"splitevery\"), 0);\r\n\t\t\t\r\n\t\t\ttemplateEnabled   = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"template\", \"enabled\"));\r\n\t\t\ttemplateAppend    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"template\", \"append\"));\r\n\t\t\ttemplateFileName  = XMLHandler.getTagValue(stepnode, \"template\", \"filename\");\r\n\t\t\tsheetname         = XMLHandler.getTagValue(stepnode, \"file\", \"sheetname\");\r\n\t\t\tNode fields       = XMLHandler.getSubNode(stepnode, \"fields\");\r\n\t\t\tint nrfields      = XMLHandler.countNodes(fields, \"field\");\r\n\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\r\n\t\t\t\r\n\t\t\t\toutputFields[i] = new ExcelField();\r\n\t\t\t\toutputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\r\n\t\t\t\toutputFields[i].setType( XMLHandler.getTagValue(fnode, \"type\") );\r\n\t\t\t\toutputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\r\n\t\t\t}\r\n\t\t\tNode customnode = XMLHandler.getSubNode(stepnode, \"custom\");\r\n\t\t\theader_font_name = getFontNameByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"header_font_name\"), \"\"));\r\n\t\t\theader_font_size = Const.NVL(XMLHandler.getTagValue(customnode,\"header_font_size\"),\"\"+DEFAULT_FONT_SIZE);\r\n\t\t\theader_font_bold=\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(customnode, \"header_font_bold\"));\r\n\t\t\theader_font_italic=\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(customnode, \"header_font_italic\"));\r\n\t\t\theader_font_underline = getFontUnderlineByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"header_font_underline\"), \"\"));\r\n\t\t\theader_font_orientation = getFontOrientationByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"header_font_orientation\"), \"\"));\r\n\t\t\theader_font_color = getFontColorByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"header_font_color\"), \"\"+FONT_COLOR_BLACK));\r\n\t\t\theader_background_color = getFontColorByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"header_background_color\"), \"\"+FONT_COLOR_NONE));\r\n\t\t\theader_row_height= XMLHandler.getTagValue(customnode,\"header_row_height\");\r\n\t\t\theader_alignment = getFontAlignmentByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"header_alignment\"), \"\"));\r\n\t\t\theader_image = XMLHandler.getTagValue(customnode,\"header_image\");\r\n\t\t\t// Row font\r\n\t\t    row_font_name = getFontNameByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"row_font_name\"), \"\"));\r\n\t\t    row_font_size = Const.NVL(XMLHandler.getTagValue(customnode,\"row_font_size\"),\"\"+DEFAULT_FONT_SIZE);\r\n\t\t\trow_font_color = getFontColorByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"row_font_color\"), \"\"+FONT_COLOR_BLACK));\r\n\t\t\trow_background_color = getFontColorByCode(Const.NVL(XMLHandler.getTagValue(customnode,\t\"row_background_color\"), \"\"+FONT_COLOR_NONE));\r\n\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\r\n\t\t}\r\n\t}","commit_id":"1715ab778dd0c1683a22c60a6d77df17b86d37b4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"static LocalResource createTarFile(FileContext files, Path p, int len,\n      Random r, LocalResourceVisibility vis) throws IOException,\n      URISyntaxException {\n\n    FSDataOutputStream outFile = null;\n    try {\n      byte[] bytes = new byte[len];\n      Path tarPath = new Path(p.toString());\n      outFile = files.create(tarPath, EnumSet.of(CREATE, OVERWRITE));\n      r.nextBytes(bytes);\n      outFile.write(bytes);\n    } finally {\n      if (outFile != null)\n        outFile.close();\n    }\n    StringBuffer tarCommand = new StringBuffer();\n    URI u = new URI(p.getParent().toString());\n    tarCommand.append(\"cd '\");\n    tarCommand.append(FileUtil.makeShellPath(u.getPath().toString()));\n    tarCommand.append(\"' ; \");\n    tarCommand.append(\"tar -czf \" + p.getName() + \".tar \" + p.getName());\n    String[] shellCmd = { \"bash\", \"-c\", tarCommand.toString() };\n    ShellCommandExecutor shexec = new ShellCommandExecutor(shellCmd);\n    shexec.execute();\n    int exitcode = shexec.getExitCode();\n    if (exitcode != 0) {\n      throw new IOException(\"Error untarring file \" + p\n          + \". Tar process exited with exit code \" + exitcode);\n    }\n    LocalResource ret = recordFactory.newRecordInstance(LocalResource.class);\n    ret.setResource(ConverterUtils.getYarnUrlFromPath(new Path(p.toString()\n        + \".tar\")));\n    ret.setSize(len);\n    ret.setType(LocalResourceType.ARCHIVE);\n    ret.setVisibility(vis);\n    ret.setTimestamp(files.getFileStatus(new Path(p.toString() + \".tar\"))\n        .getModificationTime());\n    return ret;\n  }","id":43210,"modified_method":"static LocalResource createTarFile(FileContext files, Path p, int len,\n      Random r, LocalResourceVisibility vis) throws IOException,\n      URISyntaxException {\n    byte[] bytes = new byte[len];\n    r.nextBytes(bytes);\n\n    File archiveFile = new File(p.toUri().getPath() + \".tar\");\n    archiveFile.createNewFile();\n    TarArchiveOutputStream out = new TarArchiveOutputStream(\n        new FileOutputStream(archiveFile));\n    TarArchiveEntry entry = new TarArchiveEntry(p.getName());\n    entry.setSize(bytes.length);\n    out.putArchiveEntry(entry);\n    out.write(bytes);\n    out.closeArchiveEntry();\n    out.close();\n\n    LocalResource ret = recordFactory.newRecordInstance(LocalResource.class);\n    ret.setResource(ConverterUtils.getYarnUrlFromPath(new Path(p.toString()\n        + \".tar\")));\n    ret.setSize(len);\n    ret.setType(LocalResourceType.ARCHIVE);\n    ret.setVisibility(vis);\n    ret.setTimestamp(files.getFileStatus(new Path(p.toString() + \".tar\"))\n        .getModificationTime());\n    return ret;\n  }","commit_id":"6f236b28fff7d57b41860962027c382ea3d32858","url":"https://github.com/apache/hadoop"},{"original_method":"static LocalResource createJarFile(FileContext files, Path p, int len,\n      Random r, LocalResourceVisibility vis) throws IOException,\n      URISyntaxException {\n\n    FSDataOutputStream outFile = null;\n    try {\n      byte[] bytes = new byte[len];\n      Path tarPath = new Path(p.toString());\n      outFile = files.create(tarPath, EnumSet.of(CREATE, OVERWRITE));\n      r.nextBytes(bytes);\n      outFile.write(bytes);\n    } finally {\n      if (outFile != null)\n        outFile.close();\n    }\n    StringBuffer tarCommand = new StringBuffer();\n    URI u = new URI(p.getParent().toString());\n    tarCommand.append(\"cd '\");\n    tarCommand.append(FileUtil.makeShellPath(u.getPath().toString()));\n    tarCommand.append(\"' ; \");\n    tarCommand.append(\"jar cf \" + p.getName() + \".jar \" + p.getName());\n    String[] shellCmd = { \"bash\", \"-c\", tarCommand.toString() };\n    ShellCommandExecutor shexec = new ShellCommandExecutor(shellCmd);\n    shexec.execute();\n    int exitcode = shexec.getExitCode();\n    if (exitcode != 0) {\n      throw new IOException(\"Error untarring file \" + p\n          + \". Tar process exited with exit code \" + exitcode);\n    }\n    LocalResource ret = recordFactory.newRecordInstance(LocalResource.class);\n    ret.setResource(ConverterUtils.getYarnUrlFromPath(new Path(p.toString()\n        + \".jar\")));\n    ret.setSize(len);\n    ret.setType(LocalResourceType.ARCHIVE);\n    ret.setVisibility(vis);\n    ret.setTimestamp(files.getFileStatus(new Path(p.toString() + \".jar\"))\n        .getModificationTime());\n    return ret;\n  }","id":43211,"modified_method":"static LocalResource createJarFile(FileContext files, Path p, int len,\n      Random r, LocalResourceVisibility vis) throws IOException,\n      URISyntaxException {\n    byte[] bytes = new byte[len];\n    r.nextBytes(bytes);\n\n    File archiveFile = new File(p.toUri().getPath() + \".jar\");\n    archiveFile.createNewFile();\n    JarOutputStream out = new JarOutputStream(\n        new FileOutputStream(archiveFile));\n    out.putNextEntry(new JarEntry(p.getName()));\n    out.write(bytes);\n    out.closeEntry();\n    out.close();\n\n    LocalResource ret = recordFactory.newRecordInstance(LocalResource.class);\n    ret.setResource(ConverterUtils.getYarnUrlFromPath(new Path(p.toString()\n        + \".jar\")));\n    ret.setSize(len);\n    ret.setType(LocalResourceType.ARCHIVE);\n    ret.setVisibility(vis);\n    ret.setTimestamp(files.getFileStatus(new Path(p.toString() + \".jar\"))\n        .getModificationTime());\n    return ret;\n  }","commit_id":"6f236b28fff7d57b41860962027c382ea3d32858","url":"https://github.com/apache/hadoop"},{"original_method":"static LocalResource createZipFile(FileContext files, Path p, int len,\n      Random r, LocalResourceVisibility vis) throws IOException,\n      URISyntaxException {\n\n    FSDataOutputStream outFile = null;\n    try {\n      byte[] bytes = new byte[len];\n      Path tarPath = new Path(p.toString());\n      outFile = files.create(tarPath, EnumSet.of(CREATE, OVERWRITE));\n      r.nextBytes(bytes);\n      outFile.write(bytes);\n    } finally {\n      if (outFile != null)\n        outFile.close();\n    }\n    StringBuffer zipCommand = new StringBuffer();\n    URI u = new URI(p.getParent().toString());\n    zipCommand.append(\"cd '\");\n    zipCommand.append(FileUtil.makeShellPath(u.getPath().toString()));\n    zipCommand.append(\"' ; \");\n    zipCommand.append(\"gzip \" + p.getName());\n    String[] shellCmd = { \"bash\", \"-c\", zipCommand.toString() };\n    ShellCommandExecutor shexec = new ShellCommandExecutor(shellCmd);\n    shexec.execute();\n    int exitcode = shexec.getExitCode();\n    if (exitcode != 0) {\n      throw new IOException(\"Error untarring file \" + p\n          + \". Tar process exited with exit code \" + exitcode);\n    }\n    LocalResource ret = recordFactory.newRecordInstance(LocalResource.class);\n    ret.setResource(ConverterUtils.getYarnUrlFromPath(new Path(p.toString()\n        + \".zip\")));\n    ret.setSize(len);\n    ret.setType(LocalResourceType.ARCHIVE);\n    ret.setVisibility(vis);\n    ret.setTimestamp(files.getFileStatus(new Path(p.toString() + \".gz\"))\n        .getModificationTime());\n    return ret;\n  }","id":43212,"modified_method":"static LocalResource createZipFile(FileContext files, Path p, int len,\n      Random r, LocalResourceVisibility vis) throws IOException,\n      URISyntaxException {\n    byte[] bytes = new byte[len];\n    r.nextBytes(bytes);\n\n    File archiveFile = new File(p.toUri().getPath() + \".zip\");\n    archiveFile.createNewFile();\n    ZipOutputStream out = new ZipOutputStream(\n        new FileOutputStream(archiveFile));\n    out.putNextEntry(new ZipEntry(p.getName()));\n    out.write(bytes);\n    out.closeEntry();\n    out.close();\n\n    LocalResource ret = recordFactory.newRecordInstance(LocalResource.class);\n    ret.setResource(ConverterUtils.getYarnUrlFromPath(new Path(p.toString()\n        + \".zip\")));\n    ret.setSize(len);\n    ret.setType(LocalResourceType.ARCHIVE);\n    ret.setVisibility(vis);\n    ret.setTimestamp(files.getFileStatus(new Path(p.toString() + \".zip\"))\n        .getModificationTime());\n    return ret;\n  }","commit_id":"6f236b28fff7d57b41860962027c382ea3d32858","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * We are Bob. Verify message #3 from Alice, then send message #4 to Alice.\n     *\n     * Make sure the signatures are correct, and if they are, update the\n     * NIOConnection with the session key / peer ident / clock skew / iv.\n     * The NIOConnection itself is responsible for registering with the\n     * transport\n     */\n    private void verifyInbound() {\n        if (_corrupt) return;\n        byte b[] = _sz_aliceIdent_tsA_padding_aliceSig.toByteArray();\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(prefix()+\"decrypted sz(etc) data: \" + Base64.encode(b));\n\n        try {\n            RouterIdentity alice = new RouterIdentity();\n            int sz = (int)DataHelper.fromLong(b, 0, 2); // TO-DO: Hey zzz... Throws an NPE for me... see below, for my \"quick fix\", need to find out the real reason\n            if ( (sz <= 0) || (sz > b.length-2-4-Signature.SIGNATURE_BYTES) ) {\n                _context.statManager().addRateData(\"ntcp.invalidInboundSize\", sz);\n                fail(\"size is invalid\", new Exception(\"size is \" + sz));\n                return;\n            }\n            byte aliceData[] = new byte[sz];\n            System.arraycopy(b, 2, aliceData, 0, sz);\n            alice.fromByteArray(aliceData);\n            long tsA = DataHelper.fromLong(b, 2+sz, 4);\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream(768);\n            baos.write(_X);\n            baos.write(_Y);\n            baos.write(_context.routerHash().getData());\n            baos.write(DataHelper.toLong(4, tsA));\n            baos.write(DataHelper.toLong(4, _tsB));\n            //baos.write(b, 2+sz+4, b.length-2-sz-4-Signature.SIGNATURE_BYTES);\n\n            byte toVerify[] = baos.toByteArray();\n            if (_log.shouldLog(Log.DEBUG)) {\n                _log.debug(prefix()+\"checking \" + Base64.encode(toVerify, 0, 16));\n                //_log.debug(prefix()+\"check pad \" + Base64.encode(b, 2+sz+4, 12));\n            }\n\n            byte s[] = new byte[Signature.SIGNATURE_BYTES];\n            System.arraycopy(b, b.length-s.length, s, 0, s.length);\n            Signature sig = new Signature(s);\n            _verified = _context.dsa().verifySignature(sig, toVerify, alice.getSigningPublicKey());\n            if (_verified) {\n                // get inet-addr\n                InetAddress addr = this._con.getChannel().socket().getInetAddress();\n                byte[] ip = (addr == null) ? null : addr.getAddress();\n                if (_context.banlist().isBanlistedForever(alice.calculateHash())) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Dropping inbound connection from permanently banlisted peer: \" + alice.calculateHash().toBase64());\n                    // So next time we will not accept the con from this IP,\n                    // rather than doing the whole handshake\n                    if(ip != null)\n                       _context.blocklist().add(ip);\n                    fail(\"Peer is banlisted forever: \" + alice.calculateHash().toBase64());\n                    return;\n                }\n                if(ip != null)\n                   _transport.setIP(alice.calculateHash(), ip);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"verification successful for \" + _con);\n\n                long diff = 1000*Math.abs(tsA-_tsB);\n                if (!_context.clock().getUpdatedSuccessfully()) {\n                    // Adjust the clock one time in desperation\n                    // This isn't very likely, outbound will do it first\n                    _context.clock().setOffset(1000 * (_tsB - tsA), true);\n                    tsA = _tsB;\n                    if (diff != 0)\n                        _log.logAlways(Log.WARN, \"NTP failure, NTCP adjusting clock by \" + DataHelper.formatDuration(diff));\n                } else if (diff >= Router.CLOCK_FUDGE_FACTOR) {\n                    _context.statManager().addRateData(\"ntcp.invalidInboundSkew\", diff);\n                    _transport.markReachable(alice.calculateHash(), true);\n                    // Only banlist if we know what time it is\n                    _context.banlist().banlistRouter(DataHelper.formatDuration(diff),\n                                                       alice.calculateHash(),\n                                                       _x(\"Excessive clock skew: {0}\"));\n                    _transport.setLastBadSkew(tsA- _tsB);\n                    fail(\"Clocks too skewed (\" + diff + \" ms)\", null, true);\n                    return;\n                } else if (_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(prefix()+\"Clock skew: \" + diff + \" ms\");\n                }\n\n                sendInboundConfirm(alice, tsA);\n                _con.setRemotePeer(alice);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"e_bobSig is \" + _e_bobSig.length + \" bytes long\");\n                byte iv[] = new byte[16];\n                System.arraycopy(_e_bobSig, _e_bobSig.length-16, iv, 0, 16);\n                _con.finishInboundEstablishment(_dh.getSessionKey(), (tsA-_tsB), iv, _prevEncrypted); // skew in seconds\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(prefix()+\"Verified remote peer as \" + alice.calculateHash().toBase64());\n            } else {\n                _context.statManager().addRateData(\"ntcp.invalidInboundSignature\", 1);\n                fail(\"Peer verification failed - spoof of \" + alice.calculateHash().toBase64() + \"?\");\n            }\n        } catch (IOException ioe) {\n            _context.statManager().addRateData(\"ntcp.invalidInboundIOE\", 1);\n            fail(\"Error verifying peer\", ioe);\n        } catch (DataFormatException dfe) {\n            _context.statManager().addRateData(\"ntcp.invalidInboundDFE\", 1);\n            fail(\"Error verifying peer\", dfe);\n        } catch(NullPointerException npe) {\n            fail(\"Error verifying peer\", npe); // TO-DO: zzz This is that quick-fix. -- Sponge\n        }\n    }","id":43213,"modified_method":"/**\n     * We are Bob. Verify message #3 from Alice, then send message #4 to Alice.\n     *\n     * _aliceIdentSize and _aliceIdent must be set.\n     * _sz_aliceIdent_tsA_padding_aliceSig must contain at least\n     *  (2 + _aliceIdentSize + 4 + padding + sig) bytes.\n     *\n     * Sets _aliceIdent so that we\n     *\n     * readAliceRouterIdentity() must have been called previously\n     *\n     * Make sure the signatures are correct, and if they are, update the\n     * NIOConnection with the session key / peer ident / clock skew / iv.\n     * The NIOConnection itself is responsible for registering with the\n     * transport\n     */\n    private void verifyInbound() {\n        if (_corrupt) return;\n        byte b[] = _sz_aliceIdent_tsA_padding_aliceSig.toByteArray();\n        try {\n            int sz = _aliceIdentSize;\n            long tsA = DataHelper.fromLong(b, 2+sz, 4);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream(768);\n            baos.write(_X);\n            baos.write(_Y);\n            baos.write(_context.routerHash().getData());\n            baos.write(DataHelper.toLong(4, tsA));\n            baos.write(DataHelper.toLong(4, _tsB));\n            //baos.write(b, 2+sz+4, b.length-2-sz-4-Signature.SIGNATURE_BYTES);\n\n            byte toVerify[] = baos.toByteArray();\n            if (_log.shouldLog(Log.DEBUG)) {\n                _log.debug(prefix()+\"checking \" + Base64.encode(toVerify, 0, 16));\n                //_log.debug(prefix()+\"check pad \" + Base64.encode(b, 2+sz+4, 12));\n            }\n\n            // handle variable signature size\n            SigType type = _aliceIdent.getSigningPublicKey().getType();\n            if (type == null) {\n                fail(\"unsupported sig type\");\n                return;\n            }\n            byte s[] = new byte[type.getSigLen()];\n            System.arraycopy(b, b.length-s.length, s, 0, s.length);\n            Signature sig = new Signature(type, s);\n            _verified = _context.dsa().verifySignature(sig, toVerify, _aliceIdent.getSigningPublicKey());\n            if (_verified) {\n                // get inet-addr\n                InetAddress addr = this._con.getChannel().socket().getInetAddress();\n                byte[] ip = (addr == null) ? null : addr.getAddress();\n                if (_context.banlist().isBanlistedForever(_aliceIdent.calculateHash())) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Dropping inbound connection from permanently banlisted peer: \" + _aliceIdent.calculateHash());\n                    // So next time we will not accept the con from this IP,\n                    // rather than doing the whole handshake\n                    if(ip != null)\n                       _context.blocklist().add(ip);\n                    fail(\"Peer is banlisted forever: \" + _aliceIdent.calculateHash());\n                    return;\n                }\n                if(ip != null)\n                   _transport.setIP(_aliceIdent.calculateHash(), ip);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"verification successful for \" + _con);\n\n                long diff = 1000*Math.abs(tsA-_tsB);\n                if (!_context.clock().getUpdatedSuccessfully()) {\n                    // Adjust the clock one time in desperation\n                    // This isn't very likely, outbound will do it first\n                    _context.clock().setOffset(1000 * (_tsB - tsA), true);\n                    tsA = _tsB;\n                    if (diff != 0)\n                        _log.logAlways(Log.WARN, \"NTP failure, NTCP adjusting clock by \" + DataHelper.formatDuration(diff));\n                } else if (diff >= Router.CLOCK_FUDGE_FACTOR) {\n                    _context.statManager().addRateData(\"ntcp.invalidInboundSkew\", diff);\n                    _transport.markReachable(_aliceIdent.calculateHash(), true);\n                    // Only banlist if we know what time it is\n                    _context.banlist().banlistRouter(DataHelper.formatDuration(diff),\n                                                       _aliceIdent.calculateHash(),\n                                                       _x(\"Excessive clock skew: {0}\"));\n                    _transport.setLastBadSkew(tsA- _tsB);\n                    fail(\"Clocks too skewed (\" + diff + \" ms)\", null, true);\n                    return;\n                } else if (_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(prefix()+\"Clock skew: \" + diff + \" ms\");\n                }\n\n                sendInboundConfirm(_aliceIdent, tsA);\n                _con.setRemotePeer(_aliceIdent);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"e_bobSig is \" + _e_bobSig.length + \" bytes long\");\n                byte iv[] = new byte[16];\n                System.arraycopy(_e_bobSig, _e_bobSig.length-16, iv, 0, 16);\n                _con.finishInboundEstablishment(_dh.getSessionKey(), (tsA-_tsB), iv, _prevEncrypted); // skew in seconds\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(prefix()+\"Verified remote peer as \" + _aliceIdent.calculateHash());\n            } else {\n                _context.statManager().addRateData(\"ntcp.invalidInboundSignature\", 1);\n                fail(\"Peer verification failed - spoof of \" + _aliceIdent.calculateHash() + \"?\");\n            }\n        } catch (IOException ioe) {\n            _context.statManager().addRateData(\"ntcp.invalidInboundIOE\", 1);\n            fail(\"Error verifying peer\", ioe);\n        }\n    }","commit_id":"51f9d6d421b68e2f3c177442ccaa511336c7b8c6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  We are Alice, so receive these bytes as part of an outbound connection.\n     *  This method receives messages 2 and 4, and sends message 3.\n     *\n     *  All data must be copied out of the buffer as Reader.processRead()\n     *  will return it to the pool.\n     */\n    private void receiveOutbound(ByteBuffer src) {\n        if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix()+\"Receive outbound \" + src + \" received=\" + _received);\n\n        // recv Y+E(H(X+Y)+tsB, sk, Y[239:255])\n        while (_received < _Y.length && src.hasRemaining()) {\n            byte c = src.get();\n            _Y[_received++] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv x\" + (int)c + \" received=\" + _received);\n            if (_received >= _Y.length) {\n                try {\n                    _dh.setPeerPublicValue(_Y);\n                    _dh.getSessionKey(); // force the calc\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"DH session key calculated (\" + _dh.getSessionKey().toBase64() + \")\");\n                    _e_hXY_tsB = new byte[Hash.HASH_LENGTH+4+12];\n                } catch (DHSessionKeyBuilder.InvalidPublicParameterException e) {\n                    _context.statManager().addRateData(\"ntcp.invalidDH\", 1);\n                    fail(\"Invalid X\", e);\n                    return;\n                }\n            }\n        }\n        if (_e_hXY_tsB == null) return; // !src.hasRemaining\n\n        while (_received < _Y.length + _e_hXY_tsB.length && src.hasRemaining()) {\n            int i = _received-_Y.length;\n            _received++;\n            byte c = src.get();\n            _e_hXY_tsB[i] = c;\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(prefix() + \"recv _e_hXY_tsB \" + (int)c + \" received=\" + _received);\n            if (i+1 >= _e_hXY_tsB.length) {\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix() + \"received _e_hXY_tsB fully\");\n                byte hXY_tsB[] = new byte[_e_hXY_tsB.length];\n                _context.aes().decrypt(_e_hXY_tsB, 0, hXY_tsB, 0, _dh.getSessionKey(), _Y, _Y.length-16, _e_hXY_tsB.length);\n                byte XY[] = new byte[_X.length + _Y.length];\n                System.arraycopy(_X, 0, XY, 0, _X.length);\n                System.arraycopy(_Y, 0, XY, _X.length, _Y.length);\n                byte[] h = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                _context.sha().calculateHash(XY, 0, XY.length, h, 0);\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(prefix() + \"h(XY)=\" + h.toBase64());\n                if (!DataHelper.eq(h, 0, hXY_tsB, 0, Hash.HASH_LENGTH)) {\n                    SimpleByteCache.release(h);\n                    _context.statManager().addRateData(\"ntcp.invalidHXY\", 1);\n                    fail(\"Invalid H(X+Y) - mitm attack attempted?\");\n                    return;\n                }\n                SimpleByteCache.release(h);\n                _tsB = DataHelper.fromLong(hXY_tsB, Hash.HASH_LENGTH, 4); // their (Bob's) timestamp in seconds\n                _tsA = (_context.clock().now() + 500) / 1000; // our (Alice's) timestamp in seconds\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"h(X+Y) is correct, tsA-tsB=\" + (_tsA-_tsB));\n\n                // the skew is not authenticated yet, but it is certainly fatal to\n                // the establishment, so fail hard if appropriate\n                long diff = 1000*Math.abs(_tsA-_tsB);\n                if (!_context.clock().getUpdatedSuccessfully()) {\n                    // Adjust the clock one time in desperation\n                    _context.clock().setOffset(1000 * (_tsB - _tsA), true);\n                    _tsA = _tsB;\n                    if (diff != 0)\n                        _log.logAlways(Log.WARN, \"NTP failure, NTCP adjusting clock by \" + DataHelper.formatDuration(diff));\n                } else if (diff >= Router.CLOCK_FUDGE_FACTOR) {\n                    _context.statManager().addRateData(\"ntcp.invalidOutboundSkew\", diff);\n                    _transport.markReachable(_con.getRemotePeer().calculateHash(), false);\n                    // Only banlist if we know what time it is\n                    _context.banlist().banlistRouter(DataHelper.formatDuration(diff),\n                                                       _con.getRemotePeer().calculateHash(),\n                                                       _x(\"Excessive clock skew: {0}\"));\n                    _transport.setLastBadSkew(_tsA- _tsB);\n                    fail(\"Clocks too skewed (\" + diff + \" ms)\", null, true);\n                    return;\n                } else if (_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(prefix()+\"Clock skew: \" + diff + \" ms\");\n                }\n\n                // now prepare and send our response\n                // send E(#+Alice.identity+tsA+padding+S(X+Y+Bob.identHash+tsA+tsB), sk, hX_xor_Bob.identHash[16:31])\n                int sigSize = _X.length+_Y.length+Hash.HASH_LENGTH+4+4;//+12;\n                byte preSign[] = new byte[sigSize];\n                System.arraycopy(_X, 0, preSign, 0, _X.length);\n                System.arraycopy(_Y, 0, preSign, _X.length, _Y.length);\n                System.arraycopy(_con.getRemotePeer().calculateHash().getData(), 0, preSign, _X.length+_Y.length, Hash.HASH_LENGTH);\n                DataHelper.toLong(preSign, _X.length+_Y.length+Hash.HASH_LENGTH, 4, _tsA);\n                DataHelper.toLong(preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4, 4, _tsB);\n                // hXY_tsB has 12 bytes of padding (size=48, tsB=4 + hXY=32)\n                //System.arraycopy(hXY_tsB, hXY_tsB.length-12, preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4+4, 12);\n                //byte sigPad[] = new byte[padSig];\n                //_context.random().nextBytes(sigPad);\n                //System.arraycopy(sigPad, 0, preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4+4, padSig);\n                Signature sig = _context.dsa().sign(preSign, _context.keyManager().getSigningPrivateKey());\n\n                //if (_log.shouldLog(Log.DEBUG)) {\n                //    _log.debug(prefix()+\"signing \" + Base64.encode(preSign));\n                //}\n\n                byte ident[] = _context.router().getRouterInfo().getIdentity().toByteArray();\n                int min = 2+ident.length+4+Signature.SIGNATURE_BYTES;\n                int rem = min % 16;\n                int padding = 0;\n                if (rem > 0)\n                    padding = 16 - rem;\n                byte preEncrypt[] = new byte[min+padding];\n                DataHelper.toLong(preEncrypt, 0, 2, ident.length);\n                System.arraycopy(ident, 0, preEncrypt, 2, ident.length);\n                DataHelper.toLong(preEncrypt, 2+ident.length, 4, _tsA);\n                if (padding > 0)\n                    _context.random().nextBytes(preEncrypt, 2 + ident.length + 4, padding);\n                System.arraycopy(sig.getData(), 0, preEncrypt, 2+ident.length+4+padding, Signature.SIGNATURE_BYTES);\n\n                _prevEncrypted = new byte[preEncrypt.length];\n                _context.aes().encrypt(preEncrypt, 0, _prevEncrypted, 0, _dh.getSessionKey(), _hX_xor_bobIdentHash, _hX_xor_bobIdentHash.length-16, preEncrypt.length);\n\n                //if (_log.shouldLog(Log.DEBUG)) {\n                    //_log.debug(prefix() + \"unencrypted response to Bob: \" + Base64.encode(preEncrypt));\n                    //_log.debug(prefix() + \"encrypted response to Bob: \" + Base64.encode(_prevEncrypted));\n                //}\n                // send 'er off (when the bw limiter says, etc)\n                _transport.getPumper().wantsWrite(_con, _prevEncrypted);\n            }\n        }\n        if (_received >= _Y.length + _e_hXY_tsB.length && src.hasRemaining()) {\n            // we are receiving their confirmation\n\n            // recv E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev)\n            int off = 0;\n            if (_e_bobSig == null) {\n                _e_bobSig = new byte[48];\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"receiving E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev) (remaining? \" + src.hasRemaining() + \")\");\n            } else {\n                off = _received - _Y.length - _e_hXY_tsB.length;\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"continuing to receive E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev) (remaining? \" + src.hasRemaining() + \" off=\" + off + \" recv=\" + _received + \")\");\n            }\n            while (src.hasRemaining() && off < _e_bobSig.length) {\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix()+\"recv bobSig received=\" + _received);\n                _e_bobSig[off++] = src.get();\n                _received++;\n\n                if (off >= _e_bobSig.length) {\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix() + \"received E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev): \" + Base64.encode(_e_bobSig));\n                    byte bobSig[] = new byte[_e_bobSig.length];\n                    _context.aes().decrypt(_e_bobSig, 0, bobSig, 0, _dh.getSessionKey(), _e_hXY_tsB, _e_hXY_tsB.length-16, _e_bobSig.length);\n                    // ignore the padding\n                    byte bobSigData[] = new byte[Signature.SIGNATURE_BYTES];\n                    System.arraycopy(bobSig, 0, bobSigData, 0, Signature.SIGNATURE_BYTES);\n                    Signature sig = new Signature(bobSigData);\n\n                    byte toVerify[] = new byte[_X.length+_Y.length+Hash.HASH_LENGTH+4+4];\n                    int voff = 0;\n                    System.arraycopy(_X, 0, toVerify, voff, _X.length); voff += _X.length;\n                    System.arraycopy(_Y, 0, toVerify, voff, _Y.length); voff += _Y.length;\n                    System.arraycopy(_context.routerHash().getData(), 0, toVerify, voff, Hash.HASH_LENGTH); voff += Hash.HASH_LENGTH;\n                    DataHelper.toLong(toVerify, voff, 4, _tsA); voff += 4;\n                    DataHelper.toLong(toVerify, voff, 4, _tsB); voff += 4;\n\n                    _verified = _context.dsa().verifySignature(sig, toVerify, _con.getRemotePeer().getSigningPublicKey());\n                    if (!_verified) {\n                        _context.statManager().addRateData(\"ntcp.invalidSignature\", 1);\n                        fail(\"Signature was invalid - attempt to spoof \" + _con.getRemotePeer().calculateHash().toBase64() + \"?\");\n                    } else {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(prefix() + \"signature verified from Bob.  done!\");\n                        prepareExtra(src);\n                        byte nextWriteIV[] = new byte[16];\n                        System.arraycopy(_prevEncrypted, _prevEncrypted.length-16, nextWriteIV, 0, 16);\n                        byte nextReadIV[] = new byte[16];\n                        System.arraycopy(_e_bobSig, _e_bobSig.length-16, nextReadIV, 0, nextReadIV.length);\n                        _con.finishOutboundEstablishment(_dh.getSessionKey(), (_tsA-_tsB), nextWriteIV, nextReadIV); // skew in seconds\n                        // if socket gets closed this will be null - prevent NPE\n                        InetAddress ia = _con.getChannel().socket().getInetAddress();\n                        if (ia != null)\n                            _transport.setIP(_con.getRemotePeer().calculateHash(), ia.getAddress());\n                    }\n                    return;\n                }\n            }\n        }\n    }","id":43214,"modified_method":"/**\n     *  We are Alice, so receive these bytes as part of an outbound connection.\n     *  This method receives messages 2 and 4, and sends message 3.\n     *\n     *  All data must be copied out of the buffer as Reader.processRead()\n     *  will return it to the pool.\n     */\n    private void receiveOutbound(ByteBuffer src) {\n        if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix()+\"Receive outbound \" + src + \" received=\" + _received);\n\n        // recv Y+E(H(X+Y)+tsB, sk, Y[239:255])\n        while (_received < _Y.length && src.hasRemaining()) {\n            byte c = src.get();\n            _Y[_received++] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv x\" + (int)c + \" received=\" + _received);\n            if (_received >= _Y.length) {\n                try {\n                    _dh.setPeerPublicValue(_Y);\n                    _dh.getSessionKey(); // force the calc\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"DH session key calculated (\" + _dh.getSessionKey().toBase64() + \")\");\n                    _e_hXY_tsB = new byte[Hash.HASH_LENGTH+4+12];\n                } catch (DHSessionKeyBuilder.InvalidPublicParameterException e) {\n                    _context.statManager().addRateData(\"ntcp.invalidDH\", 1);\n                    fail(\"Invalid X\", e);\n                    return;\n                }\n            }\n        }\n        if (_e_hXY_tsB == null) return; // !src.hasRemaining\n\n        while (_received < _Y.length + _e_hXY_tsB.length && src.hasRemaining()) {\n            int i = _received-_Y.length;\n            _received++;\n            byte c = src.get();\n            _e_hXY_tsB[i] = c;\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(prefix() + \"recv _e_hXY_tsB \" + (int)c + \" received=\" + _received);\n            if (i+1 >= _e_hXY_tsB.length) {\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix() + \"received _e_hXY_tsB fully\");\n                byte hXY_tsB[] = new byte[_e_hXY_tsB.length];\n                _context.aes().decrypt(_e_hXY_tsB, 0, hXY_tsB, 0, _dh.getSessionKey(), _Y, _Y.length-16, _e_hXY_tsB.length);\n                byte XY[] = new byte[_X.length + _Y.length];\n                System.arraycopy(_X, 0, XY, 0, _X.length);\n                System.arraycopy(_Y, 0, XY, _X.length, _Y.length);\n                byte[] h = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                _context.sha().calculateHash(XY, 0, XY.length, h, 0);\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(prefix() + \"h(XY)=\" + h.toBase64());\n                if (!DataHelper.eq(h, 0, hXY_tsB, 0, Hash.HASH_LENGTH)) {\n                    SimpleByteCache.release(h);\n                    _context.statManager().addRateData(\"ntcp.invalidHXY\", 1);\n                    fail(\"Invalid H(X+Y) - mitm attack attempted?\");\n                    return;\n                }\n                SimpleByteCache.release(h);\n                _tsB = DataHelper.fromLong(hXY_tsB, Hash.HASH_LENGTH, 4); // their (Bob's) timestamp in seconds\n                _tsA = (_context.clock().now() + 500) / 1000; // our (Alice's) timestamp in seconds\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"h(X+Y) is correct, tsA-tsB=\" + (_tsA-_tsB));\n\n                // the skew is not authenticated yet, but it is certainly fatal to\n                // the establishment, so fail hard if appropriate\n                long diff = 1000*Math.abs(_tsA-_tsB);\n                if (!_context.clock().getUpdatedSuccessfully()) {\n                    // Adjust the clock one time in desperation\n                    _context.clock().setOffset(1000 * (_tsB - _tsA), true);\n                    _tsA = _tsB;\n                    if (diff != 0)\n                        _log.logAlways(Log.WARN, \"NTP failure, NTCP adjusting clock by \" + DataHelper.formatDuration(diff));\n                } else if (diff >= Router.CLOCK_FUDGE_FACTOR) {\n                    _context.statManager().addRateData(\"ntcp.invalidOutboundSkew\", diff);\n                    _transport.markReachable(_con.getRemotePeer().calculateHash(), false);\n                    // Only banlist if we know what time it is\n                    _context.banlist().banlistRouter(DataHelper.formatDuration(diff),\n                                                       _con.getRemotePeer().calculateHash(),\n                                                       _x(\"Excessive clock skew: {0}\"));\n                    _transport.setLastBadSkew(_tsA- _tsB);\n                    fail(\"Clocks too skewed (\" + diff + \" ms)\", null, true);\n                    return;\n                } else if (_log.shouldLog(Log.DEBUG)) {\n                    _log.debug(prefix()+\"Clock skew: \" + diff + \" ms\");\n                }\n\n                // now prepare and send our response\n                // send E(#+Alice.identity+tsA+padding+S(X+Y+Bob.identHash+tsA+tsB), sk, hX_xor_Bob.identHash[16:31])\n                int sigSize = _X.length+_Y.length+Hash.HASH_LENGTH+4+4;//+12;\n                byte preSign[] = new byte[sigSize];\n                System.arraycopy(_X, 0, preSign, 0, _X.length);\n                System.arraycopy(_Y, 0, preSign, _X.length, _Y.length);\n                System.arraycopy(_con.getRemotePeer().calculateHash().getData(), 0, preSign, _X.length+_Y.length, Hash.HASH_LENGTH);\n                DataHelper.toLong(preSign, _X.length+_Y.length+Hash.HASH_LENGTH, 4, _tsA);\n                DataHelper.toLong(preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4, 4, _tsB);\n                // hXY_tsB has 12 bytes of padding (size=48, tsB=4 + hXY=32)\n                //System.arraycopy(hXY_tsB, hXY_tsB.length-12, preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4+4, 12);\n                //byte sigPad[] = new byte[padSig];\n                //_context.random().nextBytes(sigPad);\n                //System.arraycopy(sigPad, 0, preSign, _X.length+_Y.length+Hash.HASH_LENGTH+4+4, padSig);\n                Signature sig = _context.dsa().sign(preSign, _context.keyManager().getSigningPrivateKey());\n\n                //if (_log.shouldLog(Log.DEBUG)) {\n                //    _log.debug(prefix()+\"signing \" + Base64.encode(preSign));\n                //}\n\n                byte ident[] = _context.router().getRouterInfo().getIdentity().toByteArray();\n                // handle variable signature size\n                int min = 2 + ident.length + 4 + sig.length();\n                int rem = min % 16;\n                int padding = 0;\n                if (rem > 0)\n                    padding = 16 - rem;\n                byte preEncrypt[] = new byte[min+padding];\n                DataHelper.toLong(preEncrypt, 0, 2, ident.length);\n                System.arraycopy(ident, 0, preEncrypt, 2, ident.length);\n                DataHelper.toLong(preEncrypt, 2+ident.length, 4, _tsA);\n                if (padding > 0)\n                    _context.random().nextBytes(preEncrypt, 2 + ident.length + 4, padding);\n                System.arraycopy(sig.getData(), 0, preEncrypt, 2+ident.length+4+padding, sig.length());\n\n                _prevEncrypted = new byte[preEncrypt.length];\n                _context.aes().encrypt(preEncrypt, 0, _prevEncrypted, 0, _dh.getSessionKey(),\n                                       _hX_xor_bobIdentHash, _hX_xor_bobIdentHash.length-16, preEncrypt.length);\n\n                //if (_log.shouldLog(Log.DEBUG)) {\n                    //_log.debug(prefix() + \"unencrypted response to Bob: \" + Base64.encode(preEncrypt));\n                    //_log.debug(prefix() + \"encrypted response to Bob: \" + Base64.encode(_prevEncrypted));\n                //}\n                // send 'er off (when the bw limiter says, etc)\n                _transport.getPumper().wantsWrite(_con, _prevEncrypted);\n            }\n        }\n        if (_received >= _Y.length + _e_hXY_tsB.length && src.hasRemaining()) {\n            // we are receiving their confirmation\n\n            // recv E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev)\n            int off = 0;\n            if (_e_bobSig == null) {\n                // handle variable signature size\n                int siglen = _con.getRemotePeer().getSigningPublicKey().getType().getSigLen();\n                int rem = siglen % 16;\n                int padding;\n                if (rem > 0)\n                    padding = 16 - rem;\n                else\n                    padding = 0;\n                _e_bobSig = new byte[siglen + padding];\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"receiving E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev) (remaining? \" +\n                               src.hasRemaining() + \")\");\n            } else {\n                off = _received - _Y.length - _e_hXY_tsB.length;\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix() + \"continuing to receive E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev) (remaining? \" +\n                               src.hasRemaining() + \" off=\" + off + \" recv=\" + _received + \")\");\n            }\n            while (src.hasRemaining() && off < _e_bobSig.length) {\n                if (_log.shouldLog(Log.DEBUG)) _log.debug(prefix()+\"recv bobSig received=\" + _received);\n                _e_bobSig[off++] = src.get();\n                _received++;\n\n                if (off >= _e_bobSig.length) {\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix() + \"received E(S(X+Y+Alice.identHash+tsA+tsB)+padding, sk, prev): \" + Base64.encode(_e_bobSig));\n                    byte bobSig[] = new byte[_e_bobSig.length];\n                    _context.aes().decrypt(_e_bobSig, 0, bobSig, 0, _dh.getSessionKey(),\n                                           _e_hXY_tsB, _e_hXY_tsB.length-16, _e_bobSig.length);\n                    // ignore the padding\n                    // handle variable signature size\n                    SigType type = _con.getRemotePeer().getSigningPublicKey().getType();\n                    int siglen = type.getSigLen();\n                    byte bobSigData[] = new byte[siglen];\n                    System.arraycopy(bobSig, 0, bobSigData, 0, siglen);\n                    Signature sig = new Signature(type, bobSigData);\n\n                    byte toVerify[] = new byte[_X.length+_Y.length+Hash.HASH_LENGTH+4+4];\n                    int voff = 0;\n                    System.arraycopy(_X, 0, toVerify, voff, _X.length); voff += _X.length;\n                    System.arraycopy(_Y, 0, toVerify, voff, _Y.length); voff += _Y.length;\n                    System.arraycopy(_context.routerHash().getData(), 0, toVerify, voff, Hash.HASH_LENGTH); voff += Hash.HASH_LENGTH;\n                    DataHelper.toLong(toVerify, voff, 4, _tsA); voff += 4;\n                    DataHelper.toLong(toVerify, voff, 4, _tsB); voff += 4;\n\n                    _verified = _context.dsa().verifySignature(sig, toVerify, _con.getRemotePeer().getSigningPublicKey());\n                    if (!_verified) {\n                        _context.statManager().addRateData(\"ntcp.invalidSignature\", 1);\n                        fail(\"Signature was invalid - attempt to spoof \" + _con.getRemotePeer().calculateHash().toBase64() + \"?\");\n                    } else {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(prefix() + \"signature verified from Bob.  done!\");\n                        prepareExtra(src);\n                        byte nextWriteIV[] = new byte[16];\n                        System.arraycopy(_prevEncrypted, _prevEncrypted.length-16, nextWriteIV, 0, 16);\n                        byte nextReadIV[] = new byte[16];\n                        System.arraycopy(_e_bobSig, _e_bobSig.length-16, nextReadIV, 0, nextReadIV.length);\n                        _con.finishOutboundEstablishment(_dh.getSessionKey(), (_tsA-_tsB), nextWriteIV, nextReadIV); // skew in seconds\n                        // if socket gets closed this will be null - prevent NPE\n                        InetAddress ia = _con.getChannel().socket().getInetAddress();\n                        if (ia != null)\n                            _transport.setIP(_con.getRemotePeer().calculateHash(), ia.getAddress());\n                    }\n                    return;\n                }\n            }\n        }\n    }","commit_id":"51f9d6d421b68e2f3c177442ccaa511336c7b8c6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  We are Bob. Send message #4 to Alice.\n     */\n    private void sendInboundConfirm(RouterIdentity alice, long tsA) {\n        // send Alice E(S(X+Y+Alice.identHash+tsA+tsB), sk, prev)\n        byte toSign[] = new byte[256+256+32+4+4];\n        int off = 0;\n        System.arraycopy(_X, 0, toSign, off, 256); off += 256;\n        System.arraycopy(_Y, 0, toSign, off, 256); off += 256;\n        Hash h = alice.calculateHash();\n        System.arraycopy(h.getData(), 0, toSign, off, 32); off += 32;\n        DataHelper.toLong(toSign, off, 4, tsA); off += 4;\n        DataHelper.toLong(toSign, off, 4, _tsB); off += 4;\n\n        Signature sig = _context.dsa().sign(toSign, _context.keyManager().getSigningPrivateKey());\n        byte preSig[] = new byte[Signature.SIGNATURE_BYTES+8];\n        System.arraycopy(sig.getData(), 0, preSig, 0, Signature.SIGNATURE_BYTES);\n        _context.random().nextBytes(preSig, Signature.SIGNATURE_BYTES, 8);\n        _e_bobSig = new byte[preSig.length];\n        _context.aes().encrypt(preSig, 0, _e_bobSig, 0, _dh.getSessionKey(), _e_hXY_tsB, _e_hXY_tsB.length-16, _e_bobSig.length);\n\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(prefix() + \"Sending encrypted inbound confirmation\");\n        _transport.getPumper().wantsWrite(_con, _e_bobSig);\n    }","id":43215,"modified_method":"/**\n     *  We are Bob. Send message #4 to Alice.\n     */\n    private void sendInboundConfirm(RouterIdentity alice, long tsA) {\n        // send Alice E(S(X+Y+Alice.identHash+tsA+tsB), sk, prev)\n        byte toSign[] = new byte[256+256+32+4+4];\n        int off = 0;\n        System.arraycopy(_X, 0, toSign, off, 256); off += 256;\n        System.arraycopy(_Y, 0, toSign, off, 256); off += 256;\n        Hash h = alice.calculateHash();\n        System.arraycopy(h.getData(), 0, toSign, off, 32); off += 32;\n        DataHelper.toLong(toSign, off, 4, tsA); off += 4;\n        DataHelper.toLong(toSign, off, 4, _tsB); off += 4;\n\n        // handle variable signature size\n        Signature sig = _context.dsa().sign(toSign, _context.keyManager().getSigningPrivateKey());\n        int siglen = sig.length();\n        int rem = siglen % 16;\n        int padding;\n        if (rem > 0)\n            padding = 16 - rem;\n        else\n            padding = 0;\n        byte preSig[] = new byte[siglen + padding];\n        System.arraycopy(sig.getData(), 0, preSig, 0, siglen);\n        if (padding > 0)\n            _context.random().nextBytes(preSig, siglen, padding);\n        _e_bobSig = new byte[preSig.length];\n        _context.aes().encrypt(preSig, 0, _e_bobSig, 0, _dh.getSessionKey(), _e_hXY_tsB, _e_hXY_tsB.length-16, _e_bobSig.length);\n\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(prefix() + \"Sending encrypted inbound confirmation\");\n        _transport.getPumper().wantsWrite(_con, _e_bobSig);\n    }","commit_id":"51f9d6d421b68e2f3c177442ccaa511336c7b8c6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  we are Bob, so receive these bytes as part of an inbound connection\n     *  This method receives messages 1 and 3, and sends messages 2 and 4.\n     *\n     *  All data must be copied out of the buffer as Reader.processRead()\n     *  will return it to the pool.\n     */\n    private void receiveInbound(ByteBuffer src) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(prefix()+\"Receiving inbound: prev received=\" + _received + \" src.remaining=\" + src.remaining());\n        while (_received < _X.length && src.hasRemaining()) {\n            byte c = src.get();\n            _X[_received++] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv x\" + (int)c + \" received=\" + _received);\n            //if (_received >= _X.length) {\n            //    if (isCheckInfo(_context, _context.routerHash(), _X)) {\n            //        _context.statManager().addRateData(\"ntcp.inboundCheckConnection\", 1);\n            //        fail(\"Incoming connection was a check connection\");\n            //        return;\n            //    }\n            //}\n        }\n        while (_received < _X.length + _hX_xor_bobIdentHash.length && src.hasRemaining()) {\n            int i = _received-_X.length;\n            _received++;\n            byte c = src.get();\n            _hX_xor_bobIdentHash[i] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv bih\" + (int)c + \" received=\" + _received);\n        }\n\n        if (_received >= _X.length + _hX_xor_bobIdentHash.length) {\n            if (_dh.getSessionKey() == null) {\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"Enough data for a DH received\");\n\n                // first verify that Alice knows who she is trying to talk with and that the X\n                // isn't corrupt\n                byte[] realXor = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                _context.sha().calculateHash(_X, 0, _X.length, realXor, 0);\n                xor32(_context.routerHash().getData(), realXor);\n                //if (_log.shouldLog(Log.DEBUG)) {\n                    //_log.debug(prefix()+\"_X = \" + Base64.encode(_X));\n                //    _log.debug(prefix()+\"hx = \" + Base64.encode(hX.getData()));\n                //    _log.debug(prefix()+\"bih=\" + Base64.encode(_context.routerHash().getData()));\n                //    _log.debug(prefix()+\"xor=\" + Base64.encode(realXor));\n                //}\n                if (!DataHelper.eq(realXor, _hX_xor_bobIdentHash)) {\n                    SimpleByteCache.release(realXor);\n                    _context.statManager().addRateData(\"ntcp.invalidHXxorBIH\", 1);\n                    fail(\"Invalid hX_xor\");\n                    return;\n                }\n                SimpleByteCache.release(realXor);\n                if (!_transport.isHXHIValid(_hX_xor_bobIdentHash)) {\n                    // blocklist source? but spoofed IPs could DoS us\n                    _context.statManager().addRateData(\"ntcp.replayHXxorBIH\", 1);\n                    fail(\"Replay hX_xor\");\n                    return;\n                }\n\n                try {\n                    // ok, they're actually trying to talk to us, and we got their (unauthenticated) X\n                    _dh.setPeerPublicValue(_X);\n                    _dh.getSessionKey(); // force the calc\n                    System.arraycopy(realXor, 16, _prevEncrypted, 0, _prevEncrypted.length);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"DH session key calculated (\" + _dh.getSessionKey().toBase64() + \")\");\n\n                    // now prepare our response: Y+E(H(X+Y)+tsB+padding, sk, Y[239:255])\n                    _Y = _dh.getMyPublicValueBytes();\n                    byte xy[] = new byte[_X.length+_Y.length];\n                    System.arraycopy(_X, 0, xy, 0, _X.length);\n                    System.arraycopy(_Y, 0, xy, _X.length, _Y.length);\n                    byte[] hxy = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                    _context.sha().calculateHash(xy, 0, xy.length, hxy, 0);\n                    _tsB = (_context.clock().now() + 500) / 1000l; // our (Bob's) timestamp in seconds\n                    byte toEncrypt[] = new byte[hxy.length + (4 + 12)];  // 48\n                    System.arraycopy(hxy, 0, toEncrypt, 0, hxy.length);\n                    byte tsB[] = DataHelper.toLong(4, _tsB);\n                    System.arraycopy(tsB, 0, toEncrypt, hxy.length, tsB.length);\n                    //DataHelper.toLong(toEncrypt, hxy.getData().length, 4, _tsB);\n                    _context.random().nextBytes(toEncrypt, hxy.length + 4, 12);\n                    if (_log.shouldLog(Log.DEBUG)) {\n                        //_log.debug(prefix()+\"Y=\"+Base64.encode(_Y));\n                        //_log.debug(prefix()+\"x+y=\"+Base64.encode(xy));\n                        _log.debug(prefix()+\"h(x+y)=\"+Base64.encode(hxy));\n                        _log.debug(prefix()+\"tsb=\"+Base64.encode(tsB));\n                        _log.debug(prefix()+\"unencrypted H(X+Y)+tsB+padding: \" + Base64.encode(toEncrypt));\n                        _log.debug(prefix()+\"encryption iv= \" + Base64.encode(_Y, _Y.length-16, 16));\n                        _log.debug(prefix()+\"encryption key= \" + _dh.getSessionKey().toBase64());\n                    }\n                    SimpleByteCache.release(hxy);\n                    _e_hXY_tsB = new byte[toEncrypt.length];\n                    _context.aes().encrypt(toEncrypt, 0, _e_hXY_tsB, 0, _dh.getSessionKey(), _Y, _Y.length-16, toEncrypt.length);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"encrypted H(X+Y)+tsB+padding: \" + Base64.encode(_e_hXY_tsB));\n                    byte write[] = new byte[_Y.length + _e_hXY_tsB.length];\n                    System.arraycopy(_Y, 0, write, 0, _Y.length);\n                    System.arraycopy(_e_hXY_tsB, 0, write, _Y.length, _e_hXY_tsB.length);\n\n                    // ok, now that is prepared, we want to actually send it, so make sure we are up for writing\n                    _transport.getPumper().wantsWrite(_con, write);\n                    if (!src.hasRemaining()) return;\n                } catch (DHSessionKeyBuilder.InvalidPublicParameterException e) {\n                    _context.statManager().addRateData(\"ntcp.invalidDH\", 1);\n                    fail(\"Invalid X\", e);\n                    return;\n                }\n            }\n\n            // ok, we are onto the encrypted area\n            while (src.hasRemaining() && !_corrupt) {\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(prefix()+\"Encrypted bytes available (\" + src.hasRemaining() + \")\");\n                while (_curEncryptedOffset < _curEncrypted.length && src.hasRemaining()) {\n                    _curEncrypted[_curEncryptedOffset++] = src.get();\n                    _received++;\n                }\n                if (_curEncryptedOffset >= _curEncrypted.length) {\n                    _context.aes().decrypt(_curEncrypted, 0, _curDecrypted, 0, _dh.getSessionKey(), _prevEncrypted, 0, _curEncrypted.length);\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix()+\"full block read and decrypted: \" + Base64.encode(_curDecrypted));\n\n                    byte swap[] = new byte[16];\n                    _prevEncrypted = _curEncrypted;\n                    _curEncrypted = swap;\n                    _curEncryptedOffset = 0;\n\n                    if (_aliceIdentSize <= 0) { // we are on the first decrypted block\n                        _aliceIdentSize = (int)DataHelper.fromLong(_curDecrypted, 0, 2);\n                        _sz_aliceIdent_tsA_padding_aliceSigSize = 2 + _aliceIdentSize + 4 + Signature.SIGNATURE_BYTES;\n                        int rem = (_sz_aliceIdent_tsA_padding_aliceSigSize % 16);\n                        int padding = 0;\n                        if (rem > 0)\n                            padding = 16-rem;\n                        _sz_aliceIdent_tsA_padding_aliceSigSize += padding;\n                        try {\n                            _sz_aliceIdent_tsA_padding_aliceSig.write(_curDecrypted);\n                        } catch (IOException ioe) {\n                            if (_log.shouldLog(Log.ERROR)) _log.error(prefix()+\"Error writing to the baos?\", ioe);\n                        }\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(prefix()+\"alice ident size decrypted as \" + _aliceIdentSize + \", making the padding at \" + padding + \" and total size at \" + _sz_aliceIdent_tsA_padding_aliceSigSize);\n                    } else {\n                        // subsequent block...\n                        try {\n                            _sz_aliceIdent_tsA_padding_aliceSig.write(_curDecrypted);\n                        } catch (IOException ioe) {\n                            if (_log.shouldLog(Log.ERROR)) _log.error(prefix()+\"Error writing to the baos?\", ioe);\n                        }\n                        //if (_log.shouldLog(Log.DEBUG))\n                        //    _log.debug(prefix()+\"subsequent block decrypted (\" + _sz_aliceIdent_tsA_padding_aliceSig.size() + \")\");\n\n                        if (_sz_aliceIdent_tsA_padding_aliceSig.size() >= _sz_aliceIdent_tsA_padding_aliceSigSize) {\n                            verifyInbound();\n                            if (!_corrupt && _verified && src.hasRemaining())\n                                prepareExtra(src);\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(prefix()+\"verifying size (sz=\" + _sz_aliceIdent_tsA_padding_aliceSig.size()\n                                           + \" expected=\" + _sz_aliceIdent_tsA_padding_aliceSigSize\n                                           + \" corrupt=\" + _corrupt\n                                           + \" verified=\" + _verified + \" extra=\" + (_extra != null ? _extra.length : 0) + \")\");\n                            return;\n                        }\n                    }\n                } else {\n                    // no more bytes available in the buffer, and only a partial\n                    // block was read, so we can't decrypt it.\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"end of available data with only a partial block read (\" + _curEncryptedOffset + \", \" + _received + \")\");\n                }\n            }\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(prefix()+\"done with the data, not yet complete or corrupt\");\n        }\n    }","id":43216,"modified_method":"/**\n     *  we are Bob, so receive these bytes as part of an inbound connection\n     *  This method receives messages 1 and 3, and sends messages 2 and 4.\n     *\n     *  All data must be copied out of the buffer as Reader.processRead()\n     *  will return it to the pool.\n     */\n    private void receiveInbound(ByteBuffer src) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(prefix() + \"Receiving inbound: prev received=\" + _received +\n                       \" src.remaining=\" + src.remaining());\n        while (_received < _X.length && src.hasRemaining()) {\n            byte c = src.get();\n            _X[_received++] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv x\" + (int)c + \" received=\" + _received);\n            //if (_received >= _X.length) {\n            //    if (isCheckInfo(_context, _context.routerHash(), _X)) {\n            //        _context.statManager().addRateData(\"ntcp.inboundCheckConnection\", 1);\n            //        fail(\"Incoming connection was a check connection\");\n            //        return;\n            //    }\n            //}\n        }\n        while (_received < _X.length + _hX_xor_bobIdentHash.length && src.hasRemaining()) {\n            int i = _received-_X.length;\n            _received++;\n            byte c = src.get();\n            _hX_xor_bobIdentHash[i] = c;\n            //if (_log.shouldLog(Log.DEBUG)) _log.debug(\"recv bih\" + (int)c + \" received=\" + _received);\n        }\n\n        if (_received >= _X.length + _hX_xor_bobIdentHash.length) {\n            if (_dh.getSessionKey() == null) {\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(prefix()+\"Enough data for a DH received\");\n\n                // first verify that Alice knows who she is trying to talk with and that the X\n                // isn't corrupt\n                byte[] realXor = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                _context.sha().calculateHash(_X, 0, _X.length, realXor, 0);\n                xor32(_context.routerHash().getData(), realXor);\n                //if (_log.shouldLog(Log.DEBUG)) {\n                    //_log.debug(prefix()+\"_X = \" + Base64.encode(_X));\n                //    _log.debug(prefix()+\"hx = \" + Base64.encode(hX.getData()));\n                //    _log.debug(prefix()+\"bih=\" + Base64.encode(_context.routerHash().getData()));\n                //    _log.debug(prefix()+\"xor=\" + Base64.encode(realXor));\n                //}\n                if (!DataHelper.eq(realXor, _hX_xor_bobIdentHash)) {\n                    SimpleByteCache.release(realXor);\n                    _context.statManager().addRateData(\"ntcp.invalidHXxorBIH\", 1);\n                    fail(\"Invalid hX_xor\");\n                    return;\n                }\n                SimpleByteCache.release(realXor);\n                if (!_transport.isHXHIValid(_hX_xor_bobIdentHash)) {\n                    // blocklist source? but spoofed IPs could DoS us\n                    _context.statManager().addRateData(\"ntcp.replayHXxorBIH\", 1);\n                    fail(\"Replay hX_xor\");\n                    return;\n                }\n\n                try {\n                    // ok, they're actually trying to talk to us, and we got their (unauthenticated) X\n                    _dh.setPeerPublicValue(_X);\n                    _dh.getSessionKey(); // force the calc\n                    System.arraycopy(realXor, 16, _prevEncrypted, 0, _prevEncrypted.length);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"DH session key calculated (\" + _dh.getSessionKey().toBase64() + \")\");\n\n                    // now prepare our response: Y+E(H(X+Y)+tsB+padding, sk, Y[239:255])\n                    _Y = _dh.getMyPublicValueBytes();\n                    byte xy[] = new byte[_X.length+_Y.length];\n                    System.arraycopy(_X, 0, xy, 0, _X.length);\n                    System.arraycopy(_Y, 0, xy, _X.length, _Y.length);\n                    byte[] hxy = SimpleByteCache.acquire(Hash.HASH_LENGTH);\n                    _context.sha().calculateHash(xy, 0, xy.length, hxy, 0);\n                    _tsB = (_context.clock().now() + 500) / 1000l; // our (Bob's) timestamp in seconds\n                    byte toEncrypt[] = new byte[hxy.length + (4 + 12)];  // 48\n                    System.arraycopy(hxy, 0, toEncrypt, 0, hxy.length);\n                    byte tsB[] = DataHelper.toLong(4, _tsB);\n                    System.arraycopy(tsB, 0, toEncrypt, hxy.length, tsB.length);\n                    //DataHelper.toLong(toEncrypt, hxy.getData().length, 4, _tsB);\n                    _context.random().nextBytes(toEncrypt, hxy.length + 4, 12);\n                    if (_log.shouldLog(Log.DEBUG)) {\n                        //_log.debug(prefix()+\"Y=\"+Base64.encode(_Y));\n                        //_log.debug(prefix()+\"x+y=\"+Base64.encode(xy));\n                        _log.debug(prefix()+\"h(x+y)=\"+Base64.encode(hxy));\n                        _log.debug(prefix()+\"tsb=\"+Base64.encode(tsB));\n                        _log.debug(prefix()+\"unencrypted H(X+Y)+tsB+padding: \" + Base64.encode(toEncrypt));\n                        _log.debug(prefix()+\"encryption iv= \" + Base64.encode(_Y, _Y.length-16, 16));\n                        _log.debug(prefix()+\"encryption key= \" + _dh.getSessionKey().toBase64());\n                    }\n                    SimpleByteCache.release(hxy);\n                    _e_hXY_tsB = new byte[toEncrypt.length];\n                    _context.aes().encrypt(toEncrypt, 0, _e_hXY_tsB, 0, _dh.getSessionKey(),\n                                           _Y, _Y.length-16, toEncrypt.length);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix()+\"encrypted H(X+Y)+tsB+padding: \" + Base64.encode(_e_hXY_tsB));\n                    byte write[] = new byte[_Y.length + _e_hXY_tsB.length];\n                    System.arraycopy(_Y, 0, write, 0, _Y.length);\n                    System.arraycopy(_e_hXY_tsB, 0, write, _Y.length, _e_hXY_tsB.length);\n\n                    // ok, now that is prepared, we want to actually send it, so make sure we are up for writing\n                    _transport.getPumper().wantsWrite(_con, write);\n                    if (!src.hasRemaining()) return;\n                } catch (DHSessionKeyBuilder.InvalidPublicParameterException e) {\n                    _context.statManager().addRateData(\"ntcp.invalidDH\", 1);\n                    fail(\"Invalid X\", e);\n                    return;\n                }\n            }\n\n            // ok, we are onto the encrypted area, i.e. Message #3\n            while (src.hasRemaining() && !_corrupt) {\n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(prefix()+\"Encrypted bytes available (\" + src.hasRemaining() + \")\");\n                while (_curEncryptedOffset < _curEncrypted.length && src.hasRemaining()) {\n                    _curEncrypted[_curEncryptedOffset++] = src.get();\n                    _received++;\n                }\n                if (_curEncryptedOffset >= _curEncrypted.length) {\n                    _context.aes().decrypt(_curEncrypted, 0, _curDecrypted, 0, _dh.getSessionKey(),\n                                           _prevEncrypted, 0, _curEncrypted.length);\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix()+\"full block read and decrypted: \" + Base64.encode(_curDecrypted));\n\n                    byte swap[] = new byte[16];\n                    _prevEncrypted = _curEncrypted;\n                    _curEncrypted = swap;\n                    _curEncryptedOffset = 0;\n\n                    if (_aliceIdentSize <= 0) { // we are on the first decrypted block\n                        int sz = (int)DataHelper.fromLong(_curDecrypted, 0, 2);\n                        if (sz < MIN_RI_SIZE || sz > MAX_RI_SIZE) {\n                            _context.statManager().addRateData(\"ntcp.invalidInboundSize\", sz);\n                            fail(\"size is invalid\", new Exception(\"size is \" + sz));\n                            return;\n                        }\n                        _aliceIdentSize  = sz;\n\n                        // We must defer the calculations for total size of the message until\n                        //  we get the full alice ident so\n                        // we can determine how long the signature is.\n                        // See below\n\n                    }\n                    try {\n                        _sz_aliceIdent_tsA_padding_aliceSig.write(_curDecrypted);\n                    } catch (IOException ioe) {\n                        if (_log.shouldLog(Log.ERROR)) _log.error(prefix()+\"Error writing to the baos?\", ioe);\n                    }\n                    //if (_log.shouldLog(Log.DEBUG))\n                    //    _log.debug(prefix()+\"subsequent block decrypted (\" + _sz_aliceIdent_tsA_padding_aliceSig.size() + \")\");\n\n                    if (_aliceIdent == null &&\n                        _sz_aliceIdent_tsA_padding_aliceSig.size() >= 2 + _aliceIdentSize) {\n                        // we have enough to get Alice's RI and determine the sig+padding length\n                        readAliceRouterIdentity();\n                        if (_aliceIdent == null) {\n                            // readAliceRouterIdentity already called fail\n                            return;\n                        }\n                        SigType type = _aliceIdent.getSigningPublicKey().getType();\n                        if (type == null) {\n                            fail(\"Unsupported sig type\");\n                            return;\n                        }\n                        // handle variable signature size\n                        _sz_aliceIdent_tsA_padding_aliceSigSize = 2 + _aliceIdentSize + 4 + type.getSigLen();\n                        int rem = (_sz_aliceIdent_tsA_padding_aliceSigSize % 16);\n                        int padding = 0;\n                        if (rem > 0)\n                            padding = 16-rem;\n                        _sz_aliceIdent_tsA_padding_aliceSigSize += padding;\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(prefix() + \"alice ident size decrypted as \" + _aliceIdentSize +\n                                       \", making the padding at \" + padding + \" and total size at \" +\n                                       _sz_aliceIdent_tsA_padding_aliceSigSize);\n                    }\n\n                    if (_aliceIdent != null &&\n                        _sz_aliceIdent_tsA_padding_aliceSig.size() >= _sz_aliceIdent_tsA_padding_aliceSigSize) {\n                        // we have the remainder of Message #3, i.e. the padding+signature\n                        // Time to verify.\n\n                            verifyInbound();\n                            if (!_corrupt && _verified && src.hasRemaining())\n                                prepareExtra(src);\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(prefix()+\"verifying size (sz=\" + _sz_aliceIdent_tsA_padding_aliceSig.size()\n                                           + \" expected=\" + _sz_aliceIdent_tsA_padding_aliceSigSize\n                                           + \" corrupt=\" + _corrupt\n                                           + \" verified=\" + _verified + \" extra=\" + (_extra != null ? _extra.length : 0) + \")\");\n                            return;\n                    }\n                } else {\n                    // no more bytes available in the buffer, and only a partial\n                    // block was read, so we can't decrypt it.\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(prefix() + \"end of available data with only a partial block read (\" +\n                                   _curEncryptedOffset + \", \" + _received + \")\");\n                }\n            }\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(prefix()+\"done with the data, not yet complete or corrupt\");\n        }\n    }","commit_id":"51f9d6d421b68e2f3c177442ccaa511336c7b8c6","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Called for a request or response\n     *  @return old NodeInfo or nInfo if none, use this to reduce object churn\n     */\n    private NodeInfo heardFrom(NodeInfo nInfo) {\n        return heardFrom(nInfo, _context.clock().now());\n   }","id":43217,"modified_method":"/**\n     *  Called for a request or response\n     *  @return old NodeInfo or nInfo if none, use this to reduce object churn\n     */\n    private NodeInfo heardFrom(NodeInfo nInfo) {\n        // try to keep ourselves out of the DHT\n        if (nInfo.equals(_myNodeInfo))\n            return _myNodeInfo;\n        NID nID = nInfo.getNID();\n        NodeInfo oldInfo = _knownNodes.get(nID);\n        if (oldInfo == null) {\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"Adding node: \" + nInfo);\n            oldInfo = nInfo;\n            NodeInfo nInfo2 = _knownNodes.putIfAbsent(nID, nInfo);\n            if (nInfo2 != null)\n                oldInfo = nInfo2;\n        } else {\n            if (oldInfo.getDestination() == null && nInfo.getDestination() != null)\n                oldInfo.setDestination(nInfo.getDestination());\n        }\n        oldInfo.getNID().setLastSeen();\n        return oldInfo;\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public KRPC (I2PAppContext ctx, I2PSession session) {\n        _context = ctx;\n        _session = session;\n        _log = ctx.logManager().getLog(KRPC.class);\n        _tracker = new DHTTracker(ctx);\n\n        // in place of a DHT, store everybody we hear from for now\n        _knownNodes = new DHTNodes(ctx);\n        _sentQueries = new ConcurrentHashMap();\n        _outgoingTokens = new ConcurrentHashMap();\n        _incomingTokens = new ConcurrentHashMap();\n\n        // Construct my NodeInfo\n        // Pick ports over a big range to marginally increase security\n        // If we add a search DHT, adjust to stay out of each other's way\n        _qPort = 2555 + ctx.random().nextInt(61111);\n        _rPort = _qPort + 1;\n        _myID = new byte[NID.HASH_LENGTH];\n        ctx.random().nextBytes(_myID);\n        _myNID = new NID(_myID);\n        _myNodeInfo = new NodeInfo(_myNID, session.getMyDestination(), _qPort);\n        _dhtFile = new File(ctx.getConfigDir(), DHT_FILE);\n\n        session.addMuxedSessionListener(this, I2PSession.PROTO_DATAGRAM_RAW, _rPort);\n        session.addMuxedSessionListener(this, I2PSession.PROTO_DATAGRAM, _qPort);\n        start();\n    }","id":43218,"modified_method":"public KRPC (I2PAppContext ctx, I2PSession session) {\n        _context = ctx;\n        _session = session;\n        _log = ctx.logManager().getLog(KRPC.class);\n        _tracker = new DHTTracker(ctx);\n\n        // in place of a DHT, store everybody we hear from for now\n        _knownNodes = new DHTNodes(ctx);\n        _sentQueries = new ConcurrentHashMap();\n        _outgoingTokens = new ConcurrentHashMap();\n        _incomingTokens = new ConcurrentHashMap();\n\n        // Construct my NodeInfo\n        // Pick ports over a big range to marginally increase security\n        // If we add a search DHT, adjust to stay out of each other's way\n        _qPort = 2555 + ctx.random().nextInt(61111);\n        _rPort = _qPort + 1;\n        _myID = new byte[NID.HASH_LENGTH];\n        if (SECURE_NID)\n            System.arraycopy(session.getMyDestination().calculateHash().getData(), 0, _myID, 0, NID.HASH_LENGTH);\n        else\n            ctx.random().nextBytes(_myID);\n        _myNID = new NID(_myID);\n        _myNodeInfo = new NodeInfo(_myNID, session.getMyDestination(), _qPort);\n        _dhtFile = new File(ctx.getConfigDir(), DHT_FILE);\n\n        session.addMuxedSessionListener(this, I2PSession.PROTO_DATAGRAM_RAW, _rPort);\n        session.addMuxedSessionListener(this, I2PSession.PROTO_DATAGRAM, _qPort);\n        start();\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  NodeInfo heard from\n     */\n    public void addNode(NodeInfo nInfo) {\n        heardFrom(nInfo);\n    }","id":43219,"modified_method":"/**\n     *  Called when a reply times out\n     */\n    private void timeout(NodeInfo nInfo) {\n        boolean remove = nInfo.getNID().timeout();\n        if (remove) {\n            if (_knownNodes.remove(nInfo) != null) {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(\"Removed after consecutive timeouts: \" + nInfo);\n            }\n        }\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void timeReached() {\n                _sentQueries.remove(mid);\n                if (onTimeout != null)\n                    onTimeout.run();\n                if (_log.shouldLog(Log.INFO))\n                    _log.warn(\"timeout waiting for reply from \" + ReplyWaiter.this.toString());\n            }","id":43220,"modified_method":"public void timeReached() {\n                _sentQueries.remove(mid);\n                if (onTimeout != null)\n                    onTimeout.run();\n                timeout(ReplyWaiter.this);\n                if (_log.shouldLog(Log.INFO))\n                    _log.warn(\"timeout waiting for reply from \" + ReplyWaiter.this.toString());\n            }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  rcv concatenated 54 byte NodeInfos, return as a List\n     *  Adds all received nodeinfos to our DHT.\n     *  @throws NPE, IllegalArgumentException, and others too\n     */\n    private List<NodeInfo> receiveNodes(NodeInfo nInfo, byte[] ids) throws InvalidBEncodingException {\n        List<NodeInfo> rv = new ArrayList(ids.length / NodeInfo.LENGTH);\n        long fakeTime = _context.clock().now() - (MAX_NODEINFO_AGE * 3 / 4);\n        for (int off = 0; off < ids.length; off += NodeInfo.LENGTH) {\n            NodeInfo nInf = new NodeInfo(ids, off);\n            // anti-churn\n            // TODO do we need heardAbout too?\n            nInf = heardFrom(nInf, fakeTime);\n            rv.add(nInf);\n        }\n        if (_log.shouldLog(Log.INFO))\n             _log.info(\"Rcvd nodes from: \" + nInfo + \": \" + DataHelper.toString(rv));\n        return rv;\n    }","id":43221,"modified_method":"/**\n     *  rcv concatenated 54 byte NodeInfos, return as a List\n     *  Adds all received nodeinfos to our DHT.\n     *  @throws NPE, IllegalArgumentException, and others too\n     */\n    private List<NodeInfo> receiveNodes(NodeInfo nInfo, byte[] ids) throws InvalidBEncodingException {\n        List<NodeInfo> rv = new ArrayList(ids.length / NodeInfo.LENGTH);\n        for (int off = 0; off < ids.length; off += NodeInfo.LENGTH) {\n            NodeInfo nInf = new NodeInfo(ids, off);\n            nInf = heardAbout(nInf);\n            rv.add(nInf);\n        }\n        if (_log.shouldLog(Log.INFO))\n             _log.info(\"Rcvd nodes from: \" + nInfo + \": \" + DataHelper.toString(rv));\n        return rv;\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * No Destination yet available\n     * @throws IllegalArgumentException\n     */\n    public NodeInfo(NID nID, Hash hash, int port) {\n        super();\n        this.nID = nID;\n        this.hash = hash;\n        this.port = port;\n        initialize();\n    }","id":43222,"modified_method":"/**\n     * No Destination yet available\n     * @throws IllegalArgumentException\n     */\n    public NodeInfo(NID nID, Hash hash, int port) {\n        super();\n        this.nID = nID;\n        this.hash = hash;\n        this.port = port;\n        initialize();\n        verify();\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Use this if we have the full destination\n     * @throws IllegalArgumentException\n     */\n    public NodeInfo(NID nID, Destination dest, int port) {\n        super();\n        this.nID = nID;\n        this.dest = dest;\n        this.hash = dest.calculateHash();\n        this.port = port;\n        initialize();\n    }","id":43223,"modified_method":"/**\n     * Use this if we have the full destination\n     * @throws IllegalArgumentException\n     */\n    public NodeInfo(NID nID, Destination dest, int port) {\n        super();\n        this.nID = nID;\n        this.dest = dest;\n        this.hash = dest.calculateHash();\n        this.port = port;\n        initialize();\n        verify();\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public long lastSeen() {\n        return lastSeen;\n    }","id":43224,"modified_method":"public long lastSeen() {\n        return nID.lastSeen();\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * No Destination yet available\n     * @param compactInfo 20 byte node ID, 32 byte destHash, 2 byte port\n     * @param offset starting at this offset in compactInfo\n     * @throws IllegalArgumentException\n     * @throws AIOOBE\n     */\n    public NodeInfo(byte[] compactInfo, int offset) {\n        super();\n        byte[] d = new byte[LENGTH];\n        System.arraycopy(compactInfo, offset, d, 0, LENGTH);\n        setData(d);\n        initialize(d);\n    }","id":43225,"modified_method":"/**\n     * No Destination yet available\n     * @param compactInfo 20 byte node ID, 32 byte destHash, 2 byte port\n     * @param offset starting at this offset in compactInfo\n     * @throws IllegalArgumentException\n     * @throws AIOOBE\n     */\n    public NodeInfo(byte[] compactInfo, int offset) {\n        super();\n        byte[] d = new byte[LENGTH];\n        System.arraycopy(compactInfo, offset, d, 0, LENGTH);\n        setData(d);\n        byte[] ndata = new byte[NID.HASH_LENGTH];\n        System.arraycopy(d, 0, ndata, 0, NID.HASH_LENGTH);\n        this.nID = new NID(ndata);\n        this.hash = Hash.create(d, NID.HASH_LENGTH);\n        this.port = (int) DataHelper.fromLong(d, NID.HASH_LENGTH + Hash.HASH_LENGTH, 2);\n        if (port <= 0 || port >= 65535)\n            throw new IllegalArgumentException(\"Bad port\");\n        verify();\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public static synchronized void loadDHT(KRPC krpc, File file) {\n        Log log = I2PAppContext.getGlobalContext().logManager().getLog(PersistDHT.class);\n        int count = 0;\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            BufferedReader br = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line = null;\n            while ( (line = br.readLine()) != null) {\n                if (line.startsWith(\"#\"))\n                    continue;\n                try {\n                    krpc.addNode(new NodeInfo(line));\n                    count++;\n                    // TODO limit number? this will flush the router's SDS caches\n                } catch (IllegalArgumentException iae) {\n                    if (log.shouldLog(Log.WARN))\n                        log.warn(\"Error reading DHT entry\", iae);\n                } catch (DataFormatException dfe) {\n                    if (log.shouldLog(Log.WARN))\n                        log.warn(\"Error reading DHT entry\", dfe);\n                }\n            }\n        } catch (IOException ioe) {\n            if (log.shouldLog(Log.WARN) && file.exists())\n                log.warn(\"Error reading the DHT File\", ioe);\n        } finally {\n            if (in != null) try { in.close(); } catch (IOException ioe) {}\n        }\n        if (log.shouldLog(Log.INFO))\n            log.info(\"Loaded \" + count + \" nodes from \" + file);\n    }","id":43226,"modified_method":"public static synchronized void loadDHT(KRPC krpc, File file) {\n        Log log = I2PAppContext.getGlobalContext().logManager().getLog(PersistDHT.class);\n        int count = 0;\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            BufferedReader br = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line = null;\n            while ( (line = br.readLine()) != null) {\n                if (line.startsWith(\"#\"))\n                    continue;\n                try {\n                    krpc.heardAbout(new NodeInfo(line));\n                    count++;\n                    // TODO limit number? this will flush the router's SDS caches\n                } catch (IllegalArgumentException iae) {\n                    if (log.shouldLog(Log.WARN))\n                        log.warn(\"Error reading DHT entry\", iae);\n                } catch (DataFormatException dfe) {\n                    if (log.shouldLog(Log.WARN))\n                        log.warn(\"Error reading DHT entry\", dfe);\n                }\n            }\n        } catch (IOException ioe) {\n            if (log.shouldLog(Log.WARN) && file.exists())\n                log.warn(\"Error reading the DHT File\", ioe);\n        } finally {\n            if (in != null) try { in.close(); } catch (IOException ioe) {}\n        }\n        if (log.shouldLog(Log.INFO))\n            log.info(\"Loaded \" + count + \" nodes from \" + file);\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public static synchronized void saveDHT(DHTNodes nodes, File file) {\n        Log log = I2PAppContext.getGlobalContext().logManager().getLog(PersistDHT.class);\n        int count = 0;\n        PrintWriter out = null;\n        try {\n            out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new SecureFileOutputStream(file), \"ISO-8859-1\")));\n            out.println(\"# DHT nodes, format is NID:Hash:Destination:port\");\n            for (NodeInfo ni : nodes.values()) {\n                 // DHTNodes shouldn't contain us, if that changes check here\n                 out.println(ni.toPersistentString());\n                 count++;\n            }\n        } catch (IOException ioe) {\n            if (log.shouldLog(Log.WARN))\n                log.warn(\"Error writing the DHT File\", ioe);\n        } finally {\n            if (out != null) out.close();\n        }\n        if (log.shouldLog(Log.INFO))\n            log.info(\"Stored \" + count + \" nodes to \" + file);\n    }","id":43227,"modified_method":"public static synchronized void saveDHT(DHTNodes nodes, File file) {\n        Log log = I2PAppContext.getGlobalContext().logManager().getLog(PersistDHT.class);\n        int count = 0;\n        long maxAge = I2PAppContext.getGlobalContext().clock().now() - MAX_AGE;\n        PrintWriter out = null;\n        try {\n            out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new SecureFileOutputStream(file), \"ISO-8859-1\")));\n            out.println(\"# DHT nodes, format is NID:Hash:Destination:port\");\n            for (NodeInfo ni : nodes.values()) {\n                 if (ni.lastSeen() < maxAge)\n                     continue;\n                 // DHTNodes shouldn't contain us, if that changes check here\n                 out.println(ni.toPersistentString());\n                 count++;\n            }\n        } catch (IOException ioe) {\n            if (log.shouldLog(Log.WARN))\n                log.warn(\"Error writing the DHT File\", ioe);\n        } finally {\n            if (out != null) out.close();\n        }\n        if (log.shouldLog(Log.INFO))\n            log.info(\"Stored \" + count + \" nodes to \" + file);\n    }","commit_id":"41096c7f238c107a44c6c49977b7ea3225099d2e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public static byte[] nonce() {\r\n\t\tbyte [] nonce = new byte[32];\r\n\t\t_random.nextBytes(nonce);\r\n\t\treturn nonce;\r\n\t}","id":43228,"modified_method":"public static byte[] nonce() {\r\n\t\tbyte [] nonce = new byte[32];\r\n\t\tboolean startsWithReserved;\r\n\t\twhile (true) {\r\n\t\t\tstartsWithReserved = false;\r\n\t\t\t_random.nextBytes(nonce);\r\n\t\t\tfor (byte b: CCN_reserved_markers) {\r\n\t\t\t\tif (b == nonce[0]) {\r\n\t\t\t\t\tstartsWithReserved = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!startsWithReserved)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn nonce;\r\n\t}","commit_id":"f3d0f48c5902a9c9f5c2ec08519c2eb1ee40a58f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static void main(String[] args)\n    {\n        try\n        {\n            String host=\"localhost\";\n            int port=8080;\n            boolean verbose=false;\n            String protocol=null;\n            int count=10;\n            int size=64;\n            int fragment=4000;\n            \n            for (int i=0;i<args.length;i++)\n            {\n                String a=args[i];\n                if (\"-p\".equals(a)||\"--port\".equals(a))\n                    port=Integer.parseInt(args[++i]);\n                else if (\"-h\".equals(a)||\"--host\".equals(a))\n                    port=Integer.parseInt(args[++i]);\n                else if (\"-c\".equals(a)||\"--count\".equals(a))\n                    count=Integer.parseInt(args[++i]);\n                else if (\"-s\".equals(a)||\"--size\".equals(a))\n                    size=Integer.parseInt(args[++i]);\n                else if (\"-f\".equals(a)||\"--fragment\".equals(a))\n                    fragment=Integer.parseInt(args[++i]);\n                else if (\"-P\".equals(a)||\"--protocol\".equals(a))\n                    protocol=args[++i];\n                else if (\"-v\".equals(a)||\"--verbose\".equals(a))\n                    verbose=true;\n                else if (a.startsWith(\"-\"))\n                    usage(args);\n            }\n            \n\n            TestClient client = new TestClient(host,port,protocol==null?null:(\"org.ietf.websocket.test-\"+protocol),10000);\n            client.setSize(size);\n\n            try\n            {\n                client.open();\n                if (\"echo\".equals(protocol))\n                    client.ping(count,WebSocketConnectionD06.OP_BINARY,fragment);\n                else\n                    client.ping(count,WebSocketConnectionD06.OP_PING,-1);\n            }\n            finally\n            {\n                client.dump();\n            }\n            \n        }\n        catch (Exception e)\n        {\n            Log.warn(e);\n        }\n    }","id":43229,"modified_method":"public static void main(String[] args)\n    {\n        try\n        {\n            String host=\"localhost\";\n            int port=8080;\n            boolean verbose=false;\n            String protocol=null;\n            int count=10;\n            int size=64;\n            int fragment=4000;\n            boolean binary=false;\n            \n            for (int i=0;i<args.length;i++)\n            {\n                String a=args[i];\n                if (\"-p\".equals(a)||\"--port\".equals(a))\n                    port=Integer.parseInt(args[++i]);\n                else if (\"-h\".equals(a)||\"--host\".equals(a))\n                    port=Integer.parseInt(args[++i]);\n                else if (\"-c\".equals(a)||\"--count\".equals(a))\n                    count=Integer.parseInt(args[++i]);\n                else if (\"-s\".equals(a)||\"--size\".equals(a))\n                    size=Integer.parseInt(args[++i]);\n                else if (\"-f\".equals(a)||\"--fragment\".equals(a))\n                    fragment=Integer.parseInt(args[++i]);\n                else if (\"-P\".equals(a)||\"--protocol\".equals(a))\n                    protocol=args[++i];\n                else if (\"-v\".equals(a)||\"--verbose\".equals(a))\n                    verbose=true;\n                else if (\"-b\".equals(a)||\"--binary\".equals(a))\n                    binary=true;\n                else if (a.startsWith(\"-\"))\n                    usage(args);\n            }\n            \n\n            TestClient client = new TestClient(host,port,protocol==null?null:(\"org.ietf.websocket.test-\"+protocol),10000);\n            client.setSize(size);\n\n            try\n            {\n                client.open();\n                if (protocol.startsWith(\"echo\"))\n                    client.ping(count,binary?WebSocketConnectionD06.OP_BINARY:WebSocketConnectionD06.OP_TEXT,fragment);\n                else\n                    client.ping(count,WebSocketConnectionD06.OP_PING,-1);\n            }\n            finally\n            {\n                client.dump();\n            }\n            \n        }\n        catch (Exception e)\n        {\n            Log.warn(e);\n        }\n    }","commit_id":"7cca101aeb982603bdcf4ebc7d359f43c2cba1f7","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private static void usage(String[] args)\n    {\n        System.err.println(\"ERROR: \"+Arrays.asList(args));\n        System.err.println(\"USAGE: java -cp CLASSPATH \"+TestClient.class+\" [ OPTIONS ]\");\n        System.err.println(\"  -h|--host HOST  (default localhost)\");\n        System.err.println(\"  -p|--port PORT  (default 8080)\");\n        System.err.println(\"  -v|--verbose\");\n        System.err.println(\"  -c|--count n    (default 10)\");\n        System.err.println(\"  -s|--size n     (default 64)\");\n        System.err.println(\"  -f|--fragment n (default 4000) \");\n        System.err.println(\"  -P|--protocol echo|echo-assemble|echo-fragment\");\n        System.exit(1);\n    }","id":43230,"modified_method":"private static void usage(String[] args)\n    {\n        System.err.println(\"ERROR: \"+Arrays.asList(args));\n        System.err.println(\"USAGE: java -cp CLASSPATH \"+TestClient.class+\" [ OPTIONS ]\");\n        System.err.println(\"  -h|--host HOST  (default localhost)\");\n        System.err.println(\"  -p|--port PORT  (default 8080)\");\n        System.err.println(\"  -b|--binary\");\n        System.err.println(\"  -v|--verbose\");\n        System.err.println(\"  -c|--count n    (default 10)\");\n        System.err.println(\"  -s|--size n     (default 64)\");\n        System.err.println(\"  -f|--fragment n (default 4000) \");\n        System.err.println(\"  -P|--protocol echo|echo-assemble|echo-fragment|echo-broadcast\");\n        System.exit(1);\n    }","commit_id":"7cca101aeb982603bdcf4ebc7d359f43c2cba1f7","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void dump() throws IOException\n    {\n        _socket.close();\n        long duration=System.currentTimeMillis()-_start;\n        System.out.println(\"--- \"+_host+\" websocket ping statistics using 1 connection ---\");\n        System.out.println(_sent+\" packets transmitted, \"+_received+\" received, \"+\n                (_sent>0?String.format(\"%d\",100*(_sent-_received)/_sent)+\"% loss, \":\"\")+\n                \"time \"+duration+\"ms\");\n        System.out.printf(\"rtt min/ave/max = %.3f/%.3f/%.3f ms\\n\",_minDuration/1000000.0,_received==0?0.0:(_totalTime/_received/1000000.0),_maxDuration/1000000.0);\n    }","id":43231,"modified_method":"public void dump() throws IOException\n    {\n        _socket.close();\n        long duration=System.currentTimeMillis()-_start;\n        System.out.println(\"--- \"+_host+\" websocket ping statistics using 1 connection ---\");\n        System.out.println(_framesSent+\" frames transmitted, \"+_framesReceived+\" received, \"+\n                _messagesSent+\" messages transmitted, \"+_messagesReceived+\" received, \"+\n                \"time \"+duration+\"ms\");\n        System.out.printf(\"rtt min/ave/max = %.3f/%.3f/%.3f ms\\n\",_minDuration/1000000.0,_messagesReceived==0?0.0:(_totalTime/_messagesReceived/1000000.0),_maxDuration/1000000.0);\n    }","commit_id":"7cca101aeb982603bdcf4ebc7d359f43c2cba1f7","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void ping(int count,byte opcode,int fragment)\n    {\n        _start=System.currentTimeMillis();\n        for (int i=0;i<count && !_socket.isClosed();i++)\n        {\n            if (_socket.isClosed())\n                break;\n            try\n            {\n                byte data[] = new byte[_size];\n                __random.nextBytes(data);\n                \n                _starts.add(System.nanoTime());\n                _pending.add(TypeUtil.toHexString(data));\n                \n                int off=0;\n                int len=data.length;\n                if (fragment>0&& len>fragment)\n                    len=fragment;\n                while(off<data.length)\n                {\n                    _generator.addFrame((byte)(off==0?0x8:0),(byte)(off==0?opcode:WebSocketConnectionD06.OP_CONTINUATION),data,off,len,_socket.getSoTimeout());\n                    _sent++;\n                    off+=len;\n                    if(data.length-off>len)\n                        len=data.length-off;\n                }\n                _generator.flush(_socket.getSoTimeout());\n\n                Thread.sleep(1000);\n               \n            }\n            catch (Exception x)\n            {\n                throw new RuntimeException(x);\n            }\n        }\n    }","id":43232,"modified_method":"public void ping(int count,byte opcode,int fragment)\n    {\n        _start=System.currentTimeMillis();\n        for (int i=0;i<count && !_socket.isClosed();i++)\n        {\n            if (_socket.isClosed())\n                break;\n            try\n            {\n                byte data[]=null;\n                \n                if (opcode==WebSocketConnectionD06.OP_TEXT)\n                {\n                    StringBuilder b = new StringBuilder();\n                    while (b.length()<_size)\n                        b.append('A'+__random.nextInt(26));\n                    data=b.toString().getBytes(StringUtil.__UTF8);\n                }\n                else\n                {             \n                    data= new byte[_size];\n                    __random.nextBytes(data);\n                }\n                _starts.add(System.nanoTime());\n                \n                int off=0;\n                int len=data.length;\n                if (fragment>0&& len>fragment)\n                    len=fragment;\n                _messagesSent++;\n                while(off<data.length)\n                {                    \n                    _framesSent++;\n                    _generator.addFrame((byte)(off+len==data.length?0x8:0),(byte)(off==0?opcode:WebSocketConnectionD06.OP_CONTINUATION),data,off,len,_socket.getSoTimeout());\n                    off+=len;\n                    if(data.length-off>len)\n                        len=data.length-off;\n                    if (fragment>0&& len>fragment)\n                        len=fragment;\n                }\n                _generator.flush(_socket.getSoTimeout());\n\n                Thread.sleep(1000);\n               \n            }\n            catch (Exception x)\n            {\n                throw new RuntimeException(x);\n            }\n        }\n    }","commit_id":"7cca101aeb982603bdcf4ebc7d359f43c2cba1f7","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public TestServer(int port)\n    {\n        _connector = new SelectChannelConnector();\n        _connector.setPort(port);\n\n        addConnector(_connector);\n        _handler = new WebSocketHandler()\n        {\n            public WebSocket doWebSocketConnect(HttpServletRequest request, String protocol)\n            {\n                if (\"org.ietf.websocket.test-echo\".equals(protocol) || \"echo\".equals(protocol) || \"lws-mirror-protocol\".equals(protocol))\n                {\n                    _websocket = new TestEchoWebSocket();        \n                }\n                else if (\"org.ietf.websocket.test-echo-broadcast\".equals(protocol))\n                {\n                    _websocket = new TestEchoBroadcastWebSocket(); \n\n                }\n                else if (\"org.ietf.websocket.test-echo-assemble\".equals(protocol))\n                {\n\n                }\n                else if (\"org.ietf.websocket.test-echo-fragment\".equals(protocol))\n                {\n\n                }\n                else if (\"org.ietf.websocket.test-consume\".equals(protocol))\n                {\n\n                }\n                else if (\"org.ietf.websocket.test-produce\".equals(protocol))\n                {\n\n                }\n                else if (protocol==null)\n                {\n                    _websocket = new TestWebSocket(); \n                }\n                return _websocket;\n            }\n        };\n\n        setHandler(_handler);\n    }","id":43233,"modified_method":"public TestServer(int port)\n    {\n        _connector = new SelectChannelConnector();\n        _connector.setPort(port);\n\n        addConnector(_connector);\n        _handler = new WebSocketHandler()\n        {\n            public WebSocket doWebSocketConnect(HttpServletRequest request, String protocol)\n            {\n                if (\"org.ietf.websocket.test-echo\".equals(protocol) || \"echo\".equals(protocol) || \"lws-mirror-protocol\".equals(protocol))\n                {\n                    _websocket = new TestEchoWebSocket();        \n                }\n                else if (\"org.ietf.websocket.test-echo-broadcast\".equals(protocol))\n                {\n                    _websocket = new TestEchoBroadcastWebSocket(); \n\n                }\n                else if (\"org.ietf.websocket.test-echo-assemble\".equals(protocol))\n                {\n                    _websocket = new TestEchoAssembleWebSocket();\n                }\n                else if (\"org.ietf.websocket.test-echo-fragment\".equals(protocol))\n                {\n                    _websocket = new TestEchoFragmentWebSocket();\n                }\n                else if (protocol==null)\n                {\n                    _websocket = new TestWebSocket(); \n                }\n                return _websocket;\n            }\n        };\n\n        setHandler(_handler);\n    }","commit_id":"7cca101aeb982603bdcf4ebc7d359f43c2cba1f7","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void rollbackMigration(PartitionMigrationEvent event) {\n        if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {\n            clearPartitionData(event.getPartitionId());\n        }\n        ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));\n    }","id":43234,"modified_method":"public void rollbackMigration(PartitionMigrationEvent event) {\n        if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {\n            clearPartitionData(event.getPartitionId());\n        }\n        ownedPartitions.set(getMemberPartitions());\n    }","commit_id":"e0a13124bb936cb33615678c69895f0092ba56f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public AtomicReference<List<Integer>> getOwnedPartitions() {\n        if (ownedPartitions.get() == null) {\n            ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));\n        }\n        return ownedPartitions;\n    }","id":43235,"modified_method":"public List<Integer> getOwnedPartitions() {\n        List<Integer> partitions = ownedPartitions.get();\n        if (partitions == null) {\n            partitions = getMemberPartitions();\n            ownedPartitions.set(partitions);\n        }\n        return partitions;\n    }","commit_id":"e0a13124bb936cb33615678c69895f0092ba56f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void commitMigration(PartitionMigrationEvent event) {\n        migrateIndex(event);\n        if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {\n            clearPartitionData(event.getPartitionId());\n        }\n        ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));\n    }","id":43236,"modified_method":"public void commitMigration(PartitionMigrationEvent event) {\n        migrateIndex(event);\n        if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {\n            clearPartitionData(event.getPartitionId());\n        }\n        ownedPartitions.set(getMemberPartitions());\n    }","commit_id":"e0a13124bb936cb33615678c69895f0092ba56f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void run() throws Exception {\n        List<Integer> initialPartitions = mapService.getOwnedPartitions().get();\n        IndexService indexService = mapService.getMapContainer(name).getIndexService();\n        Set<QueryableEntry> entries = null;\n        // TODO: fix\n        if (!getNodeEngine().getPartitionService().hasOnGoingMigration()) {\n            entries = indexService.query(predicate);\n        }\n        result = new QueryResult();\n        if (entries != null) {\n            for (QueryableEntry entry : entries) {\n                result.add(new QueryResultEntryImpl(entry.getKeyData(), entry.getKeyData(), entry.getValueData()));\n            }\n        } else {\n            // run in parallel\n            runParallel(initialPartitions);\n        }\n        List<Integer> finalPartitions = mapService.getOwnedPartitions().get();\n        if (initialPartitions.equals(finalPartitions)) {\n            result.setPartitionIds(finalPartitions);\n        }\n        if (mapContainer.getMapConfig().isStatisticsEnabled()) {\n            ((MapService) getService()).getLocalMapStatsImpl(name).incrementOtherOperations();\n        }\n    }","id":43237,"modified_method":"@Override\n    public void run() throws Exception {\n        List<Integer> initialPartitions = mapService.getOwnedPartitions();\n        IndexService indexService = mapService.getMapContainer(name).getIndexService();\n        Set<QueryableEntry> entries = null;\n        // TODO: fix\n        if (!getNodeEngine().getPartitionService().hasOnGoingMigration()) {\n            entries = indexService.query(predicate);\n        }\n        result = new QueryResult();\n        if (entries != null) {\n            for (QueryableEntry entry : entries) {\n                result.add(new QueryResultEntryImpl(entry.getKeyData(), entry.getKeyData(), entry.getValueData()));\n            }\n        } else {\n            // run in parallel\n            runParallel(initialPartitions);\n        }\n        List<Integer> finalPartitions = mapService.getOwnedPartitions();\n        if (initialPartitions.equals(finalPartitions)) {\n            result.setPartitionIds(finalPartitions);\n        }\n        if (mapContainer.getMapConfig().isStatisticsEnabled()) {\n            ((MapService) getService()).getLocalMapStatsImpl(name).incrementOtherOperations();\n        }\n    }","commit_id":"e0a13124bb936cb33615678c69895f0092ba56f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public AtomicReference<List<Integer>> getOwnedPartitions() {\n        if (ownedPartitions.get() == null) {\n            ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));\n        }\n        return ownedPartitions;\n    }","id":43238,"modified_method":"public List<Integer> getOwnedPartitions() {\n        List<Integer> partitions = ownedPartitions.get();\n        if (partitions == null) {\n            partitions = getMemberPartitions();\n            ownedPartitions.set(partitions);\n        }\n        return partitions;\n    }","commit_id":"223d2774ee587c4431108821e54087ddc8001ac1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void rollbackMigration(PartitionMigrationEvent event) {\n        if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {\n            clearPartitionData(event.getPartitionId());\n        }\n        ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));\n    }","id":43239,"modified_method":"public void rollbackMigration(PartitionMigrationEvent event) {\n        if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {\n            clearPartitionData(event.getPartitionId());\n        }\n        ownedPartitions.set(getMemberPartitions());\n    }","commit_id":"223d2774ee587c4431108821e54087ddc8001ac1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void commitMigration(PartitionMigrationEvent event) {\n        migrateIndex(event);\n        if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {\n            clearPartitionData(event.getPartitionId());\n        }\n        ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));\n    }","id":43240,"modified_method":"public void commitMigration(PartitionMigrationEvent event) {\n        migrateIndex(event);\n        if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {\n            clearPartitionData(event.getPartitionId());\n        }\n        ownedPartitions.set(getMemberPartitions());\n    }","commit_id":"223d2774ee587c4431108821e54087ddc8001ac1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void run() throws Exception {\n        List<Integer> initialPartitions = mapService.getOwnedPartitions().get();\n        IndexService indexService = mapService.getMapContainer(name).getIndexService();\n        Set<QueryableEntry> entries = null;\n        // TODO: fix\n        if (!getNodeEngine().getPartitionService().hasOnGoingMigration()) {\n            entries = indexService.query(predicate);\n        }\n        result = new QueryResult();\n        if (entries != null) {\n            for (QueryableEntry entry : entries) {\n                result.add(new QueryResultEntryImpl(entry.getKeyData(), entry.getKeyData(), entry.getValueData()));\n            }\n        } else {\n            // run in parallel\n            runParallel(initialPartitions);\n        }\n        List<Integer> finalPartitions = mapService.getOwnedPartitions().get();\n        if (initialPartitions.equals(finalPartitions)) {\n            result.setPartitionIds(finalPartitions);\n        }\n        if (mapContainer.getMapConfig().isStatisticsEnabled()) {\n            ((MapService) getService()).getLocalMapStatsImpl(name).incrementOtherOperations();\n        }\n    }","id":43241,"modified_method":"@Override\n    public void run() throws Exception {\n        List<Integer> initialPartitions = mapService.getOwnedPartitions();\n        IndexService indexService = mapService.getMapContainer(name).getIndexService();\n        Set<QueryableEntry> entries = null;\n        // TODO: fix\n        if (!getNodeEngine().getPartitionService().hasOnGoingMigration()) {\n            entries = indexService.query(predicate);\n        }\n        result = new QueryResult();\n        if (entries != null) {\n            for (QueryableEntry entry : entries) {\n                result.add(new QueryResultEntryImpl(entry.getKeyData(), entry.getKeyData(), entry.getValueData()));\n            }\n        } else {\n            // run in parallel\n            runParallel(initialPartitions);\n        }\n        List<Integer> finalPartitions = mapService.getOwnedPartitions();\n        if (initialPartitions.equals(finalPartitions)) {\n            result.setPartitionIds(finalPartitions);\n        }\n        if (mapContainer.getMapConfig().isStatisticsEnabled()) {\n            ((MapService) getService()).getLocalMapStatsImpl(name).incrementOtherOperations();\n        }\n    }","commit_id":"223d2774ee587c4431108821e54087ddc8001ac1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private boolean handleGroup(JsonObject obj) throws ParseException {\n    Group group = getGroup(obj.getAsJsonObject(DEF_GROUP));\n    if (group.isArtificial()) return true; // Ignore artificial groups.\n    ServiceMessageBuilder groupMsg = ServiceMessageBuilder.testSuiteStarted(group.getBaseName());\n    // Possible attributes: \"nodeType\" \"nodeArgs\" \"running\"\n    addLocationHint(groupMsg, group);\n    boolean result = finishMessage(groupMsg, group.getId(), group.getValidParentId());\n    return result;\n  }","id":43242,"modified_method":"private boolean handleGroup(JsonObject obj) throws ParseException {\n    Group group = getGroup(obj.getAsJsonObject(DEF_GROUP));\n\n    // From spec: The implicit group at the root of each test suite has null name and parentID attributes.\n    if (group.getParent() == null && group.getTestCount() > 0) {\n      // com.intellij.execution.testframework.sm.runner.OutputToGeneralTestEventsConverter.MyServiceMessageVisitor.KEY_TESTS_COUNT\n      // and  com.intellij.execution.testframework.sm.runner.OutputToGeneralTestEventsConverter.MyServiceMessageVisitor.ATTR_KEY_TEST_COUNT\n      final ServiceMessageBuilder testCount =\n        new ServiceMessageBuilder(\"testCount\").addAttribute(\"count\", String.valueOf(group.getTestCount()));\n      super.processServiceMessages(testCount.toString(), myCurrentOutputType, myCurrentVisitor);\n    }\n\n    if (group.isArtificial()) return true; // Ignore artificial groups.\n    ServiceMessageBuilder groupMsg = ServiceMessageBuilder.testSuiteStarted(group.getBaseName());\n    // Possible attributes: \"nodeType\" \"nodeArgs\" \"running\"\n    addLocationHint(groupMsg, group);\n    return finishMessage(groupMsg, group.getId(), group.getValidParentId());\n  }","commit_id":"f628ff40158659c279d3d417bc1ec1aa37ea5fb7","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean handlePrint(JsonObject obj) throws ParseException {\n    Test test = getTest(obj);\n    ServiceMessageBuilder message = ServiceMessageBuilder.testStdOut(test.getBaseName());\n    String out;\n    if (myOutputAppeared) {\n      out = getMessage(obj) + NEWLINE;\n    }\n    else {\n      out = NEWLINE + getMessage(obj) + NEWLINE;\n    }\n    message.addAttribute(\"out\", out);\n    myOutputAppeared = true;\n    return finishMessage(message, test.getId(), test.getValidParentId());\n  }","id":43243,"modified_method":"private boolean handlePrint(JsonObject obj) throws ParseException {\n    final Test test = getTest(obj);\n    boolean result = true;\n\n    if (!test.myTestStartReported) {\n      final ServiceMessageBuilder testStarted = ServiceMessageBuilder.testStarted(test.getBaseName());\n      test.myTestStartReported = true;\n      result = finishMessage(testStarted, test.getId(), test.getValidParentId());\n    }\n\n    ServiceMessageBuilder message = ServiceMessageBuilder.testStdOut(test.getBaseName());\n    message.addAttribute(\"out\", appendLineBreakIfNeeded(getMessage(obj)));\n\n    return result & finishMessage(message, test.getId(), test.getValidParentId());\n  }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean processEventText(final String text) throws JsonSyntaxException, ParseException {\n    JsonParser jp = new JsonParser();\n    JsonElement elem;\n    try {\n      elem = jp.parse(text);\n    }\n    catch (JsonSyntaxException ex) {\n      if (text.contains(\"\\\"json\\\" is not an allowed value for option \\\"reporter\\\"\")) {\n        failedToLoad(\"Please update your pubspec.yaml dependency on package:test to version 0.12.7 or later.\", 0);\n      }\n      return doProcessServiceMessages(text);\n    }\n    if (elem == null || !elem.isJsonObject()) return false;\n    return process(elem.getAsJsonObject());\n  }","id":43244,"modified_method":"private boolean processEventText(final String text) throws JsonSyntaxException, ParseException {\n    JsonParser jp = new JsonParser();\n    JsonElement elem;\n    try {\n      elem = jp.parse(text);\n    }\n    catch (JsonSyntaxException ex) {\n      if (text.contains(\"\\\"json\\\" is not an allowed value for option \\\"reporter\\\"\")) {\n        final ServiceMessageBuilder testStarted = ServiceMessageBuilder.testStarted(\"Failed to start\");\n        final ServiceMessageBuilder testFailed = ServiceMessageBuilder.testFailed(\"Failed to start\");\n        testFailed.addAttribute(\"message\", \"Please update your pubspec.yaml dependency on package:test to version 0.12.9 or later.\");\n        final ServiceMessageBuilder testFinished = ServiceMessageBuilder.testFinished(\"Failed to start\");\n        return finishMessage(testStarted, 1, 0) & finishMessage(testFailed, 1, 0) & finishMessage(testFinished, 1, 0);\n      }\n\n      return doProcessServiceMessages(text);\n    }\n    if (elem == null || !elem.isJsonObject()) return false;\n    return process(elem.getAsJsonObject());\n  }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"String getBaseName() {\n      // file-level group\n      if (this instanceof Group && NO_NAME.equals(myName) && myParent == null && hasSuite()) {\n        return PathUtil.getFileName(getSuite().getPath());\n      }\n\n      // top-level group in suite\n      if (this instanceof Group && myParent != null && myParent.getParent() == null && NO_NAME.equals(myParent.getName())) {\n        return myName;\n      }\n\n      if (hasValidParent()) {\n        final String parentName = getParent().getName();\n        if (myName.startsWith(parentName + \" \")) {\n          return myName.substring(parentName.length() + 1);\n        }\n      }\n\n      return myName;\n    }","id":43245,"modified_method":"String getBaseName() {\n      // Virtual test that represents loading or compiling a test suite. See lib/src/runner/loader.dart -> Loader.loadFile() in pkg/test source code\n      if (this instanceof Test && getParent() == null) {\n        if (myName.startsWith(LOADING_PREFIX)) {\n          return LOADING_PREFIX + PathUtil.getFileName(myName.substring(LOADING_PREFIX.length()));\n        }\n        else if (myName.startsWith(COMPILING_PREFIX)) {\n          return COMPILING_PREFIX + PathUtil.getFileName(myName.substring(COMPILING_PREFIX.length()));\n        }\n        return myName; // can't happen\n      }\n\n      // file-level group\n      if (this instanceof Group && NO_NAME.equals(myName) && myParent == null && hasSuite()) {\n        return PathUtil.getFileName(getSuite().getPath());\n      }\n\n      // top-level group in suite\n      if (this instanceof Group && myParent != null && myParent.getParent() == null && NO_NAME.equals(myParent.getName())) {\n        return myName;\n      }\n\n      if (hasValidParent()) {\n        final String parentName = getParent().getName();\n        if (myName.startsWith(parentName + \" \")) {\n          return myName.substring(parentName.length() + 1);\n        }\n      }\n\n      return myName;\n    }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testDone() {\n      isRunning = false;\n\n      if (getParent() != null) {\n        getParent().incDoneTestsCount();\n      }\n    }","id":43246,"modified_method":"public void testDone() {\n      if (getParent() != null) {\n        getParent().incDoneTestsCount();\n      }\n    }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean handleTestStart(JsonObject obj) throws ParseException {\n    JsonObject testObj = obj.getAsJsonObject(DEF_TEST);\n    // Not reached if testObj == null.\n    Test test = getTest(obj);\n    if (test.getParent() == null && (test.getName().startsWith(LOADING_PREFIX) || test.getName().startsWith(COMPILING_PREFIX))) {\n      // Virtual test that represents loading or compiling a test suite. See lib/src/runner/loader.dart -> Loader.loadFile() in pkg/test source code\n      String path = \"\";\n\n      if (test.getName().startsWith(LOADING_PREFIX)) {\n        path = test.getName().substring(LOADING_PREFIX.length());\n      }\n      else if (test.getName().startsWith(COMPILING_PREFIX)) {\n        path = test.getName().substring(COMPILING_PREFIX.length());\n      }\n\n      if (path.length() > 0) myLocation = FILE_URL_PREFIX + path;\n      return true;\n    }\n\n    String testName = test.getBaseName();\n    ServiceMessageBuilder testStarted = ServiceMessageBuilder.testStarted(testName);\n    myTestIdToTimestamp.put(test.getId(), getTimestamp(obj));\n    addLocationHint(testStarted, test);\n    myOutputAppeared = false;\n    boolean result = finishMessage(testStarted, test.getId(), test.getValidParentId());\n\n    Metadata metadata = Metadata.from(testObj.getAsJsonObject(DEF_METADATA));\n    if (metadata.skip) {\n      ServiceMessageBuilder message = ServiceMessageBuilder.testIgnored(testName);\n      if (metadata.skipReason != null) message.addAttribute(\"message\", metadata.skipReason);\n      result &= finishMessage(message, test.getId(), test.getValidParentId());\n    }\n\n    return result;\n  }","id":43247,"modified_method":"private boolean handleTestStart(JsonObject obj) throws ParseException {\n    final JsonObject testObj = obj.getAsJsonObject(DEF_TEST);\n\n    // Not reached if testObj == null.\n    final Test test = getTest(obj);\n    myTestIdToTimestamp.put(test.getId(), getTimestamp(obj));\n\n    if (test.getParent() == null && (test.getName().startsWith(LOADING_PREFIX) || test.getName().startsWith(COMPILING_PREFIX))) {\n      // Virtual test that represents loading or compiling a test suite. See lib/src/runner/loader.dart -> Loader.loadFile() in pkg/test source code\n      // At this point we do not report anything to the framework, but if error occurs, we'll report it as a normal test\n      String path = \"\";\n\n      if (test.getName().startsWith(LOADING_PREFIX)) {\n        path = test.getName().substring(LOADING_PREFIX.length());\n      }\n      else if (test.getName().startsWith(COMPILING_PREFIX)) {\n        path = test.getName().substring(COMPILING_PREFIX.length());\n      }\n\n      if (path.length() > 0) myLocation = FILE_URL_PREFIX + path;\n\n      test.myTestStartReported = false;\n      return true;\n    }\n\n    final ServiceMessageBuilder testStarted = ServiceMessageBuilder.testStarted(test.getBaseName());\n    test.myTestStartReported = true;\n\n    addLocationHint(testStarted, test);\n    boolean result = finishMessage(testStarted, test.getId(), test.getValidParentId());\n\n    final Metadata metadata = Metadata.from(testObj.getAsJsonObject(DEF_METADATA));\n    if (metadata.skip) {\n      final ServiceMessageBuilder message = ServiceMessageBuilder.testIgnored(test.getBaseName());\n      if (metadata.skipReason != null) message.addAttribute(\"message\", metadata.skipReason);\n      result &= finishMessage(message, test.getId(), test.getValidParentId());\n    }\n\n    return result;\n  }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean handleTestDone(JsonObject obj) throws ParseException {\n    if (getBoolean(obj, JSON_HIDDEN)) return true;\n    String result = getResult(obj);\n    if (!result.equals(RESULT_SUCCESS) && !result.equals(RESULT_FAILURE) && !result.equals(RESULT_ERROR)) {\n      throw new ParseException(\"Unknown result: \" + obj, 0);\n    }\n\n    Test test = getTest(obj);\n    test.testDone();\n\n    //if (test.getMetadata().skip) return true; // skipped tests are reported as ignored in handleTestStart(). testFinished signal must follow\n\n    ServiceMessageBuilder testFinished = ServiceMessageBuilder.testFinished(test.getBaseName());\n    long duration = getTimestamp(obj) - myTestIdToTimestamp.get(test.getId());\n    testFinished.addAttribute(\"duration\", Long.toString(duration));\n\n    return finishMessage(testFinished, test.getId(), test.getValidParentId()) && checkGroupDone(test.getParent());\n  }","id":43248,"modified_method":"private boolean handleTestDone(JsonObject obj) throws ParseException {\n    final Test test = getTest(obj);\n\n    if (!test.myTestStartReported) return true;\n\n    String result = getResult(obj);\n    if (!result.equals(RESULT_SUCCESS) && !result.equals(RESULT_FAILURE) && !result.equals(RESULT_ERROR)) {\n      throw new ParseException(\"Unknown result: \" + obj, 0);\n    }\n\n    test.testDone();\n\n    //if (test.getMetadata().skip) return true; // skipped tests are reported as ignored in handleTestStart(). testFinished signal must follow\n\n    ServiceMessageBuilder testFinished = ServiceMessageBuilder.testFinished(test.getBaseName());\n    long duration = getTimestamp(obj) - myTestIdToTimestamp.get(test.getId());\n    testFinished.addAttribute(\"duration\", Long.toString(duration));\n\n    return finishMessage(testFinished, test.getId(), test.getValidParentId()) && checkGroupDone(test.getParent());\n  }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean handleAllSuites(JsonObject obj) {\n    JsonElement elem = obj.get(JSON_TEST_COUNT);\n    if (elem == null || !elem.isJsonPrimitive()) return true;\n    mySuitCount = elem.getAsInt();\n    return true;\n  }","id":43249,"modified_method":"private boolean handleAllSuites(JsonObject obj) {\n    JsonElement elem = obj.get(JSON_COUNT);\n    if (elem == null || !elem.isJsonPrimitive()) return true;\n    mySuitCount = elem.getAsInt();\n    return true;\n  }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean handleError(JsonObject obj) throws ParseException {\n    String message = getErrorMessage(obj);\n    if (message.startsWith(FAILED_TO_LOAD)) {\n      // An error due to loading failure probably was preceded by a start event that was not recorded since it is not a test.\n      JsonElement elem = obj.get(JSON_TEST_ID);\n      if (elem != null &&\n          elem.isJsonPrimitive() &&\n          (myTestData.get(elem.getAsInt()) == null || !myTestData.get(elem.getAsInt()).hasValidParent())) {\n        return failedToLoad(message, elem.getAsInt());\n      }\n    }\n\n    Test test = getTest(obj);\n    final ServiceMessageBuilder testError = ServiceMessageBuilder.testFailed(test.getBaseName());\n\n    String failureMessage = message;\n    int firstExpectedIndex = message.indexOf(EXPECTED);\n    if (firstExpectedIndex >= 0) {\n      Matcher matcher = EXPECTED_ACTUAL_RESULT.matcher(message);\n      if (matcher.find(firstExpectedIndex + EXPECTED.length())) {\n        String expectedText = matcher.group(1);\n        String actualText = matcher.group(2);\n        testError.addAttribute(\"expected\", expectedText);\n        testError.addAttribute(\"actual\", actualText);\n        if (firstExpectedIndex == 0) {\n          failureMessage = \"Comparison failed\";\n        }\n        else {\n          failureMessage = message.substring(0, firstExpectedIndex);\n        }\n      }\n    }\n\n    // The stack trace could be null, but we disallow that for consistency with all the transmitted values.\n    if (!getBoolean(obj, JSON_IS_FAILURE)) testError.addAttribute(\"error\", \"true\");\n    testError.addAttribute(\"message\", failureMessage + NEWLINE);\n\n    final ServiceMessageBuilder testStdErr = ServiceMessageBuilder.testStdErr(test.getBaseName());\n    testStdErr.addAttribute(\"out\", getStackTrace(obj));\n\n    return finishMessage(testError, test.getId(), test.getValidParentId()) &&\n           finishMessage(testStdErr, test.getId(), test.getValidParentId());\n  }","id":43250,"modified_method":"private boolean handleError(JsonObject obj) throws ParseException {\n    final Test test = getTest(obj);\n    final String message = getErrorMessage(obj);\n    boolean result = true;\n\n    if (!test.myTestStartReported) {\n      final ServiceMessageBuilder testStarted = ServiceMessageBuilder.testStarted(test.getBaseName());\n      test.myTestStartReported = true;\n      result = finishMessage(testStarted, test.getId(), test.getValidParentId());\n    }\n\n    if (test.myTestErrorReported) {\n      final ServiceMessageBuilder testErrorMessage = ServiceMessageBuilder.testStdErr(test.getBaseName());\n      testErrorMessage.addAttribute(\"out\", appendLineBreakIfNeeded(message));\n      result &= finishMessage(testErrorMessage, test.getId(), test.getValidParentId());\n    }\n    else {\n      final ServiceMessageBuilder testError = ServiceMessageBuilder.testFailed(test.getBaseName());\n      test.myTestErrorReported = true;\n\n      String failureMessage = message;\n      int firstExpectedIndex = message.indexOf(EXPECTED);\n      if (firstExpectedIndex >= 0) {\n        Matcher matcher = EXPECTED_ACTUAL_RESULT.matcher(message);\n        if (matcher.find(firstExpectedIndex + EXPECTED.length())) {\n          String expectedText = matcher.group(1);\n          String actualText = matcher.group(2);\n          testError.addAttribute(\"expected\", expectedText);\n          testError.addAttribute(\"actual\", actualText);\n          if (firstExpectedIndex == 0) {\n            failureMessage = \"Comparison failed\";\n          }\n          else {\n            failureMessage = message.substring(0, firstExpectedIndex);\n          }\n        }\n      }\n\n      if (!getBoolean(obj, JSON_IS_FAILURE)) testError.addAttribute(\"error\", \"true\");\n      testError.addAttribute(\"message\", appendLineBreakIfNeeded(failureMessage));\n\n      result &= finishMessage(testError, test.getId(), test.getValidParentId());\n    }\n\n    final String stackTrace = getStackTrace(obj);\n    if (!StringUtil.isEmptyOrSpaces(stackTrace)) {\n      final ServiceMessageBuilder stackTraceMessage = ServiceMessageBuilder.testStdErr(test.getBaseName());\n      stackTraceMessage.addAttribute(\"out\", appendLineBreakIfNeeded(stackTrace));\n      result &= finishMessage(stackTraceMessage, test.getId(), test.getValidParentId());\n    }\n\n    return result;\n  }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testLoadFailure() throws Exception {\n    String[] events =\n      {\"/usr/local/opt/dart/libexec/bin/dart --ignore-unrecognized-flags --checked --enable-vm-service:50383 --trace_service_pause_events file:///usr/local/opt/dart/libexec/bin/snapshots/pub.dart.snapshot run test:test -r json test/formatter_test.dart -n \\\"line endings\\\"\\n\",\n        \"Observatory listening on http://127.0.0.1:50383\\n\", \"\\n\",\n        \"{\\\"protocolVersion\\\":\\\"0.1.0\\\",\\\"runnerVersion\\\":\\\"0.12.6\\\",\\\"type\\\":\\\"start\\\",\\\"time\\\":0}\\n\",\n        \"{\\\"test\\\":{\\\"id\\\":0,\\\"name\\\":\\\"loading test/formatter_test.dart\\\",\\\"groupIDs\\\":[],\\\"metadata\\\":{\\\"skip\\\":false,\\\"skipReason\\\":null}},\\\"type\\\":\\\"testStart\\\",\\\"time\\\":0}\\n\",\n        \"{\\\"testID\\\":0,\\\"error\\\":\\\"Failed to load \\\\\\\"test/formatter_test.dart\\\\\\\":\\\\nline 117 pos 69: named argument expected\\\\n    test('infers \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n if the first newline uses that', skip:true, () {\\\\n                                                                    ^\\\",\\\"stackTrace\\\":\\\"\\\",\\\"isFailure\\\":false,\\\"type\\\":\\\"error\\\",\\\"time\\\":497}\\n\",\n        \"{\\\"testID\\\":0,\\\"result\\\":\\\"error\\\",\\\"hidden\\\":false,\\\"type\\\":\\\"testDone\\\",\\\"time\\\":499}\\n\",\n        \"{\\\"success\\\":false,\\\"type\\\":\\\"done\\\",\\\"time\\\":500}\\n\", \"\\n\", \"Process finished with exit code 1\\n\",};\n    String[] signals = {\"start Failed to load\", \"fail Failed to load false\", \"finish loading test/formatter_test.dart\"};\n    runTest(events, signals, new int[]{});\n  }","id":43251,"modified_method":"public void testLoadFailure() throws Exception {\n    String[] events = {\n      \"{'test':{'id':0,'name':'loading test/formatter_test.dart','groupIDs':[],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':0}\\n\",\n      \"{'testID':0,'error':'Failed to load \\\\\\\"test/formatter_test.dart\\\\\\\":\\\\nline 117 pos 69','stackTrace':'','isFailure':false,'type':'error','time':497}\\n\",\n      \"{'testID':0,'error':'2nd failure message','stackTrace':'','isFailure':false,'type':'error','time':497}\\n\",\n      \"{'testID':0,'error':'3rd failure message','stackTrace':'3rd stack trace','isFailure':false,'type':'error','time':497}\\n\",\n      \"{'testID':0,'result':'error','hidden':false,'type':'testDone','time':499}\\n\",\n      \"{'test':{'id':1,'name':'loading another_bad_test.dart','groupIDs':[],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':0}\\n\",\n      \"{'testID':1,'message':'some output\\\\n','type':'print','time':30}\\n\",\n      \"{'testID':1,'error':'Failed to load \\\\\\\"another_bad_test.dart\\\\\\\"','stackTrace':'some stack','isFailure':false,'type':'error','time':497}\\n\",\n      \"{'testID':1,'result':'error','hidden':true,'type':'testDone','time':499}\\n\",\n      \"{'success':false,'type':'done','time':500}\\n\", \"\\n\", \"Process finished with exit code 1\\n\",\n    };\n    String[] signals = {\n      \"start loading formatter_test.dart\",\n      \"fail loading formatter_test.dart true\",\n      \"print loading formatter_test.dart 2nd failure message\\n\",\n      \"print loading formatter_test.dart 3rd failure message\\n\",\n      \"print loading formatter_test.dart 3rd stack trace\\n\",\n      \"finish loading formatter_test.dart\",\n      \"start loading another_bad_test.dart\",\n      \"print loading another_bad_test.dart some output\\n\",\n      \"fail loading another_bad_test.dart true\",\n      \"print loading another_bad_test.dart some stack\\n\",\n      \"finish loading another_bad_test.dart\"\n    };\n    runTest(events, signals, new int[]{});\n  }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testGroupsDone() throws Exception {\n    String[] events = {\n      \"{'protocolVersion':'0.1.0','runnerVersion':'0.12.10','type':'start','time':0}\\n\",\n      \"{'count':1,'type':'allSuites','time':0}\\n\",\n      \"{'suite':{'id':0,'platform':'vm','path':'C:/dart_projects/DartSample2/test/a/bb/c/foo_test.dart'},'type':'suite','time':0}\\n\",\n      \"{'test':{'id':1,'name':'loading C:/dart_projects/DartSample2/test/a/bb/c/foo_test.dart','suiteID':0,'groupIDs':[],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':0}\\n\",\n      \"{'testID':1,'result':'success','hidden':true,'type':'testDone','time':192}\\n\",\n      \"{'group':{'id':2,'suiteID':0,'parentID':null,'name':null,'metadata':{'skip':false,'skipReason':null},'testCount':6},'type':'group','time':196}\\n\",\n      \"{'group':{'id':3,'suiteID':0,'parentID':2,'name':'some group','metadata':{'skip':false,'skipReason':null},'testCount':5},'type':'group','time':196}\\n\",\n      \"{'group':{'id':4,'suiteID':0,'parentID':3,'name':'some group sub group 1','metadata':{'skip':false,'skipReason':null},'testCount':1},'type':'group','time':196}\\n\",\n      \"{'test':{'id':5,'name':'some group sub group 1 passing test1','suiteID':0,'groupIDs':[2,3,4],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':196}\\n\",\n      \"{'testID':5,'result':'success','hidden':false,'type':'testDone','time':1224}\\n\",\n      \"{'group':{'id':6,'suiteID':0,'parentID':3,'name':'some group sub group 2','metadata':{'skip':false,'skipReason':null},'testCount':3},'type':'group','time':1224}\\n\",\n      \"{'test':{'id':7,'name':'some group sub group 2 passing test 2','suiteID':0,'groupIDs':[2,3,6],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':1224}\\n\",\n      \"{'testID':7,'result':'success','hidden':false,'type':'testDone','time':2226}\\n\",\n      \"{'test':{'id':8,'name':'some group sub group 2 skipped test','suiteID':0,'groupIDs':[2,3,6],'metadata':{'skip':true,'skipReason':'skip reason'}},'type':'testStart','time':2227}\\n\",\n      \"{'testID':8,'result':'success','hidden':false,'type':'testDone','time':2227}\\n\",\n      \"{'test':{'id':9,'name':'some group sub group 2 standard TestFailure','suiteID':0,'groupIDs':[2,3,6],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':2228}\\n\",\n      \"{'testID':9,'message':'in standard TestFailure test','type':'print','time':2230}\\n\",\n      \"{'testID':9,'error':'Expected: <false>\\n  Actual: <true>\\n','stackTrace':'package:test                     expect\\ntest\\\\a\\\\bb\\\\c\\\\foo_test.dart 12:79  main.<fn>.<fn>.<fn>\\n','isFailure':true,'type':'error','time':2365}\\n\",\n      \"{'testID':9,'result':'failure','hidden':false,'type':'testDone','time':2366}\\n\",\n      \"{'test':{'id':10,'name':'some group unexpected error','suiteID':0,'groupIDs':[2,3],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':2366}\\n\",\n      \"{'testID':10,'message':'in unexpected error test','type':'print','time':2367}\\n\",\n      \"{'testID':10,'error':'Unlucky','stackTrace':'test\\\\a\\\\bb\\\\c\\\\foo_test.dart 15:69  main.<fn>.<fn>\\n','isFailure':false,'type':'error','time':2401}\\n\",\n      \"{'testID':10,'result':'error','hidden':false,'type':'testDone','time':2401}\\n\",\n      \"{'test':{'id':11,'name':'passing test 3','suiteID':0,'groupIDs':[2],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':2402}\\n\",\n      \"{'testID':11,'message':'in passing test','type':'print','time':2403}\\n\",\n      \"{'testID':11,'result':'success','hidden':false,'type':'testDone','time':3404}\\n\",\n      \"{'success':false,'type':'done','time':3406}\\n\",\n    };\n    String[] signals = {\n      \"suite started foo_test.dart\",\n      \"suite started some group\",\n      \"suite started sub group 1\",\n      \"start passing test1\",\n      \"finish passing test1\",\n      \"suite finished sub group 1\",\n      \"suite started sub group 2\",\n      \"start passing test 2\",\n      \"finish passing test 2\",\n      \"start skipped test\",\n      \"skip skipped test skip reason\",\n      \"finish skipped test\",\n      \"start standard TestFailure\",\n      \"print standard TestFailure \\nin standard TestFailure test\\n\",\n      \"finish standard TestFailure\",\n      \"suite finished sub group 2\",\n      \"start unexpected error\",\n      \"print unexpected error \\nin unexpected error test\\n\",\n      \"finish unexpected error\",\n      \"suite finished some group\",\n      \"start passing test 3\",\n      \"print passing test 3 \\nin passing test\\n\",\n      \"finish passing test 3\",\n      \"suite finished foo_test.dart\"\n    };\n    runTest(events, signals, new int[]{});\n  }","id":43252,"modified_method":"public void testGroupsDone() throws Exception {\n    String[] events = {\n      \"{'protocolVersion':'0.1.0','runnerVersion':'0.12.10','type':'start','time':0}\\n\",\n      \"{'count':1,'type':'allSuites','time':0}\\n\",\n      \"{'suite':{'id':0,'platform':'vm','path':'C:/dart_projects/DartSample2/test/a/bb/c/foo_test.dart'},'type':'suite','time':0}\\n\",\n      \"{'test':{'id':1,'name':'loading C:/dart_projects/DartSample2/test/a/bb/c/foo_test.dart','suiteID':0,'groupIDs':[],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':0}\\n\",\n      \"{'testID':1,'result':'success','hidden':true,'type':'testDone','time':192}\\n\",\n      \"{'group':{'id':2,'suiteID':0,'parentID':null,'name':null,'metadata':{'skip':false,'skipReason':null},'testCount':6},'type':'group','time':196}\\n\",\n      \"{'group':{'id':3,'suiteID':0,'parentID':2,'name':'some group','metadata':{'skip':false,'skipReason':null},'testCount':5},'type':'group','time':196}\\n\",\n      \"{'group':{'id':4,'suiteID':0,'parentID':3,'name':'some group sub group 1','metadata':{'skip':false,'skipReason':null},'testCount':1},'type':'group','time':196}\\n\",\n      \"{'test':{'id':5,'name':'some group sub group 1 passing test1','suiteID':0,'groupIDs':[2,3,4],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':196}\\n\",\n      \"{'testID':5,'result':'success','hidden':false,'type':'testDone','time':1224}\\n\",\n      \"{'group':{'id':6,'suiteID':0,'parentID':3,'name':'some group sub group 2','metadata':{'skip':false,'skipReason':null},'testCount':3},'type':'group','time':1224}\\n\",\n      \"{'test':{'id':7,'name':'some group sub group 2 passing test 2','suiteID':0,'groupIDs':[2,3,6],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':1224}\\n\",\n      \"{'testID':7,'result':'success','hidden':false,'type':'testDone','time':2226}\\n\",\n      \"{'test':{'id':8,'name':'some group sub group 2 skipped test','suiteID':0,'groupIDs':[2,3,6],'metadata':{'skip':true,'skipReason':'skip reason'}},'type':'testStart','time':2227}\\n\",\n      \"{'testID':8,'result':'success','hidden':false,'type':'testDone','time':2227}\\n\",\n      \"{'test':{'id':9,'name':'some group sub group 2 standard TestFailure','suiteID':0,'groupIDs':[2,3,6],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':2228}\\n\",\n      \"{'testID':9,'message':'in standard TestFailure test','type':'print','time':2230}\\n\",\n      \"{'testID':9,'error':'Expected: <false>\\n  Actual: <true>\\n','stackTrace':'package:test                     expect\\ntest\\\\a\\\\bb\\\\c\\\\foo_test.dart 12:79  main.<fn>.<fn>.<fn>\\n','isFailure':true,'type':'error','time':2365}\\n\",\n      \"{'testID':9,'result':'failure','hidden':false,'type':'testDone','time':2366}\\n\",\n      \"{'test':{'id':10,'name':'some group unexpected error','suiteID':0,'groupIDs':[2,3],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':2366}\\n\",\n      \"{'testID':10,'message':'in unexpected error test','type':'print','time':2367}\\n\",\n      \"{'testID':10,'error':'Unlucky','stackTrace':'test\\\\a\\\\bb\\\\c\\\\foo_test.dart 15:69  main.<fn>.<fn>\\n','isFailure':false,'type':'error','time':2401}\\n\",\n      \"{'testID':10,'result':'error','hidden':false,'type':'testDone','time':2401}\\n\",\n      \"{'test':{'id':11,'name':'passing test 3','suiteID':0,'groupIDs':[2],'metadata':{'skip':false,'skipReason':null}},'type':'testStart','time':2402}\\n\",\n      \"{'testID':11,'message':'in passing test','type':'print','time':2403}\\n\",\n      \"{'testID':11,'result':'success','hidden':false,'type':'testDone','time':3404}\\n\",\n      \"{'success':false,'type':'done','time':3406}\\n\",\n    };\n    String[] signals = {\n      \"suite started foo_test.dart\",\n      \"suite started some group\",\n      \"suite started sub group 1\",\n      \"start passing test1\",\n      \"finish passing test1\",\n      \"suite finished sub group 1\",\n      \"suite started sub group 2\",\n      \"start passing test 2\",\n      \"finish passing test 2\",\n      \"start skipped test\",\n      \"skip skipped test skip reason\",\n      \"finish skipped test\",\n      \"start standard TestFailure\",\n      \"print standard TestFailure in standard TestFailure test\\n\",\n      \"finish standard TestFailure\",\n      \"suite finished sub group 2\",\n      \"start unexpected error\",\n      \"print unexpected error in unexpected error test\\n\",\n      \"finish unexpected error\",\n      \"suite finished some group\",\n      \"start passing test 3\",\n      \"print passing test 3 in passing test\\n\",\n      \"finish passing test 3\",\n      \"suite finished foo_test.dart\"\n    };\n    runTest(events, signals, new int[]{});\n  }","commit_id":"a054acd0a2e084c65ef759263e8fd9e15cee3fd0","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean processGroupDone(Group group) throws ParseException {\n    if (group.isArtificial()) return true;\n    ServiceMessageBuilder groupMsg = ServiceMessageBuilder.testSuiteFinished(group.getBaseName());\n    finishMessage(groupMsg, group.getId(), group.getValidParentId());\n    return true;\n  }","id":43253,"modified_method":"private boolean processGroupDone(@NotNull final Group group) throws ParseException {\n    if (group.isArtificial()) return true;\n\n    ServiceMessageBuilder groupMsg = ServiceMessageBuilder.testSuiteFinished(group.getBaseName());\n    return finishMessage(groupMsg, group.getId(), group.getValidParentId());\n  }","commit_id":"1d2202e163637c74207e9e1355ca475c8d77ad58","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void processAllTestsDone() {\n    // All tests are done.\n    for (Group group : myGroupData.values()) {\n      // There is no 'groupDone' event, due to asynchrony, so finish them all at the end.\n      // AFAIK the order does not matter. A depth-first post-order traversal of the tree would work\n      // if order does matter. Note: Currently, there is no tree representation, just parent links.\n      try {\n        processGroupDone(group);\n      }\n      catch (ParseException ex) {\n        // ignore it\n      }\n    }\n    myTestData.clear();\n    myGroupData.clear();\n    mySuiteData.clear();\n    mySuitCount = 0;\n  }","id":43254,"modified_method":"private void processAllTestsDone() {\n    // All tests are done.\n    for (Group group : myGroupData.values()) {\n      // For package: test prior to v. 0.12.9 there were no Group.testCount field, so need to finish them all at the end.\n      // AFAIK the order does not matter. A depth-first post-order traversal of the tree would work\n      // if order does matter. Note: Currently, there is no tree representation, just parent links.\n\n      if (group.getTestCount() == 0 || group.getDoneTestsCount() != group.getTestCount()) {\n        try {\n          processGroupDone(group);\n        }\n        catch (ParseException ex) {\n          // ignore it\n        }\n      }\n    }\n    myTestData.clear();\n    myGroupData.clear();\n    mySuiteData.clear();\n    mySuitCount = 0;\n  }","commit_id":"1d2202e163637c74207e9e1355ca475c8d77ad58","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean handleTestDone(JsonObject obj) throws ParseException {\n    if (getBoolean(obj, JSON_HIDDEN)) return true;\n    String result = getResult(obj);\n    if (!result.equals(RESULT_SUCCESS) && !result.equals(RESULT_FAILURE) && !result.equals(RESULT_ERROR)) {\n      throw new ParseException(\"Unknown result: \" + obj, 0);\n    }\n\n    Test test = getTest(obj);\n    setNotRunning(test);\n\n    //if (test.getMetadata().skip) return true; // skipped tests are reported as ignored in\n\n    // Since we cannot tell when a group is finished always reset the parent ID.\n    long duration = getTestMillis(obj) - myStartMillis;\n    ServiceMessageBuilder testFinished = ServiceMessageBuilder.testFinished(test.getBaseName());\n    testFinished.addAttribute(\"duration\", Long.toString(duration));\n    return finishMessage(testFinished, test.getId(), test.getValidParentId());\n  }","id":43255,"modified_method":"private boolean handleTestDone(JsonObject obj) throws ParseException {\n    if (getBoolean(obj, JSON_HIDDEN)) return true;\n    String result = getResult(obj);\n    if (!result.equals(RESULT_SUCCESS) && !result.equals(RESULT_FAILURE) && !result.equals(RESULT_ERROR)) {\n      throw new ParseException(\"Unknown result: \" + obj, 0);\n    }\n\n    Test test = getTest(obj);\n    test.testDone();\n\n    //if (test.getMetadata().skip) return true; // skipped tests are reported as ignored in\n\n    // Since we cannot tell when a group is finished always reset the parent ID.\n    long duration = getTestMillis(obj) - myStartMillis;\n    ServiceMessageBuilder testFinished = ServiceMessageBuilder.testFinished(test.getBaseName());\n    testFinished.addAttribute(\"duration\", Long.toString(duration));\n\n    return finishMessage(testFinished, test.getId(), test.getValidParentId()) && checkGroupDone(test.getParent());\n  }","commit_id":"1d2202e163637c74207e9e1355ca475c8d77ad58","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public void onSuiteStarted(@NotNull TestSuiteStartedEvent suiteStartedEvent) {\n      DefaultMutableTreeNode node = new DefaultMutableTreeNode(suiteStartedEvent.getName());\n      myNodes.put(suiteStartedEvent.getId(), node);\n      DefaultMutableTreeNode parentNode = myParentNode;\n      int parentId = suiteStartedEvent.getParentId();\n      if (parentId > 0) {\n        parentNode = myNodes.get(parentId);\n      }\n      myTreeModel.insertNodeInto(node, parentNode, parentNode.getChildCount());\n      myResultsViewer.performUpdate();\n    }","id":43256,"modified_method":"@Override\n    public void onSuiteStarted(@NotNull TestSuiteStartedEvent suiteStartedEvent) {\n      signals.add(\"suite started \" + suiteStartedEvent.getName());\n\n      DefaultMutableTreeNode node = new DefaultMutableTreeNode(suiteStartedEvent.getName());\n      myNodes.put(suiteStartedEvent.getId(), node);\n      DefaultMutableTreeNode parentNode = myParentNode;\n      int parentId = suiteStartedEvent.getParentId();\n      if (parentId > 0) {\n        parentNode = myNodes.get(parentId);\n      }\n      myTreeModel.insertNodeInto(node, parentNode, parentNode.getChildCount());\n      myResultsViewer.performUpdate();\n    }","commit_id":"1d2202e163637c74207e9e1355ca475c8d77ad58","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public void onSuiteFinished(@NotNull TestSuiteFinishedEvent suiteFinishedEvent) {\n    }","id":43257,"modified_method":"@Override\n    public void onSuiteFinished(@NotNull TestSuiteFinishedEvent suiteFinishedEvent) {\n      signals.add(\"suite finished \" + suiteFinishedEvent.getName());\n    }","commit_id":"1d2202e163637c74207e9e1355ca475c8d77ad58","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public boolean isSuspended()\n    {\n        return _request.isAsyncStarted();\n    }","id":43258,"modified_method":"@Override\n    public boolean isSuspended()\n    {\n        if (_request.isAsyncStarted())\n            return true;\n        try\n        {\n            return _request.getAsyncContext()!=null;\n        }\n        catch(IllegalStateException e)\n        {\n            // ignored\n        }\n        return false;\n    }","commit_id":"6ed36160f0d893590320403f1abb528eda0d9094","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Invoke the next Valve in the sequence. When the invoke returns, check\n     * the response state, and output an error report is necessary.\n     *\n     * @param request The servlet request to be processed\n     * @param response The servlet response to be created\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet error occurs\n     */\n    @Override\n    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Perform the request\n        getNext().invoke(request, response);\n\n        if (response.isCommitted()) {\n            return;\n        }\n\n        if (request.isAsyncStarted()) {\n            return;\n        }\n\n        Throwable throwable =\n            (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);\n\n        if (throwable != null) {\n\n            // The response is an error\n            response.setError();\n\n            // Reset the response (if possible)\n            try {\n                response.reset();\n            } catch (IllegalStateException e) {\n                // Ignore\n            }\n\n            response.sendError\n                (HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\n        }\n\n        response.setSuspended(false);\n\n        try {\n            report(request, response, throwable);\n        } catch (Throwable tt) {\n            ExceptionUtils.handleThrowable(tt);\n        }\n\n    }","id":43259,"modified_method":"/**\n     * Invoke the next Valve in the sequence. When the invoke returns, check\n     * the response state, and output an error report is necessary.\n     *\n     * @param request The servlet request to be processed\n     * @param response The servlet response to be created\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet error occurs\n     */\n    @Override\n    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Perform the request\n        getNext().invoke(request, response);\n\n        if (response.isCommitted()) {\n            return;\n        }\n\n        Throwable throwable =\n                (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);\n\n        if (request.isAsyncStarted() && response.getStatus() < 400 &&\n                throwable == null) {\n            return;\n        }\n\n        if (throwable != null) {\n\n            // The response is an error\n            response.setError();\n\n            // Reset the response (if possible)\n            try {\n                response.reset();\n            } catch (IllegalStateException e) {\n                // Ignore\n            }\n\n            response.sendError\n                (HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\n        }\n\n        response.setSuspended(false);\n\n        try {\n            report(request, response, throwable);\n        } catch (Throwable tt) {\n            ExceptionUtils.handleThrowable(tt);\n        }\n\n        if (request.isAsyncStarted()) {\n            request.getAsyncContext().complete();\n        }\n    }","commit_id":"2d30290b42f67395ae655fbf66da7628cd6c6fb0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws ServletException, IOException {\n\n            final AsyncContext actxt = req.startAsync();\n            actxt.setTimeout(TIMEOUT);\n            if (threaded) {\n                actxt.start(new Runnable() {\n                    @Override\n                    public void run() {\n                        try {\n                            HttpServletResponse resp =\n                                    (HttpServletResponse) actxt.getResponse();\n                            resp.sendError(status);\n                        } catch (IOException e) {\n                            // Ignore\n                        }\n                    }\n                });\n            } else {\n                resp.sendError(status);\n            }\n        }","id":43260,"modified_method":"@Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws ServletException, IOException {\n\n            final AsyncContext actxt = req.startAsync();\n            actxt.setTimeout(TIMEOUT);\n            if (threaded) {\n                actxt.start(new Runnable() {\n                    @Override\n                    public void run() {\n                        try {\n                            HttpServletResponse resp =\n                                    (HttpServletResponse) actxt.getResponse();\n                            resp.sendError(status, ERROR_MESSAGE);\n                            // Complete so there is no delay waiting for the\n                            // timeout\n                            actxt.complete();\n                        } catch (IOException e) {\n                            // Ignore\n                        }\n                    }\n                });\n            } else {\n                resp.sendError(status);\n            }\n        }","commit_id":"2d30290b42f67395ae655fbf66da7628cd6c6fb0","url":"https://github.com/apache/tomcat"},{"original_method":"private void doTestBug51197(boolean threaded) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        AsyncErrorServlet asyncErrorServlet =\n            new AsyncErrorServlet(HttpServletResponse.SC_BAD_REQUEST, threaded);\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"asyncErrorServlet\", asyncErrorServlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/asyncErrorServlet\", \"asyncErrorServlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/asyncErrorServlet\");\n\n        int rc = getUrl(url.toString(), new ByteChunk(), null);\n\n        assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);\n\n        // Without this test may complete before access log has a chance to log\n        // the request\n        Thread.sleep(REQUEST_TIME);\n\n        // Check the access log\n        alv.validateAccessLog(1, HttpServletResponse.SC_BAD_REQUEST, TIMEOUT,\n                TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);\n\n    }","id":43261,"modified_method":"private void doTestBug51197(boolean threaded) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        AsyncErrorServlet asyncErrorServlet =\n            new AsyncErrorServlet(HttpServletResponse.SC_BAD_REQUEST, threaded);\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"asyncErrorServlet\", asyncErrorServlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/asyncErrorServlet\", \"asyncErrorServlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/asyncErrorServlet\");\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(url.toString(), res, null);\n\n        assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);\n\n        // SRV 10.9.2 - Writing the response is entirely the application's\n        // responsibility when an error occurs on an application thread.\n        // The test servlet writes no content in this case.\n        if (threaded) {\n            assertEquals(0, res.getLength());\n        } else {\n            assertTrue(res.getLength() > 0);\n        }\n\n        // Without this test may complete before access log has a chance to log\n        // the request\n        Thread.sleep(REQUEST_TIME);\n\n        // Check the access log\n        alv.validateAccessLog(1, HttpServletResponse.SC_BAD_REQUEST, 0,\n                REQUEST_TIME);\n    }","commit_id":"2d30290b42f67395ae655fbf66da7628cd6c6fb0","url":"https://github.com/apache/tomcat"},{"original_method":"public void setErrorState() {\n        state.set(AsyncState.ERROR_DISPATCHING);\n    }","id":43262,"modified_method":"public void setErrorState(Throwable t) {\n        if (t!=null) request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);\n        state.set(AsyncState.ERROR_DISPATCHING);\n    }","commit_id":"b2c34f2fe90ad7be3b4e1fcab055dbee28373155","url":"https://github.com/apache/tomcat"},{"original_method":"public boolean asyncDispatch(org.apache.coyote.Request req,org.apache.coyote.Response res, SocketStatus status) throws Exception {\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n\n        if (request == null) {\n            throw new IllegalStateException(\"Dispatch may only happen on an existing request.\");\n        }\n        boolean comet = false;\n        boolean async = false;\n        boolean success = true;\n        \n        try {\n            if (status==SocketStatus.TIMEOUT) {\n                AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();\n                //TODO SERVLET3 - async\n                //configure settings for timed out\n                asyncConImpl.setTimeoutState();\n            }\n            if (status==SocketStatus.ERROR || status==SocketStatus.STOP || status==SocketStatus.DISCONNECT) {\n                AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();\n                //TODO SERVLET3 - async\n                //configure settings for timed out\n                asyncConImpl.setErrorState();\n            }\n            while (success) {\n                AsyncContextImpl impl = (AsyncContextImpl)request.getAsyncContext();\n                    // Calling the container\n                if (impl.getState()==AsyncContextImpl.AsyncState.DISPATCHED) {\n                    // Calling the container\n                    try {\n                        impl.complete();\n                        connector.getContainer().getPipeline().getFirst().invoke(request, response);\n                    } finally {\n                        success = false;\n                    }\n                } else if (impl.getState()==AsyncContextImpl.AsyncState.STARTED){\n                    //TODO SERVLET3 - async\n                    res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext());\n                    async = true;\n                    break;\n                } else if (impl.getState()==AsyncContextImpl.AsyncState.NOT_STARTED){\n                        //TODO SERVLET3 - async\n                        async = false;\n                        break;\n                } else {\n                    try {\n                        connector.getContainer().getPipeline().getFirst().invoke(request, response);\n                    }catch (RuntimeException x) {\n                        success = false;\n                    } finally {\n                    }\n                }\n            }\n            \n            if (request.isComet()) {\n                if (!response.isClosed() && !response.isError()) {\n                    if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {\n                        // Invoke a read event right away if there are available bytes\n                        if (event(req, res, SocketStatus.OPEN)) {\n                            comet = true;\n                            res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                        }\n                    } else {\n                        comet = true;\n                        res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                    }\n                } else {\n                    // Clear the filter chain, as otherwise it will not be reset elsewhere\n                    // since this is a Comet request\n                    request.setFilterChain(null);\n                }\n            }\n            if (!async && !comet) {\n                response.finishResponse();\n                req.action(ActionCode.ACTION_POST_REQUEST , null);\n            }\n\n        } catch (IOException e) {\n            success = false;\n            // Ignore\n        } catch (Throwable t) {\n            success = false;\n            log.error(sm.getString(\"coyoteAdapter.service\"), t);\n        } finally {\n            req.getRequestProcessor().setWorkerThreadName(null);\n            // Recycle the wrapper request and response\n            if (!success || (!comet && !async)) {\n                request.recycle();\n                response.recycle();\n            } else {\n                // Clear converters so that the minimum amount of memory \n                // is used by this processor\n                request.clearEncoders();\n                response.clearEncoders();\n            }\n        }\n        return success;\n    }","id":43263,"modified_method":"public boolean asyncDispatch(org.apache.coyote.Request req,org.apache.coyote.Response res, SocketStatus status) throws Exception {\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n\n        if (request == null) {\n            throw new IllegalStateException(\"Dispatch may only happen on an existing request.\");\n        }\n        boolean comet = false;\n        boolean async = false;\n        boolean success = true;\n        \n        try {\n            if (status==SocketStatus.TIMEOUT) {\n                AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();\n                //TODO SERVLET3 - async\n                //configure settings for timed out\n                asyncConImpl.setTimeoutState();\n            }\n            if (status==SocketStatus.ERROR || status==SocketStatus.STOP || status==SocketStatus.DISCONNECT) {\n                AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();\n                //TODO SERVLET3 - async\n                //configure settings for timed out\n                asyncConImpl.setErrorState(new IOException(\"Socket error.\"));\n            }\n            while (success) {\n                AsyncContextImpl impl = (AsyncContextImpl)request.getAsyncContext();\n                    // Calling the container\n                if (impl.getState()==AsyncContextImpl.AsyncState.DISPATCHED) {\n                    // Calling the container\n                    try {\n                        impl.complete();\n                        connector.getContainer().getPipeline().getFirst().invoke(request, response);\n                    } finally {\n                        success = false;\n                    }\n                } else if (impl.getState()==AsyncContextImpl.AsyncState.STARTED){\n                    //TODO SERVLET3 - async\n                    res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext());\n                    async = true;\n                    break;\n                } else if (impl.getState()==AsyncContextImpl.AsyncState.NOT_STARTED){\n                        //TODO SERVLET3 - async\n                        async = false;\n                        break;\n                } else if (impl.getState()==AsyncContextImpl.AsyncState.ERROR_DISPATCHING) {\n                    async = false;\n                    success = false;\n                    connector.getContainer().getPipeline().getFirst().invoke(request, response);\n                } else {\n                    try {\n                        connector.getContainer().getPipeline().getFirst().invoke(request, response);\n                    } catch (RuntimeException x) {\n                        impl.setErrorState(x);\n                    }\n                }\n            }\n            \n            if (request.isComet()) {\n                if (!response.isClosed() && !response.isError()) {\n                    if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {\n                        // Invoke a read event right away if there are available bytes\n                        if (event(req, res, SocketStatus.OPEN)) {\n                            comet = true;\n                            res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                        }\n                    } else {\n                        comet = true;\n                        res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                    }\n                } else {\n                    // Clear the filter chain, as otherwise it will not be reset elsewhere\n                    // since this is a Comet request\n                    request.setFilterChain(null);\n                }\n            }\n            if (!async && !comet) {\n                response.finishResponse();\n                req.action(ActionCode.ACTION_POST_REQUEST , null);\n            }\n\n        } catch (IOException e) {\n            success = false;\n            // Ignore\n        } catch (Throwable t) {\n            success = false;\n            log.error(sm.getString(\"coyoteAdapter.service\"), t);\n        } finally {\n            req.getRequestProcessor().setWorkerThreadName(null);\n            // Recycle the wrapper request and response\n            if (!success || (!comet && !async)) {\n                request.recycle();\n                response.recycle();\n            } else {\n                // Clear converters so that the minimum amount of memory \n                // is used by this processor\n                request.clearEncoders();\n                response.clearEncoders();\n            }\n        }\n        return success;\n    }","commit_id":"b2c34f2fe90ad7be3b4e1fcab055dbee28373155","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Service method.\n     */\n    public void service(org.apache.coyote.Request req, \n    \t                org.apache.coyote.Response res)\n        throws Exception {\n\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n\n        if (request == null) {\n\n            // Create objects\n            request = connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            // Link objects\n            request.setResponse(response);\n            response.setRequest(request);\n\n            // Set as notes\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            // Set query string encoding\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n\n        }\n\n        if (connector.getXpoweredBy()) {\n            response.addHeader(\"X-Powered-By\", POWERED_BY);\n        }\n\n        boolean comet = false;\n        boolean async = request.isAsyncStarted();\n        \n        try {\n\n            // Parse and set Catalina and configuration specific \n            // request parameters\n            req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());\n            if (postParseRequest(req, request, res, response)) {\n                //check valves if we support async\n                request.setAsyncSupported(connector.getContainer().getPipeline().isAsyncSupported());\n                // Calling the container\n                connector.getContainer().getPipeline().getFirst().invoke(request, response);\n\n                if (request.isComet()) {\n                    if (!response.isClosed() && !response.isError()) {\n                        if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {\n                            // Invoke a read event right away if there are available bytes\n                            if (event(req, res, SocketStatus.OPEN)) {\n                                comet = true;\n                                res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                            }\n                        } else {\n                            comet = true;\n                            res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                        }\n                    } else {\n                        // Clear the filter chain, as otherwise it will not be reset elsewhere\n                        // since this is a Comet request\n                        request.setFilterChain(null);\n                    }\n                }\n\n            }\n            AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();\n            if (asyncConImpl!=null && asyncConImpl.getState()==AsyncContextImpl.AsyncState.STARTED) {\n                res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext());\n                async = true;\n            } else if (asyncConImpl!=null && \n                          (asyncConImpl.getState()==AsyncContextImpl.AsyncState.DISPATCHING ||\n                           asyncConImpl.getState()==AsyncContextImpl.AsyncState.COMPLETING  ||\n                           asyncConImpl.getState()==AsyncContextImpl.AsyncState.TIMING_OUT  ||\n                           asyncConImpl.getState()==AsyncContextImpl.AsyncState.ERROR_DISPATCHING)) {\n                asyncDispatch(req, res, SocketStatus.OPEN);\n            } else if (!comet) {\n                response.finishResponse();\n                req.action(ActionCode.ACTION_POST_REQUEST , null);\n            }\n\n        } catch (IOException e) {\n            // Ignore\n        } catch (Throwable t) {\n            log.error(sm.getString(\"coyoteAdapter.service\"), t);\n        } finally {\n            req.getRequestProcessor().setWorkerThreadName(null);\n            // Recycle the wrapper request and response\n            if (!comet && !async) {\n                request.recycle();\n                response.recycle();\n            } else {\n                // Clear converters so that the minimum amount of memory \n                // is used by this processor\n                request.clearEncoders();\n                response.clearEncoders();\n            }\n        }\n\n    }","id":43264,"modified_method":"/**\n     * Service method.\n     */\n    public void service(org.apache.coyote.Request req, \n    \t                org.apache.coyote.Response res)\n        throws Exception {\n\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n\n        if (request == null) {\n\n            // Create objects\n            request = connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            // Link objects\n            request.setResponse(response);\n            response.setRequest(request);\n\n            // Set as notes\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            // Set query string encoding\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n\n        }\n\n        if (connector.getXpoweredBy()) {\n            response.addHeader(\"X-Powered-By\", POWERED_BY);\n        }\n\n        boolean comet = false;\n        boolean async = false;\n        \n        try {\n\n            // Parse and set Catalina and configuration specific \n            // request parameters\n            req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());\n            if (postParseRequest(req, request, res, response)) {\n                //check valves if we support async\n                request.setAsyncSupported(connector.getContainer().getPipeline().isAsyncSupported());\n                // Calling the container\n                connector.getContainer().getPipeline().getFirst().invoke(request, response);\n\n                if (request.isComet()) {\n                    if (!response.isClosed() && !response.isError()) {\n                        if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {\n                            // Invoke a read event right away if there are available bytes\n                            if (event(req, res, SocketStatus.OPEN)) {\n                                comet = true;\n                                res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                            }\n                        } else {\n                            comet = true;\n                            res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                        }\n                    } else {\n                        // Clear the filter chain, as otherwise it will not be reset elsewhere\n                        // since this is a Comet request\n                        request.setFilterChain(null);\n                    }\n                }\n\n            }\n            AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();\n            if (asyncConImpl!=null && asyncConImpl.getState()==AsyncContextImpl.AsyncState.STARTED) {\n                res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext());\n                async = true;\n            } else if (request.isAsyncDispatching()) {\n                asyncDispatch(req, res, SocketStatus.OPEN);\n                if (request.isAsyncStarted()) {\n                    async = true;\n                    res.action(ActionCode.ACTION_ASYNC_START, request.getAsyncContext());\n                }\n            } else if (!comet) {\n                response.finishResponse();\n                req.action(ActionCode.ACTION_POST_REQUEST , null);\n            }\n\n        } catch (IOException e) {\n            // Ignore\n        } catch (Throwable t) {\n            log.error(sm.getString(\"coyoteAdapter.service\"), t);\n        } finally {\n            req.getRequestProcessor().setWorkerThreadName(null);\n            // Recycle the wrapper request and response\n            if (!comet && !async) {\n                request.recycle();\n                response.recycle();\n            } else {\n                // Clear converters so that the minimum amount of memory \n                // is used by this processor\n                request.clearEncoders();\n                response.clearEncoders();\n            }\n        }\n\n    }","commit_id":"b2c34f2fe90ad7be3b4e1fcab055dbee28373155","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests on the specified socket.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(SocketWrapper<Socket> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Set the remote address\n        remoteAddr = null;\n        remoteHost = null;\n        localAddr = null;\n        localName = null;\n        remotePort = -1;\n        localPort = -1;\n\n        // Setting up the I/O\n        this.socket = socketWrapper;\n        inputBuffer.setInputStream(socket.getSocket().getInputStream());\n        outputBuffer.setOutputStream(socket.getSocket().getOutputStream());\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n\n        int keepAliveLeft = maxKeepAliveRequests>0?socketWrapper.decrementKeepAlive():-1;\n        \n        int soTimeout = endpoint.getSoTimeout();\n\n        try {\n            socket.getSocket().setSoTimeout(soTimeout);\n        } catch (Throwable t) {\n            log.debug(sm.getString(\"http11processor.socket.timeout\"), t);\n            error = true;\n        }\n\n        boolean keptAlive = socketWrapper.isKeptAlive();\n\n        while (started && !error && keepAlive) {\n\n            // Parsing the request header\n            try {\n                //TODO - calculate timeout based on length in queue (System.currentTimeMills() - wrapper.getLastAccess() is the time in queue)\n                if (keptAlive) {\n                    if (keepAliveTimeout > 0) {\n                        socket.getSocket().setSoTimeout(keepAliveTimeout);\n                    }\n                    else if (soTimeout > 0) {\n                        socket.getSocket().setSoTimeout(soTimeout);\n                    }\n                }\n                inputBuffer.parseRequestLine(false);\n                request.setStartTime(System.currentTimeMillis());\n                keptAlive = true;\n                if (disableUploadTimeout) {\n                    socket.getSocket().setSoTimeout(soTimeout);\n                } else {\n                    socket.getSocket().setSoTimeout(timeout);\n                }\n                inputBuffer.parseHeaders();\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests > 0 && keepAliveLeft == 0)\n                keepAlive = false;\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                statusDropsConnection(response.getStatus());\n                    }\n\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            try {\n                rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n                // If we know we are closing the connection, don't drain input.\n                // This way uploading a 100GB file doesn't tie up the thread \n                // if the servlet has rejected it.\n                \n                if(error && !async)\n                    inputBuffer.setSwallowInput(false);\n                if (!async)\n                    endRequest();\n            } catch (Throwable t) {\n                log.error(sm.getString(\"http11processor.request.finish\"), t);\n                // 500 - Internal Server Error\n                response.setStatus(500);\n                error = true;\n            }\n            try {\n                rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n            } catch (Throwable t) {\n                log.error(sm.getString(\"http11processor.response.finish\"), t);\n                error = true;\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            // Don't reset the param - we'll see it as ended. Next request\n            // will reset it\n            // thrA.setParam(null);\n            // Next request\n            if (!async) {\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n            \n            //hack keep alive behavior\n            break;\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n        if (async) {\n            if (error) {\n                recycle();\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.LONG;\n            }\n        } else {\n            if ( error || (!keepAlive)) {\n                recycle();\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.OPEN;\n            }\n        }\n    }","id":43265,"modified_method":"/**\n     * Process pipelined HTTP requests on the specified socket.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(SocketWrapper<Socket> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Set the remote address\n        remoteAddr = null;\n        remoteHost = null;\n        localAddr = null;\n        localName = null;\n        remotePort = -1;\n        localPort = -1;\n\n        // Setting up the I/O\n        this.socket = socketWrapper;\n        inputBuffer.setInputStream(socket.getSocket().getInputStream());\n        outputBuffer.setOutputStream(socket.getSocket().getOutputStream());\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n\n        int keepAliveLeft = maxKeepAliveRequests>0?socketWrapper.decrementKeepAlive():-1;\n        \n        int soTimeout = endpoint.getSoTimeout();\n\n        try {\n            socket.getSocket().setSoTimeout(soTimeout);\n        } catch (Throwable t) {\n            log.debug(sm.getString(\"http11processor.socket.timeout\"), t);\n            error = true;\n        }\n\n        boolean keptAlive = socketWrapper.isKeptAlive();\n\n        while (started && !error && keepAlive) {\n\n            // Parsing the request header\n            try {\n                //TODO - calculate timeout based on length in queue (System.currentTimeMills() - wrapper.getLastAccess() is the time in queue)\n                if (keptAlive) {\n                    if (keepAliveTimeout > 0) {\n                        socket.getSocket().setSoTimeout(keepAliveTimeout);\n                    }\n                    else if (soTimeout > 0) {\n                        socket.getSocket().setSoTimeout(soTimeout);\n                    }\n                }\n                inputBuffer.parseRequestLine(false);\n                request.setStartTime(System.currentTimeMillis());\n                keptAlive = true;\n                if (disableUploadTimeout) {\n                    socket.getSocket().setSoTimeout(soTimeout);\n                } else {\n                    socket.getSocket().setSoTimeout(timeout);\n                }\n                inputBuffer.parseHeaders();\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests > 0 && keepAliveLeft == 0)\n                keepAlive = false;\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                statusDropsConnection(response.getStatus());\n                    }\n\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            try {\n                rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n                // If we know we are closing the connection, don't drain input.\n                // This way uploading a 100GB file doesn't tie up the thread \n                // if the servlet has rejected it.\n                \n                if(error && !async)\n                    inputBuffer.setSwallowInput(false);\n                if (!async)\n                    endRequest();\n            } catch (Throwable t) {\n                log.error(sm.getString(\"http11processor.request.finish\"), t);\n                // 500 - Internal Server Error\n                response.setStatus(500);\n                error = true;\n            }\n            try {\n                rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n            } catch (Throwable t) {\n                log.error(sm.getString(\"http11processor.response.finish\"), t);\n                error = true;\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            // Don't reset the param - we'll see it as ended. Next request\n            // will reset it\n            // thrA.setParam(null);\n            // Next request\n            if (!async) {\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n            \n            //hack keep alive behavior\n            break;\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n        if (error) {\n            recycle();\n            return SocketState.CLOSED;\n        } else if (async) {\n            return SocketState.LONG;\n        } else {\n            if (!keepAlive) {\n                recycle();\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.OPEN;\n            }\n        } \n    }","commit_id":"b2c34f2fe90ad7be3b4e1fcab055dbee28373155","url":"https://github.com/apache/tomcat"},{"original_method":"public SocketState asyncDispatch(SocketStatus status) throws IOException {\n\n        RequestInfo rp = request.getRequestProcessor();\n        try {\n            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n            error = !adapter.asyncDispatch(request, response, status);\n        } catch (InterruptedIOException e) {\n            error = true;\n        } catch (Throwable t) {\n            log.error(sm.getString(\"http11processor.request.process\"), t);\n            // 500 - Internal Server Error\n            response.setStatus(500);\n            error = true;\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (async) {\n            if (error) {\n                recycle();\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.LONG;\n            }\n        } else {\n            if ( error || (!keepAlive)) {\n                recycle();\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.OPEN;\n            }\n        }\n    }","id":43266,"modified_method":"public SocketState asyncDispatch(SocketStatus status) throws IOException {\n\n        RequestInfo rp = request.getRequestProcessor();\n        try {\n            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n            error = !adapter.asyncDispatch(request, response, status);\n        } catch (InterruptedIOException e) {\n            error = true;\n        } catch (Throwable t) {\n            log.error(sm.getString(\"http11processor.request.process\"), t);\n            // 500 - Internal Server Error\n            response.setStatus(500);\n            error = true;\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error) {\n            recycle();\n            return SocketState.CLOSED;\n        } else if (async) {\n            return SocketState.LONG;\n        } else {\n            if (!keepAlive) {\n                recycle();\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.OPEN;\n            }\n        }\n    }","commit_id":"b2c34f2fe90ad7be3b4e1fcab055dbee28373155","url":"https://github.com/apache/tomcat"},{"original_method":"public static RequestClaim parseClaimType(Element claimType) {\n        String claimLocalName = claimType.getLocalName();\n        String claimNS = claimType.getNamespaceURI();\n        if (\"ClaimType\".equals(claimLocalName)) {\n            String claimTypeUri = claimType.getAttribute(\"Uri\");\n            String claimTypeOptional = claimType.getAttribute(\"Optional\");\n            RequestClaim requestClaim = new RequestClaim();\n            try {\n                requestClaim.setClaimType(new URI(claimTypeUri));\n            } catch (URISyntaxException e) {\n                LOG.log(\n                    Level.WARNING, \n                    \"Cannot create URI from the given ClaimType attribute value \" + claimTypeUri,\n                    e\n                );\n            }\n            requestClaim.setOptional(Boolean.parseBoolean(claimTypeOptional));\n            return requestClaim;\n        } else if (\"ClaimValue\".equals(claimLocalName)) {\n            String claimTypeUri = claimType.getAttribute(\"Uri\");\n            String claimTypeOptional = claimType.getAttribute(\"Optional\");\n            RequestClaim requestClaim = new RequestClaim();\n            try {\n                requestClaim.setClaimType(new URI(claimTypeUri));\n            } catch (URISyntaxException e) {\n                LOG.log(\n                    Level.WARNING, \n                    \"Cannot create URI from the given ClaimTye attribute value \" + claimTypeUri,\n                    e\n                );\n            }\n            \n            Node valueNode = claimType.getFirstChild();\n            if (valueNode != null) {\n                if (\"Value\".equals(valueNode.getLocalName())) {\n                    requestClaim.setClaimValue(valueNode.getTextContent());\n                } else {\n                    LOG.warning(\"Unsupported child element of ClaimValue element \"\n                            + valueNode.getLocalName());\n                    return null;\n                }\n            } else {\n                LOG.warning(\"No child element of ClaimValue element available\");\n                return null;\n            }\n             \n            requestClaim.setOptional(Boolean.parseBoolean(claimTypeOptional));\n            \n            return requestClaim;\n        }\n        \n        LOG.fine(\"Found unknown element: \" + claimLocalName + \" \" + claimNS);\n        return null;\n    }","id":43267,"modified_method":"public static RequestClaim parseClaimType(Element claimType) {\n        String claimLocalName = claimType.getLocalName();\n        String claimNS = claimType.getNamespaceURI();\n        if (\"ClaimType\".equals(claimLocalName)) {\n            String claimTypeUri = claimType.getAttribute(\"Uri\");\n            String claimTypeOptional = claimType.getAttribute(\"Optional\");\n            RequestClaim requestClaim = new RequestClaim();\n            try {\n                requestClaim.setClaimType(new URI(claimTypeUri));\n            } catch (URISyntaxException e) {\n                LOG.log(\n                    Level.WARNING, \n                    \"Cannot create URI from the given ClaimType attribute value \" + claimTypeUri,\n                    e\n                );\n            }\n            requestClaim.setOptional(Boolean.parseBoolean(claimTypeOptional));\n            return requestClaim;\n        } else if (\"ClaimValue\".equals(claimLocalName)) {\n            String claimTypeUri = claimType.getAttribute(\"Uri\");\n            String claimTypeOptional = claimType.getAttribute(\"Optional\");\n            RequestClaim requestClaim = new RequestClaim();\n            try {\n                requestClaim.setClaimType(new URI(claimTypeUri));\n            } catch (URISyntaxException e) {\n                LOG.log(\n                    Level.WARNING, \n                    \"Cannot create URI from the given ClaimTye attribute value \" + claimTypeUri,\n                    e\n                );\n            }\n            \n            Node valueNode = claimType.getFirstChild();\n            if (valueNode != null) {\n                if (\"Value\".equals(valueNode.getLocalName())) {\n                    requestClaim.setClaimValue(valueNode.getTextContent().trim());\n                } else {\n                    LOG.warning(\"Unsupported child element of ClaimValue element \"\n                            + valueNode.getLocalName());\n                    return null;\n                }\n            } else {\n                LOG.warning(\"No child element of ClaimValue element available\");\n                return null;\n            }\n             \n            requestClaim.setOptional(Boolean.parseBoolean(claimTypeOptional));\n            \n            return requestClaim;\n        }\n        \n        LOG.fine(\"Found unknown element: \" + claimLocalName + \" \" + claimNS);\n        return null;\n    }","commit_id":"39f29f9425296f2a67f6afbabed45ca593c4730b","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Parse the UseKey structure to get a ReceivedKey containing a cert/public-key/secret-key.\n     * @param useKey The UseKey object\n     * @param wsContext The WebServiceContext object\n     * @return the ReceivedKey that has been parsed\n     * @throws STSException\n     */\n    private static ReceivedKey parseUseKey(\n        UseKeyType useKey, \n        WebServiceContext wsContext\n    ) throws STSException {\n        byte[] x509 = null;\n        if (useKey.getAny() instanceof JAXBElement<?>) {\n            JAXBElement<?> useKeyJaxb = (JAXBElement<?>)useKey.getAny();\n            if (KeyInfoType.class == useKeyJaxb.getDeclaredType()) {\n                KeyInfoType keyInfoType = KeyInfoType.class.cast(useKeyJaxb.getValue());\n                LOG.fine(\"Found KeyInfo UseKey type\");\n                for (Object keyInfoContent : keyInfoType.getContent()) {\n                    X509DataType x509DataType = extractType(keyInfoContent, X509DataType.class);\n                    if (null != x509DataType) {\n                        LOG.fine(\"Found X509Data KeyInfo type\");\n                        for (Object x509Object \n                            : x509DataType.getX509IssuerSerialOrX509SKIOrX509SubjectName()) {\n                            x509 = extractType(x509Object, byte[].class);\n                            if (null != x509) {\n                                LOG.fine(\"Found X509Certificate UseKey type\");\n                                break;\n                            }\n                        }\n                    }\n                }\n            } else if (SecurityTokenReferenceType.class == useKeyJaxb.getDeclaredType()) {\n                SecurityTokenReferenceType strType = \n                    SecurityTokenReferenceType.class.cast(useKeyJaxb.getValue());\n                Element token = fetchTokenElementFromReference(strType, wsContext);\n                try {\n                    x509 = Base64Utility.decode(token.getTextContent());\n                    LOG.fine(\"Found X509Certificate UseKey type via reference\");\n                } catch (Exception e) {\n                    LOG.log(Level.WARNING, \"\", e);\n                    throw new STSException(e.getMessage(), e, STSException.INVALID_REQUEST);\n                }\n            }\n        } else if (useKey.getAny() instanceof Element) {\n            if (isTokenReferenced(useKey.getAny())) {\n                Element token = fetchTokenElementFromReference(useKey.getAny(), wsContext);\n                try {\n                    x509 = Base64Utility.decode(token.getTextContent());\n                    LOG.fine(\"Found X509Certificate UseKey type via reference\");\n                } catch (Exception e) {\n                    LOG.log(Level.WARNING, \"\", e);\n                    throw new STSException(e.getMessage(), e, STSException.INVALID_REQUEST);\n                }\n            } else {\n                Element element = (Element)useKey.getAny();\n                if (\"KeyInfo\".equals(element.getLocalName())) {\n                    return parseKeyInfoElement((Element)useKey.getAny());\n                } else {\n                    NodeList x509CertData = \n                        element.getElementsByTagNameNS(\n                            Constants.SignatureSpecNS, Constants._TAG_X509CERTIFICATE   \n                        );\n                    if (x509CertData != null && x509CertData.getLength() > 0) {\n                        try {\n                            x509 = Base64Utility.decode(x509CertData.item(0).getTextContent());\n                            LOG.fine(\"Found X509Certificate UseKey type\");\n                        } catch (Exception e) {\n                            LOG.log(Level.WARNING, \"\", e);\n                            throw new STSException(e.getMessage(), e, STSException.INVALID_REQUEST);\n                        }\n                    }\n                }\n            }\n        } else {\n            LOG.log(Level.WARNING, \"An unknown element was received\");\n            throw new STSException(\n                \"An unknown element was received\", STSException.BAD_REQUEST\n            );\n        }\n        \n        if (x509 != null) {\n            try {\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                X509Certificate cert =\n                    (X509Certificate)cf.generateCertificate(new ByteArrayInputStream(x509));\n                LOG.fine(\"Successfully parsed X509 Certificate from UseKey\");\n                ReceivedKey receivedKey = new ReceivedKey();\n                receivedKey.setX509Cert(cert);\n                return receivedKey;\n            } catch (CertificateException ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in parsing certificate: \", ex, STSException.INVALID_REQUEST);\n            }\n        }\n        return null;\n    }","id":43268,"modified_method":"/**\n     * Parse the UseKey structure to get a ReceivedKey containing a cert/public-key/secret-key.\n     * @param useKey The UseKey object\n     * @param wsContext The WebServiceContext object\n     * @return the ReceivedKey that has been parsed\n     * @throws STSException\n     */\n    private static ReceivedKey parseUseKey(\n        UseKeyType useKey, \n        WebServiceContext wsContext\n    ) throws STSException {\n        byte[] x509 = null;\n        if (useKey.getAny() instanceof JAXBElement<?>) {\n            JAXBElement<?> useKeyJaxb = (JAXBElement<?>)useKey.getAny();\n            if (KeyInfoType.class == useKeyJaxb.getDeclaredType()) {\n                KeyInfoType keyInfoType = KeyInfoType.class.cast(useKeyJaxb.getValue());\n                LOG.fine(\"Found KeyInfo UseKey type\");\n                for (Object keyInfoContent : keyInfoType.getContent()) {\n                    X509DataType x509DataType = extractType(keyInfoContent, X509DataType.class);\n                    if (null != x509DataType) {\n                        LOG.fine(\"Found X509Data KeyInfo type\");\n                        for (Object x509Object \n                            : x509DataType.getX509IssuerSerialOrX509SKIOrX509SubjectName()) {\n                            x509 = extractType(x509Object, byte[].class);\n                            if (null != x509) {\n                                LOG.fine(\"Found X509Certificate UseKey type\");\n                                break;\n                            }\n                        }\n                    }\n                }\n            } else if (SecurityTokenReferenceType.class == useKeyJaxb.getDeclaredType()) {\n                SecurityTokenReferenceType strType = \n                    SecurityTokenReferenceType.class.cast(useKeyJaxb.getValue());\n                Element token = fetchTokenElementFromReference(strType, wsContext);\n                try {\n                    x509 = Base64Utility.decode(token.getTextContent().trim());\n                    LOG.fine(\"Found X509Certificate UseKey type via reference\");\n                } catch (Exception e) {\n                    LOG.log(Level.WARNING, \"\", e);\n                    throw new STSException(e.getMessage(), e, STSException.INVALID_REQUEST);\n                }\n            }\n        } else if (useKey.getAny() instanceof Element) {\n            if (isTokenReferenced(useKey.getAny())) {\n                Element token = fetchTokenElementFromReference(useKey.getAny(), wsContext);\n                try {\n                    x509 = Base64Utility.decode(token.getTextContent().trim());\n                    LOG.fine(\"Found X509Certificate UseKey type via reference\");\n                } catch (Exception e) {\n                    LOG.log(Level.WARNING, \"\", e);\n                    throw new STSException(e.getMessage(), e, STSException.INVALID_REQUEST);\n                }\n            } else {\n                Element element = (Element)useKey.getAny();\n                if (\"KeyInfo\".equals(element.getLocalName())) {\n                    return parseKeyInfoElement((Element)useKey.getAny());\n                } else {\n                    NodeList x509CertData = \n                        element.getElementsByTagNameNS(\n                            Constants.SignatureSpecNS, Constants._TAG_X509CERTIFICATE   \n                        );\n                    if (x509CertData != null && x509CertData.getLength() > 0) {\n                        try {\n                            x509 = Base64Utility.decode(x509CertData.item(0).getTextContent().trim());\n                            LOG.fine(\"Found X509Certificate UseKey type\");\n                        } catch (Exception e) {\n                            LOG.log(Level.WARNING, \"\", e);\n                            throw new STSException(e.getMessage(), e, STSException.INVALID_REQUEST);\n                        }\n                    }\n                }\n            }\n        } else {\n            LOG.log(Level.WARNING, \"An unknown element was received\");\n            throw new STSException(\n                \"An unknown element was received\", STSException.BAD_REQUEST\n            );\n        }\n        \n        if (x509 != null) {\n            try {\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                X509Certificate cert =\n                    (X509Certificate)cf.generateCertificate(new ByteArrayInputStream(x509));\n                LOG.fine(\"Successfully parsed X509 Certificate from UseKey\");\n                ReceivedKey receivedKey = new ReceivedKey();\n                receivedKey.setX509Cert(cert);\n                return receivedKey;\n            } catch (CertificateException ex) {\n                LOG.log(Level.WARNING, \"\", ex);\n                throw new STSException(\"Error in parsing certificate: \", ex, STSException.INVALID_REQUEST);\n            }\n        }\n        return null;\n    }","commit_id":"39f29f9425296f2a67f6afbabed45ca593c4730b","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Parse the secondaryParameters element. Precedence goes to values that are specified as\n     * direct children of the RequestSecurityToken element. \n     * @param secondaryParameters the secondaryParameters element to parse\n     */\n    private void parseSecondaryParameters(Element secondaryParameters, List<ClaimsParser> claimsParsers) {\n        LOG.fine(\"Found SecondaryParameters element\");\n        Element child = DOMUtils.getFirstElement(secondaryParameters);\n        while (child != null) {\n            String localName = child.getLocalName();\n            String namespace = child.getNamespaceURI();\n            if (keyRequirements.getKeySize() == 0 && \"KeySize\".equals(localName) \n                && STSConstants.WST_NS_05_12.equals(namespace)) {\n                long keySize = Integer.parseInt(child.getTextContent());\n                keyRequirements.setKeySize(keySize);\n                LOG.fine(\"Found KeySize: \" + keySize);\n            } else if (tokenRequirements.getTokenType() == null \n                && \"TokenType\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                String tokenType = child.getTextContent();\n                tokenRequirements.setTokenType(tokenType);\n                LOG.fine(\"Found TokenType: \" + tokenType);\n            } else if (keyRequirements.getKeyType() == null \n                && \"KeyType\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                String keyType = child.getTextContent();\n                LOG.fine(\"Found KeyType: \" + keyType);\n                keyRequirements.setKeyType(keyType);\n            } else if (tokenRequirements.getClaims() == null \n                && \"Claims\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                LOG.fine(\"Found Claims element\");\n                RequestClaimCollection requestedClaims = parseClaims(child, claimsParsers);\n                tokenRequirements.setClaims(requestedClaims);\n            } else {\n                LOG.fine(\"Found unknown element: \" + localName + \" \" + namespace);\n            }\n            child = DOMUtils.getNextElement(child);\n        }\n    }","id":43269,"modified_method":"/**\n     * Parse the secondaryParameters element. Precedence goes to values that are specified as\n     * direct children of the RequestSecurityToken element. \n     * @param secondaryParameters the secondaryParameters element to parse\n     */\n    private void parseSecondaryParameters(Element secondaryParameters, List<ClaimsParser> claimsParsers) {\n        LOG.fine(\"Found SecondaryParameters element\");\n        Element child = DOMUtils.getFirstElement(secondaryParameters);\n        while (child != null) {\n            String localName = child.getLocalName();\n            String namespace = child.getNamespaceURI();\n            if (keyRequirements.getKeySize() == 0 && \"KeySize\".equals(localName) \n                && STSConstants.WST_NS_05_12.equals(namespace)) {\n                long keySize = Integer.parseInt(child.getTextContent().trim());\n                keyRequirements.setKeySize(keySize);\n                LOG.fine(\"Found KeySize: \" + keySize);\n            } else if (tokenRequirements.getTokenType() == null \n                && \"TokenType\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                String tokenType = child.getTextContent().trim();\n                tokenRequirements.setTokenType(tokenType);\n                LOG.fine(\"Found TokenType: \" + tokenType);\n            } else if (keyRequirements.getKeyType() == null \n                && \"KeyType\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                String keyType = child.getTextContent().trim();\n                LOG.fine(\"Found KeyType: \" + keyType);\n                keyRequirements.setKeyType(keyType);\n            } else if (tokenRequirements.getClaims() == null \n                && \"Claims\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                LOG.fine(\"Found Claims element\");\n                RequestClaimCollection requestedClaims = parseClaims(child, claimsParsers);\n                tokenRequirements.setClaims(requestedClaims);\n            } else {\n                LOG.fine(\"Found unknown element: \" + localName + \" \" + namespace);\n            }\n            child = DOMUtils.getNextElement(child);\n        }\n    }","commit_id":"39f29f9425296f2a67f6afbabed45ca593c4730b","url":"https://github.com/apache/cxf"},{"original_method":"private void parseParameterizedQuery(Element element, BeanDefinitionBuilder builder, ParserContext nestedCtx, Element sqlElem)\n    {\n        String sqlText;\n        boolean hasFileAttribute = sqlElem.hasAttribute(FILE_ATTRIBUTE);\n        boolean hasTextContent = !element.getTextContent().isEmpty();\n\n        if (hasFileAttribute && hasTextContent)\n        {\n            throw new IllegalArgumentException(String.format(\"Element %s cannot contain attribute file and text content simultaneously\", element.getTagName()));\n        }\n\n        if (hasFileAttribute)\n        {\n            String fileName = sqlElem.getAttribute(FILE_ATTRIBUTE);\n            try\n            {\n                sqlText = IOUtils.getResourceAsString(fileName, getClass());\n            }\n            catch (IOException e)\n            {\n                throw new IllegalStateException(\"Unable to read query from file: \" + fileName);\n            }\n        }\n        else\n        {\n            Node node = sqlElem.getFirstChild();\n\n            if (node.getNextSibling() != null && node.getNextSibling().getNodeType() == Node.CDATA_SECTION_NODE)\n            {\n                sqlText = node.getNextSibling().getNodeValue();\n            }\n            else\n            {\n                sqlText = node.getNodeValue();\n            }\n        }\n\n        SimpleQueryTemplateParser simpleQueryParser = new SimpleQueryTemplateParser();\n        QueryTemplate queryTemplate = simpleQueryParser.parse(sqlText);\n\n        if (queryTemplate.getParams().size() > 0 && !queryTemplate.usesNamedParameters())\n        {\n            throw new IllegalArgumentException(\"Templates do not support inline parameters\");\n        }\n        else\n        {\n            builder.addConstructorArgValue(queryTemplate.getSqlText());\n            builder.addConstructorArgValue(queryTemplate.getType());\n\n            element.removeChild(sqlElem);\n\n            List<Object> params = new ManagedList<Object>();\n            List<Element> childElementsByTagName = DomUtils.getChildElementsByTagName(element, IN_PARAM_ELEMENT);\n            if (queryTemplate.usesNamedParameters())\n            {\n                for (InputQueryParam inputSqlParam : queryTemplate.getInputParams())\n                {\n                    Element param = findOverriddenParamElement(inputSqlParam.getName(), childElementsByTagName);\n\n                    if (param == null)\n                    {\n                        params.add(inputSqlParam);\n                    }\n                    else\n                    {\n                        BeanDefinition paramBean = parseParameter(nestedCtx, param);\n\n                        params.add(paramBean);\n                    }\n                }\n            }\n            else\n            {\n                for (Element param : childElementsByTagName)\n                {\n                    BeanDefinition paramBean = parseParameter(nestedCtx, param);\n\n                    params.add(paramBean);\n                }\n            }\n\n            builder.addConstructorArgValue(params);\n        }\n    }","id":43270,"modified_method":"private void parseParameterizedQuery(Element element, BeanDefinitionBuilder builder, ParserContext nestedCtx, Element sqlElem)\n    {\n        String sqlText;\n        boolean hasFileAttribute = sqlElem.hasAttribute(FILE_ATTRIBUTE);\n        boolean hasTextContent = !element.getTextContent().trim().isEmpty();\n\n        if (hasFileAttribute && hasTextContent)\n        {\n            throw new IllegalArgumentException(String.format(\"Element %s cannot contain attribute file and text content simultaneously\", element.getTagName()));\n        }\n\n        if (hasFileAttribute)\n        {\n            String fileName = sqlElem.getAttribute(FILE_ATTRIBUTE);\n            try\n            {\n                sqlText = IOUtils.getResourceAsString(fileName, getClass());\n            }\n            catch (IOException e)\n            {\n                throw new IllegalStateException(\"Unable to read query from file: \" + fileName);\n            }\n        }\n        else\n        {\n            Node node = sqlElem.getFirstChild();\n\n            if (node.getNextSibling() != null && node.getNextSibling().getNodeType() == Node.CDATA_SECTION_NODE)\n            {\n                sqlText = node.getNextSibling().getNodeValue();\n            }\n            else\n            {\n                sqlText = node.getNodeValue();\n            }\n        }\n\n        SimpleQueryTemplateParser simpleQueryParser = new SimpleQueryTemplateParser();\n        QueryTemplate queryTemplate = simpleQueryParser.parse(sqlText);\n\n        if (queryTemplate.getParams().size() > 0 && !queryTemplate.usesNamedParameters())\n        {\n            throw new IllegalArgumentException(\"Templates do not support inline parameters\");\n        }\n        else\n        {\n            builder.addConstructorArgValue(queryTemplate.getSqlText());\n            builder.addConstructorArgValue(queryTemplate.getType());\n\n            element.removeChild(sqlElem);\n\n            List<Object> params = new ManagedList<Object>();\n            List<Element> childElementsByTagName = DomUtils.getChildElementsByTagName(element, IN_PARAM_ELEMENT);\n            if (queryTemplate.usesNamedParameters())\n            {\n                for (InputQueryParam inputSqlParam : queryTemplate.getInputParams())\n                {\n                    Element param = findOverriddenParamElement(inputSqlParam.getName(), childElementsByTagName);\n\n                    if (param == null)\n                    {\n                        params.add(inputSqlParam);\n                    }\n                    else\n                    {\n                        BeanDefinition paramBean = parseParameter(nestedCtx, param);\n\n                        params.add(paramBean);\n                    }\n                }\n            }\n            else\n            {\n                for (Element param : childElementsByTagName)\n                {\n                    BeanDefinition paramBean = parseParameter(nestedCtx, param);\n\n                    params.add(paramBean);\n                }\n            }\n\n            builder.addConstructorArgValue(params);\n        }\n    }","commit_id":"b1a3ca9bed22702353324080b4911fadbafd78a2","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void readQueryFromFile() throws Exception\n    {\n        Object queryTemplateBean = muleContext.getRegistry().get(\"testFileQuery\");\n        assertTrue(queryTemplateBean instanceof QueryTemplate);\n        QueryTemplate queryTemplate = (QueryTemplate) queryTemplateBean;\n        assertEquals(QueryType.SELECT, queryTemplate.getType());\n        assertEquals(\"SELECT * FROM PLANET WHERE POSITION = ?\", queryTemplate.getSqlText());\n        assertEquals(1, queryTemplate.getInputParams().size());\n        InputQueryParam param1 = queryTemplate.getInputParams().get(0);\n        assertEquals(UnknownDbType.getInstance(), param1.getType());\n        assertEquals(\"position\", param1.getName());\n        assertEquals(\"1\", param1.getValue());\n    }","id":43271,"modified_method":"@Test\n    public void readQueryFromFile() throws Exception\n    {\n        doQueryFromFileTest(muleContext.getRegistry().get(\"testFileQuery\"));\n    }","commit_id":"b1a3ca9bed22702353324080b4911fadbafd78a2","url":"https://github.com/mulesoft/mule"},{"original_method":"private void percolatorRecovery(final boolean multiPercolate) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"gateway.type\", \"none\").build();\n        logger.info(\"--> starting 3 nodes\");\n        startNode(\"node1\", settings);\n        startNode(\"node2\", settings);\n        startNode(\"node3\", settings);\n\n        final Client client = client(\"node1\");\n        client.admin().indices().prepareDelete().execute().actionGet();\n        ensureGreen(client);\n\n        client.admin().indices().prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(\"index.number_of_shards\", 2)\n                        .put(\"index.number_of_replicas\", 2)\n                )\n                .execute().actionGet();\n        ensureGreen(client);\n\n        final int numQueries = randomIntBetween(50, 100);\n        logger.info(\"--> register a queries\");\n        for (int i = 0; i < numQueries; i++) {\n            client().prepareIndex(\"test\", \"_percolator\", Integer.toString(i))\n                    .setSource(jsonBuilder().startObject().field(\"query\", matchAllQuery()).endObject())\n                    .execute().actionGet();\n        }\n\n        client().prepareIndex(\"test\", \"type\", \"1\")\n                .setSource(jsonBuilder().startObject().field(\"field\", \"a\"))\n                .execute().actionGet();\n\n        final AtomicBoolean run = new AtomicBoolean(true);\n        final CountDownLatch done = new CountDownLatch(1);\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    XContentBuilder doc = null;\n                    try {\n                        doc = jsonBuilder().startObject().field(\"field\", \"a\").endObject();\n                    } catch (IOException e) {}\n\n                    while (run.get()) {\n                        NodesInfoResponse nodesInfoResponse = client().admin().cluster().prepareNodesInfo()\n                                .execute().actionGet();\n                        String node2Id = null;\n                        String node3Id = null;\n                        for (NodeInfo nodeInfo : nodesInfoResponse) {\n                            if (\"node2\".equals(nodeInfo.getNode().getName())) {\n                                node2Id = nodeInfo.getNode().id();\n                            } else if (\"node3\".equals(nodeInfo.getNode().getName())) {\n                                node3Id = nodeInfo.getNode().id();\n                            }\n                        }\n\n                        String preference = \"_prefer_node:\" + (randomBoolean() ? node2Id : node3Id);\n                        if (multiPercolate) {\n                            MultiPercolateRequestBuilder builder = client()\n                                    .prepareMultiPercolate();\n                            int numPercolateRequest = randomIntBetween(50, 100);\n\n                            for (int i = 0; i < numPercolateRequest / 2; i++) {\n                                builder.add(\n                                        client().preparePercolate()\n                                                .setPreference(preference)\n                                                .setIndices(\"test\").setDocumentType(\"type\")\n                                                .setPercolateDoc(docBuilder().setDoc(doc)));\n                            }\n\n                            for (int i = numPercolateRequest / 2; i < numPercolateRequest; i++) {\n                                builder.add(\n                                        client().preparePercolate()\n                                                .setPreference(preference)\n                                                .setGetRequest(Requests.getRequest(\"test\").type(\"type\").id(\"1\"))\n                                                .setIndices(\"test\").setDocumentType(\"type\")\n                                );\n                            }\n\n                            MultiPercolateResponse response = builder.execute().actionGet();\n                            assertThat(response.items().length, equalTo(numPercolateRequest));\n                            for (MultiPercolateResponse.Item item : response) {\n                                assertThat(item.isFailure(), equalTo(false));\n                                assertNoFailures(item.getResponse());\n                                assertThat(item.getResponse().getSuccessfulShards(), equalTo(2));\n                                assertThat(item.getResponse().getCount(), equalTo((long) numQueries));\n                                assertThat(item.getResponse().getMatches().length, equalTo(numQueries));\n                            }\n                        } else {\n                            PercolateResponse response;\n                            if (randomBoolean()) {\n                                response = client().preparePercolate()\n                                        .setIndices(\"test\").setDocumentType(\"type\")\n                                        .setPercolateDoc(docBuilder().setDoc(doc))\n                                        .setPreference(preference)\n                                        .execute().actionGet();\n                            } else {\n                                response = client().preparePercolate()\n                                        .setGetRequest(Requests.getRequest(\"test\").type(\"type\").id(\"1\"))\n                                        .setIndices(\"test\").setDocumentType(\"type\")\n                                        .setPreference(preference)\n                                        .execute().actionGet();\n                            }\n                            assertNoFailures(response);\n                            assertThat(response.getSuccessfulShards(), equalTo(2));\n                            assertThat(response.getCount(), equalTo((long) numQueries));\n                            assertThat(response.getMatches().length, equalTo(numQueries));\n                        }\n                    }\n                } catch (Throwable t) {\n                    logger.info(\"Error in percolate thread...\", t);\n                    run.set(false);\n                    error.set(t);\n                } finally {\n                    done.countDown();\n                }\n            }\n        };\n        new Thread(r).start();\n\n        try {\n            for (int i = 0; i < 4; i++) {\n                closeNode(\"node3\");\n                client().admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"2\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                closeNode(\"node2\");\n                client().admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"1\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                startNode(\"node3\");\n                client().admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"2\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                startNode(\"node2\");\n                client().admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"3\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n            }\n        } finally {\n            run.set(false);\n        }\n        done.await();\n        assertThat(error.get(), nullValue());\n    }","id":43272,"modified_method":"private void percolatorRecovery(final boolean multiPercolate) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"gateway.type\", \"none\").build();\n        logger.info(\"--> starting 3 nodes\");\n        startNode(\"node1\", settings);\n        startNode(\"node2\", settings);\n        startNode(\"node3\", settings);\n\n        final Client client = client(\"node1\");\n        client.admin().indices().prepareDelete().execute().actionGet();\n        ensureGreen(client);\n\n        client.admin().indices().prepareCreate(\"test\")\n                .setSettings(settingsBuilder()\n                        .put(\"index.number_of_shards\", 2)\n                        .put(\"index.number_of_replicas\", 2)\n                )\n                .execute().actionGet();\n        ensureGreen(client);\n\n        final int numQueries = randomIntBetween(50, 100);\n        logger.info(\"--> register a queries\");\n        for (int i = 0; i < numQueries; i++) {\n            client.prepareIndex(\"test\", \"_percolator\", Integer.toString(i))\n                    .setSource(jsonBuilder().startObject().field(\"query\", matchAllQuery()).endObject())\n                    .execute().actionGet();\n        }\n\n        client.prepareIndex(\"test\", \"type\", \"1\")\n                .setSource(jsonBuilder().startObject().field(\"field\", \"a\"))\n                .execute().actionGet();\n\n        final AtomicBoolean run = new AtomicBoolean(true);\n        final CountDownLatch done = new CountDownLatch(1);\n        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    XContentBuilder doc = null;\n                    try {\n                        doc = jsonBuilder().startObject().field(\"field\", \"a\").endObject();\n                    } catch (IOException e) {}\n\n                    while (run.get()) {\n                        NodesInfoResponse nodesInfoResponse = client.admin().cluster().prepareNodesInfo()\n                                .execute().actionGet();\n                        String node2Id = null;\n                        String node3Id = null;\n                        for (NodeInfo nodeInfo : nodesInfoResponse) {\n                            if (\"node2\".equals(nodeInfo.getNode().getName())) {\n                                node2Id = nodeInfo.getNode().id();\n                            } else if (\"node3\".equals(nodeInfo.getNode().getName())) {\n                                node3Id = nodeInfo.getNode().id();\n                            }\n                        }\n\n                        String preference = \"_prefer_node:\" + (randomBoolean() ? node2Id : node3Id);\n                        if (multiPercolate) {\n                            MultiPercolateRequestBuilder builder = client\n                                    .prepareMultiPercolate();\n                            int numPercolateRequest = randomIntBetween(50, 100);\n\n                            for (int i = 0; i < numPercolateRequest / 2; i++) {\n                                builder.add(\n                                        client.preparePercolate()\n                                                .setPreference(preference)\n                                                .setIndices(\"test\").setDocumentType(\"type\")\n                                                .setPercolateDoc(docBuilder().setDoc(doc)));\n                            }\n\n                            for (int i = numPercolateRequest / 2; i < numPercolateRequest; i++) {\n                                builder.add(\n                                        client.preparePercolate()\n                                                .setPreference(preference)\n                                                .setGetRequest(Requests.getRequest(\"test\").type(\"type\").id(\"1\"))\n                                                .setIndices(\"test\").setDocumentType(\"type\")\n                                );\n                            }\n\n                            MultiPercolateResponse response = builder.execute().actionGet();\n                            assertThat(response.items().length, equalTo(numPercolateRequest));\n                            for (MultiPercolateResponse.Item item : response) {\n                                assertThat(item.isFailure(), equalTo(false));\n                                assertNoFailures(item.getResponse());\n                                assertThat(item.getResponse().getSuccessfulShards(), equalTo(2));\n                                assertThat(item.getResponse().getCount(), equalTo((long) numQueries));\n                                assertThat(item.getResponse().getMatches().length, equalTo(numQueries));\n                            }\n                        } else {\n                            PercolateResponse response;\n                            if (randomBoolean()) {\n                                response = client.preparePercolate()\n                                        .setIndices(\"test\").setDocumentType(\"type\")\n                                        .setPercolateDoc(docBuilder().setDoc(doc))\n                                        .setPreference(preference)\n                                        .execute().actionGet();\n                            } else {\n                                response = client.preparePercolate()\n                                        .setGetRequest(Requests.getRequest(\"test\").type(\"type\").id(\"1\"))\n                                        .setIndices(\"test\").setDocumentType(\"type\")\n                                        .setPreference(preference)\n                                        .execute().actionGet();\n                            }\n                            assertNoFailures(response);\n                            assertThat(response.getSuccessfulShards(), equalTo(2));\n                            assertThat(response.getCount(), equalTo((long) numQueries));\n                            assertThat(response.getMatches().length, equalTo(numQueries));\n                        }\n                    }\n                } catch (Throwable t) {\n                    logger.info(\"Error in percolate thread...\", t);\n                    run.set(false);\n                    error.set(t);\n                } finally {\n                    done.countDown();\n                }\n            }\n        };\n        new Thread(r).start();\n\n        try {\n            for (int i = 0; i < 4; i++) {\n                closeNode(\"node3\");\n                client.admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"2\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                closeNode(\"node2\");\n                client.admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"1\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                startNode(\"node3\");\n                client.admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"2\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n                startNode(\"node2\");\n                client.admin().cluster().prepareHealth()\n                        .setWaitForEvents(Priority.LANGUID)\n                        .setWaitForYellowStatus()\n                        .setWaitForNodes(\"3\")\n                        .execute().actionGet();\n                assertThat(error.get(), nullValue());\n            }\n        } finally {\n            run.set(false);\n        }\n        done.await();\n        assertThat(error.get(), nullValue());\n    }","commit_id":"35dcdb0b5a9a37a4b7b2366312efd8eb7455ede1","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public BaseObject(BaseObject parent, XMLElement properties) {\n\t\t//super(GROUP);\n\t\t\n\t\tif (parent == null) {\n\t\t\t// set values to their defaults according to the SVG spec\n\t\t\tstroke = false;\n\t\t\tstrokeColor = 0xff000000;\n\t\t\tstrokeWeight = 1;\n\t\t\tstrokeCap = PConstants.SQUARE;  // equivalent to BUTT in svg spec\n\t\t\tstrokeJoin = PConstants.MITER;\n\t\t\tstrokeGradient = null;\n\t\t\tstrokeGradientPaint = null;\n\t\t\tstrokeName = null;\n\n\t\t\tfill = true;\n\t\t\tfillColor = 0xff000000;\n\t\t\tfillGradient = null;\n\t\t\tfillGradientPaint = null;\n\t\t\tfillName = null;\n\n\t\t\t//hasTransform = false;\n\t\t\t//transformation = null; //new float[] { 1, 0, 0, 1, 0, 0 };\n\n\t\t\topacity = 1;\n\n\t\t} else {\n\t\t\tstroke = parent.stroke;\n\t\t\tstrokeColor = parent.strokeColor;\n\t\t\tstrokeWeight = parent.strokeWeight;\n\t\t\tstrokeCap = parent.strokeCap;\n\t\t\tstrokeJoin = parent.strokeJoin;\n\t\t\tstrokeGradient = parent.strokeGradient;\n\t\t\tstrokeGradientPaint = parent.strokeGradientPaint;\n\t\t\tstrokeName = parent.strokeName;\n\n\t\t\tfill = parent.fill;\n\t\t\tfillColor = parent.fillColor;\n\t\t\tfillGradient = parent.fillGradient;\n\t\t\tfillGradientPaint = parent.fillGradientPaint;\n\t\t\tfillName = parent.fillName;\n\n\t\t\t//hasTransform = parent.hasTransform;\n\t\t\t//transformation = parent.transformation;\n\n\t\t\topacity = parent.opacity;\n\t\t}\n\n\t\telement = properties;\n\n\t\tname = properties.getStringAttribute(\"id\");\n//\t\tif (name != null) {\n//\t\t\ttable.put(name, this);\n//\t\t\t//System.out.println(\"now parsing \" + id);\n//\t\t}\n\n\t\tString displayStr = properties.getStringAttribute(\"display\", \"inline\");\n\t\tvisible = !displayStr.equals(\"none\");\n\n\t\tString transformStr = properties.getStringAttribute(\"transform\");\n\t\tif (transformStr != null) {\n\t\t\tfloat[] t = parseMatrix(transformStr);\n\t\t\t//matrix = new PMatrix2D(t[0], t[2], t[4], t[1], t[3], t[5]);\n\t\t\tmatrix = new PMatrix3D(t[0], t[2], 0, t[4], \n\t\t\t\t\t               t[1], t[3], 0, t[5],\n\t\t\t\t\t               0, 0, 1, 0,\n\t\t\t\t\t               0, 0, 0, 1);\n\t\t}\n\t\t\n\t\tparseColors(properties);\n\t\t\n\t\tparseChildren(properties);\n\t}","id":43273,"modified_method":"public BaseObject(BaseObject parent, XMLElement properties) {\n\t\t//super(GROUP);\n\t\t\n\t\tif (parent == null) {\n\t\t\t// set values to their defaults according to the SVG spec\n\t\t\tstroke = false;\n\t\t\tstrokeColor = 0xff000000;\n\t\t\tstrokeWeight = 1;\n\t\t\tstrokeCap = PConstants.SQUARE;  // equivalent to BUTT in svg spec\n\t\t\tstrokeJoin = PConstants.MITER;\n\t\t\tstrokeGradient = null;\n\t\t\tstrokeGradientPaint = null;\n\t\t\tstrokeName = null;\n\n\t\t\tfill = true;\n\t\t\tfillColor = 0xff000000;\n\t\t\tfillGradient = null;\n\t\t\tfillGradientPaint = null;\n\t\t\tfillName = null;\n\n\t\t\t//hasTransform = false;\n\t\t\t//transformation = null; //new float[] { 1, 0, 0, 1, 0, 0 };\n\n\t\t\topacity = 1;\n\n\t\t} else {\n\t\t\tstroke = parent.stroke;\n\t\t\tstrokeColor = parent.strokeColor;\n\t\t\tstrokeWeight = parent.strokeWeight;\n\t\t\tstrokeCap = parent.strokeCap;\n\t\t\tstrokeJoin = parent.strokeJoin;\n\t\t\tstrokeGradient = parent.strokeGradient;\n\t\t\tstrokeGradientPaint = parent.strokeGradientPaint;\n\t\t\tstrokeName = parent.strokeName;\n\n\t\t\tfill = parent.fill;\n\t\t\tfillColor = parent.fillColor;\n\t\t\tfillGradient = parent.fillGradient;\n\t\t\tfillGradientPaint = parent.fillGradientPaint;\n\t\t\tfillName = parent.fillName;\n\n\t\t\t//hasTransform = parent.hasTransform;\n\t\t\t//transformation = parent.transformation;\n\n\t\t\topacity = parent.opacity;\n\t\t}\n\n\t\telement = properties;\n\n\t\tname = properties.getStringAttribute(\"id\");\n//\t\tif (name != null) {\n//\t\t\ttable.put(name, this);\n//\t\t\t//System.out.println(\"now parsing \" + id);\n//\t\t}\n\n\t\tString displayStr = properties.getStringAttribute(\"display\", \"inline\");\n\t\tvisible = !displayStr.equals(\"none\");\n\n\t\tString transformStr = properties.getStringAttribute(\"transform\");\n\t\tif (transformStr != null) {\n\t\t\tmatrix = parseMatrix(transformStr);\n\t\t}\n\t\t\n\t\tparseColors(properties);\n\t\t\n\t\tparseChildren(properties);\n\t}","commit_id":"40550d1f829c28a1a157c7d70b469804999ab026","url":"https://github.com/processing/processing"},{"original_method":"static protected float[] parseMatrix(String matrixStr) {\n\t\t/*\n\t\tString prefix = \"matrix(\";\n\t\tint start = matrixStr.indexOf(prefix);\n\t\tif (start == -1) return null;\n\t\tint stop = matrixStr.indexOf(')');\n\t\tString content = matrixStr.substring(start + matrixStr.length(), stop);\n\t\treturn PApplet.parseFloat(PApplet.splitTokens(content.trim()));\n\t\t*/\n\t\tString[] pieces = PApplet.match(matrixStr, \"\\\\s*(\\\\w+)\\\\((.*)\\\\)\");\n\t\tif (pieces == null) {\n\t\t\tSystem.err.println(\"Could not parse transform \" + matrixStr);\n\t\t\treturn null;\n\t\t}\n\t\tfloat[] m = PApplet.parseFloat(PApplet.splitTokens(pieces[2]));\n\t\t\n\t\tif (pieces[1].equals(\"matrix\")) {\n\t\t\treturn m;\n\t\t\t\n\t\t} else if (pieces[1].equals(\"translate\")) {\n\t\t\tfloat tx = m[0];\n\t\t\tfloat ty = (m.length == 2) ? m[1] : m[0];\n\t\t\treturn new float[] { 1, 0, tx,  0, 1, ty };\n\t\t\t\n\t\t} else if (pieces[1].equals(\"scale\")) {\n\t\t\tfloat sx = m[0];\n\t\t\tfloat sy = (m.length == 2) ? m[1] : m[0];\n\t\t\treturn new float[] { sx, 0, 0, 0, sy, 0 };\n\n\t\t} else if (pieces[1].equals(\"rotate\")) {\n\t\t\tfloat angle = m[0];\n\t\t\t\n\t\t\tif (m.length == 1) {\n\t\t\t\tfloat c = PApplet.cos(angle);\n\t\t\t\tfloat s = PApplet.sin(angle);\n\t\t\t\treturn new float[] { c, -s, 0,  s, c, 0 };\n\n\t\t\t} else if (m.length == 3) {\n\t\t\t\tPMatrix2D mat = new PMatrix2D(0, 1, m[1],  1, 0, m[2]);\n\t\t\t\tmat.rotate(m[0]);\n\t\t\t\tmat.translate(-m[1], -m[2]);\n\t\t\t\treturn mat.get(null);\n\t\t\t}\n\t\t\t\n\t\t} else if (pieces[1].equals(\"skewX\")) {\n\t\t\treturn new float[] { 1, PApplet.tan(m[0]), 0,  0, 1, 0 };\n\t\t\t\n\t\t} else if (pieces[1].equals(\"skewY\")) {\n\t\t\treturn new float[] { 1, 0, 0,  PApplet.tan(m[0]), 1, 0 };\n\t\t}\n\t\treturn null;\n\t}","id":43274,"modified_method":"/** \n\t * Parse the specified SVG matrix into a PMatrix2D. Note that PMatrix2D \n\t * is rotated relative to the SVG definition, so parameters are rearranged \n\t * here. More about the transformation matrices in\n\t * <a href=\"http://www.w3.org/TR/SVG/coords.html#TransformAttribute\">this section<\/a>\n\t * of the SVG documentation.\n     * @param matrixStr text of the matrix param. \n\t * @return a good old-fashioned PMatrix2D\n\t */\n\tstatic protected PMatrix2D parseMatrix(String matrixStr) {\n\t\tString[] pieces = PApplet.match(matrixStr, \"\\\\s*(\\\\w+)\\\\((.*)\\\\)\");\n\t\tif (pieces == null) {\n\t\t\tSystem.err.println(\"Could not parse transform \" + matrixStr);\n\t\t\treturn null;\n\t\t}\n\t\tfloat[] m = PApplet.parseFloat(PApplet.splitTokens(pieces[2]));\n\t\t\n\t\tif (pieces[1].equals(\"matrix\")) {\n\t\t\treturn new PMatrix2D(m[0], m[2], m[4], m[1], m[3], m[5]);\n\t\t\t\n\t\t} else if (pieces[1].equals(\"translate\")) {\n\t\t\tfloat tx = m[0];\n\t\t\tfloat ty = (m.length == 2) ? m[1] : m[0];\n\t\t\t//return new float[] { 1, 0, tx,  0, 1, ty };\n\t\t\treturn new PMatrix2D(1, 0, tx, 0, 1, ty);\n\t\t\t\n\t\t} else if (pieces[1].equals(\"scale\")) {\n\t\t\tfloat sx = m[0];\n\t\t\tfloat sy = (m.length == 2) ? m[1] : m[0];\n\t\t\t//return new float[] { sx, 0, 0, 0, sy, 0 };\n\t\t\treturn new PMatrix2D(sx, 0, 0,  0, sy, 0);\n\n\t\t} else if (pieces[1].equals(\"rotate\")) {\n\t\t\tfloat angle = m[0];\n\t\t\t\n\t\t\tif (m.length == 1) {\n\t\t\t\tfloat c = PApplet.cos(angle);\n\t\t\t\tfloat s = PApplet.sin(angle);\n\t\t\t\t// SVG version is cos(a) sin(a) -sin(a) cos(a) 0 0\n\t\t\t\treturn new PMatrix2D(c, -s, 0, s, c, 0);\n\n\t\t\t} else if (m.length == 3) {\n\t\t\t\tPMatrix2D mat = new PMatrix2D(0, 1, m[1],  1, 0, m[2]);\n\t\t\t\tmat.rotate(m[0]);\n\t\t\t\tmat.translate(-m[1], -m[2]);\n\t\t\t\treturn mat; //.get(null);\n\t\t\t}\n\t\t\t\n\t\t} else if (pieces[1].equals(\"skewX\")) {\n\t\t\t//return new float[] { 1, PApplet.tan(m[0]), 0,  0, 1, 0 };\n\t\t    return new PMatrix2D(1, 0, 1,  PApplet.tan(m[0]), 0, 0);\n\t\t\t\n\t\t} else if (pieces[1].equals(\"skewY\")) {\n\t\t\t//return new float[] { 1, 0, 0,  PApplet.tan(m[0]), 1, 0 };\n\t\t    return new PMatrix2D(1, 0, 1,  0, PApplet.tan(m[0]), 0);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"40550d1f829c28a1a157c7d70b469804999ab026","url":"https://github.com/processing/processing"},{"original_method":"protected PShape parseChild(XMLElement elem) {\n\t\tString name = elem.getName();\n\n\t\tif (name.equals(\"g\")) {\n\t\t\treturn new BaseObject(this, elem);\n\n\t\t} else if (name.equals(\"defs\")) {\n\t\t\t// generally this will contain gradient info, so may\n\t\t\t// as well just throw it into a group element for parsing\n\t\t\treturn new BaseObject(this, elem);\n\n\t\t} else if (name.equals(\"line\")) {\n\t\t\treturn new Line(this, elem);\n\n\t\t} else if (name.equals(\"circle\")) {\n\t\t\treturn new Circle(this, elem);\n\n\t\t} else if (name.equals(\"ellipse\")) {\n\t\t\treturn new Ellipse(this, elem);\n\n\t\t} else if (name.equals(\"rect\")) {\n\t\t\treturn new Rect(this, elem);\n\n\t\t} else if (name.equals(\"polygon\")) {\n\t\t\treturn new Poly(this, elem, true);\n\n\t\t} else if (name.equals(\"polyline\")) {\n\t\t\treturn new Poly(this, elem, false);\n\n\t\t} else if (name.equals(\"path\")) {\n\t\t\treturn new Path(this, elem);\n\n\t\t} else if (name.equals(\"radialGradient\")) {\n\t\t\treturn new RadialGradient(this, elem);\n\n\t\t} else if (name.equals(\"linearGradient\")) {\n\t\t\treturn new LinearGradient(this, elem);\n\n\t\t} else if (name.equals(\"text\")) {\n\t\t\tPApplet.println(\"Text is not currently handled, \" +\n\t\t\t\"convert text to outlines instead.\");\n\n\t\t} else if (name.equals(\"filter\")) {\n\t\t\tPApplet.println(\"Filters are not supported.\");\n\n\t\t} else if (name.equals(\"mask\")) {\n\t\t\tPApplet.println(\"Masks are not supported.\");\n\n\t\t} else {\n\t\t\tSystem.err.println(\"Ignoring  <\" + name + \"> tag.\");\n\t\t}\n\t\treturn null; \n\t}","id":43275,"modified_method":"/**\n\t * Parse a child XML element. \n\t * Override this method to add parsing for more SVG elements. \n\t */\n\tprotected PShape parseChild(XMLElement elem) {\n\t\tString name = elem.getName();\n\n\t\tif (name.equals(\"g\")) {\n\t\t\treturn new BaseObject(this, elem);\n\n\t\t} else if (name.equals(\"defs\")) {\n\t\t\t// generally this will contain gradient info, so may\n\t\t\t// as well just throw it into a group element for parsing\n\t\t\treturn new BaseObject(this, elem);\n\n\t\t} else if (name.equals(\"line\")) {\n\t\t\treturn new Line(this, elem);\n\n\t\t} else if (name.equals(\"circle\")) {\n\t\t\treturn new Circle(this, elem);\n\n\t\t} else if (name.equals(\"ellipse\")) {\n\t\t\treturn new Ellipse(this, elem);\n\n\t\t} else if (name.equals(\"rect\")) {\n\t\t\treturn new Rect(this, elem);\n\n\t\t} else if (name.equals(\"polygon\")) {\n\t\t\treturn new Poly(this, elem, true);\n\n\t\t} else if (name.equals(\"polyline\")) {\n\t\t\treturn new Poly(this, elem, false);\n\n\t\t} else if (name.equals(\"path\")) {\n\t\t\treturn new Path(this, elem);\n\n\t\t} else if (name.equals(\"radialGradient\")) {\n\t\t\treturn new RadialGradient(this, elem);\n\n\t\t} else if (name.equals(\"linearGradient\")) {\n\t\t\treturn new LinearGradient(this, elem);\n\n\t\t} else if (name.equals(\"text\")) {\n\t\t\tPGraphics.showWarning(\"Text is not currently handled, \" +\n\t\t\t\"convert text to outlines instead.\");\n\n\t\t} else if (name.equals(\"filter\")) {\n\t\t\tPApplet.println(\"Filters are not supported.\");\n\n\t\t} else if (name.equals(\"mask\")) {\n\t\t\tPApplet.println(\"Masks are not supported.\");\n\n\t\t} else {\n\t\t\tSystem.err.println(\"Ignoring  <\" + name + \"> tag.\");\n\t\t}\n\t\treturn null; \n\t}","commit_id":"40550d1f829c28a1a157c7d70b469804999ab026","url":"https://github.com/processing/processing"},{"original_method":"public LinearGradient(BaseObject parent, XMLElement properties) {\n\t\tsuper(parent, properties);\n\n\t\tthis.x1 = properties.getFloatAttribute(\"x1\");\n\t\tthis.y1 = properties.getFloatAttribute(\"y1\");\n\t\tthis.x2 = properties.getFloatAttribute(\"x2\");\n\t\tthis.y2 = properties.getFloatAttribute(\"y2\");\n\n\t\tString transformStr =\n\t\t\tproperties.getStringAttribute(\"gradientTransform\");\n\t\t\n\t\tif (transformStr != null) {\n\t\t\tthis.transform = new AffineTransform(parseMatrix(transformStr));\n\n\t\t\tPoint2D t1 = transform.transform(new Point2D.Float(x1, y1), null);\n\t\t\tPoint2D t2 = transform.transform(new Point2D.Float(x2, y2), null);\n\t\t\t\n\t\t\tthis.x1 = (float) t1.getX();\n\t\t\tthis.y1 = (float) t1.getY();\n\t\t\tthis.x2 = (float) t2.getX();\n\t\t\tthis.y2 = (float) t2.getY();\n\n\t\t}\n\t}","id":43276,"modified_method":"public LinearGradient(BaseObject parent, XMLElement properties) {\n\t\tsuper(parent, properties);\n\n\t\tthis.x1 = properties.getFloatAttribute(\"x1\");\n\t\tthis.y1 = properties.getFloatAttribute(\"y1\");\n\t\tthis.x2 = properties.getFloatAttribute(\"x2\");\n\t\tthis.y2 = properties.getFloatAttribute(\"y2\");\n\n\t\tString transformStr =\n\t\t\tproperties.getStringAttribute(\"gradientTransform\");\n\t\t\n\t\tif (transformStr != null) {\n            float t[] = parseMatrix(transformStr).get(null);\n            this.transform = new AffineTransform(t[0], t[3], t[1], t[4], t[2], t[5]);\n\n\t\t\tPoint2D t1 = transform.transform(new Point2D.Float(x1, y1), null);\n\t\t\tPoint2D t2 = transform.transform(new Point2D.Float(x2, y2), null);\n\t\t\t\n\t\t\tthis.x1 = (float) t1.getX();\n\t\t\tthis.y1 = (float) t1.getY();\n\t\t\tthis.x2 = (float) t2.getX();\n\t\t\tthis.y2 = (float) t2.getY();\n\n\t\t}\n\t}","commit_id":"40550d1f829c28a1a157c7d70b469804999ab026","url":"https://github.com/processing/processing"},{"original_method":"public RadialGradient(BaseObject parent, XMLElement properties) {\n\t\tsuper(parent, properties);\n\n\t\tthis.cx = properties.getFloatAttribute(\"cx\");\n\t\tthis.cy = properties.getFloatAttribute(\"cy\");\n\t\tthis.r = properties.getFloatAttribute(\"r\");\n\n\t\tString transformStr =\n\t\t\tproperties.getStringAttribute(\"gradientTransform\");\n\t\t\n\t\tif (transformStr != null) {\n\t\t\tthis.transform = new AffineTransform(parseMatrix(transformStr));\n\n\t\t\tPoint2D t1 = transform.transform(new Point2D.Float(cx, cy), null);\n\t\t\tPoint2D t2 = transform.transform(new Point2D.Float(cx + r, cy), null);\n\t\t\t\n\t\t\tthis.cx = (float) t1.getX();\n\t\t\tthis.cy = (float) t1.getY();\n\t\t\tthis.r = (float) (t2.getX() - t1.getX());\n\t\t}\n\t}","id":43277,"modified_method":"public RadialGradient(BaseObject parent, XMLElement properties) {\n\t\tsuper(parent, properties);\n\n\t\tthis.cx = properties.getFloatAttribute(\"cx\");\n\t\tthis.cy = properties.getFloatAttribute(\"cy\");\n\t\tthis.r = properties.getFloatAttribute(\"r\");\n\n\t\tString transformStr =\n\t\t\tproperties.getStringAttribute(\"gradientTransform\");\n\t\t\n\t\tif (transformStr != null) {\n\t\t    float t[] = parseMatrix(transformStr).get(null);\n\t\t\tthis.transform = new AffineTransform(t[0], t[3], t[1], t[4], t[2], t[5]);\n\n\t\t\tPoint2D t1 = transform.transform(new Point2D.Float(cx, cy), null);\n\t\t\tPoint2D t2 = transform.transform(new Point2D.Float(cx + r, cy), null);\n\t\t\t\n\t\t\tthis.cx = (float) t1.getX();\n\t\t\tthis.cy = (float) t1.getY();\n\t\t\tthis.r = (float) (t2.getX() - t1.getX());\n\t\t}\n\t}","commit_id":"40550d1f829c28a1a157c7d70b469804999ab026","url":"https://github.com/processing/processing"},{"original_method":"/**\n     * Initializes a new SVG Object with the given filename.\n     */\n    public SVG(XMLElement svg) {\n    \tsuper(null, svg);\n        \n        if (!svg.getName().equals(\"svg\")) {\n            throw new RuntimeException(\"root is not <svg>, it's <\" + svg.getName() + \">\");\n        }\n\n        // not proper parsing of the viewBox, but will cover us for cases where\n        // the width and height of the object is not specified\n        String viewBoxStr = svg.getStringAttribute(\"viewBox\");\n        if (viewBoxStr != null) {\n            int[] viewBox = PApplet.parseInt(PApplet.splitTokens(viewBoxStr));\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n\n        // TODO if viewbox is not same as width/height, then use it to scale\n        // the original objects. for now, viewbox only used when width/height\n        // are empty values (which by the spec means w/h of \"100%\"\n        String unitWidth = svg.getStringAttribute(\"width\");\n        String unitHeight = svg.getStringAttribute(\"height\");\n        if (unitWidth != null) {\n            width = parseUnitSize(unitWidth);\n            height = parseUnitSize(unitHeight);\n        } else {\n            if ((width == 0) || (height == 0)) {\n                //throw new RuntimeException(\"width/height not specified\");\n            \tSystem.err.println(\"The width and/or height is not \" +\n            \t\t\t           \"readable in the <svg> tag of this file.\");\n            \t// For the spec, the default is 100% and 100%. For purposes \n            \t// here, insert a dummy value because this is prolly just a \n            \t// font or something for which the w/h doesn't matter.\n            \twidth = 1;\n            \theight = 1;\n            }\n        }\n\n        //root = new Group(null, svg);\n        parseChildren(svg);  // ?\n    }","id":43278,"modified_method":"/**\n     * Initializes a new SVG Object with the given filename.\n     */\n    public SVG(XMLElement svg) {\n    \tsuper(null, svg);\n        \n        if (!svg.getName().equals(\"svg\")) {\n            throw new RuntimeException(\"root is not <svg>, it's <\" + svg.getName() + \">\");\n        }\n\n        // not proper parsing of the viewBox, but will cover us for cases where\n        // the width and height of the object is not specified\n        String viewBoxStr = svg.getStringAttribute(\"viewBox\");\n        if (viewBoxStr != null) {\n            int[] viewBox = PApplet.parseInt(PApplet.splitTokens(viewBoxStr));\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n\n        // TODO if viewbox is not same as width/height, then use it to scale\n        // the original objects. for now, viewbox only used when width/height\n        // are empty values (which by the spec means w/h of \"100%\"\n        String unitWidth = svg.getStringAttribute(\"width\");\n        String unitHeight = svg.getStringAttribute(\"height\");\n        if (unitWidth != null) {\n            width = parseUnitSize(unitWidth);\n            height = parseUnitSize(unitHeight);\n        } else {\n            if ((width == 0) || (height == 0)) {\n                //throw new RuntimeException(\"width/height not specified\");\n            \tPGraphics.showWarning(\"The width and/or height is not \" +\n            \t\t\t              \"readable in the <svg> tag of this file.\");\n            \t// For the spec, the default is 100% and 100%. For purposes \n            \t// here, insert a dummy value because this is prolly just a \n            \t// font or something for which the w/h doesn't matter.\n            \twidth = 1;\n            \theight = 1;\n            }\n        }\n\n        //root = new Group(null, svg);\n        parseChildren(svg);  // ?\n    }","commit_id":"40550d1f829c28a1a157c7d70b469804999ab026","url":"https://github.com/processing/processing"},{"original_method":"/**\n     * Return a boolean with a boolean default\n     * @since 0.7.12\n     */\n    public boolean getProperty(String propName, boolean defaultVal) {\n        String val = getProperty(propName);\n        if (val == null)\n            return defaultVal;\n        return Boolean.valueOf(val).booleanValue();\n    }","id":43279,"modified_method":"/**\n     * Return a boolean with a boolean default\n     * @since 0.7.12\n     */\n    public boolean getProperty(String propName, boolean defaultVal) {\n        String val = getProperty(propName);\n        if (val == null)\n            return defaultVal;\n        return Boolean.parseBoolean(val);\n    }","commit_id":"489f43529c222fa56213c321a0b0854ce74043be","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Default false\n     * @since 0.7.12\n     */\n    public boolean getBooleanProperty(String propName) {\n        return Boolean.valueOf(getProperty(propName)).booleanValue();\n    }","id":43280,"modified_method":"/**\n     * Default false\n     * @since 0.7.12\n     */\n    public boolean getBooleanProperty(String propName) {\n        return Boolean.parseBoolean(getProperty(propName));\n    }","commit_id":"489f43529c222fa56213c321a0b0854ce74043be","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected boolean isMandatory(MessageInfo messageInfo) {\n        String mandatory = (String) messageInfo.getMap().get(MessageInfoImpl.IS_MANDATORY);\n        return Boolean.valueOf(mandatory).booleanValue();\n    }","id":43281,"modified_method":"protected boolean isMandatory(MessageInfo messageInfo) {\n        String mandatory = (String) messageInfo.getMap().get(MessageInfoImpl.IS_MANDATORY);\n        return Boolean.parseBoolean(mandatory);\n    }","commit_id":"5d4fd5a59192523dbe2718a59b09f17ecbc8401d","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Do not log here, deadlock of LogWriter via rereadConfig().\n     */\n    private void parseConfig(Properties config) {\n        String fmt = config.getProperty(PROP_FORMAT, DEFAULT_FORMAT);\n        _format = fmt.toCharArray();\n        \n        String df = config.getProperty(PROP_DATEFORMAT, DEFAULT_DATEFORMAT);\n        setDateFormat(df);\n\n        String disp = config.getProperty(PROP_DISPLAYONSCREEN);\n        if (disp == null)\n            _displayOnScreen = DEFAULT_DISPLAYONSCREEN;\n        else {\n            if (\"TRUE\".equals(disp.toUpperCase(Locale.US).trim()))\n                _displayOnScreen = true;\n            else if (\"YES\".equals(disp.toUpperCase(Locale.US).trim()))\n                _displayOnScreen = true;\n            else\n                _displayOnScreen = false;\n        }\n\n        String filenameOverride = _context.getProperty(FILENAME_OVERRIDE_PROP);\n        if (filenameOverride != null)\n            _baseLogfilename = filenameOverride;\n        else\n            _baseLogfilename = config.getProperty(PROP_FILENAME, DEFAULT_FILENAME);\n\n        _fileSize = getFileSize(config.getProperty(PROP_FILESIZE, DEFAULT_FILESIZE));\n        _rotationLimit = -1;\n        try {\n            _rotationLimit = Integer.parseInt(config.getProperty(PROP_ROTATIONLIMIT, DEFAULT_ROTATIONLIMIT));\n        } catch (NumberFormatException nfe) {\n            System.err.println(\"Invalid rotation limit\");\n            nfe.printStackTrace();\n        }\n        \n        _defaultLimit = Log.getLevel(config.getProperty(PROP_DEFAULTLEVEL, DEFAULT_DEFAULTLEVEL));\n\n        _onScreenLimit = Log.getLevel(config.getProperty(PROP_DISPLAYONSCREENLEVEL, DEFAULT_ONSCREENLEVEL));\n\n        try {\n            String str = config.getProperty(PROP_CONSOLEBUFFERSIZE);\n            if (str != null)\n                _consoleBufferSize = Integer.parseInt(str);\n        } catch (NumberFormatException nfe) {}\n\n        try {\n            String str = config.getProperty(PROP_LOG_BUFFER_SIZE);\n            if (str != null)\n                _logBufferSize = Integer.parseInt(str);\n        } catch (NumberFormatException nfe) {}\n\n        _dropOnOverflow = Boolean.valueOf(config.getProperty(PROP_DROP)).booleanValue();\n\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Log set to use the base log file as \" + _baseLogfilename);\n        \n        parseLimits(config);\n    }","id":43282,"modified_method":"/**\n     * Do not log here, deadlock of LogWriter via rereadConfig().\n     */\n    private void parseConfig(Properties config) {\n        String fmt = config.getProperty(PROP_FORMAT, DEFAULT_FORMAT);\n        _format = fmt.toCharArray();\n        \n        String df = config.getProperty(PROP_DATEFORMAT, DEFAULT_DATEFORMAT);\n        setDateFormat(df);\n\n        String disp = config.getProperty(PROP_DISPLAYONSCREEN);\n        if (disp == null)\n            _displayOnScreen = DEFAULT_DISPLAYONSCREEN;\n        else {\n            if (\"TRUE\".equals(disp.toUpperCase(Locale.US).trim()))\n                _displayOnScreen = true;\n            else if (\"YES\".equals(disp.toUpperCase(Locale.US).trim()))\n                _displayOnScreen = true;\n            else\n                _displayOnScreen = false;\n        }\n\n        String filenameOverride = _context.getProperty(FILENAME_OVERRIDE_PROP);\n        if (filenameOverride != null)\n            _baseLogfilename = filenameOverride;\n        else\n            _baseLogfilename = config.getProperty(PROP_FILENAME, DEFAULT_FILENAME);\n\n        _fileSize = getFileSize(config.getProperty(PROP_FILESIZE, DEFAULT_FILESIZE));\n        _rotationLimit = -1;\n        try {\n            _rotationLimit = Integer.parseInt(config.getProperty(PROP_ROTATIONLIMIT, DEFAULT_ROTATIONLIMIT));\n        } catch (NumberFormatException nfe) {\n            System.err.println(\"Invalid rotation limit\");\n            nfe.printStackTrace();\n        }\n        \n        _defaultLimit = Log.getLevel(config.getProperty(PROP_DEFAULTLEVEL, DEFAULT_DEFAULTLEVEL));\n\n        _onScreenLimit = Log.getLevel(config.getProperty(PROP_DISPLAYONSCREENLEVEL, DEFAULT_ONSCREENLEVEL));\n\n        try {\n            String str = config.getProperty(PROP_CONSOLEBUFFERSIZE);\n            if (str != null)\n                _consoleBufferSize = Integer.parseInt(str);\n        } catch (NumberFormatException nfe) {}\n\n        try {\n            String str = config.getProperty(PROP_LOG_BUFFER_SIZE);\n            if (str != null)\n                _logBufferSize = Integer.parseInt(str);\n        } catch (NumberFormatException nfe) {}\n\n        _dropOnOverflow = Boolean.parseBoolean(config.getProperty(PROP_DROP));\n        String str = config.getProperty(PROP_DUP);\n        _dropDuplicates = str == null || Boolean.parseBoolean(str);\n\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Log set to use the base log file as \" + _baseLogfilename);\n        \n        parseLimits(config);\n    }","commit_id":"50ec27991735aac3d191622816287c2a4f23f2ab","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Matches source class, message string, and throwable class only.\n     *  @since 0.9.3\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof LogRecord))\n            return false;\n        LogRecord r = (LogRecord) o;\n        return _source == r._source &&\n               DataHelper.eq(_message, r._message) &&\n               ((_throwable == null && r._throwable == null) ||\n                (_throwable != null && r._throwable != null && _throwable.getClass() == r._throwable.getClass()));\n    }","id":43283,"modified_method":"/**\n     *  Matches source class, first part of message string, and throwable class only.\n     *  Used only by LogWriter to eliminate dups.\n     *  @since 0.9.3\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof LogRecord))\n            return false;\n        LogRecord r = (LogRecord) o;\n        return _source == r._source &&\n               ((_message == null && r._message == null) ||\n                (_message != null && r._message != null &&\n                 ((_message.length() <= MATCH_LEN) ? _message.equals(r._message)\n                                                   : _message.regionMatches(0, r._message, 0, MATCH_LEN)))) &&\n               ((_throwable == null && r._throwable == null) ||\n                (_throwable != null && r._throwable != null && _throwable.getClass() == r._throwable.getClass()));\n    }","commit_id":"50ec27991735aac3d191622816287c2a4f23f2ab","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void flushRecords(boolean shouldWait) {\n        try {\n            // zero copy, drain the manager queue directly\n            Queue<LogRecord> records = _manager.getQueue();\n            if (records == null) return;\n            if (!records.isEmpty()) {\n                LogRecord last = null;\n                LogRecord rec;\n                int dupCount = 0;\n                while ((rec = records.poll()) != null) {\n                    if (rec.equals(last)) {\n                        dupCount++;\n                    } else {\n                        if (dupCount > 0) {\n                            if (dupCount == 1)\n                                writeRecord(\"*** 1 similar message omitted\\n\");\n                            else\n                                writeRecord(\"*** \" + dupCount + \" similar messages omitted\\n\");\n                            dupCount = 0;\n                        }\n                        last = rec;\n                        writeRecord(rec);\n                    }\n                }\n                if (dupCount == 1)\n                    writeRecord(\"*** 1 similar message omitted\\n\");\n                else if (dupCount > 0)\n                    writeRecord(\"*** \" + dupCount + \" similar messages omitted\\n\");\n                try {\n                    if (_currentOut != null)\n                        _currentOut.flush();\n                } catch (IOException ioe) {\n                    if (_write && ++_diskFullMessageCount < MAX_DISKFULL_MESSAGES)\n                        System.err.println(\"Error writing the router log - disk full? \" + ioe);\n                }\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            if (shouldWait) {\n                try { \n                    synchronized (this) {\n                        this.wait(FLUSH_INTERVAL); \n                    }\n                } catch (InterruptedException ie) { // nop\n                }\n            }\n        }\n    }","id":43284,"modified_method":"public void flushRecords(boolean shouldWait) {\n        try {\n            // zero copy, drain the manager queue directly\n            Queue<LogRecord> records = _manager.getQueue();\n            if (records == null) return;\n            if (!records.isEmpty()) {\n                LogRecord last = null;\n                LogRecord rec;\n                int dupCount = 0;\n                while ((rec = records.poll()) != null) {\n                    if (_manager.shouldDropDuplicates() && rec.equals(last)) {\n                        dupCount++;\n                    } else {\n                        if (dupCount > 0) {\n                            if (dupCount == 1)\n                                writeRecord(\"*** 1 similar message omitted\\n\");\n                            else\n                                writeRecord(\"*** \" + dupCount + \" similar messages omitted\\n\");\n                            dupCount = 0;\n                        }\n                        last = rec;\n                        writeRecord(rec);\n                    }\n                }\n                if (dupCount == 1)\n                    writeRecord(\"*** 1 similar message omitted\\n\");\n                else if (dupCount > 0)\n                    writeRecord(\"*** \" + dupCount + \" similar messages omitted\\n\");\n                try {\n                    if (_currentOut != null)\n                        _currentOut.flush();\n                } catch (IOException ioe) {\n                    if (_write && ++_diskFullMessageCount < MAX_DISKFULL_MESSAGES)\n                        System.err.println(\"Error writing the router log - disk full? \" + ioe);\n                }\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            if (shouldWait) {\n                try { \n                    synchronized (this) {\n                        this.wait(FLUSH_INTERVAL); \n                    }\n                } catch (InterruptedException ie) { // nop\n                }\n            }\n        }\n    }","commit_id":"50ec27991735aac3d191622816287c2a4f23f2ab","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void loadClasses(@NotNull ComponentConfig config) {\n      ClassLoader loader = config.getClassLoader();\n\n      try {\n        final Class<?> interfaceClass = Class.forName(config.getInterfaceClass(), true, loader);\n        final Class<?> implementationClass = Comparing.equal(config.getInterfaceClass(), config.getImplementationClass()) ?\n                                             interfaceClass : StringUtil.isEmpty(config.getImplementationClass()) ? null : Class.forName(config.getImplementationClass(), true, loader);\n        boolean overrides = Boolean.parseBoolean(config.options.get(\"overrides\"));\n        MutablePicoContainer picoContainer = getPicoContainer();\n        if (overrides) {\n          ComponentAdapter oldAdapter = picoContainer.getComponentAdapterOfType(interfaceClass);\n          if (oldAdapter == null) {\n            throw new RuntimeException(config + \" does not override anything\");\n          }\n          picoContainer.unregisterComponent(oldAdapter.getComponentKey());\n          myInterfaceToClassMap.remove(interfaceClass);\n          myComponentClassToConfig.remove(oldAdapter.getComponentImplementation());\n          myComponentInterfaces.remove(interfaceClass);\n        }\n        // implementationClass == null means we want to unregister this component\n        if (implementationClass != null) {\n          if (myInterfaceToClassMap.get(interfaceClass) != null) {\n            throw new RuntimeException(\"Component already registered: \" + interfaceClass.getName());\n          }\n\n          picoContainer.registerComponent(new ComponentConfigComponentAdapter(config, implementationClass));\n          myInterfaceToClassMap.put(interfaceClass, implementationClass);\n          myComponentClassToConfig.put(implementationClass, config);\n          myComponentInterfaces.add(interfaceClass);\n        }\n      }\n      catch (Throwable t) {\n        handleInitComponentError(t, null, config);\n      }\n    }","id":43285,"modified_method":"private void loadClasses(@NotNull ComponentConfig config) {\n      ClassLoader loader = config.getClassLoader();\n\n      try {\n        final Class<?> interfaceClass = Class.forName(config.getInterfaceClass(), true, loader);\n        final Class<?> implementationClass = Comparing.equal(config.getInterfaceClass(), config.getImplementationClass()) ?\n                                             interfaceClass : StringUtil.isEmpty(config.getImplementationClass()) ? null : Class.forName(config.getImplementationClass(), true, loader);\n        boolean overrides = config.options != null && Boolean.parseBoolean(config.options.get(\"overrides\"));\n        MutablePicoContainer picoContainer = getPicoContainer();\n        if (overrides) {\n          ComponentAdapter oldAdapter = picoContainer.getComponentAdapterOfType(interfaceClass);\n          if (oldAdapter == null) {\n            throw new RuntimeException(config + \" does not override anything\");\n          }\n          picoContainer.unregisterComponent(oldAdapter.getComponentKey());\n          myInterfaceToClassMap.remove(interfaceClass);\n          myComponentClassToConfig.remove(oldAdapter.getComponentImplementation());\n          myComponentInterfaces.remove(interfaceClass);\n        }\n        // implementationClass == null means we want to unregister this component\n        if (implementationClass != null) {\n          if (myInterfaceToClassMap.get(interfaceClass) != null) {\n            throw new RuntimeException(\"Component already registered: \" + interfaceClass.getName());\n          }\n\n          picoContainer.registerComponent(new ComponentConfigComponentAdapter(config, implementationClass));\n          myInterfaceToClassMap.put(interfaceClass, implementationClass);\n          myComponentClassToConfig.put(implementationClass, config);\n          myComponentInterfaces.add(interfaceClass);\n        }\n      }\n      catch (Throwable t) {\n        handleInitComponentError(t, null, config);\n      }\n    }","commit_id":"b0970bc57cc06d42fb07c4d7008009bdada595c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isTrue(Map<String, String> options, @NonNls @NotNull String option) {\n    return options != null && options.containsKey(option) && Boolean.valueOf(options.get(option)).booleanValue();\n  }","id":43286,"modified_method":"private static boolean isTrue(@Nullable Map<String, String> options, @NonNls @NotNull String option) {\n    return options != null && Boolean.parseBoolean(options.get(option));\n  }","commit_id":"b0970bc57cc06d42fb07c4d7008009bdada595c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Map deserialize(Object context, List<Element> childNodes) {\n    Map map = (Map)context;\n    map.clear();\n\n    for (Element childNode : childNodes) {\n      if (!childNode.getName().equals(getEntryAttributeName())) {\n        LOG.warn(\"unexpected entry for serialized Map will be skipped: \" + childNode);\n        continue;\n      }\n\n      //noinspection unchecked\n      map.put(deserializeKeyOrValue(childNode, getKeyAttributeName(), context, keyBinding, keyClass),\n              deserializeKeyOrValue(childNode, getValueAttributeName(), context, valueBinding, valueClass));\n    }\n    return map;\n  }","id":43287,"modified_method":"@Nullable\n  private Map deserialize(@Nullable Object context, @NotNull List<Element> childNodes) {\n    Map map = (Map)context;\n    if (map != null) {\n      map.clear();\n    }\n\n    for (Element childNode : childNodes) {\n      if (!childNode.getName().equals(getEntryAttributeName())) {\n        LOG.warn(\"unexpected entry for serialized Map will be skipped: \" + childNode);\n        continue;\n      }\n\n      if (map == null) {\n        map = new THashMap();\n      }\n\n      //noinspection unchecked\n      map.put(deserializeKeyOrValue(childNode, getKeyAttributeName(), context, keyBinding, keyClass),\n              deserializeKeyOrValue(childNode, getValueAttributeName(), context, valueBinding, valueClass));\n    }\n    return map;\n  }","commit_id":"b0970bc57cc06d42fb07c4d7008009bdada595c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isWorkspace(final Map options) {\n    return options != null && Boolean.parseBoolean((String)options.get(ProjectStoreImpl.OPTION_WORKSPACE));\n  }","id":43288,"modified_method":"private static boolean isWorkspace(@Nullable Map<String, String> options) {\n    return options != null && Boolean.parseBoolean(options.get(ProjectStoreImpl.OPTION_WORKSPACE));\n  }","commit_id":"b0970bc57cc06d42fb07c4d7008009bdada595c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n     * @see org.opencms.widgets.I_CmsWidget#getDialogWidget(org.opencms.file.CmsObject, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\r\n     */\r\n    @Override\r\n    public String getDialogWidget(CmsObject cms, I_CmsWidgetDialog widgetDialog, I_CmsWidgetParameter param) {\r\n\r\n        return CmsMultiSelectWidget.getMultiSelectDialogWidget(\r\n            cms,\r\n            widgetDialog,\r\n            param,\r\n            this,\r\n            m_asCheckBoxes,\r\n            getHeight());\r\n    }","id":43289,"modified_method":"/**\r\n     * @see org.opencms.widgets.I_CmsWidget#getDialogWidget(org.opencms.file.CmsObject, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\r\n     */\r\n    @Override\r\n    public String getDialogWidget(CmsObject cms, I_CmsWidgetDialog widgetDialog, I_CmsWidgetParameter param) {\r\n\r\n        String id = param.getId();\r\n        StringBuffer result = new StringBuffer(16);\r\n        String height = getHeight();\r\n        List<CmsSelectWidgetOption> options = parseSelectOptions(cms, widgetDialog, param);\r\n        result.append(\"<td class=\\\"xmlTd\\\">\");\r\n        // the configured select widget height start element\r\n        if (m_asCheckBoxes && CmsStringUtil.isNotEmptyOrWhitespaceOnly(height)) {\r\n            result.append(\"<div style=\\\"height: \" + height + \"; overflow: auto;\\\">\");\r\n        }\r\n        if (!m_asCheckBoxes) {\r\n            if (m_requiresActivation) {\r\n                result.append(\"<input style=\\\"vertical-align:middle;\\\" type=\\\"checkbox\\\" id=\\\"check\"\r\n                    + id\r\n                    + \"\\\" name=\\\"check\"\r\n                    + id\r\n                    + \"\\\"\"\r\n                    + \"onclick=toggleMultiSelectWidget(this);\"\r\n                    + \" />\");\r\n                result.append(\"&nbsp;<label style=\\\"vertical-align:middle;\\\" for=\\\"check\" + id + \"\\\">\");\r\n                result.append(widgetDialog.getMessages().key(Messages.GUI_MULTISELECT_ACTIVATE_0));\r\n                result.append(\"<\/label>&nbsp;\");\r\n            }\r\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(height)) {\r\n                result.append(\"<select style=\\\"height: \" + height + \";\\\" multiple size='\");\r\n            } else {\r\n                result.append(\"<select multiple size='\");\r\n            }\r\n            result.append(options.size());\r\n            result.append(\"' style=\\\"vertical-align:middle;\\\" class=\\\"xmlInput\");\r\n            if (param.hasError()) {\r\n                result.append(\" xmlInputError\");\r\n            }\r\n            result.append(\"\\\" \");\r\n            if (m_requiresActivation) {\r\n                result.append(\"disabled=\\\"true\\\" \");\r\n            }\r\n            result.append(\"name=\\\"\");\r\n            result.append(id);\r\n            result.append(\"\\\" id=\\\"\");\r\n            result.append(id);\r\n            result.append(\"\\\">\");\r\n        }\r\n\r\n        // get select box options from default value String\r\n        List<String> selected = getSelectedValues(cms, param);\r\n        Iterator<CmsSelectWidgetOption> i = options.iterator();\r\n        while (i.hasNext()) {\r\n            CmsSelectWidgetOption option = i.next();\r\n            // create the option\r\n            if (!m_asCheckBoxes) {\r\n                result.append(\"<option value=\\\"\");\r\n                result.append(option.getValue());\r\n                result.append(\"\\\"\");\r\n                if (selected.contains(option.getValue())) {\r\n                    result.append(\" selected=\\\"selected\\\"\");\r\n                }\r\n                result.append(\">\");\r\n                result.append(option.getOption());\r\n                result.append(\"<\/option>\");\r\n            } else {\r\n                result.append(\"<input type='checkbox' name='\");\r\n                result.append(id);\r\n                result.append(\"' value='\");\r\n                result.append(option.getValue());\r\n                result.append(\"'\");\r\n                if (selected.contains(option.getValue())) {\r\n                    result.append(\" checked\");\r\n                }\r\n                result.append(\">\");\r\n                result.append(option.getOption());\r\n                result.append(\"<br>\");\r\n            }\r\n        }\r\n        if (!m_asCheckBoxes) {\r\n            result.append(\"<\/select>\");\r\n        }\r\n        // the configured select widget height end element\r\n        if (m_asCheckBoxes && CmsStringUtil.isNotEmptyOrWhitespaceOnly(height)) {\r\n            result.append(\"<\/div>\");\r\n        }\r\n        result.append(\"<\/td>\");\r\n\r\n        return result.toString();\r\n    }","commit_id":"1e739d203f04a4e1ff4738a7b30f99ce2731f987","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.opencms.widgets.I_CmsWidget#setEditorValue(org.opencms.file.CmsObject, java.util.Map, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\r\n     */\r\n    public void setEditorValue(\r\n        CmsObject cms,\r\n        Map formParameters,\r\n        I_CmsWidgetDialog widgetDialog,\r\n        I_CmsWidgetParameter param) {\r\n\r\n        CmsMultiSelectWidget.setMultiSelectEditorValue(cms, formParameters, widgetDialog, param);\r\n    }","id":43290,"modified_method":"/**\r\n     * @see org.opencms.widgets.A_CmsWidget#setEditorValue(org.opencms.file.CmsObject, java.util.Map, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\r\n     */\r\n    @Override\r\n    public void setEditorValue(\r\n        CmsObject cms,\r\n        Map<String, String[]> formParameters,\r\n        I_CmsWidgetDialog widgetDialog,\r\n        I_CmsWidgetParameter param) {\r\n\r\n        CmsMultiSelectWidget.setMultiSelectEditorValue(cms, formParameters, widgetDialog, param);\r\n    }","commit_id":"1e739d203f04a4e1ff4738a7b30f99ce2731f987","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Parses the widget configuration string.<p>\r\n     * \r\n     * @param cms the current users OpenCms context\r\n     * @param widgetDialog the dialog of this widget\r\n     */\r\n    private void parseConfiguration(CmsObject cms, I_CmsWidgetDialog widgetDialog) {\r\n\r\n        String configString = CmsMacroResolver.resolveMacros(getConfiguration(), cms, widgetDialog.getMessages());\r\n        Map<String, String> config = CmsStringUtil.splitAsMap(configString, \"|\", \"=\");\r\n        // get the list of group names to show\r\n        String groups = config.get(CONFIGURATION_GROUPS);\r\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(groups)) {\r\n            m_groupNames = CmsStringUtil.splitAsList(groups, ',', true);\r\n        }\r\n        // get the regular expression to filter the groups\r\n        String filter = config.get(CONFIGURATION_GROUPFILTER);\r\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(filter)) {\r\n            try {\r\n                m_groupFilter = Pattern.compile(filter);\r\n            } catch (PatternSyntaxException e) {\r\n                // log pattern syntax errors\r\n                LOG.error(Messages.get().getBundle().key(Messages.LOG_ERR_WIDGET_SELECTGROUP_PATTERN_1, filter));\r\n            }\r\n        }\r\n        // get the OU to read the groups from\r\n        m_ouFqn = config.get(CONFIGURATION_OUFQN);\r\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_ouFqn)) {\r\n            m_ouFqn = \"\";\r\n        } else if (!m_ouFqn.endsWith(CmsOrganizationalUnit.SEPARATOR)) {\r\n            m_ouFqn += CmsOrganizationalUnit.SEPARATOR;\r\n        }\r\n        // set the flag to include sub OUs\r\n        m_includeSubOus = Boolean.valueOf(config.get(CONFIGURATION_INCLUDESUBOUS)).booleanValue();\r\n    }","id":43291,"modified_method":"/**\r\n     * Parses the widget configuration string.<p>\r\n     * \r\n     * @param cms the current users OpenCms context\r\n     * @param widgetDialog the dialog of this widget\r\n     */\r\n    private void parseConfiguration(CmsObject cms, I_CmsWidgetDialog widgetDialog) {\r\n\r\n        String configString = CmsMacroResolver.resolveMacros(getConfiguration(), cms, widgetDialog.getMessages());\r\n        Map<String, String> config = CmsStringUtil.splitAsMap(configString, \"|\", \"=\");\r\n        // get the list of group names to show\r\n        String groups = config.get(CONFIGURATION_GROUPS);\r\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(groups)) {\r\n            m_groupNames = CmsStringUtil.splitAsList(groups, ',', true);\r\n        }\r\n        // get the regular expression to filter the groups\r\n        String filter = config.get(CONFIGURATION_GROUPFILTER);\r\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(filter)) {\r\n            try {\r\n                m_groupFilter = Pattern.compile(filter);\r\n            } catch (PatternSyntaxException e) {\r\n                // log pattern syntax errors\r\n                LOG.error(Messages.get().getBundle().key(Messages.LOG_ERR_WIDGET_SELECTGROUP_PATTERN_1, filter));\r\n            }\r\n        }\r\n        // get the OU to read the groups from\r\n        m_ouFqn = config.get(CONFIGURATION_OUFQN);\r\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_ouFqn)) {\r\n            m_ouFqn = \"\";\r\n        } else if (!m_ouFqn.endsWith(CmsOrganizationalUnit.SEPARATOR)) {\r\n            m_ouFqn += CmsOrganizationalUnit.SEPARATOR;\r\n        }\r\n        // set the flag to include sub OUs\r\n        m_includeSubOus = Boolean.parseBoolean(config.get(CONFIGURATION_INCLUDESUBOUS));\r\n        m_defaultAllAvailable = Boolean.parseBoolean(config.get(CONFIGURATION_DEFAULT_ALL));\r\n    }","commit_id":"1e739d203f04a4e1ff4738a7b30f99ce2731f987","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Returns the select options for the widget, generated from the configured input fields of the XML content.<p>\r\n     * \r\n     * @see org.opencms.widgets.A_CmsSelectWidget#parseSelectOptions(org.opencms.file.CmsObject, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\r\n     */\r\n    @Override\r\n    protected List<CmsSelectWidgetOption> parseSelectOptions(\r\n        CmsObject cms,\r\n        I_CmsWidgetDialog widgetDialog,\r\n        I_CmsWidgetParameter param) {\r\n\r\n        // only create options if not already done\r\n        if (getSelectOptions() == null) {\r\n            // parse widget configuration\r\n            parseConfiguration(cms, widgetDialog);\r\n            List<CmsSelectWidgetOption> result = new ArrayList<CmsSelectWidgetOption>();\r\n\r\n            if (isUseGroupNames()) {\r\n                // a list of group names is configured, show them\r\n                for (Iterator<String> i = getGroupNames().iterator(); i.hasNext();) {\r\n                    String groupName = i.next();\r\n                    try {\r\n                        // ensure that only existing groups are available in the select box\r\n                        CmsGroup group = cms.readGroup(getOuFqn() + groupName);\r\n                        result.add(new CmsSelectWidgetOption(group.getName(), false, group.getSimpleName()));\r\n                    } catch (CmsException e) {\r\n                        // error reading the group by name, simply skip it\r\n                    }\r\n                }\r\n            } else {\r\n                // read the groups from an optionally configured OU and filter them if configured \r\n                try {\r\n                    List<CmsGroup> groups = OpenCms.getOrgUnitManager().getGroups(cms, getOuFqn(), isIncludeSubOus());\r\n                    for (Iterator<CmsGroup> i = groups.iterator(); i.hasNext();) {\r\n                        CmsGroup group = i.next();\r\n                        if (isUseGroupFilter()) {\r\n                            // check if group name matches the given regular expression\r\n                            if (!getGroupFilter().matcher(group.getSimpleName()).matches()) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        result.add(new CmsSelectWidgetOption(group.getName(), false, group.getSimpleName()));\r\n                    }\r\n                } catch (CmsException e) {\r\n                    // error reading the groups\r\n                }\r\n\r\n            }\r\n            setSelectOptions(result);\r\n        }\r\n        return getSelectOptions();\r\n    }","id":43292,"modified_method":"/**\r\n     * Returns the select options for the widget, generated from the configured input fields of the XML content.<p>\r\n     * \r\n     * @see org.opencms.widgets.A_CmsSelectWidget#parseSelectOptions(org.opencms.file.CmsObject, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\r\n     */\r\n    @Override\r\n    protected List<CmsSelectWidgetOption> parseSelectOptions(\r\n        CmsObject cms,\r\n        I_CmsWidgetDialog widgetDialog,\r\n        I_CmsWidgetParameter param) {\r\n\r\n        // only create options if not already done\r\n        if (getSelectOptions() == null) {\r\n            // parse widget configuration\r\n            parseConfiguration(cms, widgetDialog);\r\n            List<CmsSelectWidgetOption> result = new ArrayList<CmsSelectWidgetOption>();\r\n\r\n            if (isUseGroupNames()) {\r\n                // a list of group names is configured, show them\r\n                for (Iterator<String> i = getGroupNames().iterator(); i.hasNext();) {\r\n                    String groupName = i.next();\r\n                    try {\r\n                        // ensure that only existing groups are available in the select box\r\n                        CmsGroup group = cms.readGroup(getOuFqn() + groupName);\r\n                        result.add(new CmsSelectWidgetOption(\r\n                            group.getName(),\r\n                            m_defaultAllAvailable,\r\n                            group.getSimpleName()));\r\n                    } catch (CmsException e) {\r\n                        // error reading the group by name, simply skip it\r\n                    }\r\n                }\r\n            } else {\r\n                // read the groups from an optionally configured OU and filter them if configured \r\n                try {\r\n                    List<CmsGroup> groups = OpenCms.getOrgUnitManager().getGroups(cms, getOuFqn(), isIncludeSubOus());\r\n                    for (Iterator<CmsGroup> i = groups.iterator(); i.hasNext();) {\r\n                        CmsGroup group = i.next();\r\n                        if (isUseGroupFilter()) {\r\n                            // check if group name matches the given regular expression\r\n                            if (!getGroupFilter().matcher(group.getSimpleName()).matches()) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        result.add(new CmsSelectWidgetOption(\r\n                            group.getName(),\r\n                            m_defaultAllAvailable,\r\n                            group.getSimpleName()));\r\n                    }\r\n                } catch (CmsException e) {\r\n                    // error reading the groups\r\n                }\r\n\r\n            }\r\n            setSelectOptions(result);\r\n        }\r\n        return getSelectOptions();\r\n    }","commit_id":"1e739d203f04a4e1ff4738a7b30f99ce2731f987","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.widgets.I_CmsWidget#setEditorValue(org.opencms.file.CmsObject, java.util.Map, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     */\n    public static void setMultiSelectEditorValue(\n        CmsObject cms,\n        Map formParameters,\n        I_CmsWidgetDialog widgetDialog,\n        I_CmsWidgetParameter param) {\n\n        String[] values = (String[])formParameters.get(param.getId());\n        if ((values != null) && (values.length > 0)) {\n            StringBuffer value = new StringBuffer(128);\n            for (int i = 0; i < values.length; i++) {\n                if (i > 0) {\n                    value.append(',');\n                }\n                value.append(values[i]);\n            }\n            // set the value\n            param.setStringValue(cms, value.toString());\n        } else {\n            // erase:\n            param.setStringValue(cms, \"\");\n        }\n    }","id":43293,"modified_method":"/**\n     * @param cms\n     * @param formParameters\n     * @param widgetDialog\n     * @param param\n     */\n    public static void setMultiSelectEditorValue(\n        CmsObject cms,\n        Map<String, String[]> formParameters,\n        I_CmsWidgetDialog widgetDialog,\n        I_CmsWidgetParameter param) {\n\n        String[] values = formParameters.get(param.getId());\n        if ((values != null) && (values.length > 0)) {\n            StringBuffer value = new StringBuffer(128);\n            for (int i = 0; i < values.length; i++) {\n                if (i > 0) {\n                    value.append(',');\n                }\n                value.append(values[i]);\n            }\n            // set the value\n            param.setStringValue(cms, value.toString());\n        } else {\n            // erase:\n            param.setStringValue(cms, \"\");\n        }\n    }","commit_id":"1e739d203f04a4e1ff4738a7b30f99ce2731f987","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.widgets.I_CmsWidget#getDialogWidget(org.opencms.file.CmsObject, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     */\n    public String getDialogWidget(CmsObject cms, I_CmsWidgetDialog widgetDialog, I_CmsWidgetParameter param) {\n\n        return getMultiSelectDialogWidget(cms, widgetDialog, param, this, m_asCheckBoxes, null);\n    }","id":43294,"modified_method":"/**\n     * @see org.opencms.widgets.I_CmsWidget#getDialogWidget(org.opencms.file.CmsObject, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     */\n    public String getDialogWidget(CmsObject cms, I_CmsWidgetDialog widgetDialog, I_CmsWidgetParameter param) {\n\n        String id = param.getId();\n        StringBuffer result = new StringBuffer(16);\n\n        List<CmsSelectWidgetOption> options = parseSelectOptions(cms, widgetDialog, param);\n        result.append(\"<td class=\\\"xmlTd\\\">\");\n        // the configured select widget height start element\n        if (!m_asCheckBoxes) {\n            if (m_requiresActivation) {\n                result.append(\"<input style=\\\"vertical-align:middle;\\\" type=\\\"checkbox\\\" id=\\\"check\"\n                    + id\n                    + \"\\\" name=\\\"check\"\n                    + id\n                    + \"\\\"\"\n                    + \"onclick=toggleMultiSelectWidget(this);\"\n                    + \" />\");\n                result.append(\"&nbsp;<label style=\\\"vertical-align:middle;\\\" for=\\\"check\" + id + \"\\\">\");\n                result.append(widgetDialog.getMessages().key(Messages.GUI_MULTISELECT_ACTIVATE_0));\n                result.append(\"<\/label>&nbsp;\");\n            }\n            result.append(\"<select multiple size='\");\n            result.append(options.size());\n            result.append(\"' style=\\\"vertical-align:middle;\\\" class=\\\"xmlInput\");\n            if (param.hasError()) {\n                result.append(\" xmlInputError\");\n            }\n            result.append(\"\\\" \");\n            if (m_requiresActivation) {\n                result.append(\"disabled=\\\"true\\\" \");\n            }\n            result.append(\"name=\\\"\");\n            result.append(id);\n            result.append(\"\\\" id=\\\"\");\n            result.append(id);\n            result.append(\"\\\">\");\n        }\n\n        // get select box options from default value String\n        List<String> selected = getSelectedValues(cms, param);\n        Iterator<CmsSelectWidgetOption> i = options.iterator();\n        while (i.hasNext()) {\n            CmsSelectWidgetOption option = i.next();\n            // create the option\n            if (!m_asCheckBoxes) {\n                result.append(\"<option value=\\\"\");\n                result.append(option.getValue());\n                result.append(\"\\\"\");\n                if (selected.contains(option.getValue())) {\n                    result.append(\" selected=\\\"selected\\\"\");\n                }\n                result.append(\">\");\n                result.append(option.getOption());\n                result.append(\"<\/option>\");\n            } else {\n                result.append(\"<input type='checkbox' name='\");\n                result.append(id);\n                result.append(\"' value='\");\n                result.append(option.getValue());\n                result.append(\"'\");\n                if (selected.contains(option.getValue())) {\n                    result.append(\" checked\");\n                }\n                result.append(\">\");\n                result.append(option.getOption());\n                result.append(\"<br>\");\n            }\n        }\n        if (!m_asCheckBoxes) {\n            result.append(\"<\/select>\");\n        }\n        result.append(\"<\/td>\");\n        return result.toString();\n    }","commit_id":"1e739d203f04a4e1ff4738a7b30f99ce2731f987","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public PluginDescriptor build( Reader reader, String source )\n        throws PlexusConfigurationException\n    {\n        PlexusConfiguration c = buildConfiguration( reader );\n\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setSource( source );\n        pluginDescriptor.setGroupId( c.getChild( \"groupId\" ).getValue() );\n        pluginDescriptor.setArtifactId( c.getChild( \"artifactId\" ).getValue() );\n        pluginDescriptor.setVersion( c.getChild( \"version\" ).getValue() );\n        pluginDescriptor.setGoalPrefix( c.getChild( \"goalPrefix\" ).getValue() );\n        \n        pluginDescriptor.setName( c.getChild( \"name\" ).getValue() );\n        pluginDescriptor.setDescription( c.getChild( \"description\" ).getValue() );\n\n        String isolatedRealm = c.getChild( \"isolatedRealm\" ).getValue();\n\n        if ( isolatedRealm != null )\n        {\n            pluginDescriptor.setIsolatedRealm( Boolean.valueOf( isolatedRealm ).booleanValue() );\n        }\n\n        String inheritedByDefault = c.getChild( \"inheritedByDefault\" ).getValue();\n\n        if ( inheritedByDefault != null )\n        {\n            pluginDescriptor.setInheritedByDefault( Boolean.valueOf( inheritedByDefault ).booleanValue() );\n        }\n\n        // ----------------------------------------------------------------------\n        // Components\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] mojoConfigurations = c.getChild( \"mojos\" ).getChildren( \"mojo\" );\n\n        for ( int i = 0; i < mojoConfigurations.length; i++ )\n        {\n            PlexusConfiguration component = mojoConfigurations[i];\n\n            MojoDescriptor mojoDescriptor = buildComponentDescriptor( component, pluginDescriptor );\n\n            pluginDescriptor.addMojo( mojoDescriptor );\n        }\n\n        // ----------------------------------------------------------------------\n        // Dependencies\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] dependencyConfigurations = c.getChild( \"dependencies\" ).getChildren( \"dependency\" );\n\n        List<ComponentDependency> dependencies = new ArrayList<ComponentDependency>();\n\n        for ( int i = 0; i < dependencyConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = dependencyConfigurations[i];\n\n            ComponentDependency cd = new ComponentDependency();\n\n            cd.setArtifactId( d.getChild( \"artifactId\" ).getValue() );\n\n            cd.setGroupId( d.getChild( \"groupId\" ).getValue() );\n\n            cd.setType( d.getChild( \"type\" ).getValue() );\n\n            cd.setVersion( d.getChild( \"version\" ).getValue() );\n\n            dependencies.add( cd );\n        }\n\n        pluginDescriptor.setDependencies( dependencies );\n\n        return pluginDescriptor;\n    }","id":43295,"modified_method":"public PluginDescriptor build( Reader reader, String source )\n        throws PlexusConfigurationException\n    {\n        PlexusConfiguration c = buildConfiguration( reader );\n\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setSource( source );\n        pluginDescriptor.setGroupId( c.getChild( \"groupId\" ).getValue() );\n        pluginDescriptor.setArtifactId( c.getChild( \"artifactId\" ).getValue() );\n        pluginDescriptor.setVersion( c.getChild( \"version\" ).getValue() );\n        pluginDescriptor.setGoalPrefix( c.getChild( \"goalPrefix\" ).getValue() );\n        \n        pluginDescriptor.setName( c.getChild( \"name\" ).getValue() );\n        pluginDescriptor.setDescription( c.getChild( \"description\" ).getValue() );\n\n        String isolatedRealm = c.getChild( \"isolatedRealm\" ).getValue();\n\n        if ( isolatedRealm != null )\n        {\n            pluginDescriptor.setIsolatedRealm( Boolean.parseBoolean( isolatedRealm ) );\n        }\n\n        String inheritedByDefault = c.getChild( \"inheritedByDefault\" ).getValue();\n\n        if ( inheritedByDefault != null )\n        {\n            pluginDescriptor.setInheritedByDefault( Boolean.parseBoolean( inheritedByDefault ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Components\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] mojoConfigurations = c.getChild( \"mojos\" ).getChildren( \"mojo\" );\n\n        for ( int i = 0; i < mojoConfigurations.length; i++ )\n        {\n            PlexusConfiguration component = mojoConfigurations[i];\n\n            MojoDescriptor mojoDescriptor = buildComponentDescriptor( component, pluginDescriptor );\n\n            pluginDescriptor.addMojo( mojoDescriptor );\n        }\n\n        // ----------------------------------------------------------------------\n        // Dependencies\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] dependencyConfigurations = c.getChild( \"dependencies\" ).getChildren( \"dependency\" );\n\n        List<ComponentDependency> dependencies = new ArrayList<ComponentDependency>();\n\n        for ( int i = 0; i < dependencyConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = dependencyConfigurations[i];\n\n            ComponentDependency cd = new ComponentDependency();\n\n            cd.setArtifactId( d.getChild( \"artifactId\" ).getValue() );\n\n            cd.setGroupId( d.getChild( \"groupId\" ).getValue() );\n\n            cd.setType( d.getChild( \"type\" ).getValue() );\n\n            cd.setVersion( d.getChild( \"version\" ).getValue() );\n\n            dependencies.add( cd );\n        }\n\n        pluginDescriptor.setDependencies( dependencies );\n\n        return pluginDescriptor;\n    }","commit_id":"dc09df4b99185a3bfdbeb70363171d469da81d4c","url":"https://github.com/apache/maven"},{"original_method":"public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojo = new MojoDescriptor();\n        mojo.setPluginDescriptor( pluginDescriptor );\n\n        mojo.setGoal( c.getChild( \"goal\" ).getValue() );\n        \n        mojo.setImplementation( c.getChild( \"implementation\" ).getValue() );\n\n        PlexusConfiguration langConfig = c.getChild( \"language\" );\n\n        if ( langConfig != null )\n        {\n            mojo.setLanguage( langConfig.getValue() );\n        }\n\n        PlexusConfiguration configuratorConfig = c.getChild( \"configurator\" );\n\n        if ( configuratorConfig != null )\n        {\n            mojo.setComponentConfigurator( configuratorConfig.getValue() );\n        }\n\n        PlexusConfiguration composerConfig = c.getChild( \"composer\" );\n\n        if ( composerConfig != null )\n        {\n            mojo.setComponentComposer( composerConfig.getValue() );\n        }\n\n        String since = c.getChild( \"since\" ).getValue();\n\n        if ( since != null )\n        {\n            mojo.setSince( since );\n        }\n\n        PlexusConfiguration deprecated = c.getChild( \"deprecated\", false );\n\n        if ( deprecated != null )\n        {\n            mojo.setDeprecated( deprecated.getValue() );\n        }\n\n        String phase = c.getChild( \"phase\" ).getValue();\n\n        if ( phase != null )\n        {\n            mojo.setPhase( phase );\n        }\n\n        String executePhase = c.getChild( \"executePhase\" ).getValue();\n\n        if ( executePhase != null )\n        {\n            mojo.setExecutePhase( executePhase );\n        }\n\n        String executeMojo = c.getChild( \"executeGoal\" ).getValue();\n\n        if ( executeMojo != null )\n        {\n            mojo.setExecuteGoal( executeMojo );\n        }\n\n        String executeLifecycle = c.getChild( \"executeLifecycle\" ).getValue();\n\n        if ( executeLifecycle != null )\n        {\n            mojo.setExecuteLifecycle( executeLifecycle );\n        }\n\n        mojo.setInstantiationStrategy( c.getChild( \"instantiationStrategy\" ).getValue() );\n\n        mojo.setDescription( c.getChild( \"description\" ).getValue() );\n\n        PlexusConfiguration dependencyResolution = c.getChild( \"requiresDependencyResolution\", false );\n\n        if ( dependencyResolution != null )\n        {\n            mojo.setDependencyResolutionRequired( dependencyResolution.getValue() );\n        }\n\n        PlexusConfiguration dependencyCollection = c.getChild( \"requiresDependencyCollection\", false );\n\n        if ( dependencyCollection != null )\n        {\n            mojo.setDependencyCollectionRequired( dependencyCollection.getValue() );\n        }\n\n        String directInvocationOnly = c.getChild( \"requiresDirectInvocation\" ).getValue();\n\n        if ( directInvocationOnly != null )\n        {\n            mojo.setDirectInvocationOnly( Boolean.valueOf( directInvocationOnly ).booleanValue() );\n        }\n\n        String requiresProject = c.getChild( \"requiresProject\" ).getValue();\n\n        if ( requiresProject != null )\n        {\n            mojo.setProjectRequired( Boolean.valueOf( requiresProject ).booleanValue() );\n        }\n\n        String requiresReports = c.getChild( \"requiresReports\" ).getValue();\n\n        if ( requiresReports != null )\n        {\n            mojo.setRequiresReports( Boolean.valueOf( requiresReports ).booleanValue() );\n        }\n\n        String aggregator = c.getChild( \"aggregator\" ).getValue();\n\n        if ( aggregator != null )\n        {\n            mojo.setAggregator( Boolean.valueOf( aggregator ).booleanValue() );\n        }\n\n        String requiresOnline = c.getChild( \"requiresOnline\" ).getValue();\n\n        if ( requiresOnline != null )\n        {\n            mojo.setOnlineRequired( Boolean.valueOf( requiresOnline ).booleanValue() );\n        }\n\n        String inheritedByDefault = c.getChild( \"inheritedByDefault\" ).getValue();\n\n        if ( inheritedByDefault != null )\n        {\n            mojo.setInheritedByDefault( Boolean.valueOf( inheritedByDefault ).booleanValue() );\n        }\n\n        String threadSafe = c.getChild( \"threadSafe\" ).getValue();\n\n        if ( threadSafe != null )\n        {\n            mojo.setThreadSafe( Boolean.valueOf( threadSafe ).booleanValue() );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List<Parameter> parameters = new ArrayList<Parameter>();\n\n        for ( int i = 0; i < parameterConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = parameterConfigurations[i];\n\n            Parameter parameter = new Parameter();\n\n            parameter.setName( d.getChild( \"name\" ).getValue() );\n\n            parameter.setAlias( d.getChild( \"alias\" ).getValue() );\n\n            parameter.setType( d.getChild( \"type\" ).getValue() );\n\n            String required = d.getChild( \"required\" ).getValue();\n\n            parameter.setRequired( Boolean.valueOf( required ).booleanValue() );\n\n            PlexusConfiguration editableConfig = d.getChild( \"editable\" );\n\n            // we need the null check for pre-build legacy plugins...\n            if ( editableConfig != null )\n            {\n                String editable = d.getChild( \"editable\" ).getValue();\n\n                parameter.setEditable( editable == null || Boolean.valueOf( editable ).booleanValue() );\n            }\n\n            parameter.setDescription( d.getChild( \"description\" ).getValue() );\n\n            parameter.setDeprecated( d.getChild( \"deprecated\" ).getValue() );\n\n            parameter.setImplementation( d.getChild( \"implementation\" ).getValue() );\n\n            parameters.add( parameter );\n        }\n\n        mojo.setParameters( parameters );\n\n        // TODO: this should not need to be handed off...\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        mojo.setMojoConfiguration( c.getChild( \"configuration\" ) );\n\n        // TODO: Go back to this when we get the container ready to configure mojos...\n        //        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] requirements = c.getChild( \"requirements\" ).getChildren( \"requirement\" );\n\n        for ( int i = 0; i < requirements.length; i++ )\n        {\n            PlexusConfiguration requirement = requirements[i];\n\n            ComponentRequirement cr = new ComponentRequirement();\n\n            cr.setRole( requirement.getChild( \"role\" ).getValue() );\n\n            cr.setRoleHint( requirement.getChild( \"role-hint\" ).getValue() );\n\n            cr.setFieldName( requirement.getChild( \"field-name\" ).getValue() );\n\n            mojo.addRequirement( cr );\n        }\n\n        return mojo;\n    }","id":43296,"modified_method":"public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojo = new MojoDescriptor();\n        mojo.setPluginDescriptor( pluginDescriptor );\n\n        mojo.setGoal( c.getChild( \"goal\" ).getValue() );\n        \n        mojo.setImplementation( c.getChild( \"implementation\" ).getValue() );\n\n        PlexusConfiguration langConfig = c.getChild( \"language\" );\n\n        if ( langConfig != null )\n        {\n            mojo.setLanguage( langConfig.getValue() );\n        }\n\n        PlexusConfiguration configuratorConfig = c.getChild( \"configurator\" );\n\n        if ( configuratorConfig != null )\n        {\n            mojo.setComponentConfigurator( configuratorConfig.getValue() );\n        }\n\n        PlexusConfiguration composerConfig = c.getChild( \"composer\" );\n\n        if ( composerConfig != null )\n        {\n            mojo.setComponentComposer( composerConfig.getValue() );\n        }\n\n        String since = c.getChild( \"since\" ).getValue();\n\n        if ( since != null )\n        {\n            mojo.setSince( since );\n        }\n\n        PlexusConfiguration deprecated = c.getChild( \"deprecated\", false );\n\n        if ( deprecated != null )\n        {\n            mojo.setDeprecated( deprecated.getValue() );\n        }\n\n        String phase = c.getChild( \"phase\" ).getValue();\n\n        if ( phase != null )\n        {\n            mojo.setPhase( phase );\n        }\n\n        String executePhase = c.getChild( \"executePhase\" ).getValue();\n\n        if ( executePhase != null )\n        {\n            mojo.setExecutePhase( executePhase );\n        }\n\n        String executeMojo = c.getChild( \"executeGoal\" ).getValue();\n\n        if ( executeMojo != null )\n        {\n            mojo.setExecuteGoal( executeMojo );\n        }\n\n        String executeLifecycle = c.getChild( \"executeLifecycle\" ).getValue();\n\n        if ( executeLifecycle != null )\n        {\n            mojo.setExecuteLifecycle( executeLifecycle );\n        }\n\n        mojo.setInstantiationStrategy( c.getChild( \"instantiationStrategy\" ).getValue() );\n\n        mojo.setDescription( c.getChild( \"description\" ).getValue() );\n\n        PlexusConfiguration dependencyResolution = c.getChild( \"requiresDependencyResolution\", false );\n\n        if ( dependencyResolution != null )\n        {\n            mojo.setDependencyResolutionRequired( dependencyResolution.getValue() );\n        }\n\n        PlexusConfiguration dependencyCollection = c.getChild( \"requiresDependencyCollection\", false );\n\n        if ( dependencyCollection != null )\n        {\n            mojo.setDependencyCollectionRequired( dependencyCollection.getValue() );\n        }\n\n        String directInvocationOnly = c.getChild( \"requiresDirectInvocation\" ).getValue();\n\n        if ( directInvocationOnly != null )\n        {\n            mojo.setDirectInvocationOnly( Boolean.parseBoolean( directInvocationOnly ) );\n        }\n\n        String requiresProject = c.getChild( \"requiresProject\" ).getValue();\n\n        if ( requiresProject != null )\n        {\n            mojo.setProjectRequired( Boolean.parseBoolean( requiresProject ) );\n        }\n\n        String requiresReports = c.getChild( \"requiresReports\" ).getValue();\n\n        if ( requiresReports != null )\n        {\n            mojo.setRequiresReports( Boolean.parseBoolean( requiresReports ) );\n        }\n\n        String aggregator = c.getChild( \"aggregator\" ).getValue();\n\n        if ( aggregator != null )\n        {\n            mojo.setAggregator( Boolean.parseBoolean( aggregator ) );\n        }\n\n        String requiresOnline = c.getChild( \"requiresOnline\" ).getValue();\n\n        if ( requiresOnline != null )\n        {\n            mojo.setOnlineRequired( Boolean.parseBoolean( requiresOnline ) );\n        }\n\n        String inheritedByDefault = c.getChild( \"inheritedByDefault\" ).getValue();\n\n        if ( inheritedByDefault != null )\n        {\n            mojo.setInheritedByDefault( Boolean.parseBoolean( inheritedByDefault ) );\n        }\n\n        String threadSafe = c.getChild( \"threadSafe\" ).getValue();\n\n        if ( threadSafe != null )\n        {\n            mojo.setThreadSafe( Boolean.parseBoolean( threadSafe ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List<Parameter> parameters = new ArrayList<Parameter>();\n\n        for ( int i = 0; i < parameterConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = parameterConfigurations[i];\n\n            Parameter parameter = new Parameter();\n\n            parameter.setName( d.getChild( \"name\" ).getValue() );\n\n            parameter.setAlias( d.getChild( \"alias\" ).getValue() );\n\n            parameter.setType( d.getChild( \"type\" ).getValue() );\n\n            String required = d.getChild( \"required\" ).getValue();\n\n            parameter.setRequired( Boolean.parseBoolean( required ) );\n\n            PlexusConfiguration editableConfig = d.getChild( \"editable\" );\n\n            // we need the null check for pre-build legacy plugins...\n            if ( editableConfig != null )\n            {\n                String editable = d.getChild( \"editable\" ).getValue();\n\n                parameter.setEditable( editable == null || Boolean.parseBoolean( editable ) );\n            }\n\n            parameter.setDescription( d.getChild( \"description\" ).getValue() );\n\n            parameter.setDeprecated( d.getChild( \"deprecated\" ).getValue() );\n\n            parameter.setImplementation( d.getChild( \"implementation\" ).getValue() );\n\n            parameters.add( parameter );\n        }\n\n        mojo.setParameters( parameters );\n\n        // TODO: this should not need to be handed off...\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        mojo.setMojoConfiguration( c.getChild( \"configuration\" ) );\n\n        // TODO: Go back to this when we get the container ready to configure mojos...\n        //        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] requirements = c.getChild( \"requirements\" ).getChildren( \"requirement\" );\n\n        for ( int i = 0; i < requirements.length; i++ )\n        {\n            PlexusConfiguration requirement = requirements[i];\n\n            ComponentRequirement cr = new ComponentRequirement();\n\n            cr.setRole( requirement.getChild( \"role\" ).getValue() );\n\n            cr.setRoleHint( requirement.getChild( \"role-hint\" ).getValue() );\n\n            cr.setFieldName( requirement.getChild( \"field-name\" ).getValue() );\n\n            mojo.addRequirement( cr );\n        }\n\n        return mojo;\n    }","commit_id":"dc09df4b99185a3bfdbeb70363171d469da81d4c","url":"https://github.com/apache/maven"},{"original_method":"public void readExternalUtil(final Element element, final OptionsAndConfirmations optionsAndConfirmations) throws InvalidDataException {\n    final Map<String, VcsShowOptionsSettingImpl> options = optionsAndConfirmations.getOptions();\n    List subElements = element.getChildren(OPTIONS_SETTING);\n    for (Object o : subElements) {\n      if (o instanceof Element) {\n        final Element subElement = ((Element)o);\n        final String id = subElement.getAttributeValue(ID_ATTRIBUTE);\n        final String value = subElement.getAttributeValue(VALUE_ATTTIBUTE);\n        if (id != null && value != null) {\n          try {\n            final boolean booleanValue = Boolean.valueOf(value).booleanValue();\n            getOrCreateOption(options, id).setValue(booleanValue);\n          }\n          catch (Exception e) {\n            //ignore\n          }\n        }\n      }\n    }\n    myReadValue.clear();\n    subElements = element.getChildren(CONFIRMATIONS_SETTING);\n    for (Object o : subElements) {\n      if (o instanceof Element) {\n        final Element subElement = ((Element)o);\n        final String id = subElement.getAttributeValue(ID_ATTRIBUTE);\n        final String value = subElement.getAttributeValue(VALUE_ATTTIBUTE);\n        if (id != null && value != null) {\n          try {\n            myReadValue.put(id, VcsShowConfirmationOption.Value.fromString(value));\n          }\n          catch (Exception e) {\n            //ignore\n          }\n        }\n      }\n    }\n  }","id":43297,"modified_method":"public void readExternalUtil(final Element element, final OptionsAndConfirmations optionsAndConfirmations) throws InvalidDataException {\n    final Map<String, VcsShowOptionsSettingImpl> options = optionsAndConfirmations.getOptions();\n    for (Element subElement : element.getChildren(OPTIONS_SETTING)) {\n      final String id = subElement.getAttributeValue(ID_ATTRIBUTE);\n      final String value = subElement.getAttributeValue(VALUE_ATTTIBUTE);\n      if (id != null && value != null) {\n        try {\n          getOrCreateOption(options, id).setValue(Boolean.parseBoolean(value));\n        }\n        catch (Exception ignored) {\n        }\n      }\n    }\n    myReadValue.clear();\n    for (Element subElement : element.getChildren(CONFIRMATIONS_SETTING)) {\n      final String id = subElement.getAttributeValue(ID_ATTRIBUTE);\n      final String value = subElement.getAttributeValue(VALUE_ATTTIBUTE);\n      if (id != null && value != null) {\n        try {\n          myReadValue.put(id, VcsShowConfirmationOption.Value.fromString(value));\n        }\n        catch (Exception ignored) {\n        }\n      }\n    }\n  }","commit_id":"5a6b03b9828ffa4c260a162b8173d14f03ea86bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setVisible(boolean b) {\n    if (myChooserActivated != b) {\n      if (b) {\n        myEditorComponent.pushKeyboardHandler(this);\n        if (!(MPSCore.getInstance().isTestMode())) {\n          getPatternEditor().activate(getEditorWindow(), myPatternEditorLocation, myPatternEditorSize);\n          myNodeSubstituteInfo.invalidateActions();\n          rebuildMenuEntries();\n          getPopupWindow().setVisible(true);\n          getPopupWindow().relayout();\n          getPopupWindow().setSelectionIndex(0);\n        } else {\n          getPatternEditor().activate(null, myPatternEditorLocation, myPatternEditorSize);\n          myNodeSubstituteInfo.invalidateActions();\n          rebuildMenuEntries();\n          getPopupWindow().initListModel();\n          getPopupWindow().setSelectionIndex(0);\n        }\n        myPopupActivated = true;\n      } else {\n        if (!(MPSCore.getInstance().isTestMode())) {\n          getPopupWindow().setVisible(false);\n          getPatternEditor().done();\n          getPopupWindow().setRelativeCell(null);\n        }\n        myNodeSubstituteInfo.invalidateActions();\n        myPopupActivated = false;\n        myEditorComponent.popKeyboardHandler();\n        myContextCell = null;\n      }\n    }\n    myChooserActivated = b;\n  }","id":43298,"modified_method":"public void setVisible(boolean b) {\n    if (myChooserActivated != b) {\n      if (b) {\n        myEditorComponent.pushKeyboardHandler(this);\n        if (!(MPSCore.getInstance().isTestMode())) {\n          getPatternEditor().activate(getEditorWindow(), myPatternEditorLocation, myPatternEditorSize);\n          myNodeSubstituteInfo.invalidateActions();\n          rebuildMenuEntries();\n          getPopupWindow().setVisible(true);\n          getPopupWindow().relayout();\n          getPopupWindow().setSelectionIndex(0);\n          getPopupWindow().scrollToSelection();\n        } else {\n          getPatternEditor().activate(null, myPatternEditorLocation, myPatternEditorSize);\n          myNodeSubstituteInfo.invalidateActions();\n          rebuildMenuEntries();\n          getPopupWindow().initListModel();\n          getPopupWindow().setSelectionIndex(0);\n        }\n        myPopupActivated = true;\n      } else {\n        if (!(MPSCore.getInstance().isTestMode())) {\n          getPopupWindow().setVisible(false);\n          getPatternEditor().done();\n          getPopupWindow().setRelativeCell(null);\n        }\n        myNodeSubstituteInfo.invalidateActions();\n        myPopupActivated = false;\n        myEditorComponent.popKeyboardHandler();\n        myContextCell = null;\n      }\n    }\n    myChooserActivated = b;\n  }","commit_id":"e3efafd3defdcacefe5b7cbfb49bcd898e6af5fe","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void relayout() {\n      Component component = myEditorComponent;\n      Point anchor = component.getLocationOnScreen();\n      Point location =\n        new Point(anchor.x + myRelativeCell.getX() + myRelativeCell.getLeftInset(), anchor.y + myRelativeCell.getY() + myRelativeCell.getHeight());\n\n      Rectangle deviceBounds = WindowsUtil.findDeviceBoundsAt(location);\n\n      if (location.getY() + PREFERRED_HEIGHT > deviceBounds.height + deviceBounds.y - 150) {\n        getPopupWindow().setPosition(PopupWindowPosition.TOP);\n      } else {\n        getPopupWindow().setPosition(PopupWindowPosition.BOTTOM);\n      }\n\n      Point newLocation = location;\n\n      int oldIndex = getSelectionIndex();\n\n      initListModel();\n\n      setSelectionIndex(oldIndex);\n      scrollToSelection();\n      pack();\n\n      if (getPosition() == PopupWindowPosition.TOP) {\n        newLocation = new Point(newLocation.x, newLocation.y - getHeight() - myRelativeCell.getHeight());\n      }\n\n      if (getWidth() >= deviceBounds.width) {\n        setSize(deviceBounds.width, getSize().height + myList.getFontMetrics(myList.getFont()).getHeight());\n      }\n\n      if (newLocation.x < deviceBounds.x) {\n        newLocation.x = deviceBounds.x;\n      }\n\n      if (getWidth() + newLocation.x > deviceBounds.width + deviceBounds.x) {\n        newLocation = new Point(deviceBounds.width + deviceBounds.x - getWidth(), newLocation.y);\n      }\n\n      setLocation(newLocation);\n\n      validateTree();\n      repaint();\n    }","id":43299,"modified_method":"public void relayout() {\n      Component component = myEditorComponent;\n      Point anchor = component.getLocationOnScreen();\n      Point location =\n        new Point(anchor.x + myRelativeCell.getX() + myRelativeCell.getLeftInset(), anchor.y + myRelativeCell.getY() + myRelativeCell.getHeight());\n\n      Rectangle deviceBounds = WindowsUtil.findDeviceBoundsAt(location);\n\n      if (location.getY() + PREFERRED_HEIGHT > deviceBounds.height + deviceBounds.y - 150) {\n        getPopupWindow().setPosition(PopupWindowPosition.TOP);\n      } else {\n        getPopupWindow().setPosition(PopupWindowPosition.BOTTOM);\n      }\n\n      Point newLocation = location;\n\n      int oldIndex = getSelectionIndex();\n\n      initListModel();\n\n      if (oldIndex != -1) {\n        setSelectionIndex(oldIndex);\n        scrollToSelection();\n      }\n      pack();\n\n      if (getPosition() == PopupWindowPosition.TOP) {\n        newLocation = new Point(newLocation.x, newLocation.y - getHeight() - myRelativeCell.getHeight());\n      }\n\n      if (getWidth() >= deviceBounds.width) {\n        setSize(deviceBounds.width, getSize().height + myList.getFontMetrics(myList.getFont()).getHeight());\n      }\n\n      if (newLocation.x < deviceBounds.x) {\n        newLocation.x = deviceBounds.x;\n      }\n\n      if (getWidth() + newLocation.x > deviceBounds.width + deviceBounds.x) {\n        newLocation = new Point(deviceBounds.width + deviceBounds.x - getWidth(), newLocation.y);\n      }\n\n      setLocation(newLocation);\n\n      validateTree();\n      repaint();\n    }","commit_id":"e3efafd3defdcacefe5b7cbfb49bcd898e6af5fe","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void relayout() {\n      Component component = myEditorComponent;\n      Point anchor = component.getLocationOnScreen();\n      Point location =\n        new Point(anchor.x + myRelativeCell.getX() + myRelativeCell.getLeftInset(), anchor.y + myRelativeCell.getY() + myRelativeCell.getHeight());\n\n      Rectangle deviceBounds = WindowsUtil.findDeviceBoundsAt(location);\n\n      if (location.getY() + PREFERRED_HEIGHT > deviceBounds.height + deviceBounds.y - 150) {\n        getPopupWindow().setPosition(PopupWindowPosition.TOP);\n      } else {\n        getPopupWindow().setPosition(PopupWindowPosition.BOTTOM);\n      }\n\n      Point newLocation = location;\n\n      int oldIndex = getSelectionIndex();\n\n      initListModel();\n\n      setSelectionIndex(oldIndex);\n      scrollToSelection();\n      pack();\n\n      if (getPosition() == PopupWindowPosition.TOP) {\n        newLocation = new Point(newLocation.x, newLocation.y - getHeight() - myRelativeCell.getHeight());\n      }\n\n      if (getWidth() >= deviceBounds.width) {\n        setSize(deviceBounds.width, getSize().height + myList.getFontMetrics(myList.getFont()).getHeight());\n      }\n\n      if (newLocation.x < deviceBounds.x) {\n        newLocation.x = deviceBounds.x;\n      }\n\n      if (getWidth() + newLocation.x > deviceBounds.width + deviceBounds.x) {\n        newLocation = new Point(deviceBounds.width + deviceBounds.x - getWidth(), newLocation.y);\n      }\n\n      setLocation(newLocation);\n\n      validateTree();\n      repaint();\n    }","id":43300,"modified_method":"public void relayout() {\n      Component component = myEditorComponent;\n      Point anchor = component.getLocationOnScreen();\n      Point location =\n        new Point(anchor.x + myRelativeCell.getX() + myRelativeCell.getLeftInset(), anchor.y + myRelativeCell.getY() + myRelativeCell.getHeight());\n\n      Rectangle deviceBounds = WindowsUtil.findDeviceBoundsAt(location);\n\n      if (location.getY() + PREFERRED_HEIGHT > deviceBounds.height + deviceBounds.y - 150) {\n        getPopupWindow().setPosition(PopupWindowPosition.TOP);\n      } else {\n        getPopupWindow().setPosition(PopupWindowPosition.BOTTOM);\n      }\n\n      Point newLocation = location;\n\n      int oldIndex = getSelectionIndex();\n\n      initListModel();\n\n      if (oldIndex != -1) {\n        setSelectionIndex(oldIndex);\n        scrollToSelection();\n      }\n      pack();\n\n      if (getPosition() == PopupWindowPosition.TOP) {\n        newLocation = new Point(newLocation.x, newLocation.y - getHeight() - myRelativeCell.getHeight());\n      }\n\n      if (getWidth() >= deviceBounds.width) {\n        setSize(deviceBounds.width, getSize().height + myList.getFontMetrics(myList.getFont()).getHeight());\n      }\n\n      if (newLocation.x < deviceBounds.x) {\n        newLocation.x = deviceBounds.x;\n      }\n\n      if (getWidth() + newLocation.x > deviceBounds.width + deviceBounds.x) {\n        newLocation = new Point(deviceBounds.width + deviceBounds.x - getWidth(), newLocation.y);\n      }\n\n      setLocation(newLocation);\n\n      validateTree();\n      repaint();\n    }","commit_id":"6f47a45b443e6e277d0f9473051bba0f4a3e66d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setVisible(boolean b) {\n    if (myChooserActivated != b) {\n      if (b) {\n        myEditorComponent.pushKeyboardHandler(this);\n        if (!(MPSCore.getInstance().isTestMode())) {\n          getPatternEditor().activate(getEditorWindow(), myPatternEditorLocation, myPatternEditorSize);\n          myNodeSubstituteInfo.invalidateActions();\n          rebuildMenuEntries();\n          getPopupWindow().setVisible(true);\n          getPopupWindow().relayout();\n          getPopupWindow().setSelectionIndex(0);\n        } else {\n          getPatternEditor().activate(null, myPatternEditorLocation, myPatternEditorSize);\n          myNodeSubstituteInfo.invalidateActions();\n          rebuildMenuEntries();\n          getPopupWindow().initListModel();\n          getPopupWindow().setSelectionIndex(0);\n        }\n        myPopupActivated = true;\n      } else {\n        if (!(MPSCore.getInstance().isTestMode())) {\n          getPopupWindow().setVisible(false);\n          getPatternEditor().done();\n          getPopupWindow().setRelativeCell(null);\n        }\n        myNodeSubstituteInfo.invalidateActions();\n        myPopupActivated = false;\n        myEditorComponent.popKeyboardHandler();\n        myContextCell = null;\n      }\n    }\n    myChooserActivated = b;\n  }","id":43301,"modified_method":"public void setVisible(boolean b) {\n    if (myChooserActivated != b) {\n      if (b) {\n        myEditorComponent.pushKeyboardHandler(this);\n        if (!(MPSCore.getInstance().isTestMode())) {\n          getPatternEditor().activate(getEditorWindow(), myPatternEditorLocation, myPatternEditorSize);\n          myNodeSubstituteInfo.invalidateActions();\n          rebuildMenuEntries();\n          getPopupWindow().setVisible(true);\n          getPopupWindow().relayout();\n          getPopupWindow().setSelectionIndex(0);\n          getPopupWindow().scrollToSelection();\n        } else {\n          getPatternEditor().activate(null, myPatternEditorLocation, myPatternEditorSize);\n          myNodeSubstituteInfo.invalidateActions();\n          rebuildMenuEntries();\n          getPopupWindow().initListModel();\n          getPopupWindow().setSelectionIndex(0);\n        }\n        myPopupActivated = true;\n      } else {\n        if (!(MPSCore.getInstance().isTestMode())) {\n          getPopupWindow().setVisible(false);\n          getPatternEditor().done();\n          getPopupWindow().setRelativeCell(null);\n        }\n        myNodeSubstituteInfo.invalidateActions();\n        myPopupActivated = false;\n        myEditorComponent.popKeyboardHandler();\n        myContextCell = null;\n      }\n    }\n    myChooserActivated = b;\n  }","commit_id":"6f47a45b443e6e277d0f9473051bba0f4a3e66d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void doRebuildMenuEntries() {\n    myMenuEmpty = false;\n    final String pattern = getPatternEditor().getPattern();\n\n    List<SubstituteAction> matchingActions = getMatchingActions(pattern, false);\n    boolean needToTrim;\n    String trimPattern = IntelligentInputUtil.trimLeft(pattern);\n    if (pattern.equals(trimPattern)) {\n      needToTrim = false;\n    } else {\n      needToTrim = true;\n      if (!matchingActions.isEmpty()) {\n        for (SubstituteAction action : matchingActions) {\n          if (action.canSubstitute(pattern)) {\n            needToTrim = false;\n            break;\n          }\n        }\n      }\n    }\n    if (needToTrim) {\n      matchingActions = getMatchingActions(trimPattern, false);\n    }\n    try {\n      if (myIsSmart) {\n        sortSmartActions(matchingActions);\n      } else {\n        Collections.sort(matchingActions, SubstituteActionUtil.createComparator(needToTrim ? trimPattern : pattern));\n      }\n    } catch (Exception e) {\n      LOG.error(e, e);\n    }\n\n    mySubstituteActions = matchingActions;\n    if (mySubstituteActions.size() == 0) {\n      myMenuEmpty = true;\n      mySubstituteActions.add(new AbstractNodeSubstituteAction() {\n        @Override\n        public String getMatchingText(String pattern) {\n          return \"No suggestions for \\\"\" + getPatternEditor().getPattern() + \"\\\"\";\n        }\n\n        @Override\n        public String getVisibleMatchingText(String pattern) {\n          return getMatchingText(pattern);\n        }\n\n        @Override\n        public SNode doSubstitute(@Nullable final jetbrains.mps.openapi.editor.EditorContext editorContext, String pattern) {\n          return null;\n        }\n      });\n    }\n\n    myPopupWindow.resetMaxSize();\n    for (SubstituteAction item : mySubstituteActions) {\n      Dimension dimension = getCellRenderer().getMaxDimension(item);\n      myPopupWindow.updateMaxHeight(dimension.height);\n      myPopupWindow.updateMaxWidth(dimension.width);\n    }\n  }","id":43302,"modified_method":"private void doRebuildMenuEntries() {\n    myMenuEmpty = false;\n    final String pattern = getPatternEditor().getPattern();\n\n    List<SubstituteAction> matchingActions = getMatchingActions(pattern, false);\n    boolean needToTrim;\n    String trimPattern = IntelligentInputUtil.trimLeft(pattern);\n    if (pattern.equals(trimPattern)) {\n      needToTrim = false;\n    } else {\n      needToTrim = true;\n      if (!matchingActions.isEmpty()) {\n        for (SubstituteAction action : matchingActions) {\n          if (action.canSubstitute(pattern)) {\n            needToTrim = false;\n            break;\n          }\n        }\n      }\n    }\n    if (needToTrim) {\n      matchingActions = getMatchingActions(trimPattern, false);\n    }\n    try {\n      if (myIsSmart) {\n        sortSmartActions(matchingActions);\n      } else {\n        Collections.sort(matchingActions, SubstituteActionUtil.createComparator(needToTrim ? trimPattern : pattern));\n      }\n    } catch (Exception e) {\n      LOG.error(e, e);\n    }\n\n    getPopupWindow().setOldSelectedSubstituteAction(getPopupWindow().getCurrentSelectedSubstituteAction());\n\n    mySubstituteActions = matchingActions;\n    if (mySubstituteActions.size() == 0) {\n      myMenuEmpty = true;\n      mySubstituteActions.add(new AbstractNodeSubstituteAction() {\n        @Override\n        public String getMatchingText(String pattern) {\n          return \"No suggestions for \\\"\" + getPatternEditor().getPattern() + \"\\\"\";\n        }\n\n        @Override\n        public String getVisibleMatchingText(String pattern) {\n          return getMatchingText(pattern);\n        }\n\n        @Override\n        public SNode doSubstitute(@Nullable final jetbrains.mps.openapi.editor.EditorContext editorContext, String pattern) {\n          return null;\n        }\n      });\n    }\n\n    getPopupWindow().resetMaxSize();\n    for (SubstituteAction item : mySubstituteActions) {\n      Dimension dimension = getCellRenderer().getMaxDimension(item);\n      getPopupWindow().updateMaxHeight(dimension.height);\n      getPopupWindow().updateMaxWidth(dimension.width);\n    }\n\n    getPopupWindow().updateListDimension();\n    getPopupWindow().initListModel();\n  }","commit_id":"d15ed78a6c5eed3a7339aab5df387332857c4afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void relayout() {\n      Point location = myPatternEditor.getLeftBottomPosition();\n\n      Rectangle deviceBounds = WindowsUtil.findDeviceBoundsAt(location);\n\n      if (location.getY() + PREFERRED_HEIGHT > deviceBounds.height + deviceBounds.y - 150) {\n        getPopupWindow().setPosition(PopupWindowPosition.TOP);\n      } else {\n        getPopupWindow().setPosition(PopupWindowPosition.BOTTOM);\n      }\n\n      Point newLocation = location;\n\n      int oldIndex = getSelectionIndex();\n\n      initListModel();\n\n      myList.setFixedCellHeight(myMaxHeight);\n      myList.setFixedCellWidth(myMaxWidth);\n      myList.setVisibleRowCount(Math.min(mySubstituteActions.size(), MAX_LOOKUP_LIST_HEIGHT));\n\n      if (oldIndex != -1) {\n        setSelectionIndex(oldIndex);\n        scrollToSelection();\n      }\n\n      pack();\n\n      if (getPosition() == PopupWindowPosition.TOP) {\n        newLocation = new Point(newLocation.x, newLocation.y - getHeight() - myPatternEditor.getHeight());\n      }\n\n      if (getWidth() >= deviceBounds.width) {\n        setSize(deviceBounds.width, getSize().height + myList.getFontMetrics(myList.getFont()).getHeight());\n      }\n\n      if (newLocation.x < deviceBounds.x) {\n        newLocation.x = deviceBounds.x;\n      }\n\n      if (getWidth() + newLocation.x > deviceBounds.width + deviceBounds.x) {\n        newLocation = new Point(deviceBounds.width + deviceBounds.x - getWidth(), newLocation.y);\n      }\n\n      setLocation(newLocation);\n    }","id":43303,"modified_method":"public void relayout() {\n      if (!myPatternEditor.isActivated()) {\n        return;\n      }\n      Point location = myPatternEditor.getLeftBottomPosition();\n\n      Rectangle deviceBounds = WindowsUtil.findDeviceBoundsAt(location);\n\n      Dimension preferredSize = getPreferredSize();\n      if (location.getY() + preferredSize.getHeight() > deviceBounds.height + deviceBounds.y - 150) {\n        setPosition(PopupWindowPosition.TOP);\n      } else {\n        setPosition(PopupWindowPosition.BOTTOM);\n      }\n\n      Point newLocation = location;\n\n      int oldIndex = 0;\n      if (mySelectedSubstituteAction != null) {\n        int newIndexOfLastSelectedAction = mySubstituteActions.indexOf(mySelectedSubstituteAction);\n        if (newIndexOfLastSelectedAction != -1) {\n          oldIndex = newIndexOfLastSelectedAction;\n        }\n      }\n\n      setSelectionIndex(oldIndex);\n      scrollToSelection();\n\n      setSize(preferredSize);\n\n      if (getPosition() == PopupWindowPosition.TOP) {\n        newLocation = new Point(newLocation.x, newLocation.y - getHeight() - myPatternEditor.getHeight());\n      }\n\n      if (getWidth() >= deviceBounds.width) {\n        setSize(deviceBounds.width, getSize().height + myList.getFontMetrics(myList.getFont()).getHeight());\n      }\n\n      if (newLocation.x < deviceBounds.x) {\n        newLocation.x = deviceBounds.x;\n      }\n\n      if (getWidth() + newLocation.x > deviceBounds.width + deviceBounds.x) {\n        newLocation = new Point(deviceBounds.width + deviceBounds.x - getWidth(), newLocation.y);\n      }\n\n      setLocation(newLocation);\n\n      myScroller.setSize(getSize());\n      myScroller.validate();\n    }","commit_id":"d15ed78a6c5eed3a7339aab5df387332857c4afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean processKeyTyped(EditorContext editorContext, KeyEvent keyEvent) {\n    if (getPatternEditor().processKeyTyped(keyEvent)) {\n      if (myPopupActivated) {\n        rebuildMenuEntries();\n        if (getEditorWindow() != null && !RuntimeFlags.isTestMode()) {\n          relayoutPopupMenu();\n        }\n        tryToApplyIntelligentInput();\n      }\n      return true;\n    }\n\n    return false;\n  }","id":43304,"modified_method":"@Override\n  public boolean processKeyTyped(EditorContext editorContext, KeyEvent keyEvent) {\n    if (getPatternEditor().processKeyTyped(keyEvent)) {\n      if (myPopupActivated) {\n        rebuildMenuEntries();\n        if (getEditorWindow() != null && !RuntimeFlags.isTestMode()) {\n          getPopupWindow().pack();\n          getPopupWindow().repaint();\n        }\n      }\n      return true;\n    }\n\n    return false;\n  }","commit_id":"d15ed78a6c5eed3a7339aab5df387332857c4afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PopupWindow(final Window owner) {\n      super(owner);\n      getOwner().addComponentListener(myComponentListener);\n\n      myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n      //TODO: change to EditorColorManager default font\n      myList.setFont(EditorSettings.getInstance().getDefaultEditorFont());\n      myList.setBackground(BACKGROUND_COLOR);\n      myList.setForeground(FOREGROUND_COLOR);\n      myList.setSelectionBackground(SELECTED_BACKGROUND_COLOR);\n      myList.setSelectionForeground(SELECTED_FOREGROUND_COLOR);\n\n      myList.addMouseListener(new MouseAdapter() {\n        @Override\n        public void mousePressed(MouseEvent e) {\n          repaintPopupMenu();\n        }\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n          if (e.getClickCount() == 2) {\n            ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n              @Override\n              public void run() {\n                doSubstituteSelection();\n              }\n            });\n          }\n        }\n      });\n\n      myList.setCellRenderer(getCellRenderer());\n\n      add(myScroller);\n\n      myScroller.getHorizontalScrollBar().setFocusable(false);\n      myScroller.getVerticalScrollBar().setFocusable(false);\n\n      myList.setFocusable(false);\n      pack();\n    }","id":43305,"modified_method":"public PopupWindow(final Window owner) {\n      super(owner);\n      getOwner().addComponentListener(myComponentListener);\n\n      myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n      //TODO: change to EditorColorManager default font\n      myList.setFont(EditorSettings.getInstance().getDefaultEditorFont());\n      myList.setBackground(BACKGROUND_COLOR);\n      myList.setForeground(FOREGROUND_COLOR);\n      myList.setSelectionBackground(SELECTED_BACKGROUND_COLOR);\n      myList.setSelectionForeground(SELECTED_FOREGROUND_COLOR);\n\n      myList.addMouseListener(new MouseAdapter() {\n        @Override\n        public void mousePressed(MouseEvent e) {\n          repaintPopupMenu();\n        }\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n          if (e.getClickCount() == 2) {\n            ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n              @Override\n              public void run() {\n                doSubstituteSelection();\n              }\n            });\n          }\n        }\n      });\n\n      myList.setCellRenderer(getCellRenderer());\n\n      add(myScroller);\n\n      myScroller.getHorizontalScrollBar().setFocusable(false);\n      myScroller.getVerticalScrollBar().setFocusable(false);\n\n      myList.setFocusable(false);\n      setLayout(new AbstractLayoutManager() {\n        @Override\n        public Dimension preferredLayoutSize(Container parent) {\n          int height = myScroller.getPreferredSize().height;\n          int width = myScroller.getPreferredSize().width;\n          if (myList.getModel().getSize() > myList.getVisibleRowCount()) {\n            height -= myList.getFixedCellHeight() / 2;\n          }\n          return new Dimension(width, height);\n        }\n\n        @Override\n        public void layoutContainer(Container parent) {\n          relayout();\n        }\n      });\n    }","commit_id":"d15ed78a6c5eed3a7339aab5df387332857c4afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setVisible(boolean visible) {\n     if (myChooserActivated != visible) {\n      boolean canShowPopup = getEditorWindow() != null && getEditorWindow().isShowing() && !(RuntimeFlags.isTestMode());\n      if (visible) {\n        myEditorComponent.pushKeyboardHandler(this);\n        rebuildMenuEntries();\n        getPatternEditor().activate(getEditorWindow(), myPatternEditorLocation, myPatternEditorSize, canShowPopup);\n        if (canShowPopup) {\n          getPopupWindow().relayout();\n          getPopupWindow().validate();\n          getPopupWindow().setVisible(true);\n          getPopupWindow().repaint();\n        } else {\n          getPopupWindow().initListModel();\n        }\n        getPopupWindow().setSelectionIndex(0);\n        getPopupWindow().scrollToSelection();\n        myPopupActivated = true;\n      } else {\n        if (canShowPopup) {\n          getPopupWindow().setVisible(false);\n          getPatternEditor().done();\n          getPopupWindow().setRelativeCell(null);\n        }\n        myNodeSubstituteInfo.invalidateActions();\n        myPopupActivated = false;\n        myEditorComponent.popKeyboardHandler();\n        myContextCell = null;\n      }\n    }\n    myChooserActivated = visible;\n  }","id":43306,"modified_method":"public void setVisible(boolean visible) {\n     if (myChooserActivated != visible) {\n      boolean canShowPopup = getEditorWindow() != null && getEditorWindow().isShowing() && !(RuntimeFlags.isTestMode());\n      if (visible) {\n        myEditorComponent.pushKeyboardHandler(this);\n        rebuildMenuEntries();\n        getPatternEditor().activate(getEditorWindow(), myPatternEditorLocation, myPatternEditorSize, canShowPopup);\n        if (canShowPopup) {\n          getPopupWindow().setVisible(true);\n        }\n        getPopupWindow().setSelectionIndex(0);\n        getPopupWindow().scrollToSelection();\n        myPopupActivated = true;\n      } else {\n        if (canShowPopup) {\n          getPopupWindow().setVisible(false);\n          getPatternEditor().done();\n          getPopupWindow().setRelativeCell(null);\n        }\n        myNodeSubstituteInfo.invalidateActions();\n        myPopupActivated = false;\n        myEditorComponent.popKeyboardHandler();\n        myContextCell = null;\n      }\n    }\n    myChooserActivated = visible;\n  }","commit_id":"d15ed78a6c5eed3a7339aab5df387332857c4afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean processKeyPressed(EditorContext editorContext, KeyEvent keyEvent) {\n    if (getPatternEditor().processKeyPressed(keyEvent)) {\n      if (myPopupActivated) {\n        rebuildMenuEntries();\n        relayoutPopupMenu();\n        tryToApplyIntelligentInput();\n      }\n      return true;\n    }\n\n    if (keyEvent.getKeyCode() == KeyEvent.VK_ESCAPE) {\n      setVisible(false);\n      return true;\n    }\n\n    if (myPopupActivated) {\n      return menu_processKeyPressed(keyEvent);\n    }\n\n    if (keyEvent.getKeyCode() == KeyEvent.VK_ENTER || (keyEvent.getKeyCode() == KeyEvent.VK_SPACE && keyEvent.isControlDown())) {\n      return doSubstitute();\n    }\n    return false;\n  }","id":43307,"modified_method":"@Override\n  public boolean processKeyPressed(EditorContext editorContext, KeyEvent keyEvent) {\n    if (getPatternEditor().processKeyPressed(keyEvent)) {\n      if (myPopupActivated) {\n        rebuildMenuEntries();\n        getPopupWindow().pack();\n        getPopupWindow().repaint();\n      }\n      return true;\n    }\n\n    if (keyEvent.getKeyCode() == KeyEvent.VK_ESCAPE) {\n      setVisible(false);\n      return true;\n    }\n\n    if (myPopupActivated) {\n      return menu_processKeyPressed(keyEvent);\n    }\n\n    if (keyEvent.getKeyCode() == KeyEvent.VK_ENTER || (keyEvent.getKeyCode() == KeyEvent.VK_SPACE && keyEvent.isControlDown())) {\n      return doSubstitute();\n    }\n    return false;\n  }","commit_id":"d15ed78a6c5eed3a7339aab5df387332857c4afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Simple example to demonstrate how to inject service proxy into distributed closures.\n     *\n     * @param grid Grid instance.\n     * @throws Exception If failed.\n     */\n    private static void serviceInjectionExample(Grid grid) throws Exception {\n        System.out.println(\">>>\");\n        System.out.println(\">>> Starting service injection example.\");\n        System.out.println(\">>>\");\n\n        // Get a sticky proxy for cluster-singleton map service.\n        SimpleMapService<Integer, String> mapSvc = grid.services().serviceProxy(\"myClusterSingletonService\", SimpleMapService.class, true);\n\n        int cnt = 10;\n\n        // Each service invocation will go over a proxy to the remote cluster-singleton instance.\n        for (int i = 0; i < cnt; i++)\n            mapSvc.put(i, Integer.toString(i));\n\n        // Broadcast closure to every node.\n        final Collection<Integer> mapSizes = grid.compute().broadcast(new GridCallable<Integer>() {\n            // Auto-inject service proxy.\n            @GridServiceResource(serviceName = \"myClusterSingletonService\", proxyInterface = SimpleMapService.class)\n            private SimpleMapService mapSvc;\n\n            @Override public Integer call() throws Exception {\n                int mapSize = mapSvc.size();\n\n                System.out.println(\"Executing closure [mapSize=\" + mapSize + ']');\n\n                return mapSize;\n            }\n        }).get();\n\n        System.out.println(\"Closure execution result: \" + mapSizes);\n\n        // Since we invoked the same cluster-singleton service instance\n        // from all the remote closure executions, they should all return\n        // the same size equal to 'cnt' value.\n        for (int mapSize : mapSizes)\n            if (mapSize != cnt)\n                throw new Exception(\"Invalid map size [expected=\" + cnt + \", actual=\" + mapSize + ']');\n    }","id":43308,"modified_method":"/**\n     * Simple example to demonstrate how to inject service proxy into distributed closures.\n     *\n     * @param grid Grid instance.\n     * @throws Exception If failed.\n     */\n    private static void serviceInjectionExample(Grid grid) throws Exception {\n        System.out.println(\">>>\");\n        System.out.println(\">>> Starting service injection example.\");\n        System.out.println(\">>>\");\n\n        // Get a sticky proxy for cluster-singleton map service.\n        SimpleMapService<Integer, String> mapSvc = grid.services().serviceProxy(\"myClusterSingletonService\", SimpleMapService.class, true);\n\n        int cnt = 10;\n\n        // Each service invocation will go over a proxy to the remote cluster-singleton instance.\n        for (int i = 0; i < cnt; i++)\n            mapSvc.put(i, Integer.toString(i));\n\n        // Broadcast closure to every node.\n        final Collection<Integer> mapSizes = grid.compute().broadcast(new SimpleClosure()).get();\n\n        System.out.println(\"Closure execution result: \" + mapSizes);\n\n        // Since we invoked the same cluster-singleton service instance\n        // from all the remote closure executions, they should all return\n        // the same size equal to 'cnt' value.\n        for (int mapSize : mapSizes)\n            if (mapSize != cnt)\n                throw new Exception(\"Invalid map size [expected=\" + cnt + \", actual=\" + mapSize + ']');\n    }","commit_id":"7d5857052700e893971d74fd5a0051d587d76066","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testRemoteStickyProxyInvocation() throws Exception {\n        final String name = \"testRemoteStickyProxyInvocation\";\n\n        final Grid grid = grid(0);\n\n        grid.services().deployNodeSingleton(name, new MapServiceImpl<String, Integer>()).get();\n\n        // Get remote proxy.\n        MapService<Integer, String> svc =  grid.forRemotes().services().serviceProxy(name, MapService.class, true);\n\n        // Make sure service is a local instance.\n        assertFalse(svc instanceof GridService);\n\n        for (int i = 0; i < nodeCount(); i++)\n            svc.put(i, Integer.toString(i));\n\n        int size = 0;\n\n        for (GridNode n : grid.forRemotes().nodes()) {\n            MapService<Integer, String> map = grid.forNode(n).services().serviceProxy(name, MapService.class, false);\n\n            // Make sure service is a local instance.\n            assertFalse(map instanceof GridService);\n\n            if (map.size() != 0)\n                size += map.size();\n        }\n\n        assertEquals(nodeCount(), size);\n    }","id":43309,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testRemoteStickyProxyInvocation() throws Exception {\n        final String name = \"testRemoteStickyProxyInvocation\";\n\n        final Grid grid = grid(0);\n\n        grid.services().deployNodeSingleton(name, new MapServiceImpl<String, Integer>());\n\n        // Get remote proxy.\n        MapService<Integer, String> svc =  grid.services(grid.cluster().forRemotes()).\n            serviceProxy(name, MapService.class, true);\n\n        // Make sure service is a local instance.\n        assertFalse(svc instanceof GridService);\n\n        for (int i = 0; i < nodeCount(); i++)\n            svc.put(i, Integer.toString(i));\n\n        int size = 0;\n\n        for (GridNode n : grid.cluster().forRemotes().nodes()) {\n            MapService<Integer, String> map = grid.services(grid.cluster().forNode(n)).\n                serviceProxy(name, MapService.class, false);\n\n            // Make sure service is a local instance.\n            assertFalse(map instanceof GridService);\n\n            if (map.size() != 0)\n                size += map.size();\n        }\n\n        assertEquals(nodeCount(), size);\n    }","commit_id":"c340b008b109204e177cb3ecac7a386dd52ce579","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testLocalProxyInvocation() throws Exception {\n        final String name = \"testLocalProxyInvocation\";\n\n        final Grid grid = grid(0);\n\n        grid.services().deployNodeSingleton(name, new MapServiceImpl<String, Integer>()).get();\n\n        for (int i = 0; i < nodeCount(); i++) {\n            MapService<Integer, String> svc =  grid(i).services().serviceProxy(name, MapService.class, false);\n\n            // Make sure service is a local instance.\n            assertTrue(svc instanceof GridService);\n\n            svc.put(i, Integer.toString(i));\n        }\n\n        MapService<Integer, String> map = grid.services().serviceProxy(name, MapService.class, false);\n\n        for (int i = 0; i < nodeCount(); i++)\n            assertEquals(1, map.size());\n    }","id":43310,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testLocalProxyInvocation() throws Exception {\n        final String name = \"testLocalProxyInvocation\";\n\n        final Grid grid = grid(0);\n\n        grid.services().deployNodeSingleton(name, new MapServiceImpl<String, Integer>());\n\n        for (int i = 0; i < nodeCount(); i++) {\n            MapService<Integer, String> svc =  grid(i).services().serviceProxy(name, MapService.class, false);\n\n            // Make sure service is a local instance.\n            assertTrue(svc instanceof GridService);\n\n            svc.put(i, Integer.toString(i));\n        }\n\n        MapService<Integer, String> map = grid.services().serviceProxy(name, MapService.class, false);\n\n        for (int i = 0; i < nodeCount(); i++)\n            assertEquals(1, map.size());\n    }","commit_id":"c340b008b109204e177cb3ecac7a386dd52ce579","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testRemoteNotStickProxyInvocation() throws Exception {\n        final String name = \"testRemoteNotStickProxyInvocation\";\n\n        final Grid grid = grid(0);\n\n        grid.services().deployNodeSingleton(name, new MapServiceImpl<String, Integer>()).get();\n\n        // Get remote proxy.\n        MapService<Integer, String> svc =  grid.forRemotes().services().serviceProxy(name, MapService.class, false);\n\n        // Make sure service is a local instance.\n        assertFalse(svc instanceof GridService);\n\n        for (int i = 0; i < nodeCount(); i++)\n            svc.put(i, Integer.toString(i));\n\n        int size = 0;\n\n        for (GridNode n : grid.forRemotes().nodes()) {\n            MapService<Integer, String> map = grid.forNode(n).services().serviceProxy(name, MapService.class, false);\n\n            // Make sure service is a local instance.\n            assertFalse(map instanceof GridService);\n\n            size += map.size();\n        }\n\n        assertEquals(nodeCount(), size);\n    }","id":43311,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testRemoteNotStickProxyInvocation() throws Exception {\n        final String name = \"testRemoteNotStickProxyInvocation\";\n\n        final Grid grid = grid(0);\n\n        grid.services().deployNodeSingleton(name, new MapServiceImpl<String, Integer>());\n\n        // Get remote proxy.\n        MapService<Integer, String> svc =  grid.services(grid.cluster().forRemotes()).\n            serviceProxy(name, MapService.class, false);\n\n        // Make sure service is a local instance.\n        assertFalse(svc instanceof GridService);\n\n        for (int i = 0; i < nodeCount(); i++)\n            svc.put(i, Integer.toString(i));\n\n        int size = 0;\n\n        for (GridNode n : grid.cluster().forRemotes().nodes()) {\n            MapService<Integer, String> map = grid.services(grid.cluster().forNode(n)).\n                serviceProxy(name, MapService.class, false);\n\n            // Make sure service is a local instance.\n            assertFalse(map instanceof GridService);\n\n            size += map.size();\n        }\n\n        assertEquals(nodeCount(), size);\n    }","commit_id":"c340b008b109204e177cb3ecac7a386dd52ce579","url":"https://github.com/apache/ignite"},{"original_method":"public static void main(String[] args) throws Exception {\n        try (Grid grid = GridGain.start(\"examples/config/example-compute.xml\")) {\n            GridProjection rmts = grid.forRemotes();\n\n            if (rmts.nodes().isEmpty()) {\n                System.err.println(\">>>\");\n                System.err.println(\">>> Must start at least one remote node using \" +\n                    ComputeNodeStartup.class.getSimpleName() + '.');\n                System.err.println(\">>>\");\n\n                return;\n            }\n\n            GridServices svcs = rmts.services();\n\n            try {\n                // Deploy cluster singleton.\n                svcs.deployClusterSingleton(\"myClusterSingletonService\", new SimpleMapServiceImpl()).get();\n\n                // Deploy node singleton.\n                svcs.deployNodeSingleton(\"myNodeSingletonService\", new SimpleMapServiceImpl()).get();\n\n                // Deploy 2 instances, regardless of number nodes.\n                svcs.deployMultiple(\"myMultiService\", new SimpleMapServiceImpl(), 2 /*total number*/, 0 /*0 for unlimited*/).get();\n\n                // Example for using a service proxy\n                // to access a remotely deployed service.\n                serviceProxyExample(grid);\n\n                // Example for auto-injecting service proxy\n                // into remote closure execution.\n                serviceInjectionExample(grid);\n            }\n            finally {\n                // Undeploy all services.\n                grid.services().cancelAll();\n            }\n        }\n    }","id":43312,"modified_method":"public static void main(String[] args) throws Exception {\n        try (Grid grid = GridGain.start(\"examples/config/example-compute.xml\")) {\n            GridProjection rmts = grid.cluster().forRemotes();\n\n            if (rmts.nodes().isEmpty()) {\n                System.err.println(\">>>\");\n                System.err.println(\">>> Must start at least one remote node using \" +\n                    ComputeNodeStartup.class.getSimpleName() + '.');\n                System.err.println(\">>>\");\n\n                return;\n            }\n\n            GridServices svcs = grid.services(rmts);\n\n            try {\n                // Deploy cluster singleton.\n                svcs.deployClusterSingleton(\"myClusterSingletonService\", new SimpleMapServiceImpl());\n\n                // Deploy node singleton.\n                svcs.deployNodeSingleton(\"myNodeSingletonService\", new SimpleMapServiceImpl());\n\n                // Deploy 2 instances, regardless of number nodes.\n                svcs.deployMultiple(\"myMultiService\", new SimpleMapServiceImpl(), 2 /*total number*/, 0 /*0 for unlimited*/);\n\n                // Example for using a service proxy\n                // to access a remotely deployed service.\n                serviceProxyExample(grid);\n\n                // Example for auto-injecting service proxy\n                // into remote closure execution.\n                serviceInjectionExample(grid);\n            }\n            finally {\n                // Undeploy all services.\n                grid.services().cancelAll();\n            }\n        }\n    }","commit_id":"c340b008b109204e177cb3ecac7a386dd52ce579","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Simple example to demonstrate how to inject service proxy into distributed closures.\n     *\n     * @param grid Grid instance.\n     * @throws Exception If failed.\n     */\n    private static void serviceInjectionExample(Grid grid) throws Exception {\n        System.out.println(\">>>\");\n        System.out.println(\">>> Starting service injection example.\");\n        System.out.println(\">>>\");\n\n        // Get a sticky proxy for cluster-singleton map service.\n        SimpleMapService<Integer, String> mapSvc = grid.services().serviceProxy(\"myClusterSingletonService\", SimpleMapService.class, true);\n\n        int cnt = 10;\n\n        // Each service invocation will go over a proxy to the remote cluster-singleton instance.\n        for (int i = 0; i < cnt; i++)\n            mapSvc.put(i, Integer.toString(i));\n\n        // Broadcast closure to every node.\n        final Collection<Integer> mapSizes = grid.compute().broadcast(new SimpleClosure()).get();\n\n        System.out.println(\"Closure execution result: \" + mapSizes);\n\n        // Since we invoked the same cluster-singleton service instance\n        // from all the remote closure executions, they should all return\n        // the same size equal to 'cnt' value.\n        for (int mapSize : mapSizes)\n            if (mapSize != cnt)\n                throw new Exception(\"Invalid map size [expected=\" + cnt + \", actual=\" + mapSize + ']');\n    }","id":43313,"modified_method":"/**\n     * Simple example to demonstrate how to inject service proxy into distributed closures.\n     *\n     * @param grid Grid instance.\n     * @throws Exception If failed.\n     */\n    private static void serviceInjectionExample(Grid grid) throws Exception {\n        System.out.println(\">>>\");\n        System.out.println(\">>> Starting service injection example.\");\n        System.out.println(\">>>\");\n\n        // Get a sticky proxy for cluster-singleton map service.\n        SimpleMapService<Integer, String> mapSvc = grid.services().serviceProxy(\"myClusterSingletonService\", SimpleMapService.class, true);\n\n        int cnt = 10;\n\n        // Each service invocation will go over a proxy to the remote cluster-singleton instance.\n        for (int i = 0; i < cnt; i++)\n            mapSvc.put(i, Integer.toString(i));\n\n        // Broadcast closure to every node.\n        final Collection<Integer> mapSizes = grid.compute().broadcast(new SimpleClosure());\n\n        System.out.println(\"Closure execution result: \" + mapSizes);\n\n        // Since we invoked the same cluster-singleton service instance\n        // from all the remote closure executions, they should all return\n        // the same size equal to 'cnt' value.\n        for (int mapSize : mapSizes)\n            if (mapSize != cnt)\n                throw new Exception(\"Invalid map size [expected=\" + cnt + \", actual=\" + mapSize + ']');\n    }","commit_id":"c340b008b109204e177cb3ecac7a386dd52ce579","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite ignite = Ignition.start(\"examples/config/example-compute.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Compute broadcast example started.\");\n\n            // Broadcast closure to all cluster nodes.\n            ignite.compute().broadcast((IgniteRunnable)() -> System.out.println(\"Hello World\")).get();\n\n            // Unicast closure to some cluster node picked by load balancer.\n            ignite.compute().run((IgniteRunnable)() -> System.out.println(\"Hello World\")).get();\n\n            // Unicast closure to some cluster node picked by load balancer and return result.\n            int length = ignite.compute().call((IgniteCallable<Integer>)\"Hello World\"::length).get();\n\n            System.out.println();\n            System.out.println(\">>> Computed length: \" + length);\n\n            System.out.println();\n            System.out.println(\">>> Check all nodes for hello message output.\");\n        }\n    }","id":43314,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        try (Ignite ignite = Ignition.start(\"examples/config/example-compute.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Compute broadcast example started.\");\n\n            // Broadcast closure to all cluster nodes.\n            ignite.compute().broadcast((IgniteRunnable) () -> System.out.println(\"Hello World\"));\n\n            // Unicast closure to some cluster node picked by load balancer.\n            ignite.compute().run((IgniteRunnable) () -> System.out.println(\"Hello World\"));\n\n            // Unicast closure to some cluster node picked by load balancer and return result.\n            int length = ignite.compute().call((IgniteCallable<Integer>) \"Hello World\"::length);\n\n            System.out.println();\n            System.out.println(\">>> Computed length: \" + length);\n\n            System.out.println();\n            System.out.println(\">>> Check all nodes for hello message output.\");\n        }\n    }","commit_id":"5190174084e45c1d06f35e50c0ee7f1bf38d837d","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Listen for messages from remote nodes.\n     *\n     * @param grp Cluster group.\n     * @param orderedLatch Latch for ordered messages acks.\n     * @param unorderedLatch Latch for unordered messages acks.\n     */\n    private static void localListen(\n        ClusterGroup prj,\n        final CountDownLatch orderedLatch,\n        final CountDownLatch unorderedLatch\n    ) {\n        grp.message().localListen(TOPIC.ORDERED, (nodeId, msg) -> {\n            orderedLatch.countDown();\n\n            // Return true to continue listening, false to stop.\n            return orderedLatch.getCount() > 0;\n        });\n\n        grp.message().localListen(TOPIC.UNORDERED, (nodeId, msg) -> {\n            unorderedLatch.countDown();\n\n            // Return true to continue listening, false to stop.\n            return unorderedLatch.getCount() > 0;\n        });\n    }","id":43315,"modified_method":"/**\n     * Listen for messages from remote nodes.\n     *\n     * @param imsg Ignite messaging.\n     * @param orderedLatch Latch for ordered messages acks.\n     * @param unorderedLatch Latch for unordered messages acks.\n     */\n    private static void localListen(\n        IgniteMessaging imsg,\n        final CountDownLatch orderedLatch,\n        final CountDownLatch unorderedLatch\n    ) {\n        imsg.localListen(TOPIC.ORDERED, (nodeId, msg) -> {\n            orderedLatch.countDown();\n\n            // Return true to continue listening, false to stop.\n            return orderedLatch.getCount() > 0;\n        });\n\n        imsg.localListen(TOPIC.UNORDERED, (nodeId, msg) -> {\n            unorderedLatch.countDown();\n\n            // Return true to continue listening, false to stop.\n            return unorderedLatch.getCount() > 0;\n        });\n    }","commit_id":"5190174084e45c1d06f35e50c0ee7f1bf38d837d","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite ignite = Ignition.start(\"examples/config/example-compute.xml\")) {\n            if (ignite.nodes().size() < 2) {\n                System.out.println();\n                System.out.println(\">>> Please start at least 2 cluster nodes to run example.\");\n                System.out.println();\n\n                return;\n            }\n\n            System.out.println();\n            System.out.println(\">>> Messaging example started.\");\n\n            // Projection for remote nodes.\n            ClusterGroup rmtPrj = ignite.forRemotes();\n\n            // Listen for messages from remote nodes to make sure that they received all the messages.\n            int msgCnt = rmtPrj.nodes().size() * MESSAGES_NUM;\n\n            CountDownLatch orderedLatch = new CountDownLatch(msgCnt);\n            CountDownLatch unorderedLatch = new CountDownLatch(msgCnt);\n\n            localListen(ignite.forLocal(), orderedLatch, unorderedLatch);\n\n            // Register listeners on all cluster nodes.\n            startListening(rmtPrj);\n\n            // Send unordered messages to all remote nodes.\n            for (int i = 0; i < MESSAGES_NUM; i++)\n                rmtPrj.message().send(TOPIC.UNORDERED, Integer.toString(i));\n\n            System.out.println(\">>> Finished sending unordered messages.\");\n\n            // Send ordered messages to all remote nodes.\n            for (int i = 0; i < MESSAGES_NUM; i++)\n                rmtPrj.message().sendOrdered(TOPIC.ORDERED, Integer.toString(i), 0);\n\n            System.out.println(\">>> Finished sending ordered messages.\");\n            System.out.println(\">>> Check output on all nodes for message printouts.\");\n            System.out.println(\">>> Will wait for messages acknowledgements from all remote nodes.\");\n\n            orderedLatch.await();\n            unorderedLatch.await();\n\n            System.out.println(\">>> Messaging example finished.\");\n        }\n    }","id":43316,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite ignite = Ignition.start(\"examples/config/example-compute.xml\")) {\n            if (!ExamplesUtils.checkMinTopologySize(ignite.cluster(), 2)) {\n                System.out.println();\n                System.out.println(\">>> Please start at least 2 cluster nodes to run example.\");\n                System.out.println();\n\n                return;\n            }\n\n            System.out.println();\n            System.out.println(\">>> Messaging example started.\");\n\n            // Projection for remote nodes.\n            ClusterGroup rmtPrj = ignite.cluster().forRemotes();\n\n            // Listen for messages from remote nodes to make sure that they received all the messages.\n            int msgCnt = rmtPrj.nodes().size() * MESSAGES_NUM;\n\n            CountDownLatch orderedLatch = new CountDownLatch(msgCnt);\n            CountDownLatch unorderedLatch = new CountDownLatch(msgCnt);\n\n            localListen(ignite.message(ignite.cluster().forLocal()), orderedLatch, unorderedLatch);\n\n            // Register listeners on all cluster nodes.\n            startListening(ignite, ignite.message(rmtPrj));\n\n            // Send unordered messages to all remote nodes.\n            for (int i = 0; i < MESSAGES_NUM; i++)\n                ignite.message(rmtPrj).send(TOPIC.UNORDERED, Integer.toString(i));\n\n            System.out.println(\">>> Finished sending unordered messages.\");\n\n            // Send ordered messages to all remote nodes.\n            for (int i = 0; i < MESSAGES_NUM; i++)\n                ignite.message(rmtPrj).sendOrdered(TOPIC.ORDERED, Integer.toString(i), 0);\n\n            System.out.println(\">>> Finished sending ordered messages.\");\n            System.out.println(\">>> Check output on all nodes for message printouts.\");\n            System.out.println(\">>> Will wait for messages acknowledgements from all remote nodes.\");\n\n            orderedLatch.await();\n            unorderedLatch.await();\n\n            System.out.println(\">>> Messaging example finished.\");\n        }\n    }","commit_id":"5190174084e45c1d06f35e50c0ee7f1bf38d837d","url":"https://github.com/apache/ignite"},{"original_method":"@Test\n\tpublic void testExpireArticle() throws Exception {\n\t\tupdateArticle(\"Version 2\");\n\n\t\texpireLatestArticle();\n\n\t\tAssert.assertEquals(\n\t\t\t\"Version 2\", _article.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertTrue(_article.isExpired());\n\t\tAssert.assertEquals(1.1, _article.getVersion(), 0);\n\t}","id":43317,"modified_method":"@Test\n\tpublic void testExpireArticle() throws Exception {\n\t\tupdateAndExpireLatestArticle(\"Version 2\");\n\n\t\tAssert.assertEquals(\n\t\t\t\"Version 2\", _article.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertTrue(_article.isExpired());\n\t\tAssert.assertEquals(1.1, _article.getVersion(), 0);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void fetchLatestArticle(int status) throws Exception {\n\t\t_latestArticle = JournalArticleLocalServiceUtil.fetchLatestArticle(\n\t\t\t_article.getResourcePrimKey(), status,\n\t\t\tstatus == WorkflowConstants.STATUS_APPROVED);\n\t}","id":43318,"modified_method":"protected JournalArticle fetchLatestArticle(int status) throws Exception {\n\t\treturn JournalArticleLocalServiceUtil.fetchLatestArticle(\n\t\t\t_article.getResourcePrimKey(), status,\n\t\t\tstatus == WorkflowConstants.STATUS_APPROVED);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFetchLatestArticleNotExpiredWithStatusExpired()\n\t\tthrows Exception {\n\n\t\ttestFetchLatestArticle(false, WorkflowConstants.STATUS_EXPIRED);\n\t}","id":43319,"modified_method":"@Test\n\tpublic void testFetchLatestArticleNotExpiredWithStatusExpired()\n\t\tthrows Exception {\n\n\t\t_article = JournalTestUtil.updateArticle(_article, \"Version 2\");\n\n\t\t_latestArticle = fetchLatestArticle(WorkflowConstants.STATUS_EXPIRED);\n\n\t\tAssert.assertNull(_latestArticle);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFetchLatestArticleExpiredWithStatusExpired()\n\t\tthrows Exception {\n\n\t\ttestFetchLatestArticle(true, WorkflowConstants.STATUS_EXPIRED);\n\t}","id":43320,"modified_method":"@Test\n\tpublic void testFetchLatestArticleExpiredWithStatusExpired()\n\t\tthrows Exception {\n\n\t\tupdateAndExpireLatestArticle(\"Version 2\");\n\n\t\t_latestArticle = fetchLatestArticle(WorkflowConstants.STATUS_EXPIRED);\n\n\t\tAssert.assertNotNull(_latestArticle);\n\t\tAssert.assertTrue(_latestArticle.isExpired());\n\t\tAssert.assertEquals(\n\t\t\t\"Version 2\", _latestArticle.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertEquals(1.1, _latestArticle.getVersion(), 0);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFetchLatestArticleNotExpiredWithStatusApproved()\n\t\tthrows Exception {\n\n\t\ttestFetchLatestArticle(false, WorkflowConstants.STATUS_APPROVED);\n\t}","id":43321,"modified_method":"@Test\n\tpublic void testFetchLatestArticleNotExpiredWithStatusApproved()\n\t\tthrows Exception {\n\n\t\t_article = JournalTestUtil.updateArticle(_article, \"Version 2\");\n\n\t\t_latestArticle = fetchLatestArticle(WorkflowConstants.STATUS_APPROVED);\n\n\t\tAssert.assertNotNull(_latestArticle);\n\t\tAssert.assertTrue(_latestArticle.isApproved());\n\t\tAssert.assertEquals(\n\t\t\t\"Version 2\", _latestArticle.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertEquals(1.1, _latestArticle.getVersion(), 0);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFetchLatestArticleExpiredWithStatusAny() throws Exception {\n\t\ttestFetchLatestArticle(true, WorkflowConstants.STATUS_ANY);\n\t}","id":43322,"modified_method":"@Test\n\tpublic void testFetchLatestArticleExpiredWithStatusAny() throws Exception {\n\t\tupdateAndExpireLatestArticle(\"Version 2\");\n\n\t\t_latestArticle = fetchLatestArticle(WorkflowConstants.STATUS_ANY);\n\n\t\tAssert.assertNotNull(_latestArticle);\n\t\tAssert.assertTrue(_latestArticle.isExpired());\n\t\tAssert.assertEquals(\n\t\t\t\"Version 2\", _latestArticle.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertEquals(1.1, _latestArticle.getVersion(), 0);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFetchLatestArticleNotExpiredWithStatusAny()\n\t\tthrows Exception {\n\n\t\ttestFetchLatestArticle(false, WorkflowConstants.STATUS_ANY);\n\t}","id":43323,"modified_method":"@Test\n\tpublic void testFetchLatestArticleNotExpiredWithStatusAny()\n\t\tthrows Exception {\n\n\t\t_article = JournalTestUtil.updateArticle(_article, \"Version 2\");\n\n\t\t_latestArticle = fetchLatestArticle(WorkflowConstants.STATUS_ANY);\n\n\t\tAssert.assertNotNull(_latestArticle);\n\t\tAssert.assertTrue(_latestArticle.isApproved());\n\t\tAssert.assertEquals(\n\t\t\t\"Version 2\", _latestArticle.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertEquals(1.1, _latestArticle.getVersion(), 0);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFetchLatestArticleExpiredWithStatusApproved()\n\t\tthrows Exception {\n\n\t\ttestFetchLatestArticle(true, WorkflowConstants.STATUS_APPROVED);\n\t}","id":43324,"modified_method":"@Test\n\tpublic void testFetchLatestArticleExpiredWithStatusApproved()\n\t\tthrows Exception {\n\n\t\tupdateAndExpireLatestArticle(\"Version 2\");\n\n\t\t_latestArticle = fetchLatestArticle(WorkflowConstants.STATUS_APPROVED);\n\n\t\tAssert.assertNotNull(_latestArticle);\n\t\tAssert.assertTrue(_latestArticle.isApproved());\n\t\tAssert.assertEquals(\n\t\t\t\"Version 1\", _latestArticle.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertEquals(1.0, _latestArticle.getVersion(), 0);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateArticle(String title) throws Exception {\n\t\t_article = JournalTestUtil.updateArticle(\n\t\t\t_article, title, _article.getContent());\n\t}","id":43325,"modified_method":"protected void updateAndExpireLatestArticle(String title) throws Exception {\n\t\tJournalTestUtil.updateArticle(_article, title);\n\n\t\t_article = JournalTestUtil.expireArticle(\n\t\t\t_group.getGroupId(), _article, 1.1);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUpdateArticle() throws Exception {\n\t\tupdateArticle(\"Version 2\");\n\n\t\tAssert.assertEquals(\n\t\t\t\"Version 2\", _article.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertTrue(_article.isApproved());\n\t\tAssert.assertEquals(1.1, _article.getVersion(), 0);\n\t}","id":43326,"modified_method":"@Test\n\tpublic void testUpdateArticle() throws Exception {\n\t\t_article = JournalTestUtil.updateArticle(_article, \"Version 2\");\n\n\t\tAssert.assertEquals(\n\t\t\t\"Version 2\", _article.getTitle(LocaleUtil.getDefault()));\n\t\tAssert.assertTrue(_article.isApproved());\n\t\tAssert.assertEquals(1.1, _article.getVersion(), 0);\n\t}","commit_id":"b402c8c46df8a94a52bf1df140cd80cefee49788","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Deprecated\n  protected final void invalidateClassPath() {\n    // todo: remove this method!\n    getJavaFacet().invalidateClassPath();\n  }","id":43327,"modified_method":"/**\n   * Just don't use!\n   */\n  @Deprecated\n  protected final void invalidateClassPath() {\n    // todo: remove this method!\n    ((JavaModuleFacetImpl) getJavaFacet()).invalidateClassPath();\n  }","commit_id":"fbeca479344a8ba23c74c679ddd4e105182ecbde","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public static IClassPathItem getDependenciesClasspath(Set<IModule> modules, boolean includeStubSolutions) {\n    return SModuleOperations.getDependenciesClasspath(modules, includeStubSolutions);\n  }","id":43328,"modified_method":"/**\n   * @see SModuleOperations#getDependenciesClasspath\n   */\n  @Deprecated\n  public static IClassPathItem getDependenciesClasspath(Set<IModule> modules, boolean includeStubSolutions) {\n    return SModuleOperations.getDependenciesClasspath(modules, includeStubSolutions);\n  }","commit_id":"fbeca479344a8ba23c74c679ddd4e105182ecbde","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public final Collection<String> getAdditionalClassPath() {\n    return getJavaFacet().getAdditionalClassPath();\n  }","id":43329,"modified_method":"/**\n   * JavaModuleFacetImpl#getAdditionalClassPath only for overriding\n   * Use @see JavaModuleFacetImpl#getClassPath instead\n   */\n  @Deprecated\n  public final Collection<String> getAdditionalClassPath() {\n    return ((JavaModuleFacetImpl) getJavaFacet()).getAdditionalClassPath();\n  }","commit_id":"fbeca479344a8ba23c74c679ddd4e105182ecbde","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public final Collection<String> getOwnClassPath() {\n    return getJavaFacet().getOwnClassPath();\n  }","id":43330,"modified_method":"/**\n   * JavaModuleFacetImpl#getOwnClassPath only for overriding\n   * Use JavaModuleFacetImpl#getClassPath instead\n   */\n  @Deprecated\n  public final Collection<String> getOwnClassPath() {\n    return ((JavaModuleFacetImpl) getJavaFacet()).getOwnClassPath();\n  }","commit_id":"fbeca479344a8ba23c74c679ddd4e105182ecbde","url":"https://github.com/JetBrains/MPS"},{"original_method":"public JavaModuleFacetImpl(IModule module) {\n    myModule = module;\n  }","id":43331,"modified_method":"public JavaModuleFacetImpl(IModule module) {\n    super(module);\n  }","commit_id":"fbeca479344a8ba23c74c679ddd4e105182ecbde","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static BigDecimal getBillingAccountBalance(GenericValue billingAccount) throws GenericEntityException {\n        \n        GenericDelegator delegator = billingAccount.getDelegator();\n        String billingAccountId = billingAccount.getString(\"billingAccountId\");\n\n        BigDecimal balance = ZERO;\n        BigDecimal accountLimit = getAccountLimit(billingAccount);\n        balance = balance.add(accountLimit);\n        // pending (not cancelled, rejected, or received) order payments\n        EntityConditionList whereConditions = new EntityConditionList(UtilMisc.toList(\n                new EntityExpr(\"billingAccountId\", EntityOperator.EQUALS, billingAccountId),\n                new EntityExpr(\"paymentMethodTypeId\", EntityOperator.EQUALS, \"EXT_BILLACT\"),\n                new EntityExpr(\"statusId\", EntityOperator.NOT_IN, UtilMisc.toList(\"ORDER_CANCELLED\", \"ORDER_REJECTED\")),\n                new EntityExpr(\"preferenceStatusId\", EntityOperator.NOT_IN, UtilMisc.toList(\"PAYMENT_SETTLED\", \"PAYMENT_RECEIVED\", \"PAYMENT_DECLINED\", \"PAYMENT_CANCELLED\")) // PAYMENT_NOT_AUTH\n            ), EntityOperator.AND); \n\n        GenericValue orderPaymentPreferenceSum = EntityUtil.getFirst(delegator.findByCondition(\"OrderPurchasePaymentSummary\", whereConditions, null, UtilMisc.toList(\"maxAmount\"), null, null));\n        BigDecimal ordersTotal = null;\n        if (UtilValidate.isNotEmpty(orderPaymentPreferenceSum)) {\n            ordersTotal = orderPaymentPreferenceSum.getBigDecimal(\"maxAmount\");\n        } else {\n            ordersTotal = ZERO;\n        }\n        balance = balance.subtract(ordersTotal);\n\n        List paymentAppls = delegator.findByAnd(\"PaymentApplication\", UtilMisc.toMap(\"billingAccountId\", billingAccountId));\n        // TODO: cancelled payments?\n        if (paymentAppls != null) {\n            for (Iterator pAi = paymentAppls.iterator(); pAi.hasNext(); ) {\n                GenericValue paymentAppl = (GenericValue) pAi.next();\n                if (paymentAppl.getString(\"invoiceId\") == null) {\n                    BigDecimal amountApplied = paymentAppl.getBigDecimal(\"amountApplied\");\n                    balance = balance.add(amountApplied);\n                }\n            }\n        }\n    \n        balance = balance.setScale(decimals, rounding);\n        return balance;\n        /*\n        GenericDelegator delegator = billingAccount.getDelegator();\n        String billingAccountId = billingAccount.getString(\"billingAccountId\");\n        \n        // first get the net balance of invoices - payments\n        BigDecimal balance = getBillingAccountNetBalance(delegator, billingAccountId);\n        \n        // now the amounts of all the pending orders (not cancelled, rejected or completed)\n        List orderHeaders = getBillingAccountOpenOrders(delegator, billingAccountId); \n\n        if (orderHeaders != null) {\n            Iterator ohi = orderHeaders.iterator();\n            while (ohi.hasNext()) {\n                GenericValue orderHeader = (GenericValue) ohi.next();\n                OrderReadHelper orh = new OrderReadHelper(orderHeader);\n                balance = balance.add(orh.getOrderGrandTotalBd());\n            }\n        }\n\n        // set the balance to BillingAccount.accountLimit if it is greater.  This is necessary because nowhere do we track the amount of BillingAccount\n        // to be charged to an order, such as FinAccountAuth entity does for FinAccount.  As a result, we must assume that the system is doing things correctly\n        // and use the accountLimit\n        BigDecimal accountLimit = new BigDecimal(billingAccount.getDouble(\"accountLimit\").doubleValue());\n        if (balance.compareTo(accountLimit) == 1) {\n            balance = accountLimit;\n        } else {\n            balance = balance.setScale(decimals, rounding);    \n        }\n        return balance;\n         */\n    }","id":43332,"modified_method":"public static BigDecimal getBillingAccountBalance(GenericValue billingAccount) throws GenericEntityException {\n        \n        GenericDelegator delegator = billingAccount.getDelegator();\n        String billingAccountId = billingAccount.getString(\"billingAccountId\");\n\n        BigDecimal balance = ZERO;\n        BigDecimal accountLimit = getAccountLimit(billingAccount);\n        balance = balance.add(accountLimit);\n        // pending (not cancelled, rejected, or received) order payments\n        EntityConditionList whereConditions = new EntityConditionList(UtilMisc.toList(\n                new EntityExpr(\"billingAccountId\", EntityOperator.EQUALS, billingAccountId),\n                new EntityExpr(\"paymentMethodTypeId\", EntityOperator.EQUALS, \"EXT_BILLACT\"),\n                new EntityExpr(\"statusId\", EntityOperator.NOT_IN, UtilMisc.toList(\"ORDER_CANCELLED\", \"ORDER_REJECTED\")),\n                new EntityExpr(\"preferenceStatusId\", EntityOperator.NOT_IN, UtilMisc.toList(\"PAYMENT_SETTLED\", \"PAYMENT_RECEIVED\", \"PAYMENT_DECLINED\", \"PAYMENT_CANCELLED\")) // PAYMENT_NOT_AUTH\n            ), EntityOperator.AND); \n\n        List orderPaymentPreferenceSums = delegator.findByCondition(\"OrderPurchasePaymentSummary\", whereConditions, null, UtilMisc.toList(\"maxAmount\"), null, null);\n        if (orderPaymentPreferenceSums != null) {\n            for (Iterator oppsi = orderPaymentPreferenceSums.iterator(); oppsi.hasNext(); ) {\n                GenericValue orderPaymentPreferenceSum = (GenericValue) oppsi.next();\n                balance = balance.subtract(orderPaymentPreferenceSum.getBigDecimal(\"maxAmount\"));\n            }\n        }\n\n        List paymentAppls = delegator.findByAnd(\"PaymentApplication\", UtilMisc.toMap(\"billingAccountId\", billingAccountId));\n        // TODO: cancelled payments?\n        if (paymentAppls != null) {\n            for (Iterator pAi = paymentAppls.iterator(); pAi.hasNext(); ) {\n                GenericValue paymentAppl = (GenericValue) pAi.next();\n                if (paymentAppl.getString(\"invoiceId\") == null) {\n                    BigDecimal amountApplied = paymentAppl.getBigDecimal(\"amountApplied\");\n                    balance = balance.add(amountApplied);\n                }\n            }\n        }\n    \n        balance = balance.setScale(decimals, rounding);\n        return balance;\n        /*\n        GenericDelegator delegator = billingAccount.getDelegator();\n        String billingAccountId = billingAccount.getString(\"billingAccountId\");\n        \n        // first get the net balance of invoices - payments\n        BigDecimal balance = getBillingAccountNetBalance(delegator, billingAccountId);\n        \n        // now the amounts of all the pending orders (not cancelled, rejected or completed)\n        List orderHeaders = getBillingAccountOpenOrders(delegator, billingAccountId); \n\n        if (orderHeaders != null) {\n            Iterator ohi = orderHeaders.iterator();\n            while (ohi.hasNext()) {\n                GenericValue orderHeader = (GenericValue) ohi.next();\n                OrderReadHelper orh = new OrderReadHelper(orderHeader);\n                balance = balance.add(orh.getOrderGrandTotalBd());\n            }\n        }\n\n        // set the balance to BillingAccount.accountLimit if it is greater.  This is necessary because nowhere do we track the amount of BillingAccount\n        // to be charged to an order, such as FinAccountAuth entity does for FinAccount.  As a result, we must assume that the system is doing things correctly\n        // and use the accountLimit\n        BigDecimal accountLimit = new BigDecimal(billingAccount.getDouble(\"accountLimit\").doubleValue());\n        if (balance.compareTo(accountLimit) == 1) {\n            balance = accountLimit;\n        } else {\n            balance = balance.setScale(decimals, rounding);    \n        }\n        return balance;\n         */\n    }","commit_id":"11ed296d1291468e6c0c632ca13b1d8d34264339","url":"https://github.com/apache/ofbiz"},{"original_method":"@Test\n\tpublic void testQueryForObjectWithBigInteger() throws Exception {\n\t\tString sql = \"SELECT AGE FROM CUSTMR WHERE ID = 3\";\n\t\tgiven(this.resultSet.next()).willReturn(true, false);\n\t\tgiven(this.resultSet.getObject(1)).willReturn(\"22\");\n\t\tassertEquals(new BigInteger(\"22\"), this.template.queryForObject(sql, BigInteger.class));\n\t\tverify(this.resultSet).close();\n\t\tverify(this.statement).close();\n\t}","id":43333,"modified_method":"@Test\n\tpublic void testQueryForObjectWithBigInteger() throws Exception {\n\t\tString sql = \"SELECT AGE FROM CUSTMR WHERE ID = 3\";\n\t\tgiven(this.resultSet.next()).willReturn(true, false);\n\t\tgiven(this.resultSet.getObject(1, BigInteger.class)).willReturn(new BigInteger(\"22\"));\n\t\tassertEquals(new BigInteger(\"22\"), this.template.queryForObject(sql, BigInteger.class));\n\t\tverify(this.resultSet).close();\n\t\tverify(this.statement).close();\n\t}","commit_id":"37679384e82554250c87918ad042e7cfb3825813","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * This implementation creates a JDBC 3.0 Savepoint and returns it.\n\t * @see java.sql.Connection#setSavepoint\n\t */\n\t@Override\n\tpublic Object createSavepoint() throws TransactionException {\n\t\tConnectionHolder conHolder = getConnectionHolderForSavepoint();\n\t\ttry {\n\t\t\tif (!conHolder.supportsSavepoints()) {\n\t\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\t\"Cannot create a nested transaction because savepoints are not supported by your JDBC driver\");\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\"Cannot create a nested transaction because your JDBC driver is not a JDBC 3.0 driver\", ex);\n\t\t}\n\t\ttry {\n\t\t\treturn conHolder.createSavepoint();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new CannotCreateTransactionException(\"Could not create JDBC savepoint\", ex);\n\t\t}\n\t}","id":43334,"modified_method":"/**\n\t * This implementation creates a JDBC 3.0 Savepoint and returns it.\n\t * @see java.sql.Connection#setSavepoint\n\t */\n\t@Override\n\tpublic Object createSavepoint() throws TransactionException {\n\t\tConnectionHolder conHolder = getConnectionHolderForSavepoint();\n\t\ttry {\n\t\t\tif (!conHolder.supportsSavepoints()) {\n\t\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\t\"Cannot create a nested transaction because savepoints are not supported by your JDBC driver\");\n\t\t\t}\n\t\t\treturn conHolder.createSavepoint();\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow new CannotCreateTransactionException(\"Could not create JDBC savepoint\", ex);\n\t\t}\n\t}","commit_id":"37679384e82554250c87918ad042e7cfb3825813","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Retrieve a JDBC column value from a ResultSet, using the most appropriate\n\t * value type. The returned value should be a detached value object, not having\n\t * any ties to the active ResultSet: in particular, it should not be a Blob or\n\t * Clob object but rather a byte array respectively String representation.\n\t * <p>Uses the {@code getObject(index)} method, but includes additional \"hacks\"\n\t * to get around Oracle 10g returning a non-standard object for its TIMESTAMP\n\t * datatype and a {@code java.sql.Date} for DATE columns leaving out the\n\t * time portion: These columns will explicitly be extracted as standard\n\t * {@code java.sql.Timestamp} object.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the value object\n\t * @throws SQLException if thrown by the JDBC API\n\t * @see java.sql.Blob\n\t * @see java.sql.Clob\n\t * @see java.sql.Timestamp\n\t */\n\tpublic static Object getResultSetValue(ResultSet rs, int index) throws SQLException {\n\t\tObject obj = rs.getObject(index);\n\t\tString className = null;\n\t\tif (obj != null) {\n\t\t\tclassName = obj.getClass().getName();\n\t\t}\n\t\tif (obj instanceof Blob) {\n\t\t\tobj = rs.getBytes(index);\n\t\t}\n\t\telse if (obj instanceof Clob) {\n\t\t\tobj = rs.getString(index);\n\t\t}\n\t\telse if (className != null &&\n\t\t\t\t(\"oracle.sql.TIMESTAMP\".equals(className) ||\n\t\t\t\t\"oracle.sql.TIMESTAMPTZ\".equals(className))) {\n\t\t\tobj = rs.getTimestamp(index);\n\t\t}\n\t\telse if (className != null && className.startsWith(\"oracle.sql.DATE\")) {\n\t\t\tString metaDataClassName = rs.getMetaData().getColumnClassName(index);\n\t\t\tif (\"java.sql.Timestamp\".equals(metaDataClassName) ||\n\t\t\t\t\t\"oracle.sql.TIMESTAMP\".equals(metaDataClassName)) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj = rs.getDate(index);\n\t\t\t}\n\t\t}\n\t\telse if (obj != null && obj instanceof java.sql.Date) {\n\t\t\tif (\"java.sql.Timestamp\".equals(rs.getMetaData().getColumnClassName(index))) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}","id":43335,"modified_method":"/**\n\t * Retrieve a JDBC column value from a ResultSet, using the most appropriate\n\t * value type. The returned value should be a detached value object, not having\n\t * any ties to the active ResultSet: in particular, it should not be a Blob or\n\t * Clob object but rather a byte array respectively String representation.\n\t * <p>Uses the {@code getObject(index)} method, but includes additional \"hacks\"\n\t * to get around Oracle 10g returning a non-standard object for its TIMESTAMP\n\t * datatype and a {@code java.sql.Date} for DATE columns leaving out the\n\t * time portion: These columns will explicitly be extracted as standard\n\t * {@code java.sql.Timestamp} object.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the value object\n\t * @throws SQLException if thrown by the JDBC API\n\t * @see java.sql.Blob\n\t * @see java.sql.Clob\n\t * @see java.sql.Timestamp\n\t */\n\tpublic static Object getResultSetValue(ResultSet rs, int index) throws SQLException {\n\t\tObject obj = rs.getObject(index);\n\t\tString className = null;\n\t\tif (obj != null) {\n\t\t\tclassName = obj.getClass().getName();\n\t\t}\n\t\tif (obj instanceof Blob) {\n\t\t\tobj = rs.getBytes(index);\n\t\t}\n\t\telse if (obj instanceof Clob) {\n\t\t\tobj = rs.getString(index);\n\t\t}\n\t\telse if (\"oracle.sql.TIMESTAMP\".equals(className) || \"oracle.sql.TIMESTAMPTZ\".equals(className)) {\n\t\t\tobj = rs.getTimestamp(index);\n\t\t}\n\t\telse if (className != null && className.startsWith(\"oracle.sql.DATE\")) {\n\t\t\tString metaDataClassName = rs.getMetaData().getColumnClassName(index);\n\t\t\tif (\"java.sql.Timestamp\".equals(metaDataClassName) || \"oracle.sql.TIMESTAMP\".equals(metaDataClassName)) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj = rs.getDate(index);\n\t\t\t}\n\t\t}\n\t\telse if (obj != null && obj instanceof java.sql.Date) {\n\t\t\tif (\"java.sql.Timestamp\".equals(rs.getMetaData().getColumnClassName(index))) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}","commit_id":"37679384e82554250c87918ad042e7cfb3825813","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Retrieve a JDBC column value from a ResultSet, using the specified value type.\n\t * <p>Uses the specifically typed ResultSet accessor methods, falling back to\n\t * {@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types.\n\t * <p>Note that the returned value may not be assignable to the specified\n\t * required type, in case of an unknown type. Calling code needs to deal\n\t * with this case appropriately, e.g. throwing a corresponding exception.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the required value type (may be {@code null})\n\t * @return the value object\n\t * @throws SQLException if thrown by the JDBC API\n\t */\n\tpublic static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {\n\t\tif (requiredType == null) {\n\t\t\treturn getResultSetValue(rs, index);\n\t\t}\n\n\t\tObject value = null;\n\t\tboolean wasNullCheck = false;\n\n\t\t// Explicitly extract typed value, as far as possible.\n\t\tif (String.class.equals(requiredType)) {\n\t\t\tvalue = rs.getString(index);\n\t\t}\n\t\telse if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {\n\t\t\tvalue = rs.getBoolean(index);\n\t\t\twasNullCheck = true;\n\t\t}\n\t\telse if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {\n\t\t\tvalue = rs.getByte(index);\n\t\t\twasNullCheck = true;\n\t\t}\n\t\telse if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {\n\t\t\tvalue = rs.getShort(index);\n\t\t\twasNullCheck = true;\n\t\t}\n\t\telse if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {\n\t\t\tvalue = rs.getInt(index);\n\t\t\twasNullCheck = true;\n\t\t}\n\t\telse if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {\n\t\t\tvalue = rs.getLong(index);\n\t\t\twasNullCheck = true;\n\t\t}\n\t\telse if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {\n\t\t\tvalue = rs.getFloat(index);\n\t\t\twasNullCheck = true;\n\t\t}\n\t\telse if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||\n\t\t\t\tNumber.class.equals(requiredType)) {\n\t\t\tvalue = rs.getDouble(index);\n\t\t\twasNullCheck = true;\n\t\t}\n\t\telse if (byte[].class.equals(requiredType)) {\n\t\t\tvalue = rs.getBytes(index);\n\t\t}\n\t\telse if (java.sql.Date.class.equals(requiredType)) {\n\t\t\tvalue = rs.getDate(index);\n\t\t}\n\t\telse if (java.sql.Time.class.equals(requiredType)) {\n\t\t\tvalue = rs.getTime(index);\n\t\t}\n\t\telse if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {\n\t\t\tvalue = rs.getTimestamp(index);\n\t\t}\n\t\telse if (BigDecimal.class.equals(requiredType)) {\n\t\t\tvalue = rs.getBigDecimal(index);\n\t\t}\n\t\telse if (Blob.class.equals(requiredType)) {\n\t\t\tvalue = rs.getBlob(index);\n\t\t}\n\t\telse if (Clob.class.equals(requiredType)) {\n\t\t\tvalue = rs.getClob(index);\n\t\t}\n\t\telse {\n\t\t\t// Some unknown type desired -> rely on getObject.\n\t\t\tvalue = getResultSetValue(rs, index);\n\t\t}\n\n\t\t// Perform was-null check if demanded (for results that the\n\t\t// JDBC driver returns as primitives).\n\t\tif (wasNullCheck && value != null && rs.wasNull()) {\n\t\t\tvalue = null;\n\t\t}\n\t\treturn value;\n\t}","id":43336,"modified_method":"/**\n\t * Retrieve a JDBC column value from a ResultSet, using the specified value type.\n\t * <p>Uses the specifically typed ResultSet accessor methods, falling back to\n\t * {@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types.\n\t * <p>Note that the returned value may not be assignable to the specified\n\t * required type, in case of an unknown type. Calling code needs to deal\n\t * with this case appropriately, e.g. throwing a corresponding exception.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the required value type (may be {@code null})\n\t * @return the value object\n\t * @throws SQLException if thrown by the JDBC API\n\t */\n\tpublic static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {\n\t\tif (requiredType == null) {\n\t\t\treturn getResultSetValue(rs, index);\n\t\t}\n\n\t\tObject value;\n\n\t\t// Explicitly extract typed value, as far as possible.\n\t\tif (String.class.equals(requiredType)) {\n\t\t\treturn rs.getString(index);\n\t\t}\n\t\telse if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {\n\t\t\tvalue = rs.getBoolean(index);\n\t\t}\n\t\telse if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {\n\t\t\tvalue = rs.getByte(index);\n\t\t}\n\t\telse if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {\n\t\t\tvalue = rs.getShort(index);\n\t\t}\n\t\telse if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {\n\t\t\tvalue = rs.getInt(index);\n\t\t}\n\t\telse if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {\n\t\t\tvalue = rs.getLong(index);\n\t\t}\n\t\telse if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {\n\t\t\tvalue = rs.getFloat(index);\n\t\t}\n\t\telse if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||\n\t\t\t\tNumber.class.equals(requiredType)) {\n\t\t\tvalue = rs.getDouble(index);\n\t\t}\n\t\telse if (BigDecimal.class.equals(requiredType)) {\n\t\t\treturn rs.getBigDecimal(index);\n\t\t}\n\t\telse if (java.sql.Date.class.equals(requiredType)) {\n\t\t\treturn rs.getDate(index);\n\t\t}\n\t\telse if (java.sql.Time.class.equals(requiredType)) {\n\t\t\treturn rs.getTime(index);\n\t\t}\n\t\telse if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {\n\t\t\treturn rs.getTimestamp(index);\n\t\t}\n\t\telse if (byte[].class.equals(requiredType)) {\n\t\t\treturn rs.getBytes(index);\n\t\t}\n\t\telse if (Blob.class.equals(requiredType)) {\n\t\t\treturn rs.getBlob(index);\n\t\t}\n\t\telse if (Clob.class.equals(requiredType)) {\n\t\t\treturn rs.getClob(index);\n\t\t}\n\t\telse {\n\t\t\t// Some unknown type desired -> rely on getObject.\n\t\t\tif (getObjectWithTypeAvailable) {\n\t\t\t\ttry {\n\t\t\t\t\treturn rs.getObject(index, requiredType);\n\t\t\t\t}\n\t\t\t\tcatch (SQLFeatureNotSupportedException ex) {\n\t\t\t\t\tlogger.debug(\"JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method\", ex);\n\t\t\t\t}\n\t\t\t\tcatch (AbstractMethodError err) {\n\t\t\t\t\tlogger.debug(\"JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method\", err);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Fall back to getObject without type specification...\n\t\t\treturn getResultSetValue(rs, index);\n\t\t}\n\n\t\t// Perform was-null check if necessary (for results that the JDBC driver returns as primitives).\n\t\treturn (rs.wasNull() ? null : value);\n\t}","commit_id":"37679384e82554250c87918ad042e7cfb3825813","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Return whether the given JDBC driver supports JDBC 2.0 batch updates.\n\t * <p>Typically invoked right before execution of a given set of statements:\n\t * to decide whether the set of SQL statements should be executed through\n\t * the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion.\n\t * <p>Logs a warning if the \"supportsBatchUpdates\" methods throws an exception\n\t * and simply returns {@code false} in that case.\n\t * @param con the Connection to check\n\t * @return whether JDBC 2.0 batch updates are supported\n\t * @see java.sql.DatabaseMetaData#supportsBatchUpdates()\n\t */\n\tpublic static boolean supportsBatchUpdates(Connection con) {\n\t\ttry {\n\t\t\tDatabaseMetaData dbmd = con.getMetaData();\n\t\t\tif (dbmd != null) {\n\t\t\t\tif (dbmd.supportsBatchUpdates()) {\n\t\t\t\t\tlogger.debug(\"JDBC driver supports batch updates\");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(\"JDBC driver does not support batch updates\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tlogger.debug(\"JDBC driver 'supportsBatchUpdates' method threw exception\", ex);\n\t\t}\n\t\tcatch (AbstractMethodError err) {\n\t\t\tlogger.debug(\"JDBC driver does not support JDBC 2.0 'supportsBatchUpdates' method\", err);\n\t\t}\n\t\treturn false;\n\t}","id":43337,"modified_method":"/**\n\t * Return whether the given JDBC driver supports JDBC 2.0 batch updates.\n\t * <p>Typically invoked right before execution of a given set of statements:\n\t * to decide whether the set of SQL statements should be executed through\n\t * the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion.\n\t * <p>Logs a warning if the \"supportsBatchUpdates\" methods throws an exception\n\t * and simply returns {@code false} in that case.\n\t * @param con the Connection to check\n\t * @return whether JDBC 2.0 batch updates are supported\n\t * @see java.sql.DatabaseMetaData#supportsBatchUpdates()\n\t */\n\tpublic static boolean supportsBatchUpdates(Connection con) {\n\t\ttry {\n\t\t\tDatabaseMetaData dbmd = con.getMetaData();\n\t\t\tif (dbmd != null) {\n\t\t\t\tif (dbmd.supportsBatchUpdates()) {\n\t\t\t\t\tlogger.debug(\"JDBC driver supports batch updates\");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(\"JDBC driver does not support batch updates\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tlogger.debug(\"JDBC driver 'supportsBatchUpdates' method threw exception\", ex);\n\t\t}\n\t\treturn false;\n\t}","commit_id":"37679384e82554250c87918ad042e7cfb3825813","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tpublic PreparedStatement createPreparedStatement(Connection con) throws SQLException {\n\t\t\tPreparedStatement ps;\n\t\t\tif (generatedKeysColumnNames != null || returnGeneratedKeys) {\n\t\t\t\ttry {\n\t\t\t\t\tif (generatedKeysColumnNames != null) {\n\t\t\t\t\t\tps = con.prepareStatement(this.actualSql, generatedKeysColumnNames);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tps = con.prepareStatement(this.actualSql, PreparedStatement.RETURN_GENERATED_KEYS);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (AbstractMethodError err) {\n\t\t\t\t\tthrow new InvalidDataAccessResourceUsageException(\n\t\t\t\t\t\t\t\"Your JDBC driver is not compliant with JDBC 3.0 - \" +\n\t\t\t\t\t\t\t\"it does not support retrieval of auto-generated keys\", err);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (resultSetType == ResultSet.TYPE_FORWARD_ONLY && !updatableResults) {\n\t\t\t\tps = con.prepareStatement(this.actualSql);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps = con.prepareStatement(this.actualSql, resultSetType,\n\t\t\t\t\tupdatableResults ? ResultSet.CONCUR_UPDATABLE : ResultSet.CONCUR_READ_ONLY);\n\t\t\t}\n\t\t\tsetValues(ps);\n\t\t\treturn ps;\n\t\t}","id":43338,"modified_method":"@Override\n\t\tpublic PreparedStatement createPreparedStatement(Connection con) throws SQLException {\n\t\t\tPreparedStatement ps;\n\t\t\tif (generatedKeysColumnNames != null || returnGeneratedKeys) {\n\t\t\t\tif (generatedKeysColumnNames != null) {\n\t\t\t\t\tps = con.prepareStatement(this.actualSql, generatedKeysColumnNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps = con.prepareStatement(this.actualSql, PreparedStatement.RETURN_GENERATED_KEYS);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (resultSetType == ResultSet.TYPE_FORWARD_ONLY && !updatableResults) {\n\t\t\t\tps = con.prepareStatement(this.actualSql);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps = con.prepareStatement(this.actualSql, resultSetType,\n\t\t\t\t\tupdatableResults ? ResultSet.CONCUR_UPDATABLE : ResultSet.CONCUR_READ_ONLY);\n\t\t\t}\n\t\t\tsetValues(ps);\n\t\t\treturn ps;\n\t\t}","commit_id":"37679384e82554250c87918ad042e7cfb3825813","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Reduces two subtrees together.  In this case, the implementation of the tree reduce\n     * is exactly the same as the implementation of the single reduce.\n     */\n    public Integer reduce(Integer value, Integer sum) {\n        return value + sum;\n    }","id":43339,"modified_method":"public Integer reduce(Integer value, Integer sum) {\n        return value + sum;\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void execute( Walker walker, List<GenomeLoc> intervals ) {\n        // Fast fail for walkers not supporting TreeReducible interface.\n        if( !(walker instanceof TreeReducible) )\n            throw new IllegalArgumentException(\"Hierarchical microscheduler only works with TreeReducible walkers\");\n\n        ShardStrategy shardStrategy = getShardStrategy( reference, intervals );\n        SAMDataSource dataSource = getReadsDataSource();\n\n        ReduceTree reduceTree = new ReduceTree( this );        \n\n        walker.initialize();\n        \n        for(Shard shard: shardStrategy)\n            traverseTasks.add(shard);\n\n        while( isShardTraversePending() || isTreeReducePending() ) {\n            waitForFreeQueueSlot();\n\n            if( isTreeReduceReady() )\n                queueNextTreeReduce( walker );\n            else {\n                Future traverseResult = queueNextShardTraverse( walker, dataSource );\n\n                // Add this traverse result to the reduce tree.  The reduce tree will call a callback to throw its entries on the queue.\n                reduceTree.addEntry( traverseResult );\n\n                // No more data?  Let the reduce tree know so it can finish processing what it's got.\n                if( !isShardTraversePending() )\n                    reduceTree.complete();\n            }\n        }\n\n        Object result = reduceTree.getResult();\n        \n        traversalEngine.printOnTraversalDone(\"loci\", result);\n        walker.onTraversalDone(result);\n    }","id":43340,"modified_method":"public void execute( Walker walker, List<GenomeLoc> intervals ) {\n        // Fast fail for walkers not supporting TreeReducible interface.\n        if( !(walker instanceof TreeReducible) )\n            throw new IllegalArgumentException(\"Hierarchical microscheduler only works with TreeReducible walkers\");\n\n        ShardStrategy shardStrategy = getShardStrategy( reference, intervals );\n        SAMDataSource dataSource = getReadsDataSource();\n\n        ReduceTree reduceTree = new ReduceTree( this );        \n\n        walker.initialize();\n        \n        for(Shard shard: shardStrategy)\n            traverseTasks.add(shard);\n\n        while( isShardTraversePending() || isTreeReducePending() || isOutputMergePending() ) {\n            waitForFreeQueueSlot();\n\n            if( isTreeReduceReady() )\n                queueNextTreeReduce( walker );\n            else if( isShardTraversePending() ) {\n                Future traverseResult = queueNextShardTraverse( walker, dataSource );\n\n                // Add this traverse result to the reduce tree.  The reduce tree will call a callback to throw its entries on the queue.\n                reduceTree.addEntry( traverseResult );\n\n                // No more data?  Let the reduce tree know so it can finish processing what it's got.\n                if( !isShardTraversePending() )\n                    reduceTree.complete();\n            }\n            else if( isOutputMergeReady() ) {\n                queueNextOutputMerge();\n            }\n        }\n\n        threadPool.shutdown();\n\n        Object result = null;\n        try {\n            result = reduceTree.getResult().get();\n        }\n        catch(Exception ex) {\n            throw new StingException(\"Unable to retrieve result\", ex );\n        }\n        \n        traversalEngine.printOnTraversalDone(\"loci\", result);\n        walker.onTraversalDone(result);\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Queues the next traversal of a walker from the traversal tasks queue.\n     * @param walker Walker to apply to the dataset.\n     * @param dataSource Source of the reads\n     */\n    protected Future queueNextShardTraverse( Walker walker, SAMDataSource dataSource ) {\n        if( traverseTasks.size() == 0 )\n            throw new IllegalStateException( \"Cannot traverse; no pending traversals exist.\");\n        ShardTraverser traverser = new ShardTraverser( traversalEngine,\n                                                       walker,\n                                                       traverseTasks.remove(),\n                                                       reference,\n                                                       dataSource );\n        return threadPool.submit(traverser);\n    }","id":43341,"modified_method":"/**\n     * Queues the next traversal of a walker from the traversal tasks queue.\n     * @param walker Walker to apply to the dataset.\n     * @param dataSource Source of the reads\n     */\n    protected Future queueNextShardTraverse( Walker walker, SAMDataSource dataSource ) {\n        if( traverseTasks.size() == 0 )\n            throw new IllegalStateException( \"Cannot traverse; no pending traversals exist.\");\n\n        ShardOutput shardOutput = new ShardOutput();\n\n        ShardTraverser traverser = new ShardTraverser( traversalEngine,\n                                                       walker,\n                                                       traverseTasks.remove(),\n                                                       reference,\n                                                       dataSource,\n                                                       shardOutput );\n\n        outputMergeTasks.add(new OutputMerger(shardOutput,\n                                              GenomeAnalysisTK.Instance.getOutputTracker().getGlobalOutStream(),\n                                              GenomeAnalysisTK.Instance.getOutputTracker().getGlobalErrStream()));\n\n        return threadPool.submit(traverser);\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets the error stream for the walker.\n     * @return Error stream; should be either file-backed or System.err.\n     */\n    public PrintStream getErrStream() {\n        return err;\n    }","id":43342,"modified_method":"/**\n     * Retrieve the most appropriate output stream for this thread.\n     * Will retrieve thread-local if available; otherwise, it'll read the\n     * global stream.\n     */\n    public OutputStream getErrStream() {\n        // Create an anonymous inner class which will just return the most\n        // appropriate OutputStream from those streams stored in this class.\n        return new RedirectingOutputStream(\n                new RedirectingOutputStream.OutputStreamProvider() {\n                    public OutputStream getOutputStream() {\n                        return localErr.get() != null ? localErr.get() : globalErr;\n                    }\n                } );\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets the output stream for the walker.\n     * @return Output stream; should be either file-backed or System.out.\n     */\n    public PrintStream getOutStream() {\n        return out;\n    }","id":43343,"modified_method":"/**\n     * Retrieve an output stream that will always return the most appropriate\n     * writer for this thread.\n     */\n    public OutputStream getOutStream() {\n        // Create an anonymous inner class which will just return the most\n        // appropriate OutputStream from those streams stored in this class.\n        return new RedirectingOutputStream(\n                new RedirectingOutputStream.OutputStreamProvider() {\n                    public OutputStream getOutputStream() {\n                        return localOut.get() != null ? localOut.get() : globalOut;\n                    }\n                } );\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create an object to manage output given filenames for the output and error files.\n     * If no files are specified, returns null.\n     * @param outFileName Name of the output file.\n     * @param errFileName Name of the error file.\n     */\n    public OutputTracker( String outFileName, String errFileName ) {\n        // If the two output streams match and are non-null, initialize them identically.\n        // Otherwise, initialize them separately.\n        if( outFileName != null && outFileName.equals(errFileName) ) {\n            FileOutputStream outputFile = prepareOutputFile( outFileName );\n            outFileStream = errFileStream = outputFile;\n            out = err = new PrintStream( outputFile );\n        }\n        else {\n            if( outFileName != null ) {\n                outFileStream = prepareOutputFile( outFileName );\n                out = new PrintStream( outFileStream );\n            }\n            else\n                out = System.out;\n\n            if( errFileName != null ) {\n                errFileStream = prepareOutputFile( errFileName );\n                err = new PrintStream( errFileStream );\n            }\n            else\n                err = System.err;\n        }\n    }","id":43344,"modified_method":"/**\n     * Create an object to manage output given filenames for the output and error files.\n     * If no files are specified, returns null.\n     * @param outFileName Name of the output file.\n     * @param errFileName Name of the error file.\n     */\n    public OutputTracker( String outFileName, String errFileName ) {\n        // If the two output streams match and are non-null, initialize them identically.\n        // Otherwise, initialize them separately.\n        if( outFileName != null && outFileName.equals(errFileName) ) {\n            FileOutputStream outputFile = prepareOutputFile( outFileName );\n            globalOut = globalErr = outputFile;\n        }\n        else {\n            globalOut = (outFileName != null) ? prepareOutputFile( outFileName ) : System.out;\n            globalErr = (errFileName != null) ? prepareOutputFile( errFileName ) : System.err;\n        }\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testIndependentStreams() throws FileNotFoundException {\n        OutputTracker ot = new OutputTracker(OUTPUT_FILENAME,ERROR_FILENAME);\n\n        final String OUTPUT_TEXT = \"out stream test\";\n        ot.getOutStream().append(OUTPUT_TEXT);\n\n        final String ERROR_TEXT = \"err stream test\";\n        ot.getErrStream().append(ERROR_TEXT);\n\n        Scanner outScanner = new Scanner(new File(OUTPUT_FILENAME));\n        String outText = outScanner.nextLine();\n        Assert.assertFalse(\"Out stream has too much data\", outScanner.hasNext());\n\n        Scanner errScanner = new Scanner(new File(ERROR_FILENAME));\n        String errText = errScanner.nextLine();\n        Assert.assertFalse(\"Err stream has too much data\", errScanner.hasNext());\n\n        Assert.assertEquals(\"OutputTracker: Written output text is incorrect\", outText, OUTPUT_TEXT);\n        Assert.assertEquals(\"OutputTracker: Written error text is incorrect\", errText, ERROR_TEXT);\n    }","id":43345,"modified_method":"@Test\n    public void testIndependentStreams() throws FileNotFoundException {\n        OutputTracker ot = new OutputTracker(OUTPUT_FILENAME,ERROR_FILENAME);\n\n        final String OUTPUT_TEXT = \"out stream test\";\n        PrintWriter outWriter = new PrintWriter(ot.getOutStream());\n        outWriter.append(OUTPUT_TEXT);\n        outWriter.close();\n\n        final String ERROR_TEXT = \"err stream test\";\n        PrintWriter errWriter = new PrintWriter(ot.getErrStream());\n        errWriter.append(ERROR_TEXT);\n        errWriter.close();\n\n        Scanner outScanner = new Scanner(new File(OUTPUT_FILENAME));\n        String outText = outScanner.nextLine();\n        Assert.assertFalse(\"Out stream has too much data\", outScanner.hasNext());\n\n        Scanner errScanner = new Scanner(new File(ERROR_FILENAME));\n        String errText = errScanner.nextLine();\n        Assert.assertFalse(\"Err stream has too much data\", errScanner.hasNext());\n\n        Assert.assertEquals(\"OutputTracker: Written output text is incorrect\", outText, OUTPUT_TEXT);\n        Assert.assertEquals(\"OutputTracker: Written error text is incorrect\", errText, ERROR_TEXT);\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testIdenticalInputsGetIdenticalResults() {\n        OutputTracker ot = new OutputTracker(OUTPUT_FILENAME,OUTPUT_FILENAME);\n        Assert.assertSame(\"OutputTracker: FileOutputStreams don't match\", ot.getOutFile(), ot.getErrFile());\n        Assert.assertSame(\"OutputTracker: PrintStreams don't match\", ot.getOutStream(), ot.getErrStream());\n    }","id":43346,"modified_method":"@Test\n    public void testIdenticalInputsGetIdenticalResults() {\n        OutputTracker ot = new OutputTracker(OUTPUT_FILENAME,OUTPUT_FILENAME);\n\n        Assert.assertTrue(\"OutputTracker: Output stream is of wrong type.\", ot.getOutStream() instanceof RedirectingOutputStream );\n        Assert.assertTrue(\"OutputTracker: Error stream is of wrong type.\", ot.getErrStream() instanceof RedirectingOutputStream );\n\n        RedirectingOutputStream outStream = (RedirectingOutputStream)ot.getOutStream();\n        RedirectingOutputStream errStream = (RedirectingOutputStream)ot.getErrStream();\n\n        Assert.assertSame(\"OutputTracker: PrintStreams don't match\", outStream.getBackingOutputStream(), errStream.getBackingOutputStream());\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testNullInputs() {\n        OutputTracker ot = new OutputTracker(null,null);\n        Assert.assertSame(\"OutputTracker: Output stream incorrectly initialized.\", System.out, ot.getOutStream());\n        Assert.assertSame(\"OutputTracker: Error stream incorrectly initialized.\", System.err, ot.getErrStream());\n    }","id":43347,"modified_method":"@Test\n    public void testNullInputs() {\n        OutputTracker ot = new OutputTracker(null,null);\n\n        Assert.assertTrue(\"OutputTracker: Output stream is of wrong type.\", ot.getOutStream() instanceof RedirectingOutputStream );\n        Assert.assertTrue(\"OutputTracker: Error stream is of wrong type.\", ot.getErrStream() instanceof RedirectingOutputStream );\n\n        RedirectingOutputStream outStream = (RedirectingOutputStream)ot.getOutStream();\n        RedirectingOutputStream errStream = (RedirectingOutputStream)ot.getErrStream();\n\n        Assert.assertSame(\"OutputTracker: Output stream incorrectly initialized.\", System.out, outStream.getBackingOutputStream());\n        Assert.assertSame(\"OutputTracker: Error stream incorrectly initialized.\", System.err, errStream.getBackingOutputStream());\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testOutputStreamAlone() throws FileNotFoundException {\n        OutputTracker ot = new OutputTracker(OUTPUT_FILENAME,null);\n\n        final String OUTPUT_TEXT = \"out stream test\";\n        ot.getOutStream().append(OUTPUT_TEXT);\n\n        Scanner outScanner = new Scanner(new File(OUTPUT_FILENAME));\n        String outText = outScanner.nextLine();\n        Assert.assertFalse(\"Out stream has too much data\", outScanner.hasNext());\n\n        Assert.assertEquals(\"OutputTracker: Written output is incorrect\", outText, OUTPUT_TEXT);\n        Assert.assertSame(\"OutputTracker: Error stream incorrectly initialized.\", System.err, ot.getErrStream());\n    }","id":43348,"modified_method":"@Test\n    public void testOutputStreamAlone() throws FileNotFoundException {\n        OutputTracker ot = new OutputTracker(OUTPUT_FILENAME,null);\n\n        final String OUTPUT_TEXT = \"out stream test\";\n        PrintWriter outWriter = new PrintWriter(ot.getOutStream());\n        outWriter.append(OUTPUT_TEXT);\n        outWriter.close();\n\n        Scanner outScanner = new Scanner(new File(OUTPUT_FILENAME));\n        String outText = outScanner.nextLine();\n        Assert.assertFalse(\"Out stream has too much data\", outScanner.hasNext());\n\n        Assert.assertEquals(\"OutputTracker: Written output is incorrect\", outText, OUTPUT_TEXT);\n\n        Assert.assertTrue(\"OutputTracker: Error stream is of wrong type.\", ot.getErrStream() instanceof RedirectingOutputStream );\n        RedirectingOutputStream errStream = (RedirectingOutputStream)ot.getErrStream();\n        Assert.assertSame(\"OutputTracker: Error stream incorrectly initialized.\", System.err, errStream.getBackingOutputStream());\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testErrorStreamAlone() throws FileNotFoundException {\n        OutputTracker ot = new OutputTracker(null,ERROR_FILENAME);\n\n        final String ERROR_TEXT = \"err stream test\";\n        ot.getErrStream().append(ERROR_TEXT);\n\n        Scanner errScanner = new Scanner(new File(ERROR_FILENAME));\n        String errText = errScanner.nextLine();\n        Assert.assertFalse(\"Err stream has too much data\", errScanner.hasNext());\n\n        Assert.assertSame(\"OutputTracker: Output stream incorrectly initialized.\", System.out, ot.getOutStream());\n        Assert.assertEquals(\"OutputTracker: Written error text is incorrect\", errText, ERROR_TEXT);\n    }","id":43349,"modified_method":"@Test\n    public void testErrorStreamAlone() throws FileNotFoundException {\n        OutputTracker ot = new OutputTracker(null,ERROR_FILENAME);\n\n        final String ERROR_TEXT = \"err stream test\";\n        PrintWriter errWriter = new PrintWriter(ot.getErrStream());\n        errWriter.append(ERROR_TEXT);\n        errWriter.close();\n\n        Scanner errScanner = new Scanner(new File(ERROR_FILENAME));\n        String errText = errScanner.nextLine();\n        Assert.assertFalse(\"Err stream has too much data\", errScanner.hasNext());\n\n        Assert.assertTrue(\"OutputTracker: Output stream is of wrong type.\", ot.getOutStream() instanceof RedirectingOutputStream );\n        RedirectingOutputStream outStream = (RedirectingOutputStream)ot.getOutStream();\n        Assert.assertSame(\"OutputTracker: Output stream incorrectly initialized.\", System.out, outStream.getBackingOutputStream());\n        Assert.assertEquals(\"OutputTracker: Written error text is incorrect\", errText, ERROR_TEXT);\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Object call() {\n        Object accumulator = ((LocusWalker<?,?>)walker).reduceInit();\n\n        MergingSamRecordIterator2 readShard = null;\n        try {\n            readShard = (MergingSamRecordIterator2)reads.seek( shard );\n        }\n        catch( SimpleDataSourceLoadException ex ) {\n            throw new RuntimeException( ex );\n        }\n\n        ReferenceProvider referenceProvider = new ReferenceProvider( reference, shard.getGenomeLoc() );\n        LocusContextProvider locusProvider = new LocusContextProvider( readShard );\n\n        accumulator = traversalEngine.traverse( walker, shard, referenceProvider, locusProvider, accumulator );\n\n        readShard.close();\n\n        return accumulator;\n    }","id":43350,"modified_method":"public Object call() {\n        Object accumulator = ((LocusWalker<?,?>)walker).reduceInit();\n\n        CloseableIterator<SAMRecord> readShard = null;\n        readShard = reads.seek( shard );\n\n        ReferenceProvider referenceProvider = new ReferenceProvider( reference, shard.getGenomeLoc() );\n        LocusContextProvider locusProvider = new LocusContextProvider( readShard );\n\n        OutputTracker outputTracker = GenomeAnalysisTK.Instance.getOutputTracker();\n\n        outputTracker.setLocalStreams( output.getOutStream(), output.getErrStream() );\n        try {\n            accumulator = traversalEngine.traverse( walker, shard, referenceProvider, locusProvider, accumulator );\n        }\n        finally {\n            readShard.close();\n\n            output.complete();\n            outputTracker.removeLocalStreams();            \n        }\n\n        return accumulator;\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ShardTraverser( TraverseLociByReference traversalEngine,\n                           Walker walker,\n                           Shard shard,\n                           IndexedFastaSequenceFile reference,\n                           SAMDataSource reads ) {\n        this.walker = walker;\n        this.traversalEngine = traversalEngine;\n        this.shard = shard;\n        this.reference = reference;\n        this.reads = reads;\n    }","id":43351,"modified_method":"public ShardTraverser( TraverseLociByReference traversalEngine,\n                           Walker walker,\n                           Shard shard,\n                           IndexedFastaSequenceFile reference,\n                           SAMDataSource reads,\n                           ShardOutput output ) {\n        this.walker = walker;\n        this.traversalEngine = traversalEngine;\n        this.shard = shard;\n        this.reference = reference;\n        this.reads = reads;\n        this.output = output;\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Returns the value of the reduce.  If not isReadyForReduce(), this call will until all entries become ready.\n     * @return Result of the reduce.\n     */\n    public Object call() {\n        try {\n            if( lhs == null )\n                return lhs.get();\n            else\n                return walker.reduce( lhs.get(), rhs.get() );\n        }\n        catch( InterruptedException ex ) {\n            throw new RuntimeException(\"Hierarchical reduce interrupted\", ex);\n        }\n        catch( ExecutionException ex ) {\n            throw new RuntimeException(\"Hierarchical reduce failed\", ex);\n        }\n    }","id":43352,"modified_method":"/**\n     * Returns the value of the reduce.  If not isReadyForReduce(), this call will until all entries become ready.\n     * @return Result of the reduce.\n     */\n    public Object call() {\n        try {\n            if( lhs == null )\n                return lhs.get();\n            else\n                return walker.treeReduce( lhs.get(), rhs.get() );\n        }\n        catch( InterruptedException ex ) {\n            throw new RuntimeException(\"Hierarchical reduce interrupted\", ex);\n        }\n        catch( ExecutionException ex ) {\n            throw new RuntimeException(\"Hierarchical reduce failed\", ex);\n        }\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected Walker() {\n\tif( GenomeAnalysisTK.Instance != null ) {\n\t    GenomeAnalysisTK.Instance.loadArgumentsIntoObject(this);\n\t    out = GenomeAnalysisTK.Instance.getWalkerOutputStream();\n\t    err = GenomeAnalysisTK.Instance.getWalkerErrorStream();\n\t}\n\telse {\n\t    out = System.out;\n\t    err = System.err;\n\t}\n    }","id":43353,"modified_method":"protected Walker() {\n        if( GenomeAnalysisTK.Instance != null ) {\n            GenomeAnalysisTK gatk = GenomeAnalysisTK.Instance;\n            gatk.loadArgumentsIntoObject(this);\n            out = new PrintStream( gatk.getOutputTracker().getOutStream() );\n            err = new PrintStream( gatk.getOutputTracker().getErrStream() );\n        }\n        else {\n            out = System.out;\n            err = System.err;\n        }\n    }","commit_id":"9f5f6f9bc75f9533c596398fd0fe731ca71b0159","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static void main(String[] args) {\n    final TachyonFuseOptions opts = parseOptions(args);\n    if (opts == null) {\n      System.exit(1);\n    }\n    final TachyonFuseFs fs = new TachyonFuseFs(opts);\n    final List<String> fuseOpts = opts.getFuseOpts();\n    fuseOpts.add(\"-odirect_io\");\n\n    try {\n      fs.mount(Paths.get(opts.getMountPoint()), true, opts.isDebug(),\n          fuseOpts.toArray(new String[0]));\n    } finally {\n      fs.umount();\n    }\n  }","id":43354,"modified_method":"public static void main(String[] args) {\n    final TachyonFuseOptions opts = parseOptions(args);\n    if (opts == null) {\n      System.exit(1);\n    }\n\n    sTachyonConf = ClientContext.getConf();\n    final TachyonFuseFs fs = new TachyonFuseFs(sTachyonConf, opts);\n    final List<String> fuseOpts = opts.getFuseOpts();\n    fuseOpts.add(\"-odirect_io\");\n\n    try {\n      fs.mount(Paths.get(opts.getMountPoint()), true, opts.isDebug(),\n          fuseOpts.toArray(new String[0]));\n    } finally {\n      fs.umount();\n    }\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Parses CLI options\n   * @param args CLI args\n   * @return Tachyon-FUSE configuration options\n   */\n  private static TachyonFuseOptions parseOptions(String[] args) {\n    final Options opts = new Options();\n    final Option mntPoint = Option.builder(\"m\")\n        .hasArg()\n        .required(false)\n        .longOpt(\"mount-point\")\n        .desc(\"Path where tachyon-fuse should be mounted.\")\n        .build();\n\n    final Option tachyonAddress = Option.builder(\"t\")\n        .hasArg()\n        .required(false)\n        .longOpt(\"tachyon-master\")\n        .desc(\"URI of the Tachyon Master (e.g. tachyon://localhost:19998/\")\n        .build();\n\n    final Option tachyonRoot = Option.builder(\"r\")\n        .hasArg()\n        .required(false)\n        .longOpt(\"tachyon-root\")\n        .desc(\"Path within tachyon that will be the root of the mount (e.g., /users/foo)\")\n        .build();\n\n    final Option help = Option.builder(\"h\")\n        .required(false)\n        .desc(\"Print this help\")\n        .build();\n\n    final Option debug = Option.builder(\"d\")\n        .required(false)\n        .longOpt(\"debug\")\n        .desc(\"Enable FUSE debug output\")\n        .build();\n\n    final Option fuseOption = Option.builder(\"o\")\n        .valueSeparator(',')\n        .required(false)\n        .hasArgs()\n        .desc(\"FUSE mount options\")\n        .build();\n\n    opts.addOption(mntPoint);\n    opts.addOption(tachyonAddress);\n    opts.addOption(tachyonRoot);\n    opts.addOption(help);\n    opts.addOption(debug);\n    opts.addOption(fuseOption);\n\n    final CommandLineParser parser = new DefaultParser();\n    try {\n      CommandLine cli = parser.parse(opts, args);\n\n      if (cli.hasOption(\"h\")) {\n        final HelpFormatter fmt = new HelpFormatter();\n        fmt.printHelp(TachyonFuse.class.getName(), opts);\n        return null;\n      }\n\n      String m = cli.getOptionValue(\"m\");\n      String t = cli.getOptionValue(\"t\");\n      String r = cli.getOptionValue(\"r\");\n      boolean d = cli.hasOption(\"d\");\n\n      List<String> fuseOpts;\n      if (cli.hasOption(\"o\")) {\n        String[] fopts = cli.getOptionValues(\"o\");\n        fuseOpts = new ArrayList<String>(fopts.length);\n        // keep the -o\n        for (int i = 0; i < fopts.length; i++) {\n          fuseOpts.add(\"-o\" + fopts[i]);\n        }\n      } else {\n        fuseOpts = Collections.emptyList();\n      }\n\n      if (m == null) {\n        LOG.info(\"Mounting on default {}\", TachyonFuse.DEFAULT_MOUNT_POINT);\n        m = TachyonFuse.DEFAULT_MOUNT_POINT;\n      }\n\n      if (t == null) {\n        LOG.info(\"Using default master address {}\", TachyonFuse.DEFAULT_MASTER_ADDR);\n        t = TachyonFuse.DEFAULT_MASTER_ADDR;\n      }\n\n      if (r == null) {\n        LOG.info(\"Using default tachyon root {}\", TachyonFuse.DEFAULT_ROOT);\n        r = TachyonFuse.DEFAULT_ROOT;\n      }\n\n      return new TachyonFuseOptions(m, t, r, d, fuseOpts);\n    } catch (ParseException e) {\n      System.err.println(\"Error while parsing CLI: \" + e.getMessage());\n      final HelpFormatter fmt = new HelpFormatter();\n      fmt.printHelp(TachyonFuse.class.getName(), opts);\n      return null;\n    }\n\n  }","id":43355,"modified_method":"/**\n   * Parses CLI options\n   * @param args CLI args\n   * @return Tachyon-FUSE configuration options\n   */\n  private static TachyonFuseOptions parseOptions(String[] args) {\n    final Options opts = new Options();\n    final Option mntPoint = Option.builder(\"m\")\n        .hasArg()\n        .required(false)\n        .longOpt(\"mount-point\")\n        .desc(\"Path where tachyon-fuse should be mounted.\")\n        .build();\n\n    final Option tachyonRoot = Option.builder(\"r\")\n        .hasArg()\n        .required(false)\n        .longOpt(\"tachyon-root\")\n        .desc(\"Path within tachyon that will be the root of the mount (e.g., /users/foo)\")\n        .build();\n\n    final Option help = Option.builder(\"h\")\n        .required(false)\n        .desc(\"Print this help\")\n        .build();\n\n    final Option fuseOption = Option.builder(\"o\")\n        .valueSeparator(',')\n        .required(false)\n        .hasArgs()\n        .desc(\"FUSE mount options\")\n        .build();\n\n    opts.addOption(mntPoint);\n    opts.addOption(tachyonRoot);\n    opts.addOption(help);\n    opts.addOption(fuseOption);\n\n    final CommandLineParser parser = new DefaultParser();\n    try {\n      CommandLine cli = parser.parse(opts, args);\n\n      if (cli.hasOption(\"h\")) {\n        final HelpFormatter fmt = new HelpFormatter();\n        fmt.printHelp(TachyonFuse.class.getName(), opts);\n        return null;\n      }\n\n      String mntPointValue = cli.getOptionValue(\"m\");\n      String tachyonRootValue = cli.getOptionValue(\"r\");\n\n      List<String> fuseOpts = Lists.newArrayList();\n      boolean noUserMaxWrite = true;\n      if (cli.hasOption(\"o\")) {\n        String[] fopts = cli.getOptionValues(\"o\");\n        // keep the -o\n        for (int i = 0; i < fopts.length; i++) {\n          fuseOpts.add(\"-o\" + fopts[i]);\n          if (noUserMaxWrite && fopts[i].startsWith(\"max_write\")) {\n            noUserMaxWrite = false;\n          }\n        }\n      }\n      // check if the user has specified his own max_write, otherwise get it\n      // from conf\n      if (noUserMaxWrite) {\n        final long maxWrite = sTachyonConf.getLong(Constants.FUSE_MAXWRITE_BYTES);\n        fuseOpts.add(String.format(\"-omax_write=%d\", maxWrite));\n      }\n\n      if (mntPointValue == null) {\n        mntPointValue = sTachyonConf.get(Constants.FUSE_DEFAULT_MOUNTPOINT);\n        LOG.info(\"Mounting on default {}\", mntPointValue);\n      }\n\n      if (tachyonRootValue == null) {\n        tachyonRootValue = sTachyonConf.get(Constants.FUSE_FS_ROOT);\n        LOG.info(\"Using default tachyon root {}\", tachyonRootValue);\n      }\n\n      final boolean fuseDebug = sTachyonConf.getBoolean(Constants.FUSE_DEBUG_ENABLE);\n\n      return new TachyonFuseOptions(mntPointValue, tachyonRootValue, fuseDebug, fuseOpts);\n    } catch (ParseException e) {\n      System.err.println(\"Error while parsing CLI: \" + e.getMessage());\n      final HelpFormatter fmt = new HelpFormatter();\n      fmt.printHelp(TachyonFuse.class.getName(), opts);\n      return null;\n    }\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"private int rmInternal(String path, boolean mustBeFile) {\n    int ret = 0;\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        LOG.error(\"File {} does not exist\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (mustBeFile && tfi.isFolder) {\n        LOG.error(\"File {} is a directory\", turi);\n        return -ErrorCodes.EISDIR();\n      }\n\n      mTFS.delete(tf);\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      ret = ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      ret = ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    }\n\n    return -ret;\n  }","id":43356,"modified_method":"/**\n   * Convenience internal method to remove files or directories.\n   * @param path The path to remove\n   * @param mustBeFile When true, returns an error when trying to\n   *                   remove a directory\n   * @return 0 on success, a negative value on error\n   */\n  private int rmInternal(String path, boolean mustBeFile) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        LOG.error(\"File {} does not exist\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (mustBeFile && tfi.isFolder) {\n        LOG.error(\"File {} is a directory\", turi);\n        return -ErrorCodes.EISDIR();\n      }\n\n      mTFS.delete(tf);\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int release(String path, FuseFileInfo fi) {\n    LOG.trace(\"release({})\", path);\n    final long fd = fi.fh.get();\n    OpenFileEntry oe = null;\n    synchronized (mOpenFilesLock) {\n      oe = mOpenFiles.remove(fd);\n      if (oe == null) {\n        LOG.error(\"Cannot find fd for {} in table\", path);\n        return -ErrorCodes.EBADFD();\n      }\n    }\n\n    if (oe.mIn != null) {\n      try {\n        oe.mIn.close();\n      } catch (IOException e) {\n        LOG.error(\"Failed closing {} [in]\", path, e);\n      }\n    }\n\n    if (oe.mOut != null) {\n      try {\n        LOG.trace(\"Closing file writer for {}\", path);\n        oe.mOut.close();\n      } catch (IOException e) {\n        LOG.error(\"Failed closing {} [out]\", path, e);\n      }\n    }\n\n    return 0;\n  }","id":43357,"modified_method":"/**\n   * Release the resources associated to an open file.\n   *\n   * Guaranteed to be called once for each open() or create().\n   * @param path the FS path of the file to release\n   * @param fi FileInfo data structure kept by FUSE\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int release(String path, FuseFileInfo fi) {\n    LOG.trace(\"release({})\", path);\n    final long fd = fi.fh.get();\n    OpenFileEntry oe = null;\n    synchronized (mOpenFiles) {\n      oe = mOpenFiles.remove(fd);\n      if (oe == null) {\n        LOG.error(\"Cannot find fd for {} in table\", path);\n        return -ErrorCodes.EBADFD();\n      }\n    }\n\n    if (oe.getIn() != null) {\n      try {\n        oe.getIn().close();\n      } catch (IOException e) {\n        LOG.error(\"Failed closing {} [in]\", path, e);\n      }\n    }\n\n    if (oe.getOut() != null) {\n      try {\n        LOG.trace(\"Closing file writer for {}\", path);\n        oe.getOut().close();\n      } catch (IOException e) {\n        LOG.error(\"Failed closing {} [out]\", path, e);\n      }\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"public TachyonFuseFs(TachyonFuseOptions opts) {\n    super();\n    mTFS = TachyonFileSystem.TachyonFileSystemFactory.get();\n    mMountPoint = Paths.get(opts.getMountPoint());\n    mTachyonMaster = opts.getMasterAddress();\n    mTachyonRootPath = Paths.get(opts.getTachyonRoot());\n    mOpenFileIds = 0L;\n    mOpenFiles = new HashMap<Long, OpenFileEntry>();\n    mOpenFilesLock = new Object();\n\n    mPathResolverCache = CacheBuilder.newBuilder()\n        .maximumSize(MAX_CACHED_PATHS)\n        .build(new PathCacheLoader());\n\n    Preconditions.checkArgument(mMountPoint.isAbsolute(),\n        \"mount point should be an absolute path\");\n    Preconditions.checkArgument(mTachyonRootPath.isAbsolute(),\n        \"tachyon root path should be absolute\");\n  }","id":43358,"modified_method":"TachyonFuseFs(TachyonConf conf, TachyonFuseOptions opts) {\n    super();\n    mTachyonConf = conf;\n    mTFS = TachyonFileSystemFactory.get();\n    mMountPoint = Paths.get(opts.getMountPoint());\n    mTachyonMaster = mTachyonConf.get(Constants.MASTER_ADDRESS);\n    mTachyonRootPath = Paths.get(opts.getTachyonRoot());\n    mNextOpenFileId = 0L;\n    mOpenFiles = Maps.newHashMap();\n\n    final int maxCachedPaths = mTachyonConf.getInt(Constants.FUSE_PATHCACHE_SIZE);\n    mPathResolverCache = CacheBuilder.newBuilder()\n        .maximumSize(maxCachedPaths)\n        .build(new PathCacheLoader());\n\n    Preconditions.checkArgument(mMountPoint.isAbsolute(),\n        \"mount point should be an absolute path\");\n    Preconditions.checkArgument(mTachyonRootPath.isAbsolute(),\n        \"tachyon root path should be absolute\");\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int read(String path, Pointer buf, @size_t long size, @off_t long offset,\n                  FuseFileInfo fi) {\n\n    if (size > Integer.MAX_VALUE) {\n      LOG.error(\"Cannot read more than Integer.MAX_VALUE\");\n      return ErrorCodes.EIO();\n    }\n    LOG.trace(\"read({}, {}, {})\", path, size, offset);\n    final int sz = (int) size;\n    final long fd = fi.fh.get();\n    OpenFileEntry oe = null;\n    synchronized (mOpenFilesLock) {\n      oe = mOpenFiles.get(fd);\n    }\n    if (oe == null) {\n      LOG.error(\"Cannot find fd for {} in table\", path);\n      return -ErrorCodes.EBADFD();\n    }\n\n    int rd = 0;\n    int nread = 0;\n    if (oe.mIn == null) {\n      LOG.error(\"{} was not open for reading\", path);\n      return -ErrorCodes.EBADFD();\n    }\n    try {\n      oe.mIn.seek(offset);\n      final byte[] dest = new byte[sz];\n      while (rd >= 0 && nread < size) {\n        rd = oe.mIn.read(dest, nread, sz - nread);\n        if (rd >= 0) {\n          nread += rd;\n        }\n      }\n\n      if (nread == -1) { // EOF\n        nread = 0;\n      } else if (nread > 0) {\n        buf.put(0, dest, 0, nread);\n      }\n    } catch (IOException e) {\n      LOG.error(\"IOException while reading from {}.\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return nread;\n\n  }","id":43359,"modified_method":"/**\n   * Read data from an open file.\n   * @param path the FS path of the file to read\n   * @param buf FUSE buffer to fill with data read\n   * @param size how many bytes to read\n   * @param offset offset of the read operation\n   * @param fi FileInfo data structure kept by FUSE\n   * @return the number of bytes read or 0 on EOF. A negative\n   *         value on error\n   */\n  @Override\n  public int read(String path, Pointer buf, @size_t long size, @off_t long offset,\n                  FuseFileInfo fi) {\n\n    if (size > Integer.MAX_VALUE) {\n      LOG.error(\"Cannot read more than Integer.MAX_VALUE\");\n      return -ErrorCodes.EINVAL();\n    }\n    LOG.trace(\"read({}, {}, {})\", path, size, offset);\n    final int sz = (int) size;\n    final long fd = fi.fh.get();\n    OpenFileEntry oe = null;\n    synchronized (mOpenFiles) {\n      oe = mOpenFiles.get(fd);\n    }\n    if (oe == null) {\n      LOG.error(\"Cannot find fd for {} in table\", path);\n      return -ErrorCodes.EBADFD();\n    }\n\n    int rd = 0;\n    int nread = 0;\n    if (oe.getIn() == null) {\n      LOG.error(\"{} was not open for reading\", path);\n      return -ErrorCodes.EBADFD();\n    }\n    try {\n      oe.getIn().seek(offset);\n      final byte[] dest = new byte[sz];\n      while (rd >= 0 && nread < size) {\n        rd = oe.getIn().read(dest, nread, sz - nread);\n        if (rd >= 0) {\n          nread += rd;\n        }\n      }\n\n      if (nread == -1) { // EOF\n        nread = 0;\n      } else if (nread > 0) {\n        buf.put(0, dest, 0, nread);\n      }\n    } catch (IOException e) {\n      LOG.error(\"IOException while reading from {}.\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return nread;\n\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public String getFSName() {\n    return \"tachyon-fuse\";\n  }","id":43360,"modified_method":"/**\n   * @return Name of the file system\n   */\n  @Override\n  public String getFSName() {\n    return \"tachyon-fuse\";\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int flush(String path, FuseFileInfo fi) {\n    LOG.trace(\"flush({})\", path);\n    final long fd = fi.fh.get();\n    OpenFileEntry oe = null;\n    synchronized (mOpenFilesLock) {\n      oe = mOpenFiles.get(fd);\n    }\n    if (oe == null) {\n      LOG.error(\"Cannot find fd for {} in table\", path);\n      return -ErrorCodes.EBADFD();\n    }\n    if (oe.mOut == null) {\n      LOG.error(\"{} was not open for writing\", path);\n      return -ErrorCodes.EBADFD();\n    }\n    try {\n      oe.mOut.flush();\n    } catch (IOException e) {\n      return -ErrorCodes.EIO();\n    }\n\n    return 0;\n  }","id":43361,"modified_method":"/**\n   * Flush chached data on Tachyon.\n   *\n   * Called on explicty sync() operation or at close().\n   * @param path The path on the FS of the file to close\n   * @param fi FileInfo data struct kept by FUSE\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int flush(String path, FuseFileInfo fi) {\n    LOG.trace(\"flush({})\", path);\n    final long fd = fi.fh.get();\n    OpenFileEntry oe = null;\n    synchronized (mOpenFiles) {\n      oe = mOpenFiles.get(fd);\n    }\n    if (oe == null) {\n      LOG.error(\"Cannot find fd for {} in table\", path);\n      return -ErrorCodes.EBADFD();\n    }\n    if (oe.getOut() == null) {\n      LOG.error(\"{} was not open for writing\", path);\n      return -ErrorCodes.EBADFD();\n    }\n    try {\n      oe.getOut().flush();\n    } catch (IOException e) {\n      return -ErrorCodes.EIO();\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int rmdir(String path) {\n    LOG.trace(\"rmdir({})\", path);\n    return rmInternal(path, false);\n  }","id":43362,"modified_method":"/**\n   * Delete an empty directory.\n   * @param path The FS path of the directory\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int rmdir(String path) {\n    LOG.trace(\"rmdir({})\", path);\n    return rmInternal(path, false);\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int rename(String oldPath, String newPath) {\n    int ret = 0;\n    final TachyonURI oldUri = mPathResolverCache.getUnchecked(oldPath);\n    final TachyonURI newUri = mPathResolverCache.getUnchecked(newPath);\n    LOG.trace(\"rename({}, {}) [Tachyon: {}, {}]\", oldPath, newPath, oldUri, newUri);\n\n    try {\n      final TachyonFile oldFile = mTFS.openIfExists(oldUri);\n      if (oldFile == null) {\n        LOG.error(\"File {} does not exist\", oldPath);\n        ret = ErrorCodes.ENOENT();\n      } else {\n        mTFS.rename(oldFile, newUri);\n      }\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File {} does not exist\", oldPath);\n      ret = ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException while moving {} to {}\", oldPath, newPath, e);\n      ret = ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"Exception while moving {} to {}\", oldPath, newPath, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on mv {} {}\", oldPath, newPath, e);\n      ret = ErrorCodes.EFAULT();\n    }\n\n    return -ret;\n  }","id":43363,"modified_method":"/**\n   * Rename a path\n   * @param oldPath the source path in the FS\n   * @param newPath the destination path in the FS\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int rename(String oldPath, String newPath) {\n    final TachyonURI oldUri = mPathResolverCache.getUnchecked(oldPath);\n    final TachyonURI newUri = mPathResolverCache.getUnchecked(newPath);\n    LOG.trace(\"rename({}, {}) [Tachyon: {}, {}]\", oldPath, newPath, oldUri, newUri);\n\n    try {\n      final TachyonFile oldFile = mTFS.openIfExists(oldUri);\n      if (oldFile == null) {\n        LOG.error(\"File {} does not exist\", oldPath);\n        return -ErrorCodes.ENOENT();\n      } else {\n        mTFS.rename(oldFile, newUri);\n      }\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File {} does not exist\", oldPath);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException while moving {} to {}\", oldPath, newPath, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"Exception while moving {} to {}\", oldPath, newPath, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on mv {} {}\", oldPath, newPath, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int mkdir(String path, @mode_t long mode) {\n    int ret = 0;\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"mkdir({}) [Tachyon: {}]\", path, turi);\n    LOG.warn(\"{}: mode is ignored in tachyon-fuse\", path);\n    try {\n      mTFS.mkdir(turi);\n    } catch (FileAlreadyExistsException e) {\n      LOG.debug(\"Cannot make dir. {} already exists\", path, e);\n      ret = ErrorCodes.EEXIST();\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Cannot make dir. Invalid path: {}\", path, e);\n      ret = ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"Cannot make dir. IOException: {}\", path, e);\n      ret = ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"Cannot make dir. {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    }\n\n    return -ret;\n  }","id":43364,"modified_method":"/**\n   * Create a new dir.\n   * @param path the path on the FS of the new dir\n   * @param mode Dir creation flags (IGNORED)\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int mkdir(String path, @mode_t long mode) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"mkdir({}) [Tachyon: {}]\", path, turi);\n    try {\n      mTFS.mkdir(turi);\n    } catch (FileAlreadyExistsException e) {\n      LOG.debug(\"Cannot make dir. {} already exists\", path, e);\n      return -ErrorCodes.EEXIST();\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Cannot make dir. Invalid path: {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"Cannot make dir. IOException: {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"Cannot make dir. {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int getattr(String path, FileStat stat) {\n    int ret = 0;\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"getattr({}) [Tachyon: {}]\", path, turi);\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        ret = ErrorCodes.ENOENT();\n      } else {\n        final FileInfo fi = mTFS.getInfo(tf);\n        stat.st_size.set(fi.getLength());\n\n        final long ctime = fi.getLastModificationTimeMs();\n        final long ctime_sec = fi.getLastModificationTimeMs() / 1000;\n        final long ctime_nsec = (fi.getLastModificationTimeMs() % 1000) * 1000;\n        stat.st_ctim.tv_sec.set(ctime_sec);\n        stat.st_ctim.tv_nsec.set(ctime_nsec);\n        stat.st_mtim.tv_sec.set(ctime_sec);\n        stat.st_mtim.tv_nsec.set(ctime_nsec);\n\n        System.getProperty(\"user.name\");\n\n        stat.st_uid.set(UID_AND_GID[0]);\n        stat.st_gid.set(UID_AND_GID[1]);\n\n        final int mode;\n        if (fi.isFolder) {\n          mode = FileStat.S_IFDIR;\n        } else {\n          mode = FileStat.S_IFREG;\n        }\n        stat.st_mode.set(mode);\n      }\n\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Invalid path {}\", path, e);\n      ret = ErrorCodes.ENOENT();\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      ret = ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    }\n\n    return -ret;\n  }","id":43365,"modified_method":"/**\n   * Retrieve file attributes.\n   * @param path The path on the FS of the file\n   * @param stat FUSE data structure to fill with file attrs\n   * @return 0 on success, negative value on error\n   */\n  @Override\n  public int getattr(String path, FileStat stat) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"getattr({}) [Tachyon: {}]\", path, turi);\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        return -ErrorCodes.ENOENT();\n      } else {\n        final FileInfo fi = mTFS.getInfo(tf);\n        stat.st_size.set(fi.getLength());\n\n        final long ctime = fi.getLastModificationTimeMs();\n        final long ctime_sec = fi.getLastModificationTimeMs() / 1000;\n        //keeps only the \"residual\" nanoseconds not caputred in\n        // citme_sec\n        final long ctime_nsec = (fi.getLastModificationTimeMs() % 1000) * 1000;\n        stat.st_ctim.tv_sec.set(ctime_sec);\n        stat.st_ctim.tv_nsec.set(ctime_nsec);\n        stat.st_mtim.tv_sec.set(ctime_sec);\n        stat.st_mtim.tv_nsec.set(ctime_nsec);\n\n        // Since Tachyon does not support ownership yet,\n        // set fake ownership on the user and group that\n        // is running tachyon-fuse\n        stat.st_uid.set(UID_AND_GID[0]);\n        stat.st_gid.set(UID_AND_GID[1]);\n\n        final int mode;\n        if (fi.isFolder) {\n          mode = FileStat.S_IFDIR;\n        } else {\n          mode = FileStat.S_IFREG;\n        }\n        stat.st_mode.set(mode);\n      }\n\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Invalid path {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int readdir(String path, Pointer buff, FuseFillDir filter,\n      @off_t long offset, FuseFileInfo fi) {\n    int ret = 0;\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"readdir({}) [Tachyon: {}]\", path, turi);\n\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        return -ErrorCodes.ENOTDIR();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (!tfi.isFolder) {\n        return -ErrorCodes.ENOTDIR();\n      }\n      final List<FileInfo> ls = mTFS.listStatus(tf);\n      // standard . and .. entries\n      filter.apply(buff, \".\", null, 0);\n      filter.apply(buff, \"..\", null, 0);\n\n      for (final FileInfo file : ls) {\n        filter.apply(buff, file.name, null, 0);\n      }\n\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      ret = ErrorCodes.ENOENT();\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Invalid path {}\", path, e);\n      ret = ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    }\n\n    return -ret;\n  }","id":43366,"modified_method":"/**\n   * Read the contents of a directory.\n   * @param path The FS path of the directory\n   * @param buff The FUSE buffer to fill\n   * @param filter FUSE filter\n   * @param offset Ignored in tachyon-fuse\n   * @param fi FileInfo data structure kept by FUSE\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int readdir(String path, Pointer buff, FuseFillDir filter,\n      @off_t long offset, FuseFileInfo fi) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"readdir({}) [Tachyon: {}]\", path, turi);\n\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (!tfi.isFolder) {\n        return -ErrorCodes.ENOTDIR();\n      }\n      final List<FileInfo> ls = mTFS.listStatus(tf);\n      // standard . and .. entries\n      filter.apply(buff, \".\", null, 0);\n      filter.apply(buff, \"..\", null, 0);\n\n      for (final FileInfo file : ls) {\n        filter.apply(buff, file.name, null, 0);\n      }\n\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Invalid path {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int create(String path, @mode_t long mode, FuseFileInfo fi) {\n    int ret = 0;\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    final int flags = fi.flags.get();\n    LOG.trace(\"create({}, {}) [Tachyon: {}]\", path, Integer.toHexString(flags), turi);\n    LOG.warn(\"{}: mode is ignored in tachyon-fuse\", path);\n    if ((flags & 3) != O_WRONLY.intValue()) {\n      LOG.error(\"Files can only be created in O_WRONLY mode ({})\", path);\n      return -ErrorCodes.EACCES();\n    }\n\n    try {\n\n      final OpenFileEntry ofe = new OpenFileEntry();\n      ofe.mIn = null;\n      ofe.mOut = mTFS.getOutStream(turi);\n      LOG.debug(\"Tachyon OutStream created for {}\", path);\n\n      synchronized (mOpenFilesLock) {\n        if (mOpenFiles.size() == MAX_OPEN_FILES) {\n          LOG.error(\"Cannot open {}: too many open files\", turi);\n          return ErrorCodes.EMFILE();\n        }\n        mOpenFiles.put(mOpenFileIds, ofe);\n        fi.fh.set(mOpenFileIds);\n\n        // Assuming I will never wrap around (2^64 open files are quite a lot anyway)\n        mOpenFileIds += 1;\n      }\n      LOG.debug(\"{} created and opened in O_WRONLY mode\", path);\n\n    } catch (FileAlreadyExistsException e) {\n      LOG.debug(\"File {} already exists\", turi, e);\n      ret = ErrorCodes.EEXIST();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    }\n\n    return -ret;\n  }","id":43367,"modified_method":"/**\n   * Create and open a new file.\n   * @param path The FS path of the file to open\n   * @param mode mode flags\n   * @param fi FileInfo data struct kept by FUSE\n   * @return 0 on success. A negative value on error\n   */\n  @Override\n  public int create(String path, @mode_t long mode, FuseFileInfo fi) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    final int flags = fi.flags.get();\n    LOG.trace(\"create({}, {}) [Tachyon: {}]\", path, Integer.toHexString(flags), turi);\n    // LOG.warn(\"{}: mode is ignored in tachyon-fuse\", path);\n    final int openFlag = flags & 3;\n    if (openFlag != O_WRONLY.intValue()) {\n      OpenFlags flag = OpenFlags.valueOf(openFlag);\n      LOG.error(\"Passed a {} flag to create(). Files can only be created in O_WRONLY mode ({})\",\n          flag.toString(), path);\n      return -ErrorCodes.EACCES();\n    }\n\n    try {\n\n      final OpenFileEntry ofe =\n          new OpenFileEntry(null, mTFS.getOutStream(turi));\n      LOG.debug(\"Tachyon OutStream created for {}\", path);\n\n      synchronized (mOpenFiles) {\n        if (mOpenFiles.size() == MAX_OPEN_FILES) {\n          LOG.error(\"Cannot open {}: too many open files\", turi);\n          return -ErrorCodes.EMFILE();\n        }\n        mOpenFiles.put(mNextOpenFileId, ofe);\n        fi.fh.set(mNextOpenFileId);\n\n        // Assuming I will never wrap around (2^64 open files are quite a lot anyway)\n        mNextOpenFileId += 1;\n      }\n      LOG.debug(\"{} created and opened in O_WRONLY mode\", path);\n\n    } catch (FileAlreadyExistsException e) {\n      LOG.debug(\"File {} already exists\", turi, e);\n      return -ErrorCodes.EEXIST();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int unlink(String path) {\n    LOG.trace(\"unlink({})\", path);\n    return rmInternal(path, true);\n  }","id":43368,"modified_method":"/**\n   * Delete a file from the FS.\n   * @param path the FS path of the file\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int unlink(String path) {\n    LOG.trace(\"unlink({})\", path);\n    return rmInternal(path, true);\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int write(String path, Pointer buf, @size_t long size, @off_t long offset,\n                   FuseFileInfo fi) {\n    if (size > Integer.MAX_VALUE) {\n      LOG.error(\"Cannot write more than Integer.MAX_VALUE\");\n      return ErrorCodes.EIO();\n    }\n    LOG.trace(\"write({}, {}, {})\", path, size, offset);\n    final int sz = (int) size;\n    final long fd = fi.fh.get();\n    OpenFileEntry oe = null;\n    synchronized (mOpenFilesLock) {\n      oe = mOpenFiles.get(fd);\n    }\n    if (oe == null) {\n      LOG.error(\"Cannot find fd for {} in table\", path);\n      return -ErrorCodes.EBADFD();\n    }\n\n    if (oe.mOut == null) {\n      LOG.error(\"{} was not open for writing\", path);\n      return -ErrorCodes.EBADFD();\n    }\n    // LOG.debug(\"Tachyn-fuse does not support seek for writes. Ignoring offset {}\", offset);\n    try {\n      final byte[] dest = new byte[sz];\n      buf.get(0, dest, 0, sz);\n      oe.mOut.write(dest);\n    } catch (IOException e) {\n      LOG.error(\"IOException while writing to {}.\", path, e);\n      return -ErrorCodes.EIO();\n    }\n\n    return sz;\n  }","id":43369,"modified_method":"/**\n   * Write a buffer to an open Tachyon file.\n   * @param buf The buffer with source data\n   * @param size How much data to write from the buffer\n   * @param offset The offset where to write in the file (IGNORED)\n   * @param fi FileInfo data structure kept by FUSE\n   * @return number of bytes written on success, a negative value on error\n   */\n  @Override\n  public int write(String path, Pointer buf, @size_t long size, @off_t long offset,\n                   FuseFileInfo fi) {\n    if (size > Integer.MAX_VALUE) {\n      LOG.error(\"Cannot write more than Integer.MAX_VALUE\");\n      return ErrorCodes.EIO();\n    }\n    LOG.trace(\"write({}, {}, {})\", path, size, offset);\n    final int sz = (int) size;\n    final long fd = fi.fh.get();\n    OpenFileEntry oe = null;\n    synchronized (mOpenFiles) {\n      oe = mOpenFiles.get(fd);\n    }\n    if (oe == null) {\n      LOG.error(\"Cannot find fd for {} in table\", path);\n      return -ErrorCodes.EBADFD();\n    }\n\n    if (oe.getOut() == null) {\n      LOG.error(\"{} was not open for writing\", path);\n      return -ErrorCodes.EBADFD();\n    }\n\n    try {\n      final byte[] dest = new byte[sz];\n      buf.get(0, dest, 0, sz);\n      oe.getOut().write(dest);\n    } catch (IOException e) {\n      LOG.error(\"IOException while writing to {}.\", path, e);\n      return -ErrorCodes.EIO();\n    }\n\n    return sz;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int open(String path, FuseFileInfo fi) {\n    int ret = 0;\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    final int flags = fi.flags.get();\n    LOG.trace(\"open({}, 0x{}) [Tachyon: {}]\", path, Integer.toHexString(flags), turi);\n    LOG.warn(\"{}: mode is ignored in tachyon-fuse\", path);\n\n    if ((flags & 3) != O_RDONLY.intValue()) {\n      LOG.error(\"Files can only be opened in O_RDONLY mode ({})\", path);\n      return -ErrorCodes.EACCES();\n    }\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        LOG.error(\"File {} does not exist\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (tfi.isFolder) {\n        LOG.error(\"File {} is a directory\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final OpenFileEntry ofe = new OpenFileEntry();\n      ofe.mTfid = tf.getFileId();\n      ofe.mIn = mTFS.getInStream(tf);\n      ofe.mOut = null;\n\n      synchronized (mOpenFilesLock) {\n        if (mOpenFiles.size() == MAX_OPEN_FILES) {\n          LOG.error(\"Cannot open {}: too many open files\", turi);\n          return ErrorCodes.EMFILE();\n        }\n        mOpenFiles.put(mOpenFileIds, ofe);\n        fi.fh.set(mOpenFileIds);\n\n        // Assuming I will never wrap around (2^64 open files are quite a lot anyway)\n        mOpenFileIds += 1;\n      }\n\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      ret = ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      ret = ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      ret = ErrorCodes.EFAULT();\n    }\n\n    return -ret;\n  }","id":43370,"modified_method":"/**\n   * Open an existing file for reading.\n   *\n   * Note that the open mode <emph>must<\/emph> be\n   * O_RDONLY, otherwise the open will fail. This is due to\n   * the Tachyon \"write-once/read-many-times\" file model.\n   *\n   * @param path the FS path of the file to open\n   * @param fi FileInfo data structure kept by FUSE\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int open(String path, FuseFileInfo fi) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    final int flags = fi.flags.get();\n    LOG.trace(\"open({}, 0x{}) [Tachyon: {}]\", path, Integer.toHexString(flags), turi);\n\n    if ((flags & 3) != O_RDONLY.intValue()) {\n      LOG.error(\"Files can only be opened in O_RDONLY mode ({})\", path);\n      return -ErrorCodes.EACCES();\n    }\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        LOG.error(\"File {} does not exist\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (tfi.isFolder) {\n        LOG.error(\"File {} is a directory\", turi);\n        return -ErrorCodes.EISDIR();\n      }\n      final OpenFileEntry ofe =\n          new OpenFileEntry(mTFS.getInStream(tf), null);\n\n      synchronized (mOpenFiles) {\n        if (mOpenFiles.size() == MAX_OPEN_FILES) {\n          LOG.error(\"Cannot open {}: too many open files\", turi);\n          return ErrorCodes.EMFILE();\n        }\n        mOpenFiles.put(mNextOpenFileId, ofe);\n        fi.fh.set(mNextOpenFileId);\n\n        // Assuming I will never wrap around (2^64 open files are quite a lot anyway)\n        mNextOpenFileId += 1;\n      }\n\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"public TachyonFuseOptions(String mountPoint, String masterAddress, String tachyonRoot,\n                            boolean debug, List<String> fuseOpts) {\n    mMountPoint = mountPoint;\n    mMasterAddress = masterAddress;\n    mTachyonRoot = tachyonRoot;\n    mDebug = debug;\n    mFuseOpts = fuseOpts;\n  }","id":43371,"modified_method":"TachyonFuseOptions(String mountPoint, String tachyonRoot,\n      boolean debug, List<String> fuseOpts) {\n    mMountPoint = mountPoint;\n    mTachyonRoot = tachyonRoot;\n    mDebug = debug;\n    mFuseOpts = fuseOpts;\n  }","commit_id":"3526dbc78de81285cb482f1b6227bd0f15ce1842","url":"https://github.com/amplab/tachyon"},{"original_method":"public void afterPropertiesSet() {\n\t\tHttpClientBuilder httpClientBuilder = HttpClients.custom();\n\n\t\tHttpClientConnectionManager httpClientConnectionManager =\n\t\t\tgetPoolingHttpClientConnectionManager();\n\n\t\thttpClientBuilder.setConnectionManager(httpClientConnectionManager);\n\n\t\tif ((!isNull(_login) && !isNull(_password)) ||\n\t\t\t(!isNull(_proxyLogin) && !isNull(_proxyPassword))) {\n\n\t\t\tCredentialsProvider credentialsProvider =\n\t\t\t\tnew BasicCredentialsProvider();\n\n\t\t\tif (!isNull(_login)) {\n\t\t\t\tcredentialsProvider.setCredentials(\n\t\t\t\t\tnew AuthScope(_hostName, _hostPort),\n\t\t\t\t\tnew UsernamePasswordCredentials(_login, _password));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_logger.isInfoEnabled()) {\n\t\t\t\t\t_logger.info(\"No credentials are used\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isNull(_proxyLogin)) {\n\t\t\t\tcredentialsProvider.setCredentials(\n\t\t\t\t\tnew AuthScope(_proxyHostName, _proxyHostPort),\n\t\t\t\t\tnew UsernamePasswordCredentials(\n\t\t\t\t\t\t_proxyLogin, _proxyPassword));\n\t\t\t}\n\n\t\t\thttpClientBuilder.setDefaultCredentialsProvider(\n\t\t\t\tcredentialsProvider);\n\t\t\thttpClientBuilder.setRetryHandler(\n\t\t\t\tnew HttpRequestRetryHandlerImpl());\n\t\t}\n\n\t\ttry {\n\t\t\tsetProxyHost(httpClientBuilder);\n\n\t\t\t_closeableHttpClient = httpClientBuilder.build();\n\n\t\t\t_idleConnectionMonitorThread = new IdleConnectionMonitorThread(\n\t\t\t\thttpClientConnectionManager);\n\n\t\t\t_idleConnectionMonitorThread.start();\n\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\n\t\t\t\t\t\"Configured client for \" + _protocol + \"://\" + _hostName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(\"Unable to configure client\", e);\n\t\t}\n\t}","id":43372,"modified_method":"public void afterPropertiesSet() {\n\t\tHttpClientBuilder httpClientBuilder = HttpClients.custom();\n\n\t\thttpClientBuilder = httpClientBuilder.useSystemProperties();\n\n\t\tHttpClientConnectionManager httpClientConnectionManager =\n\t\t\tgetPoolingHttpClientConnectionManager();\n\n\t\thttpClientBuilder.setConnectionManager(httpClientConnectionManager);\n\n\t\tif ((!isNull(_login) && !isNull(_password)) ||\n\t\t\t(!isNull(_proxyLogin) && !isNull(_proxyPassword))) {\n\n\t\t\tCredentialsProvider credentialsProvider =\n\t\t\t\tnew BasicCredentialsProvider();\n\n\t\t\tif (!isNull(_login)) {\n\t\t\t\tcredentialsProvider.setCredentials(\n\t\t\t\t\tnew AuthScope(_hostName, _hostPort),\n\t\t\t\t\tnew UsernamePasswordCredentials(_login, _password));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_logger.isInfoEnabled()) {\n\t\t\t\t\t_logger.info(\"No credentials are used\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isNull(_proxyLogin)) {\n\t\t\t\tcredentialsProvider.setCredentials(\n\t\t\t\t\tnew AuthScope(_proxyHostName, _proxyHostPort),\n\t\t\t\t\tnew UsernamePasswordCredentials(\n\t\t\t\t\t\t_proxyLogin, _proxyPassword));\n\t\t\t}\n\n\t\t\thttpClientBuilder.setDefaultCredentialsProvider(\n\t\t\t\tcredentialsProvider);\n\t\t\thttpClientBuilder.setRetryHandler(\n\t\t\t\tnew HttpRequestRetryHandlerImpl());\n\t\t}\n\n\t\ttry {\n\t\t\tif (_proxySelector != null) {\n\t\t\t\thttpClientBuilder.setRoutePlanner(\n\t\t\t\t\tnew SystemDefaultRoutePlanner(_proxySelector));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetProxyHost(httpClientBuilder);\n\t\t\t}\n\n\t\t\t_closeableHttpClient = httpClientBuilder.build();\n\n\t\t\t_idleConnectionMonitorThread = new IdleConnectionMonitorThread(\n\t\t\t\thttpClientConnectionManager);\n\n\t\t\t_idleConnectionMonitorThread.start();\n\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\n\t\t\t\t\t\"Configured client for \" + _protocol + \"://\" + _hostName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(\"Unable to configure client\", e);\n\t\t}\n\t}","commit_id":"9976a2bfd561206d93b0cf43cb4a2ad594595114","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void apply(Map<String, ?> options) {\n        DefaultObjectConfigurationAction action = new DefaultObjectConfigurationAction(getFileResolver(), getScriptPluginFactory(), getScriptHandlerFactory(), getClassLoaderScope(), this);\n        ConfigureUtil.configureByMap(options, action);\n        action.execute();\n    }","id":43373,"modified_method":"public void apply(Map<String, ?> options) {\n        DefaultObjectConfigurationAction action = new DefaultObjectConfigurationAction(getFileResolver(), getScriptPluginFactory(), getScriptHandlerFactory(), getClassLoaderScope().getBase().createChild(), this);\n        ConfigureUtil.configureByMap(options, action);\n        action.execute();\n    }","commit_id":"c4a5bbe2fcb75c34003a6d46b793d481e4b96532","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Closure closure) {\n        DefaultObjectConfigurationAction action = new DefaultObjectConfigurationAction(getFileResolver(), getScriptPluginFactory(), getScriptHandlerFactory(), getClassLoaderScope(), this);\n        ConfigureUtil.configure(closure, action);\n        action.execute();\n    }","id":43374,"modified_method":"public void apply(Closure closure) {\n        DefaultObjectConfigurationAction action = new DefaultObjectConfigurationAction(getFileResolver(), getScriptPluginFactory(), getScriptHandlerFactory(), getClassLoaderScope().getBase().createChild(), this);\n        ConfigureUtil.configure(closure, action);\n        action.execute();\n    }","commit_id":"c4a5bbe2fcb75c34003a6d46b793d481e4b96532","url":"https://github.com/gradle/gradle"},{"original_method":"public void lock() {\n        locked = true;\n    }","id":43375,"modified_method":"public ClassLoaderScope lock() {\n        locked = true;\n        return this;\n    }","commit_id":"77701758fbed487467814fe1506d9611346b9eb6","url":"https://github.com/gradle/gradle"},{"original_method":"protected PluginRegistry createPluginRegistry(PluginRegistry parentRegistry) {\n        return parentRegistry.createChild(project.getClassLoaderScope(), new DependencyInjectingInstantiator(this));\n    }","id":43376,"modified_method":"protected PluginRegistry createPluginRegistry(PluginRegistry parentRegistry) {\n        return parentRegistry.createChild(project.getClassLoaderScope().createChild().lock(), new DependencyInjectingInstantiator(this));\n    }","commit_id":"77701758fbed487467814fe1506d9611346b9eb6","url":"https://github.com/gradle/gradle"},{"original_method":"public void lock() {\n        //\n    }","id":43377,"modified_method":"public ClassLoaderScope lock() {\n        return this;\n    }","commit_id":"77701758fbed487467814fe1506d9611346b9eb6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void run() {\n            while (_stayAlive) {\n                while (_doRun) {\n                    // do read\n                    I2CPMessage msg = null;\n                    try {\n                        msg = in.take();\n                        if (msg.getType() == PoisonI2CPMessage.MESSAGE_TYPE)\n                            cancelRunner();\n                        else\n                            _listener.messageReceived(QueuedI2CPMessageReader.this, msg);\n                    } catch (InterruptedException ie) {}\n                }\n                // ??? unused\n                if (_stayAlive && !_doRun) {\n                    // pause .5 secs when we're paused\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException ie) {\n                        _listener.disconnected(QueuedI2CPMessageReader.this);\n                        cancelRunner();\n                    }\n                }\n            }\n            super.run(); // Since we are dead, this will do some clean up, nothing else :-)\n            in = null;\n            _readerThread = null;\n            _reader = null;\n        }","id":43378,"modified_method":"@Override\n        public void run() {\n            while (_stayAlive) {\n                while (_doRun) {\n                    // do read\n                    I2CPMessage msg = null;\n                    try {\n                        msg = in.take();\n                        if (msg.getType() == PoisonI2CPMessage.MESSAGE_TYPE) {\n                            _listener.disconnected(QueuedI2CPMessageReader.this);\n                            cancelRunner();\n                        } else {\n                            _listener.messageReceived(QueuedI2CPMessageReader.this, msg);\n                        }\n                    } catch (InterruptedException ie) {}\n                }\n                // ??? unused\n                if (_stayAlive && !_doRun) {\n                    // pause .5 secs when we're paused\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException ie) {\n                        _listener.disconnected(QueuedI2CPMessageReader.this);\n                        cancelRunner();\n                    }\n                }\n            }\n            super.run(); // Since we are dead, this will do some clean up, nothing else :-)\n            in = null;\n            _readerThread = null;\n            _reader = null;\n        }","commit_id":"fc38d54bcbd5fb49263b80af7706598991fc52a5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public HttpResponse fromCamelMessage(Message message) throws Exception {\n        LOG.trace(\"fromCamelMessage: {}\", message);\n\n        // the status code is default 200, but a header can override that\n        Integer code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, 200, Integer.class);\n        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code));\n        LOG.trace(\"HTTP Status Code: {}\", code);\n\n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    response.addHeader(key, headerValue);\n                }\n            }\n        }\n\n        Object body = message.getBody();\n        if (body != null) {\n            // support bodies as native Netty\n            ChannelBuffer buffer;\n            if (body instanceof ChannelBuffer) {\n                buffer = (ChannelBuffer) body;\n            } else {\n                // try to convert to buffer first\n                buffer = message.getBody(ChannelBuffer.class);\n                if (buffer == null) {\n                    // fallback to byte array as last resort\n                    byte[] data = message.getMandatoryBody(byte[].class);\n                    buffer = ChannelBuffers.copiedBuffer(data);\n                }\n            }\n            if (buffer != null) {\n                response.setContent(buffer);\n                int len = buffer.readableBytes();\n                // set content-length\n                response.setHeader(HttpHeaders.Names.CONTENT_LENGTH, len);\n                LOG.trace(\"Content-Length: {}\", len);\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            response.setHeader(HttpHeaders.Names.CONTENT_TYPE, contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // TODO: keep alive should be something we can control\n        String keepAlive = HttpHeaders.Values.CLOSE;\n        response.setHeader(HttpHeaders.Names.CONNECTION, keepAlive);\n        LOG.trace(\"Connection: {}\", keepAlive);\n\n        return response;\n    }","id":43379,"modified_method":"@Override\n    public HttpResponse fromCamelMessage(Message message) throws Exception {\n        LOG.trace(\"fromCamelMessage: {}\", message);\n\n        // the message body may already be a Netty HTTP response\n        if (message.getBody() instanceof HttpResponse) {\n            return (HttpResponse) message.getBody();\n        }\n\n        // the status code is default 200, but a header can override that\n        Integer code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, 200, Integer.class);\n        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(code));\n        LOG.trace(\"HTTP Status Code: {}\", code);\n\n        TypeConverter tc = message.getExchange().getContext().getTypeConverter();\n\n        // append headers\n        // must use entrySet to ensure case of keys is preserved\n        for (Map.Entry<String, Object> entry : message.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            // use an iterator as there can be multiple values. (must not use a delimiter)\n            final Iterator<?> it = ObjectHelper.createIterator(value, null);\n            while (it.hasNext()) {\n                String headerValue = tc.convertTo(String.class, it.next());\n                if (headerValue != null && headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, headerValue, message.getExchange())) {\n                    LOG.trace(\"HTTP-Header: {}={}\", key, headerValue);\n                    response.addHeader(key, headerValue);\n                }\n            }\n        }\n\n        Object body = message.getBody();\n        if (body != null) {\n            // support bodies as native Netty\n            ChannelBuffer buffer;\n            if (body instanceof ChannelBuffer) {\n                buffer = (ChannelBuffer) body;\n            } else {\n                // try to convert to buffer first\n                buffer = message.getBody(ChannelBuffer.class);\n                if (buffer == null) {\n                    // fallback to byte array as last resort\n                    byte[] data = message.getMandatoryBody(byte[].class);\n                    buffer = ChannelBuffers.copiedBuffer(data);\n                }\n            }\n            if (buffer != null) {\n                response.setContent(buffer);\n                int len = buffer.readableBytes();\n                // set content-length\n                response.setHeader(HttpHeaders.Names.CONTENT_LENGTH, len);\n                LOG.trace(\"Content-Length: {}\", len);\n            }\n        }\n\n        // set the content type in the response.\n        String contentType = MessageHelper.getContentType(message);\n        if (contentType != null) {\n            // set content-type\n            response.setHeader(HttpHeaders.Names.CONTENT_TYPE, contentType);\n            LOG.trace(\"Content-Type: {}\", contentType);\n        }\n\n        // TODO: keep alive should be something we can control\n        String keepAlive = HttpHeaders.Values.CLOSE;\n        response.setHeader(HttpHeaders.Names.CONNECTION, keepAlive);\n        LOG.trace(\"Connection: {}\", keepAlive);\n\n        return response;\n    }","commit_id":"e45a6f5889a474d8b2a5dd05a32569620fe6690e","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {\n        // store request, as this channel handler is created per pipeline\n        request = (HttpRequest) messageEvent.getMessage();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Message received: keep-alive {}\", isKeepAlive(request));\n        }\n\n        if (is100ContinueExpected(request)) {\n            // send back http 100 response to continue\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);\n            messageEvent.getChannel().write(response);\n        } else {\n            // let Camel process this message\n            super.messageReceived(ctx, messageEvent);\n        }\n    }","id":43380,"modified_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {\n        // store request, as this channel handler is created per pipeline\n        request = (HttpRequest) messageEvent.getMessage();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Message received: {} keep-alive: {}\", request, isKeepAlive(request));\n        }\n\n        if (is100ContinueExpected(request)) {\n            // send back http 100 response to continue\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, CONTINUE);\n            messageEvent.getChannel().write(response);\n            return;\n        }\n\n        if (consumer.isSuspended()) {\n            // are we suspended?\n            LOG.debug(\"Consumer suspended, cannot service request {}\", request);\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, SERVICE_UNAVAILABLE);\n            messageEvent.getChannel().write(response);\n            return;\n        }\n        if (consumer.getEndpoint().getHttpMethodRestrict() != null\n                && !consumer.getEndpoint().getHttpMethodRestrict().contains(request.getMethod().getName())) {\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, METHOD_NOT_ALLOWED);\n            messageEvent.getChannel().write(response);\n            return;\n        }\n        if (\"TRACE\".equals(request.getMethod().getName()) && !consumer.getEndpoint().isTraceEnabled()) {\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, METHOD_NOT_ALLOWED);\n            messageEvent.getChannel().write(response);\n            return;\n        }\n\n        // let Camel process this message\n        super.messageReceived(ctx, messageEvent);\n    }","commit_id":"e45a6f5889a474d8b2a5dd05a32569620fe6690e","url":"https://github.com/apache/camel"},{"original_method":"public void run()\n        {\n            while (!terminated())\n            {\n                try\n                {\n                    StreamMessage next = messageQueue.poll(1, TimeUnit.SECONDS);\n                    if (next != null)\n                    {\n                        logger.debug(\"Sending \" + next);\n                        StreamMessage.serialize(next, out, protocolVersion, session);\n                        if (next.type == StreamMessage.Type.SESSION_FAILED)\n                            terminate();\n                    }\n                }\n                catch (SocketException e)\n                {\n                    session.onError(e);\n                    terminate();\n                }\n                catch (InterruptedException | IOException e)\n                {\n                    session.onError(e);\n                }\n            }\n        }","id":43381,"modified_method":"public void run()\n        {\n            StreamMessage next;\n            while (!isClosed())\n            {\n                try\n                {\n                    if ((next = messageQueue.poll(1, TimeUnit.SECONDS)) != null)\n                    {\n                        logger.debug(\"Sending {}\", next);\n                        sendMessage(next);\n                        if (next.type == StreamMessage.Type.SESSION_FAILED)\n                            close();\n                    }\n                }\n                catch (InterruptedException e)\n                {\n                    throw new AssertionError(e);\n                }\n            }\n\n            try\n            {\n                // Sends the last messages on the queue\n                while ((next = messageQueue.poll()) != null)\n                    sendMessage(next);\n            }\n            finally\n            {\n                signalCloseDone();\n            }\n        }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public void close()\n    {\n        incoming.terminate();\n        outgoing.terminate();\n        if (socket != null && !isConnected())\n        {\n            try\n            {\n                socket.close();\n            }\n            catch (IOException ignore) {}\n        }\n    }","id":43382,"modified_method":"public ListenableFuture<?> close()\n    {\n        logger.debug(\"Closing stream connection handler on {}\", session.peer);\n\n        ListenableFuture<?> inClosed = incoming == null ? Futures.immediateFuture(null) : incoming.close();\n        ListenableFuture<?> outClosed = outgoing == null ? Futures.immediateFuture(null) : outgoing.close();\n\n        return Futures.allAsList(inClosed, outClosed);\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"protected MessageHandler(StreamSession session, int protocolVersion)\n        {\n            this.session = session;\n            this.protocolVersion = protocolVersion;\n        }","id":43383,"modified_method":"protected MessageHandler(StreamSession session, Socket socket, int protocolVersion)\n        {\n            this.session = session;\n            this.socket = socket;\n            this.protocolVersion = protocolVersion;\n        }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public void run()\n        {\n            while (!terminated())\n            {\n                try\n                {\n                    // receive message\n                    StreamMessage message = StreamMessage.deserialize(in, protocolVersion, session);\n                    assert message != null;\n                    session.messageReceived(message);\n                }\n                catch (SocketException e)\n                {\n                    // socket is closed\n                    terminate();\n                }\n                catch (Throwable e)\n                {\n                    session.onError(e);\n                }\n            }\n        }","id":43384,"modified_method":"public void run()\n        {\n            while (!isClosed())\n            {\n                try\n                {\n                    // receive message\n                    StreamMessage message = StreamMessage.deserialize(in, protocolVersion, session);\n                    // Might be null if there is an error during streaming (see FileMessage.deserialize). It's ok\n                    // to ignore here since we'll have asked for a retry.\n                    if (message != null)\n                    {\n                        logger.debug(\"Received {}\", message);\n                        session.messageReceived(message);\n                    }\n                }\n                catch (SocketException e)\n                {\n                    // socket is closed\n                    close();\n                }\n                catch (Throwable e)\n                {\n                    session.onError(e);\n                }\n            }\n            signalCloseDone();\n        }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"IncomingMessageHandler(StreamSession session, int protocolVersion, ReadableByteChannel in)\n        {\n            super(session, protocolVersion);\n            this.in = in;\n        }","id":43385,"modified_method":"IncomingMessageHandler(StreamSession session, Socket socket, int protocolVersion) throws IOException\n        {\n            super(session, socket, protocolVersion);\n            this.in = getReadChannel();\n        }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public void sendMessage(StreamMessage message)\n    {\n        assert isConnected();\n        outgoing.enqueue(message);\n    }","id":43386,"modified_method":"public void sendMessage(StreamMessage message)\n    {\n        if (outgoing.isClosed())\n            throw new RuntimeException(\"Outgoing stream handler has been closed\");\n\n        outgoing.enqueue(message);\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"OutgoingMessageHandler(StreamSession session, int protocolVersion, WritableByteChannel out)\n        {\n            super(session, protocolVersion);\n            this.out = out;\n        }","id":43387,"modified_method":"OutgoingMessageHandler(StreamSession session, Socket socket, int protocolVersion) throws IOException\n        {\n            super(session, socket, protocolVersion);\n            this.out = getWriteChannel();\n        }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"ConnectionHandler(StreamSession session)\n    {\n        this.session = session;\n        this.protocolVersion = StreamMessage.CURRENT_VERSION;\n    }","id":43388,"modified_method":"ConnectionHandler(StreamSession session)\n    {\n        this.session = session;\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n    public void run()\n    {\n        try\n        {\n            // streaming connections are per-session and have a fixed version.  we can't do anything with a wrong-version stream connection, so drop it.\n            if (version != StreamMessage.CURRENT_VERSION)\n                throw new IOException(String.format(\"Received stream using protocol version %d (my version %d). Terminating connection\", version, MessagingService.current_version));\n\n            DataInput input = new DataInputStream(socket.getInputStream());\n            StreamInitMessage init = StreamInitMessage.serializer.deserialize(input, version);\n\n            StreamSession.startReceivingStreamAsync(init.planId, init.description, socket, version);\n        }\n        catch (IOException e)\n        {\n            logger.debug(\"IOException reading from socket; closing\", e);\n            try\n            {\n                socket.close();\n            }\n            catch (IOException e2)\n            {\n                logger.debug(\"error closing socket\", e2);\n            }\n        }\n    }","id":43389,"modified_method":"@Override\n    public void run()\n    {\n        try\n        {\n            // streaming connections are per-session and have a fixed version.  we can't do anything with a wrong-version stream connection, so drop it.\n            if (version != StreamMessage.CURRENT_VERSION)\n                throw new IOException(String.format(\"Received stream using protocol version %d (my version %d). Terminating connection\", version, MessagingService.current_version));\n\n            DataInput input = new DataInputStream(socket.getInputStream());\n            StreamInitMessage init = StreamInitMessage.serializer.deserialize(input, version);\n\n            // We will use the current socket to incoming stream. So if the other side is the\n            // stream initiator, we must first create an outgoing stream, after which real streaming\n            // will start. If we were the initiator however, this socket will just be our incoming\n            // stream, everything is setup and we can initiate real streaming by sending the prepare message.\n            // Note: we cannot use the same socket for incoming and outgoing streams because we want to\n            // parallelize said streams and the socket is blocking, so we might deadlock.\n            if (init.sentByInitiator)\n            {\n                StreamResultFuture.initReceivingSide(init.planId, init.description, init.from, socket, version);\n            }\n            else\n            {\n                StreamResultFuture stream = StreamManager.instance.getStream(init.planId);\n                if (stream == null)\n                {\n                    // This should not happen. All we can do is close the socket to inform the other side, but that's a bug.\n                    logger.error(\"Got StreamInit message for a stream we are supposed to be the initiator of, but stream not found.\");\n                    socket.close();\n                    return;\n                }\n                // We're fully setup for this session, start the actual streaming\n                stream.startStreaming(init.from, socket, version);\n            }\n        }\n        catch (IOException e)\n        {\n            logger.debug(\"IOException reading from socket; closing\", e);\n            try\n            {\n                socket.close();\n            }\n            catch (IOException e2)\n            {\n                logger.debug(\"error closing socket\", e2);\n            }\n        }\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public StreamInitMessage(UUID planId, String description)\n    {\n        this.planId = planId;\n        this.description = description;\n    }","id":43390,"modified_method":"public StreamInitMessage(InetAddress from, UUID planId, String description, boolean sentByInitiator)\n    {\n        this.from = from;\n        this.planId = planId;\n        this.description = description;\n        this.sentByInitiator = sentByInitiator;\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public void serialize(StreamInitMessage message, DataOutput out, int version) throws IOException\n        {\n            UUIDSerializer.serializer.serialize(message.planId, out, MessagingService.current_version);\n            out.writeUTF(message.description);\n        }","id":43391,"modified_method":"public void serialize(StreamInitMessage message, DataOutput out, int version) throws IOException\n        {\n            CompactEndpointSerializationHelper.serialize(message.from, out);\n            UUIDSerializer.serializer.serialize(message.planId, out, MessagingService.current_version);\n            out.writeUTF(message.description);\n            out.writeBoolean(message.sentByInitiator);\n        }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public StreamInitMessage deserialize(DataInput in, int version) throws IOException\n        {\n            UUID planId = UUIDSerializer.serializer.deserialize(in, MessagingService.current_version);\n            return new StreamInitMessage(planId, in.readUTF());\n        }","id":43392,"modified_method":"public StreamInitMessage deserialize(DataInput in, int version) throws IOException\n        {\n            InetAddress from = CompactEndpointSerializationHelper.deserialize(in);\n            UUID planId = UUIDSerializer.serializer.deserialize(in, MessagingService.current_version);\n            String description = in.readUTF();\n            boolean sentByInitiator = in.readBoolean();\n            return new StreamInitMessage(from, planId, description, sentByInitiator);\n        }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public long serializedSize(StreamInitMessage message, int version)\n        {\n            long size = UUIDSerializer.serializer.serializedSize(message.planId, MessagingService.current_version);\n            size += TypeSizes.NATIVE.sizeof(message.description);\n            return size;\n        }","id":43393,"modified_method":"public long serializedSize(StreamInitMessage message, int version)\n        {\n            long size = CompactEndpointSerializationHelper.serializedSize(message.from);\n            size += UUIDSerializer.serializer.serializedSize(message.planId, MessagingService.current_version);\n            size += TypeSizes.NATIVE.sizeof(message.description);\n            size += TypeSizes.NATIVE.sizeof(message.sentByInitiator);\n            return size;\n        }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Gets streaming rate limiter.\n     * When stream_throughput_outbound_megabits_per_sec is 0, this returns rate limiter\n     * with the rate of Double.MAX_VALUE bytes per second.\n     * Rate unit is bytes per sec.\n     *\n     * @return RateLimiter with rate limit set\n     */\n    public static RateLimiter getRateLimiter()\n    {\n        double currentThroughput = ((double) DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec()) * 1024 * 1024 / 8 / 1000;\n        // if throughput is set to 0, throttling is disabled\n        if (currentThroughput == 0)\n            currentThroughput = Double.MAX_VALUE;\n        if (limiter.getRate() != currentThroughput)\n            limiter.setRate(currentThroughput);\n        return limiter;\n    }","id":43394,"modified_method":"/**\n     * Gets streaming rate limiter.\n     * When stream_throughput_outbound_megabits_per_sec is 0, this returns rate limiter\n     * with the rate of Double.MAX_VALUE bytes per second.\n     * Rate unit is bytes per sec.\n     *\n     * @return RateLimiter with rate limit set\n     */\n    public static RateLimiter getRateLimiter()\n    {\n        double currentThroughput = ((double) DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec()) * 1024 * 1024;\n        // if throughput is set to 0, throttling is disabled\n        if (currentThroughput == 0)\n            currentThroughput = Double.MAX_VALUE;\n        if (limiter.getRate() != currentThroughput)\n            limiter.setRate(currentThroughput);\n        return limiter;\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Execute this {@link StreamPlan} asynchronously.\n     *\n     * @return Future {@link StreamState} that you can use to listen on progress of streaming.\n     */\n    public StreamResultFuture execute()\n    {\n        return StreamResultFuture.startStreamingAsync(planId, description, sessions.values());\n    }","id":43395,"modified_method":"/**\n     * Execute this {@link StreamPlan} asynchronously.\n     *\n     * @return Future {@link StreamState} that you can use to listen on progress of streaming.\n     */\n    public StreamResultFuture execute()\n    {\n        return StreamResultFuture.init(planId, description, sessions.values());\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Process received file.\n     *\n     * @param sstable SSTable file received.\n     */\n    public void receive(SSTableReader sstable)\n    {\n        assert cfId.equals(sstable.metadata.cfId);\n\n        sstables.add(sstable);\n        if (sstables.size() == totalFiles)\n            complete();\n    }","id":43396,"modified_method":"/**\n     * Process received file.\n     *\n     * @param sstable SSTable file received.\n     */\n    public void received(SSTableReader sstable)\n    {\n        assert cfId.equals(sstable.metadata.cfId);\n\n        sstables.add(sstable);\n        if (sstables.size() == totalFiles)\n            complete();\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"static StreamResultFuture startStreamingAsync(UUID planId, String description, Collection<StreamSession> sessions)\n    {\n        Set<UUID> sessionsIds = new HashSet<>(sessions.size());\n        for (StreamSession session : sessions)\n            sessionsIds.add(session.id);\n\n        StreamResultFuture future = new StreamResultFuture(planId, description, sessionsIds);\n\n        StreamManager.instance.register(future);\n\n        // start sessions\n        for (StreamSession session : sessions)\n        {\n            session.register(future);\n            // register to gossiper/FD to fail on node failure\n            Gossiper.instance.register(session);\n            FailureDetector.instance.registerFailureDetectionEventListener(session);\n            streamExecutor.submit(session);\n        }\n        return future;\n    }","id":43397,"modified_method":"static StreamResultFuture init(UUID planId, String description, Collection<StreamSession> sessions)\n    {\n        StreamResultFuture future = createAndRegister(planId, description, sessions);\n\n        // start sessions\n        for (final StreamSession session : sessions)\n        {\n            session.init(future);\n            session.start();\n        }\n\n        return future;\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Create new StreamResult of given {@code planId} and type.\n     *\n     * Constructor is package private. You need to use {@link StreamPlan#execute()} to get the instance.\n     *\n     * @param planId Stream plan ID\n     * @param description Stream description\n     * @param numberOfSessions number of sessions to wait for complete\n     */\n    private StreamResultFuture(UUID planId, String description, Set<UUID> sessions)\n    {\n        this.planId = planId;\n        this.description = description;\n        this.ongoingSessions = sessions;\n\n        // if there is no session to listen to, we immediately set result for returning\n        if (sessions.isEmpty())\n            set(getCurrentState());\n    }","id":43398,"modified_method":"/**\n     * Create new StreamResult of given {@code planId} and type.\n     *\n     * Constructor is package private. You need to use {@link StreamPlan#execute()} to get the instance.\n     *\n     * @param planId Stream plan ID\n     * @param description Stream description\n     * @param numberOfSessions number of sessions to wait for complete\n     */\n    private StreamResultFuture(UUID planId, String description, Collection<StreamSession> sessions)\n    {\n        this.planId = planId;\n        this.description = description;\n        this.ongoingSessions = new HashMap<>(sessions.size());\n        for (StreamSession session : sessions)\n            this.ongoingSessions.put(session.peer, session);;\n\n        // if there is no session to listen to, we immediately set result for returning\n        if (sessions.isEmpty())\n            set(getCurrentState());\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"void handleSessionComplete(StreamSession session)\n    {\n        Gossiper.instance.unregister(session);\n        FailureDetector.instance.unregisterFailureDetectionEventListener(session);\n\n        SessionInfo sessionInfo = session.getSessionInfo();\n        sessionStates.put(sessionInfo.peer, sessionInfo);\n        fireStreamEvent(new StreamEvent.SessionCompleteEvent(session));\n        maybeComplete(session.id);\n    }","id":43399,"modified_method":"void handleSessionComplete(StreamSession session)\n    {\n        logger.debug(\"Session with {} is complete\", session.peer);\n\n        SessionInfo sessionInfo = session.getSessionInfo();\n        sessionStates.put(sessionInfo.peer, sessionInfo);\n        fireStreamEvent(new StreamEvent.SessionCompleteEvent(session));\n        maybeComplete(session);\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Check if session is completed on receiving {@code StreamMessage.Type.COMPLETE} message.\n     */\n    public synchronized void complete()\n    {\n        if (state == State.WAIT_COMPLETE)\n        {\n            state(State.COMPLETE);\n            handler.close();\n            streamResult.handleSessionComplete(this);\n        }\n        else\n        {\n            state(State.WAIT_COMPLETE);\n        }\n    }","id":43400,"modified_method":"/**\n     * Check if session is completed on receiving {@code StreamMessage.Type.COMPLETE} message.\n     */\n    public synchronized void complete()\n    {\n        if (state == State.WAIT_COMPLETE)\n        {\n            closeSession(State.COMPLETE);\n        }\n        else\n        {\n            state(State.WAIT_COMPLETE);\n        }\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"private boolean maybeCompleted()\n    {\n        boolean completed = receivers.isEmpty() && transfers.isEmpty();\n        if (completed)\n        {\n            if (state == State.WAIT_COMPLETE)\n            {\n                state(State.COMPLETE);\n                handler.close();\n                streamResult.handleSessionComplete(this);\n            }\n            else\n            {\n                // notify peer that this session is completed\n                handler.sendMessage(new CompleteMessage());\n                state(State.WAIT_COMPLETE);\n            }\n        }\n        return completed;\n    }","id":43401,"modified_method":"private boolean maybeCompleted()\n    {\n        boolean completed = receivers.isEmpty() && transfers.isEmpty();\n        if (completed)\n        {\n            if (state == State.WAIT_COMPLETE)\n            {\n                closeSession(State.COMPLETE);\n            }\n            else\n            {\n                // notify peer that this session is completed\n                handler.sendMessage(new CompleteMessage());\n                state(State.WAIT_COMPLETE);\n            }\n        }\n        return completed;\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public void messageReceived(StreamMessage message)\n    {\n        switch (message.type)\n        {\n            case PREPARE:\n                PrepareMessage msg = (PrepareMessage) message;\n                prepare(msg.requests, msg.summaries);\n                break;\n\n            case FILE:\n                receive((FileMessage) message);\n                break;\n\n            case RETRY:\n                RetryMessage retry = (RetryMessage) message;\n                retry(retry.cfId, retry.sequenceNumber);\n                break;\n\n            case COMPLETE:\n                complete();\n                break;\n\n            case SESSION_FAILED:\n                sessionFailed();\n                break;\n        }\n    }","id":43402,"modified_method":"public void messageReceived(StreamMessage message)\n    {\n        switch (message.type)\n        {\n            case PREPARE:\n                PrepareMessage msg = (PrepareMessage) message;\n                prepare(msg.requests, msg.summaries);\n                break;\n\n            case FILE:\n                received((FileMessage) message);\n                break;\n\n            case RETRY:\n                RetryMessage retry = (RetryMessage) message;\n                retry(retry.cfId, retry.sequenceNumber);\n                break;\n\n            case COMPLETE:\n                complete();\n                break;\n\n            case SESSION_FAILED:\n                sessionFailed();\n                break;\n        }\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Call back for handling exception during streaming.\n     *\n     * @param e thrown exception\n     */\n    public void onError(Throwable e)\n    {\n        state(State.FAILED);\n\n        logger.error(\"Streaming error occurred\", e);\n        // send session failure message\n        handler.sendMessage(new SessionFailedMessage());\n        // fail session\n        streamResult.handleSessionComplete(this);\n    }","id":43403,"modified_method":"/**\n     * Call back for handling exception during streaming.\n     *\n     * @param e thrown exception\n     */\n    public void onError(Throwable e)\n    {\n        logger.error(\"Streaming error occurred\", e);\n        // send session failure message\n        handler.sendMessage(new SessionFailedMessage());\n        // fail session\n        closeSession(State.FAILED);\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"public void convict(InetAddress endpoint, double phi)\n    {\n        if (!endpoint.equals(peer))\n            return;\n\n        // We want a higher confidence in the failure detection than usual because failing a streaming wrongly has a high cost.\n        if (phi < 2 * DatabaseDescriptor.getPhiConvictThreshold())\n            return;\n\n        state(State.FAILED);\n        streamResult.handleSessionComplete(this);\n    }","id":43404,"modified_method":"public void convict(InetAddress endpoint, double phi)\n    {\n        if (!endpoint.equals(peer))\n            return;\n\n        // We want a higher confidence in the failure detection than usual because failing a streaming wrongly has a high cost.\n        if (phi < 2 * DatabaseDescriptor.getPhiConvictThreshold())\n            return;\n\n        closeSession(State.FAILED);\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"private void prepareReceiving(StreamSummary summary)\n    {\n        logger.debug(\"prepare receiving \" + summary);\n        if (summary.files > 0)\n            receivers.put(summary.cfId, new StreamReceiveTask(this, summary.cfId, summary.files, summary.totalSize));\n    }","id":43405,"modified_method":"private void prepareReceiving(StreamSummary summary)\n    {\n        logger.debug(\"Prepare for receiving \" + summary);\n        if (summary.files > 0)\n            receivers.put(summary.cfId, new StreamReceiveTask(this, summary.cfId, summary.files, summary.totalSize));\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Bind this session to report to specific {@link StreamResultFuture}.\n     *\n     * @param streamResult result to report to\n     * @return this object for chaining\n     */\n    public StreamSession register(StreamResultFuture streamResult)\n    {\n        this.streamResult = streamResult;\n        return this;\n    }","id":43406,"modified_method":"/**\n     * Bind this session to report to specific {@link StreamResultFuture} and\n     * perform pre-streaming initialization.\n     *\n     * @param streamResult result to report to\n     * @return this object for chaining\n     */\n    public void init(StreamResultFuture streamResult)\n    {\n        this.streamResult = streamResult;\n\n        // register to gossiper/FD to fail on node failure\n        Gossiper.instance.register(this);\n        FailureDetector.instance.registerFailureDetectionEventListener(this);\n\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Call back on receiving {@code StreamMessage.Type.SESSION_FAILED} message.\n     */\n    public synchronized void sessionFailed()\n    {\n        handler.close();\n        streamResult.handleSessionComplete(this);\n    }","id":43407,"modified_method":"/**\n     * Call back on receiving {@code StreamMessage.Type.SESSION_FAILED} message.\n     */\n    public synchronized void sessionFailed()\n    {\n        closeSession(State.FAILED);\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Call back after receiving FileMessageHeader.\n     *\n     * @param message received file\n     */\n    public void receive(FileMessage message)\n    {\n        StreamingMetrics.totalIncomingBytes.inc(message.header.size());\n        metrics.incomingBytes.inc(message.header.size());\n        receivers.get(message.header.cfId).receive(message.sstable);\n    }","id":43408,"modified_method":"/**\n     * Call back after receiving FileMessageHeader.\n     *\n     * @param message received file\n     */\n    public void received(FileMessage message)\n    {\n        StreamingMetrics.totalIncomingBytes.inc(message.header.size());\n        metrics.incomingBytes.inc(message.header.size());\n        receivers.get(message.header.cfId).received(message.sstable);\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Prepare this session for sending/receiving files.\n     */\n    public void prepare(Collection<StreamRequest> requests, Collection<StreamSummary> summaries)\n    {\n        logger.debug(\"Start preparing this session (\" + requests.size() + \" requests, \" + summaries.size() + \" columnfamilies receiving)\");\n        // prepare tasks\n        state(State.PREPARING);\n        for (StreamRequest request : requests)\n            addTransferRanges(request.keyspace, request.ranges, request.columnFamilies, true); // always flush on stream request\n        for (StreamSummary summary : summaries)\n            prepareReceiving(summary);\n\n        // send back prepare message if prepare message contains stream request\n        if (!requests.isEmpty())\n        {\n            PrepareMessage prepare = new PrepareMessage();\n            for (StreamTransferTask task : transfers.values())\n                prepare.summaries.add(task.getSummary());\n            handler.sendMessage(prepare);\n        }\n\n        // if there are files to stream\n        if (!maybeCompleted())\n        {\n            logger.debug(\"Prepare complete. Start streaming files.\");\n            startStreamingFiles();\n        }\n    }","id":43409,"modified_method":"/**\n     * Prepare this session for sending/receiving files.\n     */\n    public void prepare(Collection<StreamRequest> requests, Collection<StreamSummary> summaries)\n    {\n        logger.debug(\"Start preparing this session (\" + requests.size() + \" to send, \" + summaries.size() + \" to receive)\");\n\n        // prepare tasks\n        state(State.PREPARING);\n        for (StreamRequest request : requests)\n            addTransferRanges(request.keyspace, request.ranges, request.columnFamilies, true); // always flush on stream request\n        for (StreamSummary summary : summaries)\n            prepareReceiving(summary);\n\n        // send back prepare message if prepare message contains stream request\n        if (!requests.isEmpty())\n        {\n            PrepareMessage prepare = new PrepareMessage();\n            for (StreamTransferTask task : transfers.values())\n                prepare.summaries.add(task.getSummary());\n            handler.sendMessage(prepare);\n        }\n\n        // if there are files to stream\n        if (!maybeCompleted())\n        {\n            logger.debug(\"Prepare complete. Start streaming files.\");\n            startStreamingFiles();\n        }\n    }","commit_id":"67ccdabfe8c48229e184d1374f9c6435ccea93ec","url":"https://github.com/apache/cassandra"},{"original_method":"@Before\n    public void setup() throws SQLException\n    {\n        database = new TestGraphDatabaseFactory().newImpermanentDatabase();\n        engine = new DocsExecutionEngine( database );\n        Connection conn = DriverManager.getConnection( \"jdbc:hsqldb:mem:graphgisttests;shutdown=true\" );\n        conn.setAutoCommit( true );\n        state = new State( engine, database, conn, null, \"\" );\n    }","id":43410,"modified_method":"@Before\n    public void setup() throws SQLException\n    {\n        database = new GraphDatabaseCypherService(new TestGraphDatabaseFactory().newImpermanentDatabase());\n        engine = new DocsExecutionEngine( database );\n        Connection conn = DriverManager.getConnection( \"jdbc:hsqldb:mem:graphgisttests;shutdown=true\" );\n        conn.setAutoCommit( true );\n        state = new State( engine, database, conn, null, \"\" );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void tearDown()\n    {\n        database.shutdown();\n    }","id":43411,"modified_method":"@After\n    public void tearDown()\n    {\n        database.getGraphDatabaseService().shutdown();\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void graphWithoutId()\n    {\n        database.execute( \"CREATE (n:Person {name:\\\"Adam\\\"});\" );\n        Block block = Block.getBlock( Arrays.asList( \"//graph\" ) );\n        assertThat( block.type, sameInstance( BlockType.GRAPH ) );\n        String output;\n        output = block.process( state );\n\n        assertThat(\n            output,\n            allOf( startsWith( \"[\\\"dot\\\"\" ), containsString( \"Adam\" ), containsString( \"cypherdoc--\" ),\n                    containsString( \".svg\" ), containsString( \"neoviz\" ) ) );\n    }","id":43412,"modified_method":"@Test\n    public void graphWithoutId()\n    {\n        engine.execute( \"CREATE (n:Person {name:\\\"Adam\\\"});\" );\n        Block block = Block.getBlock( Arrays.asList( \"//graph\" ) );\n        assertThat( block.type, sameInstance( BlockType.GRAPH ) );\n        String output;\n        output = block.process( state );\n\n        assertThat(\n            output,\n            allOf( startsWith( \"[\\\"dot\\\"\" ), containsString( \"Adam\" ), containsString( \"cypherdoc--\" ),\n                    containsString( \".svg\" ), containsString( \"neoviz\" ) ) );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void graph()\n    {\n        database.execute( \"CREATE (n:Person {name:\\\"Adam\\\"});\" );\n        Block block = Block.getBlock( Arrays.asList( \"// graph:xyz\" ) );\n        assertThat( block.type, sameInstance( BlockType.GRAPH ) );\n        String output;\n        output = block.process( state );\n\n        assertThat(\n                output,\n                allOf( startsWith( \"[\\\"dot\\\"\" ), containsString( \"Adam\" ), containsString( \"cypherdoc-xyz\" ),\n                        containsString( \".svg\" ), containsString( \"neoviz\" ) ) );\n    }","id":43413,"modified_method":"@Test\n    public void graph()\n    {\n        engine.execute( \"CREATE (n:Person {name:\\\"Adam\\\"});\" );\n        Block block = Block.getBlock( Arrays.asList( \"// graph:xyz\" ) );\n        assertThat( block.type, sameInstance( BlockType.GRAPH ) );\n        String output;\n        output = block.process( state );\n\n        assertThat(\n                output,\n                allOf( startsWith( \"[\\\"dot\\\"\" ), containsString( \"Adam\" ), containsString( \"cypherdoc-xyz\" ),\n                        containsString( \".svg\" ), containsString( \"neoviz\" ) ) );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Parse a string as CypherDoc-enhanced AsciiDoc.\n     */\n    public static String parse( String input, File parentDirectory, String url )\n    {\n        List<Block> blocks = parseBlocks( input );\n\n        EphemeralFileSystemAbstraction fs = new EphemeralFileSystemAbstraction();\n        //TODO remove config when compiled plans are feature complete\n        Map<Setting<?>, String> config = new HashMap<>();\n        config.put( GraphDatabaseSettings.cypher_runtime, \"INTERPRETED\" );\n        GraphDatabaseService database = new TestGraphDatabaseFactory().setFileSystem( fs ).newImpermanentDatabase(config);\n\n        Connection conn = null;\n        TestFailureException failure = null;\n        try\n        {\n            DocsExecutionEngine engine = new DocsExecutionEngine( database );\n            conn = DriverManager.getConnection( \"jdbc:hsqldb:mem:graphgist;shutdown=true\" );\n            conn.setAutoCommit( true );\n            return executeBlocks( blocks, new State( engine, database, conn, parentDirectory, url ) );\n        }\n        catch ( TestFailureException exception )\n        {\n            dumpStoreFiles( fs, failure = exception, \"before-shutdown\" );\n            throw exception;\n        }\n        catch ( SQLException sqlException )\n        {\n            throw new RuntimeException( sqlException );\n        }\n        finally\n        {\n            database.shutdown();\n            if ( failure != null )\n            {\n                dumpStoreFiles( fs, failure, \"after-shutdown\" );\n            }\n            if ( conn != null )\n            {\n                try\n                {\n                    conn.close();\n                }\n                catch ( SQLException sqlException )\n                {\n                    throw new RuntimeException( sqlException );\n                }\n            }\n        }\n    }","id":43414,"modified_method":"/**\n     * Parse a string as CypherDoc-enhanced AsciiDoc.\n     */\n    public static String parse( String input, File parentDirectory, String url )\n    {\n        List<Block> blocks = parseBlocks( input );\n\n        EphemeralFileSystemAbstraction fs = new EphemeralFileSystemAbstraction();\n        //TODO remove config when compiled plans are feature complete\n        Map<Setting<?>, String> config = new HashMap<>();\n        config.put( GraphDatabaseSettings.cypher_runtime, \"INTERPRETED\" );\n        GraphDatabaseQueryService database = new GraphDatabaseCypherService(\n                new TestGraphDatabaseFactory().setFileSystem( fs ).newImpermanentDatabase( config ) );\n\n        Connection conn = null;\n        TestFailureException failure = null;\n        try\n        {\n            DocsExecutionEngine engine = new DocsExecutionEngine( database );\n            conn = DriverManager.getConnection( \"jdbc:hsqldb:mem:graphgist;shutdown=true\" );\n            conn.setAutoCommit( true );\n            return executeBlocks( blocks, new State( engine, database, conn, parentDirectory, url ) );\n        }\n        catch ( TestFailureException exception )\n        {\n            dumpStoreFiles( fs, failure = exception, \"before-shutdown\" );\n            throw exception;\n        }\n        catch ( SQLException sqlException )\n        {\n            throw new RuntimeException( sqlException );\n        }\n        finally\n        {\n            database.getGraphDatabaseService().shutdown();\n            if ( failure != null )\n            {\n                dumpStoreFiles( fs, failure, \"after-shutdown\" );\n            }\n            if ( conn != null )\n            {\n                try\n                {\n                    conn.close();\n                }\n                catch ( SQLException sqlException )\n                {\n                    throw new RuntimeException( sqlException );\n                }\n            }\n        }\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected QueryExecutionEngine createEngine( GraphDatabaseAPI graphAPI )\n    {\n        LogService logService = graphAPI.getDependencyResolver().resolveDependency( LogService.class );\n        return new ExecutionEngine( graphAPI, logService.getInternalLogProvider() );\n    }","id":43415,"modified_method":"@Override\n    protected QueryExecutionEngine createEngine( GraphDatabaseAPI graphAPI )\n    {\n        LogService logService = graphAPI.getDependencyResolver().resolveDependency( LogService.class );\n        return new ExecutionEngine( new GraphDatabaseCypherService( graphAPI ), logService.getInternalLogProvider() );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ExecutionEngine engineWithLogger( LogProvider logProvider ) throws IOException\n    {\n        return new ExecutionEngine( new TestGraphDatabaseFactory().newImpermanentDatabase(), logProvider );\n    }","id":43416,"modified_method":"private ExecutionEngine engineWithLogger( LogProvider logProvider ) throws IOException\n    {\n        return new ExecutionEngine(\n                new GraphDatabaseCypherService( new TestGraphDatabaseFactory().newImpermanentDatabase() ),\n                logProvider );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void updateNodeByMapParameter()\n    {\n        engine.execute(\n                \"CREATE (n:Reference) SET n = {data} RETURN n\" ,\n                map( \"data\",\n                        map(\"key1\", \"value1\", \"key2\", 1234)\n                )\n        );\n\n        Node node1 = getNodeByIdInTx( 0 );\n\n        assertThat( node1, inTx( gdb, hasProperty( \"key1\" ).withValue( \"value1\" ) ) );\n        assertThat( node1, inTx( gdb, hasProperty( \"key2\" ).withValue( 1234 ) ) );\n\n        engine.execute(\n                \"MATCH (n:Reference) SET n = {data} RETURN n\",\n                map( \"data\",\n                        map(\"key1\", null, \"key3\", 5678)\n                )\n        );\n\n        Node node2 = getNodeByIdInTx( 0 );\n\n        assertThat( node2, inTx( gdb, not( hasProperty( \"key1\" ) ) ) );\n        assertThat( node2, inTx( gdb, not( hasProperty( \"key2\" ) ) ) );\n        assertThat( node2, inTx( gdb, hasProperty( \"key3\" ).withValue(5678) ) );\n    }","id":43417,"modified_method":"@Test\n    public void updateNodeByMapParameter()\n    {\n        engine.execute(\n                \"CREATE (n:Reference) SET n = {data} RETURN n\" ,\n                map( \"data\",\n                        map(\"key1\", \"value1\", \"key2\", 1234)\n                )\n        );\n\n        Node node1 = getNodeByIdInTx( 0 );\n\n        assertThat( node1, inTxS( hasProperty( \"key1\" ).withValue( \"value1\" ) ) );\n        assertThat( node1, inTxS( hasProperty( \"key2\" ).withValue( 1234 ) ) );\n\n        engine.execute(\n                \"MATCH (n:Reference) SET n = {data} RETURN n\",\n                map( \"data\",\n                        map(\"key1\", null, \"key3\", 5678)\n                )\n        );\n\n        Node node2 = getNodeByIdInTx( 0 );\n\n        assertThat( node2, inTxS( not( hasProperty( \"key1\" ) ) ) );\n        assertThat( node2, inTxS( not( hasProperty( \"key2\" ) ) ) );\n        assertThat( node2, inTxS( hasProperty( \"key3\" ).withValue(5678) ) );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void cleanup()\n    {\n        gdb.shutdown();\n    }","id":43418,"modified_method":"@After\n    public void cleanup()\n    {\n        gdb.getGraphDatabaseService().shutdown();\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        gdb = new TestGraphDatabaseFactory().newImpermanentDatabase();\n        engine = new ExecutionEngine(gdb);\n    }","id":43419,"modified_method":"@Before\n    public void setup()\n    {\n        gdb = new GraphDatabaseCypherService(new TestGraphDatabaseFactory().newImpermanentDatabase());\n        engine = new ExecutionEngine(gdb);\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates an execution engine around the give graph database\n     *\n     * @param database The database to wrap\n     * @param logProvider A Log provider for cypher-statements\n     */\n    public DocsExecutionEngine( GraphDatabaseService database, LogProvider logProvider )\n    {\n        inner = (org.neo4j.cypher.internal.DocsExecutionEngine) createInnerEngine( database, logProvider );\n    }","id":43420,"modified_method":"/**\n     * Creates an execution engine around the give graph database\n     *\n     * @param database The database to wrap\n     * @param logProvider A Log provider for cypher-statements\n     */\n    public DocsExecutionEngine( GraphDatabaseQueryService database, LogProvider logProvider )\n    {\n        inner = (org.neo4j.cypher.internal.DocsExecutionEngine) createInnerEngine( database, logProvider );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected\n    org.neo4j.cypher.internal.ExecutionEngine createInnerEngine( GraphDatabaseService database, LogProvider logProvider )\n    {\n        return new org.neo4j.cypher.internal.DocsExecutionEngine( database, logProvider, null, null );\n    }","id":43421,"modified_method":"protected org.neo4j.cypher.internal.ExecutionEngine createInnerEngine( GraphDatabaseQueryService database,\n            LogProvider logProvider )\n    {\n        return new org.neo4j.cypher.internal.DocsExecutionEngine( database, logProvider, null, null );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates an execution engine around the give graph database\n     * @param database The database to wrap\n     */\n    public DocsExecutionEngine( GraphDatabaseService database )\n    {\n        this( database, NullLogProvider.getInstance() );\n    }","id":43422,"modified_method":"/**\n     * Creates an execution engine around the give graph database\n     * @param database The database to wrap\n     */\n    public DocsExecutionEngine( GraphDatabaseQueryService database )\n    {\n        this( database, NullLogProvider.getInstance() );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        EphemeralFileSystemAbstraction fs = new EphemeralFileSystemAbstraction();\n        database = new TestGraphDatabaseFactory().setFileSystem( fs ).newImpermanentDatabase();\n        engine = new DocsExecutionEngine( database );\n    }","id":43423,"modified_method":"@Before\n    public void setup()\n    {\n        EphemeralFileSystemAbstraction fs = new EphemeralFileSystemAbstraction();\n        database = new GraphDatabaseCypherService(new TestGraphDatabaseFactory().setFileSystem( fs ).newImpermanentDatabase());\n        engine = new DocsExecutionEngine( database );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void teardown()\n    {\n        database.shutdown();\n    }","id":43424,"modified_method":"@After\n    public void teardown()\n    {\n        database.getGraphDatabaseService().shutdown();\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates an execution engine around the give graph database\n     * @param database The database to wrap\n     */\n    public ExecutionEngine( GraphDatabaseService database )\n    {\n        inner = createInnerEngine( database, NullLogProvider.getInstance() );\n    }","id":43425,"modified_method":"/**\n     * Creates an execution engine around the give graph database\n     * @param database The database to wrap\n     */\n    public ExecutionEngine( GraphDatabaseQueryService database )\n    {\n        inner = createInnerEngine( database, NullLogProvider.getInstance() );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates an execution engine around the give graph database\n     * @param database The database to wrap\n     * @param logProvider A {@link LogProvider} for cypher-statements\n     */\n    public ExecutionEngine( GraphDatabaseService database, LogProvider logProvider )\n    {\n        inner = createInnerEngine( database, logProvider );\n    }","id":43426,"modified_method":"/**\n     * Creates an execution engine around the give graph database\n     * @param database The database to wrap\n     * @param logProvider A {@link LogProvider} for cypher-statements\n     */\n    public ExecutionEngine( GraphDatabaseQueryService database, LogProvider logProvider )\n    {\n        inner = createInnerEngine( database, logProvider );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected org.neo4j.cypher.internal.ExecutionEngine createInnerEngine( GraphDatabaseService database, LogProvider logProvider )\n    {\n        return new org.neo4j.cypher.internal.ExecutionEngine( database, logProvider );\n    }","id":43427,"modified_method":"protected org.neo4j.cypher.internal.ExecutionEngine createInnerEngine( GraphDatabaseQueryService database, LogProvider logProvider )\n    {\n        return new org.neo4j.cypher.internal.ExecutionEngine( database, logProvider );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldConvertListsAndMapsWhenPassingFromScalaToJava() throws Exception\n    {\n        ExecutionEngine executionEngine = new ExecutionEngine( database.getGraphDatabaseService() );\n\n        ExecutionResult result = executionEngine.execute( \"RETURN { key : 'Value' , \" +\n                                                          \"collectionKey: [{ inner: 'Map1' }, { inner: 'Map2' }]}\" );\n\n        Map firstRowValue = (Map) result.iterator().next().values().iterator().next();\n        assertThat( (String) firstRowValue.get( \"key\" ), is( \"Value\" ) );\n        List theList = (List) firstRowValue.get( \"collectionKey\" );\n        assertThat( (String) ((Map) theList.get( 0 )).get( \"inner\" ), is( \"Map1\" ) );\n        assertThat( (String) ((Map) theList.get( 1 )).get( \"inner\" ), is( \"Map2\" ) );\n    }","id":43428,"modified_method":"@Test\n    public void shouldConvertListsAndMapsWhenPassingFromScalaToJava() throws Exception\n    {\n        ExecutionEngine executionEngine = new ExecutionEngine( new GraphDatabaseCypherService(database.getGraphDatabaseService()) );\n\n        ExecutionResult result = executionEngine.execute( \"RETURN { key : 'Value' , \" +\n                                                          \"collectionKey: [{ inner: 'Map1' }, { inner: 'Map2' }]}\" );\n\n        Map firstRowValue = (Map) result.iterator().next().values().iterator().next();\n        assertThat( (String) firstRowValue.get( \"key\" ), is( \"Value\" ) );\n        List theList = (List) firstRowValue.get( \"collectionKey\" );\n        assertThat( (String) ((Map) theList.get( 0 )).get( \"inner\" ), is( \"Map1\" ) );\n        assertThat( (String) ((Map) theList.get( 1 )).get( \"inner\" ), is( \"Map2\" ) );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void initializeExecutionEngine() throws Exception\n    {\n        engine = new ExecutionEngine( db );\n    }","id":43429,"modified_method":"@Before\n    public void initializeExecutionEngine() throws Exception\n    {\n        engine = new ExecutionEngine( new GraphDatabaseCypherService(db) );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setUp() throws IOException\n    {\n        GraphDatabaseService db = new TestGraphDatabaseFactory().newImpermanentDatabaseBuilder().newGraphDatabase();\n        engine = new ExecutionEngine( db );\n    }","id":43430,"modified_method":"@Before\n    public void setUp() throws IOException\n    {\n        GraphDatabaseService db = new TestGraphDatabaseFactory().newImpermanentDatabaseBuilder().newGraphDatabase();\n        engine = new ExecutionEngine( new GraphDatabaseCypherService( db) );\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldWorkFine() throws IOException\n    {\n        GraphDatabaseService db = dbRule.getGraphDatabaseService();\n\n        Label person = Label.label( \"Person\" );\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            // THIS USED TO CAUSE OUT OF FILE HANDLES\n            // (maybe look at:  http://stackoverflow.com/questions/6210348/too-many-open-files-error-on-lucene)\n            db.schema().indexFor( person ).on( \"id\" ).create();\n\n            // THIS SHOULD ALSO WORK\n            db.schema().constraintFor( person ).assertPropertyIsUnique( \"id\" ).create();\n\n            tx.success();\n        }\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.schema().indexFor( person ).on( \"name\" ).create();\n            tx.success();\n        }\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.schema().awaitIndexesOnline( 1, TimeUnit.MINUTES );\n            tx.success();\n        }\n\n        ExecutionEngine engine = new ExecutionEngine( db );\n\n        for( int count = 0; count < TRIES; count++ )\n        {\n            Pair<String, String> stringPair = getRandomName();\n            String ident = stringPair.first();\n            String name = stringPair.other();\n            String id = Long.toString( Math.abs( random.nextLong() ) );\n            String query =\n                format( \"MERGE (%s:Person {id: %s}) ON CREATE SET %s.name = \\\"%s\\\";\", ident, id, ident, name );\n\n            ExecutionResult result = engine.execute( query );\n            result.iterator().close();\n        }\n    }","id":43431,"modified_method":"@Test\n    public void shouldWorkFine() throws IOException\n    {\n        GraphDatabaseService db = dbRule.getGraphDatabaseService();\n        GraphDatabaseQueryService graph = new GraphDatabaseCypherService( db );\n\n        Label person = Label.label( \"Person\" );\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            // THIS USED TO CAUSE OUT OF FILE HANDLES\n            // (maybe look at:  http://stackoverflow.com/questions/6210348/too-many-open-files-error-on-lucene)\n            db.schema().indexFor( person ).on( \"id\" ).create();\n\n            // THIS SHOULD ALSO WORK\n            db.schema().constraintFor( person ).assertPropertyIsUnique( \"id\" ).create();\n\n            tx.success();\n        }\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.schema().indexFor( person ).on( \"name\" ).create();\n            tx.success();\n        }\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.schema().awaitIndexesOnline( 1, TimeUnit.MINUTES );\n            tx.success();\n        }\n\n        ExecutionEngine engine = new ExecutionEngine( graph );\n\n        for( int count = 0; count < TRIES; count++ )\n        {\n            Pair<String, String> stringPair = getRandomName();\n            String ident = stringPair.first();\n            String name = stringPair.other();\n            String id = Long.toString( Math.abs( random.nextLong() ) );\n            String query =\n                format( \"MERGE (%s:Person {id: %s}) ON CREATE SET %s.name = \\\"%s\\\";\", ident, id, ident, name );\n\n            ExecutionResult result = engine.execute( query );\n            result.iterator().close();\n        }\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Result( String query, InternalExecutionResult result, GraphDatabaseService database )\n    {\n        this.query = query;\n        text = result.dumpToString();\n        try (Transaction tx = database.beginTx())\n        {\n            extract( result.javaIterator() );\n        }\n        String profileText;\n        try\n        {\n            profileText = result.executionPlanDescription().toString();\n        }\n        catch ( Exception ex )\n        {\n            profileText = ex.getMessage();\n        }\n        profile = profileText;\n    }","id":43432,"modified_method":"public Result( String query, InternalExecutionResult result, GraphDatabaseQueryService database )\n    {\n        this.query = query;\n        text = result.dumpToString();\n        try (Transaction tx = database.beginTx())\n        {\n            extract( result.javaIterator() );\n        }\n        String profileText;\n        try\n        {\n            profileText = result.executionPlanDescription().toString();\n        }\n        catch ( Exception ex )\n        {\n            profileText = ex.getMessage();\n        }\n        profile = profileText;\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"State( DocsExecutionEngine engine, GraphDatabaseService database, Connection sqlConnection,\n            File parentDirectory,\n            String url )\n    {\n        this.engine = engine;\n        this.database = database;\n        this.sqlDatabase = sqlConnection;\n        this.parentDirectory = parentDirectory;\n        this.url = url.endsWith( \"/\" ) ? url : url + \"/\";\n    }","id":43433,"modified_method":"State( DocsExecutionEngine engine, GraphDatabaseQueryService database, Connection sqlConnection,\n            File parentDirectory,\n            String url )\n    {\n        this.engine = engine;\n        this.database = database;\n        this.sqlDatabase = sqlConnection;\n        this.parentDirectory = parentDirectory;\n        this.url = url.endsWith( \"/\" ) ? url : url + \"/\";\n    }","commit_id":"10b6deecb0e0aa14ce16d37e7a66413d7f0c0165","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected JChannel createChannel(boolean unique, int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(\"A\", unique, num);\n    }","id":43434,"modified_method":"protected JChannel createChannel(boolean unique, int num) throws Exception {\n        return createChannel(\"A\", unique, num);\n    }","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(String props) throws Exception {\n        return new DefaultChannelTestFactory().createChannel(\"A\", props);\n    }","id":43435,"modified_method":"protected JChannel createChannel(String id) throws Exception {\n        return createChannel(id, false, 1);\n    }","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id, boolean unique, int num) throws Exception {\n            JChannel c=createChannel(id, null);\n            if(unique && !isMuxChannelUsed()) {\n                makeUnique(c, num);\n            }\n            return c;\n        }","id":43436,"modified_method":"public Channel createChannel(String id, boolean unique, int num) throws Exception {\n            JChannel c=createChannel(id, null);\n            if(unique && !isMuxChannelUsed()) {\n                makeUnique(c, num);\n            }\n            return c;\n        }","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a channel and modifies the configuration such that no other channel will able to join this\n     * one even if they have the same cluster name (if unique = true). This is done by modifying mcast_addr and mcast_port with UDP,\n     * and by changing TCP.start_port, TCP.port_range and TCPPING.initial_hosts with TCP. Mainly used to\n     * run TestNG tests concurrently. Note that MuxChannels are not currently supported.\n     * @param num The number of channels we will create. Only important (for port_range) with TCP, ignored by UDP\n     * @return\n     * @throws Exception\n     */\n    protected JChannel createChannel(Object id, boolean unique, int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, unique, num);\n    }","id":43437,"modified_method":"/**\n     * Creates a channel and modifies the configuration such that no other channel will able to join this\n     * one even if they have the same cluster name (if unique = true). This is done by modifying mcast_addr and mcast_port with UDP,\n     * and by changing TCP.start_port, TCP.port_range and TCPPING.initial_hosts with TCP. Mainly used to\n     * run TestNG tests concurrently. Note that MuxChannels are not currently supported.\n     * @param num The number of channels we will create. Only important (for port_range) with TCP, ignored by UDP\n     * @return\n     * @throws Exception\n     */\n    protected JChannel createChannel(String id, boolean unique, int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, unique, num);\n    }","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id) throws Exception;","id":43438,"modified_method":"public Channel createChannel(String id) throws Exception;","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id) throws Exception {\n            return ChannelTestBase.this.createChannel(id);\n        }","id":43439,"modified_method":"public Channel createChannel(String id) throws Exception {\n            return ChannelTestBase.this.createChannel(id);\n        }","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id) throws Exception {\n            return createChannel(id, false, 1);\n        }","id":43440,"modified_method":"public Channel createChannel(String id) throws Exception {\n            return createChannel(id, false, 1);\n        }","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel() throws Exception {\n        return createChannel(\"A\", false, 1);\n    }","id":43441,"modified_method":"protected JChannel createChannel() throws Exception {\n        return createChannel(\"A\");\n    }","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"public JChannel createChannel(Object id, String props) throws Exception {\n            JChannel c=null;\n            if(props == null)\n                props=channel_conf;\n            if(isMuxChannelUsed()) {\n                log.info(\"Using configuration file \" + mux_conf + \", stack is \" + mux_conf_stack);\n                synchronized(muxFactory) {\n                    for(int i=0; i < muxFactory.length; i++) {\n                        if(!muxFactory[i].hasMuxChannel(mux_conf_stack, id.toString())) {\n                            c=(JChannel)muxFactory[i].createMultiplexerChannel(mux_conf_stack, id.toString());\n                            if(useBlocking()) {\n                                c.setOpt(Channel.BLOCK, Boolean.TRUE);\n                            }\n                            return c;\n                        }\n                    }\n                }\n                throw new Exception(\"Cannot create mux channel with id \" + id\n                        + \" since all currently used channels have already registered service with that id\");\n            }\n            else {\n                c=createChannel(props, useBlocking());\n            }\n            return c;\n        }","id":43442,"modified_method":"public JChannel createChannel(String id, String props) throws Exception {\n            JChannel c=null;\n            if(props == null)\n                props=channel_conf;\n            if(isMuxChannelUsed()) {\n                log.info(\"Using configuration file \" + mux_conf + \", stack is \" + mux_conf_stack);\n                synchronized(muxFactory) {\n                    for(int i=0; i < muxFactory.length; i++) {\n                        if(!muxFactory[i].hasMuxChannel(mux_conf_stack, id)) {\n                            c=(JChannel)muxFactory[i].createMultiplexerChannel(mux_conf_stack, id);\n                            if(useBlocking()) {\n                                c.setOpt(Channel.BLOCK, Boolean.TRUE);\n                            }\n                            return c;\n                        }\n                    }\n                }\n                throw new Exception(\"Cannot create mux channel with id \" + id\n                        + \" since an existing channel has already registered a service with that id\");\n            }\n            else {\n                c=createChannel(props, useBlocking());\n            }\n            return c;\n        }","commit_id":"b4cb69781c1035bed917953967ce91c17d5b819f","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(String props) throws Exception {\n        return new DefaultChannelTestFactory().createChannel(\"A\", props);\n    }","id":43443,"modified_method":"protected JChannel createChannel(String id) throws Exception {\n        return createChannel(id, false, 1);\n    }","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id) throws Exception {\n            return ChannelTestBase.this.createChannel(id);\n        }","id":43444,"modified_method":"public Channel createChannel(String id) throws Exception {\n            return ChannelTestBase.this.createChannel(id);\n        }","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(boolean unique, int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(\"A\", unique, num);\n    }","id":43445,"modified_method":"protected JChannel createChannel(boolean unique, int num) throws Exception {\n        return createChannel(\"A\", unique, num);\n    }","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"public JChannel createChannel(Object id, String props) throws Exception {\n            JChannel c=null;\n            if(props == null)\n                props=channel_conf;\n            if(isMuxChannelUsed()) {\n                log.info(\"Using configuration file \" + mux_conf + \", stack is \" + mux_conf_stack);\n                synchronized(muxFactory) {\n                    for(int i=0; i < muxFactory.length; i++) {\n                        if(!muxFactory[i].hasMuxChannel(mux_conf_stack, id.toString())) {\n                            c=(JChannel)muxFactory[i].createMultiplexerChannel(mux_conf_stack, id.toString());\n                            if(useBlocking()) {\n                                c.setOpt(Channel.BLOCK, Boolean.TRUE);\n                            }\n                            return c;\n                        }\n                    }\n                }\n                throw new Exception(\"Cannot create mux channel with id \" + id\n                        + \" since all currently used channels have already registered service with that id\");\n            }\n            else {\n                c=createChannel(props, useBlocking());\n            }\n            return c;\n        }","id":43446,"modified_method":"public JChannel createChannel(String id, String props) throws Exception {\n            JChannel c=null;\n            if(props == null)\n                props=channel_conf;\n            if(isMuxChannelUsed()) {\n                log.info(\"Using configuration file \" + mux_conf + \", stack is \" + mux_conf_stack);\n                synchronized(muxFactory) {\n                    for(int i=0; i < muxFactory.length; i++) {\n                        if(!muxFactory[i].hasMuxChannel(mux_conf_stack, id)) {\n                            c=(JChannel)muxFactory[i].createMultiplexerChannel(mux_conf_stack, id);\n                            if(useBlocking()) {\n                                c.setOpt(Channel.BLOCK, Boolean.TRUE);\n                            }\n                            return c;\n                        }\n                    }\n                }\n                throw new Exception(\"Cannot create mux channel with id \" + id\n                        + \" since an existing channel has already registered a service with that id\");\n            }\n            else {\n                c=createChannel(props, useBlocking());\n            }\n            return c;\n        }","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id, boolean unique, int num) throws Exception {\n            JChannel c=createChannel(id, null);\n            if(unique && !isMuxChannelUsed()) {\n                makeUnique(c, num);\n            }\n            return c;\n        }","id":43447,"modified_method":"public Channel createChannel(String id, boolean unique, int num) throws Exception {\n            JChannel c=createChannel(id, null);\n            if(unique && !isMuxChannelUsed()) {\n                makeUnique(c, num);\n            }\n            return c;\n        }","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id) throws Exception;","id":43448,"modified_method":"public Channel createChannel(String id) throws Exception;","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id) throws Exception {\n            return createChannel(id, false, 1);\n        }","id":43449,"modified_method":"public Channel createChannel(String id) throws Exception {\n            return createChannel(id, false, 1);\n        }","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel() throws Exception {\n        return createChannel(\"A\", false, 1);\n    }","id":43450,"modified_method":"protected JChannel createChannel() throws Exception {\n        return createChannel(\"A\");\n    }","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a channel and modifies the configuration such that no other channel will able to join this\n     * one even if they have the same cluster name (if unique = true). This is done by modifying mcast_addr and mcast_port with UDP,\n     * and by changing TCP.start_port, TCP.port_range and TCPPING.initial_hosts with TCP. Mainly used to\n     * run TestNG tests concurrently. Note that MuxChannels are not currently supported.\n     * @param num The number of channels we will create. Only important (for port_range) with TCP, ignored by UDP\n     * @return\n     * @throws Exception\n     */\n    protected JChannel createChannel(Object id, boolean unique, int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, unique, num);\n    }","id":43451,"modified_method":"/**\n     * Creates a channel and modifies the configuration such that no other channel will able to join this\n     * one even if they have the same cluster name (if unique = true). This is done by modifying mcast_addr and mcast_port with UDP,\n     * and by changing TCP.start_port, TCP.port_range and TCPPING.initial_hosts with TCP. Mainly used to\n     * run TestNG tests concurrently. Note that MuxChannels are not currently supported.\n     * @param num The number of channels we will create. Only important (for port_range) with TCP, ignored by UDP\n     * @return\n     * @throws Exception\n     */\n    protected JChannel createChannel(String id, boolean unique, int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, unique, num);\n    }","commit_id":"6f9f625b4fbce577e8034f5f57c80c6e94d2602e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id, String props) throws Exception {\n            JChannel c=null;\n            if(props == null)\n                props=channel_conf;\n            if(isMuxChannelUsed()) {\n                log.info(\"Using configuration file \" + mux_conf + \", stack is \" + mux_conf_stack);\n                synchronized(muxFactory) {\n                    for(int i=0; i < muxFactory.length; i++) {\n                        if(!muxFactory[i].hasMuxChannel(mux_conf_stack, id.toString())) {\n                            c=(JChannel)muxFactory[i].createMultiplexerChannel(mux_conf_stack, id.toString());\n                            if(useBlocking()) {\n                                c.setOpt(Channel.BLOCK, Boolean.TRUE);\n                            }\n                            return c;\n                        }\n                    }\n                }\n                throw new Exception(\"Cannot create mux channel with id \" + id\n                        + \" since all currently used channels have already registered service with that id\");\n            }\n            else {\n                c=createChannel(props, useBlocking());\n            }\n            return c;\n        }","id":43452,"modified_method":"public JChannel createChannel(Object id, String props) throws Exception {\n            JChannel c=null;\n            if(props == null)\n                props=channel_conf;\n            if(isMuxChannelUsed()) {\n                log.info(\"Using configuration file \" + mux_conf + \", stack is \" + mux_conf_stack);\n                synchronized(muxFactory) {\n                    for(int i=0; i < muxFactory.length; i++) {\n                        if(!muxFactory[i].hasMuxChannel(mux_conf_stack, id.toString())) {\n                            c=(JChannel)muxFactory[i].createMultiplexerChannel(mux_conf_stack, id.toString());\n                            if(useBlocking()) {\n                                c.setOpt(Channel.BLOCK, Boolean.TRUE);\n                            }\n                            return c;\n                        }\n                    }\n                }\n                throw new Exception(\"Cannot create mux channel with id \" + id\n                        + \" since all currently used channels have already registered service with that id\");\n            }\n            else {\n                c=createChannel(props, useBlocking());\n            }\n            return c;\n        }","commit_id":"9a9b6eceeb0a47909dd4c1b1137aa86da29061f6","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a channel and modifies the configuration such that no other channel will able to join this\n     * one even if they have the same cluster name. This is done by modifying mcast_addr and mcast_port with UDP,\n     * and by changing TCP.start_port, TCP.port_range and TCPPING.initial_hosts with TCP. Mainly used to\n     * run TestNG tests concurrently. Note that MuxChannels are not currently supported.\n     * @param num The number of channels we will create. Only important (for port_range) with TCP, ignored by UDP\n     * @return\n     * @throws Exception\n     */\n    protected JChannel createUniqueChannel(int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createUniqueChannel(num);\n    }","id":43453,"modified_method":"/**\n     * Creates a channel and modifies the configuration such that no other channel will able to join this\n     * one even if they have the same cluster name (if unique = true). This is done by modifying mcast_addr and mcast_port with UDP,\n     * and by changing TCP.start_port, TCP.port_range and TCPPING.initial_hosts with TCP. Mainly used to\n     * run TestNG tests concurrently. Note that MuxChannels are not currently supported.\n     * @param num The number of channels we will create. Only important (for port_range) with TCP, ignored by UDP\n     * @return\n     * @throws Exception\n     */\n    protected JChannel createChannel(Object id, boolean unique, int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, unique, num);\n    }","commit_id":"9a9b6eceeb0a47909dd4c1b1137aa86da29061f6","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id) throws Exception {\n            return createChannel(id, null);\n        }","id":43454,"modified_method":"public Channel createChannel(Object id) throws Exception {\n            return createChannel(id, false, 1);\n        }","commit_id":"9a9b6eceeb0a47909dd4c1b1137aa86da29061f6","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel() throws Exception {\n        return createChannel(\"A\");\n    }","id":43455,"modified_method":"protected JChannel createChannel() throws Exception {\n        return createChannel(\"A\", false, 1);\n    }","commit_id":"9a9b6eceeb0a47909dd4c1b1137aa86da29061f6","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(Object id, String props) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, props);\n    }","id":43456,"modified_method":"protected JChannel createChannel(Object id, String props) throws Exception {\n        return new DefaultChannelTestFactory().createChannel(id, props);\n    }","commit_id":"9a9b6eceeb0a47909dd4c1b1137aa86da29061f6","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(String configFile, boolean useBlocking)\n                throws Exception {\n            Map<Integer, Object> channelOptions=new HashMap<Integer, Object>();\n            channelOptions.put(Channel.BLOCK, useBlocking);\n            return createChannel(configFile, channelOptions);\n        }","id":43457,"modified_method":"private JChannel createChannel(String configFile, boolean useBlocking) throws Exception {\n            Map<Integer, Object> channelOptions=new HashMap<Integer, Object>();\n            channelOptions.put(Channel.BLOCK, useBlocking);\n\n            log.info(\"Using configuration file \" + configFile);\n            JChannel ch=new JChannel(configFile);\n            for(Map.Entry<Integer, Object> entry : channelOptions.entrySet()) {\n                Integer key=entry.getKey();\n                Object value=entry.getValue();\n                ch.setOpt(key, value);\n            }\n            return ch;\n        }","commit_id":"9a9b6eceeb0a47909dd4c1b1137aa86da29061f6","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createUniqueChannel(int num) throws Exception {\n            JChannel c=null;\n            if(isMuxChannelUsed()) {\n                throw new IllegalStateException(\"MuxChannels are currently not supported\");\n            }\n            c=createChannel(channel_conf, useBlocking());\n            ProtocolStack stack=c.getProtocolStack();\n            Protocol transport=stack.getTransport();\n            Properties props=new Properties();\n            if(transport instanceof UDP) {\n                String mcast_addr=ResourceManager.getNextMulticastAddress();\n                short mcast_port=ResourceManager.getNextMulticastPort(InetAddress.getByName(bind_addr));\n                props.setProperty(\"mcast_addr\", mcast_addr);\n                props.setProperty(\"mcast_port\", String.valueOf(mcast_port));\n                transport.setProperties(props);\n            }\n            else if(transport instanceof BasicTCP) {\n                List<Short> ports=ResourceManager.getNextTcpPorts(InetAddress.getByName(bind_addr), num);\n\n                props.setProperty(\"bind_port\", String.valueOf(ports.get(0)));\n                props.setProperty(\"port_range\", String.valueOf(num));\n                transport.setProperties(props);\n\n                Protocol ping=stack.findProtocol(TCPPING.class);\n                if(ping == null)\n                    throw new IllegalStateException(\"TCP stack must consist of TCP:TCPPING - other config are not supported\");\n                props.clear();\n\n                List<String> initial_hosts=new LinkedList<String>();\n                for(short port: ports) {\n                    initial_hosts.add(bind_addr + \"[\" + port + \"]\");\n                }\n                String tmp=Util.printListWithDelimiter(initial_hosts, \",\");\n                props.setProperty(\"initial_hosts\", tmp);\n            }\n            else {\n                throw new IllegalStateException(\"Only UDP and TCP are supported as transport protocols\");\n            }\n            return c;\n        }","id":43458,"modified_method":"private void makeUnique(JChannel channel, int num) throws Exception {\n            ProtocolStack stack=channel.getProtocolStack();\n            Protocol transport=stack.getTransport();\n            Properties props=new Properties();\n            if(transport instanceof UDP) {\n                String mcast_addr=ResourceManager.getNextMulticastAddress();\n                short mcast_port=ResourceManager.getNextMulticastPort(InetAddress.getByName(bind_addr));\n                props.setProperty(\"mcast_addr\", mcast_addr);\n                props.setProperty(\"mcast_port\", String.valueOf(mcast_port));\n                transport.setProperties(props);\n            }\n            else if(transport instanceof BasicTCP) {\n                List<Short> ports=ResourceManager.getNextTcpPorts(InetAddress.getByName(bind_addr), num);\n\n                props.setProperty(\"bind_port\", String.valueOf(ports.get(0)));\n                props.setProperty(\"port_range\", String.valueOf(num));\n                transport.setProperties(props);\n\n                Protocol ping=stack.findProtocol(TCPPING.class);\n                if(ping == null)\n                    throw new IllegalStateException(\"TCP stack must consist of TCP:TCPPING - other config are not supported\");\n                props.clear();\n\n                List<String> initial_hosts=new LinkedList<String>();\n                for(short port: ports) {\n                    initial_hosts.add(bind_addr + \"[\" + port + \"]\");\n                }\n                String tmp=Util.printListWithDelimiter(initial_hosts, \",\");\n                props.setProperty(\"initial_hosts\", tmp);\n            }\n            else {\n                throw new IllegalStateException(\"Only UDP and TCP are supported as transport protocols\");\n            }\n        }","commit_id":"9a9b6eceeb0a47909dd4c1b1137aa86da29061f6","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(Object id) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id);\n    }","id":43459,"modified_method":"protected JChannel createChannel(Object id) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, false, 1);\n    }","commit_id":"9a9b6eceeb0a47909dd4c1b1137aa86da29061f6","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final Resource resource) throws OperationFailedException {\n        ModelNode model = resource.getModel();\n        String name = JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute().resolveModelAttribute(context, model).asString();\n\n        String policy = JcaDistributedWorkManagerDefinition.DWmParameters.POLICY.getAttribute().resolveModelAttribute(context, model).asString();\n        String selector = JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR.getAttribute().resolveModelAttribute(context, model).asString();\n\n        ServiceTarget serviceTarget = context.getServiceTarget();\n        NamedDistributedWorkManager namedDistributedWorkManager = new NamedDistributedWorkManager(name);\n\n        if (policy != null && !policy.trim().isEmpty()) {\n            switch (JcaDistributedWorkManagerDefinition.PolicyValue.valueOf(policy)) {\n                case NEVER: {\n                    namedDistributedWorkManager.setPolicy(new Never());\n                    break;\n                }\n                case ALWAYS: {\n                    namedDistributedWorkManager.setPolicy(new Always());\n                    break;\n                }\n                case WATERMARK: {\n                    namedDistributedWorkManager.setPolicy(new WaterMark());\n                    break;\n                }\n                default:\n                    throw ROOT_LOGGER.unsupportedPolicy(policy);\n\n            }\n            Injection injector = new Injection();\n            for (Map.Entry<String, String> entry : ((PropertiesAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.POLICY_OPTIONS.getAttribute()).unwrap(context, model).entrySet()) {\n                try {\n                    injector.inject(namedDistributedWorkManager.getPolicy(), entry.getKey(), entry.getValue());\n                } catch (Exception e) {\n                    ROOT_LOGGER.unsupportedPolicyOption(entry.getKey());\n                }\n            }\n        } else {\n            namedDistributedWorkManager.setPolicy(new WaterMark());\n        }\n\n        if (selector != null && !selector.trim().isEmpty()) {\n            switch (JcaDistributedWorkManagerDefinition.SelectorValue.valueOf(selector)) {\n                case FIRST_AVAILABLE: {\n                    namedDistributedWorkManager.setSelector(new FirstAvailable());\n                    break;\n                }\n                case MAX_FREE_THREADS: {\n                    namedDistributedWorkManager.setSelector(new MaxFreeThreads());\n                    break;\n                }\n                case PING_TIME: {\n                    namedDistributedWorkManager.setSelector(new PingTime());\n                    break;\n                }\n                default:\n                    throw ROOT_LOGGER.unsupportedSelector(selector);\n            }\n            Injection injector = new Injection();\n            for (Map.Entry<String, String> entry : ((PropertiesAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR_OPTIONS.getAttribute()).unwrap(context, model).entrySet()) {\n                try {\n                    injector.inject(namedDistributedWorkManager.getSelector(), entry.getKey(), entry.getValue());\n                } catch (Exception e) {\n                    ROOT_LOGGER.unsupportedSelectorOption(entry.getKey());\n                }\n            }\n        } else {\n            namedDistributedWorkManager.setSelector(new PingTime());\n        }\n\n        String jgroupsStack = model.hasDefined(JcaDistributedWorkManagerDefinition.DWmParameters.TRANSPORT_JGROPUS_STACK.getAttribute().getName()) ?\n                JcaDistributedWorkManagerDefinition.DWmParameters.TRANSPORT_JGROPUS_STACK.getAttribute().resolveModelAttribute(context, model).asString() :\n                \"udp\";\n        String channelName = JcaDistributedWorkManagerDefinition.DWmParameters.TRANSPORT_JGROPUS_CLUSTER.getAttribute().resolveModelAttribute(context, model).asString();\n        Long requestTimeout = JcaDistributedWorkManagerDefinition.DWmParameters.TRANSPORT_REQUEST_TIMEOUT.getAttribute().resolveModelAttribute(context, model).asLong();\n\n        DistributedWorkManagerService wmService = new DistributedWorkManagerService(namedDistributedWorkManager, channelName, requestTimeout);\n        ServiceBuilder<DistributedWorkManager> builder = serviceTarget\n                .addService(ConnectorServices.WORKMANAGER_SERVICE.append(name), wmService);\n        builder.addDependency(ProtocolStackServiceName.CHANNEL_FACTORY.getServiceName(jgroupsStack), ChannelFactory.class, wmService.getJGroupsChannelFactoryInjector());\n\n\n        builder.addDependency(ServiceBuilder.DependencyType.OPTIONAL, ThreadsServices.EXECUTOR.append(WORKMANAGER_LONG_RUNNING).append(name), Executor.class, wmService.getExecutorLongInjector());\n        builder.addDependency(ThreadsServices.EXECUTOR.append(WORKMANAGER_SHORT_RUNNING).append(name), Executor.class, wmService.getExecutorShortInjector());\n\n        builder.addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class, wmService.getXaTerminatorInjector())\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n        WorkManagerStatisticsService wmStatsService = new WorkManagerStatisticsService(context.getResourceRegistrationForUpdate(), name, true);\n        serviceTarget\n                .addService(ConnectorServices.WORKMANAGER_STATS_SERVICE.append(name), wmStatsService)\n                .addDependency(ConnectorServices.WORKMANAGER_SERVICE.append(name), WorkManager.class, wmStatsService.getWorkManagerInjector())\n                .setInitialMode(ServiceController.Mode.PASSIVE).install();\n        DistributedWorkManagerStatisticsService dwmStatsService = new DistributedWorkManagerStatisticsService(context.getResourceRegistrationForUpdate(), name, true);\n        serviceTarget\n                .addService(ConnectorServices.DISTRIBUTED_WORKMANAGER_STATS_SERVICE.append(name), dwmStatsService)\n                .addDependency(ConnectorServices.WORKMANAGER_SERVICE.append(name), DistributedWorkManager.class, dwmStatsService.getDistributedWorkManagerInjector())\n                .setInitialMode(ServiceController.Mode.PASSIVE).install();\n        PathElement peDistributedWm = PathElement.pathElement(org.jboss.as.connector.subsystems.resourceadapters.Constants.STATISTICS_NAME, \"distributed\");\n                PathElement peLocaldWm = PathElement.pathElement(org.jboss.as.connector.subsystems.resourceadapters.Constants.STATISTICS_NAME, \"local\");\n\n                final Resource wmResource = new IronJacamarResource.IronJacamarRuntimeResource();\n\n                if (!resource.hasChild(peLocaldWm))\n                    resource.registerChild(peLocaldWm, wmResource);\n\n\n                final Resource dwmResource = new IronJacamarResource.IronJacamarRuntimeResource();\n\n                if (!resource.hasChild(peDistributedWm))\n                    resource.registerChild(peDistributedWm, dwmResource);\n    }","id":43460,"modified_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final Resource resource) throws OperationFailedException {\n        ModelNode model = resource.getModel();\n        String name = JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute().resolveModelAttribute(context, model).asString();\n\n        String policy = JcaDistributedWorkManagerDefinition.DWmParameters.POLICY.getAttribute().resolveModelAttribute(context, model).asString();\n        String selector = JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR.getAttribute().resolveModelAttribute(context, model).asString();\n\n        ServiceTarget serviceTarget = context.getServiceTarget();\n        NamedDistributedWorkManager namedDistributedWorkManager = new NamedDistributedWorkManager(name);\n\n        if (policy != null && !policy.trim().isEmpty()) {\n            switch (JcaDistributedWorkManagerDefinition.PolicyValue.valueOf(policy)) {\n                case NEVER: {\n                    namedDistributedWorkManager.setPolicy(new Never());\n                    break;\n                }\n                case ALWAYS: {\n                    namedDistributedWorkManager.setPolicy(new Always());\n                    break;\n                }\n                case WATERMARK: {\n                    namedDistributedWorkManager.setPolicy(new WaterMark());\n                    break;\n                }\n                default:\n                    throw ROOT_LOGGER.unsupportedPolicy(policy);\n\n            }\n            Injection injector = new Injection();\n            for (Map.Entry<String, String> entry : ((PropertiesAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.POLICY_OPTIONS.getAttribute()).unwrap(context, model).entrySet()) {\n                try {\n                    injector.inject(namedDistributedWorkManager.getPolicy(), entry.getKey(), entry.getValue());\n                } catch (Exception e) {\n                    ROOT_LOGGER.unsupportedPolicyOption(entry.getKey());\n                }\n            }\n        } else {\n            namedDistributedWorkManager.setPolicy(new WaterMark());\n        }\n\n        if (selector != null && !selector.trim().isEmpty()) {\n            switch (JcaDistributedWorkManagerDefinition.SelectorValue.valueOf(selector)) {\n                case FIRST_AVAILABLE: {\n                    namedDistributedWorkManager.setSelector(new FirstAvailable());\n                    break;\n                }\n                case MAX_FREE_THREADS: {\n                    namedDistributedWorkManager.setSelector(new MaxFreeThreads());\n                    break;\n                }\n                case PING_TIME: {\n                    namedDistributedWorkManager.setSelector(new PingTime());\n                    break;\n                }\n                default:\n                    throw ROOT_LOGGER.unsupportedSelector(selector);\n            }\n            Injection injector = new Injection();\n            for (Map.Entry<String, String> entry : ((PropertiesAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR_OPTIONS.getAttribute()).unwrap(context, model).entrySet()) {\n                try {\n                    injector.inject(namedDistributedWorkManager.getSelector(), entry.getKey(), entry.getValue());\n                } catch (Exception e) {\n                    ROOT_LOGGER.unsupportedSelectorOption(entry.getKey());\n                }\n            }\n        } else {\n            namedDistributedWorkManager.setSelector(new PingTime());\n        }\n\n        DistributedWorkManagerService wmService = new DistributedWorkManagerService(namedDistributedWorkManager);\n        ServiceBuilder<DistributedWorkManager> builder = serviceTarget\n                .addService(ConnectorServices.WORKMANAGER_SERVICE.append(name), wmService);\n        builder.addDependency(ProtocolStackServiceName.CHANNEL_FACTORY.getServiceName(), ChannelFactory.class, wmService.getJGroupsChannelFactoryInjector());\n\n\n        builder.addDependency(ServiceBuilder.DependencyType.OPTIONAL, ThreadsServices.EXECUTOR.append(WORKMANAGER_LONG_RUNNING).append(name), Executor.class, wmService.getExecutorLongInjector());\n        builder.addDependency(ThreadsServices.EXECUTOR.append(WORKMANAGER_SHORT_RUNNING).append(name), Executor.class, wmService.getExecutorShortInjector());\n\n        builder.addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class, wmService.getXaTerminatorInjector())\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n        WorkManagerStatisticsService wmStatsService = new WorkManagerStatisticsService(context.getResourceRegistrationForUpdate(), name, true);\n        serviceTarget\n                .addService(ConnectorServices.WORKMANAGER_STATS_SERVICE.append(name), wmStatsService)\n                .addDependency(ConnectorServices.WORKMANAGER_SERVICE.append(name), WorkManager.class, wmStatsService.getWorkManagerInjector())\n                .setInitialMode(ServiceController.Mode.PASSIVE).install();\n        DistributedWorkManagerStatisticsService dwmStatsService = new DistributedWorkManagerStatisticsService(context.getResourceRegistrationForUpdate(), name, true);\n        serviceTarget\n                .addService(ConnectorServices.DISTRIBUTED_WORKMANAGER_STATS_SERVICE.append(name), dwmStatsService)\n                .addDependency(ConnectorServices.WORKMANAGER_SERVICE.append(name), DistributedWorkManager.class, dwmStatsService.getDistributedWorkManagerInjector())\n                .setInitialMode(ServiceController.Mode.PASSIVE).install();\n        PathElement peDistributedWm = PathElement.pathElement(org.jboss.as.connector.subsystems.resourceadapters.Constants.STATISTICS_NAME, \"distributed\");\n        PathElement peLocaldWm = PathElement.pathElement(org.jboss.as.connector.subsystems.resourceadapters.Constants.STATISTICS_NAME, \"local\");\n\n        final Resource wmResource = new IronJacamarResource.IronJacamarRuntimeResource();\n\n        if (!resource.hasChild(peLocaldWm))\n            resource.registerChild(peLocaldWm, wmResource);\n\n\n        final Resource dwmResource = new IronJacamarResource.IronJacamarRuntimeResource();\n\n        if (!resource.hasChild(peDistributedWm))\n            resource.registerChild(peDistributedWm, dwmResource);\n    }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        ROOT_LOGGER.debugf(\"Starting JCA DistributedWorkManager: \", value.getName());\n\n        JGroupsTransport transport = new JGroupsTransport();\n        try {\n            transport.setChannel((JChannel) jGroupsChannelFactory.getValue().createChannel(jgroupsChannelName));\n\n            if (jgroupsChannelName != null)\n                transport.setClusterName(jgroupsChannelName);\n\n            if (requestTimeout != null)\n                transport.setTimeout(requestTimeout);\n\n            this.value.setTransport(transport);\n        } catch (Exception e) {\n            ROOT_LOGGER.trace(\"failed to start JGroups channel\", e);\n            throw ROOT_LOGGER.failedToStartJGroupsChannel(jgroupsChannelName, this.value.getName());\n        }\n\n        BlockingExecutor longRunning = (BlockingExecutor) executorLong.getOptionalValue();\n        if (longRunning != null) {\n            this.value.setLongRunningThreadPool(longRunning);\n            this.value.setShortRunningThreadPool((BlockingExecutor) executorShort.getValue());\n        } else {\n            this.value.setLongRunningThreadPool((BlockingExecutor) executorShort.getValue());\n            this.value.setShortRunningThreadPool((BlockingExecutor) executorShort.getValue());\n\n        }\n\n        this.value.setXATerminator(new XATerminatorImpl(xaTerminator.getValue()));\n\n        WorkManagerCoordinator.getInstance().registerWorkManager(value);\n\n        try {\n            transport.startup();\n        } catch (Throwable throwable) {\n            ROOT_LOGGER.trace(\"failed to start DWM transport:\", throwable);\n            throw ROOT_LOGGER.failedToStartDWMTransport(this.value.getName());\n        }\n\n        ROOT_LOGGER.debugf(\"Started JCA DistributedWorkManager: \", value.getName());\n    }","id":43461,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        ROOT_LOGGER.debugf(\"Starting JCA DistributedWorkManager: \", value.getName());\n\n        JGroupsTransport transport = new JGroupsTransport();\n        try {\n            transport.setChannel(jGroupsChannelFactory.getValue().createChannel(this.value.getName()));\n            transport.setClusterName(this.value.getName());\n\n            this.value.setTransport(transport);\n        } catch (Exception e) {\n            ROOT_LOGGER.trace(\"failed to start JGroups channel\", e);\n            throw ROOT_LOGGER.failedToStartJGroupsChannel(this.value.getName(), this.value.getName());\n        }\n\n        BlockingExecutor longRunning = (BlockingExecutor) executorLong.getOptionalValue();\n        if (longRunning != null) {\n            this.value.setLongRunningThreadPool(longRunning);\n            this.value.setShortRunningThreadPool((BlockingExecutor) executorShort.getValue());\n        } else {\n            this.value.setLongRunningThreadPool((BlockingExecutor) executorShort.getValue());\n            this.value.setShortRunningThreadPool((BlockingExecutor) executorShort.getValue());\n\n        }\n\n        this.value.setXATerminator(new XATerminatorImpl(xaTerminator.getValue()));\n\n        WorkManagerCoordinator.getInstance().registerWorkManager(value);\n\n        try {\n            transport.startup();\n        } catch (Throwable throwable) {\n            ROOT_LOGGER.trace(\"failed to start DWM transport:\", throwable);\n            throw ROOT_LOGGER.failedToStartDWMTransport(this.value.getName());\n        }\n\n        ROOT_LOGGER.debugf(\"Started JCA DistributedWorkManager: \", value.getName());\n    }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * create an instance\n     *\n     * @param value the work manager\n     */\n    public DistributedWorkManagerService(DistributedWorkManager value, final String jgroupsChannelName, final Long requestTimeout) {\n        super();\n        ROOT_LOGGER.debugf(\"Building WorkManager\");\n        this.value = value;\n        this.jgroupsChannelName = jgroupsChannelName;\n        this.requestTimeout = requestTimeout;\n\n    }","id":43462,"modified_method":"/**\n     * create an instance\n     *\n     * @param value the work manager\n     */\n    public DistributedWorkManagerService(DistributedWorkManager value) {\n        super();\n        ROOT_LOGGER.debugf(\"Building DistributedWorkManager\");\n        this.value = value;\n    }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n        super.registerAttributes(resourceRegistration);\n\n        for (final AttributeDefinition ad : DWmParameters.getReadOnlyAttributeDefinitions()) {\n            resourceRegistration.registerReadOnlyAttribute(ad, ReadResourceNameOperationStepHandler.INSTANCE);\n        }\n\n        for (final AttributeDefinition ad : DWmParameters.getReloadRequiredAttributeDefinitions()) {\n            resourceRegistration.registerReadWriteAttribute(ad, null, new ReloadRequiredWriteAttributeHandler(ad));\n        }\n\n        for (final AttributeDefinition ad : DWmParameters.getRuntimeAttributeDefinitions()) {\n            resourceRegistration.registerReadWriteAttribute(ad, null, JcaDistributedWorkManagerWriteHandler.INSTANCE);\n        }\n\n    }","id":43463,"modified_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n        super.registerAttributes(resourceRegistration);\n\n        for (final AttributeDefinition ad : DWmParameters.getReadOnlyAttributeDefinitions()) {\n            resourceRegistration.registerReadOnlyAttribute(ad, ReadResourceNameOperationStepHandler.INSTANCE);\n        }\n\n        for (final AttributeDefinition ad : DWmParameters.getRuntimeAttributeDefinitions()) {\n            resourceRegistration.registerReadWriteAttribute(ad, null, JcaDistributedWorkManagerWriteHandler.INSTANCE);\n        }\n\n    }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> list) throws XMLStreamException {\n\n            final ModelNode address = new ModelNode();\n            address.add(org.jboss.as.controller.descriptions.ModelDescriptionConstants.SUBSYSTEM, JCA);\n            address.protect();\n\n            final ModelNode subsystem = new ModelNode();\n            subsystem.get(OP).set(ADD);\n            subsystem.get(OP_ADDR).set(address);\n            list.add(subsystem);\n\n            // Handle elements\n            final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n            final EnumSet<Element> requiredElement = EnumSet.of(Element.DEFAULT_WORKMANAGER);\n            boolean ccmAdded = false;\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n\n                switch (Namespace.forUri(reader.getNamespaceURI())) {\n                    case JCA_3_0:\n                    case JCA_2_0:\n                    case JCA_1_1: {\n                        final Element element = Element.forName(reader.getLocalName());\n                        if (!visited.add(element)) {\n                            throw unexpectedElement(reader);\n                        }\n\n                        switch (element) {\n                            case ARCHIVE_VALIDATION: {\n                                list.add(parseArchiveValidation(reader, address));\n                                break;\n                            }\n                            case BEAN_VALIDATION: {\n                                list.add(parseBeanValidation(reader, address));\n                                break;\n                            }\n                            case DEFAULT_WORKMANAGER: {\n                                parseWorkManager(reader, address, list, subsystem, true);\n                                final ModelNode bootstrapContextOperation = new ModelNode();\n                                bootstrapContextOperation.get(OP).set(ADD);\n                                final ModelNode bootStrapCOntextAddress = address.clone();\n                                bootStrapCOntextAddress.add(BOOTSTRAP_CONTEXT, DEFAULT_NAME);\n                                bootStrapCOntextAddress.protect();\n\n                                bootstrapContextOperation.get(OP_ADDR).set(bootStrapCOntextAddress);\n                                bootstrapContextOperation.get(WORKMANAGER).set(DEFAULT_NAME);\n                                bootstrapContextOperation.get(NAME).set(DEFAULT_NAME);\n                                list.add(bootstrapContextOperation);\n\n                                requiredElement.remove(Element.DEFAULT_WORKMANAGER);\n\n                                break;\n                            }\n                            case CACHED_CONNECTION_MANAGER: {\n                                list.add(parseCcm(reader, address));\n                                ccmAdded = true;\n                                break;\n                            }\n                            case WORKMANAGER: {\n                                parseWorkManager(reader, address, list, subsystem, false);\n                                // AS7-4434 Multiple work managers are allowed\n                                visited.remove(Element.WORKMANAGER);\n                                break;\n                            }\n                            case DISTRIBUTED_WORKMANAGER: {\n                                parseDistributedWorkManager(reader, address, list, subsystem, false);\n                                // AS7-4434 Multiple work managers are allowed\n                                visited.remove(Element.DISTRIBUTED_WORKMANAGER);\n                                break;\n                            }\n                            case BOOTSTRAP_CONTEXTS: {\n                                parseBootstrapContexts(reader, address, list);\n                                break;\n                            }\n                            case TRACER: {\n                                if (Namespace.forUri(reader.getNamespaceURI()).equals(Namespace.JCA_3_0)) {\n                                    list.add(parseTracer(reader, address));\n                                } else {\n                                    throw unexpectedElement(reader);\n                                }\n                                break;\n                            }\n                            default:\n                                throw unexpectedElement(reader);\n                        }\n                        break;\n                    }\n                    default:\n                        throw unexpectedElement(reader);\n                }\n            }\n            if (!requiredElement.isEmpty()) {\n                throw missingRequiredElement(reader, requiredElement);\n            }\n            if (!ccmAdded) {\n                final ModelNode ccmOperation = new ModelNode();\n                ccmOperation.get(OP).set(ADD);\n\n                final ModelNode ccmAddress = address.clone();\n                ccmAddress.add(CACHED_CONNECTION_MANAGER, CACHED_CONNECTION_MANAGER);\n                ccmAddress.protect();\n\n                ccmOperation.get(OP_ADDR).set(ccmAddress);\n                list.add(ccmOperation);\n            }\n        }","id":43464,"modified_method":"@Override\n        public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> list) throws XMLStreamException {\n\n            final ModelNode address = new ModelNode();\n            address.add(org.jboss.as.controller.descriptions.ModelDescriptionConstants.SUBSYSTEM, JCA);\n            address.protect();\n\n            final ModelNode subsystem = new ModelNode();\n            subsystem.get(OP).set(ADD);\n            subsystem.get(OP_ADDR).set(address);\n            list.add(subsystem);\n\n            // Handle elements\n            final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n            final EnumSet<Element> requiredElement = EnumSet.of(Element.DEFAULT_WORKMANAGER);\n            boolean ccmAdded = false;\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n\n                switch (Namespace.forUri(reader.getNamespaceURI())) {\n                    case JCA_4_0:\n                    case JCA_3_0:\n                    case JCA_2_0:\n                    case JCA_1_1: {\n                        final Element element = Element.forName(reader.getLocalName());\n                        if (!visited.add(element)) {\n                            throw unexpectedElement(reader);\n                        }\n\n                        switch (element) {\n                            case ARCHIVE_VALIDATION: {\n                                list.add(parseArchiveValidation(reader, address));\n                                break;\n                            }\n                            case BEAN_VALIDATION: {\n                                list.add(parseBeanValidation(reader, address));\n                                break;\n                            }\n                            case DEFAULT_WORKMANAGER: {\n                                parseWorkManager(reader, address, list, subsystem, true);\n                                final ModelNode bootstrapContextOperation = new ModelNode();\n                                bootstrapContextOperation.get(OP).set(ADD);\n                                final ModelNode bootStrapCOntextAddress = address.clone();\n                                bootStrapCOntextAddress.add(BOOTSTRAP_CONTEXT, DEFAULT_NAME);\n                                bootStrapCOntextAddress.protect();\n\n                                bootstrapContextOperation.get(OP_ADDR).set(bootStrapCOntextAddress);\n                                bootstrapContextOperation.get(WORKMANAGER).set(DEFAULT_NAME);\n                                bootstrapContextOperation.get(NAME).set(DEFAULT_NAME);\n                                list.add(bootstrapContextOperation);\n\n                                requiredElement.remove(Element.DEFAULT_WORKMANAGER);\n\n                                break;\n                            }\n                            case CACHED_CONNECTION_MANAGER: {\n                                list.add(parseCcm(reader, address));\n                                ccmAdded = true;\n                                break;\n                            }\n                            case WORKMANAGER: {\n                                parseWorkManager(reader, address, list, subsystem, false);\n                                // AS7-4434 Multiple work managers are allowed\n                                visited.remove(Element.WORKMANAGER);\n                                break;\n                            }\n                            case DISTRIBUTED_WORKMANAGER: {\n                                parseDistributedWorkManager(reader, address, list, subsystem, false);\n                                // AS7-4434 Multiple work managers are allowed\n                                visited.remove(Element.DISTRIBUTED_WORKMANAGER);\n                                break;\n                            }\n                            case BOOTSTRAP_CONTEXTS: {\n                                parseBootstrapContexts(reader, address, list);\n                                break;\n                            }\n                            case TRACER: {\n                                if (Namespace.forUri(reader.getNamespaceURI()).equals(Namespace.JCA_3_0) ||\n                                    Namespace.forUri(reader.getNamespaceURI()).equals(Namespace.JCA_4_0)) {\n                                    list.add(parseTracer(reader, address));\n                                } else {\n                                    throw unexpectedElement(reader);\n                                }\n                                break;\n                            }\n                            default:\n                                throw unexpectedElement(reader);\n                        }\n                        break;\n                    }\n                    default:\n                        throw unexpectedElement(reader);\n                }\n            }\n            if (!requiredElement.isEmpty()) {\n                throw missingRequiredElement(reader, requiredElement);\n            }\n            if (!ccmAdded) {\n                final ModelNode ccmOperation = new ModelNode();\n                ccmOperation.get(OP).set(ADD);\n\n                final ModelNode ccmAddress = address.clone();\n                ccmAddress.add(CACHED_CONNECTION_MANAGER, CACHED_CONNECTION_MANAGER);\n                ccmAddress.protect();\n\n                ccmOperation.get(OP_ADDR).set(ccmAddress);\n                list.add(ccmOperation);\n            }\n        }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initializeParsers(final ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.JCA_1_1.getUriString(), ConnectorSubsystemParser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.JCA_2_0.getUriString(), ConnectorSubsystemParser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.JCA_3_0.getUriString(), ConnectorSubsystemParser.INSTANCE);\n    }","id":43465,"modified_method":"@Override\n    public void initializeParsers(final ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.JCA_1_1.getUriString(), ConnectorSubsystemParser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.JCA_2_0.getUriString(), ConnectorSubsystemParser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.JCA_3_0.getUriString(), ConnectorSubsystemParser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.JCA_4_0.getUriString(), ConnectorSubsystemParser.INSTANCE);\n    }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseDistributedWorkManager(final XMLExtendedStreamReader reader, final ModelNode parentAddress,\n                                                 final List<ModelNode> list, final ModelNode node, boolean defaultWm) throws XMLStreamException {\n\n            final ModelNode distributedWorkManagerOperation = new ModelNode();\n            distributedWorkManagerOperation.get(OP).set(ADD);\n\n            final int cnt = reader.getAttributeCount();\n            String name = null;\n            final AttributeDefinition attributeDefinition = JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute();\n            final String attributeName = attributeDefinition.getXmlName();\n            for (int i = 0; i < cnt; i++) {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NAME: {\n                        name = rawAttributeText(reader, attributeName);\n                        ((SimpleAttributeDefinition) attributeDefinition).parseAndSetParameter(name, distributedWorkManagerOperation, reader);\n                        break;\n                    }\n                    default: {\n                        throw unexpectedAttribute(reader, i);\n                    }\n                }\n            }\n\n            if (name == null) {\n                throw ParseUtils.missingRequired(reader, attributeName);\n            }\n\n            final ModelNode distributedWorkManagerAddress = parentAddress.clone();\n            distributedWorkManagerAddress.add(DISTRIBUTED_WORKMANAGER, name);\n            distributedWorkManagerAddress.protect();\n\n            distributedWorkManagerOperation.get(OP_ADDR).set(distributedWorkManagerAddress);\n            list.add(distributedWorkManagerOperation);\n\n\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n\n                final Element element = Element.forName(reader.getLocalName());\n                Namespace readerNS = Namespace.forUri(reader.getNamespaceURI());\n                switch (element) {\n                    case LONG_RUNNING_THREADS: {\n\n                        org.jboss.as.threads.Namespace ns = org.jboss.as.threads.Namespace.THREADS_1_1;\n                        ThreadsParser.getInstance().parseBlockingBoundedQueueThreadPool(reader, readerNS.getUriString(),\n                                ns, distributedWorkManagerAddress, list, WORKMANAGER_LONG_RUNNING, name);\n                        break;\n                    }\n                    case SHORT_RUNNING_THREADS: {\n                        org.jboss.as.threads.Namespace ns = org.jboss.as.threads.Namespace.THREADS_1_1;\n                        ThreadsParser.getInstance().parseBlockingBoundedQueueThreadPool(reader, readerNS.getUriString(),\n                                ns, distributedWorkManagerAddress, list, WORKMANAGER_SHORT_RUNNING, name);\n                        break;\n                    }\n                    case POLICY: {\n                        switch (readerNS) {\n                            case JCA_2_0:\n                            case JCA_3_0: {\n                                parsePolicy(reader, distributedWorkManagerOperation);\n                                break;\n                            }\n                            default: {\n                                throw unexpectedElement(reader);\n                            }\n                        }\n                        break;\n                    }\n                    case SELECTOR: {\n                        switch (readerNS) {\n                            case JCA_2_0:\n                            case JCA_3_0: {\n                                parseSelector(reader, distributedWorkManagerOperation);\n                                break;\n                            }\n                            default: {\n                                throw unexpectedElement(reader);\n                            }\n                        }\n                        break;\n                    }\n                    case TRANSPORT: {\n                        switch (readerNS) {\n                            case JCA_2_0:\n                            case JCA_3_0: {\n                                parseTransport(reader, distributedWorkManagerOperation);\n                                break;\n                            }\n                            default: {\n                                throw unexpectedElement(reader);\n                            }\n                        }\n                        break;\n                    }\n                    default:\n                        throw unexpectedElement(reader);\n                }\n\n\n            }\n\n        }","id":43466,"modified_method":"private void parseDistributedWorkManager(final XMLExtendedStreamReader reader, final ModelNode parentAddress,\n                                                 final List<ModelNode> list, final ModelNode node, boolean defaultWm) throws XMLStreamException {\n\n            final ModelNode distributedWorkManagerOperation = new ModelNode();\n            distributedWorkManagerOperation.get(OP).set(ADD);\n\n            final int cnt = reader.getAttributeCount();\n            String name = null;\n            final AttributeDefinition attributeDefinition = JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute();\n            final String attributeName = attributeDefinition.getXmlName();\n            for (int i = 0; i < cnt; i++) {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NAME: {\n                        name = rawAttributeText(reader, attributeName);\n                        ((SimpleAttributeDefinition) attributeDefinition).parseAndSetParameter(name, distributedWorkManagerOperation, reader);\n                        break;\n                    }\n                    default: {\n                        throw unexpectedAttribute(reader, i);\n                    }\n                }\n            }\n\n            if (name == null) {\n                throw ParseUtils.missingRequired(reader, attributeName);\n            }\n\n            final ModelNode distributedWorkManagerAddress = parentAddress.clone();\n            distributedWorkManagerAddress.add(DISTRIBUTED_WORKMANAGER, name);\n            distributedWorkManagerAddress.protect();\n\n            distributedWorkManagerOperation.get(OP_ADDR).set(distributedWorkManagerAddress);\n            list.add(distributedWorkManagerOperation);\n\n\n            while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n\n                final Element element = Element.forName(reader.getLocalName());\n                Namespace readerNS = Namespace.forUri(reader.getNamespaceURI());\n                switch (element) {\n                    case LONG_RUNNING_THREADS: {\n\n                        org.jboss.as.threads.Namespace ns = org.jboss.as.threads.Namespace.THREADS_1_1;\n                        ThreadsParser.getInstance().parseBlockingBoundedQueueThreadPool(reader, readerNS.getUriString(),\n                                ns, distributedWorkManagerAddress, list, WORKMANAGER_LONG_RUNNING, name);\n                        break;\n                    }\n                    case SHORT_RUNNING_THREADS: {\n                        org.jboss.as.threads.Namespace ns = org.jboss.as.threads.Namespace.THREADS_1_1;\n                        ThreadsParser.getInstance().parseBlockingBoundedQueueThreadPool(reader, readerNS.getUriString(),\n                                ns, distributedWorkManagerAddress, list, WORKMANAGER_SHORT_RUNNING, name);\n                        break;\n                    }\n                    case POLICY: {\n                        switch (readerNS) {\n                            case JCA_2_0:\n                            case JCA_3_0:\n                            case JCA_4_0: {\n                                parsePolicy(reader, distributedWorkManagerOperation);\n                                break;\n                            }\n                            default: {\n                                throw unexpectedElement(reader);\n                            }\n                        }\n                        break;\n                    }\n                    case SELECTOR: {\n                        switch (readerNS) {\n                            case JCA_2_0:\n                            case JCA_3_0:\n                            case JCA_4_0: {\n                                parseSelector(reader, distributedWorkManagerOperation);\n                                break;\n                            }\n                            default: {\n                                throw unexpectedElement(reader);\n                            }\n                        }\n                        break;\n                    }\n                    default:\n                        throw unexpectedElement(reader);\n                }\n\n\n            }\n\n        }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeDistributedWorkManagers(XMLExtendedStreamWriter writer, ModelNode parentNode) throws XMLStreamException {\n            if (parentNode.hasDefined(DISTRIBUTED_WORKMANAGER) && parentNode.get(DISTRIBUTED_WORKMANAGER).asList().size() != 0) {\n                for (Property property : parentNode.get(DISTRIBUTED_WORKMANAGER).asPropertyList()) {\n\n                    writer.writeStartElement(Element.DISTRIBUTED_WORKMANAGER.getLocalName());\n                    ((SimpleAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute()).marshallAsAttribute(property.getValue(), writer);\n\n                    for (Property prop : property.getValue().asPropertyList()) {\n                        if (WORKMANAGER_LONG_RUNNING.equals(prop.getName()) && prop.getValue().isDefined() && prop.getValue().asPropertyList().size() != 0) {\n                            ThreadsParser.getInstance().writeBoundedQueueThreadPool(writer, prop.getValue().asProperty(), Element.LONG_RUNNING_THREADS.getLocalName(), false);\n                        }\n                        if (WORKMANAGER_SHORT_RUNNING.equals(prop.getName()) && prop.getValue().isDefined() && prop.getValue().asPropertyList().size() != 0) {\n                            ThreadsParser.getInstance().writeBoundedQueueThreadPool(writer, prop.getValue().asProperty(), Element.SHORT_RUNNING_THREADS.getLocalName(), false);\n                        }\n\n                        if (JcaDistributedWorkManagerDefinition.DWmParameters.POLICY.getAttribute().getName().equals(prop.getName()) && prop.getValue().isDefined()) {\n                            writer.writeStartElement(Element.POLICY.getLocalName());\n                            writer.writeAttribute(JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute().getXmlName(), prop.getValue().asString());\n                            if (property.getValue().hasDefined(JcaDistributedWorkManagerDefinition.DWmParameters.POLICY_OPTIONS.getAttribute().getName())) {\n                                for (Property option : property.getValue().get(JcaDistributedWorkManagerDefinition.DWmParameters.POLICY_OPTIONS.getAttribute().getName()).asPropertyList()) {\n                                    writeProperty(writer, option.getName(), option\n                                            .getValue().asString(), Element.OPTION.getLocalName());\n                                }\n                            }\n                            writer.writeEndElement();\n                        }\n\n                        if (JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR.getAttribute().getName().equals(prop.getName()) && prop.getValue().isDefined()) {\n                            writer.writeStartElement(Element.SELECTOR.getLocalName());\n                            writer.writeAttribute(JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute().getXmlName(), prop.getValue().asString());\n\n                            if (property.getValue().hasDefined(JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR_OPTIONS.getAttribute().getName())) {\n                                for (Property option : property.getValue().get(JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR_OPTIONS.getAttribute().getName()).asPropertyList()) {\n                                    writeProperty(writer, option.getName(), option\n                                            .getValue().asString(), Element.OPTION.getLocalName());\n                                }\n                            }\n                            writer.writeEndElement();\n                        }\n\n                    }\n\n                    writer.writeStartElement(Element.TRANSPORT.getLocalName());\n                    ((SimpleAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.TRANSPORT_JGROPUS_STACK.getAttribute()).marshallAsAttribute(property.getValue(), writer);\n                    ((SimpleAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.TRANSPORT_JGROPUS_CLUSTER.getAttribute()).marshallAsAttribute(property.getValue(), writer);\n                    ((SimpleAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.TRANSPORT_REQUEST_TIMEOUT.getAttribute()).marshallAsAttribute(property.getValue(), writer);\n                    writer.writeEndElement();\n\n                    writer.writeEndElement();\n                }\n            }\n        }","id":43467,"modified_method":"private void writeDistributedWorkManagers(XMLExtendedStreamWriter writer, ModelNode parentNode) throws XMLStreamException {\n            if (parentNode.hasDefined(DISTRIBUTED_WORKMANAGER) && parentNode.get(DISTRIBUTED_WORKMANAGER).asList().size() != 0) {\n                for (Property property : parentNode.get(DISTRIBUTED_WORKMANAGER).asPropertyList()) {\n\n                    writer.writeStartElement(Element.DISTRIBUTED_WORKMANAGER.getLocalName());\n                    ((SimpleAttributeDefinition) JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute()).marshallAsAttribute(property.getValue(), writer);\n\n                    for (Property prop : property.getValue().asPropertyList()) {\n                        if (WORKMANAGER_LONG_RUNNING.equals(prop.getName()) && prop.getValue().isDefined() && prop.getValue().asPropertyList().size() != 0) {\n                            ThreadsParser.getInstance().writeBoundedQueueThreadPool(writer, prop.getValue().asProperty(), Element.LONG_RUNNING_THREADS.getLocalName(), false);\n                        }\n                        if (WORKMANAGER_SHORT_RUNNING.equals(prop.getName()) && prop.getValue().isDefined() && prop.getValue().asPropertyList().size() != 0) {\n                            ThreadsParser.getInstance().writeBoundedQueueThreadPool(writer, prop.getValue().asProperty(), Element.SHORT_RUNNING_THREADS.getLocalName(), false);\n                        }\n\n                        if (JcaDistributedWorkManagerDefinition.DWmParameters.POLICY.getAttribute().getName().equals(prop.getName()) && prop.getValue().isDefined()) {\n                            writer.writeStartElement(Element.POLICY.getLocalName());\n                            writer.writeAttribute(JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute().getXmlName(), prop.getValue().asString());\n                            if (property.getValue().hasDefined(JcaDistributedWorkManagerDefinition.DWmParameters.POLICY_OPTIONS.getAttribute().getName())) {\n                                for (Property option : property.getValue().get(JcaDistributedWorkManagerDefinition.DWmParameters.POLICY_OPTIONS.getAttribute().getName()).asPropertyList()) {\n                                    writeProperty(writer, option.getName(), option\n                                            .getValue().asString(), Element.OPTION.getLocalName());\n                                }\n                            }\n                            writer.writeEndElement();\n                        }\n\n                        if (JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR.getAttribute().getName().equals(prop.getName()) && prop.getValue().isDefined()) {\n                            writer.writeStartElement(Element.SELECTOR.getLocalName());\n                            writer.writeAttribute(JcaDistributedWorkManagerDefinition.DWmParameters.NAME.getAttribute().getXmlName(), prop.getValue().asString());\n\n                            if (property.getValue().hasDefined(JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR_OPTIONS.getAttribute().getName())) {\n                                for (Property option : property.getValue().get(JcaDistributedWorkManagerDefinition.DWmParameters.SELECTOR_OPTIONS.getAttribute().getName()).asPropertyList()) {\n                                    writeProperty(writer, option.getName(), option\n                                            .getValue().asString(), Element.OPTION.getLocalName());\n                                }\n                            }\n                            writer.writeEndElement();\n                        }\n\n                    }\n\n                    writer.writeEndElement();\n                }\n            }\n        }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void registerTransformers(SubsystemRegistration subsystem) {\n        ResourceTransformationDescriptionBuilder builder12 = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder12.rejectChildResource(JcaDistributedWorkManagerDefinition.PATH_DISTRIBUTED_WORK_MANAGER);\n        builder12.discardChildResource(TracerDefinition.PATH_TRACER);\n        TransformationDescription.Tools.register(builder12.build(), subsystem, ModelVersion.create(1, 2, 0));\n        ResourceTransformationDescriptionBuilder builder20 = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder20.discardChildResource(TracerDefinition.PATH_TRACER);\n        TransformationDescription.Tools.register(builder20.build(), subsystem, ModelVersion.create(2, 0, 0));\n\n    }","id":43468,"modified_method":"static void registerTransformers(SubsystemRegistration subsystem) {\n        ResourceTransformationDescriptionBuilder builder12 = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder12.rejectChildResource(JcaDistributedWorkManagerDefinition.PATH_DISTRIBUTED_WORK_MANAGER);\n        builder12.discardChildResource(TracerDefinition.PATH_TRACER);\n        TransformationDescription.Tools.register(builder12.build(), subsystem, ModelVersion.create(1, 2, 0));\n        ResourceTransformationDescriptionBuilder builder20 = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder20.discardChildResource(TracerDefinition.PATH_TRACER);\n        TransformationDescription.Tools.register(builder20.build(), subsystem, ModelVersion.create(2, 0, 0));\n        ResourceTransformationDescriptionBuilder builder30 = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        JcaDistributedWorkManagerDefinition.registerTransformers300(builder30);\n        TransformationDescription.Tools.register(builder30.build(), subsystem, ModelVersion.create(3, 0, 0));\n    }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected String getSubsystemXsdPath() throws Exception {\n        return \"schema/wildfly-jca_3_0.xsd\";\n    }","id":43469,"modified_method":"@Override\n    protected String getSubsystemXsdPath() throws Exception {\n        return \"schema/wildfly-jca_4_0.xsd\";\n    }","commit_id":"e9173de0656a21e10972fa19253f940e31be49b6","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected JChannel createChannel() throws Exception {\n        return createChannel(\"A\");\n    }","id":43470,"modified_method":"protected JChannel createChannel() throws Exception {\n        return createChannel(\"A\", false, 1);\n    }","commit_id":"d2c372b1e2de97db7dcad49de85f9a7ed49f19f1","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(Object id, String props) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, props);\n    }","id":43471,"modified_method":"protected JChannel createChannel(Object id, String props) throws Exception {\n        return new DefaultChannelTestFactory().createChannel(id, props);\n    }","commit_id":"d2c372b1e2de97db7dcad49de85f9a7ed49f19f1","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id) throws Exception {\n            return createChannel(id, null);\n        }","id":43472,"modified_method":"public Channel createChannel(Object id) throws Exception {\n            return createChannel(id, false, 1);\n        }","commit_id":"d2c372b1e2de97db7dcad49de85f9a7ed49f19f1","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(String configFile, boolean useBlocking)\n                throws Exception {\n            Map<Integer, Object> channelOptions=new HashMap<Integer, Object>();\n            channelOptions.put(Channel.BLOCK, useBlocking);\n            return createChannel(configFile, channelOptions);\n        }","id":43473,"modified_method":"private JChannel createChannel(String configFile, boolean useBlocking) throws Exception {\n            Map<Integer, Object> channelOptions=new HashMap<Integer, Object>();\n            channelOptions.put(Channel.BLOCK, useBlocking);\n\n            log.info(\"Using configuration file \" + configFile);\n            JChannel ch=new JChannel(configFile);\n            for(Map.Entry<Integer, Object> entry : channelOptions.entrySet()) {\n                Integer key=entry.getKey();\n                Object value=entry.getValue();\n                ch.setOpt(key, value);\n            }\n            return ch;\n        }","commit_id":"d2c372b1e2de97db7dcad49de85f9a7ed49f19f1","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createChannel(Object id, String props) throws Exception {\n            JChannel c=null;\n            if(props == null)\n                props=channel_conf;\n            if(isMuxChannelUsed()) {\n                log.info(\"Using configuration file \" + mux_conf + \", stack is \" + mux_conf_stack);\n                synchronized(muxFactory) {\n                    for(int i=0; i < muxFactory.length; i++) {\n                        if(!muxFactory[i].hasMuxChannel(mux_conf_stack, id.toString())) {\n                            c=(JChannel)muxFactory[i].createMultiplexerChannel(mux_conf_stack, id.toString());\n                            if(useBlocking()) {\n                                c.setOpt(Channel.BLOCK, Boolean.TRUE);\n                            }\n                            return c;\n                        }\n                    }\n                }\n                throw new Exception(\"Cannot create mux channel with id \" + id\n                        + \" since all currently used channels have already registered service with that id\");\n            }\n            else {\n                c=createChannel(props, useBlocking());\n            }\n            return c;\n        }","id":43474,"modified_method":"public JChannel createChannel(Object id, String props) throws Exception {\n            JChannel c=null;\n            if(props == null)\n                props=channel_conf;\n            if(isMuxChannelUsed()) {\n                log.info(\"Using configuration file \" + mux_conf + \", stack is \" + mux_conf_stack);\n                synchronized(muxFactory) {\n                    for(int i=0; i < muxFactory.length; i++) {\n                        if(!muxFactory[i].hasMuxChannel(mux_conf_stack, id.toString())) {\n                            c=(JChannel)muxFactory[i].createMultiplexerChannel(mux_conf_stack, id.toString());\n                            if(useBlocking()) {\n                                c.setOpt(Channel.BLOCK, Boolean.TRUE);\n                            }\n                            return c;\n                        }\n                    }\n                }\n                throw new Exception(\"Cannot create mux channel with id \" + id\n                        + \" since all currently used channels have already registered service with that id\");\n            }\n            else {\n                c=createChannel(props, useBlocking());\n            }\n            return c;\n        }","commit_id":"d2c372b1e2de97db7dcad49de85f9a7ed49f19f1","url":"https://github.com/belaban/JGroups"},{"original_method":"protected JChannel createChannel(Object id) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id);\n    }","id":43475,"modified_method":"protected JChannel createChannel(Object id) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, false, 1);\n    }","commit_id":"d2c372b1e2de97db7dcad49de85f9a7ed49f19f1","url":"https://github.com/belaban/JGroups"},{"original_method":"public Channel createUniqueChannel(int num) throws Exception {\n            JChannel c=null;\n            if(isMuxChannelUsed()) {\n                throw new IllegalStateException(\"MuxChannels are currently not supported\");\n            }\n            c=createChannel(channel_conf, useBlocking());\n            ProtocolStack stack=c.getProtocolStack();\n            Protocol transport=stack.getTransport();\n            Properties props=new Properties();\n            if(transport instanceof UDP) {\n                String mcast_addr=ResourceManager.getNextMulticastAddress();\n                short mcast_port=ResourceManager.getNextMulticastPort(InetAddress.getByName(bind_addr));\n                props.setProperty(\"mcast_addr\", mcast_addr);\n                props.setProperty(\"mcast_port\", String.valueOf(mcast_port));\n                transport.setProperties(props);\n            }\n            else if(transport instanceof BasicTCP) {\n                List<Short> ports=ResourceManager.getNextTcpPorts(InetAddress.getByName(bind_addr), num);\n\n                props.setProperty(\"bind_port\", String.valueOf(ports.get(0)));\n                props.setProperty(\"port_range\", String.valueOf(num));\n                transport.setProperties(props);\n\n                Protocol ping=stack.findProtocol(TCPPING.class);\n                if(ping == null)\n                    throw new IllegalStateException(\"TCP stack must consist of TCP:TCPPING - other config are not supported\");\n                props.clear();\n\n                List<String> initial_hosts=new LinkedList<String>();\n                for(short port: ports) {\n                    initial_hosts.add(bind_addr + \"[\" + port + \"]\");\n                }\n                String tmp=Util.printListWithDelimiter(initial_hosts, \",\");\n                props.setProperty(\"initial_hosts\", tmp);\n            }\n            else {\n                throw new IllegalStateException(\"Only UDP and TCP are supported as transport protocols\");\n            }\n            return c;\n        }","id":43476,"modified_method":"private void makeUnique(JChannel channel, int num) throws Exception {\n            ProtocolStack stack=channel.getProtocolStack();\n            Protocol transport=stack.getTransport();\n            Properties props=new Properties();\n            if(transport instanceof UDP) {\n                String mcast_addr=ResourceManager.getNextMulticastAddress();\n                short mcast_port=ResourceManager.getNextMulticastPort(InetAddress.getByName(bind_addr));\n                props.setProperty(\"mcast_addr\", mcast_addr);\n                props.setProperty(\"mcast_port\", String.valueOf(mcast_port));\n                transport.setProperties(props);\n            }\n            else if(transport instanceof BasicTCP) {\n                List<Short> ports=ResourceManager.getNextTcpPorts(InetAddress.getByName(bind_addr), num);\n\n                props.setProperty(\"bind_port\", String.valueOf(ports.get(0)));\n                props.setProperty(\"port_range\", String.valueOf(num));\n                transport.setProperties(props);\n\n                Protocol ping=stack.findProtocol(TCPPING.class);\n                if(ping == null)\n                    throw new IllegalStateException(\"TCP stack must consist of TCP:TCPPING - other config are not supported\");\n                props.clear();\n\n                List<String> initial_hosts=new LinkedList<String>();\n                for(short port: ports) {\n                    initial_hosts.add(bind_addr + \"[\" + port + \"]\");\n                }\n                String tmp=Util.printListWithDelimiter(initial_hosts, \",\");\n                props.setProperty(\"initial_hosts\", tmp);\n            }\n            else {\n                throw new IllegalStateException(\"Only UDP and TCP are supported as transport protocols\");\n            }\n        }","commit_id":"d2c372b1e2de97db7dcad49de85f9a7ed49f19f1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a channel and modifies the configuration such that no other channel will able to join this\n     * one even if they have the same cluster name. This is done by modifying mcast_addr and mcast_port with UDP,\n     * and by changing TCP.start_port, TCP.port_range and TCPPING.initial_hosts with TCP. Mainly used to\n     * run TestNG tests concurrently. Note that MuxChannels are not currently supported.\n     * @param num The number of channels we will create. Only important (for port_range) with TCP, ignored by UDP\n     * @return\n     * @throws Exception\n     */\n    protected JChannel createUniqueChannel(int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createUniqueChannel(num);\n    }","id":43477,"modified_method":"/**\n     * Creates a channel and modifies the configuration such that no other channel will able to join this\n     * one even if they have the same cluster name (if unique = true). This is done by modifying mcast_addr and mcast_port with UDP,\n     * and by changing TCP.start_port, TCP.port_range and TCPPING.initial_hosts with TCP. Mainly used to\n     * run TestNG tests concurrently. Note that MuxChannels are not currently supported.\n     * @param num The number of channels we will create. Only important (for port_range) with TCP, ignored by UDP\n     * @return\n     * @throws Exception\n     */\n    protected JChannel createChannel(Object id, boolean unique, int num) throws Exception {\n        return (JChannel)new DefaultChannelTestFactory().createChannel(id, unique, num);\n    }","commit_id":"d2c372b1e2de97db7dcad49de85f9a7ed49f19f1","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    public MemberCandidacy invite(String userId, String wikiId, String message)\n        throws WikiUserManagerException\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // Create the candidacy\n        MemberCandidacy candidacy = new MemberCandidacy(wikiId, userId, MemberCandidacy.CandidateType.INVITATION);\n        candidacy.setUserComment(message);\n        candidacy.setAdminId(xcontext.getUser());\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Add a candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(wikiId, CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        try {\n            int objectNumber = groupDoc.createXObject(candidateClassReference, xcontext);\n            candidacy.setId(objectNumber);\n            BaseObject object = groupDoc.getXObject(candidateClassReference, objectNumber);\n            object.setStringValue(CANDIDACY_CLASS_USER_FIELD, candidacy.getUserId());\n            object.setStringValue(CANDIDACY_CLASS_ADMIN_FIELD, candidacy.getAdminId());\n            object.setLargeStringValue(CANDIDACY_CLASS_ADMIN_COMMENT_FIELD, message);\n            object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, candidacy.getStatus().name().toLowerCase());\n            object.setDateValue(CANDIDACY_CLASS_DATE_OF_CREATION_FIELD, candidacy.getDateOfCreation());\n            object.setStringValue(CANDIDACY_CLASS_TYPE_FIELD, candidacy.getType().name().toLowerCase());\n        } catch (XWikiException e) {\n            throw new WikiUserManagerException(\"Failed to create a new invitation object.\", e);\n        }\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"[%] is invited to join the wiki.\", userId));\n\n        return candidacy;\n    }","id":43478,"modified_method":"@Override\n    public MemberCandidacy invite(String userId, String wikiId, String message)\n        throws WikiUserManagerException\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // Create the candidacy\n        MemberCandidacy candidacy = new MemberCandidacy(wikiId, userId, MemberCandidacy.CandidateType.INVITATION);\n        candidacy.setUserComment(message);\n        candidacy.setAdminId(xcontext.getUser());\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Add a candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(wikiId, CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        try {\n            int objectNumber = groupDoc.createXObject(candidateClassReference, xcontext);\n            candidacy.setId(objectNumber);\n            BaseObject object = groupDoc.getXObject(candidateClassReference, objectNumber);\n            object.setStringValue(CANDIDACY_CLASS_USER_FIELD, candidacy.getUserId());\n            object.setStringValue(CANDIDACY_CLASS_ADMIN_FIELD, candidacy.getAdminId());\n            object.setLargeStringValue(CANDIDACY_CLASS_ADMIN_COMMENT_FIELD, message);\n            object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, candidacy.getStatus().name().toLowerCase());\n            object.setDateValue(CANDIDACY_CLASS_DATE_OF_CREATION_FIELD, candidacy.getDateOfCreation());\n            object.setStringValue(CANDIDACY_CLASS_TYPE_FIELD, candidacy.getType().name().toLowerCase());\n        } catch (XWikiException e) {\n            throw new WikiUserManagerException(\"Failed to create a new invitation object.\", e);\n        }\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"[%s] is invited to join the wiki.\", userId));\n\n        return candidacy;\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Collection<MemberCandidacy> getAllMemberCandidacies(String wikiId, MemberCandidacy.CandidateType type)\n        throws WikiUserManagerException\n    {\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Collect all the candidacy of the good type\n        Collection<MemberCandidacy> candidacies = new ArrayList<MemberCandidacy>();\n        String typeString = type.name().toLowerCase();\n        DocumentReference candidateClassReference = new DocumentReference(wikiId, CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        for (BaseObject object : groupDoc.getXObjects(candidateClassReference)) {\n            if (object.getStringValue(CANDIDACY_CLASS_TYPE_FIELD).equals(typeString)) {\n                candidacies.add(readCandidacyFromObject(object));\n            }\n        }\n\n        return candidacies;\n    }","id":43479,"modified_method":"private Collection<MemberCandidacy> getAllMemberCandidacies(String wikiId, MemberCandidacy.CandidateType type)\n        throws WikiUserManagerException\n    {\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Collect all the candidacy of the good type\n        Collection<MemberCandidacy> candidacies = new ArrayList<MemberCandidacy>();\n        String typeString = type.name().toLowerCase();\n        DocumentReference candidateClassReference = new DocumentReference(wikiId, CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        List<BaseObject> candidacyObjects = groupDoc.getXObjects(candidateClassReference);\n        if (candidacyObjects != null) {\n            for (BaseObject object : candidacyObjects) {\n                if (object.getStringValue(CANDIDACY_CLASS_TYPE_FIELD).equals(typeString)) {\n                    candidacies.add(readCandidacyFromObject(object, wikiId));\n                }\n            }\n        }\n\n        return candidacies;\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public MemberCandidacy getCandidacy(String wikiId, int candidacyId) throws WikiUserManagerException\n    {\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Get the candidacy\n        DocumentReference candidateClassReference = new DocumentReference(wikiId, CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, candidacyId);\n        return readCandidacyFromObject(object);\n    }","id":43480,"modified_method":"@Override\n    public MemberCandidacy getCandidacy(String wikiId, int candidacyId) throws WikiUserManagerException\n    {\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Get the candidacy\n        DocumentReference candidateClassReference = new DocumentReference(wikiId, CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, candidacyId);\n        return readCandidacyFromObject(object, wikiId);\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void refuseInvitation(MemberCandidacy invitation, String message) throws WikiUserManagerException\n    {\n        // Update the candidacy object\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // Set the values\n        invitation.setUserComment(message);\n        invitation.setStatus(MemberCandidacy.Status.REJECTED);\n        invitation.setDateOfClosure(new Date());\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(invitation.getWikiId());\n\n        // Get the candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(invitation.getWikiId(), CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, invitation.getId());\n\n        // Set the new values\n        object.setLargeStringValue(CANDIDACY_CLASS_USER_COMMENT_FIELD, invitation.getUserComment());\n        object.setDateValue(CANDIDACY_CLASS_DATE_OF_CLOSURE_FIELD, invitation.getDateOfClosure());\n        object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, invitation.getStatus().name().toLowerCase());\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"User [%] has rejected the invitation to join the wiki.\",\n                invitation.getUserId()));\n    }","id":43481,"modified_method":"@Override\n    public void refuseInvitation(MemberCandidacy invitation, String message) throws WikiUserManagerException\n    {\n        // Update the candidacy object\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // Set the values\n        invitation.setUserComment(message);\n        invitation.setStatus(MemberCandidacy.Status.REJECTED);\n        invitation.setDateOfClosure(new Date());\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(invitation.getWikiId());\n\n        // Get the candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(invitation.getWikiId(), CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, invitation.getId());\n\n        // Set the new values\n        object.setLargeStringValue(CANDIDACY_CLASS_USER_COMMENT_FIELD, invitation.getUserComment());\n        object.setDateValue(CANDIDACY_CLASS_DATE_OF_CLOSURE_FIELD, invitation.getDateOfClosure());\n        object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, invitation.getStatus().name().toLowerCase());\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"User [%s] has rejected the invitation to join the wiki.\",\n                invitation.getUserId()));\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveGroupDocument(XWikiDocument document, String message) throws WikiUserManagerException {\n        // Save the document\n        XWikiContext xcontext = xcontextProvider.get();\n        XWiki xwiki = xcontext.getWiki();\n        try {\n            xwiki.saveDocument(document, message, xcontext);\n        } catch (XWikiException e) {\n            throw new WikiUserManagerException(\"Fail to save the member group\", e);\n        }\n    }","id":43482,"modified_method":"private void saveGroupDocument(XWikiDocument document, String message) throws WikiUserManagerException {\n        // The document should be hidden\n        document.setHidden(true);\n\n        // Save the document\n        XWikiContext xcontext = xcontextProvider.get();\n        XWiki xwiki = xcontext.getWiki();\n        try {\n            xwiki.saveDocument(document, message, xcontext);\n        } catch (XWikiException e) {\n            throw new WikiUserManagerException(\"Fail to save the member group\", e);\n        }\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private MemberCandidacy readCandidacyFromObject(BaseObject object)\n    {\n        MemberCandidacy candidacy = new MemberCandidacy();\n\n        candidacy.setId(object.getNumber());\n        candidacy.setUserId(object.getStringValue(CANDIDACY_CLASS_USER_FIELD));\n        candidacy.setUserComment(object.getLargeStringValue(CANDIDACY_CLASS_USER_COMMENT_FIELD));\n        candidacy.setAdminId(object.getStringValue(CANDIDACY_CLASS_ADMIN_FIELD));\n        candidacy.setAdminComment(object.getLargeStringValue(CANDIDACY_CLASS_ADMIN_COMMENT_FIELD));\n        candidacy.setAdminPrivateComment(object.getLargeStringValue(CANDIDACY_CLASS_ADMIN_PRIVATE_COMMENT_FIELD));\n        candidacy.setStatus(\n                MemberCandidacy.Status.valueOf(object.getStringValue(CANDIDACY_CLASS_STATUS_FIELD).toUpperCase()));\n        candidacy.setType(\n                MemberCandidacy.CandidateType.valueOf(object.getStringValue(CANDIDACY_CLASS_STATUS_FIELD).toUpperCase())\n        );\n        candidacy.setDateOfCreation(object.getDateValue(CANDIDACY_CLASS_DATE_OF_CREATION_FIELD));\n        candidacy.setDateOfCreation(object.getDateValue(CANDIDACY_CLASS_DATE_OF_CLOSURE_FIELD));\n\n        return candidacy;\n    }","id":43483,"modified_method":"private MemberCandidacy readCandidacyFromObject(BaseObject object, String wikiId)\n    {\n        MemberCandidacy candidacy = new MemberCandidacy();\n\n        candidacy.setId(object.getNumber());\n        candidacy.setWikiId(wikiId);\n        candidacy.setUserId(object.getStringValue(CANDIDACY_CLASS_USER_FIELD));\n        candidacy.setUserComment(object.getLargeStringValue(CANDIDACY_CLASS_USER_COMMENT_FIELD));\n        candidacy.setAdminId(object.getStringValue(CANDIDACY_CLASS_ADMIN_FIELD));\n        candidacy.setAdminComment(object.getLargeStringValue(CANDIDACY_CLASS_ADMIN_COMMENT_FIELD));\n        candidacy.setAdminPrivateComment(object.getLargeStringValue(CANDIDACY_CLASS_ADMIN_PRIVATE_COMMENT_FIELD));\n        candidacy.setStatus(\n                MemberCandidacy.Status.valueOf(object.getStringValue(CANDIDACY_CLASS_STATUS_FIELD).toUpperCase()));\n        candidacy.setType(\n                MemberCandidacy.CandidateType.valueOf(object.getStringValue(CANDIDACY_CLASS_TYPE_FIELD).toUpperCase())\n        );\n        candidacy.setDateOfCreation(object.getDateValue(CANDIDACY_CLASS_DATE_OF_CREATION_FIELD));\n        candidacy.setDateOfCreation(object.getDateValue(CANDIDACY_CLASS_DATE_OF_CLOSURE_FIELD));\n\n        return candidacy;\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void acceptInvitation(MemberCandidacy invitation, String message) throws WikiUserManagerException\n    {\n        // Add the user to the members\n        addMember(invitation.getUserId(), invitation.getWikiId());\n\n        // Then, update the candidacy object\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // Set the values\n        invitation.setUserComment(message);\n        invitation.setStatus(MemberCandidacy.Status.ACCEPTED);\n        invitation.setDateOfClosure(new Date());\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(invitation.getWikiId());\n\n        // Get the candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(invitation.getWikiId(), CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, invitation.getId());\n\n        // Set the new values\n        object.setLargeStringValue(CANDIDACY_CLASS_USER_COMMENT_FIELD, invitation.getUserComment());\n        object.setDateValue(CANDIDACY_CLASS_DATE_OF_CLOSURE_FIELD, invitation.getDateOfClosure());\n        object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, invitation.getStatus().name().toLowerCase());\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"User [%] has accepted to join the wiki. \", invitation.getUserId()));\n    }","id":43484,"modified_method":"@Override\n    public void acceptInvitation(MemberCandidacy invitation, String message) throws WikiUserManagerException\n    {\n        // Add the user to the members\n        addMember(invitation.getUserId(), invitation.getWikiId());\n\n        // Then, update the candidacy object\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // Set the values\n        invitation.setUserComment(message);\n        invitation.setStatus(MemberCandidacy.Status.ACCEPTED);\n        invitation.setDateOfClosure(new Date());\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(invitation.getWikiId());\n\n        // Get the candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(invitation.getWikiId(), CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, invitation.getId());\n\n        // Set the new values\n        object.setLargeStringValue(CANDIDACY_CLASS_USER_COMMENT_FIELD, invitation.getUserComment());\n        object.setDateValue(CANDIDACY_CLASS_DATE_OF_CLOSURE_FIELD, invitation.getDateOfClosure());\n        object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, invitation.getStatus().name().toLowerCase());\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"User [%s] has accepted to join the wiki. \", invitation.getUserId()));\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public MemberCandidacy askToJoin(String userId, String wikiId, String message)\n        throws WikiUserManagerException\n    {\n        MemberCandidacy candidacy = new MemberCandidacy(wikiId, userId, MemberCandidacy.CandidateType.REQUEST);\n        candidacy.setUserComment(message);\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Add a candidacy object\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference candidateClassReference = new DocumentReference(wikiId, CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        try {\n            int objectNumber = groupDoc.createXObject(candidateClassReference, xcontext);\n            candidacy.setId(objectNumber);\n            BaseObject object = groupDoc.getXObject(candidateClassReference, objectNumber);\n            object.setStringValue(CANDIDACY_CLASS_USER_FIELD, candidacy.getUserId());\n            object.setLargeStringValue(CANDIDACY_CLASS_USER_COMMENT_FIELD, candidacy.getUserComment());\n            object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, candidacy.getStatus().name().toLowerCase());\n            object.setDateValue(CANDIDACY_CLASS_DATE_OF_CREATION_FIELD, candidacy.getDateOfCreation());\n            object.setStringValue(CANDIDACY_CLASS_TYPE_FIELD, candidacy.getType().name().toLowerCase());\n        } catch (XWikiException e) {\n            throw new WikiUserManagerException(\"Failed to create a new join request.\", e);\n        }\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"[%] asks to join the wiki.\", userId));\n\n        return candidacy;\n    }","id":43485,"modified_method":"@Override\n    public MemberCandidacy askToJoin(String userId, String wikiId, String message)\n        throws WikiUserManagerException\n    {\n        MemberCandidacy candidacy = new MemberCandidacy(wikiId, userId, MemberCandidacy.CandidateType.REQUEST);\n        candidacy.setUserComment(message);\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Add a candidacy object\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference candidateClassReference = new DocumentReference(wikiId, CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        try {\n            int objectNumber = groupDoc.createXObject(candidateClassReference, xcontext);\n            candidacy.setId(objectNumber);\n            BaseObject object = groupDoc.getXObject(candidateClassReference, objectNumber);\n            object.setStringValue(CANDIDACY_CLASS_USER_FIELD, candidacy.getUserId());\n            object.setLargeStringValue(CANDIDACY_CLASS_USER_COMMENT_FIELD, candidacy.getUserComment());\n            object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, candidacy.getStatus().name().toLowerCase());\n            object.setDateValue(CANDIDACY_CLASS_DATE_OF_CREATION_FIELD, candidacy.getDateOfCreation());\n            object.setStringValue(CANDIDACY_CLASS_TYPE_FIELD, candidacy.getType().name().toLowerCase());\n        } catch (XWikiException e) {\n            throw new WikiUserManagerException(\"Failed to create a new join request.\", e);\n        }\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"[%s] asks to join the wiki.\", userId));\n\n        return candidacy;\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void refuseRequest(MemberCandidacy request, String message, String privateComment)\n        throws WikiUserManagerException\n    {\n        // Update the candidacy object\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // Set the values\n        request.setAdminId(xcontext.getUser());\n        request.setAdminComment(message);\n        request.setAdminPrivateComment(privateComment);\n        request.setStatus(MemberCandidacy.Status.REJECTED);\n        request.setDateOfClosure(new Date());\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(request.getWikiId());\n\n        // Get the candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(request.getWikiId(), CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, request.getId());\n\n        // Set the new values\n        object.setStringValue(CANDIDACY_CLASS_ADMIN_FIELD, request.getAdminId());\n        object.setLargeStringValue(CANDIDACY_CLASS_ADMIN_COMMENT_FIELD, request.getAdminComment());\n        object.setLargeStringValue(CANDIDACY_CLASS_ADMIN_PRIVATE_COMMENT_FIELD, request.getAdminPrivateComment());\n        object.setDateValue(CANDIDACY_CLASS_DATE_OF_CLOSURE_FIELD, request.getDateOfClosure());\n        object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, request.getStatus().name().toLowerCase());\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"Reject join request from user [%]\", request.getUserId()));\n    }","id":43486,"modified_method":"@Override\n    public void refuseRequest(MemberCandidacy request, String message, String privateComment)\n        throws WikiUserManagerException\n    {\n        // Update the candidacy object\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // Set the values\n        request.setAdminId(xcontext.getUser());\n        request.setAdminComment(message);\n        request.setAdminPrivateComment(privateComment);\n        request.setStatus(MemberCandidacy.Status.REJECTED);\n        request.setDateOfClosure(new Date());\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(request.getWikiId());\n\n        // Get the candidacy object\n        DocumentReference candidateClassReference = new DocumentReference(request.getWikiId(), CANDIDACY_CLASS_SPACE,\n                CANDIDACY_CLASS_NAME);\n        BaseObject object = groupDoc.getXObject(candidateClassReference, request.getId());\n\n        // Set the new values\n        object.setStringValue(CANDIDACY_CLASS_ADMIN_FIELD, request.getAdminId());\n        object.setLargeStringValue(CANDIDACY_CLASS_ADMIN_COMMENT_FIELD, request.getAdminComment());\n        object.setLargeStringValue(CANDIDACY_CLASS_ADMIN_PRIVATE_COMMENT_FIELD, request.getAdminPrivateComment());\n        object.setDateValue(CANDIDACY_CLASS_DATE_OF_CLOSURE_FIELD, request.getDateOfClosure());\n        object.setStringValue(CANDIDACY_CLASS_STATUS_FIELD, request.getStatus().name().toLowerCase());\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"Reject join request from user [%s]\", request.getUserId()));\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void addMember(String userId, String wikiId) throws WikiUserManagerException\n    {\n        Collection<String> members = getMembers(wikiId);\n        if (members.contains(userId)) {\n            // Nothing to do !\n            return;\n        }\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Add a member object\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference classReference = new DocumentReference(wikiId, XWiki.SYSTEM_SPACE, GROUP_CLASS_NAME);\n        try {\n            int objectNumber = groupDoc.createXObject(classReference, xcontext);\n            BaseObject object = groupDoc.getXObject(classReference, objectNumber);\n            object.set(GROUP_CLASS_MEMBER_FIELD, userId, xcontext);\n        } catch (XWikiException e) {\n            throw new WikiUserManagerException(\"Fail to add a member to the group\", e);\n        }\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"Add [%] to the group.\", userId));\n    }","id":43487,"modified_method":"@Override\n    public void addMember(String userId, String wikiId) throws WikiUserManagerException\n    {\n        Collection<String> members = getMembers(wikiId);\n        if (members.contains(userId)) {\n            // Nothing to do !\n            return;\n        }\n\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Add a member object\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference classReference = new DocumentReference(wikiId, XWiki.SYSTEM_SPACE, GROUP_CLASS_NAME);\n        try {\n            int objectNumber = groupDoc.createXObject(classReference, xcontext);\n            BaseObject object = groupDoc.getXObject(classReference, objectNumber);\n            object.set(GROUP_CLASS_MEMBER_FIELD, userId, xcontext);\n        } catch (XWikiException e) {\n            throw new WikiUserManagerException(\"Fail to add a member to the group\", e);\n        }\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"Add [%s] to the group.\", userId));\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void removeMember(String userId, String wikiId) throws WikiUserManagerException\n    {\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Get the member objects to remove\n        DocumentReference classReference = new DocumentReference(wikiId, XWiki.SYSTEM_SPACE, GROUP_CLASS_NAME);\n        List<BaseObject> objectsToRemove = new ArrayList<BaseObject>();\n        for (BaseObject object : groupDoc.getXObjects(classReference)) {\n            String member = object.getStringValue(GROUP_CLASS_MEMBER_FIELD);\n            if (userId.equals(member)) {\n                objectsToRemove.add(object);\n            }\n        }\n\n        // Remove them\n        for (BaseObject object : objectsToRemove) {\n            groupDoc.removeXObject(object);\n        }\n\n        // Save the document\n        saveGroupDocument(groupDoc, String.format(\"Remove [%] from the group.\", userId));\n    }","id":43488,"modified_method":"@Override\n    public void removeMember(String userId, String wikiId) throws WikiUserManagerException\n    {\n        // Get the group document\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n\n        // Get the member objects\n        DocumentReference classReference = new DocumentReference(wikiId, XWiki.SYSTEM_SPACE, GROUP_CLASS_NAME);\n        List<BaseObject> objects = groupDoc.getXObjects(classReference);\n        if (objects != null) {\n\n            // Get the member objects to remove\n            List<BaseObject> objectsToRemove = new ArrayList<BaseObject>();\n            for (BaseObject object : objects) {\n                String member = object.getStringValue(GROUP_CLASS_MEMBER_FIELD);\n                if (userId.equals(member)) {\n                    objectsToRemove.add(object);\n                }\n            }\n\n            // Remove them\n            for (BaseObject object : objectsToRemove) {\n                groupDoc.removeXObject(object);\n            }\n\n            // Save the document\n            saveGroupDocument(groupDoc, String.format(\"Remove [%s] from the group.\", userId));\n        }\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Collection<String> getMembers(String wikiId) throws WikiUserManagerException\n    {\n        List<String> members = new ArrayList<String>();\n\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n        DocumentReference classReference = new DocumentReference(wikiId, XWiki.SYSTEM_SPACE, GROUP_CLASS_NAME);\n        for (BaseObject object : groupDoc.getXObjects(classReference)) {\n            String member = object.getStringValue(GROUP_CLASS_MEMBER_FIELD);\n            if (!member.isEmpty() && !members.contains(member)) {\n                members.add(member);\n            }\n        }\n\n        return members;\n    }","id":43489,"modified_method":"@Override\n    public Collection<String> getMembers(String wikiId) throws WikiUserManagerException\n    {\n        List<String> members = new ArrayList<String>();\n\n        XWikiDocument groupDoc = getMembersGroupDocument(wikiId);\n        DocumentReference classReference = new DocumentReference(wikiId, XWiki.SYSTEM_SPACE, GROUP_CLASS_NAME);\n        List<BaseObject> memberObjects = groupDoc.getXObjects(classReference);\n        if (memberObjects != null) {\n            for (BaseObject object : memberObjects) {\n                String member = object.getStringValue(GROUP_CLASS_MEMBER_FIELD);\n                if (!member.isEmpty() && !members.contains(member)) {\n                    members.add(member);\n                }\n            }\n        }\n\n        return members;\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Filter from a list of candidacies those that the current user has the right to see.\n     * @param candidacies list to filter\n     * @return the filtered list\n     */\n    private Collection<MemberCandidacy> filterAuthorizedCandidacies(Collection<MemberCandidacy> candidacies)\n    {\n        Collection<MemberCandidacy> authorizedCandidacies = new ArrayList<MemberCandidacy>();\n\n        for (MemberCandidacy candidacy : candidacies) {\n            if (canSeeCandidacy(candidacy)) {\n                candidacies.add(candidacy);\n            }\n        }\n\n        return authorizedCandidacies;\n    }","id":43490,"modified_method":"/**\n     * Filter from a list of candidacies those that the current user has the right to see.\n     * @param candidacies list to filter\n     * @return the filtered list\n     */\n    private Collection<MemberCandidacy> filterAuthorizedCandidacies(Collection<MemberCandidacy> candidacies)\n    {\n        Collection<MemberCandidacy> authorizedCandidacies = new ArrayList<MemberCandidacy>();\n\n        for (MemberCandidacy candidacy : candidacies) {\n            if (canSeeCandidacy(candidacy)) {\n                authorizedCandidacies.add(candidacy);\n            }\n        }\n\n        return authorizedCandidacies;\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Refuse the request to join the wiki.\n     *\n     * @param request request to refuse\n     * @param message message about the refusal\n     * @param privateComment private comment that only the administrator can see\n     * @return true if it succeed\n     */\n    public boolean refuseRequest(MemberCandidacy request, String message, String privateComment)\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n        if (!xcontext.getUser().equals(request.getUserId())) {\n            return false;\n        }\n        try {\n            wikiUserManager.refuseRequest(request, message, privateComment);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","id":43491,"modified_method":"/**\n     * Refuse the request to join the wiki.\n     *\n     * @param request request to refuse\n     * @param message message about the refusal\n     * @param privateComment private comment that only the administrator can see\n     * @return true if it succeed\n     */\n    public boolean refuseRequest(MemberCandidacy request, String message, String privateComment)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference userReference = documentReferenceResolver.resolve(request.getUserId());\n        if (!xcontext.getUserReference().equals(userReference)) {\n            return false;\n        }\n        try {\n            wikiUserManager.refuseRequest(request, message, privateComment);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return whether or not the current wiki has local users enabled\n     */\n    public Boolean hasLocalUsersEnabled()\n    {\n        return hasLocalUsersEnabled(wikiDescriptorManager.getMainWikiId());\n    }","id":43492,"modified_method":"/**\n     * @return whether or not the current wiki has local users enabled\n     */\n    public Boolean hasLocalUsersEnabled()\n    {\n        return hasLocalUsersEnabled(wikiDescriptorManager.getCurrentWikiId());\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Accept the request to join the wiki.\n     *\n     * @param request request to accept\n     * @param message message about the acceptance\n     * @param privateComment private comment that only the administrator can see\n     * @return true if it succeed\n     */\n    public boolean acceptRequest(MemberCandidacy request, String message, String privateComment)\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n        if (!xcontext.getUser().equals(request.getUserId())) {\n            return false;\n        }\n        try {\n            wikiUserManager.acceptRequest(request, message, privateComment);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","id":43493,"modified_method":"/**\n     * Accept the request to join the wiki.\n     *\n     * @param request request to accept\n     * @param message message about the acceptance\n     * @param privateComment private comment that only the administrator can see\n     * @return true if it succeed\n     */\n    public boolean acceptRequest(MemberCandidacy request, String message, String privateComment)\n    {\n        // Check if the current user is userId\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference userReference = documentReferenceResolver.resolve(request.getUserId());\n        if (!xcontext.getUserReference().equals(userReference)) {\n            //TODO\n            return false;\n        }\n        try {\n            wikiUserManager.acceptRequest(request, message, privateComment);\n        } catch (WikiUserManagerException e) {\n            // TODO\n            return false;\n        }\n\n        return true;\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean canSeeCandidacy(MemberCandidacy candidacy)\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // If the user is concerned by the candidacy\n        if (candidacy.getUserId().equals(xcontext.getUser())) {\n            // Hide the admin private comment\n            candidacy.setAdminPrivateComment(null);\n            return true;\n        }\n\n        // Check if the user is an admin\n        return authorizationManager.hasAccess(Right.ADMIN, xcontext.getUserReference(),\n                new WikiReference(candidacy.getWikiId()));\n    }","id":43494,"modified_method":"private boolean canSeeCandidacy(MemberCandidacy candidacy)\n    {\n        XWikiContext xcontext = xcontextProvider.get();\n\n        // If the user is concerned by the candidacy\n        DocumentReference userReference = documentReferenceResolver.resolve(candidacy.getUserId());\n        if (userReference.equals(xcontext.getUserReference())) {\n            // Hide the admin private comment\n            candidacy.setAdminPrivateComment(null);\n            return true;\n        }\n\n        // Check if the user is an admin\n        return authorizationManager.hasAccess(Right.ADMIN, xcontext.getUserReference(),\n                new WikiReference(candidacy.getWikiId()));\n    }","commit_id":"6f87a4df8353e1f1dc78211af1b33fdabf0ed302","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create a new locus reference view.\n     * @param provider source for locus data.\n     */\n    public LocusReferenceView( ShardDataProvider provider ) {\n        super( provider );\n        bounds = provider.getShard().getGenomeLoc();\n        this.referenceSequence = reference.getSubsequenceAt( bounds.getContig(),\n                                                             bounds.getStart(),\n                                                             bounds.getStop() );        \n    }","id":43495,"modified_method":"/**\n     * Create a LocusReferenceView given no other contextual information about\n     * the walkers, etc.\n     * @param provider  source for locus data.\n     */\n    public LocusReferenceView( ShardDataProvider provider ) {\n        super(provider);\n        bounds = provider.getShard().getGenomeLoc();\n        windowStart = windowStop = 0;\n        initializeReferenceSequence(bounds);\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets the reference base associated with this particular point on the genome.\n     * @param genomeLoc Region for which to retrieve the base.  GenomeLoc must represent a 1-base region.\n     * @return The base at the position represented by this genomeLoc.\n     */\n    public char getReferenceBase( GenomeLoc genomeLoc ) {\n        validateLocation( genomeLoc );\n        int offset = (int)(genomeLoc.getStart() - bounds.getStart());\n        return StringUtil.bytesToString( referenceSequence.getBases(), offset, 1 ).charAt(0);\n    }","id":43496,"modified_method":"/**\n     * Gets the reference context associated with this particular point on the genome.\n     * @param genomeLoc Region for which to retrieve the base.  GenomeLoc must represent a 1-base region.\n     * @return The base at the position represented by this genomeLoc.\n     */\n    public ReferenceContext getReferenceContext( GenomeLoc genomeLoc ) {\n        validateLocation( genomeLoc );\n\n        GenomeLoc window = GenomeLocParser.createGenomeLoc( genomeLoc.getContig(), getWindowStart(genomeLoc), getWindowStop(genomeLoc) );\n        char[] bases = StringUtil.bytesToString( referenceSequence.getBases(), (int)(window.getStart() - getWindowStart(bounds)), (int)window.size() ).toCharArray();\n        return new ReferenceContext( genomeLoc, window, bases );\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Queries outside the bounds of the shard should generate an error. */\n    @Test(expected = InvalidPositionException.class)\n    public void testBoundsFailure() {\n        Shard shard = new LocusShard(GenomeLocParser.createGenomeLoc(0, 1, 50));\n\n        ShardDataProvider dataProvider = new ShardDataProvider(shard, null, sequenceFile, null);\n        LocusReferenceView view = new LocusReferenceView(dataProvider);\n\n        view.getReferenceBase(GenomeLocParser.createGenomeLoc(0, 51));\n    }","id":43497,"modified_method":"/** Queries outside the bounds of the shard should generate an error. */\n    @Test(expected = InvalidPositionException.class)\n    public void testBoundsFailure() {\n        Shard shard = new LocusShard(GenomeLocParser.createGenomeLoc(0, 1, 50));\n\n        ShardDataProvider dataProvider = new ShardDataProvider(shard, null, sequenceFile, null);\n        LocusReferenceView view = new LocusReferenceView(dataProvider);\n\n        view.getReferenceContext(GenomeLocParser.createGenomeLoc(0, 51)).getBase();\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Multiple-base pair queries should generate exceptions. */\n    @Test(expected = InvalidPositionException.class)\n    public void testSingleBPFailure() {\n        Shard shard = new LocusShard(GenomeLocParser.createGenomeLoc(0, 1, 50));\n\n        ShardDataProvider dataProvider = new ShardDataProvider(shard, null, sequenceFile, null);\n        LocusReferenceView view = new LocusReferenceView(dataProvider);\n\n        view.getReferenceBase(shard.getGenomeLoc());\n    }","id":43498,"modified_method":"/** Multiple-base pair queries should generate exceptions. */\n    @Test(expected = InvalidPositionException.class)\n    public void testSingleBPFailure() {\n        Shard shard = new LocusShard(GenomeLocParser.createGenomeLoc(0, 1, 50));\n\n        ShardDataProvider dataProvider = new ShardDataProvider(shard, null, sequenceFile, null);\n        LocusReferenceView view = new LocusReferenceView(dataProvider);\n\n        view.getReferenceContext(shard.getGenomeLoc()).getBase();\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compares the contents of the fasta and view at a specified location.\n     *\n     * @param loc\n     */\n    protected void validateLocation( GenomeLoc loc ) {\n        Shard shard = new LocusShard(loc);\n        GenomeLocusIterator shardIterator = new GenomeLocusIterator(shard.getGenomeLoc());\n\n        ShardDataProvider dataProvider = new ShardDataProvider(shard, null, sequenceFile, null);\n        LocusReferenceView view = new LocusReferenceView(dataProvider);\n\n        while (shardIterator.hasNext()) {\n            GenomeLoc locus = shardIterator.next();\n\n            ReferenceSequence expectedAsSeq = sequenceFile.getSubsequenceAt(locus.getContig(), locus.getStart(), locus.getStop());\n            char expected = StringUtil.bytesToString(expectedAsSeq.getBases()).charAt(0);\n            char actual = view.getReferenceBase(locus);\n\n            Assert.assertEquals(String.format(\"Value of base at position %s in shard %s does not match expected\", locus.toString(), shard.getGenomeLoc()),\n                    expected,\n                    actual);\n        }\n    }","id":43499,"modified_method":"/**\n     * Compares the contents of the fasta and view at a specified location.\n     *\n     * @param loc\n     */\n    protected void validateLocation( GenomeLoc loc ) {\n        Shard shard = new LocusShard(loc);\n        GenomeLocusIterator shardIterator = new GenomeLocusIterator(shard.getGenomeLoc());\n\n        ShardDataProvider dataProvider = new ShardDataProvider(shard, null, sequenceFile, null);\n        LocusReferenceView view = new LocusReferenceView(dataProvider);\n\n        while (shardIterator.hasNext()) {\n            GenomeLoc locus = shardIterator.next();\n\n            ReferenceSequence expectedAsSeq = sequenceFile.getSubsequenceAt(locus.getContig(), locus.getStart(), locus.getStop());\n            char expected = StringUtil.bytesToString(expectedAsSeq.getBases()).charAt(0);\n            char actual = view.getReferenceContext(locus).getBase();\n\n            Assert.assertEquals(String.format(\"Value of base at position %s in shard %s does not match expected\", locus.toString(), shard.getGenomeLoc()),\n                    expected,\n                    actual);\n        }\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public AlignmentContext map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        out.printf( \"In map: ref = %s, loc = %s, reads = %s%n\", ref,\n                                                                context.getLocation(),\n                                                                Arrays.deepToString( getReadNames(context.getReads()) ) );\n        return context;\n    }","id":43500,"modified_method":"public AlignmentContext map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        out.printf( \"In map: ref = %s, loc = %s, reads = %s%n\", ref.getBase(),\n                                                                context.getLocation(),\n                                                                Arrays.deepToString( getReadNames(context.getReads()) ) );\n        return context;\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ReferenceContext( char base ) {\n        this.base = base;\n    }","id":43501,"modified_method":"/**\n     * Contructor for a simple, windowless reference context.\n     * @param locus locus of interest.\n     * @param base reference base at that locus.\n     */\n    public ReferenceContext( GenomeLoc locus, char base ) {\n        this( locus, locus, new char[] { base } );\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Get the base at the given locus.\n     * @return The base at the given locus from the reference.�\n     */\n    public char getBase() {\n        return base;    \n    }","id":43502,"modified_method":"/**\n     * Get the base at the given locus.\n     * @return The base at the given locus from the reference.\n     */\n    public char getBase() {\n        return bases[(int)(locus.getStart() - window.getStart())];\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public <M,T> T traverse( Walker<M,T> walker,\n                             Shard shard,\n                             ShardDataProvider dataProvider,\n                             T sum ) {\n        logger.debug(String.format(\"TraverseLoci.traverse Genomic interval is %s\", shard.getGenomeLoc()));\n\n        if ( !(walker instanceof LocusWalker) )\n            throw new IllegalArgumentException(\"Walker isn't a loci walker!\");\n\n        LocusWalker<M, T> locusWalker = (LocusWalker<M, T>)walker;\n\n        LocusView locusView = getLocusView( walker, dataProvider );\n        LocusReferenceView referenceView = new LocusReferenceView( dataProvider );\n        ReferenceOrderedView referenceOrderedDataView = new ReferenceOrderedView( dataProvider );\n\n        // We keep processing while the next reference location is within the interval\n        while( locusView.hasNext() ) {\n            AlignmentContext locus = locusView.next();\n\n            TraversalStatistics.nRecords++;\n\n            // Iterate forward to get all reference ordered data covering this locus\n            final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation());\n\n            ReferenceContext refContext = new ReferenceContext( referenceView.getReferenceBase(locus.getLocation()) );\n\n            final boolean keepMeP = locusWalker.filter(tracker, refContext, locus);\n            if (keepMeP) {\n                M x = locusWalker.map(tracker, refContext, locus);\n                sum = locusWalker.reduce(x, sum);\n            }\n\n            if (this.maximumIterations > 0 && TraversalStatistics.nRecords > this.maximumIterations) {\n                logger.warn(String.format(\"Maximum number of reads encountered, terminating traversal \" + TraversalStatistics.nRecords));\n                break;\n            }\n\n            printProgress(\"loci\", locus.getLocation());\n        }\n\n        return sum;\n    }","id":43503,"modified_method":"@Override\n    public <M,T> T traverse( Walker<M,T> walker,\n                             Shard shard,\n                             ShardDataProvider dataProvider,\n                             T sum ) {\n        logger.debug(String.format(\"TraverseLoci.traverse Genomic interval is %s\", shard.getGenomeLoc()));\n\n        if ( !(walker instanceof LocusWalker) )\n            throw new IllegalArgumentException(\"Walker isn't a loci walker!\");\n\n        LocusWalker<M, T> locusWalker = (LocusWalker<M, T>)walker;\n\n        LocusView locusView = getLocusView( walker, dataProvider );\n        LocusReferenceView referenceView = new LocusReferenceView( walker, dataProvider );\n        ReferenceOrderedView referenceOrderedDataView = new ReferenceOrderedView( dataProvider );\n\n        // We keep processing while the next reference location is within the interval\n        while( locusView.hasNext() ) {\n            AlignmentContext locus = locusView.next();\n\n            TraversalStatistics.nRecords++;\n\n            // Iterate forward to get all reference ordered data covering this locus\n            final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation());\n\n            ReferenceContext refContext = referenceView.getReferenceContext(locus.getLocation());\n\n            final boolean keepMeP = locusWalker.filter(tracker, refContext, locus);\n            if (keepMeP) {\n                M x = locusWalker.map(tracker, refContext, locus);\n                sum = locusWalker.reduce(x, sum);\n            }\n\n            if (this.maximumIterations > 0 && TraversalStatistics.nRecords > this.maximumIterations) {\n                logger.warn(String.format(\"Maximum number of reads encountered, terminating traversal \" + TraversalStatistics.nRecords));\n                break;\n            }\n\n            printProgress(\"loci\", locus.getLocation());\n        }\n\n        return sum;\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public <M,T> T traverse( Walker<M,T> walker,\n                             Shard shard,\n                             ShardDataProvider dataProvider,\n                             T sum ) {\n\n        if ( !(walker instanceof LocusWindowWalker) )\n            throw new IllegalArgumentException(\"Walker isn't a locus window walker!\");\n\n        LocusWindowWalker<M, T> locusWindowWalker = (LocusWindowWalker<M, T>)walker;\n\n        GenomeLoc interval = shard.getGenomeLoc();\n\n        ReadView readView = new ReadView( dataProvider );\n        LocusReferenceView referenceView = new LocusReferenceView( dataProvider );\n        ReferenceOrderedView referenceOrderedDataView = new ReferenceOrderedView( dataProvider );\n\n        AlignmentContext locus = getLocusContext(readView.iterator(), interval);\n\n        // The TraverseByLocusWindow expands intervals to cover all reads in a non-standard way.\n        // TODO: Convert this approach to the standard.\n        GenomeLoc expandedInterval = locus.getLocation();\n\n        String referenceSubsequence = new String(referenceView.getReferenceBases(expandedInterval));\n\n        // Iterate forward to get all reference ordered data covering this interval\n        final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation());\n\n        //\n        // Execute our contract with the walker.  Call filter, map, and reduce\n        //\n        final boolean keepMeP = locusWindowWalker.filter(tracker, referenceSubsequence, locus);\n        if (keepMeP) {\n            M x = locusWindowWalker.map(tracker, referenceSubsequence, locus);\n            sum = locusWindowWalker.reduce(x, sum);\n        }\n\n        printProgress(\"intervals\", locus.getLocation());\n\n        return sum;\n    }","id":43504,"modified_method":"public <M,T> T traverse( Walker<M,T> walker,\n                             Shard shard,\n                             ShardDataProvider dataProvider,\n                             T sum ) {\n\n        if ( !(walker instanceof LocusWindowWalker) )\n            throw new IllegalArgumentException(\"Walker isn't a locus window walker!\");\n\n        LocusWindowWalker<M, T> locusWindowWalker = (LocusWindowWalker<M, T>)walker;\n\n        GenomeLoc interval = shard.getGenomeLoc();\n\n        ReadView readView = new ReadView( dataProvider );\n        LocusReferenceView referenceView = new LocusReferenceView( walker, dataProvider );\n        ReferenceOrderedView referenceOrderedDataView = new ReferenceOrderedView( dataProvider );\n\n        AlignmentContext locus = getLocusContext(readView.iterator(), interval);\n\n        // The TraverseByLocusWindow expands intervals to cover all reads in a non-standard way.\n        // TODO: Convert this approach to the standard.\n        GenomeLoc expandedInterval = locus.getLocation();\n\n        String referenceSubsequence = new String(referenceView.getReferenceBases(expandedInterval));\n\n        // Iterate forward to get all reference ordered data covering this interval\n        final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation());\n\n        //\n        // Execute our contract with the walker.  Call filter, map, and reduce\n        //\n        final boolean keepMeP = locusWindowWalker.filter(tracker, referenceSubsequence, locus);\n        if (keepMeP) {\n            M x = locusWindowWalker.map(tracker, referenceSubsequence, locus);\n            sum = locusWindowWalker.reduce(x, sum);\n        }\n\n        printProgress(\"intervals\", locus.getLocation());\n\n        return sum;\n    }","commit_id":"48713e154c4efb332fced0d2dbbb118b1b29f96a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n  protected void init() {\n    super.init();\n\n    JPanel optionsPanel = new JPanel(new GridBagLayout());\n    optionsPanel.add(createKeepBlankLinesPanel(),\n                     new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL,\n                                            new Insets(0, 0, 0, 0), 0, 0));\n    optionsPanel.add(createBlankLinesPanel(),\n                     new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL,\n                                            new Insets(0, 0, 0, 0), 0, 0));\n    optionsPanel.add(new JPanel(),\n                     new GridBagConstraints(0, 2, 1, 1, 0, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0,\n                                            0));\n    optionsPanel.add(new JPanel(),\n                     new GridBagConstraints(1, 0, 1, 3, 1, 0, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0,\n                                            0));\n\n    JScrollPane scroll = ScrollPaneFactory.createScrollPane(optionsPanel);\n    scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);\n    scroll.setBorder(null);\n    scroll.setMinimumSize(new Dimension(350, 0));\n\n    myPanel\n      .add(scroll,\n           new GridBagConstraints(0, 0, 1, 1, 0, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0, 4, 0, 4), 0, 0));\n\n    final JPanel previewPanel = createPreviewPanel();\n    myPanel\n      .add(previewPanel,\n           new GridBagConstraints(1, 0, 1, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0, 0, 0, 4), 0, 0));\n\n    installPreviewPanel(previewPanel);\n    addPanelToWatch(myPanel);\n\n    myIsFirstUpdate = false;\n  }","id":43505,"modified_method":"@Override\n  protected void init() {\n    super.init();\n\n    JPanel optionsPanel = new JPanel(new GridBagLayout());\n    optionsPanel.add(createKeepBlankLinesPanel(),\n                     new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL,\n                                            new Insets(0, 0, 0, 0), 0, 0));\n    optionsPanel.add(createBlankLinesPanel(),\n                     new GridBagConstraints(0, 1, 1, 1, 1, 0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL,\n                                            new Insets(0, 0, 0, 0), 0, 0));\n    optionsPanel.add(new JPanel(),\n                     new GridBagConstraints(0, 2, 1, 1, 0, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0,\n                                            0));\n\n    JScrollPane scroll = ScrollPaneFactory.createScrollPane(optionsPanel);\n    scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);\n    scroll.setBorder(null);\n    scroll.setMinimumSize(new Dimension(optionsPanel.getPreferredSize().width + scroll.getVerticalScrollBar().getPreferredSize().width,\n                                        optionsPanel.getPreferredSize().height));\n\n    myPanel\n      .add(scroll,\n           new GridBagConstraints(0, 0, 1, 1, 0, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0, 4, 0, 4), 0, 0));\n\n    final JPanel previewPanel = createPreviewPanel();\n    myPanel\n      .add(previewPanel,\n           new GridBagConstraints(1, 0, 1, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(0, 0, 0, 4), 0, 0));\n\n    installPreviewPanel(previewPanel);\n    addPanelToWatch(myPanel);\n\n    myIsFirstUpdate = false;\n  }","commit_id":"d59f9bf93059736e91a1a4e9a60ddf0ff8efd7bb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JPanel createImportLayoutPanel() {\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.setBorder(IdeBorderFactory.createTitledBorderBoldWithoutIndent(ApplicationBundle.message(\"title.import.layout\")));\n    myCbLayoutStaticImportsSeparately = new JCheckBox(\"Layout static imports separately\");\n\n    myCbLayoutStaticImportsSeparately.addItemListener(new ItemListener(){\n      public void itemStateChanged(ItemEvent e) {\n        if (areStaticImportsEnabled()) {\n          boolean found = false;\n          for (int i=myImportLayoutList.getEntryCount()-1; i>=0; i--) {\n            PackageEntry entry = myImportLayoutList.getEntryAt(i);\n            if (entry == PackageEntry.ALL_OTHER_STATIC_IMPORTS_ENTRY) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            int index = myImportLayoutList.getEntryCount();\n            if (index != 0 && myImportLayoutList.getEntryAt(index-1) != PackageEntry.BLANK_LINE_ENTRY) {\n              myImportLayoutList.addEntry(PackageEntry.BLANK_LINE_ENTRY);\n            }\n            myImportLayoutList.addEntry(PackageEntry.ALL_OTHER_STATIC_IMPORTS_ENTRY);\n          }\n        }\n        else {\n          for (int i=myImportLayoutList.getEntryCount()-1; i>=0; i--) {\n            PackageEntry entry = myImportLayoutList.getEntryAt(i);\n            if (entry.isStatic()) {\n              myImportLayoutList.removeEntryAt(i);\n            }\n          }\n        }\n        refreshTable(myImportLayoutTable, myImportLayoutList);\n        refreshTable(myPackageTable, myPackageList);\n      }\n    });\n    panel.add(myCbLayoutStaticImportsSeparately, BorderLayout.NORTH);\n    panel.add(createImportLayoutTable(), BorderLayout.CENTER);\n    panel.add(createImportLayoutButtonsPanel(), BorderLayout.EAST);\n    panel.setPreferredSize(new Dimension(-1, 200));\n    return panel;\n  }","id":43506,"modified_method":"private JPanel createImportLayoutPanel() {\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.setBorder(IdeBorderFactory.createTitledBorderBoldWithoutIndent(ApplicationBundle.message(\"title.import.layout\")));\n    myCbLayoutStaticImportsSeparately = new JCheckBox(\"Layout static imports separately\");\n\n    myCbLayoutStaticImportsSeparately.addItemListener(new ItemListener(){\n      public void itemStateChanged(ItemEvent e) {\n        if (areStaticImportsEnabled()) {\n          boolean found = false;\n          for (int i=myImportLayoutList.getEntryCount()-1; i>=0; i--) {\n            PackageEntry entry = myImportLayoutList.getEntryAt(i);\n            if (entry == PackageEntry.ALL_OTHER_STATIC_IMPORTS_ENTRY) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            int index = myImportLayoutList.getEntryCount();\n            if (index != 0 && myImportLayoutList.getEntryAt(index-1) != PackageEntry.BLANK_LINE_ENTRY) {\n              myImportLayoutList.addEntry(PackageEntry.BLANK_LINE_ENTRY);\n            }\n            myImportLayoutList.addEntry(PackageEntry.ALL_OTHER_STATIC_IMPORTS_ENTRY);\n          }\n        }\n        else {\n          for (int i=myImportLayoutList.getEntryCount()-1; i>=0; i--) {\n            PackageEntry entry = myImportLayoutList.getEntryAt(i);\n            if (entry.isStatic()) {\n              myImportLayoutList.removeEntryAt(i);\n            }\n          }\n        }\n        refreshTable(myImportLayoutTable, myImportLayoutList);\n        refreshTable(myPackageTable, myPackageList);\n      }\n    });\n    panel.add(myCbLayoutStaticImportsSeparately, BorderLayout.NORTH);\n    panel.add(createImportLayoutTable(), BorderLayout.CENTER);\n    panel.add(createImportLayoutButtonsPanel(), BorderLayout.EAST);\n    return panel;\n  }","commit_id":"d59f9bf93059736e91a1a4e9a60ddf0ff8efd7bb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JPanel createPackagesPanel() {\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.setBorder(IdeBorderFactory.createTitledBorderBoldWithoutIndent(ApplicationBundle.message(\"title.packages.to.use.import.with\")));\n\n    panel.add(createPackagesTable(), BorderLayout.CENTER);\n    panel.add(createPackagesButtonsPanel(), BorderLayout.EAST);\n    panel.setPreferredSize(new Dimension(-1, 200));\n    return panel;\n  }","id":43507,"modified_method":"private JPanel createPackagesPanel() {\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.setBorder(IdeBorderFactory.createTitledBorderBoldWithoutIndent(ApplicationBundle.message(\"title.packages.to.use.import.with\")));\n\n    panel.add(createPackagesTable(), BorderLayout.CENTER);\n    panel.add(createPackagesButtonsPanel(), BorderLayout.EAST);\n    return panel;\n  }","commit_id":"d59f9bf93059736e91a1a4e9a60ddf0ff8efd7bb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JPanel createPanel() {\n    JPanel panel = new JPanel();\n    panel.setLayout(new GridBagLayout());\n\n    for (int i = 0; i < myOptions.size(); i++) {\n      int leftInset = Boolean.TRUE.equals(myIsShifted.get(i)) ? 15 : 5;\n      if (myTitle == null) {\n        leftInset -= 4;\n      }\n      Object option = myOptions.get(i);\n      if (option instanceof JComponent) {\n        JComponent component = (JComponent)option;\n        int verticalInset = component instanceof JLabel || component instanceof JTextField ? 2 : 0;\n        panel.add(component,\n                  new GridBagConstraints(0, i, GridBagConstraints.REMAINDER, 1, 0, 0, GridBagConstraints.WEST, getFill(component),\n                                         new Insets(verticalInset, leftInset, verticalInset, 5), 0, 0));\n      }\n      else {\n        Pair pair = (Pair)option;\n        JComponent firstComponent = (JComponent)pair.first;\n        int verticalInset = firstComponent instanceof JLabel || firstComponent instanceof JTextField ? 1 : 0;\n        panel.add(firstComponent,\n                  new GridBagConstraints(0, i, 1, 1, 1, 0, GridBagConstraints.WEST, getFill(firstComponent),\n                                         new Insets(verticalInset, leftInset, verticalInset, 5), 0, 0));\n        JComponent secondComponent = (JComponent)pair.second;\n        verticalInset = secondComponent instanceof JLabel || secondComponent instanceof JTextField ? 2 : 0;\n        panel.add(secondComponent,\n                  new GridBagConstraints(1, i, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL,\n                                         new Insets(verticalInset, 5, verticalInset, 5), 0, 0));\n      }\n    }\n    JPanel p = new JPanel();\n    p.setPreferredSize(new Dimension(0, 0));\n    panel.add(p,\n              new GridBagConstraints(0, myOptions.size(), GridBagConstraints.REMAINDER, 1, 0, 1,\n                                     GridBagConstraints.NORTH, GridBagConstraints.NONE,\n                                     new Insets(0, 0, 0, 0), 0, 0));\n\n    if (myTitle != null) {\n      IdeaTitledBorder titledBorder = IdeBorderFactory.createTitledBorderBoldWithIndent(myTitle);\n      panel.setBorder(titledBorder);\n      titledBorder.acceptMinimumSize(panel);\n    }\n\n    return panel;\n  }","id":43508,"modified_method":"public JPanel createPanel() {\n    JPanel panel = new JPanel();\n    panel.setLayout(new GridBagLayout());\n\n    for (int i = 0; i < myOptions.size(); i++) {\n      int leftInset = Boolean.TRUE.equals(myIsShifted.get(i)) ? 15 : 5;\n      if (myTitle == null) {\n        leftInset -= 4;\n      }\n      Object option = myOptions.get(i);\n      if (option instanceof JComponent) {\n        JComponent component = (JComponent)option;\n        int verticalInset = component instanceof JLabel || component instanceof JTextField ? 2 : 0;\n        panel.add(component,\n                  new GridBagConstraints(0, i, GridBagConstraints.REMAINDER, 1, 1, 0, GridBagConstraints.WEST, getFill(component),\n                                         new Insets(verticalInset, leftInset, verticalInset, 5), 0, 0));\n      }\n      else {\n        Pair pair = (Pair)option;\n        JComponent firstComponent = (JComponent)pair.first;\n        int verticalInset = firstComponent instanceof JLabel || firstComponent instanceof JTextField ? 1 : 0;\n        panel.add(firstComponent,\n                  new GridBagConstraints(0, i, 1, 1, 1, 0, GridBagConstraints.WEST, getFill(firstComponent),\n                                         new Insets(verticalInset, leftInset, verticalInset, 5), 0, 0));\n        JComponent secondComponent = (JComponent)pair.second;\n        verticalInset = secondComponent instanceof JLabel || secondComponent instanceof JTextField ? 2 : 0;\n        panel.add(secondComponent,\n                  new GridBagConstraints(1, i, 1, 1, 1, 0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL,\n                                         new Insets(verticalInset, 5, verticalInset, 5), 0, 0));\n      }\n    }\n    JPanel p = new JPanel();\n    p.setPreferredSize(new Dimension(0, 0));\n    panel.add(p,\n              new GridBagConstraints(0, myOptions.size(), GridBagConstraints.REMAINDER, 1, 0, 1,\n                                     GridBagConstraints.NORTH, GridBagConstraints.NONE,\n                                     new Insets(0, 0, 0, 0), 0, 0));\n\n    if (myTitle != null) {\n      IdeaTitledBorder titledBorder = IdeBorderFactory.createTitledBorderBoldWithIndent(myTitle);\n      panel.setBorder(titledBorder);\n      titledBorder.acceptMinimumSize(panel);\n    }\n\n    return panel;\n  }","commit_id":"d59f9bf93059736e91a1a4e9a60ddf0ff8efd7bb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static JMenuBar getMenuBar(Window[] toolWindows) {\n        final int metaMask = VueUtil.isMacPlatform() ? Event.META_MASK : Event.CTRL_MASK;\n        \n        JMenuBar menuBar = new JMenuBar();\n        \n        JMenu fileMenu = menuBar.add(new JMenu(\"File\"));\n        JMenu editMenu = menuBar.add(new JMenu(\"Edit\"));\n        JMenu viewMenu = menuBar.add(new JMenu(\"View\"));\n        JMenu formatMenu = menuBar.add(new JMenu(\"Format\"));\n        JMenu arrangeMenu = menuBar.add(new JMenu(\"Arrange\"));\n        JMenu windowMenu = menuBar.add(new JMenu(\"Window\"));\n        JMenu alignMenu = menuBar.add(new JMenu(\"Arrange/Align\"));\n        //JMenu optionsMenu = menuBar.add(new JMenu(\"Options\"))l\n        JMenu helpMenu = menuBar.add(new JMenu(\"Help\"));\n\n        //adding actions\n        SaveAction saveAction = new SaveAction(\"Save\", false);\n        SaveAction saveAsAction = new SaveAction(\"Save As...\");\n        OpenAction openAction = new OpenAction(\"Open\");\n        ExitAction exitAction = new ExitAction(\"Quit\");\n        Publish publishAction = new Publish(frame,\"Export\");\n        \n        // Actions added by the power team\n        PrintAction printAction = PrintAction.getPrintAction();\n        PDFTransform pdfAction = new PDFTransform(\"PDF\");\n        HTMLConversion htmlAction = new HTMLConversion(\"HTML\");\n        ImageConversion imageAction = new ImageConversion(\"JPEG\");\n        ImageMap imageMap = new ImageMap(\"IMAP\");\n        SVGConversion svgAction = new SVGConversion(\"SVG\");\n        XMLView xmlAction = new XMLView(\"XML View\");\n        \n        if (DEBUG.Enabled) {\n            JButton u = new JButton(Actions.Undo);\n            JButton r = new JButton(Actions.Redo);\n            JButton p = new JButton(printAction);\n            JButton v = new JButton(printAction);\n            v.setText(\"Print Visible\");\n            \n            u.setBackground(Color.white);\n            r.setBackground(Color.white);\n            menuBar.add(u).setFocusable(false);\n            menuBar.add(r).setFocusable(false);\n            menuBar.add(p).setFocusable(false);\n            menuBar.add(v).setFocusable(false);\n\n            //menuBar.add(new tufts.vue.gui.VueButton(Actions.Undo)).setFocusable(false);\n            // not picking up icon yet...\n        }\n\n        if (DEBUG.Enabled) {\n            JMenu exportMenu = menuBar.add(new JMenu(\"Export\"));\n            exportMenu.add(htmlAction);\n            exportMenu.add(pdfAction);\n            exportMenu.add(imageAction);\n            exportMenu.add(svgAction);\n            exportMenu.add(xmlAction);\n            exportMenu.add(imageMap);\n\n        }\n        \n        fileMenu.add(Actions.NewMap);\n        fileMenu.add(openAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, metaMask));\n        fileMenu.add(saveAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask));\n        fileMenu.add(saveAsAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask+Event.SHIFT_MASK));\n        fileMenu.add(Actions.CloseMap);\n        fileMenu.add(printAction);\n        fileMenu.add(printAction).setText(\"Print Visible...\");\n        fileMenu.add(publishAction);\n        //fileMenu.add(exportMenu);\n        fileMenu.addSeparator();\n        fileMenu.add(exitAction);\n        \n        editMenu.add(Actions.Undo);\n        editMenu.add(Actions.Redo);\n        editMenu.addSeparator();\n        editMenu.add(Actions.NewNode);\n        editMenu.add(Actions.NewText);\n        editMenu.add(Actions.Rename);\n        editMenu.add(Actions.Duplicate);\n        editMenu.add(Actions.Delete);\n        editMenu.addSeparator();\n        editMenu.add(Actions.Cut);\n        editMenu.add(Actions.Copy);\n        editMenu.add(Actions.Paste);\n        editMenu.addSeparator();\n        editMenu.add(Actions.SelectAll);\n        editMenu.add(Actions.DeselectAll);\n        editMenu.addSeparator();\n        editMenu.add(Actions.editDataSource);\n        \n        \n        viewMenu.add(Actions.ZoomIn);\n        viewMenu.add(Actions.ZoomOut);\n        viewMenu.add(Actions.ZoomFit);\n        viewMenu.add(Actions.ZoomActual);\n        /*\n        viewMenu.addSeparator();\n        viewMenu.add(new JMenuItem(\"Resources\"));\n        viewMenu.add(new JMenuItem(\"Collection\"));\n        viewMenu.add(new JMenuItem(\"Inspector\"));\n        viewMenu.add(new JMenuItem(\"Pathway\"));\n        viewMenu.add(new JMenuItem(\"Toolbar\"));\n        viewMenu.add(new JMenuItem(\"Overview\"));\n         */\n        \n        JMenu fontMenu = new JMenu(\"Font\");\n        \n        //formatMenu.add(fontMenu);\n        formatMenu.add(Actions.FontSmaller);\n        formatMenu.add(Actions.FontBigger);\n        formatMenu.add(Actions.FontBold);\n        formatMenu.add(Actions.FontItalic);\n        //formatMenu.add(new JMenuItem(\"Size\"));\n        //formatMenu.add(new JMenuItem(\"Style\"));\n        //formatMenu.add(\"Text Justify\").setEnabled(false);\n        // TODO: ultimately better to break these out in to Node & Link submenus\n        formatMenu.addSeparator();\n        buildMenu(formatMenu, Actions.NODE_MENU_ACTIONS);\n        formatMenu.addSeparator();\n        buildMenu(formatMenu, Actions.LINK_MENU_ACTIONS);\n        \n        buildMenu(alignMenu, Actions.ARRANGE_MENU_ACTIONS);\n\n        arrangeMenu.add(Actions.BringToFront);\n        arrangeMenu.add(Actions.BringForward);\n        arrangeMenu.add(Actions.SendToBack);\n        arrangeMenu.add(Actions.SendBackward);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(Actions.Group);\n        arrangeMenu.add(Actions.Ungroup);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(alignMenu);\n        \n        if (toolWindows != null) {\n            int accel_index = 0;\n            for (int i = 0; i < toolWindows.length; i++) {\n                //System.out.println(\"adding \" + toolWindows[i]);\n                Window window = toolWindows[i];\n                if (window == null)\n                    continue;\n                WindowDisplayAction windowAction = new WindowDisplayAction(window);\n                windowAction.putValue(Action.ACCELERATOR_KEY,\n                                      KeyStroke.getKeyStroke(KeyEvent.VK_1 + accel_index++, Actions.COMMAND));\n                JCheckBoxMenuItem checkBox = new JCheckBoxMenuItem(windowAction);\n                windowAction.setLinkedButton(checkBox);\n                windowMenu.add(checkBox);\n            }\n        }\n        \n        //windowMenu.add(new UserDataAction());\n        /*\n        optionsMenu.add(new UserDataAction());\n        optionsMenu.add(new JMenuItem(\"Map Preference...\"));\n        optionsMenu.add(new JMenuItem(\"Preferences...\"));\n         */\n        \n        JMenuItem userGuide = new JMenuItem(\"User Guide\");\n        JMenuItem aboutUs = new JMenuItem(\"About VUE\");\n        helpMenu.add(userGuide);\n        helpMenu.add(aboutUs);\n        aboutusTool = new ToolWindow(\"VUE: About VUE\", tufts.vue.VUE.getInstance());\n        JPanel aboutusPanel = new JPanel();\n        aboutusPanel.setMinimumSize(new Dimension(400,400));\n        \n         JLabel spLabel = new JLabel(VueResources.getImageIcon(\"splashScreen\"));\n        //JTextArea jtf = new JTextArea(\"Version # 1.0 \\n Created By:  Academic Technology \\n Tufts University, Medford, MA \\n Copyright@Tufts University 2004\\nAll Rights Reserved \",5, 1);\n        //jtf.setEditable(false);\n        //jtf.setOpaque(false);\n        aboutusPanel.setLayout(new BorderLayout());\n        aboutusPanel.add(spLabel,BorderLayout.CENTER);\n        aboutusTool.addTool(aboutusPanel, true);\n        \n        userGuide.addActionListener(new ActionListener() {\n               public void actionPerformed(ActionEvent e) {\n                   try {\n                       VueUtil.openURL(\"http://vue.tccs.tufts.edu/userdoc/\");\n                   } catch (Exception ex) { out(ex); }\n               }});\n        \n        aboutUs.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    //aboutusTool.setLocation(200,200);\n                    VueUtil.centerOnScreen(aboutusTool);\n                    aboutusTool.setVisible(true);\n                }});\n        \n          /*\n        JToolBar toolBar = new JToolBar();\n        toolBar.add(Actions.NewMap);\n        toolBar.add(openAction);\n        toolBar.add(Actions.CloseMap);\n        toolBar.add(saveAction);\n        toolBar.add(saveAsAction);\n        toolBar.add(printAction);\n        toolBar.add(imageAction);\n        toolBar.add(htmlAction);\n        toolBar.add(xmlAction);\n        toolBar.add(pdfAction);\n        toolBar.add(imageMap);\n        toolBar.add(svgAction);\n        // toolBar.add(new JButton(new ImageIcon(\"tufts/vue/images/ZoomOut16.gif\")));\n        toolBar.add(new JButton(new PolygonIcon(Color.RED)));\n        frame.getContentPane().add(toolBar,BorderLayout.NORTH);\n          */\n\n        return menuBar;\n\n    }","id":43509,"modified_method":"static JMenuBar getMenuBar(Window[] toolWindows) {\n        final int metaMask = VueUtil.isMacPlatform() ? Event.META_MASK : Event.CTRL_MASK;\n        \n        JMenuBar menuBar = new JMenuBar();\n        \n        JMenu fileMenu = menuBar.add(new JMenu(\"File\"));\n        JMenu editMenu = menuBar.add(new JMenu(\"Edit\"));\n        JMenu viewMenu = menuBar.add(new JMenu(\"View\"));\n        JMenu formatMenu = menuBar.add(new JMenu(\"Format\"));\n        JMenu arrangeMenu = menuBar.add(new JMenu(\"Arrange\"));\n        JMenu windowMenu = menuBar.add(new JMenu(\"Window\"));\n        JMenu alignMenu = menuBar.add(new JMenu(\"Arrange/Align\"));\n        //JMenu optionsMenu = menuBar.add(new JMenu(\"Options\"))l\n        JMenu helpMenu = menuBar.add(new JMenu(\"Help\"));\n\n        //adding actions\n        SaveAction saveAction = new SaveAction(\"Save\", false);\n        SaveAction saveAsAction = new SaveAction(\"Save As...\");\n        OpenAction openAction = new OpenAction(\"Open\");\n        ExitAction exitAction = new ExitAction(\"Quit\");\n        Publish publishAction = new Publish(frame,\"Export\");\n        \n        // Actions added by the power team\n        PrintAction printAction = PrintAction.getPrintAction();\n        PDFTransform pdfAction = new PDFTransform(\"PDF\");\n        HTMLConversion htmlAction = new HTMLConversion(\"HTML\");\n        ImageConversion imageAction = new ImageConversion(\"JPEG\");\n        ImageMap imageMap = new ImageMap(\"IMAP\");\n        SVGConversion svgAction = new SVGConversion(\"SVG\");\n        XMLView xmlAction = new XMLView(\"XML View\");\n        \n        if (DEBUG.Enabled) {\n            JButton u = new JButton(Actions.Undo);\n            JButton r = new JButton(Actions.Redo);\n            JButton p = new JButton(printAction);\n            JButton v = new JButton(printAction);\n            v.setText(\"Print Visible\");\n            \n            u.setBackground(Color.white);\n            r.setBackground(Color.white);\n            menuBar.add(u).setFocusable(false);\n            menuBar.add(r).setFocusable(false);\n            menuBar.add(p).setFocusable(false);\n            menuBar.add(v).setFocusable(false);\n\n            //menuBar.add(new tufts.vue.gui.VueButton(Actions.Undo)).setFocusable(false);\n            // not picking up icon yet...\n        }\n\n        if (DEBUG.Enabled) {\n            JMenu exportMenu = menuBar.add(new JMenu(\"Export\"));\n            exportMenu.add(htmlAction);\n            exportMenu.add(pdfAction);\n            exportMenu.add(imageAction);\n            exportMenu.add(svgAction);\n            exportMenu.add(xmlAction);\n            exportMenu.add(imageMap);\n\n        }\n        \n        fileMenu.add(Actions.NewMap);\n        fileMenu.add(openAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, metaMask));\n        fileMenu.add(saveAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask));\n        fileMenu.add(saveAsAction).setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, metaMask+Event.SHIFT_MASK));\n        fileMenu.add(Actions.CloseMap);\n        fileMenu.add(printAction);\n        fileMenu.add(printAction).setText(\"Print Visible...\");\n        fileMenu.add(publishAction);\n        //fileMenu.add(exportMenu);\n        fileMenu.addSeparator();\n        fileMenu.add(exitAction);\n        \n        editMenu.add(Actions.Undo);\n        editMenu.add(Actions.Redo);\n        editMenu.addSeparator();\n        editMenu.add(Actions.NewNode);\n        editMenu.add(Actions.NewText);\n        editMenu.add(Actions.Rename);\n        editMenu.add(Actions.Duplicate);\n        editMenu.add(Actions.Delete);\n        editMenu.addSeparator();\n        editMenu.add(Actions.Cut);\n        editMenu.add(Actions.Copy);\n        editMenu.add(Actions.Paste);\n        editMenu.addSeparator();\n        editMenu.add(Actions.SelectAll);\n        editMenu.add(Actions.DeselectAll);\n        editMenu.addSeparator();\n        editMenu.add(Actions.editDataSource);\n        \n        \n        viewMenu.add(Actions.ZoomIn);\n        viewMenu.add(Actions.ZoomOut);\n        viewMenu.add(Actions.ZoomFit);\n        viewMenu.add(Actions.ZoomActual);\n        /*\n        viewMenu.addSeparator();\n        viewMenu.add(new JMenuItem(\"Resources\"));\n        viewMenu.add(new JMenuItem(\"Collection\"));\n        viewMenu.add(new JMenuItem(\"Inspector\"));\n        viewMenu.add(new JMenuItem(\"Pathway\"));\n        viewMenu.add(new JMenuItem(\"Toolbar\"));\n        viewMenu.add(new JMenuItem(\"Overview\"));\n         */\n        \n        JMenu fontMenu = new JMenu(\"Font\");\n        \n        //formatMenu.add(fontMenu);\n        formatMenu.add(Actions.FontSmaller);\n        formatMenu.add(Actions.FontBigger);\n        formatMenu.add(Actions.FontBold);\n        formatMenu.add(Actions.FontItalic);\n        //formatMenu.add(new JMenuItem(\"Size\"));\n        //formatMenu.add(new JMenuItem(\"Style\"));\n        //formatMenu.add(\"Text Justify\").setEnabled(false);\n        // TODO: ultimately better to break these out in to Node & Link submenus\n        formatMenu.addSeparator();\n        buildMenu(formatMenu, Actions.NODE_MENU_ACTIONS);\n        formatMenu.addSeparator();\n        buildMenu(formatMenu, Actions.LINK_MENU_ACTIONS);\n        \n        buildMenu(alignMenu, Actions.ARRANGE_MENU_ACTIONS);\n\n        arrangeMenu.add(Actions.BringToFront);\n        arrangeMenu.add(Actions.BringForward);\n        arrangeMenu.add(Actions.SendToBack);\n        arrangeMenu.add(Actions.SendBackward);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(Actions.Group);\n        arrangeMenu.add(Actions.Ungroup);\n        arrangeMenu.addSeparator();\n        arrangeMenu.add(alignMenu);\n        \n        if (toolWindows != null) {\n            int accel_index = 0;\n            for (int i = 0; i < toolWindows.length; i++) {\n                //System.out.println(\"adding \" + toolWindows[i]);\n                Window window = toolWindows[i];\n                if (window == null)\n                    continue;\n                WindowDisplayAction windowAction = new WindowDisplayAction(window);\n                windowAction.putValue(Action.ACCELERATOR_KEY,\n                                      KeyStroke.getKeyStroke(KeyEvent.VK_1 + accel_index++, Actions.COMMAND));\n                JCheckBoxMenuItem checkBox = new JCheckBoxMenuItem(windowAction);\n                windowAction.setLinkedButton(checkBox);\n                windowMenu.add(checkBox);\n            }\n        }\n        \n        //windowMenu.add(new UserDataAction());\n        /*\n        optionsMenu.add(new UserDataAction());\n        optionsMenu.add(new JMenuItem(\"Map Preference...\"));\n        optionsMenu.add(new JMenuItem(\"Preferences...\"));\n         */\n        \n        JMenuItem vueOnline = new JMenuItem(\"Vue Online\");\n        JMenuItem userGuide = new JMenuItem(\"User Guide\");\n        JMenuItem aboutUs = new JMenuItem(\"About VUE\");\n        helpMenu.add(vueOnline); \n        helpMenu.add(userGuide);\n        helpMenu.add(aboutUs);\n        aboutusTool = new ToolWindow(\"VUE: About VUE\", tufts.vue.VUE.getInstance());\n        JPanel backPanel = new JPanel();\n        backPanel.setBorder(new LineBorder(Color.WHITE,20));\n        backPanel.setMinimumSize(new Dimension(275,147));\n      \n        \n        JPanel aboutusPanel = new JPanel();\n        JLabel spLabel = new JLabel(VueResources.getImageIcon(\"aboutVue\"));\n        \n        JLabel jtf = new JLabel(\"<html> <font color = \\\"#20316A\\\"> <br><br>&nbsp;&nbsp;&nbsp;Developed by  Academic Technology <br> &nbsp;&nbsp;&nbsp;Copyright &copy; 2004 Tufts University<br>&nbsp; &nbsp;&nbsp;All Rights Reserved <br><br> &nbsp;&nbsp;&nbsp;Version 0.9 <br><br>&nbsp;&nbsp;&nbsp;<u> http://vue.tccs.tufts.edu<\/u><br><\/font><\/html>\");\n  \n        \n       \n        JPanel labelPanel = new JPanel();\n        labelPanel.setLayout(new BorderLayout());\n        labelPanel.add(jtf,BorderLayout.CENTER);\n          \n        aboutusPanel.setLayout(new BorderLayout());\n      \n       aboutusPanel.add(spLabel,BorderLayout.CENTER);\n        \n        \n         \n jtf.addMouseListener(new MouseAdapter(){\n    \n  \n        public void mouseClicked(MouseEvent evt) {\n           \n                try{\n                       VueUtil.openURL(\"http://vue.tccs.tufts.edu\");\n                }catch (Exception ex){}\n            \n        }\n });\n       \n        labelPanel.setBackground(Color.WHITE);\n       aboutusPanel.add(labelPanel,BorderLayout.SOUTH);\n        \n        backPanel.setLayout(new BorderLayout());\n        backPanel.add(aboutusPanel,BorderLayout.CENTER);\n \n      \n       \n            \n     \n        \n                 \n         \n        \n        aboutusTool.addTool(backPanel, false);\n        \n        userGuide.addActionListener(new ActionListener() {\n               public void actionPerformed(ActionEvent e) {\n                   try {\n                       VueUtil.openURL(\"http://vue.tccs.tufts.edu/userdoc/\");\n                   } catch (Exception ex) { out(ex); }\n               }});\n               \n        vueOnline.addActionListener(new ActionListener() {\n               public void actionPerformed(ActionEvent e) {\n                   try {\n                       VueUtil.openURL(\"http://vue.tccs.tufts.edu/\");\n                   } catch (Exception ex) { out(ex); }\n               }});\n        \n        aboutUs.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    //aboutusTool.setLocation(200,200);\n                    VueUtil.centerOnScreen(aboutusTool);\n                    aboutusTool.setVisible(true);\n                }});\n        \n          /*\n        JToolBar toolBar = new JToolBar();\n        toolBar.add(Actions.NewMap);\n        toolBar.add(openAction);\n        toolBar.add(Actions.CloseMap);\n        toolBar.add(saveAction);\n        toolBar.add(saveAsAction);\n        toolBar.add(printAction);\n        toolBar.add(imageAction);\n        toolBar.add(htmlAction);\n        toolBar.add(xmlAction);\n        toolBar.add(pdfAction);\n        toolBar.add(imageMap);\n        toolBar.add(svgAction);\n        // toolBar.add(new JButton(new ImageIcon(\"tufts/vue/images/ZoomOut16.gif\")));\n        toolBar.add(new JButton(new PolygonIcon(Color.RED)));\n        frame.getContentPane().add(toolBar,BorderLayout.NORTH);\n          */\n\n        return menuBar;\n\n    }","commit_id":"316226ab0032108d06f2164f9c8e2b4b006e84ce","url":"https://github.com/VUE/VUE"},{"original_method":"private static JBPopup getPsiElementPopup(final Object[] elements, final Map<PsiElement, GotoRelatedItem> itemsMap,\n                                           final String title, final Processor<Object> processor) {\n\n    final DefaultPsiElementCellRenderer renderer = new DefaultPsiElementCellRenderer() {\n          {\n            setFocusBorderEnabled(false);\n          }\n\n          @Override\n          public String getElementText(PsiElement element) {\n            String customName = itemsMap.get(element).getCustomName();\n            return customName != null ? customName : super.getElementText(element);\n          }\n\n          @Override\n          protected Icon getIcon(PsiElement element) {\n            Icon customIcon = itemsMap.get(element).getCustomIcon();\n            return customIcon != null ? customIcon : super.getIcon(element);\n          }\n\n          @Override\n          public String getContainerText(PsiElement element, String name) {\n            PsiFile file = element.getContainingFile();\n            return file != null && !getElementText(element).equals(file.getName())\n                   ? \"(\" + file.getName() + \")\"\n                   : null;\n          }\n\n          @Override\n          protected DefaultListCellRenderer getRightCellRenderer() {\n            return null;\n          }\n\n          @Override\n          protected boolean customizeNonPsiElementLeftRenderer(ColoredListCellRenderer renderer,\n                                                               JList list,\n                                                               Object value,\n                                                               int index,\n                                                               boolean selected,\n                                                               boolean hasFocus) {\n            final GotoRelatedItem item = (GotoRelatedItem)value;\n            Color color = list.getForeground();\n            final SimpleTextAttributes nameAttributes = new SimpleTextAttributes(Font.PLAIN, color);\n            final String name = item.getCustomName();\n            if (name == null) return false;\n            renderer.append(name, nameAttributes);\n            renderer.setIcon(item.getCustomIcon());\n            return true;\n          }\n        };\n    if (false) {\n      final ListPopupImpl popup = new ListPopupImpl(new BaseListPopupStep<Object>(title, Arrays.asList(elements)) {\n        @Override\n        public boolean isSpeedSearchEnabled() {\n          return true;\n        }\n      }) {\n        @Override\n        protected ListCellRenderer getListElementRenderer() {\n          return renderer;\n        }\n      };\n      popup.setMinimumSize(new Dimension(200, -1));\n      return popup;\n    }\n    final JList list = new JBList(elements);\n\n    list.setCellRenderer(renderer);\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        int[] ids = list.getSelectedIndices();\n        if (ids == null || ids.length == 0) return;\n        for (Object element : list.getSelectedValues()) {\n          if (element != null) {\n            processor.process(element);\n          }\n        }\n      }\n    };\n\n    PopupChooserBuilder builder = new PopupChooserBuilder(list);\n    if (title != null) {\n      builder.setTitle(title);\n    }\n    renderer.installSpeedSearch(builder, true);\n    builder.setMinSize(new Dimension(200, -1));\n    return builder.setItemChoosenCallback(runnable).createPopup();\n  }","id":43510,"modified_method":"private static JBPopup getPsiElementPopup(final Object[] elements, final Map<PsiElement, GotoRelatedItem> itemsMap,\n                                           final String title, final Processor<Object> processor) {\n\n    final Ref<Boolean> hasMnemonic = Ref.create(false);\n    final DefaultPsiElementCellRenderer renderer = new DefaultPsiElementCellRenderer() {\n      {\n        setFocusBorderEnabled(false);\n      }\n\n      @Override\n      public String getElementText(PsiElement element) {\n        String customName = itemsMap.get(element).getCustomName();\n        return (customName != null ? customName : super.getElementText(element));\n      }\n\n      @Override\n      protected Icon getIcon(PsiElement element) {\n        Icon customIcon = itemsMap.get(element).getCustomIcon();\n        return customIcon != null ? customIcon : super.getIcon(element);\n      }\n\n      @Override\n      public String getContainerText(PsiElement element, String name) {\n        PsiFile file = element.getContainingFile();\n        return file != null && !getElementText(element).equals(file.getName())\n               ? \"(\" + file.getName() + \")\"\n               : null;\n      }\n\n      @Override\n      protected DefaultListCellRenderer getRightCellRenderer() {\n        return null;\n      }\n\n      @Override\n      protected boolean customizeNonPsiElementLeftRenderer(ColoredListCellRenderer renderer,\n                                                           JList list,\n                                                           Object value,\n                                                           int index,\n                                                           boolean selected,\n                                                           boolean hasFocus) {\n        final GotoRelatedItem item = (GotoRelatedItem)value;\n        Color color = list.getForeground();\n        final SimpleTextAttributes nameAttributes = new SimpleTextAttributes(Font.PLAIN, color);\n        final String name = item.getCustomName();\n        if (name == null) return false;\n        renderer.append(name, nameAttributes);\n        renderer.setIcon(item.getCustomIcon());\n        return true;\n      }\n\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        final JPanel component = (JPanel)super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        if (!hasMnemonic.get()) return component;\n\n        final JPanel panelWithMnemonic = new JPanel(new BorderLayout());\n        final int mnemonic = getMnemonic(value, itemsMap);\n        final JLabel label = new JLabel(mnemonic != -1 ? mnemonic + \".\" : \"\");\n        label.setPreferredSize(new JLabel(\"8.\").getPreferredSize());\n        final JComponent leftRenderer = (JComponent)component.getComponents()[0];\n        component.remove(leftRenderer);\n        panelWithMnemonic.setBackground(leftRenderer.getBackground());\n        label.setBackground(leftRenderer.getBackground());\n        panelWithMnemonic.add(label, BorderLayout.WEST);\n        panelWithMnemonic.add(leftRenderer, BorderLayout.CENTER);\n        component.add(panelWithMnemonic);\n        return component;\n      }\n    };\n    final ListPopupImpl popup = new ListPopupImpl(new BaseListPopupStep<Object>(title, Arrays.asList(elements)) {\n      @Override\n      public boolean isSpeedSearchEnabled() {\n        return true;\n      }\n\n      @Override\n      public PopupStep onChosen(Object selectedValue, boolean finalChoice) {\n        processor.process(selectedValue);\n        return super.onChosen(selectedValue, finalChoice);\n      }\n    }) {\n      @Override\n      protected ListCellRenderer getListElementRenderer() {\n        return renderer;\n      }\n    };\n    popup.setMinimumSize(new Dimension(200, -1));\n    for (GotoRelatedItem item : itemsMap.values()) {\n      final int mnemonic = item.getMnemonic();\n      if (mnemonic != -1) {\n        final Action action = createNumberAction(mnemonic, popup, itemsMap, processor);\n        popup.registerAction(mnemonic + \"Action\", KeyStroke.getKeyStroke(String.valueOf(mnemonic)), action);\n        hasMnemonic.set(true);\n      }\n    }\n    return popup;\n  }","commit_id":"3165b17f419aae7aea4dfb2cfe1ab2a44676ff4a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GotoRelatedItem(@NotNull PsiElement element) {\n    myElement = element;\n  }","id":43511,"modified_method":"public GotoRelatedItem(@NotNull PsiElement element) {\n    this(element, -1);\n  }","commit_id":"3165b17f419aae7aea4dfb2cfe1ab2a44676ff4a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected GotoRelatedItem() {\n    myElement = null;\n  }","id":43512,"modified_method":"protected GotoRelatedItem() {\n    this(null, -1);\n  }","commit_id":"3165b17f419aae7aea4dfb2cfe1ab2a44676ff4a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Row(final LWComponent layer)\n        {\n            this.layer = layer;\n            label = new TextEdit(this);\n            setToolTipText(label.getText());\n            setName(layer.toString());\n            setLayout(new GridBagLayout());\n            setBorder(new CompoundBorder(new MatteBorder(1,0,1,0, Color.lightGray),\n                                         GUI.makeSpace(3,7,3,0)));\n            if (SCROLLABLE) {\n                if (layer instanceof Layer)\n                    setPreferredSize(LayerHeight);\n                else\n                    setPreferredSize(DefaultHeight);\n            }\n            //setMaximumSize(new Dimension(Short.MAX_VALUE, 64)); // no effect\n            //setMinimumSize(new Dimension(150, 100)); // no effect\n\n            addMouseListener(this);\n            addMouseMotionListener(this);\n            \n            if (layer instanceof Layer)\n                defaultBackground = Color.white;// Changed for Background\n            else\n                defaultBackground = Color.white; // debug/test case\n            setBackground(defaultBackground);\n            \n            if (true) {\n                // looks a bit messy w/current icons, but more informative\n                visible.setName(\"layer.visible\");\n                visible.setIcon(VueResources.getImageIcon(\"pathwayOff\"));\n                visible.setSelectedIcon(VueResources.getImageIcon(\"pathwayOn\"));\n                // need a bigger and/or colored icon -- to tough to see\n                locked.setName(\"layer.locked\");\n                locked.setIcon(VueResources.getImageIcon(\"lockOpen\"));\n                locked.setSelectedIcon(VueResources.getImageIcon(\"lock\"));\n                locked.setMargin(LockedInsets);\n                locked.setBorder(GUI.makeSpace(1,5,5,1)); // no effect\n            }\n            \n            locked.setSelected(layer.isLocked());\n            locked.setBorderPainted(layer.isLocked());\n            locked.setOpaque(false);\n            locked.addActionListener(new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                        //locked.setBorderPainted(locked.isSelected());                    \t\n                        layer.setLocked(locked.isSelected());\n                        if (layer == getActiveLayer() && !canBeActive(layer))\n                            if (AUTO_ADJUST_ACTIVE_LAYER) attemptAlternativeActiveLayer(false);\n                    }});\n            \n\n            visible.setSelected(layer.isVisible());\n            visible.addActionListener(new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                    \tlayer.setVisible(visible.isSelected());\n                        locked.setEnabled(layer.isVisible());                        \n                        label.setEnabled(layer.isVisible());        \n                        VUE.getMainWindow().repaint();\n                        if (layer == getActiveLayer() && !canBeActive(layer))\n                            if (AUTO_ADJUST_ACTIVE_LAYER) attemptAlternativeActiveLayer(false);                        \n                        \n                        \n                            \n                    }});\n\n            label.setEnabled(layer.isVisible());            \n            \n            if (layer instanceof Layer) {\n\n                exclusive = new JRadioButton();\n                exclusive.setName(\"exclusive\");\n                exclusive.setToolTipText(\"Quick-Edit\");\n                exclusive.setBorderPainted(false);\n                exclusive.setIcon(VueResources.getIcon(VUE.class, \"images/quickFocus_ov.png\"));\n                exclusive.setFocusable(false);\n                exclusive.setOpaque(false);\n                exclusive.addActionListener(new ActionListener() {\n                        public void actionPerformed(ActionEvent e) {\n                            exclusive.setBorderPainted(exclusive.isSelected());\n                            Row.this.setExclusive(exclusive.isSelected());\n                        }});\n            \n                //grab = new JButton(\"Grab\");\n                //grab.setFont(VueConstants.SmallFont);\n                grab = new JRadioButton();                \n                grab.setName(\"grab\");\n                grab.setToolTipText(\"Move selection to this layer\");\n                grab.setBorderPainted(false);\n                grab.setIcon(VueResources.getIcon(VUE.class, \"images/grab_ov.png\"));\n                grab.setFocusable(false); // FYI, no help on ignoring mouse-motion\n                grab.setOpaque(false);\n                \n\n//                     // todo: use icon-button version when ready to go -- may\n//                     // want to use a VueButton\n//                     grab = new JButton();\n//                     grab.setBorderPainted(false);\n//                     // todo: update when Melanie creates new icon for this\n//                     grab.setIcon(VueResources.getIcon(VUE.class, \"images/hand_open.png\"));\n//                     grab.putClientProperty(\"JButton.buttonType\", \"textured\");\n//                     grab.putClientProperty(\"JButton.sizeVariant\", \"tiny\");\n                \n                grab.addActionListener(new ActionListener() {\n                        public void actionPerformed(ActionEvent e) {\n                            if (VUE.getSelection().size() > 0) {\n                                grabFromSelection((Layer)layer);\n                                VUE.getUndoManager().mark(\"Move To Layer \" + Util.quote(layer.getLabel()));\n                            }\n                        }});\n            } else {\n                exclusive = null;\n                grab = null;\n            }\n\n            \n            final JLabel info = new JLabel()\n                //{ public Dimension getMinimumSize() { return GUI.ZeroSize; } }\n                ;\n            info.setMinimumSize(new Dimension(40,30));\n            if (layer.supportsChildren()) {\n                \n                // This might slow down undo of some large-set operations in large maps,\n                // such as grabs, as auto-reparenting will currently de-parent each\n                // child separately, issuing an event for each.  (All hierarchy events,\n                // however, are merged into a single one for undo/redo for each parent).\n                \n                // Note: depends on Layer having permitZombieEvent(e) return\n                // true, otherwise won't update correctly on undo.\n                final LWComponent.Listener countListener\n                    = new LWComponent.Listener() {\n                        public void LWCChanged(LWCEvent e) {\n                            //if (DEBUG.Enabled) Log.debug(\"UPDATING \" + Row.this + \" \" + e);\n                            String counts = \"\";\n                            final int nChild = layer.numChildren();\n                            final int allChildren = layer.getDescendentCount();\n                            info.setForeground(Color.gray);   \n                            if (nChild > 0)\n                                counts += nChild;\n                            if (allChildren != nChild)\n                                counts += \"/\" + allChildren;\n                            \n                            if(counts.length()==0){\n                            \tinfo.setText(\"\");\n                            }else{\n                            \tinfo.setText(\"(\"+counts+\")\");\n                            }\n                            //if (DEBUG.Enabled) { Row.this.validate(); GUI.paintNow(Row.this); } // slower\n                            // above will usually cause a deadlock tho when dropping images and this UI is visible\n                            //if (DEBUG.Enabled) { Row.this.validate(); GUI.paintNow(info); } // faster\n                        }};\n                countListener.LWCChanged(null); // do the initial set\n                layer.addLWCListener(countListener, LWKey.ChildrenAdded, LWKey.ChildrenRemoved);\n            }\n\n\n//             activeIcon.setIcon(VueResources.getIcon(VUE.class, \"images/hand_open.png\"));\n//             // todo perf: only actually need instance of each of these for all rows:\n//             activeIcon.setDisabledIcon(new GUI.EmptyIcon(activeIcon.getIcon())); \n//             activeIcon.setBorder(GUI.makeSpace(4,0,0,0));\n\n            \n            //final JComponent label = new VueTextField(layer.getLabel());\n            // VueTextField impl not useful to us (also not used anywhere)\n            // -- we need an impl that works just like VueTextPane, except\n            // as a single line of text.\n            \n            //final JLabel info = new JLabel(\"(\" + layer.numChildren() + \" items)\");\n            \n            final GridBagConstraints c = new GridBagConstraints();\n            c.weighty = 1; // 1 has all expanding to fill vertical, 0 leaves all at min height\n            c.anchor = GridBagConstraints.WEST;\n            \n//             c.insets.right = 4;\n//             add(exclusive, c);\n\n            //add(Box.createHorizontalStrut(5), c);\n            c.insets.right = 0;\n            add(visible, c);\n            \n            info.setHorizontalAlignment(SwingConstants.RIGHT);\n\n            if (true) {\n\n                // this magic, setting min-size to zero on the info text to 0, and wrapping\n                // it in a container with the label, allows it fill left, shriking the\n                // edit label if need-be, but never expanding the size of the two\n                // components togehter -- that way, all label-edit + info-text groups\n                // in all rows will always have the same width, keeping everything\n                // in alignment\n                \n                info.setMinimumSize(new Dimension(40,23));                \n                label.setCaretPosition(0);                \n                //info.addMouseListener(RowMouseEnterExitTracker);\n                Box box = new Box(BoxLayout.X_AXIS);\n                //JPanel box = new JPanel();\n                label.setPreferredSize(null); // must remove this, or info gets squished to 0 width\n                //label.addMouseListener(RowMouseEnterExitTracker);\n                box.add(label);\n                //box.add(Box.createHorizontalGlue());\n                box.add(info);\n                if (DEBUG.BOXES) box.setBorder(new LineBorder(Color.red));\n                box.setPreferredSize(GUI.MaxSize);\n                //box.setPreferredSize(new Dimension(200, 30));\n                //box.setMaximumSize(new Dimension(200, 30)); // apparently no use\n                \n                c.weightx = 1;\n                c.fill = GridBagConstraints.HORIZONTAL;\n                c.insets.right = 0;\n                add(box, c);\n                c.insets.left = 0;\n                //c.insets.right = 0;\n                c.weightx = 0;\n                c.fill = GridBagConstraints.NONE;\n                \n            } else {\n\n                c.weightx = 1;\n                c.fill = GridBagConstraints.HORIZONTAL;\n                add(label, c);\n                c.fill = GridBagConstraints.NONE;\n                c.weightx = 0;\n                add(info, c);\n\n//                 add(Box.createHorizontalStrut(1));\n//                 add(label);\n            \n//                 //add(Box.createHorizontalGlue());\n            \n//                 add(Box.createHorizontalStrut(1));\n//                 //info.setBorder(new LineBorder(Color.red));\n//                 //info.setPreferredSize(new Dimension(70,Short.MAX_VALUE));\n//                 //info.setMinimumSize(new Dimension(60,0));\n//                 add(info);\n            }\n            \n            //add(Box.createHorizontalGlue(), c);\n\n            if (layer.hasFlag(INTERNAL)) {            \t\n                add(locked, c);\n                preview = null;\n                return;\n            }\n            \n            preview = new Preview(layer);\n            //preview.setMinimumSize(new Dimension(128, 64));\n            \n            //preview.setPreferredSize(GUI.MaxSize);\n            //preview.setSize(256,128);\n            //preview.setPreferredSize(new Dimension(256, Short.MAX_VALUE));\n            //preview.setMaximumSize(GUI.MaxSize);\n\n            if (false && DEBUG.Enabled)\n                layer.addLWCListener(new LWComponent.Listener() {\n                        public void LWCChanged(LWCEvent e) {\n                            // this is heavy duty!  Would be nice if UserActionCompleted\n                            // came through the layer, and we could listen for that,\n                            // but it comes through the map\n                            preview.repaint();\n                        }});\n            \n            \n\n            //add(Box.createHorizontalGlue());\n            \n            if (preview != null) {\n                c.weightx = 1;\n                c.fill = GridBagConstraints.BOTH;\n                //c.fill = GridBagConstraints.VERTICAL;\n                //add(Box.createHorizontalStrut(7));\n                add(preview, c);\n                c.weightx = 0;\n                c.fill = GridBagConstraints.NONE;\n                \n            }\n\n            if (true) {\n                JPanel fixed = new JPanel(new BorderLayout());\n                fixed.setOpaque(true);                \n                fixed.setBorder(GUI.makeSpace(3,1,3,1));\n                fixed.setMinimumSize(new Dimension(53, 0));\n                \n                //fixed.add(exclusive, BorderLayout.WEST);\n                grab.setMinimumSize(new Dimension(25, 0));\n                locked.setMinimumSize(new Dimension(25, 0));                            \n                fixed.add(grab, BorderLayout.CENTER);\n                fixed.add(locked, BorderLayout.EAST);                \n                c.fill = GridBagConstraints.BOTH;\n                add(fixed, c);\n            } else {            \t\n                // old-style before we added hiding these on mouse roll-off\n                //add(activeIcon, c);\n                add(grab, c);\n                add(locked, c);\n            }\n            //setBorder(BorderFactory.createLineBorder(Color.red, 1));\n            // set initial visibility states by simulating a mouse roll-off\n            rollOff(); \n\n        }","id":43513,"modified_method":"Row(final LWComponent layer)\n        {\n            this.layer = layer;\n            label = new TextEdit(this);\n            setToolTipText(label.getText());\n            setName(layer.toString());\n            setLayout(new GridBagLayout());\n            setBorder(new CompoundBorder(new MatteBorder(1,0,1,0, Color.lightGray),\n                                         GUI.makeSpace(3,7,3,0)));\n            if (SCROLLABLE) {\n                if (layer instanceof Layer)\n                    setPreferredSize(LayerHeight);\n                else\n                    setPreferredSize(DefaultHeight);\n            }\n            //setMaximumSize(new Dimension(Short.MAX_VALUE, 64)); // no effect\n            //setMinimumSize(new Dimension(150, 100)); // no effect\n\n            addMouseListener(this);\n            addMouseMotionListener(this);\n            \n            if (layer instanceof Layer)\n                defaultBackground = Color.white;// Changed for Background\n            else\n                defaultBackground = Color.white; // debug/test case\n            setBackground(defaultBackground);\n            \n            if (true) {\n                // looks a bit messy w/current icons, but more informative\n                visible.setName(\"layer.visible\");\n                visible.setIcon(VueResources.getImageIcon(\"pathwayOff\"));\n                visible.setSelectedIcon(VueResources.getImageIcon(\"pathwayOn\"));\n                // need a bigger and/or colored icon -- to tough to see\n                locked.setName(\"layer.locked\");\n                locked.setIcon(VueResources.getImageIcon(\"lockOpen\"));\n                locked.setSelectedIcon(VueResources.getImageIcon(\"lock\"));\n                locked.setMargin(LockedInsets);\n                locked.setBorder(GUI.makeSpace(1,5,5,1)); // no effect\n            }\n            \n            locked.setSelected(layer.isLocked());\n            locked.setBorderPainted(layer.isLocked());\n            locked.setOpaque(false);\n            locked.addActionListener(new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                        //locked.setBorderPainted(locked.isSelected());                    \t\n                        layer.setLocked(locked.isSelected());\n                        if (layer == getActiveLayer() && !canBeActive(layer))\n                            if (AUTO_ADJUST_ACTIVE_LAYER) attemptAlternativeActiveLayer(false);\n                    }});\n            \n\n            visible.setSelected(layer.isVisible());\n            visible.addActionListener(new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                    \tlayer.setVisible(visible.isSelected());\n                        locked.setEnabled(layer.isVisible());                        \n                        label.setEnabled(layer.isVisible());        \n                        VUE.getMainWindow().repaint();\n                        if (layer == getActiveLayer() && !canBeActive(layer))\n                            if (AUTO_ADJUST_ACTIVE_LAYER) attemptAlternativeActiveLayer(false);                        \n                        \n                        \n                            \n                    }});\n\n            label.setEnabled(layer.isVisible());            \n            \n            if (layer instanceof Layer) {\n\n                exclusive = new JRadioButton();\n                exclusive.setName(\"exclusive\");\n                exclusive.setToolTipText(\"Quick-Edit\");\n                exclusive.setBorderPainted(false);\n                exclusive.setIcon(VueResources.getIcon(VUE.class, \"images/quickFocus_ov.png\"));\n                exclusive.setFocusable(false);\n                exclusive.setOpaque(false);\n                exclusive.addActionListener(new ActionListener() {\n                        public void actionPerformed(ActionEvent e) {\n                            exclusive.setBorderPainted(exclusive.isSelected());\n                            Row.this.setExclusive(exclusive.isSelected());\n                        }});\n            \n                //grab = new JButton(\"Grab\");\n                //grab.setFont(VueConstants.SmallFont);\n                grab = new JRadioButton();                \n                grab.setName(\"grab\");\n                grab.setToolTipText(\"Move selection to this layer\");\n                grab.setBorderPainted(false);\n                grab.setIcon(VueResources.getIcon(VUE.class, \"images/grab_ov.png\"));\n                grab.setFocusable(false); // FYI, no help on ignoring mouse-motion\n                grab.setOpaque(false);\n                \n\n//                     // todo: use icon-button version when ready to go -- may\n//                     // want to use a VueButton\n//                     grab = new JButton();\n//                     grab.setBorderPainted(false);\n//                     // todo: update when Melanie creates new icon for this\n//                     grab.setIcon(VueResources.getIcon(VUE.class, \"images/hand_open.png\"));\n//                     grab.putClientProperty(\"JButton.buttonType\", \"textured\");\n//                     grab.putClientProperty(\"JButton.sizeVariant\", \"tiny\");\n                \n                grab.addActionListener(new ActionListener() {\n                        public void actionPerformed(ActionEvent e) {\n                            if (VUE.getSelection().size() > 0) {\n                                grabFromSelection((Layer)layer);\n                                VUE.getUndoManager().mark(\"Move To Layer \" + Util.quote(layer.getLabel()));\n                            }\n                        }});\n            } else {\n                exclusive = null;\n                grab = null;\n            }\n\n            \n            final JLabel info = new JLabel()\n                //{ public Dimension getMinimumSize() { return GUI.ZeroSize; } }\n                ;\n            info.setMinimumSize(new Dimension(40,30));\n            if (layer.supportsChildren()) {\n                \n                // This might slow down undo of some large-set operations in large maps,\n                // such as grabs, as auto-reparenting will currently de-parent each\n                // child separately, issuing an event for each.  (All hierarchy events,\n                // however, are merged into a single one for undo/redo for each parent).\n                \n                // Note: depends on Layer having permitZombieEvent(e) return\n                // true, otherwise won't update correctly on undo.\n                final LWComponent.Listener countListener\n                    = new LWComponent.Listener() {\n                        public void LWCChanged(LWCEvent e) {\n                            //if (DEBUG.Enabled) Log.debug(\"UPDATING \" + Row.this + \" \" + e);\n                            String counts = \"\";\n                            final int nChild = layer.numChildren();\n                            final int allChildren = layer.getDescendentCount();\n                            info.setForeground(Color.gray);   \n                            if (nChild > 0)\n                                counts += nChild;\n                            if (allChildren != nChild)\n                                counts += \"/\" + allChildren;\n                            \n                            if(counts.length()==0){\n                            \tinfo.setText(\"\");\n                            }else{\n                            \tinfo.setText(\"(\"+counts+\")\");\n                            }                            \n                            //if (DEBUG.Enabled) { Row.this.validate(); GUI.paintNow(Row.this); } // slower\n                            // above will usually cause a deadlock tho when dropping images and this UI is visible\n                            //if (DEBUG.Enabled) { Row.this.validate(); GUI.paintNow(info); } // faster\n                        }};\n                countListener.LWCChanged(null); // do the initial set\n                layer.addLWCListener(countListener, LWKey.ChildrenAdded, LWKey.ChildrenRemoved);\n            }\n\n\n//             activeIcon.setIcon(VueResources.getIcon(VUE.class, \"images/hand_open.png\"));\n//             // todo perf: only actually need instance of each of these for all rows:\n//             activeIcon.setDisabledIcon(new GUI.EmptyIcon(activeIcon.getIcon())); \n//             activeIcon.setBorder(GUI.makeSpace(4,0,0,0));\n\n            \n            //final JComponent label = new VueTextField(layer.getLabel());\n            // VueTextField impl not useful to us (also not used anywhere)\n            // -- we need an impl that works just like VueTextPane, except\n            // as a single line of text.\n            \n            //final JLabel info = new JLabel(\"(\" + layer.numChildren() + \" items)\");\n            \n            final GridBagConstraints c = new GridBagConstraints();\n            c.weighty = 1; // 1 has all expanding to fill vertical, 0 leaves all at min height\n            c.anchor = GridBagConstraints.WEST;\n            \n//             c.insets.right = 4;\n//             add(exclusive, c);\n\n            //add(Box.createHorizontalStrut(5), c);\n            c.insets.right = 0;\n            add(visible, c);\n            \n            info.setHorizontalAlignment(SwingConstants.RIGHT);\n\n            if (true) {\n\n                // this magic, setting min-size to zero on the info text to 0, and wrapping\n                // it in a container with the label, allows it fill left, shriking the\n                // edit label if need-be, but never expanding the size of the two\n                // components togehter -- that way, all label-edit + info-text groups\n                // in all rows will always have the same width, keeping everything\n                // in alignment\n                \n                info.setMinimumSize(new Dimension(40,23));    \n                label.setMaximumSize(new Dimension(88,23)); \n                label.setCaretPosition(0);                \n                //info.addMouseListener(RowMouseEnterExitTracker);\n                Box box = new Box(BoxLayout.X_AXIS);\n                //JPanel box = new JPanel();\n                label.setPreferredSize(null); // must remove this, or info gets squished to 0 width\n                //label.addMouseListener(RowMouseEnterExitTracker);\n                box.add(label);\n                //box.add(Box.createHorizontalGlue());\n                box.add(info);\n                if (DEBUG.BOXES) box.setBorder(new LineBorder(Color.red));\n                box.setPreferredSize(GUI.MaxSize);\n                //box.setPreferredSize(new Dimension(200, 30));\n                //box.setMaximumSize(new Dimension(200, 30)); // apparently no use\n                \n                c.weightx = 1;\n                c.fill = GridBagConstraints.HORIZONTAL;\n                c.insets.right = 0;\n                add(box, c);\n                c.insets.left = 0;\n                //c.insets.right = 0;\n                c.weightx = 0;\n                c.fill = GridBagConstraints.NONE;\n                \n            } else {\n\n                c.weightx = 1;\n                c.fill = GridBagConstraints.HORIZONTAL;\n                add(label, c);\n                c.fill = GridBagConstraints.NONE;\n                c.weightx = 0;\n                add(info, c);\n\n//                 add(Box.createHorizontalStrut(1));\n//                 add(label);\n            \n//                 //add(Box.createHorizontalGlue());\n            \n//                 add(Box.createHorizontalStrut(1));\n//                 //info.setBorder(new LineBorder(Color.red));\n//                 //info.setPreferredSize(new Dimension(70,Short.MAX_VALUE));\n//                 //info.setMinimumSize(new Dimension(60,0));\n//                 add(info);\n            }\n            \n            //add(Box.createHorizontalGlue(), c);\n            info.setMinimumSize(new Dimension(40,23));    \n            label.setMinimumSize(new Dimension(88,23));             \n            if (layer.hasFlag(INTERNAL)) {            \t\n                add(locked, c);\n                preview = null;\n                return;\n            }\n            \n            preview = new Preview(layer);\n            //preview.setMinimumSize(new Dimension(128, 64));\n            \n            //preview.setPreferredSize(GUI.MaxSize);\n            //preview.setSize(256,128);\n            //preview.setPreferredSize(new Dimension(256, Short.MAX_VALUE));\n            //preview.setMaximumSize(GUI.MaxSize);\n\n            if (false && DEBUG.Enabled)\n                layer.addLWCListener(new LWComponent.Listener() {\n                        public void LWCChanged(LWCEvent e) {\n                            // this is heavy duty!  Would be nice if UserActionCompleted\n                            // came through the layer, and we could listen for that,\n                            // but it comes through the map\n                            preview.repaint();\n                        }});\n            \n            \n\n            //add(Box.createHorizontalGlue());\n            \n            if (preview != null) {\n                c.weightx = 1;\n                c.fill = GridBagConstraints.BOTH;\n                //c.fill = GridBagConstraints.VERTICAL;\n                //add(Box.createHorizontalStrut(7));\n                add(preview, c);\n                c.weightx = 0;\n                c.fill = GridBagConstraints.NONE;\n                \n            }\n\n            if (true) {\n                JPanel fixed = new JPanel(new BorderLayout());\n                fixed.setOpaque(true);                \n                fixed.setBorder(GUI.makeSpace(3,1,3,1));\n                fixed.setMinimumSize(new Dimension(53, 0));                \n                //fixed.add(exclusive, BorderLayout.WEST);                \n                locked.setMinimumSize(new Dimension(25, 0)); \n                if(grab!=null){                \t\n                \tgrab.setMinimumSize(new Dimension(25, 0));\n                \tfixed.add(grab, BorderLayout.CENTER);\n                }\n                fixed.add(locked, BorderLayout.EAST);                \n                c.fill = GridBagConstraints.BOTH;\n                add(fixed, c);\n            } else {            \t\n                // old-style before we added hiding these on mouse roll-off\n                //add(activeIcon, c);            \t\n                add(grab, c);\n                add(locked, c);\n            }            \n            // set initial visibility states by simulating a mouse roll-off\n            rollOff(); \n\n        }","commit_id":"35bf5009e19d839f900b3fd346ed993b7613dceb","url":"https://github.com/VUE/VUE"},{"original_method":"public void mouseClicked(MouseEvent e) {        \t\n            if (GUI.isDoubleClick(e)) {\n            \tif(e.isShiftDown()){  \n            \t\tif (VUE.getSelection() !=null)\n            \t\t\tVUE.getSelection().add(layer.getChildren());\n            \t\telse\n            \t\t\tVUE.getSelection().setTo(new LWSelection(layer.getChildren()));             \t\t\n            \t\t          \t\t\n            \t\tsetActiveLayer((Layer) layer, !UPDATE);\n            \t\t\n            \t}else{\n            \t\tVUE.getSelection().setTo(layer.getAllDescendents());\n            \t}            \t\n            }\n            if(((JButton)mToolbar.getComponent(3)).isBorderPainted()){\n        \t\tVUE.getSelection().setTo(layer.getAllDescendents());\n        \t}\n            Layer active = getActiveLayer();            \n        \tMouseListener popupListener = new PopupListener(active.isLocked());\n        \taddMouseListener(popupListener);\n        \t\n            \n        }","id":43514,"modified_method":"public void mouseClicked(MouseEvent e) {        \t\n            if (GUI.isDoubleClick(e)) {\n            \tif(e.isShiftDown()){  \n            \t\tif (VUE.getSelection() !=null)\n            \t\t\tVUE.getSelection().add(layer.getChildren());\n            \t\telse\n            \t\t\tVUE.getSelection().setTo(new LWSelection(layer.getChildren()));             \t\t\n            \t\t          \t\t\n            \t\tsetActiveLayer((Layer) layer, !UPDATE);\n            \t\t\n            \t}else{\n            \t\tVUE.getSelection().setTo(layer.getAllDescendents());\n            \t}            \t\n            }\n            Layer active = null;\n            if(((JButton)mToolbar.getComponent(3)).isBorderPainted()){\n            \tactive = getActiveLayer();  \n            \tRow row =null;\n           \t \tfor (Row rows : mRows){\n           \t \t\trow = rows;\n                     if (rows.layer.equals(active)){                    \t \n                    \t row.layer.setVisible(true);\n                    \t VUE.getSelection().setTo(row.layer.getAllDescendents());\n                     }else{                    \t \n                    \t row.layer.setVisible(false);\n                     }\n                 }        \t\t\n        \t\t\n        \t}   \n            if(active != null){\n            \tMouseListener popupListener = new PopupListener(active.isLocked());\n            \taddMouseListener(popupListener);\n            }\n        \t\n            \n        }","commit_id":"35bf5009e19d839f900b3fd346ed993b7613dceb","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n  public String generateDoc(PsiElement element, PsiElement originalElement) {\n    final String[] result = new String[] {null};\n\n    if (element instanceof PsiFileSystemItem && !((PsiFileSystemItem)element).isDirectory()) {\n      final VirtualFile file = ((PsiFileSystemItem)element).getVirtualFile();\n      ImageInfoIndex.processValues(file, new FileBasedIndex.ValueProcessor<ImageInfoIndex.ImageInfo>() {\n        public boolean process(VirtualFile file, ImageInfoIndex.ImageInfo value) {\n          int imageWidth = value.width;\n          int imageHeight = value.height;\n\n          int maxSize = Math.max(value.width, value.height);\n          if (maxSize > MAX_IMAGE_SIZE) {\n            double scaleFactor = (double)MAX_IMAGE_SIZE / (double)maxSize;\n            imageWidth *= scaleFactor;\n            imageHeight *= scaleFactor;\n          }\n          try {\n            final String url = new URI(\"file\", null, file.getPath(), null).toString();\n            result[0] = String.format(\"<html><body><img src=\\\"%s\\\" width=\\\"%s\\\" height=\\\"%s\\\"><p>%sx%s, %sbpp<\/p><body><\/html>\", url, imageWidth,\n                                 imageHeight, value.width, value.height, value.bpp);\n          }\n          catch (URISyntaxException e) {\n            // nothing\n          }\n          return true;\n        }\n      });\n    }\n\n    return result[0];\n  }","id":43515,"modified_method":"@Override\n  public String generateDoc(PsiElement element, PsiElement originalElement) {\n    final String[] result = new String[] {null};\n\n    if (element instanceof PsiFileSystemItem && !((PsiFileSystemItem)element).isDirectory()) {\n      final VirtualFile file = ((PsiFileSystemItem)element).getVirtualFile();\n      if (file instanceof VirtualFileWithId) {\n        ImageInfoIndex.processValues(file, new FileBasedIndex.ValueProcessor<ImageInfoIndex.ImageInfo>() {\n          public boolean process(VirtualFile file, ImageInfoIndex.ImageInfo value) {\n            int imageWidth = value.width;\n            int imageHeight = value.height;\n\n            int maxSize = Math.max(value.width, value.height);\n            if (maxSize > MAX_IMAGE_SIZE) {\n              double scaleFactor = (double)MAX_IMAGE_SIZE / (double)maxSize;\n              imageWidth *= scaleFactor;\n              imageHeight *= scaleFactor;\n            }\n            try {\n              final String url = new URI(\"file\", null, file.getPath(), null).toString();\n              result[0] = String.format(\"<html><body><img src=\\\"%s\\\" width=\\\"%s\\\" height=\\\"%s\\\"><p>%sx%s, %sbpp<\/p><body><\/html>\", url, imageWidth,\n                                   imageHeight, value.width, value.height, value.bpp);\n            }\n            catch (URISyntaxException e) {\n              // nothing\n            }\n            return true;\n          }\n        });\n      }\n    }\n\n    return result[0];\n  }","commit_id":"0942ef60f47f951f511850cc8a68fa8790ab41bb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AngularAttributeDescriptor(Project project, String attributeName, VirtualFile file, int offset) {\n    super(attributeName);\n    myProject = project;\n    myFile = file;\n    myOffset = offset;\n  }","id":43516,"modified_method":"public AngularAttributeDescriptor(final Project project, String attributeName) {\n    super(attributeName);\n    myProject = project;\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public PsiElement getDeclaration() {\n    if (myProject != null && myFile != null) {\n      PsiFile psiFile = PsiManager.getInstance(myProject).findFile(myFile);\n      return psiFile != null ? psiFile.findElementAt(myOffset) : null;\n    }\n    return super.getDeclaration();\n  }","id":43517,"modified_method":"@Override\n  public PsiElement getDeclaration() {\n    return AngularIndexUtil.resolve(myProject, AngularDirectivesIndex.INDEX_ID, getName());\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"static AngularAttributeDescriptor createDescriptor(@Nullable final Project project,\n                                                     @NotNull String directiveName,\n                                                     @Nullable VirtualFile file,\n                                                     final int offset) {\n    if (\"ng-controller\".equals(directiveName)) {\n      return new ControllerAttributeDescriptor(project, file, offset);\n    }\n    return new AngularAttributeDescriptor(project, directiveName, file, offset);\n  }","id":43518,"modified_method":"static AngularAttributeDescriptor createDescriptor(@Nullable final Project project,\n                                                     @NotNull String directiveName) {\n    if (\"ng-controller\".equals(directiveName)) {\n      return new ControllerAttributeDescriptor(project);\n    }\n    return new AngularAttributeDescriptor(project, directiveName);\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static Entry resolve(final Project project, final String indexKey, final String lookupKey) {\n    final Ref<Entry> result = Ref.create();\n    FileBasedIndex.getInstance().processValues(AngularJSIndex.INDEX_ID, indexKey, null,\n                                               new FileBasedIndex.ValueProcessor<TObjectIntHashMap<String>>() {\n                                                 @Override\n                                                 public boolean process(VirtualFile file, TObjectIntHashMap<String> descriptorNames) {\n                                                   for (Object o : descriptorNames.keys()) {\n                                                     if (lookupKey.equals(o)) {\n                                                       result.set(new Entry(file, lookupKey, descriptorNames.get(lookupKey)));\n                                                     }\n                                                   }\n                                                   return result.isNull();\n                                                 }\n                                               }, GlobalSearchScope.allScope(project)\n    );\n    return result.get();\n  }","id":43519,"modified_method":"public static JSNamedElementProxy resolve(final Project project, final ID<String, Void> index, final String lookupKey) {\n    final Ref<JSNamedElementProxy> result = Ref.create();\n    final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n    for (VirtualFile file : FileBasedIndex.getInstance().getContainingFiles(index, lookupKey, scope)) {\n      final int id = FileBasedIndex.getFileId(file);\n      FileBasedIndex.getInstance().processValues(JSEntryIndex.INDEX_ID, id, null, new FileBasedIndex.ValueProcessor<JSIndexEntry>() {\n        @Override\n        public boolean process(VirtualFile file, JSIndexEntry value) {\n          return value.processAdditionalData(JavaScriptIndex.getInstance(project), index.toString(), lookupKey, new Processor<JSNamedElementProxy>() {\n            @Override\n            public boolean process(JSNamedElementProxy proxy) {\n              if (lookupKey.equals(proxy.getName())) {\n                result.set(proxy);\n              }\n              return result.isNull();\n            }\n          });\n        }\n      }, scope);\n      if (!result.isNull()) break;\n    }\n    return result.get();\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public XmlAttributeDescriptor[] getAttributeDescriptors(XmlTag xmlTag) {\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      final Map<String, XmlAttributeDescriptor> result = new LinkedHashMap<String, XmlAttributeDescriptor>();\n      for (AngularIndexUtil.Entry entry : AngularIndexUtil.collect(project, AngularJSIndexingHandler.DIRECTIVE_KEY)) {\n        result.put(entry.name, createDescriptor(project, entry.name, entry.file, entry.offset));\n      }\n      // marker entry: if ng-model is present then angular.js file was indexed and there's no need to add all\n      // predefined entries\n      if (!result.containsKey(\"ng-model\")) {\n        for (String name : DIRECTIVE_NAMES) {\n          result.put(name, createDescriptor(project, name, null, -1));\n        }\n      }\n      return result.values().toArray(new XmlAttributeDescriptor[result.size()]);\n    }\n    return DESCRIPTORS;\n  }","id":43520,"modified_method":"@Override\n  public XmlAttributeDescriptor[] getAttributeDescriptors(XmlTag xmlTag) {\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      final Map<String, XmlAttributeDescriptor> result = new LinkedHashMap<String, XmlAttributeDescriptor>();\n      for (String directiveName : FileBasedIndex.getInstance().getAllKeys(AngularDirectivesIndex.INDEX_ID, project)) {\n        result.put(directiveName, createDescriptor(project, directiveName));\n      }\n      // marker entry: if ng-model is present then angular.js file was indexed and there's no need to add all\n      // predefined entries\n      if (!result.containsKey(\"ng-model\")) {\n        for (String name : DIRECTIVE_NAMES) {\n          result.put(name, createDescriptor(project, name));\n        }\n      }\n      return result.values().toArray(new XmlAttributeDescriptor[result.size()]);\n    }\n    return DESCRIPTORS;\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public XmlAttributeDescriptor getAttributeDescriptor(final String attrName, XmlTag xmlTag) {\n    final String attributeName = normalizeAttributeName(attrName);\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      final AngularIndexUtil.Entry resolve = AngularIndexUtil.resolve(project, AngularJSIndexingHandler.DIRECTIVE_KEY, attributeName);\n      if (resolve != null) {\n        return createDescriptor(project, attributeName, resolve.file, resolve.offset);\n      }\n      // fallback for predefined entries\n      if (ATTRIBUTE_BY_NAME.containsKey(attributeName)) {\n        return createDescriptor(project, attributeName, null, -1);\n      }\n    }\n    return ATTRIBUTE_BY_NAME.get(attributeName);\n  }","id":43521,"modified_method":"@Nullable\n  @Override\n  public XmlAttributeDescriptor getAttributeDescriptor(final String attrName, XmlTag xmlTag) {\n    final String attributeName = normalizeAttributeName(attrName);\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      if (FileBasedIndex.getInstance().getAllKeys(AngularDirectivesIndex.INDEX_ID, project).contains(attributeName) ||\n          // fallback for predefined entries\n          ATTRIBUTE_BY_NAME.containsKey(attributeName)) {\n        return createDescriptor(project, attributeName);\n      }\n    }\n    return ATTRIBUTE_BY_NAME.get(attributeName);\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void processCommentMatch(@NotNull final PsiComment comment,\n                                  @NotNull JSDocumentationProcessor.MetaDocType type,\n                                  @Nullable String matchName,\n                                  @Nullable String matchValue,\n                                  @Nullable String remainingLineContent,\n                                  @NotNull String line,\n                                  String patternMatched,\n                                  JSSymbolVisitor visitor) {\n    if (type == JSDocumentationProcessor.MetaDocType.NAME &&\n        matchName != null && matchName.contains(DIRECTIVE) && hasDirectiveName(remainingLineContent)) {\n      assert remainingLineContent != null;\n      visitor.storeAdditionalData(DIRECTIVE_KEY, getAttributeName(remainingLineContent.substring(1)),\n                                  comment.getTextOffset() + comment.getText().indexOf(matchName));\n    }\n  }","id":43522,"modified_method":"@Override\n  public void processCommentMatch(@NotNull final PsiComment comment,\n                                  @NotNull JSDocumentationProcessor.MetaDocType type,\n                                  @Nullable String matchName,\n                                  @Nullable String matchValue,\n                                  @Nullable String remainingLineContent,\n                                  @NotNull String line,\n                                  String patternMatched,\n                                  JSSymbolVisitor visitor) {\n    if (type == JSDocumentationProcessor.MetaDocType.NAME &&\n        matchName != null && matchName.contains(DIRECTIVE) && hasDirectiveName(remainingLineContent)) {\n      assert remainingLineContent != null;\n      visitor.storeAdditionalData(AngularDirectivesIndex.INDEX_ID.toString(), getAttributeName(remainingLineContent.substring(1)),\n                                  comment.getTextOffset() + comment.getText().indexOf(matchName));\n    }\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void processCallExpression(JSCallExpression callExpression, JSSymbolVisitor visitor) {\n    JSReferenceExpression callee = (JSReferenceExpression)callExpression.getMethodExpression();\n    JSExpression qualifier = callee.getQualifier();\n\n    if (qualifier == null) return;\n\n    if (DIRECTIVE.equals(callee.getReferencedName())) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(DIRECTIVE_KEY, getAttributeName(argument.getText()), argument.getTextOffset());\n        }\n      }\n    } else if (\"controller\".equals(callee.getReferencedName())) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(CONTROLLER_KEY, StringUtil.unquoteString(argument.getText()), argument.getTextOffset());\n        }\n      }\n    }\n  }","id":43523,"modified_method":"@Override\n  public void processCallExpression(JSCallExpression callExpression, JSSymbolVisitor visitor) {\n    JSReferenceExpression callee = (JSReferenceExpression)callExpression.getMethodExpression();\n    JSExpression qualifier = callee.getQualifier();\n\n    if (qualifier == null) return;\n\n    if (DIRECTIVE.equals(callee.getReferencedName())) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(AngularDirectivesIndex.INDEX_ID.toString(),\n                                      getAttributeName(argument.getText()), argument.getTextOffset());\n        }\n      }\n    } else if (\"controller\".equals(callee.getReferencedName())) {\n      JSExpression[] arguments = callExpression.getArguments();\n      if (arguments.length > 0) {\n        JSExpression argument = arguments[0];\n        if (argument instanceof JSLiteralExpression && ((JSLiteralExpression)argument).isQuotedLiteral()) {\n          visitor.storeAdditionalData(AngularControllerIndex.INDEX_ID.toString(),\n                                      StringUtil.unquoteString(argument.getText()), argument.getTextOffset());\n        }\n      }\n    }\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testControllerResolve() {\n    myFixture.configureByFiles(\"controller.after.html\", \"custom.js\");\n    int offsetBySignature = AngularTestUtil.findOffsetBySignature(\"Supa<caret>Controller\", myFixture.getFile());\n    PsiReference ref = myFixture.getFile().findReferenceAt(offsetBySignature);\n    assertNotNull(ref);\n    PsiElement resolve = ref.resolve();\n    assertNotNull(resolve);\n    assertEquals(\"custom.js\", resolve.getContainingFile().getName());\n    assertEquals(\"'SupaController'\", resolve.getText());\n  }","id":43524,"modified_method":"public void testControllerResolve() {\n    myFixture.configureByFiles(\"controller.after.html\", \"custom.js\");\n    int offsetBySignature = AngularTestUtil.findOffsetBySignature(\"Supa<caret>Controller\", myFixture.getFile());\n    PsiReference ref = myFixture.getFile().findReferenceAt(offsetBySignature);\n    assertNotNull(ref);\n    PsiElement resolve = ref.resolve();\n    assertNotNull(resolve);\n    assertEquals(\"custom.js\", resolve.getContainingFile().getName());\n    assertEquals(\"'SupaController'\", ((JSNamedElementProxy)resolve).getElement().getText());\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testCustomAttributesResolve() {\n    myFixture.configureByFiles(\"custom.after.html\", \"custom.js\");\n    int offsetBySignature = AngularTestUtil.findOffsetBySignature(\"my-cus<caret>tomer\", myFixture.getFile());\n    PsiReference ref = myFixture.getFile().findReferenceAt(offsetBySignature);\n    assertNotNull(ref);\n    PsiElement resolve = ref.resolve();\n    assertNotNull(resolve);\n    assertEquals(\"custom.js\", resolve.getContainingFile().getName());\n    assertEquals(\"'myCustomer'\", resolve.getText());\n  }","id":43525,"modified_method":"public void testCustomAttributesResolve() {\n    myFixture.configureByFiles(\"custom.after.html\", \"custom.js\");\n    int offsetBySignature = AngularTestUtil.findOffsetBySignature(\"my-cus<caret>tomer\", myFixture.getFile());\n    PsiReference ref = myFixture.getFile().findReferenceAt(offsetBySignature);\n    assertNotNull(ref);\n    PsiElement resolve = ref.resolve();\n    assertNotNull(resolve);\n    assertEquals(\"custom.js\", resolve.getContainingFile().getName());\n    assertEquals(\"'myCustomer'\", ((JSNamedElementProxy)resolve).getElement().getText());\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public ControllerAttributeDescriptor(Project project, VirtualFile file, int offset) {\n    super(project, \"ng-controller\", file, offset);\n  }","id":43526,"modified_method":"public ControllerAttributeDescriptor(final Project project) {\n    super(project, \"ng-controller\");\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public String[] getEnumeratedValues() {\n    if (myProject == null) return ArrayUtil.EMPTY_STRING_ARRAY;\n\n    final Set<String> result = new HashSet<String>();\n    for (AngularIndexUtil.Entry entry : AngularIndexUtil.collect(myProject, AngularJSIndexingHandler.CONTROLLER_KEY)) {\n      result.add(entry.name);\n    }\n    return ArrayUtil.toStringArray(result);\n  }","id":43527,"modified_method":"@Override\n  public String[] getEnumeratedValues() {\n    if (myProject == null) return ArrayUtil.EMPTY_STRING_ARRAY;\n    return ArrayUtil.toStringArray(FileBasedIndex.getInstance().getAllKeys(AngularControllerIndex.INDEX_ID, myProject));\n  }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n    @Override\n    public PsiElement resolve() {\n      final XmlAttributeValue element = getElement();\n      final String key = element.getValue();\n      final AngularIndexUtil.Entry entry = AngularIndexUtil.resolve(element.getProject(), AngularJSIndexingHandler.CONTROLLER_KEY, key);\n      if (entry == null) return null;\n\n      PsiFile psiFile = element.getManager().findFile(entry.file);\n      return psiFile != null ? psiFile.findElementAt(entry.offset) : null;\n    }","id":43528,"modified_method":"@Nullable\n    @Override\n    public PsiElement resolve() {\n      final XmlAttributeValue element = getElement();\n      final String key = element.getValue();\n      return AngularIndexUtil.resolve(element.getProject(), AngularControllerIndex.INDEX_ID, key);\n    }","commit_id":"33ac3d0e90efa1836f59749b6fc52399d9c4ccb4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean processPropertiesFiles(@NotNull final GlobalSearchScope searchScope,\n                                      @NotNull final PropertiesFileProcessor processor,\n                                      @NotNull final BundleNameEvaluator evaluator) {\n\n    return FileBasedIndex.getInstance().processValues(FileTypeIndex.NAME, PropertiesFileType.INSTANCE, null, new FileBasedIndex.ValueProcessor<Void>() {\n      public boolean process(VirtualFile file, Void value) {\n\n        final PsiFile psiFile = myPsiManager.findFile(file);\n        if (psiFile instanceof PropertiesFile){\n          final String qName = evaluator.evaluateBundleName(psiFile);\n          if (qName != null) {\n            if (!processor.process(qName, (PropertiesFile) psiFile)) return false;\n          }\n        }\n        return true;\n      }\n    }, searchScope);\n  }","id":43529,"modified_method":"private boolean processPropertiesFiles(@NotNull final GlobalSearchScope searchScope,\n                                      @NotNull final PropertiesFileProcessor processor,\n                                      @NotNull final BundleNameEvaluator evaluator) {\n\n    boolean result = FileBasedIndex.getInstance()\n      .processValues(FileTypeIndex.NAME, PropertiesFileType.INSTANCE, null, new FileBasedIndex.ValueProcessor<Void>() {\n          public boolean process(VirtualFile file, Void value) {\n\n            final PsiFile psiFile = myPsiManager.findFile(file);\n            if (psiFile instanceof PropertiesFile) {\n              final String qName = evaluator.evaluateBundleName(psiFile);\n              if (qName != null) {\n                if (!processor.process(qName, (PropertiesFile)psiFile)) return false;\n              }\n            }\n            return true;\n          }\n        },\n                     searchScope);\n    if (!result) return false;\n    return FileBasedIndex.getInstance().processValues(XmlPropertiesIndex.NAME, XmlPropertiesIndex.MARKER_KEY, null,\n                                                      new FileBasedIndex.ValueProcessor<String>() {\n                                                        public boolean process(VirtualFile file, String value) {\n\n                                                          final PsiFile psiFile = myPsiManager.findFile(file);\n                                                          if (psiFile instanceof XmlFile) {\n                                                            final String qName = evaluator.evaluateBundleName(psiFile);\n                                                            if (qName != null) {\n                                                              if (!processor.process(qName, new XmlPropertiesFile((XmlFile)psiFile))) return false;\n                                                            }\n                                                          }\n                                                          return true;\n                                                        }\n                                                      }, searchScope);\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static List<IProperty> findPropertiesByKey(Project project, final String key) {\n    return new ArrayList<IProperty>(PropertyKeyIndex.getInstance().get(key, project, GlobalSearchScope.allScope(project)));\n  }","id":43530,"modified_method":"@NotNull\n  public static List<IProperty> findPropertiesByKey(final Project project, final String key) {\n    final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n    final ArrayList<IProperty> properties =\n      new ArrayList<IProperty>(PropertyKeyIndex.getInstance().get(key, project, scope));\n    final Set<VirtualFile> files = new HashSet<VirtualFile>();\n    FileBasedIndex.getInstance().processValues(XmlPropertiesIndex.NAME, new XmlPropertiesIndex.Key(key), null, new FileBasedIndex.ValueProcessor<String>() {\n      @Override\n      public boolean process(VirtualFile file, String value) {\n        if (files.add(file)) {\n          PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n          if (psiFile instanceof XmlFile) {\n            properties.addAll(new XmlPropertiesFile((XmlFile)psiFile).findPropertiesByKey(key));\n          }\n        }\n        return false;\n      }\n    }, scope);\n    return properties;\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement resolve() {\n    final Project project = myFile.getProject();\n\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    final VirtualFile formVirtualFile = myFile.getVirtualFile();\n    if (formVirtualFile == null) {\n      return null;\n    }\n    final Module module = fileIndex.getModuleForFile(formVirtualFile);\n    if (module == null) {\n      return null;\n    }\n    PropertiesFile propertiesFile = PropertiesUtil.getPropertiesFile(getRangeText(), module);\n    return propertiesFile == null ? null : propertiesFile.getContainingFile();\n  }","id":43531,"modified_method":"public PsiElement resolve() {\n    final Project project = myFile.getProject();\n\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    final VirtualFile formVirtualFile = myFile.getVirtualFile();\n    if (formVirtualFile == null) {\n      return null;\n    }\n    final Module module = fileIndex.getModuleForFile(formVirtualFile);\n    if (module == null) {\n      return null;\n    }\n    PropertiesFile propertiesFile = PropertiesUtil.getPropertiesFile(getRangeText(), module, null);\n    return propertiesFile == null ? null : propertiesFile.getContainingFile();\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement resolve() {\n    final Project project = myFile.getProject();\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    final VirtualFile formVirtualFile = myFile.getVirtualFile();\n    if (formVirtualFile == null) {\n      return null;\n    }\n    final Module module = fileIndex.getModuleForFile(formVirtualFile);\n    if (module == null) {\n      return null;\n    }\n    final PropertiesFile propertiesFile = PropertiesUtil.getPropertiesFile(myBundleName, module);\n    if (propertiesFile == null) {\n      return null;\n    }\n    IProperty property = propertiesFile.findPropertyByKey(getRangeText());\n    return property == null ? null : property.getPsiElement();\n  }","id":43532,"modified_method":"public PsiElement resolve() {\n    final Project project = myFile.getProject();\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    final VirtualFile formVirtualFile = myFile.getVirtualFile();\n    if (formVirtualFile == null) {\n      return null;\n    }\n    final Module module = fileIndex.getModuleForFile(formVirtualFile);\n    if (module == null) {\n      return null;\n    }\n    final PropertiesFile propertiesFile = PropertiesUtil.getPropertiesFile(myBundleName, module, null);\n    if (propertiesFile == null) {\n      return null;\n    }\n    IProperty property = propertiesFile.findPropertyByKey(getRangeText());\n    return property == null ? null : property.getPsiElement();\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getText() {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":43533,"modified_method":"@Override\n  public String getText() {\n    return getContainingFile().getText();\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiDirectory getParent() {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":43534,"modified_method":"@Override\n  public PsiDirectory getParent() {\n    return getContainingFile().getParent();\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Project getProject() {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":43535,"modified_method":"@Override\n  public Project getProject() {\n    return getContainingFile().getProject();\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public ID<String, String> getName() {\n    return NAME;\n  }","id":43536,"modified_method":"@Override\n  public ID<Key, String> getName() {\n    return NAME;\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Map<String, String> map(FileContent inputData) {\n    final HashMap<String, String> map = new HashMap<String, String>();\n    StdXMLReader reader = null;\n    try {\n      reader = new StdXMLReader(new ByteArrayInputStream(inputData.getContent())) {\n        @Override\n        public Reader openStream(String publicID, String systemID) throws IOException {\n          if (!\"http://java.sun.com/dtd/properties.dtd\".equals(systemID)) throw new IOException();\n          return super.openStream(publicID, systemID);\n        }\n      };\n    }\n    catch (IOException ignore) {\n      return Collections.emptyMap();\n    }\n    NanoXmlUtil.parse(reader, new NanoXmlUtil.IXMLBuilderAdapter() {\n\n      boolean accepted;\n      boolean insideEntry;\n      String key;\n\n      @Override\n      public void startElement(String name, String nsPrefix, String nsURI, String systemID, int lineNr)\n        throws Exception {\n        if (!accepted) {\n          if (\"properties\".equals(name)) {\n            accepted = true;\n          }\n          else throw new NanoXmlUtil.ParserStoppedException();\n        }\n        else {\n          insideEntry = \"entry\".equals(name);\n        }\n      }\n\n      @Override\n      public void addAttribute(String key, String nsPrefix, String nsURI, String value, String type)\n        throws Exception {\n        if (insideEntry && \"key\".equals(key)) this.key = value;\n      }\n\n      @Override\n      public void addPCData(Reader reader, String systemID, int lineNr) throws Exception {\n        if (insideEntry && key != null) {\n          String value = StreamUtil.readTextFrom(reader);\n          map.put(key, value);\n        }\n      }\n    });\n    return map;\n  }","id":43537,"modified_method":"@NotNull\n  @Override\n  public Map<Key, String> map(FileContent inputData) {\n    final HashMap<Key, String> map = new HashMap<Key, String>();\n    StdXMLReader reader;\n    try {\n      reader = new StdXMLReader(new ByteArrayInputStream(inputData.getContent())) {\n        @Override\n        public Reader openStream(String publicID, String systemID) throws IOException {\n          if (!\"http://java.sun.com/dtd/properties.dtd\".equals(systemID)) throw new IOException();\n          return super.openStream(publicID, systemID);\n        }\n      };\n    }\n    catch (IOException ignore) {\n      return Collections.emptyMap();\n    }\n    MyIXMLBuilderAdapter builder = new MyIXMLBuilderAdapter(map);\n    NanoXmlUtil.parse(reader, builder);\n    if (builder.accepted) map.put(MARKER_KEY, \"\");\n    return map;\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getVersion() {\n    return 0;\n  }","id":43538,"modified_method":"@Override\n  public int getVersion() {\n    return 1;\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public KeyDescriptor<String> getKeyDescriptor() {\n    return ENUMERATOR_STRING_DESCRIPTOR;\n  }","id":43539,"modified_method":"@Override\n  public KeyDescriptor<Key> getKeyDescriptor() {\n    return this;\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public DataIndexer<String, String, FileContent> getIndexer() {\n    return this;\n  }","id":43540,"modified_method":"@Override\n  public DataIndexer<Key, String, FileContent> getIndexer() {\n    return this;\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSystemId() throws Exception {\n    Map<String,String> map = new XmlPropertiesIndex().map(new FileContent((\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                                                                           \"<!DOCTYPE properties SYSTEM \\\"unknown\\\">\\n\" +\n                                                                           \"<properties>\\n\" +\n                                                                           \"<comment>Hi<\/comment>\\n\" +\n                                                                           \"<entry key=\\\"foo\\\">bar<\/entry>\\n\" +\n                                                                           \"<entry key=\\\"fu\\\">baz<\/entry>\\n\" +\n                                                                           \"<\/properties>\").getBytes()));\n\n    assertEquals(0, map.size());\n  }","id":43541,"modified_method":"public void testSystemId() throws Exception {\n    Map<XmlPropertiesIndex.Key, String> map = new XmlPropertiesIndex().map(new FileContent((\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                                                                                            \"<!DOCTYPE properties SYSTEM \\\"unknown\\\">\\n\" +\n                                                                                            \"<properties>\\n\" +\n                                                                                            \"<comment>Hi<\/comment>\\n\" +\n                                                                                            \"<entry key=\\\"foo\\\">bar<\/entry>\\n\" +\n                                                                                            \"<entry key=\\\"fu\\\">baz<\/entry>\\n\" +\n                                                                                            \"<\/properties>\").getBytes()));\n\n    assertEquals(0, map.size());\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testIndex() throws Exception {\n    Map<String,String> map = new XmlPropertiesIndex().map(new FileContent((\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                                                                           \"<!DOCTYPE properties SYSTEM \\\"http://java.sun.com/dtd/properties.dtd\\\">\\n\" +\n                                                                           \"<properties>\\n\" +\n                                                                           \"<comment>Hi<\/comment>\\n\" +\n                                                                           \"<entry key=\\\"foo\\\">bar<\/entry>\\n\" +\n                                                                           \"<entry key=\\\"fu\\\">baz<\/entry>\\n\" +\n                                                                           \"<\/properties>\").getBytes()));\n\n    assertEquals(2, map.size());\n    assertEquals(\"bar\", map.get(\"foo\"));\n    assertEquals(\"baz\", map.get(\"fu\"));\n  }","id":43542,"modified_method":"public void testIndex() throws Exception {\n    Map<XmlPropertiesIndex.Key, String> map = new XmlPropertiesIndex().map(new FileContent((\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                                                                                            \"<!DOCTYPE properties SYSTEM \\\"http://java.sun.com/dtd/properties.dtd\\\">\\n\" +\n                                                                                            \"<properties>\\n\" +\n                                                                                            \"<comment>Hi<\/comment>\\n\" +\n                                                                                            \"<entry key=\\\"foo\\\">bar<\/entry>\\n\" +\n                                                                                            \"<entry key=\\\"fu\\\">baz<\/entry>\\n\" +\n                                                                                            \"<\/properties>\").getBytes()));\n\n    assertEquals(3, map.size());\n    assertEquals(\"bar\", map.get(new XmlPropertiesIndex.Key(\"foo\")));\n    assertEquals(\"baz\", map.get(new XmlPropertiesIndex.Key(\"fu\")));\n    assertTrue(map.containsKey(XmlPropertiesIndex.MARKER_KEY));\n  }","commit_id":"0f57c357b4f6eba0be13aecaa9bd3a8684a8bed5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isExecutable() {\n        return getSpec().getGradleVersion().compareTo(EXEC_MINIMUM_VERSION) >= 0;\n    }","id":43543,"modified_method":"public boolean isExecutable() {\n        return getGradleVersion().compareTo(EXEC_MINIMUM_VERSION) >= 0;\n    }","commit_id":"9f8ec6c1beef387f399c4711a55ac40a899a712f","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean isCanObtainProjectOutcomesModel() {\n        GradleVersion version = getSpec().getGradleVersion();\n        boolean isMinimumVersionOrHigher = version.compareTo(PROJECT_OUTCOMES_MINIMUM_VERSION) >= 0;\n        //noinspection SimplifiableIfStatement\n        if (isMinimumVersionOrHigher) {\n            return true;\n        } else {\n            // Special handling for snapshots/RCs of the minimum version\n            return version.getVersionBase().equals(PROJECT_OUTCOMES_MINIMUM_VERSION.getVersionBase());\n        }\n    }","id":43544,"modified_method":"public boolean isCanObtainProjectOutcomesModel() {\n        GradleVersion version = getGradleVersion();\n        boolean isMinimumVersionOrHigher = version.compareTo(PROJECT_OUTCOMES_MINIMUM_VERSION) >= 0;\n        //noinspection SimplifiableIfStatement\n        if (isMinimumVersionOrHigher) {\n            return true;\n        } else {\n            // Special handling for snapshots/RCs of the minimum version\n            return version.getVersionBase().equals(PROJECT_OUTCOMES_MINIMUM_VERSION.getVersionBase());\n        }\n    }","commit_id":"9f8ec6c1beef387f399c4711a55ac40a899a712f","url":"https://github.com/gradle/gradle"},{"original_method":"public void setGradleVersion(String gradleVersion) {\n        if (gradleVersion == null) {\n            throw new IllegalArgumentException(\"gradleVersion cannot be null\");\n        }\n        GradleVersion version = GradleVersion.version(gradleVersion);\n        if (!version.isValid()) {\n            throw new IllegalArgumentException(String.format(\"%s is not a valid Gradle version string (examples: '1.0', 1.0-rc-1'\", gradleVersion));\n        }\n        this.gradleVersion = version;\n    }","id":43545,"modified_method":"public void setGradleVersion(String gradleVersion) {\n        if (gradleVersion == null) {\n            throw new IllegalArgumentException(\"gradleVersion cannot be null\");\n        }\n        GradleVersion version = GradleVersion.version(gradleVersion);\n        if (!version.isValid()) {\n            throw new IllegalArgumentException(String.format(\"%s is not a valid Gradle version string (examples: '1.0', 1.0-rc-1'\", gradleVersion));\n        }\n        this.gradleVersion = version.getVersion();\n    }","commit_id":"9f8ec6c1beef387f399c4711a55ac40a899a712f","url":"https://github.com/gradle/gradle"},{"original_method":"public GradleVersion getGradleVersion() {\n        return gradleVersion;\n    }","id":43546,"modified_method":"public String getGradleVersion() {\n        return gradleVersion;\n    }","commit_id":"9f8ec6c1beef387f399c4711a55ac40a899a712f","url":"https://github.com/gradle/gradle"},{"original_method":"private void warnAboutInferredOutcomes(boolean isSource, ComparableGradleBuildExecuter executer) {\n        String inferred = isSource ? \"source\" : \"target\";\n        String inferredFrom = isSource ? \"target\" : \"source\";\n\n        String message = String.format(\n                \"The build outcomes for the %s build will be inferred from the %s build because the %s build is to be executed with Gradle %s.\"\n                + \" This means that the comparison accuracy will be reduced.\"\n                + \" See the Gradle User Guide for more information.\",\n                inferred, inferredFrom, inferred, executer.getSpec().getGradleVersion().getVersion()\n        );\n\n        logger.warn(message);\n    }","id":43547,"modified_method":"private void warnAboutInferredOutcomes(boolean isSource, ComparableGradleBuildExecuter executer) {\n        String inferred = isSource ? \"source\" : \"target\";\n        String inferredFrom = isSource ? \"target\" : \"source\";\n\n        String message = String.format(\n                \"The build outcomes for the %s build will be inferred from the %s build because the %s build is to be executed with Gradle %s.\"\n                + \" This means that the comparison accuracy will be reduced.\"\n                + \" See the Gradle User Guide for more information.\",\n                inferred, inferredFrom, inferred, executer.getSpec().getGradleVersion()\n        );\n\n        logger.warn(message);\n    }","commit_id":"9f8ec6c1beef387f399c4711a55ac40a899a712f","url":"https://github.com/gradle/gradle"},{"original_method":"public BuildComparisonResult compare(FileStore<String> fileStore, File reportDir, Map<String, String> hostAttributes) {\n        String executingSourceBuildMessage = executingMessage(\"source\", sourceBuildExecuter);\n        String executingTargetBuildMessage = executingMessage(\"target\", targetBuildExecuter);\n\n        if (!sourceBuildExecuter.isExecutable() || !targetBuildExecuter.isExecutable()) {\n            throw new GradleException(String.format(\n                    \"Builds must be executed with %s or newer (source: %s, target: %s)\",\n                    ComparableGradleBuildExecuter.EXEC_MINIMUM_VERSION,\n                    sourceBuildExecuter.getSpec().getGradleVersion().getVersion(),\n                    targetBuildExecuter.getSpec().getGradleVersion().getVersion()\n            ));\n        }\n\n        boolean sourceBuildHasOutcomesModel = sourceBuildExecuter.isCanObtainProjectOutcomesModel();\n        boolean targetBuildHasOutcomesModel = targetBuildExecuter.isCanObtainProjectOutcomesModel();\n\n        if (!sourceBuildHasOutcomesModel && !targetBuildHasOutcomesModel) {\n            throw new GradleException(String.format(\n                    \"Cannot run comparison because both the source and target build are to be executed with a Gradle version older than %s (source: %s, target: %s).\",\n                    ComparableGradleBuildExecuter.PROJECT_OUTCOMES_MINIMUM_VERSION,\n                    sourceBuildExecuter.getSpec().getGradleVersion().getVersion(),\n                    targetBuildExecuter.getSpec().getGradleVersion().getVersion()\n            ));\n        }\n\n        if (!sourceBuildHasOutcomesModel) {\n            warnAboutInferredOutcomes(true, sourceBuildExecuter);\n        }\n        if (!targetBuildHasOutcomesModel) {\n            warnAboutInferredOutcomes(false, targetBuildExecuter);\n        }\n\n        Set<BuildOutcome> sourceOutcomes = null;\n        if (sourceBuildHasOutcomesModel) {\n            logger.info(executingSourceBuildMessage);\n            progressLogger.started(executingSourceBuildMessage);\n            ProjectOutcomes sourceOutput = executeBuild(sourceBuildExecuter);\n            progressLogger.progress(\"inspecting source build outcomes\");\n            GradleBuildOutcomeSetTransformer sourceOutcomeTransformer = createOutcomeSetTransformer(fileStore, SOURCE_FILESTORE_PREFIX);\n            sourceOutcomes = sourceOutcomeTransformer.transform(sourceOutput);\n        }\n\n        logger.info(executingTargetBuildMessage);\n        if (sourceBuildHasOutcomesModel) {\n            progressLogger.progress(executingTargetBuildMessage);\n        } else {\n            progressLogger.started(executingTargetBuildMessage);\n        }\n\n        ProjectOutcomes targetOutput = executeBuild(targetBuildExecuter);\n\n        Set<BuildOutcome> targetOutcomes;\n        if (targetBuildHasOutcomesModel) {\n            progressLogger.progress(\"inspecting target build outcomes\");\n            GradleBuildOutcomeSetTransformer targetOutcomeTransformer = createOutcomeSetTransformer(fileStore, TARGET_FILESTORE_PREFIX);\n            targetOutcomes = targetOutcomeTransformer.transform(targetOutput);\n        } else {\n            targetOutcomes = createOutcomeSetInferrer(fileStore, TARGET_FILESTORE_PREFIX, targetBuildExecuter.getSpec().getProjectDir()).transform(sourceOutcomes);\n        }\n\n        if (!sourceBuildHasOutcomesModel) {\n            logger.info(executingSourceBuildMessage);\n            progressLogger.progress(executingSourceBuildMessage);\n            executeBuild(sourceBuildExecuter);\n            progressLogger.progress(\"inspecting source build outcomes\");\n            sourceOutcomes = createOutcomeSetInferrer(fileStore, SOURCE_FILESTORE_PREFIX, sourceBuildExecuter.getSpec().getProjectDir()).transform(targetOutcomes);\n        }\n\n        progressLogger.progress(\"comparing build outcomes\");\n        BuildComparisonResult result = compareBuilds(sourceOutcomes, targetOutcomes);\n        writeReport(result, reportDir, fileStore, hostAttributes);\n        progressLogger.completed();\n\n        return result;\n    }","id":43548,"modified_method":"public BuildComparisonResult compare(FileStore<String> fileStore, File reportDir, Map<String, String> hostAttributes) {\n        String executingSourceBuildMessage = executingMessage(\"source\", sourceBuildExecuter);\n        String executingTargetBuildMessage = executingMessage(\"target\", targetBuildExecuter);\n\n        if (!sourceBuildExecuter.isExecutable() || !targetBuildExecuter.isExecutable()) {\n            throw new GradleException(String.format(\n                    \"Builds must be executed with %s or newer (source: %s, target: %s)\",\n                    ComparableGradleBuildExecuter.EXEC_MINIMUM_VERSION,\n                    sourceBuildExecuter.getSpec().getGradleVersion(),\n                    targetBuildExecuter.getSpec().getGradleVersion()\n            ));\n        }\n\n        boolean sourceBuildHasOutcomesModel = sourceBuildExecuter.isCanObtainProjectOutcomesModel();\n        boolean targetBuildHasOutcomesModel = targetBuildExecuter.isCanObtainProjectOutcomesModel();\n\n        if (!sourceBuildHasOutcomesModel && !targetBuildHasOutcomesModel) {\n            throw new GradleException(String.format(\n                    \"Cannot run comparison because both the source and target build are to be executed with a Gradle version older than %s (source: %s, target: %s).\",\n                    ComparableGradleBuildExecuter.PROJECT_OUTCOMES_MINIMUM_VERSION,\n                    sourceBuildExecuter.getSpec().getGradleVersion(),\n                    targetBuildExecuter.getSpec().getGradleVersion()\n            ));\n        }\n\n        if (!sourceBuildHasOutcomesModel) {\n            warnAboutInferredOutcomes(true, sourceBuildExecuter);\n        }\n        if (!targetBuildHasOutcomesModel) {\n            warnAboutInferredOutcomes(false, targetBuildExecuter);\n        }\n\n        Set<BuildOutcome> sourceOutcomes = null;\n        if (sourceBuildHasOutcomesModel) {\n            logger.info(executingSourceBuildMessage);\n            progressLogger.started(executingSourceBuildMessage);\n            ProjectOutcomes sourceOutput = executeBuild(sourceBuildExecuter);\n            progressLogger.progress(\"inspecting source build outcomes\");\n            GradleBuildOutcomeSetTransformer sourceOutcomeTransformer = createOutcomeSetTransformer(fileStore, SOURCE_FILESTORE_PREFIX);\n            sourceOutcomes = sourceOutcomeTransformer.transform(sourceOutput);\n        }\n\n        logger.info(executingTargetBuildMessage);\n        if (sourceBuildHasOutcomesModel) {\n            progressLogger.progress(executingTargetBuildMessage);\n        } else {\n            progressLogger.started(executingTargetBuildMessage);\n        }\n\n        ProjectOutcomes targetOutput = executeBuild(targetBuildExecuter);\n\n        Set<BuildOutcome> targetOutcomes;\n        if (targetBuildHasOutcomesModel) {\n            progressLogger.progress(\"inspecting target build outcomes\");\n            GradleBuildOutcomeSetTransformer targetOutcomeTransformer = createOutcomeSetTransformer(fileStore, TARGET_FILESTORE_PREFIX);\n            targetOutcomes = targetOutcomeTransformer.transform(targetOutput);\n        } else {\n            targetOutcomes = createOutcomeSetInferrer(fileStore, TARGET_FILESTORE_PREFIX, targetBuildExecuter.getSpec().getProjectDir()).transform(sourceOutcomes);\n        }\n\n        if (!sourceBuildHasOutcomesModel) {\n            logger.info(executingSourceBuildMessage);\n            progressLogger.progress(executingSourceBuildMessage);\n            executeBuild(sourceBuildExecuter);\n            progressLogger.progress(\"inspecting source build outcomes\");\n            sourceOutcomes = createOutcomeSetInferrer(fileStore, SOURCE_FILESTORE_PREFIX, sourceBuildExecuter.getSpec().getProjectDir()).transform(targetOutcomes);\n        }\n\n        progressLogger.progress(\"comparing build outcomes\");\n        BuildComparisonResult result = compareBuilds(sourceOutcomes, targetOutcomes);\n        writeReport(result, reportDir, fileStore, hostAttributes);\n        progressLogger.completed();\n\n        return result;\n    }","commit_id":"9f8ec6c1beef387f399c4711a55ac40a899a712f","url":"https://github.com/gradle/gradle"},{"original_method":"private ProjectConnection createProjectConnection(ComparableGradleBuildExecuter executer) {\n        GradleConnector connector = GradleConnector.newConnector();\n        connector.forProjectDirectory(executer.getSpec().getProjectDir());\n        File gradleUserHomeDir = gradle.getStartParameter().getGradleUserHomeDir();\n        if (gradleUserHomeDir != null) {\n            connector.useGradleUserHomeDir(gradleUserHomeDir);\n        }\n\n        GradleVersion gradleVersion = executer.getSpec().getGradleVersion();\n        if (gradleVersion.equals(GradleVersion.current())) {\n            connector.useInstallation(gradle.getGradleHomeDir());\n        } else {\n            connector.useGradleVersion(gradleVersion.getVersion());\n        }\n\n        return connector.connect();\n    }","id":43549,"modified_method":"private ProjectConnection createProjectConnection(ComparableGradleBuildExecuter executer) {\n        GradleConnector connector = GradleConnector.newConnector();\n        connector.forProjectDirectory(executer.getSpec().getProjectDir());\n        File gradleUserHomeDir = gradle.getStartParameter().getGradleUserHomeDir();\n        if (gradleUserHomeDir != null) {\n            connector.useGradleUserHomeDir(gradleUserHomeDir);\n        }\n\n        GradleVersion gradleVersion = executer.getGradleVersion();\n        if (gradleVersion.equals(GradleVersion.current())) {\n            connector.useInstallation(gradle.getGradleHomeDir());\n        } else {\n            connector.useGradleVersion(gradleVersion.getVersion());\n        }\n\n        return connector.connect();\n    }","commit_id":"9f8ec6c1beef387f399c4711a55ac40a899a712f","url":"https://github.com/gradle/gradle"},{"original_method":"public void readExternal(final URL url) throws InvalidDataException, FileNotFoundException {\n    try {\n      readExternal(JDOMUtil.loadDocument(url).getRootElement());\n    }\n    catch (FileNotFoundException e) {\n      throw e;\n    }\n    catch (IOException e) {\n      throw new InvalidDataException(e);\n    }\n    catch (JDOMException e) {\n      throw new InvalidDataException(e);\n    }\n  }","id":43550,"modified_method":"public void readExternal(final URL url) throws InvalidDataException, FileNotFoundException {\n    try {\n      Document document = JDOMUtil.loadDocument(url);\n      document = JDOMXIncluder.resolve(document, url.toExternalForm());\n      readExternal(document.getRootElement());\n    }\n    catch (FileNotFoundException e) {\n      throw e;\n    }\n    catch (IOException e) {\n      throw new InvalidDataException(e);\n    }\n    catch (JDOMException e) {\n      throw new InvalidDataException(e);\n    }\n  }","commit_id":"064d7b32ef4761259d1a1a02ed5e907499dddfd0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Element getState(final Object component, final String componentName) throws StateStorageException {\n    final URL url = DecodeDefaultsUtil.getDefaults(component, componentName);\n    if (url == null) return null;\n\n    try {\n      final Element documentElement = JDOMUtil.loadDocument(url).getRootElement();\n\n      if (myPathMacroManager != null) {\n        myPathMacroManager.expandPaths(documentElement);\n      }\n\n      return documentElement;\n    }\n    catch (IOException e) {\n      throw new StateStorageException(\"Error loading state from \" + url, e);\n    }\n    catch (JDOMException e) {\n      throw new StateStorageException(\"Error loading state from \" + url, e);\n    }\n  }","id":43551,"modified_method":"@Nullable\n  public Element getState(final Object component, final String componentName) throws StateStorageException {\n    final URL url = DecodeDefaultsUtil.getDefaults(component, componentName);\n    if (url == null) return null;\n\n    try {\n      Document document = JDOMUtil.loadDocument(url);\n      document = JDOMXIncluder.resolve(document, url.toExternalForm());\n      final Element documentElement = document.getRootElement();\n\n      if (myPathMacroManager != null) {\n        myPathMacroManager.expandPaths(documentElement);\n      }\n\n      return documentElement;\n    }\n    catch (IOException e) {\n      throw new StateStorageException(\"Error loading state from \" + url, e);\n    }\n    catch (JDOMException e) {\n      throw new StateStorageException(\"Error loading state from \" + url, e);\n    }\n  }","commit_id":"d0594921e08cbaea4517539d293ba29c21dd87b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void appendProjectLibraries(final Project project, final File workspaceRoot) throws IOException {\n    final File prefsParent = getPathToUserLibsFile(workspaceRoot);\n    if (!prefsParent.isDirectory()) {\n      if (!prefsParent.mkdirs()) return;\n    }\n    File prefs = new File(prefsParent, ORG_ECLIPSE_JDT_CORE_PREFS);\n    if (!prefs.exists()) {\n      if (!prefs.createNewFile()) return;\n    }\n\n    final Properties properties = new Properties();\n    final FileInputStream inputStream = new FileInputStream(prefs);\n    try {\n      properties.load(inputStream);\n    }\n    catch (IOException e) {\n      inputStream.close();\n    }\n\n    final Library[] libraries = ProjectLibraryTable.getInstance(project).getLibraries();\n    for (Library library : libraries) {\n      properties.setProperty(ORG_ECLIPSE_JDT_CORE_USER_LIBRARY + library.getName(), writeUserLibrary(library, project));\n    }\n\n    FileOutputStream outputStream = new FileOutputStream(prefs);\n    try {\n      properties.save(outputStream, null);\n    }\n    finally {\n      outputStream.close();\n    }\n  }","id":43552,"modified_method":"public static void appendProjectLibraries(final Project project, final File workspaceRoot) throws IOException {\n    if (!workspaceRoot.isDirectory()) return;\n    Element userLibsElement = new Element(\"eclipse-userlibraries\");\n    final Library[] libraries = ProjectLibraryTable.getInstance(project).getLibraries();\n    for (Library library : libraries) {\n      Element libElement = new Element(\"library\");\n      libElement.setAttribute(\"name\", library.getName());\n      writeUserLibrary(library, libElement);\n      userLibsElement.addContent(libElement);\n    }\n    JDOMUtil.writeDocument(new Document(userLibsElement), workspaceRoot + \"/\" + project.getName() + \".userlibraries\", \"\\n\");\n  }","commit_id":"967fd39133c077e287d362e00d5962ba10bf58f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void readProjectLibrariesContent(File workspace, Project project, Collection<String> unknownLibraries) throws IOException, JDOMException {\n    final File parentPrefs = getPathToUserLibsFile(workspace);\n    final LibraryTable libraryTable = ProjectLibraryTable.getInstance(project);\n    if (parentPrefs.isDirectory()) {\n      final File prefs = new File(parentPrefs, ORG_ECLIPSE_JDT_CORE_PREFS);\n      if (prefs.exists()) {\n        final Properties properties = new Properties();\n        FileInputStream inputStream = new FileInputStream(prefs);\n        try {\n          properties.load(inputStream);\n        }\n        finally {\n          inputStream.close();\n        }\n        for (Object prop : properties.keySet()) {\n          if (((String)prop).startsWith(ORG_ECLIPSE_JDT_CORE_USER_LIBRARY)) {\n            final String libName = ((String)prop).substring(ORG_ECLIPSE_JDT_CORE_USER_LIBRARY.length());\n            Library libraryByName = libraryTable.getLibraryByName(libName);\n            if (libraryByName == null) {\n              final LibraryTable.ModifiableModel model = libraryTable.getModifiableModel();\n              libraryByName = model.createLibrary(libName);\n              model.commit();\n            }\n            if (libraryByName != null) {\n              final Library.ModifiableModel model = libraryByName.getModifiableModel();\n              final String libDescriptor = properties.getProperty((String)prop);\n              final Document document = JDOMUtil.loadDocument(libDescriptor);\n              for (Object o : document.getRootElement().getChildren(\"archive\")) {\n                String rootPath = ((Element)o).getAttributeValue(\"path\");\n                if (rootPath.startsWith(\"/\")) { //relative to workspace root\n                  rootPath = project.getBaseDir().getPath() + rootPath;\n                }\n                String url = VfsUtil.pathToUrl(rootPath);\n                final VirtualFile localFile = VirtualFileManager.getInstance().findFileByUrl(url);\n                if (localFile != null) {\n                  final VirtualFile jarFile = JarFileSystem.getInstance().getJarRootForLocalFile(localFile);\n                  if (jarFile != null) {\n                    url = jarFile.getUrl();\n                  }\n                }\n                model.addRoot(url, OrderRootType.CLASSES);\n              }\n              model.commit();\n            }\n            unknownLibraries.remove(libName);  //ignore finally found libraries\n          }\n        }\n      }\n    }\n  }","id":43553,"modified_method":"public static void readProjectLibrariesContent(File workspace, Project project, Collection<String> unknownLibraries)\n    throws IOException, JDOMException {\n    if (!workspace.isDirectory()) return;\n    final File exportedFile = new File(workspace, project.getName() + \".userlibraries\");\n    if (exportedFile.exists()) {\n      final LibraryTable libraryTable = ProjectLibraryTable.getInstance(project);\n      final Element rootElement = JDOMUtil.loadDocument(exportedFile).getRootElement();\n      for (Object o : rootElement.getChildren(\"library\")) {\n        final Element libElement = (Element)o;\n        final String libName = libElement.getAttributeValue(\"name\");\n        Library libraryByName = libraryTable.getLibraryByName(libName);\n        if (libraryByName == null) {\n          final LibraryTable.ModifiableModel model = libraryTable.getModifiableModel();\n          libraryByName = model.createLibrary(libName);\n          model.commit();\n        }\n        if (libraryByName != null) {\n          final Library.ModifiableModel model = libraryByName.getModifiableModel();\n          for (Object a : libElement.getChildren(\"archive\")) {\n            String rootPath = ((Element)a).getAttributeValue(\"path\");\n            if (rootPath.startsWith(\"/\")) { //relative to workspace root\n              rootPath = project.getBaseDir().getPath() + rootPath;\n            }\n            String url = VfsUtil.pathToUrl(rootPath);\n            final VirtualFile localFile = VirtualFileManager.getInstance().findFileByUrl(url);\n            if (localFile != null) {\n              final VirtualFile jarFile = JarFileSystem.getInstance().getJarRootForLocalFile(localFile);\n              if (jarFile != null) {\n                url = jarFile.getUrl();\n              }\n            }\n            model.addRoot(url, OrderRootType.CLASSES);\n          }\n          model.commit();\n        }\n        unknownLibraries.remove(libName);  //ignore finally found libraries\n      }\n    }\n  }","commit_id":"967fd39133c077e287d362e00d5962ba10bf58f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String writeUserLibrary(Library library, Project project) {\n    StringBuffer buf = new StringBuffer();\n    buf.append(\"<?xml version\\\\=\\\"1.0\\\" encoding\\\\=\\\"UTF-8\\\"?>\\\\r\\\\n<userlibrary systemlibrary\\\\=\\\"false\\\" version\\\\=\\\"1\\\">\");\n    final String[] urls = library.getUrls(OrderRootType.CLASSES);  //todo remove existing\n\n    for (String url : urls) {\n      buf.append(\"\\\\r\\\\n\\\\t<archive path\\\\=\\\"\").append(EclipseClasspathWriter.getRelativePath(url, new String[0], true, project, null))\n        .append(\"\\\">\");\n      /*  \"\\\\r\\\\n\\\\t\\\\t<attributes>\\\\r\\\\n\\\\t\\\\t\\\\t\" +\n      \"<attribute name\\\\=\\\"javadoc_location\\\" value\\\\=\\\"file\\\\:/C\\\\:/conf\\\"/>\\\\r\\\\n\\\\t\\\\t\" +\n      \"<\/attributes>\";*/\n      buf.append(\"\\\\r\\\\n\\\\t<\/archive>\");\n    }\n    buf.append(\"\\\\r\\\\n<\/userlibrary>\\\\r\\\\n\");\n    return buf.toString();\n  }","id":43554,"modified_method":"private static void writeUserLibrary(final Library library, final Element libElement) {\n    final VirtualFile[] files = library.getFiles(OrderRootType.CLASSES);\n    for (VirtualFile file : files) {\n      Element archElement = new Element(\"archive\");\n      if (file.getFileSystem() instanceof JarFileSystem) {\n        final VirtualFile localFile = JarFileSystem.getInstance().getVirtualFileForJar(file);\n        if (localFile != null) {\n          file = localFile;\n        }\n      }\n      archElement.setAttribute(\"path\", file.getPath());\n      libElement.addContent(archElement);\n    }\n  }","commit_id":"967fd39133c077e287d362e00d5962ba10bf58f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"ApplicationInfoImpl() {\n    try {\n      Document doc = JDOMUtil.loadDocument(ApplicationInfoImpl.class, IDEA_PATH + ApplicationNamesInfo.getComponentName() + XML_EXTENSION);\n      loadState(doc.getRootElement());\n    }\n    catch (FileNotFoundException e) {\n      LOG.error(\"Resource is not in classpath or wrong platform prefix: \" + System.getProperty(PlatformUtils.PLATFORM_PREFIX_KEY), e);\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","id":43555,"modified_method":"ApplicationInfoImpl() {\n    String resource = IDEA_PATH + ApplicationNamesInfo.getComponentName() + XML_EXTENSION;\n    try {\n      Document doc = JDOMUtil.loadDocument(ApplicationInfoImpl.class, resource);\n      loadState(doc.getRootElement());\n    }\n    catch (Exception e) {\n      throw new RuntimeException(\"Cannot load resource: \" + resource, e);\n    }\n  }","commit_id":"889e8dd7e691d0052f8428d98e17605d3cd11ac3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Icon getProgressTailIcon() {\n    if (myProgressTailIcon == null && myProgressTailIconName != null) {\n      try {\n        final URL url = getClass().getResource(myProgressTailIconName);\n        final Image image = ImageLoader.loadFromUrl(url, false);\n        if (image != null) {\n          myProgressTailIcon = new ImageIcon(image);\n        }\n      } catch (Exception ignore) {}\n    }\n    return myProgressTailIcon;\n  }","id":43556,"modified_method":"@Nullable\n  public Icon getProgressTailIcon() {\n    if (myProgressTailIcon == null && myProgressTailIconName != null) {\n      try {\n        final URL url = getClass().getResource(myProgressTailIconName);\n        @SuppressWarnings({\"deprecation\", \"UnnecessaryFullyQualifiedName\"}) final Image image = com.intellij.util.ImageLoader.loadFromUrl(url, false);\n        if (image != null) {\n          myProgressTailIcon = new ImageIcon(image);\n        }\n      } catch (Exception ignore) {}\n    }\n    return myProgressTailIcon;\n  }","commit_id":"889e8dd7e691d0052f8428d98e17605d3cd11ac3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getComponentName() {\n    final String prefix = System.getProperty(PlatformUtils.PLATFORM_PREFIX_KEY);\n    if (prefix != null) {\n      return prefix + COMPONENT_NAME;\n    }\n    return COMPONENT_NAME;\n  }","id":43557,"modified_method":"public static String getComponentName() {\n    String prefix = System.getProperty(PlatformUtils.PLATFORM_PREFIX_KEY);\n    return prefix != null ? prefix + COMPONENT_NAME : COMPONENT_NAME;\n  }","commit_id":"889e8dd7e691d0052f8428d98e17605d3cd11ac3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void readInfo(final Element rootElement) {\n    final Element names = rootElement.getChild(ELEMENT_NAMES);\n    myProductName = names.getAttributeValue(ATTRIBUTE_PRODUCT);\n    myFullProductName = names.getAttributeValue(ATTRIBUTE_FULL_NAME);\n    myLowercaseProductName = StringUtil.capitalize(myProductName.toLowerCase());\n    myScriptName = names.getAttributeValue(ATTRIBUTE_SCRIPT);\n  }","id":43558,"modified_method":"private void readInfo(final Element rootElement) {\n    final Element names = rootElement.getChild(ELEMENT_NAMES);\n    myProductName = names.getAttributeValue(ATTRIBUTE_PRODUCT);\n    myFullProductName = names.getAttributeValue(ATTRIBUTE_FULL_NAME);\n    myLowercaseProductName = StringUtil.capitalize(myProductName.toLowerCase(Locale.US));\n    myScriptName = names.getAttributeValue(ATTRIBUTE_SCRIPT);\n  }","commit_id":"889e8dd7e691d0052f8428d98e17605d3cd11ac3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ApplicationNamesInfo() {\n    try {\n      //noinspection HardCodedStringLiteral\n      readInfo((JDOMUtil.load(ApplicationNamesInfo.class.getResourceAsStream(\"/idea/\" + getComponentName() + \".xml\"))));\n    }\n    catch (Exception e) {\n      //noinspection CallToPrintStackTrace\n      e.printStackTrace();\n    }\n  }","id":43559,"modified_method":"private ApplicationNamesInfo() {\n    String resource = \"/idea/\" + getComponentName() + \".xml\";\n    try {\n      Document doc = JDOMUtil.loadDocument(ApplicationNamesInfo.class, resource);\n      readInfo(doc.getRootElement());\n    }\n    catch (Exception e) {\n      throw new RuntimeException(\"Cannot load resource: \" + resource, e);\n    }\n  }","commit_id":"889e8dd7e691d0052f8428d98e17605d3cd11ac3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createQueryBox() {\n\t\tfinal JTabbedPane tabs = new JTabbedPane();\n\n\t\tfinal JPanel inputVBox = new JPanel();\n\t\tinputVBox.setLayout(new BorderLayout());\n\t\ttabs.add(Messages.getString(\"QueryDialog.inputtab\"), inputVBox);\n\t\t\n\t\tfinal Box historyBox= Box.createHorizontalBox();\n\t\tJLabel label= new JLabel(Messages.getString(\"QueryDialog.historylabel\"));\n\t\thistoryBox.add(label);\n\t\tfinal JComboBox historyList= new JComboBox(history);\n\t\tfor(final String query : client.queryHistory) {\n\t\t\taddQuery(query);\n\t\t}\n\t\thistoryList.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tfinal String item = (String)client.queryHistory.get(historyList.getSelectedIndex());\n\t\t\t\tquery.setText(item);\n\t\t\t}\n\t\t});\n\t\thistoryBox.add(historyList);\n\t\tinputVBox.add(historyBox, BorderLayout.NORTH);\n        \n        query = new ClientTextArea(true, \"XQUERY\");\n        query.setElectricScroll(1);\n\t\tquery.setEditable(true);\n\t\tquery.setPreferredSize(new Dimension(350, 200));\n        inputVBox.add(query, BorderLayout.CENTER);\n        \n\t\tfinal Box optionsPanel = Box.createHorizontalBox();\n        \n        label = new JLabel(Messages.getString(\"QueryDialog.contextlabel\"));\n        optionsPanel.add(label);\n        \n\t\tfinal List<String> data= new ArrayList<String>();\n\t\ttry {\n\t\t\tfinal Collection root = client.getCollection(XmldbURI.ROOT_COLLECTION);\n\t\t\tdata.add(collection.getName());\n\t\t\tgetCollections(root, collection, data);\n\t\t} catch (final XMLDBException e) {\n\t\t\tClientFrame.showErrorMessage(\n\t\t\t\t\tMessages.getString(\"QueryDialog.collectionretrievalerrormessage\")+\".\", e);\n\t\t}\n\t\tcollections= new JComboBox(new java.util.Vector(data));\n\t\tcollections.addActionListener(new ActionListener() {\n                    @Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tfinal int p = collections.getSelectedIndex();\n\t\t\t\tfinal String context = data.get(p);\n\t\t\t\ttry {\n\t\t\t\t\tcollection = client.getCollection(context);\n\t\t\t\t} catch (final XMLDBException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t});\n        optionsPanel.add(collections);\n\n\t\tlabel= new JLabel(Messages.getString(\"QueryDialog.maxlabel\"));\n        optionsPanel.add(label);\n        \n\t\tcount= new SpinnerNumberModel(100, 1, 10000, 50);\n\t\tfinal JSpinner spinner= new JSpinner(count);\n\t\tspinner.setMaximumSize(new Dimension(400,100));\n\t\toptionsPanel.add(spinner);\n       \n\t\tinputVBox.add(optionsPanel, BorderLayout.SOUTH);\n\t\treturn tabs;\n\t}","id":43560,"modified_method":"private JComponent createQueryBox() {\n\t\tfinal JTabbedPane tabs = new JTabbedPane();\n\n\t\tfinal JPanel inputVBox = new JPanel();\n\t\tinputVBox.setLayout(new BorderLayout());\n\t\ttabs.add(Messages.getString(\"QueryDialog.inputtab\"), inputVBox);\n\t\t\n\t\tfinal Box historyBox= Box.createHorizontalBox();\n\t\tJLabel label= new JLabel(Messages.getString(\"QueryDialog.historylabel\"));\n\t\thistoryBox.add(label);\n\t\tfinal JComboBox historyList= new JComboBox(history);\n\t\tfor(final String query : client.queryHistory) {\n\t\t\taddQuery(query);\n\t\t}\n\t\thistoryList.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tfinal String item = (String)client.queryHistory.get(historyList.getSelectedIndex());\n\t\t\t\tquery.setText(item);\n\t\t\t}\n\t\t});\n\t\thistoryBox.add(historyList);\n\t\tinputVBox.add(historyBox, BorderLayout.NORTH);\n        \n        query = new ClientTextArea(true, \"XQUERY\");\n        query.setElectricScroll(1);\n\t\tquery.setEditable(true);\n\t\tquery.setPreferredSize(new Dimension(400, 250));\n\t\tquery.setMinimumSize(new Dimension(400, 100));\n        inputVBox.add(query, BorderLayout.CENTER);\n        \n\t\tfinal Box optionsPanel = Box.createHorizontalBox();\n        \n        label = new JLabel(Messages.getString(\"QueryDialog.contextlabel\"));\n        optionsPanel.add(label);\n        \n\t\tfinal List<String> data= new ArrayList<String>();\n\t\ttry {\n\t\t\tfinal Collection root = client.getCollection(XmldbURI.ROOT_COLLECTION);\n\t\t\tdata.add(collection.getName());\n\t\t\tgetCollections(root, collection, data);\n\t\t} catch (final XMLDBException e) {\n\t\t\tClientFrame.showErrorMessage(\n\t\t\t\t\tMessages.getString(\"QueryDialog.collectionretrievalerrormessage\")+\".\", e);\n\t\t}\n\t\tcollections= new JComboBox(new java.util.Vector(data));\n\t\tcollections.addActionListener(new ActionListener() {\n                    @Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tfinal int p = collections.getSelectedIndex();\n\t\t\t\tfinal String context = data.get(p);\n\t\t\t\ttry {\n\t\t\t\t\tcollection = client.getCollection(context);\n\t\t\t\t} catch (final XMLDBException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t});\n        optionsPanel.add(collections);\n\n\t\tlabel= new JLabel(Messages.getString(\"QueryDialog.maxlabel\"));\n        optionsPanel.add(label);\n        \n\t\tcount= new SpinnerNumberModel(100, 1, 10000, 50);\n\t\tfinal JSpinner spinner= new JSpinner(count);\n\t\tspinner.setMaximumSize(new Dimension(400,100));\n\t\toptionsPanel.add(spinner);\n       \n\t\tinputVBox.add(optionsPanel, BorderLayout.SOUTH);\n\t\treturn tabs;\n\t}","commit_id":"1e5ba005499b49cde4cc7e9f689089fa857756e6","url":"https://github.com/eXist-db/exist"},{"original_method":"private void setupComponents(boolean loadedFromDb) {\n\t\tgetContentPane().setLayout(new BorderLayout());\n\t\tfinal JToolBar toolbar = new JToolBar();\n\t\t\n\t\tURL url= getClass().getResource(\"icons/Open24.gif\");\n\t\tJButton button= new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.opentooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\topen();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\t\n                if(loadedFromDb) {\n                    url= getClass().getResource(\"icons/SaveAs23.gif\");\n                    button= new JButton(new ImageIcon(url));\n                    button.setToolTipText(\"Save to database\");\n                    button.addActionListener(new ActionListener() {\n                        @Override\n                        public void actionPerformed(ActionEvent e) {\n                            saveToDb(query.getText());\n                        }\n                    });\n                    toolbar.add(button);\n                }\n                \n\t\turl= getClass().getResource(\"icons/SaveAs24.gif\");\n\t\tbutton= new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.saveastooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tsave(query.getText(), \"query\");\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\n\t\turl= getClass().getResource(\"icons/SaveAs25.gif\");\n\t\tbutton= new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.saveresultstooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tsave(resultDisplay.getText(), \"result\");\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\t\n\t\ttoolbar.addSeparator();\n\t\turl = getClass().getResource(\"icons/Copy24.gif\");\n\t\tbutton = new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.copytooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tquery.copy();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\turl = getClass().getResource(\"icons/Cut24.gif\");\n\t\tbutton = new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.cuttooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tquery.cut();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\turl = getClass().getResource(\"icons/Paste24.gif\");\n\t\tbutton = new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.pastetooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t   query.paste();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\t\n\t\ttoolbar.addSeparator();\n\t\t//TODO: change icon\n\t\turl= getClass().getResource(\"icons/Find24.gif\");\n\t\tbutton= new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.compiletooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t   compileQuery();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\t\n\t\ttoolbar.addSeparator();\n        url= getClass().getResource(\"icons/Find24.gif\");\n\t\tsubmitButton= new JButton(Messages.getString(\"QueryDialog.submitbutton\"), new ImageIcon(url));\n\t\tsubmitButton.setToolTipText(Messages.getString(\"QueryDialog.submittooltip\"));\n\t\ttoolbar.add(submitButton);\n\t\tsubmitButton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tsubmitButton.setEnabled(false);\n\t\t\t\tif(collection instanceof LocalCollection)\n\t\t\t\t\t{killButton.setEnabled(true);}\n\t\t\t\tq=doQuery();\n\t\t\t}\n\t\t});\n\t\t\n\t\ttoolbar.addSeparator();\n\t\turl= getClass().getResource(\"icons/Delete24.gif\");\n\t\tkillButton= new JButton(Messages.getString(\"QueryDialog.killbutton\"), new ImageIcon(url));\n\t\tkillButton.setToolTipText(Messages.getString(\"QueryDialog.killtooltip\"));\n\t\ttoolbar.add(killButton);\n\t\tkillButton.setEnabled(false);\n\t\tkillButton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif(q!=null) {\n\t\t\t\t\tq.killQuery();\n\t\t\t\t\tkillButton.setEnabled(false);\n\n\t\t\t\t\tq = null;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tfinal JSplitPane split = new JSplitPane(JSplitPane.VERTICAL_SPLIT);\n\t\tsplit.setResizeWeight(0.5);\n\t\t\n\t\tfinal JComponent qbox= createQueryBox();\n\t\tsplit.setTopComponent(qbox);\n\n        final JPanel vbox = new JPanel();\n        vbox.setLayout(new BorderLayout());\n        \n        final JLabel label = new JLabel(Messages.getString(\"QueryDialog.resultslabel\"));\n        vbox.add(label, BorderLayout.NORTH);\n        \n\t\tresultTabs = new JTabbedPane();\n        \n\t\tresultDisplay= new ClientTextArea(false, \"XML\");\n\t\tresultDisplay.setText(\"\");\n\t\tresultDisplay.setPreferredSize(new Dimension(400, 250));\n\t\tresultTabs.add(Messages.getString(\"QueryDialog.XMLtab\"), resultDisplay);\n\t\t\n\t\texprDisplay = new ClientTextArea(false, \"Dump\");\n\t\texprDisplay.setText(\"\");\n\t\texprDisplay.setPreferredSize(new Dimension(400, 250));\n\t\tresultTabs.add(Messages.getString(\"QueryDialog.tracetab\"), exprDisplay);\n\t\t\n        vbox.add(resultTabs, BorderLayout.CENTER);\n        \n        final Box statusbar = Box.createHorizontalBox();\n        statusbar.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));\n        statusMessage = new JTextField(20);\n        statusMessage.setEditable(false);\n        statusMessage.setFocusable(true);\n        statusbar.add(statusMessage);\n        queryPositionDisplay = new JTextField(5);\n        queryPositionDisplay.setEditable(false);\n        queryPositionDisplay.setFocusable(true);\n        statusbar.add(queryPositionDisplay);\n        query.setPositionOutputTextArea(queryPositionDisplay);\n        \n        progress = new JProgressBar();\n        progress.setPreferredSize(new Dimension(200, statusbar.getHeight()));\n        progress.setVisible(false);\n        statusbar.add(progress);\n        \n        vbox.add(statusbar, BorderLayout.SOUTH);\n        \n\t\tsplit.setBottomComponent(vbox);\n\t\tsplit.setDividerLocation(0.4);\n\t\tgetContentPane().add(toolbar, BorderLayout.NORTH);\n        getContentPane().add(split, BorderLayout.CENTER);\n\t}","id":43561,"modified_method":"private void setupComponents(boolean loadedFromDb) {\n\t\tgetContentPane().setLayout(new BorderLayout());\n\t\tfinal JToolBar toolbar = new JToolBar();\n\t\t\n\t\tURL url= getClass().getResource(\"icons/Open24.gif\");\n\t\tJButton button= new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.opentooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\topen();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\t\n                if(loadedFromDb) {\n                    url= getClass().getResource(\"icons/SaveAs23.gif\");\n                    button= new JButton(new ImageIcon(url));\n                    button.setToolTipText(\"Save to database\");\n                    button.addActionListener(new ActionListener() {\n                        @Override\n                        public void actionPerformed(ActionEvent e) {\n                            saveToDb(query.getText());\n                        }\n                    });\n                    toolbar.add(button);\n                }\n                \n\t\turl= getClass().getResource(\"icons/SaveAs24.gif\");\n\t\tbutton= new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.saveastooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tsave(query.getText(), \"query\");\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\n\t\turl= getClass().getResource(\"icons/SaveAs25.gif\");\n\t\tbutton= new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.saveresultstooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tsave(resultDisplay.getText(), \"result\");\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\t\n\t\ttoolbar.addSeparator();\n\t\turl = getClass().getResource(\"icons/Copy24.gif\");\n\t\tbutton = new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.copytooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tquery.copy();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\turl = getClass().getResource(\"icons/Cut24.gif\");\n\t\tbutton = new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.cuttooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tquery.cut();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\turl = getClass().getResource(\"icons/Paste24.gif\");\n\t\tbutton = new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.pastetooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t   query.paste();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\t\n\t\ttoolbar.addSeparator();\n\t\t//TODO: change icon\n\t\turl= getClass().getResource(\"icons/Find24.gif\");\n\t\tbutton= new JButton(new ImageIcon(url));\n\t\tbutton.setToolTipText(Messages.getString(\"QueryDialog.compiletooltip\"));\n\t\tbutton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t   compileQuery();\n\t\t\t}\n\t\t});\n\t\ttoolbar.add(button);\n\t\t\n\t\ttoolbar.addSeparator();\n        url= getClass().getResource(\"icons/Find24.gif\");\n\t\tsubmitButton= new JButton(Messages.getString(\"QueryDialog.submitbutton\"), new ImageIcon(url));\n\t\tsubmitButton.setToolTipText(Messages.getString(\"QueryDialog.submittooltip\"));\n\t\ttoolbar.add(submitButton);\n\t\tsubmitButton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tsubmitButton.setEnabled(false);\n\t\t\t\tif(collection instanceof LocalCollection)\n\t\t\t\t\t{killButton.setEnabled(true);}\n\t\t\t\tq=doQuery();\n\t\t\t}\n\t\t});\n\t\t\n\t\ttoolbar.addSeparator();\n\t\turl= getClass().getResource(\"icons/Delete24.gif\");\n\t\tkillButton= new JButton(Messages.getString(\"QueryDialog.killbutton\"), new ImageIcon(url));\n\t\tkillButton.setToolTipText(Messages.getString(\"QueryDialog.killtooltip\"));\n\t\ttoolbar.add(killButton);\n\t\tkillButton.setEnabled(false);\n\t\tkillButton.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif(q!=null) {\n\t\t\t\t\tq.killQuery();\n\t\t\t\t\tkillButton.setEnabled(false);\n\n\t\t\t\t\tq = null;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tfinal JSplitPane split = new JSplitPane(JSplitPane.VERTICAL_SPLIT);\n\t\tsplit.setResizeWeight(0.6);\n\t\t\n\t\tfinal JComponent qbox= createQueryBox();\n\t\tsplit.setTopComponent(qbox);\n\n        final JPanel vbox = new JPanel();\n        vbox.setLayout(new BorderLayout());\n        \n        final JLabel label = new JLabel(Messages.getString(\"QueryDialog.resultslabel\"));\n        vbox.add(label, BorderLayout.NORTH);\n        \n\t\tresultTabs = new JTabbedPane();\n        \n\t\tresultDisplay= new ClientTextArea(false, \"XML\");\n\t\tresultDisplay.setText(\"\");\n\t\tresultDisplay.setPreferredSize(new Dimension(400, 250));\n\t\tresultDisplay.setMinimumSize(new Dimension(400, 100));\n\t\tresultTabs.add(Messages.getString(\"QueryDialog.XMLtab\"), resultDisplay);\n\t\t\n\t\texprDisplay = new ClientTextArea(false, \"Dump\");\n\t\texprDisplay.setText(\"\");\n\t\texprDisplay.setPreferredSize(new Dimension(400, 200));\n\t\texprDisplay.setMinimumSize(new Dimension(400, 100));\n\t\tresultTabs.add(Messages.getString(\"QueryDialog.tracetab\"), exprDisplay);\n\t\t\n        vbox.add(resultTabs, BorderLayout.CENTER);\n        \n        final Box statusbar = Box.createHorizontalBox();\n        statusbar.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));\n        statusMessage = new JTextField(20);\n        statusMessage.setEditable(false);\n        statusMessage.setFocusable(true);\n        statusbar.add(statusMessage);\n        queryPositionDisplay = new JTextField(5);\n        queryPositionDisplay.setEditable(false);\n        queryPositionDisplay.setFocusable(true);\n        statusbar.add(queryPositionDisplay);\n        query.setPositionOutputTextArea(queryPositionDisplay);\n        \n        progress = new JProgressBar();\n        progress.setPreferredSize(new Dimension(200, statusbar.getHeight()));\n        progress.setVisible(false);\n        statusbar.add(progress);\n        \n        vbox.add(statusbar, BorderLayout.SOUTH);\n        \n\t\tsplit.setBottomComponent(vbox);\n\t\tsplit.setDividerLocation(0.6);\n\t\tgetContentPane().add(toolbar, BorderLayout.NORTH);\n        getContentPane().add(split, BorderLayout.CENTER);\n\t}","commit_id":"1e5ba005499b49cde4cc7e9f689089fa857756e6","url":"https://github.com/eXist-db/exist"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    private void initComponents() {//GEN-BEGIN:initComponents\n        java.awt.GridBagConstraints gridBagConstraints;\n\n        jSplitPane2 = new javax.swing.JSplitPane();\n        jSplitPane1 = new javax.swing.JSplitPane();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        navigatorTree = new javax.swing.JTree();\n        viewPanel = new javax.swing.JPanel();\n        emptyPanel = new javax.swing.JPanel();\n        reportPanel = new javax.swing.JPanel();\n        editProjectPanel = new javax.swing.JPanel();\n        jarFileLabel = new javax.swing.JLabel();\n        jarNameTextField = new javax.swing.JTextField();\n        addJarButton = new javax.swing.JButton();\n        jarFileListLabel = new javax.swing.JLabel();\n        sourceDirLabel = new javax.swing.JLabel();\n        srcDirTextField = new javax.swing.JTextField();\n        addSourceDirButton = new javax.swing.JButton();\n        sourceDirListLabel = new javax.swing.JLabel();\n        removeJarButton = new javax.swing.JButton();\n        removeSrcDirButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        browseJarButton = new javax.swing.JButton();\n        browseSrcDirButton = new javax.swing.JButton();\n        editProjectLabel = new javax.swing.JLabel();\n        jSeparator2 = new javax.swing.JSeparator();\n        findBugsButton = new javax.swing.JButton();\n        jSeparator4 = new javax.swing.JSeparator();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        jarFileList = new javax.swing.JList();\n        jScrollPane3 = new javax.swing.JScrollPane();\n        sourceDirList = new javax.swing.JList();\n        bugTreePanel = new javax.swing.JPanel();\n        jScrollPane4 = new javax.swing.JScrollPane();\n        bugTree = new javax.swing.JTree();\n        sortOrderChooser = new javax.swing.JComboBox();\n        sortOrderLabel = new javax.swing.JLabel();\n        leftFiller = new javax.swing.JLabel();\n        rightFiller = new javax.swing.JLabel();\n        jScrollPane5 = new javax.swing.JScrollPane();\n        consoleMessageArea = new javax.swing.JTextArea();\n        jMenuBar1 = new javax.swing.JMenuBar();\n        fileMenu = new javax.swing.JMenu();\n        newProjectItem = new javax.swing.JMenuItem();\n        openProjectItem = new javax.swing.JMenuItem();\n        closeProjectItem = new javax.swing.JMenuItem();\n        jSeparator3 = new javax.swing.JSeparator();\n        exitItem = new javax.swing.JMenuItem();\n        viewMenu = new javax.swing.JMenu();\n        viewConsoleItem = new javax.swing.JCheckBoxMenuItem();\n\n        setTitle(\"FindBugs\");\n        addWindowListener(new java.awt.event.WindowAdapter() {\n            public void windowOpened(java.awt.event.WindowEvent evt) {\n                formWindowOpened(evt);\n            }\n            public void windowClosing(java.awt.event.WindowEvent evt) {\n                exitForm(evt);\n            }\n        });\n\n        jSplitPane2.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        jSplitPane2.setResizeWeight(1.0);\n        jSplitPane1.setEnabled(false);\n        jScrollPane1.setPreferredSize(new java.awt.Dimension(200, 0));\n        navigatorTree.setModel(createNavigatorTreeModel());\n        jScrollPane1.setViewportView(navigatorTree);\n\n        jSplitPane1.setLeftComponent(jScrollPane1);\n\n        viewPanel.setLayout(new java.awt.CardLayout());\n\n        viewPanel.add(emptyPanel, \"EmptyPanel\");\n\n        viewPanel.add(reportPanel, \"ReportPanel\");\n\n        editProjectPanel.setLayout(new java.awt.GridBagLayout());\n\n        jarFileLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileLabel.setText(\"Jar file:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileLabel, gridBagConstraints);\n\n        jarNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jarNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(jarNameTextField, gridBagConstraints);\n\n        addJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addJarButton.setText(\"Add\");\n        addJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addJarButton, gridBagConstraints);\n\n        jarFileListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileListLabel.setText(\"Jar Files:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListLabel, gridBagConstraints);\n\n        sourceDirLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirLabel.setText(\"Source Dir:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirLabel, gridBagConstraints);\n\n        srcDirTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                srcDirTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(srcDirTextField, gridBagConstraints);\n\n        addSourceDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addSourceDirButton.setText(\"Add\");\n        addSourceDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addSourceDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addSourceDirButton, gridBagConstraints);\n\n        sourceDirListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirListLabel.setText(\"Source Dirs:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListLabel, gridBagConstraints);\n\n        removeJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeJarButton.setText(\"Remove\");\n        removeJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeJarButton, gridBagConstraints);\n\n        removeSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeSrcDirButton.setText(\"Remove\");\n        removeSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeSrcDirButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 5;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator1, gridBagConstraints);\n\n        browseJarButton.setText(\"...\");\n        browseJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseJarButton, gridBagConstraints);\n\n        browseSrcDirButton.setText(\"...\");\n        browseSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseSrcDirButton, gridBagConstraints);\n\n        editProjectLabel.setBackground(new java.awt.Color(0, 0, 204));\n        editProjectLabel.setFont(new java.awt.Font(\"Dialog\", 1, 24));\n        editProjectLabel.setForeground(new java.awt.Color(255, 255, 255));\n        editProjectLabel.setText(\"Project\");\n        editProjectLabel.setOpaque(true);\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        editProjectPanel.add(editProjectLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 2;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator2, gridBagConstraints);\n\n        findBugsButton.setText(\"Find Bugs!\");\n        findBugsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                findBugsButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(findBugsButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 8;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator4, gridBagConstraints);\n\n        jScrollPane2.setPreferredSize(new java.awt.Dimension(259, 1));\n        jarFileList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        jarFileList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        jScrollPane2.setViewportView(jarFileList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.7;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jScrollPane2, gridBagConstraints);\n\n        jScrollPane3.setPreferredSize(new java.awt.Dimension(259, 1));\n        sourceDirList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        sourceDirList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        jScrollPane3.setViewportView(sourceDirList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jScrollPane3, gridBagConstraints);\n\n        viewPanel.add(editProjectPanel, \"EditProjectPanel\");\n\n        bugTreePanel.setLayout(new java.awt.GridBagLayout());\n\n        jScrollPane4.setViewportView(bugTree);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 1;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        bugTreePanel.add(jScrollPane4, gridBagConstraints);\n\n        sortOrderChooser.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                sortOrderChooserActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 0;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        bugTreePanel.add(sortOrderChooser, gridBagConstraints);\n\n        sortOrderLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sortOrderLabel.setText(\"Sort order:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 0;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        bugTreePanel.add(sortOrderLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 0;\n        gridBagConstraints.weightx = 0.5;\n        bugTreePanel.add(leftFiller, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 0;\n        gridBagConstraints.weightx = 0.5;\n        bugTreePanel.add(rightFiller, gridBagConstraints);\n\n        viewPanel.add(bugTreePanel, \"BugTree\");\n\n        jSplitPane1.setRightComponent(viewPanel);\n\n        jSplitPane2.setTopComponent(jSplitPane1);\n\n        jScrollPane5.setPreferredSize(new java.awt.Dimension(0, 100));\n        consoleMessageArea.setBackground(new java.awt.Color(204, 204, 204));\n        consoleMessageArea.setEditable(false);\n        consoleMessageArea.setFont(new java.awt.Font(\"Courier\", 0, 12));\n        consoleMessageArea.setMinimumSize(new java.awt.Dimension(0, 0));\n        consoleMessageArea.setPreferredSize(new java.awt.Dimension(0, 0));\n        jScrollPane5.setViewportView(consoleMessageArea);\n\n        jSplitPane2.setBottomComponent(jScrollPane5);\n\n        getContentPane().add(jSplitPane2, java.awt.BorderLayout.CENTER);\n\n        jMenuBar1.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fileMenu.setMnemonic('F');\n        fileMenu.setText(\"File\");\n        fileMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setMnemonic('N');\n        newProjectItem.setText(\"New Project\");\n        newProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(newProjectItem);\n\n        openProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        openProjectItem.setMnemonic('O');\n        openProjectItem.setText(\"Open Project\");\n        fileMenu.add(openProjectItem);\n\n        closeProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        closeProjectItem.setMnemonic('C');\n        closeProjectItem.setText(\"Close Project\");\n        fileMenu.add(closeProjectItem);\n\n        fileMenu.add(jSeparator3);\n\n        exitItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        exitItem.setMnemonic('X');\n        exitItem.setText(\"Exit\");\n        exitItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exitItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(exitItem);\n\n        jMenuBar1.add(fileMenu);\n\n        viewMenu.setMnemonic('V');\n        viewMenu.setText(\"View\");\n        viewMenu.setToolTipText(\"null\");\n        viewMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewConsoleItem.setMnemonic('C');\n        viewConsoleItem.setSelected(true);\n        viewConsoleItem.setText(\"Console\");\n        viewMenu.add(viewConsoleItem);\n\n        jMenuBar1.add(viewMenu);\n\n        setJMenuBar(jMenuBar1);\n\n        pack();\n    }","id":43562,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    private void initComponents() {//GEN-BEGIN:initComponents\n        java.awt.GridBagConstraints gridBagConstraints;\n\n        consoleSplitter = new javax.swing.JSplitPane();\n        navigatorViewSplitter = new javax.swing.JSplitPane();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        navigatorTree = new javax.swing.JTree();\n        viewPanel = new javax.swing.JPanel();\n        emptyPanel = new javax.swing.JPanel();\n        reportPanel = new javax.swing.JPanel();\n        editProjectPanel = new javax.swing.JPanel();\n        jarFileLabel = new javax.swing.JLabel();\n        jarNameTextField = new javax.swing.JTextField();\n        addJarButton = new javax.swing.JButton();\n        jarFileListLabel = new javax.swing.JLabel();\n        sourceDirLabel = new javax.swing.JLabel();\n        srcDirTextField = new javax.swing.JTextField();\n        addSourceDirButton = new javax.swing.JButton();\n        sourceDirListLabel = new javax.swing.JLabel();\n        removeJarButton = new javax.swing.JButton();\n        removeSrcDirButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        browseJarButton = new javax.swing.JButton();\n        browseSrcDirButton = new javax.swing.JButton();\n        editProjectLabel = new javax.swing.JLabel();\n        jSeparator2 = new javax.swing.JSeparator();\n        findBugsButton = new javax.swing.JButton();\n        jSeparator4 = new javax.swing.JSeparator();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        jarFileList = new javax.swing.JList();\n        jScrollPane3 = new javax.swing.JScrollPane();\n        sourceDirList = new javax.swing.JList();\n        bugTreePanel = new javax.swing.JPanel();\n        jScrollPane4 = new javax.swing.JScrollPane();\n        bugTree = new javax.swing.JTree();\n        sortOrderChooser = new javax.swing.JComboBox();\n        sortOrderLabel = new javax.swing.JLabel();\n        leftFiller = new javax.swing.JLabel();\n        rightFiller = new javax.swing.JLabel();\n        jScrollPane5 = new javax.swing.JScrollPane();\n        consoleMessageArea = new javax.swing.JTextArea();\n        jMenuBar1 = new javax.swing.JMenuBar();\n        fileMenu = new javax.swing.JMenu();\n        newProjectItem = new javax.swing.JMenuItem();\n        openProjectItem = new javax.swing.JMenuItem();\n        closeProjectItem = new javax.swing.JMenuItem();\n        jSeparator3 = new javax.swing.JSeparator();\n        exitItem = new javax.swing.JMenuItem();\n        viewMenu = new javax.swing.JMenu();\n        viewConsoleItem = new javax.swing.JCheckBoxMenuItem();\n\n        setTitle(\"FindBugs\");\n        addWindowListener(new java.awt.event.WindowAdapter() {\n            public void windowOpened(java.awt.event.WindowEvent evt) {\n                formWindowOpened(evt);\n            }\n            public void windowClosing(java.awt.event.WindowEvent evt) {\n                exitForm(evt);\n            }\n        });\n\n        consoleSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        consoleSplitter.setResizeWeight(1.0);\n        consoleSplitter.setOneTouchExpandable(true);\n        consoleSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                consoleSplitterPropertyChange(evt);\n            }\n        });\n\n        navigatorViewSplitter.setEnabled(false);\n        jScrollPane1.setPreferredSize(new java.awt.Dimension(200, 0));\n        navigatorTree.setModel(createNavigatorTreeModel());\n        jScrollPane1.setViewportView(navigatorTree);\n\n        navigatorViewSplitter.setLeftComponent(jScrollPane1);\n\n        viewPanel.setLayout(new java.awt.CardLayout());\n\n        viewPanel.add(emptyPanel, \"EmptyPanel\");\n\n        viewPanel.add(reportPanel, \"ReportPanel\");\n\n        editProjectPanel.setLayout(new java.awt.GridBagLayout());\n\n        jarFileLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileLabel.setText(\"Jar file:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileLabel, gridBagConstraints);\n\n        jarNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jarNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(jarNameTextField, gridBagConstraints);\n\n        addJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addJarButton.setText(\"Add\");\n        addJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addJarButton, gridBagConstraints);\n\n        jarFileListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileListLabel.setText(\"Jar Files:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListLabel, gridBagConstraints);\n\n        sourceDirLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirLabel.setText(\"Source Dir:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirLabel, gridBagConstraints);\n\n        srcDirTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                srcDirTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(srcDirTextField, gridBagConstraints);\n\n        addSourceDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addSourceDirButton.setText(\"Add\");\n        addSourceDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addSourceDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addSourceDirButton, gridBagConstraints);\n\n        sourceDirListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirListLabel.setText(\"Source Dirs:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListLabel, gridBagConstraints);\n\n        removeJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeJarButton.setText(\"Remove\");\n        removeJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeJarButton, gridBagConstraints);\n\n        removeSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeSrcDirButton.setText(\"Remove\");\n        removeSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeSrcDirButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 5;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator1, gridBagConstraints);\n\n        browseJarButton.setText(\"...\");\n        browseJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseJarButton, gridBagConstraints);\n\n        browseSrcDirButton.setText(\"...\");\n        browseSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseSrcDirButton, gridBagConstraints);\n\n        editProjectLabel.setBackground(new java.awt.Color(0, 0, 204));\n        editProjectLabel.setFont(new java.awt.Font(\"Dialog\", 1, 24));\n        editProjectLabel.setForeground(new java.awt.Color(255, 255, 255));\n        editProjectLabel.setText(\"Project\");\n        editProjectLabel.setOpaque(true);\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        editProjectPanel.add(editProjectLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 2;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator2, gridBagConstraints);\n\n        findBugsButton.setText(\"Find Bugs!\");\n        findBugsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                findBugsButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(findBugsButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 8;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator4, gridBagConstraints);\n\n        jScrollPane2.setPreferredSize(new java.awt.Dimension(259, 1));\n        jarFileList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        jarFileList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        jScrollPane2.setViewportView(jarFileList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.7;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jScrollPane2, gridBagConstraints);\n\n        jScrollPane3.setPreferredSize(new java.awt.Dimension(259, 1));\n        sourceDirList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        sourceDirList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        jScrollPane3.setViewportView(sourceDirList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jScrollPane3, gridBagConstraints);\n\n        viewPanel.add(editProjectPanel, \"EditProjectPanel\");\n\n        bugTreePanel.setLayout(new java.awt.GridBagLayout());\n\n        jScrollPane4.setViewportView(bugTree);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 1;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        bugTreePanel.add(jScrollPane4, gridBagConstraints);\n\n        sortOrderChooser.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                sortOrderChooserActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 0;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        bugTreePanel.add(sortOrderChooser, gridBagConstraints);\n\n        sortOrderLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sortOrderLabel.setText(\"Sort order:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 0;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        bugTreePanel.add(sortOrderLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 0;\n        gridBagConstraints.weightx = 0.5;\n        bugTreePanel.add(leftFiller, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 0;\n        gridBagConstraints.weightx = 0.5;\n        bugTreePanel.add(rightFiller, gridBagConstraints);\n\n        viewPanel.add(bugTreePanel, \"BugTree\");\n\n        navigatorViewSplitter.setRightComponent(viewPanel);\n\n        consoleSplitter.setTopComponent(navigatorViewSplitter);\n\n        jScrollPane5.setMinimumSize(new java.awt.Dimension(22, 100));\n        jScrollPane5.setPreferredSize(new java.awt.Dimension(0, 100));\n        consoleMessageArea.setBackground(new java.awt.Color(204, 204, 204));\n        consoleMessageArea.setEditable(false);\n        consoleMessageArea.setFont(new java.awt.Font(\"Courier\", 0, 12));\n        consoleMessageArea.setMinimumSize(new java.awt.Dimension(0, 0));\n        consoleMessageArea.setPreferredSize(new java.awt.Dimension(0, 5));\n        jScrollPane5.setViewportView(consoleMessageArea);\n\n        consoleSplitter.setBottomComponent(jScrollPane5);\n\n        getContentPane().add(consoleSplitter, java.awt.BorderLayout.CENTER);\n\n        jMenuBar1.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fileMenu.setMnemonic('F');\n        fileMenu.setText(\"File\");\n        fileMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setMnemonic('N');\n        newProjectItem.setText(\"New Project\");\n        newProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(newProjectItem);\n\n        openProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        openProjectItem.setMnemonic('O');\n        openProjectItem.setText(\"Open Project\");\n        fileMenu.add(openProjectItem);\n\n        closeProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        closeProjectItem.setMnemonic('C');\n        closeProjectItem.setText(\"Close Project\");\n        fileMenu.add(closeProjectItem);\n\n        fileMenu.add(jSeparator3);\n\n        exitItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        exitItem.setMnemonic('X');\n        exitItem.setText(\"Exit\");\n        exitItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exitItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(exitItem);\n\n        jMenuBar1.add(fileMenu);\n\n        viewMenu.setMnemonic('V');\n        viewMenu.setText(\"View\");\n        viewMenu.setToolTipText(\"null\");\n        viewMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewConsoleItem.setMnemonic('C');\n        viewConsoleItem.setSelected(true);\n        viewConsoleItem.setText(\"Console\");\n        viewConsoleItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewConsoleItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewConsoleItem);\n\n        jMenuBar1.add(viewMenu);\n\n        setJMenuBar(jMenuBar1);\n\n        pack();\n    }","commit_id":"de8928229ee5a24e84a116a09996873ac5ec7cd8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        StringBuilder text = new StringBuilder();\n        text.append(getReportHeader());\n        try {\n            BufferedReader input = new BufferedReader(new FileReader(Main.pref\n                    .getPreferencesDirFile()\n                    + File.separator + \"preferences\"));\n            try {\n                String line = null;\n\n                while ((line = input.readLine()) != null) {\n                    // Skip potential private information\n                    if (line.trim().toLowerCase().startsWith(\"osm-server.username\")) {\n                        continue;\n                    }\n                    if (line.trim().toLowerCase().startsWith(\"osm-server.password\")) {\n                        continue;\n                    }\n                    if (line.trim().toLowerCase().startsWith(\"marker.show\")) {\n                        continue;\n                    }\n\n                    text.append(line);\n                    text.append(\"\\n\");\n                }\n            } finally {\n                input.close();\n            }\n        } catch (Exception x) {\n            x.printStackTrace();\n        }\n\n        JTextArea ta = new JTextArea(text.toString());\n        ta.setWrapStyleWord(true);\n        ta.setLineWrap(true);\n        ta.setEditable(false);\n        JScrollPane sp = new JScrollPane(ta);\n        sp.setPreferredSize(new Dimension(600, 500));\n\n        ExtendedDialog ed = new ExtendedDialog(Main.parent,\n                tr(\"Status Report\"),\n                new String[] {tr(\"Copy to clipboard and close\"), tr(\"Close\") });\n        ed.setButtonIcons(new String[] {\"copy.png\", \"cancel.png\" });\n        ed.setContent(sp);\n        ed.showDialog();\n\n        if(ed.getValue() != 1) return;\n        try {\n            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(\n                    new StringSelection(text.toString()), new ClipboardOwner() {\n                        public void lostOwnership(Clipboard clipboard, Transferable contents) {}\n                    }\n            );\n        }\n        catch (RuntimeException x) {}\n    }","id":43563,"modified_method":"public void actionPerformed(ActionEvent e) {\n        StringBuilder text = new StringBuilder();\n        text.append(getReportHeader());\n        try {\n            BufferedReader input = new BufferedReader(new FileReader(Main.pref\n                    .getPreferencesDirFile()\n                    + File.separator + \"preferences\"));\n            try {\n                String line = null;\n\n                while ((line = input.readLine()) != null) {\n                    // Skip potential private information\n                    if (line.trim().toLowerCase().startsWith(\"osm-server.username\")) {\n                        continue;\n                    }\n                    if (line.trim().toLowerCase().startsWith(\"osm-server.password\")) {\n                        continue;\n                    }\n                    if (line.trim().toLowerCase().startsWith(\"marker.show\")) {\n                        continue;\n                    }\n\n                    text.append(line);\n                    text.append(\"\\n\");\n                }\n            } finally {\n                input.close();\n            }\n        } catch (Exception x) {\n            x.printStackTrace();\n        }\n\n        JTextArea ta = new JTextArea(text.toString());\n        ta.setWrapStyleWord(true);\n        ta.setLineWrap(true);\n        ta.setEditable(false);\n        JScrollPane sp = new JScrollPane(ta);\n\n        ExtendedDialog ed = new ExtendedDialog(Main.parent,\n                tr(\"Status Report\"),\n                new String[] {tr(\"Copy to clipboard and close\"), tr(\"Close\") });\n        ed.setButtonIcons(new String[] {\"copy.png\", \"cancel.png\" });\n        ed.setContent(sp, false);\n        ed.setMinimumSize(new Dimension(500, 0));\n        ed.showDialog();\n\n        if(ed.getValue() != 1) return;\n        try {\n            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(\n                    new StringSelection(text.toString()), new ClipboardOwner() {\n                        public void lostOwnership(Clipboard clipboard, Transferable contents) {}\n                    }\n            );\n        }\n        catch (RuntimeException x) {}\n    }","commit_id":"ff5e3a25e69bfbeb93a0ca67f4bd5e3ad6a5eab3","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Object getLock() {\n        return lock;\n    }","id":43564,"modified_method":"/**\n     * Return the lock for this queue.\n     */\n    public Object getLock() {\n        return lock;\n    }","commit_id":"ed601bc31a6efda1c1291454201ea367d7d216f7","url":"https://github.com/apache/sling"},{"original_method":"public EventInfo waitForFinish() throws InterruptedException {\n        this.isWaiting = true;\n        this.markForCleanUp = false;\n        this.lock.wait();\n        this.isWaiting = false;\n        final EventInfo object = this.eventInfo;\n        this.eventInfo = null;\n        return object;\n    }","id":43565,"modified_method":"/**\n     * Wait for the job to be finished.\n     * This is called if the queue is ordered.\n     */\n    public EventInfo waitForFinish() throws InterruptedException {\n        this.isWaiting = true;\n        this.markForCleanUp = false;\n        this.lock.wait();\n        this.isWaiting = false;\n        final EventInfo object = this.eventInfo;\n        this.eventInfo = null;\n        return object;\n    }","commit_id":"ed601bc31a6efda1c1291454201ea367d7d216f7","url":"https://github.com/apache/sling"},{"original_method":"public void notifyFinish(EventInfo i) {\n        this.eventInfo = i;\n        this.lock.notify();\n    }","id":43566,"modified_method":"/**\n     * Notify a finished job - for ordered queues\n     */\n    public void notifyFinish(EventInfo i) {\n        this.eventInfo = i;\n        this.lock.notify();\n    }","commit_id":"ed601bc31a6efda1c1291454201ea367d7d216f7","url":"https://github.com/apache/sling"},{"original_method":"public void markForCleanUp() {\n        if ( !this.isWaiting ) {\n            this.markForCleanUp = true;\n        }\n    }","id":43567,"modified_method":"/**\n     * Mark this queue for cleanup.\n     */\n    public void markForCleanUp() {\n        if ( !this.isWaiting ) {\n            this.markForCleanUp = true;\n        }\n    }","commit_id":"ed601bc31a6efda1c1291454201ea367d7d216f7","url":"https://github.com/apache/sling"},{"original_method":"public boolean isMarkedForCleanUp() {\n        return !this.isWaiting && this.markForCleanUp;\n    }","id":43568,"modified_method":"/**\n     * Check if this queue is marked for cleanup\n     */\n    public boolean isMarkedForCleanUp() {\n        return !this.isWaiting && this.markForCleanUp;\n    }","commit_id":"ed601bc31a6efda1c1291454201ea367d7d216f7","url":"https://github.com/apache/sling"},{"original_method":"private void checkForNotify(final Event job, final EventInfo info) {\n        if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n            // we know the queue exists\n            final JobBlockingQueue jobQueue;\n            synchronized ( this.jobQueues ) {\n                jobQueue = this.jobQueues.get(job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME));\n            }\n            synchronized ( jobQueue.getLock()) {\n                EventInfo reprocessInfo = null;\n                if ( info != null ) {\n                    reprocessInfo = jobQueue.reschedule(info, this.scheduler);\n                }\n                jobQueue.notifyFinish(reprocessInfo);\n            }\n        }\n    }","id":43569,"modified_method":"private void checkForNotify(final Event job, final EventInfo info) {\n        if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n            // we know the queue exists\n            final JobBlockingQueue jobQueue;\n            synchronized ( this.jobQueues ) {\n                jobQueue = this.jobQueues.get(job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME));\n            }\n            synchronized ( jobQueue.getLock()) {\n                EventInfo reprocessInfo = null;\n                if ( info != null ) {\n                    reprocessInfo = jobQueue.reschedule(info, this.scheduler);\n                }\n                if ( jobQueue.isOrdered() ) {\n                    jobQueue.notifyFinish(reprocessInfo);\n                } else {\n                    jobQueue.freeSlot();\n                }\n            }\n        }\n    }","commit_id":"ed601bc31a6efda1c1291454201ea367d7d216f7","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This method runs in the background and processes the local queue.\n     */\n    protected void runInBackground() throws RepositoryException {\n        this.backgroundSession = this.createSession();\n        this.backgroundSession.getWorkspace().getObservationManager()\n                .addEventListener(this,\n                                  javax.jcr.observation.Event.PROPERTY_REMOVED\n                                    |javax.jcr.observation.Event.NODE_REMOVED,\n                                  this.repositoryPath,\n                                  true,\n                                  null,\n                                  new String[] {this.getEventNodeType()},\n                                  true);\n        // load unprocessed jobs from repository\n        if ( this.running ) {\n            logger.info(\"Apache Sling Job Event Handler started.\");\n            logger.debug(\"Job Handler Configuration: (sleepTime={} secs, maxJobRetries={}, waitForAck={} ms, maximumParallelJobs={}, cleanupPeriod={} min)\",\n                    new Object[] {sleepTime, maxJobRetries,waitForAckMs,maximumParallelJobs,cleanupPeriod});\n        } else {\n            final ComponentContext ctx = this.componentContext;\n            // deactivate\n            if ( ctx != null ) {\n                logger.info(\"Deactivating component {} due to errors during startup.\", ctx.getProperties().get(Constants.SERVICE_ID));\n                final String name = (String) componentContext.getProperties().get(\n                    ComponentConstants.COMPONENT_NAME);\n                ctx.disableComponent(name);\n            }\n        }\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n\n            if ( info != null && this.running ) {\n                logger.debug(\"Processing new job {}\", info.event);\n                // check for local only jobs and remove them from the queue if they're meant\n                // for another application node\n                final String appId = (String)info.event.getProperty(EventUtil.PROPERTY_APPLICATION);\n                if ( info.event.getProperty(EventUtil.PROPERTY_JOB_RUN_LOCAL) != null\n                    && appId != null && !this.applicationId.equals(appId) ) {\n                    logger.debug(\"Discarding job {} : local job for a different application node.\", info.event);\n                    info = null;\n                }\n\n                // check if we should put this into a separate queue\n                if ( info != null && info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                    final String queueName = (String)info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME);\n                    synchronized ( this.jobQueues ) {\n                        logger.debug(\"Queuing job {} into queue {}.\", info.event, queueName);\n                        BlockingQueue<EventInfo> jobQueue = this.jobQueues.get(queueName);\n                        if ( jobQueue == null ) {\n                            final boolean orderedQueue = info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_ORDERED) != null;\n                            final JobBlockingQueue jq = new JobBlockingQueue(queueName, orderedQueue, this.logger);\n                            jobQueue = jq;\n                            this.jobQueues.put(queueName, jq);\n                            // Start background thread\n                            this.threadPool.execute(new Runnable() {\n\n                                /**\n                                 * @see java.lang.Runnable#run()\n                                 */\n                                public void run() {\n                                    while ( running && !jq.isFinished() ) {\n                                        logger.info(\"Starting job queue {}\", queueName);\n                                        try {\n                                            runJobQueue(queueName, jq);\n                                        } catch (Throwable t) {\n                                            logger.error(\"Job queue stopped with exception: \" + t.getMessage() + \". Restarting.\", t);\n                                        }\n                                    }\n                                }\n\n                            });\n                        }\n                        try {\n                            jobQueue.put(info);\n                        } catch (InterruptedException e) {\n                            // this should never happen\n                            this.ignoreException(e);\n                        }\n                    }\n                    // don't process this here\n                    info = null;\n                }\n\n                // if we still have a job, process it\n                if ( info != null ) {\n                    if ( this.executeJob(info, null) == Status.RESCHEDULE ) {\n                        this.putBackIntoMainQueue(info, true);\n                    }\n                }\n            }\n        }\n    }","id":43570,"modified_method":"/**\n     * This method runs in the background and processes the local queue.\n     */\n    protected void runInBackground() throws RepositoryException {\n        this.backgroundSession = this.createSession();\n        this.backgroundSession.getWorkspace().getObservationManager()\n                .addEventListener(this,\n                                  javax.jcr.observation.Event.PROPERTY_REMOVED\n                                    |javax.jcr.observation.Event.NODE_REMOVED,\n                                  this.repositoryPath,\n                                  true,\n                                  null,\n                                  new String[] {this.getEventNodeType()},\n                                  true);\n        // load unprocessed jobs from repository\n        if ( this.running ) {\n            logger.info(\"Apache Sling Job Event Handler started.\");\n            logger.debug(\"Job Handler Configuration: (sleepTime={} secs, maxJobRetries={}, waitForAck={} ms, maximumParallelJobs={}, cleanupPeriod={} min)\",\n                    new Object[] {sleepTime, maxJobRetries,waitForAckMs,maximumParallelJobs,cleanupPeriod});\n        } else {\n            final ComponentContext ctx = this.componentContext;\n            // deactivate\n            if ( ctx != null ) {\n                logger.info(\"Deactivating component {} due to errors during startup.\", ctx.getProperties().get(Constants.SERVICE_ID));\n                final String name = (String) componentContext.getProperties().get(\n                    ComponentConstants.COMPONENT_NAME);\n                ctx.disableComponent(name);\n            }\n        }\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n\n            if ( info != null && this.running ) {\n                logger.debug(\"Processing new job {}\", info.event);\n                // check for local only jobs and remove them from the queue if they're meant\n                // for another application node\n                final String appId = (String)info.event.getProperty(EventUtil.PROPERTY_APPLICATION);\n                if ( info.event.getProperty(EventUtil.PROPERTY_JOB_RUN_LOCAL) != null\n                    && appId != null && !this.applicationId.equals(appId) ) {\n                    logger.debug(\"Discarding job {} : local job for a different application node.\", info.event);\n                    info = null;\n                }\n\n                // check if we should put this into a separate queue\n                if ( info != null && info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                    final String queueName = (String)info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME);\n                    synchronized ( this.jobQueues ) {\n                        logger.debug(\"Queuing job {} into queue {}.\", info.event, queueName);\n                        BlockingQueue<EventInfo> jobQueue = this.jobQueues.get(queueName);\n                        if ( jobQueue == null ) {\n                            final boolean orderedQueue = info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_ORDERED) != null;\n                            final JobBlockingQueue jq = new JobBlockingQueue(queueName, orderedQueue, this.logger);\n                            jobQueue = jq;\n                            this.jobQueues.put(queueName, jq);\n                            // Start background thread\n                            this.threadPool.execute(new Runnable() {\n\n                                /**\n                                 * @see java.lang.Runnable#run()\n                                 */\n                                public void run() {\n                                    while ( running && !jq.isFinished() ) {\n                                        logger.info(\"Starting {}job queue {}\", (orderedQueue ? \"ordered \" : \"\"), queueName);\n                                        try {\n                                            runJobQueue(queueName, jq);\n                                        } catch (Throwable t) {\n                                            logger.error(\"Job queue stopped with exception: \" + t.getMessage() + \". Restarting.\", t);\n                                        }\n                                    }\n                                }\n\n                            });\n                        }\n                        try {\n                            jobQueue.put(info);\n                        } catch (InterruptedException e) {\n                            // this should never happen\n                            this.ignoreException(e);\n                        }\n                    }\n                    // don't process this here\n                    info = null;\n                }\n\n                // if we still have a job, process it\n                if ( info != null ) {\n                    if ( this.executeJob(info, null) == Status.RESCHEDULE ) {\n                        this.putBackIntoMainQueue(info, true);\n                    }\n                }\n            }\n        }\n    }","commit_id":"ed601bc31a6efda1c1291454201ea367d7d216f7","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Execute a job queue\n     * @param queueName The name of the job queue\n     * @param jobQueue The job queue\n     */\n    private void runJobQueue(final String queueName, final JobBlockingQueue jobQueue) {\n        EventInfo info = null;\n        while ( this.running && !jobQueue.isFinished() ) {\n            if ( info == null ) {\n                // so let's wait/get the next job from the queue\n                try {\n                    info = jobQueue.take();\n                } catch (InterruptedException e) {\n                    // we ignore this\n                    this.ignoreException(e);\n                }\n            }\n\n            if ( info != null && this.running && !jobQueue.isFinished() ) {\n                synchronized ( jobQueue.getLock()) {\n                    final EventInfo processInfo = info;\n                    info = null;\n                    final Status status = this.executeJob(processInfo, jobQueue);\n                    if ( status == Status.SUCCESS ) {\n                        try {\n                            info = jobQueue.waitForFinish();\n                        } catch (InterruptedException e) {\n                            this.ignoreException(e);\n                        }\n                    } else if ( status == Status.RESCHEDULE ) {\n                        info = jobQueue.reschedule(processInfo, this.scheduler);\n                    }\n                }\n            }\n        }\n    }","id":43571,"modified_method":"/**\n     * Execute a job queue\n     * @param queueName The name of the job queue\n     * @param jobQueue The job queue\n     */\n    private void runJobQueue(final String queueName, final JobBlockingQueue jobQueue) {\n        EventInfo info = null;\n        while ( this.running && !jobQueue.isFinished() ) {\n            if ( info == null ) {\n                // so let's wait/get the next job from the queue\n                try {\n                    info = jobQueue.take();\n                } catch (InterruptedException e) {\n                    // we ignore this\n                    this.ignoreException(e);\n                }\n            }\n\n            if ( info != null && this.running && !jobQueue.isFinished() ) {\n                final EventInfo processInfo = info;\n                info = null;\n                if ( jobQueue.isOrdered() ) {\n                    // if we are ordered we simply wait for the finish\n                    synchronized ( jobQueue.getLock()) {\n                        final Status status = this.executeJob(processInfo, jobQueue);\n                        if ( status == Status.SUCCESS ) {\n                            try {\n                                info = jobQueue.waitForFinish();\n                            } catch (InterruptedException e) {\n                                this.ignoreException(e);\n                            }\n                        } else if ( status == Status.RESCHEDULE ) {\n                            info = jobQueue.reschedule(processInfo, this.scheduler);\n                        }\n                    }\n                } else {\n                    final int maxJobs = ParallelInfo.getMaxNumberOfParallelJobs(processInfo.event);\n                    synchronized ( jobQueue.getLock() ) {\n                        try {\n                            jobQueue.acquireSlot(maxJobs);\n                        } catch (InterruptedException e) {\n                            this.ignoreException(e);\n                        }\n                    }\n                    if ( this.running && !jobQueue.isFinished() ) {\n                        final Status status = this.executeJob(processInfo, jobQueue);\n                        if ( status == Status.RESCHEDULE ) {\n                            jobQueue.reschedule(processInfo, this.scheduler);\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"ed601bc31a6efda1c1291454201ea367d7d216f7","url":"https://github.com/apache/sling"},{"original_method":"public void notifyFinish(EventInfo i) {\n            this.eventInfo = i;\n            synchronized ( this.lock ) {\n                this.lock.notify();\n            }\n        }","id":43572,"modified_method":"public void notifyFinish(EventInfo i) {\n            this.eventInfo = i;\n            this.lock.notify();\n        }","commit_id":"ed2411d9bb2c321cc2f666c9aa1bcf99f796a0e3","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Execute a job queue\n     * @param queueName The name of the job queue\n     * @param jobQueue The job queue\n     */\n    private void runJobQueue(final String queueName, final JobBlockingQueue jobQueue) {\n        EventInfo info = null;\n        while ( this.running ) {\n            if ( info == null ) {\n                // so let's wait/get the next job from the queue\n                try {\n                    info = jobQueue.take();\n                } catch (InterruptedException e) {\n                    // we ignore this\n                    this.ignoreException(e);\n                }\n            }\n\n            if ( info != null && this.running ) {\n                final EventInfo processInfo = info;\n                info = null;\n                if ( this.executeJob(processInfo, jobQueue) ) {\n                    EventInfo newInfo = null;\n                    try {\n                        newInfo = jobQueue.waitForFinish();\n                    } catch (InterruptedException e) {\n                        this.ignoreException(e);\n                    }\n                    // if we have an info, this is a reschedule\n                    if ( newInfo != null ) {\n                        final EventInfo newEventInfo = newInfo;\n                        final Event job = newInfo.event;\n\n                        // is this an ordered queue?\n                        final boolean orderedQueue = job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_ORDERED) != null;\n\n                        if ( orderedQueue ) {\n                            // we just sleep for the delay time - if none, we continue and retry\n                            // this job again\n                            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY) != null ) {\n                                final long delay = (Long)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY);\n                                try {\n                                    Thread.sleep(delay);\n                                } catch (InterruptedException e) {\n                                    this.ignoreException(e);\n                                }\n                            }\n                            info = newInfo;\n                        } else {\n                            // delay rescheduling?\n                            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY) != null ) {\n                                final long delay = (Long)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY);\n                                final Date fireDate = new Date();\n                                fireDate.setTime(System.currentTimeMillis() + delay);\n\n                                final Runnable t = new Runnable() {\n                                    public void run() {\n                                        try {\n                                            jobQueue.put(newEventInfo);\n                                        } catch (InterruptedException e) {\n                                            // this should never happen\n                                            ignoreException(e);\n                                        }\n                                    }\n                                };\n                                try {\n                                    this.scheduler.fireJobAt(null, t, null, fireDate);\n                                } catch (Exception e) {\n                                    // we ignore the exception and just put back the job in the queue\n                                    ignoreException(e);\n                                    t.run();\n                                }\n                            } else {\n                                // put directly into queue\n                                try {\n                                    jobQueue.put(newInfo);\n                                } catch (InterruptedException e) {\n                                    // this should never happen\n                                    this.ignoreException(e);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","id":43573,"modified_method":"/**\n     * Execute a job queue\n     * @param queueName The name of the job queue\n     * @param jobQueue The job queue\n     */\n    private void runJobQueue(final String queueName, final JobBlockingQueue jobQueue) {\n        EventInfo info = null;\n        while ( this.running ) {\n            if ( info == null ) {\n                // so let's wait/get the next job from the queue\n                try {\n                    info = jobQueue.take();\n                } catch (InterruptedException e) {\n                    // we ignore this\n                    this.ignoreException(e);\n                }\n            }\n\n            if ( info != null && this.running ) {\n                synchronized ( jobQueue.getLock()) {\n                    final EventInfo processInfo = info;\n                    info = null;\n                    if ( this.executeJob(processInfo, jobQueue) ) {\n                        EventInfo newInfo = null;\n                        try {\n                            newInfo = jobQueue.waitForFinish();\n                        } catch (InterruptedException e) {\n                            this.ignoreException(e);\n                        }\n                        // if we have an info, this is a reschedule\n                        if ( newInfo != null ) {\n                            final EventInfo newEventInfo = newInfo;\n                            final Event job = newInfo.event;\n\n                            // is this an ordered queue?\n                            final boolean orderedQueue = job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_ORDERED) != null;\n\n                            if ( orderedQueue ) {\n                                // we just sleep for the delay time - if none, we continue and retry\n                                // this job again\n                                if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY) != null ) {\n                                    final long delay = (Long)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY);\n                                    try {\n                                        Thread.sleep(delay);\n                                    } catch (InterruptedException e) {\n                                        this.ignoreException(e);\n                                    }\n                                }\n                                info = newInfo;\n                            } else {\n                                // delay rescheduling?\n                                if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY) != null ) {\n                                    final long delay = (Long)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY);\n                                    final Date fireDate = new Date();\n                                    fireDate.setTime(System.currentTimeMillis() + delay);\n\n                                    final Runnable t = new Runnable() {\n                                        public void run() {\n                                            try {\n                                                jobQueue.put(newEventInfo);\n                                            } catch (InterruptedException e) {\n                                                // this should never happen\n                                                ignoreException(e);\n                                            }\n                                        }\n                                    };\n                                    try {\n                                        this.scheduler.fireJobAt(null, t, null, fireDate);\n                                    } catch (Exception e) {\n                                        // we ignore the exception and just put back the job in the queue\n                                        ignoreException(e);\n                                        t.run();\n                                    }\n                                } else {\n                                    // put directly into queue\n                                    try {\n                                        jobQueue.put(newInfo);\n                                    } catch (InterruptedException e) {\n                                        // this should never happen\n                                        this.ignoreException(e);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"ed2411d9bb2c321cc2f666c9aa1bcf99f796a0e3","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This method runs in the background and processes the local queue.\n     */\n    protected void runInBackground() throws RepositoryException {\n        this.backgroundSession = this.createSession();\n        this.backgroundSession.getWorkspace().getObservationManager()\n                .addEventListener(this,\n                                  javax.jcr.observation.Event.PROPERTY_REMOVED\n                                    |javax.jcr.observation.Event.NODE_REMOVED,\n                                  this.repositoryPath,\n                                  true,\n                                  null,\n                                  new String[] {this.getEventNodeType()},\n                                  true);\n        // give the system some time to start\n        try {\n            Thread.sleep(1000 * 60 * 2); // 2min\n        } catch (InterruptedException e) {\n            this.ignoreException(e);\n        }\n        // load unprocessed jobs from repository\n        if ( this.running ) {\n            this.loadJobs();\n        }\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n\n            if ( info != null && this.running ) {\n                // check for local only jobs and remove them from the queue if they're meant\n                // for another application node\n                final String appId = (String)info.event.getProperty(EventUtil.PROPERTY_APPLICATION);\n                if ( info.event.getProperty(EventUtil.PROPERTY_JOB_RUN_LOCAL) != null\n                    && appId != null && !this.applicationId.equals(appId) ) {\n                    info = null;\n                }\n\n                // check if we should put this into a separate queue\n                if ( info != null && info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                    final String queueName = (String)info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME);\n                    synchronized ( this.jobQueues ) {\n                        BlockingQueue<EventInfo> jobQueue = this.jobQueues.get(queueName);\n                        if ( jobQueue == null ) {\n                            final JobBlockingQueue jq = new JobBlockingQueue();\n                            jobQueue = jq;\n                            this.jobQueues.put(queueName, jq);\n                            // Start background thread\n                            this.threadPool.execute(new Runnable() {\n\n                                /**\n                                 * @see java.lang.Runnable#run()\n                                 */\n                                public void run() {\n                                    runJobQueue(queueName, jq);\n                                }\n\n                            });\n                        }\n                        try {\n                            jobQueue.put(info);\n                        } catch (InterruptedException e) {\n                            // this should never happen\n                            this.ignoreException(e);\n                        }\n                    }\n                    // don't process this here\n                    info = null;\n                }\n\n                // if we still have a job, process it\n                if ( info != null ) {\n                    this.executeJob(info, null);\n                }\n            }\n        }\n    }","id":43574,"modified_method":"/**\n     * This method runs in the background and processes the local queue.\n     */\n    protected void runInBackground() throws RepositoryException {\n        this.backgroundSession = this.createSession();\n        this.backgroundSession.getWorkspace().getObservationManager()\n                .addEventListener(this,\n                                  javax.jcr.observation.Event.PROPERTY_REMOVED\n                                    |javax.jcr.observation.Event.NODE_REMOVED,\n                                  this.repositoryPath,\n                                  true,\n                                  null,\n                                  new String[] {this.getEventNodeType()},\n                                  true);\n        // give the system some time to start\n        try {\n            Thread.sleep(1000 * 60 * 1); // 1min\n        } catch (InterruptedException e) {\n            this.ignoreException(e);\n        }\n        // load unprocessed jobs from repository\n        if ( this.running ) {\n            this.loadJobs();\n        }\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n\n            if ( info != null && this.running ) {\n                // check for local only jobs and remove them from the queue if they're meant\n                // for another application node\n                final String appId = (String)info.event.getProperty(EventUtil.PROPERTY_APPLICATION);\n                if ( info.event.getProperty(EventUtil.PROPERTY_JOB_RUN_LOCAL) != null\n                    && appId != null && !this.applicationId.equals(appId) ) {\n                    info = null;\n                }\n\n                // check if we should put this into a separate queue\n                if ( info != null && info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                    final String queueName = (String)info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME);\n                    synchronized ( this.jobQueues ) {\n                        BlockingQueue<EventInfo> jobQueue = this.jobQueues.get(queueName);\n                        if ( jobQueue == null ) {\n                            final JobBlockingQueue jq = new JobBlockingQueue();\n                            jobQueue = jq;\n                            this.jobQueues.put(queueName, jq);\n                            // Start background thread\n                            this.threadPool.execute(new Runnable() {\n\n                                /**\n                                 * @see java.lang.Runnable#run()\n                                 */\n                                public void run() {\n                                    runJobQueue(queueName, jq);\n                                }\n\n                            });\n                        }\n                        try {\n                            jobQueue.put(info);\n                        } catch (InterruptedException e) {\n                            // this should never happen\n                            this.ignoreException(e);\n                        }\n                    }\n                    // don't process this here\n                    info = null;\n                }\n\n                // if we still have a job, process it\n                if ( info != null ) {\n                    this.executeJob(info, null);\n                }\n            }\n        }\n    }","commit_id":"ed2411d9bb2c321cc2f666c9aa1bcf99f796a0e3","url":"https://github.com/apache/sling"},{"original_method":"public EventInfo waitForFinish() throws InterruptedException {\n            synchronized ( this.lock ) {\n                this.lock.wait();\n            }\n            final EventInfo object = this.eventInfo;\n            this.eventInfo = null;\n            return object;\n        }","id":43575,"modified_method":"public EventInfo waitForFinish() throws InterruptedException {\n            this.lock.wait();\n            final EventInfo object = this.eventInfo;\n            this.eventInfo = null;\n            return object;\n        }","commit_id":"ed2411d9bb2c321cc2f666c9aa1bcf99f796a0e3","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This is a notification from the component which processed the job.\n     *\n     * @see org.apache.sling.event.EventUtil.JobStatusNotifier#finishedJob(org.osgi.service.event.Event, String, boolean)\n     */\n    public boolean finishedJob(Event job, String eventNodePath, boolean shouldReschedule) {\n        boolean reschedule = shouldReschedule;\n        if ( shouldReschedule ) {\n            // check if we exceeded the number of retries\n            int retries = this.maxJobRetries;\n            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRIES) != null ) {\n                retries = (Integer) job.getProperty(EventUtil.PROPERTY_JOB_RETRIES);\n            }\n            int retryCount = 0;\n            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                retryCount = (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT);\n            }\n            retryCount++;\n            if ( retries != -1 && retryCount > retries ) {\n                reschedule = false;\n            }\n            if ( reschedule ) {\n                // update event with retry count and retries\n                final Dictionary<String, Object> newProperties = new EventPropertiesMap(job);\n                newProperties.put(EventUtil.PROPERTY_JOB_RETRY_COUNT, retryCount);\n                newProperties.put(EventUtil.PROPERTY_JOB_RETRIES, retries);\n                job = new Event(job.getTopic(), newProperties);\n            }\n        }\n        final boolean parallelProcessing = job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null\n                                        || job.getProperty(EventUtil.PROPERTY_JOB_PARALLEL) != null;\n        // we have to use the same session for unlocking that we used for locking!\n        synchronized ( this.backgroundSession ) {\n            try {\n                this.backgroundSession.refresh(false);\n                // check if the job has been cancelled\n                if ( !this.backgroundSession.itemExists(eventNodePath) ) {\n                    return true;\n                }\n                final Node eventNode = (Node) this.backgroundSession.getItem(eventNodePath);\n                boolean unlock = true;\n                try {\n                    if ( !reschedule ) {\n                        synchronized ( this.deletedJobs ) {\n                            this.deletedJobs.add(eventNodePath);\n                        }\n                        // unlock node\n                        try {\n                            eventNode.unlock();\n                        } catch (RepositoryException e) {\n                            // if unlock fails, we silently ignore this\n                            this.ignoreException(e);\n                        }\n                        unlock = false;\n                        final String jobId = (String)job.getProperty(EventUtil.PROPERTY_JOB_ID);\n                        if ( jobId == null ) {\n                            // remove node from repository if no job is set\n                            final Node parentNode = eventNode.getParent();\n                            eventNode.remove();\n                            parentNode.save();\n                        } else {\n                            eventNode.setProperty(EventHelper.NODE_PROPERTY_FINISHED, Calendar.getInstance());\n                            eventNode.save();\n                        }\n                    }\n                } catch (RepositoryException re) {\n                    // if an exception occurs, we just log\n                    this.logger.error(\"Exception during job finishing.\", re);\n                } finally {\n                    if ( !parallelProcessing) {\n                        final String jobTopic = (String)job.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n                        synchronized ( this.processingMap ) {\n                            this.processingMap.put(jobTopic, Boolean.FALSE);\n                        }\n                    }\n                    if ( unlock ) {\n                        synchronized ( this.deletedJobs ) {\n                            this.deletedJobs.add(eventNodePath);\n                        }\n                        // unlock node\n                        try {\n                            eventNode.unlock();\n                        } catch (RepositoryException e) {\n                            // if unlock fails, we silently ignore this\n                            this.ignoreException(e);\n                        }\n                    }\n                }\n                if ( reschedule ) {\n                    // update retry count and retries in the repository\n                    try {\n                        eventNode.setProperty(EventUtil.PROPERTY_JOB_RETRIES, (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRIES));\n                        eventNode.setProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT, (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT));\n                        eventNode.save();\n                    } catch (RepositoryException re) {\n                        // if an exception occurs, we just log\n                        this.logger.error(\"Exception during job updating job rescheduling information.\", re);\n                    }\n                    final EventInfo info = new EventInfo();\n                    try {\n                        info.event = job;\n                        info.nodePath = eventNode.getPath();\n                    } catch (RepositoryException e) {\n                        // this should never happen\n                        this.ignoreException(e);\n                    }\n                    // if this is an own job queue, we simply signal the queue to continue\n                    // it will pick up the event and either reschedule or wait\n                    if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                        // we know the queue exists\n                        final JobBlockingQueue jobQueue;\n                        synchronized ( this.jobQueues ) {\n                            jobQueue = this.jobQueues.get(job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME));\n                        }\n                        jobQueue.notifyFinish(info);\n                    } else {\n\n                        // delay rescheduling?\n                        if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY) != null ) {\n                            final long delay = (Long)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY);\n                            final Date fireDate = new Date();\n                            fireDate.setTime(System.currentTimeMillis() + delay);\n\n                            final Runnable t = new Runnable() {\n                                public void run() {\n                                    try {\n                                        queue.put(info);\n                                    } catch (InterruptedException e) {\n                                        // this should never happen\n                                        ignoreException(e);\n                                    }\n                                }\n                            };\n                            try {\n                                this.scheduler.fireJobAt(null, t, null, fireDate);\n                            } catch (Exception e) {\n                                // we ignore the exception and just put back the job in the queue\n                                ignoreException(e);\n                                t.run();\n                            }\n                        } else {\n                            // put directly into queue\n                            try {\n                                queue.put(info);\n                            } catch (InterruptedException e) {\n                                // this should never happen\n                                this.ignoreException(e);\n                            }\n                        }\n                    }\n                } else {\n                    // if this is an own job queue, we simply signal the queue to continue\n                    // it will pick up the event continue with the next event\n                    if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                        // we know the queue exists\n                        final JobBlockingQueue jobQueue;\n                        synchronized ( this.jobQueues ) {\n                            jobQueue = this.jobQueues.get(job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME));\n                        }\n                        jobQueue.notifyFinish(null);\n                    }\n                }\n                if ( !shouldReschedule ) {\n                    return true;\n                }\n                return reschedule;\n            } catch (RepositoryException re) {\n                this.logger.error(\"Unable to create new session.\", re);\n                return false;\n            }\n        }\n    }","id":43576,"modified_method":"/**\n     * This is a notification from the component which processed the job.\n     *\n     * @see org.apache.sling.event.EventUtil.JobStatusNotifier#finishedJob(org.osgi.service.event.Event, String, boolean)\n     */\n    public boolean finishedJob(Event job, String eventNodePath, boolean shouldReschedule) {\n        boolean reschedule = shouldReschedule;\n        if ( shouldReschedule ) {\n            // check if we exceeded the number of retries\n            int retries = this.maxJobRetries;\n            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRIES) != null ) {\n                retries = (Integer) job.getProperty(EventUtil.PROPERTY_JOB_RETRIES);\n            }\n            int retryCount = 0;\n            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                retryCount = (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT);\n            }\n            retryCount++;\n            if ( retries != -1 && retryCount > retries ) {\n                reschedule = false;\n            }\n            if ( reschedule ) {\n                // update event with retry count and retries\n                final Dictionary<String, Object> newProperties = new EventPropertiesMap(job);\n                newProperties.put(EventUtil.PROPERTY_JOB_RETRY_COUNT, retryCount);\n                newProperties.put(EventUtil.PROPERTY_JOB_RETRIES, retries);\n                job = new Event(job.getTopic(), newProperties);\n            }\n        }\n        final boolean parallelProcessing = job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null\n                                        || job.getProperty(EventUtil.PROPERTY_JOB_PARALLEL) != null;\n        // we have to use the same session for unlocking that we used for locking!\n        synchronized ( this.backgroundSession ) {\n            try {\n                this.backgroundSession.refresh(false);\n                // check if the job has been cancelled\n                if ( !this.backgroundSession.itemExists(eventNodePath) ) {\n                    return true;\n                }\n                final Node eventNode = (Node) this.backgroundSession.getItem(eventNodePath);\n                boolean unlock = true;\n                try {\n                    if ( !reschedule ) {\n                        synchronized ( this.deletedJobs ) {\n                            this.deletedJobs.add(eventNodePath);\n                        }\n                        // unlock node\n                        try {\n                            eventNode.unlock();\n                        } catch (RepositoryException e) {\n                            // if unlock fails, we silently ignore this\n                            this.ignoreException(e);\n                        }\n                        unlock = false;\n                        final String jobId = (String)job.getProperty(EventUtil.PROPERTY_JOB_ID);\n                        if ( jobId == null ) {\n                            // remove node from repository if no job is set\n                            final Node parentNode = eventNode.getParent();\n                            eventNode.remove();\n                            parentNode.save();\n                        } else {\n                            eventNode.setProperty(EventHelper.NODE_PROPERTY_FINISHED, Calendar.getInstance());\n                            eventNode.save();\n                        }\n                    }\n                } catch (RepositoryException re) {\n                    // if an exception occurs, we just log\n                    this.logger.error(\"Exception during job finishing.\", re);\n                } finally {\n                    if ( !parallelProcessing) {\n                        final String jobTopic = (String)job.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n                        synchronized ( this.processingMap ) {\n                            this.processingMap.put(jobTopic, Boolean.FALSE);\n                        }\n                    }\n                    if ( unlock ) {\n                        synchronized ( this.deletedJobs ) {\n                            this.deletedJobs.add(eventNodePath);\n                        }\n                        // unlock node\n                        try {\n                            eventNode.unlock();\n                        } catch (RepositoryException e) {\n                            // if unlock fails, we silently ignore this\n                            this.ignoreException(e);\n                        }\n                    }\n                }\n                if ( reschedule ) {\n                    // update retry count and retries in the repository\n                    try {\n                        eventNode.setProperty(EventUtil.PROPERTY_JOB_RETRIES, (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRIES));\n                        eventNode.setProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT, (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT));\n                        eventNode.save();\n                    } catch (RepositoryException re) {\n                        // if an exception occurs, we just log\n                        this.logger.error(\"Exception during job updating job rescheduling information.\", re);\n                    }\n                    final EventInfo info = new EventInfo();\n                    try {\n                        info.event = job;\n                        info.nodePath = eventNode.getPath();\n                    } catch (RepositoryException e) {\n                        // this should never happen\n                        this.ignoreException(e);\n                    }\n                    // if this is an own job queue, we simply signal the queue to continue\n                    // it will pick up the event and either reschedule or wait\n                    if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                        // we know the queue exists\n                        final JobBlockingQueue jobQueue;\n                        synchronized ( this.jobQueues ) {\n                            jobQueue = this.jobQueues.get(job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME));\n                        }\n                        synchronized ( jobQueue.getLock()) {\n                            jobQueue.notifyFinish(info);\n                        }\n                    } else {\n\n                        // delay rescheduling?\n                        if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY) != null ) {\n                            final long delay = (Long)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY);\n                            final Date fireDate = new Date();\n                            fireDate.setTime(System.currentTimeMillis() + delay);\n\n                            final Runnable t = new Runnable() {\n                                public void run() {\n                                    try {\n                                        queue.put(info);\n                                    } catch (InterruptedException e) {\n                                        // this should never happen\n                                        ignoreException(e);\n                                    }\n                                }\n                            };\n                            try {\n                                this.scheduler.fireJobAt(null, t, null, fireDate);\n                            } catch (Exception e) {\n                                // we ignore the exception and just put back the job in the queue\n                                ignoreException(e);\n                                t.run();\n                            }\n                        } else {\n                            // put directly into queue\n                            try {\n                                queue.put(info);\n                            } catch (InterruptedException e) {\n                                // this should never happen\n                                this.ignoreException(e);\n                            }\n                        }\n                    }\n                } else {\n                    // if this is an own job queue, we simply signal the queue to continue\n                    // it will pick up the event continue with the next event\n                    if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                        // we know the queue exists\n                        final JobBlockingQueue jobQueue;\n                        synchronized ( this.jobQueues ) {\n                            jobQueue = this.jobQueues.get(job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME));\n                        }\n                        synchronized ( jobQueue.getLock()) {\n                            jobQueue.notifyFinish(null);\n                        }\n                    }\n                }\n                if ( !shouldReschedule ) {\n                    return true;\n                }\n                return reschedule;\n            } catch (RepositoryException re) {\n                this.logger.error(\"Unable to create new session.\", re);\n                return false;\n            }\n        }\n    }","commit_id":"ed2411d9bb2c321cc2f666c9aa1bcf99f796a0e3","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic Map<String, String> getGroupRoles(CourseManagementService cmService, String userEid) {\n\t\tMap<String, String> sectionRoles = new HashMap<String, String>();\n\n\t\t// Don't bother doing anything if the integration is configured to ignore\n\t\t// CourseOffering memberships.\n\t\tif ((roleMap == null) || (roleMap.size() == 0)) {\n\t\t\treturn sectionRoles;\n\t\t}\n\n\t\t// Find all of the course offerings for which this user is a member\n\t\tMap<String, String> courseOfferingRoles = cmService.findCourseOfferingRoles(userEid);\n\t\tif(log.isDebugEnabled()) log.debug(\"Found \" + courseOfferingRoles.size() + \" course offering roles for \" + userEid);\n\n\t\t// Add all of the equivalent course offerings-> role mappings for this user\n\t\tSet<String> coEids = new HashSet<String>(courseOfferingRoles.keySet());\n\t\tfor(String coEid : coEids) {\n\t\t\tSet<CourseOffering> equivOfferings = cmService.getEquivalentCourseOfferings(coEid);\n\t\t\tfor(Iterator<CourseOffering> equivIter = equivOfferings.iterator(); equivIter.hasNext();) {\n\t\t\t\tCourseOffering equiv = equivIter.next();\n\t\t\t\t// Use the role in the original course offering for this equivalent course offering\n\t\t\t\tcourseOfferingRoles.put(equiv.getEid(), courseOfferingRoles.get(coEid));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Iterator<String> coIter = courseOfferingRoles.keySet().iterator(); coIter.hasNext();) {\n\t\t\tString coEid = coIter.next();\n\t\t\tString coRole = courseOfferingRoles.get(coEid);\n\t\t\t\n\t\t\t// If this role shouldn't be part of the site, ignore the membership in this course offering\n\t\t\tString sakaiRole = convertRole(coRole);\n\t\t\tif(sakaiRole == null) {\n\t\t\t\tif(log.isDebugEnabled()) log.debug(\"Course offering role \" + coRole + \" is not mapped to a sakai role.  Skipping this membership.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(log.isDebugEnabled()) log.debug(userEid + \" has role=\" + coRole + \" in course offering \" + coEid);\n\t\t\t// Get the sections in each course offering\n\t\t\tSet<Section> sections = cmService.getSections(coEid);\n\t\t\tfor(Iterator<Section> secIter = sections.iterator(); secIter.hasNext();) {\n\t\t\t\t// Add the section EIDs and the converted *CourseOffering* role to the sectionRoles map\n\t\t\t\tSection section = secIter.next();\n\t\t\t\tsectionRoles.put(section.getEid(), sakaiRole);\n\t\t\t}\n\t\t}\n\t\treturn sectionRoles;\n\t}","id":43577,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic Map<String, String> getGroupRoles(CourseManagementService cmService, String userEid) {\n\t\tMap<String, String> sectionRoles = new HashMap<String, String>();\n\n\t\t// Don't bother doing anything if the integration is configured to ignore\n\t\t// CourseOffering memberships.\n\t\tif ((roleMap == null) || (roleMap.size() == 0)) {\n\t\t\treturn sectionRoles;\n\t\t}\n\n\t\t// Find all of the course offerings for which this user is a member\n\t\tMap<String, String> courseOfferingRoles = cmService.findCourseOfferingRoles(userEid);\n\t\tif(log.isDebugEnabled()) log.debug(\"Found \" + courseOfferingRoles.size() + \" course offering roles for \" + userEid);\n\n\t\t// Add all of the equivalent course offerings-> role mappings for this user\n\t\tSet<String> coEids = new HashSet<String>(courseOfferingRoles.keySet());\n\t\tfor(String coEid : coEids) {\n\t\t\tSet<CourseOffering> equivOfferings = cmService.getEquivalentCourseOfferings(coEid);\n\t\t\tfor(Iterator<CourseOffering> equivIter = equivOfferings.iterator(); equivIter.hasNext();) {\n\t\t\t\tCourseOffering equiv = equivIter.next();\n\t\t\t\t// Use the role in the original course offering for this equivalent course offering\n\t\t\t\tcourseOfferingRoles.put(equiv.getEid(), courseOfferingRoles.get(coEid));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Iterator<String> coIter = courseOfferingRoles.keySet().iterator(); coIter.hasNext();) {\n\t\t\tString coEid = coIter.next();\n\t\t\tString coRole = courseOfferingRoles.get(coEid);\n\t\t\t\n\t\t\t// If this role shouldn't be part of the site, ignore the membership in this course offering\n\t\t\tString sakaiRole = convertRole(coRole);\n\t\t\tif(sakaiRole == null) {\n\t\t\t\tif(log.isDebugEnabled()) log.debug(\"Course offering role \" + coRole + \" is not mapped to a sakai role.  Skipping this membership.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(log.isDebugEnabled()) log.debug(userEid + \" has role=\" + coRole + \" in course offering \" + coEid);\n\t\t\t// Get the sections in each course offering\n\t\t\tSet<Section> sections = cmService.getSections(coEid);\n\t\t\tfor(Iterator<Section> secIter = sections.iterator(); secIter.hasNext();) {\n\t\t\t\t// Add the section EIDs and the converted *CourseOffering* role to the sectionRoles map\n\t\t\t\tSection section = secIter.next();\n\t\t\t\tsectionRoles.put(section.getEid().toUpperCase(), sakaiRole);\n\t\t\t}\n\t\t}\n\t\treturn sectionRoles;\n\t}","commit_id":"c672c7522f887d4d53b16f094b2fd337bff07ffb","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public Map<String, String> getGroupRoles(CourseManagementService cmService, String userEid) {\n\t\tMap<String, String> groupRoleMap = new HashMap<String, String>();\n\t\t\n\t\t// Start with the sectionEid->role map\n\t\tif ((roleMap != null) && (roleMap.size() > 0)) {\n\t\t\tMap<String, String> sectionRoles = cmService.findSectionRoles(userEid);\n\n\t\t\t// Convert these roles to Sakai roles\n\t\t\tfor(String key : sectionRoles.keySet()) {\n\t\t\t\tgroupRoleMap.put(key, convertRole((String)sectionRoles.get(key)));\n\t\t\t}\n\t\t}\n\n\t\t// Next add all enrollments to the sectionEid->role map, overriding memberships\n\t\tif ((enrollmentStatusRoleMap != null) && (enrollmentStatusRoleMap.size() > 0)) {\n\t\t\tSet<Section> enrolledSections = cmService.findEnrolledSections(userEid);\n\t\t\tif(log.isDebugEnabled()) log.debug(\"Found \" + enrolledSections.size() + \" currently enrolled sections for user \" + userEid);\n\t\t\tfor(Section section : enrolledSections) {\n\t\t\t\tif(log.isDebugEnabled()) log.debug(userEid + \" is enrolled in an enrollment set attached to section \" + section.getEid());\n\t\t\t\t// TODO Calling this for every section  is inefficient -- add new method to CM service?\n\t\t\t\tEnrollment enr = cmService.findEnrollment(userEid, section.getEnrollmentSet().getEid());\n\t\t\t\tString roleFromEnrollmentStatus = enrollmentStatusRoleMap.get(enr.getEnrollmentStatus());\n\n\t\t\t\t// Only add the enrollment if it's not dropped and it has an enrollment role mapping\n\t\t\t\tif(roleFromEnrollmentStatus != null && ! enr.isDropped()) {\n\t\t\t\t\tgroupRoleMap.put(section.getEid(), roleFromEnrollmentStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finally, add the official instructors, overriding any other roles if necessary\n\t\tif ((officialInstructorRole != null) && (officialInstructorRole.length() > 0)) {\n\t\t\tSet<Section> instructingSections = cmService.findInstructingSections(userEid);\n\t\t\tfor(Section instructingSection : instructingSections) {\n\t\t\t\tgroupRoleMap.put(instructingSection.getEid(), officialInstructorRole);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(log.isDebugEnabled()) {\n\t\t\tfor(String sectionEid : groupRoleMap.keySet()) {\n\t\t\t\tlog.debug(\"User \" + userEid + \" has role \" + groupRoleMap.get(sectionEid) + \" in \" + sectionEid);\n\t\t\t}\n\t\t}\n\t\treturn groupRoleMap;\n\t}","id":43578,"modified_method":"public Map<String, String> getGroupRoles(CourseManagementService cmService, String userEid) {\n\t\tMap<String, String> groupRoleMap = new HashMap<String, String>();\n\t\t\n\t\t// Start with the sectionEid->role map\n\t\tif ((roleMap != null) && (roleMap.size() > 0)) {\n\t\t\tMap<String, String> sectionRoles = cmService.findSectionRoles(userEid);\n\n\t\t\t// Convert these roles to Sakai roles\n\t\t\tfor(String key : sectionRoles.keySet()) {\n\t\t\t\tgroupRoleMap.put(key.toUpperCase(), convertRole((String)sectionRoles.get(key)));\n\t\t\t}\n\t\t}\n\n\t\t// Next add all enrollments to the sectionEid->role map, overriding memberships\n\t\tif ((enrollmentStatusRoleMap != null) && (enrollmentStatusRoleMap.size() > 0)) {\n\t\t\tSet<Section> enrolledSections = cmService.findEnrolledSections(userEid);\n\t\t\tif(log.isDebugEnabled()) log.debug(\"Found \" + enrolledSections.size() + \" currently enrolled sections for user \" + userEid);\n\t\t\tfor(Section section : enrolledSections) {\n\t\t\t\tif(log.isDebugEnabled()) log.debug(userEid + \" is enrolled in an enrollment set attached to section \" + section.getEid());\n\t\t\t\t// TODO Calling this for every section  is inefficient -- add new method to CM service?\n\t\t\t\tEnrollment enr = cmService.findEnrollment(userEid, section.getEnrollmentSet().getEid());\n\t\t\t\tString roleFromEnrollmentStatus = enrollmentStatusRoleMap.get(enr.getEnrollmentStatus());\n\n\t\t\t\t// Only add the enrollment if it's not dropped and it has an enrollment role mapping\n\t\t\t\tif(roleFromEnrollmentStatus != null && ! enr.isDropped()) {\n\t\t\t\t\tgroupRoleMap.put(section.getEid().toUpperCase(), roleFromEnrollmentStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finally, add the official instructors, overriding any other roles if necessary\n\t\tif ((officialInstructorRole != null) && (officialInstructorRole.length() > 0)) {\n\t\t\tSet<Section> instructingSections = cmService.findInstructingSections(userEid);\n\t\t\tfor(Section instructingSection : instructingSections) {\n\t\t\t\tgroupRoleMap.put(instructingSection.getEid().toUpperCase(), officialInstructorRole);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(log.isDebugEnabled()) {\n\t\t\tfor(String sectionEid : groupRoleMap.keySet()) {\n\t\t\t\tlog.debug(\"User \" + userEid + \" has role \" + groupRoleMap.get(sectionEid) + \" in \" + sectionEid);\n\t\t\t}\n\t\t}\n\t\treturn groupRoleMap;\n\t}","commit_id":"c672c7522f887d4d53b16f094b2fd337bff07ffb","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private boolean useBlockFormatter(final FileType fileType) {\n   // if (!\"lesya\".equals(System.getProperty(\"user.name\"))) return false;\n    return ApplicationManager.getApplication().isUnitTestMode() && (fileType == StdFileTypes.XML || fileType == StdFileTypes.HTML);\n  }","id":43579,"modified_method":"private boolean useBlockFormatter(final FileType fileType) {\n    //if (!\"lesya\".equals(System.getProperty(\"user.name\"))) return false;\n    return ApplicationManager.getApplication().isUnitTestMode()\n           && (fileType == StdFileTypes.XML || fileType == StdFileTypes.HTML || fileType == StdFileTypes.JAVA);\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ASTNode processRange(final ASTNode element, final int startOffset, final int endOffset) {\n    final FileType fileType = myHelper.getFileType();\n\n    if (useBlockFormatter(fileType)) {\n      TextRange range = new TextRange(startOffset, endOffset);\n      final PsiFile containingFile = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n      final PsiBasedFormattingModel model = new PsiBasedFormattingModel(containingFile);\n      try {\n        Formatter.getInstance().format(model, createBlock(containingFile), mySettings, mySettings.getIndentOptions(fileType), range);\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n\n      return element;\n\n    }\n\n    if (useNewFormatter(fileType)) {\n      PseudoTextBuilder pseudoTextBuilder = ((LanguageFileType)fileType).getLanguage().getFormatter();\n      if (pseudoTextBuilder == null) {\n        return element;\n      }\n      else {\n        try {\n          final PseudoText pseudoText = pseudoTextBuilder.build(myHelper.getProject(), mySettings, SourceTreeToPsiMap.treeElementToPsi(element));\n          GeneralCodeFormatter.createSimpleInstance(pseudoText, mySettings, fileType, startOffset, endOffset, null).format();\n        }\n        catch (ProcessCanceledException processCanceledException) {\n          throw processCanceledException;\n        }\n        catch (Exception e) {\n          LOG.error(e);\n        }\n        formatComments(element, startOffset, endOffset);\n        return element;\n      }\n    }\n\n    final TextRange range = element.getTextRange();\n    final int elementStartOffset = range.getStartOffset();\n    return processRange(element, new int[]{startOffset - elementStartOffset, endOffset - elementStartOffset});\n  }","id":43580,"modified_method":"public ASTNode processRange(final ASTNode element, final int startOffset, final int endOffset) {\n    final FileType fileType = myHelper.getFileType();\n\n    if (useBlockFormatter(fileType)) {\n      TextRange range = new TextRange(startOffset, endOffset);\n      final PsiFile containingFile = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n      final PsiBasedFormattingModel model = new PsiBasedFormattingModel(containingFile, mySettings);\n      if (containingFile.getTextLength() > 0) {\n        try {\n          Formatter.getInstance().format(model, createBlock(containingFile), mySettings, mySettings.getIndentOptions(fileType), range);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);                   \n        }\n      }\n      return element;\n\n    }\n\n    if (useNewFormatter(fileType)) {\n      PseudoTextBuilder pseudoTextBuilder = ((LanguageFileType)fileType).getLanguage().getFormatter();\n      if (pseudoTextBuilder == null) {\n        return element;\n      }\n      else {\n        try {\n          final PseudoText pseudoText = pseudoTextBuilder.build(myHelper.getProject(), mySettings, SourceTreeToPsiMap.treeElementToPsi(element));\n          GeneralCodeFormatter.createSimpleInstance(pseudoText, mySettings, fileType, startOffset, endOffset, null).format();\n        }\n        catch (ProcessCanceledException processCanceledException) {\n          throw processCanceledException;\n        }\n        catch (Exception e) {\n          LOG.error(e);\n        }\n        formatComments(element, startOffset, endOffset);\n        return element;\n      }\n    }\n\n    final TextRange range = element.getTextRange();\n    final int elementStartOffset = range.getStartOffset();\n    return processRange(element, new int[]{startOffset - elementStartOffset, endOffset - elementStartOffset});\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Block createBlock(final PsiFile element) {\n    return AbstractXmlBlock.creareRoot(element, mySettings);\n  }","id":43581,"modified_method":"private Block createBlock(final PsiFile element) {\n    if (element.getFileType() == StdFileTypes.XML || element.getFileType()== StdFileTypes.HTML) {\n      return AbstractXmlBlock.creareRoot(element, mySettings);\n    } else {\n      return AbstractJavaBlock.createJavaBlock(SourceTreeToPsiMap.psiElementToTree(element), mySettings);\n    }\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ASTNode process(ASTNode element, int parent_indent) {\n\n    final FileType fileType = myHelper.getFileType();\n    if (useBlockFormatter(fileType)) {\n      TextRange range = element.getTextRange();\n      final PsiFile containingFile = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n      final PsiBasedFormattingModel model = new PsiBasedFormattingModel(containingFile);\n      try {\n        Formatter.getInstance().format(model, createBlock(containingFile), mySettings, mySettings.getIndentOptions(fileType), range);\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n\n      return element;\n\n    }\n\n    if (useNewFormatter(myHelper.getFileType())) {\n      TextRange range = element.getTextRange();\n      int startOffset = range.getStartOffset();\n      int endOffset = range.getEndOffset();\n\n      processRange(element, startOffset, endOffset);\n      return element;\n    }\n\n    if (element instanceof CompositeElement) {\n      ASTNode parent = element;\n      ChameleonTransforming.transformChildren(parent);\n\n      child1 = null;\n      child2 = Helper.shiftForwardToNonSpace(parent.getFirstChildNode());\n      int indent = -1;\n      for (; child2 != null; child1 = child2, child2 = Helper.shiftForwardToNonSpace(child2.getTreeNext())) {\n        if (child1 != null || SourceTreeToPsiMap.treeElementToPsi(parent) instanceof PsiFile) {\n          child2 = myCodeFormatter.format(SourceTreeToPsiMap.treeElementToPsi(parent), child1, child2, mySettings, myHelper);\n        }\n\n        if (indent < 0) {\n          indent = myIndentAdjuster.calculateIndent(child2, -1);\n        }\n\n        if (child2 != null) {\n          child2 = myIndentAdjuster.adjustIndent(child2, indent);\n        }\n      }\n\n      element = myWrapper.wrap(element);\n      element = myIndentAdjuster.adjustIndent(element, parent_indent);\n      myCommentFormatter.process(element);\n\n      indent = -1;\n      for (ASTNode child = element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        if (indent < 0) {\n          indent = myIndentAdjuster.calculateIndent(child, -1);\n        }\n        child = process(child, indent);\n      }\n    }\n    return element;\n  }","id":43582,"modified_method":"public ASTNode process(ASTNode element, int parent_indent) {\n\n    final FileType fileType = myHelper.getFileType();\n    if (useBlockFormatter(fileType)) {\n      TextRange range = element.getTextRange();\n      int startOffset = range.getStartOffset();\n      int endOffset = range.getEndOffset();\n\n      processRange(element, startOffset, endOffset);\n      return element;\n    }\n\n    if (useNewFormatter(myHelper.getFileType())) {\n      TextRange range = element.getTextRange();\n      int startOffset = range.getStartOffset();\n      int endOffset = range.getEndOffset();\n\n      processRange(element, startOffset, endOffset);\n      return element;\n    }\n\n    if (element instanceof CompositeElement) {\n      ASTNode parent = element;\n      ChameleonTransforming.transformChildren(parent);\n\n      child1 = null;\n      child2 = Helper.shiftForwardToNonSpace(parent.getFirstChildNode());\n      int indent = -1;\n      for (; child2 != null; child1 = child2, child2 = Helper.shiftForwardToNonSpace(child2.getTreeNext())) {\n        if (child1 != null || SourceTreeToPsiMap.treeElementToPsi(parent) instanceof PsiFile) {\n          child2 = myCodeFormatter.format(SourceTreeToPsiMap.treeElementToPsi(parent), child1, child2, mySettings, myHelper);\n        }\n\n        if (indent < 0) {\n          indent = myIndentAdjuster.calculateIndent(child2, -1);\n        }\n\n        if (child2 != null) {\n          child2 = myIndentAdjuster.adjustIndent(child2, indent);\n        }\n      }\n\n      element = myWrapper.wrap(element);\n      element = myIndentAdjuster.adjustIndent(element, parent_indent);\n      myCommentFormatter.process(element);\n\n      indent = -1;\n      for (ASTNode child = element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        if (indent < 0) {\n          indent = myIndentAdjuster.calculateIndent(child, -1);\n        }\n        child = process(child, indent);\n      }\n    }\n    return element;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void performModifications() {\n    int shift = 0;\n    WhiteSpace prev = null;\n    for (Iterator<Block> iterator = myInfos.keySet().iterator(); iterator.hasNext();) {\n      Block block = iterator.next();\n      final WhiteSpace whiteSpace = getBlockInfo(block).getWhiteSpace();\n      final String newWhiteSpace = whiteSpace.generateWhiteSpace();\n      if (prev == whiteSpace || whiteSpace.isReadOnly()) continue;\n      final TextRange textRange = whiteSpace.getTextRange();\n      myModel.replaceWhiteSpace(new TextRange(textRange.getStartOffset() + shift, textRange.getEndOffset() + shift), newWhiteSpace);\n      shift += newWhiteSpace.length() - (textRange.getLength());\n      prev = whiteSpace;\n    }\n  }","id":43583,"modified_method":"public void performModifications() throws IncorrectOperationException {\n    int shift = 0;\n    WhiteSpace prev = null;\n    for (BlockWrapper block = myFirstTokenBlock; block != null; block = block.getNextBlock()) {\n      final WhiteSpace whiteSpace = block.getWhiteSpace();\n      if (!whiteSpace.isReadOnly()) {\n        final int oldTextRangeLength = block.getTextRange().getLength();\n        final String newWhiteSpace = whiteSpace.generateWhiteSpace(myIndentOption);\n        if (prev == whiteSpace || whiteSpace.isReadOnly()) continue;\n        if (whiteSpace.equals(newWhiteSpace)) continue;\n        final TextRange textRange = whiteSpace.getTextRange();\n        final TextRange wsRange = new TextRange(textRange.getStartOffset() + shift, textRange.getEndOffset() + shift);\n        myModel.replaceWhiteSpace(wsRange, newWhiteSpace);\n        shift += (newWhiteSpace.length() - (textRange.getLength())) + (block.getBlock().getTextRange().getLength() - oldTextRangeLength);\n      }\n      prev = whiteSpace;\n    }\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Element save(final AlignmentImpl alignment) {\n    final Element result = new Element(\"Alignment\");\n    result.setAttribute(\"type\", alignment.getType().toString());\n    result.setAttribute(\"id\", alignment.getId());\n    return result;\n  }","id":43584,"modified_method":"private Element save(final AlignmentImpl alignment) {\n    final Element result = new Element(\"Alignment\");\n    result.setAttribute(\"id\", alignment.getId());\n    return result;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void onCurrentLineChanged() {\n    myAlignedAlignments.clear();\n    myWrapCandidates.clear();\n  }","id":43585,"modified_method":"private void onCurrentLineChanged() {\n    myAlignedAlignments.clear();\n    myWrapCandidate = null;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Element save(final SpacePropertyImpl spaceProperty) {\n    final Element result = new Element(\"Space\");\n    result.setAttribute(\"minspace\", String.valueOf(spaceProperty.getMinSpaces()));\n    result.setAttribute(\"maxspace\", String.valueOf(spaceProperty.getMaxSpaces()));\n    result.setAttribute(\"minlf\", String.valueOf(spaceProperty.getMinLineFeeds()));\n    result.setAttribute(\"maxlf\", String.valueOf(spaceProperty.getMaxLineFeeds()));\n    return result;\n  }","id":43586,"modified_method":"private Element save(final SpacePropertyImpl spaceProperty) {\n    final Element result = new Element(\"Space\");\n    spaceProperty.refresh(this);\n    result.setAttribute(\"minspace\", String.valueOf(spaceProperty.getMinSpaces()));\n    result.setAttribute(\"maxspace\", String.valueOf(spaceProperty.getMaxSpaces()));\n    result.setAttribute(\"minlf\", String.valueOf(spaceProperty.getMinLineFeeds()));\n    return result;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getAlignOffset(final AlignmentImpl alignment) {\n    if (alignment == null) return -1;\n    return alignment.getCurrentOffset();\n  }","id":43587,"modified_method":"private int getAlignOffset() {\n    BlockWrapper current = myCurrentBlock;\n    while (true) {\n      final AlignmentImpl alignment = (AlignmentImpl)current.getBlock().getAlignment();\n      if (alignment != null && alignment.getCurrentOffset() >= 0){\n        return alignment.getCurrentOffset();\n      }\n      else {\n        current = current.getParent();\n        if (current == null) return -1;\n        if (current.getStartOffset() != myCurrentBlock.getStartOffset()) return -1;\n      }\n    }\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FormatProcessor(FormattingModel model,\n                       Block rootBlock,\n                       CodeStyleSettings settings,\n                       CodeStyleSettings.IndentOptions indentOptions,\n                       TextRange affectedRange) {\n    myModel = model;\n    myIndentOption = indentOptions;\n    mySettings = settings;\n    final InitialInfoBuilder builder = InitialInfoBuilder.buildBlocks(rootBlock, model, affectedRange);\n    myInfos = builder.getBlockToInfoMap();\n    myCurrentBlock = builder.getFirstTokenBlock();\n    /*\n    final Element element = saveToXml(rootBlock);\n    try {\n      JDOMUtil.writeDocument(new Document(element), new File(\"c:/temp/format.xml\"), \"\\n\");\n    }\n    catch (IOException e) {\n      //ignore\n    }\n    */\n  }","id":43588,"modified_method":"public FormatProcessor(FormattingModel model,\n                       Block rootBlock,\n                       CodeStyleSettings settings,\n                       CodeStyleSettings.IndentOptions indentOptions,\n                       TextRange affectedRange) {\n    myModel = model;\n    myIndentOption = indentOptions;\n    mySettings = settings;\n    final InitialInfoBuilder builder = InitialInfoBuilder.buildBlocks(rootBlock, model, affectedRange);\n    myInfos = builder.getBlockToInfoMap();\n    myFirstTokenBlock = builder.getFirstTokenBlock();\n    myCurrentBlock = myFirstTokenBlock;\n    myTextRangeToWrapper = buildTextRangeToInfoMap(myFirstTokenBlock);\n    //final Element element = saveToXml(rootBlock);\n    //try {\n      //JDOMUtil.writeDocument(new Document(element), new File(\"c:/temp/format.xml\"), \"\\n\");\n    //}\n    //catch (IOException e) {\n      //ignore\n    //}\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setAlignOffset(final AlignmentImpl alignment, final int currentIndent) {\n    if (alignment != null) {\n      if (!myAlignedAlignments.contains(alignment)) {\n        alignment.setCurrentOffset(currentIndent);\n      }\n      myAlignedAlignments.add(alignment);\n    }\n  }","id":43589,"modified_method":"private void setAlignOffset(final int currentIndent) {\n    BlockWrapper current = myCurrentBlock;\n    while (true) {\n      final AlignmentImpl alignment = (AlignmentImpl)current.getBlock().getAlignment();\n      if (alignment != null && !myAlignedAlignments.contains(alignment)) {\n        alignment.setCurrentOffset(currentIndent);\n        myAlignedAlignments.add(alignment);\n      }\n      current = current.getParent();\n      if (current == null) return;\n      if (current.getStartOffset() != myCurrentBlock.getStartOffset()) return;\n\n    }\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processToken() {\n\n    final SpacePropertyImpl spaceProperty = myCurrentBlock.getSpaceProperty();\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n\n    whiteSpace.arrangeLineFeeds(spaceProperty);\n\n    try {\n      if (processWrap()){\n        return;\n      }\n    }\n    finally {\n      if (whiteSpace.containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n    }\n\n    final Block block = myCurrentBlock.getBlock();\n    if (whiteSpace.containsLineFeeds()) {\n      adjustLineIndent();\n    } else {\n      whiteSpace.arrangeSpaces(spaceProperty);\n    }\n\n    setAlignOffset(myCurrentBlock.getAlignment(), getOffsetBefore(block));\n\n    if (myCurrentBlock.containsLineFeeds()) {\n      onCurrentLineChanged();\n    }\n    myCurrentBlock = myCurrentBlock.getNextBlock();\n  }","id":43590,"modified_method":"private void processToken() {\n\n    final SpacePropertyImpl spaceProperty = myCurrentBlock.getSpaceProperty();\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n\n    whiteSpace.arrangeLineFeeds(spaceProperty, this);\n\n    try {\n      if (processWrap(spaceProperty)){\n        return;\n      }\n    }\n    finally {\n      if (whiteSpace.containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n    }\n\n    final Block block = myCurrentBlock.getBlock();\n    if (whiteSpace.containsLineFeeds()) {\n      adjustLineIndent();\n    } else {\n      whiteSpace.arrangeSpaces(spaceProperty);\n    }\n\n    setAlignOffset(getOffsetBefore(block));\n\n    if (myCurrentBlock.containsLineFeeds()) {\n      onCurrentLineChanged();\n    }\n\n    if (shouldSaveDependancy(spaceProperty, whiteSpace)) {\n      saveDependancy(spaceProperty);\n    }\n\n    if (!myAlignAgain) {\n      myAlignAgain = shouldReformatBecauseOfBackwardDependance(whiteSpace.getTextRange());\n    }\n\n    myCurrentBlock = myCurrentBlock.getNextBlock();\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isSuitableInTheCurrentPosition(final WrapImpl wrap) {\n    return wrap.isWrapFirstElement() || (wrap.getFirstPosition() < myCurrentBlock.getTextRange().getStartOffset());\n  }","id":43591,"modified_method":"private boolean processWrap(SpaceProperty spaceProperty) {\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n    final TextRange textRange = myCurrentBlock.getTextRange();\n    final WrapImpl[] wraps = myCurrentBlock.getWraps();\n\n    if (whiteSpace.containsLineFeeds() && !whiteSpace.containsLineFeedsInitially()) {\n      whiteSpace.removeLineFeeds(spaceProperty, this);\n    }\n\n    boolean wrapIsPresent = whiteSpace.containsLineFeeds();\n\n    for (int i = 0; i < wraps.length; i++) {\n      WrapImpl wrap = wraps[i];\n      wrap.processNextEntry(textRange.getStartOffset());\n    }\n\n    WrapImpl wrap = getWrapToBeUsed(wraps);\n\n    if (wrap != null || wrapIsPresent) {\n      if (!wrapIsPresent && !canReplaceWrapCandidate(wrap)) {\n        myCurrentBlock = myWrapCandidate;\n        return true;\n      }\n      else if (wrap != null && wrap.getFirstEntry() != null) {\n        myCurrentBlock = wrap.getFirstEntry();\n        wrap.markAsUsed();\n        return true;\n      } else if (wrap != null && wrapCanBeUsedInTheFuture(wrap)) {\n        wrap.markAsUsed();\n      }\n      whiteSpace.ensureLineFeed();\n      myWrapCandidate = null;\n    } else {\n      for (int i = 0; i < wraps.length; i++) {\n        WrapImpl wrap1 = wraps[i];\n        if (isCandidateToBeWrapped(wrap1) && canReplaceWrapCandidate(wrap1)){\n          myWrapCandidate = myCurrentBlock;\n        }\n        if (wrapCanBeUsedInTheFuture(wrap1)) {\n          wrap1.saveFirstEntry(myCurrentBlock);\n        }\n\n      }\n    }\n\n    if (!whiteSpace.containsLineFeeds() && lineOver() && myWrapCandidate != null && !whiteSpace.isReadOnly()) {\n      myCurrentBlock = myWrapCandidate;\n      return true;\n    }\n\n    return false;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getOffsetBefore(final Block block) {\n    int result = 0;\n    BlockWrapper info = getBlockInfo(block);\n    while (true) {\n      final WhiteSpace whiteSpace = info.getWhiteSpace();\n      result += whiteSpace.getSpaces();\n      if (whiteSpace.containsLineFeeds()){\n        return result;\n      }\n      info = info.getPreviousBlock();\n      if (info == null) return result;\n      result += info.getSymbolsAtTheLastLine();\n      if (info.containsLineFeeds()) return result;\n    }\n  }","id":43592,"modified_method":"private int getOffsetBefore(final Block block) {\n    int result = 0;\n    BlockWrapper info = getBlockInfo(block);\n    while (true) {\n      final WhiteSpace whiteSpace = info.getWhiteSpace();\n      result += whiteSpace.getTotalSpaces();\n      if (whiteSpace.containsLineFeeds()){\n        return result;\n      }\n      info = info.getPreviousBlock();\n      if (info == null) return result;\n      result += info.getSymbolsAtTheLastLine();\n      if (info.containsLineFeeds()) return result;\n    }\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void format() throws IncorrectOperationException {\n    formatWithoutRealModifications();\n\n    myModel.runModificationTransaction(new Runnable() {\n      public void run() {\n        performModifications();\n      }\n    });\n\n  }","id":43593,"modified_method":"public void format() throws IncorrectOperationException {\n    formatWithoutRealModifications();\n    performModifications();\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void adjustLineIndent() {\n    int alignOffset = getAlignOffset(myCurrentBlock.getAlignment());\n    if (alignOffset == -1) {\n      myCurrentBlock.arrangeBlockOffset(myIndentOption);\n      final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n      whiteSpace.setSpaces(myCurrentBlock.getBlockOffset());\n      myCurrentBlock.fixOffset(whiteSpace.getSpaces());\n    } else {\n      myCurrentBlock.getWhiteSpace().setSpaces(alignOffset);\n    }\n  }","id":43594,"modified_method":"private void adjustLineIndent() {\n    int alignOffset = getAlignOffset();\n    if (alignOffset == -1) {\n      //myCurrentBlock.arrangeBlockOffset(myIndentOption);\n      final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n      whiteSpace.setSpaces(0, myCurrentBlock.calculateOffset(myIndentOption));\n      //myCurrentBlock.fixOffset(whiteSpace.getTotalSpaces());\n\n    } else {\n      final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n      BlockWrapper previousIndentedBlock = getPreviousIndentedBlock();\n      if (previousIndentedBlock == null) {\n        whiteSpace.setSpaces(alignOffset, 0);\n      } else {\n        int indentOffset = previousIndentedBlock.getWhiteSpace().getIndentOffset();\n        if (indentOffset > alignOffset) {\n          whiteSpace.setSpaces(alignOffset, 0);\n        } else {\n          whiteSpace.setSpaces(alignOffset - indentOffset, indentOffset);\n        }\n\n      }\n    }\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void formatWithoutRealModifications() {\n    while (myCurrentBlock != null) {\n      processToken();\n    }\n  }","id":43595,"modified_method":"public void formatWithoutRealModifications() {\n    while (true) {\n      myAlignAgain = false;\n      myCurrentBlock = myFirstTokenBlock;\n      while (myCurrentBlock != null) {\n        processToken();\n      }\n      if (!myAlignAgain) return;\n      reset();\n    }\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Element saveToXml(Block root){\n    final Element result = new Element(\"Block\");\n    final TextRange textRange = root.getTextRange();\n    result.setAttribute(\"start\", String.valueOf(textRange.getStartOffset()));\n    result.setAttribute(\"stop\", String.valueOf(textRange.getEndOffset()));\n    final Alignment alignment = root.getAlignment();\n    if (alignment != null) {\n      result.addContent(save((AlignmentImpl)alignment));\n    }\n    final Indent indent = root.getIndent();\n    if (indent != null) {\n      result.addContent(save((IndentImpl)indent));\n    }\n\n    final Wrap wrap = root.getWrap();\n    if (wrap != null) {\n      result.addContent(save((WrapImpl)wrap));\n    }\n\n    final List<Block> subBlocks = root.getSubBlocks();\n    Block prev = null;\n    for (Iterator<Block> iterator = subBlocks.iterator(); iterator.hasNext();) {\n      Block block = iterator.next();\n      if (prev != null) {\n        final SpaceProperty spaceProperty = root.getSpaceProperty(prev, block);\n        if (spaceProperty != null) {\n          result.addContent(save((SpacePropertyImpl)spaceProperty));\n        }\n      }\n      result.addContent(saveToXml(block));\n      prev = block;\n    }\n\n    return result;\n  }","id":43596,"modified_method":"public Element saveToXml(Block root){\n    final Element result = new Element(\"Block\");\n    final TextRange textRange = root.getTextRange();\n    result.setAttribute(\"start\", String.valueOf(textRange.getStartOffset()));\n    result.setAttribute(\"stop\", String.valueOf(textRange.getEndOffset()));\n    final Alignment alignment = root.getAlignment();\n    if (alignment != null) {\n      result.addContent(save((AlignmentImpl)alignment));\n    }\n    final Indent indent = root.getIndent();\n    if (indent != null) {\n      result.addContent(save((IndentImpl)indent));\n    }\n\n    final Wrap wrap = root.getWrap();\n    if (wrap != null) {\n      result.addContent(save((WrapImpl)wrap));\n    }\n\n    final List<Block> subBlocks = root.getSubBlocks();\n    Block prev = null;\n    for (Iterator<Block> iterator = subBlocks.iterator(); iterator.hasNext();) {\n      Block block = iterator.next();\n      if (prev != null) {\n        final SpaceProperty spaceProperty = root.getSpaceProperty(prev, block);\n        if (spaceProperty != null) {\n          result.addContent(save((SpacePropertyImpl)spaceProperty));\n        }\n      }\n      result.addContent(saveToXml(block));\n\n      prev = block;\n    }\n    result.addContent(new Text(root.toString()));\n    return result;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SpaceProperty getReadOnlySpace() {\n    return new SpacePropertyImpl(0,0,0,0,true, false);\n  }","id":43597,"modified_method":"public SpaceProperty getReadOnlySpace() {\n    return new SpacePropertyImpl(0,0,0,true, false, true, 0);\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SpaceProperty createSpaceProperty(int minOffset, int maxOffset, int minLineFeeds, int maxLineFeeds) {\n    return new SpacePropertyImpl(minOffset, maxOffset, minLineFeeds, maxLineFeeds, false, false);\n  }","id":43598,"modified_method":"public SpaceProperty createSpaceProperty(int minOffset,\n                                           int maxOffset,\n                                           int minLineFeeds,\n                                           final boolean keepLineBreaks,\n                                           final int keepBlankLines) {\n    return new SpacePropertyImpl(minOffset, maxOffset, minLineFeeds, false, false, keepLineBreaks, keepBlankLines);\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Indent getNormalIndent(int indentCount) {\n    return new IndentImpl(IndentImpl.Type.NORMAL, indentCount, 0);\n  }","id":43599,"modified_method":"public Indent createNormalIndent() {\n    return new IndentImpl(IndentImpl.Type.NORMAL, false);\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Indent getLabelIndent(int indentCount) {\n    return new IndentImpl(IndentImpl.Type.LABEL, indentCount, 0);\n  }","id":43600,"modified_method":"public Indent createLabelIndent() {\n    return new IndentImpl(IndentImpl.Type.LABEL, false);\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Indent getNoneIndent() {\n    return new IndentImpl(IndentImpl.Type.NONE, 0,0);\n  }","id":43601,"modified_method":"public Indent getNoneIndent() {\n    return new IndentImpl(IndentImpl.Type.NONE, false);\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SpaceProperty createSafeSpace() {\n    return new SpacePropertyImpl(0,0,0,0,false,true);\n  }","id":43602,"modified_method":"public SpaceProperty createSafeSpace(final boolean shouldKeepLineBreaks, final int keepBlankLines) {\n    return new SpacePropertyImpl(0,0,0,false,true, shouldKeepLineBreaks, keepBlankLines);\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ASTNode makeSpace(ASTNode parent,\n                           ASTNode child1,\n                           ASTNode child2,\n                           String text,\n                           boolean indentMultiline) {\n    LeafElement space = getSpaceElement(parent, child1, child2);\n    final CharTable charTableByTree = SharedImplUtil.findCharTableByTree(parent);\n    int indentShift;\n    if (space == null) {\n      if (text.length() == 0) return child2;\n      LeafElement newSpace = Factory.createSingleLeafElement(ElementType.WHITE_SPACE, text.toCharArray(), 0, text.length(),\n                                                             charTableByTree, SharedImplUtil.getManagerByTree(parent));\n      final ASTNode anchorBefore = (child1 != null ? child1.getTreeNext() : parent.getFirstChildNode());\n      parent.addChild(newSpace, anchorBefore);\n      indentShift = getIndent(newSpace.getText(), true);\n    }\n    else {\n      final String oldSpace = space.getText();\n      if (text.length() == 0) {\n        if (child1 != null && child2 != null) {\n          if (!canStickChildrenTogether(child1, child2)) {\n            return makeSpace(parent, child1, child2, \" \", indentMultiline);\n          }\n        }\n\n        parent.removeChild(space);\n        indentShift = -getIndent(oldSpace, true);\n      }\n      else {\n        if (text.length() == space.getTextLength()) {\n          int i;\n          for (i = 0; i < text.length(); i++) {\n            if (text.charAt(i) != space.charAt(i)) break;\n          }\n          if (i == text.length()) return child2;\n        }\n        ASTNode newSpace = Factory.createSingleLeafElement(ElementType.WHITE_SPACE, text.toCharArray(), 0, text.length(),\n                                                               charTableByTree, SharedImplUtil.getManagerByTree(space));\n        space.getTreeParent().replaceChild(space, newSpace);\n        indentShift = getIndent(newSpace.getText(), true) - getIndent(oldSpace, true);\n      }\n    }\n    if (indentMultiline) {\n      child2 = shiftIndentInside((TreeElement)child2, indentShift);\n    }\n    return child2;\n  }","id":43603,"modified_method":"public ASTNode makeSpace(ASTNode parent,\n                           ASTNode child1,\n                           ASTNode child2,\n                           String text,\n                           boolean indentMultiline) {\n    LeafElement space = getSpaceElement(parent, child1, child2);\n    final CharTable charTableByTree = SharedImplUtil.findCharTableByTree(parent);\n    int indentShift;\n    if (space == null) {\n      if (text.length() == 0) return child2;\n      LeafElement newSpace = Factory.createSingleLeafElement(ElementType.WHITE_SPACE, text.toCharArray(), 0, text.length(),\n                                                             charTableByTree, SharedImplUtil.getManagerByTree(parent));\n      final ASTNode anchorBefore = (child1 != null ? child1.getTreeNext() : parent.getFirstChildNode());\n      parent.addChild(newSpace, anchorBefore);\n      indentShift = getIndent(newSpace.getText(), true);\n    }\n    else {\n      final String oldSpace = space.getText();\n      if (text.length() == 0) {\n        if (child1 != null && child2 != null) {\n          if (!canStickChildrenTogether(child1, child2)) {\n            return makeSpace(parent, child1, child2, \" \", indentMultiline);\n          }\n        }\n\n        parent.removeChild(space);\n        indentShift = -getIndent(oldSpace, true);\n      }\n      else {\n        if (text.length() == space.getTextLength()) {\n          int i;\n          for (i = 0; i < text.length(); i++) {\n            if (text.charAt(i) != space.charAt(i)) break;\n          }\n          if (i == text.length()) return child2;\n        }\n        ASTNode newSpace = Factory.createSingleLeafElement(ElementType.WHITE_SPACE, text.toCharArray(), 0, text.length(),\n                                                               charTableByTree, SharedImplUtil.getManagerByTree(space));\n        space.getTreeParent().replaceChild(space, newSpace);\n        indentShift = getIndent(newSpace.getText(), true) - getIndent(oldSpace, true);\n      }\n    }\n    if (indentMultiline) {\n      child2 = shiftIndentInside(child2, indentShift);\n    }\n    return child2;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"int getSpaces() {\n    return mySpaces;\n  }","id":43604,"modified_method":"public int getSpaces() {\n    return mySpaces;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IndentImpl(final Type type, final int count, final int spaces) {\n    myType = type;\n    myCount = count;\n    mySpaces = spaces;\n  }","id":43605,"modified_method":"public IndentImpl(final Type type, boolean absolute, final int spaces) {\n    myType = type;\n    myIsAbsolute = absolute;\n    mySpaces = spaces;\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void replaceWhiteSpace(TextRange textRange, String whiteSpace) {\n    FormatterUtil.replaceWhiteSpace(whiteSpace,\n                                    myASTNode.findLeafElementAt(textRange.getEndOffset()),\n                                    ElementType.WHITE_SPACE);\n  }","id":43606,"modified_method":"public void replaceWhiteSpace(final TextRange textRange, final String whiteSpace) throws IncorrectOperationException {\n    final PomModel model = myProject.getModel();\n    final TreeAspect aspect = model.getModelAspect(TreeAspect.class);\n    try {\n      model.runTransaction(new PomTransactionBase(SourceTreeToPsiMap.treeElementToPsi(myASTNode)) {\n        public PomModelEvent runInner(){\n          final FileElement fileElement = getFileElement(myASTNode);\n          final ASTNode leafElement = myASTNode.findLeafElementAt(textRange.getEndOffset());\n          if (leafElement.getTextRange().getStartOffset() < textRange.getStartOffset()) {\n            new Helper(StdFileTypes.JAVA, myProject).shiftIndentInside(leafElement, whiteSpace.length());\n          } else {\n            FormatterUtil.replaceWhiteSpace(whiteSpace,\n                                                           leafElement,\n                                                           ElementType.WHITE_SPACE);\n            if (leafElement.textContains('\\n') && whiteSpace.indexOf('\\n') >= 0) {\n              try {\n                int lastLineIndent = getLastLineIndent(leafElement.getText());\n                new Helper(StdFileTypes.JAVA, myProject).shiftIndentInside(leafElement, whiteSpace.length() - lastLineIndent);\n              }\n              catch (IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          }\n          TreeUtil.clearCaches(fileElement);\n          return null;\n        }\n\n        private int getLastLineIndent(final String text) throws IOException {\n          final CodeStyleSettings.IndentOptions options = mySettings.JAVA_INDENT_OPTIONS;\n          String lastLine = getLastLine(text);\n          if (lastLine == null) return 0;\n          int result = 0;\n          for (int i = 0; i < lastLine.length(); i++) {\n            if (lastLine.charAt(i) == ' ') result += 1;\n            if (lastLine.charAt(i) == '\\t') result += options.TAB_SIZE;\n            return result;\n          }\n          return result;\n        }\n\n        private String getLastLine(final String text) throws IOException {\n          final LineNumberReader lineNumberReader = new LineNumberReader(new StringReader(text));\n          String line;\n          String result = null;\n          while ((line = lineNumberReader.readLine()) != null) {\n            result = line;\n          }\n          return result;\n        }\n\n        private FileElement getFileElement(final ASTNode element) {\n          return (FileElement)SourceTreeToPsiMap.psiElementToTree(SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile());\n        }\n      }, aspect);\n    }\n    catch (IncorrectOperationException e) {\n      throw e;\n    }\n\n\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiBasedFormattingModel(final PsiFile file) {\n    myASTNode = SourceTreeToPsiMap.psiElementToTree(file);\n    myProject = file.getProject();\n    final Document document = PsiDocumentManager.getInstance(myProject).getDocument(file);\n    if (document != null) {\n      myDocument = document;\n    } else {\n      myDocument = new DocumentImpl(file.getText());\n    }\n  }","id":43607,"modified_method":"public PsiBasedFormattingModel(final PsiFile file, CodeStyleSettings settings) {\n    mySettings = settings;\n    myASTNode = SourceTreeToPsiMap.psiElementToTree(file);\n    myProject = file.getProject();\n    final Document document = PsiDocumentManager.getInstance(myProject).getDocument(file);\n    if (document != null) {\n      myDocument = document;\n    } else {\n      myDocument = new DocumentImpl(file.getText());\n    }\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CharSequence getText(final TextRange textRange) {\n    return myDocument.getCharsSequence();\n  }","id":43608,"modified_method":"public CharSequence getText(final TextRange textRange) {\n    return myDocument.getCharsSequence().subSequence(textRange.getStartOffset(), textRange.getEndOffset());\n  }","commit_id":"c708ef839b3bc1aa69020109a50521a1c4e9fe23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void defineAlignOffset(final LeafBlockWrapper block) {\n    AbstractBlockWrapper current = myCurrentBlock;\n    while (true) {\n      final AlignmentImpl alignment = current.getAlignment();\n      if (alignment != null && !myAlignedAlignments.contains(alignment)) {\n        alignment.setOffsetRespBlock(block);\n        myAlignedAlignments.add(alignment);\n      }\n      current = current.getParent();\n      if (current == null) return;\n      if (current.getStartOffset() != myCurrentBlock.getStartOffset()) return;\n\n    }\n  }","id":43609,"modified_method":"private void defineAlignOffset(final LeafBlockWrapper block) {\n    AbstractBlockWrapper current = myCurrentBlock;\n    while (true) {\n      final AlignmentImpl alignment = current.getAlignment();\n      if (alignment != null) {\n        alignment.setOffsetRespBlock(block);\n      }\n      current = current.getParent();\n      if (current == null) return;\n      if (current.getStartOffset() != myCurrentBlock.getStartOffset()) return;\n\n    }\n  }","commit_id":"2d55151fadef1d95d504e2730000d2114b025ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Applies indent to the white space of {@link #myCurrentBlock currently processed wrapped block}. Both indentation\n   * and alignment options are took into consideration here.\n   */\n  private void adjustLineIndent() {\n    IndentData alignOffset = getAlignOffset();\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n\n    if (alignOffset == null) {\n      final IndentData offset = myCurrentBlock.calculateOffset(myIndentOption);\n      whiteSpace.setSpaces(offset.getSpaces(), offset.getIndentSpaces());\n    }\n    else {\n      whiteSpace.setSpaces(alignOffset.getSpaces(), alignOffset.getIndentSpaces());\n    }\n  }","id":43610,"modified_method":"/**\n   * Applies indent to the white space of {@link #myCurrentBlock currently processed wrapped block}. Both indentation\n   * and alignment options are took into consideration here.\n   */\n  private void adjustLineIndent() {\n    IndentData alignOffset = getAlignOffset();\n\n    if (alignOffset == null) {\n      adjustSpacingByIndentOffset();\n    }\n    else {\n      myCurrentBlock.getWhiteSpace().setSpaces(alignOffset.getSpaces(), alignOffset.getIndentSpaces());\n    }\n  }","commit_id":"2d55151fadef1d95d504e2730000d2114b025ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void onCurrentLineChanged() {\n    myAlignedAlignments.clear();\n    myWrapCandidate = null;\n  }","id":43611,"modified_method":"private void onCurrentLineChanged() {\n    myWrapCandidate = null;\n  }","commit_id":"2d55151fadef1d95d504e2730000d2114b025ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processToken() {\n    final SpacingImpl spaceProperty = myCurrentBlock.getSpaceProperty();\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n\n    whiteSpace.arrangeLineFeeds(spaceProperty, this);\n\n    if (!whiteSpace.containsLineFeeds()) {\n      whiteSpace.arrangeSpaces(spaceProperty);\n    }\n\n    try {\n      if (processWrap(spaceProperty)) {\n        return;\n      }\n    }\n    finally {\n      if (whiteSpace.containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n    }\n\n    if (whiteSpace.containsLineFeeds()) {\n      adjustLineIndent();\n    }\n    else {\n      whiteSpace.arrangeSpaces(spaceProperty);\n    }\n\n    defineAlignOffset(myCurrentBlock);\n\n    if (myCurrentBlock.containsLineFeeds()) {\n      onCurrentLineChanged();\n    }\n\n    if (shouldSaveDependency(spaceProperty, whiteSpace)) {\n      saveDependency(spaceProperty);\n    }\n\n    if (!whiteSpace.isIsReadOnly() && shouldReformatBecauseOfBackwardDependency(whiteSpace.getTextRange())) {\n      myAlignAgain.add(whiteSpace);\n    }\n    else if (!myAlignAgain.isEmpty()) {\n      myAlignAgain.remove(whiteSpace);\n    }\n\n    myCurrentBlock = myCurrentBlock.getNextBlock();\n  }","id":43612,"modified_method":"private void processToken() {\n    final SpacingImpl spaceProperty = myCurrentBlock.getSpaceProperty();\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n\n    whiteSpace.arrangeLineFeeds(spaceProperty, this);\n\n    if (!whiteSpace.containsLineFeeds()) {\n      whiteSpace.arrangeSpaces(spaceProperty);\n    }\n\n    try {\n      if (processWrap(spaceProperty)) {\n        return;\n      }\n    }\n    finally {\n      if (whiteSpace.containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n    }\n\n    if (!adjustIndent()) {\n       return;\n    }\n\n    defineAlignOffset(myCurrentBlock);\n\n    if (myCurrentBlock.containsLineFeeds()) {\n      onCurrentLineChanged();\n    }\n\n    if (shouldSaveDependency(spaceProperty, whiteSpace)) {\n      saveDependency(spaceProperty);\n    }\n\n    if (!whiteSpace.isIsReadOnly() && shouldReformatBecauseOfBackwardDependency(whiteSpace.getTextRange())) {\n      myAlignAgain.add(whiteSpace);\n    }\n    else if (!myAlignAgain.isEmpty()) {\n      myAlignAgain.remove(whiteSpace);\n    }\n\n    myCurrentBlock = myCurrentBlock.getNextBlock();\n  }","commit_id":"2d55151fadef1d95d504e2730000d2114b025ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reset() {\n    myAlignedAlignments.clear();\n    myPreviousDependencies.clear();\n    myWrapCandidate = null;\n    if (myRootBlockWrapper != null) {\n      myRootBlockWrapper.reset();\n    }\n  }","id":43613,"modified_method":"private void reset() {\n    myBackwardShiftedAlignedBlocks.clear();\n    myPreviousDependencies.clear();\n    myWrapCandidate = null;\n    if (myRootBlockWrapper != null) {\n      myRootBlockWrapper.reset();\n    }\n  }","commit_id":"2d55151fadef1d95d504e2730000d2114b025ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Type getType() {\n    return myType;\n  }","id":43614,"modified_method":"Type getType() {\n    return myType;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getCurrentOffset() {\n    return myCurrentOffset;\n  }","id":43615,"modified_method":"int getCurrentOffset() {\n    return myCurrentOffset;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setCurrentOffset(final int currentIndent) {\n    myCurrentOffset = currentIndent;\n  }","id":43616,"modified_method":"void setCurrentOffset(final int currentIndent) {\n    myCurrentOffset = currentIndent;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int calculateIndentUnder(Block block) {\n    if (block == null) return 0;\n    final BlockWrapper info = getBlockInfo(block);\n    if (info.getWhiteSpace().containsLineFeeds()) {\n      return getOffsetBefore(info) + getIndent(block);\n    }\n    return calculateIndentUnder(block.getParent());\n  }","id":43617,"modified_method":"private int calculateIndentUnder(Block block) {\n    if (block == null) return 0;\n    final BlockWrapper info = getBlockInfo(block);\n    if (info.getWhiteSpace().containsLineFeeds()) {\n      final Indent indent = getBlockInfo(block).getChildIndent();\n      final int offsetBeforeBlock = getOffsetBefore(info);\n      return offsetBeforeBlock + getIndent(indent);\n    }\n    return calculateIndentUnder(block.getParent());\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void adjustLineIndent() {\n    int alignOffset = getAlignOffset(myCurrentBlock.getAlignment());\n    if (alignOffset == -1) {\n      myCurrentBlock.getWhiteSpace().setSpaces(calculateIndentUnder(getNearestIndentedParent(myCurrentBlock.getBlock().getParent())));\n    } else {\n      myCurrentBlock.getWhiteSpace().setSpaces(alignOffset);\n    }\n  }","id":43618,"modified_method":"private void adjustLineIndent() {\n    int alignOffset = getAlignOffset(myCurrentBlock.getAlignment());\n    if (alignOffset == -1) {\n      final Block block = myCurrentBlock.getBlock();\n      Block current = getParentWithTheSameOffset(block);\n      final Block candidate = getNearestIndentedParent(block.getParent(), current);\n      final int indent = calculateIndentUnder(candidate);\n      myCurrentBlock.getWhiteSpace().setSpaces(indent);\n    } else {\n      myCurrentBlock.getWhiteSpace().setSpaces(alignOffset);\n    }\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processToken() {\n\n    final SpaceProperty spaceProperty = myCurrentBlock.getSpaceProperty();\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n\n    whiteSpace.arrangeLineFeeds(spaceProperty);\n\n    try {\n      if (processWrap()){\n        return;\n      }\n    }\n    finally {\n      if (whiteSpace.containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n    }\n\n    final Block block = myCurrentBlock.getBlock();\n    if (whiteSpace.containsLineFeeds()) {\n      adjustLineIndent();\n    } else {\n      whiteSpace.arrangeSpaces(spaceProperty);\n    }\n\n    setAlignOffset(myCurrentBlock.getAlignment(), getOffsetBefore(block));\n\n    if (myCurrentBlock.containsLineFeeds()) {\n      onCurrentLineChanged();\n    }\n    myCurrentBlock = myCurrentBlock.getNextBlock();\n  }","id":43619,"modified_method":"private void processToken() {\n\n    final SpaceProperty spaceProperty = myCurrentBlock.getSpaceProperty();\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n\n    whiteSpace.arrangeLineFeeds(spaceProperty);\n\n    try {\n      if (processWrap()){\n        return;\n      }\n    }\n    finally {\n      if (whiteSpace.containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n    }\n\n    final Block block = myCurrentBlock.getBlock();;\n    if (!whiteSpace.isReadOnly()) {\n\n      if (whiteSpace.containsLineFeeds()) {\n        adjustLineIndent();\n      } else {\n        whiteSpace.arrangeSpaces(spaceProperty);\n      }\n    }\n\n    setAlignOffset(myCurrentBlock.getAlignment(), getOffsetBefore(block));\n\n    if (myCurrentBlock.containsLineFeeds()) {\n      onCurrentLineChanged();\n    }\n    myCurrentBlock = myCurrentBlock.getNextBlock();\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isCandidateToBeWrapped(final Wrap wrap) {\n    return wrap != null && (wrap.getType() == Wrap.Type.WRAP_AS_NEEDED || wrap.getType() == Wrap.Type.CHOP_IF_NEEDED);\n  }","id":43620,"modified_method":"private boolean isCandidateToBeWrapped(final Wrap wrap) {\n    return isSuitableInTheCurrentPosition(wrap) && (wrap.getType() == Wrap.Type.WRAP_AS_NEEDED || wrap.getType() == Wrap.Type.CHOP_IF_NEEDED);\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void performModifications() {\n    int shift = 0;\n    WhiteSpace prev = null;\n    for (Iterator<Block> iterator = myInfos.keySet().iterator(); iterator.hasNext();) {\n      Block block = iterator.next();\n      final WhiteSpace whiteSpace = getBlockInfo(block).getWhiteSpace();\n      if (prev == whiteSpace || whiteSpace.isReadOnly()) continue;\n      final TextRange textRange = whiteSpace.getTextRange();\n      final String newWhiteSpace = whiteSpace.generateWhiteSpace();\n      myModel.replaceWhiteSpace(new TextRange(textRange.getStartOffset() + shift, textRange.getEndOffset() + shift), newWhiteSpace);\n      shift += newWhiteSpace.length() - (textRange.getLength());\n      prev = whiteSpace;\n    }\n  }","id":43621,"modified_method":"public void performModifications() {\n    int shift = 0;\n    WhiteSpace prev = null;\n    for (Iterator<Block> iterator = myInfos.keySet().iterator(); iterator.hasNext();) {\n      Block block = iterator.next();\n      final WhiteSpace whiteSpace = getBlockInfo(block).getWhiteSpace();\n      final String newWhiteSpace = whiteSpace.generateWhiteSpace();\n      if (prev == whiteSpace || whiteSpace.isReadOnly()) continue;\n      final TextRange textRange = whiteSpace.getTextRange();\n      myModel.replaceWhiteSpace(new TextRange(textRange.getStartOffset() + shift, textRange.getEndOffset() + shift), newWhiteSpace);\n      shift += newWhiteSpace.length() - (textRange.getLength());\n      prev = whiteSpace;\n    }\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void format() {\n    while (myCurrentBlock != null) {\n      processToken();\n    }\n\n    performModifications();\n  }","id":43622,"modified_method":"public void format() {\n    formatWithoutRealModifications();\n\n    performModifications();\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processWrap() {\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n    final TextRange textRange = myCurrentBlock.getBlock().getTextRange();\n    boolean wrapIsPresent = whiteSpace.containsLineFeeds();\n\n    final Wrap wrap = myCurrentBlock.getWrap();\n    if (shouldUseWrap(wrap) || wrapIsPresent) {\n      whiteSpace.ensureLineFeed();\n      if (wrapCanBeUsedInTheFuture(wrap)) {\n        wrap.markAsUsed();\n      }\n      if (wrap != null && wrap.getFirstEntry() >= 0) {\n        myReparseFromOffset = wrap.getFirstEntry();\n        wrap.markAsUsed();\n        shiftToOffset(myReparseFromOffset);\n        myReparseFromOffset = -1;\n        return true;\n      }\n    } else if (isCandidateToBeWrapped(wrap)){\n      myWrapCandidates.clear();\n      myWrapCandidates.add(myCurrentBlock);\n    } else if (wrapCanBeUsedInTheFuture(wrap) && !wrapIsPresent) {\n      wrap.saveFirstEntry(textRange.getStartOffset());\n    }\n\n    if (!whiteSpace.containsLineFeeds() && lineOver() && !myWrapCandidates.isEmpty()) {\n      myCurrentBlock = myWrapCandidates.get(myWrapCandidates.size() - 1);\n      return true;\n    }\n\n    return false;\n  }","id":43623,"modified_method":"private boolean processWrap() {\n    final WhiteSpace whiteSpace = myCurrentBlock.getWhiteSpace();\n    final TextRange textRange = myCurrentBlock.getTextRange();\n    final Wrap wrap = myCurrentBlock.getWrap();\n\n    boolean wrapIsPresent = whiteSpace.containsLineFeeds();\n\n    if (wrap != null) {\n      wrap.processNextEntry(textRange.getStartOffset());\n    }\n\n    if (shouldUseWrap(wrap) || wrapIsPresent) {\n      if (wrap != null && wrap.getFirstEntry() >= 0) {\n        myReparseFromOffset = wrap.getFirstEntry();\n        wrap.markAsUsed();\n        shiftToOffset(myReparseFromOffset);\n        myReparseFromOffset = -1;\n        return true;\n      } else if (wrap != null && wrapCanBeUsedInTheFuture(wrap)) {\n        wrap.markAsUsed();\n      }\n      whiteSpace.ensureLineFeed();\n    } else {\n      if (wrap != null) {\n        if (isCandidateToBeWrapped(wrap)){\n          myWrapCandidates.clear();\n          myWrapCandidates.add(myCurrentBlock);\n        }\n        if (wrapCanBeUsedInTheFuture(wrap)) {\n          wrap.saveFirstEntry(textRange.getStartOffset());\n        }\n      }\n    }\n\n    if (!whiteSpace.containsLineFeeds() && lineOver() && !myWrapCandidates.isEmpty() && !whiteSpace.isReadOnly()) {\n      myCurrentBlock = myWrapCandidates.get(myWrapCandidates.size() - 1);\n      return true;\n    }\n\n    return false;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getOffsetBefore(final BlockWrapper info) {\n    final List<Block> subBlocks = info.getBlock().getSubBlocks();\n    if (subBlocks.isEmpty()) {\n      return getOffsetBefore(info.getBlock());\n    } else {\n      return getOffsetBefore(getBlockInfo(subBlocks.get(0)));\n    }\n  }","id":43624,"modified_method":"private int getOffsetBefore(final BlockWrapper info) {\n    final List<Block> subBlocks = info.getSubBlocks();\n    if (subBlocks.isEmpty()) {\n      return getOffsetBefore(info.getBlock());\n    } else {\n      return getOffsetBefore(getBlockInfo(subBlocks.get(0)));\n    }\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void shiftToOffset(final int marker) {\n    while (myCurrentBlock.getPreviousBlock() != null && myCurrentBlock.getBlock().getTextRange().getStartOffset() > marker) {\n      if (myCurrentBlock.getWhiteSpace().containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n      myCurrentBlock = myCurrentBlock.getPreviousBlock();\n      if (myCurrentBlock.containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n    }\n  }","id":43625,"modified_method":"private void shiftToOffset(final int marker) {\n    while (myCurrentBlock.getPreviousBlock() != null && myCurrentBlock.getTextRange().getStartOffset() > marker) {\n      if (myCurrentBlock.getWhiteSpace().containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n      myCurrentBlock = myCurrentBlock.getPreviousBlock();\n      if (myCurrentBlock.containsLineFeeds()) {\n        onCurrentLineChanged();\n      }\n    }\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Block getNearestIndentedParent(Block block) {\n    if (block == null) return null;\n    final Block parent = block.getParent();\n    if (getBlockInfo(block).notIsFirstElement()) return parent;\n    return getNearestIndentedParent(parent);\n  }","id":43626,"modified_method":"private Block getNearestIndentedParent(Block block, Block current) {\n    if (block == null) return null;\n    final Block parent = block.getParent();\n    if (parent == null) return null;\n    if (!current.skipIndent(parent) && getBlockInfo(block).notIsFirstElement()) return parent;\n    return getNearestIndentedParent(parent, current);\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FormatterImpl(FormattingModel model, Block rootBlock, CodeStyleSettings settings, CodeStyleSettings.IndentOptions indentOptions) {\n    myModel = model;\n    myIndentOption = indentOptions;\n    mySettings = settings;\n    final InitialInfoBuilder builder = InitialInfoBuilder.buildBlocks(rootBlock, model);\n    myInfos = builder.getBlockToInfoMap();\n    myCurrentBlock = builder.getFirstTokenBlock();\n  }","id":43627,"modified_method":"public FormatterImpl(FormattingModel model,\n                       Block rootBlock,\n                       CodeStyleSettings settings,\n                       CodeStyleSettings.IndentOptions indentOptions,\n                       TextRange affectedRange) {\n    myModel = model;\n    myIndentOption = indentOptions;\n    mySettings = settings;\n    final InitialInfoBuilder builder = InitialInfoBuilder.buildBlocks(rootBlock, model, affectedRange);\n    myInfos = builder.getBlockToInfoMap();\n    myCurrentBlock = builder.getFirstTokenBlock();\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean shouldUseWrap(final Wrap wrap) {\n    if (myWrapCandidates.contains(myCurrentBlock)) return true;\n    if (wrap == null) return false;\n    if (wrap.isIsActive()) return true;\n    final Wrap.Type type = wrap.getType();\n    if (type == Wrap.Type.WRAP_ALWAYS) return true;\n    if (type == Wrap.Type.WRAP_AS_NEEDED || type == Wrap.Type.CHOP_IF_NEEDED) {\n      return lineOver();\n    }\n    return false;\n  }","id":43628,"modified_method":"private boolean shouldUseWrap(final Wrap wrap) {\n    if (myWrapCandidates.contains(myCurrentBlock)) return true;\n    if (wrap == null) return false;\n    if (!isSuitableInTheCurrentPosition(wrap)) return false;\n    if (wrap.isIsActive()) return true;\n    final Wrap.Type type = wrap.getType();\n    if (type == Wrap.Type.WRAP_ALWAYS) return true;\n    if (type == Wrap.Type.WRAP_AS_NEEDED || type == Wrap.Type.CHOP_IF_NEEDED) {\n      return lineOver();\n    }\n    return false;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean wrapCanBeUsedInTheFuture(final Wrap wrap) {\n    return wrap != null && wrap.getType() == Wrap.Type.CHOP_IF_NEEDED;\n  }","id":43629,"modified_method":"private boolean wrapCanBeUsedInTheFuture(final Wrap wrap) {\n    return wrap != null && wrap.getType() == Wrap.Type.CHOP_IF_NEEDED &&\n           (isSuitableInTheCurrentPosition(wrap));\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getIndent(final Block block) {\n    final Indent indent = getBlockInfo(block).getChildIndent();\n    if (indent == null) return myIndentOption.CONTINUATION_INDENT_SIZE;\n    if (indent.getType() == Indent.Type.NORMAL) return myIndentOption.INDENT_SIZE;\n    return myIndentOption.LABEL_INDENT_SIZE;\n  }","id":43630,"modified_method":"private int getIndent(final Indent indent) {\n    if (indent == null) return myIndentOption.CONTINUATION_INDENT_SIZE;\n    if (indent.getType() == Indent.Type.NONE) return 0;\n    if (indent.getType() == Indent.Type.NORMAL) return myIndentOption.INDENT_SIZE;\n    return myIndentOption.LABEL_INDENT_SIZE;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getSpaces() {\n    return mySpaces;\n  }","id":43631,"modified_method":"int getSpaces() {\n    return mySpaces;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Type getType() {\n    return myType;\n  }","id":43632,"modified_method":"Type getType() {\n    return myType;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getCount() {\n    return myCount;\n  }","id":43633,"modified_method":"int getCount() {\n    return myCount;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static final InitialInfoBuilder buildBlocks(Block root, FormattingModel model) {\n    final InitialInfoBuilder builder = new InitialInfoBuilder(model);\n    builder.buildFrom(root, 0);\n    return builder;\n  }","id":43634,"modified_method":"public static final InitialInfoBuilder buildBlocks(Block root, FormattingModel model, final TextRange affectedRange) {\n    final InitialInfoBuilder builder = new InitialInfoBuilder(model, affectedRange);\n    builder.buildFrom(root, 0);\n    return builder;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private InitialInfoBuilder(final FormattingModel model) {\n    myModel = model;\n    myCurrentWhiteSpace = new WhiteSpace(0, 0, 0, 0, true);\n  }","id":43635,"modified_method":"private InitialInfoBuilder(final FormattingModel model, final TextRange affectedRange) {\n    myModel = model;\n    myAffectedRange = affectedRange;\n    myCurrentWhiteSpace = new WhiteSpace(0, 0, 0, 0, true);\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildFrom(final Block rootBlock, final int index) {\n    final TextRange textRange = rootBlock.getTextRange();\n    final int blockStartOffset = textRange.getStartOffset();\n    myCurrentWhiteSpace.append(blockStartOffset, myModel);\n    final BlockWrapper info = new BlockWrapper(rootBlock, myCurrentWhiteSpace, myModel, myPreviousBlock, index, myResult);\n    myResult.put(rootBlock, info);\n    final List<Block> subBlocks = rootBlock.getSubBlocks();\n    if (subBlocks.isEmpty()) {\n      LOG.assertTrue(rootBlock.getTextRange().getLength() > 0);\n      if (myPreviousBlock != null) {\n        myPreviousBlock.setNextBlock(info);\n      }\n      if (myFirstTokenBlock == null) {\n        myFirstTokenBlock = info;\n      }\n      if (myCurrentSpaceProperty != null && myCurrentSpaceProperty.isReadOnly()) {\n        myCurrentWhiteSpace.setReadOnly();\n      }\n      myCurrentWhiteSpace = new WhiteSpace(textRange.getEndOffset(), textRange.getEndOffset(), 0, 0, false);\n      myPreviousBlock = info;\n    } else {\n      Block previous = null;\n      for (int i = 0; i < subBlocks.size(); i++) {\n        final Block block = subBlocks.get(i);\n        if (previous != null) {\n          myCurrentSpaceProperty = rootBlock.getSpaceProperty(previous, block);\n        }\n        buildFrom(block, i);\n        previous = block;\n      }\n    }\n  }","id":43636,"modified_method":"private void buildFrom(final Block rootBlock, final int index) {\n    final TextRange textRange = rootBlock.getTextRange();\n    final int blockStartOffset = textRange.getStartOffset();\n    myCurrentWhiteSpace.append(blockStartOffset, myModel);\n    boolean isReadOnly = isReadOnly(textRange);\n    final BlockWrapper info = new BlockWrapper(rootBlock, myCurrentWhiteSpace, myModel, myPreviousBlock, index, myResult, isReadOnly, textRange);\n    myResult.put(rootBlock, info);\n    final List<Block> subBlocks = rootBlock.getSubBlocks();\n    if (subBlocks.isEmpty() || isReadOnly) {\n      LOG.assertTrue(textRange.getLength() > 0);\n      if (myPreviousBlock != null) {\n        myPreviousBlock.setNextBlock(info);\n      }\n      if (myFirstTokenBlock == null) {\n        myFirstTokenBlock = info;\n      }\n      if (currentWhiteSpaceIsRreadOnly()) {\n        myCurrentWhiteSpace.setReadOnly();\n      }\n      myCurrentWhiteSpace = new WhiteSpace(textRange.getEndOffset(), textRange.getEndOffset(), 0, 0, false);\n      myPreviousBlock = info;\n    } else {\n      Block previous = null;\n      for (int i = 0; i < subBlocks.size(); i++) {\n        final Block block = subBlocks.get(i);\n        if (previous != null) {\n          myCurrentSpaceProperty = rootBlock.getSpaceProperty(previous, block);\n        }\n        buildFrom(block, i);\n        previous = block;\n      }\n    }\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getMaxLineFeeds() {\n    return myMaxLineFeeds;\n  }","id":43637,"modified_method":"int getMaxLineFeeds() {\n    return myMaxLineFeeds;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getMinSpaces() {\n    return myMinSpaces;\n  }","id":43638,"modified_method":"int getMinSpaces() {\n    return myMinSpaces;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getMinLineFeeds() {\n    return myMinLineFeeds;\n  }","id":43639,"modified_method":"int getMinLineFeeds() {\n    return myMinLineFeeds;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isReadOnly(){\n    return myIsReadOnly;\n  }","id":43640,"modified_method":"boolean isReadOnly(){\n    return myIsReadOnly;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getMaxSpaces() {\n    return myMaxSpaces;\n  }","id":43641,"modified_method":"int getMaxSpaces() {\n    return myMaxSpaces;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void append(int newEndOffset, FormattingModel model) {\n    final int oldEndOffset = myTextRange.getEndOffset();\n    if (newEndOffset == oldEndOffset) return;\n    int oldLastLine = model.getLineNumber(oldEndOffset);\n    int newLine = model.getLineNumber(newEndOffset);\n    myTextRange = new TextRange(myTextRange.getStartOffset(), newEndOffset);\n    final int lineIncrement = newLine - oldLastLine;\n    if (lineIncrement > 0) {\n      mySpaces = newEndOffset - model.getLineStartOffset(model.getLineNumber(newEndOffset));\n    } else {\n      mySpaces += myTextRange.getEndOffset() - oldEndOffset;\n    }\n    myLineFeeds += lineIncrement;\n  }","id":43642,"modified_method":"public void append(int newEndOffset, FormattingModel model) {\n    final int oldEndOffset = myTextRange.getEndOffset();\n    if (newEndOffset == oldEndOffset) return;\n    int oldLastLine = model.getLineNumber(oldEndOffset);\n    int newLine = model.getLineNumber(newEndOffset);\n    myTextRange = new TextRange(myTextRange.getStartOffset(), newEndOffset);\n    final int lineIncrement = newLine - oldLastLine;\n    if (lineIncrement > 0) {\n      mySpaces = newEndOffset - model.getLineStartOffset(model.getLineNumber(newEndOffset));\n    } else {\n      mySpaces += myTextRange.getEndOffset() - oldEndOffset;\n    }\n    myLineFeeds += lineIncrement;\n\n    myInitial = model.getText(myTextRange);\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Type getType() {\n    return myType;\n  }","id":43643,"modified_method":"Type getType() {\n    return myType;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getFirstEntry() {\n    return myFirstEntry;\n  }","id":43644,"modified_method":"int getFirstEntry() {\n    return myFirstEntry;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void saveFirstEntry(final int startOffset) {\n    if (myFirstEntry < 0) {\n      myFirstEntry = startOffset;\n    }\n  }","id":43645,"modified_method":"void saveFirstEntry(final int startOffset) {\n    if (myFirstEntry < 0) {\n      myFirstEntry = startOffset;\n    }\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void markAsUsed() {\n    myFirstEntry = -1;\n    myIsActive = true;\n  }","id":43646,"modified_method":"void markAsUsed() {\n    myFirstEntry = -1;\n    myIsActive = true;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isIsActive() {\n    return myIsActive;\n  }","id":43647,"modified_method":"boolean isIsActive() {\n    return myIsActive;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Wrap(final Type type) {\n    myType = type;\n\n  }","id":43648,"modified_method":"public Wrap(final Type type, boolean wrapFirstElement) {\n    myType = type;\n    myWrapFirstElement = wrapFirstElement;\n\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<Block> buildChildren() {\n    final ArrayList<Block> result = new ArrayList<Block>();\n    if (myNode.getElementType() == ElementType.XML_TEXT && mySettings.XML_KEEP_WHITESPACES) {\n      return result;\n    }\n    if (myNode instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(myNode);\n      ASTNode child = myNode.getFirstChildNode();\n      final Wrap tagWrap = new Wrap(Wrap.Type.WRAP_ALWAYS);\n      final Wrap attrWrap = new Wrap(getWrapType(mySettings.XML_ATTRIBUTE_WRAP));\n      final Wrap textWrap = new Wrap(getWrapType(mySettings.XML_TEXT_WRAP));\n      final Alignment attrAlignment = new Alignment(Alignment.Type.NORMAL);\n      final Alignment textAlignment = new Alignment(Alignment.Type.NORMAL);\n      while (child != null) {\n        if (child.getElementType() != ElementType.WHITE_SPACE && child.getText().trim().length() > 0){\n          Wrap wrap = chooseWrap(child, tagWrap, attrWrap, textWrap);\n          Alignment alignment = chooseAlignment(child, attrAlignment, textAlignment);\n          result.add(new XmlBlock(child, wrap, alignment, mySettings));\n        }\n        child = child.getTreeNext();\n      }\n    }\n    return result;\n  }","id":43649,"modified_method":"private List<Block> buildChildren() {\n    final ArrayList<Block> result = new ArrayList<Block>();\n    if (myNode.getElementType() == ElementType.XML_TEXT && mySettings.XML_KEEP_WHITESPACES) {\n      return result;\n    }\n    if (myNode instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(myNode);\n      ASTNode child = myNode.getFirstChildNode();\n      final Wrap tagWrap = new Wrap(Wrap.Type.WRAP_ALWAYS,true);\n      final Wrap attrWrap = new Wrap(getWrapType(mySettings.XML_ATTRIBUTE_WRAP), false);\n      final Wrap textWrap = new Wrap(getWrapType(mySettings.XML_TEXT_WRAP), true);\n      final Alignment attrAlignment = new Alignment(Alignment.Type.NORMAL);\n      final Alignment textAlignment = new Alignment(Alignment.Type.NORMAL);\n      while (child != null) {\n        if (!containsWhiteSpacesOnly(child) && child.getTextLength() > 0){\n          Wrap wrap = chooseWrap(child, tagWrap, attrWrap, textWrap);\n          Alignment alignment = chooseAlignment(child, attrAlignment, textAlignment);\n          result.add(new XmlBlock(child, wrap, alignment, mySettings, this));\n        }\n        child = child.getTreeNext();\n      }\n    }\n    return result;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Block getParent() {\n    final ASTNode treeParent = myNode.getTreeParent();\n    return treeParent == null ? null : treeParent.getUserData(KEY);\n  }","id":43650,"modified_method":"public Block getParent() {\n    return myParent;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Wrap getWrap() {\n    return myNode.getUserData(WRAP_KEY);\n  }","id":43651,"modified_method":"public Wrap getWrap() {\n    return myWrap;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Alignment getAlignment() {\n    return myNode.getUserData(ALIGN_KEY);\n  }","id":43652,"modified_method":"public Alignment getAlignment() {\n    return myAlignment;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlBlock(final ASTNode node, final Wrap wrap, final Alignment alignment, CodeStyleSettings settings) {\n    myNode = node;\n    myNode.putUserData(ALIGN_KEY, alignment);\n    myNode.putUserData(WRAP_KEY, wrap);\n    myNode.putUserData(KEY, this);\n    mySettings = settings;\n    myText = myNode.getText();\n  }","id":43653,"modified_method":"public XmlBlock(final ASTNode node, final Wrap wrap, final Alignment alignment, CodeStyleSettings settings, XmlBlock parent) {\n    myNode = node;\n    myWrap = wrap;\n    myAlignment = alignment;\n    mySettings = settings;\n    myParent = parent;\n    myDefaultProperty = new SpaceProperty(0, Integer.MAX_VALUE, 0, getMaxLine(), false);\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SpaceProperty getSpaceProperty(Block child1, Block child2) {\n    final IElementType elementType = myNode.getElementType();\n    final IElementType type1 = ((XmlBlock)child1).myNode.getElementType();\n    final IElementType type2 = ((XmlBlock)child2).myNode.getElementType();\n    if (elementType == ElementType.XML_TAG) {\n      if (isXmlTagName(type1, type2)){\n        final int spaces = mySettings.XML_SPACE_AROUND_TAG_NAME ? 1 : 0;\n        return new SpaceProperty(spaces, spaces, 0, getMaxLine(), false);\n      } else if (type2 == ElementType.XML_ATTRIBUTE) {\n        return new SpaceProperty(1, 1, 0, getMaxLine(), false);\n      }\n    }\n    if ((type2 == ElementType.XML_TAG || type2 == ElementType.XML_END_TAG_START || type2 == ElementType.XML_TEXT) && mySettings.XML_KEEP_WHITESPACES) {\n      return new SpaceProperty(0,0,0,0,true);\n    }\n    if (type1 == ElementType.XML_DATA_CHARACTERS && type2 == ElementType.XML_DATA_CHARACTERS) {\n      return new SpaceProperty(1, 1, 0, getMaxLine(), false);\n    }\n    if (type2 == ElementType.XML_TEXT && type1 == ElementType.XML_TAG) {\n      return new SpaceProperty(0, 0, 1, getMaxLine(), false);\n    }\n    if (type1 == ElementType.XML_TEXT && type2 == ElementType.XML_END_TAG_START) {\n      return new SpaceProperty(0, 0, 0, getMaxLine(), false);\n    }\n\n    if (type2 == ElementType.XML_TEXT && type1 == ElementType.XML_TAG_END) {\n      return new SpaceProperty(0, 0, 0, getMaxLine(), false);\n    }\n\n    if (elementType == ElementType.XML_ATTRIBUTE) {\n      if (type1 == ElementType.XML_EQ || type2 == ElementType.XML_EQ) {\n        int spaces = mySettings.XML_SPACE_AROUND_EQUALITY_IN_ATTRINUTE ? 1 : 0;\n        return new SpaceProperty(spaces, spaces, 0, getMaxLine(), false);\n      }\n    }\n\n    return new SpaceProperty(0, Integer.MAX_VALUE, 0, getMaxLine(), false);\n  }","id":43654,"modified_method":"public SpaceProperty getSpaceProperty(Block child1, Block child2) {\n    final IElementType elementType = myNode.getElementType();\n    final IElementType type1 = ((XmlBlock)child1).myNode.getElementType();\n    final IElementType type2 = ((XmlBlock)child2).myNode.getElementType();\n\n    if ((type2 == ElementType.XML_TAG || type2 == ElementType.XML_END_TAG_START || type2 == ElementType.XML_TEXT) && mySettings.XML_KEEP_WHITESPACES) {\n      return new SpaceProperty(0,0,0,0,true);\n    }\n\n    if (elementType == ElementType.XML_TAG) {\n      return getSpacesInsideTag(type1, type2);\n\n    } else if (elementType == ElementType.XML_TEXT) {\n      return getSpacesInsideText(type1, type2);\n\n    } else if (elementType == ElementType.XML_ATTRIBUTE) {\n      return getSpacesInsideAttribute(type1, type2);\n    }\n\n    return myDefaultProperty;\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Indent getChildIndent() {\n    return myNode.getElementType() == ElementType.XML_TAG ? new Indent(Indent.Type.NORMAL, 1, 0) : null;\n  }","id":43655,"modified_method":"public Indent getChildIndent() {\n    final IElementType elementType = myNode.getElementType();\n    if (elementType == ElementType.XML_DOCUMENT || elementType == ElementType.XML_PROLOG) {\n      return new Indent(Indent.Type.NONE, 0,0);\n    } else {\n      return elementType == ElementType.XML_TAG ? new Indent(Indent.Type.NORMAL, 1, 0) : null;\n    }\n  }","commit_id":"b7342da711d807a1b926d48f48b39219089a5916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Digraph drawPTC(TreeConstructionReportImpl rep) {\n\t\tDigraph d = new Digraph();\n\t\tSet<AbstractToken> drawn = new HashSet<AbstractToken>();\n\t\tSet<ParserRule> drawnRules = new HashSet<ParserRule>();\n\t\tList<AbstractToken> traces = new ArrayList<AbstractToken>();\n\t\ttraces.add(rep.getSuccess());\n\t\ttraces.addAll(rep.getDeadends());\n\t\tboolean sol = true;\n\t\tfor (AbstractToken t : traces) {\n\t\t\twhile (t != null && !drawn.contains(t)) {\n\t\t\t\t// String ser = ((AbstractToken) t).serialize().replaceAll(\n\t\t\t\t// \"\\\\\\\\\", \"\\\\\\\\\");\n\t\t\t\tString s = t.getClass().getSimpleName() + \"\\\\n\"\n\t\t\t\t\t\t+ t.getCurrent() + \"\\\\n'\" /* + ser */+ \"'\";\n\t\t\t\td.add(new Node(t, s));\n\t\t\t\tif (t.getGrammarElement() != null) {\n\t\t\t\t\tParserRule pr = GrammarUtil.containingParserRule(t\n\t\t\t\t\t\t\t.getGrammarElement());\n\t\t\t\t\tif (pr != null && !drawnRules.contains(pr)) {\n\t\t\t\t\t\tdrawnRules.add(pr);\n\t\t\t\t\t\tdrawRule(pr, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (t.getNext() != null) {\n\t\t\t\t\tEdge e = new Edge(t.getNext(), t);\n\t\t\t\t\te.setLabel(String.valueOf(((AbstractToken) t).getNo()));\n\t\t\t\t\tif (!sol)\n\t\t\t\t\t\te.setStyle(\"dashed\");\n\t\t\t\t\td.add(e);\n\t\t\t\t}\n\t\t\t\tdrawn.add(t);\n\t\t\t\tt = (AbstractToken) t.getNext();\n\t\t\t}\n\t\t\tsol = false;\n\t\t}\n\t\treturn d;\n\t}","id":43656,"modified_method":"protected Digraph drawPTC(TreeConstructionReportImpl rep) {\n\t\tDigraph d = new Digraph();\n\t\tSet<AbstractToken> drawn = new HashSet<AbstractToken>();\n\t\tSet<ParserRule> drawnRules = new HashSet<ParserRule>();\n\t\tList<AbstractToken> traces = new ArrayList<AbstractToken>();\n\t\ttraces.add(rep.getSuccess());\n\t\ttraces.addAll(rep.getDeadends());\n\t\tboolean sol = true;\n\t\tfor (AbstractToken t : traces) {\n\t\t\twhile (t != null && !drawn.contains(t)) {\n\t\t\t\t// String ser = ((AbstractToken) t).serialize().replaceAll(\n\t\t\t\t// \"\\\\\\\\\", \"\\\\\\\\\");\n\t\t\t\tString s = t.getClass().getSimpleName() + \"\\\\n\"\n\t\t\t\t\t\t+ t.getCurrent() + \"\\\\n'\" /* + ser */+ \"'\";\n\t\t\t\td.add(new Node(t, s));\n\t\t\t\tif (t.getGrammarElement() != null) {\n\t\t\t\t\tParserRule pr = GrammarUtil.containingParserRule(t\n\t\t\t\t\t\t\t.getGrammarElement());\n\t\t\t\t\tif (pr != null && !drawnRules.contains(pr)) {\n\t\t\t\t\t\tdrawnRules.add(pr);\n\t\t\t\t\t\tdrawRule(pr, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (t.getNext() != null) {\n\t\t\t\t\tEdge e = new Edge(t.getNext(), t);\n\t\t\t\t\te.setLabel(String.valueOf((t).getNo()));\n\t\t\t\t\tif (!sol)\n\t\t\t\t\t\te.setStyle(\"dashed\");\n\t\t\t\t\td.add(e);\n\t\t\t\t}\n\t\t\t\tdrawn.add(t);\n\t\t\t\tt = t.getNext();\n\t\t\t}\n\t\t\tsol = false;\n\t\t}\n\t\treturn d;\n\t}","commit_id":"eab67c19788dfe8e19cfb8649a1607e5fa1f79c4","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void setStatusStyle(Props p, Status s) {\n\t\tswitch (s) {\n\t\tcase AMBIGIOUS:\n\t\t\tp.put(\"color\", \"green\");\n\t\t\tbreak;\n\t\tcase DETOUR_OR_LOOP:\n\t\t\tp.put(\"color\", \"blue\");\n\t\t\tbreak;\n\t\tcase ORPHAN:\n\t\t\tp.put(\"color\", \"grey\");\n\t\t\tbreak;\n\t\tcase UNKNOWN:\n\t\t\tp.put(\"color\", \"red\");\n\t\t\tbreak;\n\t\t}\n\t}","id":43657,"modified_method":"protected void setStatusStyle(Props p, Status s) {\n\t\tswitch (s) {\n\t\t\tcase AMBIGIOUS:\n\t\t\t\tp.put(\"color\", \"green\");\n\t\t\t\tbreak;\n\t\t\tcase DETOUR_OR_LOOP:\n\t\t\t\tp.put(\"color\", \"blue\");\n\t\t\t\tbreak;\n\t\t\tcase ORPHAN:\n\t\t\t\tp.put(\"color\", \"grey\");\n\t\t\t\tbreak;\n\t\t\tcase UNKNOWN:\n\t\t\t\tp.put(\"color\", \"red\");\n\t\t\t\tbreak;\n\t\t\tcase ENABLED:\n\t\t\t\tbreak;\n\t\t}\n\t}","commit_id":"eab67c19788dfe8e19cfb8649a1607e5fa1f79c4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n    public void strictEntailment() {\n        StatefulKnowledgeSession kSession = getSession( \"strict.drl\" );\n        Map<String, FactHandle> handles = new HashMap<String, FactHandle>();\n        kSession.fireAllRules();\n\n        EntryPoint ep = kSession.getEntryPoint(EntryPointId.DEFAULT.getEntryPointId());\n        TruthMaintenanceSystem tms = ((NamedEntryPoint)ep).getTruthMaintenanceSystem();\n\n        assertEquals(2, tms.getEqualityKeyMap().size());\n        assertEquals( 5, kSession.getObjects().size() );\n\n        checkDefeasibilityByHandleId( getEqualityKey(\"C( id=99 )\", tms), DefeasibilityStatus.DEFINITELY, 2, 2 );\n        checkDefeasibilityByHandleId( getEqualityKey(\"D( id=-5 )\", tms), DefeasibilityStatus.DEFINITELY, 1, 1);\n    }","id":43658,"modified_method":"@Test\n    public void testStrictEntailment() {\n        StatefulKnowledgeSession kSession = getSession( \"org/drools/compiler/beliefsystem/defeasible/strict.drl\" );\n        kSession.fireAllRules();\n\n//        TruthMaintenanceSystem tms = ( (StatefulKnowledgeSessionImpl) kSession ).session.getTruthMaintenanceSystem();\n\n        TruthMaintenanceSystem tms = ((NamedEntryPoint) kSession.getEntryPoint( \"DEFAULT\" )).getTruthMaintenanceSystem();\n        FactType Ctype = kSession.getKieBase().getFactType( \"org.drools.defeasible\", \"C\" );\n        FactType Dtype = kSession.getKieBase().getFactType( \"org.drools.defeasible\", \"D\" );\n\n\n        ObjectHashMap keys = tms.getEqualityKeyMap();\n        Iterator iter = keys.iterator();\n        ObjectHashMap.ObjectEntry entry;\n        while ( ( entry = ( ObjectHashMap.ObjectEntry) iter.next() ) != null ) {\n            EqualityKey key = (EqualityKey) entry.getValue();\n\n            Class factClass = key.getFactHandle().getObject().getClass();\n            if ( factClass == Ctype.getFactClass() ) {\n                checkStatus( key, 2, DefeasibilityStatus.DEFINITELY );\n            } else if ( factClass == Dtype.getFactClass() ) {\n                checkStatus( key, 1, DefeasibilityStatus.DEFINITELY );\n            } else {\n                fail( \"Unrecognized object has been logically justified : \" + factClass );\n            }\n        }\n\n        assertEquals( 5, kSession.getObjects().size() );\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void checkDefeasibilityByHandleId( EqualityKey key, DefeasibilityStatus status, int insertSize, int undefeatedSize ) {\n        DefeasibleBeliefSet dbs = (DefeasibleBeliefSet) key.getBeliefSet();\n\n        assertEquals( status, dbs.getStatus() );\n\n        switch ( status ) {\n            case DEFINITELY:\n//                assertTrue( dbs.getDeliberation() == BeliefSet.FACT_WMSTATE.IN );\n//                assertTrue( dbs.isDefinitelyProvable() );\n//                assertTrue( dbs.isDefeasiblyProvable() );\n//                assertFalse( dbs.isUndecidable() );\n//                assertFalse( dbs.isDefeated() );\n                break;\n\n            case DEFEASIBLY:\n//                assertTrue( dbs.getDeliberation() == BeliefSet.FACT_WMSTATE.IN );\n//                assertFalse( dbs.isDefinitelyProvable() );\n//                assertTrue( dbs.isDefeasiblyProvable() );\n//                assertFalse( dbs.isUndecidable() );\n//                assertFalse( dbs.isDefeated() );\n                break;\n\n            case DEFEATEDLY:\n//                assertTrue( dbs.getDeliberation() == BeliefSet.FACT_WMSTATE.HELD );\n//                assertFalse( dbs.isDefinitelyProvable() );\n//                assertFalse( dbs.isDefeasiblyProvable() );\n//                assertFalse( dbs.isUndecidable() );\n//                assertTrue( dbs.isDefeated() );\n                break;\n\n            case UNDECIDABLY:\n//                assertTrue( dbs.getDeliberation() == BeliefSet.FACT_WMSTATE.HELD );\n//                assertFalse( dbs.isDefinitelyProvable() );\n//                assertFalse( dbs.isDefeasiblyProvable() );\n//                assertTrue( dbs.isUndecidable() );\n//                assertFalse( dbs.isDefeated() );\n                break;\n        }\n\n        assertEquals( insertSize, dbs.size() );\n        assertEquals( undefeatedSize, dbs.undefeatdSize() );\n    }","id":43659,"modified_method":"private void checkStatus( EqualityKey key, int support, DefeasibilityStatus status ) {\n        assertEquals( EqualityKey.JUSTIFIED, key.getStatus() );\n        BeliefSet set = key.getBeliefSet();\n        assertTrue( set instanceof DefeasibleBeliefSet );\n        DefeasibleBeliefSet dfs = ( DefeasibleBeliefSet ) set;\n//        LinkedListNode n = dfs.getFirst();\n//        do {\n//            System.out.println( n );\n//            n = (LinkedListNode) n.getNext();\n//        } while ( n != null );\n\n        assertEquals( support, dfs.size() );\n        assertEquals( status, dfs.getStatus() );\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void defeasibleEntailment( ) {\n        StatefulKnowledgeSession kSession = getSession( \"strictOverride.drl\" );\n        kSession.fireAllRules();\n\n        EntryPoint ep = kSession.getEntryPoint(EntryPointId.DEFAULT.getEntryPointId());\n        TruthMaintenanceSystem tms = ((NamedEntryPoint)ep).getTruthMaintenanceSystem();\n\n        assertEquals( 2, tms.getEqualityKeyMap().size());\n        assertEquals( 5, kSession.getObjects().size() );\n\n        checkDefeasibilityByHandleId( getEqualityKey(\"X( id=-1 )\", tms), DefeasibilityStatus.DEFINITELY, 3, 2);\n        checkDefeasibilityByHandleId( getEqualityKey(\"C( id=99 )\", tms), DefeasibilityStatus.DEFINITELY, 1, 1);\n    }","id":43660,"modified_method":"@Test\n    public void testDefeasibleEntailmentWithStrictOverride() {\n        StatefulKnowledgeSession kSession = getSession( \"org/drools/compiler/beliefsystem/defeasible/strictOverride.drl\" );\n        kSession.fireAllRules();\n\n        TruthMaintenanceSystem tms = ((NamedEntryPoint) kSession.getEntryPoint( \"DEFAULT\" )).getTruthMaintenanceSystem();\n        FactType Ctype = kSession.getKieBase().getFactType( \"org.drools.defeasible\", \"C\" );\n        FactType Xtype = kSession.getKieBase().getFactType( \"org.drools.defeasible\", \"X\" );\n\n\n        ObjectHashMap keys = tms.getEqualityKeyMap();\n        Iterator iter = keys.iterator();\n        ObjectHashMap.ObjectEntry entry;\n        while ( ( entry = ( ObjectHashMap.ObjectEntry) iter.next() ) != null ) {\n            EqualityKey key = (EqualityKey) entry.getValue();\n\n            Class factClass = key.getFactHandle().getObject().getClass();\n            if ( factClass == Ctype.getFactClass() ) {\n                checkStatus( key, 1, DefeasibilityStatus.DEFINITELY );\n            } else if ( factClass == Xtype.getFactClass() ) {\n                checkStatus( key, 1, DefeasibilityStatus.DEFINITELY );\n            } else {\n                fail( \"Unrecognized object has been logically justified : \" + factClass );\n            }\n        }\n\n        for ( Object o : kSession.getObjects() ) {\n            System.out.println( o );\n        }\n        assertEquals( 5, kSession.getObjects().size() );\n\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void defeasibleEntailmentMultiActivation( ) {\n        StatefulKnowledgeSession kSession = getSession( \"defeat.drl\" );\n        kSession.fireAllRules();\n\n        EntryPoint ep = kSession.getEntryPoint(EntryPointId.DEFAULT.getEntryPointId());\n        TruthMaintenanceSystem tms = ((NamedEntryPoint)ep).getTruthMaintenanceSystem();\n\n        assertEquals( 1, tms.getEqualityKeyMap().size() );\n        assertEquals( 4, kSession.getObjects().size() );\n\n        //checkDefeasibilityByHandleId( 4, DefeasibilityStatus.UNDECIDABLY, 3, 3, tms );\n        checkDefeasibilityByHandleId( getEqualityKey(\"X( id=-1 )\", tms), DefeasibilityStatus.UNDECIDABLY, 3, 3 );\n    }","id":43661,"modified_method":"@Test\n    public void defeasibleEntailmentMultiActivation() {\n        StatefulKnowledgeSession kSession = getSession( \"org/drools/compiler/beliefsystem/defeasible/defeat.drl\" );\n        kSession.fireAllRules();\n\n        TruthMaintenanceSystem tms = ((NamedEntryPoint) kSession.getEntryPoint( \"DEFAULT\" )).getTruthMaintenanceSystem();\n        FactType Xtype = kSession.getKieBase().getFactType( \"org.drools.defeasible\", \"X\" );\n\n\n        ObjectHashMap keys = tms.getEqualityKeyMap();\n        Iterator iter = keys.iterator();\n        ObjectHashMap.ObjectEntry entry;\n        while ( ( entry = ( ObjectHashMap.ObjectEntry) iter.next() ) != null ) {\n            EqualityKey key = (EqualityKey) entry.getValue();\n\n            Class factClass = key.getFactHandle().getObject().getClass();\n            if ( factClass == Xtype.getFactClass() ) {\n                checkStatus( key, 3, DefeasibilityStatus.UNDECIDABLY );\n            } else {\n                fail( \"Unrecognized object has been logically justified : \" + factClass );\n            }\n        }\n\n        for ( Object o : kSession.getObjects() ) {\n            System.out.println( o );\n        }\n        assertEquals( 3, kSession.getObjects().size() );\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected StatefulKnowledgeSession getSession( String ruleFile  ) {\n        KnowledgeBuilder kBuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kBuilder.add( ResourceFactory.newClassPathResource(ruleFile, getClass()), ResourceType.DRL );\n        if ( kBuilder.hasErrors() ) {\n            System.err.println( kBuilder.getErrors() );\n            fail();\n        }\n\n        KnowledgeBase kBase = KnowledgeBaseFactory.newKnowledgeBase();\n        kBase.addKnowledgePackages( kBuilder.getKnowledgePackages() );\n\n        KieSessionConfiguration ksConf = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();\n\n        ((SessionConfiguration) ksConf).setBeliefSystemType( BeliefSystemType.DEFEASIBLE );\n\n\n        StatefulKnowledgeSession kSession = kBase.newStatefulKnowledgeSession( ksConf, null );\n        return kSession;\n    }","id":43662,"modified_method":"protected StatefulKnowledgeSession getSession( String ruleFile ) {\n        KnowledgeBuilder kBuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kBuilder.add( ResourceFactory.newClassPathResource( ruleFile ),\n                ResourceType.DRL );\n        if ( kBuilder.hasErrors() ) {\n            System.err.println( kBuilder.getErrors() );\n            fail();\n        }\n\n        KnowledgeBase kBase = KnowledgeBaseFactory.newKnowledgeBase();\n        kBase.addKnowledgePackages( kBuilder.getKnowledgePackages() );\n\n\n        KieSessionConfiguration ksConf = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();\n        ((SessionConfiguration) ksConf).setBeliefSystemType( BeliefSystemType.DEFEASIBLE );\n\n        StatefulKnowledgeSession kSession = kBase.newStatefulKnowledgeSession( ksConf, null );\n        return kSession;\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void addUndefeated(DefeasibleLogicalDependency dep, LinkedListEntry<DefeasibleLogicalDependency> node) {\n        boolean pos = dep.getValue() == null || MODE.POSITIVE.getId().equals( dep.getValue().toString() );\n        switch( dep.getStatus() ) {\n            case DEFINITELY:\n                if ( pos ) {\n                    definitelyPosCount++;\n                    statusMask = statusMask | DEFINITELY_POS_BIT;\n                } else {\n                    definitelyNegCount++;\n                    statusMask = statusMask | DEFINITELY_NEG_BIT;\n                }\n                break;\n            case DEFEASIBLY:\n                if ( pos ) {\n                    defeasiblyPosCount++;\n                    statusMask = statusMask | DEFEASIBLY_POS_BIT;\n                } else {\n                    defeasiblyNegCount++;\n                    statusMask = statusMask | DEFEASIBLY_NEG_BIT;\n                }\n                break;\n            case DEFEATEDLY:\n                if ( pos ) {\n                    defeatedlyPosCount++;\n                    statusMask = statusMask | DEFEATEDLY_POS_BIT;\n                } else {\n                    defeatedlyNegCount++;\n                    statusMask = statusMask | DEFEATEDLY_NEG_BIT;\n                }\n                break;\n            case UNDECIDABLY:\n                throw new IllegalStateException(\"Individual logical dependencies cannot be undecidably\");\n        }\n\n        if (rootUndefeated == null) {\n            rootUndefeated = node;\n            tailUndefeated = node;\n        } else {\n            if ( dep.getStatus() == DefeasibilityStatus.DEFINITELY ) {\n                // Strict dependencies at to the front\n                rootUndefeated.setPrevious(node);\n                node.setNext(rootUndefeated);\n                rootUndefeated = node;\n            } else {\n                // add to end\n                tailUndefeated.setNext(node);\n                node.setPrevious(rootUndefeated);\n                tailUndefeated = node;\n            }\n        }\n    }","id":43663,"modified_method":"public void addUndefeated(DefeasibleLogicalDependency dep, LinkedListEntry<DefeasibleLogicalDependency> node) {\n        boolean pos = dep.getValue() == null || MODE.POSITIVE.getId().equals( dep.getValue().toString() );\n        switch( dep.getStatus() ) {\n            case DEFINITELY:\n                if ( pos ) {\n                    definitelyPosCount++;\n                    statusMask = statusMask | DEFINITELY_POS_BIT;\n                } else {\n                    definitelyNegCount++;\n                    statusMask = statusMask | DEFINITELY_NEG_BIT;\n                }\n                break;\n            case DEFEASIBLY:\n                if ( pos ) {\n                    defeasiblyPosCount++;\n                    statusMask = statusMask | DEFEASIBLY_POS_BIT;\n                } else {\n                    defeasiblyNegCount++;\n                    statusMask = statusMask | DEFEASIBLY_NEG_BIT;\n                }\n                break;\n            case DEFEATEDLY:\n                if ( pos ) {\n                    defeatedlyPosCount++;\n                    statusMask = statusMask | DEFEATEDLY_POS_BIT;\n                } else {\n                    defeatedlyNegCount++;\n                    statusMask = statusMask | DEFEATEDLY_NEG_BIT;\n                }\n                break;\n            case UNDECIDABLY:\n                throw new IllegalStateException(\"Individual logical dependencies cannot be undecidably\");\n        }\n\n        if (rootUndefeated == null) {\n            rootUndefeated = node;\n            tailUndefeated = node;\n        } else {\n            if ( dep.getStatus() == DefeasibilityStatus.DEFINITELY ) {\n                // Strict dependencies at to the front\n                rootUndefeated.setPrevious(node);\n                node.setNext(rootUndefeated);\n                rootUndefeated = node;\n            } else {\n                // add to end\n                tailUndefeated.setNext(node);\n                node.setPrevious(tailUndefeated);\n                tailUndefeated = node;\n            }\n        }\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public FastIterator iterator() {\n        return iterator();\n    }","id":43664,"modified_method":"public FastIterator iterator() {\n        return iterator;\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void updateStatus() {\n        if ( isDefinitelyPosProveable() && !isDefinitelyNegProveable() ) {\n            status = DefeasibilityStatus.DEFINITELY;\n            return;\n        } else if ( !isDefinitelyPosProveable() && isDefinitelyNegProveable() ) {\n            status = DefeasibilityStatus.DEFINITELY;\n            return;\n        }  else if ( isDefinitelyPosProveable() && isDefinitelyNegProveable() ) {\n            status = DefeasibilityStatus.UNDECIDABLY;\n            return;\n        }\n\n        if ( isDefeasiblyPosProveable() && !isDefeasiblyNegProveable() && !isDefeatedlyNegProveable() ) {\n            status = DefeasibilityStatus.DEFEASIBLY;\n            return;\n        } else if ( !isDefeasiblyPosProveable() && !isDefeatedlyPosProveable() && isDefeasiblyNegProveable() ) {\n            status = DefeasibilityStatus.DEFEASIBLY;\n            return;\n        }\n\n//        else if ( isDefinitelyPosProveable() && isDefinitelyNegProveable() ) {\n//            return DefeasibilityStatus.UNDECIDABLY;\n//        }\n\n        status = DefeasibilityStatus.UNDECIDABLY;\n    }","id":43665,"modified_method":"public void updateStatus() {\n        if ( isDefinitelyPosProveable() ^ isDefinitelyNegProveable() ) {\n            status = DefeasibilityStatus.DEFINITELY;\n            return;\n        }\n\n        if ( isConflicting() ) {\n            status = DefeasibilityStatus.UNDECIDABLY;\n            return;\n        }\n\n        if ( isDefeasiblyPosProveable() ^ isDefeasiblyNegProveable() ) {\n            status = DefeasibilityStatus.DEFEASIBLY;\n            return;\n        }\n\n        if ( isDefeatedlyPosProveable() ^ isDefeatedlyNegProveable() ) {\n            status = DefeasibilityStatus.DEFEATEDLY;\n            return;\n        }\n\n        status = DefeasibilityStatus.UNDECIDABLY;\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public BeliefSystem getBeliefSystem() {\n        return null;\n    }","id":43666,"modified_method":"public BeliefSystem getBeliefSystem() {\n        return beliefSystem;\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void add(LinkedListNode node) {\n        DefeasibleLogicalDependency newDep = (DefeasibleLogicalDependency) ((LinkedListEntry) node).getObject();\n        newDep.setStatus(resolveStatus(newDep));\n\n        Rule rule = newDep.getJustifier().getRule();\n\n        // first iterate to see if this new dep is defeated. If it's defeated, it can no longer impacts any deps\n        // if we checked what it defeats, and later this was defeated, we would have undo action. So we do the cheaper work first.\n        boolean wasDefeated = false;\n        for (LinkedListEntry<DefeasibleLogicalDependency> existingNode = rootUndefeated; existingNode != null; existingNode = existingNode.getNext()) {\n            DefeasibleLogicalDependency existingDep = existingNode.getObject();\n            wasDefeated = checkAndApplyIsDefeated(newDep, rule, existingDep);\n            if (wasDefeated) {\n                break;\n            }\n        }\n\n        if (!wasDefeated) {\n            DefeasibleLogicalDependency stagedDeps = null;\n            //for (DefeasibleLogicalDependency existingDep = rootUndefeated; existingDep != null; ) {\n            for (LinkedListEntry<DefeasibleLogicalDependency> existingNode = rootUndefeated; existingNode != null;) {\n                LinkedListEntry<DefeasibleLogicalDependency> next = existingNode.getNext();\n                DefeasibleLogicalDependency existingDep = existingNode.getObject();\n\n                if (checkAndApplyIsDefeated(existingDep, existingDep.getJustifier().getRule(), newDep)) {\n                    // fist remove it from the undefeated list\n                    removeUndefeated(existingDep, existingNode);\n                    if (existingDep.getRootDefeated() != null) {\n                        // build up the list of staged deps, that will need to be reprocessed\n                        if (stagedDeps == null) {\n                            stagedDeps = existingDep.getRootDefeated();\n                        } else {\n                            stagedDeps.setPrevious(existingDep.getTailDefeated());\n                            stagedDeps = existingDep.getRootDefeated();\n                        }\n                    }\n                }\n                existingNode = next;\n            }\n            addUndefeated(newDep, (LinkedListEntry<DefeasibleLogicalDependency>) node);\n            // now process the staged\n            reprocessDefeated(stagedDeps);\n        }\n        updateStatus();\n    }","id":43667,"modified_method":"public void add(LinkedListNode node) {\n        DefeasibleLogicalDependency newDep = (DefeasibleLogicalDependency) ((LinkedListEntry) node).getObject();\n        newDep.setStatus(resolveStatus(newDep));\n\n        Rule rule = newDep.getJustifier().getRule();\n\n        // first iterate to see if this new dep is defeated. If it's defeated, it can no longer impacts any deps\n        // if we checked what it defeats, and later this was defeated, we would have undo action. So we do the cheaper work first.\n        boolean wasDefeated = false;\n        for (LinkedListEntry<DefeasibleLogicalDependency> existingNode = rootUndefeated; existingNode != null; existingNode = existingNode.getNext()) {\n            DefeasibleLogicalDependency existingDep = existingNode.getObject();\n            wasDefeated = checkAndApplyIsDefeated(newDep, rule, existingDep);\n            if (wasDefeated) {\n                break;\n            }\n        }\n\n        if (!wasDefeated) {\n            LinkedListEntry<DefeasibleLogicalDependency> stagedDeps = null;\n            //for (DefeasibleLogicalDependency existingDep = rootUndefeated; existingDep != null; ) {\n            for (LinkedListEntry<DefeasibleLogicalDependency> existingNode = rootUndefeated; existingNode != null;) {\n                LinkedListEntry<DefeasibleLogicalDependency> next = existingNode.getNext();\n                DefeasibleLogicalDependency existingDep = existingNode.getObject();\n\n                if (checkAndApplyIsDefeated(existingDep, existingDep.getJustifier().getRule(), newDep)) {\n                    // fist remove it from the undefeated list\n                    removeUndefeated(existingDep, existingNode);\n                    if (existingDep.getRootDefeated() != null) {\n                        // build up the list of staged deps, that will need to be reprocessed\n                        if (stagedDeps == null) {\n                            stagedDeps = existingDep.getRootDefeated();\n                        } else {\n                            stagedDeps.setPrevious( existingDep.getTailDefeated() );\n                            stagedDeps = existingDep.getRootDefeated();\n                        }\n                    }\n                    existingDep.clearDefeated();\n                }\n                existingNode = next;\n            }\n            addUndefeated(newDep, (LinkedListEntry<DefeasibleLogicalDependency>) node);\n            // now process the staged\n            reprocessDefeated(stagedDeps);\n        }\n        updateStatus();\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void reprocessDefeated(DefeasibleLogicalDependency deps) {\n        for (DefeasibleLogicalDependency dep = deps; dep != null; ) {\n            DefeasibleLogicalDependency next = (DefeasibleLogicalDependency) dep.getNext();\n            dep.nullPrevNext(); // it needs to be removed, before it can be processed\n            add(dep); // adding back in, effectively reprocesses the dep\n            dep = next;\n        }\n    }","id":43668,"modified_method":"private void reprocessDefeated( LinkedListEntry<DefeasibleLogicalDependency> deps) {\n        for ( LinkedListEntry<DefeasibleLogicalDependency> dep = deps; dep != null; ) {\n            LinkedListEntry<DefeasibleLogicalDependency> next = dep.getNext();\n            dep.nullPrevNext(); // it needs to be removed, before it can be processed\n            DefeasibleLogicalDependency ld = dep.getObject();\n            add( dep ); // adding back in, effectively reprocesses the dep\n            dep = next;\n        }\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void removeUndefeated(DefeasibleLogicalDependency dep, LinkedListEntry<DefeasibleLogicalDependency> node) {\n        boolean pos = dep.getValue() != null && MODE.POSITIVE.getId().equals( dep.getValue().toString() );\n        switch( dep.getStatus() ) {\n            case DEFINITELY:\n                if ( pos ) {\n                    definitelyPosCount--;\n                    if ( definitelyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFINITELY_POS_BIT;\n                    }\n                } else {\n                    definitelyNegCount--;\n                    if ( definitelyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFINITELY_NEG_BIT;\n                    }\n                }\n                break;\n            case DEFEASIBLY:\n                if ( pos ) {\n                    defeasiblyPosCount--;\n                    if ( defeasiblyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFEASIBLY_POS_BIT;\n                    }\n                } else {\n                    defeasiblyNegCount--;\n                    if ( defeasiblyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFEASIBLY_NEG_BIT;\n                    }\n                }\n                break;\n            case DEFEATEDLY:\n                if ( pos ) {\n                    defeatedlyPosCount--;\n                    if ( defeatedlyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFEATEDLY_POS_BIT;\n                    }\n                } else {\n                    defeatedlyNegCount--;\n                    if ( defeatedlyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFEATEDLY_NEG_BIT;\n                    }\n                }\n                break;\n            case UNDECIDABLY:\n                throw new IllegalStateException(\"Individual logical dependencies cannot be undecidably\");\n        }\n\n        if (this.rootUndefeated == node) {\n            removeFirst();\n        } else if (this.tailUndefeated == node) {\n            removeLast();\n        } else {\n            node.getPrevious().setNext(node.getNext());\n            ((LinkedListNode)node.getNext()).setPrevious(node.getPrevious());\n            node.nullPrevNext();\n        }\n    }","id":43669,"modified_method":"public void removeUndefeated(DefeasibleLogicalDependency dep, LinkedListEntry<DefeasibleLogicalDependency> node) {\n        boolean pos = dep.getValue() == null || MODE.POSITIVE.getId().equals( dep.getValue().toString() );\n        switch( dep.getStatus() ) {\n            case DEFINITELY:\n                if ( pos ) {\n                    definitelyPosCount--;\n                    if ( definitelyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFINITELY_POS_BIT;\n                    }\n                } else {\n                    definitelyNegCount--;\n                    if ( definitelyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFINITELY_NEG_BIT;\n                    }\n                }\n                break;\n            case DEFEASIBLY:\n                if ( pos ) {\n                    defeasiblyPosCount--;\n                    if ( defeasiblyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFEASIBLY_POS_BIT;\n                    }\n                } else {\n                    defeasiblyNegCount--;\n                    if ( defeasiblyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFEASIBLY_NEG_BIT;\n                    }\n                }\n                break;\n            case DEFEATEDLY:\n                if ( pos ) {\n                    defeatedlyPosCount--;\n                    if ( defeatedlyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFEATEDLY_POS_BIT;\n                    }\n                } else {\n                    defeatedlyNegCount--;\n                    if ( defeatedlyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFEATEDLY_NEG_BIT;\n                    }\n                }\n                break;\n            case UNDECIDABLY:\n                throw new IllegalStateException(\"Individual logical dependencies cannot be undecidably\");\n        }\n\n        if (this.rootUndefeated == node) {\n            removeFirst();\n        } else if (this.tailUndefeated == node) {\n            removeLast();\n        } else {\n            node.getPrevious().setNext(node.getNext());\n            ((LinkedListNode)node.getNext()).setPrevious(node.getPrevious());\n            node.nullPrevNext();\n        }\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public boolean isUndecided() {\n        return getStatus() == DefeasibilityStatus.UNDECIDABLY;\n    }","id":43670,"modified_method":"public boolean isUndecided() {\n        return getStatus() == DefeasibilityStatus.UNDECIDABLY || getStatus() == DefeasibilityStatus.DEFEATEDLY;\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private boolean checkAndApplyIsDefeated(DefeasibleLogicalDependency potentialInferior, Rule rule, DefeasibleLogicalDependency potentialSuperior) {\n        // adds the references that defeat the current node\n        if (Arrays.binarySearch(potentialSuperior.getDefeats(), rule.getName()) >= 0 ||\n            Arrays.binarySearch(potentialSuperior.getDefeats(), rule.getPackage() + \".\" + rule.getName()) >= 0) {\n            potentialSuperior.addDefeated(potentialInferior);\n            return true;\n        }\n        return false;\n    }","id":43671,"modified_method":"private boolean checkAndApplyIsDefeated(DefeasibleLogicalDependency potentialInferior, Rule rule, DefeasibleLogicalDependency potentialSuperior) {\n        if ( potentialSuperior.getDefeats() == null ) {\n            return false;\n        }\n        if ( potentialSuperior.getStatus() == DefeasibilityStatus.DEFINITELY && potentialInferior.getStatus() != DefeasibilityStatus.DEFINITELY ) {\n            potentialSuperior.addDefeated(potentialInferior);\n            return true;\n        }\n        // adds the references that defeat the current node\n        if (Arrays.binarySearch(potentialSuperior.getDefeats(), rule.getName()) >= 0 ||\n            Arrays.binarySearch(potentialSuperior.getDefeats(), rule.getPackage() + \".\" + rule.getName()) >= 0) {\n            potentialSuperior.addDefeated(potentialInferior);\n            return true;\n        }\n        return false;\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void removeDefeated(DefeasibleLogicalDependency defeated) {\n        defeated.setDefeatedBy( null );\n        if (this.rootDefeated == defeated) {\n            removeFirst();\n        } else if (this.tailDefeated == defeated) {\n            removeLast();\n        } else {\n            defeated.getPrevious().setNext(defeated.getNext());\n            (defeated.getNext()).setPrevious(defeated.getPrevious());\n            defeated.nullPrevNext();\n        }\n    }","id":43672,"modified_method":"public void removeDefeated(DefeasibleLogicalDependency defeated) {\n        defeated.setDefeatedBy( null );\n        if (this.rootDefeated.getObject() == defeated) {\n            removeFirst();\n        } else if (this.tailDefeated.getObject() == defeated) {\n            removeLast();\n        } else {\n            LinkedListEntry<DefeasibleLogicalDependency> entry = this.rootDefeated;\n            while ( entry.getObject() != defeated ) {\n                entry = entry.getNext();\n            }\n            entry.getPrevious().setNext(entry.getNext());\n            (entry.getNext()).setPrevious(entry.getPrevious());\n            entry.nullPrevNext();\n\n        }\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void initDefeats() {\n        Object o = getJustifier().getRule().getMetaData().get(DEFEATER);\n\n\n\n        if ( o != null && ((Boolean)o).booleanValue() ) {\n            isDefeater = true;\n        }\n\n        o = getJustifier().getRule().getMetaData().get(DEFEATS);\n        if ( o != null ) {\n            // this must be sorted, so superiority is a quick search.\n            if (o instanceof String) {\n                defeats = new String[]{(String) o};\n                Arrays.sort(defeats);\n            } else if (o instanceof Object[]) {\n                Object[] oArray = (Object[]) o;\n                defeats = new String[oArray.length];\n                for ( int i = 0; i < oArray.length;i++ ) {\n                    defeats[i] = (String) oArray[i];\n                }\n                Arrays.sort(defeats);\n            }\n        } else {\n            defeats = EMPTY_DEFEATS;\n        }\n    }","id":43673,"modified_method":"private void initDefeats() {\n        Object o = getJustifier().getRule().getMetaData().get(DEFEATER);\n\n\n\n        if ( o != null && ((Boolean)o).booleanValue() ) {\n            isDefeater = true;\n        }\n\n        o = getJustifier().getRule().getMetaData().get(DEFEATS);\n        if ( o != null ) {\n            // this must be sorted, so superiority is a quick search.\n            if (o instanceof String) {\n                defeats = new String[]{(String) o};\n                Arrays.sort(defeats);\n            } else if (o instanceof Object[]) {\n                defeats = Arrays.copyOf( (Object[]) o, ( (Object[]) o ).length, String[].class );\n                Arrays.sort(defeats);\n            }\n        } else {\n            defeats = EMPTY_DEFEATS;\n        }\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void addDefeated(DefeasibleLogicalDependency defeated) {\n        defeated.setDefeatedBy( this );\n        if (rootDefeated == null) {\n            rootDefeated = defeated;\n        } else {\n            tailDefeated.setNext(defeated);\n            defeated.setPrevious(rootDefeated);\n        }\n        tailDefeated = defeated;\n    }","id":43674,"modified_method":"public void addDefeated(DefeasibleLogicalDependency defeated) {\n        defeated.setDefeatedBy( this );\n        LinkedListEntry def = new LinkedListEntry<DefeasibleLogicalDependency>( defeated );\n        if (rootDefeated == null) {\n            rootDefeated = def;\n        } else {\n            tailDefeated.setNext( def );\n            def.setPrevious( rootDefeated );\n        }\n        tailDefeated = def;\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public DefeasibleLogicalDependency removeFirst() {\n        if (this.rootDefeated == null) {\n            return null;\n        }\n        final DefeasibleLogicalDependency node = this.rootDefeated;\n        this.rootDefeated = (DefeasibleLogicalDependency) node.getNext();\n        node.setNext(null);\n        if (this.rootDefeated != null) {\n            this.rootDefeated.setPrevious(null);\n        } else {\n            this.tailDefeated = null;\n        }\n        return node;\n    }","id":43675,"modified_method":"public DefeasibleLogicalDependency removeFirst() {\n        if (this.rootDefeated == null) {\n            return null;\n        }\n        final LinkedListEntry<DefeasibleLogicalDependency> node = this.rootDefeated;\n        this.rootDefeated = node.getNext();\n        node.setNext(null);\n        if (this.rootDefeated != null) {\n            this.rootDefeated.setPrevious(null);\n        } else {\n            this.tailDefeated = null;\n        }\n        return node.getObject();\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public DefeasibleLogicalDependency removeLast() {\n        if (this.tailDefeated == null) {\n            return null;\n        }\n        final DefeasibleLogicalDependency node = this.tailDefeated;\n        this.tailDefeated = (DefeasibleLogicalDependency) node.getPrevious();\n        node.setPrevious(null);\n        if (this.tailDefeated != null) {\n            this.tailDefeated.setNext(null);\n        } else {\n            this.rootDefeated = this.tailDefeated;\n        }\n        return node;\n    }","id":43676,"modified_method":"public DefeasibleLogicalDependency removeLast() {\n        if (this.tailDefeated == null) {\n            return null;\n        }\n        final LinkedListEntry<DefeasibleLogicalDependency> node = this.tailDefeated;\n        this.tailDefeated = node.getPrevious();\n        node.setPrevious(null);\n        if (this.tailDefeated != null) {\n            this.tailDefeated.setNext(null);\n        } else {\n            this.rootDefeated = this.tailDefeated;\n        }\n        return node.getObject();\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void delete(LogicalDependency node,\n                       BeliefSet beliefSet,\n                       PropagationContext context) {\n        JTMSBeliefSetImpl jtmsBeliefSet = (JTMSBeliefSetImpl) beliefSet;\n        boolean wasConflicting = jtmsBeliefSet.isUndecided();\n        boolean wasNegated = jtmsBeliefSet.isNegated();\n\n        // If the prime object is removed, we need to update the FactHandle, and tell the callback to update\n        boolean primeChanged = false;\n\n        if ( (jtmsBeliefSet.getPositiveFactHandle() != null && jtmsBeliefSet.getPositiveFactHandle().getObject() == node.getObject()) ||\n             (jtmsBeliefSet.getNegativeFactHandle() != null && jtmsBeliefSet.getNegativeFactHandle().getObject() == node.getObject()) ) {\n            primeChanged = true;\n        }\n\n        beliefSet.remove( node.getJustifierEntry() );\n        if ( beliefSet.isEmpty() ) {\n            if ( wasNegated ) {\n                defEP.getObjectStore().addHandle( beliefSet.getFactHandle(), beliefSet.getFactHandle().getObject() ); // was negated, so add back in, so main retract works\n                InternalFactHandle fh = jtmsBeliefSet.getNegativeFactHandle();\n                ((NamedEntryPoint) fh.getEntryPoint()).delete( fh, (Rule) context.getRuleOrigin(), node.getJustifier() );\n            }\n\n            if ( !(context.getType() == PropagationContext.DELETION && context.getFactHandle() == beliefSet.getFactHandle()) ) { // don't start retract, if the FH is already in the process of being retracted\n                // do not if the FH is the root of the context, it means it's already in the process of retraction\n                InternalFactHandle fh = jtmsBeliefSet.getFactHandle();\n                ((NamedEntryPoint) fh.getEntryPoint()).delete( fh, (Rule) context.getRuleOrigin(), node.getJustifier() );\n            }\n\n        } else if ( wasConflicting && !jtmsBeliefSet.isUndecided() ) {\n            insertBelief( node,\n                          defEP.getObjectTypeConfigurationRegistry().getObjectTypeConf( defEP.getEntryPoint(), node.getObject() ),\n                          jtmsBeliefSet,\n                          false,\n                          wasNegated,\n                          wasConflicting );\n        } else if ( primeChanged ) {\n            // we know there must be at least one more of the same type, as they are still in conflict\n            String value;\n            InternalFactHandle handle;\n            Object object = null;\n            if ( jtmsBeliefSet.isNegated() ) {\n                value = MODE.NEGATIVE.getId();\n                handle = jtmsBeliefSet.getNegativeFactHandle();\n                // Find the new node, and update the handle to it, Negatives iterate from the last\n                for ( LinkedListEntry<LogicalDependency> entry = (LinkedListEntry<LogicalDependency>) jtmsBeliefSet.getLast(); entry != null; entry = (LinkedListEntry<LogicalDependency>) entry.getPrevious() ) {\n                    if ( entry.getObject().getValue().equals( value ) ) {\n                        object = entry.getObject().getObject();\n                        break;\n                    }\n                }\n            } else {\n                value = MODE.POSITIVE.getId();\n                handle = jtmsBeliefSet.getPositiveFactHandle();\n                // Find the new node, and update the handle to it, Positives iterate from the front\n                for ( LinkedListEntry<LogicalDependency> entry = (LinkedListEntry<LogicalDependency>) jtmsBeliefSet.getFirst(); entry != null; entry = (LinkedListEntry<LogicalDependency>) entry.getNext() ) {\n                    if ( entry.getObject().getValue().equals( value ) ) {\n                        object = entry.getObject().getObject();\n                        break;\n                    }\n                }\n            }\n\n            // Equality might have changed on the object, so remove (which uses the handle id) and add back in\n            ((NamedEntryPoint) handle.getEntryPoint()).getObjectStore().updateHandle( handle, object );\n            ((NamedEntryPoint) handle.getEntryPoint() ).update( handle, true, handle.getObject(), Long.MAX_VALUE, Object.class, null );\n        }\n    }","id":43677,"modified_method":"public void delete(LogicalDependency node,\n                       BeliefSet beliefSet,\n                       PropagationContext context) {\n        JTMSBeliefSet jtmsBeliefSet = (JTMSBeliefSet) beliefSet;\n        boolean wasConflicting = jtmsBeliefSet.isUndecided();\n        boolean wasNegated = jtmsBeliefSet.isNegated();\n\n        // If the prime object is removed, we need to update the FactHandle, and tell the callback to update\n        boolean primeChanged = false;\n\n        if ( (jtmsBeliefSet.getPositiveFactHandle() != null && jtmsBeliefSet.getPositiveFactHandle().getObject() == node.getObject()) ||\n             (jtmsBeliefSet.getNegativeFactHandle() != null && jtmsBeliefSet.getNegativeFactHandle().getObject() == node.getObject()) ) {\n            primeChanged = true;\n        }\n\n        beliefSet.remove( node.getJustifierEntry() );\n        if ( beliefSet.isEmpty() ) {\n            if ( wasNegated ) {\n                defEP.getObjectStore().addHandle( beliefSet.getFactHandle(), beliefSet.getFactHandle().getObject() ); // was negated, so add back in, so main retract works\n                InternalFactHandle fh = jtmsBeliefSet.getNegativeFactHandle();\n                ((NamedEntryPoint) fh.getEntryPoint()).delete( fh, (Rule) context.getRuleOrigin(), node.getJustifier() );\n            }\n\n            if ( !(context.getType() == PropagationContext.DELETION && context.getFactHandle() == beliefSet.getFactHandle()) ) { // don't start retract, if the FH is already in the process of being retracted\n                // do not if the FH is the root of the context, it means it's already in the process of retraction\n                InternalFactHandle fh = jtmsBeliefSet.getFactHandle();\n                ((NamedEntryPoint) fh.getEntryPoint()).delete( fh, (Rule) context.getRuleOrigin(), node.getJustifier() );\n            }\n\n        } else if ( wasConflicting && !jtmsBeliefSet.isUndecided() ) {\n            insertBelief( node,\n                          defEP.getObjectTypeConfigurationRegistry().getObjectTypeConf( defEP.getEntryPoint(), node.getObject() ),\n                          jtmsBeliefSet,\n                          context,\n                          false,\n                          wasNegated,\n                          wasConflicting );\n        } else if ( primeChanged ) {\n            // we know there must be at least one more of the same type, as they are still in conflict\n            String value;\n            InternalFactHandle handle;\n            Object object = null;\n            if ( jtmsBeliefSet.isNegated() ) {\n                if ( ! wasNegated ) {\n                    jtmsBeliefSet.setNegativeFactHandle( jtmsBeliefSet.getPositiveFactHandle() );\n                    jtmsBeliefSet.setPositiveFactHandle( null );\n                }\n                value = MODE.NEGATIVE.getId();\n                handle = jtmsBeliefSet.getNegativeFactHandle();\n                // Find the new node, and update the handle to it, Negatives iterate from the last\n                for ( LinkedListEntry<LogicalDependency> entry = (LinkedListEntry<LogicalDependency>) jtmsBeliefSet.getLast(); entry != null; entry = (LinkedListEntry<LogicalDependency>) entry.getPrevious() ) {\n                    if ( entry.getObject().getValue().equals( value ) ) {\n                        object = entry.getObject().getObject();\n                        break;\n                    }\n                }\n            } else {\n                if ( wasNegated ) {\n                    jtmsBeliefSet.setPositiveFactHandle( jtmsBeliefSet.getNegativeFactHandle() );\n                    jtmsBeliefSet.setNegativeFactHandle( null );\n                }\n                value = MODE.POSITIVE.getId();\n                handle = jtmsBeliefSet.getPositiveFactHandle();\n                // Find the new node, and update the handle to it, Positives iterate from the front\n                for ( LinkedListEntry<LogicalDependency> entry = (LinkedListEntry<LogicalDependency>) jtmsBeliefSet.getFirst(); entry != null; entry = (LinkedListEntry<LogicalDependency>) entry.getNext() ) {\n                    if ( entry.getObject().getValue() == null || entry.getObject().getValue().equals( value ) ) {\n                        object = entry.getObject().getObject();\n                        break;\n                    }\n                }\n            }\n\n            // Equality might have changed on the object, so remove (which uses the handle id) and add back in\n            ((NamedEntryPoint) handle.getEntryPoint()).getObjectStore().updateHandle( handle, object );\n            ((NamedEntryPoint) handle.getEntryPoint() ).update( handle, true, handle.getObject(), Long.MAX_VALUE, Object.class, null );\n        }\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void insertBelief(LogicalDependency node,\n                              ObjectTypeConf typeConf,\n                              JTMSBeliefSet jtmsBeliefSet,\n                              boolean wasEmpty,\n                              boolean wasNegated,\n                              boolean isUndecided) {\n        if ( jtmsBeliefSet.isNegated() ) {\n            jtmsBeliefSet.setNegativeFactHandle( (InternalFactHandle) negEP.insert( node.getObject() ) );\n\n            // As the neg partition is always stated, it'll have no equality key.\n            // However the equality key is needed to stop duplicate LogicalCallbacks, so we manually set it\n            // @FIXME **MDP could this be a problem during derialization, where the\n            jtmsBeliefSet.getNegativeFactHandle().setEqualityKey( jtmsBeliefSet.getFactHandle().getEqualityKey() );\n            jtmsBeliefSet.setPositiveFactHandle( null );\n            if ( !(wasNegated || isUndecided) ) {\n                defEP.getObjectStore().removeHandle( jtmsBeliefSet.getFactHandle() ); // Make sure the FH is no longer visible in the default ObjectStore\n            }\n        } else {\n            jtmsBeliefSet.setPositiveFactHandle( jtmsBeliefSet.getFactHandle() ); // Use the BeliefSet FH for positive facts\n            jtmsBeliefSet.setNegativeFactHandle( null );\n\n            if ( !wasEmpty && (wasNegated || isUndecided ) ) {\n                jtmsBeliefSet.getFactHandle().setObject( node.getObject() ); // Set the Object, as it may have been a negative initialization, before conflict\n                defEP.getObjectStore().addHandle( jtmsBeliefSet.getPositiveFactHandle(), jtmsBeliefSet.getPositiveFactHandle().getObject() ); // Make sure the FH is visible again\n            }\n            defEP.insert( jtmsBeliefSet.getPositiveFactHandle(),\n                          node.getObject(),\n                          node.getJustifier().getRule(),\n                          node.getJustifier(),\n                          typeConf,\n                          null );\n        }\n    }","id":43678,"modified_method":"private void insertBelief(LogicalDependency node,\n                              ObjectTypeConf typeConf,\n                              JTMSBeliefSet jtmsBeliefSet,\n                              PropagationContext context,\n                              boolean wasEmpty,\n                              boolean wasNegated,\n                              boolean isUndecided) {\n        if ( jtmsBeliefSet.isNegated() && ! jtmsBeliefSet.isUndecided() ) {\n            jtmsBeliefSet.setNegativeFactHandle( (InternalFactHandle) negEP.insert( node.getObject() ) );\n\n            // As the neg partition is always stated, it'll have no equality key.\n            // However the equality key is needed to stop duplicate LogicalCallbacks, so we manually set it\n            // @FIXME **MDP could this be a problem during derialization, where the\n            jtmsBeliefSet.getNegativeFactHandle().setEqualityKey( jtmsBeliefSet.getFactHandle().getEqualityKey() );\n            jtmsBeliefSet.setPositiveFactHandle( null );\n            if ( !(wasNegated || isUndecided) ) {\n                defEP.getObjectStore().removeHandle( jtmsBeliefSet.getFactHandle() ); // Make sure the FH is no longer visible in the default ObjectStore\n            }\n        } else if ( jtmsBeliefSet.isPositive() && ! jtmsBeliefSet.isUndecided() ) {\n            jtmsBeliefSet.setPositiveFactHandle( jtmsBeliefSet.getFactHandle() ); // Use the BeliefSet FH for positive facts\n            jtmsBeliefSet.setNegativeFactHandle( null );\n\n            if ( !wasEmpty && (wasNegated || isUndecided ) ) {\n                jtmsBeliefSet.getFactHandle().setObject( node.getObject() ); // Set the Object, as it may have been a negative initialization, before conflict\n                defEP.getObjectStore().addHandle( jtmsBeliefSet.getPositiveFactHandle(), jtmsBeliefSet.getPositiveFactHandle().getObject() ); // Make sure the FH is visible again\n            }\n            defEP.insert( jtmsBeliefSet.getPositiveFactHandle(),\n                          node.getObject(),\n                          node.getJustifier().getRule(),\n                          node.getJustifier(),\n                          typeConf,\n                          null );\n        }\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void insert(LogicalDependency node,\n                       BeliefSet beliefSet,\n                       PropagationContext context,\n                       ObjectTypeConf typeConf) {\n        JTMSBeliefSet jtmsBeliefSet = (JTMSBeliefSet) beliefSet;\n\n        boolean wasEmpty = jtmsBeliefSet.isEmpty();\n        boolean wasNegated = jtmsBeliefSet.isNegated();\n        boolean isUndecided = jtmsBeliefSet.isUndecided();\n\n        jtmsBeliefSet.add( node.getJustifierEntry() );\n\n        if ( wasEmpty ) {\n            // Insert Belief\n            insertBelief( node, typeConf, jtmsBeliefSet, wasEmpty, wasNegated, isUndecided );\n        } else if ( !isUndecided && jtmsBeliefSet.isUndecided() ) {\n            // Handle Conflict\n            if ( STRICT ) {\n                throw new IllegalStateException( \"FATAL : A fact and its negation have been asserted \" + jtmsBeliefSet.getFactHandle().getObject() );\n            }\n\n            InternalFactHandle fh;\n            boolean fullyRetract;\n            if ( wasNegated ) {\n                fh = jtmsBeliefSet.getNegativeFactHandle();\n                jtmsBeliefSet.setNegativeFactHandle( null );\n                fullyRetract = true; // Only fully retract negatives\n\n                ((NamedEntryPoint) fh.getEntryPoint()).delete( fh, (Rule) context.getRuleOrigin(), node.getJustifier() );\n            } else {\n                fh = jtmsBeliefSet.getPositiveFactHandle();\n                jtmsBeliefSet.setPositiveFactHandle( null );\n                fullyRetract = false; // Positives only retract from the rete network, handle must remain\n\n                NamedEntryPoint nep = (NamedEntryPoint) fh.getEntryPoint() ;\n\n//                final ObjectTypeConf typeConf = nep.getObjectTypeConfigurationRegistry().getObjectTypeConf( nep.getEntryPoint(),\n//                                                                                                            handle.getObject() );\n\n                ((NamedEntryPoint) fh.getEntryPoint() ).getEntryPointNode().retractObject( fh, context, typeConf, nep.getInternalWorkingMemory() );\n            }\n\n        }\n    }","id":43679,"modified_method":"public void insert(LogicalDependency node,\n                       BeliefSet beliefSet,\n                       PropagationContext context,\n                       ObjectTypeConf typeConf) {\n        JTMSBeliefSet jtmsBeliefSet = (JTMSBeliefSet) beliefSet;\n\n        boolean wasEmpty = jtmsBeliefSet.isEmpty();\n        boolean wasNegated = jtmsBeliefSet.isNegated();\n        boolean wasUndecided = jtmsBeliefSet.isUndecided();\n\n        jtmsBeliefSet.add( node.getJustifierEntry() );\n\n        if ( wasEmpty ) {\n            // Insert Belief\n            if ( ! jtmsBeliefSet.isUndecided() ) {\n                insertBelief( node, typeConf, jtmsBeliefSet, context, wasEmpty, wasNegated, wasUndecided );\n            } else {\n                defEP.getObjectStore().removeHandle( jtmsBeliefSet.getFactHandle() );\n            }\n        } else if ( !wasUndecided && jtmsBeliefSet.isUndecided() ) {\n            // Handle Conflict\n            if ( STRICT ) {\n                throw new IllegalStateException( \"FATAL : A fact and its negation have been asserted \" + jtmsBeliefSet.getFactHandle().getObject() );\n            }\n\n            InternalFactHandle fh;\n            boolean fullyRetract;\n            if ( wasNegated ) {\n                fh = jtmsBeliefSet.getNegativeFactHandle();\n                jtmsBeliefSet.setNegativeFactHandle( null );\n                fullyRetract = true; // Only fully retract negatives\n\n                ((NamedEntryPoint) fh.getEntryPoint()).delete( fh, context.getRuleOrigin(), node.getJustifier() );\n            } else {\n                fh = jtmsBeliefSet.getPositiveFactHandle();\n                jtmsBeliefSet.setPositiveFactHandle( null );\n                fullyRetract = false; // Positives only retract from the rete network, handle must remain\n\n                NamedEntryPoint nep = (NamedEntryPoint) fh.getEntryPoint() ;\n\n//                final ObjectTypeConf typeConf = nep.getObjectTypeConfigurationRegistry().getObjectTypeConf( nep.getEntryPoint(),\n//                                                                                                            handle.getObject() );\n\n                nep.getEntryPointNode().retractObject( fh, context, typeConf, nep.getInternalWorkingMemory() );\n            }\n\n        } else {\n            if ( wasUndecided && ! jtmsBeliefSet.isUndecided() ) {\n                insertBelief( node, typeConf, jtmsBeliefSet, context, wasEmpty, wasNegated, wasUndecided );\n            }\n        }\n    }","commit_id":"6e45d53be4d9e380dd592087681400e924f3c528","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private int getLimitCount(Session session, int rowCount) {\n\n        int limitCount = Integer.MAX_VALUE;\n\n        if (sortAndSlice.limitCondition != null) {\n            Integer limit =\n                (Integer) sortAndSlice.limitCondition.getRightNode().getValue(\n                    session);\n\n            if (limit == null || limit.intValue() <= 0) {\n                throw Error.error(ErrorCode.X_2201W);\n            }\n\n            limitCount = limit.intValue();\n        }\n\n        if (rowCount != 0 && rowCount < limitCount) {\n            limitCount = rowCount;\n        }\n\n        return limitCount;\n    }","id":43680,"modified_method":"private int getLimitCount(Session session, int rowCount) {\n\n        int limitCount = Integer.MAX_VALUE;\n\n        if (sortAndSlice.limitCondition != null) {\n            Integer limit =\n                (Integer) sortAndSlice.limitCondition.getRightNode().getValue(\n                    session);\n\n            if (limit == null || limit.intValue() < 0) {\n                throw Error.error(ErrorCode.X_2201W);\n            }\n\n            limitCount = limit.intValue();\n        }\n\n        if (rowCount != 0 && rowCount < limitCount) {\n            limitCount = rowCount;\n        }\n\n        return limitCount;\n    }","commit_id":"47d85055c992ce0e36520175742db6cc05dae6ed","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * translate the rowCount into total number of rows needed from query,\n     * including any rows skipped at the beginning\n     */\n    private int getMaxRowCount(Session session, int rowCount) {\n\n        int limitStart = getLimitStart(session);\n        int limitCount = getLimitCount(session, rowCount);\n\n        if (simpleLimit) {\n            if (rowCount == 0) {\n                rowCount = limitCount;\n            }\n\n            if (rowCount == 0 || rowCount > Integer.MAX_VALUE - limitStart) {\n                rowCount = Integer.MAX_VALUE;\n            } else {\n                rowCount += limitStart;\n            }\n        } else {\n            rowCount = Integer.MAX_VALUE;\n        }\n\n        return rowCount;\n    }","id":43681,"modified_method":"/**\n     * translate the rowCount into total number of rows needed from query,\n     * including any rows skipped at the beginning\n     */\n    private int getMaxRowCount(Session session, int rowCount) {\n\n        int limitStart = getLimitStart(session);\n        int limitCount = getLimitCount(session, rowCount);\n\n        if (simpleLimit) {\n            if (rowCount == 0) {\n                rowCount = limitCount;\n            }\n\n            if (rowCount > Integer.MAX_VALUE - limitStart) {\n                rowCount = Integer.MAX_VALUE;\n            } else {\n                rowCount += limitStart;\n            }\n        } else {\n            rowCount = Integer.MAX_VALUE;\n        }\n\n        return rowCount;\n    }","commit_id":"47d85055c992ce0e36520175742db6cc05dae6ed","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private Result buildResult(Session session, int limitcount) {\n\n        RowSetNavigatorData navigator = new RowSetNavigatorData(session,\n            (QuerySpecification) this);\n        Result result = Result.newResult(navigator);\n\n        result.metaData = resultMetaData;\n\n        result.setDataResultConcurrency(isUpdatable);\n\n        int fullJoinIndex = 0;\n        RangeIterator[] rangeIterators =\n            new RangeIterator[rangeVariables.length];\n\n        for (int i = 0; i < rangeVariables.length; i++) {\n            rangeIterators[i] = rangeVariables[i].getIterator(session);\n        }\n\n        for (int currentIndex = 0; ; ) {\n            if (currentIndex < fullJoinIndex) {\n                boolean end = true;\n\n                for (int i = fullJoinIndex + 1; i < rangeVariables.length;\n                        i++) {\n                    if (rangeVariables[i].isRightJoin) {\n                        rangeIterators[i] = rangeVariables[i].getFullIterator(\n                            session, (RangeIteratorMain) rangeIterators[i]);\n                        fullJoinIndex = i;\n                        currentIndex  = i;\n                        end           = false;\n\n                        break;\n                    }\n                }\n\n                if (end) {\n                    break;\n                }\n            }\n\n            RangeIterator it = rangeIterators[currentIndex];\n\n            if (it.next()) {\n                if (currentIndex < rangeVariables.length - 1) {\n                    currentIndex++;\n\n                    continue;\n                }\n            } else {\n                it.reset();\n\n                currentIndex--;\n\n                continue;\n            }\n\n            session.sessionData.startRowProcessing();\n\n            Object[] data = new Object[indexLimitData];\n\n            for (int i = 0; i < indexStartAggregates; i++) {\n                if (isAggregated && aggregateCheck[i]) {\n                    continue;\n                } else {\n                    data[i] = exprColumns[i].getValue(session);\n                }\n            }\n\n            for (int i = indexLimitVisible; i < indexLimitRowId; i++) {\n                data[i] = it.getRowidObject();\n            }\n\n            Object[] groupData = null;\n\n            if (isAggregated || isGrouped) {\n                groupData = navigator.getGroupData(data);\n\n                if (groupData != null) {\n                    data = groupData;\n                }\n            }\n\n            for (int i = indexStartAggregates; i < indexLimitExpressions;\n                    i++) {\n                data[i] =\n                    ((ExpressionAggregate) exprColumns[i])\n                        .updateAggregatingValue(session, data[i]);\n            }\n\n            if (groupData == null) {\n                navigator.add(data);\n            }\n\n            if (isAggregated || isGrouped) {\n                continue;\n            }\n\n            if (navigator.getSize() >= limitcount) {\n                break;\n            }\n        }\n\n        navigator.reset();\n\n        if (!isGrouped && !isAggregated) {\n            return result;\n        }\n\n        if (isAggregated) {\n            if (!isGrouped && navigator.getSize() == 0) {\n                Object[] data = new Object[exprColumns.length];\n\n                navigator.add(data);\n            }\n\n            RangeIteratorBase it = new RangeIteratorBase(session,\n                navigator.store, navigator.table, resultRangePosition);\n\n            session.sessionContext.setRangeIterator(it);\n\n            while (it.next()) {\n                for (int i = indexStartAggregates; i < indexLimitExpressions;\n                        i++) {\n                    ExpressionAggregate aggregate =\n                        (ExpressionAggregate) exprColumns[i];\n\n                    it.currentData[i] = aggregate.getAggregatedValue(session,\n                            it.currentData[i]);\n                }\n\n                for (int i = 0; i < indexStartAggregates; i++) {\n                    if (aggregateCheck[i]) {\n                        it.currentData[i] = exprColumns[i].getValue(session);\n                    }\n                }\n            }\n        }\n\n        navigator.reset();\n\n        if (havingCondition != null) {\n            while (navigator.hasNext()) {\n                Object[] data = (Object[]) navigator.getNext();\n\n                if (!Boolean.TRUE.equals(\n                        data[indexLimitVisible + groupByColumnCount])) {\n                    navigator.remove();\n                }\n            }\n\n            navigator.reset();\n        }\n\n        return result;\n    }","id":43682,"modified_method":"private Result buildResult(Session session, int limitcount) {\n\n        RowSetNavigatorData navigator = new RowSetNavigatorData(session,\n            this);\n        Result result = Result.newResult(navigator);\n\n        result.metaData = resultMetaData;\n\n        result.setDataResultConcurrency(isUpdatable);\n\n        int fullJoinIndex = 0;\n        RangeIterator[] rangeIterators =\n            new RangeIterator[rangeVariables.length];\n\n        for (int i = 0; i < rangeVariables.length; i++) {\n            rangeIterators[i] = rangeVariables[i].getIterator(session);\n        }\n\n        for (int currentIndex = 0; ; ) {\n            if (currentIndex < fullJoinIndex) {\n                boolean end = true;\n\n                for (int i = fullJoinIndex + 1; i < rangeVariables.length;\n                        i++) {\n                    if (rangeVariables[i].isRightJoin) {\n                        rangeIterators[i] = rangeVariables[i].getFullIterator(\n                            session, (RangeIteratorMain) rangeIterators[i]);\n                        fullJoinIndex = i;\n                        currentIndex  = i;\n                        end           = false;\n\n                        break;\n                    }\n                }\n\n                if (end) {\n                    break;\n                }\n            }\n\n            RangeIterator it = rangeIterators[currentIndex];\n\n            if (it.next()) {\n                if (currentIndex < rangeVariables.length - 1) {\n                    currentIndex++;\n\n                    continue;\n                }\n            } else {\n                it.reset();\n\n                currentIndex--;\n\n                continue;\n            }\n\n            session.sessionData.startRowProcessing();\n\n            Object[] data = new Object[indexLimitData];\n\n            for (int i = 0; i < indexStartAggregates; i++) {\n                if (isAggregated && aggregateCheck[i]) {\n                    continue;\n                } else {\n                    data[i] = exprColumns[i].getValue(session);\n                }\n            }\n\n            for (int i = indexLimitVisible; i < indexLimitRowId; i++) {\n                data[i] = it.getRowidObject();\n            }\n\n            Object[] groupData = null;\n\n            if (isAggregated || isGrouped) {\n                groupData = navigator.getGroupData(data);\n\n                if (groupData != null) {\n                    data = groupData;\n                }\n            }\n\n            for (int i = indexStartAggregates; i < indexLimitExpressions;\n                    i++) {\n                data[i] =\n                    ((ExpressionAggregate) exprColumns[i])\n                        .updateAggregatingValue(session, data[i]);\n            }\n\n            if (groupData == null) {\n                navigator.add(data);\n            }\n\n            if (isAggregated || isGrouped) {\n                continue;\n            }\n\n            if (navigator.getSize() >= limitcount) {\n                break;\n            }\n        }\n\n        navigator.reset();\n\n        if (!isGrouped && !isAggregated) {\n            return result;\n        }\n\n        if (isAggregated) {\n            if (!isGrouped && navigator.getSize() == 0) {\n                Object[] data = new Object[exprColumns.length];\n\n                navigator.add(data);\n            }\n\n            RangeIteratorBase it = new RangeIteratorBase(session,\n                navigator.store, navigator.table, resultRangePosition);\n\n            session.sessionContext.setRangeIterator(it);\n\n            while (it.next()) {\n                for (int i = indexStartAggregates; i < indexLimitExpressions;\n                        i++) {\n                    ExpressionAggregate aggregate =\n                        (ExpressionAggregate) exprColumns[i];\n\n                    it.currentData[i] = aggregate.getAggregatedValue(session,\n                            it.currentData[i]);\n                }\n\n                for (int i = 0; i < indexStartAggregates; i++) {\n                    if (aggregateCheck[i]) {\n                        it.currentData[i] = exprColumns[i].getValue(session);\n                    }\n                }\n            }\n        }\n\n        navigator.reset();\n\n        if (havingCondition != null) {\n            while (navigator.hasNext()) {\n                Object[] data = navigator.getNext();\n\n                if (!Boolean.TRUE.equals(\n                        data[indexLimitVisible + groupByColumnCount])) {\n                    navigator.remove();\n                }\n            }\n\n            navigator.reset();\n        }\n\n        return result;\n    }","commit_id":"47d85055c992ce0e36520175742db6cc05dae6ed","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void removeUndefeated(DefeasibleLogicalDependency dep) {\n        boolean pos = dep.getValue() != null && MODE.POSITIVE.getId().equals( dep.getValue().toString() );\n        switch( dep.getStatus() ) {\n            case DEFINITELY:\n                if ( pos ) {\n                    definitelyPosCount--;\n                    if ( definitelyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFINITELY_POS_BIT;\n                    }\n                } else {\n                    definitelyNegCount--;\n                    if ( definitelyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFINITELY_NEG_BIT;\n                    }\n                }\n                break;\n            case DEFEASIBLY:\n                if ( pos ) {\n                    defeasiblyPosCount--;\n                    if ( defeasiblyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFEASIBLY_POS_BIT;\n                    }\n                } else {\n                    defeasiblyNegCount--;\n                    if ( defeasiblyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFEASIBLY_NEG_BIT;\n                    }\n                }\n                break;\n            case DEFEATEDLY:\n                if ( pos ) {\n                    defeatedlyPosCount--;\n                    if ( defeatedlyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFEATEDLY_POS_BIT;\n                    }\n                } else {\n                    defeatedlyNegCount--;\n                    if ( defeatedlyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFEATEDLY_NEG_BIT;\n                    }\n                }\n                break;\n            case UNDECIDABLY:\n                throw new IllegalStateException(\"Individual logical dependencies cannot be undecidably\");\n        }\n\n        if (this.rootUndefeated == dep) {\n            removeFirst();\n        } else if (this.tailUndefeated == dep) {\n            removeLast();\n        } else {\n            dep.getPrevious().setNext(dep.getNext());\n            (dep.getNext()).setPrevious(dep.getPrevious());\n            dep.nullPrevNext();\n        }\n    }","id":43683,"modified_method":"public void removeUndefeated(DefeasibleLogicalDependency dep, LinkedListEntry<DefeasibleLogicalDependency> node) {\n        boolean pos = dep.getValue() != null && MODE.POSITIVE.getId().equals( dep.getValue().toString() );\n        switch( dep.getStatus() ) {\n            case DEFINITELY:\n                if ( pos ) {\n                    definitelyPosCount--;\n                    if ( definitelyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFINITELY_POS_BIT;\n                    }\n                } else {\n                    definitelyNegCount--;\n                    if ( definitelyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFINITELY_NEG_BIT;\n                    }\n                }\n                break;\n            case DEFEASIBLY:\n                if ( pos ) {\n                    defeasiblyPosCount--;\n                    if ( defeasiblyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFEASIBLY_POS_BIT;\n                    }\n                } else {\n                    defeasiblyNegCount--;\n                    if ( defeasiblyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFEASIBLY_NEG_BIT;\n                    }\n                }\n                break;\n            case DEFEATEDLY:\n                if ( pos ) {\n                    defeatedlyPosCount--;\n                    if ( defeatedlyPosCount == 0 ) {\n                        statusMask = statusMask ^ DEFEATEDLY_POS_BIT;\n                    }\n                } else {\n                    defeatedlyNegCount--;\n                    if ( defeatedlyNegCount == 0 ) {\n                        statusMask = statusMask ^ DEFEATEDLY_NEG_BIT;\n                    }\n                }\n                break;\n            case UNDECIDABLY:\n                throw new IllegalStateException(\"Individual logical dependencies cannot be undecidably\");\n        }\n\n        if (this.rootUndefeated == node) {\n            removeFirst();\n        } else if (this.tailUndefeated == node) {\n            removeLast();\n        } else {\n            node.getPrevious().setNext(node.getNext());\n            ((LinkedListNode)node.getNext()).setPrevious(node.getPrevious());\n            node.nullPrevNext();\n        }\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public DefeasibleLogicalDependency getRootUndefeated() {\n        return this.rootUndefeated;\n    }","id":43684,"modified_method":"public LinkedListNode getRootUndefeated() {\n        return this.rootUndefeated;\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void add(LinkedListNode node) {\n        DefeasibleLogicalDependency newDep = (DefeasibleLogicalDependency) node;\n\n        Rule rule = newDep.getJustifier().getRule();\n\n        // first iterate to see if this new dep is defeated. If it's defeated, it can no longer impacts any deps\n        // if we checked what it defeats, and later this was defeated, we would have undo action. So we do the cheaper work first.\n        boolean wasDefeated = false;\n        for (DefeasibleLogicalDependency existingDep = rootUndefeated; existingDep != null; existingDep = (DefeasibleLogicalDependency) existingDep.getNext()) {\n            wasDefeated = checkAndApplyIsDefeated(newDep, rule, existingDep);\n            if (wasDefeated) {\n                break;\n            }\n        }\n\n        if (!wasDefeated) {\n            DefeasibleLogicalDependency stagedDeps = null;\n            for (DefeasibleLogicalDependency existingDep = rootUndefeated; existingDep != null; ) {\n                DefeasibleLogicalDependency next = (DefeasibleLogicalDependency) existingDep.getNext();\n                if (checkAndApplyIsDefeated(existingDep, existingDep.getJustifier().getRule(), newDep)) {\n                    // fist remove it from the undefeated list\n                    removeUndefeated(existingDep);\n                    if (existingDep.getRootDefeated() != null) {\n                        // build up the list of staged deps, that will need to be reprocessed\n                        if (stagedDeps == null) {\n                            stagedDeps = existingDep.getRootDefeated();\n                        } else {\n                            stagedDeps.setPrevious(existingDep.getTailDefeated());\n                            stagedDeps = existingDep.getRootDefeated();\n                        }\n                    }\n                }\n                existingDep = next;\n            }\n            addUndefeated(newDep);\n            // now process the staged\n            reprocessDefeated(stagedDeps);\n        }\n    }","id":43685,"modified_method":"public void add(LinkedListNode node) {\n        DefeasibleLogicalDependency newDep = (DefeasibleLogicalDependency) ((LinkedListEntry) node).getObject();\n\n        Rule rule = newDep.getJustifier().getRule();\n\n        // first iterate to see if this new dep is defeated. If it's defeated, it can no longer impacts any deps\n        // if we checked what it defeats, and later this was defeated, we would have undo action. So we do the cheaper work first.\n        boolean wasDefeated = false;\n        for (LinkedListEntry<DefeasibleLogicalDependency> existingNode = rootUndefeated; existingNode != null; existingNode = existingNode.getNext()) {\n            DefeasibleLogicalDependency existingDep = existingNode.getObject();\n            wasDefeated = checkAndApplyIsDefeated(newDep, rule, existingDep);\n            if (wasDefeated) {\n                break;\n            }\n        }\n\n        if (!wasDefeated) {\n            DefeasibleLogicalDependency stagedDeps = null;\n            //for (DefeasibleLogicalDependency existingDep = rootUndefeated; existingDep != null; ) {\n            for (LinkedListEntry<DefeasibleLogicalDependency> existingNode = rootUndefeated; existingNode != null; existingNode = existingNode.getNext()) {\n                LinkedListEntry<DefeasibleLogicalDependency> next = existingNode.getNext();\n                DefeasibleLogicalDependency existingDep = existingNode.getObject();\n\n                if (checkAndApplyIsDefeated(existingDep, existingDep.getJustifier().getRule(), newDep)) {\n                    // fist remove it from the undefeated list\n                    removeUndefeated(existingDep, existingNode);\n                    if (existingDep.getRootDefeated() != null) {\n                        // build up the list of staged deps, that will need to be reprocessed\n                        if (stagedDeps == null) {\n                            stagedDeps = existingDep.getRootDefeated();\n                        } else {\n                            stagedDeps.setPrevious(existingDep.getTailDefeated());\n                            stagedDeps = existingDep.getRootDefeated();\n                        }\n                    }\n                }\n                existingNode = next;\n            }\n            addUndefeated(newDep, (LinkedListEntry<DefeasibleLogicalDependency>) node);\n            // now process the staged\n            reprocessDefeated(stagedDeps);\n        }\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public DefeasibleLogicalDependency removeLast() {\n        if (this.tailUndefeated == null) {\n            return null;\n        }\n        final DefeasibleLogicalDependency node = this.tailUndefeated;\n        this.tailUndefeated = (DefeasibleLogicalDependency) node.getPrevious();\n        node.setPrevious(null);\n        if (this.tailUndefeated != null) {\n            this.tailUndefeated.setNext(null);\n        } else {\n            this.rootUndefeated = this.tailUndefeated;\n        }\n        return node;\n    }","id":43686,"modified_method":"public LinkedListNode removeLast() {\n        if (this.tailUndefeated == null) {\n            return null;\n        }\n        final LinkedListEntry<DefeasibleLogicalDependency> node = this.tailUndefeated;\n        this.tailUndefeated = node.getPrevious();\n        node.setPrevious(null);\n        if (this.tailUndefeated != null) {\n            this.tailUndefeated.setNext(null);\n        } else {\n            this.rootUndefeated = this.tailUndefeated;\n        }\n        return node;\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public DefeasibleLogicalDependency getTailUnDefeated() {\n        return this.tailUndefeated;\n    }","id":43687,"modified_method":"public LinkedListNode getTailUnDefeated() {\n        return this.tailUndefeated;\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public DefeasibleLogicalDependency removeFirst() {\n        if (this.rootUndefeated == null) {\n            return null;\n        }\n        final DefeasibleLogicalDependency node = this.rootUndefeated;\n        this.rootUndefeated = (DefeasibleLogicalDependency) node.getNext();\n        node.setNext(null);\n        if (this.rootUndefeated != null) {\n            this.rootUndefeated.setPrevious(null);\n        } else {\n            this.tailUndefeated = null;\n        }\n        return node;\n    }","id":43688,"modified_method":"public LinkedListNode removeFirst() {\n        if (this.rootUndefeated == null) {\n            return null;\n        }\n        final LinkedListEntry<DefeasibleLogicalDependency> node = this.rootUndefeated;\n        this.rootUndefeated = node.getNext();\n        node.setNext(null);\n        if (this.rootUndefeated != null) {\n            this.rootUndefeated.setPrevious(null);\n        } else {\n            this.tailUndefeated = null;\n        }\n        return node;\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void cancel(PropagationContext propagationContext) {\n        // get all but last, as that we'll do via the BeliefSystem, for cleanup\n        // note we don't update negative, conflict counters. It's needed for the last cleanup operation\n        FastIterator it = iterator();\n        for ( DefeasibleLogicalDependency entry = (DefeasibleLogicalDependency) getFirst(); entry != tailUndefeated;  ) {\n            DefeasibleLogicalDependency temp = (DefeasibleLogicalDependency) it.next(entry); // get next, as we are about to remove it\n            final LogicalDependency node = (LogicalDependency) entry.getObject();\n            node.getJustifier().getLogicalDependencies().remove( node );\n            remove( entry );\n            entry = temp;\n        }\n\n        LinkedListEntry last = (LinkedListEntry) getFirst();\n        final LogicalDependency node = (LogicalDependency) last.getObject();\n        node.getJustifier().getLogicalDependencies().remove( node );\n        //beliefSystem.delete( node, this, context );\n        positiveFactHandle = null;\n        negativeFactHandle = null;\n    }","id":43689,"modified_method":"public void cancel(PropagationContext propagationContext) {\n        // get all but last, as that we'll do via the BeliefSystem, for cleanup\n        // note we don't update negative, conflict counters. It's needed for the last cleanup operation\n        FastIterator it = iterator();\n        for ( LinkedListEntry<DefeasibleLogicalDependency>  node =  getFirst(); node != tailUndefeated;  ) {\n            LinkedListEntry<DefeasibleLogicalDependency>  temp = (LinkedListEntry<DefeasibleLogicalDependency>) it.next(node); // get next, as we are about to remove it\n            final DefeasibleLogicalDependency dep =  node.getObject();\n            dep.getJustifier().getLogicalDependencies().remove( dep );\n            remove( dep );\n            node = temp;\n        }\n\n        LinkedListEntry last = (LinkedListEntry) getFirst();\n        final LogicalDependency node = (LogicalDependency) last.getObject();\n        node.getJustifier().getLogicalDependencies().remove( node );\n        //beliefSystem.delete( node, this, context );\n        positiveFactHandle = null;\n        negativeFactHandle = null;\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void addUndefeated(DefeasibleLogicalDependency dep) {\n        boolean pos = dep.getValue() != null && MODE.POSITIVE.getId().equals( dep.getValue().toString() );\n        switch( dep.getStatus() ) {\n            case DEFINITELY:\n                if ( pos ) {\n                    definitelyPosCount++;\n                    statusMask = statusMask & DEFINITELY_POS_BIT;\n                } else {\n                    definitelyNegCount++;\n                    statusMask = statusMask & DEFINITELY_NEG_BIT;\n                }\n                break;\n            case DEFEASIBLY:\n                if ( pos ) {\n                    defeasiblyPosCount++;\n                    statusMask = statusMask & DEFEASIBLY_POS_BIT;\n                } else {\n                    defeasiblyNegCount++;\n                    statusMask = statusMask & DEFEASIBLY_NEG_BIT;\n                }\n                break;\n            case DEFEATEDLY:\n                if ( pos ) {\n                    defeatedlyPosCount++;\n                    statusMask = statusMask & DEFEATEDLY_POS_BIT;\n                } else {\n                    defeatedlyNegCount++;\n                    statusMask = statusMask & DEFEATEDLY_NEG_BIT;\n                }\n                break;\n            case UNDECIDABLY:\n                throw new IllegalStateException(\"Individual logical dependencies cannot be undecidably\");\n        }\n\n        if (rootUndefeated == null) {\n            rootUndefeated = dep;\n            tailUndefeated = dep;\n        } else {\n            if ( dep.getStatus() == DefeasibilityStatus.DEFINITELY ) {\n                // Strict dependencies at to the front\n                rootUndefeated.setPrevious(dep);\n                dep.setNext(rootUndefeated);\n                rootUndefeated = dep;\n            } else {\n                // add to end\n                tailUndefeated.setNext(dep);\n                dep.setPrevious(rootUndefeated);\n                tailUndefeated = dep;\n            }\n        }\n    }","id":43690,"modified_method":"public void addUndefeated(DefeasibleLogicalDependency dep, LinkedListEntry<DefeasibleLogicalDependency> node) {\n        boolean pos = dep.getValue() != null && MODE.POSITIVE.getId().equals( dep.getValue().toString() );\n        switch( dep.getStatus() ) {\n            case DEFINITELY:\n                if ( pos ) {\n                    definitelyPosCount++;\n                    statusMask = statusMask & DEFINITELY_POS_BIT;\n                } else {\n                    definitelyNegCount++;\n                    statusMask = statusMask & DEFINITELY_NEG_BIT;\n                }\n                break;\n            case DEFEASIBLY:\n                if ( pos ) {\n                    defeasiblyPosCount++;\n                    statusMask = statusMask & DEFEASIBLY_POS_BIT;\n                } else {\n                    defeasiblyNegCount++;\n                    statusMask = statusMask & DEFEASIBLY_NEG_BIT;\n                }\n                break;\n            case DEFEATEDLY:\n                if ( pos ) {\n                    defeatedlyPosCount++;\n                    statusMask = statusMask & DEFEATEDLY_POS_BIT;\n                } else {\n                    defeatedlyNegCount++;\n                    statusMask = statusMask & DEFEATEDLY_NEG_BIT;\n                }\n                break;\n            case UNDECIDABLY:\n                throw new IllegalStateException(\"Individual logical dependencies cannot be undecidably\");\n        }\n\n        if (rootUndefeated == null) {\n            rootUndefeated = node;\n            tailUndefeated = node;\n        } else {\n            if ( dep.getStatus() == DefeasibilityStatus.DEFINITELY ) {\n                // Strict dependencies at to the front\n                rootUndefeated.setPrevious(node);\n                node.setNext(rootUndefeated);\n                rootUndefeated = node;\n            } else {\n                // add to end\n                tailUndefeated.setNext(node);\n                node.setPrevious(rootUndefeated);\n                tailUndefeated = node;\n            }\n        }\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void remove(LinkedListNode node) {\n        DefeasibleLogicalDependency dep = (DefeasibleLogicalDependency) node;\n\n        if (dep.getDefeatedBy() != null) {\n            // Defeated deps do not have defeated defeated lists of their own, so just remove.\n            DefeasibleLogicalDependency defeater = dep.getDefeatedBy();\n            defeater.removeDefeated(dep);\n        } else {\n            // ins undefeated, process it's defeated list if they exist\n            removeUndefeated(dep);\n            if (dep.getRootDefeated() != null) {\n                reprocessDefeated(dep.getRootDefeated());\n            }\n        }\n    }","id":43691,"modified_method":"public void remove(LinkedListNode node) {\n        DefeasibleLogicalDependency dep =  ((LinkedListEntry<DefeasibleLogicalDependency>)node).getObject();\n\n        if (dep.getDefeatedBy() != null) {\n            // Defeated deps do not have defeated defeated lists of their own, so just remove.\n            DefeasibleLogicalDependency defeater = dep.getDefeatedBy();\n            defeater.removeDefeated(dep);\n        } else {\n            // ins undefeated, process it's defeated list if they exist\n            removeUndefeated(dep, (LinkedListEntry<DefeasibleLogicalDependency>) node);\n            if (dep.getRootDefeated() != null) {\n                reprocessDefeated(dep.getRootDefeated());\n            }\n        }\n    }","commit_id":"2c97a701c8a963b30e8895efd647f8e6466a3d5b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @see org.opencms.ade.containerpage.client.ui.I_CmsContainerpageToolbarButton#setActive(boolean)\n     */\n    public void setActive(boolean active) {\n\n        if (active) {\n            if (CmsContainerpageEditor.INSTANCE.getCurrentButton() != null) {\n                CmsContainerpageEditor.INSTANCE.getCurrentButton().setActive(false);\n            }\n            onToolbarActivate();\n            CmsContainerpageEditor.INSTANCE.setCurrentButton(this);\n        } else {\n            onToolbarDeactivate();\n            CmsContainerpageEditor.INSTANCE.setCurrentButton(null);\n        }\n        setDown(active);\n    }","id":43692,"modified_method":"/**\n     * @see org.opencms.ade.containerpage.client.ui.I_CmsContainerpageToolbarButton#setActive(boolean)\n     */\n    public void setActive(boolean active) {\n\n        m_isActive = active;\n        setDown(m_isActive);\n\n        if (active) {\n            //            if (CmsContainerpageEditor.INSTANCE.getCurrentButton() != null) {\n            //                CmsContainerpageEditor.INSTANCE.getCurrentButton().setActive(false);\n            //            }\n            onToolbarActivate();\n            //           CmsContainerpageEditor.INSTANCE.setCurrentButton(this);\n        } else {\n            onToolbarDeactivate();\n            //            CmsContainerpageEditor.INSTANCE.setCurrentButton(null);\n        }\n        //        setDown(active);\n    }","commit_id":"b5dc22ee6a8116cbc387238d73b6f1f2b59029ce","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.containerpage.client.ui.I_CmsContainerpageToolbarButton#isActive()\n     */\n    public boolean isActive() {\n\n        return isDown();\n    }","id":43693,"modified_method":"/**\n     * @see org.opencms.ade.containerpage.client.ui.I_CmsContainerpageToolbarButton#isActive()\n     */\n    public boolean isActive() {\n\n        return m_isActive;\n        //return isDown();\n    }","commit_id":"b5dc22ee6a8116cbc387238d73b6f1f2b59029ce","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.containerpage.client.ui.I_CmsContainerpageToolbarButton#isActive()\n     */\n    public boolean isActive() {\n\n        return !isOpen();\n    }","id":43694,"modified_method":"/**\n     * @see org.opencms.ade.containerpage.client.ui.I_CmsContainerpageToolbarButton#isActive()\n     */\n    public boolean isActive() {\n\n        return isOpen();\n    }","commit_id":"b5dc22ee6a8116cbc387238d73b6f1f2b59029ce","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.containerpage.client.ui.I_CmsContainerpageToolbarButton#setActive(boolean)\n     */\n    public void setActive(boolean active) {\n\n        if (active) {\n            if (CmsContainerpageEditor.INSTANCE.getCurrentButton() != null) {\n                CmsContainerpageEditor.INSTANCE.getCurrentButton().setActive(false);\n            }\n            onToolbarActivate();\n            CmsContainerpageEditor.INSTANCE.setCurrentButton(this);\n            this.openMenu();\n\n        } else {\n            onToolbarDeactivate();\n            CmsContainerpageEditor.INSTANCE.setCurrentButton(null);\n            this.closeMenu();\n        }\n\n    }","id":43695,"modified_method":"/**\n     * @see org.opencms.ade.containerpage.client.ui.I_CmsContainerpageToolbarButton#setActive(boolean)\n     */\n    public void setActive(boolean active) {\n\n        if (active) {\n            //            if (CmsContainerpageEditor.INSTANCE.getCurrentButton() != null) {\n            //                CmsContainerpageEditor.INSTANCE.getCurrentButton().setActive(false);\n            //            }\n            onToolbarActivate();\n            //            CmsContainerpageEditor.INSTANCE.setCurrentButton(this);\n            this.openMenu();\n\n        } else {\n            onToolbarDeactivate();\n            //            CmsContainerpageEditor.INSTANCE.setCurrentButton(null);\n            this.closeMenu();\n        }\n\n    }","commit_id":"b5dc22ee6a8116cbc387238d73b6f1f2b59029ce","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n     */\n    public void onClick(ClickEvent event) {\n\n        try {\n            I_CmsContainerpageToolbarButton source = (I_CmsContainerpageToolbarButton)event.getSource();\n            // setting the button active/inactive depending on its current state\n            source.setActive(source.isActive());\n        } catch (Exception e) {\n            CmsDebugLog.getInstance().printLine(e.getMessage());\n        }\n\n    }","id":43696,"modified_method":"/**\n     * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n     */\n    public void onClick(ClickEvent event) {\n\n        try {\n            I_CmsContainerpageToolbarButton source = (I_CmsContainerpageToolbarButton)event.getSource();\n            boolean active = source.isActive();\n            if (!active) {\n                if (m_currentButton != null) {\n                    m_currentButton.setActive(false);\n                }\n                m_currentButton = source;\n            } else {\n                m_currentButton = null;\n            }\n            // setting the button active/inactive depending on its current state\n            source.setActive(!active);\n        } catch (Exception e) {\n            CmsDebugLog.getInstance().printLine(e.getMessage());\n        }\n\n    }","commit_id":"b5dc22ee6a8116cbc387238d73b6f1f2b59029ce","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructor.<p>\n     */\n    public CmsToolbarClipboardMenu() {\n\n        super(CmsToolbarButton.ButtonData.CLIPBOARD, \"clipboard\", true);\n    }","id":43697,"modified_method":"/**\n     * Constructor.<p>\n     */\n    public CmsToolbarClipboardMenu() {\n\n        super(CmsToolbarButton.ButtonData.CLIPBOARD, \"clipboard\", true);\n        Label menuContent = new Label(\"Menu content\");\n        menuContent.getElement().getStyle().setHeight(100, Unit.PX);\n        menuContent.getElement().getStyle().setWidth(650, Unit.PX);\n        setMenuWidget(menuContent);\n    }","commit_id":"b5dc22ee6a8116cbc387238d73b6f1f2b59029ce","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the priority of a menu item visibility mode.<p>\n     *\n     * Higher priority modes override the ones with lower priorities.<p>\n     *\n     *\n     * @param mode the mode\n     * @return the priority for the mode\n     */\n    private int getPriority(CmsMenuItemVisibilityMode mode) {\n\n        if (mode.isActive()) {\n            return 0;\n        }\n        if (mode.isInActive()) {\n            return 1;\n        }\n        // invisible\n        return 2;\n    }","id":43698,"modified_method":"/**\n     * Gets the priority of a menu item visibility mode.<p>\n     *\n     * Higher priority modes override the ones with lower priorities.<p>\n     *\n     *\n     * @param mode the mode\n     * @return the priority for the mode\n     */\n    private int getPriority(CmsMenuItemVisibilityMode mode) {\n\n        if (mode.isPrioritized()) {\n            return 4;\n        }\n        if (mode.isInActive()) {\n            return 0;\n        }\n        if (mode.isActive()) {\n            return 1;\n        }\n        // invisible\n        return 2;\n    }","commit_id":"e6678048ed4e6b91888dafb9d99e3f08a81e787b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.contextmenu.I_CmsHasMenuItemVisibility#getVisibility(org.opencms.file.CmsObject, java.util.List)\n     */\n    public CmsMenuItemVisibilityMode getVisibility(CmsObject cms, List<CmsResource> resources) {\n\n        if (resources.size() <= 1) {\n            // Single-selection case where we just delegate to getSingleVisibility\n            // this applies also to main menu items\n            return getSingleVisibility(cms, resources.size() == 1 ? resources.get(0) : null);\n        } else {\n            if (m_singleResourceOnly) {\n                return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n            }\n            CmsMenuItemVisibilityMode currentVisibility = CmsMenuItemVisibilityMode.VISIBILITY_ACTIVE;\n            for (CmsResource resource : resources) {\n                CmsMenuItemVisibilityMode visibilityForResource = getSingleVisibility(cms, resource);\n                if (getPriority(visibilityForResource) > getPriority(currentVisibility)) {\n                    currentVisibility = visibilityForResource;\n                }\n            }\n            if (currentVisibility.isInActive()) {\n                // In the multi-selection case, different resources may cause the menu item to be inactive for different reasons,\n                // which would make it hard to give a user-readable message. So we set the status to invisible.\n                currentVisibility = CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n            }\n            return currentVisibility;\n        }\n    }","id":43699,"modified_method":"/**\n     * @see org.opencms.ui.contextmenu.I_CmsHasMenuItemVisibility#getVisibility(org.opencms.file.CmsObject, java.util.List)\n     */\n    public CmsMenuItemVisibilityMode getVisibility(CmsObject cms, List<CmsResource> resources) {\n\n        if (resources.size() <= 1) {\n            // Single-selection case where we just delegate to getSingleVisibility\n            // this applies also to main menu items\n            return getSingleVisibility(cms, resources.size() == 1 ? resources.get(0) : null);\n        } else {\n            if (m_singleResourceOnly) {\n                return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n            }\n            CmsMenuItemVisibilityMode currentVisibility = null;\n            for (CmsResource resource : resources) {\n                CmsMenuItemVisibilityMode visibilityForResource = getSingleVisibility(cms, resource);\n                if ((currentVisibility == null)\n                    || (getPriority(visibilityForResource) > getPriority(currentVisibility))) {\n                    currentVisibility = visibilityForResource;\n                }\n            }\n            if (currentVisibility == null) {\n                currentVisibility = CmsMenuItemVisibilityMode.VISIBILITY_ACTIVE;\n            }\n            if (currentVisibility.isInActive()) {\n                // In the multi-selection case, different resources may cause the menu item to be inactive for different reasons,\n                // which would make it hard to give a user-readable message. So we set the status to invisible.\n                currentVisibility = CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n            }\n            return currentVisibility;\n        }\n    }","commit_id":"e6678048ed4e6b91888dafb9d99e3f08a81e787b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds the name of the message key for the visibility mode.<p>\n     *\n     * @param messageKey the name of the message key for the visibility mode\n     * @return an extended visibility mode containing the message key\n     */\n    public CmsMenuItemVisibilityMode addMessageKey(String messageKey) {\n\n        CmsMenuItemVisibilityMode mode = (CmsMenuItemVisibilityMode)clone();\n        mode.m_messageKey = messageKey;\n        return mode;\n    }","id":43700,"modified_method":"/**\n     * Adds the name of the message key for the visibility mode.<p>\n     *\n     * @param messageKey the name of the message key for the visibility mode\n     * @return an extended visibility mode containing the message key\n     */\n    public CmsMenuItemVisibilityMode addMessageKey(String messageKey) {\n\n        CmsMenuItemVisibilityMode mode = clone();\n        mode.m_messageKey = messageKey;\n        return mode;\n    }","commit_id":"e6678048ed4e6b91888dafb9d99e3f08a81e787b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    protected Object clone() {\n\n        return new CmsMenuItemVisibilityMode(getMode());\n    }","id":43701,"modified_method":"/**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    protected CmsMenuItemVisibilityMode clone() {\n\n        return new CmsMenuItemVisibilityMode(getMode());\n    }","commit_id":"e6678048ed4e6b91888dafb9d99e3f08a81e787b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.contextmenu.A_CmsSimpleVisibilityCheck#getSingleVisibility(org.opencms.file.CmsObject, org.opencms.file.CmsResource)\n     */\n    @Override\n    public CmsMenuItemVisibilityMode getSingleVisibility(CmsObject cms, CmsResource resource) {\n\n        String inActiveKey = null;\n        if (flag(roleeditor) && !OpenCms.getRoleManager().hasRole(cms, CmsRole.EDITOR)) {\n            return VISIBILITY_INVISIBLE;\n        }\n\n        if (flag(rolewpuser) && !OpenCms.getRoleManager().hasRole(cms, CmsRole.WORKPLACE_USER)) {\n            return VISIBILITY_INVISIBLE;\n        }\n\n        if (flag(notonline) && cms.getRequestContext().getCurrentProject().isOnlineProject()) {\n            return VISIBILITY_INVISIBLE;\n        }\n\n        if ((resource != null)) {\n            // in case of main menu entries, the given resource is null\n            if (flag(mainmenu)) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            CmsResourceUtil resUtil = new CmsResourceUtil(cms, resource);\n            if (flag(file) && !resource.isFile()) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(folder) && resource.isFile()) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(pointer)\n                && !OpenCms.getResourceManager().matchResourceType(\n                    CmsResourceTypePointer.getStaticTypeName(),\n                    resource.getTypeId())) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(replacable)) {\n                I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resource);\n                boolean usesDumpLoader = type.getLoaderId() == CmsDumpLoader.RESOURCE_LOADER_ID;\n                if (!usesDumpLoader && !(type instanceof CmsResourceTypeImage)) {\n                    return VISIBILITY_INVISIBLE;\n                }\n\n            }\n\n            if (flag(xml)) {\n                I_CmsResourceType type = resUtil.getResourceType();\n                boolean isXml = (type instanceof CmsResourceTypeXmlContent) || (type instanceof CmsResourceTypeXmlPage);\n                if (!isXml) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(unlocked)) {\n                CmsLock lock = resUtil.getLock();\n                if (!lock.isUnlocked()) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(otherlock)) {\n                CmsLock lock = resUtil.getLock();\n                if (lock.isUnlocked() || lock.isOwnedBy(cms.getRequestContext().getCurrentUser())) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(nootherlock)) {\n                CmsLock lock = resUtil.getLock();\n                if (!lock.isUnlocked() && !lock.isOwnedBy(cms.getRequestContext().getCurrentUser())) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(mylock)) {\n                CmsLock lock = resUtil.getLock();\n                if (!lock.isOwnedBy(cms.getRequestContext().getCurrentUser())) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(noinheritedlock)) {\n                CmsLock lock = resUtil.getLock();\n                if (lock.isInherited()) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(notunchangedfile) && resource.isFile() && resUtil.getResource().getState().isUnchanged()) {\n                inActiveKey = Messages.GUI_CONTEXTMENU_TITLE_INACTIVE_UNCHANGED_0;\n            }\n\n            if (flag(notnew) && (inActiveKey == null) && resource.getState().isNew()) {\n                inActiveKey = Messages.GUI_CONTEXTMENU_TITLE_INACTIVE_NEW_UNCHANGED_0;\n            }\n\n            if (flag(haseditor)\n                && !OpenCms.getWorkplaceManager().getWorkplaceEditorManager().isEditorAvailableForResource(resource)) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(inproject) && (!resUtil.isInsideProject() || resUtil.getProjectState().isLockedForPublishing())) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(notinproject)\n                && (resUtil.isInsideProject() || resUtil.getProjectState().isLockedForPublishing())) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(publishpermission)) {\n                try {\n                    if (!cms.hasPermissions(\n                        resource,\n                        CmsPermissionSet.ACCESS_DIRECT_PUBLISH,\n                        false,\n                        CmsResourceFilter.ALL)) {\n                        return VISIBILITY_INVISIBLE;\n                    }\n                } catch (CmsException e) {\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            }\n\n            if (flag(controlpermission)) {\n                try {\n                    if (!cms.hasPermissions(\n                        resource,\n                        CmsPermissionSet.ACCESS_CONTROL,\n                        false,\n                        CmsResourceFilter.IGNORE_EXPIRATION)) {\n                        return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n                    }\n                } catch (CmsException e) {\n                    LOG.warn(\"Error checking context menu entry permissions\", e);\n                    return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(writepermisssion)) {\n                try {\n                    if (!resUtil.getLock().isLockableBy(cms.getRequestContext().getCurrentUser())) {\n                        // set invisible if not lockable\n                        return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n                    }\n                    if (!resUtil.isEditable()\n                        || !cms.hasPermissions(\n                            resUtil.getResource(),\n                            CmsPermissionSet.ACCESS_WRITE,\n                            false,\n                            CmsResourceFilter.ALL)) {\n                        inActiveKey = Messages.GUI_CONTEXTMENU_TITLE_INACTIVE_PERM_WRITE_0;\n                    }\n                } catch (CmsException e) {\n                    LOG.debug(\"Error checking context menu entry permissions.\", e);\n                    return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(notdeleted) && (inActiveKey == null) && resUtil.getResource().getState().isDeleted()) {\n                inActiveKey = Messages.GUI_CONTEXTMENU_TITLE_INACTIVE_DELETED_0;\n            }\n\n            if (flag(deleted) && !resource.getState().isDeleted()) {\n                return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n            }\n\n        } else {\n            if (!flag(mainmenu)) {\n                return VISIBILITY_INVISIBLE;\n            }\n        }\n        if (inActiveKey != null) {\n            return CmsMenuItemVisibilityMode.VISIBILITY_INACTIVE.addMessageKey(inActiveKey);\n        }\n        return VISIBILITY_ACTIVE;\n    }","id":43702,"modified_method":"/**\n     * @see org.opencms.ui.contextmenu.A_CmsSimpleVisibilityCheck#getSingleVisibility(org.opencms.file.CmsObject, org.opencms.file.CmsResource)\n     */\n    @Override\n    public CmsMenuItemVisibilityMode getSingleVisibility(CmsObject cms, CmsResource resource) {\n\n        boolean prioritize = false;\n        String inActiveKey = null;\n        if (flag(roleeditor) && !OpenCms.getRoleManager().hasRole(cms, CmsRole.EDITOR)) {\n            return VISIBILITY_INVISIBLE;\n        }\n\n        if (flag(rolewpuser) && !OpenCms.getRoleManager().hasRole(cms, CmsRole.WORKPLACE_USER)) {\n            return VISIBILITY_INVISIBLE;\n        }\n\n        if (flag(notonline) && cms.getRequestContext().getCurrentProject().isOnlineProject()) {\n            return VISIBILITY_INVISIBLE;\n        }\n\n        if ((resource != null)) {\n            // in case of main menu entries, the given resource is null\n            if (flag(mainmenu)) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            CmsResourceUtil resUtil = new CmsResourceUtil(cms, resource);\n            if (flag(file) && !resource.isFile()) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(folder) && resource.isFile()) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(pointer)\n                && !OpenCms.getResourceManager().matchResourceType(\n                    CmsResourceTypePointer.getStaticTypeName(),\n                    resource.getTypeId())) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(replacable)) {\n                I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resource);\n                boolean usesDumpLoader = type.getLoaderId() == CmsDumpLoader.RESOURCE_LOADER_ID;\n                if (!usesDumpLoader && !(type instanceof CmsResourceTypeImage)) {\n                    return VISIBILITY_INVISIBLE;\n                }\n\n            }\n\n            if (flag(xml)) {\n                I_CmsResourceType type = resUtil.getResourceType();\n                boolean isXml = (type instanceof CmsResourceTypeXmlContent) || (type instanceof CmsResourceTypeXmlPage);\n                if (!isXml) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(unlocked)) {\n                CmsLock lock = resUtil.getLock();\n                if (!lock.isUnlocked()) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(otherlock)) {\n                CmsLock lock = resUtil.getLock();\n                if (lock.isUnlocked() || lock.isOwnedBy(cms.getRequestContext().getCurrentUser())) {\n                    return VISIBILITY_INVISIBLE;\n                }\n                prioritize = true;\n            }\n\n            if (flag(nootherlock)) {\n                CmsLock lock = resUtil.getLock();\n                if (!lock.isUnlocked() && !lock.isOwnedBy(cms.getRequestContext().getCurrentUser())) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(mylock)) {\n                CmsLock lock = resUtil.getLock();\n                if (!lock.isOwnedBy(cms.getRequestContext().getCurrentUser())) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(noinheritedlock)) {\n                CmsLock lock = resUtil.getLock();\n                if (lock.isInherited()) {\n                    return VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(notunchangedfile) && resource.isFile() && resUtil.getResource().getState().isUnchanged()) {\n                inActiveKey = Messages.GUI_CONTEXTMENU_TITLE_INACTIVE_UNCHANGED_0;\n            }\n\n            if (flag(notnew) && (inActiveKey == null) && resource.getState().isNew()) {\n                inActiveKey = Messages.GUI_CONTEXTMENU_TITLE_INACTIVE_NEW_UNCHANGED_0;\n            }\n\n            if (flag(haseditor)\n                && !OpenCms.getWorkplaceManager().getWorkplaceEditorManager().isEditorAvailableForResource(resource)) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(inproject) && (!resUtil.isInsideProject() || resUtil.getProjectState().isLockedForPublishing())) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(notinproject)\n                && (resUtil.isInsideProject() || resUtil.getProjectState().isLockedForPublishing())) {\n                return VISIBILITY_INVISIBLE;\n            }\n\n            if (flag(publishpermission)) {\n                try {\n                    if (!cms.hasPermissions(\n                        resource,\n                        CmsPermissionSet.ACCESS_DIRECT_PUBLISH,\n                        false,\n                        CmsResourceFilter.ALL)) {\n                        return VISIBILITY_INVISIBLE;\n                    }\n                } catch (CmsException e) {\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            }\n\n            if (flag(controlpermission)) {\n                try {\n                    if (!cms.hasPermissions(\n                        resource,\n                        CmsPermissionSet.ACCESS_CONTROL,\n                        false,\n                        CmsResourceFilter.IGNORE_EXPIRATION)) {\n                        return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n                    }\n                } catch (CmsException e) {\n                    LOG.warn(\"Error checking context menu entry permissions\", e);\n                    return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(writepermisssion)) {\n                try {\n                    if (!resUtil.getLock().isLockableBy(cms.getRequestContext().getCurrentUser())) {\n                        // set invisible if not lockable\n                        return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n                    }\n                    if (!resUtil.isEditable()\n                        || !cms.hasPermissions(\n                            resUtil.getResource(),\n                            CmsPermissionSet.ACCESS_WRITE,\n                            false,\n                            CmsResourceFilter.ALL)) {\n                        inActiveKey = Messages.GUI_CONTEXTMENU_TITLE_INACTIVE_PERM_WRITE_0;\n                    }\n                } catch (CmsException e) {\n                    LOG.debug(\"Error checking context menu entry permissions.\", e);\n                    return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n                }\n            }\n\n            if (flag(notdeleted) && (inActiveKey == null) && resUtil.getResource().getState().isDeleted()) {\n                inActiveKey = Messages.GUI_CONTEXTMENU_TITLE_INACTIVE_DELETED_0;\n            }\n\n            if (flag(deleted) && !resource.getState().isDeleted()) {\n                return CmsMenuItemVisibilityMode.VISIBILITY_INVISIBLE;\n            }\n\n        } else {\n            if (!flag(mainmenu)) {\n                return VISIBILITY_INVISIBLE;\n            }\n        }\n        if (inActiveKey != null) {\n            return CmsMenuItemVisibilityMode.VISIBILITY_INACTIVE.addMessageKey(inActiveKey).prioritize(prioritize);\n        }\n        return VISIBILITY_ACTIVE.prioritize(prioritize);\n    }","commit_id":"e6678048ed4e6b91888dafb9d99e3f08a81e787b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n    public void startBot() throws IRCBotException\n    {\n        if (isBotStarted()) {\n            throw new IRCBotException(\"Bot is already started!\");\n        }\n\n        // Get configuration data for the Bot\n        BotData botData = this.ircModel.loadBotData();\n\n        if (botData.isActive()) {\n            // Register Bot Listener components to the Bot\n            ListenerManager listenerManager = this.bot.getListenerManager();\n            for (IRCBotListener botListener : this.botListenerComponents.get()) {\n                listenerManager.addListener(botListener);\n            }\n\n            // Register all Wiki Bot Listeners before we start the Bot itself just because we want all Bot Listeners to\n            // be ready when the Bot starts so that they can receive all the events and not miss any.\n            this.botListenerManager.registerWikiBotListeners();\n\n            // Connect to server if not already connected\n            if (!this.bot.isConnected()) {\n                this.bot.setName(botData.getName());\n                try {\n                    this.bot.connect(botData.getServer());\n                } catch (Exception e) {\n                    throw new IRCBotException(\n                        String.format(\"Failed to connect to IRC server [%s]\", botData.getServer()), e);\n                }\n\n                // Identify if a password is set\n                if (!StringUtils.isEmpty(botData.getPassword())) {\n                    this.bot.identify(botData.getPassword());\n                }\n            }\n\n            // Join channel\n            this.bot.joinChannel(botData.getChannel());\n        }\n    }","id":43703,"modified_method":"@Override\n    public void startBot(boolean updateBotStatus) throws IRCBotException\n    {\n        if (isBotStarted()) {\n            throw new IRCBotException(\"Bot is already started!\");\n        }\n\n        // Get configuration data for the Bot\n        BotData botData = this.ircModel.loadBotData();\n\n        if (botData.isActive() || updateBotStatus) {\n            // Register Bot Listener components to the Bot\n            ListenerManager listenerManager = this.bot.getListenerManager();\n            for (IRCBotListener botListener : this.botListenerComponents.get()) {\n                listenerManager.addListener(botListener);\n            }\n\n            // Register all Wiki Bot Listeners before we start the Bot itself just because we want all Bot Listeners to\n            // be ready when the Bot starts so that they can receive all the events and not miss any.\n            this.botListenerManager.registerWikiBotListeners();\n\n            // Connect to server if not already connected\n            if (!this.bot.isConnected()) {\n                this.bot.setName(botData.getName());\n                try {\n                    this.bot.connect(botData.getServer());\n                } catch (Exception e) {\n                    throw new IRCBotException(\n                        String.format(\"Failed to connect to IRC server [%s]\", botData.getServer()), e);\n                }\n\n                // Identify if a password is set\n                if (!StringUtils.isEmpty(botData.getPassword())) {\n                    this.bot.identify(botData.getPassword());\n                }\n            }\n\n            // Join channel\n            this.bot.joinChannel(botData.getChannel());\n\n            // Mark the Bot as active if it's not already and updateBotStatus is true\n            if (updateBotStatus && !botData.isActive()) {\n                this.ircModel.setActive(true);\n            }\n\n        }\n    }","commit_id":"6d09a0111c40f724fd64a5a570aeb77139392dc1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void stopBot() throws IRCBotException\n    {\n        if (this.bot.isConnected()) {\n            this.bot.disconnect();\n            // Wait for the IRC Server to be fully stopped\n            while (this.bot.isConnected()) {\n                try {\n                    Thread.sleep(100L);\n                } catch (InterruptedException e) {\n                    throw new IRCBotException(\"Failed to fully wait for IRC client termination\", e);\n                }\n            }\n        }\n\n        // Unregister after disconnecting the Bot to allow the listeners to receive all the events till the last moment.\n        // Note that Bot Listeners handling event after the disconnection should pay attention not to send anything to\n        // the channel since the Bot is stopped!\n        this.botListenerManager.unregisterWikiBotListeners();\n    }","id":43704,"modified_method":"@Override\n    public void stopBot(boolean updateBotStatus) throws IRCBotException\n    {\n        if (!isBotStarted()) {\n            throw new IRCBotException(\"Bot is already stopped!\");\n        }\n\n        this.bot.disconnect();\n\n        // Wait for the IRC Server to be fully stopped\n        while (this.bot.isConnected()) {\n            try {\n                Thread.sleep(100L);\n            } catch (InterruptedException e) {\n                throw new IRCBotException(\"Failed to fully wait for IRC client termination\", e);\n            }\n        }\n\n        // Unregister after disconnecting the Bot to allow the listeners to receive all the events till the last moment.\n        // Note that Bot Listeners handling event after the disconnection should pay attention not to send anything to\n        // the channel since the Bot is stopped!\n        this.botListenerManager.unregisterWikiBotListeners();\n\n        // Mark the Bot as inactive\n        if (updateBotStatus) {\n            this.ircModel.setActive(false);\n        }\n    }","commit_id":"6d09a0111c40f724fd64a5a570aeb77139392dc1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void startBot() throws Exception\n    {\n        final IRCBot bot = getComponentManager().lookupComponent(IRCBot.class);\n        final WikiIRCModel ircModel = getComponentManager().lookupComponent(WikiIRCModel.class);\n        final BotData botData = new BotData(\"botName\", \"server\", null, \"channel\", true);\n        final ListenerManager listenerManager = getMockery().mock(ListenerManager.class);\n        final Provider<List<IRCBotListener>> botListenerComponents =\n            getComponentManager().lookupComponent(new DefaultParameterizedType(null, Provider.class,\n                new DefaultParameterizedType(null, List.class, IRCBotListener.class)));\n        final IRCBotListener componentBotListener = getMockery().mock(IRCBotListener.class);\n        final WikiIRCBotListenerManager botListenerManager =\n            getComponentManager().lookupComponent(WikiIRCBotListenerManager.class);\n\n        getMockery().checking(new Expectations()\n        {{\n            oneOf(bot).isConnected();\n            will(returnValue(false));\n            oneOf(ircModel).loadBotData();\n            will(returnValue(botData));\n            allowing(bot).getListenerManager();\n            will(returnValue(listenerManager));\n            oneOf(botListenerComponents).get();\n            will(returnValue(Collections.singletonList(componentBotListener)));\n            oneOf(bot).isConnected();\n            will(returnValue(false));\n\n            // Real tests are here:\n\n            // - Verify that the component listener is added to the ListenerManager and that the Wiki Bot Listeners\n            //    registration is made\n            oneOf(listenerManager).addListener(componentBotListener);\n            oneOf(botListenerManager).registerWikiBotListeners();\n\n            // - Verify that the Bot sets the bot name, connects to the server and join the channel\n            oneOf(bot).setName(\"botName\");\n            oneOf(bot).connect(\"server\");\n            oneOf(bot).joinChannel(\"channel\");\n        }});\n\n        this.manager.startBot();\n    }","id":43705,"modified_method":"@Test\n    public void startBot() throws Exception\n    {\n        prepareStartBotTests(true);\n\n        this.manager.startBot(false);\n    }","commit_id":"6d09a0111c40f724fd64a5a570aeb77139392dc1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public BotData loadBotData() throws IRCBotException\n    {\n        XWikiDocument configurationDocument = getConfigurationDocument();\n        BaseObject configurationObject = configurationDocument.getXObject(WIKI_BOT_CONFIGURATION_CLASS);\n        if (configurationObject == null) {\n            // There's no Bot Configuration object\n            throw new IRCBotException(String.format(\"Cannot find IRC Bot Configuration object in [%s] document\",\n                this.compactWikiSerializer.serialize(configurationDocument.getDocumentReference())));\n        }\n\n        BotData botData = new BotData(\n            configurationObject.getStringValue(BOTNAME_PROPERTY),\n            configurationObject.getStringValue(SERVER_PROPERTY),\n            configurationObject.getStringValue(PASSWORD_PROPERTY),\n            configurationObject.getStringValue(CHANNEL_PROPERTY),\n            configurationObject.getIntValue(INACTIVE_PROPERTY) != 1);\n\n        return botData;\n    }","id":43706,"modified_method":"@Override\n    public BotData loadBotData() throws IRCBotException\n    {\n        BaseObject configurationObject = getIRCBotConfigurationObject();\n        BotData botData = new BotData(\n            configurationObject.getStringValue(BOTNAME_PROPERTY),\n            configurationObject.getStringValue(SERVER_PROPERTY),\n            configurationObject.getStringValue(PASSWORD_PROPERTY),\n            configurationObject.getStringValue(CHANNEL_PROPERTY),\n            configurationObject.getIntValue(INACTIVE_PROPERTY) != 1);\n        return botData;\n    }","commit_id":"6d09a0111c40f724fd64a5a570aeb77139392dc1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void scheduleHeartbeat() {\n\t\tif (this.heartbeatDisabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tAssert.state(this.config.getTaskScheduler() != null, \"Expected SockJS TaskScheduler\");\n\t\tcancelHeartbeat();\n\t\tif (!isActive()) {\n\t\t\treturn;\n\t\t}\n\n\t\tDate time = new Date(System.currentTimeMillis() + this.config.getHeartbeatTime());\n\t\tthis.heartbeatTask = this.config.getTaskScheduler().schedule(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tsendHeartbeat();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}, time);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Scheduled heartbeat in session \" + getId());\n\t\t}\n\t}","id":43707,"modified_method":"protected void scheduleHeartbeat() {\n\t\tif (this.heartbeatDisabled) {\n\t\t\treturn;\n\t\t}\n\t\tsynchronized (this.heartbeatLock) {\n\t\t\tcancelHeartbeat();\n\t\t\tif (!isActive()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDate time = new Date(System.currentTimeMillis() + this.config.getHeartbeatTime());\n\t\t\tthis.heartbeatTask = new HeartbeatTask();\n\t\t\tthis.heartbeatFuture = this.config.getTaskScheduler().schedule(this.heartbeatTask, time);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Scheduled heartbeat in session \" + getId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"16879a2cf0829047188b0f9b1b11ff87af10ab69","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void sendHeartbeat() throws SockJsTransportFailureException {\n\t\tif (isActive()) {\n\t\t\tif (heartbeatLock.tryLock()) {\n\t\t\t\ttry {\n\t\t\t\t\twriteFrame(SockJsFrame.heartbeatFrame());\n\t\t\t\t\tscheduleHeartbeat();\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\theartbeatLock.unlock();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":43708,"modified_method":"protected void sendHeartbeat() throws SockJsTransportFailureException {\n\t\tsynchronized (this.heartbeatLock) {\n\t\t\tif (isActive() && !this.heartbeatDisabled) {\n\t\t\t\twriteFrame(SockJsFrame.heartbeatFrame());\n\t\t\t\tscheduleHeartbeat();\n\t\t\t}\n\t\t}\n\t}","commit_id":"16879a2cf0829047188b0f9b1b11ff87af10ab69","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void cancelHeartbeat() {\n\t\ttry {\n\t\t\tScheduledFuture<?> task = this.heartbeatTask;\n\t\t\tthis.heartbeatTask = null;\n\t\t\tif (task == null || task.isCancelled()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Cancelling heartbeat in session \" + getId());\n\t\t\t}\n\t\t\tif (task.cancel(false)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Failed to cancel heartbeat, acquiring heartbeat write lock.\");\n\t\t\t}\n\t\t\tthis.heartbeatLock.lock();\n\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Releasing heartbeat lock.\");\n\t\t\t}\n\t\t\tthis.heartbeatLock.unlock();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Failure while cancelling heartbeat in session \" + getId(), ex);\n\t\t}\n\t}","id":43709,"modified_method":"protected void cancelHeartbeat() {\n\t\tsynchronized (this.heartbeatLock) {\n\t\t\tif (this.heartbeatFuture != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Cancelling heartbeat in session \" + getId());\n\t\t\t\t}\n\t\t\t\tthis.heartbeatFuture.cancel(false);\n\t\t\t\tthis.heartbeatFuture = null;\n\t\t\t}\n\t\t\tif (this.heartbeatTask != null) {\n\t\t\t\tthis.heartbeatTask.cancel();\n\t\t\t\tthis.heartbeatTask = null;\n\t\t\t}\n\t\t}\n\t}","commit_id":"16879a2cf0829047188b0f9b1b11ff87af10ab69","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void scheduleAndCancelHeartbeat() throws Exception {\n\n\t\tScheduledFuture<?> task = mock(ScheduledFuture.class);\n\t\twillReturn(task).given(this.taskScheduler).schedule(any(Runnable.class), any(Date.class));\n\n\t\tthis.session.setActive(true);\n\t\tthis.session.scheduleHeartbeat();\n\n\t\tverify(this.taskScheduler).schedule(any(Runnable.class), any(Date.class));\n\t\tverifyNoMoreInteractions(this.taskScheduler);\n\n\t\tgiven(task.isCancelled()).willReturn(false);\n\t\tgiven(task.cancel(false)).willReturn(true);\n\n\t\tthis.session.cancelHeartbeat();\n\n\t\tverify(task).isCancelled();\n\t\tverify(task).cancel(false);\n\t\tverifyNoMoreInteractions(task);\n\t}","id":43710,"modified_method":"@Test\n\tpublic void scheduleAndCancelHeartbeat() throws Exception {\n\n\t\tScheduledFuture<?> task = mock(ScheduledFuture.class);\n\t\twillReturn(task).given(this.taskScheduler).schedule(any(Runnable.class), any(Date.class));\n\n\t\tthis.session.setActive(true);\n\t\tthis.session.scheduleHeartbeat();\n\n\t\tverify(this.taskScheduler).schedule(any(Runnable.class), any(Date.class));\n\t\tverifyNoMoreInteractions(this.taskScheduler);\n\n\t\tgiven(task.isCancelled()).willReturn(false);\n\t\tgiven(task.cancel(false)).willReturn(true);\n\n\t\tthis.session.cancelHeartbeat();\n\n\t\tverify(task).cancel(false);\n\t\tverifyNoMoreInteractions(task);\n\t}","commit_id":"16879a2cf0829047188b0f9b1b11ff87af10ab69","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void sendHeartbeatWhenDisabled() throws Exception {\n\t\tthis.session.disableHeartbeat();\n\t\tthis.session.sendHeartbeat();\n\n\t\tassertEquals(Collections.emptyList(), this.session.getSockJsFramesWritten());\n\t}","id":43711,"modified_method":"@Test\n\tpublic void sendHeartbeatWhenDisabled() throws Exception {\n\t\tthis.session.disableHeartbeat();\n\t\tthis.session.setActive(true);\n\t\tthis.session.sendHeartbeat();\n\n\t\tassertEquals(Collections.emptyList(), this.session.getSockJsFramesWritten());\n\t}","commit_id":"16879a2cf0829047188b0f9b1b11ff87af10ab69","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public int size() {\n            return lsValues.size();\n        }","id":43712,"modified_method":"public int size() {\n            return (lsValues == null) ? 0 : lsValues.size();\n        }","commit_id":"9e5fe91bcc9e8225743c5dec9224954f8a4c46f7","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object next() {\n                Data value = it.next();\n                return ThreadContext.get().toObject(value);\n            }","id":43713,"modified_method":"public Object next() {\n                Data value = it.next();\n                return toObject(value);\n            }","commit_id":"9e5fe91bcc9e8225743c5dec9224954f8a4c46f7","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object[] toArray() {\n            throw new UnsupportedOperationException();\n        }","id":43714,"modified_method":"public Object[] toArray() {\n            if (size() == 0) {\n                return null;\n            }\n            return toArray(new Object[size()]);\n        }","commit_id":"9e5fe91bcc9e8225743c5dec9224954f8a4c46f7","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object[] toArray(Object[] a) {\n            throw new UnsupportedOperationException();\n        }","id":43715,"modified_method":"public Object[] toArray(Object[] a) {\n            int size = size();\n            if (size == 0) {\n                return null;\n            }\n            if (a == null || a.length < size) {\n                a = new Object[size];\n            }\n            for (int i = 0; i < size; i++) {\n                a[i] = toObject(lsValues.get(i));\n            }\n            return a;\n        }","commit_id":"9e5fe91bcc9e8225743c5dec9224954f8a4c46f7","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object get(Object key) {\n        processLocalRecords();\n        Record record = mapCache.get(key);\n        if (record == null) {\n            return OBJECT_REDO;\n        } else {\n            if (record.isActive()) {\n                try {\n                    Object value = toObject(record.getValue());\n                    record.setLastAccessed();\n                    return value;\n                } catch (Throwable t) {\n                    logger.log(Level.FINEST, \"Exception when reading object \", t);\n                    return OBJECT_REDO;\n                }\n            } else {\n                //record is removed!\n                mapCache.remove(key);\n                return null;\n            }\n        }\n    }","id":43716,"modified_method":"public Object get(Object key) {\n        processLocalRecords();\n        Record record = mapCache.get(key);\n        if (record == null) {\n            return OBJECT_REDO;\n        } else {\n            if (record.isActive() && record.isValid()) {\n                try {\n                    Object value = toObject(record.getValue());\n                    record.setLastAccessed();\n                    return value;\n                } catch (Throwable t) {\n                    logger.log(Level.FINEST, \"Exception when reading object \", t);\n                    return OBJECT_REDO;\n                }\n            } else {\n                //record is removed!\n                mapCache.remove(key);\n//                return null;\n                return OBJECT_REDO;\n            }\n        }\n    }","commit_id":"9e5fe91bcc9e8225743c5dec9224954f8a4c46f7","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n\tprotected synchronized void writeFrameInternal(SockJsFrame frame) throws IOException {\n\t\tif (isActive()) {\n\t\t\tframe = this.frameFormat.format(frame);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Writing \" + frame);\n\t\t\t}\n\t\t\tthis.response.getBody().write(frame.getContentBytes());\n\t\t}\n\t}","id":43717,"modified_method":"@Override\n\tprotected void writeFrameInternal(SockJsFrame frame) throws IOException {\n\t\tif (isActive()) {\n\t\t\tframe = this.frameFormat.format(frame);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Writing \" + frame);\n\t\t\t}\n\t\t\tgetResponse().getBody().write(frame.getContentBytes());\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public AbstractHttpSockJsSession(String id, SockJsServiceConfig config,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) {\n\n\t\tsuper(id, config, wsHandler, attributes);\n\t\tthis.messageCache = new ArrayBlockingQueue<String>(config.getHttpMessageCacheSize());\n\t}","id":43718,"modified_method":"public AbstractHttpSockJsSession(String id, SockJsServiceConfig config,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) {\n\n\t\tsuper(id, config, wsHandler, attributes);\n\t\tthis.messageCache = new LinkedBlockingQueue<String>(config.getHttpMessageCacheSize());\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void tryFlushCache() throws SockJsTransportFailureException {\n\t\tif (this.messageCache.isEmpty()) {\n\t\t\tlogger.trace(\"Nothing to flush\");\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(this.messageCache.size() + \" message(s) to flush\");\n\t\t}\n\t\tif (isActive()) {\n\t\t\tlogger.trace(\"Flushing messages\");\n\t\t\tflushCache();\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Not ready to flush\");\n\t\t\t}\n\t\t}\n\t}","id":43719,"modified_method":"private void tryFlushCache() throws SockJsTransportFailureException {\n\t\tif (this.messageCache.isEmpty()) {\n\t\t\tlogger.trace(\"Nothing to flush\");\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(this.messageCache.size() + \" message(s) to flush\");\n\t\t}\n\t\tif (isActive() && this.requestInitialized) {\n\t\t\tlogger.trace(\"Flushing messages\");\n\t\t\tflushCache();\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Not ready to flush\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected final synchronized void sendMessageInternal(String message) throws SockJsTransportFailureException {\n\t\tthis.messageCache.add(message);\n\t\ttryFlushCache();\n\t}","id":43720,"modified_method":"@Override\n\tprotected final void sendMessageInternal(String message) throws SockJsTransportFailureException {\n\t\tthis.messageCache.add(message);\n\t\ttryFlushCache();\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected synchronized void resetRequest() {\n\t\tupdateLastActiveTime();\n\t\tif (isActive() && this.asyncRequestControl.isStarted()) {\n\t\t\ttry {\n\t\t\t\tlogger.debug(\"Completing asynchronous request\");\n\t\t\t\tthis.asyncRequestControl.complete();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.error(\"Failed to complete request: \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\tthis.request = null;\n\t\tthis.response = null;\n\t\tthis.asyncRequestControl = null;\n\t}","id":43721,"modified_method":"protected void resetRequest() {\n\n\t\tthis.requestInitialized = false;\n\t\tupdateLastActiveTime();\n\n\t\tif (isActive()) {\n\t\t\tServerHttpAsyncRequestControl control = this.asyncRequestControl;\n\t\t\tif (control.isStarted()) {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.debug(\"Completing asynchronous request\");\n\t\t\t\t\tcontrol.complete();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.error(\"Failed to complete request: \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.response = null;\n\t\tthis.asyncRequestControl = null;\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic synchronized boolean isActive() {\n\t\treturn (this.asyncRequestControl != null && !this.asyncRequestControl.isCompleted());\n\t}","id":43722,"modified_method":"@Override\n\tpublic boolean isActive() {\n\t\tServerHttpAsyncRequestControl control = this.asyncRequestControl;\n\t\treturn (control != null && !control.isCompleted());\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Handle the first HTTP request, i.e. the one that starts a SockJS session.\n\t * Write a prelude to the response (if needed), send the SockJS \"open\" frame\n\t * to indicate to the client the session is opened, and invoke the\n\t * delegate WebSocketHandler to provide it with the newly opened session.\n\t * <p>\n\t * The \"xhr\" and \"jsonp\" (polling-based) transports completes the initial request\n\t * as soon as the open frame is sent. Following that the client should start a\n\t * successive polling request within the same SockJS session.\n\t * <p>\n\t * The \"xhr_streaming\", \"eventsource\", and \"htmlfile\" transports are streaming\n\t * based and will leave the initial request open in order to stream one or\n\t * more messages. However, even streaming based transports eventually recycle\n\t * the long running request, after a certain number of bytes have been streamed\n\t * (128K by default), and allow the client to start a successive request within\n\t * the same SockJS session.\n\t *\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t *\n\t * @see #handleSuccessiveRequest(org.springframework.http.server.ServerHttpRequest, org.springframework.http.server.ServerHttpResponse, org.springframework.web.socket.sockjs.frame.SockJsFrameFormat)\n\t */\n\tpublic synchronized void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tinitRequest(request, response, frameFormat);\n\n\t\tthis.uri = request.getURI();\n\t\tthis.handshakeHeaders = request.getHeaders();\n\t\tthis.principal = request.getPrincipal();\n\t\tthis.localAddress = request.getLocalAddress();\n\t\tthis.remoteAddress = request.getRemoteAddress();\n\n\t\ttry {\n\t\t\twritePrelude();\n\t\t\twriteFrame(SockJsFrame.openFrame());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to send \\\"open\\\" frame\", getId(), ex);\n\t\t}\n\n\t\ttry {\n\t\t\tdelegateConnectionEstablished();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SockJsException(\"Unhandled exception from WebSocketHandler\", getId(), ex);\n\t\t}\n\t}","id":43723,"modified_method":"/**\n\t * Handle the first HTTP request, i.e. the one that starts a SockJS session.\n\t * Write a prelude to the response (if needed), send the SockJS \"open\" frame\n\t * to indicate to the client the session is opened, and invoke the\n\t * delegate WebSocketHandler to provide it with the newly opened session.\n\t * <p>\n\t * The \"xhr\" and \"jsonp\" (polling-based) transports completes the initial request\n\t * as soon as the open frame is sent. Following that the client should start a\n\t * successive polling request within the same SockJS session.\n\t * <p>\n\t * The \"xhr_streaming\", \"eventsource\", and \"htmlfile\" transports are streaming\n\t * based and will leave the initial request open in order to stream one or\n\t * more messages. However, even streaming based transports eventually recycle\n\t * the long running request, after a certain number of bytes have been streamed\n\t * (128K by default), and allow the client to start a successive request within\n\t * the same SockJS session.\n\t *\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t *\n\t * @see #handleSuccessiveRequest(org.springframework.http.server.ServerHttpRequest, org.springframework.http.server.ServerHttpResponse, org.springframework.web.socket.sockjs.frame.SockJsFrameFormat)\n\t */\n\tpublic void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tinitRequest(request, response, frameFormat);\n\n\t\tthis.uri = request.getURI();\n\t\tthis.handshakeHeaders = request.getHeaders();\n\t\tthis.principal = request.getPrincipal();\n\t\tthis.localAddress = request.getLocalAddress();\n\t\tthis.remoteAddress = request.getRemoteAddress();\n\n\t\ttry {\n\t\t\twritePrelude(request, response);\n\t\t\twriteFrame(SockJsFrame.openFrame());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to send \\\"open\\\" frame\", getId(), ex);\n\t\t}\n\n\t\ttry {\n\t\t\tthis.requestInitialized = true;\n\t\t\tdelegateConnectionEstablished();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SockJsException(\"Unhandled exception from WebSocketHandler\", getId(), ex);\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Handle all HTTP requests part of the same SockJS session except for the very\n\t * first, initial request. Write a prelude (if needed) and keep the request\n\t * open and ready to send a message from the server to the client.\n\t * <p>\n\t * The \"xhr\" and \"jsonp\" (polling-based) transports completes the request when\n\t * the next message is sent, which could be an array of messages cached during\n\t * the time between successive requests, or it could be a heartbeat message\n\t * sent if no other messages were sent (by default within 25 seconds).\n\t * <p>\n\t * The \"xhr_streaming\", \"eventsource\", and \"htmlfile\" transports are streaming\n\t * based and will leave the request open longer in order to stream messages over\n\t * a period of time. However, even streaming based transports eventually recycle\n\t * the long running request, after a certain number of bytes have been streamed\n\t * (128K by default), and allow the client to start a successive request within\n\t * the same SockJS session.\n\t *\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t *\n\t * @see #handleInitialRequest(org.springframework.http.server.ServerHttpRequest, org.springframework.http.server.ServerHttpResponse, org.springframework.web.socket.sockjs.frame.SockJsFrameFormat)\n\t */\n\tpublic synchronized void handleSuccessiveRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, SockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tinitRequest(request, response, frameFormat);\n\t\ttry {\n\t\t\twritePrelude();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to send \\\"open\\\" frame\", getId(), ex);\n\t\t}\n\t\tstartAsyncRequest();\n\t}","id":43724,"modified_method":"/**\n\t * Handle all HTTP requests part of the same SockJS session except for the very\n\t * first, initial request. Write a prelude (if needed) and keep the request\n\t * open and ready to send a message from the server to the client.\n\t * <p>\n\t * The \"xhr\" and \"jsonp\" (polling-based) transports completes the request when\n\t * the next message is sent, which could be an array of messages cached during\n\t * the time between successive requests, or it could be a heartbeat message\n\t * sent if no other messages were sent (by default within 25 seconds).\n\t * <p>\n\t * The \"xhr_streaming\", \"eventsource\", and \"htmlfile\" transports are streaming\n\t * based and will leave the request open longer in order to stream messages over\n\t * a period of time. However, even streaming based transports eventually recycle\n\t * the long running request, after a certain number of bytes have been streamed\n\t * (128K by default), and allow the client to start a successive request within\n\t * the same SockJS session.\n\t *\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t *\n\t * @see #handleInitialRequest(org.springframework.http.server.ServerHttpRequest, org.springframework.http.server.ServerHttpResponse, org.springframework.web.socket.sockjs.frame.SockJsFrameFormat)\n\t */\n\tpublic void handleSuccessiveRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, SockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tinitRequest(request, response, frameFormat);\n\t\ttry {\n\t\t\twritePrelude(request, response);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to send \\\"open\\\" frame\", getId(), ex);\n\t\t}\n\t\tstartAsyncRequest();\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected BlockingQueue<String> getMessageCache() {\n\t\treturn this.messageCache;\n\t}","id":43725,"modified_method":"protected Queue<String> getMessageCache() {\n\t\treturn this.messageCache;\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void startAsyncRequest() throws SockJsException {\n\t\ttry {\n\t\t\tthis.asyncRequestControl.start(-1);\n\t\t\tscheduleHeartbeat();\n\t\t\ttryFlushCache();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to flush messages\", getId(), ex);\n\t\t}\n\t}","id":43726,"modified_method":"protected void startAsyncRequest() throws SockJsException {\n\t\ttry {\n\t\t\tthis.asyncRequestControl.start(-1);\n\t\t\tthis.requestInitialized = true;\n\t\t\tscheduleHeartbeat();\n\t\t\ttryFlushCache();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to flush messages\", getId(), ex);\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void initRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) {\n\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.notNull(frameFormat, \"SockJsFrameFormat must not be null\");\n\n\t\tthis.request = request;\n\t\tthis.response = response;\n\t\tthis.asyncRequestControl = request.getAsyncRequestControl(response);\n\t\tthis.frameFormat = frameFormat;\n\t}","id":43727,"modified_method":"private void initRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) {\n\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.notNull(frameFormat, \"SockJsFrameFormat must not be null\");\n\n\t\tthis.response = response;\n\t\tthis.frameFormat = frameFormat;\n\t\tthis.asyncRequestControl = request.getAsyncRequestControl(response);\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public synchronized void sendHeartbeat() throws SockJsTransportFailureException {\n\t\tif (isActive()) {\n\t\t\twriteFrame(SockJsFrame.heartbeatFrame());\n\t\t\tscheduleHeartbeat();\n\t\t}\n\t}","id":43728,"modified_method":"public void sendHeartbeat() throws SockJsTransportFailureException {\n\t\tif (isActive()) {\n\t\t\twriteFrame(SockJsFrame.heartbeatFrame());\n\t\t\tscheduleHeartbeat();\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public final synchronized void sendMessage(WebSocketMessage<?> message) throws IOException {\n\t\tAssert.isTrue(!isClosed(), \"Cannot send a message when session is closed\");\n\t\tAssert.isInstanceOf(TextMessage.class, message, \"Expected text message: \" + message);\n\t\tsendMessageInternal(((TextMessage) message).getPayload());\n\t}","id":43729,"modified_method":"public final void sendMessage(WebSocketMessage<?> message) throws IOException {\n\t\tAssert.isTrue(!isClosed(), \"Cannot send a message when session is closed\");\n\t\tAssert.isInstanceOf(TextMessage.class, message, \"Expected text message: \" + message);\n\t\tsendMessageInternal(((TextMessage) message).getPayload());\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void cancelHeartbeat() {\n\t\tif ((this.heartbeatTask != null) && !this.heartbeatTask.isDone()) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Cancelling heartbeat\");\n\t\t\t}\n\t\t\tthis.heartbeatTask.cancel(false);\n\t\t}\n\t\tthis.heartbeatTask = null;\n\t}","id":43730,"modified_method":"protected void cancelHeartbeat() {\n\n\t\tScheduledFuture<?> task = this.heartbeatTask;\n\t\tthis.heartbeatTask = null;\n\n\t\tif ((task != null) && !task.isDone()) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Cancelling heartbeat\");\n\t\t\t}\n\t\t\ttask.cancel(false);\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleSuccessiveRequest() throws Exception {\n\n\t\tthis.session.getMessageCache().add(\"x\");\n\t\tthis.session.handleSuccessiveRequest(this.request, this.response, this.frameFormat);\n\n\t\tassertTrue(this.session.hasRequest());\n\t\tassertTrue(this.session.hasResponse());\n\t\tassertTrue(this.servletRequest.isAsyncStarted());\n\n\t\tassertTrue(this.session.wasHeartbeatScheduled());\n\t\tassertTrue(this.session.wasCacheFlushed());\n\n\t\tassertEquals(\"hhh\\n\", this.servletResponse.getContentAsString());\n\n\t\tverifyNoMoreInteractions(this.webSocketHandler);\n\t}","id":43731,"modified_method":"@Test\n\tpublic void handleSuccessiveRequest() throws Exception {\n\n\t\tthis.session.getMessageCache().add(\"x\");\n\t\tthis.session.handleSuccessiveRequest(this.request, this.response, this.frameFormat);\n\n\t\tassertTrue(this.servletRequest.isAsyncStarted());\n\n\t\tassertTrue(this.session.wasHeartbeatScheduled());\n\t\tassertTrue(this.session.wasCacheFlushed());\n\n\t\tassertEquals(\"hhh\\n\", this.servletResponse.getContentAsString());\n\n\t\tverifyNoMoreInteractions(this.webSocketHandler);\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleInitialRequest() throws Exception {\n\n\t\tthis.session.handleInitialRequest(this.request, this.response, this.frameFormat);\n\n\t\tassertTrue(this.session.hasRequest());\n\t\tassertTrue(this.session.hasResponse());\n\n\t\tassertEquals(\"hhh\\no\", this.servletResponse.getContentAsString());\n\t\tassertFalse(this.servletRequest.isAsyncStarted());\n\n\t\tverify(this.webSocketHandler).afterConnectionEstablished(this.session);\n\t}","id":43732,"modified_method":"@Test\n\tpublic void handleInitialRequest() throws Exception {\n\n\t\tthis.session.handleInitialRequest(this.request, this.response, this.frameFormat);\n\n\t\tassertEquals(\"hhh\\no\", this.servletResponse.getContentAsString());\n\t\tassertFalse(this.servletRequest.isAsyncStarted());\n\n\t\tverify(this.webSocketHandler).afterConnectionEstablished(this.session);\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected void flushCache() throws SockJsTransportFailureException {\n\t\tcancelHeartbeat();\n\t\tBlockingQueue<String> messageCache = getMessageCache();\n\t\tString[] messages = messageCache.toArray(new String[messageCache.size()]);\n\t\tmessageCache.clear();\n\n\t\tSockJsMessageCodec messageCodec = getSockJsServiceConfig().getMessageCodec();\n\t\tSockJsFrame frame = SockJsFrame.messageFrame(messageCodec, messages);\n\t\twriteFrame(frame);\n\t}","id":43733,"modified_method":"@Override\n\tprotected void flushCache() throws SockJsTransportFailureException {\n\t\tcancelHeartbeat();\n\t\tQueue<String> messageCache = getMessageCache();\n\t\tString[] messages = messageCache.toArray(new String[messageCache.size()]);\n\t\tmessageCache.clear();\n\n\t\tSockJsMessageCodec messageCodec = getSockJsServiceConfig().getMessageCodec();\n\t\tSockJsFrame frame = SockJsFrame.messageFrame(messageCodec, messages);\n\t\twriteFrame(frame);\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected synchronized void writeFrameInternal(SockJsFrame frame) throws IOException {\n\t\tif (isActive()) {\n\t\t\tsuper.writeFrameInternal(frame);\n\t\t\tgetResponse().flush();\n\t\t}\n\t}","id":43734,"modified_method":"@Override\n\tprotected void writeFrameInternal(SockJsFrame frame) throws IOException {\n\t\tif (isActive()) {\n\t\t\tsuper.writeFrameInternal(frame);\n\t\t\tgetResponse().flush();\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected synchronized void resetRequest() {\n\t\tsuper.resetRequest();\n\t\tthis.byteCount = 0;\n\t}","id":43735,"modified_method":"@Override\n\tprotected void resetRequest() {\n\t\tsuper.resetRequest();\n\t\tthis.byteCount = 0;\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic synchronized void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tsuper.handleInitialRequest(request, response, frameFormat);\n\n\t\t// the WebSocketHandler delegate may have closed the session\n\t\tif (!isClosed()) {\n\t\t\tsuper.startAsyncRequest();\n\t\t}\n\t}","id":43736,"modified_method":"@Override\n\tpublic void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tsuper.handleInitialRequest(request, response, frameFormat);\n\n\t\t// the WebSocketHandler delegate may have closed the session\n\t\tif (!isClosed()) {\n\t\t\tsuper.startAsyncRequest();\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void scheduleSessionTask() {\n\t\tthis.sessionCleanupTask = getTaskScheduler().scheduleAtFixedRate(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tint count = sessions.size();\n\t\t\t\t\tif (logger.isTraceEnabled() && (count != 0)) {\n\t\t\t\t\t\tlogger.trace(\"Checking \" + count + \" session(s) for timeouts [\" + getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tfor (SockJsSession session : sessions.values()) {\n\t\t\t\t\t\tif (session.getTimeSinceLastActive() > getDisconnectDelay()) {\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Removing \" + session + \" for [\" + getName() + \"]\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\tsessions.remove(session.getId());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled() && count > 0) {\n\t\t\t\t\t\tlogger.trace(sessions.size() + \" remaining session(s) [\" + getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\tlogger.error(\"Failed to complete session timeout checks for [\" + getName() + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, getDisconnectDelay());\n\t}","id":43737,"modified_method":"private void scheduleSessionTask() {\n\n\t\tsynchronized (this.sessions) {\n\t\t\tif (this.sessionCleanupTask != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.sessionCleanupTask = getTaskScheduler().scheduleAtFixedRate(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint count = sessions.size();\n\t\t\t\t\t\tif (logger.isTraceEnabled() && (count != 0)) {\n\t\t\t\t\t\t\tlogger.trace(\"Checking \" + count + \" session(s) for timeouts [\" + getName() + \"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (SockJsSession session : sessions.values()) {\n\t\t\t\t\t\t\tif (session.getTimeSinceLastActive() > getDisconnectDelay()) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Removing \" + session + \" for [\" + getName() + \"]\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t\tsessions.remove(session.getId());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled() && count > 0) {\n\t\t\t\t\t\t\tlogger.trace(sessions.size() + \" remaining session(s) [\" + getName() + \"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\t\tlogger.error(\"Failed to complete session timeout checks for [\" + getName() + \"]\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, getDisconnectDelay());\n\t\t}\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private SockJsSession createSockJsSession(String sessionId, SockJsSessionFactory sessionFactory,\n\t\t\tWebSocketHandler handler, Map<String, Object> attributes) {\n\n\t\tsynchronized (this.sessions) {\n\t\t\tSockJsSession session = this.sessions.get(sessionId);\n\t\t\tif (session != null) {\n\t\t\t\treturn session;\n\t\t\t}\n\t\t\tif (this.sessionCleanupTask == null) {\n\t\t\t\tscheduleSessionTask();\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Creating new session with session id \\\"\" + sessionId + \"\\\"\");\n\t\t\t}\n\t\t\tsession = sessionFactory.createSession(sessionId, handler, attributes);\n\t\t\tthis.sessions.put(sessionId, session);\n\t\t\treturn session;\n\t\t}\n\t}","id":43738,"modified_method":"private SockJsSession createSockJsSession(String sessionId, SockJsSessionFactory sessionFactory,\n\t\t\tWebSocketHandler handler, Map<String, Object> attributes) {\n\n\t\tSockJsSession session = this.sessions.get(sessionId);\n\t\tif (session != null) {\n\t\t\treturn session;\n\t\t}\n\n\t\tif (this.sessionCleanupTask == null) {\n\t\t\tscheduleSessionTask();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Creating new session with session id \\\"\" + sessionId + \"\\\"\");\n\t\t}\n\t\tsession = sessionFactory.createSession(sessionId, handler, attributes);\n\t\tthis.sessions.put(sessionId, session);\n\n\t\treturn session;\n\t}","commit_id":"4028a3b0bce0f2dd40cdbcf3314304974993eea3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Persist the job in the resource tree\n     * @param jobTopic The required job topic\n     * @param jobName The optional job name\n     * @param jobProperties The optional job properties\n     * @return The persisted job or <code>null<\/code>.\n     */\n    private Job addJobInteral(final String jobTopic,\n            final String jobName,\n            final Map<String, Object> jobProperties,\n            final List<String> errors) {\n        final QueueInfo info = this.queueConfigManager.getQueueInfo(jobTopic);\n        if ( info.queueConfiguration.getType() == QueueConfiguration.Type.DROP ) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Dropping job due to configuration of queue {} : {}\", info.queueName, Utility.toString(jobTopic, jobName, jobProperties));\n            }\n            Utility.sendNotification(this.eventAdmin, NotificationConstants.TOPIC_JOB_CANCELLED, jobTopic, jobName, jobProperties, null);\n        } else {\n            // check for unique jobs\n            if ( jobName != null && !this.lock(jobName) ) {\n                logger.debug(\"Discarding duplicate job {}\", Utility.toString(jobTopic, jobName, jobProperties));\n                return null;\n            } else {\n                if ( info.queueConfiguration.getType() != QueueConfiguration.Type.IGNORE ) {\n                    final TopologyCapabilities caps = this.topologyCapabilities;\n                    info.targetId = (caps == null ? null : caps.detectTarget(jobTopic, jobProperties, info));\n                }\n                if ( logger.isDebugEnabled() ) {\n                    if ( info.targetId != null ) {\n                        logger.debug(\"Persisting job {} into queue {}, target={}\", new Object[] {Utility.toString(jobTopic, jobName, jobProperties), info.queueName, info.targetId});\n                    } else {\n                        logger.debug(\"Persisting job {} into queue {}\", Utility.toString(jobTopic, jobName, jobProperties), info.queueName);\n                    }\n                }\n                ResourceResolver resolver = null;\n                try {\n                    resolver = this.resourceResolverFactory.getAdministrativeResourceResolver(null);\n\n                    final JobImpl job = this.writeJob(resolver,\n                            jobTopic,\n                            jobName,\n                            jobProperties,\n                            info);\n                    if ( job != null ) {\n                        if ( configuration.isLocalJob(job.getResourcePath()) ) {\n                            this.backgroundLoader.addJob(job);\n                        }\n                        return job;\n                    }\n                } catch (final PersistenceException re ) {\n                    // something went wrong, so let's log it\n                    this.logger.error(\"Exception during persisting new job '\" + Utility.toString(jobTopic, jobName, jobProperties) + \"'\", re);\n                } catch (final LoginException le) {\n                    // there is nothing we can do except log!\n                    this.logger.error(\"Exception during persisting new job '\" + Utility.toString(jobTopic, jobName, jobProperties) + \"'\", le);\n                } finally {\n                    if ( resolver != null ) {\n                        resolver.close();\n                    }\n                }\n                if ( errors != null ) {\n                    errors.add(\"Unable to persist new job.\");\n                }\n            }\n        }\n        return null;\n    }","id":43739,"modified_method":"/**\n     * Persist the job in the resource tree\n     * @param jobTopic The required job topic\n     * @param jobName The optional job name\n     * @param jobProperties The optional job properties\n     * @return The persisted job or <code>null<\/code>.\n     */\n    private Job addJobInteral(final String jobTopic,\n            final String jobName,\n            final Map<String, Object> jobProperties,\n            final List<String> errors) {\n        final QueueInfo info = this.queueConfigManager.getQueueInfo(jobTopic);\n        if ( info.queueConfiguration.getType() == QueueConfiguration.Type.DROP ) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Dropping job due to configuration of queue {} : {}\", info.queueName, Utility.toString(jobTopic, jobName, jobProperties));\n            }\n            Utility.sendNotification(this.eventAdmin, NotificationConstants.TOPIC_JOB_CANCELLED, jobTopic, jobName, jobProperties, null);\n        } else {\n            // check for unique jobs\n            if ( jobName != null && !this.lock(jobTopic, jobName) ) {\n                logger.debug(\"Discarding duplicate job {}\", Utility.toString(jobTopic, jobName, jobProperties));\n                return null;\n            } else {\n                if ( info.queueConfiguration.getType() != QueueConfiguration.Type.IGNORE ) {\n                    final TopologyCapabilities caps = this.topologyCapabilities;\n                    info.targetId = (caps == null ? null : caps.detectTarget(jobTopic, jobProperties, info));\n                }\n                if ( logger.isDebugEnabled() ) {\n                    if ( info.targetId != null ) {\n                        logger.debug(\"Persisting job {} into queue {}, target={}\", new Object[] {Utility.toString(jobTopic, jobName, jobProperties), info.queueName, info.targetId});\n                    } else {\n                        logger.debug(\"Persisting job {} into queue {}\", Utility.toString(jobTopic, jobName, jobProperties), info.queueName);\n                    }\n                }\n                ResourceResolver resolver = null;\n                try {\n                    resolver = this.resourceResolverFactory.getAdministrativeResourceResolver(null);\n\n                    final JobImpl job = this.writeJob(resolver,\n                            jobTopic,\n                            jobName,\n                            jobProperties,\n                            info);\n                    if ( job != null ) {\n                        if ( configuration.isLocalJob(job.getResourcePath()) ) {\n                            this.backgroundLoader.addJob(job);\n                        }\n                        return job;\n                    }\n                } catch (final PersistenceException re ) {\n                    // something went wrong, so let's log it\n                    this.logger.error(\"Exception during persisting new job '\" + Utility.toString(jobTopic, jobName, jobProperties) + \"'\", re);\n                } catch (final LoginException le) {\n                    // there is nothing we can do except log!\n                    this.logger.error(\"Exception during persisting new job '\" + Utility.toString(jobTopic, jobName, jobProperties) + \"'\", le);\n                } finally {\n                    if ( resolver != null ) {\n                        resolver.close();\n                    }\n                }\n                if ( errors != null ) {\n                    errors.add(\"Unable to persist new job.\");\n                }\n            }\n        }\n        return null;\n    }","commit_id":"3a3e5ba6a952e5ac634011d5041b2b86b2ea9f02","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Try to get a \"lock\" for a resource\n     */\n    private boolean lock(final String id) {\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"Trying to get lock for {}\", id);\n        }\n        boolean hasLock = false;\n        ResourceResolver resolver = null;\n        try {\n            resolver = this.resourceResolverFactory.getAdministrativeResourceResolver(null);\n            final String lockName = ResourceHelper.filterName(id);\n            final StringBuilder sb = new StringBuilder(this.configuration.getLocksPath());\n            sb.append('/');\n            sb.append(lockName);\n            final String path = sb.toString();\n\n            Resource lockResource = resolver.getResource(path);\n            if ( lockResource == null ) {\n                resolver.refresh();\n                try {\n                    final Map<String, Object> props = new HashMap<String, Object>();\n                    props.put(Utility.PROPERTY_LOCK_CREATED, Calendar.getInstance());\n                    props.put(Utility.PROPERTY_LOCK_CREATED_APP, Environment.APPLICATION_ID);\n                    props.put(ResourceResolver.PROPERTY_RESOURCE_TYPE, Utility.RESOURCE_TYPE_LOCK);\n\n                    lockResource = ResourceHelper.getOrCreateResource(resolver,\n                            path,\n                            props);\n\n                    // check if lock resource has correct name (SNS)\n                    if ( !lockResource.getName().equals(lockName) ) {\n                        if ( logger.isDebugEnabled() ) {\n                            logger.debug(\"Created SNS lock resource on instance {} - discarding\", Environment.APPLICATION_ID);\n                        }\n                        resolver.delete(lockResource);\n                        resolver.commit();\n                    } else {\n                        final ValueMap vm = lockResource.adaptTo(ValueMap.class);\n                        if ( logger.isDebugEnabled() ) {\n                            logger.debug(\"Got lock resource on instance {} with {}\", Environment.APPLICATION_ID, vm.get(Utility.PROPERTY_LOCK_CREATED_APP));\n                        }\n                        if ( vm.get(Utility.PROPERTY_LOCK_CREATED_APP).equals(Environment.APPLICATION_ID) ) {\n                            hasLock = true;\n                        }\n                    }\n                } catch (final PersistenceException ignore) {\n                    // ignore\n                    this.ignoreException(ignore);\n                }\n            }\n        } catch (final LoginException ignore) {\n            this.ignoreException(ignore);\n        } finally {\n            if ( resolver != null ) {\n                resolver.close();\n            }\n        }\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"Lock for {} = {}\", id, hasLock);\n        }\n        return hasLock;\n    }","id":43740,"modified_method":"/**\n     * Try to get a \"lock\" for a resource\n     */\n    private boolean lock(final String jobTopic, final String id) {\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"Trying to get lock for {}\", id);\n        }\n        boolean hasLock = false;\n        ResourceResolver resolver = null;\n        try {\n            resolver = this.resourceResolverFactory.getAdministrativeResourceResolver(null);\n            final String lockName = ResourceHelper.filterName(id);\n            final StringBuilder sb = new StringBuilder(this.configuration.getLocksPath());\n            sb.append('/');\n            sb.append(jobTopic.replace('/', '.'));\n            sb.append('/');\n            sb.append(lockName);\n            final String path = sb.toString();\n\n            Resource lockResource = resolver.getResource(path);\n            if ( lockResource == null ) {\n                resolver.refresh();\n                try {\n                    final Map<String, Object> props = new HashMap<String, Object>();\n                    props.put(Utility.PROPERTY_LOCK_CREATED, Calendar.getInstance());\n                    props.put(Utility.PROPERTY_LOCK_CREATED_APP, Environment.APPLICATION_ID);\n                    props.put(ResourceResolver.PROPERTY_RESOURCE_TYPE, Utility.RESOURCE_TYPE_LOCK);\n\n                    lockResource = ResourceHelper.getOrCreateResource(resolver,\n                            path,\n                            props);\n\n                    // check if lock resource has correct name (SNS)\n                    if ( !lockResource.getName().equals(lockName) ) {\n                        if ( logger.isDebugEnabled() ) {\n                            logger.debug(\"Created SNS lock resource on instance {} - discarding\", Environment.APPLICATION_ID);\n                        }\n                        resolver.delete(lockResource);\n                        resolver.commit();\n                    } else {\n                        final ValueMap vm = lockResource.adaptTo(ValueMap.class);\n                        if ( logger.isDebugEnabled() ) {\n                            logger.debug(\"Got lock resource on instance {} with {}\", Environment.APPLICATION_ID, vm.get(Utility.PROPERTY_LOCK_CREATED_APP));\n                        }\n                        if ( vm.get(Utility.PROPERTY_LOCK_CREATED_APP).equals(Environment.APPLICATION_ID) ) {\n                            hasLock = true;\n                        }\n                    }\n                } catch (final PersistenceException ignore) {\n                    // ignore\n                    this.ignoreException(ignore);\n                }\n            }\n        } catch (final LoginException ignore) {\n            this.ignoreException(ignore);\n        } finally {\n            if ( resolver != null ) {\n                resolver.close();\n            }\n        }\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"Lock for {} = {}\", id, hasLock);\n        }\n        return hasLock;\n    }","commit_id":"3a3e5ba6a952e5ac634011d5041b2b86b2ea9f02","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Clean up the locks\n     * All locks older than three minutes are removed\n     */\n    private void lockCleanup(final TopologyCapabilities caps) {\n        if ( caps != null && caps.isLeader() ) {\n            this.logger.debug(\"Cleaning up job resource tree: removing obsolete locks\");\n            ResourceResolver resolver = null;\n            try {\n                resolver = this.resourceResolverFactory.getAdministrativeResourceResolver(null);\n                final Calendar startDate = Calendar.getInstance();\n                startDate.add(Calendar.MINUTE, -3);\n\n                final StringBuilder buf = new StringBuilder(64);\n\n                buf.append(\"//element(*)[@\");\n                buf.append(ISO9075.encode(ResourceResolver.PROPERTY_RESOURCE_TYPE));\n                buf.append(\" = '\");\n                buf.append(Utility.RESOURCE_TYPE_LOCK);\n                buf.append(\"' and @\");\n                buf.append(ISO9075.encode(Utility.PROPERTY_LOCK_CREATED));\n                buf.append(\" < xs:dateTime('\");\n                buf.append(ISO8601.format(startDate));\n                buf.append(\"')]\");\n                final Iterator<Resource> result = resolver.findResources(buf.toString(), \"xpath\");\n\n                while ( caps.isActive() && result.hasNext() ) {\n                    final Resource lockResource = result.next();\n                    // sanity check for the path\n                    if ( this.configuration.isLock(lockResource.getPath()) ) {\n                        try {\n                            resolver.delete(lockResource);\n                            resolver.commit();\n                        } catch ( final PersistenceException pe) {\n                            this.ignoreException(pe);\n                            resolver.refresh();\n                        }\n                    }\n                }\n            } catch (final QuerySyntaxException qse) {\n                this.ignoreException(qse);\n            } catch (final LoginException le) {\n                this.ignoreException(le);\n            } finally {\n                if ( resolver != null ) {\n                    resolver.close();\n                }\n            }\n        }\n    }","id":43741,"modified_method":"/**\n     * Clean up the locks\n     * All locks older than two minutes are removed\n     */\n    private void lockCleanup(final TopologyCapabilities caps) {\n        if ( caps != null && caps.isLeader() ) {\n            this.logger.debug(\"Cleaning up job resource tree: removing obsolete locks\");\n            final List<Resource> candidates = new ArrayList<Resource>();\n            ResourceResolver resolver = null;\n            try {\n                resolver = this.resourceResolverFactory.getAdministrativeResourceResolver(null);\n                final Resource parentResource = resolver.getResource(this.configuration.getLocksPath());\n                final Calendar startDate = Calendar.getInstance();\n                startDate.add(Calendar.MINUTE, -2);\n\n                this.lockCleanup(caps, candidates, parentResource, startDate);\n                final BatchResourceRemover remover = new BatchResourceRemover();\n                boolean batchRemove = true;\n                for(final Resource lockResource : candidates) {\n                    if ( caps.isActive() ) {\n                        try {\n                            if ( batchRemove ) {\n                                remover.delete(lockResource);\n                            } else {\n                                resolver.delete(lockResource);\n                                resolver.commit();\n                            }\n                        } catch ( final PersistenceException pe) {\n                            batchRemove = false;\n                            this.ignoreException(pe);\n                            resolver.refresh();\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                try {\n                    resolver.commit();\n                } catch ( final PersistenceException pe) {\n                    this.ignoreException(pe);\n                    resolver.refresh();\n                }\n\n/* Old implementation using a query\n                final StringBuilder buf = new StringBuilder(64);\n\n                buf.append(\"//element(*)[@\");\n                buf.append(ISO9075.encode(ResourceResolver.PROPERTY_RESOURCE_TYPE));\n                buf.append(\" = '\");\n                buf.append(Utility.RESOURCE_TYPE_LOCK);\n                buf.append(\"' and @\");\n                buf.append(ISO9075.encode(Utility.PROPERTY_LOCK_CREATED));\n                buf.append(\" < xs:dateTime('\");\n                buf.append(ISO8601.format(startDate));\n                buf.append(\"')]\");\n                final Iterator<Resource> result = resolver.findResources(buf.toString(), \"xpath\");\n\n                while ( caps.isActive() && result.hasNext() ) {\n                    final Resource lockResource = result.next();\n                    // sanity check for the path\n                    if ( this.configuration.isLock(lockResource.getPath()) ) {\n                        try {\n                            resolver.delete(lockResource);\n                            resolver.commit();\n                        } catch ( final PersistenceException pe) {\n                            this.ignoreException(pe);\n                            resolver.refresh();\n                        }\n                    }\n                }\n            } catch (final QuerySyntaxException qse) {\n                this.ignoreException(qse);\n*/\n            } catch (final LoginException le) {\n                this.ignoreException(le);\n            } finally {\n                if ( resolver != null ) {\n                    resolver.close();\n                }\n            }\n        }\n    }","commit_id":"3a3e5ba6a952e5ac634011d5041b2b86b2ea9f02","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * One maintenance run\n     */\n    public void run(final TopologyCapabilities topologyCapabilities,\n            final QueueConfigurationManager queueManager,\n            final long cleanUpCounter) {\n        // check topology and config change during each invocation\n        final boolean topologyChanged = this.topologyHasChanged(topologyCapabilities);\n        final boolean configChanged = this.queueConfigurationHasChanged(topologyCapabilities, queueManager);\n\n        // if topology changed, reschedule assigned jobs for stopped instances\n        if ( topologyChanged ) {\n            this.reassignJobs(topologyCapabilities, queueManager);\n        }\n        // try to assign unassigned jobs\n        if ( topologyChanged || configChanged ) {\n            this.assignUnassignedJobs(topologyCapabilities, queueManager);\n        }\n\n        if ( topologyChanged && !this.checkedForPreviousVersion && topologyCapabilities != null && topologyCapabilities.isLeader() ) {\n            this.processJobsFromPreviousVersions(topologyCapabilities, queueManager);\n        }\n\n        if ( topologyCapabilities != null ) {\n            // Clean up\n            final String cleanUpAssignedPath;;\n            if ( topologyCapabilities.isLeader() ) {\n                cleanUpAssignedPath = this.configuration.getUnassignedJobsPath();\n            } else {\n                cleanUpAssignedPath = null;\n            }\n\n            if ( cleanUpCounter % 60 == 0 ) { // full clean up is done every hour\n                this.fullEmptyFolderCleanup(topologyCapabilities, this.configuration.getLocalJobsPath());\n                if ( cleanUpAssignedPath != null ) {\n                    this.fullEmptyFolderCleanup(topologyCapabilities, cleanUpAssignedPath);\n                }\n            } else if ( cleanUpCounter % 5 == 0 ) { // simple clean up every 5 minutes\n                this.simpleEmptyFolderCleanup(topologyCapabilities, this.configuration.getLocalJobsPath());\n                if ( cleanUpAssignedPath != null ) {\n                    this.simpleEmptyFolderCleanup(topologyCapabilities, cleanUpAssignedPath);\n                }\n            }\n        }\n\n        // lock cleanup is done every 3 minutes\n        if ( cleanUpCounter % 3 == 0 ) {\n            this.lockCleanup(topologyCapabilities);\n        }\n    }","id":43742,"modified_method":"/**\n     * One maintenance run\n     */\n    public void run(final TopologyCapabilities topologyCapabilities,\n            final QueueConfigurationManager queueManager,\n            final long cleanUpCounter) {\n        // check topology and config change during each invocation\n        final boolean topologyChanged = this.topologyHasChanged(topologyCapabilities);\n        final boolean configChanged = this.queueConfigurationHasChanged(topologyCapabilities, queueManager);\n\n        // if topology changed, reschedule assigned jobs for stopped instances\n        if ( topologyChanged ) {\n            this.reassignJobs(topologyCapabilities, queueManager);\n        }\n        // try to assign unassigned jobs\n        if ( topologyChanged || configChanged ) {\n            this.assignUnassignedJobs(topologyCapabilities, queueManager);\n        }\n\n        if ( topologyChanged && !this.checkedForPreviousVersion && topologyCapabilities != null && topologyCapabilities.isLeader() ) {\n            this.processJobsFromPreviousVersions(topologyCapabilities, queueManager);\n        }\n\n        if ( topologyCapabilities != null ) {\n            // Clean up\n            final String cleanUpAssignedPath;;\n            if ( topologyCapabilities.isLeader() ) {\n                cleanUpAssignedPath = this.configuration.getUnassignedJobsPath();\n            } else {\n                cleanUpAssignedPath = null;\n            }\n\n            if ( cleanUpCounter % 60 == 0 ) { // full clean up is done every hour\n                this.fullEmptyFolderCleanup(topologyCapabilities, this.configuration.getLocalJobsPath());\n                if ( cleanUpAssignedPath != null ) {\n                    this.fullEmptyFolderCleanup(topologyCapabilities, cleanUpAssignedPath);\n                }\n            } else if ( cleanUpCounter % 5 == 0 ) { // simple clean up every 5 minutes\n                this.simpleEmptyFolderCleanup(topologyCapabilities, this.configuration.getLocalJobsPath());\n                if ( cleanUpAssignedPath != null ) {\n                    this.simpleEmptyFolderCleanup(topologyCapabilities, cleanUpAssignedPath);\n                }\n            }\n        }\n\n        // lock cleanup is done every minute\n        this.lockCleanup(topologyCapabilities);\n    }","commit_id":"3a3e5ba6a952e5ac634011d5041b2b86b2ea9f02","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public T traverse( final ActiveRegionWalker<M,T> walker,\n                       final LocusShardDataProvider dataProvider,\n                       T sum) {\n        logger.debug(String.format(\"TraverseActiveRegion.traverse: Shard is %s\", dataProvider));\n\n        final LocusView locusView = getLocusView( walker, dataProvider );\n        final GenomeLocSortedSet initialIntervals = engine.getIntervals(); // BUGBUG: unfortunate inefficiency that needs to be removed\n\n        final LocusReferenceView referenceView = new LocusReferenceView( walker, dataProvider );\n        final int activeRegionExtension = walker.getClass().getAnnotation(ActiveRegionExtension.class).extension();\n\n        if ( locusView.hasNext() ) { // trivial optimization to avoid unnecessary processing when there's nothing here at all\n\n            int minStart = Integer.MAX_VALUE;\n            final ArrayList<ActiveRegion> isActiveList = new ArrayList<ActiveRegion>();\n\n            //ReferenceOrderedView referenceOrderedDataView = new ReferenceOrderedView( dataProvider );\n            ReferenceOrderedView referenceOrderedDataView = null;\n            if ( WalkerManager.getWalkerDataSource(walker) != DataSource.REFERENCE_ORDERED_DATA )\n                referenceOrderedDataView = new ManagingReferenceOrderedView( dataProvider );\n            else\n                referenceOrderedDataView = (RodLocusView)locusView;\n\n            // We keep processing while the next reference location is within the interval\n            while( locusView.hasNext() ) {\n                final AlignmentContext locus = locusView.next();\n                GenomeLoc location = locus.getLocation();\n\n                dataProvider.getShard().getReadMetrics().incrementNumIterations();\n\n                if ( locus.hasExtendedEventPileup() ) {\n                    // if the alignment context we received holds an \"extended\" pileup (i.e. pileup of insertions/deletions\n                    // associated with the current site), we need to update the location. The updated location still starts\n                    // at the current genomic position, but it has to span the length of the longest deletion (if any).\n                    location = engine.getGenomeLocParser().setStop(location,location.getStop()+locus.getExtendedEventPileup().getMaxDeletionLength());\n\n                    // it is possible that the new expanded location spans the current shard boundary; the next method ensures\n                    // that when it is the case, the reference sequence held by the ReferenceView will be reloaded so that\n                    // the view has all the bases we are gonna need. If the location fits within the current view bounds,\n                    // the next call will not do anything to the view:\n                    referenceView.expandBoundsToAccomodateLoc(location);\n                }\n\n                // create reference context. Note that if we have a pileup of \"extended events\", the context will\n                // hold the (longest) stretch of deleted reference bases (if deletions are present in the pileup).\n                final ReferenceContext refContext = referenceView.getReferenceContext(location);\n\n                // Iterate forward to get all reference ordered data covering this location\n                final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation(), refContext);\n\n                // Call the walkers isActive function for this locus and add them to the list to be integrated later\n                if( initialIntervals.overlaps(location) ) {\n                    final boolean isActive = walker.isActive( tracker, refContext, locus );\n                    isActiveList.add( new ActiveRegion(location, isActive, engine.getGenomeLocParser(), activeRegionExtension ) );\n                }\n                \n                // Grab all the previously unseen reads from this pileup and add them to the massive read list\n                for( final PileupElement p : locus.getBasePileup() ) {\n                    final SAMRecord read = p.getRead();\n                    if( !myReads.contains(read) ) {\n                        myReads.add(read);\n                    }\n                }\n\n                // If this is the last pileup for this shard then need to first do a special walker.isActive() call\n                // and then calculate the minimum alignment start so that we know which active regions in the work queue are now safe to process\n                if( !locusView.hasNext() ) {\n                    // Call the walkers isActive function for this locus and add them to the list to be integrated later\n                    if( initialIntervals.overlaps(location) ) {\n                        final boolean isActive = walker.isActive( tracker, refContext, locus );\n                        isActiveList.add( new ActiveRegion(location, isActive, engine.getGenomeLocParser(), activeRegionExtension ) );\n                    }\n\n                    for( final PileupElement p : locus.getBasePileup() ) {\n                        final SAMRecord read = p.getRead();\n                        if( !myReads.contains(read) ) {\n                            myReads.add(read);\n                        }\n                        if( read.getAlignmentStart() < minStart ) { minStart = read.getAlignmentStart(); }\n                    }\n                }\n                printProgress(dataProvider.getShard(),locus.getLocation());\n            }\n\n            // Take the individual isActive calls and integrate them into contiguous active regions and\n            // add these blocks of work to the work queue\n            final ArrayList<ActiveRegion> activeRegions = integrateActiveList( isActiveList );\n            logger.debug(\"Integrated \" + isActiveList.size() + \" isActive calls into \" + activeRegions.size() + \" regions.\" );\n            workQueue.addAll( activeRegions );\n\n            // Since we've sufficiently past this point (or this contig!) in the workQueue we can unload those regions and process them\n            if( !workQueue.isEmpty() ) {\n                while( workQueue.peek().getExtendedLoc().getStop() < minStart || !workQueue.peek().getExtendedLoc().getContig().equals(dataProvider.getLocus().getContig()) ) {\n                    final ActiveRegion activeRegion = workQueue.remove();\n                    sum = processActiveRegion( activeRegion, myReads, workQueue, sum, walker );\n                }\n            }\n        }\n\n        return sum;\n    }","id":43743,"modified_method":"@Override\n    public T traverse( final ActiveRegionWalker<M,T> walker,\n                       final LocusShardDataProvider dataProvider,\n                       T sum) {\n        logger.debug(String.format(\"TraverseActiveRegion.traverse: Shard is %s\", dataProvider));\n\n        final LocusView locusView = getLocusView( walker, dataProvider );\n        final GenomeLocSortedSet initialIntervals = engine.getIntervals(); // BUGBUG: unfortunate inefficiency that needs to be removed\n\n        final LocusReferenceView referenceView = new LocusReferenceView( walker, dataProvider );\n        final int activeRegionExtension = walker.getClass().getAnnotation(ActiveRegionExtension.class).extension();\n\n        if ( locusView.hasNext() ) { // trivial optimization to avoid unnecessary processing when there's nothing here at all\n\n            int minStart = Integer.MAX_VALUE;\n            final ArrayList<ActiveRegion> isActiveList = new ArrayList<ActiveRegion>();\n\n            //ReferenceOrderedView referenceOrderedDataView = new ReferenceOrderedView( dataProvider );\n            ReferenceOrderedView referenceOrderedDataView = null;\n            if ( WalkerManager.getWalkerDataSource(walker) != DataSource.REFERENCE_ORDERED_DATA )\n                referenceOrderedDataView = new ManagingReferenceOrderedView( dataProvider );\n            else\n                referenceOrderedDataView = (RodLocusView)locusView;\n\n            // We keep processing while the next reference location is within the interval\n            while( locusView.hasNext() ) {\n                final AlignmentContext locus = locusView.next();\n                GenomeLoc location = locus.getLocation();\n\n                dataProvider.getShard().getReadMetrics().incrementNumIterations();\n\n                if ( locus.hasExtendedEventPileup() ) {\n                    // if the alignment context we received holds an \"extended\" pileup (i.e. pileup of insertions/deletions\n                    // associated with the current site), we need to update the location. The updated location still starts\n                    // at the current genomic position, but it has to span the length of the longest deletion (if any).\n                    location = engine.getGenomeLocParser().setStop(location,location.getStop()+locus.getExtendedEventPileup().getMaxDeletionLength());\n\n                    // it is possible that the new expanded location spans the current shard boundary; the next method ensures\n                    // that when it is the case, the reference sequence held by the ReferenceView will be reloaded so that\n                    // the view has all the bases we are gonna need. If the location fits within the current view bounds,\n                    // the next call will not do anything to the view:\n                    referenceView.expandBoundsToAccomodateLoc(location);\n                }\n\n                // create reference context. Note that if we have a pileup of \"extended events\", the context will\n                // hold the (longest) stretch of deleted reference bases (if deletions are present in the pileup).\n                final ReferenceContext refContext = referenceView.getReferenceContext(location);\n\n                // Iterate forward to get all reference ordered data covering this location\n                final RefMetaDataTracker tracker = referenceOrderedDataView.getReferenceOrderedDataAtLocus(locus.getLocation(), refContext);\n\n                // Call the walkers isActive function for this locus and add them to the list to be integrated later\n                if( initialIntervals.overlaps(location) ) {\n                    final boolean isActive = ( walker.presetActiveRegions == null ? walker.isActive( tracker, refContext, locus ) : walker.presetActiveRegions.overlaps(location) );\n                    isActiveList.add( new ActiveRegion(location, isActive, engine.getGenomeLocParser(), activeRegionExtension ) );\n                }\n                \n                // Grab all the previously unseen reads from this pileup and add them to the massive read list\n                for( final PileupElement p : locus.getBasePileup() ) {\n                    final SAMRecord read = p.getRead();\n                    if( !myReads.contains(read) ) {\n                        myReads.add(read);\n                    }\n                }\n\n                // If this is the last pileup for this shard then need to first do a special walker.isActive() call\n                // and then calculate the minimum alignment start so that we know which active regions in the work queue are now safe to process\n                if( !locusView.hasNext() ) {\n                    // Call the walkers isActive function for this locus and add them to the list to be integrated later\n                    if( initialIntervals.overlaps(location) ) {\n                        final boolean isActive = ( walker.presetActiveRegions == null ? walker.isActive( tracker, refContext, locus ) : walker.presetActiveRegions.overlaps(location) );\n                        isActiveList.add( new ActiveRegion(location, isActive, engine.getGenomeLocParser(), activeRegionExtension ) );\n                    }\n\n                    for( final PileupElement p : locus.getBasePileup() ) {\n                        final SAMRecord read = p.getRead();\n                        if( !myReads.contains(read) ) {\n                            myReads.add(read);\n                        }\n                        if( read.getAlignmentStart() < minStart ) { minStart = read.getAlignmentStart(); }\n                    }\n                }\n                printProgress(dataProvider.getShard(),locus.getLocation());\n            }\n\n            // Take the individual isActive calls and integrate them into contiguous active regions and\n            // add these blocks of work to the work queue\n            final ArrayList<ActiveRegion> activeRegions = integrateActiveList( isActiveList );\n            logger.debug(\"Integrated \" + isActiveList.size() + \" isActive calls into \" + activeRegions.size() + \" regions.\" );\n            workQueue.addAll( activeRegions );\n\n            // Since we've sufficiently past this point (or this contig!) in the workQueue we can unload those regions and process them\n            if( !workQueue.isEmpty() ) {\n                while( workQueue.peek().getExtendedLoc().getStop() < minStart || !workQueue.peek().getExtendedLoc().getContig().equals(dataProvider.getLocus().getContig()) ) {\n                    final ActiveRegion activeRegion = workQueue.remove();\n                    sum = processActiveRegion( activeRegion, myReads, workQueue, sum, walker );\n                }\n            }\n        }\n\n        return sum;\n    }","commit_id":"9818c69df67fe5c930df4b62d895b5b9b15fac07","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, List listeners )\n        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        // TODO: use as a conflict resolver\n        Object key = node.getKey();\n        if ( managedVersions.containsKey( key ) )\n        {\n            Artifact artifact = (Artifact) managedVersions.get( key );\n\n            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );\n\n            if ( artifact.getVersion() != null )\n            {\n                node.getArtifact().setVersion( artifact.getVersion() );\n            }\n            if ( artifact.getScope() != null )\n            {\n                node.getArtifact().setScope( artifact.getScope() );\n            }\n        }\n\n        List previousNodes = (List) resolvedArtifacts.get( key );\n        if ( previousNodes != null )\n        {\n            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )\n            {\n                ResolutionNode previous = (ResolutionNode) i.next();\n\n                if ( previous.isActive() )\n                {\n                    // Version mediation\n                    VersionRange previousRange = previous.getArtifact().getVersionRange();\n                    VersionRange currentRange = node.getArtifact().getVersionRange();\n\n                    // TODO: why do we force the version on it? what if they don't match?\n                    if ( previousRange == null )\n                    {\n                        // version was already resolved\n                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n                    }\n                    else if ( currentRange == null )\n                    {\n                        // version was already resolved\n                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n                    }\n                    else\n                    {\n                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                        // version but the restriction is identical\n                        VersionRange newRange = previousRange.restrict( currentRange );\n                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\n                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )\n                        {\n                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),\n                                       newRange );\n                        }\n                        previous.getArtifact().setVersionRange( newRange );\n                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );\n\n                        //Select an appropriate available version from the (now restricted) range\n                        //Note this version was selected before to get the appropriate POM\n                        //But it was reset by the call to setVersionRange on restricting the version\n                        ResolutionNode[] resetNodes = {previous, node};\n                        for ( int j = 0; j < 2; j++ )\n                        {\n                            Artifact resetArtifact = resetNodes[j].getArtifact();\n                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&\n                                resetArtifact.getAvailableVersions() != null )\n                            {\n\n                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(\n                                    resetArtifact.getAvailableVersions() ).toString() );\n                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );\n                            }\n                        }\n                    }\n\n                    // Conflict Resolution\n                    // TODO: use as conflict resolver(s), chain\n\n                    // TODO: should this be part of mediation?\n                    // previous one is more dominant\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        checkScopeUpdate( node, previous, listeners );\n                    }\n                    else\n                    {\n                        checkScopeUpdate( previous, node, listeners );\n                    }\n\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        // previous was nearer\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );\n                        node.disable();\n                    }\n                    else\n                    {\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact() );\n                        previous.disable();\n                    }\n                }\n            }\n        }\n        else\n        {\n            previousNodes = new ArrayList();\n            resolvedArtifacts.put( key, previousNodes );\n        }\n        previousNodes.add( node );\n\n        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n\n        if ( node.isActive() )\n        {\n            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n            {\n                ResolutionNode child = (ResolutionNode) i.next();\n                // We leave in optional ones, but don't pick up its dependencies\n                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )\n                {\n                    Artifact artifact = child.getArtifact();\n                    try\n                    {\n                        if ( artifact.getVersion() == null )\n                        {\n                            // set the recommended version\n                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?\n                            ArtifactVersion version;\n                            if ( !artifact.isSelectedVersionKnown() )\n                            {\n                                List versions = artifact.getAvailableVersions();\n                                if ( versions == null )\n                                {\n                                    versions = source.retrieveAvailableVersions( artifact, localRepository,\n                                                                                 remoteRepositories );\n                                    artifact.setAvailableVersions( versions );\n                                }\n\n                                VersionRange versionRange = artifact.getVersionRange();\n\n                                version = versionRange.matchVersion( versions );\n\n                                if ( version == null )\n                                {\n                                    if ( versions.isEmpty() )\n                                    {\n                                        throw new OverConstrainedVersionException(\n                                            \"No versions are present in the repository for the artifact with a range \" +\n                                                versionRange, artifact, remoteRepositories );\n                                    }\n                                    else\n                                    {\n                                        throw new OverConstrainedVersionException( \"Couldn't find a version in \" +\n                                            versions + \" to match range \" + versionRange, artifact,\n                                                                                          remoteRepositories );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                version = artifact.getSelectedVersion();\n                            }\n\n                            artifact.selectVersion( version.toString() );\n                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );\n                        }\n\n                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );\n\n                        //TODO might be better to have source.retreive() throw a specific exception for this situation\n                        //and catch here rather than have it return null\n                        if ( rGroup == null )\n                        {\n                            //relocated dependency artifact is declared excluded, no need to add and recurse further\n                            continue;\n                        }\n\n                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n                    }\n                    catch ( CyclicDependencyException e )\n                    {\n                        // would like to throw this, but we have crappy stuff in the repo\n\n                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        throw new ArtifactResolutionException(\n                            \"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories,\n                            e );\n                    }\n\n                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,\n                             filter, listeners );\n                }\n            }\n\n            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n        }\n    }","id":43744,"modified_method":"private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,\n                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                          ArtifactFilter filter, List listeners )\n        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException\n    {\n        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );\n\n        // TODO: use as a conflict resolver\n        Object key = node.getKey();\n        if ( managedVersions.containsKey( key ) )\n        {\n            Artifact artifact = (Artifact) managedVersions.get( key );\n\n            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );\n\n            if ( artifact.getVersion() != null )\n            {\n                node.getArtifact().setVersion( artifact.getVersion() );\n            }\n            if ( artifact.getScope() != null )\n            {\n                node.getArtifact().setScope( artifact.getScope() );\n            }\n        }\n\n        List previousNodes = (List) resolvedArtifacts.get( key );\n        if ( previousNodes != null )\n        {\n            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )\n            {\n                ResolutionNode previous = (ResolutionNode) i.next();\n\n                if ( previous.isActive() )\n                {\n                    // Version mediation\n                    VersionRange previousRange = previous.getArtifact().getVersionRange();\n                    VersionRange currentRange = node.getArtifact().getVersionRange();\n\n                    // TODO: why do we force the version on it? what if they don't match?\n                    if ( previousRange == null )\n                    {\n                        // version was already resolved\n                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n                    }\n                    else if ( currentRange == null )\n                    {\n                        // version was already resolved\n                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n                    }\n                    else\n                    {\n                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                        // version but the restriction is identical\n                        VersionRange newRange = previousRange.restrict( currentRange );\n                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\n                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )\n                        {\n                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),\n                                       newRange );\n                        }\n                        previous.getArtifact().setVersionRange( newRange );\n                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );\n\n                        //Select an appropriate available version from the (now restricted) range\n                        //Note this version was selected before to get the appropriate POM\n                        //But it was reset by the call to setVersionRange on restricting the version\n                        ResolutionNode[] resetNodes = {previous, node};\n                        for ( int j = 0; j < 2; j++ )\n                        {\n                            Artifact resetArtifact = resetNodes[j].getArtifact();\n                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&\n                                resetArtifact.getAvailableVersions() != null )\n                            {\n\n                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(\n                                    resetArtifact.getAvailableVersions() ).toString() );\n                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );\n                            }\n                        }\n                    }\n\n                    // Conflict Resolution\n                    // TODO: use as conflict resolver(s), chain\n\n                    // TODO: should this be part of mediation?\n                    // previous one is more dominant\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        checkScopeUpdate( node, previous, listeners );\n                    }\n                    else\n                    {\n                        checkScopeUpdate( previous, node, listeners );\n                    }\n\n                    if ( previous.getDepth() <= node.getDepth() )\n                    {\n                        // previous was nearer\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );\n                        node.disable();\n                    }\n                    else\n                    {\n                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact() );\n                        previous.disable();\n                    }\n                }\n            }\n        }\n        else\n        {\n            previousNodes = new ArrayList();\n            resolvedArtifacts.put( key, previousNodes );\n        }\n        previousNodes.add( node );\n\n        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );\n\n        // don't pull in the transitive deps of a system-scoped dependency.\n        if ( node.isActive() && !Artifact.SCOPE_SYSTEM.equals( node.getArtifact().getScope() ) )\n        {\n            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );\n\n            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )\n            {\n                ResolutionNode child = (ResolutionNode) i.next();\n                // We leave in optional ones, but don't pick up its dependencies\n                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )\n                {\n                    Artifact artifact = child.getArtifact();\n                    try\n                    {\n                        if ( artifact.getVersion() == null )\n                        {\n                            // set the recommended version\n                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?\n                            ArtifactVersion version;\n                            if ( !artifact.isSelectedVersionKnown() )\n                            {\n                                List versions = artifact.getAvailableVersions();\n                                if ( versions == null )\n                                {\n                                    versions = source.retrieveAvailableVersions( artifact, localRepository,\n                                                                                 remoteRepositories );\n                                    artifact.setAvailableVersions( versions );\n                                }\n\n                                VersionRange versionRange = artifact.getVersionRange();\n\n                                version = versionRange.matchVersion( versions );\n\n                                if ( version == null )\n                                {\n                                    if ( versions.isEmpty() )\n                                    {\n                                        throw new OverConstrainedVersionException(\n                                            \"No versions are present in the repository for the artifact with a range \" +\n                                                versionRange, artifact, remoteRepositories );\n                                    }\n                                    else\n                                    {\n                                        throw new OverConstrainedVersionException( \"Couldn't find a version in \" +\n                                            versions + \" to match range \" + versionRange, artifact,\n                                                                                          remoteRepositories );\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                version = artifact.getSelectedVersion();\n                            }\n\n                            artifact.selectVersion( version.toString() );\n                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );\n                        }\n\n                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );\n\n                        //TODO might be better to have source.retreive() throw a specific exception for this situation\n                        //and catch here rather than have it return null\n                        if ( rGroup == null )\n                        {\n                            //relocated dependency artifact is declared excluded, no need to add and recurse further\n                            continue;\n                        }\n\n                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );\n                    }\n                    catch ( CyclicDependencyException e )\n                    {\n                        // would like to throw this, but we have crappy stuff in the repo\n\n                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,\n                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        artifact.setDependencyTrail( node.getDependencyTrail() );\n                        throw new ArtifactResolutionException(\n                            \"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories,\n                            e );\n                    }\n\n                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,\n                             filter, listeners );\n                }\n            }\n\n            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );\n        }\n    }","commit_id":"52bd946dac234524a4982f88a05981944275598e","url":"https://github.com/apache/maven"},{"original_method":"protected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tif (sockJsSession.isNew()) {\n\t\t\tlogger.debug(\"Opening \" + getTransportType() + \" connection\");\n\t\t\tsockJsSession.handleInitialRequest(request, response, getFrameFormat(request));\n\t\t}\n\t\telse if (sockJsSession.isClosed()) {\n\t\t\tlogger.debug(\"Connection already closed (but not removed yet)\");\n\t\t\tSockJsFrame frame = SockJsFrame.closeFrameGoAway();\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(frame.getContentBytes());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new SockJsException(\"Failed to send \" + frame, sockJsSession.getId(), ex);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if (!sockJsSession.isActive()) {\n\t\t\tlogger.debug(\"starting \" + getTransportType() + \" async request\");\n\t\t\tsockJsSession.startLongPollingRequest(request, response, getFrameFormat(request));\n\t\t}\n\t\telse {\n\t\t\tlogger.debug(\"another \" + getTransportType() + \" connection still open: \" + sockJsSession);\n\t\t\tSockJsFrame frame = getFrameFormat(request).format(SockJsFrame.closeFrameAnotherConnectionOpen());\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(frame.getContentBytes());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new SockJsException(\"Failed to send \" + frame, sockJsSession.getId(), ex);\n\t\t\t}\n\t\t}\n\t}","id":43745,"modified_method":"protected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tif (sockJsSession.isNew()) {\n\t\t\tlogger.debug(\"Opening \" + getTransportType() + \" connection\");\n\t\t\tsockJsSession.handleInitialRequest(request, response, getFrameFormat(request));\n\t\t}\n\t\telse if (sockJsSession.isClosed()) {\n\t\t\tlogger.debug(\"Connection already closed (but not removed yet)\");\n\t\t\tSockJsFrame frame = SockJsFrame.closeFrameGoAway();\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(frame.getContentBytes());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new SockJsException(\"Failed to send \" + frame, sockJsSession.getId(), ex);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if (!sockJsSession.isActive()) {\n\t\t\tlogger.debug(\"starting \" + getTransportType() + \" async request\");\n\t\t\tsockJsSession.handleSuccessiveRequest(request, response, getFrameFormat(request));\n\t\t}\n\t\telse {\n\t\t\tlogger.debug(\"another \" + getTransportType() + \" connection still open: \" + sockJsSession);\n\t\t\tSockJsFrame frame = getFrameFormat(request).format(SockJsFrame.closeFrameAnotherConnectionOpen());\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(frame.getContentBytes());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new SockJsException(\"Failed to send \" + frame, sockJsSession.getId(), ex);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c1f3da082c3b0fb470cee991d7ae96264d52f5bb","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void tryFlushCache() throws SockJsTransportFailureException {\n\t\tif (isActive() && !getMessageCache().isEmpty()) {\n\t\t\tlogger.trace(\"Flushing messages\");\n\t\t\tflushCache();\n\t\t}\n\t}","id":43746,"modified_method":"private void tryFlushCache() throws SockJsTransportFailureException {\n\t\tif (this.messageCache.isEmpty()) {\n\t\t\tlogger.trace(\"Nothing to flush\");\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(this.messageCache.size() + \" message(s) to flush\");\n\t\t}\n\t\tif (isActive()) {\n\t\t\tlogger.trace(\"Flushing messages\");\n\t\t\tflushCache();\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Not ready to flush\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"c1f3da082c3b0fb470cee991d7ae96264d52f5bb","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void updateRequest(ServerHttpRequest request, ServerHttpResponse response, SockJsFrameFormat frameFormat) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.notNull(frameFormat, \"SockJsFrameFormat must not be null\");\n\t\tthis.request = request;\n\t\tthis.response = response;\n\t\tthis.asyncRequestControl = request.getAsyncRequestControl(response);\n\t\tthis.frameFormat = frameFormat;\n\t\tafterRequestUpdated();\n\t}","id":43747,"modified_method":"private void initRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) {\n\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.notNull(frameFormat, \"SockJsFrameFormat must not be null\");\n\n\t\tthis.request = request;\n\t\tthis.response = response;\n\t\tthis.asyncRequestControl = request.getAsyncRequestControl(response);\n\t\tthis.frameFormat = frameFormat;\n\t}","commit_id":"c1f3da082c3b0fb470cee991d7ae96264d52f5bb","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public synchronized void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tupdateRequest(request, response, frameFormat);\n\t\ttry {\n\t\t\twritePrelude();\n\t\t\twriteFrame(SockJsFrame.openFrame());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to send \\\"open\\\" frame\", getId(), ex);\n\t\t}\n\n\t\tthis.uri = request.getURI();\n\t\tthis.handshakeHeaders = request.getHeaders();\n\t\tthis.principal = request.getPrincipal();\n\t\tthis.localAddress = request.getLocalAddress();\n\t\tthis.remoteAddress = request.getRemoteAddress();\n\n\t\ttry {\n\t\t\tdelegateConnectionEstablished();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SockJsException(\"Unhandled exception from WebSocketHandler\", getId(), ex);\n\t\t}\n\t}","id":43748,"modified_method":"/**\n\t * Handle the first HTTP request, i.e. the one that starts a SockJS session.\n\t * Write a prelude to the response (if needed), send the SockJS \"open\" frame\n\t * to indicate to the client the session is opened, and invoke the\n\t * delegate WebSocketHandler to provide it with the newly opened session.\n\t * <p>\n\t * The \"xhr\" and \"jsonp\" (polling-based) transports completes the initial request\n\t * as soon as the open frame is sent. Following that the client should start a\n\t * successive polling request within the same SockJS session.\n\t * <p>\n\t * The \"xhr_streaming\", \"eventsource\", and \"htmlfile\" transports are streaming\n\t * based and will leave the initial request open in order to stream one or\n\t * more messages. However, even streaming based transports eventually recycle\n\t * the long running request, after a certain number of bytes have been streamed\n\t * (128K by default), and allow the client to start a successive request within\n\t * the same SockJS session.\n\t *\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t *\n\t * @see #handleSuccessiveRequest(org.springframework.http.server.ServerHttpRequest, org.springframework.http.server.ServerHttpResponse, org.springframework.web.socket.sockjs.frame.SockJsFrameFormat)\n\t */\n\tpublic synchronized void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tinitRequest(request, response, frameFormat);\n\n\t\tthis.uri = request.getURI();\n\t\tthis.handshakeHeaders = request.getHeaders();\n\t\tthis.principal = request.getPrincipal();\n\t\tthis.localAddress = request.getLocalAddress();\n\t\tthis.remoteAddress = request.getRemoteAddress();\n\n\t\ttry {\n\t\t\twritePrelude();\n\t\t\twriteFrame(SockJsFrame.openFrame());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to send \\\"open\\\" frame\", getId(), ex);\n\t\t}\n\n\t\ttry {\n\t\t\tdelegateConnectionEstablished();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SockJsException(\"Unhandled exception from WebSocketHandler\", getId(), ex);\n\t\t}\n\t}","commit_id":"c1f3da082c3b0fb470cee991d7ae96264d52f5bb","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public synchronized void startLongPollingRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, SockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tupdateRequest(request, response, frameFormat);\n\t\ttry {\n\t\t\tthis.asyncRequestControl.start(-1);\n\t\t\tscheduleHeartbeat();\n\t\t\ttryFlushCache();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to flush messages\", getId(), ex);\n\t\t}\n\t}","id":43749,"modified_method":"/**\n\t * Handle all HTTP requests part of the same SockJS session except for the very\n\t * first, initial request. Write a prelude (if needed) and keep the request\n\t * open and ready to send a message from the server to the client.\n\t * <p>\n\t * The \"xhr\" and \"jsonp\" (polling-based) transports completes the request when\n\t * the next message is sent, which could be an array of messages cached during\n\t * the time between successive requests, or it could be a heartbeat message\n\t * sent if no other messages were sent (by default within 25 seconds).\n\t * <p>\n\t * The \"xhr_streaming\", \"eventsource\", and \"htmlfile\" transports are streaming\n\t * based and will leave the request open longer in order to stream messages over\n\t * a period of time. However, even streaming based transports eventually recycle\n\t * the long running request, after a certain number of bytes have been streamed\n\t * (128K by default), and allow the client to start a successive request within\n\t * the same SockJS session.\n\t *\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t *\n\t * @see #handleInitialRequest(org.springframework.http.server.ServerHttpRequest, org.springframework.http.server.ServerHttpResponse, org.springframework.web.socket.sockjs.frame.SockJsFrameFormat)\n\t */\n\tpublic synchronized void handleSuccessiveRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, SockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tinitRequest(request, response, frameFormat);\n\t\ttry {\n\t\t\twritePrelude();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"Failed to send \\\"open\\\" frame\", getId(), ex);\n\t\t}\n\t\tstartAsyncRequest();\n\t}","commit_id":"c1f3da082c3b0fb470cee991d7ae96264d52f5bb","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void delegateMessages(String[] messages) throws SockJsMessageDeliveryException {\n\t\tList<String> undelivered = new ArrayList<String>(Arrays.asList(messages));\n\t\tfor (String message : messages) {\n\t\t\ttry {\n\t\t\t\tif (isClosed()) {\n\t\t\t\t\tthrow new SockJsMessageDeliveryException(this.id, undelivered, null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.handler.handleMessage(this, new TextMessage(message));\n\t\t\t\t\tundelivered.remove(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new SockJsMessageDeliveryException(this.id, undelivered, ex);\n\t\t\t}\n\t\t}\n\t}","id":43750,"modified_method":"public void delegateMessages(String[] messages) throws SockJsMessageDeliveryException {\n\t\tList<String> undelivered = new ArrayList<String>(Arrays.asList(messages));\n\t\tfor (String message : messages) {\n\t\t\ttry {\n\t\t\t\tif (isClosed()) {\n\t\t\t\t\tthrow new SockJsMessageDeliveryException(this.id, undelivered, \"Session closed\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.handler.handleMessage(this, new TextMessage(message));\n\t\t\t\t\tundelivered.remove(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new SockJsMessageDeliveryException(this.id, undelivered, ex);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c1f3da082c3b0fb470cee991d7ae96264d52f5bb","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected TestSockJsSession initSockJsSession() {\n\t\treturn new TestSockJsSession(\"1\", this.sockJsConfig, this.webSocketHandler,\n\t\t\t\tCollections.<String, Object>emptyMap());\n\t}","id":43751,"modified_method":"protected abstract S initSockJsSession();","commit_id":"c1f3da082c3b0fb470cee991d7ae96264d52f5bb","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic synchronized void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tsuper.handleInitialRequest(request, response, frameFormat);\n\n\t\t// the WebSocketHandler delegate may have closed the session\n\t\tif (!isClosed()) {\n\t\t\tsuper.startLongPollingRequest(request, response, frameFormat);\n\t\t}\n\t}","id":43752,"modified_method":"@Override\n\tpublic synchronized void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tsuper.handleInitialRequest(request, response, frameFormat);\n\n\t\t// the WebSocketHandler delegate may have closed the session\n\t\tif (!isClosed()) {\n\t\t\tsuper.startAsyncRequest();\n\t\t}\n\t}","commit_id":"c1f3da082c3b0fb470cee991d7ae96264d52f5bb","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void handleReadAttribute(OperationContext context, ModelNode operation, final ActiveMQServer server) throws OperationFailedException {\n        final String name = operation.require(ModelDescriptionConstants.NAME).asString();\n\n        if (STARTED.getName().equals(name)) {\n            boolean started = server.isStarted();\n            context.getResult().set(started);\n        } else if (VERSION.getName().equals(name)) {\n            String version = server.getVersion().getFullVersion();\n            context.getResult().set(version);\n        } else if (ACTIVE.getName().equals(name)) {\n            boolean active = server.isActive();\n            context.getResult().set(active);\n        } else {\n            // Bug\n            throw MessagingLogger.ROOT_LOGGER.unsupportedAttribute(name);\n        }\n    }","id":43753,"modified_method":"private void handleReadAttribute(OperationContext context, ModelNode operation, final ActiveMQServer server) throws OperationFailedException {\n        final String name = operation.require(ModelDescriptionConstants.NAME).asString();\n\n        if (STARTED.getName().equals(name)) {\n            boolean started = server != null ? server.isStarted() : false;\n            context.getResult().set(started);\n        } else if (VERSION.getName().equals(name)) {\n            if (server != null) {\n                String version = server.getVersion().getFullVersion();\n                context.getResult().set(version);\n            }\n        } else if (ACTIVE.getName().equals(name)) {\n            boolean active = server != null ? server.isActive() : false;\n            context.getResult().set(active);\n        } else {\n            // Bug\n            throw MessagingLogger.ROOT_LOGGER.unsupportedAttribute(name);\n        }\n    }","commit_id":"64ea893356dea1756214f9e271bff58f78a3780e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n        final String operationName = operation.require(OP).asString();\n\n        final ServiceName serviceName = MessagingServices.getActiveMQServiceName(PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n\n        if (READ_ATTRIBUTE_OPERATION.equals(operationName)) {\n            if (context.getRunningMode() == RunningMode.NORMAL) {\n                ServiceController<?> service = context.getServiceRegistry(false).getService(serviceName);\n                if (service == null || service.getState() != ServiceController.State.UP) {\n                    throw MessagingLogger.ROOT_LOGGER.activeMQServerNotInstalled(serviceName.getSimpleName());\n                }\n                ActiveMQServer server = ActiveMQServer.class.cast(service.getValue());\n                //TODO 'active' should possibly be set to false if we are admin only?\n                handleReadAttribute(context, operation, server);\n            }\n            return;\n        }\n\n        if (rollbackOperationIfServerNotActive(context, operation)) {\n            return;\n        }\n\n        final ActiveMQServerControl serverControl = getServerControl(context, operation);\n\n        try {\n            if (GET_CONNECTORS_AS_JSON.equals(operationName)) {\n                String json = serverControl.getConnectorsAsJSON();\n                context.getResult().set(json);\n            } else if (RESET_ALL_MESSAGE_COUNTERS.equals(operationName)) {\n                serverControl.resetAllMessageCounters();\n                context.getResult();\n            } else if (RESET_ALL_MESSAGE_COUNTER_HISTORIES.equals(operationName)) {\n                serverControl.resetAllMessageCounterHistories();\n                context.getResult();\n            } else if (LIST_PREPARED_TRANSACTIONS.equals(operationName)) {\n                String[] list = serverControl.listPreparedTransactions();\n                reportListOfStrings(context, list);\n            } else if (LIST_PREPARED_TRANSACTION_DETAILS_AS_JSON.equals(operationName)) {\n                String json = serverControl.listPreparedTransactionDetailsAsJSON();\n                context.getResult().set(json);\n            } else if (LIST_PREPARED_TRANSACTION_DETAILS_AS_HTML.equals(operationName)) {\n                String html = serverControl.listPreparedTransactionDetailsAsHTML();\n                context.getResult().set(html);\n            } else if (LIST_HEURISTIC_COMMITTED_TRANSACTIONS.equals(operationName)) {\n                String[] list = serverControl.listHeuristicCommittedTransactions();\n                reportListOfStrings(context, list);\n            } else if (LIST_HEURISTIC_ROLLED_BACK_TRANSACTIONS.equals(operationName)) {\n                String[] list = serverControl.listHeuristicRolledBackTransactions();\n                reportListOfStrings(context, list);\n            } else if (COMMIT_PREPARED_TRANSACTION.equals(operationName)) {\n                String txId = TRANSACTION_AS_BASE_64.resolveModelAttribute(context, operation).asString();\n                boolean committed = serverControl.commitPreparedTransaction(txId);\n                context.getResult().set(committed);\n            } else if (ROLLBACK_PREPARED_TRANSACTION.equals(operationName)) {\n                String txId = TRANSACTION_AS_BASE_64.resolveModelAttribute(context, operation).asString();\n                boolean committed = serverControl.rollbackPreparedTransaction(txId);\n                context.getResult().set(committed);\n            } else if (LIST_REMOTE_ADDRESSES.equals(operationName)) {\n                ModelNode address = OPTIONAL_IP_ADDRESS.resolveModelAttribute(context, operation);\n                String[] list = address.isDefined() ? serverControl.listRemoteAddresses(address.asString()) : serverControl.listRemoteAddresses();\n                reportListOfStrings(context, list);\n            } else if (CLOSE_CONNECTIONS_FOR_ADDRESS.equals(operationName)) {\n                String address = REQUIRED_IP_ADDRESS.resolveModelAttribute(context, operation).asString();\n                boolean closed = serverControl.closeConnectionsForAddress(address);\n                context.getResult().set(closed);\n            } else if (CLOSE_CONNECTIONS_FOR_USER.equals(operationName)) {\n                String user = USER.resolveModelAttribute(context, operation).asString();\n                boolean closed = serverControl.closeConnectionsForUser(user);\n                context.getResult().set(closed);\n            } else if (CLOSE_CONSUMER_CONNECTIONS_FOR_ADDRESS.equals(operationName)) {\n                String address = ADDRESS_MATCH.resolveModelAttribute(context, operation).asString();\n                boolean closed = serverControl.closeConsumerConnectionsForAddress(address);\n                context.getResult().set(closed);\n            } else if (LIST_CONNECTION_IDS.equals(operationName)) {\n                String[] list = serverControl.listConnectionIDs();\n                reportListOfStrings(context, list);\n            } else if (LIST_PRODUCERS_INFO_AS_JSON.equals(operationName)) {\n                String json = serverControl.listProducersInfoAsJSON();\n                context.getResult().set(json);\n            } else if (LIST_SESSIONS.equals(operationName)) {\n                String connectionID = CONNECTION_ID.resolveModelAttribute(context, operation).asString();\n                String[] list = serverControl.listSessions(connectionID);\n                reportListOfStrings(context, list);\n            } else if (GET_ROLES.equals(operationName)) {\n                String addressMatch = ADDRESS_MATCH.resolveModelAttribute(context, operation).asString();\n                String json = serverControl.getRolesAsJSON(addressMatch);\n                reportRoles(context, json);\n            } else if (GET_ROLES_AS_JSON.equals(operationName)) {\n                String addressMatch = ADDRESS_MATCH.resolveModelAttribute(context, operation).asString();\n                String json = serverControl.getRolesAsJSON(addressMatch);\n                reportRolesAsJSON(context, json);\n            } else if (GET_ADDRESS_SETTINGS_AS_JSON.equals(operationName)) {\n                String addressMatch = ADDRESS_MATCH.resolveModelAttribute(context, operation).asString();\n                String json = serverControl.getAddressSettingsAsJSON(addressMatch);\n                context.getResult().set(json);\n            } else if (FORCE_FAILOVER.equals(operationName)) {\n                serverControl.forceFailover();\n                context.getResult();\n            } else {\n                // Bug\n                throw MessagingLogger.ROOT_LOGGER.unsupportedOperation(operationName);\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            context.getFailureDescription().set(e.getLocalizedMessage());\n        }\n    }","id":43754,"modified_method":"@Override\n    protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n        final String operationName = operation.require(OP).asString();\n\n        final ServiceName serviceName = MessagingServices.getActiveMQServiceName(PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n\n        if (READ_ATTRIBUTE_OPERATION.equals(operationName)) {\n            ActiveMQServer server = null;\n            if (context.getRunningMode() == RunningMode.NORMAL) {\n                ServiceController<?> service = context.getServiceRegistry(false).getService(serviceName);\n                if (service == null || service.getState() != ServiceController.State.UP) {\n                    throw MessagingLogger.ROOT_LOGGER.activeMQServerNotInstalled(serviceName.getSimpleName());\n                }\n                server = ActiveMQServer.class.cast(service.getValue());\n            }\n            handleReadAttribute(context, operation, server);\n            return;\n        }\n\n        if (rollbackOperationIfServerNotActive(context, operation)) {\n            return;\n        }\n\n        final ActiveMQServerControl serverControl = getServerControl(context, operation);\n\n        try {\n            if (GET_CONNECTORS_AS_JSON.equals(operationName)) {\n                String json = serverControl.getConnectorsAsJSON();\n                context.getResult().set(json);\n            } else if (RESET_ALL_MESSAGE_COUNTERS.equals(operationName)) {\n                serverControl.resetAllMessageCounters();\n                context.getResult();\n            } else if (RESET_ALL_MESSAGE_COUNTER_HISTORIES.equals(operationName)) {\n                serverControl.resetAllMessageCounterHistories();\n                context.getResult();\n            } else if (LIST_PREPARED_TRANSACTIONS.equals(operationName)) {\n                String[] list = serverControl.listPreparedTransactions();\n                reportListOfStrings(context, list);\n            } else if (LIST_PREPARED_TRANSACTION_DETAILS_AS_JSON.equals(operationName)) {\n                String json = serverControl.listPreparedTransactionDetailsAsJSON();\n                context.getResult().set(json);\n            } else if (LIST_PREPARED_TRANSACTION_DETAILS_AS_HTML.equals(operationName)) {\n                String html = serverControl.listPreparedTransactionDetailsAsHTML();\n                context.getResult().set(html);\n            } else if (LIST_HEURISTIC_COMMITTED_TRANSACTIONS.equals(operationName)) {\n                String[] list = serverControl.listHeuristicCommittedTransactions();\n                reportListOfStrings(context, list);\n            } else if (LIST_HEURISTIC_ROLLED_BACK_TRANSACTIONS.equals(operationName)) {\n                String[] list = serverControl.listHeuristicRolledBackTransactions();\n                reportListOfStrings(context, list);\n            } else if (COMMIT_PREPARED_TRANSACTION.equals(operationName)) {\n                String txId = TRANSACTION_AS_BASE_64.resolveModelAttribute(context, operation).asString();\n                boolean committed = serverControl.commitPreparedTransaction(txId);\n                context.getResult().set(committed);\n            } else if (ROLLBACK_PREPARED_TRANSACTION.equals(operationName)) {\n                String txId = TRANSACTION_AS_BASE_64.resolveModelAttribute(context, operation).asString();\n                boolean committed = serverControl.rollbackPreparedTransaction(txId);\n                context.getResult().set(committed);\n            } else if (LIST_REMOTE_ADDRESSES.equals(operationName)) {\n                ModelNode address = OPTIONAL_IP_ADDRESS.resolveModelAttribute(context, operation);\n                String[] list = address.isDefined() ? serverControl.listRemoteAddresses(address.asString()) : serverControl.listRemoteAddresses();\n                reportListOfStrings(context, list);\n            } else if (CLOSE_CONNECTIONS_FOR_ADDRESS.equals(operationName)) {\n                String address = REQUIRED_IP_ADDRESS.resolveModelAttribute(context, operation).asString();\n                boolean closed = serverControl.closeConnectionsForAddress(address);\n                context.getResult().set(closed);\n            } else if (CLOSE_CONNECTIONS_FOR_USER.equals(operationName)) {\n                String user = USER.resolveModelAttribute(context, operation).asString();\n                boolean closed = serverControl.closeConnectionsForUser(user);\n                context.getResult().set(closed);\n            } else if (CLOSE_CONSUMER_CONNECTIONS_FOR_ADDRESS.equals(operationName)) {\n                String address = ADDRESS_MATCH.resolveModelAttribute(context, operation).asString();\n                boolean closed = serverControl.closeConsumerConnectionsForAddress(address);\n                context.getResult().set(closed);\n            } else if (LIST_CONNECTION_IDS.equals(operationName)) {\n                String[] list = serverControl.listConnectionIDs();\n                reportListOfStrings(context, list);\n            } else if (LIST_PRODUCERS_INFO_AS_JSON.equals(operationName)) {\n                String json = serverControl.listProducersInfoAsJSON();\n                context.getResult().set(json);\n            } else if (LIST_SESSIONS.equals(operationName)) {\n                String connectionID = CONNECTION_ID.resolveModelAttribute(context, operation).asString();\n                String[] list = serverControl.listSessions(connectionID);\n                reportListOfStrings(context, list);\n            } else if (GET_ROLES.equals(operationName)) {\n                String addressMatch = ADDRESS_MATCH.resolveModelAttribute(context, operation).asString();\n                String json = serverControl.getRolesAsJSON(addressMatch);\n                reportRoles(context, json);\n            } else if (GET_ROLES_AS_JSON.equals(operationName)) {\n                String addressMatch = ADDRESS_MATCH.resolveModelAttribute(context, operation).asString();\n                String json = serverControl.getRolesAsJSON(addressMatch);\n                reportRolesAsJSON(context, json);\n            } else if (GET_ADDRESS_SETTINGS_AS_JSON.equals(operationName)) {\n                String addressMatch = ADDRESS_MATCH.resolveModelAttribute(context, operation).asString();\n                String json = serverControl.getAddressSettingsAsJSON(addressMatch);\n                context.getResult().set(json);\n            } else if (FORCE_FAILOVER.equals(operationName)) {\n                serverControl.forceFailover();\n                context.getResult();\n            } else {\n                // Bug\n                throw MessagingLogger.ROOT_LOGGER.unsupportedOperation(operationName);\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            context.getFailureDescription().set(e.getLocalizedMessage());\n        }\n    }","commit_id":"64ea893356dea1756214f9e271bff58f78a3780e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\tpublic long[] getAvailableClassNameIds(\n\t\tlong companyId, boolean onlyAvailable) {\n\n\t\tMap<String, AssetRendererFactory> assetRenderFactories =\n\t\t\t_assetRenderFactoriesMapByClassName;\n\n\t\tif (companyId > 0) {\n\t\t\tassetRenderFactories = filterAssetRendererFactories(\n\t\t\t\tcompanyId, _assetRenderFactoriesMapByClassName);\n\t\t}\n\n\t\tlong[] classNameIds = new long[assetRenderFactories.size()];\n\n\t\tint i = 0;\n\n\t\tfor (AssetRendererFactory assetRendererFactory :\n\t\t\t\tassetRenderFactories.values()) {\n\n\t\t\tif (!onlyAvailable || assetRendererFactory.isSelectable()) {\n\t\t\t\tclassNameIds[i] = assetRendererFactory.getClassNameId();\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\treturn classNameIds;\n\t}","id":43755,"modified_method":"@Override\n\tpublic long[] getClassNameIds(long companyId, boolean filterSelectable) {\n\t\tMap<String, AssetRendererFactory> assetRenderFactories =\n\t\t\t_assetRenderFactoriesMapByClassName;\n\n\t\tif (companyId > 0) {\n\t\t\tassetRenderFactories = filterAssetRendererFactories(\n\t\t\t\tcompanyId, _assetRenderFactoriesMapByClassName,\n\t\t\t\tfilterSelectable);\n\t\t}\n\n\t\tlong[] classNameIds = new long[assetRenderFactories.size()];\n\n\t\tint i = 0;\n\n\t\tfor (AssetRendererFactory assetRendererFactory :\n\t\t\t\tassetRenderFactories.values()) {\n\n\t\t\tclassNameIds[i] = assetRendererFactory.getClassNameId();\n\n\t\t\ti++;\n\t\t}\n\n\t\treturn classNameIds;\n\t}","commit_id":"fba0b12b994fd7f9733d8a32063b6248ffa9c5ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Map<String, AssetRendererFactory> filterAssetRendererFactories(\n\t\tlong companyId,\n\t\tMap<String, AssetRendererFactory> assetRendererFactories) {\n\n\t\tMap<String, AssetRendererFactory> filteredAssetRendererFactories =\n\t\t\tnew ConcurrentHashMap<String, AssetRendererFactory>();\n\n\t\tfor (String className : assetRendererFactories.keySet()) {\n\t\t\tAssetRendererFactory assetRendererFactory =\n\t\t\t\tassetRendererFactories.get(className);\n\n\t\t\tif (assetRendererFactory.isActive(companyId)) {\n\t\t\t\tfilteredAssetRendererFactories.put(\n\t\t\t\t\tclassName, assetRendererFactory);\n\t\t\t}\n\t\t}\n\n\t\treturn filteredAssetRendererFactories;\n\t}","id":43756,"modified_method":"private Map<String, AssetRendererFactory> filterAssetRendererFactories(\n\t\tlong companyId,\n\t\tMap<String, AssetRendererFactory> assetRendererFactories,\n\t\tboolean filterSelectable) {\n\n\t\tMap<String, AssetRendererFactory> filteredAssetRendererFactories =\n\t\t\tnew ConcurrentHashMap<String, AssetRendererFactory>();\n\n\t\tfor (String className : assetRendererFactories.keySet()) {\n\t\t\tAssetRendererFactory assetRendererFactory =\n\t\t\t\tassetRendererFactories.get(className);\n\n\t\t\tif (assetRendererFactory.isActive(companyId) &&\n\t\t\t\t(!filterSelectable || assetRendererFactory.isSelectable())) {\n\n\t\t\t\tfilteredAssetRendererFactories.put(\n\t\t\t\t\tclassName, assetRendererFactory);\n\t\t\t}\n\t\t}\n\n\t\treturn filteredAssetRendererFactories;\n\t}","commit_id":"fba0b12b994fd7f9733d8a32063b6248ffa9c5ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<AssetRendererFactory> getAssetRendererFactories(\n\t\tlong companyId) {\n\n\t\treturn ListUtil.fromMapValues(\n\t\t\tfilterAssetRendererFactories(\n\t\t\t\tcompanyId, _assetRenderFactoriesMapByClassName));\n\t}","id":43757,"modified_method":"@Override\n\tpublic List<AssetRendererFactory> getAssetRendererFactories(\n\t\tlong companyId) {\n\n\t\treturn ListUtil.fromMapValues(\n\t\t\tfilterAssetRendererFactories(\n\t\t\t\tcompanyId, _assetRenderFactoriesMapByClassName, false));\n\t}","commit_id":"fba0b12b994fd7f9733d8a32063b6248ffa9c5ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic long[] getClassNameIds(long companyId) {\n\t\treturn getAvailableClassNameIds(companyId, false);\n\t}","id":43758,"modified_method":"@Override\n\tpublic long[] getClassNameIds(long companyId) {\n\t\treturn getClassNameIds(companyId, false);\n\t}","commit_id":"fba0b12b994fd7f9733d8a32063b6248ffa9c5ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static long[] getAvailableClassNameIds(\n\t\tlong companyId, boolean onlyAvailable) {\n\n\t\treturn getAssetRendererFactoryRegistry().getAvailableClassNameIds(\n\t\t\tcompanyId, onlyAvailable);\n\t}","id":43759,"modified_method":"public static long[] getClassNameIds(\n\t\tlong companyId, boolean filterSelectable) {\n\n\t\treturn getAssetRendererFactoryRegistry().getClassNameIds(\n\t\t\tcompanyId, filterSelectable);\n\t}","commit_id":"fba0b12b994fd7f9733d8a32063b6248ffa9c5ad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void onMessage(final Message message) {\n        RuntimeCamelException rce = null;\n        try {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(endpoint + \" consumer receiving JMS message: \" + message);\n            }\n            Destination replyDestination = getReplyToDestination(message);\n            final JmsExchange exchange = createExchange(message, replyDestination);\n            if (eagerLoadingOfProperties) {\n                exchange.getIn().getHeaders();\n            }\n            processor.process(exchange);\n            final JmsMessage out = exchange.getOut(false);\n            if (exchange.getException() != null) {\n                rce = new RuntimeCamelException(exchange.getException());\n            }\n            if (rce == null && out != null && !disableReplyTo) {\n                sendReply(replyDestination, message, exchange, out);\n            }\n        } catch (Exception e) {\n            rce = new RuntimeCamelException(e);\n        }\n        if (rce != null) {\n            LOG.warn(endpoint + \" consumer caught an exception while processing \"\n                     + \"JMS message: \" + message, rce);\n            throw rce;\n        }\n    }","id":43760,"modified_method":"public void onMessage(final Message message) {\n        RuntimeCamelException rce = null;\n        try {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(endpoint + \" consumer receiving JMS message: \" + message);\n            }\n            Destination replyDestination = getReplyToDestination(message);\n            final JmsExchange exchange = createExchange(message, replyDestination);\n            if (eagerLoadingOfProperties) {\n                exchange.getIn().getHeaders();\n            }\n\n            // process the exchange\n            processor.process(exchange);\n\n            // get the correct jms message to send as reply\n            JmsMessage body = null;\n            if (exchange.isFailed()) {\n                if (exchange.getException() != null) {\n                    // an exception occured while processing\n                    // TODO: Camel-585 somekind of flag to determine if we should send the exchange back to the client\n                    // or do as new wrap as runtime exception to be thrown back to spring so it can do rollback\n                    rce = wrapRuntimeCamelException(exchange.getException());\n                } else if (exchange.getFault().getBody() != null) {\n                    // a fault occured while processing\n                    body = exchange.getFault();\n                }\n            } else {\n                // process OK so get the reply\n                body = exchange.getOut(false);\n            }\n            // send the reply\n            if (rce == null && body != null && !disableReplyTo) {\n                sendReply(replyDestination, message, exchange, body);\n            }\n        } catch (Exception e) {\n            rce = wrapRuntimeCamelException(e);\n        }\n        if (rce != null) {\n            LOG.warn(endpoint + \" consumer caught an exception while processing \"\n                     + \"JMS message: \" + message, rce);\n            throw rce;\n        }\n    }","commit_id":"0a7458148693c7c114a17eeecaeb5f71bd61886b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Return the underlying JMS Fault message\n     *\n     * @return the JMS fault message\n     */\n    public Message getFaultMessage() {\n        return getOut().getJmsMessage();\n    }","id":43761,"modified_method":"/**\n     * Return the underlying JMS Fault message\n     *\n     * @return the JMS fault message\n     */\n    public Message getFaultMessage() {\n        return getFault().getJmsMessage();\n    }","commit_id":"0a7458148693c7c114a17eeecaeb5f71bd61886b","url":"https://github.com/apache/camel"},{"original_method":"public static void showError( String message, Exception e, boolean showStackTrace )\n    {\n        System.err.println( message );\n\n        if ( showStackTrace )\n        {\n            e.printStackTrace();\n        }\n        else\n        {\n            System.err.println( e.getMessage() );\n\n            for ( Throwable cause = e.getCause(); cause != null; cause = cause.getCause() )\n            {\n                System.err.print( \"Caused by: \" );\n                System.err.println( cause.getMessage() );\n            }\n        }\n    }","id":43762,"modified_method":"public static void showError( MavenEmbedderLogger logger, String message, Exception e, boolean showStackTrace )\n    {\n        if ( showStackTrace )\n        {\n            logger.error( message, e );\n        }\n        else\n        {\n            logger.error( message );\n\n            if ( e != null )\n            {\n                logger.error( e.getMessage() );\n\n                for ( Throwable cause = e.getCause(); cause != null; cause = cause.getCause() )\n                {\n                    logger.error( \"Caused by: \" + cause.getMessage() );\n                }\n            }\n        }\n    }","commit_id":"977d3bccdccc203f413790269d6d0c9f71442ad0","url":"https://github.com/apache/maven"},{"original_method":"public static MavenExecutionRequest buildRequest( CommandLine commandLine, boolean debug, boolean quiet, boolean showErrors )\n    {\n        // ----------------------------------------------------------------------\n        // Now that we have everything that we need we will fire up plexus and\n        // bring the maven component to life for use.\n        // ----------------------------------------------------------------------\n\n        boolean interactive = true;\n\n        if ( commandLine.hasOption( CLIManager.BATCH_MODE ) )\n        {\n            interactive = false;\n        }\n\n        boolean pluginUpdateOverride = false;\n\n        if ( commandLine.hasOption( CLIManager.FORCE_PLUGIN_UPDATES ) ||\n            commandLine.hasOption( CLIManager.FORCE_PLUGIN_UPDATES2 ) )\n        {\n            pluginUpdateOverride = true;\n        }\n        else if ( commandLine.hasOption( CLIManager.SUPPRESS_PLUGIN_UPDATES ) )\n        {\n            pluginUpdateOverride = false;\n        }\n\n        boolean noSnapshotUpdates = false;\n        if ( commandLine.hasOption( CLIManager.SUPRESS_SNAPSHOT_UPDATES ) )\n        {\n            noSnapshotUpdates = true;\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        List<String> goals = commandLine.getArgList();\n\n        boolean recursive = true;\n\n        // this is the default behavior.\n        String reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;\n\n        if ( commandLine.hasOption( CLIManager.NON_RECURSIVE ) )\n        {\n            recursive = false;\n        }\n\n        if ( commandLine.hasOption( CLIManager.FAIL_FAST ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;\n        }\n        else if ( commandLine.hasOption( CLIManager.FAIL_AT_END ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_AT_END;\n        }\n        else if ( commandLine.hasOption( CLIManager.FAIL_NEVER ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_NEVER;\n        }\n\n        boolean offline = false;\n\n        if ( commandLine.hasOption( CLIManager.OFFLINE ) )\n        {\n            offline = true;\n        }\n\n        boolean updateSnapshots = false;\n\n        if ( commandLine.hasOption( CLIManager.UPDATE_SNAPSHOTS ) )\n        {\n            updateSnapshots = true;\n        }\n\n        String globalChecksumPolicy = null;\n\n        if ( commandLine.hasOption( CLIManager.CHECKSUM_FAILURE_POLICY ) )\n        {\n            // todo; log\n            System.out.println( \"+ Enabling strict checksum verification on all artifact downloads.\" );\n\n            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_FAIL;\n        }\n        else if ( commandLine.hasOption( CLIManager.CHECKSUM_WARNING_POLICY ) )\n        {\n            // todo: log\n            System.out.println( \"+ Disabling strict checksum verification on all artifact downloads.\" );\n\n            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_WARN;\n        }\n\n        File baseDirectory = new File( System.getProperty( \"user.dir\" ) );\n\n        // ----------------------------------------------------------------------\n        // Profile Activation\n        // ----------------------------------------------------------------------\n\n        List<String> activeProfiles = new ArrayList<String>();\n\n        List<String> inactiveProfiles = new ArrayList<String>();\n\n        if ( commandLine.hasOption( CLIManager.ACTIVATE_PROFILES ) )\n        {\n            String [] profileOptionValues = commandLine.getOptionValues( CLIManager.ACTIVATE_PROFILES );\n            if ( profileOptionValues != null )\n            {\n                for ( int i=0; i < profileOptionValues.length; ++i )\n                {\n                    StringTokenizer profileTokens = new StringTokenizer( profileOptionValues[i] , \",\" );\n\n                    while ( profileTokens.hasMoreTokens() )\n                    {\n                        String profileAction = profileTokens.nextToken().trim();\n\n                        if ( profileAction.startsWith( \"-\" ) || profileAction.startsWith( \"!\" ) )\n                        {\n                            inactiveProfiles.add( profileAction.substring( 1 ) );\n                        }\n                        else if ( profileAction.startsWith( \"+\" ) )\n                        {\n                            activeProfiles.add( profileAction.substring( 1 ) );\n                        }\n                        else\n                        {\n                            activeProfiles.add( profileAction );\n                        }\n                    }\n                }\n            }\n        }\n\n        MavenTransferListener transferListener;\n\n        if ( interactive )\n        {\n            transferListener = new ConsoleDownloadMonitor();\n        }\n        else\n        {\n            transferListener = new BatchModeDownloadMonitor();\n        }\n\n        transferListener.setShowChecksumEvents( false );\n\n        String alternatePomFile = null;\n        if ( commandLine.hasOption( CLIManager.ALTERNATE_POM_FILE ) )\n        {\n            alternatePomFile = commandLine.getOptionValue( CLIManager.ALTERNATE_POM_FILE );\n        }\n\n        int loggingLevel;\n\n        if ( debug )\n        {\n            loggingLevel = MavenExecutionRequest.LOGGING_LEVEL_DEBUG;\n        }\n        else if ( quiet )\n        {\n            // TODO: we need to do some more work here. Some plugins use sys out or log errors at info level.\n            // Ideally, we could use Warn across the board\n            loggingLevel = MavenExecutionRequest.LOGGING_LEVEL_ERROR;\n            // TODO:Additionally, we can't change the mojo level because the component key includes the version and it isn't known ahead of time. This seems worth changing.\n        }\n        else\n        {\n            loggingLevel = MavenExecutionRequest.LOGGING_LEVEL_INFO;\n        }\n\n        Properties systemProperties = new Properties();\n        Properties userProperties = new Properties();\n        populateProperties( commandLine, systemProperties, userProperties );\n\n        File userToolchainsFile;\n        if ( commandLine.hasOption( CLIManager.ALTERNATE_USER_TOOLCHAINS ) )\n        {\n            userToolchainsFile = new File( commandLine.getOptionValue( CLIManager.ALTERNATE_USER_TOOLCHAINS ) );\n        }\n        else\n        {\n            userToolchainsFile = MavenEmbedder.DEFAULT_USER_TOOLCHAINS_FILE;\n        }\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( baseDirectory )\n            .setGoals( goals )\n            .setSystemProperties( systemProperties )\n            .setUserProperties( userProperties )\n            .setReactorFailureBehavior( reactorFailureBehaviour ) // default: fail fast\n            .setRecursive( recursive ) // default: true\n            .setShowErrors( showErrors ) // default: false\n            .setInteractiveMode( interactive ) // default: true\n            .setOffline( offline ) // default: false\n            .setUsePluginUpdateOverride( pluginUpdateOverride )\n            .addActiveProfiles( activeProfiles ) // optional\n            .addInactiveProfiles( inactiveProfiles ) // optional\n            .setLoggingLevel( loggingLevel ) // default: info\n            .setTransferListener( transferListener ) // default: batch mode which goes along with interactive\n            .setUpdateSnapshots( updateSnapshots ) // default: false\n            .setNoSnapshotUpdates( noSnapshotUpdates ) // default: false\n            .setGlobalChecksumPolicy( globalChecksumPolicy ) // default: warn\n            .setUserToolchainsFile( userToolchainsFile );\n        \n        File pom;\n        \n        if ( alternatePomFile != null )\n        {\n            pom = new File( alternatePomFile );\n        }\n        else\n        {\n            pom = new File( baseDirectory, Maven.POMv4 ); \n        }\n                \n        if ( pom.exists() )\n        {\n            request.setPom( pom );\n        }        \n\n        if ( commandLine.hasOption( CLIManager.RESUME_FROM ) )\n        {\n            request.setResumeFrom( commandLine.getOptionValue( CLIManager.RESUME_FROM ) );\n        }\n\n        if ( commandLine.hasOption( CLIManager.PROJECT_LIST ) )\n        {\n            String projectList = commandLine.getOptionValue( CLIManager.PROJECT_LIST );\n            String[] projects = StringUtils.split( projectList, \",\" );\n            request.setSelectedProjects( Arrays.asList( projects ) );\n        }\n\n        if ( commandLine.hasOption( CLIManager.ALSO_MAKE ) && !commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_UPSTREAM );\n        }\n        else if ( !commandLine.hasOption( CLIManager.ALSO_MAKE )\n            && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_DOWNSTREAM );\n        }\n        else if ( commandLine.hasOption( CLIManager.ALSO_MAKE )\n            && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_BOTH );\n        }\n\n        String localRepoProperty = request.getUserProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );\n\n        if ( localRepoProperty == null )\n        {\n            localRepoProperty = request.getSystemProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );\n        }\n\n        if ( localRepoProperty != null )\n        {\n            request.setLocalRepositoryPath( localRepoProperty );\n        }\n\n        return request;\n    }","id":43763,"modified_method":"public static MavenExecutionRequest buildRequest( CommandLine commandLine, boolean debug, boolean quiet, boolean showErrors )\n    {\n        // ----------------------------------------------------------------------\n        // Now that we have everything that we need we will fire up plexus and\n        // bring the maven component to life for use.\n        // ----------------------------------------------------------------------\n\n        boolean interactive = true;\n\n        if ( commandLine.hasOption( CLIManager.BATCH_MODE ) )\n        {\n            interactive = false;\n        }\n\n        boolean pluginUpdateOverride = false;\n\n        if ( commandLine.hasOption( CLIManager.FORCE_PLUGIN_UPDATES ) ||\n            commandLine.hasOption( CLIManager.FORCE_PLUGIN_UPDATES2 ) )\n        {\n            pluginUpdateOverride = true;\n        }\n        else if ( commandLine.hasOption( CLIManager.SUPPRESS_PLUGIN_UPDATES ) )\n        {\n            pluginUpdateOverride = false;\n        }\n\n        boolean noSnapshotUpdates = false;\n        if ( commandLine.hasOption( CLIManager.SUPRESS_SNAPSHOT_UPDATES ) )\n        {\n            noSnapshotUpdates = true;\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        List<String> goals = commandLine.getArgList();\n\n        boolean recursive = true;\n\n        // this is the default behavior.\n        String reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;\n\n        if ( commandLine.hasOption( CLIManager.NON_RECURSIVE ) )\n        {\n            recursive = false;\n        }\n\n        if ( commandLine.hasOption( CLIManager.FAIL_FAST ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;\n        }\n        else if ( commandLine.hasOption( CLIManager.FAIL_AT_END ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_AT_END;\n        }\n        else if ( commandLine.hasOption( CLIManager.FAIL_NEVER ) )\n        {\n            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_NEVER;\n        }\n\n        boolean offline = false;\n\n        if ( commandLine.hasOption( CLIManager.OFFLINE ) )\n        {\n            offline = true;\n        }\n\n        boolean updateSnapshots = false;\n\n        if ( commandLine.hasOption( CLIManager.UPDATE_SNAPSHOTS ) )\n        {\n            updateSnapshots = true;\n        }\n\n        String globalChecksumPolicy = null;\n\n        if ( commandLine.hasOption( CLIManager.CHECKSUM_FAILURE_POLICY ) )\n        {\n            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_FAIL;\n        }\n        else if ( commandLine.hasOption( CLIManager.CHECKSUM_WARNING_POLICY ) )\n        {\n            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_WARN;\n        }\n\n        File baseDirectory = new File( System.getProperty( \"user.dir\" ) );\n\n        // ----------------------------------------------------------------------\n        // Profile Activation\n        // ----------------------------------------------------------------------\n\n        List<String> activeProfiles = new ArrayList<String>();\n\n        List<String> inactiveProfiles = new ArrayList<String>();\n\n        if ( commandLine.hasOption( CLIManager.ACTIVATE_PROFILES ) )\n        {\n            String [] profileOptionValues = commandLine.getOptionValues( CLIManager.ACTIVATE_PROFILES );\n            if ( profileOptionValues != null )\n            {\n                for ( int i=0; i < profileOptionValues.length; ++i )\n                {\n                    StringTokenizer profileTokens = new StringTokenizer( profileOptionValues[i] , \",\" );\n\n                    while ( profileTokens.hasMoreTokens() )\n                    {\n                        String profileAction = profileTokens.nextToken().trim();\n\n                        if ( profileAction.startsWith( \"-\" ) || profileAction.startsWith( \"!\" ) )\n                        {\n                            inactiveProfiles.add( profileAction.substring( 1 ) );\n                        }\n                        else if ( profileAction.startsWith( \"+\" ) )\n                        {\n                            activeProfiles.add( profileAction.substring( 1 ) );\n                        }\n                        else\n                        {\n                            activeProfiles.add( profileAction );\n                        }\n                    }\n                }\n            }\n        }\n\n        MavenTransferListener transferListener;\n\n        if ( interactive )\n        {\n            transferListener = new ConsoleDownloadMonitor();\n        }\n        else\n        {\n            transferListener = new BatchModeDownloadMonitor();\n        }\n\n        transferListener.setShowChecksumEvents( false );\n\n        String alternatePomFile = null;\n        if ( commandLine.hasOption( CLIManager.ALTERNATE_POM_FILE ) )\n        {\n            alternatePomFile = commandLine.getOptionValue( CLIManager.ALTERNATE_POM_FILE );\n        }\n\n        int loggingLevel;\n\n        if ( debug )\n        {\n            loggingLevel = MavenExecutionRequest.LOGGING_LEVEL_DEBUG;\n        }\n        else if ( quiet )\n        {\n            // TODO: we need to do some more work here. Some plugins use sys out or log errors at info level.\n            // Ideally, we could use Warn across the board\n            loggingLevel = MavenExecutionRequest.LOGGING_LEVEL_ERROR;\n            // TODO:Additionally, we can't change the mojo level because the component key includes the version and it isn't known ahead of time. This seems worth changing.\n        }\n        else\n        {\n            loggingLevel = MavenExecutionRequest.LOGGING_LEVEL_INFO;\n        }\n\n        Properties systemProperties = new Properties();\n        Properties userProperties = new Properties();\n        populateProperties( commandLine, systemProperties, userProperties );\n\n        File userToolchainsFile;\n        if ( commandLine.hasOption( CLIManager.ALTERNATE_USER_TOOLCHAINS ) )\n        {\n            userToolchainsFile = new File( commandLine.getOptionValue( CLIManager.ALTERNATE_USER_TOOLCHAINS ) );\n        }\n        else\n        {\n            userToolchainsFile = MavenEmbedder.DEFAULT_USER_TOOLCHAINS_FILE;\n        }\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( baseDirectory )\n            .setGoals( goals )\n            .setSystemProperties( systemProperties )\n            .setUserProperties( userProperties )\n            .setReactorFailureBehavior( reactorFailureBehaviour ) // default: fail fast\n            .setRecursive( recursive ) // default: true\n            .setShowErrors( showErrors ) // default: false\n            .setInteractiveMode( interactive ) // default: true\n            .setOffline( offline ) // default: false\n            .setUsePluginUpdateOverride( pluginUpdateOverride )\n            .addActiveProfiles( activeProfiles ) // optional\n            .addInactiveProfiles( inactiveProfiles ) // optional\n            .setLoggingLevel( loggingLevel ) // default: info\n            .setTransferListener( transferListener ) // default: batch mode which goes along with interactive\n            .setUpdateSnapshots( updateSnapshots ) // default: false\n            .setNoSnapshotUpdates( noSnapshotUpdates ) // default: false\n            .setGlobalChecksumPolicy( globalChecksumPolicy ) // default: warn\n            .setUserToolchainsFile( userToolchainsFile );\n        \n        File pom;\n        \n        if ( alternatePomFile != null )\n        {\n            pom = new File( alternatePomFile );\n        }\n        else\n        {\n            pom = new File( baseDirectory, Maven.POMv4 ); \n        }\n                \n        if ( pom.exists() )\n        {\n            request.setPom( pom );\n        }        \n\n        if ( commandLine.hasOption( CLIManager.RESUME_FROM ) )\n        {\n            request.setResumeFrom( commandLine.getOptionValue( CLIManager.RESUME_FROM ) );\n        }\n\n        if ( commandLine.hasOption( CLIManager.PROJECT_LIST ) )\n        {\n            String projectList = commandLine.getOptionValue( CLIManager.PROJECT_LIST );\n            String[] projects = StringUtils.split( projectList, \",\" );\n            request.setSelectedProjects( Arrays.asList( projects ) );\n        }\n\n        if ( commandLine.hasOption( CLIManager.ALSO_MAKE ) && !commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_UPSTREAM );\n        }\n        else if ( !commandLine.hasOption( CLIManager.ALSO_MAKE )\n            && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_DOWNSTREAM );\n        }\n        else if ( commandLine.hasOption( CLIManager.ALSO_MAKE )\n            && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )\n        {\n            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_BOTH );\n        }\n\n        String localRepoProperty = request.getUserProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );\n\n        if ( localRepoProperty == null )\n        {\n            localRepoProperty = request.getSystemProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );\n        }\n\n        if ( localRepoProperty != null )\n        {\n            request.setLocalRepositoryPath( localRepoProperty );\n        }\n\n        return request;\n    }","commit_id":"977d3bccdccc203f413790269d6d0c9f71442ad0","url":"https://github.com/apache/maven"},{"original_method":"public int doMain( String[] args, ClassWorld classWorld )\n    {\n        // ----------------------------------------------------------------------\n        // Setup the command line parser\n        // ----------------------------------------------------------------------\n\n        CLIManager cliManager = new CLIManager();\n\n        CommandLine commandLine;\n        try\n        {\n            commandLine = cliManager.parse( args );\n        }\n        catch ( ParseException e )\n        {\n            System.err.println( \"Unable to parse command line options: \" + e.getMessage() );\n            cliManager.displayHelp();\n            return 1;\n        }\n\n        boolean debug = commandLine.hasOption( CLIManager.DEBUG );\n\n        boolean quiet = !debug && commandLine.hasOption( CLIManager.QUIET );\n\n        boolean showErrors = debug || commandLine.hasOption( CLIManager.ERRORS );\n\n        if ( showErrors )\n        {\n            System.out.println( \"+ Error stacktraces are turned on.\" );\n        }\n\n        // ----------------------------------------------------------------------\n        // Process particular command line options\n        // ----------------------------------------------------------------------\n\n        if ( commandLine.hasOption( CLIManager.HELP ) )\n        {\n            cliManager.displayHelp();\n\n            return 0;\n        }\n\n        if ( commandLine.hasOption( CLIManager.VERSION ) )\n        {\n            CLIReportingUtils.showVersion();\n\n            return 0;\n        }\n        else if ( debug || commandLine.hasOption( CLIManager.SHOW_VERSION ) )\n        {\n            CLIReportingUtils.showVersion();\n        }\n\n        // Make sure the Maven home directory is an absolute path to save us from confusion with say drive-relative\n        // Windows paths.\n        String mavenHome = System.getProperty( \"maven.home\" );\n        if ( mavenHome != null )\n        {\n            System.setProperty( \"maven.home\", new File( mavenHome ).getAbsolutePath() );\n        }\n\n        MavenExecutionRequest request = CLIRequestUtils.buildRequest( commandLine, debug, quiet, showErrors );\n\n        Configuration configuration = buildEmbedderConfiguration( request, commandLine, classWorld );\n\n        ConfigurationValidationResult cvr = MavenEmbedder.validateConfiguration( configuration );\n\n        if ( cvr.isUserSettingsFilePresent() && !cvr.isUserSettingsFileParses() )\n        {\n            CLIReportingUtils.showError( \"Error reading user settings: \", cvr.getUserSettingsException(), showErrors );\n\n            return 1;\n        }\n\n        if ( cvr.isGlobalSettingsFilePresent() && !cvr.isGlobalSettingsFileParses() )\n        {\n            CLIReportingUtils.showError( \"Error reading global settings: \", cvr.getGlobalSettingsException(), showErrors );\n\n            return 1;\n        }\n\n        if ( configuration.getGlobalSettingsFile() != null )\n        {\n            request.setGlobalSettingsFile( configuration.getGlobalSettingsFile() );\n        }\n\n        if ( configuration.getUserSettingsFile() != null )\n        {\n            request.setUserSettingsFile( configuration.getUserSettingsFile() );\n        }\n\n        MavenEmbedder mavenEmbedder;\n\n        try\n        {\n            mavenEmbedder = new MavenEmbedder( configuration );\n        }\n        catch ( MavenEmbedderException e )\n        {\n            CLIReportingUtils.showError( \"Unable to start the embedder: \", e, showErrors );\n\n            return 1;\n        }\n\n        try\n        {\n            if ( commandLine.hasOption( CLIManager.ENCRYPT_MASTER_PASSWORD ) )\n            {\n                String passwd = commandLine.getOptionValue( CLIManager.ENCRYPT_MASTER_PASSWORD );\n\n                DefaultPlexusCipher cipher = new DefaultPlexusCipher();\n\n                System.out.println( cipher.encryptAndDecorate( passwd,\n                                                               DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION ) );\n\n                return 0;\n            }\n            else if ( commandLine.hasOption( CLIManager.ENCRYPT_PASSWORD ) )\n            {\n                String passwd = commandLine.getOptionValue( CLIManager.ENCRYPT_PASSWORD );\n\n                DefaultSecDispatcher dispatcher;\n                dispatcher = (DefaultSecDispatcher) mavenEmbedder.getPlexusContainer().lookup( SecDispatcher.class );\n                String configurationFile = dispatcher.getConfigurationFile();\n                if ( configurationFile.startsWith( \"~\" ) )\n                {\n                    configurationFile = System.getProperty( \"user.home\" ) + configurationFile.substring( 1 );\n                }\n                String file = System.getProperty( DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION, configurationFile );\n                mavenEmbedder.getPlexusContainer().release( dispatcher );\n\n                String master = null;\n\n                SettingsSecurity sec = SecUtil.read( file, true );\n                if ( sec != null )\n                {\n                    master = sec.getMaster();\n                }\n\n                if ( master == null )\n                {\n                    System.err.println( \"Master password is not set in the setting security file\" );\n\n                    return 1;\n                }\n\n                DefaultPlexusCipher cipher = new DefaultPlexusCipher();\n                String masterPasswd =\n                    cipher.decryptDecorated( master, DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION );\n                System.out.println( cipher.encryptAndDecorate( passwd, masterPasswd ) );\n\n                return 0;\n            }\n        }\n        catch ( Exception e )\n        {\n            CLIReportingUtils.showError( \"FATAL ERROR: \" + \"Error encrypting password: \" + e.getMessage(), e, showErrors );\n\n            return 1;\n        }\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        try\n        {\n            mavenEmbedder.stop();\n        }\n        catch ( MavenEmbedderException e )\n        {\n            result.addException( e );\n        }\n\n        // The exception handling should be handled in Maven itself.\n\n        if ( result.hasExceptions() )\n        {\n            ExceptionSummary es = result.getExceptionSummary();\n\n            if ( es == null )\n            {\n                result.getExceptions().get( 0 ).printStackTrace();\n            }\n            else\n            {\n                System.out.println( es.getMessage() );\n\n                if ( showErrors )\n                {\n                    es.getException().printStackTrace();\n                }\n            }\n\n            if ( MavenExecutionRequest.REACTOR_FAIL_NEVER.equals( request.getReactorFailureBehavior() ) )\n            {\n                System.out.println( \"+ Build failures were ignored.\" );\n\n                return 0;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n        else\n        {\n            return 0;\n        }\n    }","id":43764,"modified_method":"public int doMain( String[] args, ClassWorld classWorld )\n    {\n        // ----------------------------------------------------------------------\n        // Setup the command line parser\n        // ----------------------------------------------------------------------\n\n        CLIManager cliManager = new CLIManager();\n\n        CommandLine commandLine;\n        try\n        {\n            commandLine = cliManager.parse( args );\n        }\n        catch ( ParseException e )\n        {\n            System.err.println( \"Unable to parse command line options: \" + e.getMessage() );\n            cliManager.displayHelp();\n            return 1;\n        }\n\n        boolean debug = commandLine.hasOption( CLIManager.DEBUG );\n\n        boolean quiet = !debug && commandLine.hasOption( CLIManager.QUIET );\n\n        boolean showErrors = debug || commandLine.hasOption( CLIManager.ERRORS );\n\n        // ----------------------------------------------------------------------\n        // Process particular command line options\n        // ----------------------------------------------------------------------\n\n        if ( commandLine.hasOption( CLIManager.HELP ) )\n        {\n            cliManager.displayHelp();\n\n            return 0;\n        }\n\n        if ( commandLine.hasOption( CLIManager.VERSION ) )\n        {\n            CLIReportingUtils.showVersion();\n\n            return 0;\n        }\n\n        // Make sure the Maven home directory is an absolute path to save us from confusion with say drive-relative\n        // Windows paths.\n        String mavenHome = System.getProperty( \"maven.home\" );\n        if ( mavenHome != null )\n        {\n            System.setProperty( \"maven.home\", new File( mavenHome ).getAbsolutePath() );\n        }\n\n        MavenExecutionRequest request = CLIRequestUtils.buildRequest( commandLine, debug, quiet, showErrors );\n\n        Configuration configuration = buildEmbedderConfiguration( request, commandLine, classWorld );\n\n        MavenEmbedderLogger logger = configuration.getMavenEmbedderLogger();\n\n        if ( debug || commandLine.hasOption( CLIManager.SHOW_VERSION ) )\n        {\n            CLIReportingUtils.showVersion();\n        }\n\n        if ( showErrors )\n        {\n            logger.info( \"Error stacktraces are turned on.\" );\n        }\n\n        if ( MavenExecutionRequest.CHECKSUM_POLICY_WARN.equals( request.getGlobalChecksumPolicy() ) )\n        {\n            logger.info( \"Disabling strict checksum verification on all artifact downloads.\" );\n        }\n        else if ( MavenExecutionRequest.CHECKSUM_POLICY_FAIL.equals( request.getGlobalChecksumPolicy() ) )\n        {\n            logger.info( \"Enabling strict checksum verification on all artifact downloads.\" );\n        }\n\n        ConfigurationValidationResult cvr = MavenEmbedder.validateConfiguration( configuration );\n\n        if ( cvr.isUserSettingsFilePresent() && !cvr.isUserSettingsFileParses() )\n        {\n            CLIReportingUtils.showError( logger, \"Error reading user settings: \", cvr.getUserSettingsException(),\n                                         showErrors );\n\n            return 1;\n        }\n\n        if ( cvr.isGlobalSettingsFilePresent() && !cvr.isGlobalSettingsFileParses() )\n        {\n            CLIReportingUtils.showError( logger, \"Error reading global settings: \", cvr.getGlobalSettingsException(),\n                                         showErrors );\n\n            return 1;\n        }\n\n        if ( configuration.getGlobalSettingsFile() != null )\n        {\n            request.setGlobalSettingsFile( configuration.getGlobalSettingsFile() );\n        }\n\n        if ( configuration.getUserSettingsFile() != null )\n        {\n            request.setUserSettingsFile( configuration.getUserSettingsFile() );\n        }\n\n        MavenEmbedder mavenEmbedder;\n\n        try\n        {\n            mavenEmbedder = new MavenEmbedder( configuration );\n        }\n        catch ( MavenEmbedderException e )\n        {\n            CLIReportingUtils.showError( logger, \"Unable to start the embedder: \", e, showErrors );\n\n            return 1;\n        }\n\n        try\n        {\n            if ( commandLine.hasOption( CLIManager.ENCRYPT_MASTER_PASSWORD ) )\n            {\n                String passwd = commandLine.getOptionValue( CLIManager.ENCRYPT_MASTER_PASSWORD );\n\n                DefaultPlexusCipher cipher = new DefaultPlexusCipher();\n\n                System.out.println( cipher.encryptAndDecorate( passwd,\n                                                               DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION ) );\n\n                return 0;\n            }\n            else if ( commandLine.hasOption( CLIManager.ENCRYPT_PASSWORD ) )\n            {\n                String passwd = commandLine.getOptionValue( CLIManager.ENCRYPT_PASSWORD );\n\n                DefaultSecDispatcher dispatcher;\n                dispatcher = (DefaultSecDispatcher) mavenEmbedder.getPlexusContainer().lookup( SecDispatcher.class );\n                String configurationFile = dispatcher.getConfigurationFile();\n                if ( configurationFile.startsWith( \"~\" ) )\n                {\n                    configurationFile = System.getProperty( \"user.home\" ) + configurationFile.substring( 1 );\n                }\n                String file = System.getProperty( DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION, configurationFile );\n                mavenEmbedder.getPlexusContainer().release( dispatcher );\n\n                String master = null;\n\n                SettingsSecurity sec = SecUtil.read( file, true );\n                if ( sec != null )\n                {\n                    master = sec.getMaster();\n                }\n\n                if ( master == null )\n                {\n                    System.err.println( \"Master password is not set in the setting security file\" );\n\n                    return 1;\n                }\n\n                DefaultPlexusCipher cipher = new DefaultPlexusCipher();\n                String masterPasswd =\n                    cipher.decryptDecorated( master, DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION );\n                System.out.println( cipher.encryptAndDecorate( passwd, masterPasswd ) );\n\n                return 0;\n            }\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"FATAL ERROR: \" + \"Error encrypting password: \" + e.getMessage() );\n            e.printStackTrace();\n\n            return 1;\n        }\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        try\n        {\n            mavenEmbedder.stop();\n        }\n        catch ( MavenEmbedderException e )\n        {\n            result.addException( e );\n        }\n\n        // The exception handling should be handled in Maven itself.\n\n        if ( result.hasExceptions() )\n        {\n            ExceptionSummary es = result.getExceptionSummary();\n\n            if ( es == null )\n            {\n                logger.error( \"\", result.getExceptions().get( 0 ) );\n            }\n            else\n            {\n                if ( showErrors )\n                {\n                    logger.error( es.getMessage(), es.getException() );\n                }\n                else\n                {\n                    logger.error( es.getMessage() );\n                }\n            }\n\n            if ( MavenExecutionRequest.REACTOR_FAIL_NEVER.equals( request.getReactorFailureBehavior() ) )\n            {\n                logger.info( \"Build failures were ignored.\" );\n\n                return 0;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n        else\n        {\n            return 0;\n        }\n    }","commit_id":"977d3bccdccc203f413790269d6d0c9f71442ad0","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Execute a list of tasks. Each task may be a phase in the lifecycle or the\n     * execution of a mojo.\n     *\n     * @param tasks\n     * @param session\n     */\n    public MavenExecutionResponse execute( List tasks, MavenSession session )\n    {\n        MavenExecutionResponse response = new MavenExecutionResponse();\n\n        response.setStart( new Date() );\n\n        Map phaseMap = new HashMap();\n\n        for ( Iterator i = phases.iterator(); i.hasNext(); )\n        {\n            Phase p = (Phase) i.next();\n\n            // Make a copy of the phase as we will modify it\n            phaseMap.put( p.getId(), new Phase( p ) );\n        }\n\n        try\n        {\n            MavenProject project = session.getProject();\n\n            ArtifactHandler artifactHandler = artifactHandlerManager.getArtifactHandler( project.getPackaging() );\n\n            if ( artifactHandler != null )\n            {\n                if ( artifactHandler.packageGoal() != null )\n                {\n                    verifyMojoPhase( artifactHandler.packageGoal(), session, phaseMap );\n                }\n\n                if ( artifactHandler.additionalPlugin() != null )\n                {\n                    String additionalPluginGroupId = \"maven\";\n\n                    String additionalPluginArtifactId = \"maven-\" + artifactHandler.additionalPlugin() + \"-plugin\";\n\n                    injectHandlerPluginConfiguration( project, additionalPluginGroupId, additionalPluginArtifactId );\n\n                    Plugin plugin = new Plugin();\n\n                    plugin.setGroupId( additionalPluginGroupId );\n\n                    plugin.setArtifactId( additionalPluginArtifactId );\n\n                    processPluginPhases( plugin, session, phaseMap );\n                }\n            }\n\n            processPluginConfiguration( session.getProject(), session, phaseMap );\n\n            for ( Iterator i = tasks.iterator(); i.hasNext(); )\n            {\n                String task = (String) i.next();\n\n                processGoalChain( task, session, phaseMap );\n\n                if ( phaseMap.containsKey( task ) )\n                {\n                    executePhase( task, session, response, phaseMap );\n                }\n                else\n                {\n                    PluginExecutionResponse pluginResponse = executeMojo( task, session );\n\n                    if ( pluginResponse.isExecutionFailure() )\n                    {\n                        response.setExecutionFailure( task, pluginResponse.getFailureResponse() );\n                    }\n                }\n                if ( response.isExecutionFailure() )\n                {\n                    break;\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            response.setException( e );\n        }\n        finally\n        {\n            response.setFinish( new Date() );\n        }\n\n        return response;\n    }","id":43765,"modified_method":"/**\n     * Execute a list of tasks. Each task may be a phase in the lifecycle or the\n     * execution of a mojo.\n     *\n     * @param tasks\n     * @param session\n     */\n    public MavenExecutionResponse execute( List tasks, MavenSession session )\n        throws LifecycleExecutionException\n    {\n        MavenExecutionResponse response = new MavenExecutionResponse();\n\n        response.setStart( new Date() );\n\n        Map phaseMap = new HashMap();\n\n        for ( Iterator i = phases.iterator(); i.hasNext(); )\n        {\n            Phase p = (Phase) i.next();\n\n            // Make a copy of the phase as we will modify it\n            phaseMap.put( p.getId(), new Phase( p ) );\n        }\n\n        try\n        {\n            MavenProject project = session.getProject();\n\n            ArtifactHandler artifactHandler = artifactHandlerManager.getArtifactHandler( project.getPackaging() );\n\n            if ( artifactHandler != null )\n            {\n                if ( artifactHandler.packageGoal() != null )\n                {\n                    verifyMojoPhase( artifactHandler.packageGoal(), session, phaseMap );\n                }\n\n                if ( artifactHandler.additionalPlugin() != null )\n                {\n                    String additionalPluginGroupId = \"maven\";\n\n                    String additionalPluginArtifactId = \"maven-\" + artifactHandler.additionalPlugin() + \"-plugin\";\n\n                    injectHandlerPluginConfiguration( project, additionalPluginGroupId, additionalPluginArtifactId );\n\n                    Plugin plugin = new Plugin();\n\n                    plugin.setGroupId( additionalPluginGroupId );\n\n                    plugin.setArtifactId( additionalPluginArtifactId );\n\n                    processPluginPhases( plugin, session, phaseMap );\n                }\n            }\n\n            processPluginConfiguration( session.getProject(), session, phaseMap );\n\n            for ( Iterator i = tasks.iterator(); i.hasNext(); )\n            {\n                String task = (String) i.next();\n\n                processGoalChain( task, session, phaseMap );\n\n                if ( phaseMap.containsKey( task ) )\n                {\n                    executePhase( task, session, phaseMap );\n                }\n                else\n                {\n                    executeMojo( task, session );\n                }\n            }\n        }\n        catch ( PluginExecutionException e )\n        {\n            response.setException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new LifecycleExecutionException( \"Error during lifecycle execution\", e );\n        }\n        finally\n        {\n            response.setFinish( new Date() );\n        }\n\n        return response;\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"private void executePhase( String phase, MavenSession session, MavenExecutionResponse response, Map phaseMap )\n        throws LifecycleExecutionException\n    {\n        // only execute up to the given phase\n        int index = phases.indexOf( phaseMap.get( phase ) );\n\n        EventDispatcher dispatcher = session.getEventDispatcher();\n\n        for ( int j = 0; j <= index; j++ )\n        {\n            Phase p = (Phase) phases.get( j );\n\n            p = (Phase) phaseMap.get( p.getId() );\n\n            String event = MavenEvents.PHASE_EXECUTION;\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            dispatcher.dispatchStart( event, p.getId() );\n            try\n            {\n                if ( p.getGoals() != null )\n                {\n                    for ( Iterator i = p.getGoals().iterator(); i.hasNext(); )\n                    {\n                        String goal = (String) i.next();\n\n                        PluginExecutionResponse pluginResponse = executeMojo( goal, session );\n\n                        if ( pluginResponse.isExecutionFailure() )\n                        {\n                            response.setExecutionFailure( goal, pluginResponse.getFailureResponse() );\n\n                            return;\n                        }\n                    }\n                }\n\n                dispatcher.dispatchEnd( event, p.getId() );\n            }\n            catch ( LifecycleExecutionException e )\n            {\n                dispatcher.dispatchError( event, p.getId(), e );\n\n                throw e;\n            }\n            // End event monitoring.\n        }\n    }","id":43766,"modified_method":"private void executePhase( String phase, MavenSession session, Map phaseMap )\n        throws PluginExecutionException\n    {\n        // only execute up to the given phase\n        int index = phases.indexOf( phaseMap.get( phase ) );\n\n        EventDispatcher dispatcher = session.getEventDispatcher();\n\n        for ( int j = 0; j <= index; j++ )\n        {\n            Phase p = (Phase) phases.get( j );\n\n            p = (Phase) phaseMap.get( p.getId() );\n\n            String event = MavenEvents.PHASE_EXECUTION;\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            dispatcher.dispatchStart( event, p.getId() );\n            try\n            {\n                if ( p.getGoals() != null )\n                {\n                    for ( Iterator i = p.getGoals().iterator(); i.hasNext(); )\n                    {\n                        String goal = (String) i.next();\n\n                        executeMojo( goal, session );\n                    }\n                }\n            }\n            catch ( PluginExecutionException e )\n            {\n                dispatcher.dispatchError( event, p.getId(), e );\n                throw e;\n            }\n\n            dispatcher.dispatchEnd( event, p.getId() );\n        }\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"protected PluginExecutionResponse executeMojo( String id, MavenSession session )\n        throws LifecycleExecutionException\n    {\n        // ----------------------------------------------------------------------\n        // We have something of the form <pluginId>:<mojoId>, so this might be\n        // something like:\n        //\n        // clean:clean\n        // idea:idea\n        // archetype:create\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            Logger logger = getLogger();\n            logger.debug( \"Resolving artifacts from:\\n\" + \"\\t{localRepository: \" + session.getLocalRepository() +\n                          \"}\\n\" + \"\\t{remoteRepositories: \" + session.getRemoteRepositories() + \"}\" );\n\n            return pluginManager.executeMojo( session, id );\n        }\n        catch ( GoalExecutionException e )\n        {\n            throw new LifecycleExecutionException( \"Problem executing \" + id, e );\n        }\n    }","id":43767,"modified_method":"protected void executeMojo( String id, MavenSession session )\n        throws PluginExecutionException\n    {\n        // ----------------------------------------------------------------------\n        // We have something of the form <pluginId>:<mojoId>, so this might be\n        // something like:\n        //\n        // clean:clean\n        // idea:idea\n        // archetype:create\n        // ----------------------------------------------------------------------\n\n        Logger logger = getLogger();\n        logger.debug( \"Resolving artifacts from:\" );\n        logger.debug( \"\\t{localRepository: \" + session.getLocalRepository() + \"}\" );\n        logger.debug( \"\\t{remoteRepositories: \" + session.getRemoteRepositories() + \"}\" );\n\n        pluginManager.executeMojo( session, id );\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"private MavenExecutionResponse processProject( MavenExecutionRequest request, MavenProject project,\n                                                   EventDispatcher dispatcher, List goals )\n        throws Exception\n    {\n        MavenSession session = createSession( request );\n\n        session.setProject( project );\n\n        session.setRemoteRepositories( getArtifactRepositories( project, request.getSettings() ) );\n\n        resolveParameters( request );\n\n        // !! This is ripe for refactoring to an aspect.\n        // Event monitoring.\n        String event = MavenEvents.PROJECT_EXECUTION;\n\n        dispatcher.dispatchStart( event, project.getId() );\n\n        MavenExecutionResponse response = null;\n        try\n        {\n            // Actual meat of the code.\n            response = lifecycleExecutor.execute( goals, session );\n\n            dispatcher.dispatchEnd( event, project.getId() );\n        }\n        catch ( Exception e )\n        {\n            dispatcher.dispatchError( event, project.getId(), e );\n            throw e;\n        }\n        // End event monitoring.\n\n        // TODO: is this perhaps more appropriate in the CLI?\n        if ( response.isExecutionFailure() )\n        {\n            if ( response.getException() != null )\n            {\n                // TODO: this should be a \"FATAL\" exception, reported to the\n                // developers - however currently a LOT of\n                // \"user\" errors fall through the cracks (like invalid POMs, as\n                // one example)\n                logError( response );\n            }\n            else\n            {\n                logFailure( response );\n            }\n        }\n        else\n        {\n            logSuccess( response );\n        }\n        return response;\n    }","id":43768,"modified_method":"private MavenExecutionResponse processProject( MavenExecutionRequest request, MavenProject project,\n                                                   EventDispatcher dispatcher, List goals )\n        throws Exception\n    {\n        MavenSession session = createSession( request );\n\n        session.setProject( project );\n\n        session.setRemoteRepositories( getArtifactRepositories( project, request.getSettings() ) );\n\n        resolveParameters( request );\n\n        // !! This is ripe for refactoring to an aspect.\n        // Event monitoring.\n        String event = MavenEvents.PROJECT_EXECUTION;\n\n        dispatcher.dispatchStart( event, project.getId() );\n\n        MavenExecutionResponse response = null;\n        try\n        {\n            // Actual meat of the code.\n            response = lifecycleExecutor.execute( goals, session );\n\n            dispatcher.dispatchEnd( event, project.getId() );\n        }\n        catch ( Exception e )\n        {\n            dispatcher.dispatchError( event, project.getId(), e );\n            throw e;\n        }\n        // End event monitoring.\n\n        // TODO: is this perhaps more appropriate in the CLI?\n        if ( response.isExecutionFailure() )\n        {\n            // TODO: yuck! Revisit when cleaning up the exception handling from the top down\n            if ( response.getException() instanceof PluginExecutionException )\n            {\n                logFailure( response, (PluginExecutionException) response.getException() );\n            }\n            else\n            {\n                // TODO: this should be a \"FATAL\" exception, reported to the\n                // developers - however currently a LOT of\n                // \"user\" errors fall through the cracks (like invalid POMs, as\n                // one example)\n                logError( response );\n            }\n        }\n        else\n        {\n            logSuccess( response );\n        }\n        return response;\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"protected void logFailure( MavenExecutionResponse r )\n    {\n        line();\n\n        getLogger().info( \"BUILD FAILURE\" );\n\n        line();\n\n        getLogger().info( \"Reason: \" + r.getFailureResponse().shortMessage() );\n\n        line();\n\n        getLogger().info( r.getFailureResponse().longMessage() );\n\n        line();\n\n        stats( r.getStart(), r.getFinish() );\n\n        line();\n    }","id":43769,"modified_method":"protected void logFailure( MavenExecutionResponse r, PluginExecutionException e )\n    {\n        line();\n\n        getLogger().info( \"BUILD FAILURE\" );\n\n        line();\n\n        getLogger().info( \"Reason: \" + e.getMessage() );\n\n        line();\n\n        getLogger().info( e.getLongMessage() );\n\n        line();\n\n        stats( r.getStart(), r.getFinish() );\n\n        line();\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"public PluginExecutionResponse executeMojo( MavenSession session, String goalName )\n        throws GoalExecutionException\n    {\n        try\n        {\n            verifyPluginForGoal( goalName, session );\n        }\n        catch ( Exception e )\n        {\n            throw new GoalExecutionException( \"Unable to execute goal: \" + goalName, e );\n        }\n\n        PluginExecutionRequest request;\n\n        PluginExecutionResponse response;\n\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( goalName );\n        if ( mojoDescriptor == null )\n        {\n            throw new GoalExecutionException( \"Unable to find goal: \" + goalName );\n        }\n\n        try\n        {\n            if ( mojoDescriptor.requiresDependencyResolution() )\n            {\n\n                ArtifactResolver artifactResolver = null;\n                MavenProjectBuilder mavenProjectBuilder = null;\n\n                try\n                {\n                    artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                    mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                    resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder );\n                    downloadDependencies( session, artifactResolver );\n                }\n                finally\n                {\n                    // TODO: watch out for the exceptions being thrown\n                    if ( artifactResolver != null )\n                    {\n                        container.release( artifactResolver );\n                    }\n                    if ( mavenProjectBuilder != null )\n                    {\n                        container.release( mavenProjectBuilder );\n                    }\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new GoalExecutionException( \"Unable to resolve required dependencies for goal\", e );\n        }\n\n        try\n        {\n            request = new PluginExecutionRequest( createParameters( mojoDescriptor, session ) );\n\n            request.setLog( session.getLog() );\n        }\n        catch ( PluginConfigurationException e )\n        {\n            throw new GoalExecutionException( \"Error configuring plugin for execution.\", e );\n        }\n\n        response = new PluginExecutionResponse();\n\n        Plugin plugin = null;\n\n        try\n        {\n            plugin = (Plugin) container.lookup( Plugin.ROLE, goalName );\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n\n            dispatcher.dispatchStart( event, goalName );\n            try\n            {\n                plugin.execute( request, response );\n\n                dispatcher.dispatchEnd( event, goalName );\n            }\n            catch ( Exception e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalName, e );\n                throw e;\n            }\n            // End event monitoring.\n\n            releaseComponents( mojoDescriptor, request );\n\n            container.release( plugin );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new GoalExecutionException( \"Error looking up plugin: \", e );\n        }\n        catch ( Exception e )\n        {\n            throw new GoalExecutionException( \"Error executing plugin: \", e );\n        }\n\n        return response;\n    }","id":43770,"modified_method":"public void executeMojo( MavenSession session, String goalName )\n        throws PluginExecutionException\n    {\n        try\n        {\n            verifyPluginForGoal( goalName, session );\n        }\n        catch ( Exception e )\n        {\n            throw new PluginExecutionException( \"Unable to execute goal: \" + goalName, e );\n        }\n\n        PluginExecutionRequest request;\n\n        PluginExecutionResponse response;\n\n        MojoDescriptor mojoDescriptor = getMojoDescriptor( goalName );\n        if ( mojoDescriptor == null )\n        {\n            throw new PluginExecutionException( \"Unable to find goal: \" + goalName );\n        }\n\n        try\n        {\n            if ( mojoDescriptor.requiresDependencyResolution() )\n            {\n\n                ArtifactResolver artifactResolver = null;\n                MavenProjectBuilder mavenProjectBuilder = null;\n\n                try\n                {\n                    artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                    mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                    resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder );\n                    downloadDependencies( session, artifactResolver );\n                }\n                finally\n                {\n                    // TODO: watch out for the exceptions being thrown\n                    if ( artifactResolver != null )\n                    {\n                        container.release( artifactResolver );\n                    }\n                    if ( mavenProjectBuilder != null )\n                    {\n                        container.release( mavenProjectBuilder );\n                    }\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new PluginExecutionException( \"Unable to resolve required dependencies for goal\", e );\n        }\n\n        try\n        {\n            request = new PluginExecutionRequest( createParameters( mojoDescriptor, session ) );\n\n            request.setLog( session.getLog() );\n        }\n        catch ( PluginConfigurationException e )\n        {\n            throw new PluginExecutionException( \"Error configuring plugin for execution.\", e );\n        }\n\n        Plugin plugin = null;\n\n        try\n        {\n            plugin = (Plugin) container.lookup( Plugin.ROLE, goalName );\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n\n            dispatcher.dispatchStart( event, goalName );\n            try\n            {\n                plugin.execute( request );\n\n                dispatcher.dispatchEnd( event, goalName );\n            }\n            catch ( PluginExecutionException e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalName, e );\n                throw e;\n            }\n            // End event monitoring.\n\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new PluginExecutionException( \"Error looking up plugin: \", e );\n        }\n        finally\n        {\n            try\n            {\n                releaseComponents( mojoDescriptor, request );\n\n                container.release( plugin );\n            }\n            catch ( Exception e )\n            {\n                // TODO: better error handling, needed!\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"private void downloadDependencies( MavenSession context, ArtifactResolver artifactResolver )\n        throws GoalExecutionException\n    {\n        try\n        {\n            for ( Iterator it = context.getProject().getArtifacts().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n\n                artifactResolver.resolve( artifact, context.getRemoteRepositories(), context.getLocalRepository() );\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new GoalExecutionException( \"Can't resolve artifact: \", e );\n        }\n    }","id":43771,"modified_method":"private void downloadDependencies( MavenSession context, ArtifactResolver artifactResolver )\n        throws ArtifactResolutionException\n    {\n            for ( Iterator it = context.getProject().getArtifacts().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n\n                artifactResolver.resolve( artifact, context.getRemoteRepositories(), context.getLocalRepository() );\n            }\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"public void execute(PluginExecutionRequest request, PluginExecutionResponse response) throws Exception {\n        this.executed = true;\n    }","id":43772,"modified_method":"public void execute(PluginExecutionRequest request) throws PluginExecutionException {\n        this.executed = true;\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        name = (String) request.getParameter( \"name\" );\n\n        artifactId = (String) request.getParameter( \"artifactId\" );\n\n        foo = (String) request.getParameter( \"foo\" );\n\n        executed = true;\n    }","id":43773,"modified_method":"public void execute( PluginExecutionRequest request )\n        throws PluginExecutionException\n    {\n        name = (String) request.getParameter( \"name\" );\n\n        artifactId = (String) request.getParameter( \"artifactId\" );\n\n        foo = (String) request.getParameter( \"foo\" );\n\n        executed = true;\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"public boolean isExecutionFailure()\n    {\n        return ( failedGoal != null || exception != null );\n    }","id":43774,"modified_method":"public boolean isExecutionFailure()\n    {\n        return ( exception != null );\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"public void testPlugin()\n        throws Exception\n    {\n        setupPlugin();\n\n        request = new PluginExecutionRequest( getTestParameters() );\n\n        response = new PluginExecutionResponse();\n\n        plugin.execute( request, response );\n\n        validatePluginExecution();\n    }","id":43775,"modified_method":"public void testPlugin()\n        throws Exception\n    {\n        setupPlugin();\n\n        request = new PluginExecutionRequest( getTestParameters() );\n\n        plugin.execute( request );\n\n        validatePluginExecution();\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        name = (String) request.getParameter( \"name\" );\n\n        artifactId = (String) request.getParameter( \"artifactId\" );\n\n        foo = (String) request.getParameter( \"foo\" );\n\n        executed = true;\n    }","id":43776,"modified_method":"public void execute( PluginExecutionRequest request )\n        throws PluginExecutionException\n    {\n        name = (String) request.getParameter( \"name\" );\n\n        artifactId = (String) request.getParameter( \"artifactId\" );\n\n        foo = (String) request.getParameter( \"foo\" );\n\n        executed = true;\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"public void testIntegratedPluginExecution()\n        throws Exception\n    {\n        TestPlugin plugin = new TestPlugin();\n\n        Map parameters = new HashMap();\n\n        parameters.put( \"name\", \"Maven\" );\n\n        parameters.put( \"artifactId\", \"maven-core\" );\n\n        parameters.put( \"foo\", \"bar\" );\n\n        PluginExecutionRequest request = new PluginExecutionRequest( parameters );\n\n        PluginExecutionResponse response = new PluginExecutionResponse();\n\n        plugin.execute( request, response );\n\n        assertTrue( plugin.hasExecuted() );\n\n        assertEquals( \"Maven\", plugin.getName() );\n\n        assertEquals( \"maven-core\", plugin.getArtifactId() );\n\n        assertEquals( \"bar\", plugin.getFoo() );\n    }","id":43777,"modified_method":"public void testIntegratedPluginExecution()\n        throws Exception\n    {\n        TestPlugin plugin = new TestPlugin();\n\n        Map parameters = new HashMap();\n\n        parameters.put( \"name\", \"Maven\" );\n\n        parameters.put( \"artifactId\", \"maven-core\" );\n\n        parameters.put( \"foo\", \"bar\" );\n\n        PluginExecutionRequest request = new PluginExecutionRequest( parameters );\n\n        plugin.execute( request );\n\n        assertTrue( plugin.hasExecuted() );\n\n        assertEquals( \"Maven\", plugin.getName() );\n\n        assertEquals( \"maven-core\", plugin.getArtifactId() );\n\n        assertEquals( \"bar\", plugin.getFoo() );\n    }","commit_id":"a593e7df887fc7e7f525e22469be9559de7957f0","url":"https://github.com/apache/maven"},{"original_method":"@Override\n    public Set<String> existsByIds(Set<String> ids) {\n        if (ids == null || ids.size() == 0) return new HashSet<String>();\n        if (ids.size() == 1) return existsById(ids.iterator().next()) ? ids : new HashSet<String>();\n        Set<String> idsr = new TreeSet<String>();\n        final SolrQuery params = new SolrQuery();\n        params.setRows(0);\n        params.setStart(0);\n        params.setFacet(false);\n        params.clearSorts();\n        params.setFields(CollectionSchema.id.getSolrFieldName());\n        params.setIncludeScore(false);\n        SolrQueryRequest req = new SolrQueryRequestBase(this.core, params){};\n        req.getContext().put(\"path\", SELECT);\n        req.getContext().put(\"webapp\", CONTEXT);\n        for (String id: ids) {\n            params.setQuery(\"{!raw f=\" + CollectionSchema.id.getSolrFieldName() + \"}\" + id);\n            SolrQueryResponse rsp = new SolrQueryResponse();\n            this.requestHandler.handleRequest(req, rsp);\n            DocList response = ((ResultContext) rsp.getValues().get(\"response\")).docs;\n            if (response.matches() > 0) idsr.add(id);\n        }\n        req.close();\n        return idsr;\n    }","id":43778,"modified_method":"@Override\n    public Set<String> existsByIds(Set<String> ids) {\n        if (ids == null || ids.size() == 0) return new HashSet<String>();\n        if (ids.size() == 1) return existsById(ids.iterator().next()) ? ids : new HashSet<String>();\n        Set<String> idsr = new TreeSet<String>();\n        final SolrQuery params = new SolrQuery();\n        params.setRows(0);\n        params.setStart(0);\n        params.setFacet(false);\n        params.clearSorts();\n        params.setFields(CollectionSchema.id.getSolrFieldName());\n        params.setIncludeScore(false);\n        SolrQueryRequest req = new SolrQueryRequestBase(this.core, params){};\n        req.getContext().put(\"path\", SELECT);\n        req.getContext().put(\"webapp\", CONTEXT);\n        try {\n\t        for (String id: ids) {\n\t            params.setQuery(\"{!raw f=\" + CollectionSchema.id.getSolrFieldName() + \"}\" + id);\n\t            SolrQueryResponse rsp = new SolrQueryResponse();\n\t            this.requestHandler.handleRequest(req, rsp);\n\t            DocList response = ((ResultContext) rsp.getValues().get(\"response\")).docs;\n\t            if (response.matches() > 0) idsr.add(id);\n\t        }\n        } finally {\n        \treq.close();\n        }\n        return idsr;\n    }","commit_id":"2c2ebb0d9218098e102b3a44432846493ec7fc05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n        if (!(request instanceof HttpServletRequest)) {\n            if (chain != null) chain.doFilter(request, response);\n            return;\n        }\n\n        HttpServletRequest hrequest = (HttpServletRequest) request;\n        HttpServletResponse hresponse = (HttpServletResponse) response;\n        SolrQueryRequest req = null;\n\n        // check if this servlet was called correctly\n        String pathInfo = hrequest.getPathInfo();\n        String path = pathInfo == null ? hrequest.getServletPath() : hrequest.getServletPath() + pathInfo; // should be \"/select\" after this\n\n        if (!EmbeddedSolrConnector.SELECT.equals(path)) {\n            // this is not for this servlet\n            if (chain != null) chain.doFilter(request, response);\n            return;\n        }\n        if (!EmbeddedSolrConnector.CONTEXT.equals(hrequest.getContextPath())) {\n            // this is not for this servlet\n            if (chain != null) chain.doFilter(request, response);\n            return;\n        }\n\n        // reject POST which is not supported here\n        final Method reqMethod = Method.getMethod(hrequest.getMethod());\n        if (reqMethod == null || (reqMethod != Method.GET && reqMethod != Method.HEAD)) {\n            throw new ServletException(\"Unsupported method: \" + hrequest.getMethod());\n        }\n\n        try {\n            SolrCore core = connector.getCore();\n            if (core == null) {\n                throw new UnsupportedOperationException(\"core not initialized\");\n            }\n\n            // prepare request to solr\n            hrequest.setAttribute(\"org.apache.solr.CoreContainer\", core);\n            MultiMapSolrParams mmsp = SolrRequestParsers.parseQueryString(hrequest.getQueryString());\n            req = connector.request(mmsp);\n\n            SolrQueryResponse rsp = connector.query(req);\n\n            // prepare response\n            hresponse.setHeader(\"Cache-Control\", \"no-cache\");\n            HttpCacheHeaderUtil.checkHttpCachingVeto(rsp, hresponse, reqMethod);\n\n            // check error\n            if (rsp.getException() != null) {\n                sendError(hresponse, rsp.getException());\n                return;\n            }\n\n            // write response header\n            final String contentType = responseWriter.getContentType(req, rsp);\n            if (null != contentType) response.setContentType(contentType);\n\n            if (Method.HEAD == reqMethod) {\n                return;\n            }\n\n            // write response body\n            Writer out = new FastWriter(new OutputStreamWriter(response.getOutputStream(), UTF8.charset));\n\n            //debug\n            @SuppressWarnings(\"unchecked\")\n            Iterator<Map.Entry<String, Object>> ie = rsp.getValues().iterator();\n            Map.Entry<String, Object> e;\n            while (ie.hasNext()) {\n                e = ie.next();\n                System.out.println(\"Field: \" + e.getKey() + \", value: \" + e.getValue().getClass().getName());\n                //Field: responseHeader, value: org.apache.solr.common.util.SimpleOrderedMap\n                //Field: response, value: org.apache.solr.search.DocSlice\n                if (e.getValue() instanceof DocList) {\n                    DocList ids = (DocList) e.getValue();\n                    SolrIndexSearcher searcher = req.getSearcher();\n                    DocIterator iterator = ids.iterator();\n                    int sz = ids.size();\n                    for (int i = 0; i < sz; i++) {\n                        int id = iterator.nextDoc();\n                        searcher.doc(id);\n                    }\n                }\n            }\n\n            responseWriter.write(out, req, rsp);\n            out.flush();\n            return;\n\n        } catch (final Throwable ex) {\n            sendError(hresponse, ex);\n            return;\n        } finally {\n            if (req != null) {\n                req.close();\n            }\n            SolrRequestInfo.clearRequestInfo();\n        }\n    }","id":43779,"modified_method":"@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\n        if (!(request instanceof HttpServletRequest)) {\n            if (chain != null) chain.doFilter(request, response);\n            return;\n        }\n\n        HttpServletRequest hrequest = (HttpServletRequest) request;\n        HttpServletResponse hresponse = (HttpServletResponse) response;\n        SolrQueryRequest req = null;\n\n        // check if this servlet was called correctly\n        String pathInfo = hrequest.getPathInfo();\n        String path = pathInfo == null ? hrequest.getServletPath() : hrequest.getServletPath() + pathInfo; // should be \"/select\" after this\n\n        if (!EmbeddedSolrConnector.SELECT.equals(path)) {\n            // this is not for this servlet\n            if (chain != null) chain.doFilter(request, response);\n            return;\n        }\n        if (!EmbeddedSolrConnector.CONTEXT.equals(hrequest.getContextPath())) {\n            // this is not for this servlet\n            if (chain != null) chain.doFilter(request, response);\n            return;\n        }\n\n        // reject POST which is not supported here\n        final Method reqMethod = Method.getMethod(hrequest.getMethod());\n        if (reqMethod == null || (reqMethod != Method.GET && reqMethod != Method.HEAD)) {\n            throw new ServletException(\"Unsupported method: \" + hrequest.getMethod());\n        }\n        \n        Writer out = null;\n        try {\n            SolrCore core = connector.getCore();\n            if (core == null) {\n                throw new UnsupportedOperationException(\"core not initialized\");\n            }\n\n            // prepare request to solr\n            hrequest.setAttribute(\"org.apache.solr.CoreContainer\", core);\n            MultiMapSolrParams mmsp = SolrRequestParsers.parseQueryString(hrequest.getQueryString());\n            req = connector.request(mmsp);\n\n            SolrQueryResponse rsp = connector.query(req);\n\n            // prepare response\n            hresponse.setHeader(\"Cache-Control\", \"no-cache\");\n            HttpCacheHeaderUtil.checkHttpCachingVeto(rsp, hresponse, reqMethod);\n\n            // check error\n            if (rsp.getException() != null) {\n                sendError(hresponse, rsp.getException());\n                return;\n            }\n\n            // write response header\n            final String contentType = responseWriter.getContentType(req, rsp);\n            if (null != contentType) response.setContentType(contentType);\n\n            if (Method.HEAD == reqMethod) {\n                return;\n            }\n\n            // write response body\n            out = new FastWriter(new OutputStreamWriter(response.getOutputStream(), UTF8.charset));\n\n            //debug\n            @SuppressWarnings(\"unchecked\")\n            Iterator<Map.Entry<String, Object>> ie = rsp.getValues().iterator();\n            Map.Entry<String, Object> e;\n            while (ie.hasNext()) {\n                e = ie.next();\n                System.out.println(\"Field: \" + e.getKey() + \", value: \" + e.getValue().getClass().getName());\n                //Field: responseHeader, value: org.apache.solr.common.util.SimpleOrderedMap\n                //Field: response, value: org.apache.solr.search.DocSlice\n                if (e.getValue() instanceof DocList) {\n                    DocList ids = (DocList) e.getValue();\n                    SolrIndexSearcher searcher = req.getSearcher();\n                    DocIterator iterator = ids.iterator();\n                    int sz = ids.size();\n                    for (int i = 0; i < sz; i++) {\n                        int id = iterator.nextDoc();\n                        searcher.doc(id);\n                    }\n                }\n            }\n\n            responseWriter.write(out, req, rsp);\n            out.flush();\n        } catch (final Throwable ex) {\n            sendError(hresponse, ex);\n        } finally {\n            if (req != null) {\n                req.close();\n            }\n            SolrRequestInfo.clearRequestInfo();\n            if (out != null) try {out.close();} catch (final IOException e1) {}\n        }\n    }","commit_id":"2c2ebb0d9218098e102b3a44432846493ec7fc05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * @param header\n     * @param post\n     * @param env\n     * @param out\n     * @return\n     */\n    public static serverObjects respond(final RequestHeader header, serverObjects post, final serverSwitch env, final OutputStream out) {\n\n        // this uses the methods in the jetty servlet environment and can be removed if jetty in implemented\n        Switchboard sb = (Switchboard) env;\n\n        // remember the peer contact for peer statistics\n        final String clientip = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"<unknown>\"); // read an artificial header addendum\n        final String userAgent = header.get(HeaderFramework.USER_AGENT, \"<unknown>\");\n        sb.peers.peerActions.setUserAgent(clientip, userAgent);\n\n        // check if user is allowed to search (can be switched in /ConfigPortal.html)\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final boolean searchAllowed = authenticated || sb.getConfigBool(\"publicSearchpage\", true);\n        if (!searchAllowed) return null;\n\n        // check post\n        if (post == null) {post = new serverObjects(); post.put(\"q\", \"\"); post.put(\"num\", \"0\");}\n        ConcurrentLog.info(\"GSA Query\", post.toString());\n        sb.intermissionAllThreads(3000); // tell all threads to do nothing for a specific time\n        \n        // rename post fields according to result style\n        //post.put(CommonParams.Q, post.remove(\"q\")); // same as solr\n        //post.put(CommonParams.START, post.remove(\"start\")); // same as solr\n        //post.put(, post.remove(\"client\"));//required, example: myfrontend\n        //post.put(, post.remove(\"output\"));//required, example: xml,xml_no_dtd\n        String originalQuery = post.get(CommonParams.Q, \"\");\n        post.put(\"originalQuery\", originalQuery);\n        \n        // get a solr query string\n        QueryGoal qg = new QueryGoal(originalQuery, originalQuery);\n        StringBuilder solrQ = qg.collectionTextQueryString(sb.index.fulltext().getDefaultConfiguration(), 0, false);\n        post.put(\"defType\", \"edismax\");\n        post.put(CommonParams.Q, solrQ.toString());\n        post.put(CommonParams.ROWS, post.remove(\"num\"));\n        post.put(CommonParams.ROWS, Math.min(post.getInt(CommonParams.ROWS, 10), (authenticated) ? 100000000 : 100));\n        \n        // set ranking\n        if (post.containsKey(\"sort\")) {\n            // if a gsa-style sort attribute is given, use this to set the solr sort attribute\n            GSAResponseWriter.Sort sort = new GSAResponseWriter.Sort(post.get(CommonParams.SORT, \"\"));\n            String sorts = sort.toSolr();\n            if (sorts == null) {\n                post.remove(CommonParams.SORT);\n            } else {\n                post.put(CommonParams.SORT, sorts);\n            }\n        } else {\n            // if no such sort attribute is given, use the ranking as configured for YaCy\n            Ranking ranking = sb.index.fulltext().getDefaultConfiguration().getRanking(0);\n            String bq = ranking.getBoostQuery();\n            String bf = ranking.getBoostFunction();\n            if (bq.length() > 0) post.put(\"bq\", bq);\n            if (bf.length() > 0) post.put(\"boost\", bf); // a boost function extension, see http://wiki.apache.org/solr/ExtendedDisMax#bf_.28Boost_Function.2C_additive.29\n        }\n        String daterange[] = post.remove(\"daterange\");\n        if (daterange != null) {\n            String origfq = post.get(CommonParams.FQ);\n            String datefq = \"\";\n            for (String dr: daterange) {\n                String from_to[] = dr.endsWith(\"..\") ? new String[]{dr.substring(0, dr.length() - 2), \"\"} : dr.startsWith(\"..\") ? new String[]{\"\", dr.substring(2)} : dr.split(\"\\\\.\\\\.\");\n                if (from_to.length != 2) continue;\n                Date from = HeaderFramework.parseGSAFS(from_to[0]);\n                if (from == null) from = new Date(0);\n                Date to = HeaderFramework.parseGSAFS(from_to[1]);\n                if (to == null) to = new Date();\n                to.setTime(to.getTime() + 24L * 60L * 60L * 1000L); // we add a day because the day is inclusive\n                String z = CollectionSchema.last_modified.getSolrFieldName() + \":[\" + ISO8601Formatter.FORMATTER.format(from) + \" TO \" + ISO8601Formatter.FORMATTER.format(to) + \"]\";\n                datefq = datefq.length() == 0 ? z : \" OR \" + z;\n            }\n            if (datefq.length() > 0) post.put(CommonParams.FQ, origfq == null || origfq.length() == 0 ? datefq : \"(\" + origfq + \") AND (\" + datefq + \")\");\n        }\n        post.put(CommonParams.FL,\n                CollectionSchema.content_type.getSolrFieldName() + ',' +\n                CollectionSchema.id.getSolrFieldName() + ',' +\n                CollectionSchema.sku.getSolrFieldName() + ',' +\n                CollectionSchema.title.getSolrFieldName() + ',' +\n                CollectionSchema.description_txt.getSolrFieldName() + ',' +\n                CollectionSchema.load_date_dt.getSolrFieldName() + ',' +\n                CollectionSchema.last_modified.getSolrFieldName() + ',' +\n                CollectionSchema.size_i.getSolrFieldName());\n        post.put(\"hl\", \"true\");\n        post.put(\"hl.q\", qg.getIncludeString());\n        post.put(\"hl.fl\", CollectionSchema.h1_txt.getSolrFieldName() + \",\" + CollectionSchema.h2_txt.getSolrFieldName() + \",\" + CollectionSchema.text_t.getSolrFieldName());\n        post.put(\"hl.alternateField\", CollectionSchema.description_txt.getSolrFieldName());\n        post.put(\"hl.simple.pre\", \"<b>\");\n        post.put(\"hl.simple.post\", \"<\/b>\");\n        post.put(\"hl.fragsize\", Integer.toString(SearchEvent.SNIPPET_MAX_LENGTH));\n        \n        //String[] access = post.remove(\"access\");\n        //String[] entqr = post.remove(\"entqr\");\n\n        // add sites operator\n        String[] site = post.remove(\"site\"); // example: col1|col2\n        if (site != null && site[0].length() > 0) {\n            String origfq = post.get(CommonParams.FQ);\n            String sitefq = QueryModifier.parseCollectionExpression(site[0]);\n            post.put(CommonParams.FQ, origfq == null || origfq.length() == 0 ? sitefq : \"(\" + origfq + \") AND (\" + sitefq + \")\");\n        }\n        \n        // get the embedded connector\n        EmbeddedSolrConnector connector = sb.index.fulltext().getDefaultEmbeddedConnector();\n        if (connector == null) return null;\n\n        // do the solr request\n        SolrQueryRequest req = connector.request(post.toSolrParams(null));\n        SolrQueryResponse response = null;\n        Exception e = null;\n        try {response = connector.query(req);} catch (final SolrException ee) {e = ee;}\n        if (response != null) e = response.getException();\n        if (e != null) {\n            ConcurrentLog.logException(e);\n            if (req != null) req.close();\n            SolrRequestInfo.clearRequestInfo();\n            return null;\n        }\n\n        // set some context for the writer\n        /*\n        Map<Object,Object> context = req.getContext();\n        context.put(\"ip\", header.get(\"CLIENTIP\", \"\"));\n        context.put(\"client\", \"vsm_frontent\");\n        context.put(\"sort\", sort.sort);\n        context.put(\"site\", site == null ? \"\" : site);\n        context.put(\"access\", access == null ? \"p\" : access[0]);\n        context.put(\"entqr\", entqr == null ? \"3\" : entqr[0]);\n        */\n        \n        // write the result directly to the output stream\n        Writer ow = new FastWriter(new OutputStreamWriter(out, UTF8.charset));\n        try {\n            responseWriter.write(ow, req, response);\n            ow.flush();\n        } catch (final IOException e1) {\n        } finally {\n            req.close();\n            SolrRequestInfo.clearRequestInfo();\n            try {ow.close();} catch (final IOException e1) {}\n        }\n\n        // log result\n        Object rv = response.getValues().get(\"response\");\n        int matches = 0;\n        if (rv != null && rv instanceof ResultContext) {\n            matches = ((ResultContext) rv).docs.matches();\n        } else if (rv != null && rv instanceof SolrDocumentList) {\n            matches = (int) ((SolrDocumentList) rv).getNumFound();\n        }\n        AccessTracker.addToDump(originalQuery, Integer.toString(matches));\n        ConcurrentLog.info(\"GSA Query\", \"results: \" + matches + \", for query:\" + post.toString());\n        \n        return null;\n    }","id":43780,"modified_method":"/**\n     * @param header\n     * @param post\n     * @param env\n     * @param out\n     * @return\n     */\n    public static serverObjects respond(final RequestHeader header, serverObjects post, final serverSwitch env, final OutputStream out) {\n\n        // this uses the methods in the jetty servlet environment and can be removed if jetty in implemented\n        Switchboard sb = (Switchboard) env;\n\n        // remember the peer contact for peer statistics\n        final String clientip = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"<unknown>\"); // read an artificial header addendum\n        final String userAgent = header.get(HeaderFramework.USER_AGENT, \"<unknown>\");\n        sb.peers.peerActions.setUserAgent(clientip, userAgent);\n\n        // check if user is allowed to search (can be switched in /ConfigPortal.html)\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final boolean searchAllowed = authenticated || sb.getConfigBool(\"publicSearchpage\", true);\n        if (!searchAllowed) return null;\n\n        // check post\n        if (post == null) {post = new serverObjects(); post.put(\"q\", \"\"); post.put(\"num\", \"0\");}\n        ConcurrentLog.info(\"GSA Query\", post.toString());\n        sb.intermissionAllThreads(3000); // tell all threads to do nothing for a specific time\n        \n        // rename post fields according to result style\n        //post.put(CommonParams.Q, post.remove(\"q\")); // same as solr\n        //post.put(CommonParams.START, post.remove(\"start\")); // same as solr\n        //post.put(, post.remove(\"client\"));//required, example: myfrontend\n        //post.put(, post.remove(\"output\"));//required, example: xml,xml_no_dtd\n        String originalQuery = post.get(CommonParams.Q, \"\");\n        post.put(\"originalQuery\", originalQuery);\n        \n        // get a solr query string\n        QueryGoal qg = new QueryGoal(originalQuery, originalQuery);\n        StringBuilder solrQ = qg.collectionTextQueryString(sb.index.fulltext().getDefaultConfiguration(), 0, false);\n        post.put(\"defType\", \"edismax\");\n        post.put(CommonParams.Q, solrQ.toString());\n        post.put(CommonParams.ROWS, post.remove(\"num\"));\n        post.put(CommonParams.ROWS, Math.min(post.getInt(CommonParams.ROWS, 10), (authenticated) ? 100000000 : 100));\n        \n        // set ranking\n        if (post.containsKey(\"sort\")) {\n            // if a gsa-style sort attribute is given, use this to set the solr sort attribute\n            GSAResponseWriter.Sort sort = new GSAResponseWriter.Sort(post.get(CommonParams.SORT, \"\"));\n            String sorts = sort.toSolr();\n            if (sorts == null) {\n                post.remove(CommonParams.SORT);\n            } else {\n                post.put(CommonParams.SORT, sorts);\n            }\n        } else {\n            // if no such sort attribute is given, use the ranking as configured for YaCy\n            Ranking ranking = sb.index.fulltext().getDefaultConfiguration().getRanking(0);\n            String bq = ranking.getBoostQuery();\n            String bf = ranking.getBoostFunction();\n            if (bq.length() > 0) post.put(\"bq\", bq);\n            if (bf.length() > 0) post.put(\"boost\", bf); // a boost function extension, see http://wiki.apache.org/solr/ExtendedDisMax#bf_.28Boost_Function.2C_additive.29\n        }\n        String daterange[] = post.remove(\"daterange\");\n        if (daterange != null) {\n            String origfq = post.get(CommonParams.FQ);\n            String datefq = \"\";\n            for (String dr: daterange) {\n                String from_to[] = dr.endsWith(\"..\") ? new String[]{dr.substring(0, dr.length() - 2), \"\"} : dr.startsWith(\"..\") ? new String[]{\"\", dr.substring(2)} : dr.split(\"\\\\.\\\\.\");\n                if (from_to.length != 2) continue;\n                Date from = HeaderFramework.parseGSAFS(from_to[0]);\n                if (from == null) from = new Date(0);\n                Date to = HeaderFramework.parseGSAFS(from_to[1]);\n                if (to == null) to = new Date();\n                to.setTime(to.getTime() + 24L * 60L * 60L * 1000L); // we add a day because the day is inclusive\n                String z = CollectionSchema.last_modified.getSolrFieldName() + \":[\" + ISO8601Formatter.FORMATTER.format(from) + \" TO \" + ISO8601Formatter.FORMATTER.format(to) + \"]\";\n                datefq = datefq.length() == 0 ? z : \" OR \" + z;\n            }\n            if (datefq.length() > 0) post.put(CommonParams.FQ, origfq == null || origfq.length() == 0 ? datefq : \"(\" + origfq + \") AND (\" + datefq + \")\");\n        }\n        post.put(CommonParams.FL,\n                CollectionSchema.content_type.getSolrFieldName() + ',' +\n                CollectionSchema.id.getSolrFieldName() + ',' +\n                CollectionSchema.sku.getSolrFieldName() + ',' +\n                CollectionSchema.title.getSolrFieldName() + ',' +\n                CollectionSchema.description_txt.getSolrFieldName() + ',' +\n                CollectionSchema.load_date_dt.getSolrFieldName() + ',' +\n                CollectionSchema.last_modified.getSolrFieldName() + ',' +\n                CollectionSchema.size_i.getSolrFieldName());\n        post.put(\"hl\", \"true\");\n        post.put(\"hl.q\", qg.getIncludeString());\n        post.put(\"hl.fl\", CollectionSchema.h1_txt.getSolrFieldName() + \",\" + CollectionSchema.h2_txt.getSolrFieldName() + \",\" + CollectionSchema.text_t.getSolrFieldName());\n        post.put(\"hl.alternateField\", CollectionSchema.description_txt.getSolrFieldName());\n        post.put(\"hl.simple.pre\", \"<b>\");\n        post.put(\"hl.simple.post\", \"<\/b>\");\n        post.put(\"hl.fragsize\", Integer.toString(SearchEvent.SNIPPET_MAX_LENGTH));\n        \n        //String[] access = post.remove(\"access\");\n        //String[] entqr = post.remove(\"entqr\");\n\n        // add sites operator\n        String[] site = post.remove(\"site\"); // example: col1|col2\n        if (site != null && site[0].length() > 0) {\n            String origfq = post.get(CommonParams.FQ);\n            String sitefq = QueryModifier.parseCollectionExpression(site[0]);\n            post.put(CommonParams.FQ, origfq == null || origfq.length() == 0 ? sitefq : \"(\" + origfq + \") AND (\" + sitefq + \")\");\n        }\n        \n        // get the embedded connector\n        EmbeddedSolrConnector connector = sb.index.fulltext().getDefaultEmbeddedConnector();\n        if (connector == null) return null;\n\n        // do the solr request\n        SolrQueryRequest req = connector.request(post.toSolrParams(null));\n        SolrQueryResponse response = null;\n        Writer ow = null;\n        try {\n        \tresponse = connector.query(req);\n\t        if (response != null) {\n\t        \tException e = response.getException();\n\t\t        if (e != null) {\n\t\t            ConcurrentLog.logException(e);\n\t\t        } else {\n\t\t\n\t\t\t        // set some context for the writer\n\t\t\t        /*\n\t\t\t        Map<Object,Object> context = req.getContext();\n\t\t\t        context.put(\"ip\", header.get(\"CLIENTIP\", \"\"));\n\t\t\t        context.put(\"client\", \"vsm_frontent\");\n\t\t\t        context.put(\"sort\", sort.sort);\n\t\t\t        context.put(\"site\", site == null ? \"\" : site);\n\t\t\t        context.put(\"access\", access == null ? \"p\" : access[0]);\n\t\t\t        context.put(\"entqr\", entqr == null ? \"3\" : entqr[0]);\n\t\t\t        */\n\t\t\t        \n\t\t\t        // write the result directly to the output stream\n\t\t\t        ow = new FastWriter(new OutputStreamWriter(out, UTF8.charset));\n\t\t            responseWriter.write(ow, req, response);\n\t\t            ow.flush();\n\t\t        }\n\t        }\n        } catch (final SolrException e) {\n        \tConcurrentLog.logException(e);\n        } catch (final IOException e1) {\n        } finally {\n            req.close();\n            SolrRequestInfo.clearRequestInfo();\n            if (ow != null) try {ow.close();} catch (final IOException e1) {}\n        }\n        if (response == null) return null;\n\n        // log result\n        Object rv = response.getValues().get(\"response\");\n        int matches = 0;\n        if (rv != null && rv instanceof ResultContext) {\n            matches = ((ResultContext) rv).docs.matches();\n        } else if (rv != null && rv instanceof SolrDocumentList) {\n            matches = (int) ((SolrDocumentList) rv).getNumFound();\n        }\n        AccessTracker.addToDump(originalQuery, Integer.toString(matches));\n        ConcurrentLog.info(\"GSA Query\", \"results: \" + matches + \", for query:\" + post.toString());\n        \n        return null;\n    }","commit_id":"2c2ebb0d9218098e102b3a44432846493ec7fc05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * a query to solr, for documentation of parameters see:\n     * http://lucene.apache.org/solr/api-3_6_0/doc-files/tutorial.html\n     * and\n     * http://wiki.apache.org/solr/SolrQuerySyntax\n     * @param header\n     * @param post\n     * @param env\n     * @param out\n     * @return\n     */\n    public static serverObjects respond(final RequestHeader header, serverObjects post, final serverSwitch env, final OutputStream out) {\n\n        // this uses the methods in the jetty servlet environment and can be removed if jetty in implemented\n        Switchboard sb = (Switchboard) env;\n\n        // remember the peer contact for peer statistics\n        final String clientip = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"<unknown>\"); // read an artificial header addendum\n        final String userAgent = header.get(HeaderFramework.USER_AGENT, \"<unknown>\");\n        sb.peers.peerActions.setUserAgent(clientip, userAgent);\n\n        // check if user is allowed to search (can be switched in /ConfigPortal.html)\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final boolean searchAllowed = authenticated || sb.getConfigBool(\"publicSearchpage\", true);\n        if (!searchAllowed) return null;\n\n        // check post\n        if (post == null) {post = new serverObjects(); post.put(CommonParams.Q, \"\"); post.put(CommonParams.ROWS, \"0\");}\n        if (post.size() > 100) {\n            ConcurrentLog.warn(\"select\", \"rejected bad-formed search request with \" + post.size() + \" properties from \" + header.refererHost());\n            return null; // prevent the worst hacks here...\n        }\n        sb.intermissionAllThreads(3000); // tell all threads to do nothing for a specific time\n        \n        // get the ranking profile id\n        int profileNr = post.getInt(\"profileNr\", 0);\n        \n        // rename post fields according to result style\n        if (!post.containsKey(CommonParams.Q) && post.containsKey(\"query\")) {\n            String querystring = post.get(\"query\", \"\");\n            post.remove(\"query\");\n            QueryModifier modifier = new QueryModifier();\n            querystring = modifier.parse(querystring);\n            modifier.apply(post);\n            QueryGoal qg = new QueryGoal(querystring, querystring);\n            StringBuilder solrQ = qg.collectionTextQueryString(sb.index.fulltext().getDefaultConfiguration(), profileNr, false);\n            post.put(CommonParams.Q, solrQ.toString()); // sru patch\n        }\n        String q = post.get(CommonParams.Q, \"\");\n        if (!post.containsKey(CommonParams.START)) post.put(CommonParams.START, post.remove(\"startRecord\", 0)); // sru patch\n        if (!post.containsKey(CommonParams.ROWS)) post.put(CommonParams.ROWS, post.remove(\"maximumRecords\", 10)); // sru patch\n        post.put(CommonParams.ROWS, Math.min(post.getInt(CommonParams.ROWS, 10), (authenticated) ? 100000000 : 100));\n        \n        // set ranking according to profile number if ranking attributes are not given in the request\n        if (!post.containsKey(\"sort\") && !post.containsKey(\"bq\") && !post.containsKey(\"bf\") && !post.containsKey(\"boost\")) {\n            if (!post.containsKey(\"defType\")) post.put(\"defType\", \"edismax\");        \n            Ranking ranking = sb.index.fulltext().getDefaultConfiguration().getRanking(profileNr);\n            String bq = ranking.getBoostQuery();\n            String bf = ranking.getBoostFunction();\n            if (bq.length() > 0) post.put(\"bq\", bq);\n            if (bf.length() > 0) post.put(\"boost\", bf); // a boost function extension, see http://wiki.apache.org/solr/ExtendedDisMax#bf_.28Boost_Function.2C_additive.29\n        }\n        \n        // get a response writer for the result\n        String wt = post.get(CommonParams.WT, \"xml\"); // maybe use /solr/select?q=*:*&start=0&rows=10&wt=exml\n        QueryResponseWriter responseWriter = RESPONSE_WRITER.get(wt);\n        if (responseWriter == null) return null;\n        if (responseWriter instanceof OpensearchResponseWriter) {\n            // set the title every time, it is possible that it has changed\n            final String promoteSearchPageGreeting =\n                            (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ? env.getConfig(\n                                \"network.unit.description\",\n                                \"\") : env.getConfig(SwitchboardConstants.GREETING, \"\");\n            ((OpensearchResponseWriter) responseWriter).setTitle(promoteSearchPageGreeting);\n        }\n        \n        // if this is a call to YaCys special search formats, enhance the query with field assignments\n        if ((responseWriter instanceof YJsonResponseWriter || responseWriter instanceof OpensearchResponseWriter) && \"true\".equals(post.get(\"hl\", \"true\"))) {\n            // add options for snippet generation\n            if (!post.containsKey(\"hl.q\")) post.put(\"hl.q\", q);\n            if (!post.containsKey(\"hl.fl\")) post.put(\"hl.fl\", CollectionSchema.h1_txt.getSolrFieldName() + \",\" + CollectionSchema.h2_txt.getSolrFieldName() + \",\" + CollectionSchema.text_t.getSolrFieldName());\n            if (!post.containsKey(\"hl.alternateField\")) post.put(\"hl.alternateField\", CollectionSchema.description_txt.getSolrFieldName());\n            if (!post.containsKey(\"hl.simple.pre\")) post.put(\"hl.simple.pre\", \"<b>\");\n            if (!post.containsKey(\"hl.simple.post\")) post.put(\"hl.simple.post\", \"<\/b>\");\n            if (!post.containsKey(\"hl.fragsize\")) post.put(\"hl.fragsize\", Integer.toString(SearchEvent.SNIPPET_MAX_LENGTH));\n        }\n\n        // get the embedded connector\n        boolean defaultConnector = post == null || post.get(\"core\", CollectionSchema.CORE_NAME).equals(CollectionSchema.CORE_NAME);\n        EmbeddedSolrConnector connector = defaultConnector ? sb.index.fulltext().getDefaultEmbeddedConnector() : sb.index.fulltext().getEmbeddedConnector(WebgraphSchema.CORE_NAME);\n        if (connector == null) return null;\n\n        // do the solr request, generate facets if we use a special YaCy format\n        SolrParams params = post.toSolrParams(/*responseWriter instanceof JsonResponseWriter ? new YaCySchema[]{YaCySchema.host_s, YaCySchema.url_file_ext_s, YaCySchema.url_protocol_s} :*/ null);\n        SolrQueryRequest req = connector.request(params);\n        SolrQueryResponse response = null;\n        Exception e = null;\n        try {response = connector.query(req);} catch (final SolrException ee) {e = ee;}\n        if (response != null) e = response.getException();\n        if (e != null) {\n            ConcurrentLog.logException(e);\n            if (req != null) req.close();\n            SolrRequestInfo.clearRequestInfo();\n            return null;\n        }\n\n        // write the result directly to the output stream\n        if (responseWriter instanceof BinaryResponseWriter) {\n            try {\n                ((BinaryResponseWriter) responseWriter).write(out, req, response);\n            } catch (final IOException e1) {\n            } finally {\n                req.close();\n                SolrRequestInfo.clearRequestInfo();\n            }\n        } else {\n            Writer ow = new FastWriter(new OutputStreamWriter(out, UTF8.charset));\n            try {\n                responseWriter.write(ow, req, response);\n                ow.flush();\n            } catch (final IOException e1) {\n            } finally {\n                req.close();\n                SolrRequestInfo.clearRequestInfo();\n                try {ow.close();} catch (final IOException e1) {}\n            }\n        }\n\n        // log result\n        Object rv = response.getValues().get(\"response\");\n        int matches = 0;\n        if (rv != null && rv instanceof ResultContext) {\n            matches = ((ResultContext) rv).docs.matches();\n        } else if (rv != null && rv instanceof SolrDocumentList) {\n            matches = (int) ((SolrDocumentList) rv).getNumFound();\n        }\n        AccessTracker.addToDump(q, Integer.toString(matches));\n        ConcurrentLog.info(\"SOLR Query\", \"results: \" + matches + \", for query:\" + post.toString());\n\n        return null;\n    }","id":43781,"modified_method":"/**\n     * a query to solr, for documentation of parameters see:\n     * http://lucene.apache.org/solr/api-3_6_0/doc-files/tutorial.html\n     * and\n     * http://wiki.apache.org/solr/SolrQuerySyntax\n     * @param header\n     * @param post\n     * @param env\n     * @param out\n     * @return\n     */\n    public static serverObjects respond(final RequestHeader header, serverObjects post, final serverSwitch env, final OutputStream out) {\n\n        // this uses the methods in the jetty servlet environment and can be removed if jetty in implemented\n        Switchboard sb = (Switchboard) env;\n\n        // remember the peer contact for peer statistics\n        final String clientip = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"<unknown>\"); // read an artificial header addendum\n        final String userAgent = header.get(HeaderFramework.USER_AGENT, \"<unknown>\");\n        sb.peers.peerActions.setUserAgent(clientip, userAgent);\n\n        // check if user is allowed to search (can be switched in /ConfigPortal.html)\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final boolean searchAllowed = authenticated || sb.getConfigBool(\"publicSearchpage\", true);\n        if (!searchAllowed) return null;\n\n        // check post\n        if (post == null) {post = new serverObjects(); post.put(CommonParams.Q, \"\"); post.put(CommonParams.ROWS, \"0\");}\n        if (post.size() > 100) {\n            ConcurrentLog.warn(\"select\", \"rejected bad-formed search request with \" + post.size() + \" properties from \" + header.refererHost());\n            return null; // prevent the worst hacks here...\n        }\n        sb.intermissionAllThreads(3000); // tell all threads to do nothing for a specific time\n        \n        // get the ranking profile id\n        int profileNr = post.getInt(\"profileNr\", 0);\n        \n        // rename post fields according to result style\n        if (!post.containsKey(CommonParams.Q) && post.containsKey(\"query\")) {\n            String querystring = post.get(\"query\", \"\");\n            post.remove(\"query\");\n            QueryModifier modifier = new QueryModifier();\n            querystring = modifier.parse(querystring);\n            modifier.apply(post);\n            QueryGoal qg = new QueryGoal(querystring, querystring);\n            StringBuilder solrQ = qg.collectionTextQueryString(sb.index.fulltext().getDefaultConfiguration(), profileNr, false);\n            post.put(CommonParams.Q, solrQ.toString()); // sru patch\n        }\n        String q = post.get(CommonParams.Q, \"\");\n        if (!post.containsKey(CommonParams.START)) post.put(CommonParams.START, post.remove(\"startRecord\", 0)); // sru patch\n        if (!post.containsKey(CommonParams.ROWS)) post.put(CommonParams.ROWS, post.remove(\"maximumRecords\", 10)); // sru patch\n        post.put(CommonParams.ROWS, Math.min(post.getInt(CommonParams.ROWS, 10), (authenticated) ? 100000000 : 100));\n        \n        // set ranking according to profile number if ranking attributes are not given in the request\n        if (!post.containsKey(\"sort\") && !post.containsKey(\"bq\") && !post.containsKey(\"bf\") && !post.containsKey(\"boost\")) {\n            if (!post.containsKey(\"defType\")) post.put(\"defType\", \"edismax\");        \n            Ranking ranking = sb.index.fulltext().getDefaultConfiguration().getRanking(profileNr);\n            String bq = ranking.getBoostQuery();\n            String bf = ranking.getBoostFunction();\n            if (bq.length() > 0) post.put(\"bq\", bq);\n            if (bf.length() > 0) post.put(\"boost\", bf); // a boost function extension, see http://wiki.apache.org/solr/ExtendedDisMax#bf_.28Boost_Function.2C_additive.29\n        }\n        \n        // get a response writer for the result\n        String wt = post.get(CommonParams.WT, \"xml\"); // maybe use /solr/select?q=*:*&start=0&rows=10&wt=exml\n        QueryResponseWriter responseWriter = RESPONSE_WRITER.get(wt);\n        if (responseWriter == null) return null;\n        if (responseWriter instanceof OpensearchResponseWriter) {\n            // set the title every time, it is possible that it has changed\n            final String promoteSearchPageGreeting =\n                            (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ? env.getConfig(\n                                \"network.unit.description\",\n                                \"\") : env.getConfig(SwitchboardConstants.GREETING, \"\");\n            ((OpensearchResponseWriter) responseWriter).setTitle(promoteSearchPageGreeting);\n        }\n        \n        // if this is a call to YaCys special search formats, enhance the query with field assignments\n        if ((responseWriter instanceof YJsonResponseWriter || responseWriter instanceof OpensearchResponseWriter) && \"true\".equals(post.get(\"hl\", \"true\"))) {\n            // add options for snippet generation\n            if (!post.containsKey(\"hl.q\")) post.put(\"hl.q\", q);\n            if (!post.containsKey(\"hl.fl\")) post.put(\"hl.fl\", CollectionSchema.h1_txt.getSolrFieldName() + \",\" + CollectionSchema.h2_txt.getSolrFieldName() + \",\" + CollectionSchema.text_t.getSolrFieldName());\n            if (!post.containsKey(\"hl.alternateField\")) post.put(\"hl.alternateField\", CollectionSchema.description_txt.getSolrFieldName());\n            if (!post.containsKey(\"hl.simple.pre\")) post.put(\"hl.simple.pre\", \"<b>\");\n            if (!post.containsKey(\"hl.simple.post\")) post.put(\"hl.simple.post\", \"<\/b>\");\n            if (!post.containsKey(\"hl.fragsize\")) post.put(\"hl.fragsize\", Integer.toString(SearchEvent.SNIPPET_MAX_LENGTH));\n        }\n\n        // get the embedded connector\n        boolean defaultConnector = post == null || post.get(\"core\", CollectionSchema.CORE_NAME).equals(CollectionSchema.CORE_NAME);\n        EmbeddedSolrConnector connector = defaultConnector ? sb.index.fulltext().getDefaultEmbeddedConnector() : sb.index.fulltext().getEmbeddedConnector(WebgraphSchema.CORE_NAME);\n        if (connector == null) return null;\n\n        // do the solr request, generate facets if we use a special YaCy format\n        SolrParams params = post.toSolrParams(/*responseWriter instanceof JsonResponseWriter ? new YaCySchema[]{YaCySchema.host_s, YaCySchema.url_file_ext_s, YaCySchema.url_protocol_s} :*/ null);\n        SolrQueryRequest req = connector.request(params);\n        Writer ow = null;\n        SolrQueryResponse response = null;\n        try {\n\t        response = connector.query(req);\n\t        if (response != null) {\n\t        \tException e = response.getException();\n\t        \tif (e != null) {\n\t        \t\tConcurrentLog.logException(e);\n\t        \t} else {\n\t\t        \t\n\t\t\t        // write the result directly to the output stream\n\t\t        \tif (responseWriter instanceof BinaryResponseWriter) {\n\t\t\t            ((BinaryResponseWriter) responseWriter).write(out, req, response);\n\t\t\t        } else {\n\t\t\t            ow = new FastWriter(new OutputStreamWriter(out, UTF8.charset));\n\t\t\t            responseWriter.write(ow, req, response);\n\t\t                ow.flush();\n\t\t\t        }\n\t        \t}\n\t        }\n        } catch (final SolrException e) {\n        \tConcurrentLog.logException(e);\n        } catch (final IOException e1) {\n        } finally {\n        \treq.close();\n            SolrRequestInfo.clearRequestInfo();\n            if (ow != null) try {ow.close();} catch (final IOException e1) {}\n        }\n        if (response == null) return null;\n\n        // log result\n        Object rv = response.getValues().get(\"response\");\n        int matches = 0;\n        if (rv != null && rv instanceof ResultContext) {\n            matches = ((ResultContext) rv).docs.matches();\n        } else if (rv != null && rv instanceof SolrDocumentList) {\n            matches = (int) ((SolrDocumentList) rv).getNumFound();\n        }\n        AccessTracker.addToDump(q, Integer.toString(matches));\n        ConcurrentLog.info(\"SOLR Query\", \"results: \" + matches + \", for query:\" + post.toString());\n\n        return null;\n    }","commit_id":"2c2ebb0d9218098e102b3a44432846493ec7fc05","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public CamelConduit(CamelContext context, Bus b, EndpointInfo epInfo, EndpointReferenceType targetReference,\n            HeaderFilterStrategy headerFilterStrategy) {\n        super(getTargetReference(epInfo, targetReference, b));\n        String address = epInfo.getAddress();\n        if (address != null) {\n            targetCamelEndpointUri = address.substring(CxfConstants.CAMEL_TRANSPORT_PREFIX.length());\n            if (targetCamelEndpointUri.startsWith(\"//\")) {\n                targetCamelEndpointUri = targetCamelEndpointUri.substring(2);\n            }\n        }\n        camelContext = context;\n        endpointInfo = epInfo;\n        bus = b;\n        initConfig();\n        this.headerFilterStrategy = headerFilterStrategy;\n    }","id":43782,"modified_method":"public CamelConduit(CamelContext context, Bus b, EndpointInfo epInfo, EndpointReferenceType targetReference,\n            HeaderFilterStrategy headerFilterStrategy) {\n        super(getTargetReference(epInfo, targetReference, b));\n        String address = epInfo.getAddress();\n        if (address != null) {\n            targetCamelEndpointUri = address.substring(CxfConstants.CAMEL_TRANSPORT_PREFIX.length());\n            if (targetCamelEndpointUri.startsWith(\"//\")) {\n                targetCamelEndpointUri = targetCamelEndpointUri.substring(2);\n            }\n        }\n        camelContext = context;\n        endpointInfo = epInfo;\n        bus = b;\n        initConfig();\n        this.headerFilterStrategy = headerFilterStrategy;\n        Endpoint target = getCamelContext().getEndpoint(targetCamelEndpointUri);\n        try {\n            producer = target.createProducer();\n            producer.start();\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Cannot create the producer rightly\", e);\n        }\n    }","commit_id":"1439fe1bbbaa1b72dc759e75755d8dd983f63a26","url":"https://github.com/apache/camel"},{"original_method":"public void close() {\n        getLogger().log(Level.FINE, \"CamelConduit closed \");\n\n    }","id":43783,"modified_method":"public void close() {\n        getLogger().log(Level.FINE, \"CamelConduit closed \");\n        // shutdown the producer\n        try {\n            producer.stop();\n        } catch (Exception e) {\n            getLogger().log(Level.WARNING, \"CamelConduit producer stop with the exception\", e);\n        }\n    }","commit_id":"1439fe1bbbaa1b72dc759e75755d8dd983f63a26","url":"https://github.com/apache/camel"},{"original_method":"private void commitOutputMessage() throws IOException {\n            ExchangePattern pattern;\n            if (isOneWay) {\n                pattern = ExchangePattern.InOnly;\n            } else {\n                pattern = ExchangePattern.InOut;\n            }\n            getLogger().log(Level.FINE, \"send the message to endpoint\" + targetCamelEndpointUri);\n            // We could wait for the rely asynchronously\n            org.apache.camel.Exchange exchange = getCamelTemplate().send(targetCamelEndpointUri, pattern, new Processor() {\n                public void process(org.apache.camel.Exchange ex) throws IOException {\n                    CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);\n                    // Send out the request message here, copy the protocolHeader back\n                    CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, ex.getIn().getHeaders(), ex);\n \n                    // TODO support different encoding\n                    ex.getIn().setBody(outputStream.getBytes());\n                    getLogger().log(Level.FINE, \"template sending request: \", ex.getIn());\n                }\n            });\n            exchange.setProperty(CxfConstants.CXF_EXCHANGE, outMessage.getExchange());\n            // Throw the exception that the template get\n            if (exchange.getException() != null) {\n                throw IOHelper.createIOException(\"Can't send the request message.\", exchange.getException());\n            }\n            if (!isOneWay) {\n                handleResponse(exchange);\n            }\n\n        }","id":43784,"modified_method":"private void commitOutputMessage() throws IOException {\n            ExchangePattern pattern;\n            if (isOneWay) {\n                pattern = ExchangePattern.InOnly;\n            } else {\n                pattern = ExchangePattern.InOut;\n            }\n            getLogger().log(Level.FINE, \"send the message to endpoint\" + targetCamelEndpointUri);\n            org.apache.camel.Exchange exchange = producer.createExchange(pattern);\n            \n            exchange.setProperty(Exchange.TO_ENDPOINT, targetCamelEndpointUri);\n            CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);\n            // Send out the request message here, copy the protocolHeader back\n            CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, exchange.getIn().getHeaders(), exchange);\n\n            // TODO support different encoding\n            exchange.getIn().setBody(outputStream.getBytes());\n            getLogger().log(Level.FINE, \"template sending request: \", exchange.getIn());\n            Exception exception = null;\n            try {\n                producer.process(exchange);\n            } catch (Exception ex) {\n                exception = ex;                \n            }\n            // Throw the exception that the template get\n            exception = exchange.getException();            \n            if (exception != null) {\n                throw IOHelper.createIOException(\"Can't send the request message.\", exchange.getException());\n            }\n            exchange.setProperty(CxfConstants.CXF_EXCHANGE, outMessage.getExchange());\n            if (!isOneWay) {\n                handleResponse(exchange);\n            }\n\n        }","commit_id":"1439fe1bbbaa1b72dc759e75755d8dd983f63a26","url":"https://github.com/apache/camel"},{"original_method":"@Test\n\tpublic void testAddUserNotificationWhenNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationsDelivery(false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(0, userNotificationEventsJSONObjects.size());\n\t}","id":43785,"modified_method":"@Test\n\tpublic void testAddUserNotificationWhenNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\taddSubscription();\n\n\t\tupdateUserNotificationsDelivery(false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(0, userNotificationEventsJSONObjects.size());\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddUserNotification() throws Exception {\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(1, userNotificationEventsJSONObjects.size());\n\n\t\tfor (JSONObject userNotificationEventsJSONObject :\n\t\t\t\tuserNotificationEventsJSONObjects) {\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\t\tuserNotificationEventsJSONObject.getInt(\"notificationType\"));\n\t\t}\n\t}","id":43786,"modified_method":"@Test\n\tpublic void testAddUserNotification() throws Exception {\n\t\taddSubscription();\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(1, userNotificationEventsJSONObjects.size());\n\n\t\tfor (JSONObject userNotificationEventsJSONObject :\n\t\t\t\tuserNotificationEventsJSONObjects) {\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\t\tuserNotificationEventsJSONObject.getInt(\"notificationType\"));\n\t\t}\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected abstract void updateBaseModel(BaseModel baseModel)\n\t\tthrows Exception;","id":43787,"modified_method":"protected abstract BaseModel updateBaseModel(BaseModel baseModel)\n\t\tthrows Exception;","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUpdateUserNotificationWhenNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationsDelivery(false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tupdateBaseModel(baseModel);\n\n\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(0, userNotificationEventsJSONObjects.size());\n\t}","id":43788,"modified_method":"@Test\n\tpublic void testUpdateUserNotificationWhenNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationsDelivery(false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\taddSubscription();\n\n\t\tBaseModel updatedBasemodel = updateBaseModel(baseModel);\n\n\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)updatedBasemodel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(0, userNotificationEventsJSONObjects.size());\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUpdateUserNotificationWhenEmailNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_EMAIL, false);\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_UPDATE_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_EMAIL, false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tupdateBaseModel(baseModel);\n\n\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(2, userNotificationEventsJSONObjects.size());\n\n\t\tint[] notificationTypes = new int[0];\n\n\t\tfor (JSONObject userNotificationEventsJSONObject :\n\t\t\t\tuserNotificationEventsJSONObjects) {\n\n\t\t\tnotificationTypes = ArrayUtil.append(\n\t\t\t\tnotificationTypes,\n\t\t\t\tuserNotificationEventsJSONObject.getInt(\"notificationType\"));\n\t\t}\n\n\t\tAssert.assertNotEquals(notificationTypes[0], notificationTypes[1]);\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.contains(\n\t\t\t\tnotificationTypes,\n\t\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.contains(\n\t\t\t\tnotificationTypes,\n\t\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_UPDATE_ENTRY));\n\t}","id":43789,"modified_method":"@Test\n\tpublic void testUpdateUserNotificationWhenEmailNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_EMAIL, false);\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_UPDATE_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_EMAIL, false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\taddSubscription();\n\n\t\tBaseModel updatedBasemodel = updateBaseModel(baseModel);\n\n\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)updatedBasemodel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(1, userNotificationEventsJSONObjects.size());\n\n\t\tint notificationType = -1;\n\n\t\tfor (JSONObject userNotificationEventsJSONObject :\n\t\t\t\tuserNotificationEventsJSONObjects) {\n\n\t\t\tnotificationType = userNotificationEventsJSONObject.getInt(\n\t\t\t\t\"notificationType\");\n\t\t}\n\n\t\tAssert.assertEquals(\n\t\t\tnotificationType,\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_UPDATE_ENTRY);\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddUserNotificationWhenWebsiteNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE, false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(0, userNotificationEventsJSONObjects.size());\n\t}","id":43790,"modified_method":"@Test\n\tpublic void testAddUserNotificationWhenWebsiteNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\taddSubscription();\n\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE, false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(0, userNotificationEventsJSONObjects.size());\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void\n\t\t\ttestUpdateUserNotificationWhenWebsiteNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE, false);\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_UPDATE_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE, false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tupdateBaseModel(baseModel);\n\n\t\tAssert.assertEquals(2, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tlogRecord = logRecords.get(1);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(0, userNotificationEventsJSONObjects.size());\n\t}","id":43791,"modified_method":"@Test\n\tpublic void\n\t\t\ttestUpdateUserNotificationWhenWebsiteNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE, false);\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_UPDATE_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_WEBSITE, false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\taddSubscription();\n\n\t\tBaseModel updatedBasemodel = updateBaseModel(baseModel);\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)updatedBasemodel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(0, userNotificationEventsJSONObjects.size());\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddUserNotificationWhenEmailNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_EMAIL, false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(1, userNotificationEventsJSONObjects.size());\n\n\t\tfor (JSONObject userNotificationEventsJSONObject :\n\t\t\t\tuserNotificationEventsJSONObjects) {\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\t\tuserNotificationEventsJSONObject.getInt(\"notificationType\"));\n\t\t}\n\t}","id":43792,"modified_method":"@Test\n\tpublic void testAddUserNotificationWhenEmailNotificationsDisabled()\n\t\tthrows Exception {\n\n\t\taddSubscription();\n\n\t\tupdateUserNotificationDelivery(\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\tUserNotificationDeliveryConstants.TYPE_EMAIL, false);\n\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(1, userNotificationEventsJSONObjects.size());\n\n\t\tfor (JSONObject userNotificationEventsJSONObject :\n\t\t\t\tuserNotificationEventsJSONObjects) {\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY,\n\t\t\t\tuserNotificationEventsJSONObject.getInt(\"notificationType\"));\n\t\t}\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUpdateUserNotification() throws Exception {\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\tupdateBaseModel(baseModel);\n\n\t\tAssert.assertEquals(2, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tlogRecord = logRecords.get(1);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)baseModel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(2, userNotificationEventsJSONObjects.size());\n\n\t\tint[] notificationTypes = new int[0];\n\n\t\tfor (JSONObject userNotificationEventsJSONObject :\n\t\t\t\tuserNotificationEventsJSONObjects) {\n\n\t\t\tnotificationTypes = ArrayUtil.append(\n\t\t\t\tnotificationTypes,\n\t\t\t\tuserNotificationEventsJSONObject.getInt(\"notificationType\"));\n\t\t}\n\n\t\tAssert.assertNotEquals(notificationTypes[0], notificationTypes[1]);\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.contains(\n\t\t\t\tnotificationTypes,\n\t\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_ADD_ENTRY));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.contains(\n\t\t\t\tnotificationTypes,\n\t\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_UPDATE_ENTRY));\n\t}","id":43793,"modified_method":"@Test\n\tpublic void testUpdateUserNotification() throws Exception {\n\t\tBaseModel baseModel = addBaseModel();\n\n\t\taddSubscription();\n\n\t\tBaseModel updatedBasemodel = updateBaseModel(baseModel);\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\"Sending email\", logRecord.getMessage());\n\n\t\tList<JSONObject> userNotificationEventsJSONObjects =\n\t\t\tgetUserNotificationEventsJSONObjects(\n\t\t\t\tuser.getUserId(), (Long)updatedBasemodel.getPrimaryKeyObj());\n\n\t\tAssert.assertEquals(1, userNotificationEventsJSONObjects.size());\n\n\t\tint notificationType = -1;\n\n\t\tfor (JSONObject userNotificationEventsJSONObject :\n\t\t\t\tuserNotificationEventsJSONObjects) {\n\n\t\t\tnotificationType = userNotificationEventsJSONObject.getInt(\n\t\t\t\t\"notificationType\");\n\t\t}\n\n\t\tAssert.assertEquals(\n\t\t\tnotificationType,\n\t\t\tUserNotificationDefinition.NOTIFICATION_TYPE_UPDATE_ENTRY);\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\t@Override\n\tpublic void setUp() throws Exception {\n\t\tsuper.setUp();\n\n\t\tlogRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tLoggerMockMailServiceImpl.class.getName(), Level.INFO);\n\n\t\tuser = TestPropsValues.getUser();\n\n\t\tgroup = GroupTestUtil.addGroup();\n\n\t\taddContainerModel();\n\n\t\taddSubscription();\n\n\t\tuserNotificationDeliveries = getUserNotificationDeliveries(\n\t\t\tuser.getUserId());\n\t}","id":43794,"modified_method":"@Before\n\t@Override\n\tpublic void setUp() throws Exception {\n\t\tsuper.setUp();\n\n\t\tlogRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tLoggerMockMailServiceImpl.class.getName(), Level.INFO);\n\n\t\tuser = TestPropsValues.getUser();\n\n\t\tgroup = GroupTestUtil.addGroup();\n\n\t\taddContainerModel();\n\n\t\tuserNotificationDeliveries = getUserNotificationDeliveries(\n\t\t\tuser.getUserId());\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateBaseModel(BaseModel baseModel) throws Exception {\n\t\tBlogsEntry blogsEntry = (BlogsEntry)baseModel;\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setCommand(Constants.UPDATE);\n\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tBlogsEntryLocalServiceUtil.updateEntry(\n\t\t\tblogsEntry.getUserId(), blogsEntry.getEntryId(),\n\t\t\tServiceTestUtil.randomString(), blogsEntry.getDescription(),\n\t\t\tblogsEntry.getContent(), 1, 1, 2012, 12, 00, true, true,\n\t\t\tnew String[0], blogsEntry.getSmallImage(),\n\t\t\tblogsEntry.getSmallImageURL(), StringPool.BLANK, null,\n\t\t\tserviceContext);\n\t}","id":43795,"modified_method":"protected BaseModel updateBaseModel(BaseModel baseModel) throws Exception {\n\t\tBlogsEntry blogsEntry = (BlogsEntry)baseModel;\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setCommand(Constants.UPDATE);\n\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\treturn BlogsEntryLocalServiceUtil.updateEntry(\n\t\t\tblogsEntry.getUserId(), blogsEntry.getEntryId(),\n\t\t\tServiceTestUtil.randomString(), blogsEntry.getDescription(),\n\t\t\tblogsEntry.getContent(), 1, 1, 2012, 12, 00, true, true,\n\t\t\tnew String[0], blogsEntry.getSmallImage(),\n\t\t\tblogsEntry.getSmallImageURL(), StringPool.BLANK, null,\n\t\t\tserviceContext);\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateBaseModel(BaseModel baseModel) throws Exception {\n\t\tWikiPage page = (WikiPage)baseModel;\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setCommand(Constants.UPDATE);\n\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tWikiPageLocalServiceUtil.updatePage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), page.getTitle(),\n\t\t\tpage.getVersion(), ServiceTestUtil.randomString(50),\n\t\t\tServiceTestUtil.randomString(), false,\n\t\t\tWikiPageConstants.DEFAULT_FORMAT, StringPool.BLANK,\n\t\t\tStringPool.BLANK, serviceContext);\n\t}","id":43796,"modified_method":"protected BaseModel updateBaseModel(BaseModel baseModel) throws Exception {\n\t\tWikiPage page = (WikiPage)baseModel;\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setCommand(Constants.UPDATE);\n\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\treturn WikiPageLocalServiceUtil.updatePage(\n\t\t\tTestPropsValues.getUserId(), _node.getNodeId(), page.getTitle(),\n\t\t\tpage.getVersion(), ServiceTestUtil.randomString(50),\n\t\t\tServiceTestUtil.randomString(), false,\n\t\t\tWikiPageConstants.DEFAULT_FORMAT, StringPool.BLANK,\n\t\t\tStringPool.BLANK, serviceContext);\n\t}","commit_id":"43aa2584c278766929ed0a03718067d9006edde5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected WikiPage updatePage(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tlong nodeId = ParamUtil.getLong(actionRequest, \"nodeId\");\n\t\tString title = ParamUtil.getString(actionRequest, \"title\");\n\t\tdouble version = ParamUtil.getDouble(actionRequest, \"version\");\n\n\t\tString content = ParamUtil.getString(actionRequest, \"content\");\n\t\tString summary = ParamUtil.getString(actionRequest, \"summary\");\n\t\tboolean minorEdit = ParamUtil.getBoolean(actionRequest, \"minorEdit\");\n\t\tString format = ParamUtil.getString(actionRequest, \"format\");\n\t\tString parentTitle = ParamUtil.getString(actionRequest, \"parentTitle\");\n\t\tString redirectTitle = null;\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tWikiPage.class.getName(), actionRequest);\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\treturn WikiPageServiceUtil.addPage(\n\t\t\t\tnodeId, title, content, summary, minorEdit, format, parentTitle,\n\t\t\t\tredirectTitle, serviceContext);\n\t\t}\n\t\telse {\n\t\t\treturn WikiPageServiceUtil.updatePage(\n\t\t\t\tnodeId, title, version, content, summary, minorEdit, format,\n\t\t\t\tparentTitle, redirectTitle, serviceContext);\n\t\t}\n\t}","id":43797,"modified_method":"protected WikiPage updatePage(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tlong nodeId = ParamUtil.getLong(actionRequest, \"nodeId\");\n\t\tString title = ParamUtil.getString(actionRequest, \"title\");\n\t\tdouble version = ParamUtil.getDouble(actionRequest, \"version\");\n\n\t\tString content = ParamUtil.getString(actionRequest, \"content\");\n\t\tString summary = ParamUtil.getString(actionRequest, \"summary\");\n\t\tboolean minorEdit = ParamUtil.getBoolean(actionRequest, \"minorEdit\");\n\t\tString format = ParamUtil.getString(actionRequest, \"format\");\n\t\tString parentTitle = ParamUtil.getString(actionRequest, \"parentTitle\");\n\t\tString redirectTitle = null;\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tWikiPage.class.getName(), actionRequest);\n\n\t\tWikiPage page = null;\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\tpage = WikiPageServiceUtil.addPage(\n\t\t\t\tnodeId, title, content, summary, minorEdit, format, parentTitle,\n\t\t\t\tredirectTitle, serviceContext);\n\t\t}\n\t\telse {\n\t\t\tpage = WikiPageServiceUtil.updatePage(\n\t\t\t\tnodeId, title, version, content, summary, minorEdit, format,\n\t\t\t\tparentTitle, redirectTitle, serviceContext);\n\t\t}\n\n\t\treturn page;\n\t}","commit_id":"adb6c26a851f81aa613dc951b5c38315d3546377","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updatePage(ActionRequest req) throws Exception {\n\t\tlong nodeId = ParamUtil.getLong(req, \"nodeId\");\n\t\tString title = ParamUtil.getString(req, \"title\");\n\n\t\tString content = ParamUtil.getString(req, \"content\");\n\t\tString format = ParamUtil.getString(req, \"format\");\n\n\t\tString[] tagsEntries = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"tagsEntries\"));\n\n\t\tWikiPageServiceUtil.updatePage(\n\t\t\tnodeId, title, content, format, tagsEntries);\n\t}","id":43798,"modified_method":"protected WikiPage updatePage(ActionRequest req) throws Exception {\n\t\tlong nodeId = ParamUtil.getLong(req, \"nodeId\");\n\t\tString title = ParamUtil.getString(req, \"title\");\n\n\t\tString content = ParamUtil.getString(req, \"content\");\n\t\tString format = ParamUtil.getString(req, \"format\");\n\n\t\tString[] tagsEntries = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"tagsEntries\"));\n\n\t\treturn WikiPageServiceUtil.updatePage(\n\t\t\tnodeId, title, content, format, tagsEntries);\n\t}","commit_id":"a35ad57210e8fb31d64d2fa0d865bf1a88c8ec18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tupdatePage(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeletePage(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.REVERT)) {\n\t\t\t\trevertPage(req);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(cmd)) {\n\t\t\t\tsendRedirect(req, res);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchNodeException ||\n\t\t\t\te instanceof NoSuchPageException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(req, e.getClass().getName());\n\n\t\t\t\tsetForward(req, \"portlet.wiki.error\");\n\t\t\t}\n\t\t\telse if (e instanceof PageContentException ||\n\t\t\t\t\t e instanceof PageTitleException) {\n\n\t\t\t\tSessionErrors.add(req, e.getClass().getName());\n\t\t\t}\n\t\t\telse if (e instanceof TagsEntryException) {\n\t\t\t\tSessionErrors.add(req, e.getClass().getName(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":43799,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tWikiPage page = null;\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tpage = updatePage(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeletePage(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.REVERT)) {\n\t\t\t\trevertPage(req);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(cmd)) {\n\t\t\t\tString redirect = ParamUtil.getString(req, \"redirect\");\n\n\t\t\t\tif (page != null) {\n\t\t\t\t\tboolean saveAndContinue = ParamUtil.getBoolean(\n\t\t\t\t\t\treq, \"saveAndContinue\");\n\n\t\t\t\t\tif (saveAndContinue) {\n\t\t\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\t\t\tconfig, req, page, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsendRedirect(req, res, redirect);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchNodeException ||\n\t\t\t\te instanceof NoSuchPageException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(req, e.getClass().getName());\n\n\t\t\t\tsetForward(req, \"portlet.wiki.error\");\n\t\t\t}\n\t\t\telse if (e instanceof PageContentException ||\n\t\t\t\t\t e instanceof PageTitleException) {\n\n\t\t\t\tSessionErrors.add(req, e.getClass().getName());\n\t\t\t}\n\t\t\telse if (e instanceof TagsEntryException) {\n\t\t\t\tSessionErrors.add(req, e.getClass().getName(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"a35ad57210e8fb31d64d2fa0d865bf1a88c8ec18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    @NotNull\n    public JsNode visitBinaryWithTypeRHSExpression(@NotNull JetBinaryExpressionWithTypeRHS expression,\n            @NotNull TranslationContext context) {\n        JsExpression jsExpression = Translation.translateAsExpression(expression.getLeft(), context);\n\n        if (expression.getOperationReference().getReferencedNameElementType() != JetTokens.AS_KEYWORD)\n            return jsExpression.source(expression);\n\n        JetTypeReference type = expression.getRight();\n        assert type != null;\n        if (BindingContextUtils.getNotNull(context.bindingContext(), BindingContext.TYPE, type).isNullable())\n            return jsExpression.source(expression);\n\n        // KT-2670\n        // we actually do not care for types in js\n        return TranslationUtils.sure(jsExpression, context).source(expression);\n    }","id":43800,"modified_method":"@Override\n    @NotNull\n    public JsNode visitBinaryWithTypeRHSExpression(@NotNull JetBinaryExpressionWithTypeRHS expression,\n            @NotNull TranslationContext context) {\n        JsExpression jsExpression = Translation.translateAsExpression(expression.getLeft(), context);\n\n        if (expression.getOperationReference().getReferencedNameElementType() != JetTokens.AS_KEYWORD)\n            return jsExpression.source(expression);\n\n        JetType rightType = BindingContextUtils.getNotNull(context.bindingContext(), BindingContext.TYPE, expression.getRight());\n        JetType leftType = BindingContextUtils.getNotNull(context.bindingContext(), BindingContext.EXPRESSION_TYPE, expression.getLeft());\n        if (rightType.isNullable() || !leftType.isNullable()) {\n            return jsExpression.source(expression);\n        }\n\n        // KT-2670\n        // we actually do not care for types in js\n        return TranslationUtils.sure(jsExpression, context).source(expression);\n    }","commit_id":"371dfc6ec4741d827fabdad4448bdbd8bf15aedf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static JsExpression translate(\n            @NotNull JetUnaryExpression expression,\n            @NotNull TranslationContext context\n    ) {\n        IElementType operationToken = expression.getOperationReference().getReferencedNameElementType();\n        if (operationToken == JetTokens.EXCLEXCL) {\n            return sure(translateAsExpression(getBaseExpression(expression), context), context);\n        }\n        if (IncrementTranslator.isIncrement(operationToken)) {\n            return IncrementTranslator.translate(expression, context);\n        }\n\n        JsExpression baseExpression = TranslationUtils.translateBaseExpression(context, expression);\n        if (isExclForBinaryEqualLikeExpr(expression, baseExpression)) {\n            return translateExclForBinaryEqualLikeExpr((JsBinaryOperation) baseExpression);\n        }\n\n        ResolvedCall<? extends FunctionDescriptor> resolvedCall = getFunctionResolvedCall(context.bindingContext(), expression.getOperationReference());\n        return CallTranslator.instance$.translate(context, resolvedCall, baseExpression);\n    }","id":43801,"modified_method":"@NotNull\n    public static JsExpression translate(\n            @NotNull JetUnaryExpression expression,\n            @NotNull TranslationContext context\n    ) {\n        IElementType operationToken = expression.getOperationReference().getReferencedNameElementType();\n        if (operationToken == JetTokens.EXCLEXCL) {\n            JetExpression baseExpression = getBaseExpression(expression);\n            JetType type = BindingContextUtils.getNotNull(context.bindingContext(), BindingContext.EXPRESSION_TYPE, baseExpression);\n            JsExpression translatedExpression = translateAsExpression(baseExpression, context);\n            return type.isNullable() ? sure(translatedExpression, context) : translatedExpression;\n        }\n\n        if (IncrementTranslator.isIncrement(operationToken)) {\n            return IncrementTranslator.translate(expression, context);\n        }\n\n        JsExpression baseExpression = TranslationUtils.translateBaseExpression(context, expression);\n        if (isExclForBinaryEqualLikeExpr(expression, baseExpression)) {\n            return translateExclForBinaryEqualLikeExpr((JsBinaryOperation) baseExpression);\n        }\n\n        ResolvedCall<? extends FunctionDescriptor> resolvedCall = getFunctionResolvedCall(context.bindingContext(), expression.getOperationReference());\n        return CallTranslator.instance$.translate(context, resolvedCall, baseExpression);\n    }","commit_id":"371dfc6ec4741d827fabdad4448bdbd8bf15aedf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable @IfNotParsed\n    public JetTypeReference getRight() {\n        ASTNode node = getOperationReference().getNode();\n        while (node != null) {\n            PsiElement psi = node.getPsi();\n            if (psi instanceof JetTypeReference) {\n                return (JetTypeReference) psi;\n            }\n            node = node.getTreeNext();\n        }\n\n        return null;\n    }","id":43802,"modified_method":"@Nullable @IfNotParsed\n    public JetTypeReference getRight() {\n        ASTNode node = getOperationSign().getNode();\n        while (node != null) {\n            PsiElement psi = node.getPsi();\n            if (psi instanceof JetTypeReference) {\n                return (JetTypeReference) psi;\n            }\n            node = node.getTreeNext();\n        }\n\n        return null;\n    }","commit_id":"4dec2ce60feb348c6c417d6d7bfd1136fd55f80d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JetSimpleNameExpression getOperationReference() {\n        return (JetSimpleNameExpression) findChildByType(JetNodeTypes.OPERATION_REFERENCE);\n    }","id":43803,"modified_method":"@NotNull\n    public JetSimpleNameExpression getOperationSign() {\n        return (JetSimpleNameExpression) findChildByType(JetNodeTypes.OPERATION_REFERENCE);\n    }","commit_id":"4dec2ce60feb348c6c417d6d7bfd1136fd55f80d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public void visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression) {\n            if (expression.getOperationReference().getReferencedNameElementType() == JetTokens.COLON) {\n                JetType actualType = getType(scope, expression.getLeft(), false);\n                JetType expectedType = typeResolver.resolveType(scope, expression.getRight());\n                if (actualType != null && !semanticServices.getTypeChecker().isSubtypeOf(actualType, expectedType)) {\n                    // TODO\n                    semanticServices.getErrorHandler().typeMismatch(expression.getLeft(), expectedType, actualType);\n                }\n                result = expectedType;\n                return;\n            }\n            throw new UnsupportedOperationException(); // TODO\n        }","id":43804,"modified_method":"@Override\n        public void visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression) {\n            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();\n            JetType actualType = getType(scope, expression.getLeft(), false);\n            JetTypeReference right = expression.getRight();\n            if (right != null) {\n                JetType targetType = typeResolver.resolveType(scope, right);\n                if (operationType == JetTokens.COLON) {\n                    if (actualType != null && !semanticServices.getTypeChecker().isSubtypeOf(actualType, targetType)) {\n                        semanticServices.getErrorHandler().typeMismatch(expression.getLeft(), targetType, actualType);\n                    }\n                }\n                else if (operationType == JetTokens.AS_KEYWORD) {\n                    // TODO : Check for cast impossibility\n                }\n                else {\n                    semanticServices.getErrorHandler().structuralError(expression.getOperationSign().getNode(), \"Unsupported binary operation\");\n                }\n                result = targetType;\n            }\n        }","commit_id":"4dec2ce60feb348c6c417d6d7bfd1136fd55f80d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static String[] getParameters(final String iText) {\r\n\t\tint openPos = iText.indexOf(OPEN_BRACE);\r\n\t\tif (openPos == -1)\r\n\t\t\treturn EMPTY_PARAMETERS;\r\n\r\n\t\tint closePos = iText.indexOf(CLOSED_BRACE, openPos + 1);\r\n\t\tif (closePos == -1)\r\n\t\t\treturn EMPTY_PARAMETERS;\r\n\r\n\t\treturn iText.substring(openPos + 1, closePos).split(PARAMETER_SEPARATOR);\r\n\t}","id":43805,"modified_method":"public static String[] getParameters(final String iText) {\r\n\t\tint openPos = iText.indexOf(OPEN_BRACE);\r\n\t\tif (openPos == -1)\r\n\t\t\treturn EMPTY_PARAMETERS;\r\n\r\n\t\tint closePos = iText.indexOf(CLOSED_BRACE, openPos + 1);\r\n\t\tif (closePos == -1)\r\n\t\t\treturn EMPTY_PARAMETERS;\r\n\r\n\t\tif (closePos - openPos == 1)\r\n\t\t\t// EMPTY STRING: TREATS AS EMPTY\r\n\t\t\treturn EMPTY_PARAMETERS;\r\n\r\n\t\tString[] pars = iText.substring(openPos + 1, closePos).split(PARAMETER_SEPARATOR);\r\n\r\n\t\t// REMOVE TAIL AND END SPACES\r\n\t\tfor (int i = 0; i < pars.length; ++i)\r\n\t\t\tpars[i] = pars[i].trim();\r\n\r\n\t\treturn pars;\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tprotected boolean evaluateExpression(final OSQLCondition iCondition, final Object iLeft, final Object iRight) {\r\n\t\tif (iLeft instanceof Collection<?>) {\r\n\t\t\tCollection<ORecordSchemaAware<?>> collection = (Collection<ORecordSchemaAware<?>>) iLeft;\r\n\t\t\tfor (ORecordSchemaAware<?> o : collection) {\r\n\t\t\t\tif ((Boolean) ((OSQLCondition) iCondition.getRight()).evaluate(o) == Boolean.TRUE)\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iRight instanceof Collection<?>) {\r\n\r\n\t\t\tCollection<ORecordSchemaAware<?>> collection = (Collection<ORecordSchemaAware<?>>) iRight;\r\n\t\t\tfor (ORecordSchemaAware<?> o : collection) {\r\n\t\t\t\tif ((Boolean) ((OSQLCondition) iCondition.getLeft()).evaluate(o) == Boolean.TRUE)\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":43806,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\tprotected boolean evaluateExpression(final OSQLCondition iCondition, final Object iLeft, final Object iRight) {\r\n\t\tOSQLCondition condition;\r\n\t\t\r\n\t\ttry {\r\n\t\t\tcondition = (OSQLCondition) (iCondition.getLeft() instanceof OSQLCondition ? iCondition.getLeft() : iCondition.getRight());\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new OQueryExecutionException(\"Operator contains needs a condition to apply\", e);\r\n\t\t}\r\n\r\n\t\tif (iLeft instanceof Collection<?>) {\r\n\r\n\t\t\tCollection<ORecordSchemaAware<?>> collection = (Collection<ORecordSchemaAware<?>>) iLeft;\r\n\t\t\tfor (ORecordSchemaAware<?> o : collection) {\r\n\t\t\t\tif ((Boolean) condition.evaluate(o) == Boolean.TRUE)\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iRight instanceof Collection<?>) {\r\n\r\n\t\t\tCollection<ORecordSchemaAware<?>> collection = (Collection<ORecordSchemaAware<?>>) iRight;\r\n\t\t\tfor (ORecordSchemaAware<?> o : collection) {\r\n\t\t\t\tif ((Boolean) condition.evaluate(o) == Boolean.TRUE)\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean evaluate(final OSQLCondition iCondition, final Object iLeft, final Object iRight) {\r\n\t\tif (iLeft instanceof OSQLAllValues) {\r\n\t\t\t// ALL VALUES\r\n\t\t\tfinal OSQLAllValues allValues = (OSQLAllValues) iLeft;\r\n\t\t\tif (allValues.values.length == 0)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tfor (Object v : allValues.values)\r\n\t\t\t\tif (v == null || !evaluateExpression(iCondition, v, iRight))\r\n\t\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\t\t} else if (iRight instanceof OSQLAllValues) {\r\n\t\t\t// ALL VALUES\r\n\t\t\tfinal OSQLAllValues allValues = (OSQLAllValues) iRight;\r\n\t\t\tif (allValues.values.length == 0)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tfor (Object v : allValues.values)\r\n\t\t\t\tif (v == null || !evaluateExpression(iCondition, v, iLeft))\r\n\t\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\r\n\t\t} else if (iLeft instanceof OSQLValueAny) {\r\n\t\t\t// ANY VALUES\r\n\t\t\tfinal OSQLValueAny anyValue = (OSQLValueAny) iLeft;\r\n\t\t\tif (anyValue.values.length == 0)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tfor (Object v : anyValue.values)\r\n\t\t\t\tif (v != null && evaluateExpression(iCondition, iRight, v))\r\n\t\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t} else if (iRight instanceof OSQLValueAny) {\r\n\t\t\t// ANY VALUES\r\n\t\t\tfinal OSQLValueAny anyValue = (OSQLValueAny) iRight;\r\n\t\t\tif (anyValue.values.length == 0)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tfor (Object v : anyValue.values)\r\n\t\t\t\tif (v != null && evaluateExpression(iCondition, iLeft, v))\r\n\t\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\r\n\t\t} else\r\n\t\t\t// SINGLE SIMPLE ITEM\r\n\t\t\treturn evaluateExpression(iCondition, iLeft, iRight);\r\n\t}","id":43807,"modified_method":"public boolean evaluate(final OSQLCondition iCondition, final Object iLeft, final Object iRight) {\r\n\t\tif (iLeft instanceof OSQLValueAll) {\r\n\t\t\t// ALL VALUES\r\n\t\t\tfinal OSQLValueAll allValues = (OSQLValueAll) iLeft;\r\n\t\t\tif (allValues.values.length == 0)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tfor (Object v : allValues.values)\r\n\t\t\t\tif (v == null || !evaluateExpression(iCondition, v, iRight))\r\n\t\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\t\t} else if (iRight instanceof OSQLValueAll) {\r\n\t\t\t// ALL VALUES\r\n\t\t\tfinal OSQLValueAll allValues = (OSQLValueAll) iRight;\r\n\t\t\tif (allValues.values.length == 0)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tfor (Object v : allValues.values)\r\n\t\t\t\tif (v == null || !evaluateExpression(iCondition, v, iLeft))\r\n\t\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\r\n\t\t} else if (iLeft instanceof OSQLValueAny) {\r\n\t\t\t// ANY VALUES\r\n\t\t\tfinal OSQLValueAny anyValue = (OSQLValueAny) iLeft;\r\n\t\t\tif (anyValue.values.length == 0)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tfor (Object v : anyValue.values)\r\n\t\t\t\tif (v != null && evaluateExpression(iCondition, iRight, v))\r\n\t\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t} else if (iRight instanceof OSQLValueAny) {\r\n\t\t\t// ANY VALUES\r\n\t\t\tfinal OSQLValueAny anyValue = (OSQLValueAny) iRight;\r\n\t\t\tif (anyValue.values.length == 0)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tfor (Object v : anyValue.values)\r\n\t\t\t\tif (v != null && evaluateExpression(iCondition, iLeft, v))\r\n\t\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\r\n\t\t} else\r\n\t\t\t// SINGLE SIMPLE ITEM\r\n\t\t\treturn evaluateExpression(iCondition, iLeft, iRight);\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean evaluateExpression(OSQLCondition iCondition, final Object iLeft, final Object iRight) {\r\n\t\treturn OQueryHelper.like(iLeft.toString(), iRight.toString());\r\n\t}","id":43808,"modified_method":"protected boolean evaluateExpression(OSQLCondition iCondition, final Object iLeft, final Object iRight) {\r\n\t\treturn OQueryHelper.like(iRight.toString(), iLeft.toString());\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic String toString() {\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(\"ALL(\");\r\n\t\tif (names != null) {\r\n\t\t\tint i = 0;\r\n\t\t\tfor (String n : names) {\r\n\t\t\t\tif (i++ > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(n);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbuffer.append(\")\");\r\n\r\n\t\treturn buffer.toString();\r\n\t}","id":43809,"modified_method":"@Override\r\n\tpublic String toString() {\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(NAME);\r\n\t\tbuffer.append(\"(\");\r\n\t\tif (names != null) {\r\n\t\t\tint i = 0;\r\n\t\t\tfor (String n : names) {\r\n\t\t\t\tif (i++ > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(n);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbuffer.append(\")\");\r\n\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Object getValue(final ORecordInternal<?> iRecord) {\r\n\t\tif (names == null || names.length == 0)\r\n\t\t\treturn null;\r\n\r\n\t\tif (names.length == 1)\r\n\t\t\t// NO MATTER OF TYPE: RETURN THE SINGLE FIELD VALUE TO SIMPLIFY\r\n\t\t\treturn ((ORecordSchemaAware<?>) iRecord).field(names[0]);\r\n\r\n\t\treturn new OSQLAllValues(((ORecordSchemaAware<?>) iRecord).fieldValues());\r\n\t}","id":43810,"modified_method":"public Object getValue(final ORecordInternal<?> iRecord) {\r\n\t\tif (names.length == 1)\r\n\t\t\t// NO MATTER OF TYPE: RETURN THE SINGLE FIELD VALUE TO SIMPLIFY\r\n\t\t\treturn ((ORecordSchemaAware<?>) iRecord).field(names[0]);\r\n\r\n\t\treturn new OSQLValueAll(((ORecordSchemaAware<?>) iRecord).fieldValues());\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Object getValue(final ORecordInternal<?> iRecord) {\r\n\t\tif (names == null || names.length == 0)\r\n\t\t\treturn null;\r\n\r\n\t\tif (names.length == 1)\r\n\t\t\t// NO MATTER OF TYPE: RETURN THE SINGLE FIELD VALUE TO SIMPLIFY\r\n\t\t\treturn ((ORecordSchemaAware<?>) iRecord).field(names[0]);\r\n\r\n\t\treturn new OSQLValueAny(((ORecordSchemaAware<?>) iRecord).fieldValues());\r\n\t}","id":43811,"modified_method":"public Object getValue(final ORecordInternal<?> iRecord) {\r\n\t\tif (names.length == 1)\r\n\t\t\t// NO MATTER OF TYPE: RETURN THE SINGLE FIELD VALUE TO SIMPLIFY\r\n\t\t\treturn ((ORecordSchemaAware<?>) iRecord).field(names[0]);\r\n\r\n\t\treturn new OSQLValueAny(((ORecordSchemaAware<?>) iRecord).fieldValues());\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic String toString() {\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(\"ANY(\");\r\n\t\tif (names != null) {\r\n\t\t\tint i = 0;\r\n\t\t\tfor (String n : names) {\r\n\t\t\t\tif (i++ > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(n);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbuffer.append(\")\");\r\n\r\n\t\treturn buffer.toString();\r\n\t}","id":43812,"modified_method":"@Override\r\n\tpublic String toString() {\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\t\tbuffer.append(NAME);\r\n\t\tbuffer.append(\"(\");\r\n\t\tif (names != null) {\r\n\t\t\tint i = 0;\r\n\t\t\tfor (String n : names) {\r\n\t\t\t\tif (i++ > 0)\r\n\t\t\t\t\tbuffer.append(\", \");\r\n\t\t\t\tbuffer.append(n);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbuffer.append(\")\");\r\n\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private String[] nextValue(final boolean iAdvanceWhenNotFound) {\r\n\t\tif (!jumpWhiteSpaces())\r\n\t\t\treturn null;\r\n\r\n\t\tint begin = currentPos;\r\n\t\tchar c;\r\n\t\tchar stringBeginCharacter = ' ';\r\n\t\tint openBraces = 0;\r\n\t\tint openBraket = 0;\r\n\r\n\t\tfor (; currentPos < text.length(); ++currentPos) {\r\n\t\t\tc = text.charAt(currentPos);\r\n\r\n\t\t\tif (stringBeginCharacter == ' ' && (c == '\"' || c == '\\'')) {\r\n\t\t\t\t// QUOTED STRING: GET UNTIL THE END OF QUOTING\r\n\t\t\t\tstringBeginCharacter = c;\r\n\t\t\t} else if (stringBeginCharacter != ' ') {\r\n\t\t\t\tif (c == stringBeginCharacter) {\r\n\t\t\t\t\tstringBeginCharacter = ' ';\r\n\r\n\t\t\t\t\tif (openBraket == 0 && openBraces == 0) {\r\n\t\t\t\t\t\tif (iAdvanceWhenNotFound)\r\n\t\t\t\t\t\t\tcurrentPos++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (c == '(') {\r\n\t\t\t\topenBraces++;\r\n\t\t\t} else if (c == ')') {\r\n\t\t\t\topenBraces--;\r\n\t\t\t} else if (c == '[') {\r\n\t\t\t\topenBraket++;\r\n\t\t\t} else if (c == ']') {\r\n\t\t\t\topenBraket--;\r\n\t\t\t\tif (openBraket == 0 && openBraces == 0) {\r\n\t\t\t\t\tcurrentPos++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} else if (c == ' ' && openBraces == 0) {\r\n\t\t\t\tbreak;\r\n\t\t\t} else if (!Character.isLetter(c) && !Character.isDigit(c) && c != '.' && openBraces == 0 && openBraket == 0) {\r\n\t\t\t\tif (iAdvanceWhenNotFound)\r\n\t\t\t\t\tcurrentPos++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new String[] { textUpperCase.substring(begin, currentPos), text.substring(begin, currentPos) };\r\n\t}","id":43813,"modified_method":"private String[] nextValue(final boolean iAdvanceWhenNotFound) {\r\n\t\tif (!jumpWhiteSpaces())\r\n\t\t\treturn null;\r\n\r\n\t\tint begin = currentPos;\r\n\t\tchar c;\r\n\t\tchar stringBeginCharacter = ' ';\r\n\t\tint openBraces = 0;\r\n\t\tint openBraket = 0;\r\n\r\n\t\tfor (; currentPos < text.length(); ++currentPos) {\r\n\t\t\tc = text.charAt(currentPos);\r\n\r\n\t\t\tif (stringBeginCharacter == ' ' && (c == '\"' || c == '\\'')) {\r\n\t\t\t\t// QUOTED STRING: GET UNTIL THE END OF QUOTING\r\n\t\t\t\tstringBeginCharacter = c;\r\n\t\t\t} else if (stringBeginCharacter != ' ') {\r\n\t\t\t\tif (c == stringBeginCharacter) {\r\n\t\t\t\t\tstringBeginCharacter = ' ';\r\n\r\n\t\t\t\t\tif (openBraket == 0 && openBraces == 0) {\r\n\t\t\t\t\t\tif (iAdvanceWhenNotFound)\r\n\t\t\t\t\t\t\tcurrentPos++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (c == '(') {\r\n\t\t\t\topenBraces++;\r\n\t\t\t} else if (c == ')') {\r\n\t\t\t\topenBraces--;\r\n\t\t\t} else if (c == '[') {\r\n\t\t\t\topenBraket++;\r\n\t\t\t} else if (c == ']') {\r\n\t\t\t\topenBraket--;\r\n\t\t\t\tif (openBraket == 0 && openBraces == 0) {\r\n\t\t\t\t\tcurrentPos++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} else if (c == ' ' && openBraces == 0) {\r\n\t\t\t\tbreak;\r\n\t\t\t} else if (!Character.isLetter(c) && !Character.isDigit(c) && c != '.' && c != '-' && c != '+' && openBraces == 0\r\n\t\t\t\t\t&& openBraket == 0) {\r\n\t\t\t\tif (iAdvanceWhenNotFound)\r\n\t\t\t\t\tcurrentPos++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new String[] { textUpperCase.substring(begin, currentPos), text.substring(begin, currentPos) };\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected OSQLCondition extractCondition() {\r\n\t\tif (!jumpWhiteSpaces())\r\n\t\t\t// END OF TEXT\r\n\t\t\treturn null;\r\n\r\n\t\t// CREATE THE CONDITION OBJECT\r\n\t\treturn new OSQLCondition(extractConditionItem(), extractConditionOperator(), extractConditionItem());\r\n\t}","id":43814,"modified_method":"protected OSQLCondition extractCondition() {\r\n\t\tif (!jumpWhiteSpaces())\r\n\t\t\t// END OF TEXT\r\n\t\t\treturn null;\r\n\r\n\t\tbraces = 0;\r\n\r\n\t\t// CREATE THE CONDITION OBJECT\r\n\t\treturn new OSQLCondition(extractConditionItem(), extractConditionOperator(), extractConditionItem());\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private Object extractConditionItem() {\r\n\t\tObject result = null;\r\n\t\tString[] words = nextValue(true);\r\n\t\tif (words == null)\r\n\t\t\treturn null;\r\n\r\n\t\tif (words[0].startsWith(OQueryHelper.OPEN_BRACE)) {\r\n\t\t\t// SUB-CONDITION\r\n\t\t\tcurrentPos = currentPos - words[0].length() + 1;\r\n\r\n\t\t\tOSQLCondition subCondition = new OSQLCondition(extractConditionItem(), extractConditionOperator(), extractConditionItem());\r\n\r\n\t\t\tcurrentPos++;\r\n\r\n\t\t\treturn subCondition;\r\n\t\t} else if (words[0].startsWith(OQueryHelper.OPEN_COLLECTION)) {\r\n\t\t\t// COLLECTION OF ELEMENTS\r\n\t\t\tcurrentPos = currentPos - words[0].length() + 1;\r\n\r\n\t\t\tList<Object> coll = new ArrayList<Object>();\r\n\r\n\t\t\tString[] item;\r\n\t\t\tObject v;\r\n\t\t\tdo {\r\n\t\t\t\titem = nextValue(true);\r\n\r\n\t\t\t\tv = getValue(item);\r\n\t\t\t\tcoll.add(v);\r\n\r\n\t\t\t\titem = nextValue(true);\r\n\t\t\t} while (item != null && item[0].equals(OQueryHelper.COLLECTION_SEPARATOR));\r\n\r\n\t\t\tcurrentPos++;\r\n\r\n\t\t\treturn coll;\r\n\t\t} else if (words[0].startsWith(KEYWORD_COLUMN)) {\r\n\t\t\tString[] parameters = OQueryHelper.getParameters(words[0]);\r\n\t\t\tif (parameters.length != 1)\r\n\t\t\t\tthrow new OQueryParsingException(\"Missed column number\", text, currentPos);\r\n\t\t\tresult = new OSQLItemColumn(Integer.parseInt(parameters[0]));\r\n\t\t} else\r\n\t\t\tresult = getValue(words);\r\n\r\n\t\treturn result;\r\n\t}","id":43815,"modified_method":"private Object extractConditionItem() {\r\n\t\tObject result = null;\r\n\t\tString[] words = nextValue(true);\r\n\t\tif (words == null)\r\n\t\t\treturn null;\r\n\r\n\t\tif (words[0].startsWith(OQueryHelper.OPEN_BRACE)) {\r\n\t\t\tbraces++;\r\n\r\n\t\t\t// SUB-CONDITION\r\n\t\t\tcurrentPos = currentPos - words[0].length() + 1;\r\n\r\n\t\t\tOSQLCondition subCondition = new OSQLCondition(extractConditionItem(), extractConditionOperator(), extractConditionItem());\r\n\r\n\t\t\tjumpWhiteSpaces();\r\n\r\n\t\t\tcurrentPos++;\r\n\r\n\t\t\tbraces--;\r\n\r\n\t\t\treturn subCondition;\r\n\t\t} else if (words[0].startsWith(OQueryHelper.OPEN_COLLECTION)) {\r\n\t\t\t// COLLECTION OF ELEMENTS\r\n\t\t\tcurrentPos = currentPos - words[0].length() + 1;\r\n\r\n\t\t\tList<Object> coll = new ArrayList<Object>();\r\n\r\n\t\t\tString[] item;\r\n\t\t\tObject v;\r\n\t\t\tdo {\r\n\t\t\t\titem = nextValue(true);\r\n\r\n\t\t\t\tv = getValue(item);\r\n\t\t\t\tcoll.add(v);\r\n\r\n\t\t\t\titem = nextValue(true);\r\n\t\t\t} while (item != null && item[0].equals(OQueryHelper.COLLECTION_SEPARATOR));\r\n\r\n\t\t\tcurrentPos++;\r\n\r\n\t\t\treturn coll;\r\n\t\t} else if (words[0].startsWith(KEYWORD_COLUMN)) {\r\n\r\n\t\t\tString[] parameters = OQueryHelper.getParameters(words[0]);\r\n\t\t\tif (parameters.length != 1)\r\n\t\t\t\tthrow new OQueryParsingException(\"Missed column number\", text, currentPos);\r\n\t\t\tresult = new OSQLItemColumn(Integer.parseInt(parameters[0]));\r\n\r\n\t\t} else if (words[0].startsWith(OSQLFieldAll.NAME + \"(\")) {\r\n\r\n\t\t\tString[] parameters = OQueryHelper.getParameters(words[0]);\r\n\t\t\tresult = new OSQLFieldAll(this, parameters);\r\n\r\n\t\t} else if (words[0].startsWith(OSQLFieldAny.NAME + \"(\")) {\r\n\r\n\t\t\tString[] parameters = OQueryHelper.getParameters(words[0]);\r\n\t\t\tresult = new OSQLFieldAny(this, parameters);\r\n\r\n\t\t} else\r\n\t\t\tresult = getValue(words);\r\n\r\n\t\treturn result;\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private Object getValue(final String[] words) {\r\n\t\tif (words[0].startsWith(\"'\") || words[0].startsWith(\"\\\"\"))\r\n\t\t\treturn stringContent(words[1]);\r\n\t\telse if (Character.isDigit(words[0].charAt(0)) || words[0].charAt(0) == '+' || words[0].charAt(0) == '-') {\r\n\t\t\tif (words[0].contains(\".\"))\r\n\t\t\t\treturn new Float(words[0]);\r\n\t\t\telse if (Character.isDigit(words[0].charAt(0)))\r\n\t\t\t\treturn new Integer(words[0]);\r\n\t\t}\r\n\r\n\t\treturn new OSQLField(this, words[1]);\r\n\t}","id":43816,"modified_method":"private Object getValue(final String[] words) {\r\n\t\tif (words[0].startsWith(\"'\") || words[0].startsWith(\"\\\"\"))\r\n\t\t\treturn stringContent(words[1]);\r\n\t\telse if (Character.isDigit(words[0].charAt(0)) || words[0].charAt(0) == '+' || words[0].charAt(0) == '-') {\r\n\t\t\tif (words[0].contains(\".\"))\r\n\t\t\t\treturn new Float(words[0]);\r\n\t\t\telse\r\n\t\t\t\treturn new Integer(words[0]);\r\n\t\t}\r\n\r\n\t\treturn new OSQLField(this, words[1]);\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OSQLValueAny(final Object[] iValues) {\r\n\t\tvalues = iValues;\r\n\t}","id":43817,"modified_method":"public OSQLValueAny(final Object[] iValues) {\r\n\t\tsuper(iValues);\r\n\t}","commit_id":"057ba964d183fac6a7dc94a73d461d6a8500c70a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprotected boolean evaluateExpression(final ORecordInternal<?> iRecord, final OSQLFilterCondition iCondition, final Object iLeft,\r\n\t\t\tfinal Object iRight) {\r\n\t\tOSQLFilterCondition condition;\r\n\r\n\t\ttry {\r\n\t\t\tcondition = (OSQLFilterCondition) (iCondition.getLeft() instanceof OSQLFilterCondition ? iCondition.getLeft() : iCondition\r\n\t\t\t\t\t.getRight());\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new OCommandExecutionException(\"Operator contains needs a condition to apply\", e);\r\n\t\t}\r\n\r\n\t\tif (iLeft instanceof Collection<?>) {\r\n\r\n\t\t\tCollection<ORecordSchemaAware<?>> collection = (Collection<ORecordSchemaAware<?>>) iLeft;\r\n\t\t\tfor (ORecordSchemaAware<?> o : collection) {\r\n\t\t\t\tif ((Boolean) condition.evaluate(o) == Boolean.TRUE)\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iRight instanceof Collection<?>) {\r\n\r\n\t\t\tCollection<ORecordSchemaAware<?>> collection = (Collection<ORecordSchemaAware<?>>) iRight;\r\n\t\t\tfor (ORecordSchemaAware<?> o : collection) {\r\n\t\t\t\tif ((Boolean) condition.evaluate(o) == Boolean.TRUE)\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":43818,"modified_method":"@Override\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprotected boolean evaluateExpression(final ORecordInternal<?> iRecord, final OSQLFilterCondition iCondition, final Object iLeft,\r\n\t\t\tfinal Object iRight) {\r\n\t\tfinal OSQLFilterCondition condition;\r\n\r\n\t\tif (iCondition.getLeft() instanceof OSQLFilterCondition)\r\n\t\t\tcondition = (OSQLFilterCondition) iCondition.getLeft();\r\n\t\telse if (iCondition.getRight() instanceof OSQLFilterCondition)\r\n\t\t\tcondition = (OSQLFilterCondition) iCondition.getRight();\r\n\t\telse\r\n\t\t\tcondition = null;\r\n\r\n\t\tif (iLeft instanceof Collection<?>) {\r\n\r\n\t\t\tfinal Collection<ORecordSchemaAware<?>> collection = (Collection<ORecordSchemaAware<?>>) iLeft;\r\n\r\n\t\t\tif (condition != null) {\r\n\t\t\t\t// CHECK AGAINST A CONDITION\r\n\t\t\t\tfor (ORecordSchemaAware<?> o : collection) {\r\n\t\t\t\t\tif ((Boolean) condition.evaluate(o) == Boolean.TRUE)\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// CHECK AGAINST A SINGLE VALUE\r\n\t\t\t\tfor (Object o : collection) {\r\n\t\t\t\t\tif (OQueryOperatorEquals.equals(iRight, o))\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (iRight instanceof Collection<?>) {\r\n\r\n\t\t\t// CHECK AGAINST A CONDITION\r\n\t\t\tfinal Collection<ORecordSchemaAware<?>> collection = (Collection<ORecordSchemaAware<?>>) iRight;\r\n\r\n\t\t\tif (condition != null) {\r\n\t\t\t\tfor (ORecordSchemaAware<?> o : collection) {\r\n\t\t\t\t\tif ((Boolean) condition.evaluate(o) == Boolean.TRUE)\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// CHECK AGAINST A SINGLE VALUE\r\n\t\t\t\tfor (Object o : collection) {\r\n\t\t\t\t\tif (OQueryOperatorEquals.equals(iLeft, o))\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"d9c36087b1227b33dced8039f0071158e916d2ab","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprotected boolean evaluateExpression(final ORecordInternal<?> iRecord, OSQLFilterCondition iCondition, final Object iLeft,\r\n\t\t\tfinal Object iRight) {\r\n\t\tif (iLeft instanceof Collection<?>) {\r\n\t\t\tCollection<Object> collection = (Collection<Object>) iLeft;\r\n\t\t\tfor (Object o : collection) {\r\n\t\t\t\tif (OQueryOperatorEquals.equals(iRight, o))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iRight instanceof Collection<?>) {\r\n\r\n\t\t\tCollection<Object> collection = (Collection<Object>) iRight;\r\n\t\t\tfor (Object o : collection) {\r\n\t\t\t\tif (OQueryOperatorEquals.equals(iLeft, o))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iLeft.getClass().isArray()) {\r\n\r\n\t\t\tfor (Object o : (Object[]) iLeft) {\r\n\t\t\t\tif (OQueryOperatorEquals.equals(iRight, o))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iRight.getClass().isArray()) {\r\n\r\n\t\t\tfor (Object o : (Object[]) iRight) {\r\n\t\t\t\tif (OQueryOperatorEquals.equals(iLeft, o))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}","id":43819,"modified_method":"@Override\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprotected boolean evaluateExpression(final ORecordInternal<?> iRecord, OSQLFilterCondition iCondition, final Object iLeft,\r\n\t\t\tfinal Object iRight) {\r\n\t\tif (iLeft instanceof Collection<?>) {\r\n\t\t\tfinal Collection<Object> collection = (Collection<Object>) iLeft;\r\n\t\t\tfor (Object o : collection) {\r\n\t\t\t\tif (OQueryOperatorEquals.equals(iRight, o))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iRight instanceof Collection<?>) {\r\n\r\n\t\t\tfinal Collection<Object> collection = (Collection<Object>) iRight;\r\n\t\t\tfor (Object o : collection) {\r\n\t\t\t\tif (OQueryOperatorEquals.equals(iLeft, o))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iLeft.getClass().isArray()) {\r\n\r\n\t\t\tfor (Object o : (Object[]) iLeft) {\r\n\t\t\t\tif (OQueryOperatorEquals.equals(iRight, o))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (iRight.getClass().isArray()) {\r\n\r\n\t\t\tfor (Object o : (Object[]) iRight) {\r\n\t\t\t\tif (OQueryOperatorEquals.equals(iLeft, o))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}","commit_id":"d9c36087b1227b33dced8039f0071158e916d2ab","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public ORecordInternal<?> browseCluster(final int iRequesterId, final ORecordBrowsingListener iListener,\r\n\t\t\tORecordInternal<?> ioRecord, final OCluster cluster, final long iBeginRange, final long iEndRange,\r\n\t\t\tfinal boolean iLockEntireCluster) throws IOException {\r\n\t\tORecordInternal<?> record;\r\n\t\tORawBuffer recordBuffer;\r\n\t\tlong positionInPhyCluster;\r\n\r\n\t\tif (iLockEntireCluster)\r\n\t\t\t// LOCK THE ENTIRE CLUSTER AVOIDING TO LOCK EVERY SINGLE RECORD\r\n\t\t\tcluster.lock();\r\n\r\n\t\ttry {\r\n\t\t\tfinal OClusterPositionIterator iterator = cluster.absoluteIterator(iBeginRange, iEndRange);\r\n\r\n\t\t\tfinal ORecordId rid = new ORecordId(cluster.getId());\r\n\t\t\tfinal ODatabaseRecord database = ioRecord.getDatabase();\r\n\t\t\tORecordInternal<?> recordToCheck = null;\r\n\r\n\t\t\t// BROWSE ALL THE RECORDS\r\n\t\t\twhile (iterator.hasNext()) {\r\n\t\t\t\tpositionInPhyCluster = iterator.next();\r\n\r\n\t\t\t\tif (positionInPhyCluster == -1)\r\n\t\t\t\t\t// NOT VALID POSITION (IT HAS BEEN DELETED)\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\trid.clusterPosition = positionInPhyCluster;\r\n\r\n\t\t\t\t// TRY IN TX\r\n\t\t\t\trecord = database.getTransaction().getEntry(rid);\r\n\t\t\t\tif (record == null)\r\n\t\t\t\t\t// TRY IN CACHE\r\n\t\t\t\t\trecord = database.getCache().findRecord(rid);\r\n\r\n\t\t\t\tif (record != null && record.getRecordType() != ODocument.RECORD_TYPE)\r\n\t\t\t\t\t// WRONG RECORD TYPE: JUMP IT\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (record == null) {\r\n\t\t\t\t\t\t// READ THE RAW RECORD. IF iLockEntireCluster THEN THE READ WILL\r\n\t\t\t\t\t\t// BE NOT-LOCKING, OTHERWISE YES\r\n\t\t\t\t\t\trecordBuffer = readRecord(iRequesterId, cluster, positionInPhyCluster, !iLockEntireCluster);\r\n\t\t\t\t\t\tif (recordBuffer == null)\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\tif (recordBuffer.recordType != ODocument.RECORD_TYPE)\r\n\t\t\t\t\t\t\t// WRONG RECORD TYPE: JUMP IT\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\tif (ioRecord.getRecordType() != recordBuffer.recordType) {\r\n\t\t\t\t\t\t\t// RECORD NULL OR DIFFERENT IN TYPE: CREATE A NEW ONE\r\n\t\t\t\t\t\t\tfinal ORecordInternal<?> newRecord = ORecordFactory.newInstance(recordBuffer.recordType);\r\n\t\t\t\t\t\t\tnewRecord.setDatabase(ioRecord.getDatabase());\r\n\t\t\t\t\t\t\tioRecord = newRecord;\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t// RESET CURRENT RECORD\r\n\t\t\t\t\t\t\tioRecord.reset();\r\n\r\n\t\t\t\t\t\tioRecord.setVersion(recordBuffer.version);\r\n\t\t\t\t\t\tioRecord.setIdentity(cluster.getId(), positionInPhyCluster);\r\n\t\t\t\t\t\tioRecord.fromStream(recordBuffer.buffer);\r\n\t\t\t\t\t\trecordToCheck = ioRecord;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\t// GET THE RECORD CACHED\r\n\t\t\t\t\t\trecordToCheck = record;\r\n\r\n\t\t\t\t\tif (!iListener.foreach(recordToCheck))\r\n\t\t\t\t\t\t// LISTENER HAS INTERRUPTED THE EXECUTION\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tOLogManager.instance().error(this, \"Error on loading record %s. Cause: %s\", recordToCheck.getIdentity(), e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} finally {\r\n\r\n\t\t\tif (iLockEntireCluster)\r\n\t\t\t\t// UNLOCK THE ENTIRE CLUSTER\r\n\t\t\t\tcluster.unlock();\r\n\t\t}\r\n\r\n\t\treturn ioRecord;\r\n\t}","id":43820,"modified_method":"public ORecordInternal<?> browseCluster(final int iRequesterId, final ORecordBrowsingListener iListener,\r\n\t\t\tORecordInternal<?> ioRecord, final OCluster cluster, final long iBeginRange, final long iEndRange,\r\n\t\t\tfinal boolean iLockEntireCluster) throws IOException {\r\n\t\tORecordInternal<?> record;\r\n\t\tORawBuffer recordBuffer;\r\n\t\tlong positionInPhyCluster;\r\n\r\n\t\tif (iLockEntireCluster)\r\n\t\t\t// LOCK THE ENTIRE CLUSTER AVOIDING TO LOCK EVERY SINGLE RECORD\r\n\t\t\tcluster.lock();\r\n\r\n\t\ttry {\r\n\t\t\tfinal OClusterPositionIterator iterator = cluster.absoluteIterator(iBeginRange, iEndRange);\r\n\r\n\t\t\tfinal ORecordId rid = new ORecordId(cluster.getId());\r\n\t\t\tfinal ODatabaseRecord database = ioRecord.getDatabase();\r\n\t\t\tORecordInternal<?> recordToCheck = null;\r\n\r\n\t\t\t// BROWSE ALL THE RECORDS\r\n\t\t\twhile (iterator.hasNext()) {\r\n\t\t\t\tpositionInPhyCluster = iterator.next();\r\n\r\n\t\t\t\tif (positionInPhyCluster == -1)\r\n\t\t\t\t\t// NOT VALID POSITION (IT HAS BEEN DELETED)\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\trid.clusterPosition = positionInPhyCluster;\r\n\r\n\t\t\t\t// TRY IN TX\r\n\t\t\t\trecord = database.getTransaction().getEntry(rid);\r\n\t\t\t\tif (record == null)\r\n\t\t\t\t\t// TRY IN CACHE\r\n\t\t\t\t\trecord = database.getCache().findRecord(rid);\r\n\r\n\t\t\t\tif (record != null && record.getRecordType() != ODocument.RECORD_TYPE)\r\n\t\t\t\t\t// WRONG RECORD TYPE: JUMP IT\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (record == null) {\r\n\t\t\t\t\t\t// READ THE RAW RECORD. IF iLockEntireCluster THEN THE READ WILL\r\n\t\t\t\t\t\t// BE NOT-LOCKING, OTHERWISE YES\r\n\t\t\t\t\t\trecordBuffer = readRecord(iRequesterId, cluster, positionInPhyCluster, !iLockEntireCluster);\r\n\t\t\t\t\t\tif (recordBuffer == null)\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\tif (recordBuffer.recordType != ODocument.RECORD_TYPE)\r\n\t\t\t\t\t\t\t// WRONG RECORD TYPE: JUMP IT\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\tif (ioRecord.getRecordType() != recordBuffer.recordType) {\r\n\t\t\t\t\t\t\t// RECORD NULL OR DIFFERENT IN TYPE: CREATE A NEW ONE\r\n\t\t\t\t\t\t\tfinal ORecordInternal<?> newRecord = ORecordFactory.newInstance(recordBuffer.recordType);\r\n\t\t\t\t\t\t\tnewRecord.setDatabase(ioRecord.getDatabase());\r\n\t\t\t\t\t\t\tioRecord = newRecord;\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t// RESET CURRENT RECORD\r\n\t\t\t\t\t\t\tioRecord.reset();\r\n\r\n\t\t\t\t\t\tioRecord.setVersion(recordBuffer.version);\r\n\t\t\t\t\t\tioRecord.setIdentity(cluster.getId(), positionInPhyCluster);\r\n\t\t\t\t\t\tioRecord.fromStream(recordBuffer.buffer);\r\n\t\t\t\t\t\trecordToCheck = ioRecord;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\t// GET THE RECORD CACHED\r\n\t\t\t\t\t\trecordToCheck = record;\r\n\r\n\t\t\t\t\tif (!iListener.foreach(recordToCheck))\r\n\t\t\t\t\t\t// LISTENER HAS INTERRUPTED THE EXECUTION\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} catch (OCommandExecutionException e) {\r\n\t\t\t\t\t// PASS THROUGH\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tOLogManager.instance().error(this, \"Error on loading record %s. Cause: %s\", recordToCheck.getIdentity(), e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} finally {\r\n\r\n\t\t\tif (iLockEntireCluster)\r\n\t\t\t\t// UNLOCK THE ENTIRE CLUSTER\r\n\t\t\t\tcluster.unlock();\r\n\t\t}\r\n\r\n\t\treturn ioRecord;\r\n\t}","commit_id":"d9c36087b1227b33dced8039f0071158e916d2ab","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static void handleFilter(Bucket data, String mimeType, FilterOperation operation, ResultHandling resultHandling, String resultFilename, ToadletContext ctx, NodeClientCore core)\n            throws ToadletContextClosedException, IOException, BadRequestException {\n        Bucket resultBucket = ctx.getBucketFactory().makeBucket(-1);\n        String resultMimeType = null;\n        boolean unsafe = false;\n        try {\n            FilterStatus status = applyFilter(data, resultBucket, mimeType, operation, core);\n            resultMimeType = status.mimeType;\n        } catch (UnsafeContentTypeException e) {\n            unsafe = true;\n        } catch (IOException e) {\n            Logger.error(ContentFilterToadlet.class, \"IO error running content filter\", e);\n            throw e;\n        }\n\n        if (unsafe) {\n            // copied from Toadlet.sendErrorPage()\n            PageNode page = ctx.getPageMaker().getPageNode(l10n(\"errorUnsafeContentTitle\"), ctx);\n            HTMLNode pageNode = page.outer;\n            HTMLNode contentNode = page.content;\n            \n            HTMLNode infoboxContent = ctx.getPageMaker().getInfobox(\"infobox-error\", l10n(\"errorUnsafeContentTitle\"), contentNode, null, true);\n            infoboxContent.addChild(new HTMLNode(\"#\", l10n(\"errorUnsafeContent\")));\n            infoboxContent.addChild(\"br\");\n            infoboxContent.addChild(\"a\", \"href\", \".\", NodeL10n.getBase().getString(\"Toadlet.returnToPrevPage\"));\n            infoboxContent.addChild(\"br\");\n            addHomepageLink(infoboxContent);\n            \n            byte[] buffer = pageNode.generate().getBytes(\"UTF-8\");\n            ctx.sendReplyHeaders(200, \"OK\", null, \"text/html; charset=utf-8\", buffer.length);\n            ctx.writeData(buffer, 0, buffer.length);\n        } else {\n            if (resultHandling == ResultHandling.DISPLAY) {\n                ctx.sendReplyHeaders(200, \"OK\", null, resultMimeType, resultBucket.size());\n                ctx.writeData(resultBucket);\n            } else if (resultHandling == ResultHandling.SAVE) {\n                MultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n                headers.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + resultFilename + '\"');\n                headers.put(\"Cache-Control\", \"private\");\n                headers.put(\"Content-Transfer-Encoding\", \"binary\");\n                ctx.sendReplyHeaders(200, \"OK\", headers, \"application/force-download\", resultBucket.size());\n                ctx.writeData(resultBucket);\n            } else {\n                throw new BadRequestException(\"result-handling\");\n            }\n        }\n    }","id":43821,"modified_method":"private void handleFilter(Bucket data, String mimeType, FilterOperation operation, ResultHandling resultHandling, String resultFilename, ToadletContext ctx, NodeClientCore core)\n            throws ToadletContextClosedException, IOException, BadRequestException {\n        Bucket resultBucket = ctx.getBucketFactory().makeBucket(-1);\n        String resultMimeType = null;\n        boolean unsafe = false;\n        try {\n            FilterStatus status = applyFilter(data, resultBucket, mimeType, operation, core);\n            resultMimeType = status.mimeType;\n        } catch (UnsafeContentTypeException e) {\n            unsafe = true;\n        } catch (IOException e) {\n            Logger.error(this, \"IO error running content filter\", e);\n            throw e;\n        }\n\n        if (unsafe) {\n        \tsendErrorPage(ctx, 200, l10n(\"errorUnsafeContentTitle\"), l10n(\"errorUnsafeContent\"));\n        } else {\n            if (resultHandling == ResultHandling.DISPLAY) {\n                ctx.sendReplyHeaders(200, \"OK\", null, resultMimeType, resultBucket.size());\n                ctx.writeData(resultBucket);\n            } else if (resultHandling == ResultHandling.SAVE) {\n                MultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n                headers.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + resultFilename + '\"');\n                headers.put(\"Cache-Control\", \"private\");\n                headers.put(\"Content-Transfer-Encoding\", \"binary\");\n                ctx.sendReplyHeaders(200, \"OK\", headers, \"application/force-download\", resultBucket.size());\n                ctx.writeData(resultBucket);\n            } else {\n                throw new BadRequestException(\"result-handling\");\n            }\n        }\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"private static String makeResultFilename(String originalFilename, String mimeType) {\n        String filteredFilename;\n        int p = originalFilename.indexOf('.', 1);\n        if (p > 0) {\n            filteredFilename = originalFilename.substring(0, p) + \".filtered\" + originalFilename.substring(p); \n        } else {\n            filteredFilename = originalFilename + \".filtered\";\n        }\n        filteredFilename = FileUtil.sanitize(filteredFilename, mimeType);\n        return filteredFilename;\n    }","id":43822,"modified_method":"private String makeResultFilename(String originalFilename, String mimeType) {\n        String filteredFilename;\n        int p = originalFilename.indexOf('.', 1);\n        if (p > 0) {\n            filteredFilename = originalFilename.substring(0, p) + \".filtered\" + originalFilename.substring(p); \n        } else {\n            filteredFilename = originalFilename + \".filtered\";\n        }\n        filteredFilename = FileUtil.sanitize(filteredFilename, mimeType);\n        return filteredFilename;\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodGET(URI uri, final HTTPRequest request, final ToadletContext ctx)\n            throws ToadletContextClosedException, IOException, RedirectException {\n        if (container.publicGatewayMode() && !ctx.isAllowedFullAccess()) {\n            super.sendErrorPage(ctx, 403, NodeL10n.getBase().getString(\"Toadlet.unauthorizedTitle\"),\n                    NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n            return;\n        }\n        \n        PageMaker pageMaker = ctx.getPageMaker();\n        \n        PageNode page = pageMaker.getPageNode(l10n(\"pageTitle\"), ctx);\n        HTMLNode pageNode = page.outer;\n        HTMLNode contentNode = page.content;\n\n        contentNode.addChild(ctx.getAlertManager().createSummary());\n\n        contentNode.addChild(createContent(pageMaker, ctx));\n        \n        writeHTMLReply(ctx, 200, \"OK\", null, pageNode.generate());\n    }","id":43823,"modified_method":"public void handleMethodGET(URI uri, final HTTPRequest request, final ToadletContext ctx)\n            throws ToadletContextClosedException, IOException, RedirectException {\n        if (container.publicGatewayMode() && !ctx.isAllowedFullAccess()) {\n            sendErrorPage(ctx, 403, NodeL10n.getBase().getString(\"Toadlet.unauthorizedTitle\"),\n                    NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n            return;\n        }\n        \n        PageMaker pageMaker = ctx.getPageMaker();\n        \n        PageNode page = pageMaker.getPageNode(l10n(\"pageTitle\"), ctx);\n        HTMLNode pageNode = page.outer;\n        HTMLNode contentNode = page.content;\n\n        contentNode.addChild(ctx.getAlertManager().createSummary());\n\n        contentNode.addChild(createContent(pageMaker, ctx));\n        \n        writeHTMLReply(ctx, 200, \"OK\", null, pageNode.generate());\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodPOST(URI uri, final HTTPRequest request, final ToadletContext ctx)\n            throws ToadletContextClosedException, IOException, RedirectException {\n        if (container.publicGatewayMode() && !ctx.isAllowedFullAccess()) {\n            sendErrorPage(ctx, 403, NodeL10n.getBase().getString(\"Toadlet.unauthorizedTitle\"),\n                    NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n            return;\n        }\n        try {\n            // Browse... button on filter page\n            if (request.isPartSet(\"filter-local\")) {\n                try {\n                    FilterOperation filterOperation = getFilterOperation(request);\n                    ResultHandling resultHandling = getResultHandling(request);\n                    String mimeType = request.getPartAsStringFailsafe(\"mime-type\", 100);\n                    MultiValueTable<String, String> responseHeaders = new MultiValueTable<String, String>();\n                    responseHeaders.put(\"Location\", LocalFileFilterToadlet.PATH\n                            + \"?filter-operation=\" + filterOperation\n                            + \"&result-handling=\" + resultHandling\n                            + \"&mime-type=\" + mimeType);\n                    ctx.sendReplyHeaders(302, \"Found\", responseHeaders, null, 0);\n                } catch (BadRequestException e) {\n                    String invalidPart = e.getInvalidRequestPart();\n                    if (invalidPart == \"filter-operation\") {\n                        writeBadRequestError(l10n(\"errorMustSpecifyFilterOperationTitle\"), l10n(\"errorMustSpecifyFilterOperation\"), ctx, true);\n                    } else if (invalidPart == \"result-handling\") {\n                        writeBadRequestError(l10n(\"errorMustSpecifyResultHandlingTitle\"), l10n(\"errorMustSpecifyResultHandling\"), ctx, true);\n                    } else {\n                        writeBadRequestError(l10n(\"errorBadRequestTitle\"), l10n(\"errorBadRequest\"), ctx, true);\n                    }\n                    return;\n                }\n            // Filter button on local file browser\n            } else if (request.isPartSet(LocalFileBrowserToadlet.selectFile)) {\n                handleFilterRequest(request, ctx, core);\n            // Filter File button on filter page\n            } else if (request.isPartSet(\"filter-upload\")) {\n                handleUploadedFilterRequest(request, ctx, core);\n            } else {\n                handleMethodGET(uri, new HTTPRequestImpl(uri, \"GET\"), ctx);\n            }\n        } finally {\n            request.freeParts();\n        }\n    }","id":43824,"modified_method":"public void handleMethodPOST(URI uri, final HTTPRequest request, final ToadletContext ctx)\n            throws ToadletContextClosedException, IOException, RedirectException {\n        if (container.publicGatewayMode() && !ctx.isAllowedFullAccess()) {\n            sendErrorPage(ctx, 403, NodeL10n.getBase().getString(\"Toadlet.unauthorizedTitle\"),\n                    NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n            return;\n        }\n        try {\n            // Browse... button on filter page\n            if (request.isPartSet(\"filter-local\")) {\n                try {\n                    FilterOperation filterOperation = getFilterOperation(request);\n                    ResultHandling resultHandling = getResultHandling(request);\n                    String mimeType = request.getPartAsStringFailsafe(\"mime-type\", 100);\n                    MultiValueTable<String, String> responseHeaders = new MultiValueTable<String, String>();\n                    responseHeaders.put(\"Location\", LocalFileFilterToadlet.PATH\n                            + \"?filter-operation=\" + filterOperation\n                            + \"&result-handling=\" + resultHandling\n                            + \"&mime-type=\" + mimeType);\n                    ctx.sendReplyHeaders(302, \"Found\", responseHeaders, null, 0);\n                } catch (BadRequestException e) {\n                    String invalidPart = e.getInvalidRequestPart();\n                    if (invalidPart == \"filter-operation\") {\n                        writeBadRequestError(l10n(\"errorMustSpecifyFilterOperationTitle\"), l10n(\"errorMustSpecifyFilterOperation\"), ctx, true);\n                    } else if (invalidPart == \"result-handling\") {\n                        writeBadRequestError(l10n(\"errorMustSpecifyResultHandlingTitle\"), l10n(\"errorMustSpecifyResultHandling\"), ctx, true);\n                    } else {\n                        writeBadRequestError(l10n(\"errorBadRequestTitle\"), l10n(\"errorBadRequest\"), ctx, true);\n                    }\n                    return;\n                }\n            // Filter button on local file browser\n            } else if (request.isPartSet(LocalFileBrowserToadlet.selectFile)) {\n                handleFilterRequest(request, ctx, core, true);\n            // Filter File button on filter page\n            } else if (request.isPartSet(\"filter-upload\")) {\n                handleFilterRequest(request, ctx, core, false);\n            } else {\n                handleMethodGET(uri, new HTTPRequestImpl(uri, \"GET\"), ctx);\n            }\n        } finally {\n            request.freeParts();\n        }\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"private static FilterStatus applyFilter(InputStream input, OutputStream output, String mimeType, FilterOperation operation, NodeClientCore core)\n            throws UnsafeContentTypeException, IOException {\n        URI fakeUri;\n        try {\n            fakeUri = new URI(\"http://127.0.0.1:8888/\");\n        } catch (URISyntaxException e) {\n            Logger.error(ContentFilterToadlet.class, \"Inexplicable URI error\", e);\n            return null;\n        }\n        //TODO: check operation, once ContentFilter supports write filtering\n        return ContentFilter.filter(input, output, mimeType, fakeUri, null, null, null,\n                core.getLinkFilterExceptionProvider());\n    }","id":43825,"modified_method":"private FilterStatus applyFilter(InputStream input, OutputStream output, String mimeType, FilterOperation operation, NodeClientCore core)\n            throws UnsafeContentTypeException, IOException {\n        URI fakeUri;\n        try {\n            fakeUri = new URI(\"http://127.0.0.1:8888/\");\n        } catch (URISyntaxException e) {\n            Logger.error(ContentFilterToadlet.class, \"Inexplicable URI error\", e);\n            return null;\n        }\n        //TODO: check operation, once ContentFilter supports write filtering\n        return ContentFilter.filter(input, output, mimeType, fakeUri, null, null, null,\n                core.getLinkFilterExceptionProvider());\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Handle a request to filter a local file.\n     */\n    static void handleFilterRequest(HTTPRequest request, ToadletContext ctx, NodeClientCore core)\n            throws ToadletContextClosedException, IOException {\n        try {\n            FilterOperation filterOperation = getFilterOperation(request);\n            ResultHandling resultHandling = getResultHandling(request);\n            String mimeType = request.getPartAsStringFailsafe(\"mime-type\", 100);\n            String filename = request.getPartAsStringFailsafe(\"filename\", QueueToadlet.MAX_FILENAME_LENGTH);\n            if (filename.length() == 0) {\n                throw new BadRequestException(\"filename\");\n            }\n            if (mimeType.length() == 0) {\n                mimeType = DefaultMIMETypes.guessMIMEType(filename, false);\n            }\n            String resultFilename = makeResultFilename(filename, mimeType);\n            File file = new File(filename);\n            Bucket bucket = new FileBucket(file, true, false, false, false, false);\n            try {\n                handleFilter(bucket, mimeType, filterOperation, resultHandling, resultFilename, ctx, core);\n            } catch (FileNotFoundException e) {\n                writeBadRequestError(l10n(\"errorNoFileOrCannotReadTitle\"), l10n(\"errorNoFileOrCannotRead\", \"file\", filename), ctx, true);\n                return;\n            }\n        } catch (BadRequestException e) {\n            String invalidPart = e.getInvalidRequestPart();\n            if (invalidPart == \"filter-operation\") {\n                writeBadRequestError(l10n(\"errorMustSpecifyFilterOperationTitle\"), l10n(\"errorMustSpecifyFilterOperation\"), ctx, true);\n            } else if (invalidPart == \"result-handling\") {\n                writeBadRequestError(l10n(\"errorMustSpecifyResultHandlingTitle\"), l10n(\"errorMustSpecifyResultHandling\"), ctx, true);\n            } else if (invalidPart == \"filename\") {\n                writeBadRequestError(l10n(\"errorNoFileSelectedTitle\"), l10n(\"errorNoFileSelected\"), ctx, true);\n            } else {\n                writeBadRequestError(l10n(\"errorBadRequestTitle\"), l10n(\"errorBadRequest\"), ctx, true);\n            }\n        }\n    }","id":43826,"modified_method":"/**\n     * Handle a request to filter a file.\n     */\n    private void handleFilterRequest(HTTPRequest request, ToadletContext ctx, NodeClientCore core, boolean localFile)\n            throws ToadletContextClosedException, IOException {\n        try {\n            FilterOperation filterOperation = getFilterOperation(request);\n            ResultHandling resultHandling = getResultHandling(request);\n            String mimeType = request.getPartAsStringFailsafe(\"mime-type\", 100);\n            String filename;\n            Bucket bucket;\n            if (localFile) {\n            \tfilename = request.getPartAsStringFailsafe(\"filename\", QueueToadlet.MAX_FILENAME_LENGTH);\n\t            if (mimeType.length() == 0) {\n\t                mimeType = DefaultMIMETypes.guessMIMEType(filename, false);\n\t            }\n\t            File file = new File(filename);\n\t            bucket = new FileBucket(file, true, false, false, false, false);\n            } else {\n                HTTPUploadedFile file = request.getUploadedFile(\"filename\");\n                if (file == null) {\n                    throw new BadRequestException(\"filename\");\n                }\n                filename = file.getFilename();\n                if (mimeType.length() == 0) {\n                    mimeType = file.getContentType();\n                }\n                bucket = file.getData();\n            }\n            if (filename.length() == 0) {\n                throw new BadRequestException(\"filename\");\n            }\n            String resultFilename = makeResultFilename(filename, mimeType);\n            try {\n                handleFilter(bucket, mimeType, filterOperation, resultHandling, resultFilename, ctx, core);\n            } catch (FileNotFoundException e) {\n                writeBadRequestError(l10n(\"errorNoFileOrCannotReadTitle\"), l10n(\"errorNoFileOrCannotRead\", \"file\", filename), ctx, true);\n            }\n        } catch (BadRequestException e) {\n            String invalidPart = e.getInvalidRequestPart();\n            if (invalidPart == \"filter-operation\") {\n                writeBadRequestError(l10n(\"errorMustSpecifyFilterOperationTitle\"), l10n(\"errorMustSpecifyFilterOperation\"), ctx, true);\n            } else if (invalidPart == \"result-handling\") {\n                writeBadRequestError(l10n(\"errorMustSpecifyResultHandlingTitle\"), l10n(\"errorMustSpecifyResultHandling\"), ctx, true);\n            } else if (invalidPart == \"filename\") {\n                writeBadRequestError(l10n(\"errorNoFileSelectedTitle\"), l10n(\"errorNoFileSelected\"), ctx, true);\n            } else {\n                writeBadRequestError(l10n(\"errorBadRequestTitle\"), l10n(\"errorBadRequest\"), ctx, true);\n            }\n        }\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"public boolean isEnabled (ToadletContext ctx) {\n        boolean fullAccess = (!container.publicGatewayMode()) || ((ctx != null) && ctx.isAllowedFullAccess());\n        return ctx.isAdvancedModeEnabled() && fullAccess;\n    }","id":43827,"modified_method":"public boolean isEnabled (ToadletContext ctx) {\n        boolean fullAccess = !container.publicGatewayMode() || ctx.isAllowedFullAccess();\n        return ctx.isAdvancedModeEnabled() && fullAccess;\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"private static FilterStatus applyFilter(Bucket input, Bucket output, String mimeType, FilterOperation operation, NodeClientCore core)\n            throws UnsafeContentTypeException, IOException {\n        InputStream inputStream = null;\n        OutputStream outputStream = null;\n        try {\n            inputStream = input.getInputStream();\n            outputStream = output.getOutputStream();\n            return applyFilter(inputStream, outputStream, mimeType, operation, core);\n        } finally {\n            Closer.close(inputStream);\n            Closer.close(outputStream);\n        }\n    }","id":43828,"modified_method":"private FilterStatus applyFilter(Bucket input, Bucket output, String mimeType, FilterOperation operation, NodeClientCore core)\n            throws UnsafeContentTypeException, IOException {\n        InputStream inputStream = null;\n        OutputStream outputStream = null;\n        try {\n            inputStream = input.getInputStream();\n            outputStream = output.getOutputStream();\n            return applyFilter(inputStream, outputStream, mimeType, operation, core);\n        } finally {\n            Closer.close(inputStream);\n            Closer.close(outputStream);\n        }\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"private static void writeBadRequestError(String header, String message, ToadletContext context, boolean returnToFilterPage)\n            throws ToadletContextClosedException, IOException {\n        PageMaker pageMaker = context.getPageMaker();\n        PageNode page = pageMaker.getPageNode(header, context);\n        HTMLNode pageNode = page.outer;\n        HTMLNode contentNode = page.content;\n        if (context.isAllowedFullAccess()) {\n            contentNode.addChild(context.getAlertManager().createSummary());\n        }\n        HTMLNode infoboxContent = pageMaker.getInfobox(\"infobox-error\", header, contentNode, \"filter-error\", false);\n        infoboxContent.addChild(\"#\", message);\n        if (returnToFilterPage) {\n            NodeL10n.getBase().addL10nSubstitution(infoboxContent.addChild(\"div\"),\n                    \"ContentFilterToadlet.tryAgainFilterFilePage\", new String[] { \"link\" },\n                    new HTMLNode[] { HTMLNode.link(ContentFilterToadlet.PATH) });\n        }\n        // copied from writeHTMLReply\n        byte[] buffer = pageNode.generate().getBytes(\"UTF-8\");\n        context.sendReplyHeaders(400, \"Bad request\", null, \"text/html; charset=utf-8\", buffer.length);\n        context.writeData(buffer, 0, buffer.length);\n    }","id":43829,"modified_method":"private void writeBadRequestError(String header, String message, ToadletContext context, boolean returnToFilterPage)\n            throws ToadletContextClosedException, IOException {\n        PageMaker pageMaker = context.getPageMaker();\n        PageNode page = pageMaker.getPageNode(header, context);\n        HTMLNode pageNode = page.outer;\n        HTMLNode contentNode = page.content;\n        if (context.isAllowedFullAccess()) {\n            contentNode.addChild(context.getAlertManager().createSummary());\n        }\n        HTMLNode infoboxContent = pageMaker.getInfobox(\"infobox-error\", header, contentNode, \"filter-error\", false);\n        infoboxContent.addChild(\"#\", message);\n        if (returnToFilterPage) {\n            NodeL10n.getBase().addL10nSubstitution(infoboxContent.addChild(\"div\"),\n                    \"ContentFilterToadlet.tryAgainFilterFilePage\", new String[] { \"link\" },\n                    new HTMLNode[] { HTMLNode.link(ContentFilterToadlet.PATH) });\n        }\n        writeHTMLReply(context, 400, \"Bad request\", pageNode.generate());\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"private static ResultHandling getResultHandling(HTTPRequest request)\n            throws BadRequestException {\n        String s = request.getPartAsStringFailsafe(\"result-handling\", 100);\n        try {\n            return ResultHandling.valueOf(s);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(\"result-handling\", e);\n        }\n    }","id":43830,"modified_method":"private ResultHandling getResultHandling(HTTPRequest request)\n            throws BadRequestException {\n        String s = request.getPartAsStringFailsafe(\"result-handling\", 100);\n        try {\n            return ResultHandling.valueOf(s);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(\"result-handling\", e);\n        }\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"private static FilterOperation getFilterOperation(HTTPRequest request)\n            throws BadRequestException {\n        String s = request.getPartAsStringFailsafe(\"filter-operation\", 100);\n        try {\n            return FilterOperation.valueOf(s);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(\"filter-operation\", e);\n        }\n    }","id":43831,"modified_method":"private FilterOperation getFilterOperation(HTTPRequest request)\n            throws BadRequestException {\n        String s = request.getPartAsStringFailsafe(\"filter-operation\", 100);\n        try {\n            return FilterOperation.valueOf(s);\n        } catch (IllegalArgumentException e) {\n            throw new BadRequestException(\"filter-operation\", e);\n        }\n    }","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodPOST(URI uri, HTTPRequest request, final ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\n\t\tif(container.publicGatewayMode() && !ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, NodeL10n.getBase().getString(\"Toadlet.unauthorizedTitle\"), NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// Browse... button on upload page\n\t\t\tif (request.isPartSet(\"insert-local\")) {\n\t\t\t\t\n\t\t\t\tFreenetURI insertURI;\n\t\t\t\tString keyType = request.getPartAsStringFailsafe(\"keytype\", 10);\n\t\t\t\tif (\"CHK\".equals(keyType)) {\n\t\t\t\t\tinsertURI = new FreenetURI(\"CHK@\");\n\t\t\t\t\tif(fiw != null)\n\t\t\t\t\t\tfiw.reportCanonicalInsert();\n\t\t\t\t} else if(\"SSK\".equals(keyType)) {\n\t\t\t\t\tinsertURI = new FreenetURI(\"SSK@\");\n\t\t\t\t\tif(fiw != null)\n\t\t\t\t\t\tfiw.reportRandomInsert();\n\t\t\t\t} else if(\"specify\".equals(keyType)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString u = request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH);\n\t\t\t\t\t\tinsertURI = new FreenetURI(u);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Inserting key: \"+insertURI+\" (\"+u+\")\");\n\t\t\t\t\t} catch (MalformedURLException mue1) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"),\n\t\t\t\t\t\t           l10n(\"errorInvalidURIToU\"), ctx, false, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twriteError(l10n(\"errorMustSpecifyKeyTypeTitle\"),\n\t\t\t\t\t           l10n(\"errorMustSpecifyKeyType\"), ctx, false, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tMultiValueTable<String, String> responseHeaders = new MultiValueTable<String, String>();\n\t\t\t\tresponseHeaders.put(\"Location\", LocalFileInsertToadlet.PATH+\"?key=\"+insertURI.toASCIIString()+\n\t\t\t\t        \"&compress=\"+String.valueOf(request.getPartAsStringFailsafe(\"compress\", 128).length() > 0)+\n\t\t\t\t        \"&compatibilityMode=\"+request.getPartAsStringFailsafe(\"compatibilityMode\", 100)+\n\t\t\t\t        \"&overrideSplitfileKey=\"+request.getPartAsStringFailsafe(\"overrideSplitfileKey\", 65));\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", responseHeaders, null, 0);\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(\"select-location\")) {\n\t\t\t\ttry {\n\t\t\t\t\tthrow new RedirectException(LocalDirectoryConfigToadlet.basePath()+\"/downloads/\");\n\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\t//Shouldn't happen, path is defined as such.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString pass = request.getPartAsStringFailsafe(\"formPassword\", 32);\n\t\t\tif ((pass.length() == 0) || !pass.equals(ctx.getFormPassword())) {\n\t\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t\t\theaders.put(\"Location\", path());\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No formPassword: \"+pass);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(request.isPartSet(\"delete_request\") && (request.getPartAsStringFailsafe(\"delete_request\", 128).length() > 0)) {\n\t\t\t\t// Confirm box\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"confirmDeleteTitle\"), ctx);\n\t\t\t\tHTMLNode inner = page.content;\n\t\t\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-warning\", l10n(\"confirmDeleteTitle\"), inner, \"confirm-delete-title\", true);\n\t\t\t\t\n\t\t\t\tHTMLNode deleteNode = new HTMLNode(\"p\");\n\t\t\t\tHTMLNode deleteForm = ctx.addFormChild(deleteNode, path(), \"queueDeleteForm\");\n\t\t\t\tHTMLNode infoList = deleteForm.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\tpart = part.substring(\"identifier-\".length());\n\t\t\t\t\tif(part.length() > 50) continue; // It's just a number \n\t\t\t\t\t\n\t\t\t\t\tString identifier = request.getPartAsStringFailsafe(\"identifier-\"+part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\tif(identifier == null) continue;\n\t\t\t\t\tString filename = request.getPartAsStringFailsafe(\"filename-\"+part, MAX_FILENAME_LENGTH);\n\t\t\t\t\tString keyString = request.getPartAsStringFailsafe(\"key-\"+part, MAX_KEY_LENGTH);\n\t\t\t\t\tString type = request.getPartAsStringFailsafe(\"type-\"+part, MAX_TYPE_LENGTH);\n\t\t\t\t\tString size = request.getPartAsStringFailsafe(\"size-\"+part, 50);\n\t\t\t\t\tif(filename != null) {\n\t\t\t\t\t\tHTMLNode line = infoList.addChild(\"li\");\n\t\t\t\t\t\tline.addChild(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.filenameLabel\")+\" \");\n\t\t\t\t\t\tif(keyString != null) {\n\t\t\t\t\t\t\tline.addChild(\"a\", \"href\", \"/\"+keyString, filename);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tline.addChild(\"#\", filename);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(type != null && !type.equals(\"\")) {\n\t\t\t\t\t\tHTMLNode line = infoList.addChild(\"li\");\n\t\t\t\t\t\tboolean finalized = request.isPartSet(\"finalizedType\");\n\t\t\t\t\t\tline.addChild(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.\"+(finalized ? \"mimeType\" : \"expectedMimeType\"), new String[] { \"mime\" }, new String[] { type }));\n\t\t\t\t\t}\n\t\t\t\t\tif(size != null) {\n\t\t\t\t\t\tHTMLNode line = infoList.addChild(\"li\");\n\t\t\t\t\t\tline.addChild(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.sizeLabel\") + \" \" + size);\n\t\t\t\t\t}\n\t\t\t\t\tinfoList.addChild(\"#\", l10n(\"deleteFileFromTemp\"));\n\t\t\t\t\tinfoList.addChild(\"input\", new String[] { \"type\", \"name\", \"value\", \"checked\" },\n\t\t\t\t\t        new String[] { \"checkbox\", \"identifier-\"+part, identifier, \"checked\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontent.addChild(\"p\", l10n(\"confirmDelete\"));\n\t\t\t\tcontent.addChild(deleteNode);\n\n\t\t\t\tdeleteForm.addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"submit\", \"remove_request\", NodeL10n.getBase().getString(\"Toadlet.yes\") });\n\t\t\t\tdeleteForm.addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"submit\", \"cancel\", NodeL10n.getBase().getString(\"Toadlet.no\") });\n\n\t\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", page.outer.generate());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"remove_request\") && (request.getPartAsStringFailsafe(\"remove_request\", 128).length() > 0)) {\n\t\t\t\t\n\t\t\t\t// FIXME optimise into a single database job.\n\t\t\t\t\n\t\t\t\tString identifier = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\t\tidentifier = part.substring(\"identifier-\".length());\n\t\t\t\t\t\tif(identifier.length() > 50) continue;\n\t\t\t\t\t\tidentifier = request.getPartAsStringFailsafe(part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing \"+identifier);\n\t\t\t\t\t\tfcp.removeGlobalRequestBlocking(identifier);\n\t\t\t\t\t}\n\t\t\t\t} catch (MessageInvalidException e) {\n\t\t\t\t\tthis.sendErrorPage(ctx, 200,\n\t\t\t\t\t\t\tl10n(\"failedToRemoveRequest\"),\n\t\t\t\t\t\t\tl10n(\"failedToRemove\",\n\t\t\t\t\t\t\t        new String[]{ \"id\", \"message\" },\n\t\t\t\t\t\t\t        new String[]{ identifier, e.getMessage()}\n\t\t\t\t\t\t\t));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"remove_finished_uploads_request\") && (request.getPartAsStringFailsafe(\"remove_finished_uploads_request\", 128).length() > 0)) {\n\t\t\t\tString identifier = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tRequestStatus[] reqs;\n\t\t\t\t\treqs = fcp.getGlobalRequests();\n                                        for(RequestStatus r : reqs) {\n\t\t\t\t\t\tif(r instanceof UploadFileRequestStatus) {\n\t\t\t\t\t\t\tUploadFileRequestStatus upload = (UploadFileRequestStatus)r;\n\t\t\t\t\t\t\tif(upload.hasSucceeded()) {\n\t\t\t\t\t\t\t\tidentifier = upload.getIdentifier();\n\t\t\t\t\t\t\t\tfcp.removeGlobalRequestBlocking(identifier);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t} catch (MessageInvalidException e) {\n\t\t\t\t\tthis.sendErrorPage(ctx, 200,\n\t\t\t\t\t\t\tl10n(\"failedToRemoveRequest\"),\n\t\t\t\t\t\t\tl10n(\"failedToRemove\",\n\t\t\t\t\t\t\t        new String[]{ \"id\", \"message\" },\n\t\t\t\t\t\t\t        new String[]{ identifier, e.getMessage()}\n\t\t\t\t\t\t\t));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\t} else if(request.isPartSet(\"remove_finished_downloads_request\") && (request.getPartAsStringFailsafe(\"remove_finished_downloads_request\", 128).length() > 0)) {\n\t\t\t\tString identifier = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tRequestStatus[] reqs;\n\t\t\t\t\treqs = fcp.getGlobalRequests();\n\t\t\t\t\t\n\t\t\t\t\tboolean hasIdentifier = false;\n\t\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\t\thasIdentifier = true;\n\t\t\t\t\t\tidentifier = part.substring(\"identifier-\".length());\n\t\t\t\t\t\tif(identifier.length() > 50) continue;\n\t\t\t\t\t\tidentifier = request.getPartAsStringFailsafe(part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing \"+identifier);\n\t\t\t\t\t\tfcp.removeGlobalRequestBlocking(identifier);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!hasIdentifier) { // delete all, because no identifier is given\n\t\t\t\t\t\tfor(RequestStatus r : reqs) {\n\t\t\t\t\t\t\tif(r instanceof DownloadRequestStatus) {\n\t\t\t\t\t\t\t\tDownloadRequestStatus download = (DownloadRequestStatus)r;\n\t\t\t\t\t\t\t\tif(download.isPersistent() && download.hasSucceeded() && download.isTotalFinalized() && !download.toTempSpace()) {\n\t\t\t\t\t\t\t\t\tidentifier = download.getIdentifier();\n\t\t\t\t\t\t\t\t\tfcp.removeGlobalRequestBlocking(identifier);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (MessageInvalidException e) {\n\t\t\t\t\tthis.sendErrorPage(ctx, 200,\n\t\t\t\t\t\t\tl10n(\"failedToRemoveRequest\"),\n\t\t\t\t\t\t\tl10n(\"failedToRemove\",\n\t\t\t\t\t\t\t        new String[]{ \"id\", \"message\" },\n\t\t\t\t\t\t\t        new String[]{ identifier, e.getMessage()}\n\t\t\t\t\t\t\t));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if(request.isPartSet(\"restart_request\") && (request.getPartAsStringFailsafe(\"restart_request\", 128).length() > 0)) {\n\t\t\t\tboolean disableFilterData = request.isPartSet(\"disableFilterData\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tString identifier = \"\";\n\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\tidentifier = part.substring(\"identifier-\".length());\n\t\t\t\t\tif(identifier.length() > 50) continue;\n\t\t\t\t\tidentifier = request.getPartAsStringFailsafe(part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Restarting \"+identifier);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfcp.restartBlocking(identifier, disableFilterData);\n\t\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"panic\") && (request.getPartAsStringFailsafe(\"panic\", 128).length() > 0)) {\n\t\t\t\tif(SimpleToadletServer.noConfirmPanic) {\n\t\t\t\t\tcore.node.killMasterKeysFile();\n\t\t\t\t\tcore.node.panic();\n\t\t\t\t\tsendPanicingPage(ctx);\n\t\t\t\t\tcore.node.finishPanic();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tsendConfirmPanicPage(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(request.isPartSet(\"confirmpanic\") && (request.getPartAsStringFailsafe(\"confirmpanic\", 128).length() > 0)) {\n\t\t\t\tcore.node.killMasterKeysFile();\n\t\t\t\tcore.node.panic();\n\t\t\t\tsendPanicingPage(ctx);\n\t\t\t\tcore.node.finishPanic();\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"download\")) {\n\t\t\t\t// Queue a download\n\t\t\t\tif(!request.isPartSet(\"key\")) {\n\t\t\t\t\twriteError(l10n(\"errorNoKey\"), l10n(\"errorNoKeyToD\"), ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString expectedMIMEType = null;\n\t\t\t\tif(request.isPartSet(\"type\")) {\n\t\t\t\t\texpectedMIMEType = request.getPartAsStringFailsafe(\"type\", MAX_TYPE_LENGTH);\n\t\t\t\t}\n\t\t\t\tFreenetURI fetchURI;\n\t\t\t\ttry {\n\t\t\t\t\tfetchURI = new FreenetURI(request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH));\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToD\"), ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString persistence = request.getPartAsStringFailsafe(\"persistence\", 32);\n\t\t\t\tString returnType = request.getPartAsStringFailsafe(\"return-type\", 32);\n\t\t\t\tboolean filterData = request.isPartSet(\"filterData\");\n\t\t\t\tString downloadPath;\n\t\t\t\tFile downloadsDir = null;\n\t\t\t\t//Download to disk disabled and initialized.\n\t\t\t\tif (request.isPartSet(\"path\") && !core.isDownloadDisabled()) {\n\t\t\t\t\tdownloadPath = request.getPartAsStringFailsafe(\"path\", MAX_FILENAME_LENGTH);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdownloadsDir = getDownloadsDir(downloadPath);\n\t\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\t\tdownloadDisallowedPage(e, downloadPath, ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t//Downloading to disk not initialized and/or disabled.\n\t\t\t\t} else returnType = \"direct\";\n\t\t\t\ttry {\n\t\t\t\t\tfcp.makePersistentGlobalRequestBlocking(fetchURI, filterData, expectedMIMEType, persistence, returnType, false, downloadsDir);\n\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\tthis.writeError(l10n(\"QueueToadlet.errorDToDisk\"), l10n(\"QueueToadlet.errorDToDiskConfig\"), ctx);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"bulkDownloads\")) {\n\t\t\t\tString bulkDownloadsAsString = request.getPartAsStringFailsafe(\"bulkDownloads\", 262144);\n\t\t\t\tString[] keys = bulkDownloadsAsString.split(\"\\n\");\n\t\t\t\tif((\"\".equals(bulkDownloadsAsString)) || (keys.length < 1)) {\n\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tLinkedList<String> success = new LinkedList<String>(), failure = new LinkedList<String>();\n\t\t\t\tboolean filterData = request.isPartSet(\"filterData\");\n\t\t\t\tString target = request.getPartAsStringFailsafe(\"target\", 128);\n\t\t\t\tif(target == null) target = \"direct\";\n\t\t\t\tString downloadPath;\n\t\t\t\tFile downloadsDir = null;\n\t\t\t\tif (request.isPartSet(\"path\") && !core.isDownloadDisabled()) {\n\t\t\t\t\tdownloadPath = request.getPartAsStringFailsafe(\"path\", MAX_FILENAME_LENGTH);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdownloadsDir = getDownloadsDir(downloadPath);\n\t\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\t\tdownloadDisallowedPage(e, downloadPath, ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else target = \"direct\";\n\n\t\t\t\tfor(int i=0; i<keys.length; i++) {\n\t\t\t\t\tString currentKey = keys[i];\n\n\t\t\t\t\t// trim leading/trailing space\n\t\t\t\t\tcurrentKey = currentKey.trim();\n\t\t\t\t\tif (currentKey.length() == 0)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFreenetURI fetchURI = new FreenetURI(currentKey);\n\t\t\t\t\t\tfcp.makePersistentGlobalRequestBlocking(fetchURI, filterData, null,\n\t\t\t\t\t\t        \"forever\", target, false, downloadsDir);\n\t\t\t\t\t\tsuccess.add(fetchURI.toString(true, false));\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tfailure.add(currentKey);\n\t\t\t\t\t\tLogger.error(this,\n\t\t\t\t\t\t        \"An error occured while attempting to download key(\"+i+\") : \"+\n\t\t\t\t\t\t        currentKey+ \" : \"+e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tboolean displayFailureBox = failure.size() > 0;\n\t\t\t\tboolean displaySuccessBox = success.size() > 0;\n\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"downloadFiles\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\t\tHTMLNode alertContent = ctx.getPageMaker().getInfobox(\n\t\t\t\t        (displayFailureBox ? \"infobox-warning\" : \"infobox-info\"),\n\t\t\t\t        l10n(\"downloadFiles\"), contentNode, \"grouped-downloads\", true);\n\t\t\t\tif(displaySuccessBox) {\n\t\t\t\t\tHTMLNode successDiv = alertContent.addChild(\"ul\");\n\t\t\t\t\tsuccessDiv.addChild(\"#\", l10n(\"enqueuedSuccessfully\", \"number\",\n\t\t\t\t\t        String.valueOf(success.size())));\n\t\t\t\t\tfor(String s: success) {\n\t\t\t\t\t\tHTMLNode line = successDiv.addChild(\"li\");\n\t\t\t\t\t\tline.addChild(\"#\", s);\n\t\t\t\t\t}\n\t\t\t\t\tsuccessDiv.addChild(\"br\");\n\t\t\t\t}\n\t\t\t\tif(displayFailureBox) {\n\t\t\t\t\tHTMLNode failureDiv = alertContent.addChild(\"ul\");\n\t\t\t\t\tif(displayFailureBox) {\n\t\t\t\t\t\tfailureDiv.addChild(\"#\", l10n(\"enqueuedFailure\", \"number\",\n\t\t\t\t\t\t        String.valueOf(failure.size())));\n\t\t\t\t\t\tfor(String f: failure) {\n\t\t\t\t\t\t\tHTMLNode line = failureDiv.addChild(\"li\");\n\t\t\t\t\t\t\tline.addChild(\"#\", f);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfailureDiv.addChild(\"br\");\n\t\t\t\t}\n\t\t\t\talertContent.addChild(\"a\", \"href\", path(),\n\t\t\t\t        NodeL10n.getBase().getString(\"Toadlet.returnToQueuepage\"));\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(\"change_priority_top\")) {\n\t\t\t\thandleChangePriority(request, ctx, \"_top\");\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(\"change_priority_bottom\")) {\n\t\t\t\thandleChangePriority(request, ctx, \"_bottom\");\n\t\t\t\treturn;\n\t\t\t\t// FIXME factor out the next 3 items, they are very messy!\n\t\t\t} else if (request.getPartAsStringFailsafe(\"insert\", 128).length() > 0) {\n\t\t\t\tfinal FreenetURI insertURI;\n\t\t\t\tString keyType = request.getPartAsStringFailsafe(\"keytype\", 10);\n\t\t\t\tif (\"CHK\".equals(keyType)) {\n\t\t\t\t\tinsertURI = new FreenetURI(\"CHK@\");\n\t\t\t\t\tif(fiw != null)\n\t\t\t\t\t\tfiw.reportCanonicalInsert();\n\t\t\t\t} else if(\"SSK\".equals(keyType)) {\n\t\t\t\t\tinsertURI = new FreenetURI(\"SSK@\");\n\t\t\t\t\tif(fiw != null)\n\t\t\t\t\t\tfiw.reportRandomInsert();\n\t\t\t\t} else if(\"specify\".equals(keyType)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString u = request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH);\n\t\t\t\t\t\tinsertURI = new FreenetURI(u);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Inserting key: \"+insertURI+\" (\"+u+\")\");\n\t\t\t\t\t} catch (MalformedURLException mue1) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx, false, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twriteError(l10n(\"errorMustSpecifyKeyTypeTitle\"),\n\t\t\t\t\t           l10n(\"errorMustSpecifyKeyType\"), ctx, false, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinal HTTPUploadedFile file = request.getUploadedFile(\"filename\");\n\t\t\t\tif (file == null || file.getFilename().trim().length() == 0) {\n\t\t\t\t\twriteError(l10n(\"errorNoFileSelected\"), l10n(\"errorNoFileSelectedU\"), ctx, false, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinal boolean compress = request.getPartAsStringFailsafe(\"compress\", 128).length() > 0;\n\t\t\t\tfinal String identifier = file.getFilename() + \"-fred-\" + System.currentTimeMillis();\n\t\t\t\tfinal String compatibilityMode = request.getPartAsStringFailsafe(\"compatibilityMode\", 100);\n\t\t\t\tfinal CompatibilityMode cmode;\n\t\t\t\tif(compatibilityMode.equals(\"\"))\n\t\t\t\t\tcmode = CompatibilityMode.COMPAT_CURRENT;\n\t\t\t\telse\n\t\t\t\t\tcmode = CompatibilityMode.valueOf(compatibilityMode);\n\t\t\t\tString s = request.getPartAsStringFailsafe(\"overrideSplitfileKey\", 65);\n\t\t\t\tfinal byte[] overrideSplitfileKey;\n\t\t\t\tif(s != null && !s.equals(\"\"))\n\t\t\t\t\toverrideSplitfileKey = HexUtil.hexToBytes(s);\n\t\t\t\telse\n\t\t\t\t\toverrideSplitfileKey = null;\n\t\t\t\tfinal String fnam;\n\t\t\t\tif(insertURI.getKeyType().equals(\"CHK\") || keyType.equals(\"SSK\"))\n\t\t\t\t\tfnam = file.getFilename();\n\t\t\t\telse\n\t\t\t\t\tfnam = null;\n\t\t\t\t/* copy bucket data */\n\t\t\t\tfinal Bucket copiedBucket = core.persistentTempBucketFactory.makeBucket(file.getData().size());\n\t\t\t\tBucketTools.copy(file.getData(), copiedBucket);\n\t\t\t\tfinal MutableBoolean done = new MutableBoolean();\n\t\t\t\ttry {\n\t\t\t\t\tcore.queue(new DBJob() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\treturn \"QueueToadlet StartInsert\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfinal ClientPut clientPut;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tclientPut = new ClientPut(fcp.getGlobalForeverClient(), insertURI, identifier, Integer.MAX_VALUE, null, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, ClientRequest.PERSIST_FOREVER, null, false, !compress, -1, ClientPutMessage.UPLOAD_FROM_DIRECT, null, file.getContentType(), copiedBucket, null, fnam, false, false, Node.FORK_ON_CACHEABLE_DEFAULT, HighLevelSimpleClientImpl.EXTRA_INSERTS_SINGLE_BLOCK, HighLevelSimpleClientImpl.EXTRA_INSERTS_SPLITFILE_HEADER, false, cmode, overrideSplitfileKey, fcp, container);\n\t\t\t\t\t\t\t\tif(clientPut != null)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfcp.startBlocking(clientPut, container, context);\n\t\t\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorAccessDenied\"), l10n(\"errorAccessDeniedFile\", \"file\", file.getFilename()), ctx, false, true);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorNoFileOrCannotRead\"), l10n(\"errorAccessDeniedFile\", \"file\", file.getFilename()), ctx, false, true);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MalformedURLException mue1) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx, false, true);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Unresolved metadata in starting insert from data uploaded from browser: \"+e, e);\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t// FIXME should this be a proper localised message? It shouldn't happen... but we'd like to get reports if it does.\n\t\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\t\twriteInternalError(t, ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tsynchronized(done) {\n\t\t\t\t\t\t\t\t\tdone.value = true;\n\t\t\t\t\t\t\t\t\tdone.notifyAll();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (ToadletContextClosedException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, NativeThread.HIGH_PRIORITY+1, false);\n\t\t\t\t} catch (DatabaseDisabledException e1) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsynchronized(done) {\n\t\t\t\t\twhile(!done.value)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdone.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(LocalFileBrowserToadlet.selectFile)) {\n\t\t\t\tfinal String filename = request.getPartAsStringFailsafe(\"filename\", MAX_FILENAME_LENGTH);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Inserting local file: \"+filename);\n\t\t\t\tfinal File file = new File(filename);\n\t\t\t\tfinal String identifier = file.getName() + \"-fred-\" + System.currentTimeMillis();\n\t\t\t\tfinal String contentType = DefaultMIMETypes.guessMIMEType(filename, false);\n\t\t\t\tfinal FreenetURI furi;\n\t\t\t\tfinal String key = request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH);\n\t\t\t\tfinal boolean compress = request.isPartSet(\"compress\");\n\t\t\t\tfinal String compatibilityMode = request.getPartAsStringFailsafe(\"compatibilityMode\", 100);\n\t\t\t\tfinal CompatibilityMode cmode;\n\t\t\t\tif(compatibilityMode.equals(\"\"))\n\t\t\t\t\tcmode = CompatibilityMode.COMPAT_CURRENT;\n\t\t\t\telse\n\t\t\t\t\tcmode = CompatibilityMode.valueOf(compatibilityMode);\n\t\t\t\tString s = request.getPartAsStringFailsafe(\"overrideSplitfileKey\", 65);\n\t\t\t\tfinal byte[] overrideSplitfileKey;\n\t\t\t\tif(s != null && !s.equals(\"\"))\n\t\t\t\t\toverrideSplitfileKey = HexUtil.hexToBytes(s);\n\t\t\t\telse\n\t\t\t\t\toverrideSplitfileKey = null;\n\t\t\t\tif(key != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfuri = new FreenetURI(key);\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfuri = new FreenetURI(\"CHK@\");\n\t\t\t\t}\n\t\t\t\tfinal String target;\n\t\t\t\tif(furi.getDocName() != null)\n\t\t\t\t\ttarget = null;\n\t\t\t\telse\n\t\t\t\t\ttarget = file.getName();\n\t\t\t\tfinal MutableBoolean done = new MutableBoolean();\n\t\t\t\ttry {\n\t\t\t\t\tcore.queue(new DBJob() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\treturn \"QueueToadlet StartLocalFileInsert\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tfinal ClientPut clientPut;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tclientPut = new ClientPut(fcp.getGlobalForeverClient(), furi, identifier, Integer.MAX_VALUE, null, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, ClientRequest.PERSIST_FOREVER, null, false, !compress, -1, ClientPutMessage.UPLOAD_FROM_DISK, file, contentType, new FileBucket(file, true, false, false, false, false), null, target, false, false, Node.FORK_ON_CACHEABLE_DEFAULT, HighLevelSimpleClientImpl.EXTRA_INSERTS_SINGLE_BLOCK, HighLevelSimpleClientImpl.EXTRA_INSERTS_SPLITFILE_HEADER, false, cmode, overrideSplitfileKey, fcp, container);\n\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Started global request to insert \"+file+\" to CHK@ as \"+identifier);\n\t\t\t\t\t\t\t\tif(clientPut != null)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfcp.startBlocking(clientPut, container, context);\n\t\t\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\t\t\t\t\t\t// Impossible???\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorNoFileOrCannotRead\"), l10n(\"errorAccessDeniedFile\", \"file\", target), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorAccessDenied\"), l10n(\"errorAccessDeniedFile\", new String[]{ \"file\" }, new String[]{ file.getName() }), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Unresolved metadata in starting insert from data from file: \"+e, e);\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t// FIXME should this be a proper localised message? It shouldn't happen... but we'd like to get reports if it does.\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tsynchronized(done) {\n\t\t\t\t\t\t\t\t\tdone.value = true;\n\t\t\t\t\t\t\t\t\tdone.notifyAll();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (ToadletContextClosedException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, NativeThread.HIGH_PRIORITY+1, false);\n\t\t\t\t} catch (DatabaseDisabledException e1) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsynchronized(done) {\n\t\t\t\t\twhile(!done.value)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdone.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(LocalFileBrowserToadlet.selectDir)) {\n\t\t\t\tfinal String filename = request.getPartAsStringFailsafe(\"filename\", MAX_FILENAME_LENGTH);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Inserting local directory: \"+filename);\n\t\t\t\tfinal File file = new File(filename);\n\t\t\t\tfinal String identifier = file.getName() + \"-fred-\" + System.currentTimeMillis();\n\t\t\t\tfinal FreenetURI furi;\n\t\t\t\tfinal String key = request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH);\n\t\t\t\tfinal boolean compress = request.isPartSet(\"compress\");\n\t\t\t\tString s = request.getPartAsStringFailsafe(\"overrideSplitfileKey\", 65);\n\t\t\t\tfinal byte[] overrideSplitfileKey;\n\t\t\t\tif(s != null && !s.equals(\"\"))\n\t\t\t\t\toverrideSplitfileKey = HexUtil.hexToBytes(s);\n\t\t\t\telse\n\t\t\t\t\toverrideSplitfileKey = null;\n\t\t\t\tif(key != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfuri = new FreenetURI(key);\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfuri = new FreenetURI(\"CHK@\");\n\t\t\t\t}\n\t\t\t\tfinal MutableBoolean done = new MutableBoolean();\n\t\t\t\ttry {\n\t\t\t\t\tcore.queue(new DBJob() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\treturn \"QueueToadlet StartLocalDirInsert\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tClientPutDir clientPutDir;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tclientPutDir = new ClientPutDir(fcp.getGlobalForeverClient(), furi, identifier, Integer.MAX_VALUE, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, ClientRequest.PERSIST_FOREVER, null, false, !compress, -1, file, null, false, /* make include hidden files configurable? FIXME */ false, true, false, false, Node.FORK_ON_CACHEABLE_DEFAULT, HighLevelSimpleClientImpl.EXTRA_INSERTS_SINGLE_BLOCK, HighLevelSimpleClientImpl.EXTRA_INSERTS_SPLITFILE_HEADER, false, overrideSplitfileKey, fcp, container);\n\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Started global request to insert dir \"+file+\" to \"+furi+\" as \"+identifier);\n\t\t\t\t\t\t\t\tif(clientPutDir != null)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfcp.startBlocking(clientPutDir, container, context);\n\t\t\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\t\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same directory twice in same millisecond\");\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorNoFileOrCannotRead\"), l10n(\"QueueToadlet.errorAccessDeniedFile\", \"file\", file.toString()), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (TooManyFilesInsertException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"tooManyFilesInOneFolder\"), l10n(\"tooManyFilesInOneFolder\"), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tsynchronized(done) {\n\t\t\t\t\t\t\t\t\tdone.value = true;\n\t\t\t\t\t\t\t\t\tdone.notifyAll();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (ToadletContextClosedException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, NativeThread.HIGH_PRIORITY+1, false);\n\t\t\t\t} catch (DatabaseDisabledException e1) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsynchronized(done) {\n\t\t\t\t\twhile(!done.value)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdone.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n            // Filter File button on upload page\n            } else if (request.isPartSet(\"filter-upload\")) {\n                ContentFilterToadlet.handleUploadedFilterRequest(request, ctx, core);\n\t\t\t} else if (request.isPartSet(\"recommend_request\")) {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"recommendAFileToFriends\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\tHTMLNode infoboxContent = ctx.getPageMaker().getInfobox(\"#\", l10n(\"recommendAFileToFriends\"), contentNode, \"recommend-file\", true);\n\t\t\t\tHTMLNode form = ctx.addFormChild(infoboxContent, path(), \"recommendForm2\");\n\t\t\t\t\n\t\t\t\tint x = 0;\n\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\tString key = request.getPartAsStringFailsafe(\"key-\"+part.substring(\"identifier-\".length()), MAX_KEY_LENGTH);\n\t\t\t\t\tif(key == null || key.equals(\"\")) continue;\n\t\t\t\t\tform.addChild(\"#\", l10n(\"key\") + \":\");\n\t\t\t\t\tform.addChild(\"br\");\n\t\t\t\t\tform.addChild(\"#\", key);\n\t\t\t\t\tform.addChild(\"br\");\n\t\t\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t\t\t\tnew String[] { \"hidden\", \"key-\"+x, key });\n\t\t\t\t}\n\t\t\t\tform.addChild(\"label\", \"for\", \"descB\", (l10n(\"recommendDescription\") + ' '));\n\t\t\t\tform.addChild(\"br\");\n\t\t\t\tform.addChild(\"textarea\",\n\t\t\t\t        new String[]{\"id\", \"name\", \"row\", \"cols\"},\n\t\t\t\t        new String[]{\"descB\", \"description\", \"3\", \"70\"});\n\t\t\t\tform.addChild(\"br\");\n\n\t\t\t\tHTMLNode peerTable = form.addChild(\"table\", \"class\", \"darknet_connections\");\n\t\t\t\tpeerTable.addChild(\"th\", \"colspan\", \"2\", l10n(\"recommendToFriends\"));\n\t\t\t\tfor(DarknetPeerNode peer : core.node.getDarknetConnections()) {\n\t\t\t\t\tHTMLNode peerRow = peerTable.addChild(\"tr\", \"class\", \"darknet_connections_normal\");\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-marker\").addChild(\"input\",\n\t\t\t\t\t        new String[] { \"type\", \"name\" }, \n\t\t\t\t\t        new String[] { \"checkbox\", \"node_\" + peer.hashCode() });\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-name\").addChild(\"#\", peer.getName());\n\t\t\t\t}\n\n\t\t\t\tform.addChild(\"input\",\n\t\t\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t\t\t        new String[]{\"submit\", \"recommend_uri\", l10n(\"recommend\")});\n\n\t\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"recommend_uri\") && request.isPartSet(\"URI\")) {\n\t\t\t\tString description = request.getPartAsStringFailsafe(\"description\", 32768);\n\t\t\t\tArrayList<FreenetURI> uris = new ArrayList<FreenetURI>();\n\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\tif(!part.startsWith(\"key-\")) continue;\n\t\t\t\t\tString key = request.getPartAsStringFailsafe(part, MAX_KEY_LENGTH);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFreenetURI furi = new FreenetURI(key);\n\t\t\t\t\t\turis.add(furi);\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(DarknetPeerNode peer : core.node.getDarknetConnections()) {\n\t\t\t\t\tif(request.isPartSet(\"node_\" + peer.hashCode())) {\n\t\t\t\t\t\tfor(FreenetURI furi : uris)\n\t\t\t\t\t\t\tpeer.sendDownloadFeed(furi, description);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t}\n\t\t} finally {\n\t\t\trequest.freeParts();\n\t\t}\n\t\tthis.handleMethodGET(uri, new HTTPRequestImpl(uri, \"GET\"), ctx);\n\t}","id":43832,"modified_method":"public void handleMethodPOST(URI uri, HTTPRequest request, final ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\n\t\tif(container.publicGatewayMode() && !ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, NodeL10n.getBase().getString(\"Toadlet.unauthorizedTitle\"), NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// Browse... button on upload page\n\t\t\tif (request.isPartSet(\"insert-local\")) {\n\t\t\t\t\n\t\t\t\tFreenetURI insertURI;\n\t\t\t\tString keyType = request.getPartAsStringFailsafe(\"keytype\", 10);\n\t\t\t\tif (\"CHK\".equals(keyType)) {\n\t\t\t\t\tinsertURI = new FreenetURI(\"CHK@\");\n\t\t\t\t\tif(fiw != null)\n\t\t\t\t\t\tfiw.reportCanonicalInsert();\n\t\t\t\t} else if(\"SSK\".equals(keyType)) {\n\t\t\t\t\tinsertURI = new FreenetURI(\"SSK@\");\n\t\t\t\t\tif(fiw != null)\n\t\t\t\t\t\tfiw.reportRandomInsert();\n\t\t\t\t} else if(\"specify\".equals(keyType)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString u = request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH);\n\t\t\t\t\t\tinsertURI = new FreenetURI(u);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Inserting key: \"+insertURI+\" (\"+u+\")\");\n\t\t\t\t\t} catch (MalformedURLException mue1) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"),\n\t\t\t\t\t\t           l10n(\"errorInvalidURIToU\"), ctx, false, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twriteError(l10n(\"errorMustSpecifyKeyTypeTitle\"),\n\t\t\t\t\t           l10n(\"errorMustSpecifyKeyType\"), ctx, false, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tMultiValueTable<String, String> responseHeaders = new MultiValueTable<String, String>();\n\t\t\t\tresponseHeaders.put(\"Location\", LocalFileInsertToadlet.PATH+\"?key=\"+insertURI.toASCIIString()+\n\t\t\t\t        \"&compress=\"+String.valueOf(request.getPartAsStringFailsafe(\"compress\", 128).length() > 0)+\n\t\t\t\t        \"&compatibilityMode=\"+request.getPartAsStringFailsafe(\"compatibilityMode\", 100)+\n\t\t\t\t        \"&overrideSplitfileKey=\"+request.getPartAsStringFailsafe(\"overrideSplitfileKey\", 65));\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", responseHeaders, null, 0);\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(\"select-location\")) {\n\t\t\t\ttry {\n\t\t\t\t\tthrow new RedirectException(LocalDirectoryConfigToadlet.basePath()+\"/downloads/\");\n\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\t//Shouldn't happen, path is defined as such.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString pass = request.getPartAsStringFailsafe(\"formPassword\", 32);\n\t\t\tif ((pass.length() == 0) || !pass.equals(ctx.getFormPassword())) {\n\t\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t\t\theaders.put(\"Location\", path());\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No formPassword: \"+pass);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(request.isPartSet(\"delete_request\") && (request.getPartAsStringFailsafe(\"delete_request\", 128).length() > 0)) {\n\t\t\t\t// Confirm box\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"confirmDeleteTitle\"), ctx);\n\t\t\t\tHTMLNode inner = page.content;\n\t\t\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-warning\", l10n(\"confirmDeleteTitle\"), inner, \"confirm-delete-title\", true);\n\t\t\t\t\n\t\t\t\tHTMLNode deleteNode = new HTMLNode(\"p\");\n\t\t\t\tHTMLNode deleteForm = ctx.addFormChild(deleteNode, path(), \"queueDeleteForm\");\n\t\t\t\tHTMLNode infoList = deleteForm.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\tpart = part.substring(\"identifier-\".length());\n\t\t\t\t\tif(part.length() > 50) continue; // It's just a number \n\t\t\t\t\t\n\t\t\t\t\tString identifier = request.getPartAsStringFailsafe(\"identifier-\"+part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\tif(identifier == null) continue;\n\t\t\t\t\tString filename = request.getPartAsStringFailsafe(\"filename-\"+part, MAX_FILENAME_LENGTH);\n\t\t\t\t\tString keyString = request.getPartAsStringFailsafe(\"key-\"+part, MAX_KEY_LENGTH);\n\t\t\t\t\tString type = request.getPartAsStringFailsafe(\"type-\"+part, MAX_TYPE_LENGTH);\n\t\t\t\t\tString size = request.getPartAsStringFailsafe(\"size-\"+part, 50);\n\t\t\t\t\tif(filename != null) {\n\t\t\t\t\t\tHTMLNode line = infoList.addChild(\"li\");\n\t\t\t\t\t\tline.addChild(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.filenameLabel\")+\" \");\n\t\t\t\t\t\tif(keyString != null) {\n\t\t\t\t\t\t\tline.addChild(\"a\", \"href\", \"/\"+keyString, filename);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tline.addChild(\"#\", filename);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(type != null && !type.equals(\"\")) {\n\t\t\t\t\t\tHTMLNode line = infoList.addChild(\"li\");\n\t\t\t\t\t\tboolean finalized = request.isPartSet(\"finalizedType\");\n\t\t\t\t\t\tline.addChild(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.\"+(finalized ? \"mimeType\" : \"expectedMimeType\"), new String[] { \"mime\" }, new String[] { type }));\n\t\t\t\t\t}\n\t\t\t\t\tif(size != null) {\n\t\t\t\t\t\tHTMLNode line = infoList.addChild(\"li\");\n\t\t\t\t\t\tline.addChild(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.sizeLabel\") + \" \" + size);\n\t\t\t\t\t}\n\t\t\t\t\tinfoList.addChild(\"#\", l10n(\"deleteFileFromTemp\"));\n\t\t\t\t\tinfoList.addChild(\"input\", new String[] { \"type\", \"name\", \"value\", \"checked\" },\n\t\t\t\t\t        new String[] { \"checkbox\", \"identifier-\"+part, identifier, \"checked\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontent.addChild(\"p\", l10n(\"confirmDelete\"));\n\t\t\t\tcontent.addChild(deleteNode);\n\n\t\t\t\tdeleteForm.addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"submit\", \"remove_request\", NodeL10n.getBase().getString(\"Toadlet.yes\") });\n\t\t\t\tdeleteForm.addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"submit\", \"cancel\", NodeL10n.getBase().getString(\"Toadlet.no\") });\n\n\t\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", page.outer.generate());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"remove_request\") && (request.getPartAsStringFailsafe(\"remove_request\", 128).length() > 0)) {\n\t\t\t\t\n\t\t\t\t// FIXME optimise into a single database job.\n\t\t\t\t\n\t\t\t\tString identifier = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\t\tidentifier = part.substring(\"identifier-\".length());\n\t\t\t\t\t\tif(identifier.length() > 50) continue;\n\t\t\t\t\t\tidentifier = request.getPartAsStringFailsafe(part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing \"+identifier);\n\t\t\t\t\t\tfcp.removeGlobalRequestBlocking(identifier);\n\t\t\t\t\t}\n\t\t\t\t} catch (MessageInvalidException e) {\n\t\t\t\t\tthis.sendErrorPage(ctx, 200,\n\t\t\t\t\t\t\tl10n(\"failedToRemoveRequest\"),\n\t\t\t\t\t\t\tl10n(\"failedToRemove\",\n\t\t\t\t\t\t\t        new String[]{ \"id\", \"message\" },\n\t\t\t\t\t\t\t        new String[]{ identifier, e.getMessage()}\n\t\t\t\t\t\t\t));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"remove_finished_uploads_request\") && (request.getPartAsStringFailsafe(\"remove_finished_uploads_request\", 128).length() > 0)) {\n\t\t\t\tString identifier = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tRequestStatus[] reqs;\n\t\t\t\t\treqs = fcp.getGlobalRequests();\n                                        for(RequestStatus r : reqs) {\n\t\t\t\t\t\tif(r instanceof UploadFileRequestStatus) {\n\t\t\t\t\t\t\tUploadFileRequestStatus upload = (UploadFileRequestStatus)r;\n\t\t\t\t\t\t\tif(upload.hasSucceeded()) {\n\t\t\t\t\t\t\t\tidentifier = upload.getIdentifier();\n\t\t\t\t\t\t\t\tfcp.removeGlobalRequestBlocking(identifier);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t} catch (MessageInvalidException e) {\n\t\t\t\t\tthis.sendErrorPage(ctx, 200,\n\t\t\t\t\t\t\tl10n(\"failedToRemoveRequest\"),\n\t\t\t\t\t\t\tl10n(\"failedToRemove\",\n\t\t\t\t\t\t\t        new String[]{ \"id\", \"message\" },\n\t\t\t\t\t\t\t        new String[]{ identifier, e.getMessage()}\n\t\t\t\t\t\t\t));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\t} else if(request.isPartSet(\"remove_finished_downloads_request\") && (request.getPartAsStringFailsafe(\"remove_finished_downloads_request\", 128).length() > 0)) {\n\t\t\t\tString identifier = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tRequestStatus[] reqs;\n\t\t\t\t\treqs = fcp.getGlobalRequests();\n\t\t\t\t\t\n\t\t\t\t\tboolean hasIdentifier = false;\n\t\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\t\thasIdentifier = true;\n\t\t\t\t\t\tidentifier = part.substring(\"identifier-\".length());\n\t\t\t\t\t\tif(identifier.length() > 50) continue;\n\t\t\t\t\t\tidentifier = request.getPartAsStringFailsafe(part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing \"+identifier);\n\t\t\t\t\t\tfcp.removeGlobalRequestBlocking(identifier);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!hasIdentifier) { // delete all, because no identifier is given\n\t\t\t\t\t\tfor(RequestStatus r : reqs) {\n\t\t\t\t\t\t\tif(r instanceof DownloadRequestStatus) {\n\t\t\t\t\t\t\t\tDownloadRequestStatus download = (DownloadRequestStatus)r;\n\t\t\t\t\t\t\t\tif(download.isPersistent() && download.hasSucceeded() && download.isTotalFinalized() && !download.toTempSpace()) {\n\t\t\t\t\t\t\t\t\tidentifier = download.getIdentifier();\n\t\t\t\t\t\t\t\t\tfcp.removeGlobalRequestBlocking(identifier);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (MessageInvalidException e) {\n\t\t\t\t\tthis.sendErrorPage(ctx, 200,\n\t\t\t\t\t\t\tl10n(\"failedToRemoveRequest\"),\n\t\t\t\t\t\t\tl10n(\"failedToRemove\",\n\t\t\t\t\t\t\t        new String[]{ \"id\", \"message\" },\n\t\t\t\t\t\t\t        new String[]{ identifier, e.getMessage()}\n\t\t\t\t\t\t\t));\n\t\t\t\t\treturn;\n\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if(request.isPartSet(\"restart_request\") && (request.getPartAsStringFailsafe(\"restart_request\", 128).length() > 0)) {\n\t\t\t\tboolean disableFilterData = request.isPartSet(\"disableFilterData\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tString identifier = \"\";\n\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\tidentifier = part.substring(\"identifier-\".length());\n\t\t\t\t\tif(identifier.length() > 50) continue;\n\t\t\t\t\tidentifier = request.getPartAsStringFailsafe(part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Restarting \"+identifier);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfcp.restartBlocking(identifier, disableFilterData);\n\t\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"panic\") && (request.getPartAsStringFailsafe(\"panic\", 128).length() > 0)) {\n\t\t\t\tif(SimpleToadletServer.noConfirmPanic) {\n\t\t\t\t\tcore.node.killMasterKeysFile();\n\t\t\t\t\tcore.node.panic();\n\t\t\t\t\tsendPanicingPage(ctx);\n\t\t\t\t\tcore.node.finishPanic();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tsendConfirmPanicPage(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(request.isPartSet(\"confirmpanic\") && (request.getPartAsStringFailsafe(\"confirmpanic\", 128).length() > 0)) {\n\t\t\t\tcore.node.killMasterKeysFile();\n\t\t\t\tcore.node.panic();\n\t\t\t\tsendPanicingPage(ctx);\n\t\t\t\tcore.node.finishPanic();\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"download\")) {\n\t\t\t\t// Queue a download\n\t\t\t\tif(!request.isPartSet(\"key\")) {\n\t\t\t\t\twriteError(l10n(\"errorNoKey\"), l10n(\"errorNoKeyToD\"), ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString expectedMIMEType = null;\n\t\t\t\tif(request.isPartSet(\"type\")) {\n\t\t\t\t\texpectedMIMEType = request.getPartAsStringFailsafe(\"type\", MAX_TYPE_LENGTH);\n\t\t\t\t}\n\t\t\t\tFreenetURI fetchURI;\n\t\t\t\ttry {\n\t\t\t\t\tfetchURI = new FreenetURI(request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH));\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToD\"), ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString persistence = request.getPartAsStringFailsafe(\"persistence\", 32);\n\t\t\t\tString returnType = request.getPartAsStringFailsafe(\"return-type\", 32);\n\t\t\t\tboolean filterData = request.isPartSet(\"filterData\");\n\t\t\t\tString downloadPath;\n\t\t\t\tFile downloadsDir = null;\n\t\t\t\t//Download to disk disabled and initialized.\n\t\t\t\tif (request.isPartSet(\"path\") && !core.isDownloadDisabled()) {\n\t\t\t\t\tdownloadPath = request.getPartAsStringFailsafe(\"path\", MAX_FILENAME_LENGTH);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdownloadsDir = getDownloadsDir(downloadPath);\n\t\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\t\tdownloadDisallowedPage(e, downloadPath, ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t//Downloading to disk not initialized and/or disabled.\n\t\t\t\t} else returnType = \"direct\";\n\t\t\t\ttry {\n\t\t\t\t\tfcp.makePersistentGlobalRequestBlocking(fetchURI, filterData, expectedMIMEType, persistence, returnType, false, downloadsDir);\n\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\tthis.writeError(l10n(\"QueueToadlet.errorDToDisk\"), l10n(\"QueueToadlet.errorDToDiskConfig\"), ctx);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"bulkDownloads\")) {\n\t\t\t\tString bulkDownloadsAsString = request.getPartAsStringFailsafe(\"bulkDownloads\", 262144);\n\t\t\t\tString[] keys = bulkDownloadsAsString.split(\"\\n\");\n\t\t\t\tif((\"\".equals(bulkDownloadsAsString)) || (keys.length < 1)) {\n\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tLinkedList<String> success = new LinkedList<String>(), failure = new LinkedList<String>();\n\t\t\t\tboolean filterData = request.isPartSet(\"filterData\");\n\t\t\t\tString target = request.getPartAsStringFailsafe(\"target\", 128);\n\t\t\t\tif(target == null) target = \"direct\";\n\t\t\t\tString downloadPath;\n\t\t\t\tFile downloadsDir = null;\n\t\t\t\tif (request.isPartSet(\"path\") && !core.isDownloadDisabled()) {\n\t\t\t\t\tdownloadPath = request.getPartAsStringFailsafe(\"path\", MAX_FILENAME_LENGTH);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdownloadsDir = getDownloadsDir(downloadPath);\n\t\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\t\tdownloadDisallowedPage(e, downloadPath, ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else target = \"direct\";\n\n\t\t\t\tfor(int i=0; i<keys.length; i++) {\n\t\t\t\t\tString currentKey = keys[i];\n\n\t\t\t\t\t// trim leading/trailing space\n\t\t\t\t\tcurrentKey = currentKey.trim();\n\t\t\t\t\tif (currentKey.length() == 0)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFreenetURI fetchURI = new FreenetURI(currentKey);\n\t\t\t\t\t\tfcp.makePersistentGlobalRequestBlocking(fetchURI, filterData, null,\n\t\t\t\t\t\t        \"forever\", target, false, downloadsDir);\n\t\t\t\t\t\tsuccess.add(fetchURI.toString(true, false));\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tfailure.add(currentKey);\n\t\t\t\t\t\tLogger.error(this,\n\t\t\t\t\t\t        \"An error occured while attempting to download key(\"+i+\") : \"+\n\t\t\t\t\t\t        currentKey+ \" : \"+e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tboolean displayFailureBox = failure.size() > 0;\n\t\t\t\tboolean displaySuccessBox = success.size() > 0;\n\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"downloadFiles\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\t\tHTMLNode alertContent = ctx.getPageMaker().getInfobox(\n\t\t\t\t        (displayFailureBox ? \"infobox-warning\" : \"infobox-info\"),\n\t\t\t\t        l10n(\"downloadFiles\"), contentNode, \"grouped-downloads\", true);\n\t\t\t\tif(displaySuccessBox) {\n\t\t\t\t\tHTMLNode successDiv = alertContent.addChild(\"ul\");\n\t\t\t\t\tsuccessDiv.addChild(\"#\", l10n(\"enqueuedSuccessfully\", \"number\",\n\t\t\t\t\t        String.valueOf(success.size())));\n\t\t\t\t\tfor(String s: success) {\n\t\t\t\t\t\tHTMLNode line = successDiv.addChild(\"li\");\n\t\t\t\t\t\tline.addChild(\"#\", s);\n\t\t\t\t\t}\n\t\t\t\t\tsuccessDiv.addChild(\"br\");\n\t\t\t\t}\n\t\t\t\tif(displayFailureBox) {\n\t\t\t\t\tHTMLNode failureDiv = alertContent.addChild(\"ul\");\n\t\t\t\t\tif(displayFailureBox) {\n\t\t\t\t\t\tfailureDiv.addChild(\"#\", l10n(\"enqueuedFailure\", \"number\",\n\t\t\t\t\t\t        String.valueOf(failure.size())));\n\t\t\t\t\t\tfor(String f: failure) {\n\t\t\t\t\t\t\tHTMLNode line = failureDiv.addChild(\"li\");\n\t\t\t\t\t\t\tline.addChild(\"#\", f);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfailureDiv.addChild(\"br\");\n\t\t\t\t}\n\t\t\t\talertContent.addChild(\"a\", \"href\", path(),\n\t\t\t\t        NodeL10n.getBase().getString(\"Toadlet.returnToQueuepage\"));\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(\"change_priority_top\")) {\n\t\t\t\thandleChangePriority(request, ctx, \"_top\");\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(\"change_priority_bottom\")) {\n\t\t\t\thandleChangePriority(request, ctx, \"_bottom\");\n\t\t\t\treturn;\n\t\t\t\t// FIXME factor out the next 3 items, they are very messy!\n\t\t\t} else if (request.getPartAsStringFailsafe(\"insert\", 128).length() > 0) {\n\t\t\t\tfinal FreenetURI insertURI;\n\t\t\t\tString keyType = request.getPartAsStringFailsafe(\"keytype\", 10);\n\t\t\t\tif (\"CHK\".equals(keyType)) {\n\t\t\t\t\tinsertURI = new FreenetURI(\"CHK@\");\n\t\t\t\t\tif(fiw != null)\n\t\t\t\t\t\tfiw.reportCanonicalInsert();\n\t\t\t\t} else if(\"SSK\".equals(keyType)) {\n\t\t\t\t\tinsertURI = new FreenetURI(\"SSK@\");\n\t\t\t\t\tif(fiw != null)\n\t\t\t\t\t\tfiw.reportRandomInsert();\n\t\t\t\t} else if(\"specify\".equals(keyType)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString u = request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH);\n\t\t\t\t\t\tinsertURI = new FreenetURI(u);\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Inserting key: \"+insertURI+\" (\"+u+\")\");\n\t\t\t\t\t} catch (MalformedURLException mue1) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx, false, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twriteError(l10n(\"errorMustSpecifyKeyTypeTitle\"),\n\t\t\t\t\t           l10n(\"errorMustSpecifyKeyType\"), ctx, false, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinal HTTPUploadedFile file = request.getUploadedFile(\"filename\");\n\t\t\t\tif (file == null || file.getFilename().trim().length() == 0) {\n\t\t\t\t\twriteError(l10n(\"errorNoFileSelected\"), l10n(\"errorNoFileSelectedU\"), ctx, false, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinal boolean compress = request.getPartAsStringFailsafe(\"compress\", 128).length() > 0;\n\t\t\t\tfinal String identifier = file.getFilename() + \"-fred-\" + System.currentTimeMillis();\n\t\t\t\tfinal String compatibilityMode = request.getPartAsStringFailsafe(\"compatibilityMode\", 100);\n\t\t\t\tfinal CompatibilityMode cmode;\n\t\t\t\tif(compatibilityMode.equals(\"\"))\n\t\t\t\t\tcmode = CompatibilityMode.COMPAT_CURRENT;\n\t\t\t\telse\n\t\t\t\t\tcmode = CompatibilityMode.valueOf(compatibilityMode);\n\t\t\t\tString s = request.getPartAsStringFailsafe(\"overrideSplitfileKey\", 65);\n\t\t\t\tfinal byte[] overrideSplitfileKey;\n\t\t\t\tif(s != null && !s.equals(\"\"))\n\t\t\t\t\toverrideSplitfileKey = HexUtil.hexToBytes(s);\n\t\t\t\telse\n\t\t\t\t\toverrideSplitfileKey = null;\n\t\t\t\tfinal String fnam;\n\t\t\t\tif(insertURI.getKeyType().equals(\"CHK\") || keyType.equals(\"SSK\"))\n\t\t\t\t\tfnam = file.getFilename();\n\t\t\t\telse\n\t\t\t\t\tfnam = null;\n\t\t\t\t/* copy bucket data */\n\t\t\t\tfinal Bucket copiedBucket = core.persistentTempBucketFactory.makeBucket(file.getData().size());\n\t\t\t\tBucketTools.copy(file.getData(), copiedBucket);\n\t\t\t\tfinal MutableBoolean done = new MutableBoolean();\n\t\t\t\ttry {\n\t\t\t\t\tcore.queue(new DBJob() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\treturn \"QueueToadlet StartInsert\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfinal ClientPut clientPut;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tclientPut = new ClientPut(fcp.getGlobalForeverClient(), insertURI, identifier, Integer.MAX_VALUE, null, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, ClientRequest.PERSIST_FOREVER, null, false, !compress, -1, ClientPutMessage.UPLOAD_FROM_DIRECT, null, file.getContentType(), copiedBucket, null, fnam, false, false, Node.FORK_ON_CACHEABLE_DEFAULT, HighLevelSimpleClientImpl.EXTRA_INSERTS_SINGLE_BLOCK, HighLevelSimpleClientImpl.EXTRA_INSERTS_SPLITFILE_HEADER, false, cmode, overrideSplitfileKey, fcp, container);\n\t\t\t\t\t\t\t\tif(clientPut != null)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfcp.startBlocking(clientPut, container, context);\n\t\t\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorAccessDenied\"), l10n(\"errorAccessDeniedFile\", \"file\", file.getFilename()), ctx, false, true);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorNoFileOrCannotRead\"), l10n(\"errorAccessDeniedFile\", \"file\", file.getFilename()), ctx, false, true);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MalformedURLException mue1) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx, false, true);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Unresolved metadata in starting insert from data uploaded from browser: \"+e, e);\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t// FIXME should this be a proper localised message? It shouldn't happen... but we'd like to get reports if it does.\n\t\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\t\twriteInternalError(t, ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tsynchronized(done) {\n\t\t\t\t\t\t\t\t\tdone.value = true;\n\t\t\t\t\t\t\t\t\tdone.notifyAll();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (ToadletContextClosedException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, NativeThread.HIGH_PRIORITY+1, false);\n\t\t\t\t} catch (DatabaseDisabledException e1) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsynchronized(done) {\n\t\t\t\t\twhile(!done.value)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdone.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(LocalFileBrowserToadlet.selectFile)) {\n\t\t\t\tfinal String filename = request.getPartAsStringFailsafe(\"filename\", MAX_FILENAME_LENGTH);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Inserting local file: \"+filename);\n\t\t\t\tfinal File file = new File(filename);\n\t\t\t\tfinal String identifier = file.getName() + \"-fred-\" + System.currentTimeMillis();\n\t\t\t\tfinal String contentType = DefaultMIMETypes.guessMIMEType(filename, false);\n\t\t\t\tfinal FreenetURI furi;\n\t\t\t\tfinal String key = request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH);\n\t\t\t\tfinal boolean compress = request.isPartSet(\"compress\");\n\t\t\t\tfinal String compatibilityMode = request.getPartAsStringFailsafe(\"compatibilityMode\", 100);\n\t\t\t\tfinal CompatibilityMode cmode;\n\t\t\t\tif(compatibilityMode.equals(\"\"))\n\t\t\t\t\tcmode = CompatibilityMode.COMPAT_CURRENT;\n\t\t\t\telse\n\t\t\t\t\tcmode = CompatibilityMode.valueOf(compatibilityMode);\n\t\t\t\tString s = request.getPartAsStringFailsafe(\"overrideSplitfileKey\", 65);\n\t\t\t\tfinal byte[] overrideSplitfileKey;\n\t\t\t\tif(s != null && !s.equals(\"\"))\n\t\t\t\t\toverrideSplitfileKey = HexUtil.hexToBytes(s);\n\t\t\t\telse\n\t\t\t\t\toverrideSplitfileKey = null;\n\t\t\t\tif(key != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfuri = new FreenetURI(key);\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfuri = new FreenetURI(\"CHK@\");\n\t\t\t\t}\n\t\t\t\tfinal String target;\n\t\t\t\tif(furi.getDocName() != null)\n\t\t\t\t\ttarget = null;\n\t\t\t\telse\n\t\t\t\t\ttarget = file.getName();\n\t\t\t\tfinal MutableBoolean done = new MutableBoolean();\n\t\t\t\ttry {\n\t\t\t\t\tcore.queue(new DBJob() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\treturn \"QueueToadlet StartLocalFileInsert\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tfinal ClientPut clientPut;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tclientPut = new ClientPut(fcp.getGlobalForeverClient(), furi, identifier, Integer.MAX_VALUE, null, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, ClientRequest.PERSIST_FOREVER, null, false, !compress, -1, ClientPutMessage.UPLOAD_FROM_DISK, file, contentType, new FileBucket(file, true, false, false, false, false), null, target, false, false, Node.FORK_ON_CACHEABLE_DEFAULT, HighLevelSimpleClientImpl.EXTRA_INSERTS_SINGLE_BLOCK, HighLevelSimpleClientImpl.EXTRA_INSERTS_SPLITFILE_HEADER, false, cmode, overrideSplitfileKey, fcp, container);\n\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Started global request to insert \"+file+\" to CHK@ as \"+identifier);\n\t\t\t\t\t\t\t\tif(clientPut != null)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfcp.startBlocking(clientPut, container, context);\n\t\t\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\t\t\t\t\t\t// Impossible???\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorNoFileOrCannotRead\"), l10n(\"errorAccessDeniedFile\", \"file\", target), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (NotAllowedException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorAccessDenied\"), l10n(\"errorAccessDeniedFile\", new String[]{ \"file\" }, new String[]{ file.getName() }), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Unresolved metadata in starting insert from data from file: \"+e, e);\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t// FIXME should this be a proper localised message? It shouldn't happen... but we'd like to get reports if it does.\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tsynchronized(done) {\n\t\t\t\t\t\t\t\t\tdone.value = true;\n\t\t\t\t\t\t\t\t\tdone.notifyAll();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (ToadletContextClosedException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, NativeThread.HIGH_PRIORITY+1, false);\n\t\t\t\t} catch (DatabaseDisabledException e1) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsynchronized(done) {\n\t\t\t\t\twhile(!done.value)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdone.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else if (request.isPartSet(LocalFileBrowserToadlet.selectDir)) {\n\t\t\t\tfinal String filename = request.getPartAsStringFailsafe(\"filename\", MAX_FILENAME_LENGTH);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Inserting local directory: \"+filename);\n\t\t\t\tfinal File file = new File(filename);\n\t\t\t\tfinal String identifier = file.getName() + \"-fred-\" + System.currentTimeMillis();\n\t\t\t\tfinal FreenetURI furi;\n\t\t\t\tfinal String key = request.getPartAsStringFailsafe(\"key\", MAX_KEY_LENGTH);\n\t\t\t\tfinal boolean compress = request.isPartSet(\"compress\");\n\t\t\t\tString s = request.getPartAsStringFailsafe(\"overrideSplitfileKey\", 65);\n\t\t\t\tfinal byte[] overrideSplitfileKey;\n\t\t\t\tif(s != null && !s.equals(\"\"))\n\t\t\t\t\toverrideSplitfileKey = HexUtil.hexToBytes(s);\n\t\t\t\telse\n\t\t\t\t\toverrideSplitfileKey = null;\n\t\t\t\tif(key != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfuri = new FreenetURI(key);\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfuri = new FreenetURI(\"CHK@\");\n\t\t\t\t}\n\t\t\t\tfinal MutableBoolean done = new MutableBoolean();\n\t\t\t\ttry {\n\t\t\t\t\tcore.queue(new DBJob() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\treturn \"QueueToadlet StartLocalDirInsert\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tClientPutDir clientPutDir;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tclientPutDir = new ClientPutDir(fcp.getGlobalForeverClient(), furi, identifier, Integer.MAX_VALUE, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, ClientRequest.PERSIST_FOREVER, null, false, !compress, -1, file, null, false, /* make include hidden files configurable? FIXME */ false, true, false, false, Node.FORK_ON_CACHEABLE_DEFAULT, HighLevelSimpleClientImpl.EXTRA_INSERTS_SINGLE_BLOCK, HighLevelSimpleClientImpl.EXTRA_INSERTS_SPLITFILE_HEADER, false, overrideSplitfileKey, fcp, container);\n\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Started global request to insert dir \"+file+\" to \"+furi+\" as \"+identifier);\n\t\t\t\t\t\t\t\tif(clientPutDir != null)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfcp.startBlocking(clientPutDir, container, context);\n\t\t\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same file twice in same millisecond\");\n\t\t\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t} catch (DatabaseDisabledException e) {\n\t\t\t\t\t\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\t\t\t\t\tLogger.error(this, \"Cannot put same directory twice in same millisecond\");\n\t\t\t\t\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"errorNoFileOrCannotRead\"), l10n(\"QueueToadlet.errorAccessDeniedFile\", \"file\", file.toString()), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (TooManyFilesInsertException e) {\n\t\t\t\t\t\t\t\twriteError(l10n(\"tooManyFilesInOneFolder\"), l10n(\"tooManyFilesInOneFolder\"), ctx);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tsynchronized(done) {\n\t\t\t\t\t\t\t\t\tdone.value = true;\n\t\t\t\t\t\t\t\t\tdone.notifyAll();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} catch (ToadletContextClosedException e) {\n\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, NativeThread.HIGH_PRIORITY+1, false);\n\t\t\t\t} catch (DatabaseDisabledException e1) {\n\t\t\t\t\tsendPersistenceDisabledError(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsynchronized(done) {\n\t\t\t\t\twhile(!done.value)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdone.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n            // Filter File button on upload page\n            } else if (request.isPartSet(\"filter-upload\")) {\n            \ttry {\n            \t\tthrow new RedirectException(ContentFilterToadlet.PATH);\n            \t} catch (URISyntaxException e) {\n            \t\tLogger.error(this, \"Invalid path for content filter toadlet\", e);\n            \t}\n\t\t\t} else if (request.isPartSet(\"recommend_request\")) {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"recommendAFileToFriends\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\tHTMLNode infoboxContent = ctx.getPageMaker().getInfobox(\"#\", l10n(\"recommendAFileToFriends\"), contentNode, \"recommend-file\", true);\n\t\t\t\tHTMLNode form = ctx.addFormChild(infoboxContent, path(), \"recommendForm2\");\n\t\t\t\t\n\t\t\t\tint x = 0;\n\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\tif(!part.startsWith(\"identifier-\")) continue;\n\t\t\t\t\tString key = request.getPartAsStringFailsafe(\"key-\"+part.substring(\"identifier-\".length()), MAX_KEY_LENGTH);\n\t\t\t\t\tif(key == null || key.equals(\"\")) continue;\n\t\t\t\t\tform.addChild(\"#\", l10n(\"key\") + \":\");\n\t\t\t\t\tform.addChild(\"br\");\n\t\t\t\t\tform.addChild(\"#\", key);\n\t\t\t\t\tform.addChild(\"br\");\n\t\t\t\t\tform.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t\t\t\tnew String[] { \"hidden\", \"key-\"+x, key });\n\t\t\t\t}\n\t\t\t\tform.addChild(\"label\", \"for\", \"descB\", (l10n(\"recommendDescription\") + ' '));\n\t\t\t\tform.addChild(\"br\");\n\t\t\t\tform.addChild(\"textarea\",\n\t\t\t\t        new String[]{\"id\", \"name\", \"row\", \"cols\"},\n\t\t\t\t        new String[]{\"descB\", \"description\", \"3\", \"70\"});\n\t\t\t\tform.addChild(\"br\");\n\n\t\t\t\tHTMLNode peerTable = form.addChild(\"table\", \"class\", \"darknet_connections\");\n\t\t\t\tpeerTable.addChild(\"th\", \"colspan\", \"2\", l10n(\"recommendToFriends\"));\n\t\t\t\tfor(DarknetPeerNode peer : core.node.getDarknetConnections()) {\n\t\t\t\t\tHTMLNode peerRow = peerTable.addChild(\"tr\", \"class\", \"darknet_connections_normal\");\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-marker\").addChild(\"input\",\n\t\t\t\t\t        new String[] { \"type\", \"name\" }, \n\t\t\t\t\t        new String[] { \"checkbox\", \"node_\" + peer.hashCode() });\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-name\").addChild(\"#\", peer.getName());\n\t\t\t\t}\n\n\t\t\t\tform.addChild(\"input\",\n\t\t\t\t        new String[]{\"type\", \"name\", \"value\"},\n\t\t\t\t        new String[]{\"submit\", \"recommend_uri\", l10n(\"recommend\")});\n\n\t\t\t\tthis.writeHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t} else if(request.isPartSet(\"recommend_uri\") && request.isPartSet(\"URI\")) {\n\t\t\t\tString description = request.getPartAsStringFailsafe(\"description\", 32768);\n\t\t\t\tArrayList<FreenetURI> uris = new ArrayList<FreenetURI>();\n\t\t\t\tfor(String part : request.getParts()) {\n\t\t\t\t\tif(!part.startsWith(\"key-\")) continue;\n\t\t\t\t\tString key = request.getPartAsStringFailsafe(part, MAX_KEY_LENGTH);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFreenetURI furi = new FreenetURI(key);\n\t\t\t\t\t\turis.add(furi);\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\twriteError(l10n(\"errorInvalidURI\"), l10n(\"errorInvalidURIToU\"), ctx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(DarknetPeerNode peer : core.node.getDarknetConnections()) {\n\t\t\t\t\tif(request.isPartSet(\"node_\" + peer.hashCode())) {\n\t\t\t\t\t\tfor(FreenetURI furi : uris)\n\t\t\t\t\t\t\tpeer.sendDownloadFeed(furi, description);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twritePermanentRedirect(ctx, \"Done\", path());\n\t\t\t\treturn;\n\t\t\t}\n\t\t} finally {\n\t\t\trequest.freeParts();\n\t\t}\n\t\tthis.handleMethodGET(uri, new HTTPRequestImpl(uri, \"GET\"), ctx);\n\t}","commit_id":"48855ed6ae8295c04197da598ce0669b1d3824d6","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodPOST(URI uri, HTTPRequest request, ToadletContext ctx) throws\n\t        ToadletContextClosedException, IOException, RedirectException {\n\t\tif (!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, NodeL10n.getBase().getString(\"Toadlet.unauthorizedTitle\"),\n\t\t\t        NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString pass = request.getPartAsStringFailsafe(\"formPassword\", 32);\n\t\tif((pass == null) || !pass.equals(core.formPassword)) {\n\t\t\tMultiValueTable<String,String> headers = new MultiValueTable<String,String>();\n\t\t\theaders.put(\"Location\", path());\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t//User requested reset to defaults, so present confirmation page.\n\t\tif (request.isPartSet(\"confirm-reset-to-defaults\")) {\n\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"confirmResetTitle\"), ctx);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-warning\", l10n(\"confirmResetTitle\"),\n\t\t\t        contentNode, \"reset-confirm\", true);\n\t\t\tcontent.addChild(\"#\", l10n(\"confirmReset\"));\n\n\t\t\tHTMLNode yesForm = ctx.addFormChild(content, path(), \"yes-button\");\n\t\t\tyesForm.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"hidden\", \"subconfig\",\n\t\t\t                request.getPartAsStringFailsafe(\"subconfig\", MAX_PARAM_VALUE_SIZE) });\n\t\t\tyesForm.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"value\" },\n\t\t\t        new String[] { \"submit\", NodeL10n.getBase().getString(\"Toadlet.yes\") });\n\n\t\t\tHTMLNode noForm = ctx.addFormChild(content, path(), \"no-button\");\n\t\t\tnoForm.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"submit\", \"decline-default-reset\",\n\t\t\t                NodeL10n.getBase().getString(\"Toadlet.no\")});\n\t\t}\n\n\t\t//Returning from directory selector with a selection or declining resetting settings to defaults.\n\t\t//Re-render config page with any changes made in the selector while also persisting values changed but\n\t\t//not applied.\n\t\tif(request.isPartSet(\"select-dir\") || request.isPartSet(\"decline-default-reset\")) {\n\t\t\thandleMethodGET(uri, request, ctx);\n\t\t\treturn;\n\t\t}\n\n\t\t//Entering directory selector from config page.\n\t\t//This would be two loops if it checked for a redirect (key.startsWith(\"select-directory.\")) before\n\t\t//constructing params string. It always constructs it, then redirects if it turns out to be needed.\n\t\tboolean directorySelector = false;\n\t\tString params = \"?\";\n\t\tString value;\n\t\tfor(String key : request.getParts()) {\n\t\t\t //Prepare parts for page selection redirect:\n\t\t\t//Extract option and put into \"select-for\"; preserve others.\n\t\t\tvalue = request.getPartAsStringFailsafe(key, MAX_PARAM_VALUE_SIZE);\n\t\t\tif(key.startsWith(\"select-directory.\")) {\n\t\t\t\tparams +=\"select-for=\"+URLEncoder.encode(key.substring(\"select-directory.\".length()),true)+'&';\n\t\t\t\tdirectorySelector = true;\n\t\t\t} else {\n\t\t\t\tparams += URLEncoder.encode(key,true)+'='+URLEncoder.encode(value, true)+'&';\n\t\t\t}\n\t\t}\n\t\tif(directorySelector) {\n\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>(1);\n\t\t\t//params ends in &. Download directory browser starts in default download directory.\n\t\t\theaders.put(\"Location\", directoryBrowserPath+params+\n\t\t\t        \"path=\"+core.getDownloadsDir().getAbsolutePath());\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder errbuf = new StringBuilder();\n\t\tboolean logMINOR = Logger.shouldLog(LogLevel.MINOR, this);\n\n\t\tString desiredPrefix = null;\n\t\tif (request.isPartSet(\"subconfig\")) {\n\t\t\tdesiredPrefix = request.getPartAsStringFailsafe(\"subconfig\", MAX_PARAM_VALUE_SIZE);\n\t\t\tif (logMINOR) {\n\t\t\t\tLogger.minor(this, \"Restoring defaults on subconfig prefix \\'\"+desiredPrefix+\"\\'.\");\n\t\t\t}\n\t\t}\n\n\t\tfor(SubConfig sc : config.getConfigs()) {\n\t\t\tString prefix = sc.getPrefix();\n\t\t\t//If prefix were null, it could match an unset desiredPrefix.\n\t\t\tassert(prefix != null);\n\t\t\tString configName;\n\n\t\t\tfor(Option<?> o : sc.getOptions()) {\n\t\t\t\tconfigName=o.getName();\n\t\t\t\tif(logMINOR) {\n\t\t\t\t\tLogger.minor(this, \"Checking if change is needed for \"+prefix+ '.' +configName);\n\t\t\t\t}\n\n\t\t\t\t//This ignores unrecognized parameters.\n\t\t\t\tif(request.isPartSet(prefix+ '.' +configName) || prefix.equals(desiredPrefix)) {\n\t\t\t\t\t//Current subconfig is to be reset to default and the current option is visible.\n\t\t\t\t\tif (prefix.equals(desiredPrefix) && request.isPartSet(prefix+ '.' +configName)) {\n\t\t\t\t\t\tvalue = o.getDefault();\n\t\t\t\t\t} else { //request.isPartSet(prefix+ '.' +configName)) {\n\t\t\t\t\t\t//Setting a specific value\n\t\t\t\t\t\tvalue = request.getPartAsStringFailsafe(prefix+ '.' +configName,\n\t\t\t\t\t        MAX_PARAM_VALUE_SIZE);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!(o.getValueString().equals(value))){\n\n\t\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Setting \"+prefix+ '.' +configName+\n\t\t\t\t\t\t\t        \" to \"+value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\to.setValue(value);\n\t\t\t\t\t\t} catch (InvalidConfigValueException e) {\n\t\t\t\t\t\t\terrbuf.append(o.getName()).append(' ')\n\t\t\t\t\t\t\t        .append(e.getMessage()).append('\\n');\n\t\t\t\t\t\t} catch (NodeNeedRestartException e) {\n\t\t\t\t\t\t\tneedRestart = true;\n\t\t\t\t\t\t} catch (Exception e){\n\t\t\t\t\t\t\terrbuf.append(o.getName()).append(' ').append(e).append('\\n');\n\t\t\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Wrapper params\n\t\t\tString wrapperConfigName = \"wrapper.java.maxmemory\";\n\t\t\tif(request.isPartSet(wrapperConfigName)) {\n\t\t\t\tvalue = request.getPartAsStringFailsafe(wrapperConfigName, MAX_PARAM_VALUE_SIZE);\n\t\t\t\tif(!WrapperConfig.getWrapperProperty(wrapperConfigName).equals(value)) {\n\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"Setting \"+wrapperConfigName+\" to \"+value);\n\t\t\t\t\t}\n\t\t\t\t\tWrapperConfig.setWrapperProperty(wrapperConfigName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconfig.store();\n\n\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"appliedTitle\"), ctx);\n\t\tHTMLNode pageNode = page.outer;\n\t\tHTMLNode contentNode = page.content;\n\n\t\tif (errbuf.length() == 0) {\n\t\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-success\", l10n(\"appliedTitle\"),\n\t\t\t        contentNode, \"configuration-applied\", true);\n\t\t\tcontent.addChild(\"#\", l10n(\"appliedSuccess\"));\n\n\t\t\tif (needRestart) {\n\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\tcontent.addChild(\"#\", l10n(\"needRestart\"));\n\n\t\t\t\tif (node.isUsingWrapper()) {\n\t\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\t\tHTMLNode restartForm = ctx.addFormChild(content, \"/\", \"restartForm\");\n\t\t\t\t\trestartForm.addChild(\"input\",//\n\t\t\t\t\t        new String[] { \"type\", \"name\" },//\n\t\t\t\t\t        new String[] { \"hidden\", \"restart\" });\n\t\t\t\t\trestartForm.addChild(\"input\", //\n\t\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },//\n\t\t\t\t\t        new String[] { \"submit\", \"restart2\",//\n\t\t\t\t\t                l10n( \"restartNode\") });\n\t\t\t\t}\n\n\t\t\t\tif (needRestartUserAlert == null) {\n\t\t\t\t\tneedRestartUserAlert = new NeedRestartUserAlert();\n\t\t\t\t\tnode.clientCore.alerts.register(needRestartUserAlert);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-error\", l10n(\"appliedFailureTitle\"),\n\t\t\t        contentNode, \"configuration-error\", true).addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tcontent.addChild(\"#\", l10n(\"appliedFailureExceptions\"));\n\t\t\tcontent.addChild(\"br\");\n\t\t\tcontent.addChild(\"#\", errbuf.toString());\n\t\t}\n\n\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-normal\", l10n(\"possibilitiesTitle\"),\n\t\t        contentNode, \"configuration-possibilities\", false);\n\t\tcontent.addChild(\"a\", new String[]{\"href\", \"title\"}, new String[]{path(), l10n(\"shortTitle\")},\n\t\t        l10n(\"returnToNodeConfig\"));\n\t\tcontent.addChild(\"br\");\n\t\taddHomepageLink(content);\n\n\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\n\t}","id":43833,"modified_method":"public void handleMethodPOST(URI uri, HTTPRequest request, ToadletContext ctx) throws\n\t        ToadletContextClosedException, IOException, RedirectException {\n\t\tif (!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, NodeL10n.getBase().getString(\"Toadlet.unauthorizedTitle\"),\n\t\t\t        NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString pass = request.getPartAsStringFailsafe(\"formPassword\", 32);\n\t\tif((pass == null) || !pass.equals(core.formPassword)) {\n\t\t\tMultiValueTable<String,String> headers = new MultiValueTable<String,String>();\n\t\t\theaders.put(\"Location\", path());\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t//User requested reset to defaults, so present confirmation page.\n\t\tif (request.isPartSet(\"confirm-reset-to-defaults\")) {\n\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"confirmResetTitle\"), ctx);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-warning\", l10n(\"confirmResetTitle\"),\n\t\t\t        contentNode, \"reset-confirm\", true);\n\t\t\tcontent.addChild(\"#\", l10n(\"confirmReset\"));\n\n\t\t\tHTMLNode yesForm = ctx.addFormChild(content, path(), \"yes-button\");\n\t\t\tString subconfig = request.getPartAsStringFailsafe(\"subconfig\", MAX_PARAM_VALUE_SIZE);\n\t\t\tyesForm.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"hidden\", \"subconfig\", subconfig });\n\t\t\t//Persist visible fields so that they are reset to default.\n\t\t\tfor (String part : request.getParts()) {\n\t\t\t\tif (part.startsWith(subconfig)) {\n\t\t\t\t\tyesForm.addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"hidden\", part, \"visible\" });\n\t\t\t\t}\n\t\t\t}\n\t\t\tyesForm.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"submit\", \"reset-to-defaults\",\n\t\t\t                NodeL10n.getBase().getString(\"Toadlet.yes\") });\n\n\t\t\tHTMLNode noForm = ctx.addFormChild(content, path(), \"no-button\");\n\t\t\tnoForm.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"submit\", \"decline-default-reset\",\n\t\t\t                NodeL10n.getBase().getString(\"Toadlet.no\")});\n\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t}\n\n\t\t//Returning from directory selector with a selection or declining resetting settings to defaults.\n\t\t//Re-render config page with any changes made in the selector while also persisting values changed but\n\t\t//not applied.\n\t\tif(request.isPartSet(\"select-dir\") || request.isPartSet(\"decline-default-reset\")) {\n\t\t\thandleMethodGET(uri, request, ctx);\n\t\t\treturn;\n\t\t}\n\n\t\t//Entering directory selector from config page.\n\t\t//This would be two loops if it checked for a redirect (key.startsWith(\"select-directory.\")) before\n\t\t//constructing params string. It always constructs it, then redirects if it turns out to be needed.\n\t\tboolean directorySelector = false;\n\t\tString params = \"?\";\n\t\tString value;\n\t\tfor(String key : request.getParts()) {\n\t\t\t //Prepare parts for page selection redirect:\n\t\t\t//Extract option and put into \"select-for\"; preserve others.\n\t\t\tvalue = request.getPartAsStringFailsafe(key, MAX_PARAM_VALUE_SIZE);\n\t\t\tif(key.startsWith(\"select-directory.\")) {\n\t\t\t\tparams +=\"select-for=\"+URLEncoder.encode(key.substring(\"select-directory.\".length()),true)+'&';\n\t\t\t\tdirectorySelector = true;\n\t\t\t} else {\n\t\t\t\tparams += URLEncoder.encode(key,true)+'='+URLEncoder.encode(value, true)+'&';\n\t\t\t}\n\t\t}\n\t\tif(directorySelector) {\n\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>(1);\n\t\t\t//params ends in &. Download directory browser starts in default download directory.\n\t\t\theaders.put(\"Location\", directoryBrowserPath+params+\n\t\t\t        \"path=\"+core.getDownloadsDir().getAbsolutePath());\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder errbuf = new StringBuilder();\n\t\tboolean logMINOR = Logger.shouldLog(LogLevel.MINOR, this);\n\n\t\tString desiredPrefix = request.getPartAsStringFailsafe(\"subconfig\", MAX_PARAM_VALUE_SIZE);\n\t\tboolean resetToDefault = request.isPartSet(\"reset-to-defaults\");\n\t\tif (resetToDefault && logMINOR) {\n\t\t\tLogger.minor(this, \"Restoring defaults on subconfig prefix \\'\"+desiredPrefix+\"\\'.\");\n\t\t}\n\n\t\tfor(SubConfig sc : config.getConfigs()) {\n\t\t\tString prefix = sc.getPrefix();\n\t\t\tString configName;\n\n\t\t\tfor(Option<?> o : sc.getOptions()) {\n\t\t\t\tconfigName=o.getName();\n\t\t\t\tif(logMINOR) {\n\t\t\t\t\tLogger.minor(this, \"Checking option \"+prefix+ '.' +configName);\n\t\t\t\t}\n\n\t\t\t\t//This ignores unrecognized parameters.\n\t\t\t\tif(request.isPartSet(prefix+ '.' +configName) || prefix.equals(desiredPrefix)) {\n\t\t\t\t\t//Current subconfig is to be reset to default and the current option is visible.\n\t\t\t\t\tif (prefix.equals(desiredPrefix) && request.isPartSet(prefix+'.'+configName)\n\t\t\t\t\t        && resetToDefault) {\n\t\t\t\t\t\tvalue = o.getDefault();\n\t\t\t\t\t} else if (request.isPartSet(prefix+ '.' +configName)) {\n\t\t\t\t\t\t//Current option is visible.\n\t\t\t\t\t\tvalue = request.getPartAsStringFailsafe(prefix+ '.' +configName,\n\t\t\t\t\t        MAX_PARAM_VALUE_SIZE);\n\t\t\t\t\t} else { //if (prefix.equals(desiredPrefix) &&\n\t\t\t\t\t\t// !request.isPartSet(prefix+ '.' +configName)) {\n\t\t\t\t\t\t//Current subconfig resetting, but the current option is not visible.\n\t\t\t\t\t\tif (logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring invisible option \"\n\t\t\t\t\t\t\t        +prefix+ '.' +configName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue = o.getValueString();\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!(o.getValueString().equals(value))){\n\n\t\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Changing \"+prefix+ '.' +configName+\n\t\t\t\t\t\t\t        \" to \"+value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\to.setValue(value);\n\t\t\t\t\t\t} catch (InvalidConfigValueException e) {\n\t\t\t\t\t\t\terrbuf.append(o.getName()).append(' ')\n\t\t\t\t\t\t\t        .append(e.getMessage()).append('\\n');\n\t\t\t\t\t\t} catch (NodeNeedRestartException e) {\n\t\t\t\t\t\t\tneedRestart = true;\n\t\t\t\t\t\t} catch (Exception e){\n\t\t\t\t\t\t\terrbuf.append(o.getName()).append(' ').append(e).append('\\n');\n\t\t\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, prefix+ '.' +configName+\" has not been changed.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Wrapper params\n\t\t\tString wrapperConfigName = \"wrapper.java.maxmemory\";\n\t\t\tif(request.isPartSet(wrapperConfigName)) {\n\t\t\t\tvalue = request.getPartAsStringFailsafe(wrapperConfigName, MAX_PARAM_VALUE_SIZE);\n\t\t\t\tif(!WrapperConfig.getWrapperProperty(wrapperConfigName).equals(value)) {\n\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"Setting \"+wrapperConfigName+\" to \"+value);\n\t\t\t\t\t}\n\t\t\t\t\tWrapperConfig.setWrapperProperty(wrapperConfigName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconfig.store();\n\n\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"appliedTitle\"), ctx);\n\t\tHTMLNode pageNode = page.outer;\n\t\tHTMLNode contentNode = page.content;\n\n\t\tif (errbuf.length() == 0) {\n\t\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-success\", l10n(\"appliedTitle\"),\n\t\t\t        contentNode, \"configuration-applied\", true);\n\t\t\tcontent.addChild(\"#\", l10n(\"appliedSuccess\"));\n\n\t\t\tif (needRestart) {\n\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\tcontent.addChild(\"#\", l10n(\"needRestart\"));\n\n\t\t\t\tif (node.isUsingWrapper()) {\n\t\t\t\t\tcontent.addChild(\"br\");\n\t\t\t\t\tHTMLNode restartForm = ctx.addFormChild(content, \"/\", \"restartForm\");\n\t\t\t\t\trestartForm.addChild(\"input\",//\n\t\t\t\t\t        new String[] { \"type\", \"name\" },//\n\t\t\t\t\t        new String[] { \"hidden\", \"restart\" });\n\t\t\t\t\trestartForm.addChild(\"input\", //\n\t\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },//\n\t\t\t\t\t        new String[] { \"submit\", \"restart2\",//\n\t\t\t\t\t                l10n( \"restartNode\") });\n\t\t\t\t}\n\n\t\t\t\tif (needRestartUserAlert == null) {\n\t\t\t\t\tneedRestartUserAlert = new NeedRestartUserAlert();\n\t\t\t\t\tnode.clientCore.alerts.register(needRestartUserAlert);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-error\", l10n(\"appliedFailureTitle\"),\n\t\t\t        contentNode, \"configuration-error\", true).addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tcontent.addChild(\"#\", l10n(\"appliedFailureExceptions\"));\n\t\t\tcontent.addChild(\"br\");\n\t\t\tcontent.addChild(\"#\", errbuf.toString());\n\t\t}\n\n\t\tHTMLNode content = ctx.getPageMaker().getInfobox(\"infobox-normal\", l10n(\"possibilitiesTitle\"),\n\t\t        contentNode, \"configuration-possibilities\", false);\n\t\tcontent.addChild(\"a\", new String[]{\"href\", \"title\"}, new String[]{path(), l10n(\"shortTitle\")},\n\t\t        l10n(\"returnToNodeConfig\"));\n\t\tcontent.addChild(\"br\");\n\t\taddHomepageLink(content);\n\n\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\n\t}","commit_id":"e0796b9f6ce2dae78f538e6c58de6214bfb7ffa5","url":"https://github.com/freenet/fred"},{"original_method":"@Inject\n   public GitReviewPresenter(GitServerOperations server,\n                             Display view,\n                             final EventBus events,\n                             final GitState gitState,\n                             final Session session,\n                             final GlobalDisplay globalDisplay,\n                             VCSFileOpener vcsFileOpener)\n   {\n      server_ = server;\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      gitState_ = gitState;\n      vcsFileOpener_ = vcsFileOpener;\n\n      new WidgetHandlerRegistration(view.asWidget())\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return gitState_.addVcsRefreshHandler(new VcsRefreshHandler()\n            {\n               @Override\n               public void onVcsRefresh(VcsRefreshEvent event)\n               {\n                  if (event.getReason() == Reason.VcsOperation)\n                  {\n                     Scheduler.get().scheduleDeferred(new ScheduledCommand()\n                     {\n                        @Override\n                        public void execute()\n                        {\n                           updateDiff(true);\n\n                           initialized_ = true;\n                        }\n                     });\n                  }\n               }\n            }, false);\n         }\n      };\n\n      new WidgetHandlerRegistration(view.asWidget())\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return events.addHandler(FileChangeEvent.TYPE, new FileChangeHandler()\n            {\n               @Override\n               public void onFileChange(FileChangeEvent event)\n               {\n                  ArrayList<StatusAndPath> paths = view_.getChangelistTable()\n                        .getSelectedItems();\n                  if (paths.size() != 1)\n                  {\n                     clearDiff();\n                     return;\n                  }\n\n                  StatusAndPath vcsStatus = StatusAndPath.fromInfo(\n                        event.getFileChange().getFile().getGitStatus());\n                  if (paths.get(0).getRawPath().equals(vcsStatus.getRawPath()))\n                  {\n                     gitState.refresh(false);\n                  }\n               }\n            });\n         }\n      };\n\n      view_.getChangelistTable().addSelectionChangeHandler(new Handler()\n      {\n         @Override\n         public void onSelectionChange(SelectionChangeEvent event)\n         {\n            overrideSizeWarning_ = false;\n            view_.setFilesCommandsEnabled(view_.getSelectedPaths().size() > 0);\n            if (initialized_)\n               updateDiff(true);\n         }\n      });\n      view_.getChangelistTable().addRowCountChangeHandler(new RowCountChangeEvent.Handler()\n      {\n         @Override\n         public void onRowCountChange(RowCountChangeEvent event)\n         {\n            // This is necessary because during initial load, the selection\n            // model has its selection set before any items are loaded into\n            // the table (so therefore view_.getSelectedPaths().size() is always\n            // 0, and the files commands are not enabled until selection changes\n            // again). By updating the files commands' enabled state on row\n            // count change as well, we can make sure they get enabled.\n            view_.setFilesCommandsEnabled(view_.getSelectedPaths().size() > 0);\n         }\n      });\n      view_.getChangelistTable().addKeyDownHandler(new KeyDownHandler()\n      {\n         @Override\n         public void onKeyDown(KeyDownEvent event)\n         {\n            // Space toggles the staged/unstaged state of the current selection.\n            // Enter does the same plus moves the selection down.\n\n            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER\n                || event.getNativeKeyCode() == ' ')\n            {\n               getTable().toggleStaged(\n                     event.getNativeKeyCode() == KeyCodes.KEY_ENTER);\n            }\n         }\n      });\n      view_.getChangelistTable().addMouseDownHandler(new MouseDownHandler()\n      {\n         private DoubleClickState dblClick = new DoubleClickState();\n         @Override\n         public void onMouseDown(MouseDownEvent event)\n         {\n            if (dblClick.checkForDoubleClick(event.getNativeEvent()))\n            {\n               event.preventDefault();\n               event.stopPropagation();\n               getTable().toggleStaged(false);\n            }\n         }\n      });\n      \n      view_.getChangelistTable().addContextMenuHandler(new ContextMenuHandler()\n      {\n         @Override\n         public void onContextMenu(ContextMenuEvent event)\n         {\n            NativeEvent nativeEvent = event.getNativeEvent();\n            view_.showContextMenu(nativeEvent.getClientX(),\n                                  nativeEvent.getClientY(),\n                                  new Command() {\n                                    @Override\n                                    public void execute()\n                                    {\n                                       openSelectedFiles();                       \n                                    }\n            });\n\n         }\n      });\n\n      view_.getStageFilesButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            ArrayList<String> paths = view_.getSelectedPaths();\n            if (paths.size() == 0)\n               return;\n            server_.gitStage(paths, new SimpleRequestCallback<Void>());\n            \n            view_.getChangelistTable().focus();\n         }\n      });\n\n      view_.getRevertFilesButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            final ArrayList<String> paths = view_.getSelectedPaths();\n            if (paths.size() == 0)\n               return;\n            String noun = paths.size() == 1 ? \"file\" : \"files\";\n            globalDisplay_.showYesNoMessage(\n                  GlobalDisplay.MSG_WARNING,\n                  \"Revert Changes\",\n                  \"Changes to the selected \" + noun + \" will be lost, including \" +\n                  \"staged changes.\\n\\nAre you sure you want to continue?\",\n                  new Operation()\n                  {\n                     @Override\n                     public void execute()\n                     {\n                        view_.getChangelistTable().selectNextUnselectedItem();\n\n                        server_.gitRevert(\n                              paths,\n                              new SimpleRequestCallback<Void>(\"Revert Changes\"));\n                        \n                        view_.getChangelistTable().focus();\n                     }\n                  },\n                  false);\n         }\n      });\n\n      view_.getCommitIsAmend().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent)\n         {\n            server_.gitHistory(\"\", null, 0, 1, null, new ServerRequestCallback<RpcObjectList<CommitInfo>>() {\n               @Override\n               public void onResponseReceived(RpcObjectList<CommitInfo> response)\n               {\n                  if (response.length() == 1)\n                  {\n                     String description = response.get(0).getDescription();\n\n                     if (view_.getCommitIsAmend().getValue())\n                     {\n                        if (view_.getCommitMessage().getText().length() == 0)\n                           view_.getCommitMessage().setText(description);\n                     }\n                     else\n                     {\n                        if (view_.getCommitMessage().getText().equals(description))\n                           view_.getCommitMessage().setText(\"\");\n                     }\n                  }\n               }\n\n               @Override\n               public void onError(ServerError error)\n               {\n                  Debug.logError(error);\n               }\n            });\n         }\n      });\n\n      view_.getStageAllButton().addClickHandler(\n            new ApplyPatchClickHandler(PatchMode.Stage, false));\n      view_.getDiscardAllButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            String which = view_.getLineTableDisplay().getSelectedLines().size() == 0\n                           ? \"All unstaged\"\n                           : \"The selected\";\n            globalDisplay.showYesNoMessage(\n                  GlobalDisplay.MSG_WARNING,\n                  \"Discard All\",\n                  which + \" changes in this file will be \" +\n                  \"lost.\\n\\nAre you sure you want to continue?\",\n                  new Operation() {\n                     @Override\n                     public void execute() {\n                        new ApplyPatchClickHandler(PatchMode.Working, true).execute();\n                     }\n                  },\n                  false);\n         }\n      });\n      view_.getUnstageAllButton().addClickHandler(\n            new ApplyPatchClickHandler(PatchMode.Stage, true));\n      view_.getStagedCheckBox().addValueChangeHandler(\n            new ValueChangeHandler<Boolean>()\n            {\n               @Override\n               public void onValueChange(ValueChangeEvent<Boolean> event)\n               {\n                  if (initialized_)\n                     updateDiff(false);\n               }\n            });\n      view_.getLineTableDisplay().addDiffChunkActionHandler(new ApplyPatchHandler());\n      view_.getLineTableDisplay().addDiffLineActionHandler(new ApplyPatchHandler());\n\n      new IntStateValue(MODULE_GIT, KEY_CONTEXT_LINES, ClientState.PERSISTENT,\n                        session.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(Integer value)\n         {\n            if (value != null)\n               view_.getContextLines().setValue(value);\n         }\n\n         @Override\n         protected Integer getValue()\n         {\n            return view_.getContextLines().getValue();\n         }\n      };\n\n      view_.getContextLines().addValueChangeHandler(new ValueChangeHandler<Integer>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Integer> event)\n         {\n            updateDiff(false);\n         }\n      });\n\n      view_.getCommitButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            server_.gitCommit(\n                  view_.getCommitMessage().getText(),\n                  view_.getCommitIsAmend().getValue(),\n                  false,\n                  new SimpleRequestCallback<ConsoleProcess>()\n                  {\n                     @Override\n                     public void onResponseReceived(ConsoleProcess proc)\n                     {\n                        proc.addProcessExitHandler(new ProcessExitEvent.Handler()\n                        {\n                           @Override\n                           public void onProcessExit(ProcessExitEvent event)\n                           {\n                              if (event.getExitCode() == 0)\n                                 view_.getCommitMessage().setText(\"\");\n                           }\n                        });\n                        new ConsoleProgressDialog(proc, server_).showModal();\n                     }\n                  });\n         }\n      });\n\n      view_.getOverrideSizeWarningButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            overrideSizeWarning_ = true;\n            updateDiff(false);\n         }\n      });\n   }","id":43834,"modified_method":"@Inject\n   public GitReviewPresenter(GitPresenterCore gitPresenterCore,\n                             GitServerOperations server,\n                             Display view,\n                             Binder binder,\n                             Commands commands,\n                             final EventBus events,\n                             final GitState gitState,\n                             final Session session,\n                             final GlobalDisplay globalDisplay,\n                             VCSFileOpener vcsFileOpener)\n   {\n      gitPresenterCore_ = gitPresenterCore;\n      server_ = server;\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      gitState_ = gitState;\n      vcsFileOpener_ = vcsFileOpener;\n      \n      binder.bind(commands, this);\n\n      new WidgetHandlerRegistration(view.asWidget())\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return gitState_.addVcsRefreshHandler(new VcsRefreshHandler()\n            {\n               @Override\n               public void onVcsRefresh(VcsRefreshEvent event)\n               {\n                  if (event.getReason() == Reason.VcsOperation)\n                  {\n                     Scheduler.get().scheduleDeferred(new ScheduledCommand()\n                     {\n                        @Override\n                        public void execute()\n                        {\n                           updateDiff(true);\n\n                           initialized_ = true;\n                        }\n                     });\n                  }\n               }\n            }, false);\n         }\n      };\n\n      new WidgetHandlerRegistration(view.asWidget())\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return events.addHandler(FileChangeEvent.TYPE, new FileChangeHandler()\n            {\n               @Override\n               public void onFileChange(FileChangeEvent event)\n               {\n                  ArrayList<StatusAndPath> paths = view_.getChangelistTable()\n                        .getSelectedItems();\n                  if (paths.size() != 1)\n                  {\n                     clearDiff();\n                     return;\n                  }\n\n                  StatusAndPath vcsStatus = StatusAndPath.fromInfo(\n                        event.getFileChange().getFile().getGitStatus());\n                  if (paths.get(0).getRawPath().equals(vcsStatus.getRawPath()))\n                  {\n                     gitState.refresh(false);\n                  }\n               }\n            });\n         }\n      };\n\n      view_.getChangelistTable().addSelectionChangeHandler(new SelectionChangeEvent.Handler()\n      {\n         @Override\n         public void onSelectionChange(SelectionChangeEvent event)\n         {\n            overrideSizeWarning_ = false;\n            view_.setFilesCommandsEnabled(view_.getSelectedPaths().size() > 0);\n            if (initialized_)\n               updateDiff(true);\n         }\n      });\n      view_.getChangelistTable().addRowCountChangeHandler(new RowCountChangeEvent.Handler()\n      {\n         @Override\n         public void onRowCountChange(RowCountChangeEvent event)\n         {\n            // This is necessary because during initial load, the selection\n            // model has its selection set before any items are loaded into\n            // the table (so therefore view_.getSelectedPaths().size() is always\n            // 0, and the files commands are not enabled until selection changes\n            // again). By updating the files commands' enabled state on row\n            // count change as well, we can make sure they get enabled.\n            view_.setFilesCommandsEnabled(view_.getSelectedPaths().size() > 0);\n         }\n      });\n      view_.getChangelistTable().addKeyDownHandler(new KeyDownHandler()\n      {\n         @Override\n         public void onKeyDown(KeyDownEvent event)\n         {\n            // Space toggles the staged/unstaged state of the current selection.\n            // Enter does the same plus moves the selection down.\n\n            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER\n                || event.getNativeKeyCode() == ' ')\n            {\n               getTable().toggleStaged(\n                     event.getNativeKeyCode() == KeyCodes.KEY_ENTER);\n            }\n         }\n      });\n      view_.getChangelistTable().addMouseDownHandler(new MouseDownHandler()\n      {\n         private DoubleClickState dblClick = new DoubleClickState();\n         @Override\n         public void onMouseDown(MouseDownEvent event)\n         {\n            if (dblClick.checkForDoubleClick(event.getNativeEvent()))\n            {\n               event.preventDefault();\n               event.stopPropagation();\n               getTable().toggleStaged(false);\n            }\n         }\n      });\n      \n      view_.getChangelistTable().addContextMenuHandler(new ContextMenuHandler()\n      {\n         @Override\n         public void onContextMenu(ContextMenuEvent event)\n         {\n            NativeEvent nativeEvent = event.getNativeEvent();\n            view_.showContextMenu(nativeEvent.getClientX(),\n                                  nativeEvent.getClientY(),\n                                  new Command() {\n                                    @Override\n                                    public void execute()\n                                    {\n                                       openSelectedFiles();                       \n                                    }\n            });\n\n         }\n      });\n\n      view_.getStageFilesButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            ArrayList<String> paths = view_.getSelectedPaths();\n            if (paths.size() == 0)\n               return;\n            server_.gitStage(paths, new SimpleRequestCallback<Void>());\n            \n            view_.getChangelistTable().focus();\n         }\n      });\n\n      view_.getRevertFilesButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            final ArrayList<String> paths = view_.getSelectedPaths();\n            if (paths.size() == 0)\n               return;\n            String noun = paths.size() == 1 ? \"file\" : \"files\";\n            globalDisplay_.showYesNoMessage(\n                  GlobalDisplay.MSG_WARNING,\n                  \"Revert Changes\",\n                  \"Changes to the selected \" + noun + \" will be lost, including \" +\n                  \"staged changes.\\n\\nAre you sure you want to continue?\",\n                  new Operation()\n                  {\n                     @Override\n                     public void execute()\n                     {\n                        view_.getChangelistTable().selectNextUnselectedItem();\n\n                        server_.gitRevert(\n                              paths,\n                              new SimpleRequestCallback<Void>(\"Revert Changes\"));\n                        \n                        view_.getChangelistTable().focus();\n                     }\n                  },\n                  false);\n         }\n      });\n\n      view_.getCommitIsAmend().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent)\n         {\n            server_.gitHistory(\"\", null, 0, 1, null, new ServerRequestCallback<RpcObjectList<CommitInfo>>() {\n               @Override\n               public void onResponseReceived(RpcObjectList<CommitInfo> response)\n               {\n                  if (response.length() == 1)\n                  {\n                     String description = response.get(0).getDescription();\n\n                     if (view_.getCommitIsAmend().getValue())\n                     {\n                        if (view_.getCommitMessage().getText().length() == 0)\n                           view_.getCommitMessage().setText(description);\n                     }\n                     else\n                     {\n                        if (view_.getCommitMessage().getText().equals(description))\n                           view_.getCommitMessage().setText(\"\");\n                     }\n                  }\n               }\n\n               @Override\n               public void onError(ServerError error)\n               {\n                  Debug.logError(error);\n               }\n            });\n         }\n      });\n\n      view_.getStageAllButton().addClickHandler(\n            new ApplyPatchClickHandler(PatchMode.Stage, false));\n      view_.getDiscardAllButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            String which = view_.getLineTableDisplay().getSelectedLines().size() == 0\n                           ? \"All unstaged\"\n                           : \"The selected\";\n            globalDisplay.showYesNoMessage(\n                  GlobalDisplay.MSG_WARNING,\n                  \"Discard All\",\n                  which + \" changes in this file will be \" +\n                  \"lost.\\n\\nAre you sure you want to continue?\",\n                  new Operation() {\n                     @Override\n                     public void execute() {\n                        new ApplyPatchClickHandler(PatchMode.Working, true).execute();\n                     }\n                  },\n                  false);\n         }\n      });\n      view_.getUnstageAllButton().addClickHandler(\n            new ApplyPatchClickHandler(PatchMode.Stage, true));\n      view_.getStagedCheckBox().addValueChangeHandler(\n            new ValueChangeHandler<Boolean>()\n            {\n               @Override\n               public void onValueChange(ValueChangeEvent<Boolean> event)\n               {\n                  if (initialized_)\n                     updateDiff(false);\n               }\n            });\n      view_.getLineTableDisplay().addDiffChunkActionHandler(new ApplyPatchHandler());\n      view_.getLineTableDisplay().addDiffLineActionHandler(new ApplyPatchHandler());\n\n      new IntStateValue(MODULE_GIT, KEY_CONTEXT_LINES, ClientState.PERSISTENT,\n                        session.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(Integer value)\n         {\n            if (value != null)\n               view_.getContextLines().setValue(value);\n         }\n\n         @Override\n         protected Integer getValue()\n         {\n            return view_.getContextLines().getValue();\n         }\n      };\n\n      view_.getContextLines().addValueChangeHandler(new ValueChangeHandler<Integer>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Integer> event)\n         {\n            updateDiff(false);\n         }\n      });\n\n      view_.getCommitButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            server_.gitCommit(\n                  view_.getCommitMessage().getText(),\n                  view_.getCommitIsAmend().getValue(),\n                  false,\n                  new SimpleRequestCallback<ConsoleProcess>()\n                  {\n                     @Override\n                     public void onResponseReceived(ConsoleProcess proc)\n                     {\n                        proc.addProcessExitHandler(new ProcessExitEvent.Handler()\n                        {\n                           @Override\n                           public void onProcessExit(ProcessExitEvent event)\n                           {\n                              if (event.getExitCode() == 0)\n                                 view_.getCommitMessage().setText(\"\");\n                           }\n                        });\n                        new ConsoleProgressDialog(proc, server_).showModal();\n                     }\n                  });\n         }\n      });\n\n      view_.getOverrideSizeWarningButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            overrideSizeWarning_ = true;\n            updateDiff(false);\n         }\n      });\n   }","commit_id":"6be22277f7b3181b73e5ddc9c9af84a81ca63186","url":"https://github.com/rstudio/rstudio"},{"original_method":"public SVNCommandHandler(SVNPresenterDisplay display,\n                            GlobalDisplay globalDisplay,\n                            Commands commands,\n                            SVNServerOperations server,\n                            SVNState svnState,\n                            VCSFileOpener vcsFileOpener)\n   {\n      display_ = display;\n      globalDisplay_ = globalDisplay;\n      server_ = server;\n      svnState_ = svnState;\n      vcsFileOpener_ = vcsFileOpener;\n      GWT.<Binder>create(Binder.class).bind(commands, this);\n   }","id":43835,"modified_method":"public SVNCommandHandler(SVNPresenterDisplay display,\n                            GlobalDisplay globalDisplay,\n                            Commands commands,\n                            SVNServerOperations server,\n                            SVNState svnState,\n                            VCSFileOpener vcsFileOpener)\n   {\n      display_ = display;\n      globalDisplay_ = globalDisplay;\n      commands_ = commands;\n      server_ = server;\n      svnState_ = svnState;\n      vcsFileOpener_ = vcsFileOpener;\n      GWT.<Binder>create(Binder.class).bind(commands, this);\n   }","commit_id":"6be22277f7b3181b73e5ddc9c9af84a81ca63186","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public SVNReviewPanel(SVNChangelistTablePresenter changelist,\n                         LineTableView diffPane,\n                         final Commands commands,\n                         FileTypeRegistry fileTypeRegistry)\n   {\n      fileTypeRegistry_ = fileTypeRegistry;\n      splitPanel_ = new SplitLayoutPanel(4);\n\n      changelist_ = changelist.getView();\n      lines_ = diffPane;\n      lines_.getElement().setTabIndex(-1);\n\n      overrideSizeWarning_ = new SizeWarningWidget(\"diff\");\n\n      changelist.setSelectFirstItemByDefault(true);\n\n      Widget widget = GWT.<Binder>create(Binder.class).createAndBindUi(this);\n      initWidget(widget);\n\n      topToolbar_.addStyleName(RES.styles().toolbar());\n\n      switchViewButton_ = new LeftRightToggleButton(\"Changes\", \"History\", true);\n      topToolbar_.addLeftWidget(switchViewButton_);\n\n      topToolbar_.addLeftSeparator();\n\n      revertFilesButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Revert\",\n            commands.vcsRevert().getImageResource(),\n            (ClickHandler) null));\n\n/*\n      topToolbar_.addLeftSeparator();\n\n      ignoreButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Ignore\", RES.ignore(), (ClickHandler) null));\n*/\n\n      refreshButton_ = new ToolbarButton(\n            \"Refresh\", commands.vcsRefresh().getImageResource(),\n            (ClickHandler) null);\n      topToolbar_.addRightWidget(refreshButton_);\n\n      topToolbar_.addRightSeparator();\n\n\n      topToolbar_.addRightWidget(commands.vcsPull().createToolbarButton());\n\n      topToolbar_.addRightSeparator();\n\n      topToolbar_.addRightWidget(commands.vcsPush().createToolbarButton());\n\n      diffToolbar_.addStyleName(RES.styles().toolbar());\n      diffToolbar_.addStyleName(RES.styles().diffToolbar());\n\n      diffToolbar_.addLeftSeparator();\n      discardAllButton_ = diffToolbar_.addLeftWidget(new ToolbarButton(\n            \"Discard All\", RES.discard(), (ClickHandler) null));\n\n      listBoxAdapter_ = new ListBoxAdapter(contextLines_);\n\n      new WidgetHandlerRegistration(this)\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return Event.addNativePreviewHandler(new NativePreviewHandler()\n            {\n               @Override\n               public void onPreviewNativeEvent(NativePreviewEvent event)\n               {\n                  NativeEvent nativeEvent = event.getNativeEvent();\n                  if (event.getTypeInt() == Event.ONKEYDOWN\n                      && KeyboardShortcut.getModifierValue(nativeEvent) == KeyboardShortcut.CTRL)\n                  {\n                     switch (nativeEvent.getKeyCode())\n                     {\n                        case KeyCodes.KEY_DOWN:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, getLineScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_UP:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_,\n                                    -getLineScroll(diffScroll_),\n                                    0);\n                           break;\n                        case KeyCodes.KEY_PAGEDOWN:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, getPageScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_PAGEUP:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_,\n                                    -getPageScroll(diffScroll_),\n                                    0);\n                           break;\n                     }\n                  }\n               }\n            });\n         }\n      };\n   }","id":43836,"modified_method":"@Inject\n   public SVNReviewPanel(SVNChangelistTablePresenter changelist,\n                         LineTableView diffPane,\n                         Commands commands)\n   {\n      commands_ = commands;\n      splitPanel_ = new SplitLayoutPanel(4);\n\n      changelist_ = changelist.getView();\n      lines_ = diffPane;\n      lines_.getElement().setTabIndex(-1);\n\n      overrideSizeWarning_ = new SizeWarningWidget(\"diff\");\n\n      changelist.setSelectFirstItemByDefault(true);\n\n      Widget widget = GWT.<Binder>create(Binder.class).createAndBindUi(this);\n      initWidget(widget);\n\n      topToolbar_.addStyleName(RES.styles().toolbar());\n\n      switchViewButton_ = new LeftRightToggleButton(\"Changes\", \"History\", true);\n      switchViewButton_.getElement().getStyle().setMarginRight(8, Unit.PX);\n      topToolbar_.addLeftWidget(switchViewButton_);\n      \n      topToolbar_.addLeftWidget(commands.vcsAddFiles().createToolbarButton());\n      topToolbar_.addLeftWidget(commands.vcsRemoveFiles().createToolbarButton());\n      topToolbar_.addLeftWidget(commands.vcsRevert().createToolbarButton());\n\n     \n      \n/*\n      topToolbar_.addLeftSeparator();\n\n      ignoreButton_ = topToolbar_.addLeftWidget(new ToolbarButton(\n            \"Ignore\", RES.ignore(), (ClickHandler) null));\n*/\n\n    \n      topToolbar_.addRightWidget(commands.vcsRefresh().createToolbarButton());\n\n      topToolbar_.addRightSeparator();\n\n      commands.vcsPull().setButtonLabel(\"Update\");\n      commands.vcsPull().setMenuLabel(\"Update\");\n      topToolbar_.addRightWidget(commands.vcsPull().createToolbarButton());\n\n      topToolbar_.addRightSeparator();\n      topToolbar_.addRightWidget(commands.vcsCommit().createToolbarButton());\n      \n      \n      diffToolbar_.addStyleName(RES.styles().toolbar());\n      diffToolbar_.addStyleName(RES.styles().diffToolbar());\n\n      diffToolbar_.addLeftSeparator();\n      discardAllButton_ = diffToolbar_.addLeftWidget(new ToolbarButton(\n            \"Discard All\", RES.discard(), (ClickHandler) null));\n\n      listBoxAdapter_ = new ListBoxAdapter(contextLines_);\n\n      new WidgetHandlerRegistration(this)\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return Event.addNativePreviewHandler(new NativePreviewHandler()\n            {\n               @Override\n               public void onPreviewNativeEvent(NativePreviewEvent event)\n               {\n                  NativeEvent nativeEvent = event.getNativeEvent();\n                  if (event.getTypeInt() == Event.ONKEYDOWN\n                      && KeyboardShortcut.getModifierValue(nativeEvent) == KeyboardShortcut.CTRL)\n                  {\n                     switch (nativeEvent.getKeyCode())\n                     {\n                        case KeyCodes.KEY_DOWN:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, getLineScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_UP:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_,\n                                    -getLineScroll(diffScroll_),\n                                    0);\n                           break;\n                        case KeyCodes.KEY_PAGEDOWN:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_, getPageScroll(diffScroll_), 0);\n                           break;\n                        case KeyCodes.KEY_PAGEUP:\n                           nativeEvent.preventDefault();\n                           scrollBy(diffScroll_,\n                                    -getPageScroll(diffScroll_),\n                                    0);\n                           break;\n                     }\n                  }\n               }\n            });\n         }\n      };\n   }","commit_id":"6be22277f7b3181b73e5ddc9c9af84a81ca63186","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showContextMenu(final int clientX, \n                               final int clientY,\n                               Command openSelectedCommand)\n   {\n      // make sure enabled/disabled states of buttons are correct (note\n      // that this won't be necessary when the Stage/Revert buttons correctly\n      // update their enabled state at startup -- see bug #2102)\n      setFilesCommandsEnabled(getSelectedPaths().size() > 0);\n\n      final ToolbarPopupMenu menu = new ToolbarPopupMenu();\n\n     MenuItem revertMenu = new MenuItem(\n           AppCommand.formatMenuLabel(RES.discard(), \"Revert...\", \"\"),\n           true,\n           new Command() {\n              @Override\n              public void execute()\n              {\n                 revertFilesButton_.click();\n              }\n\n           });\n      if (revertFilesButton_.isEnabled())\n         menu.addItem(revertMenu);\n\n      menu.addSeparator();\n      MenuItem openMenu = new MenuItem(\"Open\", false, openSelectedCommand);\n      menu.addItem(openMenu);\n      \n      menu.setPopupPositionAndShow(new PositionCallback() {\n         @Override\n         public void setPosition(int offsetWidth, int offsetHeight)\n         {\n            menu.setPopupPosition(clientX, clientY);\n         }\n      });\n     \n   }","id":43837,"modified_method":"@Override\n   public void showContextMenu(final int clientX, \n                               final int clientY)\n   {\n      final ToolbarPopupMenu menu = new ToolbarPopupMenu();\n      \n      menu.addItem(commands_.vcsAddFiles().createMenuItem(false));\n      menu.addItem(commands_.vcsRemoveFiles().createMenuItem(false));\n      menu.addItem(commands_.vcsRevert().createMenuItem(false));\n      menu.addSeparator();\n      menu.addItem(commands_.vcsOpen().createMenuItem(false));\n    \n      menu.setPopupPositionAndShow(new PositionCallback() {\n         @Override\n         public void setPosition(int offsetWidth, int offsetHeight)\n         {\n            menu.setPopupPosition(clientX, clientY);     \n         }\n      });\n   }","commit_id":"6be22277f7b3181b73e5ddc9c9af84a81ca63186","url":"https://github.com/rstudio/rstudio"},{"original_method":"void showContextMenu(int clientX, \n                           int clientY, \n                           Command openSelectedCommand);","id":43838,"modified_method":"void showContextMenu(int clientX, int clientY);","commit_id":"6be22277f7b3181b73e5ddc9c9af84a81ca63186","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public SVNReviewPresenter(SVNServerOperations server,\n                             Display view,\n                             final EventBus events,\n                             final SVNState svnState,\n                             final Session session,\n                             final GlobalDisplay globalDisplay)\n   {\n      server_ = server;\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      svnState_ = svnState;\n\n      new WidgetHandlerRegistration(view.asWidget())\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return svnState_.addVcsRefreshHandler(new VcsRefreshHandler()\n            {\n               @Override\n               public void onVcsRefresh(VcsRefreshEvent event)\n               {\n                  if (event.getReason() == Reason.VcsOperation)\n                  {\n                     Scheduler.get().scheduleDeferred(new ScheduledCommand()\n                     {\n                        @Override\n                        public void execute()\n                        {\n                           updateDiff();\n\n                           initialized_ = true;\n                        }\n                     });\n                  }\n               }\n            }, false);\n         }\n      };\n\n      new WidgetHandlerRegistration(view.asWidget())\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return events.addHandler(FileChangeEvent.TYPE, new FileChangeHandler()\n            {\n               @Override\n               public void onFileChange(FileChangeEvent event)\n               {\n                  ArrayList<StatusAndPath> paths = view_.getChangelistTable()\n                        .getSelectedItems();\n                  if (paths.size() != 1)\n                  {\n                     clearDiff();\n                     return;\n                  }\n\n                  StatusAndPath vcsStatus = StatusAndPath.fromInfo(\n                        event.getFileChange().getFile().getGitStatus());\n                  if (paths.get(0).getRawPath().equals(vcsStatus.getRawPath()))\n                  {\n                     svnState.refresh(false);\n                  }\n               }\n            });\n         }\n      };\n\n      view_.getChangelistTable().addSelectionChangeHandler(new com.google.gwt.view.client.SelectionChangeEvent.Handler()\n      {\n         @Override\n         public void onSelectionChange(SelectionChangeEvent event)\n         {\n            overrideSizeWarning_ = false;\n            view_.setFilesCommandsEnabled(view_.getSelectedPaths().size() > 0);\n            if (initialized_)\n               updateDiff();\n         }\n      });\n      view_.getChangelistTable().addRowCountChangeHandler(new RowCountChangeEvent.Handler()\n      {\n         @Override\n         public void onRowCountChange(RowCountChangeEvent event)\n         {\n            // This is necessary because during initial load, the selection\n            // model has its selection set before any items are loaded into\n            // the table (so therefore view_.getSelectedPaths().size() is always\n            // 0, and the files commands are not enabled until selection changes\n            // again). By updating the files commands' enabled state on row\n            // count change as well, we can make sure they get enabled.\n            view_.setFilesCommandsEnabled(view_.getSelectedPaths().size() > 0);\n         }\n      });\n\n      view_.getChangelistTable().addContextMenuHandler(new ContextMenuHandler()\n      {\n         @Override\n         public void onContextMenu(ContextMenuEvent event)\n         {\n            NativeEvent nativeEvent = event.getNativeEvent();\n            view_.showContextMenu(nativeEvent.getClientX(),\n                                  nativeEvent.getClientY(),\n                                  new Command() {\n                                    @Override\n                                    public void execute()\n                                    {\n                                       openSelectedFile();\n                                    }\n            });\n         }\n      });\n\n      view_.getRevertFilesButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            final ArrayList<String> paths = view_.getSelectedPaths();\n            if (paths.size() == 0)\n               return;\n            String noun = paths.size() == 1 ? \"file\" : \"files\";\n            globalDisplay_.showYesNoMessage(\n                  GlobalDisplay.MSG_WARNING,\n                  \"Revert Changes\",\n                  \"Changes to the selected \" + noun + \" will be lost.\\n\\nAre \" +\n                  \"you sure you want to continue?\",\n                  new Operation()\n                  {\n                     @Override\n                     public void execute()\n                     {\n                        view_.getChangelistTable().selectNextUnselectedItem();\n\n                        server_.svnRevert(\n                              paths,\n                              new ProcessCallback(\"Revert Changes\"));\n\n                        view_.getChangelistTable().focus();\n                     }\n                  },\n                  false);\n         }\n      });\n\n      view_.getDiscardAllButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            String which = view_.getLineTableDisplay()\n                                 .getSelectedLines()\n                                 .size() == 0\n                           ? \"All \"\n                           : \"The selected\";\n            globalDisplay.showYesNoMessage(\n                  GlobalDisplay.MSG_WARNING,\n                  \"Discard All\",\n                  which + \" changes in this file will be \" +\n                  \"lost.\\n\\nAre you sure you want to continue?\",\n                  new Operation()\n                  {\n                     @Override\n                     public void execute()\n                     {\n                        new DiscardClickHandler().execute();\n                     }\n                  },\n                  false);\n         }\n      });\n\n      view_.getRefreshButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            view_.getChangelistTable().showProgress();\n            svnState_.refresh(true);\n         }\n      });\n\n      view_.getLineTableDisplay().addDiffChunkActionHandler(new ApplyPatchHandler());\n      view_.getLineTableDisplay().addDiffLineActionHandler(new ApplyPatchHandler());\n\n      new IntStateValue(MODULE_SVN, KEY_CONTEXT_LINES, ClientState.PERSISTENT,\n                        session.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(Integer value)\n         {\n            if (value != null)\n               view_.getContextLines().setValue(value);\n         }\n\n         @Override\n         protected Integer getValue()\n         {\n            return view_.getContextLines().getValue();\n         }\n      };\n\n      view_.getContextLines().addValueChangeHandler(new ValueChangeHandler<Integer>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Integer> event)\n         {\n            updateDiff();\n         }\n      });\n\n      view_.getOverrideSizeWarningButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            overrideSizeWarning_ = true;\n            updateDiff();\n         }\n      });\n   }","id":43839,"modified_method":"@Inject\n   public SVNReviewPresenter(SVNServerOperations server,\n                             Display view,\n                             Binder binder,\n                             Commands commands,\n                             final EventBus events,\n                             final SVNState svnState,\n                             final Session session,\n                             final GlobalDisplay globalDisplay,\n                             VCSFileOpener vcsFileOpener)\n   {\n      server_ = server;\n      view_ = view;\n      svnState_ = svnState;\n      \n      binder.bind(commands, this);\n      \n      commandHandler_ = new SVNCommandHandler(view, \n                                              globalDisplay, \n                                              commands, \n                                              server, \n                                              svnState, \n                                              vcsFileOpener);\n      \n      new WidgetHandlerRegistration(view.asWidget())\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return svnState_.addVcsRefreshHandler(new VcsRefreshHandler()\n            {\n               @Override\n               public void onVcsRefresh(VcsRefreshEvent event)\n               {\n                  if (event.getReason() == Reason.VcsOperation)\n                  {\n                     Scheduler.get().scheduleDeferred(new ScheduledCommand()\n                     {\n                        @Override\n                        public void execute()\n                        {\n                           updateDiff();\n\n                           initialized_ = true;\n                        }\n                     });\n                  }\n               }\n            }, false);\n         }\n      };\n\n      new WidgetHandlerRegistration(view.asWidget())\n      {\n         @Override\n         protected HandlerRegistration doRegister()\n         {\n            return events.addHandler(FileChangeEvent.TYPE, new FileChangeHandler()\n            {\n               @Override\n               public void onFileChange(FileChangeEvent event)\n               {\n                  ArrayList<StatusAndPath> paths = view_.getChangelistTable()\n                        .getSelectedItems();\n                  if (paths.size() != 1)\n                  {\n                     clearDiff();\n                     return;\n                  }\n\n                  StatusAndPath vcsStatus = StatusAndPath.fromInfo(\n                        event.getFileChange().getFile().getGitStatus());\n                  if (paths.get(0).getRawPath().equals(vcsStatus.getRawPath()))\n                  {\n                     svnState.refresh(false);\n                  }\n               }\n            });\n         }\n      };\n\n      view_.getChangelistTable().addSelectionChangeHandler(new com.google.gwt.view.client.SelectionChangeEvent.Handler()\n      {\n         @Override\n         public void onSelectionChange(SelectionChangeEvent event)\n         {\n            overrideSizeWarning_ = false;\n            commandHandler_.setFilesCommandsEnabled(view_.getSelectedPaths().size() > 0);\n            if (initialized_)\n               updateDiff();\n         }\n      });\n      view_.getChangelistTable().addRowCountChangeHandler(new RowCountChangeEvent.Handler()\n      {\n         @Override\n         public void onRowCountChange(RowCountChangeEvent event)\n         {\n            // This is necessary because during initial load, the selection\n            // model has its selection set before any items are loaded into\n            // the table (so therefore view_.getSelectedPaths().size() is always\n            // 0, and the files commands are not enabled until selection changes\n            // again). By updating the files commands' enabled state on row\n            // count change as well, we can make sure they get enabled.\n            commandHandler_.setFilesCommandsEnabled(view_.getSelectedPaths().size() > 0);\n         }\n      });\n\n      view_.getChangelistTable().addContextMenuHandler(new ContextMenuHandler()\n      {\n         @Override\n         public void onContextMenu(ContextMenuEvent event)\n         {\n            NativeEvent nativeEvent = event.getNativeEvent();\n            view_.showContextMenu(nativeEvent.getClientX(),\n                                  nativeEvent.getClientY());\n         }\n      });\n\n      view_.getDiscardAllButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            String which = view_.getLineTableDisplay()\n                                 .getSelectedLines()\n                                 .size() == 0\n                           ? \"All \"\n                           : \"The selected\";\n            globalDisplay.showYesNoMessage(\n                  GlobalDisplay.MSG_WARNING,\n                  \"Discard All\",\n                  which + \" changes in this file will be \" +\n                  \"lost.\\n\\nAre you sure you want to continue?\",\n                  new Operation()\n                  {\n                     @Override\n                     public void execute()\n                     {\n                        new DiscardClickHandler().execute();\n                     }\n                  },\n                  false);\n         }\n      });\n\n      view_.getLineTableDisplay().addDiffChunkActionHandler(new ApplyPatchHandler());\n      view_.getLineTableDisplay().addDiffLineActionHandler(new ApplyPatchHandler());\n\n      new IntStateValue(MODULE_SVN, KEY_CONTEXT_LINES, ClientState.PERSISTENT,\n                        session.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(Integer value)\n         {\n            if (value != null)\n               view_.getContextLines().setValue(value);\n         }\n\n         @Override\n         protected Integer getValue()\n         {\n            return view_.getContextLines().getValue();\n         }\n      };\n\n      view_.getContextLines().addValueChangeHandler(new ValueChangeHandler<Integer>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Integer> event)\n         {\n            updateDiff();\n         }\n      });\n\n      view_.getOverrideSizeWarningButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            overrideSizeWarning_ = true;\n            updateDiff();\n         }\n      });\n   }","commit_id":"6be22277f7b3181b73e5ddc9c9af84a81ca63186","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public VCSApplicationWindow(Provider<GitPresenterCore> pVCSCore,\n                               Provider<ReviewPresenter> pReviewPresenter,\n                               Provider<HistoryPresenter> pHistoryPresenter,\n                               Provider<Commands> pCommands,\n                               Provider<Binder> pBinder,\n                               Provider<EventBus> pEventBus,\n                               Provider<FontSizeManager> pFontSizeManager,\n                               Session session)\n   {\n      super(pEventBus, pFontSizeManager);\n      pVCSCore_ = pVCSCore;\n      pReviewPresenter_ = pReviewPresenter;\n      pHistoryPresenter_ = pHistoryPresenter;\n      pCommands_ = pCommands;\n      pBinder_ = pBinder;\n      session_ = session;\n   }","id":43840,"modified_method":"@Inject\n   public VCSApplicationWindow(Provider<ReviewPresenter> pReviewPresenter,\n                               Provider<HistoryPresenter> pHistoryPresenter,\n                               Provider<Commands> pCommands,\n                               Provider<EventBus> pEventBus,\n                               Provider<FontSizeManager> pFontSizeManager)\n   {\n      super(pEventBus, pFontSizeManager);\n      pReviewPresenter_ = pReviewPresenter;\n      pHistoryPresenter_ = pHistoryPresenter;\n      pCommands_ = pCommands;\n   }","commit_id":"6be22277f7b3181b73e5ddc9c9af84a81ca63186","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected void onInitialize(LayoutPanel mainPanel, \n                               JavaScriptObject params)\n   {\n      // set our window title\n      Window.setTitle(\"Review Changes\");\n      \n      // bind commands to this instance\n      pBinder_.get().bind(pCommands_.get(), this);\n      \n      // make sure vcs core is initialized\n      if (session_.getSessionInfo().getVcsName().equalsIgnoreCase(\n                                                         VCSConstants.GIT_ID))\n         pVCSCore_.get();\n      \n      // show the vcs ui in our main panel\n      VCSApplicationParams vcsParams = params.<VCSApplicationParams>cast();\n      ReviewPresenter rpres = pReviewPresenter_.get();\n      ArrayList<StatusAndPath> selected = vcsParams.getSelected();\n      if (selected.size() > 0)\n         rpres.setSelectedPaths(selected);\n      HistoryPresenter hpres = pHistoryPresenter_.get();\n      if (vcsParams.getHistoryFileFilter() != null)\n         hpres.setFileFilter(vcsParams.getHistoryFileFilter());\n           \n      vcsPopupController_ = VCSPopup.show(mainPanel,\n                                          rpres,\n                                          hpres, \n                                          vcsParams.getShowHistory());  \n   }","id":43841,"modified_method":"@Override\n   protected void onInitialize(LayoutPanel mainPanel, \n                               JavaScriptObject params)\n   {\n      // set our window title\n      Window.setTitle(\"Review Changes\");\n            \n      // show the vcs ui in our main panel\n      VCSApplicationParams vcsParams = params.<VCSApplicationParams>cast();\n      ReviewPresenter rpres = pReviewPresenter_.get();\n      ArrayList<StatusAndPath> selected = vcsParams.getSelected();\n      if (selected.size() > 0)\n         rpres.setSelectedPaths(selected);\n      HistoryPresenter hpres = pHistoryPresenter_.get();\n      if (vcsParams.getHistoryFileFilter() != null)\n         hpres.setFileFilter(vcsParams.getHistoryFileFilter());\n           \n      vcsPopupController_ = VCSPopup.show(mainPanel,\n                                          rpres,\n                                          hpres, \n                                          vcsParams.getShowHistory());  \n   }","commit_id":"6be22277f7b3181b73e5ddc9c9af84a81ca63186","url":"https://github.com/rstudio/rstudio"},{"original_method":"private List<MethodContract> visitLogicalOperation(PsiExpression[] operands, boolean conjunction, List<ValueConstraint[]> states) {\n    ValueConstraint breakValue = conjunction ? FALSE_VALUE : TRUE_VALUE;\n    List<MethodContract> finalStates = ContainerUtil.newArrayList();\n    for (PsiExpression operand : operands) {\n      List<MethodContract> opResults = visitExpression(states, operand);\n      finalStates.addAll(ContainerUtil.filter(opResults, contract -> contract.returnValue == breakValue));\n      states = antecedentsReturning(opResults, negateConstraint(breakValue));\n    }\n    finalStates.addAll(toContracts(states, negateConstraint(breakValue)));\n    return finalStates;\n  }","id":43842,"modified_method":"private List<MethodContract> visitLogicalOperation(PsiExpression[] operands, boolean conjunction, List<ValueConstraint[]> states) {\n    ValueConstraint breakValue = conjunction ? FALSE_VALUE : TRUE_VALUE;\n    List<MethodContract> finalStates = ContainerUtil.newArrayList();\n    for (PsiExpression operand : operands) {\n      List<PreContract> opResults = visitExpression(states, operand);\n      finalStates.addAll(ContainerUtil.filter(knownContracts(opResults), contract -> contract.returnValue == breakValue));\n      states = antecedentsReturning(opResults, negateConstraint(breakValue));\n    }\n    finalStates.addAll(toContracts(states, negateConstraint(breakValue)));\n    return finalStates;\n  }","commit_id":"cbb7e26a7df40bec6d387c220c116449f7187948","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<ValueConstraint[]> antecedentsReturning(List<MethodContract> values, ValueConstraint result) {\n    return ContainerUtil.mapNotNull(values, contract -> contract.returnValue == result ? contract.arguments : null);\n  }","id":43843,"modified_method":"private static List<ValueConstraint[]> antecedentsReturning(List<PreContract> values, ValueConstraint result) {\n    return ContainerUtil.mapNotNull(knownContracts(values), contract -> contract.returnValue == result ? contract.arguments : null);\n  }","commit_id":"cbb7e26a7df40bec6d387c220c116449f7187948","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private List<MethodContract> visitExpression(final List<ValueConstraint[]> states, @Nullable PsiExpression expr) {\n    if (states.isEmpty()) return Collections.emptyList();\n    if (states.size() > 300) return Collections.emptyList(); // too complex\n\n    if (expr instanceof PsiPolyadicExpression) {\n      PsiExpression[] operands = ((PsiPolyadicExpression)expr).getOperands();\n      IElementType op = ((PsiPolyadicExpression)expr).getOperationTokenType();\n      if (operands.length == 2 && (op == JavaTokenType.EQEQ || op == JavaTokenType.NE)) {\n        return visitEqualityComparison(states, operands[0], operands[1], op == JavaTokenType.EQEQ);\n      }\n      if (op == JavaTokenType.ANDAND || op == JavaTokenType.OROR) {\n        return visitLogicalOperation(operands, op == JavaTokenType.ANDAND, states);\n      }\n    }\n\n    if (expr instanceof PsiConditionalExpression) {\n      List<MethodContract> conditionResults = visitExpression(states, ((PsiConditionalExpression)expr).getCondition());\n      return ContainerUtil.concat(\n        visitExpression(antecedentsReturning(conditionResults, TRUE_VALUE), ((PsiConditionalExpression)expr).getThenExpression()),\n        visitExpression(antecedentsReturning(conditionResults, FALSE_VALUE), ((PsiConditionalExpression)expr).getElseExpression()));\n    }\n\n\n    if (expr instanceof PsiParenthesizedExpression) {\n      return visitExpression(states, ((PsiParenthesizedExpression)expr).getExpression());\n    }\n    if (expr instanceof PsiTypeCastExpression) {\n      return visitExpression(states, ((PsiTypeCastExpression)expr).getOperand());\n    }\n\n    if (expr instanceof PsiPrefixExpression && ((PsiPrefixExpression)expr).getOperationTokenType() == JavaTokenType.EXCL) {\n      List<MethodContract> result = ContainerUtil.newArrayList();\n      for (MethodContract contract : visitExpression(states, ((PsiPrefixExpression)expr).getOperand())) {\n        if (contract.returnValue == TRUE_VALUE || contract.returnValue == FALSE_VALUE) {\n          result.add(new MethodContract(contract.arguments, negateConstraint(contract.returnValue)));\n        }\n      }\n      return result;\n    }\n\n    if (expr instanceof PsiInstanceOfExpression) {\n      final int parameter = resolveParameter(((PsiInstanceOfExpression)expr).getOperand());\n      if (parameter >= 0) {\n        return ContainerUtil.mapNotNull(states, state -> contractWithConstraint(state, parameter, NULL_VALUE, FALSE_VALUE));\n      }\n    }\n\n    if (expr instanceof PsiNewExpression) {\n      return toContracts(states, NOT_NULL_VALUE);\n    }\n    if (expr instanceof PsiMethodCallExpression) {\n      PsiMethod method = ((PsiMethodCallExpression)expr).resolveMethod();\n      if (method != null && NullableNotNullManager.isNotNull(method)) {\n        return toContracts(states, NOT_NULL_VALUE);\n      }\n    }\n\n    final ValueConstraint constraint = getLiteralConstraint(expr);\n    if (constraint != null) {\n      return toContracts(states, constraint);\n    }\n\n    int paramIndex = resolveParameter(expr);\n    if (paramIndex >= 0) {\n      List<MethodContract> result = ContainerUtil.newArrayList();\n      for (ValueConstraint[] state : states) {\n        if (state[paramIndex] != ANY_VALUE) {\n          // the second 'o' reference in cases like: if (o != null) return o;\n          result.add(new MethodContract(state, state[paramIndex]));\n        } else if (textMatches(getParameter(paramIndex).getTypeElement(), PsiKeyword.BOOLEAN)) {\n          // if (boolValue) ...\n          ContainerUtil.addIfNotNull(result, contractWithConstraint(state, paramIndex, TRUE_VALUE, TRUE_VALUE));\n          ContainerUtil.addIfNotNull(result, contractWithConstraint(state, paramIndex, FALSE_VALUE, FALSE_VALUE));\n        }\n      }\n      return result;\n    }\n\n    return Collections.emptyList();\n  }","id":43844,"modified_method":"@NotNull\n  private List<PreContract> visitExpression(final List<ValueConstraint[]> states, @Nullable PsiExpression expr) {\n    if (states.isEmpty()) return Collections.emptyList();\n    if (states.size() > 300) return Collections.emptyList(); // too complex\n\n    if (expr instanceof PsiPolyadicExpression) {\n      PsiExpression[] operands = ((PsiPolyadicExpression)expr).getOperands();\n      IElementType op = ((PsiPolyadicExpression)expr).getOperationTokenType();\n      if (operands.length == 2 && (op == JavaTokenType.EQEQ || op == JavaTokenType.NE)) {\n        return asPreContracts(visitEqualityComparison(states, operands[0], operands[1], op == JavaTokenType.EQEQ));\n      }\n      if (op == JavaTokenType.ANDAND || op == JavaTokenType.OROR) {\n        return asPreContracts(visitLogicalOperation(operands, op == JavaTokenType.ANDAND, states));\n      }\n    }\n\n    if (expr instanceof PsiConditionalExpression) {\n      List<PreContract> conditionResults = visitExpression(states, ((PsiConditionalExpression)expr).getCondition());\n      return ContainerUtil.concat(\n        visitExpression(antecedentsReturning(conditionResults, TRUE_VALUE), ((PsiConditionalExpression)expr).getThenExpression()),\n        visitExpression(antecedentsReturning(conditionResults, FALSE_VALUE), ((PsiConditionalExpression)expr).getElseExpression()));\n    }\n\n\n    if (expr instanceof PsiParenthesizedExpression) {\n      return visitExpression(states, ((PsiParenthesizedExpression)expr).getExpression());\n    }\n    if (expr instanceof PsiTypeCastExpression) {\n      return visitExpression(states, ((PsiTypeCastExpression)expr).getOperand());\n    }\n\n    if (expr instanceof PsiPrefixExpression && ((PsiPrefixExpression)expr).getOperationTokenType() == JavaTokenType.EXCL) {\n      List<PreContract> result = ContainerUtil.newArrayList();\n      for (PreContract contract : visitExpression(states, ((PsiPrefixExpression)expr).getOperand())) {\n        ContainerUtil.addIfNotNull(result, NegatingContract.negate(contract));\n      }\n      return result;\n    }\n\n    if (expr instanceof PsiInstanceOfExpression) {\n      final int parameter = resolveParameter(((PsiInstanceOfExpression)expr).getOperand());\n      if (parameter >= 0) {\n        return asPreContracts(ContainerUtil.mapNotNull(states, state -> contractWithConstraint(state, parameter, NULL_VALUE, FALSE_VALUE)));\n      }\n    }\n\n    if (expr instanceof PsiNewExpression) {\n      return asPreContracts(toContracts(states, NOT_NULL_VALUE));\n    }\n    if (expr instanceof PsiMethodCallExpression) {\n      return Collections.singletonList(new MethodCallContract((PsiMethodCallExpression)expr, states));\n    }\n\n    final ValueConstraint constraint = getLiteralConstraint(expr);\n    if (constraint != null) {\n      return asPreContracts(toContracts(states, constraint));\n    }\n\n    int paramIndex = resolveParameter(expr);\n    if (paramIndex >= 0) {\n      List<MethodContract> result = ContainerUtil.newArrayList();\n      for (ValueConstraint[] state : states) {\n        if (state[paramIndex] != ANY_VALUE) {\n          // the second 'o' reference in cases like: if (o != null) return o;\n          result.add(new MethodContract(state, state[paramIndex]));\n        } else if (textMatches(getParameter(paramIndex).getTypeElement(), PsiKeyword.BOOLEAN)) {\n          // if (boolValue) ...\n          ContainerUtil.addIfNotNull(result, contractWithConstraint(state, paramIndex, TRUE_VALUE, TRUE_VALUE));\n          ContainerUtil.addIfNotNull(result, contractWithConstraint(state, paramIndex, FALSE_VALUE, FALSE_VALUE));\n        }\n      }\n      return asPreContracts(result);\n    }\n\n    return Collections.emptyList();\n  }","commit_id":"cbb7e26a7df40bec6d387c220c116449f7187948","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private List<PreContract> visitStatements(List<ValueConstraint[]> states, PsiStatement... statements) {\n    CodeBlockContracts result = new CodeBlockContracts();\n    for (PsiStatement statement : statements) {\n      if (statement instanceof PsiBlockStatement) {\n        result.addAll(visitStatements(states, ((PsiBlockStatement)statement).getCodeBlock().getStatements()));\n      }\n      else if (statement instanceof PsiIfStatement) {\n        List<MethodContract> conditionResults = visitExpression(states, ((PsiIfStatement)statement).getCondition());\n\n        PsiStatement thenBranch = ((PsiIfStatement)statement).getThenBranch();\n        if (thenBranch != null) {\n          result.addAll(visitStatements(antecedentsReturning(conditionResults, TRUE_VALUE), thenBranch));\n        }\n\n        List<ValueConstraint[]> falseStates = antecedentsReturning(conditionResults, FALSE_VALUE);\n        PsiStatement elseBranch = ((PsiIfStatement)statement).getElseBranch();\n        if (elseBranch != null) {\n          result.addAll(visitStatements(falseStates, elseBranch));\n        } else {\n          states = falseStates;\n          continue;\n        }\n      }\n      else if (statement instanceof PsiThrowStatement) {\n        result.addAll(ContainerUtil.map(toContracts(states, THROW_EXCEPTION), KnownContract::new));\n      }\n      else if (statement instanceof PsiReturnStatement) {\n        result.addAll(ContainerUtil.map(visitExpression(states, ((PsiReturnStatement)statement).getReturnValue()), KnownContract::new));\n      }\n      else if (statement instanceof PsiAssertStatement) {\n        List<MethodContract> conditionResults = visitExpression(states, ((PsiAssertStatement)statement).getAssertCondition());\n        result.addAll(ContainerUtil.map(toContracts(antecedentsReturning(conditionResults, FALSE_VALUE), THROW_EXCEPTION), KnownContract::new));\n      }\n      else if (statement instanceof PsiDeclarationStatement) {\n        result.declarations.add((PsiDeclarationStatement)statement);\n        continue;\n      }\n      else if (statement instanceof PsiDoWhileStatement) {\n        result.addAll(visitStatements(states, ((PsiDoWhileStatement)statement).getBody()));\n      }\n\n      break; // visit only the first statement unless it's 'if' whose 'then' always returns and the next statement is effectively 'else'\n    }\n    return result.accumulated;\n  }","id":43845,"modified_method":"@NotNull\n  private List<PreContract> visitStatements(List<ValueConstraint[]> states, PsiStatement... statements) {\n    CodeBlockContracts result = new CodeBlockContracts();\n    for (PsiStatement statement : statements) {\n      if (statement instanceof PsiBlockStatement) {\n        result.addAll(visitStatements(states, ((PsiBlockStatement)statement).getCodeBlock().getStatements()));\n      }\n      else if (statement instanceof PsiIfStatement) {\n        List<PreContract> conditionResults = visitExpression(states, ((PsiIfStatement)statement).getCondition());\n\n        PsiStatement thenBranch = ((PsiIfStatement)statement).getThenBranch();\n        if (thenBranch != null) {\n          result.addAll(visitStatements(antecedentsReturning(conditionResults, TRUE_VALUE), thenBranch));\n        }\n\n        List<ValueConstraint[]> falseStates = antecedentsReturning(conditionResults, FALSE_VALUE);\n        PsiStatement elseBranch = ((PsiIfStatement)statement).getElseBranch();\n        if (elseBranch != null) {\n          result.addAll(visitStatements(falseStates, elseBranch));\n        } else {\n          states = falseStates;\n          continue;\n        }\n      }\n      else if (statement instanceof PsiThrowStatement) {\n        result.addAll(asPreContracts(toContracts(states, THROW_EXCEPTION)));\n      }\n      else if (statement instanceof PsiReturnStatement) {\n        result.addAll(visitExpression(states, ((PsiReturnStatement)statement).getReturnValue()));\n      }\n      else if (statement instanceof PsiAssertStatement) {\n        List<PreContract> conditionResults = visitExpression(states, ((PsiAssertStatement)statement).getAssertCondition());\n        result.addAll(asPreContracts(toContracts(antecedentsReturning(conditionResults, FALSE_VALUE), THROW_EXCEPTION)));\n      }\n      else if (statement instanceof PsiDeclarationStatement) {\n        result.declarations.add((PsiDeclarationStatement)statement);\n        continue;\n      }\n      else if (statement instanceof PsiDoWhileStatement) {\n        result.addAll(visitStatements(states, ((PsiDoWhileStatement)statement).getBody()));\n      }\n\n      break; // visit only the first statement unless it's 'if' whose 'then' always returns and the next statement is effectively 'else'\n    }\n    return result.accumulated;\n  }","commit_id":"cbb7e26a7df40bec6d387c220c116449f7187948","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<MethodContract> toContracts(List<ValueConstraint[]> states, ValueConstraint constraint) {\n    return ContainerUtil.map(states, state -> new MethodContract(state, constraint));\n  }","id":43846,"modified_method":"static List<MethodContract> toContracts(List<ValueConstraint[]> states, ValueConstraint constraint) {\n    return ContainerUtil.map(states, state -> new MethodContract(state, constraint));\n  }","commit_id":"cbb7e26a7df40bec6d387c220c116449f7187948","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DelegationContract(PsiMethodCallExpression expression, boolean negated) {\n    myExpression = expression;\n    myNegated = negated;\n  }","id":43847,"modified_method":"DelegationContract(PsiMethodCallExpression expression, boolean negated) {\n    myExpression = expression;\n    myNegated = negated;\n  }","commit_id":"cbb7e26a7df40bec6d387c220c116449f7187948","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public KnownContract(MethodContract knownContract) {\n    myKnownContract = knownContract;\n  }","id":43848,"modified_method":"KnownContract(@NotNull MethodContract knownContract) {\n    myKnownContract = knownContract;\n  }","commit_id":"cbb7e26a7df40bec6d387c220c116449f7187948","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SideEffectFilter(List<PsiExpression> expressionsToCheck, List<PreContract> contracts) {\n    myExpressionsToCheck = expressionsToCheck;\n    myContracts = contracts;\n  }","id":43849,"modified_method":"SideEffectFilter(List<PsiExpression> expressionsToCheck, List<PreContract> contracts) {\n    myExpressionsToCheck = expressionsToCheck;\n    myContracts = contracts;\n  }","commit_id":"cbb7e26a7df40bec6d387c220c116449f7187948","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public QualifiedName asQualifiedName() {\n    return PyPsiUtils.asQualifiedName(this);\n  }","id":43850,"modified_method":"@Nullable\n  @Override\n  public QualifiedName asQualifiedName() {\n    if (myQualifiedName == null) {\n      myQualifiedName = PyPsiUtils.asQualifiedName(this);\n    }\n    return myQualifiedName;\n  }","commit_id":"6bbdc88bfd31c60b12821d65f8d103ac11b5e119","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static List<PsiElement> resolveImportReference(final PyReferenceExpression importRef) {\n    // prerequisites\n    if (importRef == null) return Collections.emptyList();\n    if (!importRef.isValid()) return Collections.emptyList(); // we often catch a reparse while in a process of resolution\n    final String referencedName = importRef.getReferencedName(); // it will be the \"foo\" in later comments\n    if (referencedName == null) return Collections.emptyList();\n    final PsiFile file = importRef.getContainingFile();\n    if (file == null || !file.isValid()) return Collections.emptyList();\n\n    final PsiElement parent =\n      PsiTreeUtil.getParentOfType(importRef, PyImportElement.class, PyFromImportStatement.class); //importRef.getParent();\n    if (parent instanceof PyImportElement) {\n      PyImportElement import_element = (PyImportElement)parent;\n      return multiResolveImportElement(import_element, importRef.asQualifiedName());\n    }\n    else if (parent instanceof PyFromImportStatement) { // \"from foo import\"\n      PyFromImportStatement from_import_statement = (PyFromImportStatement)parent;\n      return resolveFromImportStatementSource(from_import_statement, importRef.asQualifiedName());\n    }\n    return Collections.emptyList();\n  }","id":43851,"modified_method":"@NotNull\n  public static List<PsiElement> resolveImportReference(final PyReferenceExpression importRef) {\n    // prerequisites\n    if (importRef == null) return Collections.emptyList();\n    if (!importRef.isValid()) return Collections.emptyList(); // we often catch a reparse while in a process of resolution\n    final String referencedName = importRef.getReferencedName(); // it will be the \"foo\" in later comments\n    if (referencedName == null) return Collections.emptyList();\n    final PsiFile file = importRef.getContainingFile();\n    if (file == null || !file.isValid()) return Collections.emptyList();\n\n    final PyElement parent = PsiTreeUtil.getParentOfType(importRef, PyImportElement.class, PyFromImportStatement.class); //importRef.getParent();\n    final PyQualifiedName qname = importRef.asQualifiedName();\n    if (parent instanceof PyImportElement) {\n      PyImportElement import_element = (PyImportElement)parent;\n      return multiResolveImportElement(import_element, qname);\n    }\n    else if (parent instanceof PyFromImportStatement) { // \"from foo import\"\n      PyFromImportStatement from_import_statement = (PyFromImportStatement)parent;\n      final List<PsiElement> results = resolveFromImportStatementSource(from_import_statement, qname);\n      if (results.isEmpty() && qname != null && qname.getComponentCount() > 0) {\n        final PyQualifiedName importedQName = PyQualifiedName.fromComponents(qname.getLastComponent());\n        final PyQualifiedName containingQName = qname.removeLastComponent();\n        final PsiElement result = resolveForeignImport(parent, importedQName, containingQName);\n        return result != null ? Collections.singletonList(result) : Collections.<PsiElement>emptyList();\n      }\n      return results;\n    }\n    return Collections.emptyList();\n  }","commit_id":"908d67d3973dc663211a10b15c9757a32b930897","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyFromImportNameReference(PyReferenceExpressionImpl element, PyResolveContext context) {\n    super(element, context);\n    myImportElement = PsiTreeUtil.getParentOfType(element, PyImportElement.class);\n    assert myImportElement != null;\n    myStatement = PsiTreeUtil.getParentOfType(element, PyFromImportStatement.class);\n    assert myStatement != null;\n  }","id":43852,"modified_method":"public PyFromImportNameReference(PyReferenceExpressionImpl element, PyResolveContext context) {\n    super(element, context);\n    myStatement = PsiTreeUtil.getParentOfType(element, PyFromImportStatement.class);\n    assert myStatement != null;\n  }","commit_id":"6b2fa6f9b7aec39465aa2c83b58af328b2e40115","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected List<RatedResolveResult> resolveInner() {\n    return ResolveImportUtil.resolveNameInFromImport(myImportElement, myElement.asQualifiedName(), myStatement);\n  }","id":43853,"modified_method":"@NotNull\n  @Override\n  protected List<RatedResolveResult> resolveInner() {\n    PyQualifiedName qName = myElement.asQualifiedName();\n    return qName == null\n           ? Collections.<RatedResolveResult>emptyList()\n           : ResolveImportUtil.resolveNameInFromImport(myStatement, qName);\n  }","commit_id":"6b2fa6f9b7aec39465aa2c83b58af328b2e40115","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public PsiElement resolve() {\n    return ResolveImportUtil.resolveImportElement(this, getImportedQName());\n  }","id":43854,"modified_method":"@Nullable\n  @Override\n  public PsiElement resolve() {\n    PyQualifiedName qName = getImportedQName();\n    return qName == null ? null : ResolveImportUtil.resolveImportElement(this, qName);\n  }","commit_id":"6b2fa6f9b7aec39465aa2c83b58af328b2e40115","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected List<RatedResolveResult> resolveInner() {\n    final String referencedName = myElement.getReferencedName();\n    if (referencedName == null) return Collections.emptyList();\n\n    final PyImportElement parent = PsiTreeUtil.getParentOfType(myElement, PyImportElement.class); //importRef.getParent();\n    final PyQualifiedName qname = myElement.asQualifiedName();\n    return ResolveImportUtil.resolveNameInImportStatement(parent, qname);\n  }","id":43855,"modified_method":"@NotNull\n  @Override\n  protected List<RatedResolveResult> resolveInner() {\n    final PyImportElement parent = PsiTreeUtil.getParentOfType(myElement, PyImportElement.class); //importRef.getParent();\n    final PyQualifiedName qname = myElement.asQualifiedName();\n    return qname == null ? Collections.<RatedResolveResult>emptyList() : ResolveImportUtil.resolveNameInImportStatement(parent, qname);\n  }","commit_id":"6b2fa6f9b7aec39465aa2c83b58af328b2e40115","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<RatedResolveResult> resolveNameInFromImport(PyImportElement importElement, PyQualifiedName qName,\n                                                                 PyFromImportStatement importStatement) {\n    if (qName == null) {\n      return Collections.emptyList();\n    }\n    PsiFile file = importElement.getContainingFile().getOriginalFile();\n    String name = qName.getComponents().get(0);\n\n    final List<PsiElement> candidates = importStatement.resolveImportSourceCandidates();\n    List<PsiElement> resultList = new ArrayList<PsiElement>();\n    for (PsiElement candidate : candidates) {\n      if (!candidate.isValid()) {\n        throw new PsiInvalidElementAccessException(candidate, \"Got an invalid candidate from resolveImportSourceCandidates(): \" + candidate.getClass());\n      }\n      if (candidate instanceof PsiDirectory) {\n        candidate = PyUtil.getPackageElement((PsiDirectory)candidate);\n      }\n      PsiElement result = resolveChild(candidate, name, file, false, true);\n      if (result != null) {\n        if (!result.isValid()) {\n          throw new PsiInvalidElementAccessException(result, \"Got an invalid candidate from resolveChild(): \" + result.getClass());\n        }\n        resultList.add(result);\n      }\n    }\n    if (!resultList.isEmpty()) {\n      return rateResults(resultList);\n    }\n    return Collections.emptyList();\n  }","id":43856,"modified_method":"public static List<RatedResolveResult> resolveNameInFromImport(PyFromImportStatement importStatement, @NotNull PyQualifiedName qName) {\n    PsiFile file = importStatement.getContainingFile().getOriginalFile();\n    String name = qName.getComponents().get(0);\n\n    final List<PsiElement> candidates = importStatement.resolveImportSourceCandidates();\n    List<PsiElement> resultList = new ArrayList<PsiElement>();\n    for (PsiElement candidate : candidates) {\n      if (!candidate.isValid()) {\n        throw new PsiInvalidElementAccessException(candidate, \"Got an invalid candidate from resolveImportSourceCandidates(): \" + candidate.getClass());\n      }\n      if (candidate instanceof PsiDirectory) {\n        candidate = PyUtil.getPackageElement((PsiDirectory)candidate);\n      }\n      PsiElement result = resolveChild(candidate, name, file, false, true);\n      if (result != null) {\n        if (!result.isValid()) {\n          throw new PsiInvalidElementAccessException(result, \"Got an invalid candidate from resolveChild(): \" + result.getClass());\n        }\n        resultList.add(result);\n      }\n    }\n    if (!resultList.isEmpty()) {\n      return rateResults(resultList);\n    }\n    return Collections.emptyList();\n  }","commit_id":"6b2fa6f9b7aec39465aa2c83b58af328b2e40115","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement resolveImportElement(PyImportElement importElement, final PyQualifiedName qName) {\n    final List<RatedResolveResult> resultList = RatedResolveResult.sorted(multiResolveImportElement(importElement, qName));\n    return resultList.size() > 0 ? resultList.get(0).getElement() : null;\n  }","id":43857,"modified_method":"@Nullable\n  public static PsiElement resolveImportElement(PyImportElement importElement, @NotNull final PyQualifiedName qName) {\n    List<RatedResolveResult> targets;\n    final PyStatement importStatement = importElement.getContainingImportStatement();\n    if (importStatement instanceof PyFromImportStatement) {\n      targets = resolveNameInFromImport((PyFromImportStatement)importStatement, qName);\n    }\n    else { // \"import foo\"\n      targets = resolveNameInImportStatement(importElement, qName);\n    }\n    final List<RatedResolveResult> resultList = RatedResolveResult.sorted(targets);\n    return resultList.size() > 0 ? resultList.get(0).getElement() : null;\n  }","commit_id":"6b2fa6f9b7aec39465aa2c83b58af328b2e40115","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<RatedResolveResult> resolveNameInImportStatement(PyImportElement importElement, PyQualifiedName qName) {\n    if (qName == null) {\n      return Collections.emptyList();\n    }\n    final PsiFile file = importElement.getContainingFile().getOriginalFile();\n    boolean absoluteImportEnabled = isAbsoluteImportEnabledFor(importElement);\n    final List<PsiElement> modules = resolveModule(qName, file, absoluteImportEnabled, 0);\n    if (modules.size() > 0) {\n      return rateResults(modules);\n    }\n    return Collections.emptyList();\n  }","id":43858,"modified_method":"public static List<RatedResolveResult> resolveNameInImportStatement(PyImportElement importElement, @NotNull PyQualifiedName qName) {\n    final PsiFile file = importElement.getContainingFile().getOriginalFile();\n    boolean absoluteImportEnabled = isAbsoluteImportEnabledFor(importElement);\n    final List<PsiElement> modules = resolveModule(qName, file, absoluteImportEnabled, 0);\n    return rateResults(modules);\n  }","commit_id":"6b2fa6f9b7aec39465aa2c83b58af328b2e40115","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Add import directive into the PSI tree for the given namespace.\n     *\n     * @param importString full name of the import. Can contain .* if necessary.\n     * @param file File where directive should be added.\n     */\n    public static void addImportDirective(@NotNull String importString, @NotNull JetFile file) {\n        List<JetImportDirective> importDirectives = file.getImportDirectives();\n\n        JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importString);\n\n        String lineSeparator = System.getProperty(\"line.separator\");\n        if (!importDirectives.isEmpty()) {\n\n            // Check if import is already present\n            for (JetImportDirective directive : importDirectives) {\n                if (directive.getText().endsWith(importString) || directive.getText().endsWith(importString + \";\")) {\n                    return;\n                }\n            }\n\n            JetImportDirective lastDirective = importDirectives.get(importDirectives.size() - 1);\n            lastDirective.getParent().addAfter(newDirective, lastDirective);\n            lastDirective.getParent().addAfter(JetPsiFactory.createWhiteSpace(file.getProject(), lineSeparator), lastDirective);\n        }\n        else {\n            List<JetDeclaration> declarations = file.getDeclarations();\n            assert !declarations.isEmpty();\n            JetDeclaration firstDeclaration = declarations.iterator().next();\n            firstDeclaration.getParent().addBefore(newDirective, firstDeclaration);\n            firstDeclaration.getParent().addBefore(JetPsiFactory.createWhiteSpace(file.getProject(), lineSeparator + lineSeparator), firstDeclaration);\n        }\n    }","id":43859,"modified_method":"/**\n     * Add import directive into the PSI tree for the given namespace.\n     *\n     * @param importString full name of the import. Can contain .* if necessary.\n     * @param file File where directive should be added.\n     */\n    public static void addImportDirective(@NotNull String importString, @NotNull JetFile file) {\n        List<JetImportDirective> importDirectives = file.getImportDirectives();\n\n        JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importString);\n\n        // TODO: Should be processed with formatter\n        final PsiElement newLineWhitespace = JetPsiFactory.createWhiteSpace(file.getProject(), \"\\n\");\n        final PsiElement doubleLineWhitespace = JetPsiFactory.createWhiteSpace(file.getProject(), \"\\n\\n\");\n\n        if (!importDirectives.isEmpty()) {\n\n            // Check if import is already present\n            for (JetImportDirective directive : importDirectives) {\n                if (directive.getText().endsWith(importString) || directive.getText().endsWith(importString + \";\")) {\n                    return;\n                }\n            }\n\n            JetImportDirective lastDirective = importDirectives.get(importDirectives.size() - 1);\n            lastDirective.getParent().addAfter(newDirective, lastDirective);\n            lastDirective.getParent().addAfter(newLineWhitespace, lastDirective);\n        }\n        else {\n            List<JetDeclaration> declarations = file.getDeclarations();\n            assert !declarations.isEmpty();\n            JetDeclaration firstDeclaration = declarations.iterator().next();\n            firstDeclaration.getParent().addBefore(newDirective, firstDeclaration);\n            firstDeclaration.getParent().addBefore(doubleLineWhitespace, firstDeclaration);\n        }\n    }","commit_id":"14bccd9352765fa215f4bad598c4fdf55589a05d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void generateMethods(Project project, Editor editor, JetClassOrObject classOrObject, List<DescriptorClassMember> selectedElements) {\n        final JetClassBody body = classOrObject.getBody();\n        if (body == null) {\n            return;\n        }\n\n        String lineSeparator = System.getProperty(\"line.separator\");\n\n        for (DescriptorClassMember selectedElement : selectedElements) {\n\n            body.addBefore(JetPsiFactory.createWhiteSpace(body.getProject(), lineSeparator + lineSeparator), body.getRBrace());\n\n            final DeclarationDescriptor descriptor = selectedElement.getDescriptor();\n            if (descriptor instanceof NamedFunctionDescriptor) {\n                JetElement target = overrideFunction(project, (NamedFunctionDescriptor) descriptor);\n                body.addBefore(target, body.getRBrace());\n            }\n            else if (descriptor instanceof PropertyDescriptor) {\n                JetElement target = overrideProperty(project, (PropertyDescriptor) descriptor);\n                body.addBefore(target, body.getRBrace());\n            }\n        }\n    }","id":43860,"modified_method":"public static void generateMethods(Project project, Editor editor, JetClassOrObject classOrObject, List<DescriptorClassMember> selectedElements) {\n        final JetClassBody body = classOrObject.getBody();\n        if (body == null) {\n            return;\n        }\n\n        final PsiElement newLineWhitespace = JetPsiFactory.createWhiteSpace(body.getProject(), \"\\n\");\n\n        for (DescriptorClassMember selectedElement : selectedElements) {\n\n            // TODO: Insert spaces should be done by formatter\n            body.addBefore(newLineWhitespace, body.getRBrace());\n\n            final DeclarationDescriptor descriptor = selectedElement.getDescriptor();\n            if (descriptor instanceof NamedFunctionDescriptor) {\n                JetElement target = overrideFunction(project, (NamedFunctionDescriptor) descriptor);\n                body.addBefore(target, body.getRBrace());\n            }\n            else if (descriptor instanceof PropertyDescriptor) {\n                JetElement target = overrideProperty(project, (PropertyDescriptor) descriptor);\n                body.addBefore(target, body.getRBrace());\n            }\n        }\n    }","commit_id":"14bccd9352765fa215f4bad598c4fdf55589a05d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Should we use instantaneous rates for the estimated speed, or the period rates? \n     * This first checks the router's configuration, then the context, and then \n     * finally falls back on a static default (true).\n     *\n     * @return true if we should use instantaneous rates, false if we should use period averages\n     */\n    private boolean getUseInstantaneousRates() {\n        if (_context.router() != null) {\n            String val = _context.router().getConfigSetting(PROP_USE_INSTANTANEOUS_RATES);\n            if (val != null) {\n                try {\n                    return Boolean.getBoolean(val);\n                } catch (NumberFormatException nfe) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"Instantaneous rate for speed improperly set in the router config [\" + val + \"]\", nfe);\n                }\n            }\n        }\n        String val = _context.getProperty(PROP_USE_INSTANTANEOUS_RATES, \"\"+DEFAULT_USE_INSTANTANEOUS_RATES);\n        if (val != null) {\n            try {\n                return Boolean.getBoolean(val);\n            } catch (NumberFormatException nfe) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Instantaneous rate for speed improperly set in the router environment [\" + val + \"]\", nfe);\n            }\n        }\n        return DEFAULT_USE_INSTANTANEOUS_RATES;\n    }","id":43861,"modified_method":"/**\n     * Should we use instantaneous rates for the estimated speed, or the period rates? \n     * This first checks the router's configuration, then the context, and then \n     * finally falls back on a static default (true).\n     *\n     * @return true if we should use instantaneous rates, false if we should use period averages\n     */\n    private boolean getUseInstantaneousRates() {\n        if (_context.router() != null) {\n            String val = _context.router().getConfigSetting(PROP_USE_INSTANTANEOUS_RATES);\n            if (val != null) {\n                return Boolean.valueOf(val).booleanValue();\n            }\n        }\n        String val = _context.getProperty(PROP_USE_INSTANTANEOUS_RATES, \"\"+DEFAULT_USE_INSTANTANEOUS_RATES);\n        if (val != null) {\n            return Boolean.valueOf(val).booleanValue();\n        }\n        return DEFAULT_USE_INSTANTANEOUS_RATES;\n    }","commit_id":"a5ed02eb1c2866b809041b290afd385c5df42d6b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Execute an XForms action.\n     *\n     * @param pipelineContext       current PipelineContext\n     * @param targetId              id of the target control\n     * @param eventHandlerContainer event handler containe this action is running in\n     * @param actionElement         Element specifying the action to execute\n     * @param actionContext         ActionContext instance for deferred updates, or null\n     */\n    public void runAction(final PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement, ActionContext actionContext) {\n\n        // Check that we understand the action element\n        final String actionNamespaceURI = actionElement.getNamespaceURI();\n        if (!XFormsConstants.XFORMS_NAMESPACE_URI.equals(actionNamespaceURI)) {\n            throw new OXFException(\"Invalid action namespace: \" + actionNamespaceURI);\n        }\n\n        // Set binding context\n        setBindingContext(pipelineContext, eventHandlerContainer.getId(), actionElement);\n\n        final String actionEventName = actionElement.getName();\n\n        if (XFormsActions.XFORMS_SETVALUE_ACTION.equals(actionEventName)) {\n            // 10.1.9 The setvalue Element\n            // xforms:setvalue\n\n            final String value = actionElement.attributeValue(\"value\");\n            final String content = actionElement.getStringValue();\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String valueToSet;\n            if (value != null) {\n                // Value to set is computed with an XPath expression\n                Map namespaceContext = Dom4jUtils.getNamespaceContextNoDefault(actionElement);\n                valueToSet = currentInstance.evaluateXPathAsString(pipelineContext, xformsControls.getCurrentSingleNode(), value, namespaceContext, null, xformsControls.getFunctionLibrary(), null);\n            } else {\n                // Value to set is static content\n                valueToSet = content;\n            }\n\n            // Set value on current node\n            final Node currentNode = xformsControls.getCurrentSingleNode();\n            XFormsInstance.setValueForNode(pipelineContext, currentNode, valueToSet);\n\n            if (actionContext != null) {\n                // \"XForms Actions that change only the value of an instance node results in setting\n                // the flags for recalculate, revalidate, and refresh to true and making no change to\n                // the flag for rebuild\".\n                actionContext.recalculate = true;\n                actionContext.revalidate = true;\n                actionContext.refresh = true;\n            } else {\n                // Send events directly\n                final XFormsModel model = xformsControls.getCurrentModel();\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_RESET_ACTION.equals(actionEventName)) {\n            // 10.1.11 The reset Element\n\n            final String modelId = actionElement.attributeValue(\"model\");\n\n            final Object modelObject = containingDocument.getObjectById(pipelineContext, modelId);\n            if (modelObject instanceof XFormsModel) {\n                final XFormsModel model = (XFormsModel) modelObject;\n                containingDocument.dispatchEvent(pipelineContext, new XFormsResetEvent(model));\n            } else {\n                throw new OXFException(\"xforms:reset model attribute must point to an xforms:model element.\");\n            }\n\n            // \"the reset action takes effect immediately and clears all of the flags.\"\n            if (actionContext != null)\n                actionContext.setAll(false);\n\n        } else if (XFormsActions.XFORMS_ACTION_ACTION.equals(actionEventName)) {\n            // 10.1.1 The action Element\n\n            final ActionContext newActionContext = (actionContext == null) ? new ActionContext() : null;\n            for (Iterator i = actionElement.elementIterator(); i.hasNext();) {\n                final Element embeddedActionElement = (Element) i.next();\n                runAction(pipelineContext, targetId, eventHandlerContainer, embeddedActionElement, (newActionContext == null) ? actionContext : newActionContext );\n            }\n            if (newActionContext != null) {\n                // Binding context has to be reset as it may have been modified by sub-actions\n                setBindingContext(pipelineContext, eventHandlerContainer.getId(), actionElement);\n                final XFormsModel model = xformsControls.getCurrentModel();\n\n                // Process deferred behavior\n                if (newActionContext.rebuild)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                if (newActionContext.recalculate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                if (newActionContext.revalidate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                if (newActionContext.refresh)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_REBUILD_ACTION.equals(actionEventName)) {\n            // 10.1.3 The rebuild Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.rebuild = false;\n\n        } else if (XFormsActions.XFORMS_RECALCULATE_ACTION.equals(actionEventName)) {\n            // 10.1.4 The recalculate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.recalculate = false;\n\n        } else if (XFormsActions.XFORMS_REVALIDATE_ACTION.equals(actionEventName)) {\n            // 10.1.5 The revalidate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.revalidate = false;\n\n        } else if (XFormsActions.XFORMS_REFRESH_ACTION.equals(actionEventName)) {\n            // 10.1.6 The refresh Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.refresh = false;\n\n        } else if (XFormsActions.XFORMS_TOGGLE_ACTION.equals(actionEventName)) {\n            // 9.2.3 The toggle Element\n\n            final String caseId = actionElement.attributeValue(\"case\");\n\n            // Update xforms:switch info and dispatch events\n            xformsControls.updateSwitchInfo(pipelineContext, caseId);\n\n        } else if (XFormsActions.XFORMS_INSERT_ACTION.equals(actionEventName)) {\n            // 9.3.5 The insert Element\n            final String atAttribute = actionElement.attributeValue(\"at\");\n            final String positionAttribute = actionElement.attributeValue(\"position\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToBeUpdated = xformsControls.getCurrentNodeset();\n\n            if (collectionToBeUpdated.size() > 0) {\n                // \"If the collection is empty, the insert action has no effect.\"\n\n                // \"2. The node-set binding identifies a homogeneous collection in the instance\n                // data. The final member of this collection is cloned to produce the node that will\n                // be inserted.\"\n                final Element clonedElement;\n                {\n                    final Element lastElement = (Element) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1);\n                    clonedElement = (Element) lastElement.createCopy();\n                    XFormsUtils.setInitialDecoration(clonedElement);\n                }\n\n                // \"Finally, this newly created node is inserted into the instance data at the location\n                // specified by attributes position and at.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final String insertionIndexString = currentInstance.evaluateXPathAsString(pipelineContext, xformsControls.getCurrentSingleNode(),\n                        \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                // Don't think we will get NaN with XPath 2.0...\n                int insertionIndex = \"NaN\".equals(insertionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(insertionIndexString) ;\n\n                // Adjust index to be in range\n                if (insertionIndex > collectionToBeUpdated.size())\n                    insertionIndex = collectionToBeUpdated.size();\n\n                if (insertionIndex < 1)\n                    insertionIndex = 1;\n\n                // Find actual insertion point and insert\n                final Element indexElement = (Element) collectionToBeUpdated.get(insertionIndex - 1);\n\n                final Element parentElement = indexElement.getParent();\n                final List siblingElements = parentElement.elements();\n                final int actualIndex = siblingElements.indexOf(indexElement);\n\n                // Insert new element (changes to the list are reflected in the document)\n                final int newNodeIndex;\n                if (\"after\".equals(positionAttribute) || \"NaN\".equals(insertionIndexString)) {\n                    siblingElements.add(actualIndex + 1, clonedElement);\n                    newNodeIndex = insertionIndex + 1;\n                } else if (\"before\".equals(positionAttribute)) {\n                    siblingElements.add(actualIndex, clonedElement);\n                    newNodeIndex = insertionIndex;\n                } else {\n                    throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after'.\");\n                }\n\n                // \"3. The index for any repeating sequence that is bound to the homogeneous\n                // collection where the node was added is updated to point to the newly added node.\n                // The indexes for inner nested repeat collections are re-initialized to\n                // startindex.\"\n\n                // Find list of affected repeat ids\n                final Map boundRepeatIds = new HashMap();\n                final Map childrenRepeatIds = new HashMap();\n                findAffectedRepeatIds(pipelineContext, parentElement, boundRepeatIds, childrenRepeatIds);\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                // Update repeat information for the ids found\n                if (boundRepeatIds.size() != 0 || childrenRepeatIds.size() != 0) {\n\n                    for (Iterator i = boundRepeatIds.keySet().iterator(); i.hasNext();) {\n                        final String repeatId = (String) i.next();\n                        currentControlsState.updateRepeatIndex(repeatId, newNodeIndex);\n                    }\n                    for (Iterator i = childrenRepeatIds.keySet().iterator(); i.hasNext();) {\n                        final String repeatId = (String) i.next();\n                        //final int newIndex = ((Integer) currentControlsState.getInitialRepeatIdToIndex().get(repeatId)).intValue();\n                        final int newIndex = 1;\n                        currentControlsState.updateRepeatIndex(repeatId, newIndex);\n                    }\n                }\n\n                // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsInsertEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_DELETE_ACTION.equals(actionEventName)) {\n            // 9.3.6 The delete Element\n\n            final String atAttribute = actionElement.attributeValue(\"at\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToBeUpdated = xformsControls.getCurrentNodeset();\n\n            if (collectionToBeUpdated.size() > 0) {\n                // \"If the collection is empty, the delete action has no effect.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final Element parentElement;\n                int deletionIndex;\n                final List siblingElements;\n                final int actualIndex;\n                {\n                    final String deletionIndexString = currentInstance.evaluateXPathAsString(pipelineContext, xformsControls.getCurrentSingleNode(),\n                            \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // Don't think we will get NaN with XPath 2.0...\n                    deletionIndex = \"NaN\".equals(deletionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(deletionIndexString) ;\n\n                    // Adjust index to be in range\n                    if (deletionIndex > collectionToBeUpdated.size())\n                        deletionIndex = collectionToBeUpdated.size();\n\n                    if (deletionIndex < 1)\n                        deletionIndex = 1;\n\n                    // Find actual deletion point\n                    final Element indexElement = (Element) collectionToBeUpdated.get(deletionIndex - 1);\n\n                    parentElement = indexElement.getParent();\n                    siblingElements = parentElement.elements();\n                    actualIndex = siblingElements.indexOf(indexElement);\n                }\n\n                // Find list of affected repeat ids\n                final Map boundRepeatIds = new HashMap();\n                final Map childrenRepeatIds = new HashMap();\n                findAffectedRepeatIds(pipelineContext, parentElement, boundRepeatIds, childrenRepeatIds);\n\n                // Then only perform the deletion (so that the list above is correct even when the last node is deleted)\n                siblingElements.remove(actualIndex);\n\n                // Rebuild ControlsState\n                final Map previousRepeatIdToIndex = xformsControls.getCurrentControlsState().getRepeatIdToIndex();\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                // Update repeat information for the ids found\n                if (boundRepeatIds.size() != 0 || childrenRepeatIds.size() != 0) {\n                    boolean updateInnerRepeats = false;\n                    // Iterate over bound repeat ids\n                    for (Iterator i = boundRepeatIds.keySet().iterator(); i.hasNext();) {\n                        final String repeatId = (String) i.next();\n\n                        if (collectionToBeUpdated.size() == 1) {\n                            // Delete the last element of the collection: the index must be set to 0\n                            currentControlsState.updateRepeatIndex(repeatId, 0);\n                            updateInnerRepeats = true;\n                        } else {\n                            final int currentlySelected = ((Integer) previousRepeatIdToIndex.get(repeatId)).intValue();\n                            if (currentlySelected == deletionIndex) {\n                                if (deletionIndex == collectionToBeUpdated.size()) {\n\n                                    // o \"When the last remaining item in the collection is removed,\n                                    // the index position becomes 0.\"\n\n                                    // o \"When the index was pointing to the deleted node, which was\n                                    // the last item in the collection, the index will point to the new\n                                    // last node of the collection and the index of inner repeats is\n                                    // reinitialized.\"\n\n                                    currentControlsState.updateRepeatIndex(repeatId, currentlySelected - 1);\n                                    updateInnerRepeats = true;\n                                } else {\n                                    // o \"When the index was pointing to the deleted node, which was\n                                    // not the last item in the collection, the index position is not\n                                    // changed and the index of inner repeats is re-initialized.\"\n\n                                    updateInnerRepeats = true;\n                                }\n                            }\n                        }\n                    }\n\n                    if (updateInnerRepeats) {\n                        for (Iterator i = childrenRepeatIds.keySet().iterator(); i.hasNext();) {\n                            final String repeatId = (String) i.next();\n                            final int newIndex = (collectionToBeUpdated.size() == 1) ? 0 : 1;\n                            currentControlsState.updateRepeatIndex(repeatId, newIndex);\n                        }\n                    }\n                }\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new org.orbeon.oxf.xforms.event.events.XFormsDeleteEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETINDEX_ACTION.equals(actionEventName)) {\n            // 9.3.7 The setindex Element\n\n            final String repeatId = actionElement.attributeValue(\"repeat\");\n            final String indexXPath = actionElement.attributeValue(\"index\");\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String indexString = currentInstance.evaluateXPathAsString(pipelineContext, xformsControls.getCurrentSingleNode(),\n                    \"string(number(\" + indexXPath + \"))\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n            executeSetindexAction(pipelineContext, containingDocument, repeatId, indexString);\n\n        } else if (XFormsActions.XFORMS_SEND_ACTION.equals(actionEventName)) {\n            // 10.1.10 The send Element\n\n            // Find submission object\n            final String submissionId = actionElement.attributeValue(\"submission\");\n            if (submissionId == null)\n                throw new OXFException(\"Missing mandatory submission attribute on xforms:send element.\");\n            final Object submission = containingDocument.getObjectById(pipelineContext, submissionId);\n            if (submission == null || !(submission instanceof XFormsModelSubmission))\n                throw new OXFException(\"submission attribute on xforms:send element does not refer to existing xforms:submission element.\");\n\n            // Dispatch event to submission object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitEvent((XFormsEventTarget) submission));\n\n        } else if (XFormsActions.XFORMS_DISPATCH_ACTION.equals(actionEventName)) {\n            // 10.1.2 The dispatch Element\n\n            // Mandatory attributes\n            final String newEventName = actionElement.attributeValue(\"name\");\n            if (newEventName == null)\n                throw new OXFException(\"Missing mandatory name attribute on xforms:dispatch element.\");\n            final String newEventTargetId = actionElement.attributeValue(\"target\");\n            if (newEventTargetId == null)\n                throw new OXFException(\"Missing mandatory target attribute on xforms:dispatch element.\");\n\n            // Optional attributes\n            final boolean newEventBubbles; {\n                final String newEventBubblesString = actionElement.attributeValue(\"bubbles\");\n                // FIXME: \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                newEventBubbles = Boolean.getBoolean((newEventBubblesString == null) ? \"true\" : newEventBubblesString);\n            }\n            final boolean newEventCancelable; {\n                // FIXME: \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                final String newEventCancelableString = actionElement.attributeValue(\"cancelable\");\n                newEventCancelable = Boolean.getBoolean((newEventCancelableString == null) ? \"true\" : newEventCancelableString);\n            }\n\n            final Object newTargetObject = containingDocument.getObjectById(pipelineContext, newEventTargetId);\n\n            if (newTargetObject instanceof XFormsEventTarget) {\n                // This can be anything\n                containingDocument.dispatchEvent(pipelineContext, XFormsEventFactory.createEvent(newEventName, (XFormsEventTarget) newTargetObject, newEventBubbles, newEventCancelable));\n            } else {\n                throw new OXFException(\"Invalid event target for id: \" + newEventTargetId);\n            }\n\n        } else {\n            throw new OXFException(\"Invalid action requested: \" + actionEventName);\n        }\n    }","id":43862,"modified_method":"/**\n     * Execute an XForms action.\n     *\n     * @param pipelineContext       current PipelineContext\n     * @param targetId              id of the target control\n     * @param eventHandlerContainer event handler containe this action is running in\n     * @param actionElement         Element specifying the action to execute\n     * @param actionContext         ActionContext instance for deferred updates, or null\n     */\n    public void runAction(final PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement, ActionContext actionContext) {\n\n        // Check that we understand the action element\n        final String actionNamespaceURI = actionElement.getNamespaceURI();\n        if (!XFormsConstants.XFORMS_NAMESPACE_URI.equals(actionNamespaceURI)) {\n            throw new OXFException(\"Invalid action namespace: \" + actionNamespaceURI);\n        }\n\n        // Set binding context\n        setBindingContext(pipelineContext, eventHandlerContainer.getId(), actionElement);\n\n        final String actionEventName = actionElement.getName();\n\n        if (XFormsActions.XFORMS_SETVALUE_ACTION.equals(actionEventName)) {\n            // 10.1.9 The setvalue Element\n            // xforms:setvalue\n\n            final String value = actionElement.attributeValue(\"value\");\n            final String content = actionElement.getStringValue();\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String valueToSet;\n            if (value != null) {\n                // Value to set is computed with an XPath expression\n                Map namespaceContext = Dom4jUtils.getNamespaceContextNoDefault(actionElement);\n                valueToSet = currentInstance.evaluateXPathAsString(pipelineContext, xformsControls.getCurrentSingleNode(), value, namespaceContext, null, xformsControls.getFunctionLibrary(), null);\n            } else {\n                // Value to set is static content\n                valueToSet = content;\n            }\n\n            // Set value on current node\n            final Node currentNode = xformsControls.getCurrentSingleNode();\n            XFormsInstance.setValueForNode(pipelineContext, currentNode, valueToSet);\n\n            if (actionContext != null) {\n                // \"XForms Actions that change only the value of an instance node results in setting\n                // the flags for recalculate, revalidate, and refresh to true and making no change to\n                // the flag for rebuild\".\n                actionContext.recalculate = true;\n                actionContext.revalidate = true;\n                actionContext.refresh = true;\n            } else {\n                // Send events directly\n                final XFormsModel model = xformsControls.getCurrentModel();\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_RESET_ACTION.equals(actionEventName)) {\n            // 10.1.11 The reset Element\n\n            final String modelId = actionElement.attributeValue(\"model\");\n\n            final Object modelObject = containingDocument.getObjectById(pipelineContext, modelId);\n            if (modelObject instanceof XFormsModel) {\n                final XFormsModel model = (XFormsModel) modelObject;\n                containingDocument.dispatchEvent(pipelineContext, new XFormsResetEvent(model));\n            } else {\n                throw new OXFException(\"xforms:reset model attribute must point to an xforms:model element.\");\n            }\n\n            // \"the reset action takes effect immediately and clears all of the flags.\"\n            if (actionContext != null)\n                actionContext.setAll(false);\n\n        } else if (XFormsActions.XFORMS_ACTION_ACTION.equals(actionEventName)) {\n            // 10.1.1 The action Element\n\n            final ActionContext newActionContext = (actionContext == null) ? new ActionContext() : null;\n            for (Iterator i = actionElement.elementIterator(); i.hasNext();) {\n                final Element embeddedActionElement = (Element) i.next();\n                runAction(pipelineContext, targetId, eventHandlerContainer, embeddedActionElement, (newActionContext == null) ? actionContext : newActionContext );\n            }\n            if (newActionContext != null) {\n                // Binding context has to be reset as it may have been modified by sub-actions\n                setBindingContext(pipelineContext, eventHandlerContainer.getId(), actionElement);\n                final XFormsModel model = xformsControls.getCurrentModel();\n\n                // Process deferred behavior\n                if (newActionContext.rebuild)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                if (newActionContext.recalculate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                if (newActionContext.revalidate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                if (newActionContext.refresh)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_REBUILD_ACTION.equals(actionEventName)) {\n            // 10.1.3 The rebuild Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.rebuild = false;\n\n        } else if (XFormsActions.XFORMS_RECALCULATE_ACTION.equals(actionEventName)) {\n            // 10.1.4 The recalculate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.recalculate = false;\n\n        } else if (XFormsActions.XFORMS_REVALIDATE_ACTION.equals(actionEventName)) {\n            // 10.1.5 The revalidate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.revalidate = false;\n\n        } else if (XFormsActions.XFORMS_REFRESH_ACTION.equals(actionEventName)) {\n            // 10.1.6 The refresh Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.refresh = false;\n\n        } else if (XFormsActions.XFORMS_TOGGLE_ACTION.equals(actionEventName)) {\n            // 9.2.3 The toggle Element\n\n            final String caseId = actionElement.attributeValue(\"case\");\n\n            // Update xforms:switch info and dispatch events\n            xformsControls.updateSwitchInfo(pipelineContext, caseId);\n\n        } else if (XFormsActions.XFORMS_INSERT_ACTION.equals(actionEventName)) {\n            // 9.3.5 The insert Element\n            final String atAttribute = actionElement.attributeValue(\"at\");\n            final String positionAttribute = actionElement.attributeValue(\"position\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToBeUpdated = xformsControls.getCurrentNodeset();\n\n            if (collectionToBeUpdated.size() > 0) {\n                // \"If the collection is empty, the insert action has no effect.\"\n\n                // \"2. The node-set binding identifies a homogeneous collection in the instance\n                // data. The final member of this collection is cloned to produce the node that will\n                // be inserted.\"\n                final Element clonedElement;\n                {\n                    final Element lastElement = (Element) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1);\n                    clonedElement = (Element) lastElement.createCopy();\n                    XFormsUtils.setInitialDecoration(clonedElement);\n                }\n\n                // \"Finally, this newly created node is inserted into the instance data at the location\n                // specified by attributes position and at.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final String insertionIndexString = currentInstance.evaluateXPathAsString(pipelineContext, xformsControls.getCurrentSingleNode(),\n                        \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                // Don't think we will get NaN with XPath 2.0...\n                int insertionIndex = \"NaN\".equals(insertionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(insertionIndexString) ;\n\n                // Adjust index to be in range\n                if (insertionIndex > collectionToBeUpdated.size())\n                    insertionIndex = collectionToBeUpdated.size();\n\n                if (insertionIndex < 1)\n                    insertionIndex = 1;\n\n                // Find actual insertion point and insert\n                final Element indexElement = (Element) collectionToBeUpdated.get(insertionIndex - 1);\n\n                final Element parentElement = indexElement.getParent();\n                final List siblingElements = parentElement.elements();\n                final int actualIndex = siblingElements.indexOf(indexElement);\n\n                // Insert new element (changes to the list are reflected in the document)\n                final int newNodeIndex;\n                if (\"after\".equals(positionAttribute) || \"NaN\".equals(insertionIndexString)) {\n                    siblingElements.add(actualIndex + 1, clonedElement);\n                    newNodeIndex = insertionIndex + 1;\n                } else if (\"before\".equals(positionAttribute)) {\n                    siblingElements.add(actualIndex, clonedElement);\n                    newNodeIndex = insertionIndex;\n                } else {\n                    throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after'.\");\n                }\n\n                // \"3. The index for any repeating sequence that is bound to the homogeneous\n                // collection where the node was added is updated to point to the newly added node.\n                // The indexes for inner nested repeat collections are re-initialized to\n                // startindex.\"\n\n                // Find list of affected repeat ids\n                final Map boundRepeatIds = new HashMap();\n                final Map childrenRepeatIds = new HashMap();\n                findAffectedRepeatIds(pipelineContext, parentElement, boundRepeatIds, childrenRepeatIds);\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                // Update repeat information for the ids found\n                if (boundRepeatIds.size() != 0 || childrenRepeatIds.size() != 0) {\n\n                    for (Iterator i = boundRepeatIds.keySet().iterator(); i.hasNext();) {\n                        final String repeatId = (String) i.next();\n                        currentControlsState.updateRepeatIndex(repeatId, newNodeIndex);\n                    }\n                    for (Iterator i = childrenRepeatIds.keySet().iterator(); i.hasNext();) {\n                        final String repeatId = (String) i.next();\n                        //final int newIndex = ((Integer) currentControlsState.getInitialRepeatIdToIndex().get(repeatId)).intValue();\n                        final int newIndex = 1;\n                        currentControlsState.updateRepeatIndex(repeatId, newIndex);\n                    }\n                }\n\n                // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsInsertEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_DELETE_ACTION.equals(actionEventName)) {\n            // 9.3.6 The delete Element\n\n            final String atAttribute = actionElement.attributeValue(\"at\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToBeUpdated = xformsControls.getCurrentNodeset();\n\n            if (collectionToBeUpdated.size() > 0) {\n                // \"If the collection is empty, the delete action has no effect.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final Element parentElement;\n                int deletionIndex;\n                final List siblingElements;\n                final int actualIndex;\n                {\n                    final String deletionIndexString = currentInstance.evaluateXPathAsString(pipelineContext, xformsControls.getCurrentSingleNode(),\n                            \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // Don't think we will get NaN with XPath 2.0...\n                    deletionIndex = \"NaN\".equals(deletionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(deletionIndexString) ;\n\n                    // Adjust index to be in range\n                    if (deletionIndex > collectionToBeUpdated.size())\n                        deletionIndex = collectionToBeUpdated.size();\n\n                    if (deletionIndex < 1)\n                        deletionIndex = 1;\n\n                    // Find actual deletion point\n                    final Element indexElement = (Element) collectionToBeUpdated.get(deletionIndex - 1);\n\n                    parentElement = indexElement.getParent();\n                    siblingElements = parentElement.elements();\n                    actualIndex = siblingElements.indexOf(indexElement);\n                }\n\n                // Find list of affected repeat ids\n                final Map boundRepeatIds = new HashMap();\n                final Map childrenRepeatIds = new HashMap();\n                findAffectedRepeatIds(pipelineContext, parentElement, boundRepeatIds, childrenRepeatIds);\n\n                // Then only perform the deletion (so that the list above is correct even when the last node is deleted)\n                siblingElements.remove(actualIndex);\n\n                // Rebuild ControlsState\n                final Map previousRepeatIdToIndex = xformsControls.getCurrentControlsState().getRepeatIdToIndex();\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                // Update repeat information for the ids found\n                if (boundRepeatIds.size() != 0 || childrenRepeatIds.size() != 0) {\n                    boolean updateInnerRepeats = false;\n                    // Iterate over bound repeat ids\n                    for (Iterator i = boundRepeatIds.keySet().iterator(); i.hasNext();) {\n                        final String repeatId = (String) i.next();\n\n                        if (collectionToBeUpdated.size() == 1) {\n                            // Delete the last element of the collection: the index must be set to 0\n                            currentControlsState.updateRepeatIndex(repeatId, 0);\n                            updateInnerRepeats = true;\n                        } else {\n                            final int currentlySelected = ((Integer) previousRepeatIdToIndex.get(repeatId)).intValue();\n                            if (currentlySelected == deletionIndex) {\n                                if (deletionIndex == collectionToBeUpdated.size()) {\n\n                                    // o \"When the last remaining item in the collection is removed,\n                                    // the index position becomes 0.\"\n\n                                    // o \"When the index was pointing to the deleted node, which was\n                                    // the last item in the collection, the index will point to the new\n                                    // last node of the collection and the index of inner repeats is\n                                    // reinitialized.\"\n\n                                    currentControlsState.updateRepeatIndex(repeatId, currentlySelected - 1);\n                                    updateInnerRepeats = true;\n                                } else {\n                                    // o \"When the index was pointing to the deleted node, which was\n                                    // not the last item in the collection, the index position is not\n                                    // changed and the index of inner repeats is re-initialized.\"\n\n                                    updateInnerRepeats = true;\n                                }\n                            }\n                        }\n                    }\n\n                    if (updateInnerRepeats) {\n                        for (Iterator i = childrenRepeatIds.keySet().iterator(); i.hasNext();) {\n                            final String repeatId = (String) i.next();\n                            final int newIndex = (collectionToBeUpdated.size() == 1) ? 0 : 1;\n                            currentControlsState.updateRepeatIndex(repeatId, newIndex);\n                        }\n                    }\n                }\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new org.orbeon.oxf.xforms.event.events.XFormsDeleteEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETINDEX_ACTION.equals(actionEventName)) {\n            // 9.3.7 The setindex Element\n\n            final String repeatId = actionElement.attributeValue(\"repeat\");\n            final String indexXPath = actionElement.attributeValue(\"index\");\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String indexString = currentInstance.evaluateXPathAsString(pipelineContext, xformsControls.getCurrentSingleNode(),\n                    \"string(number(\" + indexXPath + \"))\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n            executeSetindexAction(pipelineContext, containingDocument, repeatId, indexString);\n\n        } else if (XFormsActions.XFORMS_SEND_ACTION.equals(actionEventName)) {\n            // 10.1.10 The send Element\n\n            // Find submission object\n            final String submissionId = actionElement.attributeValue(\"submission\");\n            if (submissionId == null)\n                throw new OXFException(\"Missing mandatory submission attribute on xforms:send element.\");\n            final Object submission = containingDocument.getObjectById(pipelineContext, submissionId);\n            if (submission == null || !(submission instanceof XFormsModelSubmission))\n                throw new OXFException(\"submission attribute on xforms:send element does not refer to existing xforms:submission element.\");\n\n            // Dispatch event to submission object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitEvent((XFormsEventTarget) submission));\n\n        } else if (XFormsActions.XFORMS_DISPATCH_ACTION.equals(actionEventName)) {\n            // 10.1.2 The dispatch Element\n\n            // Mandatory attributes\n            final String newEventName = actionElement.attributeValue(\"name\");\n            if (newEventName == null)\n                throw new OXFException(\"Missing mandatory name attribute on xforms:dispatch element.\");\n            final String newEventTargetId = actionElement.attributeValue(\"target\");\n            if (newEventTargetId == null)\n                throw new OXFException(\"Missing mandatory target attribute on xforms:dispatch element.\");\n\n            // Optional attributes\n            final boolean newEventBubbles; {\n                final String newEventBubblesString = actionElement.attributeValue(\"bubbles\");\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                newEventBubbles = Boolean.valueOf((newEventBubblesString == null) ? \"true\" : newEventBubblesString).booleanValue();\n            }\n            final boolean newEventCancelable; {\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                final String newEventCancelableString = actionElement.attributeValue(\"cancelable\");\n                newEventCancelable = Boolean.valueOf((newEventCancelableString == null) ? \"true\" : newEventCancelableString).booleanValue();\n            }\n\n            final Object newTargetObject = containingDocument.getObjectById(pipelineContext, newEventTargetId);\n\n            if (newTargetObject instanceof XFormsEventTarget) {\n                // This can be anything\n                containingDocument.dispatchEvent(pipelineContext, XFormsEventFactory.createEvent(newEventName, (XFormsEventTarget) newTargetObject, newEventBubbles, newEventCancelable));\n            } else {\n                throw new OXFException(\"Invalid event target for id: \" + newEventTargetId);\n            }\n\n        } else {\n            throw new OXFException(\"Invalid action requested: \" + actionEventName);\n        }\n    }","commit_id":"589a6f7c47e1a0914ec5c0b4e4876b4b46b8f4a6","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static XFormsEvent createEvent(String eventName, XFormsEventTarget targetObject, XFormsEventTarget otherTargetObject, boolean allowCustomEvents, boolean bubbles, boolean cancelable,\n                                          String contextString, Element contextElement, Throwable contextThrowable, Element filesElement) {\n\n        // TODO\n        // XFORMS_MODEL_DESTRUCT\n        // XFORMS_RESET\n\n        // TODO: more efficient way to switch!\n\n        if (eventName.equals(XFormsEvents.XFORMS_DOM_ACTIVATE)) {\n            return new XFormsDOMActivateEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_COMPUTE_EXCEPTION)) {\n            return new org.orbeon.oxf.xforms.event.events.XFormsComputeExceptionEvent(targetObject, contextString, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DELETE)) {\n            return new XFormsDeleteEvent(targetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DESELECT)) {\n            return new XFormsDeselectEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_INSERT)) {\n            return new XFormsInsertEvent(targetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_ERROR)) {\n            return new XFormsLinkErrorEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_EXCEPTION)) {\n            return new XFormsLinkExceptionEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REFRESH)) {\n            return new XFormsRefreshEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SELECT)) {\n            return new XFormsSelectEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT_ERROR)) {\n            return new XFormsSubmitErrorEvent(targetObject, contextString, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT)) {\n            return new XFormsSubmitEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT_DONE)) {\n            return new XFormsSubmitDoneEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE)) {\n            return new XXFormsValueChangeWithFocusChangeEvent(targetObject, otherTargetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XXFORMS_SUBMIT)) {\n            return new XXFormsSubmissionEvent(targetObject, filesElement);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_CONSTRUCT)) {\n            return new XFormsModelConstructEvent(targetObject);\n//        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_DESTRUCT)) {\n//            return new XFormsModelDestructEvent(targetObject);\n//        } else if (eventName.equals(XFormsEvents.XFORMS_RESET)) {\n//            return new XFormsResetEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_CONSTRUCT_DONE)) {\n            return new XFormsModelConstructDoneEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READY)) {\n            return new XFormsReadyEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REBUILD)) {\n            return new XFormsRebuildEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_RECALCULATE)) {\n            return new XFormsRecalculateEvent(targetObject, Boolean.getBoolean(contextString));\n        } else if (eventName.equals(XFormsEvents.XFORMS_REVALIDATE)) {\n            return new XFormsRevalidateEvent(targetObject, Boolean.getBoolean(contextString));\n        } else if (eventName.equals(XFormsEvents.XFORMS_VALUE_CHANGED)) {\n            return new XFormsValueChangeEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DOM_FOCUS_OUT)) {\n            return new XFormsDOMFocusOutEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DOM_FOCUS_IN)) {\n            return new XFormsDOMFocusInEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_VALID)) {\n            return new XFormsValidEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_INVALID)) {\n            return new XFormsInvalidEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REQUIRED)) {\n            return new XFormsRequiredEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_OPTIONAL)) {\n            return new XFormsOptionalEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READWRITE)) {\n            return new XFormsReadwriteEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READONLY)) {\n            return new XFormsReadonlyEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_ENABLED)) {\n            return new XFormsEnabledEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DISABLED)) {\n            return new XFormsDisabledEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SCROLL_FIRST)) {\n            return new XFormsScrollFirstEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SCROLL_LAST)) {\n            return new XFormsScrollLastEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_EXCEPTION)) {\n            return new XFormsLinkExceptionEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_ERROR)) {\n            return new XFormsLinkErrorEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (allowCustomEvents) {\n            return new XFormsCustomEvent(eventName, targetObject, bubbles, cancelable);\n        } else {\n            throw new OXFException(\"Event factory could not find event with name: \" + eventName);\n        }\n    }","id":43863,"modified_method":"private static XFormsEvent createEvent(String eventName, XFormsEventTarget targetObject, XFormsEventTarget otherTargetObject, boolean allowCustomEvents, boolean bubbles, boolean cancelable,\n                                          String contextString, Element contextElement, Throwable contextThrowable, Element filesElement) {\n\n        // TODO\n        // XFORMS_MODEL_DESTRUCT\n        // XFORMS_RESET\n\n        // TODO: more efficient way to switch!\n\n        if (eventName.equals(XFormsEvents.XFORMS_DOM_ACTIVATE)) {\n            return new XFormsDOMActivateEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_COMPUTE_EXCEPTION)) {\n            return new org.orbeon.oxf.xforms.event.events.XFormsComputeExceptionEvent(targetObject, contextString, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DELETE)) {\n            return new XFormsDeleteEvent(targetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DESELECT)) {\n            return new XFormsDeselectEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_INSERT)) {\n            return new XFormsInsertEvent(targetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_ERROR)) {\n            return new XFormsLinkErrorEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_EXCEPTION)) {\n            return new XFormsLinkExceptionEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REFRESH)) {\n            return new XFormsRefreshEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SELECT)) {\n            return new XFormsSelectEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT_ERROR)) {\n            return new XFormsSubmitErrorEvent(targetObject, contextString, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT)) {\n            return new XFormsSubmitEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SUBMIT_DONE)) {\n            return new XFormsSubmitDoneEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE)) {\n            return new XXFormsValueChangeWithFocusChangeEvent(targetObject, otherTargetObject, contextString);\n        } else if (eventName.equals(XFormsEvents.XXFORMS_SUBMIT)) {\n            return new XXFormsSubmissionEvent(targetObject, filesElement);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_CONSTRUCT)) {\n            return new XFormsModelConstructEvent(targetObject);\n//        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_DESTRUCT)) {\n//            return new XFormsModelDestructEvent(targetObject);\n//        } else if (eventName.equals(XFormsEvents.XFORMS_RESET)) {\n//            return new XFormsResetEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_MODEL_CONSTRUCT_DONE)) {\n            return new XFormsModelConstructDoneEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READY)) {\n            return new XFormsReadyEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REBUILD)) {\n            return new XFormsRebuildEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_RECALCULATE)) {\n            return new XFormsRecalculateEvent(targetObject, Boolean.valueOf(contextString).booleanValue());\n        } else if (eventName.equals(XFormsEvents.XFORMS_REVALIDATE)) {\n            return new XFormsRevalidateEvent(targetObject, Boolean.valueOf(contextString).booleanValue());\n        } else if (eventName.equals(XFormsEvents.XFORMS_VALUE_CHANGED)) {\n            return new XFormsValueChangeEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DOM_FOCUS_OUT)) {\n            return new XFormsDOMFocusOutEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DOM_FOCUS_IN)) {\n            return new XFormsDOMFocusInEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_VALID)) {\n            return new XFormsValidEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_INVALID)) {\n            return new XFormsInvalidEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_REQUIRED)) {\n            return new XFormsRequiredEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_OPTIONAL)) {\n            return new XFormsOptionalEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READWRITE)) {\n            return new XFormsReadwriteEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_READONLY)) {\n            return new XFormsReadonlyEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_ENABLED)) {\n            return new XFormsEnabledEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_DISABLED)) {\n            return new XFormsDisabledEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SCROLL_FIRST)) {\n            return new XFormsScrollFirstEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_SCROLL_LAST)) {\n            return new XFormsScrollLastEvent(targetObject);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_EXCEPTION)) {\n            return new XFormsLinkExceptionEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (eventName.equals(XFormsEvents.XFORMS_LINK_ERROR)) {\n            return new XFormsLinkErrorEvent(targetObject, contextString, contextElement, contextThrowable);\n        } else if (allowCustomEvents) {\n            return new XFormsCustomEvent(eventName, targetObject, bubbles, cancelable);\n        } else {\n            throw new OXFException(\"Event factory could not find event with name: \" + eventName);\n        }\n    }","commit_id":"589a6f7c47e1a0914ec5c0b4e4876b4b46b8f4a6","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void extractSubmissionElement() {\n        if (!submissionElementExtracted) {\n\n            action = submissionElement.attributeValue(\"action\");\n            method = submissionElement.attributeValue(\"method\");\n            version = submissionElement.attributeValue(\"version\");\n\n            if (submissionElement.attributeValue(\"indent\") != null) {\n                indent = Boolean.getBoolean(submissionElement.attributeValue(\"indent\"));\n            }\n            mediatype = submissionElement.attributeValue(\"mediatype\");\n            encoding = submissionElement.attributeValue(\"encoding\");\n            if (submissionElement.attributeValue(\"omitxmldeclaration\") != null) {\n                omitxmldeclaration = Boolean.getBoolean(submissionElement.attributeValue(\"omit-xml-declaration\"));\n            }\n            if (submissionElement.attributeValue(\"standalone\") != null) {\n                standalone = new Boolean(submissionElement.attributeValue(\"standalone\"));\n            }\n\n            cdatasectionelements = submissionElement.attributeValue(\"cdata-section-elements\");\n            if (submissionElement.attributeValue(\"replace\") != null) {\n                replace = submissionElement.attributeValue(\"replace\");\n            }\n            if (submissionElement.attributeValue(\"separator\") != null) {\n                separator = submissionElement.attributeValue(\"separator\");\n            }\n            includenamespaceprefixes = submissionElement.attributeValue(\"includenamespaceprefixes\");\n\n            submissionElementExtracted = true;\n        }\n    }","id":43864,"modified_method":"private void extractSubmissionElement() {\n        if (!submissionElementExtracted) {\n\n            action = submissionElement.attributeValue(\"action\");\n            method = submissionElement.attributeValue(\"method\");\n            version = submissionElement.attributeValue(\"version\");\n\n            if (submissionElement.attributeValue(\"indent\") != null) {\n                indent = Boolean.valueOf(submissionElement.attributeValue(\"indent\")).booleanValue();\n            }\n            mediatype = submissionElement.attributeValue(\"mediatype\");\n            encoding = submissionElement.attributeValue(\"encoding\");\n            if (submissionElement.attributeValue(\"omitxmldeclaration\") != null) {\n                omitxmldeclaration = Boolean.valueOf(submissionElement.attributeValue(\"omit-xml-declaration\")).booleanValue();\n            }\n            if (submissionElement.attributeValue(\"standalone\") != null) {\n                standalone = new Boolean(submissionElement.attributeValue(\"standalone\"));\n            }\n\n            cdatasectionelements = submissionElement.attributeValue(\"cdata-section-elements\");\n            if (submissionElement.attributeValue(\"replace\") != null) {\n                replace = submissionElement.attributeValue(\"replace\");\n            }\n            if (submissionElement.attributeValue(\"separator\") != null) {\n                separator = submissionElement.attributeValue(\"separator\");\n            }\n            includenamespaceprefixes = submissionElement.attributeValue(\"includenamespaceprefixes\");\n\n            submissionElementExtracted = true;\n        }\n    }","commit_id":"589a6f7c47e1a0914ec5c0b4e4876b4b46b8f4a6","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * The user made changes to the network config and wants to save them, so\n     * lets go ahead and do so.\n     *\n     */\n    private void saveChanges() {\n        boolean restartRequired = false;\n        \n        if ( (_hostname != null) && (_hostname.length() > 0) ) {\n            String oldHost = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_TCP_HOSTNAME);\n            if ( (oldHost == null) || (!oldHost.equalsIgnoreCase(_hostname)) ) {\n                _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_TCP_HOSTNAME, _hostname);\n                addFormNotice(\"Updating hostname from \" + oldHost + \" to \" + _hostname);\n                restartRequired = true;\n            }\n        }\n        if ( (_port != null) && (_port.length() > 0) ) {\n            String oldPort = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_TCP_PORT);\n            if ( (oldPort == null) || (!oldPort.equalsIgnoreCase(_port)) ) {\n                _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_TCP_PORT, _port);\n                addFormNotice(\"Updating TCP port from \" + oldPort + \" to \" + _port);\n                restartRequired = true;\n            }\n        }\n        \n        updateRates();\n        \n        if (_timeSyncEnabled) {\n            _context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"false\");\n        } else {\n            _context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"false\");\n        }\n        \n        boolean saved = _context.router().saveConfig();\n        if (saved) \n            addFormNotice(\"Configuration saved successfully\");\n        else\n            addFormNotice(\"Error saving the configuration (applied but not saved) - please see the error logs\");\n        \n        if (restartRequired) {\n            addFormNotice(\"Performing a soft restart\");\n            _context.router().restart();\n            addFormNotice(\"Soft restart complete\");\n        }\n    }","id":43865,"modified_method":"/**\n     * The user made changes to the network config and wants to save them, so\n     * lets go ahead and do so.\n     *\n     */\n    private void saveChanges() {\n        boolean restartRequired = false;\n        \n        if ( (_hostname != null) && (_hostname.length() > 0) ) {\n            String oldHost = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_TCP_HOSTNAME);\n            if ( (oldHost == null) || (!oldHost.equalsIgnoreCase(_hostname)) ) {\n                _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_TCP_HOSTNAME, _hostname);\n                addFormNotice(\"Updating hostname from \" + oldHost + \" to \" + _hostname);\n                restartRequired = true;\n            }\n        }\n        if ( (_port != null) && (_port.length() > 0) ) {\n            String oldPort = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_TCP_PORT);\n            if ( (oldPort == null) || (!oldPort.equalsIgnoreCase(_port)) ) {\n                _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_TCP_PORT, _port);\n                addFormNotice(\"Updating TCP port from \" + oldPort + \" to \" + _port);\n                restartRequired = true;\n            }\n        }\n        \n        updateRates();\n        \n        if (_timeSyncEnabled) {\n            // Time sync enable, means NOT disabled \n            _context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"false\");\n        } else {\n            _context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"true\");\n        }\n        \n        boolean saved = _context.router().saveConfig();\n        if (saved) \n            addFormNotice(\"Configuration saved successfully\");\n        else\n            addFormNotice(\"Error saving the configuration (applied but not saved) - please see the error logs\");\n        \n        if (restartRequired) {\n            addFormNotice(\"Performing a soft restart\");\n            _context.router().restart();\n            addFormNotice(\"Soft restart complete\");\n        }\n    }","commit_id":"84f8931ddd4f94a7a6a74ef3e5eabbcd9aa00ec7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String getEnableTimeSyncChecked() {\n        String enabled = _context.getProperty(Timestamper.PROP_DISABLED, \"true\");\n        if ( (enabled == null) || (!\"true\".equalsIgnoreCase(enabled)) )\n            return \"\";\n        else\n            return \" checked \";\n    }","id":43866,"modified_method":"public String getEnableTimeSyncChecked() {\n        String disabled = _context.getProperty(Timestamper.PROP_DISABLED, \"false\");\n        if ( (disabled != null) && (\"true\".equalsIgnoreCase(disabled)) )\n            return \"\";\n        else\n            return \" checked \";\n    }","commit_id":"84f8931ddd4f94a7a6a74ef3e5eabbcd9aa00ec7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Reload all the config elements from the appContext\n     *\n     */\n    private void updateConfig() {\n        String serverList = _context.getProperty(PROP_SERVER_LIST);\n        if ( (serverList == null) || (serverList.trim().length() <= 0) )\n            serverList = DEFAULT_SERVER_LIST;\n        synchronized (_servers) {\n            _servers.clear();\n            StringTokenizer tok = new StringTokenizer(serverList, \",\");\n            while (tok.hasMoreTokens()) {\n                String val = (String)tok.nextToken();\n                val = val.trim();\n                if (val.length() > 0)\n                    _servers.add(val);\n            }\n        }\n        \n        String freq = _context.getProperty(PROP_QUERY_FREQUENCY);\n        if ( (freq == null) || (freq.trim().length() <= 0) )\n            freq = DEFAULT_QUERY_FREQUENCY + \"\";\n        try {\n            int ms = Integer.parseInt(freq);\n            if (ms > 60*1000) {\n                _queryFrequency = ms;\n            } else {\n                if ( (_log != null) && (_log.shouldLog(Log.ERROR)) )\n                    _log.error(\"Query frequency once every \" + ms + \"ms is too fast!\");\n                _queryFrequency = DEFAULT_QUERY_FREQUENCY;\n            }\n        } catch (NumberFormatException nfe) {\n            if ( (_log != null) && (_log.shouldLog(Log.WARN)) )\n                _log.warn(\"Invalid query frequency [\" + freq + \"], falling back on \" + DEFAULT_QUERY_FREQUENCY);\n            _queryFrequency = DEFAULT_QUERY_FREQUENCY;\n        }\n        \n        String disabled = _context.getProperty(PROP_DISABLED);\n        if (disabled == null)\n            disabled = DEFAULT_DISABLED + \"\";\n        _disabled = Boolean.getBoolean(disabled);\n    }","id":43867,"modified_method":"/**\n     * Reload all the config elements from the appContext\n     *\n     */\n    private void updateConfig() {\n        String serverList = _context.getProperty(PROP_SERVER_LIST);\n        if ( (serverList == null) || (serverList.trim().length() <= 0) )\n            serverList = DEFAULT_SERVER_LIST;\n        synchronized (_servers) {\n            _servers.clear();\n            StringTokenizer tok = new StringTokenizer(serverList, \",\");\n            while (tok.hasMoreTokens()) {\n                String val = (String)tok.nextToken();\n                val = val.trim();\n                if (val.length() > 0)\n                    _servers.add(val);\n            }\n        }\n        \n        String freq = _context.getProperty(PROP_QUERY_FREQUENCY);\n        if ( (freq == null) || (freq.trim().length() <= 0) )\n            freq = DEFAULT_QUERY_FREQUENCY + \"\";\n        try {\n            int ms = Integer.parseInt(freq);\n            if (ms > 60*1000) {\n                _queryFrequency = ms;\n            } else {\n                if ( (_log != null) && (_log.shouldLog(Log.ERROR)) )\n                    _log.error(\"Query frequency once every \" + ms + \"ms is too fast!\");\n                _queryFrequency = DEFAULT_QUERY_FREQUENCY;\n            }\n        } catch (NumberFormatException nfe) {\n            if ( (_log != null) && (_log.shouldLog(Log.WARN)) )\n                _log.warn(\"Invalid query frequency [\" + freq + \"], falling back on \" + DEFAULT_QUERY_FREQUENCY);\n            _queryFrequency = DEFAULT_QUERY_FREQUENCY;\n        }\n        \n        String disabled = _context.getProperty(PROP_DISABLED);\n        if (disabled == null)\n            disabled = DEFAULT_DISABLED + \"\";\n        _disabled = Boolean.valueOf(disabled).booleanValue();\n    }","commit_id":"84f8931ddd4f94a7a6a74ef3e5eabbcd9aa00ec7","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private double[][] initialXY(DataInfo tinfo, DataInfo dinfo, long na_cnt) {\n      double[][] centers, centers_exp = null;\n      Random rand = RandomUtils.getRNG(_parms._seed);\n\n      if (null != _parms._user_points) { // Set Y = user-specified starting points, X = standard normal matrix\n        Vec[] centersVecs = _parms._user_points.get().vecs();\n        centers = new double[_parms._k][_ncolA];\n\n        // Get the centers and put into array\n        for (int c = 0; c < _ncolA; c++) {\n          for (int r = 0; r < _parms._k; r++)\n            centers[r][c] = centersVecs[c].at(r);\n        }\n\n        // Permute cluster columns to align with dinfo and expand out categoricals\n        centers = ArrayUtils.permuteCols(centers, tinfo._permutation);\n        centers_exp = expandCats(centers, tinfo);\n        initialXGausProj(dinfo);\n        return centers_exp;   // Don't project or change Y in any way if user-specified, just return it\n\n      } else if (_parms._init == Initialization.Random) {  // Generate X and Y from standard normal distribution\n        centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n        initialXGausProj(dinfo);\n\n      } else if (_parms._init == Initialization.SVD) {  // Run SVD on A'A/n (Gram) and set Y = right singular vectors\n        PCAModel.PCAParameters parms = new PCAModel.PCAParameters();\n        parms._train = _parms._train;\n        parms._ignored_columns = _parms._ignored_columns;\n        parms._ignore_const_cols = _parms._ignore_const_cols;\n        parms._score_each_iteration = _parms._score_each_iteration;\n        parms._use_all_factor_levels = true;   // Since GLRM requires Y matrix to have fully expanded ncols\n        parms._k = _parms._k;\n        parms._max_iterations = _parms._max_iterations;\n        parms._transform = _parms._transform;\n        parms._seed = _parms._seed;\n        parms._pca_method = PCAModel.PCAParameters.Method.GramSVD;\n        parms._impute_missing = true;\n\n        PCAModel pca = null;\n        PCA job = null;\n        try {\n          job = new PCA(parms);\n          pca = job.trainModel().get();\n        } finally {\n          if (job != null) job.remove();\n          if (pca != null) pca.remove();\n        }\n\n        // Ensure SVD centers align with adapted training frame cols\n        assert pca._output._permutation.length == tinfo._permutation.length;\n        for(int i = 0; i < tinfo._permutation.length; i++)\n          assert pca._output._permutation[i] == tinfo._permutation[i];\n        centers_exp = ArrayUtils.transpose(pca._output._eigenvectors_raw);\n        // for(int i = 0; i < centers_exp.length; i++)\n        //  ArrayUtils.mult(centers_exp[i], pca._output._std_deviation[i] * Math.sqrt(pca._output._nobs-1));\n        initialXGausProj(dinfo);  // TODO: We want X = UD when Y = V' from SVD A = UDV'\n\n      } else if (_parms._init == Initialization.PlusPlus) {  // Run k-means++ and set Y = resulting cluster centers, X = indicator matrix of assignments\n        KMeansModel.KMeansParameters parms = new KMeansModel.KMeansParameters();\n        parms._train = _parms._train;\n        parms._ignored_columns = _parms._ignored_columns;\n        parms._ignore_const_cols = _parms._ignore_const_cols;\n        parms._score_each_iteration = _parms._score_each_iteration;\n        parms._init = KMeans.Initialization.PlusPlus;\n        parms._k = _parms._k;\n        parms._max_iterations = _parms._max_iterations;\n        parms._standardize = true;\n        parms._seed = _parms._seed;\n        parms._pred_indicator = true;\n\n        KMeansModel km = null;\n        KMeans job = null;\n        try {\n          job = new KMeans(parms);\n          km = job.trainModel().get();\n\n          // Score only if clusters well-defined and closed-form solution does not exist\n          double frob = frobenius2(km._output._centers_raw);\n          if(frob != 0 && !Double.isNaN(frob) && na_cnt == 0 && !_parms.hasClosedForm())\n            initialXKmeans(dinfo, km);\n        } finally {\n          if (job != null) job.remove();\n          if (km != null) km.remove();\n        }\n\n        // Permute cluster columns to align with dinfo, normalize nums, and expand out cats to indicator cols\n        centers = ArrayUtils.permuteCols(km._output._centers_raw, tinfo.mapNames(km._output._names));\n        centers = transform(centers, tinfo._normSub, tinfo._normMul, tinfo._cats, tinfo._nums);\n        centers_exp = expandCats(centers, tinfo);\n      } else\n        error(\"_init\", \"Initialization method \" + _parms._init + \" is undefined\");\n\n      // If all centers are zero or any are NaN, initialize to standard Gaussian random matrix\n      assert centers_exp != null && centers_exp.length == _parms._k && centers_exp[0].length == _ncolY : \"Y must have \" + _parms._k + \" rows and \" + _ncolY + \" columns\";\n      double frob = frobenius2(centers_exp);   // TODO: Don't need to calculate twice if k-means++\n      if(frob == 0 || Double.isNaN(frob)) {\n        warn(\"_init\", \"Initialization failed. Setting initial Y to standard normal random matrix instead\");\n        centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n      }\n\n      // Project rows of Y into appropriate subspace for regularizer\n      for(int i = 0; i < _parms._k; i++)\n        centers_exp[i] = _parms.project_y(centers_exp[i], rand);\n      return centers_exp;\n    }","id":43868,"modified_method":"private double[][] initialXY(DataInfo tinfo, Frame dfrm, long na_cnt) {\n      double[][] centers, centers_exp = null;\n      Random rand = RandomUtils.getRNG(_parms._seed);\n\n      if (null != _parms._user_points) { // Set Y = user-specified starting points, X = standard normal matrix\n        Vec[] centersVecs = _parms._user_points.get().vecs();\n        centers = new double[_parms._k][_ncolA];\n\n        // Get the centers and put into array\n        for (int c = 0; c < _ncolA; c++) {\n          for (int r = 0; r < _parms._k; r++)\n            centers[r][c] = centersVecs[c].at(r);\n        }\n\n        // Permute cluster columns to align with dinfo and expand out categoricals\n        centers = ArrayUtils.permuteCols(centers, tinfo._permutation);\n        centers_exp = expandCats(centers, tinfo);\n        initialXGausProj(dfrm, _ncolA, _ncolX);\n        return centers_exp;   // Don't project or change Y in any way if user-specified, just return it\n\n      } else if (_parms._init == Initialization.Random) {  // Generate X and Y from standard normal distribution\n        centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n        initialXGausProj(dfrm, _ncolA, _ncolX);\n\n      } else if (_parms._init == Initialization.SVD) {  // Run SVD on A'A/n (Gram) and set Y = right singular vectors\n        PCAModel.PCAParameters parms = new PCAModel.PCAParameters();\n        parms._train = _parms._train;\n        parms._ignored_columns = _parms._ignored_columns;\n        parms._ignore_const_cols = _parms._ignore_const_cols;\n        parms._score_each_iteration = _parms._score_each_iteration;\n        parms._use_all_factor_levels = true;   // Since GLRM requires Y matrix to have fully expanded ncols\n        parms._k = _parms._k;\n        parms._max_iterations = _parms._max_iterations;\n        parms._transform = _parms._transform;\n        parms._seed = _parms._seed;\n        parms._pca_method = PCAModel.PCAParameters.Method.GramSVD;\n        parms._impute_missing = true;\n\n        PCAModel pca = null;\n        PCA job = null;\n        try {\n          job = new PCA(parms);\n          pca = job.trainModel().get();\n        } finally {\n          if (job != null) job.remove();\n          if (pca != null) pca.remove();\n        }\n\n        // Ensure SVD centers align with adapted training frame cols\n        assert pca._output._permutation.length == tinfo._permutation.length;\n        for(int i = 0; i < tinfo._permutation.length; i++)\n          assert pca._output._permutation[i] == tinfo._permutation[i];\n        centers_exp = ArrayUtils.transpose(pca._output._eigenvectors_raw);\n        // for(int i = 0; i < centers_exp.length; i++)\n        //  ArrayUtils.mult(centers_exp[i], pca._output._std_deviation[i] * Math.sqrt(pca._output._nobs-1));\n        initialXGausProj(dfrm, _ncolA, _ncolX);  // TODO: We want X = UD when Y = V' from SVD A = UDV'\n\n      } else if (_parms._init == Initialization.PlusPlus) {  // Run k-means++ and set Y = resulting cluster centers, X = indicator matrix of assignments\n        KMeansModel.KMeansParameters parms = new KMeansModel.KMeansParameters();\n        parms._train = _parms._train;\n        parms._ignored_columns = _parms._ignored_columns;\n        parms._ignore_const_cols = _parms._ignore_const_cols;\n        parms._score_each_iteration = _parms._score_each_iteration;\n        parms._init = KMeans.Initialization.PlusPlus;\n        parms._k = _parms._k;\n        parms._max_iterations = _parms._max_iterations;\n        parms._standardize = true;\n        parms._seed = _parms._seed;\n        parms._pred_indicator = true;\n\n        KMeansModel km = null;\n        KMeans job = null;\n        try {\n          job = new KMeans(parms);\n          km = job.trainModel().get();\n\n          // Score only if clusters well-defined and closed-form solution does not exist\n          double frob = frobenius2(km._output._centers_raw);\n          if(frob != 0 && !Double.isNaN(frob) && na_cnt == 0 && !_parms.hasClosedForm())\n            initialXKmeans(dfrm, km, _ncolA, _ncolX);\n        } finally {\n          if (job != null) job.remove();\n          if (km != null) km.remove();\n        }\n\n        // Permute cluster columns to align with dinfo, normalize nums, and expand out cats to indicator cols\n        centers = ArrayUtils.permuteCols(km._output._centers_raw, tinfo.mapNames(km._output._names));\n        centers = transform(centers, tinfo._normSub, tinfo._normMul, tinfo._cats, tinfo._nums);\n        centers_exp = expandCats(centers, tinfo);\n      } else\n        error(\"_init\", \"Initialization method \" + _parms._init + \" is undefined\");\n\n      // If all centers are zero or any are NaN, initialize to standard Gaussian random matrix\n      assert centers_exp != null && centers_exp.length == _parms._k && centers_exp[0].length == _ncolY : \"Y must have \" + _parms._k + \" rows and \" + _ncolY + \" columns\";\n      double frob = frobenius2(centers_exp);   // TODO: Don't need to calculate twice if k-means++\n      if(frob == 0 || Double.isNaN(frob)) {\n        warn(\"_init\", \"Initialization failed. Setting initial Y to standard normal random matrix instead\");\n        centers_exp = ArrayUtils.gaussianArray(_parms._k, _ncolY);\n      }\n\n      // Project rows of Y into appropriate subspace for regularizer\n      for(int i = 0; i < _parms._k; i++)\n        centers_exp[i] = _parms.project_y(centers_exp[i], rand);\n      return centers_exp;\n    }","commit_id":"70048180db64db52683c7f314ca4d4431d2d3dda","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override protected void compute2() {\n      GLRMModel model = null;\n      DataInfo dinfo = null, xinfo = null, tinfo = null;\n      Frame fr = null, x = null;\n      boolean overwriteX = false;\n\n      try {\n        init(true);   // Initialize parameters\n        _parms.read_lock_frames(GLRM.this); // Fetch & read-lock input frames\n        if (error_count() > 0) throw new IllegalArgumentException(\"Found validation errors: \" + validationErrors());\n\n        // The model to be built\n        model = new GLRMModel(dest(), _parms, new GLRMModel.GLRMOutput(GLRM.this));\n        model.delete_and_lock(self());\n\n        // Save adapted frame info for scoring later\n        tinfo = new DataInfo(Key.make(), _train, _valid, 0, true, _parms._transform, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(tinfo._key, tinfo);\n\n        // Save training frame adaptation information for use in scoring later\n        model._output._normSub = tinfo._normSub == null ? new double[tinfo._nums] : tinfo._normSub;\n        if(tinfo._normMul == null) {\n          model._output._normMul = new double[tinfo._nums];\n          Arrays.fill(model._output._normMul, 1.0);\n        } else\n          model._output._normMul = tinfo._normMul;\n        model._output._permutation = tinfo._permutation;\n        model._output._nnums = tinfo._nums;\n        model._output._ncats = tinfo._cats;\n        model._output._catOffsets = tinfo._catOffsets;\n        model._output._names_expanded = tinfo.coefNames();\n\n        long nobs = _train.numRows() * _train.numCols();\n        long na_cnt = 0;\n        for(int i = 0; i < _train.numCols(); i++)\n          na_cnt += _train.vec(i).naCnt();\n        model._output._nobs = nobs - na_cnt;   // TODO: Should we count NAs?\n\n        // 0) Initialize Y and X matrices\n        // Jam A and X into a single frame for distributed computation\n        // [A,X,W] A is read-only training data, X is matrix from prior iteration, W is working copy of X this iteration\n        Vec[] vecs = new Vec[_ncolA + 2*_ncolX];\n        for (int i = 0; i < _ncolA; i++) vecs[i] = _train.vec(i);\n        for (int i = _ncolA; i < vecs.length; i++)\n          vecs[i] = _train.anyVec().makeZero();\n        fr = new Frame(null, vecs);\n        dinfo = new DataInfo(Key.make(), fr, null, 0, true, _parms._transform, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(dinfo._key, dinfo);\n\n        int weightId = dinfo._weights ? dinfo.weightChunkId() : -1;\n        int[] numLevels = dinfo._adaptedFrame.numLevels();\n\n        // Use closed form solution for X if L2 loss and regularization\n        double[][] yinit = initialXY(tinfo, dinfo, na_cnt);\n        Archetypes yt = new Archetypes(ArrayUtils.transpose(yinit), true, dinfo._catOffsets, numLevels);\n        if (na_cnt == 0 && _parms.hasClosedForm())\n          initialXClosedForm(dinfo, yt, model._output._normSub, model._output._normMul);\n\n        // Compute initial objective function\n        ObjCalc objtsk = new ObjCalc(_parms, yt, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, weightId, _parms._gamma_x != 0).doAll(dinfo._adaptedFrame);\n        model._output._objective = objtsk._loss + _parms._gamma_x * objtsk._xold_reg + _parms._gamma_y * _parms.regularize_y(yt._archetypes);\n        model._output._iterations = 0;\n        model._output._avg_change_obj = 2 * TOLERANCE;    // Run at least 1 iteration\n        model.update(_key);  // Update model in K/V store\n        update(1);           // One unit of work\n\n        double step = _parms._init_step_size;   // Initial step size\n        int steps_in_row = 0;                   // Keep track of number of steps taken that decrease objective\n\n        while (!isDone(model, steps_in_row, step)) {\n          // TODO: Should step be divided by number of original or expanded (with 0/1 categorical) cols?\n          // 1) Update X matrix given fixed Y\n          UpdateX xtsk = new UpdateX(_parms, yt, step/_ncolA, overwriteX, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, weightId);\n          xtsk.doAll(dinfo._adaptedFrame);\n          \n          // 2) Update Y matrix given fixed X\n          UpdateY ytsk = new UpdateY(_parms, yt, step/_ncolA, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, weightId);\n          double[][] yttmp = ytsk.doAll(dinfo._adaptedFrame)._ytnew;\n          Archetypes ytnew = new Archetypes(yttmp, true, dinfo._catOffsets, numLevels);\n\n          // 3) Compute average change in objective function\n          objtsk = new ObjCalc(_parms, ytnew, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, weightId).doAll(dinfo._adaptedFrame);\n          double obj_new = objtsk._loss + _parms._gamma_x * xtsk._xreg + _parms._gamma_y * ytsk._yreg;\n          model._output._avg_change_obj = (model._output._objective - obj_new) / nobs;\n          model._output._iterations++;\n\n          // step = 1.0 / model._output._iterations;   // Step size \\alpha_k = 1/iters\n          if(model._output._avg_change_obj > 0) {   // Objective decreased this iteration\n            yt = ytnew;\n            model._output._archetypes = yt._archetypes;\n            model._output._objective = obj_new;\n            step *= 1.05;\n            steps_in_row = Math.max(1, steps_in_row+1);\n            overwriteX = true;\n          } else {    // If objective increased, re-run with smaller step size\n            step = step / Math.max(1.5, -steps_in_row);\n            steps_in_row = Math.min(0, steps_in_row-1);\n            overwriteX = false;\n            Log.info(\"Iteration \" + model._output._iterations + \": Objective increased to \" + obj_new + \"; reducing step size to \" + step);\n          }\n          model._output._step_size = step;\n          model.update(self()); // Update model in K/V store\n          update(1);            // One unit of work\n        }\n\n        // 4) Save solution to model output\n        // Save X frame for user reference later\n        Vec[] xvecs = new Vec[_ncolX];\n        if(overwriteX) {\n          for (int i = 0; i < _ncolX; i++) xvecs[i] = fr.vec(idx_xnew(i, _ncolA, _ncolX));\n        } else {\n          for (int i = 0; i < _ncolX; i++) xvecs[i] = fr.vec(idx_xold(i, _ncolA));\n        }\n        x = new Frame(_parms._loading_key, null, xvecs);\n        xinfo = new DataInfo(Key.make(), x, null, 0, true, DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(x._key, x);\n        DKV.put(xinfo._key, xinfo);\n        model._output._step_size = step;\n        model._output._loading_key = _parms._loading_key;\n        model._output._archetypes_full = yt;  // Need full archetypes object for scoring\n        model._output._archetypes = yt._archetypes;\n        if (_parms._recover_svd) recoverSVD(model, xinfo);\n\n        model.update(self());\n        done();\n      } catch (Throwable t) {\n        Job thisJob = DKV.getGet(_key);\n        if (thisJob._state == JobState.CANCELLED) {\n          Log.info(\"Job cancelled by user.\");\n        } else {\n          t.printStackTrace();\n          failed(t);\n          throw t;\n        }\n      } finally {\n        updateModelOutput();\n        _parms.read_unlock_frames(GLRM.this);\n        if (model != null) model.unlock(_key);\n        if (tinfo != null) tinfo.remove();\n        if (dinfo != null) dinfo.remove();\n        if (xinfo != null) xinfo.remove();\n\n        // if (x != null && !_parms._keep_loading) x.delete();\n        // Clean up unused copy of X matrix\n        if (fr != null) {\n          if(overwriteX) {\n            for (int i = 0; i < _ncolX; i++) fr.vec(idx_xold(i, _ncolA)).remove();\n          } else {\n            for (int i = 0; i < _ncolX; i++) fr.vec(idx_xnew(i, _ncolA, _ncolX)).remove();\n          }\n        }\n      }\n      tryComplete();\n    }","id":43869,"modified_method":"@Override protected void compute2() {\n      GLRMModel model = null;\n      DataInfo dinfo = null, xinfo = null, tinfo = null;\n      Frame fr = null, x = null;\n      boolean overwriteX = false;\n\n      try {\n        init(true);   // Initialize parameters\n        _parms.read_lock_frames(GLRM.this); // Fetch & read-lock input frames\n        if (error_count() > 0) throw new IllegalArgumentException(\"Found validation errors: \" + validationErrors());\n\n        // The model to be built\n        model = new GLRMModel(dest(), _parms, new GLRMModel.GLRMOutput(GLRM.this));\n        model.delete_and_lock(self());\n\n        // Save adapted frame info for scoring later\n        tinfo = new DataInfo(Key.make(), _train, _valid, 0, true, _parms._transform, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(tinfo._key, tinfo);\n\n        // Save training frame adaptation information for use in scoring later\n        model._output._normSub = tinfo._normSub == null ? new double[tinfo._nums] : tinfo._normSub;\n        if(tinfo._normMul == null) {\n          model._output._normMul = new double[tinfo._nums];\n          Arrays.fill(model._output._normMul, 1.0);\n        } else\n          model._output._normMul = tinfo._normMul;\n        model._output._permutation = tinfo._permutation;\n        model._output._nnums = tinfo._nums;\n        model._output._ncats = tinfo._cats;\n        model._output._catOffsets = tinfo._catOffsets;\n        model._output._names_expanded = tinfo.coefNames();\n\n        long nobs = _train.numRows() * _train.numCols();\n        long na_cnt = 0;\n        for(int i = 0; i < _train.numCols(); i++)\n          na_cnt += _train.vec(i).naCnt();\n        model._output._nobs = nobs - na_cnt;   // TODO: Should we count NAs?\n\n        // 0) Initialize Y and X matrices\n        // Jam A and X into a single frame for distributed computation\n        // [A,X,W] A is read-only training data, X is matrix from prior iteration, W is working copy of X this iteration\n        fr = new Frame(_train);\n        for (int i = 0; i < _ncolX; i++) fr.add(\"xcol_\" + i, fr.anyVec().makeZero());\n        for (int i = 0; i < _ncolX; i++) fr.add(\"wcol_\" + i, fr.anyVec().makeZero());\n        dinfo = new DataInfo(Key.make(), fr, null, 0, true, _parms._transform, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(dinfo._key, dinfo);\n\n        int weightId = dinfo._weights ? dinfo.weightChunkId() : -1;\n        int[] numLevels = tinfo._adaptedFrame.numLevels();\n\n        // Use closed form solution for X if L2 loss and regularization\n        double[][] yinit = initialXY(tinfo, dinfo._adaptedFrame, na_cnt);\n        Archetypes yt = new Archetypes(ArrayUtils.transpose(yinit), true, tinfo._catOffsets, numLevels);\n        if (na_cnt == 0 && _parms.hasClosedForm())\n          initialXClosedForm(dinfo, yt, model._output._normSub, model._output._normMul);\n\n        // Compute initial objective function\n        ObjCalc objtsk = new ObjCalc(_parms, yt, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, weightId, _parms._gamma_x != 0).doAll(dinfo._adaptedFrame);\n        model._output._objective = objtsk._loss + _parms._gamma_x * objtsk._xold_reg + _parms._gamma_y * _parms.regularize_y(yt._archetypes);\n        model._output._iterations = 0;\n        model._output._avg_change_obj = 2 * TOLERANCE;    // Run at least 1 iteration\n        model.update(_key);  // Update model in K/V store\n        update(1);           // One unit of work\n\n        double step = _parms._init_step_size;   // Initial step size\n        int steps_in_row = 0;                   // Keep track of number of steps taken that decrease objective\n\n        while (!isDone(model, steps_in_row, step)) {\n          // TODO: Should step be divided by number of original or expanded (with 0/1 categorical) cols?\n          // 1) Update X matrix given fixed Y\n          UpdateX xtsk = new UpdateX(_parms, yt, step/_ncolA, overwriteX, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, weightId);\n          xtsk.doAll(dinfo._adaptedFrame);\n          \n          // 2) Update Y matrix given fixed X\n          UpdateY ytsk = new UpdateY(_parms, yt, step/_ncolA, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, weightId);\n          double[][] yttmp = ytsk.doAll(dinfo._adaptedFrame)._ytnew;\n          Archetypes ytnew = new Archetypes(yttmp, true, dinfo._catOffsets, numLevels);\n\n          // 3) Compute average change in objective function\n          objtsk = new ObjCalc(_parms, ytnew, _ncolA, _ncolX, dinfo._cats, model._output._normSub, model._output._normMul, weightId).doAll(dinfo._adaptedFrame);\n          double obj_new = objtsk._loss + _parms._gamma_x * xtsk._xreg + _parms._gamma_y * ytsk._yreg;\n          model._output._avg_change_obj = (model._output._objective - obj_new) / nobs;\n          model._output._iterations++;\n\n          // step = 1.0 / model._output._iterations;   // Step size \\alpha_k = 1/iters\n          if(model._output._avg_change_obj > 0) {   // Objective decreased this iteration\n            yt = ytnew;\n            model._output._archetypes = yt._archetypes;\n            model._output._objective = obj_new;\n            step *= 1.05;\n            steps_in_row = Math.max(1, steps_in_row+1);\n            overwriteX = true;\n          } else {    // If objective increased, re-run with smaller step size\n            step = step / Math.max(1.5, -steps_in_row);\n            steps_in_row = Math.min(0, steps_in_row-1);\n            overwriteX = false;\n            Log.info(\"Iteration \" + model._output._iterations + \": Objective increased to \" + obj_new + \"; reducing step size to \" + step);\n          }\n          model._output._step_size = step;\n          model.update(self()); // Update model in K/V store\n          update(1);            // One unit of work\n        }\n\n        // 4) Save solution to model output\n        // Save X frame for user reference later\n        Vec[] xvecs = new Vec[_ncolX];\n        if(overwriteX) {\n          for (int i = 0; i < _ncolX; i++) xvecs[i] = fr.vec(idx_xnew(i, _ncolA, _ncolX));\n        } else {\n          for (int i = 0; i < _ncolX; i++) xvecs[i] = fr.vec(idx_xold(i, _ncolA));\n        }\n        x = new Frame(_parms._loading_key, null, xvecs);\n        xinfo = new DataInfo(Key.make(), x, null, 0, true, DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, false, false, false, /* weights */ false, /* offset */ false, /* fold */ false);\n        DKV.put(x._key, x);\n        DKV.put(xinfo._key, xinfo);\n        model._output._step_size = step;\n        model._output._loading_key = _parms._loading_key;\n        model._output._archetypes_full = yt;  // Need full archetypes object for scoring\n        model._output._archetypes = yt._archetypes;\n        if (_parms._recover_svd) recoverSVD(model, xinfo);\n\n        model.update(self());\n        done();\n      } catch (Throwable t) {\n        Job thisJob = DKV.getGet(_key);\n        if (thisJob._state == JobState.CANCELLED) {\n          Log.info(\"Job cancelled by user.\");\n        } else {\n          t.printStackTrace();\n          failed(t);\n          throw t;\n        }\n      } finally {\n        updateModelOutput();\n        _parms.read_unlock_frames(GLRM.this);\n        if (model != null) model.unlock(_key);\n        if (tinfo != null) tinfo.remove();\n        if (dinfo != null) dinfo.remove();\n        if (xinfo != null) xinfo.remove();\n\n        // if (x != null && !_parms._keep_loading) x.delete();\n        // Clean up unused copy of X matrix\n        if (fr != null) {\n          if(overwriteX) {\n            for (int i = 0; i < _ncolX; i++) fr.vec(idx_xold(i, _ncolA)).remove();\n          } else {\n            for (int i = 0; i < _ncolX; i++) fr.vec(idx_xnew(i, _ncolA, _ncolX)).remove();\n          }\n        }\n      }\n      tryComplete();\n    }","commit_id":"70048180db64db52683c7f314ca4d4431d2d3dda","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void initialXKmeans(DataInfo dinfo, KMeansModel km) {\n      // Frame pred = km.score(_parms.train());\n      Log.info(\"Initializing X to matrix of indicator columns corresponding to cluster assignments\");\n      final KMeansModel model = km;\n      new MRTask() {\n        @Override public void map( Chunk chks[] ) {\n          double tmp [] = new double[_ncolA];\n          double preds[] = new double[_ncolX];\n          Random rand = RandomUtils.getRNG(_parms._seed + chks[0].start());\n\n          for(int row = 0; row < chks[0]._len; row++) {\n            double p[] = model.score_indicator(chks, row, tmp, preds);\n            p = _parms.project_x(p, rand);  // TODO: Should we restrict indicator cols to regularizer subspace?\n            for(int c = 0; c < preds.length; c++) {\n              chks[_ncolA+c].set(row, p[c]);\n              chks[_ncolA+_ncolX+c].set(row, p[c]);\n            }\n          }\n        }\n      }.doAll(dinfo._adaptedFrame);\n    }","id":43870,"modified_method":"private void initialXKmeans(Frame fr, KMeansModel km, final int ncolA, final int ncolX) {\n      // Frame pred = km.score(_parms.train());\n      Log.info(\"Initializing X to matrix of indicator columns corresponding to cluster assignments\");\n      final KMeansModel model = km;\n      new MRTask() {\n        @Override public void map( Chunk chks[] ) {\n          double tmp [] = new double[ncolA];\n          double preds[] = new double[ncolX];\n          Random rand = RandomUtils.getRNG(_parms._seed + chks[0].start());\n\n          for(int row = 0; row < chks[0]._len; row++) {\n            double p[] = model.score_indicator(chks, row, tmp, preds);\n            p = _parms.project_x(p, rand);  // TODO: Should we restrict indicator cols to regularizer subspace?\n            for(int c = 0; c < preds.length; c++) {\n              chks[ncolA+c].set(row, p[c]);\n              chks[ncolA+ncolX+c].set(row, p[c]);\n            }\n          }\n        }\n      }.doAll(fr);\n    }","commit_id":"70048180db64db52683c7f314ca4d4431d2d3dda","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void initialXGausProj(DataInfo dinfo) {\n      new MRTask() {\n        @Override public void map( Chunk chks[] ) {\n          Random rand = RandomUtils.getRNG(_parms._seed + chks[0].start());\n\n          for(int row = 0; row < chks[0]._len; row++) {\n            double[] xrow = ArrayUtils.gaussianVector(_ncolX, _parms._seed);\n            xrow = _parms.project_x(xrow, rand);\n            for(int c = 0; c < xrow.length; c++) {\n              chks[_ncolA+c].set(row, xrow[c]);\n              chks[_ncolA+_ncolX+c].set(row, xrow[c]);\n            }\n          }\n        }\n      }.doAll(dinfo._adaptedFrame);\n    }","id":43871,"modified_method":"private void initialXGausProj(Frame fr, final int ncolA, final int ncolX) {\n      new MRTask() {\n        @Override public void map( Chunk chks[] ) {\n          Random rand = RandomUtils.getRNG(_parms._seed + chks[0].start());\n\n          for(int row = 0; row < chks[0]._len; row++) {\n            double xrow[] = ArrayUtils.gaussianVector(ncolX, _parms._seed);\n            xrow = _parms.project_x(xrow, rand);\n            for(int c = 0; c < xrow.length; c++) {\n              chks[ncolA+c].set(row, xrow[c]);\n              chks[ncolA+ncolX+c].set(row, xrow[c]);\n            }\n          }\n        }\n      }.doAll(fr);\n    }","commit_id":"70048180db64db52683c7f314ca4d4431d2d3dda","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@BeforeClass public static void setup() { stall_till_cloudsize(1); }","id":43872,"modified_method":"@BeforeClass public static void setup() { stall_till_cloudsize(2); }","commit_id":"70048180db64db52683c7f314ca4d4431d2d3dda","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** {@inheritDoc} */\n    @Override public void writeExternal(ObjectOutput out) throws IOException {\n        synchronized (cfg) {\n            cfg.write(out);\n        }\n    }","id":43873,"modified_method":"/** {@inheritDoc} */\n    @Override public void writeExternal(ObjectOutput out) throws IOException {\n        cfg.write(out);\n    }","commit_id":"2de6bba345b895b68dfe4c27fd1fa98d137223e7","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void run(GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2Job jobImpl = (GridHadoopV2Job) taskCtx.job();\n\n        JobContext jobCtx = jobImpl.hadoopJobContext();\n\n        try {\n            OutputCommitter commiter = jobCtx.getJobConf().getOutputCommitter();\n\n            if (abort)\n                commiter.abortJob(jobCtx, JobStatus.State.FAILED);\n            else\n                commiter.commitJob(jobCtx);\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","id":43874,"modified_method":"/** {@inheritDoc} */\n    @Override public void run(GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2Job jobImpl = (GridHadoopV2Job) taskCtx.job();\n\n        JobContext jobCtx = jobImpl.hadoopJobContext();\n\n        try {\n            OutputCommitter committer = jobCtx.getJobConf().getOutputCommitter();\n\n            if (abort)\n                committer.abortJob(jobCtx, JobStatus.State.FAILED);\n            else\n                committer.commitJob(jobCtx);\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"2de6bba345b895b68dfe4c27fd1fa98d137223e7","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void run(final GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2Job jobImpl = (GridHadoopV2Job) taskCtx.job();\n\n        JobConf jobConf = jobImpl.hadoopJobContext().getJobConf();\n\n        Reducer combiner = U.newInstance(jobConf.getCombinerClass());\n\n        combiner.configure(jobConf);\n\n        GridHadoopTaskInput input = taskCtx.input();\n\n        Reporter reporter = Reporter.NULL;\n\n        OutputCollector collector = new OutputCollector() {\n            @Override public void collect(Object key, Object val) throws IOException {\n                try {\n                    taskCtx.output().write(key, val);\n                }\n                catch (GridException e) {\n                    throw new IOException(e);\n                }\n            }\n        };\n\n        try {\n            while (input.next())\n                combiner.reduce(input.key(), input.values(), collector, reporter);\n\n            combiner.close();\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","id":43875,"modified_method":"/** {@inheritDoc} */\n    @Override public void run(final GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2Job jobImpl = (GridHadoopV2Job) taskCtx.job();\n\n        JobConf jobConf = new JobConf(jobImpl.hadoopJobContext().getJobConf());\n\n        Reducer combiner = U.newInstance(jobConf.getCombinerClass());\n\n        combiner.configure(jobConf);\n\n        GridHadoopTaskInput input = taskCtx.input();\n\n        Reporter reporter = Reporter.NULL;\n\n        OutputCollector collector = new OutputCollector() {\n            @Override public void collect(Object key, Object val) throws IOException {\n                try {\n                    taskCtx.output().write(key, val);\n                }\n                catch (GridException e) {\n                    throw new IOException(e);\n                }\n            }\n        };\n\n        try {\n            while (input.next())\n                combiner.reduce(input.key(), input.values(), collector, reporter);\n\n            combiner.close();\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"2de6bba345b895b68dfe4c27fd1fa98d137223e7","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void run(final GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2Job jobImpl = (GridHadoopV2Job) taskCtx.job();\n\n        JobConf jobConf = jobImpl.hadoopJobContext().getJobConf();\n\n        Mapper mapper = U.newInstance(jobConf.getMapperClass());\n\n        InputFormat inFormat = jobConf.getInputFormat();\n\n        GridHadoopFileBlock block = info().fileBlock();\n\n        InputSplit split = new FileSplit(new Path(block.file().toString()), block.start(), block.length(), block.hosts());\n\n        OutputCollector collector = new OutputCollector() {\n            @Override public void collect(Object key, Object val) throws IOException {\n                try {\n                    taskCtx.output().write(key, val);\n                }\n                catch (GridException e) {\n                    throw new IOException(e);\n                }\n            }\n        };\n\n        Reporter reporter = Reporter.NULL;\n\n        try {\n            RecordReader reader = inFormat.getRecordReader(split, jobConf, reporter);\n\n            Object key = reader.createKey();\n            Object val = reader.createValue();\n\n            mapper.configure(jobConf);\n\n            while (reader.next(key, val))\n                mapper.map(key, val, collector, reporter);\n\n            mapper.close();\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","id":43876,"modified_method":"/** {@inheritDoc} */\n    @Override public void run(final GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2Job jobImpl = (GridHadoopV2Job) taskCtx.job();\n\n        JobConf jobConf = new JobConf(jobImpl.hadoopJobContext().getJobConf());\n\n        Mapper mapper = U.newInstance(jobConf.getMapperClass());\n\n        InputFormat inFormat = jobConf.getInputFormat();\n\n        GridHadoopFileBlock block = info().fileBlock();\n\n        InputSplit split = new FileSplit(new Path(block.file().toString()), block.start(), block.length(), block.hosts());\n\n        OutputCollector collector = new OutputCollector() {\n            @Override public void collect(Object key, Object val) throws IOException {\n                try {\n                    taskCtx.output().write(key, val);\n                }\n                catch (GridException e) {\n                    throw new IOException(e);\n                }\n            }\n        };\n\n        Reporter reporter = Reporter.NULL;\n\n        try {\n            RecordReader reader = inFormat.getRecordReader(split, jobConf, reporter);\n\n            Object key = reader.createKey();\n            Object val = reader.createValue();\n\n            mapper.configure(jobConf);\n\n            while (reader.next(key, val))\n                mapper.map(key, val, collector, reporter);\n\n            mapper.close();\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"2de6bba345b895b68dfe4c27fd1fa98d137223e7","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void run(GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2Job jobImpl = (GridHadoopV2Job) taskCtx.job();\n\n        JobConf jobConf = jobImpl.hadoopJobContext().getJobConf();\n\n        Reducer reducer = U.newInstance(jobConf.getReducerClass());\n\n        OutputFormat outFormat = jobConf.getOutputFormat();\n\n        Reporter reporter = Reporter.NULL;\n\n        NumberFormat numFormat = NumberFormat.getInstance();\n\n        numFormat.setMinimumIntegerDigits(5);\n        numFormat.setGroupingUsed(false);\n\n        String fileName = \"part-\" + numFormat.format(info().taskNumber());\n\n        reducer.configure(jobConf);\n\n        GridHadoopTaskInput input = taskCtx.input();\n\n        TaskAttemptID attempt = jobImpl.attemptId(info());\n\n        jobConf.set(\"mapreduce.task.attempt.id\", attempt.toString());\n\n        try {\n            final RecordWriter writer = outFormat.getRecordWriter(null, jobConf, fileName, reporter);\n\n            OutputCollector collector = new OutputCollector() {\n                @Override public void collect(Object key, Object val) throws IOException {\n                    writer.write(key, val);\n                }\n            };\n\n            try {\n                while (input.next())\n                    reducer.reduce(input.key(), input.values(), collector, reporter);\n\n                reducer.close();\n            }\n            finally {\n                writer.close(reporter);\n            }\n\n            OutputCommitter commiter = jobConf.getOutputCommitter();\n\n            commiter.commitTask(new TaskAttemptContextImpl(jobConf, attempt));\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","id":43877,"modified_method":"/** {@inheritDoc} */\n    @Override public void run(GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2Job jobImpl = (GridHadoopV2Job) taskCtx.job();\n\n        JobConf jobConf = new JobConf(jobImpl.hadoopJobContext().getJobConf());\n\n        Reducer reducer = U.newInstance(jobConf.getReducerClass());\n\n        OutputFormat outFormat = jobConf.getOutputFormat();\n\n        Reporter reporter = Reporter.NULL;\n\n        NumberFormat numFormat = NumberFormat.getInstance();\n\n        numFormat.setMinimumIntegerDigits(5);\n        numFormat.setGroupingUsed(false);\n\n        String fileName = \"part-\" + numFormat.format(info().taskNumber());\n\n        reducer.configure(jobConf);\n\n        GridHadoopTaskInput input = taskCtx.input();\n\n        TaskAttemptID attempt = jobImpl.attemptId(info());\n\n        jobConf.set(\"mapreduce.task.attempt.id\", attempt.toString());\n\n        try {\n            final RecordWriter writer = outFormat.getRecordWriter(null, jobConf, fileName, reporter);\n\n            OutputCollector collector = new OutputCollector() {\n                @Override public void collect(Object key, Object val) throws IOException {\n                    writer.write(key, val);\n                }\n            };\n\n            try {\n                while (input.next())\n                    reducer.reduce(input.key(), input.values(), collector, reporter);\n\n                reducer.close();\n            }\n            finally {\n                writer.close(reporter);\n            }\n\n            OutputCommitter commiter = jobConf.getOutputCommitter();\n\n            commiter.commitTask(new TaskAttemptContextImpl(jobConf, attempt));\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"2de6bba345b895b68dfe4c27fd1fa98d137223e7","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param cfg Hadoop configuration of the job.\n     * @param ctx Context for IO operations.\n     * @param taskAttemptID Task execution id.\n     */\n    public GridHadoopV2Context(Configuration cfg, GridHadoopTaskContext ctx, TaskAttemptID taskAttemptID) {\n        this.cfg = cfg;\n        this.taskAttemptID = taskAttemptID;\n\n        output = ctx.output();\n        input = ctx.input();\n    }","id":43878,"modified_method":"/**\n     * @param cfg Hadoop configuration of the job.\n     * @param ctx Context for IO operations.\n     * @param taskAttemptID Task execution id.\n     */\n    public GridHadoopV2Context(Configuration cfg, GridHadoopTaskContext ctx, TaskAttemptID taskAttemptID) {\n        this.cfg = new Configuration(cfg);\n        this.taskAttemptID = taskAttemptID;\n\n        output = ctx.output();\n        input = ctx.input();\n    }","commit_id":"2de6bba345b895b68dfe4c27fd1fa98d137223e7","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public GridHadoopTask createTask(GridHadoopTaskInfo taskInfo) {\n        boolean isAbort = taskInfo.type() == GridHadoopTaskType.ABORT;\n\n        switch (taskInfo.type()) {\n            case MAP: {\n                if (ctx.getJobConf().getUseNewMapper())\n                    return new GridHadoopV2MapTask(taskInfo);\n                else\n                    return new GridHadoopV1MapTask(taskInfo);\n            }\n\n            case REDUCE: {\n                if (ctx.getJobConf().getUseNewReducer())\n                    return new GridHadoopV2ReduceTask(taskInfo);\n                else\n                    return new GridHadoopV1ReduceTask(taskInfo);\n            }\n\n            case COMBINE: {\n                if (ctx.getJobConf().getCombinerClass() == null)\n                    return new GridHadoopV2CombineTask(taskInfo);\n                else\n                    return new GridHadoopV1CombineTask(taskInfo);\n            }\n\n            case COMMIT:\n            case ABORT: {\n                if (ctx.getJobConf().getUseNewReducer())\n                    return new GridHadoopV2CleanupTask(taskInfo, isAbort);\n                else\n                    return new GridHadoopV1CleanupTask(taskInfo, isAbort);\n            }\n\n            default:\n                return null;\n        }\n    }","id":43879,"modified_method":"/** {@inheritDoc} */\n    @Override public GridHadoopTask createTask(GridHadoopTaskInfo taskInfo) {\n        boolean isAbort = taskInfo.type() == GridHadoopTaskType.ABORT;\n\n        switch (taskInfo.type()) {\n            case MAP:\n                return useNewMapper ? new GridHadoopV2MapTask(taskInfo) : new GridHadoopV1MapTask(taskInfo);\n\n            case REDUCE:\n                return useNewReducer ? new GridHadoopV2ReduceTask(taskInfo) : new GridHadoopV1ReduceTask(taskInfo);\n\n            case COMBINE:\n                return useNewCombiner ? new GridHadoopV2CombineTask(taskInfo) : new GridHadoopV1CombineTask(taskInfo);\n\n            case COMMIT:\n            case ABORT:\n                return useNewReducer ? new GridHadoopV2CleanupTask(taskInfo, isAbort) : new GridHadoopV1CleanupTask(taskInfo, isAbort);\n\n            default:\n                return null;\n        }\n    }","commit_id":"2de6bba345b895b68dfe4c27fd1fa98d137223e7","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param jobId Job ID.\n     * @param jobInfo Job info.\n     */\n    public GridHadoopV2Job(GridHadoopJobId jobId, GridHadoopDefaultJobInfo jobInfo) {\n        this.jobId = jobId;\n        this.jobInfo = jobInfo;\n\n        JobID hadoopJobID = new JobID(jobId.globalId().toString(), jobId.localId());\n\n        ctx = new JobContextImpl(jobInfo.configuration(), hadoopJobID);\n\n        keyCls = ctx.getMapOutputKeyClass();\n        valCls = ctx.getMapOutputValueClass();\n    }","id":43880,"modified_method":"/**\n     * @param jobId Job ID.\n     * @param jobInfo Job info.\n     */\n    public GridHadoopV2Job(GridHadoopJobId jobId, GridHadoopDefaultJobInfo jobInfo) {\n        this.jobId = jobId;\n        this.jobInfo = jobInfo;\n\n        JobID hadoopJobID = new JobID(jobId.globalId().toString(), jobId.localId());\n\n        JobConf cfg = jobInfo.configuration();\n\n        ctx = new JobContextImpl(cfg, hadoopJobID);\n\n        useNewMapper = cfg.getUseNewMapper();\n        useNewReducer = cfg.getUseNewReducer();\n        useNewCombiner = cfg.getCombinerClass() == null;\n\n        keyCls = ctx.getMapOutputKeyClass();\n        valCls = ctx.getMapOutputValueClass();\n    }","commit_id":"2de6bba345b895b68dfe4c27fd1fa98d137223e7","url":"https://github.com/apache/ignite"},{"original_method":"@Test\n    public void testGrabbingListOfEntries() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMinimumMessageCount(1);\n        mock.assertIsSatisfied();\n\n        Exchange exchange = mock.getExchanges().get(0);\n        assertNotNull(exchange);\n        Message in = exchange.getIn();\n        assertNotNull(in);\n        assertNotNull(in.getBody());\n        assertIsInstanceOf(String.class,in.getBody());\n        assertStringContains(in.getBody().toString(),\"temp\");\n    }","id":43881,"modified_method":"@Test\n    public void testGrabbingListOfEntries() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        // as the default delay option is one hour long, we expect exactly one message exchange\n        mock.expectedMessageCount(1);\n        mock.assertIsSatisfied();\n\n        Exchange exchange = mock.getExchanges().get(0);\n        assertNotNull(exchange);\n        Message in = exchange.getIn();\n        assertNotNull(in);\n        assertNotNull(in.getBody());\n        String body = assertIsInstanceOf(String.class, in.getBody());\n        assertStringContains(body, \"temp\");\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"weather:foo\").to(\"mock:result\");\n            }\n        };\n    }","id":43882,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"weather:foo\").to(\"mock:result\");\n            }\n        };\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"weather:foo?location=Madrid,Spain\").to(\"mock:result\");\n            }\n        };\n    }","id":43883,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"weather:foo?location=Madrid,Spain\").to(\"mock:result\");\n            }\n        };\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"weather:foo?location=Madrid,Spain&period=7 days\").to(\"mock:result\");\n            }\n        };\n    }","id":43884,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"weather:foo?location=Madrid,Spain&period=7 days&units=IMPERIAL\").to(\"mock:result\");\n            }\n        };\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        WeatherConfiguration configuration = new WeatherConfiguration();\n\n        // and then override from parameters\n        setProperties(configuration, parameters);\n\n        WeatherEndpoint endpoint = new WeatherEndpoint(uri, this, configuration);\n        return endpoint;\n    }","id":43885,"modified_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        WeatherConfiguration configuration = new WeatherConfiguration(this);\n\n        // and then override from parameters\n        setProperties(configuration, parameters);\n\n        WeatherEndpoint endpoint = new WeatherEndpoint(uri, this, configuration);\n        return endpoint;\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"public void setPeriod(String period) {\n        if (period != null) {\n            int result = 0;\n            try {\n                result = new Scanner(period).useDelimiter(\"\\\\D+\").nextInt();\n            } catch (Throwable e) {\n            }\n            if (result != 0) {\n                this.period = \"\" + result;\n            } else {\n                this.period = \"\";\n            }\n        }\n    }","id":43886,"modified_method":"public void setPeriod(String period) {\n        notNull(period, \"period\");\n        int result = 0;\n        try {\n            result = new Scanner(period).useDelimiter(\"\\\\D+\").nextInt();\n        } catch (Throwable e) {\n            // ignore and fallback the period to be an empty string\n        }\n        if (result != 0) {\n            this.period = \"\" + result;\n        }\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"public String getUnits() {\n        return units;\n    }","id":43887,"modified_method":"public WeatherUnits getUnits() {\n        return units;\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"private String getGeoLocation() {\n        final String LATITUDE = \"latitude\";\n        final String LONGITUDE = \"longitude\";\n        String result = \"\";\n\n        try {\n            String urlStr = \"http://freegeoip.net/json/\";\n            URL url = new URL(urlStr);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            String inputLine;\n            String temp = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                temp += inputLine;\n            }\n            in.close();\n            urlConnection.disconnect();\n\n            if (temp != null && !temp.isEmpty()) {\n                ObjectMapper mapper = new ObjectMapper();\n                JsonNode node = mapper.readValue(temp, JsonNode.class);\n                JsonNode latitudeNode = node.get(LATITUDE);\n                JsonNode longitudeNode = node.get(LONGITUDE);\n                if (latitudeNode != null && longitudeNode != null) {\n                    result = \"lat=\" + latitudeNode.toString() + \"&lon=\" + longitudeNode.toString();\n                }\n            }\n        } catch (Exception e) {\n            //this is going to fail if using this offline\n        }\n        return result;\n    }","id":43888,"modified_method":"private String getGeoLocation() throws Exception {\n        String geoLocation = component.getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, new URL(\"http://freegeoip.net/json/\"));\n        if (isEmpty(geoLocation)) {\n            throw new IllegalStateException(\"Retrieved an unexpected value: '\" + geoLocation + \"' for the geographical location\");\n        }\n\n        ObjectMapper mapper = new ObjectMapper();\n        JsonNode node = mapper.readValue(geoLocation, JsonNode.class);\n        JsonNode latitudeNode = notNull(node.get(\"latitude\"), \"latitude\");\n        JsonNode longitudeNode = notNull(node.get(\"longitude\"), \"longitude\");\n\n        return \"lat=\" + latitudeNode.toString() + \"&lon=\" + longitudeNode.toString();\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"public String getQuery() {\n        String result = \"http://api.openweathermap.org/data/2.5/\";\n        String location = \"\";\n        if (getLocation() == null || getLocation().isEmpty()) {\n            location = getGeoLocation();\n        } else {\n            //assuming the location is a town,country\n            location = \"q=\" + getLocation();\n        }\n        if (getPeriod() != null && getPeriod().isEmpty()) {\n\n            result += \"weather?\" + location;\n\n        } else {\n            result += \"forecast/daily?\" + location + \"&cnt=\" + getPeriod();\n        }\n        result += \"&units=\" + this.units;\n        return result;\n    }","id":43889,"modified_method":"public String getQuery() throws Exception {\n        String result = \"http://api.openweathermap.org/data/2.5/\";\n        String location = \"\";\n        if (isEmpty(getLocation())) {\n            location = getGeoLocation();\n        } else {\n            // assuming the location is a town or country\n            location = \"q=\" + getLocation();\n        }\n\n        if (isEmpty(getPeriod())) {\n            result += \"weather?\" + location;\n        } else {\n            result += \"forecast/daily?\" + location + \"&cnt=\" + getPeriod();\n        }\n        result += \"&units=\" + units.name().toLowerCase();\n\n        return result;\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"public WeatherConsumer(WeatherEndpoint endpoint, Processor processor, String query) {\n        super(endpoint, processor);\n        this.endpoint = endpoint;\n        this.query = query;\n    }","id":43890,"modified_method":"public WeatherConsumer(WeatherEndpoint endpoint, Processor processor, String query) {\n        super(endpoint, processor);\n        this.query = query;\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"protected int poll() throws Exception {\n        LOG.debug(\"Executing Weather Query \" + this.query);\n        URL url = new URL(this.query);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String inputLine;\n        String answer = \"\";\n        while ((inputLine = in.readLine()) != null) {\n            answer += inputLine;\n        }\n        in.close();\n        urlConnection.disconnect();\n        LOG.debug(\"result = \" + answer);\n        if (answer != null && !answer.isEmpty()) {\n            Exchange exchange = endpoint.createExchange();\n            exchange.getIn().setBody(answer);\n            exchange.setProperty(\"query\", this.query);\n            getProcessor().process(exchange);\n            return 1;\n        } else {\n            return 0;\n        }\n    }","id":43891,"modified_method":"@Override\n    protected int poll() throws Exception {\n        LOG.debug(\"Going to execute the query '{}'\", query);\n        String answer = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, new URL(query));\n        LOG.debug(\"Got back the answer '{}'\", answer);\n        if (ObjectHelper.isEmpty(answer)) {\n            throw new IllegalStateException(\"Got the empty string '\" + answer + \"' as the result of the query '\" + query + \"'\");\n        }\n\n        Exchange exchange = getEndpoint().createExchange();\n        exchange.getIn().setBody(answer);\n        exchange.getIn().setHeader(WeatherConstants.WEATHER_QUERY, query);\n        getProcessor().process(exchange);\n\n        return 1;\n    }","commit_id":"eb1fa8294925d8fb598831256a7411af2781aa36","url":"https://github.com/apache/camel"},{"original_method":"public String renderStatusHTML() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"<html><head><title>I2P Router Console<\/title><\/head><body>\\n\");\n        buf.append(\"<h1>Router console<\/h1>\\n\");\n        buf.append(\"<i><a href=\\\"/routerConsole.html\\\">console<\/a> | <a href=\\\"/routerStats.html\\\">stats<\/a><\/i><br>\\n\");\n\n        buf.append(\"<form action=\\\"/routerConsole.html\\\">\");\n        buf.append(\"<select name=\\\"go\\\" onChange='location.href=this.value'>\");\n        buf.append(\"<option value=\\\"/routerConsole.html#bandwidth\\\">Bandwidth<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#clients\\\">Clients<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#transports\\\">Transports<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#profiles\\\">Peer Profiles<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#tunnels\\\">Tunnels<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#jobs\\\">Jobs<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#shitlist\\\">Shitlist<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#pending\\\">Pending messages<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#netdb\\\">Network Database<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#logs\\\">Log messages<\/option>\\n\");\n        buf.append(\"<\/select>\");\n        buf.append(\"<\/form>\");\n\n        buf.append(\"<form action=\\\"/shutdown\\\" method=\\\"GET\\\">\");\n        buf.append(\"<b>Shut down the router:<\/b>\");\n        buf.append(\"<input type=\\\"password\\\" name=\\\"password\\\" size=\\\"8\\\" />\");\n        buf.append(\"<input type=\\\"submit\\\" value=\\\"shutdown!\\\" />\");\n        buf.append(\"<\/form>\");\n        buf.append(\"<hr />\\n\");\n\n        if ( (_routerInfo != null) && (_routerInfo.getIdentity() != null) )\n            buf.append(\"<b>Router: <\/b> \").append(_routerInfo.getIdentity().getHash().toBase64()).append(\"<br />\\n\");\n        buf.append(\"<b>As of: <\/b> \").append(new Date(_context.clock().now())).append(\" (uptime: \").append(DataHelper.formatDuration(getUptime())).append(\") <br />\\n\");\n        buf.append(\"<b>Started on: <\/b> \").append(new Date(getWhenStarted())).append(\"<br />\\n\");\n        buf.append(\"<b>Clock offset: <\/b> \").append(_context.clock().getOffset()).append(\"ms (OS time: \").append(new Date(_context.clock().now() - _context.clock().getOffset())).append(\")<br />\\n\");\n        long tot = Runtime.getRuntime().totalMemory()/1024;\n        long free = Runtime.getRuntime().freeMemory()/1024;\n        buf.append(\"<b>Memory:<\/b> In use: \").append((tot-free)).append(\"KB Free: \").append(free).append(\"KB <br />\\n\"); \n        buf.append(\"<b>Version:<\/b> Router: \").append(RouterVersion.VERSION).append(\" / SDK: \").append(CoreVersion.VERSION).append(\"<br />\\n\"); \n        if (_higherVersionSeen) \n            buf.append(\"<b><font color=\\\"red\\\">HIGHER VERSION SEEN<\/font><b> - please <a href=\\\"http://i2p.dnsalias.net/\\\">check<\/a> to see if there is a new release out<br />\\n\");\n\n        buf.append(\"<hr /><a name=\\\"bandwidth\\\"> <\/a><h2>Bandwidth<\/h2>\\n\");\n        long sent = _context.bandwidthLimiter().getTotalSendBytes();\n        long received = _context.bandwidthLimiter().getTotalReceiveBytes();\n        buf.append(\"<ul>\");\n\n        buf.append(\"<li> \").append(sent).append(\" bytes sent, \");\n        buf.append(received).append(\" bytes received<\/li>\");\n\n        DecimalFormat fmt = new DecimalFormat(\"##0.00\");\n\n        // we use the unadjusted time, since thats what getWhenStarted is based off\n        long lifetime = _context.clock().now()-_context.clock().getOffset() - getWhenStarted();\n        lifetime /= 1000;\n        if ( (sent > 0) && (received > 0) ) {\n            double sendKBps = sent / (lifetime*1024.0);\n            double receivedKBps = received / (lifetime*1024.0);\n            buf.append(\"<li>Lifetime rate: \");\n            buf.append(fmt.format(sendKBps)).append(\"KBps sent \");\n            buf.append(fmt.format(receivedKBps)).append(\"KBps received\");\n            buf.append(\"<\/li>\");\n            } \n        \n        RateStat sendRate = _context.statManager().getRate(\"transport.sendMessageSize\");\n        for (int i = 0; i < sendRate.getPeriods().length; i++) {\n            Rate rate = sendRate.getRate(sendRate.getPeriods()[i]);\n            double bytes = rate.getLastTotalValue() + rate.getCurrentTotalValue();\n            long ms = rate.getLastTotalEventTime() + rate.getLastTotalEventTime();\n            if (ms <= 0) {\n                bytes = 0;\n                ms = 1;\n            }\n            buf.append(\"<li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" instantaneous send avg: \");\n            double bps = bytes*1000.0d/ms;\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li><li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" period send avg: \");\n            // we include lastPeriod + current *partial* period, and jrandom is too lazy to calculate how\n            // much of that partial is contained here, so 2*period it is.\n            bps = bytes*1000.0d/(2*rate.getPeriod()); \n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li>\");\n        }\n\n        RateStat receiveRate = _context.statManager().getRate(\"transport.receiveMessageSize\");\n        for (int i = 0; i < receiveRate.getPeriods().length; i++) {\n            Rate rate = receiveRate.getRate(receiveRate.getPeriods()[i]);\n            double bytes = rate.getLastTotalValue();\n            long ms = rate.getLastTotalEventTime();\n            if (ms <= 0) {\n                bytes = 0;\n                ms = 1;\n            }\n            buf.append(\"<li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" instantaneous receive avg: \");\n            double bps = bytes*1000.0d/ms;\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps \");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps \");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li><li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" period receive avg: \");\n            // we include lastPeriod + current *partial* period, and jrandom is too lazy to calculate how\n            // much of that partial is contained here, so 2*period it is.\n            bps = bytes*1000.0d/(rate.getPeriod());\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li>\");\n        }\n\n        buf.append(\"<\/ul>\\n\");\n        buf.append(\"<i>Instantaneous averages count how fast the transfers go when we're trying to transfer data, \");\n        buf.append(\"while period averages count how fast the transfers go across the entire period, even when we're not \");\n        buf.append(\"trying to transfer data.  Lifetime averages count how many elephants there are on the moon [like anyone reads this text]<\/i>\");\n        buf.append(\"\\n\");\n\n        buf.append(\"<hr /><a name=\\\"clients\\\"> <\/a>\\n\");\n        buf.append(_context.clientManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"transports\\\"> <\/a>\\n\");\n        buf.append(_context.commSystem().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"profiles\\\"> <\/a>\\n\");\n        buf.append(_context.peerManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"tunnels\\\"> <\/a>\\n\");\n        buf.append(_context.tunnelManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"jobs\\\"> <\/a>\\n\");\n        buf.append(_context.jobQueue().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"shitlist\\\"> <\/a>\\n\");\n        buf.append(_context.shitlist().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"pending\\\"> <\/a>\\n\");\n        buf.append(_context.messageRegistry().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"netdb\\\"> <\/a>\\n\");\n        buf.append(_context.netDb().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"logs\\\"> <\/a>\\n\");\t\n        List msgs = _context.logManager().getBuffer().getMostRecentMessages();\n        buf.append(\"\\n<h2>Most recent console messages:<\/h2><table border=\\\"1\\\">\\n\");\n        for (Iterator iter = msgs.iterator(); iter.hasNext(); ) {\n            String msg = (String)iter.next();\n            buf.append(\"<tr><td valign=\\\"top\\\" align=\\\"left\\\"><pre>\").append(msg);\n            buf.append(\"<\/pre><\/td><\/tr>\\n\");\n        }\n        buf.append(\"<\/table>\");\n        buf.append(\"<\/body><\/html>\\n\");\n        return buf.toString();\n    }","id":43892,"modified_method":"public String renderStatusHTML() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"<html><head><title>I2P Router Console<\/title><\/head><body>\\n\");\n        buf.append(\"<h1>Router console<\/h1>\\n\");\n        buf.append(\"<i><a href=\\\"/routerConsole.html\\\">console<\/a> | <a href=\\\"/routerStats.html\\\">stats<\/a><\/i><br>\\n\");\n\n        buf.append(\"<form action=\\\"/routerConsole.html\\\">\");\n        buf.append(\"<select name=\\\"go\\\" onChange='location.href=this.value'>\");\n        buf.append(\"<option value=\\\"/routerConsole.html#bandwidth\\\">Bandwidth<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#clients\\\">Clients<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#transports\\\">Transports<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#profiles\\\">Peer Profiles<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#tunnels\\\">Tunnels<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#jobs\\\">Jobs<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#shitlist\\\">Shitlist<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#pending\\\">Pending messages<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#netdb\\\">Network Database<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#logs\\\">Log messages<\/option>\\n\");\n        buf.append(\"<\/select>\");\n        buf.append(\"<\/form>\");\n\n        buf.append(\"<form action=\\\"/shutdown\\\" method=\\\"GET\\\">\");\n        buf.append(\"<b>Shut down the router:<\/b>\");\n        buf.append(\"<input type=\\\"password\\\" name=\\\"password\\\" size=\\\"8\\\" />\");\n        buf.append(\"<input type=\\\"submit\\\" value=\\\"shutdown!\\\" />\");\n        buf.append(\"<\/form>\");\n        buf.append(\"<hr />\\n\");\n\n        if ( (_routerInfo != null) && (_routerInfo.getIdentity() != null) )\n            buf.append(\"<b>Router: <\/b> \").append(_routerInfo.getIdentity().getHash().toBase64()).append(\"<br />\\n\");\n        buf.append(\"<b>As of: <\/b> \").append(new Date(_context.clock().now())).append(\" (uptime: \").append(DataHelper.formatDuration(getUptime())).append(\") <br />\\n\");\n        buf.append(\"<b>Started on: <\/b> \").append(new Date(getWhenStarted())).append(\"<br />\\n\");\n        buf.append(\"<b>Clock offset: <\/b> \").append(_context.clock().getOffset()).append(\"ms (OS time: \").append(new Date(_context.clock().now() - _context.clock().getOffset())).append(\")<br />\\n\");\n        long tot = Runtime.getRuntime().totalMemory()/1024;\n        long free = Runtime.getRuntime().freeMemory()/1024;\n        buf.append(\"<b>Memory:<\/b> In use: \").append((tot-free)).append(\"KB Free: \").append(free).append(\"KB <br />\\n\"); \n        buf.append(\"<b>Version:<\/b> Router: \").append(RouterVersion.VERSION).append(\" / SDK: \").append(CoreVersion.VERSION).append(\"<br />\\n\"); \n        if (_higherVersionSeen) \n            buf.append(\"<b><font color=\\\"red\\\">HIGHER VERSION SEEN<\/font><b> - please <a href=\\\"http://i2p.dnsalias.net/\\\">check<\/a> to see if there is a new release out<br />\\n\");\n\n        buf.append(\"<hr /><a name=\\\"bandwidth\\\"> <\/a><h2>Bandwidth<\/h2>\\n\");\n        long sent = _context.bandwidthLimiter().getTotalSendBytes();\n        long received = _context.bandwidthLimiter().getTotalReceiveBytes();\n        buf.append(\"<ul>\");\n\n        buf.append(\"<li> \").append(sent).append(\" bytes sent, \");\n        buf.append(received).append(\" bytes received<\/li>\");\n\n        DecimalFormat fmt = new DecimalFormat(\"##0.00\");\n\n        // we use the unadjusted time, since thats what getWhenStarted is based off\n        long lifetime = _context.clock().now()-_context.clock().getOffset() - getWhenStarted();\n        lifetime /= 1000;\n        if ( (sent > 0) && (received > 0) ) {\n            double sendKBps = sent / (lifetime*1024.0);\n            double receivedKBps = received / (lifetime*1024.0);\n            buf.append(\"<li>Lifetime rate: \");\n            buf.append(fmt.format(sendKBps)).append(\"KBps sent \");\n            buf.append(fmt.format(receivedKBps)).append(\"KBps received\");\n            buf.append(\"<\/li>\");\n            } \n        \n        RateStat sendRate = _context.statManager().getRate(\"transport.sendMessageSize\");\n        for (int i = 0; i < sendRate.getPeriods().length; i++) {\n            Rate rate = sendRate.getRate(sendRate.getPeriods()[i]);\n            double bytes = rate.getLastTotalValue();\n            long ms = rate.getLastTotalEventTime() + rate.getLastTotalEventTime();\n            if (ms <= 0) {\n                bytes = 0;\n                ms = 1;\n            }\n            buf.append(\"<li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" instantaneous send avg: \");\n            double bps = bytes*1000.0d/ms;\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li><li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" period send avg: \");\n            bps = bytes*1000.0d/(rate.getPeriod()); \n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li>\");\n        }\n\n        RateStat receiveRate = _context.statManager().getRate(\"transport.receiveMessageSize\");\n        for (int i = 0; i < receiveRate.getPeriods().length; i++) {\n            Rate rate = receiveRate.getRate(receiveRate.getPeriods()[i]);\n            double bytes = rate.getLastTotalValue();\n            long ms = rate.getLastTotalEventTime();\n            if (ms <= 0) {\n                bytes = 0;\n                ms = 1;\n            }\n            buf.append(\"<li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" instantaneous receive avg: \");\n            double bps = bytes*1000.0d/ms;\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps \");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps \");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li><li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" period receive avg: \");\n            bps = bytes*1000.0d/(rate.getPeriod());\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li>\");\n        }\n\n        buf.append(\"<\/ul>\\n\");\n        buf.append(\"<i>Instantaneous averages count how fast the transfers go when we're trying to transfer data, \");\n        buf.append(\"while period averages count how fast the transfers go across the entire period, even when we're not \");\n        buf.append(\"trying to transfer data.  Lifetime averages count how many elephants there are on the moon [like anyone reads this text]<\/i>\");\n        buf.append(\"\\n\");\n\n        buf.append(\"<hr /><a name=\\\"clients\\\"> <\/a>\\n\");\n        buf.append(_context.clientManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"transports\\\"> <\/a>\\n\");\n        buf.append(_context.commSystem().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"profiles\\\"> <\/a>\\n\");\n        buf.append(_context.peerManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"tunnels\\\"> <\/a>\\n\");\n        buf.append(_context.tunnelManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"jobs\\\"> <\/a>\\n\");\n        buf.append(_context.jobQueue().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"shitlist\\\"> <\/a>\\n\");\n        buf.append(_context.shitlist().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"pending\\\"> <\/a>\\n\");\n        buf.append(_context.messageRegistry().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"netdb\\\"> <\/a>\\n\");\n        buf.append(_context.netDb().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"logs\\\"> <\/a>\\n\");\t\n        List msgs = _context.logManager().getBuffer().getMostRecentMessages();\n        buf.append(\"\\n<h2>Most recent console messages:<\/h2><table border=\\\"1\\\">\\n\");\n        for (Iterator iter = msgs.iterator(); iter.hasNext(); ) {\n            String msg = (String)iter.next();\n            buf.append(\"<tr><td valign=\\\"top\\\" align=\\\"left\\\"><pre>\").append(msg);\n            buf.append(\"<\/pre><\/td><\/tr>\\n\");\n        }\n        buf.append(\"<\/table>\");\n        buf.append(\"<\/body><\/html>\\n\");\n        return buf.toString();\n    }","commit_id":"40b59d5a5a6655fd7607ec067acb29dc72dbe0f0","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String renderStatusHTML() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"<html><head><title>I2P Router Console<\/title><\/head><body>\\n\");\n        buf.append(\"<h1>Router console<\/h1>\\n\");\n        buf.append(\"<i><a href=\\\"/routerConsole.html\\\">console<\/a> | <a href=\\\"/routerStats.html\\\">stats<\/a><\/i><br>\\n\");\n\n        buf.append(\"<form action=\\\"/routerConsole.html\\\">\");\n        buf.append(\"<select name=\\\"go\\\" onChange='location.href=this.value'>\");\n        buf.append(\"<option value=\\\"/routerConsole.html#bandwidth\\\">Bandwidth<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#clients\\\">Clients<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#transports\\\">Transports<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#profiles\\\">Peer Profiles<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#tunnels\\\">Tunnels<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#jobs\\\">Jobs<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#shitlist\\\">Shitlist<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#pending\\\">Pending messages<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#netdb\\\">Network Database<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#logs\\\">Log messages<\/option>\\n\");\n        buf.append(\"<\/select>\");\n        buf.append(\"<\/form>\");\n\n        buf.append(\"<form action=\\\"/shutdown\\\" method=\\\"GET\\\">\");\n        buf.append(\"<b>Shut down the router:<\/b>\");\n        buf.append(\"<input type=\\\"password\\\" name=\\\"password\\\" size=\\\"8\\\" />\");\n        buf.append(\"<input type=\\\"submit\\\" value=\\\"shutdown!\\\" />\");\n        buf.append(\"<\/form>\");\n        buf.append(\"<hr />\\n\");\n\n        if ( (_routerInfo != null) && (_routerInfo.getIdentity() != null) )\n            buf.append(\"<b>Router: <\/b> \").append(_routerInfo.getIdentity().getHash().toBase64()).append(\"<br />\\n\");\n        buf.append(\"<b>As of: <\/b> \").append(new Date(_context.clock().now())).append(\" (uptime: \").append(DataHelper.formatDuration(getUptime())).append(\") <br />\\n\");\n        buf.append(\"<b>Started on: <\/b> \").append(new Date(getWhenStarted())).append(\"<br />\\n\");\n        buf.append(\"<b>Clock offset: <\/b> \").append(_context.clock().getOffset()).append(\"ms (OS time: \").append(new Date(_context.clock().now() - _context.clock().getOffset())).append(\")<br />\\n\");\n        long tot = Runtime.getRuntime().totalMemory()/1024;\n        long free = Runtime.getRuntime().freeMemory()/1024;\n        buf.append(\"<b>Memory:<\/b> In use: \").append((tot-free)).append(\"KB Free: \").append(free).append(\"KB <br />\\n\"); \n        buf.append(\"<b>Version:<\/b> Router: \").append(RouterVersion.VERSION).append(\" / SDK: \").append(CoreVersion.VERSION).append(\"<br />\\n\"); \n        if (_higherVersionSeen) \n            buf.append(\"<b><font color=\\\"red\\\">HIGHER VERSION SEEN<\/font><b> - please <a href=\\\"http://i2p.dnsalias.net/\\\">check<\/a> to see if there is a new release out<br />\\n\");\n\n        buf.append(\"<hr /><a name=\\\"bandwidth\\\"> <\/a><h2>Bandwidth<\/h2>\\n\");\n        long sent = _context.bandwidthLimiter().getTotalSendBytes();\n        long received = _context.bandwidthLimiter().getTotalReceiveBytes();\n        buf.append(\"<ul>\");\n\n        buf.append(\"<li> \").append(sent).append(\" bytes sent, \");\n        buf.append(received).append(\" bytes received<\/li>\");\n\n        DecimalFormat fmt = new DecimalFormat(\"##0.00\");\n\n        // we use the unadjusted time, since thats what getWhenStarted is based off\n        long lifetime = _context.clock().now()-_context.clock().getOffset() - getWhenStarted();\n        lifetime /= 1000;\n        if ( (sent > 0) && (received > 0) ) {\n            double sendKBps = sent / (lifetime*1024.0);\n            double receivedKBps = received / (lifetime*1024.0);\n            buf.append(\"<li>Lifetime rate: \");\n            buf.append(fmt.format(sendKBps)).append(\"KBps sent \");\n            buf.append(fmt.format(receivedKBps)).append(\"KBps received\");\n            buf.append(\"<\/li>\");\n            } \n        \n        RateStat sendRate = _context.statManager().getRate(\"transport.sendMessageSize\");\n        for (int i = 0; i < sendRate.getPeriods().length; i++) {\n            Rate rate = sendRate.getRate(sendRate.getPeriods()[i]);\n            double bytes = rate.getLastTotalValue() + rate.getCurrentTotalValue();\n            long ms = rate.getLastTotalEventTime() + rate.getLastTotalEventTime();\n            if (ms <= 0) {\n                bytes = 0;\n                ms = 1;\n            }\n            buf.append(\"<li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" instantaneous send avg: \");\n            double bps = bytes*1000.0d/ms;\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li><li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" period send avg: \");\n            // we include lastPeriod + current *partial* period, and jrandom is too lazy to calculate how\n            // much of that partial is contained here, so 2*period it is.\n            bps = bytes*1000.0d/(2*rate.getPeriod()); \n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li>\");\n        }\n\n        RateStat receiveRate = _context.statManager().getRate(\"transport.receiveMessageSize\");\n        for (int i = 0; i < receiveRate.getPeriods().length; i++) {\n            Rate rate = receiveRate.getRate(receiveRate.getPeriods()[i]);\n            double bytes = rate.getLastTotalValue() + rate.getCurrentTotalValue();\n            long ms = rate.getLastTotalEventTime() + rate.getLastTotalEventTime();\n            if (ms <= 0) {\n                bytes = 0;\n                ms = 1;\n            }\n            buf.append(\"<li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" instantaneous receive avg: \");\n            double bps = bytes*1000.0d/ms;\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps \");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps \");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li><li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" period receive avg: \");\n            // we include lastPeriod + current *partial* period, and jrandom is too lazy to calculate how\n            // much of that partial is contained here, so 2*period it is.\n            bps = bytes*1000.0d/(2*rate.getPeriod());\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li>\");\n        }\n\n        buf.append(\"<\/ul>\\n\");\n        buf.append(\"<i>Instantaneous averages count how fast the transfers go when we're trying to transfer data, \");\n        buf.append(\"while period averages count how fast the transfers go across the entire period, even when we're not \");\n        buf.append(\"trying to transfer data.  Lifetime averages count how many elephants there are on the moon [like anyone reads this text]<\/i>\");\n        buf.append(\"\\n\");\n\n        buf.append(\"<hr /><a name=\\\"clients\\\"> <\/a>\\n\");\n        buf.append(_context.clientManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"transports\\\"> <\/a>\\n\");\n        buf.append(_context.commSystem().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"profiles\\\"> <\/a>\\n\");\n        buf.append(_context.peerManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"tunnels\\\"> <\/a>\\n\");\n        buf.append(_context.tunnelManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"jobs\\\"> <\/a>\\n\");\n        buf.append(_context.jobQueue().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"shitlist\\\"> <\/a>\\n\");\n        buf.append(_context.shitlist().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"pending\\\"> <\/a>\\n\");\n        buf.append(_context.messageRegistry().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"netdb\\\"> <\/a>\\n\");\n        buf.append(_context.netDb().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"logs\\\"> <\/a>\\n\");\t\n        List msgs = _context.logManager().getBuffer().getMostRecentMessages();\n        buf.append(\"\\n<h2>Most recent console messages:<\/h2><table border=\\\"1\\\">\\n\");\n        for (Iterator iter = msgs.iterator(); iter.hasNext(); ) {\n            String msg = (String)iter.next();\n            buf.append(\"<tr><td valign=\\\"top\\\" align=\\\"left\\\"><pre>\").append(msg);\n            buf.append(\"<\/pre><\/td><\/tr>\\n\");\n        }\n        buf.append(\"<\/table>\");\n        buf.append(\"<\/body><\/html>\\n\");\n        return buf.toString();\n    }","id":43893,"modified_method":"public String renderStatusHTML() {\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"<html><head><title>I2P Router Console<\/title><\/head><body>\\n\");\n        buf.append(\"<h1>Router console<\/h1>\\n\");\n        buf.append(\"<i><a href=\\\"/routerConsole.html\\\">console<\/a> | <a href=\\\"/routerStats.html\\\">stats<\/a><\/i><br>\\n\");\n\n        buf.append(\"<form action=\\\"/routerConsole.html\\\">\");\n        buf.append(\"<select name=\\\"go\\\" onChange='location.href=this.value'>\");\n        buf.append(\"<option value=\\\"/routerConsole.html#bandwidth\\\">Bandwidth<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#clients\\\">Clients<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#transports\\\">Transports<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#profiles\\\">Peer Profiles<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#tunnels\\\">Tunnels<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#jobs\\\">Jobs<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#shitlist\\\">Shitlist<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#pending\\\">Pending messages<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#netdb\\\">Network Database<\/option>\\n\");\n        buf.append(\"<option value=\\\"/routerConsole.html#logs\\\">Log messages<\/option>\\n\");\n        buf.append(\"<\/select>\");\n        buf.append(\"<\/form>\");\n\n        buf.append(\"<form action=\\\"/shutdown\\\" method=\\\"GET\\\">\");\n        buf.append(\"<b>Shut down the router:<\/b>\");\n        buf.append(\"<input type=\\\"password\\\" name=\\\"password\\\" size=\\\"8\\\" />\");\n        buf.append(\"<input type=\\\"submit\\\" value=\\\"shutdown!\\\" />\");\n        buf.append(\"<\/form>\");\n        buf.append(\"<hr />\\n\");\n\n        if ( (_routerInfo != null) && (_routerInfo.getIdentity() != null) )\n            buf.append(\"<b>Router: <\/b> \").append(_routerInfo.getIdentity().getHash().toBase64()).append(\"<br />\\n\");\n        buf.append(\"<b>As of: <\/b> \").append(new Date(_context.clock().now())).append(\" (uptime: \").append(DataHelper.formatDuration(getUptime())).append(\") <br />\\n\");\n        buf.append(\"<b>Started on: <\/b> \").append(new Date(getWhenStarted())).append(\"<br />\\n\");\n        buf.append(\"<b>Clock offset: <\/b> \").append(_context.clock().getOffset()).append(\"ms (OS time: \").append(new Date(_context.clock().now() - _context.clock().getOffset())).append(\")<br />\\n\");\n        long tot = Runtime.getRuntime().totalMemory()/1024;\n        long free = Runtime.getRuntime().freeMemory()/1024;\n        buf.append(\"<b>Memory:<\/b> In use: \").append((tot-free)).append(\"KB Free: \").append(free).append(\"KB <br />\\n\"); \n        buf.append(\"<b>Version:<\/b> Router: \").append(RouterVersion.VERSION).append(\" / SDK: \").append(CoreVersion.VERSION).append(\"<br />\\n\"); \n        if (_higherVersionSeen) \n            buf.append(\"<b><font color=\\\"red\\\">HIGHER VERSION SEEN<\/font><b> - please <a href=\\\"http://i2p.dnsalias.net/\\\">check<\/a> to see if there is a new release out<br />\\n\");\n\n        buf.append(\"<hr /><a name=\\\"bandwidth\\\"> <\/a><h2>Bandwidth<\/h2>\\n\");\n        long sent = _context.bandwidthLimiter().getTotalSendBytes();\n        long received = _context.bandwidthLimiter().getTotalReceiveBytes();\n        buf.append(\"<ul>\");\n\n        buf.append(\"<li> \").append(sent).append(\" bytes sent, \");\n        buf.append(received).append(\" bytes received<\/li>\");\n\n        DecimalFormat fmt = new DecimalFormat(\"##0.00\");\n\n        // we use the unadjusted time, since thats what getWhenStarted is based off\n        long lifetime = _context.clock().now()-_context.clock().getOffset() - getWhenStarted();\n        lifetime /= 1000;\n        if ( (sent > 0) && (received > 0) ) {\n            double sendKBps = sent / (lifetime*1024.0);\n            double receivedKBps = received / (lifetime*1024.0);\n            buf.append(\"<li>Lifetime rate: \");\n            buf.append(fmt.format(sendKBps)).append(\"KBps sent \");\n            buf.append(fmt.format(receivedKBps)).append(\"KBps received\");\n            buf.append(\"<\/li>\");\n            } \n        \n        RateStat sendRate = _context.statManager().getRate(\"transport.sendMessageSize\");\n        for (int i = 0; i < sendRate.getPeriods().length; i++) {\n            Rate rate = sendRate.getRate(sendRate.getPeriods()[i]);\n            double bytes = rate.getLastTotalValue() + rate.getCurrentTotalValue();\n            long ms = rate.getLastTotalEventTime() + rate.getLastTotalEventTime();\n            if (ms <= 0) {\n                bytes = 0;\n                ms = 1;\n            }\n            buf.append(\"<li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" instantaneous send avg: \");\n            double bps = bytes*1000.0d/ms;\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li><li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" period send avg: \");\n            // we include lastPeriod + current *partial* period, and jrandom is too lazy to calculate how\n            // much of that partial is contained here, so 2*period it is.\n            bps = bytes*1000.0d/(2*rate.getPeriod()); \n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li>\");\n        }\n\n        RateStat receiveRate = _context.statManager().getRate(\"transport.receiveMessageSize\");\n        for (int i = 0; i < receiveRate.getPeriods().length; i++) {\n            Rate rate = receiveRate.getRate(receiveRate.getPeriods()[i]);\n            double bytes = rate.getLastTotalValue();\n            long ms = rate.getLastTotalEventTime();\n            if (ms <= 0) {\n                bytes = 0;\n                ms = 1;\n            }\n            buf.append(\"<li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" instantaneous receive avg: \");\n            double bps = bytes*1000.0d/ms;\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps \");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps \");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li><li>\");\n            buf.append(DataHelper.formatDuration(rate.getPeriod())).append(\" period receive avg: \");\n            // we include lastPeriod + current *partial* period, and jrandom is too lazy to calculate how\n            // much of that partial is contained here, so 2*period it is.\n            bps = bytes*1000.0d/(rate.getPeriod());\n            if (bps > 2048) {\n                bps /= 1024.0d;\n                buf.append(fmt.format(bps)).append(\" KBps\");\n            } else {\n                buf.append(fmt.format(bps)).append(\" Bps\");\n            }\n            buf.append(\" over \").append((long)bytes).append(\" bytes\");\n            buf.append(\"<\/li>\");\n        }\n\n        buf.append(\"<\/ul>\\n\");\n        buf.append(\"<i>Instantaneous averages count how fast the transfers go when we're trying to transfer data, \");\n        buf.append(\"while period averages count how fast the transfers go across the entire period, even when we're not \");\n        buf.append(\"trying to transfer data.  Lifetime averages count how many elephants there are on the moon [like anyone reads this text]<\/i>\");\n        buf.append(\"\\n\");\n\n        buf.append(\"<hr /><a name=\\\"clients\\\"> <\/a>\\n\");\n        buf.append(_context.clientManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"transports\\\"> <\/a>\\n\");\n        buf.append(_context.commSystem().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"profiles\\\"> <\/a>\\n\");\n        buf.append(_context.peerManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"tunnels\\\"> <\/a>\\n\");\n        buf.append(_context.tunnelManager().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"jobs\\\"> <\/a>\\n\");\n        buf.append(_context.jobQueue().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"shitlist\\\"> <\/a>\\n\");\n        buf.append(_context.shitlist().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"pending\\\"> <\/a>\\n\");\n        buf.append(_context.messageRegistry().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"netdb\\\"> <\/a>\\n\");\n        buf.append(_context.netDb().renderStatusHTML());\n        buf.append(\"\\n<hr /><a name=\\\"logs\\\"> <\/a>\\n\");\t\n        List msgs = _context.logManager().getBuffer().getMostRecentMessages();\n        buf.append(\"\\n<h2>Most recent console messages:<\/h2><table border=\\\"1\\\">\\n\");\n        for (Iterator iter = msgs.iterator(); iter.hasNext(); ) {\n            String msg = (String)iter.next();\n            buf.append(\"<tr><td valign=\\\"top\\\" align=\\\"left\\\"><pre>\").append(msg);\n            buf.append(\"<\/pre><\/td><\/tr>\\n\");\n        }\n        buf.append(\"<\/table>\");\n        buf.append(\"<\/body><\/html>\\n\");\n        return buf.toString();\n    }","commit_id":"e2da05b19707f4c0743d31b3d0c6a1cb9beb772a","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Router(String configFilename, Properties envProps) {\n        _config = new Properties();\n        _context = new RouterContext(this, envProps);\n        if (configFilename == null)\n            _configFilename = _context.getProperty(PROP_CONFIG_FILE, \"router.config\");\n        else\n            _configFilename = configFilename;\n        _routerInfo = null;\n        _higherVersionSeen = false;\n        _log = _context.logManager().getLog(Router.class);\n        _log.info(\"New router created with config file \" + _configFilename);\n        _sessionKeyPersistenceHelper = new SessionKeyPersistenceHelper(_context);\n        _killVMOnEnd = true;\n        _oomListener = new I2PThread.OOMEventListener() { \n            public void outOfMemory(OutOfMemoryError oom) { \n                _log.log(Log.CRIT, \"Thread ran out of memory\", oom);\n                shutdown(); \n            }\n        };\n        _shutdownHook = new ShutdownHook();\n    }","id":43894,"modified_method":"public Router(String configFilename, Properties envProps) {\n        _config = new Properties();\n        _context = new RouterContext(this, envProps);\n        if (configFilename == null)\n            _configFilename = _context.getProperty(PROP_CONFIG_FILE, \"router.config\");\n        else\n            _configFilename = configFilename;\n        _routerInfo = null;\n        _higherVersionSeen = false;\n        _log = _context.logManager().getLog(Router.class);\n        _log.info(\"New router created with config file \" + _configFilename);\n        _sessionKeyPersistenceHelper = new SessionKeyPersistenceHelper(_context);\n        _killVMOnEnd = true;\n        _oomListener = new I2PThread.OOMEventListener() { \n            public void outOfMemory(OutOfMemoryError oom) { \n                _log.log(Log.CRIT, \"Thread ran out of memory\", oom);\n                for (int i = 0; i < 5; i++) { // try this 5 times, in case it OOMs\n                    try { \n                        _log.log(Log.CRIT, \"free mem: \" + Runtime.getRuntime().freeMemory() + \n                                           \" total mem: \" + Runtime.getRuntime().totalMemory());\n                        break; // w00t\n                    } catch (OutOfMemoryError oome) {\n                        // gobble\n                    }\n                }\n                shutdown(); \n            }\n        };\n        _shutdownHook = new ShutdownHook();\n    }","commit_id":"e2da05b19707f4c0743d31b3d0c6a1cb9beb772a","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            _log.log(Log.CRIT, \"Shutting down the router...\");\n            shutdown();\n        }","id":43895,"modified_method":"public void run() {\n            setName(\"Router \" + _id + \" shutdown\");\n            _log.log(Log.CRIT, \"Shutting down the router...\");\n            shutdown();\n        }","commit_id":"e2da05b19707f4c0743d31b3d0c6a1cb9beb772a","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  For single stat page\n     *  @since 0.9\n     */\n    public String getSingleStat() {\n        try {\n            if (StatSummarizer.isDisabled())\n                return \"\";\n            if (_stat == null) {\n                _out.write(\"No stat\");\n                return \"\";\n            }\n            List<Rate> rates = StatSummarizer.instance().parseSpecs(_stat);\n            if (rates.size() != 1) {\n                _out.write(\"Graphs not enabled for \" + _stat);\n                return \"\";\n            }\n            Rate r = rates.get(0);\n            _out.write(\"<h3>\");\n            _out.write(_(\"{0} for {1}\", r.getRateStat().getName(), DataHelper.formatDuration2(_periodCount * r.getPeriod())));\n            if (_end > 0)\n                _out.write(' ' + _(\"ending {0} ago\", DataHelper.formatDuration2(_end * r.getPeriod())));\n\n            _out.write(\"<\/h3><img class=\\\"statimage\\\" border=\\\"0\\\"\"\n                       + \" src=\\\"viewstat.jsp?stat=\"\n                       + r.getRateStat().getName() \n                       + \"&amp;showEvents=\" + _showEvents\n                       + \"&amp;period=\" + r.getPeriod() \n                       + \"&amp;periodCount=\" + _periodCount \n                       + \"&amp;end=\" + _end \n                       + \"&amp;width=\" + _width\n                       + \"&amp;height=\" + _height\n                       + \"\\\"><p>\\n\");\n\n            if (_width < MAX_X && _height < MAX_Y) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width * 3 / 2, _height * 3 / 2));\n                _out.write(_(\"Larger\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_width > MIN_X && _height > MIN_Y) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width * 2 / 3, _height * 2 / 3));\n                _out.write(_(\"Smaller\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_height < MAX_Y) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width, _height * 3 / 2));\n                _out.write(_(\"Taller\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_height > MIN_Y) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width, _height * 2 / 3));\n                _out.write(_(\"Shorter\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_width < MAX_X) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width * 3 / 2, _height));\n                _out.write(_(\"Wider\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_width > MIN_X) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width * 2 / 3, _height));\n                _out.write(_(\"Narrower\"));\n                _out.write(\"<\/a>\");\n            }\n\n            _out.write(\"<br>\");\n            if (_periodCount < MAX_C) {\n                _out.write(link(_stat, _showEvents, _periodCount * 2, _end, _width, _height));\n                _out.write(_(\"Larger interval\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_periodCount > MIN_C) {\n                _out.write(link(_stat, _showEvents, _periodCount / 2, _end, _width, _height));\n                _out.write(_(\"Smaller interval\"));\n                _out.write(\"<\/a>\");\n            }\n\n            _out.write(\"<br>\");\n            if (_periodCount < MAX_C) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end + _periodCount, _width, _height));\n                _out.write(_(\"Previous interval\"));\n                _out.write(\"<\/a>\");\n            }\n\n            if (_end > 0) {\n                int end = _end - _periodCount;\n                if (end <= 0)\n                    end = 0;\n                if (_periodCount < MAX_C)\n                    _out.write(\" - \");\n                _out.write(link(_stat, _showEvents, _periodCount, end, _width, _height));\n                _out.write(_(\"Next interval\"));\n                _out.write(\"<\/a> \");\n            }\n\n            _out.write(\"<br>\");\n            _out.write(link(_stat, !_showEvents, _periodCount, _end, _width, _height));\n            _out.write(_showEvents ? _(\"Plot averages\") : _(\"plot events\"));\n            _out.write(\"<\/a>\");\n\n            _out.write(\"<\/p><p><i>\" + _(\"All times are UTC.\") + \"<\/i><\/p>\\n\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        return \"\"; \n    }","id":43896,"modified_method":"/**\n     *  For single stat page;\n     *  stat = \"bw.combined\" treated specially\n     *\n     *  @since 0.9\n     */\n    public String getSingleStat() {\n        try {\n            if (StatSummarizer.isDisabled())\n                return \"\";\n            if (_stat == null) {\n                _out.write(\"No stat specified\");\n                return \"\";\n            }\n            long period;\n            String name, displayName;\n            if (_stat.equals(\"bw.combined\")) {\n                period = 60000;\n                name = _stat;\n                displayName = _(\"Bandwidth usage\");\n            } else {\n                List<Rate> rates = StatSummarizer.instance().parseSpecs(_stat);\n                if (rates.size() != 1) {\n                    _out.write(\"Graphs not enabled for \" + _stat);\n                    return \"\";\n                }\n                Rate r = rates.get(0);\n                period = r.getPeriod();\n                name = r.getRateStat().getName();\n                displayName = name;\n            }\n            _out.write(\"<h3>\");\n            _out.write(_(\"{0} for {1}\", displayName, DataHelper.formatDuration2(_periodCount * period)));\n            if (_end > 0)\n                _out.write(' ' + _(\"ending {0} ago\", DataHelper.formatDuration2(_end * period)));\n\n            _out.write(\"<\/h3><img class=\\\"statimage\\\" border=\\\"0\\\"\"\n                       + \" src=\\\"viewstat.jsp?stat=\"\n                       + name\n                       + \"&amp;showEvents=\" + _showEvents\n                       + \"&amp;period=\" + period\n                       + \"&amp;periodCount=\" + _periodCount \n                       + \"&amp;end=\" + _end \n                       + \"&amp;width=\" + _width\n                       + \"&amp;height=\" + _height\n                       + \"\\\"><p>\\n\");\n\n            if (_width < MAX_X && _height < MAX_Y) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width * 3 / 2, _height * 3 / 2));\n                _out.write(_(\"Larger\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_width > MIN_X && _height > MIN_Y) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width * 2 / 3, _height * 2 / 3));\n                _out.write(_(\"Smaller\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_height < MAX_Y) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width, _height * 3 / 2));\n                _out.write(_(\"Taller\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_height > MIN_Y) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width, _height * 2 / 3));\n                _out.write(_(\"Shorter\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_width < MAX_X) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width * 3 / 2, _height));\n                _out.write(_(\"Wider\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_width > MIN_X) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end, _width * 2 / 3, _height));\n                _out.write(_(\"Narrower\"));\n                _out.write(\"<\/a>\");\n            }\n\n            _out.write(\"<br>\");\n            if (_periodCount < MAX_C) {\n                _out.write(link(_stat, _showEvents, _periodCount * 2, _end, _width, _height));\n                _out.write(_(\"Larger interval\"));\n                _out.write(\"<\/a> - \");\n            }\n\n            if (_periodCount > MIN_C) {\n                _out.write(link(_stat, _showEvents, _periodCount / 2, _end, _width, _height));\n                _out.write(_(\"Smaller interval\"));\n                _out.write(\"<\/a>\");\n            }\n\n            _out.write(\"<br>\");\n            if (_periodCount < MAX_C) {\n                _out.write(link(_stat, _showEvents, _periodCount, _end + _periodCount, _width, _height));\n                _out.write(_(\"Previous interval\"));\n                _out.write(\"<\/a>\");\n            }\n\n            if (_end > 0) {\n                int end = _end - _periodCount;\n                if (end <= 0)\n                    end = 0;\n                if (_periodCount < MAX_C)\n                    _out.write(\" - \");\n                _out.write(link(_stat, _showEvents, _periodCount, end, _width, _height));\n                _out.write(_(\"Next interval\"));\n                _out.write(\"<\/a> \");\n            }\n\n            _out.write(\"<br>\");\n            _out.write(link(_stat, !_showEvents, _periodCount, _end, _width, _height));\n            if (!_stat.equals(\"bw.combined\"))\n                _out.write(_showEvents ? _(\"Plot averages\") : _(\"plot events\"));\n            _out.write(\"<\/a>\");\n\n            _out.write(\"<\/p><p><i>\" + _(\"All times are UTC.\") + \"<\/i><\/p>\\n\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        return \"\"; \n    }","commit_id":"21e47e61f01e24796257076f8d98b43a6e37258d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String getImages() { \n        if (StatSummarizer.isDisabled())\n            return \"\";\n        try {\n            List listeners = StatSummarizer.instance().getListeners();\n            TreeSet ordered = new TreeSet(new AlphaComparator());\n            ordered.addAll(listeners);\n\n            // go to some trouble to see if we have the data for the combined bw graph\n            boolean hasTx = false;\n            boolean hasRx = false;\n            for (Iterator iter = ordered.iterator(); iter.hasNext(); ) {\n                SummaryListener lsnr = (SummaryListener)iter.next();\n                String title = lsnr.getRate().getRateStat().getName();\n                if (title.equals(\"bw.sendRate\")) hasTx = true;\n                else if (title.equals(\"bw.recvRate\")) hasRx = true;\n            }\n\n            if (hasTx && hasRx && !_showEvents) {\n                _out.write(\"<a href=\\\"viewstat?stat=bw.combined\"\n                           + \"&amp;periodCount=\" + (3 * _periodCount )\n                           + \"&amp;width=\" + (3 * _width)\n                           + \"&amp;height=\" + (3 * _height)\n                           + \"\\\">\");\n                String title = _(\"Combined bandwidth graph\");\n                _out.write(\"<img class=\\\"statimage\\\"\"\n                           + \" src=\\\"viewstat.jsp?stat=bw.combined\"\n                           + \"&amp;periodCount=\" + _periodCount \n                           + \"&amp;width=\" + _width\n                           + \"&amp;height=\" + (_height - 13)\n                           + \"\\\" alt=\\\"\" + title + \"\\\" title=\\\"\" + title + \"\\\"><\/a>\\n\");\n            }\n            \n            for (Iterator iter = ordered.iterator(); iter.hasNext(); ) {\n                SummaryListener lsnr = (SummaryListener)iter.next();\n                Rate r = lsnr.getRate();\n                // e.g. \"statname for 60m\"\n                String title = _(\"{0} for {1}\", r.getRateStat().getName(), DataHelper.formatDuration2(_periodCount * r.getPeriod()));\n                _out.write(\"<a href=\\\"graph?stat=\"\n                           + r.getRateStat().getName() \n                           + '.' + r.getPeriod() \n                           + \"&amp;c=\" + (3 * _periodCount)\n                           + \"&amp;w=\" + (3 * _width)\n                           + \"&amp;h=\" + (3 * _height)\n                           + (_showEvents ? \"&amp;showEvents=1\" : \"\")\n                           + \"\\\">\");\n                _out.write(\"<img class=\\\"statimage\\\" border=\\\"0\\\"\"\n                           + \" src=\\\"viewstat.jsp?stat=\"\n                           + r.getRateStat().getName() \n                           + \"&amp;showEvents=\" + _showEvents\n                           + \"&amp;period=\" + r.getPeriod() \n                           + \"&amp;periodCount=\" + _periodCount \n                           + \"&amp;width=\" + _width\n                           + \"&amp;height=\" + _height\n                           + \"\\\" alt=\\\"\" + title \n                           + \"\\\" title=\\\"\" + title + \"\\\"><\/a>\\n\");\n            }\n\n            // FIXME jrobin doesn't support setting the timezone, will have to mod TimeAxis.java\n            // 0.9.1 - all graphs currently state UTC on them, so this text blurb is unnecessary,\n            //_out.write(\"<p><i>\" + _(\"All times are UTC.\") + \"<\/i><\/p>\\n\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        return \"\"; \n    }","id":43897,"modified_method":"public String getImages() { \n        if (StatSummarizer.isDisabled())\n            return \"\";\n        try {\n            List listeners = StatSummarizer.instance().getListeners();\n            TreeSet ordered = new TreeSet(new AlphaComparator());\n            ordered.addAll(listeners);\n\n            // go to some trouble to see if we have the data for the combined bw graph\n            boolean hasTx = false;\n            boolean hasRx = false;\n            for (Iterator iter = ordered.iterator(); iter.hasNext(); ) {\n                SummaryListener lsnr = (SummaryListener)iter.next();\n                String title = lsnr.getRate().getRateStat().getName();\n                if (title.equals(\"bw.sendRate\")) hasTx = true;\n                else if (title.equals(\"bw.recvRate\")) hasRx = true;\n            }\n\n            if (hasTx && hasRx && !_showEvents) {\n                _out.write(\"<a href=\\\"graph?stat=bw.combined\"\n                           + \"&amp;c=\" + (3 * _periodCount )\n                           + \"&amp;w=\" + (3 * _width)\n                           + \"&amp;h=\" + (3 * _height)\n                           + \"\\\">\");\n                String title = _(\"Combined bandwidth graph\");\n                _out.write(\"<img class=\\\"statimage\\\"\"\n                           + \" src=\\\"viewstat.jsp?stat=bw.combined\"\n                           + \"&amp;periodCount=\" + _periodCount \n                           + \"&amp;width=\" + _width\n                           + \"&amp;height=\" + (_height - 13)\n                           + \"\\\" alt=\\\"\" + title + \"\\\" title=\\\"\" + title + \"\\\"><\/a>\\n\");\n            }\n            \n            for (Iterator iter = ordered.iterator(); iter.hasNext(); ) {\n                SummaryListener lsnr = (SummaryListener)iter.next();\n                Rate r = lsnr.getRate();\n                // e.g. \"statname for 60m\"\n                String title = _(\"{0} for {1}\", r.getRateStat().getName(), DataHelper.formatDuration2(_periodCount * r.getPeriod()));\n                _out.write(\"<a href=\\\"graph?stat=\"\n                           + r.getRateStat().getName() \n                           + '.' + r.getPeriod() \n                           + \"&amp;c=\" + (3 * _periodCount)\n                           + \"&amp;w=\" + (3 * _width)\n                           + \"&amp;h=\" + (3 * _height)\n                           + (_showEvents ? \"&amp;showEvents=1\" : \"\")\n                           + \"\\\">\");\n                _out.write(\"<img class=\\\"statimage\\\" border=\\\"0\\\"\"\n                           + \" src=\\\"viewstat.jsp?stat=\"\n                           + r.getRateStat().getName() \n                           + \"&amp;showEvents=\" + _showEvents\n                           + \"&amp;period=\" + r.getPeriod() \n                           + \"&amp;periodCount=\" + _periodCount \n                           + \"&amp;width=\" + _width\n                           + \"&amp;height=\" + _height\n                           + \"\\\" alt=\\\"\" + title \n                           + \"\\\" title=\\\"\" + title + \"\\\"><\/a>\\n\");\n            }\n\n            // FIXME jrobin doesn't support setting the timezone, will have to mod TimeAxis.java\n            // 0.9.1 - all graphs currently state UTC on them, so this text blurb is unnecessary,\n            //_out.write(\"<p><i>\" + _(\"All times are UTC.\") + \"<\/i><\/p>\\n\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        return \"\"; \n    }","commit_id":"21e47e61f01e24796257076f8d98b43a6e37258d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  This does the two-data bandwidth graph only.\n     *  For all other graphs see SummaryRenderer\n     *  Synchronized to conserve memory.\n     *  @return success\n     */\n    public boolean renderRatePng(OutputStream out, int width, int height, boolean hideLegend,\n                                              boolean hideGrid, boolean hideTitle, boolean showEvents,\n                                              int periodCount, boolean showCredit) throws IOException {\n        try {\n            try {\n                _sem.acquire();\n            } catch (InterruptedException ie) {}\n            return locked_renderRatePng(out, width, height, hideLegend, hideGrid, hideTitle, showEvents,\n                                        periodCount, showCredit);\n        } finally {\n            _sem.release();\n        }\n    }","id":43898,"modified_method":"/**\n     *  This does the two-data bandwidth graph only.\n     *  For all other graphs see renderPng() above.\n     *  Synchronized to conserve memory.\n     *\n     *  @param end number of periods before now\n     *  @return success\n     */\n    public boolean renderRatePng(OutputStream out, int width, int height, boolean hideLegend,\n                                              boolean hideGrid, boolean hideTitle, boolean showEvents,\n                                              int periodCount, int end, boolean showCredit) throws IOException {\n        try {\n            try {\n                _sem.acquire();\n            } catch (InterruptedException ie) {}\n            return locked_renderRatePng(out, width, height, hideLegend, hideGrid, hideTitle, showEvents,\n                                        periodCount, end, showCredit);\n        } finally {\n            _sem.release();\n        }\n    }","commit_id":"21e47e61f01e24796257076f8d98b43a6e37258d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private boolean locked_getXML(Rate rate, OutputStream out) throws IOException {\n        for (SummaryListener lsnr : _listeners) {\n            if (lsnr.getRate().equals(rate)) {\n                lsnr.getData().exportXml(out);\n                out.write((\"<!-- Rate: \" + lsnr.getRate().getRateStat().getName() + \" for period \" + lsnr.getRate().getPeriod() + \" -->\\n\").getBytes());\n                out.write((\"<!-- Average data soure name: \" + lsnr.getName() + \" event count data source name: \" + lsnr.getEventName() + \" -->\\n\").getBytes());\n                return true;\n            }\n        }\n        return false;\n    }","id":43899,"modified_method":"private boolean locked_getXML(Rate rate, OutputStream out) throws IOException {\n        for (SummaryListener lsnr : _listeners) {\n            if (lsnr.getRate().equals(rate)) {\n                lsnr.getData().exportXml(out);\n                out.write((\"<!-- Rate: \" + lsnr.getRate().getRateStat().getName() + \" for period \" + lsnr.getRate().getPeriod() + \" -->\\n\").getBytes());\n                out.write((\"<!-- Average data source name: \" + lsnr.getName() + \" event count data source name: \" + lsnr.getEventName() + \" -->\\n\").getBytes());\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"21e47e61f01e24796257076f8d98b43a6e37258d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private boolean locked_renderRatePng(OutputStream out, int width, int height, boolean hideLegend,\n                                              boolean hideGrid, boolean hideTitle, boolean showEvents,\n                                              int periodCount, boolean showCredit) throws IOException {\n\n        // go to some trouble to see if we have the data for the combined bw graph\n        SummaryListener txLsnr = null;\n        SummaryListener rxLsnr = null;\n        for (SummaryListener lsnr : StatSummarizer.instance().getListeners()) {\n            String title = lsnr.getRate().getRateStat().getName();\n            if (title.equals(\"bw.sendRate\"))\n                txLsnr = lsnr;\n            else if (title.equals(\"bw.recvRate\"))\n                rxLsnr = lsnr;\n        }\n        if (txLsnr == null || rxLsnr == null)\n            throw new IOException(\"no rates for combined graph\");\n\n        long end = _context.clock().now() - 75*1000;\n        if (width > GraphHelper.MAX_X)\n            width = GraphHelper.MAX_X;\n        else if (width <= 0)\n            width = GraphHelper.DEFAULT_X;\n        if (height > GraphHelper.MAX_Y)\n            height = GraphHelper.MAX_Y;\n        else if (height <= 0)\n            height = GraphHelper.DEFAULT_Y;\n        if (periodCount <= 0 || periodCount > txLsnr.getRows())\n            periodCount = txLsnr.getRows();\n        long period = 60*1000;\n        long start = end - period*periodCount;\n        //long begin = System.currentTimeMillis();\n        ImageOutputStream ios = null;\n        try {\n            RrdGraphDef def = new RrdGraphDef();\n            def.setTimeSpan(start/1000, end/1000);\n            def.setMinValue(0d);\n            def.setBase(1024);\n            String title = _(\"Bandwidth usage\");\n            if (!hideTitle)\n                def.setTitle(title);\n            long started = _context.router().getWhenStarted();\n            if (started > start && started < end)\n                def.vrule(started / 1000, SummaryRenderer.RESTART_BAR_COLOR, null, 4.0f);  // no room for legend\n            String sendName = SummaryListener.createName(_context, \"bw.sendRate.60000\");\n            String recvName = SummaryListener.createName(_context, \"bw.recvRate.60000\");\n            def.datasource(sendName, txLsnr.getData().getPath(), sendName, SummaryListener.CF, txLsnr.getBackendName());\n            def.datasource(recvName, rxLsnr.getData().getPath(), recvName, SummaryListener.CF, rxLsnr.getBackendName());\n            def.area(sendName, Color.BLUE, _(\"Outbound Bytes/sec\"));\n            //def.line(sendName, Color.BLUE, \"Outbound bytes/sec\", 3);\n            def.line(recvName, Color.RED, _(\"Inbound Bytes/sec\") + \"\\\\r\", 3);\n            //def.area(recvName, Color.RED, \"Inbound bytes/sec@r\");\n            if (!hideLegend) {\n                def.gprint(sendName, SummaryListener.CF, _(\"Out average\") + \": %.2f %s\" + _(\"Bps\"));\n                def.gprint(sendName, \"MAX\", ' ' + _(\"max\") + \": %.2f %S\" + _(\"Bps\") + \"\\\\r\");\n                def.gprint(recvName, SummaryListener.CF, _(\"In average\") + \": %.2f %S\" + _(\"Bps\"));\n                def.gprint(recvName, \"MAX\", ' ' + _(\"max\") + \": %.2f %S\" + _(\"Bps\") + \"\\\\r\");\n                // '07-Jul 21:09 UTC' with month name in the system locale\n                SimpleDateFormat sdf = new SimpleDateFormat(\"dd-MMM HH:mm\");\n                def.comment(sdf.format(new Date(start)) + \" -- \" + sdf.format(new Date(end)) + \" UTC\\\\r\");\n            }\n            if (!showCredit)\n                def.setShowSignature(false);\n            if (hideLegend) \n                def.setNoLegend(true);\n            if (hideGrid) {\n                def.setDrawXGrid(false);\n                def.setDrawYGrid(false);\n            }\n            //System.out.println(\"rendering: path=\" + path + \" dsNames[0]=\" + dsNames[0] + \" dsNames[1]=\" + dsNames[1] + \" lsnr.getName=\" + _listener.getName());\n            def.setAntiAliasing(false);\n            //System.out.println(\"Rendering: \\n\" + def.exportXmlTemplate());\n            //System.out.println(\"*****************\\nData: \\n\" + _listener.getData().dump());\n            def.setWidth(width);\n            def.setHeight(height);\n            def.setImageFormat(\"PNG\");\n            def.setLazy(true);\n\n            RrdGraph graph = new RrdGraph(def);\n            //System.out.println(\"Graph created\");\n            int totalWidth = graph.getRrdGraphInfo().getWidth();\n            int totalHeight = graph.getRrdGraphInfo().getHeight();\n            BufferedImage img = new BufferedImage(totalWidth, totalHeight, BufferedImage.TYPE_USHORT_565_RGB);\n            Graphics gfx = img.getGraphics();\n            graph.render(gfx);\n            ios = new MemoryCacheImageOutputStream(out);\n            ImageIO.write(img, \"png\", ios);\n\n            //File t = File.createTempFile(\"jrobinData\", \".xml\");\n            //_listener.getData().dumpXml(new FileOutputStream(t));\n            //System.out.println(\"plotted: \" + (data != null ? data.length : 0) + \" bytes in \" + timeToPlot\n            //                   ); // + \", data written to \" + t.getAbsolutePath());\n            return true;\n        } catch (RrdException re) {\n            _log.error(\"Error rendering\", re);\n            throw new IOException(\"Error plotting: \" + re.getMessage());\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Error rendering\", ioe);\n            throw ioe;\n        } catch (OutOfMemoryError oom) {\n            _log.error(\"Error rendering\", oom);\n            throw new IOException(\"Error plotting: \" + oom.getMessage());\n        } finally {\n            // this does not close the underlying stream\n            if (ios != null) try {ios.close();} catch (IOException ioe) {}\n        }\n    }","id":43900,"modified_method":"private boolean locked_renderRatePng(OutputStream out, int width, int height, boolean hideLegend,\n                                              boolean hideGrid, boolean hideTitle, boolean showEvents,\n                                              int periodCount, int end, boolean showCredit) throws IOException {\n\n        // go to some trouble to see if we have the data for the combined bw graph\n        SummaryListener txLsnr = null;\n        SummaryListener rxLsnr = null;\n        for (SummaryListener lsnr : StatSummarizer.instance().getListeners()) {\n            String title = lsnr.getRate().getRateStat().getName();\n            if (title.equals(\"bw.sendRate\"))\n                txLsnr = lsnr;\n            else if (title.equals(\"bw.recvRate\"))\n                rxLsnr = lsnr;\n        }\n        if (txLsnr == null || rxLsnr == null)\n            throw new IOException(\"no rates for combined graph\");\n\n        if (width > GraphHelper.MAX_X)\n            width = GraphHelper.MAX_X;\n        else if (width <= 0)\n            width = GraphHelper.DEFAULT_X;\n        if (height > GraphHelper.MAX_Y)\n            height = GraphHelper.MAX_Y;\n        else if (height <= 0)\n            height = GraphHelper.DEFAULT_Y;\n        txLsnr.renderPng(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount,\n                         end, showCredit, rxLsnr, _(\"Bandwidth usage\"));\n        return true;\n    }","commit_id":"21e47e61f01e24796257076f8d98b43a6e37258d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  @param end number of periods before now\n     */\n    public void renderPng(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,\n                          boolean hideTitle, boolean showEvents, int periodCount,\n                          int end, boolean showCredit) throws IOException {\n        if (_renderer == null || _db == null)\n            throw new IOException(\"No RRD, check logs for previous errors\");\n        _renderer.render(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount, end, showCredit); \n    }","id":43901,"modified_method":"/**\n     *  Single graph.\n     *\n     *  @param end number of periods before now\n     */\n    public void renderPng(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,\n                          boolean hideTitle, boolean showEvents, int periodCount,\n                          int end, boolean showCredit) throws IOException {\n        renderPng(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount,\n                  end, showCredit, null, null); \n    }","commit_id":"21e47e61f01e24796257076f8d98b43a6e37258d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Render the stats as determined by the specified JRobin xml config,\n     * but note that this doesn't work on stock jvms, as it requires \n     * DOM level 3 load and store support.  Perhaps we can bundle that, or\n     * specify who can get it from where, etc.\n     *\n     * @deprecated unsed\n     */\n    public static synchronized void render(I2PAppContext ctx, OutputStream out, String filename) throws IOException {\n        long end = ctx.clock().now() - 60*1000;\n        long start = end - 60*1000*SummaryListener.PERIODS;\n        try {\n            RrdGraphDefTemplate template = new RrdGraphDefTemplate(filename);\n            RrdGraphDef def = template.getRrdGraphDef();\n            def.setTimeSpan(start/1000, end/1000); // ignore the periods in the template\n            // FIXME not clear how to get the height and width from the template\n            int width = GraphHelper.DEFAULT_X;\n            int height = GraphHelper.DEFAULT_Y;\n            def.setWidth(width);\n            def.setHeight(height);\n\n            RrdGraph graph = new RrdGraph(def);\n            int totalWidth = graph.getRrdGraphInfo().getWidth();\n            int totalHeight = graph.getRrdGraphInfo().getHeight();\n            BufferedImage img = new BufferedImage(totalWidth, totalHeight, BufferedImage.TYPE_USHORT_565_RGB);\n            Graphics gfx = img.getGraphics();\n            graph.render(gfx);\n            ImageOutputStream ios = new MemoryCacheImageOutputStream(out);\n            ImageIO.write(img, \"png\", ios);\n        } catch (RrdException re) {\n            //_log.error(\"Error rendering \" + filename, re);\n            throw new IOException(\"Error plotting: \" + re.getMessage());\n        } catch (IOException ioe) {\n            //_log.error(\"Error rendering \" + filename, ioe);\n            throw ioe;\n        }\n    }","id":43902,"modified_method":"/**\n     * Render the stats as determined by the specified JRobin xml config,\n     * but note that this doesn't work on stock jvms, as it requires \n     * DOM level 3 load and store support.  Perhaps we can bundle that, or\n     * specify who can get it from where, etc.\n     *\n     * @deprecated unsed\n     * @throws UnsupportedOperationException always\n     */\n    public static synchronized void render(I2PAppContext ctx, OutputStream out, String filename) throws IOException {\n        throw new UnsupportedOperationException();\n/*****\n        long end = ctx.clock().now() - 60*1000;\n        long start = end - 60*1000*SummaryListener.PERIODS;\n        try {\n            RrdGraphDefTemplate template = new RrdGraphDefTemplate(filename);\n            RrdGraphDef def = template.getRrdGraphDef();\n            def.setTimeSpan(start/1000, end/1000); // ignore the periods in the template\n            // FIXME not clear how to get the height and width from the template\n            int width = GraphHelper.DEFAULT_X;\n            int height = GraphHelper.DEFAULT_Y;\n            def.setWidth(width);\n            def.setHeight(height);\n\n            RrdGraph graph = new RrdGraph(def);\n            int totalWidth = graph.getRrdGraphInfo().getWidth();\n            int totalHeight = graph.getRrdGraphInfo().getHeight();\n            BufferedImage img = new BufferedImage(totalWidth, totalHeight, BufferedImage.TYPE_USHORT_565_RGB);\n            Graphics gfx = img.getGraphics();\n            graph.render(gfx);\n            ImageOutputStream ios = new MemoryCacheImageOutputStream(out);\n            ImageIO.write(img, \"png\", ios);\n        } catch (RrdException re) {\n            //_log.error(\"Error rendering \" + filename, re);\n            throw new IOException(\"Error plotting: \" + re.getMessage());\n        } catch (IOException ioe) {\n            //_log.error(\"Error rendering \" + filename, ioe);\n            throw ioe;\n        }\n*****/\n    }","commit_id":"21e47e61f01e24796257076f8d98b43a6e37258d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  @param endp number of periods before now\n     */\n    public void render(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,\n                       boolean hideTitle, boolean showEvents, int periodCount,\n                       int endp, boolean showCredit) throws IOException {\n        long end = _listener.now() - 75*1000;\n        long period = _listener.getRate().getPeriod();\n        if (endp > 0)\n            end -= period * endp;\n        if (periodCount <= 0 || periodCount > _listener.getRows())\n            periodCount = _listener.getRows();\n        long start = end - (period * periodCount);\n        //long begin = System.currentTimeMillis();\n        ImageOutputStream ios = null;\n        try {\n            RrdGraphDef def = new RrdGraphDef();\n            def.setTimeSpan(start/1000, end/1000);\n            def.setMinValue(0d);\n            String name = _listener.getRate().getRateStat().getName();\n            // heuristic to set K=1024\n            if ((name.startsWith(\"bw.\") || name.indexOf(\"Size\") >= 0 || name.indexOf(\"Bps\") >= 0 || name.indexOf(\"memory\") >= 0)\n                && !showEvents)\n                def.setBase(1024);\n            if (!hideTitle) {\n                String title;\n                String p;\n                // we want the formatting and translation of formatDuration2(), except not zh, and not the &nbsp;\n                if (IS_WIN && \"zh\".equals(Messages.getLanguage(_context)))\n                    p = DataHelper.formatDuration(period);\n                else\n                    p = DataHelper.formatDuration2(period).replace(\"&nbsp;\", \" \");\n                if (showEvents)\n                    title = name + ' ' + _(\"events in {0}\", p);\n                else\n                    title = name + ' ' + _(\"averaged for {0}\", p);\n                def.setTitle(title);\n            }\n            String path = _listener.getData().getPath();\n            String dsNames[] = _listener.getData().getDsNames();\n            String plotName = null;\n            String descr = null;\n            if (showEvents) {\n                // include the average event count on the plot\n                plotName = dsNames[1];\n                descr = _(\"Events per period\");\n            } else {\n                // include the average value\n                plotName = dsNames[0];\n                // The descriptions are not tagged in the createRateStat calls\n                // (there are over 500 of them)\n                // but the descriptions for the default graphs are tagged in\n                // Strings.java\n                descr = _(_listener.getRate().getRateStat().getDescription());\n            }\n\n            //long started = ((RouterContext)_context).router().getWhenStarted();\n            //if (started > start && started < end)\n            //    def.vrule(started / 1000, RESTART_BAR_COLOR, _(\"Restart\"), 4.0f);\n\n            def.datasource(plotName, path, plotName, SummaryListener.CF, _listener.getBackendName());\n            if (descr.length() > 0)\n                def.area(plotName, Color.BLUE, descr + \"\\\\r\");\n            else\n                def.area(plotName, Color.BLUE);\n            if (!hideLegend) {\n                def.gprint(plotName, SummaryListener.CF, _(\"avg\") + \": %.2f %s\");\n                def.gprint(plotName, \"MAX\", ' ' + _(\"max\") + \": %.2f %S\");\n                def.gprint(plotName, \"LAST\", ' ' + _(\"now\") + \": %.2f %S\\\\r\");\n                // '07-Jul 21:09 UTC' with month name in the system locale\n                SimpleDateFormat sdf = new SimpleDateFormat(\"dd-MMM HH:mm\");\n                Map<Long, String> events = ((RouterContext)_context).router().eventLog().getEvents(EventLog.STARTED, start);\n                for (Map.Entry<Long, String> event : events.entrySet()) {\n                    long started = event.getKey().longValue();\n                    if (started > start && started < end) {\n                        String legend = _(\"Restart\") + ' ' + sdf.format(new Date(started)) + \" UTC \" + event.getValue() + \"\\\\r\";\n                        def.vrule(started / 1000, RESTART_BAR_COLOR, legend, 4.0f);\n                    }\n                }\n                def.comment(sdf.format(new Date(start)) + \" -- \" + sdf.format(new Date(end)) + \" UTC\\\\r\");\n            }\n            if (!showCredit)\n                def.setShowSignature(false);\n            /*\n            // these four lines set up a graph plotting both values and events on the same chart\n            // (but with the same coordinates, so the values may look pretty skewed)\n                def.datasource(dsNames[0], path, dsNames[0], \"AVERAGE\", \"MEMORY\");\n                def.datasource(dsNames[1], path, dsNames[1], \"AVERAGE\", \"MEMORY\");\n                def.area(dsNames[0], Color.BLUE, _listener.getRate().getRateStat().getDescription());\n                def.line(dsNames[1], Color.RED, \"Events per period\");\n            */\n            if (hideLegend) \n                def.setNoLegend(true);\n            if (hideGrid) {\n                def.setDrawXGrid(false);\n                def.setDrawYGrid(false);\n            }\n            //System.out.println(\"rendering: path=\" + path + \" dsNames[0]=\" + dsNames[0] + \" dsNames[1]=\" + dsNames[1] + \" lsnr.getName=\" + _listener.getName());\n            def.setAntiAliasing(false);\n            //System.out.println(\"Rendering: \\n\" + def.exportXmlTemplate());\n            //System.out.println(\"*****************\\nData: \\n\" + _listener.getData().dump());\n            def.setWidth(width);\n            def.setHeight(height);\n            def.setImageFormat(\"PNG\");\n            def.setLazy(true);\n\n            RrdGraph graph = new RrdGraph(def);\n            int totalWidth = graph.getRrdGraphInfo().getWidth();\n            int totalHeight = graph.getRrdGraphInfo().getHeight();\n            BufferedImage img = new BufferedImage(totalWidth, totalHeight, BufferedImage.TYPE_USHORT_565_RGB);\n            Graphics gfx = img.getGraphics();\n            graph.render(gfx);\n            ios = new MemoryCacheImageOutputStream(out);\n            ImageIO.write(img, \"png\", ios);\n            //System.out.println(\"Graph created\");\n\n            //File t = File.createTempFile(\"jrobinData\", \".xml\");\n            //_listener.getData().dumpXml(new FileOutputStream(t));\n            //System.out.println(\"plotted: \" + (data != null ? data.length : 0) + \" bytes in \" + timeToPlot\n            //                   ); // + \", data written to \" + t.getAbsolutePath());\n        } catch (RrdException re) {\n            _log.error(\"Error rendering\", re);\n            throw new IOException(\"Error plotting: \" + re.getMessage());\n        } catch (IOException ioe) {\n            // typically org.mortbay.jetty.EofException extends java.io.EOFException\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Error rendering\", ioe);\n            throw ioe;\n        } catch (OutOfMemoryError oom) {\n            _log.error(\"Error rendering\", oom);\n            throw new IOException(\"Error plotting: \" + oom.getMessage());\n        } finally {\n            // this does not close the underlying stream\n            if (ios != null) try {ios.close();} catch (IOException ioe) {}\n        }\n    }","id":43903,"modified_method":"/**\n     *  Single graph.\n     *\n     *  @param endp number of periods before now\n     */\n    public void render(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,\n                       boolean hideTitle, boolean showEvents, int periodCount,\n                       int endp, boolean showCredit) throws IOException {\n        render(out, width, height, hideLegend, hideGrid, hideTitle,\n               showEvents, periodCount, endp, showCredit, null, null);\n    }","commit_id":"21e47e61f01e24796257076f8d98b43a6e37258d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void traverseNodes(final DefaultMutableTreeNode root, List<TreePath> pathsToExpand, List<TreePath> toSelect) {\n    final Object userObject = root.getUserObject();\n    final TreeNode[] rootPath = root.getPath();\n    if (userObject instanceof Descriptor) {\n      final String displayName = ((Descriptor)userObject).getText();\n      if (mySelectedNodes.contains(displayName)) {\n        toSelect.add(new TreePath(rootPath));\n      }\n      if (myExpandedNodes.contains(displayName)) {\n        pathsToExpand.add(new TreePath(rootPath));\n      }\n    }\n    else if (userObject instanceof String){\n      final String str = (String)userObject;\n      if (mySelectedNodes.contains(str)) {\n        toSelect.add(new TreePath(rootPath));\n      }\n      if (myExpandedNodes.contains(str)) {\n        pathsToExpand.add(new TreePath(rootPath));\n      }\n      for (int i = 0; i < root.getChildCount(); i++) {\n        traverseNodes((DefaultMutableTreeNode)root.getChildAt(i), pathsToExpand, toSelect);\n      }\n    }\n  }","id":43904,"modified_method":"private void traverseNodes(final DefaultMutableTreeNode root, List<TreePath> pathsToExpand, List<TreePath> toSelect) {\n    final Object userObject = root.getUserObject();\n    final TreeNode[] rootPath = root.getPath();\n    if (userObject instanceof Descriptor) {\n      final String shortName = ((Descriptor)userObject).getKey().toString();\n      if (mySelectedNodes.contains(shortName)) {\n        toSelect.add(new TreePath(rootPath));\n      }\n      if (myExpandedNodes.contains(shortName)) {\n        pathsToExpand.add(new TreePath(rootPath));\n      }\n    }\n    else if (userObject instanceof String){\n      final String str = (String)userObject;\n      if (mySelectedNodes.contains(str)) {\n        toSelect.add(new TreePath(rootPath));\n      }\n      if (myExpandedNodes.contains(str)) {\n        pathsToExpand.add(new TreePath(rootPath));\n      }\n      for (int i = 0; i < root.getChildCount(); i++) {\n        traverseNodes((DefaultMutableTreeNode)root.getChildAt(i), pathsToExpand, toSelect);\n      }\n    }\n  }","commit_id":"5ae28ca5c8baee52190ccf57c53d3f7b8a540085","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void saveVisibleState(Tree tree) {\n    myExpandedNodes.clear();\n    final DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode)tree.getModel().getRoot();\n    Enumeration<TreePath> expanded = tree.getExpandedDescendants(new TreePath(rootNode.getPath()));\n    if (expanded != null) {\n      while (expanded.hasMoreElements()) {\n        final TreePath treePath = expanded.nextElement();\n        final DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n        String expandedNode;\n        if (node.getUserObject() instanceof Descriptor) {\n          expandedNode = ((Descriptor)node.getUserObject()).getText();\n        }\n        else {\n          expandedNode = (String)node.getUserObject();\n        }\n        myExpandedNodes.add(expandedNode);\n      }\n    }\n    mySelectedNodes.clear();\n    final TreePath[] selectionPaths = tree.getSelectionPaths();\n    for (int i = 0; selectionPaths != null && i < selectionPaths.length; i++) {\n      final DefaultMutableTreeNode node = (DefaultMutableTreeNode)selectionPaths[i].getLastPathComponent();\n      String selectedNode;\n      if (node.getUserObject() instanceof Descriptor) {\n        selectedNode = ((Descriptor)node.getUserObject()).getText();\n      }\n      else {\n        selectedNode = (String)node.getUserObject();\n      }\n      mySelectedNodes.add(selectedNode);\n    }\n  }","id":43905,"modified_method":"public void saveVisibleState(Tree tree) {\n    myExpandedNodes.clear();\n    final DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode)tree.getModel().getRoot();\n    Enumeration<TreePath> expanded = tree.getExpandedDescendants(new TreePath(rootNode.getPath()));\n    if (expanded != null) {\n      while (expanded.hasMoreElements()) {\n        final TreePath treePath = expanded.nextElement();\n        final DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n        String expandedNode;\n        if (node.getUserObject() instanceof Descriptor) {\n          expandedNode = ((Descriptor)node.getUserObject()).getKey().toString();\n        }\n        else {\n          expandedNode = (String)node.getUserObject();\n        }\n        myExpandedNodes.add(expandedNode);\n      }\n    }\n    mySelectedNodes.clear();\n    final TreePath[] selectionPaths = tree.getSelectionPaths();\n    for (int i = 0; selectionPaths != null && i < selectionPaths.length; i++) {\n      final DefaultMutableTreeNode node = (DefaultMutableTreeNode)selectionPaths[i].getLastPathComponent();\n      String selectedNode;\n      if (node.getUserObject() instanceof Descriptor) {\n        selectedNode = ((Descriptor)node.getUserObject()).getKey().toString();\n      }\n      else {\n        selectedNode = (String)node.getUserObject();\n      }\n      mySelectedNodes.add(selectedNode);\n    }\n  }","commit_id":"5ae28ca5c8baee52190ccf57c53d3f7b8a540085","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Parses the given http response.\n     * @param response the http response to parse\n     * @return the new account\n     */\n    private NewAccount parseHttpResponse(String response)\n    {\n        NewAccount newAccount = null;\n        try\n        {\n            JSONObject jsonObject = new JSONObject(response);\n            boolean isSuccess = jsonObject.getBoolean(\"success\");\n\n            if (isSuccess)\n            {\n                newAccount = new NewAccount(\n                    usernameField.getText() + \"@ippi.fr\",\n                    passField.getPassword(),\n                    null,\n                    \"ippi.fr\");\n            }\n            else\n            {\n                showErrorMessage(jsonObject.getString(\"error_message\"));\n            }\n        }\n        catch (JSONException e1)\n        {\n            if (logger.isInfoEnabled())\n                logger.info(\"Failed Json parsing.\", e1);\n        }\n\n        return newAccount;\n    }","id":43906,"modified_method":"/**\n     * Parses the given http response.\n     * @param response the http response to parse\n     * @return the new account\n     */\n    private NewAccount parseHttpResponse(String response)\n    {\n        NewAccount newAccount = null;\n        try\n        {\n            JSONObject jsonObject = (JSONObject)JSONValue\n                .parseWithException(response);\n            boolean isSuccess = (Boolean)jsonObject.get(\"success\");\n\n            if (isSuccess)\n            {\n                newAccount = new NewAccount(\n                    usernameField.getText() + \"@ippi.fr\",\n                    passField.getPassword(),\n                    null,\n                    \"ippi.fr\");\n            }\n            else\n            {\n                showErrorMessage((String)jsonObject.get(\"error_message\"));\n            }\n        }\n        catch (Throwable e1)\n        {\n            if (logger.isInfoEnabled())\n                logger.info(\"Failed Json parsing.\", e1);\n        }\n\n        return newAccount;\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Parses the given http response.\n     * @param response the http response to parse\n     * @return the new account\n     */\n    private NewAccount parseHttpResponse(String response)\n    {\n        NewAccount newAccount = null;\n        try\n        {\n            JSONObject jsonObject = new JSONObject(response);\n            boolean isSuccess = jsonObject.getBoolean(\"success\");\n\n            if (isSuccess)\n            {\n                newAccount = new NewAccount(\n                    jsonObject.getString(\"sip_address\"),\n                    passField.getPassword(),\n                    null,\n                    jsonObject.getString(\"outbound_proxy\"));\n\n                String xcapRoot = jsonObject.getString(\"xcap_root\");\n\n                // as sip2sip adds @sip2sip.info at the end of the\n                // xcap_uri but doesn't report it in resullt after\n                // creating account, we add it\n                String domain = null;\n                int delimIndex = newAccount.getUserName().indexOf(\"@\");\n                if (delimIndex != -1)\n                {\n                    domain = newAccount.getUserName().substring(delimIndex);\n                }\n                if(domain != null)\n                {\n                    if(xcapRoot.endsWith(\"/\"))\n                        xcapRoot =\n                            xcapRoot.substring(0, xcapRoot.length() - 1)\n                            + domain;\n                    else\n                        xcapRoot += domain;\n                }\n\n                newAccount.setXcapRoot(xcapRoot);\n            }\n            else\n            {\n                showErrorMessage(jsonObject.getString(\"error_message\"));\n            }\n        }\n        catch (JSONException e1)\n        {\n            if (logger.isInfoEnabled())\n                logger.info(\"Failed Json parsing.\", e1);\n        }\n\n        return newAccount;\n    }","id":43907,"modified_method":"/**\n     * Parses the given http response.\n     * @param response the http response to parse\n     * @return the new account\n     */\n    private NewAccount parseHttpResponse(String response)\n    {\n        NewAccount newAccount = null;\n        try\n        {\n            JSONObject jsonObject = (JSONObject)JSONValue\n                .parseWithException(response);\n            boolean isSuccess = (Boolean)jsonObject.get(\"success\");\n\n            if (isSuccess)\n            {\n                newAccount = new NewAccount(\n                    (String)jsonObject.get(\"sip_address\"),\n                    passField.getPassword(),\n                    null,\n                    (String)jsonObject.get(\"outbound_proxy\"));\n\n                String xcapRoot = (String)jsonObject.get(\"xcap_root\");\n\n                // as sip2sip adds @sip2sip.info at the end of the\n                // xcap_uri but doesn't report it in resullt after\n                // creating account, we add it\n                String domain = null;\n                int delimIndex = newAccount.getUserName().indexOf(\"@\");\n                if (delimIndex != -1)\n                {\n                    domain = newAccount.getUserName().substring(delimIndex);\n                }\n                if(domain != null)\n                {\n                    if(xcapRoot.endsWith(\"/\"))\n                        xcapRoot =\n                            xcapRoot.substring(0, xcapRoot.length() - 1)\n                            + domain;\n                    else\n                        xcapRoot += domain;\n                }\n\n                newAccount.setXcapRoot(xcapRoot);\n            }\n            else\n            {\n                showErrorMessage((String)jsonObject.get(\"error_message\"));\n            }\n        }\n        catch (Throwable e1)\n        {\n            if (logger.isInfoEnabled())\n                logger.info(\"Failed Json parsing.\", e1);\n        }\n\n        return newAccount;\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Replaces the Blip.tv video links with their corresponding thumbnails.\n     *\n     * @param sourceString the original chat message.\n     * @return replaced thumbnail image link; the original video link in case of\n     *         no match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        try\n        {\n            String url = \"http://oohembed.com/oohembed/?url=\" + sourceString;\n\n            URL sourceURL = new URL(url);\n            URLConnection conn = sourceURL.openConnection();\n\n            BufferedReader in =\n                new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\n            String inputLine, holder = \"\";\n\n            while ((inputLine = in.readLine()) != null)\n                holder += inputLine;\n            in.close();\n\n            JSONObject wrapper = new JSONObject(holder);\n\n            String thumbUrl = wrapper.getString(\"thumbnail_url\");\n\n            if (thumbUrl != null)\n            {\n                return thumbUrl;\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n\n        return sourceString;\n    }","id":43908,"modified_method":"/**\n     * Replaces the Blip.tv video links with their corresponding thumbnails.\n     *\n     * @param sourceString the original chat message.\n     * @return replaced thumbnail image link; the original video link in case of\n     *         no match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        try\n        {\n            String url = \"http://oohembed.com/oohembed/?url=\" + sourceString;\n\n            URL sourceURL = new URL(url);\n            URLConnection conn = sourceURL.openConnection();\n\n            BufferedReader in =\n                new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\n            String inputLine, holder = \"\";\n\n            while ((inputLine = in.readLine()) != null)\n                holder += inputLine;\n            in.close();\n\n            JSONObject wrapper = (JSONObject)JSONValue\n                .parseWithException(holder);\n\n            String thumbUrl = (String)wrapper.get(\"thumbnail_url\");\n\n            if (thumbUrl != null)\n            {\n                return thumbUrl;\n            }\n        }\n        catch (Throwable e)\n        {\n            logger.error(\"Error parsing\", e);\n        }\n\n        return sourceString;\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Replaces the Flickr image links with their corresponding thumbnails.\n     *\n     * @param sourceString the original flickr image link.\n     * @return replaced thumbnail image link; the original image link in case of\n     *         no match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        final Pattern p =\n            Pattern.compile(\n                \"\\\\/photos\\\\/[0-9a-zA-Z_\\\\-\\\\@]+\\\\/([0-9]+)(\\\\/[^\\\"\\\\<]*)*\",\n                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n        Matcher m = p.matcher(sourceString);\n        String thumbUrl = sourceString;\n\n        while (m.find())\n        {\n            try\n            {\n                // API URL\n                String url =\n                    \"http://api.flickr.com/services/rest/\"\n                    + \"?method=flickr.photos.getInfo&api_key=\"\n                        + API_KEY + \"&photo_id=\" + m.group(1)\n                        + \"&format=json&nojsoncallback=1\";\n\n                URL flickrURL = new URL(url);\n                URLConnection conn = flickrURL.openConnection();\n\n                BufferedReader in =\n                    new BufferedReader(new InputStreamReader(conn\n                        .getInputStream()));\n\n                String inputLine, holder = \"\";\n\n                while ((inputLine = in.readLine()) != null)\n                    holder = inputLine;\n                in.close();\n\n                JSONObject wrapper = new JSONObject(holder);\n\n                if (wrapper.getString(\"stat\").equals(\"ok\"))\n                {\n                    JSONObject result = wrapper.getJSONObject(\"photo\");\n                    if (!(result.length() == 0))\n                    {\n                        String farmID = result.getString(\"farm\");\n                        String serverID = result.getString(\"server\");\n                        String secret = result.getString(\"secret\");\n\n                        thumbUrl =\n                            \"http://farm\" + farmID + \".static.flickr.com/\"\n                                + serverID + \"/\" + m.group(1) + \"_\" + secret\n                                + \"_t.jpg\";\n                    }\n                }\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        return thumbUrl;\n    }","id":43909,"modified_method":"/**\n     * Replaces the Flickr image links with their corresponding thumbnails.\n     *\n     * @param sourceString the original flickr image link.\n     * @return replaced thumbnail image link; the original image link in case of\n     *         no match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        final Pattern p =\n            Pattern.compile(\n                \"\\\\/photos\\\\/[0-9a-zA-Z_\\\\-\\\\@]+\\\\/([0-9]+)(\\\\/[^\\\"\\\\<]*)*\",\n                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n        Matcher m = p.matcher(sourceString);\n        String thumbUrl = sourceString;\n\n        while (m.find())\n        {\n            try\n            {\n                // API URL\n                String url =\n                    \"http://api.flickr.com/services/rest/\"\n                    + \"?method=flickr.photos.getInfo&api_key=\"\n                        + API_KEY + \"&photo_id=\" + m.group(1)\n                        + \"&format=json&nojsoncallback=1\";\n\n                URL flickrURL = new URL(url);\n                URLConnection conn = flickrURL.openConnection();\n\n                BufferedReader in =\n                    new BufferedReader(new InputStreamReader(conn\n                        .getInputStream()));\n\n                String inputLine, holder = \"\";\n\n                while ((inputLine = in.readLine()) != null)\n                    holder = inputLine;\n                in.close();\n\n                JSONObject wrapper = (JSONObject)JSONValue\n                    .parseWithException(holder);\n\n                if (wrapper.get(\"stat\").equals(\"ok\"))\n                {\n                    JSONObject result = (JSONObject)wrapper.get(\"photo\");\n                    if (!(result.isEmpty()))\n                    {\n                        String farmID = (String)result.get(\"farm\");\n                        String serverID = (String)result.get(\"server\");\n                        String secret = (String)result.get(\"secret\");\n\n                        thumbUrl =\n                            \"http://farm\" + farmID + \".static.flickr.com/\"\n                                + serverID + \"/\" + m.group(1) + \"_\" + secret\n                                + \"_t.jpg\";\n                    }\n                }\n            }\n            catch(Throwable e)\n            {\n                logger.error(\"Error parsing\", e);\n            }\n        }\n\n        return thumbUrl;\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Replaces the Hulu video links with their corresponding thumbnails.\n     *\n     * @param sourceString the original video link.\n     * @return thumbnail image link; the original video link in case of no\n     *         match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        try\n        {\n            String url = \"http://oohembed.com/oohembed/?url=\" + sourceString;\n            URL sourceURL = new URL(url);\n            URLConnection conn = sourceURL.openConnection();\n\n            BufferedReader in =\n                new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\n            String inputLine, holder = \"\";\n\n            while ((inputLine = in.readLine()) != null)\n                holder = inputLine;\n            in.close();\n\n            JSONObject wrapper = new JSONObject(holder);\n\n            String thumbUrl = wrapper.getString(\"thumbnail_url\");\n\n            if (thumbUrl != null)\n            {\n                return thumbUrl;\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n\n        return sourceString;\n    }","id":43910,"modified_method":"/**\n     * Replaces the Hulu video links with their corresponding thumbnails.\n     *\n     * @param sourceString the original video link.\n     * @return thumbnail image link; the original video link in case of no\n     *         match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        try\n        {\n            String url = \"http://oohembed.com/oohembed/?url=\" + sourceString;\n            URL sourceURL = new URL(url);\n            URLConnection conn = sourceURL.openConnection();\n\n            BufferedReader in =\n                new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\n            String inputLine, holder = \"\";\n\n            while ((inputLine = in.readLine()) != null)\n                holder = inputLine;\n            in.close();\n\n            JSONObject wrapper = (JSONObject)JSONValue\n                .parseWithException(holder);\n\n            String thumbUrl = (String)wrapper.get(\"thumbnail_url\");\n\n            if (thumbUrl != null)\n            {\n                return thumbUrl;\n            }\n        }\n        catch (Throwable e)\n        {\n            logger.error(\"Error parsing\", e);\n        }\n\n        return sourceString;\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the thumbnail URL of the video link provided.\n     * \n     * @param sourceString the original video link.\n     * @return the thumbnail image link; the original link in case of no match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        final Pattern p =\n            Pattern.compile(\".+\\\\.com\\\\/([a-zA-Z0-9_\\\\-]+)\",\n                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n        Matcher m = p.matcher(sourceString);\n\n        String thumbUrl = sourceString;\n\n        while (m.find())\n        {\n            try\n            {\n                String url =\n                    \"http://vimeo.com/api/v2/video/\" + m.group(1) + \".json\";\n                URL vimeoURL = new URL(url);\n                URLConnection conn = vimeoURL.openConnection();\n\n                BufferedReader in =\n                    new BufferedReader(new InputStreamReader(conn\n                        .getInputStream()));\n\n                String inputLine, holder = \"\";\n\n                while ((inputLine = in.readLine()) != null)\n                    holder = inputLine;\n                in.close();\n\n                JSONArray result = new JSONArray(holder);\n\n                if (!(result.length() == 0))\n                {\n                    thumbUrl\n                        = result.getJSONObject(0).getString(\"thumbnail_medium\");\n                }\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n\n        return thumbUrl;\n    }","id":43911,"modified_method":"/**\n     * Returns the thumbnail URL of the video link provided.\n     * \n     * @param sourceString the original video link.\n     * @return the thumbnail image link; the original link in case of no match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        final Pattern p =\n            Pattern.compile(\".+\\\\.com\\\\/([a-zA-Z0-9_\\\\-]+)\",\n                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n        Matcher m = p.matcher(sourceString);\n\n        String thumbUrl = sourceString;\n\n        while (m.find())\n        {\n            try\n            {\n                String url =\n                    \"http://vimeo.com/api/v2/video/\" + m.group(1) + \".json\";\n                URL vimeoURL = new URL(url);\n                URLConnection conn = vimeoURL.openConnection();\n\n                BufferedReader in =\n                    new BufferedReader(new InputStreamReader(conn\n                        .getInputStream()));\n\n                String inputLine, holder = \"\";\n\n                while ((inputLine = in.readLine()) != null)\n                    holder = inputLine;\n                in.close();\n\n                JSONArray result = (JSONArray)JSONValue\n                    .parseWithException(holder);\n\n                if (!(result.isEmpty()))\n                {\n                    thumbUrl\n                        = (String)((JSONObject)result.get(0))\n                            .get(\"thumbnail_medium\");\n                }\n            }\n            catch (Throwable e)\n            {\n                logger.error(\"Error parsing\", e);\n            }\n        }\n\n        return thumbUrl;\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the thumbnail URL of the video link provided.\n     *\n     * @param sourceString the original video link.\n     * @return the thumbnail image link; the original link in case of no match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        try\n        {\n            String url = \"http://youtube.com/oembed/?url=\" + sourceString;\n            URL sourceURL = new URL(url);\n            URLConnection conn = sourceURL.openConnection();\n\n            BufferedReader in =\n                new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\n            String inputLine, holder = \"\";\n\n            while ((inputLine = in.readLine()) != null)\n                holder = inputLine;\n            in.close();\n\n            JSONObject wrapper = new JSONObject(holder);\n\n            String thumbUrl = wrapper.getString(\"thumbnail_url\");\n\n            if (thumbUrl != null)\n            {\n                return thumbUrl;\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n\n        return sourceString;\n    }","id":43912,"modified_method":"/**\n     * Returns the thumbnail URL of the video link provided.\n     *\n     * @param sourceString the original video link.\n     * @return the thumbnail image link; the original link in case of no match.\n     */\n    public String getReplacement(String sourceString)\n    {\n        try\n        {\n            String url = \"http://youtube.com/oembed/?url=\" + sourceString;\n            URL sourceURL = new URL(url);\n            URLConnection conn = sourceURL.openConnection();\n\n            BufferedReader in =\n                new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\n            String inputLine, holder = \"\";\n\n            while ((inputLine = in.readLine()) != null)\n                holder = inputLine;\n            in.close();\n\n            JSONObject wrapper = (JSONObject)JSONValue\n                .parseWithException(holder);\n\n            String thumbUrl = (String)wrapper.get(\"thumbnail_url\");\n\n            if (thumbUrl != null)\n            {\n                return thumbUrl;\n            }\n        }\n        catch (Throwable e)\n        {\n            logger.error(\"Error parsing\", e);\n        }\n\n        return sourceString;\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * The logic that runs in separate thread. Dispatching responses.\n     */\n    public void run()\n    {\n        if(connection == null)\n        {\n            logger.error(\"No connection.\");\n            return;\n        }\n\n        try\n        {\n            connectionReader = new BufferedReader(new InputStreamReader(\n                connection.getInputStream()));\n\n            if (!connectionReader.readLine().contains(\"XiVO\"))\n            {\n                logger.error(\"Error xivo with server!\");\n                destroy();\n                return;\n            }\n\n            String line;\n            while ((line = connectionReader.readLine()) != null || !stopped)\n            {\n                try\n                {\n                    if(logger.isTraceEnabled())\n                        logger.trace(\"Read from server:\" + line);\n\n                    handle(new JSONObject(line));\n                }\n                catch(JSONException ex)\n                {\n                    logger.error(\"Error parsing object:\" + line, ex);\n                }\n            }\n        }\n        catch(IOException ex)\n        {\n            destroy();\n        }\n    }","id":43913,"modified_method":"/**\n     * The logic that runs in separate thread. Dispatching responses.\n     */\n    public void run()\n    {\n        if(connection == null)\n        {\n            logger.error(\"No connection.\");\n            return;\n        }\n\n        try\n        {\n            connectionReader = new BufferedReader(new InputStreamReader(\n                connection.getInputStream()));\n\n            if (!connectionReader.readLine().contains(\"XiVO\"))\n            {\n                logger.error(\"Error xivo with server!\");\n                destroy();\n                return;\n            }\n\n            String line;\n            while ((line = connectionReader.readLine()) != null || !stopped)\n            {\n                try\n                {\n                    if(logger.isTraceEnabled())\n                        logger.trace(\"Read from server:\" + line);\n\n                    handle((JSONObject)JSONValue.parseWithException(line));\n                }\n                catch(Throwable ex)\n                {\n                    logger.error(\"Error parsing object:\" + line, ex);\n                }\n            }\n        }\n        catch(IOException ex)\n        {\n            destroy();\n        }\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sends password command.\n     * @param sessionId the session id from previous command.\n     * @param password the password to authorize.\n     * @return is command successful.\n     */\n    private boolean authorize(String sessionId, String password)\n    {\n        if(connection == null || sessionId == null || password == null)\n            return false;\n\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.accumulate(\"class\",\"login_pass\");\n            obj.accumulate(\"hashedpassword\",\n                Sha1Crypto.encode(sessionId + \":\" + password));\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error login with password\", e);\n            return false;\n        }\n    }","id":43914,"modified_method":"/**\n     * Sends password command.\n     * @param sessionId the session id from previous command.\n     * @param password the password to authorize.\n     * @return is command successful.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private boolean authorize(String sessionId, String password)\n    {\n        if(connection == null || sessionId == null || password == null)\n            return false;\n\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.put(\"class\",\"login_pass\");\n            obj.put(\"hashedpassword\",\n                Sha1Crypto.encode(sessionId + \":\" + password));\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error login with password\", e);\n            return false;\n        }\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sends command to retrieve phones list.\n     * @return is command successful.\n     */\n    private boolean getPhoneList()\n    {\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.accumulate(\"class\", \"phones\");\n            obj.accumulate(\"function\", \"getlist\");\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error retrieving phones\");\n            return false;\n        }\n    }","id":43915,"modified_method":"/**\n     * Sends command to retrieve phones list.\n     * @return is command successful.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private boolean getPhoneList()\n    {\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.put(\"class\", \"phones\");\n            obj.put(\"function\", \"getlist\");\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error retrieving phones\");\n            return false;\n        }\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sends login command.\n     * @param username the username.\n     * @return is command successful.\n     */\n    private boolean login(String username)\n    {\n        if(connection == null || username == null)\n            return false;\n\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.accumulate(\"class\",\"login_id\");\n            obj.accumulate(\"company\", \"Jitsi\");\n\n            String os = \"x11\";\n            if(OSUtils.IS_WINDOWS)\n                os = \"win\";\n            else if(OSUtils.IS_MAC)\n                os = \"mac\";\n            obj.accumulate(\"ident\", username + \"@\" + os);\n\n            obj.accumulate(\"userid\", username);\n            obj.accumulate(\"version\", \"9999\");\n            obj.accumulate(\"xivoversion\", \"1.1\");\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error login\", e);\n            return false;\n        }\n    }","id":43916,"modified_method":"/**\n     * Sends login command.\n     * @param username the username.\n     * @return is command successful.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private boolean login(String username)\n    {\n        if(connection == null || username == null)\n            return false;\n\n\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.put(\"class\",\"login_id\");\n            obj.put(\"company\", \"Jitsi\");\n\n            String os = \"x11\";\n            if(OSUtils.IS_WINDOWS)\n                os = \"win\";\n            else if(OSUtils.IS_MAC)\n                os = \"mac\";\n            obj.put(\"ident\", username + \"@\" + os);\n\n            obj.put(\"userid\", username);\n            obj.put(\"version\", \"9999\");\n            obj.put(\"xivoversion\", \"1.1\");\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error login\", e);\n            return false;\n        }\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Send needed command for features.\n     * @param astid param from previous command.\n     * @param xivoUserId param from previous command.\n     * @return is command successful.\n     */\n    private boolean sendFeatures(String astid, String xivoUserId)\n    {\n        if(connection == null || astid == null || xivoUserId == null)\n            return false;\n\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.accumulate(\"class\",\"featuresget\");\n            obj.accumulate(\"userid\", astid + \"/\" + xivoUserId);\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error send features get command\", e);\n            return false;\n        }\n    }","id":43917,"modified_method":"/**\n     * Send needed command for features.\n     * @param astid param from previous command.\n     * @param xivoUserId param from previous command.\n     * @return is command successful.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private boolean sendFeatures(String astid, String xivoUserId)\n    {\n        if(connection == null || astid == null || xivoUserId == null)\n            return false;\n\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.put(\"class\",\"featuresget\");\n            obj.put(\"userid\", astid + \"/\" + xivoUserId);\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error send features get command\", e);\n            return false;\n        }\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * parses received phones list and creates/resolves groups and contacts\n     * @param objReceived the obj with data.\n     */\n    private void phonesRecieved(JSONObject objReceived)\n    {\n        try\n        {\n            if(!objReceived.getString(\"function\").equals(\"sendlist\")\n                || !objReceived.has(\"payload\"))\n                return;\n\n            JSONObject payload = objReceived.getJSONObject(\"payload\");\n            Iterator iter = payload.keys();\n            List<JSONObject> phoneList = new ArrayList<JSONObject>();\n            while(iter.hasNext())\n            {\n                JSONObject obj = (JSONObject)payload.get((String) iter.next());\n                Iterator phonesIter = obj.keys();\n                while(phonesIter.hasNext())\n                    phoneList.add(\n                        (JSONObject)obj.get((String)phonesIter.next()));\n\n            }\n\n            for(JSONObject phone : phoneList)\n            {\n                try\n                {\n                    // don't handle non sip phones\n                    if(!phone.getString(\"tech\").equalsIgnoreCase(\"sip\"))\n                        continue;\n\n                    String groupName = phone.getString(\"context\");\n\n                    ContactGroupSipImpl parentGroup =\n                        findGroupByName(groupName);\n\n                    if(parentGroup == null)\n                    {\n                        parentGroup =\n                            new ContactGroupSipImpl(groupName, sipProvider);\n                        parentGroup.setPersistent(true);\n                        getRootGroup().addSubgroup(parentGroup);\n\n                        fireGroupEvent(parentGroup,\n                            ServerStoredGroupEvent.GROUP_CREATED_EVENT);\n                    }\n\n                    String number = phone.getString(\"number\");\n\n                    Address address =\n                            sipProvider.parseAddressString(number);\n\n                    //if the contact is already in the contact list\n                    ContactSipImpl contact =\n                        parentOperationSet.resolveContactID(address.toString());\n\n                    if(contact == null)\n                    {\n                        contact = new ContactSipImpl(address, sipProvider);\n                        contact.setDisplayName(\n                                phone.getString(\"firstname\") + \" \"\n                                + phone.getString(\"lastname\"));\n                        contact.setResolved(true);\n                        parentGroup.addContact(contact);\n\n                        fireContactAdded(parentGroup, contact);\n                    }\n                    else\n                    {\n                        contact.setDisplayName(\n                                phone.getString(\"firstname\") + \" \"\n                                + phone.getString(\"lastname\"));\n                        contact.setResolved(true);\n\n                        fireContactResolved(parentGroup, contact);\n                    }\n                }\n                catch(Throwable t)\n                {\n                    logger.error(\"Error parsing \" + phone);\n                }\n            }\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error init list from server\", t);\n        }\n    }","id":43918,"modified_method":"/**\n     * parses received phones list and creates/resolves groups and contacts\n     * @param objReceived the obj with data.\n     */\n    private void phonesRecieved(JSONObject objReceived)\n    {\n        try\n        {\n            if(!objReceived.get(\"function\").equals(\"sendlist\")\n                || !objReceived.containsKey(\"payload\"))\n                return;\n\n            JSONObject payload = (JSONObject)objReceived.get(\"payload\");\n            Iterator iter = payload.keySet().iterator();\n            List<JSONObject> phoneList = new ArrayList<JSONObject>();\n            while(iter.hasNext())\n            {\n                JSONObject obj = (JSONObject)payload.get(iter.next());\n                Iterator phonesIter = obj.keySet().iterator();\n                while(phonesIter.hasNext())\n                    phoneList.add(\n                        (JSONObject)obj.get(phonesIter.next()));\n\n            }\n\n            for(JSONObject phone : phoneList)\n            {\n                try\n                {\n                    // don't handle non sip phones\n                    if(!((String)phone.get(\"tech\")).equalsIgnoreCase(\"sip\"))\n                        continue;\n\n                    String groupName = (String)phone.get(\"context\");\n\n                    ContactGroupSipImpl parentGroup =\n                        findGroupByName(groupName);\n\n                    if(parentGroup == null)\n                    {\n                        parentGroup =\n                            new ContactGroupSipImpl(groupName, sipProvider);\n                        parentGroup.setPersistent(true);\n                        getRootGroup().addSubgroup(parentGroup);\n\n                        fireGroupEvent(parentGroup,\n                            ServerStoredGroupEvent.GROUP_CREATED_EVENT);\n                    }\n\n                    String number = (String)phone.get(\"number\");\n\n                    Address address =\n                            sipProvider.parseAddressString(number);\n\n                    //if the contact is already in the contact list\n                    ContactSipImpl contact =\n                        parentOperationSet.resolveContactID(address.toString());\n\n                    if(contact == null)\n                    {\n                        contact = new ContactSipImpl(address, sipProvider);\n                        contact.setDisplayName(\n                                phone.get(\"firstname\") + \" \"\n                                + phone.get(\"lastname\"));\n                        contact.setResolved(true);\n                        parentGroup.addContact(contact);\n\n                        fireContactAdded(parentGroup, contact);\n                    }\n                    else\n                    {\n                        contact.setDisplayName(\n                                phone.get(\"firstname\") + \" \"\n                                + phone.get(\"lastname\"));\n                        contact.setResolved(true);\n\n                        fireContactResolved(parentGroup, contact);\n                    }\n                }\n                catch(Throwable t)\n                {\n                    logger.error(\"Error parsing \" + phone);\n                }\n            }\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error init list from server\", t);\n        }\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sends login command.\n     * @param capalistParam param from previous command.\n     * @return is command successful.\n     */\n    private boolean sendCapas(JSONArray capalistParam)\n    {\n        if(connection == null\n            || capalistParam == null || capalistParam.length() < 1)\n            return false;\n\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.accumulate(\"class\", \"login_capas\");\n            obj.accumulate(\"capaid\", capalistParam.getString(0));\n            obj.accumulate(\"lastconnwins\", \"false\");\n            obj.accumulate(\"loginkind\", \"agent\");\n            obj.accumulate(\"state\", \"\");\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error login\", e);\n            return false;\n        }\n    }","id":43919,"modified_method":"/**\n     * Sends login command.\n     * @param capalistParam param from previous command.\n     * @return is command successful.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private boolean sendCapas(JSONArray capalistParam)\n    {\n        if(connection == null\n            || capalistParam == null || capalistParam.isEmpty())\n            return false;\n\n        JSONObject obj = new JSONObject();\n        try\n        {\n            obj.put(\"class\", \"login_capas\");\n            obj.put(\"capaid\", capalistParam.get(0));\n            obj.put(\"lastconnwins\", \"false\");\n            obj.put(\"loginkind\", \"agent\");\n            obj.put(\"state\", \"\");\n\n            return send(obj);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Error login\", e);\n            return false;\n        }\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles new incoming object.\n     */\n    private void handle(JSONObject incomingObject)\n    {\n        if(!incomingObject.has(\"class\"))\n            return;\n\n        try\n        {\n            String classField = incomingObject.getString(\"class\");\n\n            if (classField.equals(\"loginko\"))\n            {\n                showError(null, null,\n                        \"Unauthorized. Cannot login: \" +\n                        incomingObject.getString(\"errorstring\"));\n\n                logger.error(\"Error login: \" +\n                    incomingObject.getString(\"errorstring\"));\n\n                destroy();\n\n                return;\n            }\n            else if (classField.equals(\"login_id_ok\"))\n            {\n                AccountID accountID = sipProvider.getAccountID();\n                boolean useSipCredentials =\n                    accountID.getAccountPropertyBoolean(\n                                            XIVO_USE_SIP_CREDETIALS, true);\n                String password;\n                if (useSipCredentials)\n                {\n                    password = SipActivator.getProtocolProviderFactory().\n                            loadPassword(accountID);\n                }\n                else\n                {\n                    password = accountID.getAccountPropertyString(XIVO_PASSWORD);\n                }\n\n                if(!authorize(incomingObject.getString(\"sessionid\"), password))\n                    logger.error(\"Error login authorization!\");\n\n                return;\n            }\n            else if (classField.equals(\"login_pass_ok\"))\n            {\n                if(!sendCapas(incomingObject.getJSONArray(\"capalist\")))\n                    logger.error(\"Error send capas!\");\n\n                return;\n            }\n            else if (classField.equals(\"login_capas_ok\"))\n            {\n                if(!sendFeatures(incomingObject.getString(\"astid\"),\n                            incomingObject.getString(\"xivo_userid\")))\n                    logger.error(\"Problem send features get!\");\n\n                return;\n            }\n            else if (classField.equals(\"features\"))\n            {\n                if(!getPhoneList())\n                    logger.error(\"Problem send get phones!\");\n\n                return;\n            }\n            else if (classField.equals(\"phones\"))\n            {\n                phonesRecieved(incomingObject);\n                return;\n            }\n            else if (classField.equals(\"disconn\"))\n            {\n                destroy();\n                return;\n            }\n            else\n            {\n                if(logger.isTraceEnabled())\n                    logger.trace(\"unhandled classField: \" + incomingObject);\n                return;\n            }\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error handling incoming object\", t);\n        }\n    }","id":43920,"modified_method":"/**\n     * Handles new incoming object.\n     */\n    private void handle(JSONObject incomingObject)\n    {\n        if(!incomingObject.containsKey(\"class\"))\n            return;\n\n        try\n        {\n            String classField = (String)incomingObject.get(\"class\");\n\n            if (classField.equals(\"loginko\"))\n            {\n                showError(null, null,\n                        \"Unauthorized. Cannot login: \" +\n                        incomingObject.get(\"errorstring\"));\n\n                logger.error(\"Error login: \" +\n                    incomingObject.get(\"errorstring\"));\n\n                destroy();\n\n                return;\n            }\n            else if (classField.equals(\"login_id_ok\"))\n            {\n                AccountID accountID = sipProvider.getAccountID();\n                boolean useSipCredentials =\n                    accountID.getAccountPropertyBoolean(\n                                            XIVO_USE_SIP_CREDETIALS, true);\n                String password;\n                if (useSipCredentials)\n                {\n                    password = SipActivator.getProtocolProviderFactory().\n                            loadPassword(accountID);\n                }\n                else\n                {\n                    password = accountID.getAccountPropertyString(XIVO_PASSWORD);\n                }\n\n                if(!authorize((String)incomingObject.get(\"sessionid\"), password))\n                    logger.error(\"Error login authorization!\");\n\n                return;\n            }\n            else if (classField.equals(\"login_pass_ok\"))\n            {\n                if(!sendCapas((JSONArray)incomingObject.get(\"capalist\")))\n                    logger.error(\"Error send capas!\");\n\n                return;\n            }\n            else if (classField.equals(\"login_capas_ok\"))\n            {\n                if(!sendFeatures((String)incomingObject.get(\"astid\"),\n                            (String)incomingObject.get(\"xivo_userid\")))\n                    logger.error(\"Problem send features get!\");\n\n                return;\n            }\n            else if (classField.equals(\"features\"))\n            {\n                if(!getPhoneList())\n                    logger.error(\"Problem send get phones!\");\n\n                return;\n            }\n            else if (classField.equals(\"phones\"))\n            {\n                phonesRecieved(incomingObject);\n                return;\n            }\n            else if (classField.equals(\"disconn\"))\n            {\n                destroy();\n                return;\n            }\n            else\n            {\n                if(logger.isTraceEnabled())\n                    logger.trace(\"unhandled classField: \" + incomingObject);\n                return;\n            }\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error handling incoming object\", t);\n        }\n    }","commit_id":"4f3d81f0ccdecc7528114f7470a0c2749a908982","url":"https://github.com/jitsi/jitsi"},{"original_method":"public String toString() {\n    StringBuilder r = new StringBuilder();\n    for (int i = 0; i < myProgram.getInstructions().size(); i++) {\n      Instruction instruction = myProgram.getInstructions().get(i);\n      r.append(instruction).append(\" \");\n      r.append(toString(myResult.get(instruction)));\n      r.append(\"\\n\");\n    }\n    return r.toString();\n  }","id":43921,"modified_method":"public String toString() {\n    StringBuilder r = new StringBuilder();\n    for (int i = 0; i < myProgram.size(); i++) {\n      Instruction instruction = myProgram.get(i);\n      r.append(instruction).append(\" \");\n      r.append(toString(myResult.get(instruction)));\n      r.append(\"\\n\");\n    }\n    return r.toString();\n  }","commit_id":"6a55b26849a7e4a75533897bae1725a3c1ef421b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void buildEdges() {\n    super.buildEdges();\n    addEdgeTo(getProgram().getInstructions().get(myJumpTo));\n  }","id":43922,"modified_method":"public void buildEdges() {\n    super.buildEdges();\n    addEdgeTo(getProgram().get(myJumpTo));\n  }","commit_id":"6a55b26849a7e4a75533897bae1725a3c1ef421b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void buildEdges() {\n    List<Instruction> instructions = myProgram.getInstructions();\n    int index = instructions.indexOf(this);\n    if (index != instructions.size() - 1) {\n      addEdgeTo(instructions.get(index + 1));\n    }\n  }","id":43923,"modified_method":"public void buildEdges() {\n    if (this != getProgram().end()) {\n      addEdgeTo(getProgram().get(getIndex() + 1));\n    }\n  }","commit_id":"6a55b26849a7e4a75533897bae1725a3c1ef421b","url":"https://github.com/JetBrains/MPS"},{"original_method":"int getIndex() {\n    return myProgram.getInstructions().indexOf(this);\n  }","id":43924,"modified_method":"int getIndex() {\n    return myProgram.indexOf(this);\n  }","commit_id":"6a55b26849a7e4a75533897bae1725a3c1ef421b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void buildEdges() {\n    addEdgeTo(getProgram().getInstructions().get(myJumpTo));\n  }","id":43925,"modified_method":"public void buildEdges() {\n    addEdgeTo(getProgram().get(myJumpTo));\n  }","commit_id":"6a55b26849a7e4a75533897bae1725a3c1ef421b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Boolean fun(Instruction instruction, Boolean input) {\n    if (instruction.getProgram().getInstructions().get(0) == instruction) {\n      return true;\n    }\n    return input;\n  }","id":43926,"modified_method":"public Boolean fun(Instruction instruction, Boolean input) {\n    if (instruction.getProgram().get(0) == instruction) {\n      return true;\n    }\n    return input;\n  }","commit_id":"6a55b26849a7e4a75533897bae1725a3c1ef421b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void buildEdges() {\n    List<Instruction> instructions = getProgram().getInstructions();\n    addEdgeTo(instructions.get(instructions.size() - 1));\n  }","id":43927,"modified_method":"public void buildEdges() {\n    addEdgeTo(getProgram().end());\n  }","commit_id":"6a55b26849a7e4a75533897bae1725a3c1ef421b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private int currentPosition() {\n    return myProgram.getInstructions().size();\n  }","id":43928,"modified_method":"private int currentPosition() {\n    return myProgram.size();\n  }","commit_id":"6a55b26849a7e4a75533897bae1725a3c1ef421b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String getPureName(PsiVariable var) {\n    final JavaCodeStyleManager styleManager = JavaCodeStyleManager.getInstance(myProject);\n    return var instanceof PsiLocalVariable\n                        ? styleManager.variableNameToPropertyName(var.getName(), VariableKind.LOCAL_VARIABLE) : styleManager.variableNameToPropertyName(var.getName(), VariableKind.PARAMETER);\n  }","id":43929,"modified_method":"private String getPureName(PsiVariable var) {\n    final JavaCodeStyleManager styleManager = JavaCodeStyleManager.getInstance(myProject);\n    final VariableKind kind = var instanceof PsiLocalVariable ? VariableKind.LOCAL_VARIABLE : VariableKind.PARAMETER;\n    return styleManager.variableNameToPropertyName(var.getName(), kind);\n  }","commit_id":"b4a99e051b730fd29659296155ef1d58ba42e92a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addOutputVariableFieldsWithGetters() throws IncorrectOperationException {\n    final Map<String, String> var2FieldNames = new HashMap<String, String>();\n    final PsiVariable[] outputVariables = myExtractProcessor.getOutputVariables();\n    for (int i = 0; i < outputVariables.length; i++) {\n      final PsiVariable var = outputVariables[i];\n      final PsiField outputField = myOutputFields[i];\n      final String name = getPureName(var);\n      LOG.assertTrue(name != null);\n      if (outputField != null) {\n        var2FieldNames.put(var.getName(), outputField.getName());\n        myInnerClass.add(outputField);\n      }\n      final PsiField field = PropertyUtil.findPropertyField(myProject, myInnerClass, name, false);\n      LOG.assertTrue(field != null, \"i:\" + i + \"; output variables: \" + Arrays.toString(outputVariables) + \"; parameters: \" + Arrays.toString(getMethod().getParameterList().getParameters()) + \"; output field: \" + outputField );\n      myInnerClass.add(PropertyUtil.generateGetterPrototype(field));\n    }\n\n    PsiParameter[] params = getMethod().getParameterList().getParameters();\n    ParameterInfoImpl[] infos = new ParameterInfoImpl[params.length];\n    for (int i = 0; i < params.length; i++) {\n      PsiParameter param = params[i];\n      infos[i] = new ParameterInfoImpl(i, param.getName(), param.getType());\n    }\n    ChangeSignatureProcessor cp = new ChangeSignatureProcessor(myProject, getMethod(), false, null, getMethod().getName(),\n                                                               new PsiImmediateClassType(myInnerClass, PsiSubstitutor.EMPTY), infos);\n    cp.run();\n    final PsiCodeBlock body = getMethod().getBody();\n    LOG.assertTrue(body != null);\n    final List<PsiLocalVariable> vars = new ArrayList<PsiLocalVariable>();\n    final Map<PsiElement, PsiElement> replacementMap = new LinkedHashMap<PsiElement, PsiElement>();\n    final List<PsiReturnStatement> returnStatements = new ArrayList<PsiReturnStatement>();\n    body.accept(new JavaRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitReturnStatement(final PsiReturnStatement statement) {\n        super.visitReturnStatement(statement);\n        try {\n          returnStatements.add(statement);\n          replacementMap.put(statement, myElementFactory.createStatementFromText(\"return this;\", statement));\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n      @Override\n      public void visitClass(PsiClass aClass) {\n      }\n\n      @Override\n      public void visitDeclarationStatement(final PsiDeclarationStatement statement) {\n        super.visitDeclarationStatement(statement);\n        final PsiElement[] declaredElements = statement.getDeclaredElements();//todo\n        for (PsiElement declaredElement : declaredElements) {\n          if (declaredElement instanceof PsiVariable) {\n            for (PsiVariable variable : outputVariables) {\n              PsiLocalVariable var = (PsiLocalVariable)declaredElement;\n              if (Comparing.strEqual(var.getName(), variable.getName())) {\n                final PsiExpression initializer = var.getInitializer();\n                if (initializer == null) {\n                  replacementMap.put(statement, null);\n                }\n                else {\n                  replacementMap.put(var, var);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      @Override\n      public void visitReferenceExpression(final PsiReferenceExpression expression) {\n        super.visitReferenceExpression(expression);\n        final PsiElement resolved = expression.resolve();\n        if (resolved instanceof PsiLocalVariable) {\n          final String var = ((PsiLocalVariable)resolved).getName();\n          for (PsiVariable variable : outputVariables) {\n            if (Comparing.strEqual(variable.getName(), var)) {\n              vars.add((PsiLocalVariable)resolved);\n              break;\n            }\n          }\n        }\n      }\n    });\n\n    if (myExtractProcessor.generatesConditionalExit()) {\n      for (int i = 0; i < returnStatements.size() - 1; i++) {\n        final PsiReturnStatement condition = returnStatements.get(i);\n        condition.getParent().addBefore(myElementFactory.createStatementFromText(\"myResult = true;\", condition), condition);\n      }\n\n      LOG.assertTrue(!returnStatements.isEmpty());\n      final PsiReturnStatement returnStatement = returnStatements.get(returnStatements.size() - 1);\n      returnStatement.getParent().addBefore(myElementFactory.createStatementFromText(\"myResult = false;\", returnStatement), returnStatement);\n    }\n\n    for (PsiLocalVariable var : vars) {\n      final String fieldName = var2FieldNames.get(var.getName());\n      for (PsiReference reference : ReferencesSearch.search(var)) {\n        reference.handleElementRename(fieldName);\n      }\n    }\n\n    for (PsiElement statement : replacementMap.keySet()) {\n      final PsiElement replacement = replacementMap.get(statement);\n      if (replacement != null) {\n        if (statement instanceof PsiLocalVariable) {\n          final PsiLocalVariable variable = (PsiLocalVariable)statement;\n          variable.normalizeDeclaration();\n          final PsiExpression initializer = variable.getInitializer();\n          LOG.assertTrue(initializer != null);\n          final PsiStatement assignmentStatement = myElementFactory.createStatementFromText(var2FieldNames.get(variable.getName()) + \" = \" + initializer.getText() + \";\", statement);\n          final PsiDeclarationStatement declaration = PsiTreeUtil.getParentOfType(statement, PsiDeclarationStatement.class);\n          LOG.assertTrue(declaration != null);\n          declaration.replace(assignmentStatement);\n        } else {\n          if (statement instanceof PsiReturnStatement) {\n            final PsiExpression returnValue = ((PsiReturnStatement)statement).getReturnValue();\n            if (!(returnValue instanceof PsiReferenceExpression || returnValue == null || returnValue instanceof PsiLiteralExpression)) {\n              statement.getParent()\n                .addBefore(myElementFactory.createStatementFromText(returnValue.getText() + \";\", returnValue), statement);\n            }\n          }\n          statement.replace(replacement);\n        }\n      } else {\n        statement.delete();\n      }\n    }\n  }","id":43930,"modified_method":"private void addOutputVariableFieldsWithGetters() throws IncorrectOperationException {\n    final Map<String, String> var2FieldNames = new HashMap<String, String>();\n    final PsiVariable[] outputVariables = myExtractProcessor.getOutputVariables();\n    for (int i = 0; i < outputVariables.length; i++) {\n      final PsiVariable var = outputVariables[i];\n      final PsiField outputField = myOutputFields[i];\n      final String name = getPureName(var);\n      LOG.assertTrue(name != null);\n      final PsiField field;\n      if (outputField != null) {\n        var2FieldNames.put(var.getName(), outputField.getName());\n        myInnerClass.add(outputField);\n        field = outputField;\n      } else {\n        field = PropertyUtil.findPropertyField(myProject, myInnerClass, name, false);\n      }\n      LOG.assertTrue(field != null, \"i:\" + i + \"; output variables: \" + Arrays.toString(outputVariables) + \"; parameters: \" + Arrays.toString(getMethod().getParameterList().getParameters()) + \"; output field: \" + outputField );\n      myInnerClass.add(PropertyUtil.generateGetterPrototype(field));\n    }\n\n    PsiParameter[] params = getMethod().getParameterList().getParameters();\n    ParameterInfoImpl[] infos = new ParameterInfoImpl[params.length];\n    for (int i = 0; i < params.length; i++) {\n      PsiParameter param = params[i];\n      infos[i] = new ParameterInfoImpl(i, param.getName(), param.getType());\n    }\n    ChangeSignatureProcessor cp = new ChangeSignatureProcessor(myProject, getMethod(), false, null, getMethod().getName(),\n                                                               new PsiImmediateClassType(myInnerClass, PsiSubstitutor.EMPTY), infos);\n    cp.run();\n    final PsiCodeBlock body = getMethod().getBody();\n    LOG.assertTrue(body != null);\n    final List<PsiLocalVariable> vars = new ArrayList<PsiLocalVariable>();\n    final Map<PsiElement, PsiElement> replacementMap = new LinkedHashMap<PsiElement, PsiElement>();\n    final List<PsiReturnStatement> returnStatements = new ArrayList<PsiReturnStatement>();\n    body.accept(new JavaRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitReturnStatement(final PsiReturnStatement statement) {\n        super.visitReturnStatement(statement);\n        try {\n          returnStatements.add(statement);\n          replacementMap.put(statement, myElementFactory.createStatementFromText(\"return this;\", statement));\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n      @Override\n      public void visitClass(PsiClass aClass) {\n      }\n\n      @Override\n      public void visitDeclarationStatement(final PsiDeclarationStatement statement) {\n        super.visitDeclarationStatement(statement);\n        final PsiElement[] declaredElements = statement.getDeclaredElements();//todo\n        for (PsiElement declaredElement : declaredElements) {\n          if (declaredElement instanceof PsiVariable) {\n            for (PsiVariable variable : outputVariables) {\n              PsiLocalVariable var = (PsiLocalVariable)declaredElement;\n              if (Comparing.strEqual(var.getName(), variable.getName())) {\n                final PsiExpression initializer = var.getInitializer();\n                if (initializer == null) {\n                  replacementMap.put(statement, null);\n                }\n                else {\n                  replacementMap.put(var, var);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      @Override\n      public void visitReferenceExpression(final PsiReferenceExpression expression) {\n        super.visitReferenceExpression(expression);\n        final PsiElement resolved = expression.resolve();\n        if (resolved instanceof PsiLocalVariable) {\n          final String var = ((PsiLocalVariable)resolved).getName();\n          for (PsiVariable variable : outputVariables) {\n            if (Comparing.strEqual(variable.getName(), var)) {\n              vars.add((PsiLocalVariable)resolved);\n              break;\n            }\n          }\n        }\n      }\n    });\n\n    if (myExtractProcessor.generatesConditionalExit()) {\n      for (int i = 0; i < returnStatements.size() - 1; i++) {\n        final PsiReturnStatement condition = returnStatements.get(i);\n        condition.getParent().addBefore(myElementFactory.createStatementFromText(\"myResult = true;\", condition), condition);\n      }\n\n      LOG.assertTrue(!returnStatements.isEmpty());\n      final PsiReturnStatement returnStatement = returnStatements.get(returnStatements.size() - 1);\n      returnStatement.getParent().addBefore(myElementFactory.createStatementFromText(\"myResult = false;\", returnStatement), returnStatement);\n    }\n\n    for (PsiLocalVariable var : vars) {\n      final String fieldName = var2FieldNames.get(var.getName());\n      for (PsiReference reference : ReferencesSearch.search(var)) {\n        reference.handleElementRename(fieldName);\n      }\n    }\n\n    for (PsiElement statement : replacementMap.keySet()) {\n      final PsiElement replacement = replacementMap.get(statement);\n      if (replacement != null) {\n        if (statement instanceof PsiLocalVariable) {\n          final PsiLocalVariable variable = (PsiLocalVariable)statement;\n          variable.normalizeDeclaration();\n          final PsiExpression initializer = variable.getInitializer();\n          LOG.assertTrue(initializer != null);\n          final PsiStatement assignmentStatement = myElementFactory.createStatementFromText(var2FieldNames.get(variable.getName()) + \" = \" + initializer.getText() + \";\", statement);\n          final PsiDeclarationStatement declaration = PsiTreeUtil.getParentOfType(statement, PsiDeclarationStatement.class);\n          LOG.assertTrue(declaration != null);\n          declaration.replace(assignmentStatement);\n        } else {\n          if (statement instanceof PsiReturnStatement) {\n            final PsiExpression returnValue = ((PsiReturnStatement)statement).getReturnValue();\n            if (!(returnValue instanceof PsiReferenceExpression || returnValue == null || returnValue instanceof PsiLiteralExpression)) {\n              statement.getParent()\n                .addBefore(myElementFactory.createStatementFromText(returnValue.getText() + \";\", returnValue), statement);\n            }\n          }\n          statement.replace(replacement);\n        }\n      } else {\n        statement.delete();\n      }\n    }\n  }","commit_id":"b4a99e051b730fd29659296155ef1d58ba42e92a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void declareNecessaryVariablesAfterCall(final PsiVariable outputVariable) throws IncorrectOperationException {\n      if (myMultipleExitPoints) {\n        final String object = JavaCodeStyleManager.getInstance(myProject).suggestUniqueVariableName(StringUtil.decapitalize(myInnerClassName), outputVariable, true);\n        final PsiStatement methodCallStatement = PsiTreeUtil.getParentOfType(getMethodCall(), PsiStatement.class);\n        LOG.assertTrue(methodCallStatement != null);\n        final PsiStatement declarationStatement = myElementFactory\n          .createStatementFromText(myInnerClassName + \" \" + object + \" = \" + getMethodCall().getText() + \";\", myInnerMethod);\n        if (methodCallStatement instanceof PsiIfStatement) {\n          methodCallStatement.getParent().addBefore(declarationStatement, methodCallStatement);\n          final PsiExpression conditionExpression = ((PsiIfStatement)methodCallStatement).getCondition();\n          conditionExpression.replace(myElementFactory.createExpressionFromText(object + \".is()\", myInnerMethod));\n        } else if (myElements[0] instanceof PsiExpression){\n          methodCallStatement.getParent().addBefore(declarationStatement, methodCallStatement);\n        } else {\n          methodCallStatement.replace(declarationStatement);\n        }\n\n        final List<PsiVariable> usedVariables = myControlFlowWrapper.getUsedVariables();\n        Collection<ControlFlowUtil.VariableInfo> reassigned = myControlFlowWrapper.getInitializedTwice();\n        for (PsiVariable variable : usedVariables) {\n          String name = variable.getName();\n          LOG.assertTrue(name != null);\n          PsiStatement st = null;\n          if (isDeclaredInside(variable)) {\n            st = myElementFactory.createStatementFromText(\n              variable.getType().getCanonicalText() + \" \" + name + \" = \" + object + \".\" + PropertyUtil.suggestGetterName(getPureName(variable), variable.getType()) + \"();\",\n              myInnerMethod);\n            if (reassigned.contains(new ControlFlowUtil.VariableInfo(variable, null))) {\n              final PsiElement[] psiElements = ((PsiDeclarationStatement)st).getDeclaredElements();\n              assert psiElements.length > 0;\n              PsiVariable var = (PsiVariable)psiElements[0];\n              PsiUtil.setModifierProperty(var, PsiModifier.FINAL, false);\n            }\n          }\n          else {\n            if (ArrayUtil.find(myOutputVariables, variable) != -1) {\n              st = myElementFactory.createStatementFromText(name + \" = \" + object + \".\" + PropertyUtil.suggestGetterName(getPureName(variable), variable.getType()) + \"();\", myInnerMethod);\n            }\n          }\n          if (st != null) {\n            addToMethodCallLocation(st);\n          }\n        }\n        if (myElements[0] instanceof PsiAssignmentExpression) {\n          getMethodCall().getParent().replace(((PsiAssignmentExpression)getMethodCall().getParent()).getLExpression());\n        } else if (myElements[0] instanceof PsiPostfixExpression || myElements[0] instanceof PsiPrefixExpression) {\n          getMethodCall().getParent().replace(((PsiBinaryExpression)getMethodCall().getParent()).getLOperand());\n        }\n      }\n      else {\n        super.declareNecessaryVariablesAfterCall(outputVariable);\n      }\n    }","id":43931,"modified_method":"@Override\n    protected void declareNecessaryVariablesAfterCall(final PsiVariable outputVariable) throws IncorrectOperationException {\n      if (myMultipleExitPoints) {\n        final String object = JavaCodeStyleManager.getInstance(myProject).suggestUniqueVariableName(StringUtil.decapitalize(myInnerClassName), outputVariable, true);\n        final PsiStatement methodCallStatement = PsiTreeUtil.getParentOfType(getMethodCall(), PsiStatement.class);\n        LOG.assertTrue(methodCallStatement != null);\n        final PsiStatement declarationStatement = myElementFactory\n          .createStatementFromText(myInnerClassName + \" \" + object + \" = \" + getMethodCall().getText() + \";\", myInnerMethod);\n        if (methodCallStatement instanceof PsiIfStatement) {\n          methodCallStatement.getParent().addBefore(declarationStatement, methodCallStatement);\n          final PsiExpression conditionExpression = ((PsiIfStatement)methodCallStatement).getCondition();\n          conditionExpression.replace(myElementFactory.createExpressionFromText(object + \".is()\", myInnerMethod));\n        } else if (myElements[0] instanceof PsiExpression){\n          methodCallStatement.getParent().addBefore(declarationStatement, methodCallStatement);\n        } else {\n          methodCallStatement.replace(declarationStatement);\n        }\n\n        final List<PsiVariable> usedVariables = myControlFlowWrapper.getUsedVariables();\n        Collection<ControlFlowUtil.VariableInfo> reassigned = myControlFlowWrapper.getInitializedTwice();\n        for (PsiVariable variable : usedVariables) {\n          String name = variable.getName();\n          LOG.assertTrue(name != null);\n          PsiStatement st = null;\n          final String pureName = getPureName(variable);\n          final int varIdxInOutput = ArrayUtil.find(myOutputVariables, variable);\n          final String getterName = varIdxInOutput > -1 && myOutputFields[varIdxInOutput] != null ? PropertyUtil.suggestGetterName(myProject, myOutputFields[varIdxInOutput]) : PropertyUtil.suggestGetterName(pureName, variable.getType());\n          if (isDeclaredInside(variable)) {\n            st = myElementFactory.createStatementFromText(\n              variable.getType().getCanonicalText() + \" \" + name + \" = \" + object + \".\" + getterName + \"();\",\n              myInnerMethod);\n            if (reassigned.contains(new ControlFlowUtil.VariableInfo(variable, null))) {\n              final PsiElement[] psiElements = ((PsiDeclarationStatement)st).getDeclaredElements();\n              assert psiElements.length > 0;\n              PsiVariable var = (PsiVariable)psiElements[0];\n              PsiUtil.setModifierProperty(var, PsiModifier.FINAL, false);\n            }\n          }\n          else {\n            if (varIdxInOutput != -1) {\n              st = myElementFactory.createStatementFromText(name + \" = \" + object + \".\" + getterName + \"();\", myInnerMethod);\n            }\n          }\n          if (st != null) {\n            addToMethodCallLocation(st);\n          }\n        }\n        if (myElements[0] instanceof PsiAssignmentExpression) {\n          getMethodCall().getParent().replace(((PsiAssignmentExpression)getMethodCall().getParent()).getLExpression());\n        } else if (myElements[0] instanceof PsiPostfixExpression || myElements[0] instanceof PsiPrefixExpression) {\n          getMethodCall().getParent().replace(((PsiBinaryExpression)getMethodCall().getParent()).getLOperand());\n        }\n      }\n      else {\n        super.declareNecessaryVariablesAfterCall(outputVariable);\n      }\n    }","commit_id":"b4a99e051b730fd29659296155ef1d58ba42e92a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void findUsagesForMethod(PsiMethod overridingMethod, List<FixableUsageInfo> usages, boolean changeSignature) {\n    final PsiCodeBlock body = overridingMethod.getBody();\n    final String baseParameterName = StringUtil.decapitalize(className);\n    final String fixedParamName =\n      body != null\n      ? JavaCodeStyleManager.getInstance(myProject).suggestUniqueVariableName(baseParameterName, body.getLBrace(), true)\n      : JavaCodeStyleManager.getInstance(myProject).propertyNameToVariableName(baseParameterName, VariableKind.PARAMETER);\n\n    usages.add(new MergeMethodArguments(overridingMethod, className, packageName, fixedParamName, paramsToMerge, typeParams, keepMethodAsDelegate, myCreateInnerClass ? method.getContainingClass() : null, changeSignature));\n\n    final ParamUsageVisitor visitor = new ParamUsageVisitor(overridingMethod, paramsToMerge);\n    overridingMethod.accept(visitor);\n    final Set<PsiReferenceExpression> values = visitor.getParameterUsages();\n    for (PsiReferenceExpression paramUsage : values) {\n      final PsiParameter parameter = (PsiParameter)paramUsage.resolve();\n      assert parameter != null;\n      final PsiMethod containingMethod = (PsiMethod)parameter.getDeclarationScope();\n      final int index = containingMethod.getParameterList().getParameterIndex(parameter);\n      final PsiParameter replacedParameter = method.getParameterList().getParameters()[index];\n      final ParameterChunk parameterChunk = ParameterChunk.getChunkByParameter(parameter, parameters);\n\n      @NonNls String getter = parameterChunk != null ? parameterChunk.getter : null;\n      final String paramName = parameterChunk != null ? parameterChunk.parameter.name : replacedParameter.getName();\n      final PsiType paramType = parameterChunk != null ? parameterChunk.parameter.type : replacedParameter.getType();\n      if (getter == null) {\n        getter = GenerateMembersUtil.suggestGetterName(paramName, paramType, myProject);\n        paramsNeedingGetters.add(replacedParameter);\n      }\n      @NonNls String setter = parameterChunk != null ? parameterChunk.setter : null;\n      if (setter == null) {\n        setter = GenerateMembersUtil.suggestSetterName(paramName, paramType, myProject);\n      }\n      if (RefactoringUtil.isPlusPlusOrMinusMinus(paramUsage.getParent())) {\n        usages.add(new ReplaceParameterIncrementDecrement(paramUsage, fixedParamName, setter, getter));\n        if (parameterChunk == null || parameterChunk.setter == null) {\n          paramsNeedingSetters.add(replacedParameter);\n        }\n      }\n      else if (RefactoringUtil.isAssignmentLHS(paramUsage)) {\n        usages.add(new ReplaceParameterAssignmentWithCall(paramUsage, fixedParamName, setter, getter));\n        if (parameterChunk == null || parameterChunk.setter == null) {\n          paramsNeedingSetters.add(replacedParameter);\n        }\n      }\n      else {\n        usages.add(new ReplaceParameterReferenceWithCall(paramUsage, fixedParamName, getter));\n      }\n    }\n  }","id":43932,"modified_method":"private void findUsagesForMethod(PsiMethod overridingMethod, List<FixableUsageInfo> usages, boolean changeSignature) {\n    final PsiCodeBlock body = overridingMethod.getBody();\n    final String baseParameterName = StringUtil.decapitalize(className);\n    final String fixedParamName =\n      body != null\n      ? JavaCodeStyleManager.getInstance(myProject).suggestUniqueVariableName(baseParameterName, body.getLBrace(), true)\n      : JavaCodeStyleManager.getInstance(myProject).propertyNameToVariableName(baseParameterName, VariableKind.PARAMETER);\n\n    usages.add(new MergeMethodArguments(overridingMethod, className, packageName, fixedParamName, paramsToMerge, typeParams, keepMethodAsDelegate, myCreateInnerClass ? method.getContainingClass() : null, changeSignature));\n\n    final ParamUsageVisitor visitor = new ParamUsageVisitor(overridingMethod, paramsToMerge);\n    overridingMethod.accept(visitor);\n    final Set<PsiReferenceExpression> values = visitor.getParameterUsages();\n    for (PsiReferenceExpression paramUsage : values) {\n      final PsiParameter parameter = (PsiParameter)paramUsage.resolve();\n      assert parameter != null;\n      final PsiMethod containingMethod = (PsiMethod)parameter.getDeclarationScope();\n      final int index = containingMethod.getParameterList().getParameterIndex(parameter);\n      final PsiParameter replacedParameter = method.getParameterList().getParameters()[index];\n      final ParameterChunk parameterChunk = ParameterChunk.getChunkByParameter(parameter, parameters);\n\n      @NonNls String getter = parameterChunk != null ? parameterChunk.getter : null;\n      final String paramName = parameterChunk != null ? parameterChunk.parameter.name : replacedParameter.getName();\n      final PsiType paramType = parameterChunk != null ? parameterChunk.parameter.type : replacedParameter.getType();\n      if (getter == null) {\n        getter = parameterChunk != null && parameterChunk.field != null ? GenerateMembersUtil.suggestGetterName(parameterChunk.field) \n                                                                        : GenerateMembersUtil.suggestGetterName(paramName, paramType, myProject);\n        paramsNeedingGetters.add(replacedParameter);\n      }\n      @NonNls String setter = parameterChunk != null ? parameterChunk.setter : null;\n      if (setter == null) {\n        setter = parameterChunk != null && parameterChunk.field != null ? GenerateMembersUtil.suggestSetterName(parameterChunk.field)\n                                                                        : GenerateMembersUtil.suggestSetterName(paramName, paramType, myProject);\n      }\n      if (RefactoringUtil.isPlusPlusOrMinusMinus(paramUsage.getParent())) {\n        usages.add(new ReplaceParameterIncrementDecrement(paramUsage, fixedParamName, setter, getter));\n        if (parameterChunk == null || parameterChunk.setter == null) {\n          paramsNeedingSetters.add(replacedParameter);\n        }\n      }\n      else if (RefactoringUtil.isAssignmentLHS(paramUsage)) {\n        usages.add(new ReplaceParameterAssignmentWithCall(paramUsage, fixedParamName, setter, getter));\n        if (parameterChunk == null || parameterChunk.setter == null) {\n          paramsNeedingSetters.add(replacedParameter);\n        }\n      }\n      else {\n        usages.add(new ReplaceParameterReferenceWithCall(paramUsage, fixedParamName, getter));\n      }\n    }\n  }","commit_id":"7a0ae14c434c269d39e4d7c25ff661415a8e96e1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeXML(XMLOutput xmlOutput, @CheckForNull Object destination) throws IOException {\n\t\tXMLAttributeList attributeList = new XMLAttributeList();\n\t\tif (getProjectName() != null) {\n\t        attributeList = attributeList.addAttribute(PROJECTNAME_ATTRIBUTE_NAME, getProjectName());\n        }\n\t\txmlOutput.openTag(\n\t\t\t\tBugCollection.PROJECT_ELEMENT_NAME,\n\t\t\t\tattributeList\n\t\t\t\t);\n\n\t\tXMLOutputUtil.writeElementList(xmlOutput, JAR_ELEMENT_NAME, analysisTargets);\n\t\tXMLOutputUtil.writeElementList(xmlOutput, AUX_CLASSPATH_ENTRY_ELEMENT_NAME, auxClasspathEntryList);\n\t\tXMLOutputUtil.writeElementList(xmlOutput, SRC_DIR_ELEMENT_NAME, srcDirList);\n\t\tXMLOutputUtil.writeFileList(xmlOutput, WRK_DIR_ELEMENT_NAME, currentWorkingDirectoryList);\n\t\tif (suppressionFilter != null && !suppressionFilter.isEmpty()) {\n\t\t\txmlOutput.openTag(\"SuppressionFilter\");\n\t\t\tsuppressionFilter.writeBodyAsXML(xmlOutput);\n\t\t\txmlOutput.closeTag(\"SuppressionFilter\");\n\t\t}\n\t\t\n\t\tif (cloudId != null) {\n\t\t\txmlOutput.startTag(CLOUD_ELEMENT_NAME);\n\t\t\txmlOutput.addAttribute(CLOUD_ID_ATTRIBUTE_NAME, cloudId);\n\t\t\txmlOutput.stopTag(false);\n\t\t\tfor(Map.Entry e : cloudProperties.entrySet()) {\n\t\t\t\txmlOutput.startTag(CLOUD_PROPERTY_ELEMENT_NAME);\n\t\t\t\txmlOutput.addAttribute(\"key\", e.getKey().toString());\n\t\t\t\txmlOutput.stopTag(false);\n\t\t\t\tObject value = e.getValue();\n\t\t\t\txmlOutput.writeText(value.toString());\n\t\t\t\txmlOutput.closeTag(CLOUD_PROPERTY_ELEMENT_NAME);\n\t\t\t}\n\t\t\txmlOutput.closeTag(CLOUD_ELEMENT_NAME);\t\n\t\t\t\n\t\t}\n\t\t\t\n\t\txmlOutput.closeTag(BugCollection.PROJECT_ELEMENT_NAME);\n\t}","id":43933,"modified_method":"public void writeXML(XMLOutput xmlOutput, @CheckForNull File destination) throws IOException {\n\t\tXMLAttributeList attributeList = new XMLAttributeList();\n\t\tif (getProjectName() != null) {\n\t        attributeList = attributeList.addAttribute(PROJECTNAME_ATTRIBUTE_NAME, getProjectName());\n        }\n\t\txmlOutput.openTag(\n\t\t\t\tBugCollection.PROJECT_ELEMENT_NAME,\n\t\t\t\tattributeList\n\t\t\t\t);\n\n\t\tString base = destination.getParent();\n\t\twriteElementList(xmlOutput, JAR_ELEMENT_NAME, convertToRelative(analysisTargets, base));\n\t\twriteElementList(xmlOutput, AUX_CLASSPATH_ENTRY_ELEMENT_NAME, convertToRelative(auxClasspathEntryList, base));\n\t\twriteElementList(xmlOutput, SRC_DIR_ELEMENT_NAME, convertToRelative(srcDirList, base));\n\n\t\tList<String> cwdStrings = new ArrayList<String>();\n\t\tfor (File file : currentWorkingDirectoryList)\n\t\t\tcwdStrings.add(file.getPath());\n\t\tXMLOutputUtil.writeElementList(xmlOutput, WRK_DIR_ELEMENT_NAME, convertToRelative(cwdStrings, base));\n\t\tif (suppressionFilter != null && !suppressionFilter.isEmpty()) {\n\t\t\txmlOutput.openTag(\"SuppressionFilter\");\n\t\t\tsuppressionFilter.writeBodyAsXML(xmlOutput);\n\t\t\txmlOutput.closeTag(\"SuppressionFilter\");\n\t\t}\n\t\t\n\t\tif (cloudId != null) {\n\t\t\txmlOutput.startTag(CLOUD_ELEMENT_NAME);\n\t\t\txmlOutput.addAttribute(CLOUD_ID_ATTRIBUTE_NAME, cloudId);\n\t\t\txmlOutput.stopTag(false);\n\t\t\tfor(Map.Entry e : cloudProperties.entrySet()) {\n\t\t\t\txmlOutput.startTag(CLOUD_PROPERTY_ELEMENT_NAME);\n\t\t\t\txmlOutput.addAttribute(\"key\", e.getKey().toString());\n\t\t\t\txmlOutput.stopTag(false);\n\t\t\t\tObject value = e.getValue();\n\t\t\t\txmlOutput.writeText(value.toString());\n\t\t\t\txmlOutput.closeTag(CLOUD_PROPERTY_ELEMENT_NAME);\n\t\t\t}\n\t\t\txmlOutput.closeTag(CLOUD_ELEMENT_NAME);\t\n\t\t\t\n\t\t}\n\t\t\t\n\t\txmlOutput.closeTag(BugCollection.PROJECT_ELEMENT_NAME);\n\t}","commit_id":"67f1e25e0de32f02fdc78329d972d15af37f1038","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"List<String> makeRelative(List<String> files, @CheckForNull Object destination) {\n\t\tif (destination == null) {\n\t        return files;\n        }\n\t\tif (currentWorkingDirectoryList.isEmpty()) {\n\t        return files;\n        }\n\t\tif (destination instanceof File) {\n\t\t\tFile where = (File)destination;\n\t\t\tif (where.getParentFile().equals(currentWorkingDirectoryList.get(0))) {\n\t\t\t\tList<String> result = new ArrayList<String>(files.size());\n\t\t\t\tString root = where.getParent();\n\t\t\t\tfor(String s : files) {\n\t\t\t\t\tif (s.startsWith(root)) {\n\t                    result.add(s.substring(root.length()));\n                    } else {\n\t                    result.add(s);\n                    }\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn files;\n\t}","id":43934,"modified_method":"private Iterable<String> convertToRelative(List<String> paths, String base) {\n\t\tList<String> newList = new ArrayList<String>(paths.size());\n\t\tfor (String path : paths) {\n\t\t\tnewList.add(convertToRelative(path, base));\n\t\t}\n\t\treturn newList;\n\t}","commit_id":"67f1e25e0de32f02fdc78329d972d15af37f1038","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public  void writeXML(File f) throws IOException {\n\t\tOutputStream out  = new FileOutputStream(f);\n\t\tXMLOutput xmlOutput = new OutputStreamXMLOutput(out);\n\t\ttry {\n\t\t\twriteXML(xmlOutput);\n\t\t} finally {\n\t\t\txmlOutput.finish();\n\t\t}\n\t}","id":43935,"modified_method":"public  void writeXML(File f) throws IOException {\n\t\tOutputStream out  = new FileOutputStream(f);\n\t\tXMLOutput xmlOutput = new OutputStreamXMLOutput(out);\n\t\ttry {\n\t\t\twriteXML(xmlOutput, f);\n\t\t} finally {\n\t\t\txmlOutput.finish();\n\t\t}\n\t}","commit_id":"67f1e25e0de32f02fdc78329d972d15af37f1038","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void endElement(String uri, String name, String qName) throws SAXException {\n\t\t// URI should always be empty.\n\t\t// So, qName is the name of the element.\n\t\t\n\t\tif (discardedElement(qName)) {\n\t\t\tnestingOfIgnoredElements--;\n\t\t} else if (nestingOfIgnoredElements > 0) {\n\t\t\t// ignore it\n\t\t} else if (elementStack.size() > 1) {\n\t\t\tString outerElement = elementStack.get(elementStack.size() - 2);\n\n\t\t\tif (qName.equals(\"Or\") || qName.equals(\"And\") || qName.equals(\"Match\") || isTopLevelFilter(qName)) {\n\t\t\t\tif (DEBUG) System.out.println(\"  ending \" + elementStack + \" \" + qName + \" \" + matcherStack);\n\t\t\t\t\n\t\t\t\tmatcherStack.pop();\n\t\t\t} else if (outerElement.equals(BUG_COLLECTION)) {\n\t\t\t\tif (qName.equals(\"BugInstance\")) {\n\t\t\t\t\tbugCollection.add(bugInstance, false);\n\t\t\t\t   if (!bugInstance.isDead())\n\t\t\t\t\t\tbugCollection.getProjectStats().addBug(bugInstance);\n\t\t\t\t}\n\t\t\t} else if (outerElement.equals(PROJECT)) {\n\t\t\t\t//System.out.println(\"Adding project element \" + qName + \": \" + getTextContents());\n\t\t\t\tif (qName.equals(\"Jar\"))\n\t\t\t\t\tproject.addFile(getTextContents());\n\t\t\t\telse if (qName.equals(\"SrcDir\"))\n\t\t\t\t\tproject.addSourceDir(getTextContents());\n\t\t\t\telse if (qName.equals(\"AuxClasspathEntry\"))\n\t\t\t\t\tproject.addAuxClasspathEntry(getTextContents());\n\t\t\t}\telse if (outerElement.equals(Project.CLOUD_ELEMENT_NAME) && qName.equals(Project.CLOUD_PROPERTY_ELEMENT_NAME)) {\n\t\t\t\t\tassert cloudPropertyKey != null;\n\t\t\t\t\tproject.getCloudProperties().setProperty(cloudPropertyKey, getTextContents());\n\t\t\t\t\tcloudPropertyKey = null;\n\t\t\t} else if (outerElement.equals(\"BugInstance\")) {\n\t\t\t\tif (qName.equals(\"UserAnnotation\")) {\n                    bugInstance.setAnnotationText(getTextContents(), null);\n                }\n\t\t\t} else if (outerElement.equals(BugCollection.ERRORS_ELEMENT_NAME)) {\n\t\t\t\tif (qName.equals(BugCollection.ANALYSIS_ERROR_ELEMENT_NAME)) {\n\t\t\t\t\tanalysisError.setMessage(getTextContents());\n\t\t\t\t\tbugCollection.addError(analysisError);\n\t\t\t\t} else if (qName.equals(BugCollection.ERROR_ELEMENT_NAME)) {\n\t\t\t\t\tif (stackTrace.size() > 0) {\n\t\t\t\t\t\tanalysisError.setStackTrace(stackTrace.toArray(new String[stackTrace.size()]));\n\t\t\t\t\t}\n\t\t\t\t\tbugCollection.addError(analysisError);\n\t\t\t\t} else if (qName.equals(BugCollection.MISSING_CLASS_ELEMENT_NAME)) {\n\t\t\t\t\tbugCollection.addMissingClass(getTextContents());\n\t\t\t\t}\n\n\t\t\t} else if (outerElement.equals(BugCollection.ERROR_ELEMENT_NAME)) {\n\t\t\t\tif (qName.equals(BugCollection.ERROR_MESSAGE_ELEMENT_NAME)) {\n\t\t\t\t\tanalysisError.setMessage(getTextContents());\n\t\t\t\t} else if (qName.equals(BugCollection.ERROR_EXCEPTION_ELEMENT_NAME)) {\n\t\t\t\t\tanalysisError.setExceptionMessage(getTextContents());\n\t\t\t\t} else if (qName.equals(BugCollection.ERROR_STACK_TRACE_ELEMENT_NAME)) {\n\t\t\t\t\tstackTrace.add(getTextContents());\n\t\t\t\t}\n\t\t\t} else if (outerElement.equals(\"ClassFeatures\")) {\n\t\t\t\tif (qName.equals(ClassFeatureSet.ELEMENT_NAME)) {\n\t\t\t\t\tbugCollection.setClassFeatureSet(classFeatureSet);\n\t\t\t\t\tclassFeatureSet = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telementStack.remove(elementStack.size() - 1);\n\t}","id":43936,"modified_method":"@Override\n\tpublic void endElement(String uri, String name, String qName) throws SAXException {\n\t\t// URI should always be empty.\n\t\t// So, qName is the name of the element.\n\t\t\n\t\tif (discardedElement(qName)) {\n\t\t\tnestingOfIgnoredElements--;\n\t\t} else if (nestingOfIgnoredElements > 0) {\n\t\t\t// ignore it\n\t\t} else if (elementStack.size() > 1) {\n\t\t\tString outerElement = elementStack.get(elementStack.size() - 2);\n\n\t\t\tif (qName.equals(\"Or\") || qName.equals(\"And\") || qName.equals(\"Match\") || isTopLevelFilter(qName)) {\n\t\t\t\tif (DEBUG) System.out.println(\"  ending \" + elementStack + \" \" + qName + \" \" + matcherStack);\n\t\t\t\t\n\t\t\t\tmatcherStack.pop();\n\t\t\t} else if (outerElement.equals(BUG_COLLECTION)) {\n\t\t\t\tif (qName.equals(\"BugInstance\")) {\n\t\t\t\t\tbugCollection.add(bugInstance, false);\n\t\t\t\t   if (!bugInstance.isDead())\n\t\t\t\t\t\tbugCollection.getProjectStats().addBug(bugInstance);\n\t\t\t\t}\n\t\t\t} else if (outerElement.equals(PROJECT)) {\n\t\t\t\t//System.out.println(\"Adding project element \" + qName + \": \" + getTextContents());\n\t\t\t\tif (qName.equals(\"Jar\"))\n\t\t\t\t\tproject.addFile(makeAbsolute(getTextContents()));\n\t\t\t\telse if (qName.equals(\"SrcDir\"))\n\t\t\t\t\tproject.addSourceDir(makeAbsolute(getTextContents()));\n\t\t\t\telse if (qName.equals(\"AuxClasspathEntry\"))\n\t\t\t\t\tproject.addAuxClasspathEntry(makeAbsolute(getTextContents()));\n\t\t\t}\telse if (outerElement.equals(Project.CLOUD_ELEMENT_NAME) && qName.equals(Project.CLOUD_PROPERTY_ELEMENT_NAME)) {\n\t\t\t\t\tassert cloudPropertyKey != null;\n\t\t\t\t\tproject.getCloudProperties().setProperty(cloudPropertyKey, getTextContents());\n\t\t\t\t\tcloudPropertyKey = null;\n\t\t\t} else if (outerElement.equals(\"BugInstance\")) {\n\t\t\t\tif (qName.equals(\"UserAnnotation\")) {\n                    bugInstance.setAnnotationText(getTextContents(), null);\n                }\n\t\t\t} else if (outerElement.equals(BugCollection.ERRORS_ELEMENT_NAME)) {\n\t\t\t\tif (qName.equals(BugCollection.ANALYSIS_ERROR_ELEMENT_NAME)) {\n\t\t\t\t\tanalysisError.setMessage(getTextContents());\n\t\t\t\t\tbugCollection.addError(analysisError);\n\t\t\t\t} else if (qName.equals(BugCollection.ERROR_ELEMENT_NAME)) {\n\t\t\t\t\tif (stackTrace.size() > 0) {\n\t\t\t\t\t\tanalysisError.setStackTrace(stackTrace.toArray(new String[stackTrace.size()]));\n\t\t\t\t\t}\n\t\t\t\t\tbugCollection.addError(analysisError);\n\t\t\t\t} else if (qName.equals(BugCollection.MISSING_CLASS_ELEMENT_NAME)) {\n\t\t\t\t\tbugCollection.addMissingClass(getTextContents());\n\t\t\t\t}\n\n\t\t\t} else if (outerElement.equals(BugCollection.ERROR_ELEMENT_NAME)) {\n\t\t\t\tif (qName.equals(BugCollection.ERROR_MESSAGE_ELEMENT_NAME)) {\n\t\t\t\t\tanalysisError.setMessage(getTextContents());\n\t\t\t\t} else if (qName.equals(BugCollection.ERROR_EXCEPTION_ELEMENT_NAME)) {\n\t\t\t\t\tanalysisError.setExceptionMessage(getTextContents());\n\t\t\t\t} else if (qName.equals(BugCollection.ERROR_STACK_TRACE_ELEMENT_NAME)) {\n\t\t\t\t\tstackTrace.add(getTextContents());\n\t\t\t\t}\n\t\t\t} else if (outerElement.equals(\"ClassFeatures\")) {\n\t\t\t\tif (qName.equals(ClassFeatureSet.ELEMENT_NAME)) {\n\t\t\t\t\tbugCollection.setClassFeatureSet(classFeatureSet);\n\t\t\t\t\tclassFeatureSet = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telementStack.remove(elementStack.size() - 1);\n\t}","commit_id":"67f1e25e0de32f02fdc78329d972d15af37f1038","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Test\n    public void testClientListeners_InSplitBrain() throws InterruptedException {\n        Config config = new Config();\n        config.setProperty(GroupProperties.PROP_MERGE_FIRST_RUN_DELAY_SECONDS, \"5\");\n        config.setProperty(GroupProperties.PROP_MERGE_NEXT_RUN_DELAY_SECONDS, \"5\");\n        HazelcastInstance h1 = Hazelcast.newHazelcastInstance(config);\n        HazelcastInstance h2 = Hazelcast.newHazelcastInstance(config);\n\n        final ClientConfig clientConfig = new ClientConfig();\n        clientConfig.addAddress(\"127.0.0.1\");\n        final HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);\n\n        final String mapName = randomMapName();\n        final IMap<Object, Boolean> map1 = h1.getMap(mapName);\n        final IMap<Object, Boolean> map2 = h2.getMap(mapName);\n        final IMap<Object, Boolean> mapC = client.getMap(mapName);\n\n        final CountDownLatch mergedLatch = new CountDownLatch(1);\n\n        final int ITERATION_COUNT = 20;\n        final AtomicInteger[] atomicIntegers = new AtomicInteger[ITERATION_COUNT];\n        for (int i = 0; i < ITERATION_COUNT; i++) {\n            atomicIntegers[i] = new AtomicInteger(0);\n        }\n\n        h1.getLifecycleService().addLifecycleListener(new LifecycleListener() {\n            public void stateChanged(LifecycleEvent event) {\n                if (event.getState() == LifecycleEvent.LifecycleState.MERGED) {\n                    mergedLatch.countDown();\n                }\n            }\n        });\n\n        h2.getLifecycleService().addLifecycleListener(new LifecycleListener() {\n            public void stateChanged(LifecycleEvent event) {\n                if (event.getState() == LifecycleEvent.LifecycleState.MERGED) {\n                    mergedLatch.countDown();\n                }\n            }\n        });\n\n        map1.addEntryListener(new EntryAdapter<Object, Boolean>() {\n            @Override\n            public void onEntryEvent(EntryEvent<Object, Boolean> event) {\n                final Boolean shouldCount = event.getValue();\n                if (shouldCount) {\n                    atomicIntegers[(Integer) event.getKey()].incrementAndGet();\n                }\n            }\n        }, true);\n\n        map2.addEntryListener(new EntryAdapter<Object, Boolean>() {\n            @Override\n            public void onEntryEvent(EntryEvent<Object, Boolean> event) {\n                final Boolean shouldCount = event.getValue();\n                if (shouldCount) {\n                    atomicIntegers[(Integer) event.getKey()].incrementAndGet();\n                }\n            }\n        }, true);\n\n\n        mapC.addEntryListener(new EntryAdapter<Object, Boolean>() {\n            @Override\n            public void onEntryEvent(EntryEvent<Object, Boolean> event) {\n                final Boolean shouldCount = event.getValue();\n                if (shouldCount) {\n                    atomicIntegers[(Integer) event.getKey()].incrementAndGet();\n                }\n            }\n        }, true);\n\n\n        closeConnectionBetween(h2, h1);\n        final Random random = new Random();\n\n        final Thread clientThread = new Thread() {\n            @Override\n            public void run() {\n\n                //Just to generate pressure\n                while (mergedLatch.getCount() != 0) {\n                    mapC.put(random.nextInt() % 1000, false);\n                }\n\n                for (int i = 0; i < ITERATION_COUNT; i++) {\n                    mapC.put(i, true);\n                }\n            }\n        };\n\n        clientThread.start();\n        assertTrue(mergedLatch.await(30, TimeUnit.SECONDS));\n        assertEquals(2, h1.getCluster().getMembers().size());\n        assertEquals(2, h2.getCluster().getMembers().size());\n        clientThread.join();\n\n        for (int i = 0; i < ITERATION_COUNT; i++) {\n            final int id = i;\n            assertTrueEventually(new AssertTask() {\n                @Override\n                public void run() throws Exception {\n                    assertEquals(\"id \" + id, 3, atomicIntegers[id].get());\n                }\n            }, 10);\n        }\n\n\n    }","id":43937,"modified_method":"@Test\n    @Repeat(10)\n    public void testClientListeners_InSplitBrain() throws InterruptedException {\n        Config config = new Config();\n        config.setProperty(GroupProperties.PROP_MERGE_FIRST_RUN_DELAY_SECONDS, \"5\");\n        config.setProperty(GroupProperties.PROP_MERGE_NEXT_RUN_DELAY_SECONDS, \"5\");\n        HazelcastInstance h1 = Hazelcast.newHazelcastInstance(config);\n        HazelcastInstance h2 = Hazelcast.newHazelcastInstance(config);\n\n        final ClientConfig clientConfig = new ClientConfig();\n        final HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);\n\n        final String mapName = randomMapName();\n        final IMap<Object, Boolean> mapNode1 = h1.getMap(mapName);\n        final IMap<Object, Boolean> mapNode2 = h2.getMap(mapName);\n        final IMap<Object, Boolean> mapClient = client.getMap(mapName);\n\n        final int ITERATION_COUNT = 20;\n        final AtomicInteger[] atomicIntegers = new AtomicInteger[ITERATION_COUNT];\n        for (int i = 0; i < ITERATION_COUNT; i++) {\n            atomicIntegers[i] = new AtomicInteger(0);\n        }\n\n        final CountDownLatch mergedLatch = new CountDownLatch(1);\n        final LifecycleListener mergeListener = new LifecycleListener() {\n            public void stateChanged(LifecycleEvent event) {\n                if (event.getState() == LifecycleEvent.LifecycleState.MERGED) {\n                    mergedLatch.countDown();\n                }\n            }\n        };\n        h1.getLifecycleService().addLifecycleListener(mergeListener);\n        h2.getLifecycleService().addLifecycleListener(mergeListener);\n\n        final EntryAdapter<Object, Boolean> entryListener = new EntryAdapter<Object, Boolean>() {\n            @Override\n            public void onEntryEvent(EntryEvent<Object, Boolean> event) {\n                final Boolean shouldCount = event.getValue();\n                if (shouldCount) {\n                    atomicIntegers[(Integer) event.getKey()].incrementAndGet();\n                }\n            }\n        };\n        mapNode1.addEntryListener(entryListener, true);\n        mapNode2.addEntryListener(entryListener, true);\n        mapClient.addEntryListener(entryListener, true);\n\n        closeConnectionBetween(h2, h1);\n\n        final Random random = new Random();\n        final Thread clientThread = new Thread() {\n            @Override\n            public void run() {\n                //Just to generate pressure\n                while (mergedLatch.getCount() != 0) {\n                    mapClient.put(random.nextInt() % 1000, false);\n                }\n\n                for (int i = 0; i < ITERATION_COUNT; i++) {\n                    mapClient.put(i, true);\n                }\n            }\n        };\n\n        clientThread.start();\n        assertTrue(mergedLatch.await(30, TimeUnit.SECONDS));\n        assertEquals(2, h1.getCluster().getMembers().size());\n        assertEquals(2, h2.getCluster().getMembers().size());\n        clientThread.join();\n\n        for (int i = 0; i < ITERATION_COUNT; i++) {\n            final int id = i;\n            assertTrueEventually(new AssertTask() {\n                @Override\n                public void run() throws Exception {\n                    assertEquals(\"id \" + id, 3, atomicIntegers[id].get());\n                }\n            }, 10);\n        }\n\n\n    }","commit_id":"2deb73ff3a379a2710f396ad102ffa70bab9bede","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testClientListeners_InSplitBrain() throws InterruptedException {\n        Config config = new Config();\n        config.setProperty(GroupProperties.PROP_MERGE_FIRST_RUN_DELAY_SECONDS, \"5\");\n        config.setProperty(GroupProperties.PROP_MERGE_NEXT_RUN_DELAY_SECONDS, \"5\");\n        HazelcastInstance h1 = Hazelcast.newHazelcastInstance(config);\n        HazelcastInstance h2 = Hazelcast.newHazelcastInstance(config);\n\n        final ClientConfig clientConfig = new ClientConfig();\n        clientConfig.addAddress(\"127.0.0.1\");\n        final HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);\n\n        final String mapName = randomMapName();\n        final IMap<Object, Boolean> map1 = h1.getMap(mapName);\n        final IMap<Object, Boolean> map2 = h2.getMap(mapName);\n        final IMap<Object, Boolean> mapC = client.getMap(mapName);\n\n        final CountDownLatch mergedLatch = new CountDownLatch(1);\n\n        final int ITERATION_COUNT = 20;\n        final AtomicInteger[] atomicIntegers = new AtomicInteger[ITERATION_COUNT];\n        for (int i = 0; i < ITERATION_COUNT; i++) {\n            atomicIntegers[i] = new AtomicInteger(0);\n        }\n\n        h1.getLifecycleService().addLifecycleListener(new LifecycleListener() {\n            public void stateChanged(LifecycleEvent event) {\n                if (event.getState() == LifecycleEvent.LifecycleState.MERGED) {\n                    mergedLatch.countDown();\n                }\n            }\n        });\n\n        h2.getLifecycleService().addLifecycleListener(new LifecycleListener() {\n            public void stateChanged(LifecycleEvent event) {\n                if (event.getState() == LifecycleEvent.LifecycleState.MERGED) {\n                    mergedLatch.countDown();\n                }\n            }\n        });\n\n        map1.addEntryListener(new EntryAdapter<Object, Boolean>() {\n            @Override\n            public void onEntryEvent(EntryEvent<Object, Boolean> event) {\n                final Boolean shouldCount = event.getValue();\n                if (shouldCount) {\n                    atomicIntegers[(Integer) event.getKey()].incrementAndGet();\n                }\n            }\n        }, true);\n\n        map2.addEntryListener(new EntryAdapter<Object, Boolean>() {\n            @Override\n            public void onEntryEvent(EntryEvent<Object, Boolean> event) {\n                final Boolean shouldCount = event.getValue();\n                if (shouldCount) {\n                    atomicIntegers[(Integer) event.getKey()].incrementAndGet();\n                }\n            }\n        }, true);\n\n\n        mapC.addEntryListener(new EntryAdapter<Object, Boolean>() {\n            @Override\n            public void onEntryEvent(EntryEvent<Object, Boolean> event) {\n                final Boolean shouldCount = event.getValue();\n                if (shouldCount) {\n                    atomicIntegers[(Integer) event.getKey()].incrementAndGet();\n                }\n            }\n        }, true);\n\n\n        closeConnectionBetween(h2, h1);\n        final Random random = new Random();\n\n        final Thread clientThread = new Thread() {\n            @Override\n            public void run() {\n\n                //Just to generate pressure\n                while (mergedLatch.getCount() != 0) {\n                    mapC.put(random.nextInt() % 1000, false);\n                }\n\n                for (int i = 0; i < ITERATION_COUNT; i++) {\n                    mapC.put(i, true);\n                }\n            }\n        };\n\n        clientThread.start();\n        assertTrue(mergedLatch.await(30, TimeUnit.SECONDS));\n        assertEquals(2, h1.getCluster().getMembers().size());\n        assertEquals(2, h2.getCluster().getMembers().size());\n        clientThread.join();\n\n        for (int i = 0; i < ITERATION_COUNT; i++) {\n            final int id = i;\n            assertTrueEventually(new AssertTask() {\n                @Override\n                public void run() throws Exception {\n                    assertEquals(\"id \" + id, 3, atomicIntegers[id].get());\n                }\n            }, 10);\n        }\n\n\n    }","id":43938,"modified_method":"@Test\n    @Repeat(10)\n    public void testClientListeners_InSplitBrain() throws InterruptedException {\n        Config config = new Config();\n        config.setProperty(GroupProperties.PROP_MERGE_FIRST_RUN_DELAY_SECONDS, \"5\");\n        config.setProperty(GroupProperties.PROP_MERGE_NEXT_RUN_DELAY_SECONDS, \"5\");\n        HazelcastInstance h1 = Hazelcast.newHazelcastInstance(config);\n        HazelcastInstance h2 = Hazelcast.newHazelcastInstance(config);\n\n        final ClientConfig clientConfig = new ClientConfig();\n        final HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);\n\n        final String mapName = randomMapName();\n        final IMap<Object, Boolean> mapNode1 = h1.getMap(mapName);\n        final IMap<Object, Boolean> mapNode2 = h2.getMap(mapName);\n        final IMap<Object, Boolean> mapClient = client.getMap(mapName);\n\n        final int ITERATION_COUNT = 20;\n        final AtomicInteger[] atomicIntegers = new AtomicInteger[ITERATION_COUNT];\n        for (int i = 0; i < ITERATION_COUNT; i++) {\n            atomicIntegers[i] = new AtomicInteger(0);\n        }\n\n        final CountDownLatch mergedLatch = new CountDownLatch(1);\n        final LifecycleListener mergeListener = new LifecycleListener() {\n            public void stateChanged(LifecycleEvent event) {\n                if (event.getState() == LifecycleEvent.LifecycleState.MERGED) {\n                    mergedLatch.countDown();\n                }\n            }\n        };\n        h1.getLifecycleService().addLifecycleListener(mergeListener);\n        h2.getLifecycleService().addLifecycleListener(mergeListener);\n\n        final EntryAdapter<Object, Boolean> entryListener = new EntryAdapter<Object, Boolean>() {\n            @Override\n            public void onEntryEvent(EntryEvent<Object, Boolean> event) {\n                final Boolean shouldCount = event.getValue();\n                if (shouldCount) {\n                    atomicIntegers[(Integer) event.getKey()].incrementAndGet();\n                }\n            }\n        };\n        mapNode1.addEntryListener(entryListener, true);\n        mapNode2.addEntryListener(entryListener, true);\n        mapClient.addEntryListener(entryListener, true);\n\n        closeConnectionBetween(h2, h1);\n\n        final Random random = new Random();\n        final Thread clientThread = new Thread() {\n            @Override\n            public void run() {\n                //Just to generate pressure\n                while (mergedLatch.getCount() != 0) {\n                    mapClient.put(random.nextInt() % 1000, false);\n                }\n\n                for (int i = 0; i < ITERATION_COUNT; i++) {\n                    mapClient.put(i, true);\n                }\n            }\n        };\n\n        clientThread.start();\n        assertTrue(mergedLatch.await(30, TimeUnit.SECONDS));\n        assertEquals(2, h1.getCluster().getMembers().size());\n        assertEquals(2, h2.getCluster().getMembers().size());\n        clientThread.join();\n\n        for (int i = 0; i < ITERATION_COUNT; i++) {\n            final int id = i;\n            assertTrueEventually(new AssertTask() {\n                @Override\n                public void run() throws Exception {\n                    assertEquals(\"id \" + id, 3, atomicIntegers[id].get());\n                }\n            }, 10);\n        }\n\n\n    }","commit_id":"309682b6bccfc51d51956307809f6934cb41e1f3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Nullable\n  public static PsiClass createSubclassGroovy(final GrTypeDefinition psiClass, final PsiDirectory targetDirectory, final String className) {\n    final Project project = psiClass.getProject();\n    final Ref<GrTypeDefinition> targetClass = new Ref<GrTypeDefinition>();\n\n    new WriteCommandAction(project, getTitle(psiClass), getTitle(psiClass)) {\n      @Override\n      protected void run(Result result) throws Throwable {\n        IdeDocumentHistory.getInstance(project).includeCurrentPlaceAsChangePlace();\n\n        final GrTypeParameterList oldTypeParameterList = psiClass.getTypeParameterList();\n\n        try {\n          targetClass.set(CreateClassActionBase.createClassByType(targetDirectory, className, PsiManager.getInstance(project), psiClass,\n                                                                  GroovyTemplates.GROOVY_CLASS, true));\n        }\n        catch (final IncorrectOperationException e) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              Messages.showErrorDialog(project, CodeInsightBundle.message(\"intention.error.cannot.create.class.message\", className) +\n                                                \"\\n\" + e.getLocalizedMessage(),\n                                       CodeInsightBundle.message(\"intention.error.cannot.create.class.title\"));\n            }\n          });\n          return;\n        }\n        startTemplate(oldTypeParameterList, project, psiClass, targetClass.get(), false);\n        PsiElement element = targetClass.get();\n        JavaCodeStyleManager.getInstance(project).shortenClassReferences(element);\n      }\n    }.execute();\n    if (targetClass.get() == null) return null;\n    if (!ApplicationManager.getApplication().isUnitTestMode() && !psiClass.hasTypeParameters()) {\n\n      final Editor editor = CodeInsightUtil.positionCursor(project, targetClass.get().getContainingFile(), targetClass.get().getLBrace());\n      if (editor == null) return targetClass.get();\n      chooseAndImplement(psiClass, project, targetClass.get(), editor);\n    }\n    return targetClass.get();\n  }","id":43939,"modified_method":"@Nullable\n  public static PsiClass createSubclassGroovy(final GrTypeDefinition psiClass, final PsiDirectory targetDirectory, final String className) {\n    final Project project = psiClass.getProject();\n    final Ref<GrTypeDefinition> targetClass = new Ref<GrTypeDefinition>();\n\n    new WriteCommandAction(project, getTitle(psiClass), getTitle(psiClass)) {\n      @Override\n      protected void run(@NotNull Result result) throws Throwable {\n        IdeDocumentHistory.getInstance(project).includeCurrentPlaceAsChangePlace();\n\n        final GrTypeParameterList oldTypeParameterList = psiClass.getTypeParameterList();\n\n        try {\n          targetClass.set(CreateClassActionBase.createClassByType(targetDirectory, className, PsiManager.getInstance(project), psiClass, GroovyTemplates.GROOVY_CLASS, true));\n        }\n        catch (final IncorrectOperationException e) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              Messages.showErrorDialog(project, CodeInsightBundle.message(\"intention.error.cannot.create.class.message\", className) +\n                                                \"\\n\" + e.getLocalizedMessage(),\n                                       CodeInsightBundle.message(\"intention.error.cannot.create.class.title\"));\n            }\n          });\n          return;\n        }\n        startTemplate(oldTypeParameterList, project, psiClass, targetClass.get(), false);\n      }\n    }.execute();\n\n    if (targetClass.get() == null) return null;\n    if (!ApplicationManager.getApplication().isUnitTestMode() && !psiClass.hasTypeParameters()) {\n\n      final Editor editor = CodeInsightUtil.positionCursor(project, targetClass.get().getContainingFile(), targetClass.get().getLBrace());\n      if (editor == null) return targetClass.get();\n      chooseAndImplement(psiClass, project, targetClass.get(), editor);\n    }\n    return targetClass.get();\n  }","commit_id":"5383da83266aab6251c495e19b621bf6317dfc98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void startTemplate(GrTypeParameterList oldTypeParameterList,\n                                    final Project project,\n                                    final GrTypeDefinition psiClass,\n                                    final GrTypeDefinition targetClass,\n                                    boolean includeClassName) {\n    PsiElementFactory jfactory = JavaPsiFacade.getElementFactory(project);\n    final GroovyPsiElementFactory elementFactory = GroovyPsiElementFactory.getInstance(project);\n    GrCodeReferenceElement ref = elementFactory.createCodeReferenceElementFromClass(psiClass);\n    try {\n      if (psiClass.isInterface()) {\n        GrImplementsClause clause = targetClass.getImplementsClause();\n        if (clause == null) {\n          clause = (GrImplementsClause)targetClass.addAfter(elementFactory.createImplementsClause(), targetClass.getNameIdentifierGroovy());\n        }\n        ref = (GrCodeReferenceElement)clause.add(ref);\n      }\n      else {\n        GrExtendsClause clause = targetClass.getExtendsClause();\n        if (clause == null) {\n          clause = (GrExtendsClause)targetClass.addAfter(elementFactory.createExtendsClause(), targetClass.getNameIdentifierGroovy());\n        }\n        ref = (GrCodeReferenceElement)clause.add(ref);\n      }\n      if (psiClass.hasTypeParameters() || includeClassName) {\n        final Editor editor = CodeInsightUtil.positionCursor(project, targetClass.getContainingFile(), targetClass.getLBrace());\n        final TemplateBuilderImpl templateBuilder = editor == null || ApplicationManager.getApplication().isUnitTestMode() ? null\n                                                    : (TemplateBuilderImpl)TemplateBuilderFactory.getInstance().createTemplateBuilder(targetClass);\n\n        if (includeClassName && templateBuilder != null) {\n          templateBuilder.replaceElement(targetClass.getNameIdentifier(), targetClass.getName());\n        }\n\n        if (oldTypeParameterList != null) {\n          for (PsiTypeParameter parameter : oldTypeParameterList.getTypeParameters()) {\n            final PsiElement param = ref.getTypeArgumentList().add(elementFactory.createTypeElement(jfactory.createType(parameter)));\n            if (templateBuilder != null) {\n              templateBuilder.replaceElement(param, param.getText());\n            }\n          }\n        }\n\n        final GrTypeParameterList typeParameterList = targetClass.getTypeParameterList();\n        assert typeParameterList != null;\n        typeParameterList.replace(oldTypeParameterList);\n\n        if (templateBuilder != null) {\n          templateBuilder.setEndVariableBefore(ref);\n          final Template template = templateBuilder.buildTemplate();\n          template.addEndVariable();\n\n          final PsiFile containingFile = targetClass.getContainingFile();\n\n          PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(editor.getDocument());\n\n          final TextRange textRange = targetClass.getTextRange();\n          final int startClassOffset = textRange.getStartOffset();\n          editor.getDocument().deleteString(textRange.getStartOffset(), textRange.getEndOffset());\n          CreateFromUsageBaseFix.startTemplate(editor, template, project, new TemplateEditingAdapter() {\n            @Override\n            public void templateFinished(Template template, boolean brokenOff) {\n              chooseAndImplement(psiClass, project,PsiTreeUtil.getParentOfType(containingFile.findElementAt(startClassOffset), GrTypeDefinition.class),editor);\n            }\n          }, getTitle(psiClass));\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":43940,"modified_method":"private static void startTemplate(GrTypeParameterList oldTypeParameterList,\n                                    final Project project,\n                                    final GrTypeDefinition psiClass,\n                                    final GrTypeDefinition targetClass,\n                                    boolean includeClassName) {\n    PsiElementFactory jfactory = JavaPsiFacade.getElementFactory(project);\n    final GroovyPsiElementFactory elementFactory = GroovyPsiElementFactory.getInstance(project);\n    GrCodeReferenceElement stubRef = elementFactory.createCodeReferenceElementFromClass(psiClass);\n    try {\n      GrReferenceList clause = psiClass.isInterface() ? targetClass.getImplementsClause() : targetClass.getExtendsClause();\n      if (clause == null) {\n        GrReferenceList stubRefList = psiClass.isInterface() ? elementFactory.createImplementsClause() : elementFactory.createExtendsClause();\n        clause = (GrExtendsClause)targetClass.addAfter(stubRefList, targetClass.getNameIdentifierGroovy());\n      }\n      GrCodeReferenceElement ref = (GrCodeReferenceElement)clause.add(stubRef);\n\n      if (psiClass.hasTypeParameters() || includeClassName) {\n        final Editor editor = CodeInsightUtil.positionCursor(project, targetClass.getContainingFile(), targetClass.getLBrace());\n        final TemplateBuilderImpl templateBuilder = editor == null || ApplicationManager.getApplication().isUnitTestMode() ? null\n                                                    : (TemplateBuilderImpl)TemplateBuilderFactory.getInstance().createTemplateBuilder(targetClass);\n\n        if (includeClassName && templateBuilder != null) {\n          templateBuilder.replaceElement(targetClass.getNameIdentifier(), targetClass.getName());\n        }\n\n        if (oldTypeParameterList != null && oldTypeParameterList.getTypeParameters().length > 0) {\n          GrTypeArgumentList existingList = ref.getTypeArgumentList();\n          final GrTypeParameterList typeParameterList =\n            (GrTypeParameterList)targetClass.addAfter(elementFactory.createTypeParameterList(), targetClass.getNameIdentifierGroovy());\n\n          GrTypeArgumentList argList;\n          if (existingList == null) {\n            GrCodeReferenceElement codeRef = elementFactory.createCodeReferenceElementFromText(\"A<T>\");\n            argList = ((GrTypeArgumentList)ref.add(codeRef.getTypeArgumentList()));\n            argList.getTypeArgumentElements()[0].delete();\n          }\n          else {\n            argList = existingList;\n          }\n\n          for (PsiTypeParameter parameter : oldTypeParameterList.getTypeParameters()) {\n            final PsiElement param = argList.add(elementFactory.createTypeElement(jfactory.createType(parameter)));\n            if (templateBuilder != null) {\n              templateBuilder.replaceElement(param, param.getText());\n            }\n\n            typeParameterList.add(elementFactory.createTypeParameter(parameter.getName(), parameter.getExtendsListTypes()));\n          }\n        }\n\n        if (templateBuilder != null) {\n          templateBuilder.setEndVariableBefore(ref);\n          final Template template = templateBuilder.buildTemplate();\n          template.addEndVariable();\n\n          final PsiFile containingFile = targetClass.getContainingFile();\n\n          PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(editor.getDocument());\n\n          final TextRange textRange = targetClass.getTextRange();\n          final RangeMarker startClassOffset = editor.getDocument().createRangeMarker(textRange.getStartOffset(), textRange.getEndOffset());\n          startClassOffset.setGreedyToLeft(true);\n          startClassOffset.setGreedyToRight(true);\n          editor.getDocument().deleteString(textRange.getStartOffset(), textRange.getEndOffset());\n          CreateFromUsageBaseFix.startTemplate(editor, template, project, new TemplateEditingAdapter() {\n            @Override\n            public void templateFinished(Template template, boolean brokenOff) {\n              chooseAndImplement(psiClass, project,PsiTreeUtil.getParentOfType(containingFile.findElementAt(startClassOffset.getStartOffset()), GrTypeDefinition.class),editor);\n            }\n          }, getTitle(psiClass));\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"5383da83266aab6251c495e19b621bf6317dfc98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public JetType visitSuperExpression(JetSuperExpression expression, ExpressionTypingContext context) {\n        if (!context.namespacesAllowed) {\n            context.trace.report(SUPER_IS_NOT_AN_EXPRESSION.on(expression, expression.getText()));\n            return null;\n        }\n        JetType result = null;\n\n        ReceiverDescriptor thisReceiver = resolveToReceiver(expression, context, true);\n        if (thisReceiver == null) return null;\n\n        if (!thisReceiver.exists()) {\n            context.trace.report(SUPER_NOT_AVAILABLE.on(expression));\n        }\n        else {\n            JetType thisType = thisReceiver.getType();\n            Collection<? extends JetType> supertypes = thisType.getConstructor().getSupertypes();\n            TypeSubstitutor substitutor = TypeSubstitutor.create(thisType);\n\n            JetTypeReference superTypeQualifier = expression.getSuperTypeQualifier();\n            if (superTypeQualifier != null) {\n                JetTypeElement typeElement = superTypeQualifier.getTypeElement();\n\n                DeclarationDescriptor classifierCandidate = null;\n                JetType supertype = null;\n                PsiElement redundantTypeArguments = null;\n                if (typeElement instanceof JetUserType) {\n                    JetUserType userType = (JetUserType) typeElement;\n                    // This may be just a superclass name even if the superclass is generic\n                    if (userType.getTypeArguments().isEmpty()) {\n                        classifierCandidate = context.expressionTypingServices.getTypeResolver().resolveClass(context.scope, userType, context.trace);\n                    }\n                    else {\n                        supertype = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, superTypeQualifier, context.trace, true);\n                        redundantTypeArguments = userType.getTypeArgumentList();\n                    }\n                }\n                else {\n                    supertype = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, superTypeQualifier, context.trace, true);\n                }\n\n                if (supertype != null) {\n                    if (supertypes.contains(supertype)) {\n                        result = supertype;\n                    }\n                }\n                else if (classifierCandidate instanceof ClassDescriptor) {\n                    ClassDescriptor superclass = (ClassDescriptor) classifierCandidate;\n\n                    for (JetType declaredSupertype : supertypes) {\n                        if (declaredSupertype.getConstructor().equals(superclass.getTypeConstructor())) {\n                            result = substitutor.safeSubstitute(declaredSupertype, Variance.INVARIANT);\n                            break;\n                        }\n                    }\n                }\n\n                boolean validClassifier = classifierCandidate != null && !ErrorUtils.isError(classifierCandidate);\n                boolean validType = supertype != null && !ErrorUtils.isErrorType(supertype);\n                if (result == null && (validClassifier || validType)) {\n                    context.trace.report(NOT_A_SUPERTYPE.on(superTypeQualifier));\n                }\n                else if (redundantTypeArguments != null) {\n                    context.trace.report(TYPE_ARGUMENTS_REDUNDANT_IN_SUPER_QUALIFIER.on(redundantTypeArguments));\n                }\n            }\n            else {\n                if (supertypes.size() > 1) {\n                    context.trace.report(AMBIGUOUS_SUPER.on(expression));\n                }\n                else {\n                    // supertypes may be empty when all the supertypes are error types (are not resolved, for example)\n                    JetType type = supertypes.isEmpty()\n                                   ? JetStandardClasses.getAnyType()\n                                   : supertypes.iterator().next();\n                    result = substitutor.substitute(type, Variance.INVARIANT);\n                }\n            }\n            if (result != null) {\n                context.trace.record(BindingContext.EXPRESSION_TYPE, expression.getInstanceReference(), result);\n                context.trace.record(BindingContext.REFERENCE_TARGET, expression.getInstanceReference(), result.getConstructor().getDeclarationDescriptor());\n            }\n        }\n        return DataFlowUtils.checkType(result, expression, context);\n    }","id":43941,"modified_method":"@Override\n    public JetType visitSuperExpression(JetSuperExpression expression, ExpressionTypingContext context) {\n        if (!context.namespacesAllowed) {\n            context.trace.report(SUPER_IS_NOT_AN_EXPRESSION.on(expression, expression.getText()));\n            return null;\n        }\n        JetType result = null;\n\n        ReceiverDescriptor thisReceiver = resolveToReceiver(expression, context, true);\n        if (thisReceiver == null) return null;\n\n        if (!thisReceiver.exists()) {\n            context.trace.report(SUPER_NOT_AVAILABLE.on(expression));\n        }\n        else {\n            JetType thisType = thisReceiver.getType();\n            Collection<? extends JetType> supertypes = thisType.getConstructor().getSupertypes();\n            TypeSubstitutor substitutor = TypeSubstitutor.create(thisType);\n\n            JetTypeReference superTypeQualifier = expression.getSuperTypeQualifier();\n            if (superTypeQualifier != null) {\n                JetTypeElement typeElement = superTypeQualifier.getTypeElement();\n\n                DeclarationDescriptor classifierCandidate = null;\n                JetType supertype = null;\n                PsiElement redundantTypeArguments = null;\n                if (typeElement instanceof JetUserType) {\n                    JetUserType userType = (JetUserType) typeElement;\n                    // This may be just a superclass name even if the superclass is generic\n                    if (userType.getTypeArguments().isEmpty()) {\n                        classifierCandidate = context.expressionTypingServices.getTypeResolver().resolveClass(context.scope, userType, context.trace);\n                    }\n                    else {\n                        supertype = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, superTypeQualifier, context.trace, true);\n                        redundantTypeArguments = userType.getTypeArgumentList();\n                    }\n                }\n                else {\n                    supertype = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, superTypeQualifier, context.trace, true);\n                }\n\n                if (supertype != null) {\n                    if (supertypes.contains(supertype)) {\n                        result = supertype;\n                    }\n                }\n                else if (classifierCandidate instanceof ClassDescriptor) {\n                    ClassDescriptor superclass = (ClassDescriptor) classifierCandidate;\n\n                    for (JetType declaredSupertype : supertypes) {\n                        if (declaredSupertype.getConstructor().equals(superclass.getTypeConstructor())) {\n                            result = substitutor.safeSubstitute(declaredSupertype, Variance.INVARIANT);\n                            break;\n                        }\n                    }\n                }\n\n                boolean validClassifier = classifierCandidate != null && !ErrorUtils.isError(classifierCandidate);\n                boolean validType = supertype != null && !ErrorUtils.isErrorType(supertype);\n                if (result == null && (validClassifier || validType)) {\n                    context.trace.report(NOT_A_SUPERTYPE.on(superTypeQualifier));\n                }\n                else if (redundantTypeArguments != null) {\n                    context.trace.report(TYPE_ARGUMENTS_REDUNDANT_IN_SUPER_QUALIFIER.on(redundantTypeArguments));\n                }\n            }\n            else {\n                if (supertypes.size() > 1) {\n                    context.trace.report(AMBIGUOUS_SUPER.on(expression));\n                }\n                else {\n                    // supertypes may be empty when all the supertypes are error types (are not resolved, for example)\n                    JetType type = supertypes.isEmpty()\n                                   ? JetStandardClasses.getAnyType()\n                                   : supertypes.iterator().next();\n                    result = substitutor.substitute(type, Variance.INVARIANT);\n                }\n            }\n            if (result != null) {\n                context.trace.record(BindingContext.EXPRESSION_TYPE, expression.getInstanceReference(), result);\n                context.trace.record(BindingContext.REFERENCE_TARGET, expression.getInstanceReference(), result.getConstructor().getDeclarationDescriptor());\n                if (superTypeQualifier != null) {\n                    context.trace.record(BindingContext.TYPE_RESOLUTION_SCOPE, superTypeQualifier, context.scope);\n                }\n            }\n        }\n        return DataFlowUtils.checkType(result, expression, context);\n    }","commit_id":"2fcc7b0cbb548c94822d0fc472ce9f43d3b461b7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static ClassDescriptor getTopLevelClass(ClassDescriptor classDescriptor) {\n        while (true) {\n            DeclarationDescriptor parent = classDescriptor.getContainingDeclaration();\n            if (parent instanceof ClassDescriptor) {\n                classDescriptor = (ClassDescriptor) parent;\n            } else {\n                return classDescriptor;\n            }\n        }\n    }","id":43942,"modified_method":"public static ClassDescriptor getTopLevelClass(ClassDescriptor classDescriptor) {\n        while (true) {\n            DeclarationDescriptor parent = classDescriptor.getContainingDeclaration();\n            if (parent instanceof ClassDescriptor) {\n                classDescriptor = (ClassDescriptor) parent;\n            } else {\n                return classDescriptor;\n            }\n        }\n    }","commit_id":"2fcc7b0cbb548c94822d0fc472ce9f43d3b461b7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static List<JetElement> generateOverridingMembers(List<DescriptorClassMember> selectedElements, JetFile file, boolean fqNames) {\n        List<JetElement> overridingMembers = new ArrayList<JetElement>();\n        for (DescriptorClassMember selectedElement : selectedElements) {\n            final DeclarationDescriptor descriptor = selectedElement.getDescriptor();\n            if (descriptor instanceof SimpleFunctionDescriptor) {\n                overridingMembers.add(overrideFunction(file.getProject(), file, (SimpleFunctionDescriptor)descriptor, fqNames));\n            }\n            else if (descriptor instanceof PropertyDescriptor) {\n                overridingMembers.add(overrideProperty(file.getProject(), file, (PropertyDescriptor)descriptor, fqNames));\n            }\n        }\n        return overridingMembers;\n    }","id":43943,"modified_method":"private static List<JetElement> generateOverridingMembers(List<DescriptorClassMember> selectedElements, JetFile file) {\n        List<JetElement> overridingMembers = new ArrayList<JetElement>();\n        for (DescriptorClassMember selectedElement : selectedElements) {\n            final DeclarationDescriptor descriptor = selectedElement.getDescriptor();\n            if (descriptor instanceof SimpleFunctionDescriptor) {\n                overridingMembers.add(overrideFunction(file.getProject(), (SimpleFunctionDescriptor)descriptor));\n            }\n            else if (descriptor instanceof PropertyDescriptor) {\n                overridingMembers.add(overrideProperty(file.getProject(), (PropertyDescriptor)descriptor));\n            }\n        }\n        return overridingMembers;\n    }","commit_id":"2fcc7b0cbb548c94822d0fc472ce9f43d3b461b7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void generateMethods(Editor editor,\n            JetClassOrObject classOrObject,\n            List<DescriptorClassMember> selectedElements) {\n        final JetClassBody body = classOrObject.getBody();\n        if (body == null) {\n            return;\n        }\n\n        PsiElement afterAnchor = findInsertAfterAnchor(editor, body);\n\n        if (afterAnchor == null) {\n            return;\n        }\n\n        for (JetElement element : generateOverridingMembers(selectedElements, (JetFile)classOrObject.getContainingFile(), false)) {\n            afterAnchor = body.addAfter(element, afterAnchor);\n        }\n    }","id":43944,"modified_method":"public static void generateMethods(Editor editor,\n            JetClassOrObject classOrObject,\n            List<DescriptorClassMember> selectedElements) {\n        final JetClassBody body = classOrObject.getBody();\n        if (body == null) {\n            return;\n        }\n\n        PsiElement afterAnchor = findInsertAfterAnchor(editor, body);\n\n        if (afterAnchor == null) {\n            return;\n        }\n\n        List<JetElement> elementsToCompact = new ArrayList<JetElement>();\n        final JetFile file = (JetFile)classOrObject.getContainingFile();\n        for (JetElement element : generateOverridingMembers(selectedElements, file)) {\n            PsiElement added = body.addAfter(element, afterAnchor);\n            afterAnchor = added;\n            elementsToCompact.add((JetElement)added);\n        }\n        compactReferenceToClasses(elementsToCompact);\n    }","commit_id":"2fcc7b0cbb548c94822d0fc472ce9f43d3b461b7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static JetElement overrideProperty(Project project, JetFile file, PropertyDescriptor descriptor, boolean fqNames) {\n        StringBuilder bodyBuilder = new StringBuilder();\n        bodyBuilder.append(displayableVisibility(descriptor)).append(\"override \");\n        if (descriptor.isVar()) {\n            bodyBuilder.append(\"var \");\n        }\n        else {\n            bodyBuilder.append(\"val \");\n        }\n        bodyBuilder.append(descriptor.getName()).append(\" : \").append(DescriptorRenderer.COMPACT.renderTypeWithShortNames(\n                descriptor.getType()));\n        ImportInsertHelper.addImportDirectivesIfNeeded(descriptor.getType(), file);\n        String initializer = defaultInitializer(descriptor.getType(), JetStandardLibrary.getInstance());\n        if (initializer != null) {\n            bodyBuilder.append(\" = \").append(initializer);\n        }\n        else {\n            bodyBuilder.append(\" = ?\");\n        }\n        return JetPsiFactory.createProperty(project, bodyBuilder.toString());\n    }","id":43945,"modified_method":"private static JetElement overrideProperty(Project project, PropertyDescriptor descriptor) {\n        StringBuilder bodyBuilder = new StringBuilder();\n        bodyBuilder.append(displayableVisibility(descriptor)).append(\"override \");\n        if (descriptor.isVar()) {\n            bodyBuilder.append(\"var \");\n        }\n        else {\n            bodyBuilder.append(\"val \");\n        }\n        bodyBuilder.append(descriptor.getName()).append(\" : \").append(DescriptorRenderer.COMPACT.renderTypeWithShortNames(\n                descriptor.getType()));\n        String initializer = defaultInitializer(descriptor.getType(), JetStandardLibrary.getInstance());\n        if (initializer != null) {\n            bodyBuilder.append(\" = \").append(initializer);\n        }\n        else {\n            bodyBuilder.append(\" = ?\");\n        }\n        return JetPsiFactory.createProperty(project, bodyBuilder.toString());\n    }","commit_id":"2fcc7b0cbb548c94822d0fc472ce9f43d3b461b7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static JetElement overrideFunction(Project project, JetFile file, SimpleFunctionDescriptor descriptor, boolean fqNames) {\n        StringBuilder bodyBuilder = new StringBuilder();\n        bodyBuilder.append(displayableVisibility(descriptor));\n        bodyBuilder.append(\"override fun \");\n\n        List<String> whereRestrictions = new ArrayList<String>();\n        if (!descriptor.getTypeParameters().isEmpty()) {\n            bodyBuilder.append(\"<\");\n            boolean first = true;\n            for (TypeParameterDescriptor param : descriptor.getTypeParameters()) {\n                if (!first) {\n                    bodyBuilder.append(\", \");\n                }\n\n                bodyBuilder.append(param.getName());\n                Set<JetType> upperBounds = param.getUpperBounds();\n                if (!upperBounds.isEmpty()) {\n                    boolean firstUpperBound = true;\n                    for (JetType upperBound : upperBounds) {\n                        String upperBoundText = \" : \" + DescriptorRenderer.TEXT.renderTypeWithShortNames(upperBound);\n                        if (upperBound != JetStandardClasses.getDefaultBound()) {\n                            if (firstUpperBound) {\n                                bodyBuilder.append(upperBoundText);\n                            } else {\n                                whereRestrictions.add(param.getName() + upperBoundText);\n                            }\n                        }\n                        ImportInsertHelper.addImportDirectivesIfNeeded(upperBound, file);\n                        firstUpperBound = false;\n                    }\n                }\n\n                first = false;\n            }\n            bodyBuilder.append(\"> \");\n        }\n        bodyBuilder.append(descriptor.getName()).append(\"(\");\n        boolean isAbstractFun = descriptor.getModality() == Modality.ABSTRACT;\n        StringBuilder delegationBuilder = new StringBuilder();\n        if (isAbstractFun) {\n            delegationBuilder.append(\"throw UnsupportedOperationException()\");\n        }\n        else {\n            delegationBuilder.append(\"super<\").append(descriptor.getContainingDeclaration().getName());\n            delegationBuilder.append(\">.\").append(descriptor.getName()).append(\"(\");\n        }\n        boolean first = true;\n        for (ValueParameterDescriptor parameterDescriptor : descriptor.getValueParameters()) {\n            if (!first) {\n                bodyBuilder.append(\",\");\n                if (!isAbstractFun) {\n                    delegationBuilder.append(\",\");\n                }\n            }\n            first = false;\n            bodyBuilder.append(parameterDescriptor.getName());\n            bodyBuilder.append(\" : \");\n            bodyBuilder.append(DescriptorRenderer.TEXT.renderTypeWithShortNames(parameterDescriptor.getType()));\n\n            ImportInsertHelper.addImportDirectivesIfNeeded(parameterDescriptor.getType(), file);\n\n            if (!isAbstractFun) {\n                delegationBuilder.append(parameterDescriptor.getName());\n            }\n        }\n        bodyBuilder.append(\")\");\n        if (!isAbstractFun) {\n            delegationBuilder.append(\")\");\n        }\n        final JetType returnType = descriptor.getReturnType();\n        final JetStandardLibrary stdlib = JetStandardLibrary.getInstance();\n\n        boolean returnsNotUnit = returnType != null && !stdlib.getTuple0Type().equals(returnType);\n        if (returnsNotUnit) {\n            bodyBuilder.append(\" : \").append(DescriptorRenderer.TEXT.renderTypeWithShortNames(returnType));\n            ImportInsertHelper.addImportDirectivesIfNeeded(returnType, file);\n        }\n        if (!whereRestrictions.isEmpty()) {\n            bodyBuilder.append(\"\\n\").append(\"where \").append(StringUtil.join(whereRestrictions, \", \"));\n        }\n        bodyBuilder.append(\"{\").append(returnsNotUnit && !isAbstractFun ? \"return \" : \"\").append(delegationBuilder.toString()).append(\"}\");\n\n        return JetPsiFactory.createFunction(project, bodyBuilder.toString());\n    }","id":43946,"modified_method":"private static JetElement overrideFunction(Project project, SimpleFunctionDescriptor descriptor) {\n        StringBuilder bodyBuilder = new StringBuilder();\n        bodyBuilder.append(displayableVisibility(descriptor));\n        bodyBuilder.append(\"override fun \");\n\n        List<String> whereRestrictions = new ArrayList<String>();\n        if (!descriptor.getTypeParameters().isEmpty()) {\n            bodyBuilder.append(\"<\");\n            boolean first = true;\n            for (TypeParameterDescriptor param : descriptor.getTypeParameters()) {\n                if (!first) {\n                    bodyBuilder.append(\", \");\n                }\n\n                bodyBuilder.append(param.getName());\n                Set<JetType> upperBounds = param.getUpperBounds();\n                if (!upperBounds.isEmpty()) {\n                    boolean firstUpperBound = true;\n                    for (JetType upperBound : upperBounds) {\n                        String upperBoundText = \" : \" + renderType(upperBound);\n                        if (upperBound != JetStandardClasses.getDefaultBound()) {\n                            if (firstUpperBound) {\n                                bodyBuilder.append(upperBoundText);\n                            } else {\n                                whereRestrictions.add(param.getName() + upperBoundText);\n                            }\n                        }\n                        firstUpperBound = false;\n                    }\n                }\n\n                first = false;\n            }\n            bodyBuilder.append(\"> \");\n        }\n        bodyBuilder.append(descriptor.getName()).append(\"(\");\n        boolean isAbstractFun = descriptor.getModality() == Modality.ABSTRACT;\n        StringBuilder delegationBuilder = new StringBuilder();\n        if (isAbstractFun) {\n            delegationBuilder.append(\"throw UnsupportedOperationException()\");\n        }\n        else {\n            delegationBuilder.append(\"super<\").append(descriptor.getContainingDeclaration().getName());\n            delegationBuilder.append(\">.\").append(descriptor.getName()).append(\"(\");\n        }\n        boolean first = true;\n        for (ValueParameterDescriptor parameterDescriptor : descriptor.getValueParameters()) {\n            if (!first) {\n                bodyBuilder.append(\",\");\n                if (!isAbstractFun) {\n                    delegationBuilder.append(\",\");\n                }\n            }\n            first = false;\n            bodyBuilder.append(parameterDescriptor.getName());\n            bodyBuilder.append(\" : \");\n            bodyBuilder.append(renderType(parameterDescriptor.getType()));\n\n            if (!isAbstractFun) {\n                delegationBuilder.append(parameterDescriptor.getName());\n            }\n        }\n        bodyBuilder.append(\")\");\n        if (!isAbstractFun) {\n            delegationBuilder.append(\")\");\n        }\n        final JetType returnType = descriptor.getReturnType();\n        final JetStandardLibrary stdlib = JetStandardLibrary.getInstance();\n\n        boolean returnsNotUnit = returnType != null && !stdlib.getTuple0Type().equals(returnType);\n        if (returnsNotUnit) {\n            bodyBuilder.append(\" : \").append(renderType(returnType));\n        }\n        if (!whereRestrictions.isEmpty()) {\n            bodyBuilder.append(\"\\n\").append(\"where \").append(StringUtil.join(whereRestrictions, \", \"));\n        }\n        bodyBuilder.append(\"{\").append(returnsNotUnit && !isAbstractFun ? \"return \" : \"\").append(delegationBuilder.toString()).append(\"}\");\n\n        return JetPsiFactory.createFunction(project, bodyBuilder.toString());\n    }","commit_id":"2fcc7b0cbb548c94822d0fc472ce9f43d3b461b7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JetType resolveType(@NotNull final JetScope scope, @NotNull final JetTypeReference typeReference, BindingTrace trace, boolean checkBounds) {\n        JetType cachedType = trace.getBindingContext().get(BindingContext.TYPE, typeReference);\n        if (cachedType != null) return cachedType;\n\n        final List<AnnotationDescriptor> annotations = annotationResolver.createAnnotationStubs(typeReference.getAnnotations(), trace);\n\n        JetTypeElement typeElement = typeReference.getTypeElement();\n        JetType type = resolveTypeElement(scope, annotations, typeElement, false, trace, checkBounds);\n        trace.record(BindingContext.TYPE, typeReference, type);\n\n        return type;\n    }","id":43947,"modified_method":"@NotNull\n    public JetType resolveType(@NotNull final JetScope scope, @NotNull final JetTypeReference typeReference, BindingTrace trace, boolean checkBounds) {\n        JetType cachedType = trace.getBindingContext().get(BindingContext.TYPE, typeReference);\n        if (cachedType != null) return cachedType;\n\n        final List<AnnotationDescriptor> annotations = annotationResolver.createAnnotationStubs(typeReference.getAnnotations(), trace);\n\n        JetTypeElement typeElement = typeReference.getTypeElement();\n        JetType type = resolveTypeElement(scope, annotations, typeElement, false, trace, checkBounds);\n        trace.record(BindingContext.TYPE, typeReference, type);\n        trace.record(BindingContext.TYPE_RESOLUTION_SCOPE, typeReference, scope);\n\n        return type;\n    }","commit_id":"2fcc7b0cbb548c94822d0fc472ce9f43d3b461b7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean applyMethod(PsiClass clazz, PsiMethod existingMethod, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        return false; // the user cancels\n    }","id":43948,"modified_method":"public PsiMethod applyMethod(PsiClass clazz, PsiMethod existingMethod, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        return null;\n    }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean applyMethod(PsiClass clazz, PsiMethod existingMethod, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        newMethodStrategy.insertNewMethod(clazz, newMethod, editor);\n        return true;\n    }","id":43949,"modified_method":"public PsiMethod applyMethod(PsiClass clazz, PsiMethod existingMethod, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        return newMethodStrategy.insertNewMethod(clazz, newMethod, editor);\n    }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * This method is executed just after the <code>toString<\/code> method is created or updated.\n     *\n     * @param method            the newly created/updated <code>toString<\/code> method.\n     * @param params            additional parameters stored with key/value in the map.\n     * @param template          the template to use\n     * @throws IncorrectOperationException  is thrown by IDEA\n     */\n    private void afterCreateToStringMethod(PsiMethod method, Map<String, String> params, TemplateResource template) throws IncorrectOperationException {\n\n        // if the code uses Arrays, then make sure java.util.Arrays is imported.\n        String javaCode = method.getText();\n        if (javaCode.indexOf(\"Arrays.\") > 0 && !(psi.hasImportStatement(javaFile, \"java.util.*\") || psi.hasImportStatement(javaFile, \"java.util.Arrays\"))) {\n            // java.util.Arrays must be imported as java.util.* since the addImportStatement method doens't support onDemand-import statement yet.\n            psi.addImportStatement(javaFile, \"java.util.*\", elementFactory);\n        }\n\n        // if the code uses Reflection (Field[]), then make sure java.lang.reflect.Field is imported.\n        if (javaCode.indexOf(\"Field[]\") > 0 && !(psi.hasImportStatement(javaFile, \"java.lang.reflect.*\") || psi.hasImportStatement(javaFile, \"java.lang.reflect.Field\"))) {\n            // java.lang.reflect.Field must be imported as java.lang.reflect.* since the addImportStatement method doens't support onDemand-import statement yet.\n            psi.addImportStatement(javaFile, \"java.lang.reflect.*\", elementFactory);\n        }\n\n        // any additional packages to import from the params\n        if (params.get(\"autoImportPackages\") != null) {\n            autoImportPackages(params.get(\"autoImportPackages\"));\n        }\n\n        // reformat code\n        codeStyleManager.reformat(method);\n\n        // jump to method\n        if (config.isJumpToMethod() && editor != null) {\n            PsiMethod newMethod = psi.findMethodByName(clazz, template.getTargetMethodName());\n            if (newMethod != null) {\n                int offset = newMethod.getTextOffset();\n                if (offset > 2) {\n                    VisualPosition vp = editor.offsetToVisualPosition(offset);\n                    if (logger.isDebugEnabled()) logger.debug(\"Moving/Scrolling caret to \" + vp +  \" (offset=\" + offset + \")\");\n                    editor.getCaretModel().moveToVisualPosition(vp);\n                    editor.getScrollingModel().scrollToCaret(ScrollType.CENTER_DOWN);\n                }\n            }\n        }\n    }","id":43950,"modified_method":"/**\n   * This method is executed just after the <code>toString<\/code> method is created or updated.\n   *\n   * @param method   the newly created/updated <code>toString<\/code> method.\n   * @param params   additional parameters stored with key/value in the map.\n   * @param template the template to use\n   * @throws IncorrectOperationException is thrown by IDEA\n   */\n  private void afterCreateToStringMethod(PsiMethod method, Map<String, String> params, TemplateResource template)\n    throws IncorrectOperationException {\n\n    if (containingFile instanceof PsiJavaFile) {\n      final PsiJavaFile javaFile = (PsiJavaFile)containingFile;\n      // if the code uses Arrays, then make sure java.util.Arrays is imported.\n      String javaCode = method.getText();\n      if (javaCode.indexOf(\"Arrays.\") > 0 &&\n          !(psi.hasImportStatement(javaFile, \"java.util.*\") || psi.hasImportStatement(javaFile, \"java.util.Arrays\"))) {\n        // java.util.Arrays must be imported as java.util.* since the addImportStatement method doens't support onDemand-import statement yet.\n        psi.addImportStatement(javaFile, \"java.util.*\", elementFactory);\n      }\n\n      // if the code uses Reflection (Field[]), then make sure java.lang.reflect.Field is imported.\n      if (javaCode.indexOf(\"Field[]\") > 0 &&\n          !(psi.hasImportStatement(javaFile, \"java.lang.reflect.*\") || psi.hasImportStatement(javaFile, \"java.lang.reflect.Field\"))) {\n        // java.lang.reflect.Field must be imported as java.lang.reflect.* since the addImportStatement method doens't support onDemand-import statement yet.\n        psi.addImportStatement(javaFile, \"java.lang.reflect.*\", elementFactory);\n      }\n\n      // any additional packages to import from the params\n      if (params.get(\"autoImportPackages\") != null) {\n        autoImportPackages(javaFile, params.get(\"autoImportPackages\"));\n      }\n    }\n\n    // reformat code\n    codeStyleManager.reformat(method);\n\n    // jump to method\n    if (config.isJumpToMethod() && editor != null) {\n      PsiMethod newMethod = psi.findMethodByName(clazz, template.getTargetMethodName());\n      if (newMethod != null) {\n        int offset = newMethod.getTextOffset();\n        if (offset > 2) {\n          VisualPosition vp = editor.offsetToVisualPosition(offset);\n          if (logger.isDebugEnabled()) logger.debug(\"Moving/Scrolling caret to \" + vp + \" (offset=\" + offset + \")\");\n          editor.getCaretModel().moveToVisualPosition(vp);\n          editor.getScrollingModel().scrollToCaret(ScrollType.CENTER_DOWN);\n        }\n      }\n    }\n  }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Automatic import the packages.\n     *\n     * @param packageNames   names of packages (must end with .* and be seperated by ; or ,)\n     * @throws IncorrectOperationException   error adding imported package\n     */\n    private void autoImportPackages(String packageNames) throws IncorrectOperationException {\n        StringTokenizer tok = new StringTokenizer(packageNames, \",\");\n        while (tok.hasMoreTokens()) {\n            String packageName = tok.nextToken().trim(); // trim in case of space\n            if (logger.isDebugEnabled()) logger.debug(\"Auto importing package: \" + packageName);\n            psi.addImportStatement(javaFile, packageName, elementFactory);\n        }\n    }","id":43951,"modified_method":"/**\n   * Automatic import the packages.\n   *\n   * @param packageNames names of packages (must end with .* and be seperated by ; or ,)\n   * @throws IncorrectOperationException error adding imported package\n   */\n  private void autoImportPackages(PsiJavaFile psiJavaFile, String packageNames) throws IncorrectOperationException {\n    StringTokenizer tok = new StringTokenizer(packageNames, \",\");\n    while (tok.hasMoreTokens()) {\n      String packageName = tok.nextToken().trim(); // trim in case of space\n      if (logger.isDebugEnabled()) logger.debug(\"Auto importing package: \" + packageName);\n      psi.addImportStatement(psiJavaFile, packageName, elementFactory);\n    }\n  }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GenerateToStringWorker(PsiClass clazz, Editor editor, boolean insertAtOverride) {\n        this.clazz = clazz;\n        this.project = clazz.getProject();\n        this.psi = PsiAdapterFactory.getPsiAdapter();\n        this.editor = editor;\n        this.elementFactory = JavaPsiFacade.getInstance(project).getElementFactory();\n        this.codeStyleManager = psi.getCodeStyleManager(project);\n        this.javaFile = (PsiJavaFile) clazz.getContainingFile();\n        this.config = GenerateToStringContext.getConfig();\n        this.hasOverrideAnnotation = insertAtOverride;\n    }","id":43952,"modified_method":"public GenerateToStringWorker(PsiClass clazz, Editor editor, boolean insertAtOverride) {\n    this.clazz = clazz;\n    this.project = clazz.getProject();\n    this.psi = PsiAdapterFactory.getPsiAdapter();\n    this.editor = editor;\n    this.elementFactory = JavaPsiFacade.getInstance(project).getElementFactory();\n    this.codeStyleManager = psi.getCodeStyleManager(project);\n    this.containingFile = clazz.getContainingFile();\n    this.config = GenerateToStringContext.getConfig();\n    this.hasOverrideAnnotation = insertAtOverride;\n  }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Creates the <code>toString<\/code> method.\n     *\n     * @param selectedMembers   the selected members as both {@link com.intellij.psi.PsiField} and {@link com.intellij.psi.PsiMethod}.\n     * @param policy            conflict resolution policy\n     * @param params            additional parameters stored with key/value in the map.\n     * @param template          the template to use\n     * @return the created method, null if the method is not created due the user cancels this operation\n     * @throws GenerateCodeException is thrown when there is an error generating the javacode.\n     * @throws IncorrectOperationException is thrown by IDEA.\n     */\n    @Nullable\n    private PsiMethod createToStringMethod(Collection<PsiMember> selectedMembers, ConflictResolutionPolicy policy, Map<String, String> params, TemplateResource template) throws IncorrectOperationException, GenerateCodeException {\n        // generate code using velocity\n        String body = velocityGenerateCode(selectedMembers, params, template.getMethodBody());\n        if (logger.isDebugEnabled()) logger.debug(\"Method body generated from Velocity:\\n\" + body);\n\n        // fix weird linebreak problem in IDEA #3296 and later\n        body = StringUtil.fixLineBreaks(body);\n\n        // create psi newMethod named toString()\n        PsiMethod newMethod = elementFactory.createMethodFromText(template.getMethodSignature() + \" { \" + body + \" }\", null);\n        codeStyleManager.reformat(newMethod);\n\n        // insertNewMethod conflict resolution policy (add/replace, duplicate, cancel)\n        PsiMethod existingMethod = clazz.findMethodBySignature(newMethod, false);\n        boolean operationExectued = policy.applyMethod(clazz, existingMethod, newMethod, editor);\n        if (! operationExectued)\n            return null; // user cancelled so return null\n\n        if (hasOverrideAnnotation) {                            \n            PsiMethod toStringMethod = clazz.findMethodBySignature(newMethod, false); // must find again to be able to add javadoc (IDEA does not add if using method parameter)\n            annotate(toStringMethod, \"java.lang.Override\");\n        }\n\n        // add annotations\n        if (template.hasAnnotations()) {\n            PsiMethod toStringMethod = clazz.findMethodBySignature(newMethod, false); // must find again to be able to add javadoc (IDEA does not add if using method parameter)\n            String[] annotations = template.getAnnotations();\n            // must reverse loop to add annotations in the same order as in the template (when inserting it would insert in top)\n            for (int i = annotations.length - 1; i > -1; i--) {\n                String text = annotations[i];\n                psi.addAnnotationToMethod(elementFactory, toStringMethod, text);\n            }\n        }\n\n        // applyJavaDoc conflict resolution policy (add or keep existing)\n        String existingJavaDoc = params.get(\"existingJavaDoc\");\n        String newJavaDoc = template.getJavaDoc();\n        if (existingJavaDoc != null || newJavaDoc != null) {\n            PsiMethod toStringMethod = clazz.findMethodBySignature(newMethod, false); // must find again to be able to add javadoc (IDEA does not add if using method parameter)\n\n            // generate javadoc using velocity\n            newJavaDoc = velocityGenerateCode(selectedMembers, params, newJavaDoc);\n            if (logger.isDebugEnabled()) logger.debug(\"JavaDoc body generated from Velocity:\\n\" + newJavaDoc);\n\n            applyJavaDoc(toStringMethod, elementFactory, codeStyleManager, existingJavaDoc, newJavaDoc);\n        }\n\n        // reformat code style\n        codeStyleManager.reformat(newMethod);\n\n        // return the created method\n        return newMethod;\n    }","id":43953,"modified_method":"/**\n   * Creates the <code>toString<\/code> method.\n   *\n   * @param selectedMembers the selected members as both {@link com.intellij.psi.PsiField} and {@link com.intellij.psi.PsiMethod}.\n   * @param policy          conflict resolution policy\n   * @param params          additional parameters stored with key/value in the map.\n   * @param template        the template to use\n   * @return the created method, null if the method is not created due the user cancels this operation\n   * @throws GenerateCodeException       is thrown when there is an error generating the javacode.\n   * @throws IncorrectOperationException is thrown by IDEA.\n   */\n  @Nullable\n  private PsiMethod createToStringMethod(Collection<PsiMember> selectedMembers,\n                                         ConflictResolutionPolicy policy,\n                                         Map<String, String> params,\n                                         TemplateResource template) throws IncorrectOperationException, GenerateCodeException {\n    // generate code using velocity\n    String body = velocityGenerateCode(selectedMembers, params, template.getMethodBody());\n    if (logger.isDebugEnabled()) logger.debug(\"Method body generated from Velocity:\\n\" + body);\n\n    // fix weird linebreak problem in IDEA #3296 and later\n    body = StringUtil.fixLineBreaks(body);\n\n    // create psi newMethod named toString()\n    PsiMethod newMethod = elementFactory.createMethodFromText(template.getMethodSignature() + \" { \" + body + \" }\", null);\n    codeStyleManager.reformat(newMethod);\n\n    // insertNewMethod conflict resolution policy (add/replace, duplicate, cancel)\n    PsiMethod existingMethod = clazz.findMethodBySignature(newMethod, false);\n    PsiMethod toStringMethod = policy.applyMethod(clazz, existingMethod, newMethod, editor);\n    if (toStringMethod == null) {\n      return null; // user cancelled so return null\n    }\n\n    if (hasOverrideAnnotation) {\n      annotate(toStringMethod, \"java.lang.Override\");\n    }\n\n    // add annotations\n    if (template.hasAnnotations()) {\n      String[] annotations = template.getAnnotations();\n      // must reverse loop to add annotations in the same order as in the template (when inserting it would insert in top)\n      for (int i = annotations.length - 1; i > -1; i--) {\n        String text = annotations[i];\n        psi.addAnnotationToMethod(elementFactory, toStringMethod, text);\n      }\n    }\n\n    // applyJavaDoc conflict resolution policy (add or keep existing)\n    String existingJavaDoc = params.get(\"existingJavaDoc\");\n    String newJavaDoc = template.getJavaDoc();\n    if (existingJavaDoc != null || newJavaDoc != null) {\n      // generate javadoc using velocity\n      newJavaDoc = velocityGenerateCode(selectedMembers, params, newJavaDoc);\n      if (logger.isDebugEnabled()) logger.debug(\"JavaDoc body generated from Velocity:\\n\" + newJavaDoc);\n\n      applyJavaDoc(toStringMethod, elementFactory, codeStyleManager, existingJavaDoc, newJavaDoc);\n    }\n\n    // return the created method\n    return toStringMethod;\n  }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean insertNewMethod(PsiClass clazz, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        // lazy initialize otherwise IDEA throws error: Component requests are not allowed before they are created\n        if (psi == null) {\n            psi = PsiAdapterFactory.getPsiAdapter();\n        }\n\n        // if main method exists and is the last then add toString just before main method\n        PsiMethod methodHashCode = psi.findHashCodeMethod(clazz);\n        PsiMethod methodEquals = psi.findEqualsMethod(clazz);\n\n        // if both methos exist determine the last method in the javafile\n        PsiMethod method;\n        if (methodEquals != null && methodHashCode != null) {\n            if (methodEquals.getTextOffset() > methodHashCode.getTextOffset()) {\n                method = methodEquals;\n            } else {\n                method = methodHashCode;\n            }\n        } else {\n            method = methodHashCode != null ? methodHashCode : methodEquals;\n        }\n\n        if (method != null) {\n            // insert after the equals/hashCode method\n            clazz.addAfter(newMethod, method);\n        } else {\n            // no equals/hashCode so insert at caret\n            InsertAtCaretStrategy.getInstance().insertNewMethod(clazz, newMethod, editor);\n        }\n\n        return true;\n    }","id":43954,"modified_method":"public PsiMethod insertNewMethod(PsiClass clazz, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        // lazy initialize otherwise IDEA throws error: Component requests are not allowed before they are created\n        if (psi == null) {\n            psi = PsiAdapterFactory.getPsiAdapter();\n        }\n\n        // if main method exists and is the last then add toString just before main method\n        PsiMethod methodHashCode = psi.findHashCodeMethod(clazz);\n        PsiMethod methodEquals = psi.findEqualsMethod(clazz);\n\n        // if both methos exist determine the last method in the javafile\n        PsiMethod method;\n        if (methodEquals != null && methodHashCode != null) {\n            if (methodEquals.getTextOffset() > methodHashCode.getTextOffset()) {\n                method = methodEquals;\n            } else {\n                method = methodHashCode;\n            }\n        } else {\n            method = methodHashCode != null ? methodHashCode : methodEquals;\n        }\n\n        if (method != null) {\n            // insert after the equals/hashCode method\n            newMethod = (PsiMethod) clazz.addAfter(newMethod, method);\n        } else {\n            // no equals/hashCode so insert at caret\n            newMethod = InsertAtCaretStrategy.getInstance().insertNewMethod(clazz, newMethod, editor);\n        }\n\n        return newMethod;\n    }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean insertNewMethod(PsiClass clazz, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        int offset = editor != null ? editor.getCaretModel().getOffset() : clazz.getTextRange().getEndOffset() - 1;\n        GenerateMembersUtil.insertMembersAtOffset(clazz.getContainingFile(), offset, Arrays.asList(new PsiGenerationInfo(newMethod, false)));\n        return true;\n    }","id":43955,"modified_method":"public PsiMethod insertNewMethod(PsiClass clazz, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n    int offset = editor != null ? editor.getCaretModel().getOffset() : clazz.getTextRange().getEndOffset() - 1;\n    final PsiGenerationInfo generationInfo = new PsiGenerationInfo(newMethod, false);\n    GenerateMembersUtil.insertMembersAtOffset(clazz.getContainingFile(), offset, Arrays.asList(generationInfo));\n    return (PsiMethod) generationInfo.getPsiMember();\n  }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean insertNewMethod(PsiClass clazz, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        PsiAdapter psi = PsiAdapterFactory.getPsiAdapter();\n\n        // if main method exists and is the last then add toString just before main method\n        PsiMethod mainMethod = psi.findPublicStaticVoidMainMethod(clazz);\n        if (mainMethod != null) {\n            // add before main method if it is the last method\n            PsiMethod[] methods = clazz.getMethods();\n            if (mainMethod.equals(methods[methods.length - 1])) {\n                clazz.addBefore(newMethod, mainMethod);\n                return true; // return as the method is added\n            }\n        }\n\n        // otherwise add it at the end\n        PsiElement last = clazz.getRBrace(); // rbrace is the last } java token. fixes bug #9\n        clazz.addBefore(newMethod, last);\n\n        return true;\n    }","id":43956,"modified_method":"public PsiMethod insertNewMethod(PsiClass clazz, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        PsiAdapter psi = PsiAdapterFactory.getPsiAdapter();\n\n        // if main method exists and is the last then add toString just before main method\n        PsiMethod mainMethod = psi.findPublicStaticVoidMainMethod(clazz);\n        if (mainMethod != null) {\n            // add before main method if it is the last method\n            PsiMethod[] methods = clazz.getMethods();\n            if (mainMethod.equals(methods[methods.length - 1])) {\n                return (PsiMethod) clazz.addBefore(newMethod, mainMethod);  // return as the method is added\n            }\n        }\n\n        // otherwise add it at the end\n        PsiElement last = clazz.getRBrace(); // rbrace is the last } java token. fixes bug #9\n        return (PsiMethod) clazz.addBefore(newMethod, last);\n    }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean applyMethod(PsiClass clazz, PsiMethod existingMethod, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        if (existingMethod != null) {\n            existingMethod.replace(newMethod);\n            return true;\n        } else {\n            return DuplicatePolicy.getInstance().applyMethod(clazz, existingMethod, newMethod, editor);\n        }\n    }","id":43957,"modified_method":"public PsiMethod applyMethod(PsiClass clazz, PsiMethod existingMethod, PsiMethod newMethod, Editor editor) throws IncorrectOperationException {\n        if (existingMethod != null) {\n            return (PsiMethod) existingMethod.replace(newMethod);\n        } else {\n            return DuplicatePolicy.getInstance().applyMethod(clazz, existingMethod, newMethod, editor);\n        }\n    }","commit_id":"9583bb50430c4888535c69aa2187a54961543fc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void _generate(final LwRootContainer rootContainer, final Module module) throws CodeGenerationException, IncorrectOperationException{\n    myBuffer = new StringBuffer();\n    myIsFirstParameterStack = new Stack<Boolean>();\n\n    final HashMap<LwComponent,String> component2variable = new HashMap<LwComponent,String>();\n    final TObjectIntHashMap<String> class2variableIndex = new TObjectIntHashMap<String>();\n    final HashMap<String,LwComponent> id2component = new HashMap<String, LwComponent>();\n\n    if (rootContainer.getComponentCount() != 1) {\n      throw new CodeGenerationException(null, UIDesignerBundle.message(\"error.one.toplevel.component.required\"));\n    }\n    final LwComponent topComponent = (LwComponent)rootContainer.getComponent(0);\n    String id = Utils.findNotEmptyPanelWithXYLayout(topComponent);\n    if (id != null) {\n      throw new CodeGenerationException(id, UIDesignerBundle.message(\"error.nonempty.xy.panels.found\"));\n    }\n\n    final PsiClass classToBind = FormEditingUtil.findClassToBind(module, rootContainer.getClassToBind());\n    if (classToBind == null) {\n      throw new ClassToBindNotFoundException(UIDesignerBundle.message(\"error.class.to.bind.not.found\", rootContainer.getClassToBind()));\n    }\n\n    if (Utils.getCustomCreateComponentCount(rootContainer) > 0) {\n      if (FormEditingUtil.findCreateComponentsMethod(classToBind) == null) {\n        throw new CodeGenerationException(null, UIDesignerBundle.message(\"error.no.custom.create.method\"));\n      }\n      myBuffer.append(AsmCodeGenerator.CREATE_COMPONENTS_METHOD_NAME).append(\"();\");\n    }\n\n    generateSetupCodeForComponent(topComponent,\n                                  component2variable,\n                                  class2variableIndex,\n                                  id2component, module, classToBind);\n    generateComponentReferenceProperties(topComponent, component2variable, class2variableIndex, id2component, classToBind);\n    generateButtonGroups(rootContainer, component2variable, class2variableIndex, id2component, classToBind);\n\n    final String methodText = myBuffer.toString();\n\n    final PsiManager psiManager = PsiManager.getInstance(module.getProject());\n    final PsiElementFactory elementFactory = psiManager.getElementFactory();\n\n    final PsiClass newClass = (PsiClass) classToBind.copy();\n\n    cleanup(newClass);\n\n    // [anton] the comments are written according to the SCR 26896  \n    final PsiClass fakeClass = elementFactory.createClassFromText(\n      \"{\\n\" +\n      \"// GUI initializer generated by \" + ApplicationNamesInfo.getInstance().getFullProductName() + \" GUI Designer\\n\" +\n      \"// >>> IMPORTANT!! <<<\\n\" +\n      \"// DO NOT EDIT OR ADD ANY CODE HERE!\\n\" +\n      \"\" + AsmCodeGenerator.SETUP_METHOD_NAME + \"();\\n\" +\n      \"}\\n\" +\n      \"\\n\" +\n      \"/** Method generated by \" + ApplicationNamesInfo.getInstance().getFullProductName() + \" GUI Designer\\n\" +\n      \" * >>> IMPORTANT!! <<<\\n\" +\n      \" * DO NOT edit this method OR call it in your code!\\n\" +\n      \" * @noinspection ALL\\n\" +\n      \" */\\n\" +\n      \"private void \" + AsmCodeGenerator.SETUP_METHOD_NAME + \"()\\n\" +\n      \"{\\n\" +\n      methodText +\n      \"}\\n\",\n      null\n    );\n\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(module.getProject());\n    PsiMethod method = (PsiMethod) newClass.add(fakeClass.getMethods()[0]);\n    method = (PsiMethod) codeStyleManager.reformat(method);\n    PsiElement initializer = null;\n\n    // don't generate initializer block if $$$setupUI$$$() is called explicitly from one of the constructors\n    boolean needInitializer = true;\n    for(PsiMethod constructor: newClass.getConstructors()) {\n      if (containsMethodIdentifier(constructor, method)) {\n        needInitializer = false;\n        break;\n      }\n    }\n\n    if (needInitializer) {\n      initializer = newClass.addBefore(fakeClass.getInitializers()[0], method);\n      initializer = codeStyleManager.reformat(initializer);\n    }\n\n    @NonNls final String grcMethodText = \"/** @noinspection ALL */ public javax.swing.JComponent \" +\n                                         AsmCodeGenerator.GET_ROOT_COMPONENT_METHOD_NAME +\n                                         \"() { return \" + topComponent.getBinding() + \"; }\";\n    generateMethodIfRequired(newClass, method, AsmCodeGenerator.GET_ROOT_COMPONENT_METHOD_NAME, grcMethodText, topComponent.getBinding() != null);\n\n    final String loadButtonTextMethodText = getLoadMethodText(AsmCodeGenerator.LOAD_BUTTON_TEXT_METHOD, AbstractButton.class, module);\n    generateMethodIfRequired(newClass, method, AsmCodeGenerator.LOAD_BUTTON_TEXT_METHOD, loadButtonTextMethodText, myNeedLoadButtonText);\n    final String loadLabelTextMethodText = getLoadMethodText(AsmCodeGenerator.LOAD_LABEL_TEXT_METHOD, JLabel.class, module);\n    generateMethodIfRequired(newClass, method, AsmCodeGenerator.LOAD_LABEL_TEXT_METHOD, loadLabelTextMethodText, myNeedLoadLabelText);\n\n    codeStyleManager.shortenClassReferences(method);\n    if (initializer != null) {\n      codeStyleManager.shortenClassReferences(initializer);\n    }\n\n    final String newText = newClass.getText();\n    final String oldText = classToBind.getText();\n    if (!newText.equals(oldText)) {\n      classToBind.replace(newClass);\n    }\n  }","id":43958,"modified_method":"private void _generate(final LwRootContainer rootContainer, final Module module) throws CodeGenerationException, IncorrectOperationException{\n    myBuffer = new StringBuffer();\n    myIsFirstParameterStack = new Stack<Boolean>();\n\n    final HashMap<LwComponent,String> component2variable = new HashMap<LwComponent,String>();\n    final TObjectIntHashMap<String> class2variableIndex = new TObjectIntHashMap<String>();\n    final HashMap<String,LwComponent> id2component = new HashMap<String, LwComponent>();\n\n    if (rootContainer.getComponentCount() != 1) {\n      throw new CodeGenerationException(null, UIDesignerBundle.message(\"error.one.toplevel.component.required\"));\n    }\n    final LwComponent topComponent = (LwComponent)rootContainer.getComponent(0);\n    String id = Utils.findNotEmptyPanelWithXYLayout(topComponent);\n    if (id != null) {\n      throw new CodeGenerationException(id, UIDesignerBundle.message(\"error.nonempty.xy.panels.found\"));\n    }\n\n    final PsiClass classToBind = FormEditingUtil.findClassToBind(module, rootContainer.getClassToBind());\n    if (classToBind == null) {\n      throw new ClassToBindNotFoundException(UIDesignerBundle.message(\"error.class.to.bind.not.found\", rootContainer.getClassToBind()));\n    }\n\n    if (Utils.getCustomCreateComponentCount(rootContainer) > 0) {\n      if (FormEditingUtil.findCreateComponentsMethod(classToBind) == null) {\n        throw new CodeGenerationException(null, UIDesignerBundle.message(\"error.no.custom.create.method\"));\n      }\n      myBuffer.append(AsmCodeGenerator.CREATE_COMPONENTS_METHOD_NAME).append(\"();\");\n    }\n\n    generateSetupCodeForComponent(topComponent,\n                                  component2variable,\n                                  class2variableIndex,\n                                  id2component, module, classToBind);\n    generateComponentReferenceProperties(topComponent, component2variable, class2variableIndex, id2component, classToBind);\n    generateButtonGroups(rootContainer, component2variable, class2variableIndex, id2component, classToBind);\n\n    final String methodText = myBuffer.toString();\n\n    final PsiManager psiManager = PsiManager.getInstance(module.getProject());\n    final PsiElementFactory elementFactory = psiManager.getElementFactory();\n\n    PsiClass newClass = (PsiClass) classToBind.copy();\n\n    cleanup(newClass);\n\n    // [anton] the comments are written according to the SCR 26896  \n    final PsiClass fakeClass = elementFactory.createClassFromText(\n      \"{\\n\" +\n      \"// GUI initializer generated by \" + ApplicationNamesInfo.getInstance().getFullProductName() + \" GUI Designer\\n\" +\n      \"// >>> IMPORTANT!! <<<\\n\" +\n      \"// DO NOT EDIT OR ADD ANY CODE HERE!\\n\" +\n      \"\" + AsmCodeGenerator.SETUP_METHOD_NAME + \"();\\n\" +\n      \"}\\n\" +\n      \"\\n\" +\n      \"/** Method generated by \" + ApplicationNamesInfo.getInstance().getFullProductName() + \" GUI Designer\\n\" +\n      \" * >>> IMPORTANT!! <<<\\n\" +\n      \" * DO NOT edit this method OR call it in your code!\\n\" +\n      \" * @noinspection ALL\\n\" +\n      \" */\\n\" +\n      \"private void \" + AsmCodeGenerator.SETUP_METHOD_NAME + \"()\\n\" +\n      \"{\\n\" +\n      methodText +\n      \"}\\n\",\n      null\n    );\n\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(module.getProject());\n    PsiMethod method = (PsiMethod) newClass.add(fakeClass.getMethods()[0]);\n\n    // don't generate initializer block if $$$setupUI$$$() is called explicitly from one of the constructors\n    boolean needInitializer = true;\n    for(PsiMethod constructor: newClass.getConstructors()) {\n      if (containsMethodIdentifier(constructor, method)) {\n        needInitializer = false;\n        break;\n      }\n    }\n\n    if (needInitializer) {\n      newClass.addBefore(fakeClass.getInitializers()[0], method);\n    }\n\n    @NonNls final String grcMethodText = \"/** @noinspection ALL */ public javax.swing.JComponent \" +\n                                         AsmCodeGenerator.GET_ROOT_COMPONENT_METHOD_NAME +\n                                         \"() { return \" + topComponent.getBinding() + \"; }\";\n    generateMethodIfRequired(newClass, method, AsmCodeGenerator.GET_ROOT_COMPONENT_METHOD_NAME, grcMethodText, topComponent.getBinding() != null);\n\n    final String loadButtonTextMethodText = getLoadMethodText(AsmCodeGenerator.LOAD_BUTTON_TEXT_METHOD, AbstractButton.class, module);\n    generateMethodIfRequired(newClass, method, AsmCodeGenerator.LOAD_BUTTON_TEXT_METHOD, loadButtonTextMethodText, myNeedLoadButtonText);\n    final String loadLabelTextMethodText = getLoadMethodText(AsmCodeGenerator.LOAD_LABEL_TEXT_METHOD, JLabel.class, module);\n    generateMethodIfRequired(newClass, method, AsmCodeGenerator.LOAD_LABEL_TEXT_METHOD, loadLabelTextMethodText, myNeedLoadLabelText);\n\n    newClass = (PsiClass) codeStyleManager.shortenClassReferences(newClass);\n    newClass = (PsiClass) codeStyleManager.reformat(newClass);\n\n    if (!lexemsEqual(classToBind, newClass)) {\n      classToBind.replace(newClass);\n    }\n  }","commit_id":"a8579579c20453a93aace0c7a96e7bd662418939","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateMethodIfRequired(PsiClass aClass, PsiMethod anchor, final String methodName, String methodText, boolean condition) throws IncorrectOperationException {\n    PsiElementFactory elementFactory = PsiManager.getInstance(myProject).getElementFactory();\n    PsiMethod newMethod = null;\n    PsiMethod[] oldMethods = aClass.findMethodsByName(methodName, false);\n    if (!condition) {\n      for(PsiMethod oldMethod: oldMethods) {\n        oldMethod.delete();\n      }\n    }\n    else {\n      newMethod = elementFactory.createMethodFromText(methodText, aClass);\n      if (oldMethods.length > 0) {\n        oldMethods [0].replace(newMethod);\n      }\n      else {\n        aClass.addAfter(newMethod, anchor);\n      }\n    }\n    if (newMethod != null) {\n      CodeStyleManager csm = CodeStyleManager.getInstance(myProject);\n      newMethod = (PsiMethod)csm.reformat(newMethod);\n      csm.shortenClassReferences(newMethod);\n    }\n  }","id":43959,"modified_method":"private void generateMethodIfRequired(PsiClass aClass, PsiMethod anchor, final String methodName, String methodText, boolean condition) throws IncorrectOperationException {\n    PsiElementFactory elementFactory = PsiManager.getInstance(myProject).getElementFactory();\n    PsiMethod newMethod = null;\n    PsiMethod[] oldMethods = aClass.findMethodsByName(methodName, false);\n    if (!condition) {\n      for(PsiMethod oldMethod: oldMethods) {\n        oldMethod.delete();\n      }\n    }\n    else {\n      newMethod = elementFactory.createMethodFromText(methodText, aClass);\n      if (oldMethods.length > 0) {\n        newMethod = (PsiMethod) oldMethods [0].replace(newMethod);\n      }\n      else {\n        newMethod = (PsiMethod) aClass.addAfter(newMethod, anchor);\n      }\n    }\n  }","commit_id":"a8579579c20453a93aace0c7a96e7bd662418939","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void runTest() throws Throwable {\n    final Throwable[] throwable = new Throwable[] {null};\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        CommandProcessor.getInstance().executeCommand(getProject(), new Runnable() {\n          public void run() {\n\n            try {\n              doRunTest();\n            } catch (Throwable t) {\n              throwable[0] = t;\n            }\n          }\n        }, \"\", null);\n      }\n    });\n\n    if (throwable[0] != null) {\n      throw throwable[0];\n    }\n  }","id":43960,"modified_method":"protected void runTest() throws Throwable {\n    final Throwable[] throwable = {null};\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        CommandProcessor.getInstance().executeCommand(getProject(), new Runnable() {\n          public void run() {\n\n            try {\n              doRunTest();\n            } catch (Throwable t) {\n              throwable[0] = t;\n            }\n          }\n        }, \"\", null);\n      }\n    });\n\n    if (throwable[0] != null) {\n      throw throwable[0];\n    }\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected DataContext getCurrentEditorDataContext() {\n    final DataContext defaultContext = DataManager.getInstance().getDataContext();\n    DataContext dataContext = new DataContext() {\n      @Nullable\n      public Object getData(@NonNls String dataId) {\n        if (dataId.equals(DataConstants.EDITOR)) return getEditor();\n        if (dataId.equals(DataConstants.PROJECT)) return getProject();\n        if (dataId.equals(DataConstants.PSI_FILE)) return getFile();\n        if (dataId.equals(DataConstants.PSI_ELEMENT)) return getFile().findElementAt(getEditor().getCaretModel().getOffset());\n        return defaultContext.getData(dataId);\n      }\n    };\n    return dataContext;\n  }","id":43961,"modified_method":"protected static DataContext getCurrentEditorDataContext() {\n    final DataContext defaultContext = DataManager.getInstance().getDataContext();\n    return new DataContext() {\n      @Nullable\n      public Object getData(@NonNls String dataId) {\n        if (dataId.equals(DataConstants.EDITOR)) return getEditor();\n        if (dataId.equals(DataConstants.PROJECT)) return getProject();\n        if (dataId.equals(DataConstants.PSI_FILE)) return getFile();\n        if (dataId.equals(DataConstants.PSI_ELEMENT)) return getFile().findElementAt(getEditor().getCaretModel().getOffset());\n        return defaultContext.getData(dataId);\n      }\n    };\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Same as checkResultByFile but text is provided directly.\n   * @param message - this check specific message. Added to text, caret position, selection checking. May be null\n   * @param fileText\n   * @param ignoreTrailingSpaces - whether trailing spaces in editor in data file should be stripped prior to comparing.\n   */\n  protected void checkResultByText(String message, String fileText, final boolean ignoreTrailingSpaces) {\n    bringRealEditorBack();\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n      }\n    });\n    final Document document = EditorFactory.getInstance().createDocument(fileText);\n\n    int caretIndex = fileText.indexOf(CARET_MARKER);\n    int selStartIndex = fileText.indexOf(SELECTION_START_MARKER);\n    int selEndIndex = fileText.indexOf(SELECTION_END_MARKER);\n\n    final RangeMarker caretMarker = caretIndex >= 0 ? document.createRangeMarker(caretIndex, caretIndex) : null;\n    final RangeMarker selStartMarker = selStartIndex >= 0\n                                       ? document.createRangeMarker(selStartIndex, selStartIndex)\n                                       : null;\n    final RangeMarker selEndMarker = selEndIndex >= 0\n                                     ? document.createRangeMarker(selEndIndex, selEndIndex)\n                                     : null;\n\n    if (caretMarker != null) {\n      document.deleteString(caretMarker.getStartOffset(), caretMarker.getStartOffset() + CARET_MARKER.length());\n    }\n    if (selStartMarker != null) {\n      document.deleteString(selStartMarker.getStartOffset(),\n                            selStartMarker.getStartOffset() + SELECTION_START_MARKER.length());\n    }\n    if (selEndMarker != null) {\n      document.deleteString(selEndMarker.getStartOffset(),\n                            selEndMarker.getStartOffset() + SELECTION_END_MARKER.length());\n    }\n\n    String newFileText = document.getText();\n    String newFileText1 = newFileText;\n    if (ignoreTrailingSpaces) {\n      Document document1 = EditorFactory.getInstance().createDocument(newFileText);\n      ((DocumentEx) document1).stripTrailingSpaces(false);\n      newFileText1 = document1.getText();\n    }\n\n    PostprocessReformattingAspect.getInstance(getProject()).doPostponedFormatting();\n    PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n    assertEquals(getMessage(\"Text mismatch\", message), newFileText1, myFile.getText());\n\n    checkCaretPosition(caretMarker, newFileText, message);\n    checkSelection(selStartMarker, selEndMarker, newFileText, message);\n  }","id":43962,"modified_method":"/**\n   * Same as checkResultByFile but text is provided directly.\n   * @param message - this check specific message. Added to text, caret position, selection checking. May be null\n   * @param fileText\n   * @param ignoreTrailingSpaces - whether trailing spaces in editor in data file should be stripped prior to comparing.\n   */\n  protected void checkResultByText(String message, String fileText, final boolean ignoreTrailingSpaces) {\n    bringRealEditorBack();\n    PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n    final Document document = EditorFactory.getInstance().createDocument(fileText);\n\n    int caretIndex = fileText.indexOf(CARET_MARKER);\n    int selStartIndex = fileText.indexOf(SELECTION_START_MARKER);\n    int selEndIndex = fileText.indexOf(SELECTION_END_MARKER);\n\n    final RangeMarker caretMarker = caretIndex >= 0 ? document.createRangeMarker(caretIndex, caretIndex) : null;\n    final RangeMarker selStartMarker = selStartIndex >= 0\n                                       ? document.createRangeMarker(selStartIndex, selStartIndex)\n                                       : null;\n    final RangeMarker selEndMarker = selEndIndex >= 0\n                                     ? document.createRangeMarker(selEndIndex, selEndIndex)\n                                     : null;\n\n    if (caretMarker != null) {\n      document.deleteString(caretMarker.getStartOffset(), caretMarker.getStartOffset() + CARET_MARKER.length());\n    }\n    if (selStartMarker != null) {\n      document.deleteString(selStartMarker.getStartOffset(),\n                            selStartMarker.getStartOffset() + SELECTION_START_MARKER.length());\n    }\n    if (selEndMarker != null) {\n      document.deleteString(selEndMarker.getStartOffset(),\n                            selEndMarker.getStartOffset() + SELECTION_END_MARKER.length());\n    }\n\n    String newFileText = document.getText();\n    String newFileText1 = newFileText;\n    if (ignoreTrailingSpaces) {\n      Document document1 = EditorFactory.getInstance().createDocument(newFileText);\n      ((DocumentEx) document1).stripTrailingSpaces(false);\n      newFileText1 = document1.getText();\n    }\n\n    PostprocessReformattingAspect.getInstance(getProject()).doPostponedFormatting();\n    PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n    assertEquals(getMessage(\"Text mismatch\", message), newFileText1, myFile.getText());\n\n    checkCaretPosition(caretMarker, newFileText, message);\n    checkSelection(selStartMarker, selEndMarker, newFileText, message);\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getMessage(String engineMessage, String userMessage) {\n    if (userMessage == null) return engineMessage;\n    StringBuffer buf = new StringBuffer(userMessage);\n    buf.append(\" [\").append(engineMessage).append(\"]\");\n    return buf.toString();\n  }","id":43963,"modified_method":"private static String getMessage(@NonNls String engineMessage, String userMessage) {\n    if (userMessage == null) return engineMessage;\n    return userMessage + \" [\" + engineMessage + \"]\";\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean preprocessUsages(Ref<UsageInfo[]> refUsages) {\n    final ArrayList<String> conflicts = new ArrayList<String>();\n\n    class Visitor extends JavaRecursiveElementVisitor {\n      private final HashMap<PsiElement,HashSet<PsiElement>> reported = new HashMap<PsiElement, HashSet<PsiElement>>();\n\n      @Override public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {\n        PsiElement resolved = reference.resolve();\n        if (resolved instanceof PsiMember &&\n            PsiTreeUtil.isAncestor(myInnerClass, resolved, true) &&\n            becomesInaccessible(((PsiMember)resolved))) {\n          final PsiElement container = ConflictsUtil.getContainer(reference);\n          HashSet<PsiElement> containerSet = reported.get(resolved);\n          if (containerSet == null) {\n            containerSet = new HashSet<PsiElement>();\n            reported.put(resolved, containerSet);\n          }\n          if (!containerSet.contains(container)) {\n            containerSet.add(container);\n            String message = RefactoringBundle.message(\"0.will.become.inaccessible.from.1\",\n                                                       RefactoringUIUtil.getDescription(resolved, true),\n                                                       RefactoringUIUtil.getDescription(container, true));\n            conflicts.add(message);\n          }\n        }\n      }\n\n      private boolean becomesInaccessible(PsiMember element) {\n        final String visibilityModifier = VisibilityUtil.getVisibilityModifier(element.getModifierList());\n        if (PsiModifier.PRIVATE.equals(visibilityModifier)) return true;\n        if (PsiModifier.PUBLIC.equals(visibilityModifier)) return false;\n        final PsiFile containingFile = myOuterClass.getContainingFile();\n        if (myTargetContainer instanceof PsiDirectory) {\n          final PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage(((PsiDirectory)myTargetContainer));\n          return !isInPackage(containingFile, aPackage);\n        }\n        // target container is a class\n        PsiFile targetFile = myTargetContainer.getContainingFile();\n        if (targetFile != null) {\n          final PsiDirectory containingDirectory = targetFile.getContainingDirectory();\n          if (containingDirectory != null) {\n            final PsiPackage targetPackage = JavaDirectoryService.getInstance().getPackage(containingDirectory);\n            return isInPackage(containingFile, targetPackage);\n          }\n        }\n        return false;\n      }\n\n\n      @Override public void visitClass(PsiClass aClass) {\n        if (aClass == myInnerClass) return;\n        super.visitClass(aClass);\n      }\n    }\n\n//    if (myInnerClass.hasModifierProperty(PsiModifier.)) {\n    myOuterClass.accept(new Visitor());\n\n    return showConflicts(conflicts);\n  }","id":43964,"modified_method":"protected boolean preprocessUsages(Ref<UsageInfo[]> refUsages) {\n    final ArrayList<String> conflicts = new ArrayList<String>();\n\n    class Visitor extends JavaRecursiveElementVisitor {\n      private final HashMap<PsiElement,HashSet<PsiElement>> reported = new HashMap<PsiElement, HashSet<PsiElement>>();\n\n      @Override public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {\n        PsiElement resolved = reference.resolve();\n        if (resolved instanceof PsiMember &&\n            PsiTreeUtil.isAncestor(myInnerClass, resolved, true) &&\n            becomesInaccessible((PsiMember)resolved)) {\n          final PsiElement container = ConflictsUtil.getContainer(reference);\n          HashSet<PsiElement> containerSet = reported.get(resolved);\n          if (containerSet == null) {\n            containerSet = new HashSet<PsiElement>();\n            reported.put(resolved, containerSet);\n          }\n          if (!containerSet.contains(container)) {\n            containerSet.add(container);\n            String message = RefactoringBundle.message(\"0.will.become.inaccessible.from.1\",\n                                                       RefactoringUIUtil.getDescription(resolved, true),\n                                                       RefactoringUIUtil.getDescription(container, true));\n            conflicts.add(message);\n          }\n        }\n      }\n\n      private boolean becomesInaccessible(PsiMember element) {\n        final String visibilityModifier = VisibilityUtil.getVisibilityModifier(element.getModifierList());\n        if (PsiModifier.PRIVATE.equals(visibilityModifier)) return true;\n        if (PsiModifier.PUBLIC.equals(visibilityModifier)) return false;\n        final PsiFile containingFile = myOuterClass.getContainingFile();\n        if (myTargetContainer instanceof PsiDirectory) {\n          final PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage((PsiDirectory)myTargetContainer);\n          return !isInPackage(containingFile, aPackage);\n        }\n        // target container is a class\n        PsiFile targetFile = myTargetContainer.getContainingFile();\n        if (targetFile != null) {\n          final PsiDirectory containingDirectory = targetFile.getContainingDirectory();\n          if (containingDirectory != null) {\n            final PsiPackage targetPackage = JavaDirectoryService.getInstance().getPackage(containingDirectory);\n            return isInPackage(containingFile, targetPackage);\n          }\n        }\n        return false;\n      }\n\n\n      @Override public void visitClass(PsiClass aClass) {\n        if (aClass == myInnerClass) return;\n        super.visitClass(aClass);\n      }\n    }\n\n//    if (myInnerClass.hasModifierProperty(PsiModifier.)) {\n    myOuterClass.accept(new Visitor());\n\n    return showConflicts(conflicts);\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void performRefactoring(final UsageInfo[] usages) {\n    PsiManager manager = PsiManager.getInstance(myProject);\n    final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n\n    final RefactoringElementListener elementListener = getTransaction().getElementListener(myInnerClass);\n    String newClassName = myNewClassName;\n    try {\n      PsiField field = null;\n      if (myParameterNameOuterClass != null) {\n        // pass outer as a parameter\n        field = factory.createField(myFieldNameOuterClass, factory.createType(myOuterClass));\n        field = (PsiField)myInnerClass.add(field);\n        addFieldInitializationToConstructors(myInnerClass, field, myParameterNameOuterClass);\n      }\n\n      ChangeContextUtil.encodeContextInfo(myInnerClass, false);\n\n      PsiClass newClass;\n      if (myTargetContainer instanceof PsiDirectory) {\n        newClass = JavaDirectoryService.getInstance().createClass(((PsiDirectory)myTargetContainer), newClassName);\n        PsiDocComment defaultDocComment = newClass.getDocComment();\n        if (defaultDocComment != null && myInnerClass.getDocComment() == null) {\n          myInnerClass.addAfter(defaultDocComment, null);\n        }\n\n        newClass = (PsiClass)newClass.replace(myInnerClass);\n        newClass.getModifierList().setModifierProperty(PsiModifier.STATIC, false);\n        newClass.getModifierList().setModifierProperty(PsiModifier.PRIVATE, false);\n        newClass.getModifierList().setModifierProperty(PsiModifier.PROTECTED, false);\n        final boolean makePublic = needPublicAccess();\n        if (makePublic) {\n          newClass.getModifierList().setModifierProperty(PsiModifier.PUBLIC, true);\n        }\n\n        final PsiMethod[] constructors = newClass.getConstructors();\n        for (PsiMethod constructor : constructors) {\n          final PsiModifierList modifierList = constructor.getModifierList();\n          modifierList.setModifierProperty(PsiModifier.PRIVATE, false);\n          modifierList.setModifierProperty(PsiModifier.PROTECTED, false);\n          if (makePublic) {\n            modifierList.setModifierProperty(PsiModifier.PUBLIC, true);\n          }\n        }\n\n      }\n      else {\n        newClass = (PsiClass)myTargetContainer.add(myInnerClass);\n      }\n      newClass.setName(newClassName);\n\n      // replace references in a new class to old inner class with references to itself\n      for (PsiReference ref : ReferencesSearch.search(myInnerClass, new LocalSearchScope(newClass), true)) {\n        PsiElement element = ref.getElement();\n        if (element.getParent() instanceof PsiJavaCodeReferenceElement) {\n          PsiJavaCodeReferenceElement parentRef = (PsiJavaCodeReferenceElement)element.getParent();\n          PsiElement parentRefElement = parentRef.resolve();\n          if (parentRefElement instanceof PsiClass) { // reference to inner class inside our inner\n            parentRef.getQualifier().delete();\n            continue;\n          }\n        }\n        ref.bindToElement(newClass);\n      }\n\n      List<PsiReference> referencesToRebind = new ArrayList<PsiReference>();\n      for (UsageInfo usage : usages) {\n        if (usage.isNonCodeUsage) continue;\n        PsiElement refElement = usage.getElement();\n        PsiReference[] references = refElement.getReferences();\n        for (PsiReference reference : references) {\n          if (reference.isReferenceTo(myInnerClass)) {\n            referencesToRebind.add(reference);\n          }\n        }\n      }\n\n      myInnerClass.delete();\n\n      // correct references in usages\n      for (UsageInfo usage : usages) {\n        if (usage.isNonCodeUsage) continue;\n        PsiElement refElement = usage.getElement();\n        if (myParameterNameOuterClass != null) { // should pass outer as parameter\n          PsiElement refParent = refElement.getParent();\n          if (refParent instanceof PsiNewExpression || refParent instanceof PsiAnonymousClass) {\n            PsiNewExpression newExpr = refParent instanceof PsiNewExpression\n                                       ? (PsiNewExpression)refParent\n                                       : (PsiNewExpression)refParent.getParent();\n\n            PsiExpressionList argList = newExpr.getArgumentList();\n\n            if (argList != null) { // can happen in incomplete code\n              if (newExpr.getQualifier() == null) {\n                PsiThisExpression thisExpr;\n                PsiClass parentClass = RefactoringUtil.getThisClass(newExpr);\n                if (myOuterClass.equals(parentClass)) {\n                  thisExpr = RefactoringUtil.createThisExpression(manager, null);\n                }\n                else {\n                  thisExpr = RefactoringUtil.createThisExpression(manager, myOuterClass);\n                }\n                argList.addAfter(thisExpr, null);\n              }\n              else {\n                argList.addAfter(newExpr.getQualifier(), null);\n                newExpr.getQualifier().delete();\n              }\n            }\n          }\n        }\n      }\n\n      for (PsiReference reference : referencesToRebind) {\n        reference.bindToElement(newClass);\n      }\n\n      if (field != null) {\n        PsiExpression accessExpression = factory.createExpressionFromText(myFieldNameOuterClass, null);\n        ChangeContextUtil.decodeContextInfo(newClass, myOuterClass, accessExpression);\n      }\n      else {\n        ChangeContextUtil.decodeContextInfo(newClass, null, null);\n      }\n\n      PsiFile targetFile = newClass.getContainingFile();\n      OpenFileDescriptor descriptor = new OpenFileDescriptor(myProject, targetFile.getVirtualFile(), newClass.getTextOffset());\n      FileEditorManager.getInstance(myProject).openTextEditor(descriptor, true);\n\n      if (myMoveCallback != null) {\n        myMoveCallback.refactoringCompleted();\n      }\n      elementListener.elementMoved(newClass);\n\n      List<NonCodeUsageInfo> nonCodeUsages = new ArrayList<NonCodeUsageInfo>();\n      for (UsageInfo usage : usages) {\n        if (usage instanceof NonCodeUsageInfo) {\n          nonCodeUsages.add((NonCodeUsageInfo)usage);\n        }\n      }\n      myNonCodeUsages = nonCodeUsages.toArray(new NonCodeUsageInfo[nonCodeUsages.size()]);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":43965,"modified_method":"protected void performRefactoring(final UsageInfo[] usages) {\n    PsiManager manager = PsiManager.getInstance(myProject);\n    final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n\n    final RefactoringElementListener elementListener = getTransaction().getElementListener(myInnerClass);\n    String newClassName = myNewClassName;\n    try {\n      PsiField field = null;\n      if (myParameterNameOuterClass != null) {\n        // pass outer as a parameter\n        field = factory.createField(myFieldNameOuterClass, factory.createType(myOuterClass));\n        field = (PsiField)myInnerClass.add(field);\n        myInnerClass = field.getContainingClass();\n        addFieldInitializationToConstructors(myInnerClass, field, myParameterNameOuterClass);\n      }\n\n      ChangeContextUtil.encodeContextInfo(myInnerClass, false);\n\n      PsiClass newClass;\n      if (myTargetContainer instanceof PsiDirectory) {\n        myInnerClass = CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(myInnerClass);\n        newClass = JavaDirectoryService.getInstance().createClass((PsiDirectory)myTargetContainer, newClassName);\n        PsiDocComment defaultDocComment = newClass.getDocComment();\n        if (defaultDocComment != null && myInnerClass.getDocComment() == null) {\n          myInnerClass = (PsiClass)myInnerClass.addAfter(defaultDocComment, null).getParent();\n        }\n\n        newClass = (PsiClass)newClass.replace(myInnerClass);\n        newClass.getModifierList().setModifierProperty(PsiModifier.STATIC, false);\n        newClass.getModifierList().setModifierProperty(PsiModifier.PRIVATE, false);\n        newClass.getModifierList().setModifierProperty(PsiModifier.PROTECTED, false);\n        final boolean makePublic = needPublicAccess();\n        if (makePublic) {\n          newClass.getModifierList().setModifierProperty(PsiModifier.PUBLIC, true);\n        }\n\n        final PsiMethod[] constructors = newClass.getConstructors();\n        for (PsiMethod constructor : constructors) {\n          final PsiModifierList modifierList = constructor.getModifierList();\n          modifierList.setModifierProperty(PsiModifier.PRIVATE, false);\n          modifierList.setModifierProperty(PsiModifier.PROTECTED, false);\n          if (makePublic) {\n            modifierList.setModifierProperty(PsiModifier.PUBLIC, true);\n          }\n        }\n\n      }\n      else {\n        newClass = (PsiClass)myTargetContainer.add(myInnerClass);\n      }\n      newClass.setName(newClassName);\n\n      // replace references in a new class to old inner class with references to itself\n      for (PsiReference ref : ReferencesSearch.search(myInnerClass, new LocalSearchScope(newClass), true)) {\n        PsiElement element = ref.getElement();\n        if (element.getParent() instanceof PsiJavaCodeReferenceElement) {\n          PsiJavaCodeReferenceElement parentRef = (PsiJavaCodeReferenceElement)element.getParent();\n          PsiElement parentRefElement = parentRef.resolve();\n          if (parentRefElement instanceof PsiClass) { // reference to inner class inside our inner\n            parentRef.getQualifier().delete();\n            continue;\n          }\n        }\n        ref.bindToElement(newClass);\n      }\n\n      List<PsiReference> referencesToRebind = new ArrayList<PsiReference>();\n      for (UsageInfo usage : usages) {\n        if (usage.isNonCodeUsage) continue;\n        PsiElement refElement = usage.getElement();\n        PsiReference[] references = refElement.getReferences();\n        for (PsiReference reference : references) {\n          if (reference.isReferenceTo(myInnerClass)) {\n            referencesToRebind.add(reference);\n          }\n        }\n      }\n\n      myInnerClass.delete();\n\n      // correct references in usages\n      for (UsageInfo usage : usages) {\n        if (usage.isNonCodeUsage) continue;\n        PsiElement refElement = usage.getElement();\n        if (myParameterNameOuterClass != null) { // should pass outer as parameter\n          PsiElement refParent = refElement.getParent();\n          if (refParent instanceof PsiNewExpression || refParent instanceof PsiAnonymousClass) {\n            PsiNewExpression newExpr = refParent instanceof PsiNewExpression\n                                       ? (PsiNewExpression)refParent\n                                       : (PsiNewExpression)refParent.getParent();\n\n            PsiExpressionList argList = newExpr.getArgumentList();\n\n            if (argList != null) { // can happen in incomplete code\n              if (newExpr.getQualifier() == null) {\n                PsiThisExpression thisExpr;\n                PsiClass parentClass = RefactoringUtil.getThisClass(newExpr);\n                if (myOuterClass.equals(parentClass)) {\n                  thisExpr = RefactoringUtil.createThisExpression(manager, null);\n                }\n                else {\n                  thisExpr = RefactoringUtil.createThisExpression(manager, myOuterClass);\n                }\n                argList.addAfter(thisExpr, null);\n              }\n              else {\n                argList.addAfter(newExpr.getQualifier(), null);\n                newExpr.getQualifier().delete();\n              }\n            }\n          }\n        }\n      }\n\n      for (PsiReference reference : referencesToRebind) {\n        reference.bindToElement(newClass);\n      }\n\n      if (field != null) {\n        PsiExpression accessExpression = factory.createExpressionFromText(myFieldNameOuterClass, null);\n        ChangeContextUtil.decodeContextInfo(newClass, myOuterClass, accessExpression);\n      }\n      else {\n        ChangeContextUtil.decodeContextInfo(newClass, null, null);\n      }\n\n      PsiFile targetFile = newClass.getContainingFile();\n      OpenFileDescriptor descriptor = new OpenFileDescriptor(myProject, targetFile.getVirtualFile(), newClass.getTextOffset());\n      FileEditorManager.getInstance(myProject).openTextEditor(descriptor, true);\n\n      if (myMoveCallback != null) {\n        myMoveCallback.refactoringCompleted();\n      }\n      elementListener.elementMoved(newClass);\n\n      List<NonCodeUsageInfo> nonCodeUsages = new ArrayList<NonCodeUsageInfo>();\n      for (UsageInfo usage : usages) {\n        if (usage instanceof NonCodeUsageInfo) {\n          nonCodeUsages.add((NonCodeUsageInfo)usage);\n        }\n      }\n      myNonCodeUsages = nonCodeUsages.toArray(new NonCodeUsageInfo[nonCodeUsages.size()]);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean needPublicAccess() {\n    if (myOuterClass.isInterface()) {\n      return true;\n    }\n    if (myTargetContainer instanceof PsiDirectory) {\n      PsiPackage targetPackage = JavaDirectoryService.getInstance().getPackage(((PsiDirectory)myTargetContainer));\n      if (targetPackage != null && !isInPackage(myOuterClass.getContainingFile(), targetPackage)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":43966,"modified_method":"private boolean needPublicAccess() {\n    if (myOuterClass.isInterface()) {\n      return true;\n    }\n    if (myTargetContainer instanceof PsiDirectory) {\n      PsiPackage targetPackage = JavaDirectoryService.getInstance().getPackage((PsiDirectory)myTargetContainer);\n      if (targetPackage != null && !isInPackage(myOuterClass.getContainingFile(), targetPackage)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void storeLinesAndCols() {\n    myStartLine = myDocument.getLineNumber(getStartOffset());\n    myStartColumn = getStartOffset() - myDocument.getLineStartOffset(myStartLine);\n    myEndLine = myDocument.getLineNumber(getEndOffset());\n    myEndColumn = getEndOffset() - myDocument.getLineStartOffset(myEndLine);\n  }","id":43967,"modified_method":"private void storeLinesAndCols() {\n    // document might have been changed already\n    if (getStartOffset() < myDocument.getTextLength()) {\n      myStartLine = myDocument.getLineNumber(getStartOffset());\n      myStartColumn = getStartOffset() - myDocument.getLineStartOffset(myStartLine);\n    }\n    if (getEndOffset() < myDocument.getTextLength()) {\n      myEndLine = myDocument.getLineNumber(getEndOffset());\n      myEndColumn = getEndOffset() - myDocument.getLineStartOffset(myEndLine);\n    }\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerLocalRef(@NotNull PsiReference ref, PsiElement refElement) {\n    if (refElement instanceof PsiMethod && PsiTreeUtil.isAncestor(refElement, ref.getElement(), true)) return; // filter self-recursive calls\n    if (refElement instanceof PsiClass && PsiTreeUtil.isAncestor(refElement, ref.getElement(), true)) return; // filter inner use of itself\n    synchronized (myLocalRefsMap) {\n      myLocalRefsMap.put(ref, refElement);\n    }\n    if(refElement instanceof PsiNamedElement) {\n      PsiNamedElement namedElement = (PsiNamedElement)refElement;\n    }\n  }","id":43968,"modified_method":"private void registerLocalRef(@NotNull PsiReference ref, PsiElement refElement) {\n    if (refElement instanceof PsiMethod && PsiTreeUtil.isAncestor(refElement, ref.getElement(), true)) return; // filter self-recursive calls\n    if (refElement instanceof PsiClass && PsiTreeUtil.isAncestor(refElement, ref.getElement(), true)) return; // filter inner use of itself\n    synchronized (myLocalRefsMap) {\n      myLocalRefsMap.put(ref, refElement);\n    }\n  }","commit_id":"38ddd35fccbd8d92da7fa84c194e5626b9053745","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    // expect the descriptor to point to the unresolved identifier.\n    PyClass cls = myQualifierClass;\n    String item_name = myIdentifier;\n    if (cls != null) {\n      if (addFieldToInit(project, cls, item_name, new CreateFieldCallback(project, item_name))) return;\n    }\n    // somehow we failed. tell about this\n    PyUtil.showBalloon(project, PyBundle.message(\"QFIX.failed.to.add.field\"), MessageType.ERROR);\n  }","id":43969,"modified_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    // expect the descriptor to point to the unresolved identifier.\n    PyClass cls = myQualifierClass;\n    String item_name = myIdentifier;\n    if (cls != null) {\n      PsiElement initStatement = addFieldToInit(project, cls, item_name, new CreateFieldCallback(project, item_name));\n      if (initStatement != null) {\n        showTemplateBuilder(initStatement);\n        return;\n      }\n    }\n    // somehow we failed. tell about this\n    PyUtil.showBalloon(project, PyBundle.message(\"QFIX.failed.to.add.field\"), MessageType.ERROR);\n  }","commit_id":"0f49b802f66803bab9e1996496d4465309ca7456","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean addFieldToInit(Project project, PyClass cls, String item_name, FieldCallback callback) {\n    if (cls != null && item_name != null) {\n      PyFunction init = cls.findMethodByName(PyNames.INIT, false);\n      Language language = cls.getLanguage();\n      if (language instanceof PythonLanguage) {\n        PythonLanguage pythonLanguage = (PythonLanguage)language;\n        PyElementGenerator generator = pythonLanguage.getElementGenerator();\n        callback.setGenerator(generator);\n        if (init != null) {\n          appendToInit(init, callback);\n          return true;\n        }\n        else { // no init! boldly copy ancestor's.\n          for (PyClass ancestor : cls.iterateAncestors()) {\n            init = ancestor.findMethodByName(PyNames.INIT, false);\n            if (init != null) break;\n          }\n          PyFunction new_init = createInitMethod(project, cls, init, generator);\n\n          appendToInit(new_init, callback);\n          new_init.add(generator.createFromText(project, PsiWhiteSpace.class, \"\\n\\n\")); // after the last line\n\n          PsiElement add_anchor = null;\n          PyFunction[] meths = cls.getMethods();\n          if (meths.length > 0) add_anchor = meths[0].getPrevSibling();\n          PyStatementList cls_content = cls.getStatementList();\n          cls_content.addAfter(new_init, add_anchor);\n\n          PyUtil.showBalloon(project, PyBundle.message(\"QFIX.added.constructor.$0.for.field.$1\", cls.getName(), item_name), MessageType.INFO);\n          return true;\n          //else  // well, that can't be\n        }\n      }\n    }\n    return false;\n  }","id":43970,"modified_method":"public static PsiElement addFieldToInit(Project project, PyClass cls, String item_name, FieldCallback callback) {\n    if (cls != null && item_name != null) {\n      PyFunction init = cls.findMethodByName(PyNames.INIT, false);\n      Language language = cls.getLanguage();\n      if (language instanceof PythonLanguage) {\n        PythonLanguage pythonLanguage = (PythonLanguage)language;\n        PyElementGenerator generator = pythonLanguage.getElementGenerator();\n        callback.setGenerator(generator);\n        if (init != null) {\n          return appendToInit(init, callback);\n        }\n        else { // no init! boldly copy ancestor's.\n          for (PyClass ancestor : cls.iterateAncestors()) {\n            init = ancestor.findMethodByName(PyNames.INIT, false);\n            if (init != null) break;\n          }\n          PyFunction new_init = createInitMethod(project, cls, init, generator);\n\n          appendToInit(new_init, callback);\n          new_init.add(generator.createFromText(project, PsiWhiteSpace.class, \"\\n\\n\")); // after the last line\n\n          PsiElement add_anchor = null;\n          PyFunction[] meths = cls.getMethods();\n          if (meths.length > 0) add_anchor = meths[0].getPrevSibling();\n          PyStatementList cls_content = cls.getStatementList();\n          new_init = (PyFunction) cls_content.addAfter(new_init, add_anchor);\n\n          PyUtil.showBalloon(project, PyBundle.message(\"QFIX.added.constructor.$0.for.field.$1\", cls.getName(), item_name), MessageType.INFO);\n          return new_init.getStatementList().getStatements()[0];\n          //else  // well, that can't be\n        }\n      }\n    }\n    return null;\n  }","commit_id":"0f49b802f66803bab9e1996496d4465309ca7456","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiFile createGroovyFile(String idText) {\n    return PsiManager.getInstance(myProject).getElementFactory().createFileFromText(\"__DUMMY.\" + GroovyFileType.GROOVY_FILE_TYPE.getDefaultExtension(), idText);\n  }","id":43971,"modified_method":"private PsiFile createGroovyFile(String idText) {\n    return createDummyFile(idText);\n  }","commit_id":"8fc9d56af2d080e09feb1e63e77f169c99a73ace","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrParameter createParameter(String name, @Nullable String typeText) throws IncorrectOperationException {\n    String fileText;\n    if (typeText != null) {\n      fileText = \"def foo(\" + typeText + \" \" + name + \") {}\";\n    } else {\n      fileText = \"def foo(\" + name + \") {}\";\n    }\n    PsiFile psiFile = PsiManager.getInstance(myProject).getElementFactory().createFileFromText(\"__DUMMY.\" + GroovyFileType.GROOVY_FILE_TYPE.getDefaultExtension(), fileText);\n    ASTNode node = psiFile.getFirstChild().getNode();\n    if (node.getElementType() != GroovyElementTypes.METHOD_DEFINITION)\n      throw new IncorrectOperationException(\"Invalid all text\");\n    return ((GrMethod) node.getPsi()).getParameters()[0];\n  }","id":43972,"modified_method":"public GrParameter createParameter(String name, @Nullable String typeText) throws IncorrectOperationException {\n    String fileText;\n    if (typeText != null) {\n      fileText = \"def foo(\" + typeText + \" \" + name + \") {}\";\n    } else {\n      fileText = \"def foo(\" + name + \") {}\";\n    }\n    PsiFile psiFile = createDummyFile(fileText);\n    ASTNode node = psiFile.getFirstChild().getNode();\n    if (node.getElementType() != GroovyElementTypes.METHOD_DEFINITION)\n      throw new IncorrectOperationException(\"Invalid all text\");\n    return ((GrMethod) node.getPsi()).getParameters()[0];\n  }","commit_id":"8fc9d56af2d080e09feb1e63e77f169c99a73ace","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrClosableBlock createClosureFromText(String s) throws IncorrectOperationException {\n    PsiFile psiFile = PsiManager.getInstance(myProject).getElementFactory().createFileFromText(\"__DUMMY.\" + GroovyFileType.GROOVY_FILE_TYPE.getDefaultExtension(), s);\n    ASTNode node = psiFile.getFirstChild().getNode();\n    if (node.getElementType() != GroovyElementTypes.CLOSABLE_BLOCK)\n      throw new IncorrectOperationException(\"Invalid all text\");\n    return (GrClosableBlock) node.getPsi();\n  }","id":43973,"modified_method":"public GrClosableBlock createClosureFromText(String closureText) throws IncorrectOperationException {\n    PsiFile psiFile = createDummyFile(closureText);\n    ASTNode node = psiFile.getFirstChild().getNode();\n    if (node.getElementType() != GroovyElementTypes.CLOSABLE_BLOCK)\n      throw new IncorrectOperationException(\"Invalid all text\");\n    return (GrClosableBlock) node.getPsi();\n  }","commit_id":"8fc9d56af2d080e09feb1e63e77f169c99a73ace","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addImportForClass(PsiClass aClass)  {\n    try {\n      // Calculating position\n      Project project = aClass.getProject();\n      GroovyElementFactory factory = GroovyElementFactory.getInstance(project);\n      GrImportStatement ourImportStatement = factory.createImportStatementFromText(aClass.getQualifiedName());\n      GrImportStatement[] importStatements = getImportStatements();\n      PsiElement psiElementAfter = null;\n      if (importStatements.length > 0) {\n        psiElementAfter = importStatements[importStatements.length - 1];\n      } else if (getPackageDefinition() != null) {\n        psiElementAfter = getPackageDefinition();\n      }\n      if (psiElementAfter != null &&\n              psiElementAfter.getNode() != null) {\n        addAfter(ourImportStatement, psiElementAfter);\n      } else {\n        addBefore(ourImportStatement, getFirstChild());\n      }\n    } catch (IncorrectOperationException e) {\n      e.printStackTrace();\n    }\n  }","id":43974,"modified_method":"public GrImportStatement addImportForClass(PsiClass aClass)  {\n    try {\n      // Calculating position\n      Project project = aClass.getProject();\n      GroovyElementFactory factory = GroovyElementFactory.getInstance(project);\n      GrImportStatement ourImportStatement = factory.createImportStatementFromText(aClass.getQualifiedName());\n      GrImportStatement[] importStatements = getImportStatements();\n      PsiElement psiElementAfter = null;\n      if (importStatements.length > 0) {\n        psiElementAfter = importStatements[importStatements.length - 1];\n      } else if (getPackageDefinition() != null) {\n        psiElementAfter = getPackageDefinition();\n      }\n      if (psiElementAfter != null &&\n              psiElementAfter.getNode() != null) {\n        return (GrImportStatement) addAfter(ourImportStatement, psiElementAfter);\n      } else {\n        return (GrImportStatement) addBefore(ourImportStatement, getFirstChild());\n      }\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return null;\n    }\n  }","commit_id":"8fc9d56af2d080e09feb1e63e77f169c99a73ace","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addDelegate(MuleDefinitionParser delegate)\n    {\n        delegates = (MuleDefinitionParser[]) ArrayUtils.add(delegates, delegate);\n    }","id":43975,"modified_method":"protected MuleDefinitionParser addDelegate(MuleDefinitionParser delegate)\n    {\n        delegates = (MuleDefinitionParser[]) ArrayUtils.add(delegates, delegate);\n        return delegate;\n    }","commit_id":"06634bb95f1e95b0ae429980d882d357fb68ad46","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void addDelegate(MuleDefinitionParser delegate)\n    {\n        delegate.registerPreProcessor(new PreProcessor()\n        {\n            public void preProcess(PropertyConfiguration config, Element element)\n            {\n                if (first)\n                {\n                    originalId = element.getAttribute(AbstractMuleBeanDefinitionParser.ATTRIBUTE_ID);\n                    originalName = element.getAttribute(AbstractMuleBeanDefinitionParser.ATTRIBUTE_NAME);\n                }\n                else\n                {\n                    resetNameAndId(element);\n                }\n            }\n        });\n        super.addDelegate(delegate);\n    }","id":43976,"modified_method":"protected MuleDefinitionParser addDelegate(MuleDefinitionParser delegate)\n    {\n        delegate.registerPreProcessor(new PreProcessor()\n        {\n            public void preProcess(PropertyConfiguration config, Element element)\n            {\n                if (first)\n                {\n                    originalId = element.getAttribute(AbstractMuleBeanDefinitionParser.ATTRIBUTE_ID);\n                    originalName = element.getAttribute(AbstractMuleBeanDefinitionParser.ATTRIBUTE_NAME);\n                }\n                else\n                {\n                    resetNameAndId(element);\n                }\n            }\n        });\n        return super.addDelegate(delegate);\n    }","commit_id":"06634bb95f1e95b0ae429980d882d357fb68ad46","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void addChildDelegate(MuleChildDefinitionParser delegate)\n    {\n        super.addDelegate(delegate);\n    }","id":43977,"modified_method":"protected MuleChildDefinitionParser addChildDelegate(MuleChildDefinitionParser delegate)\n    {\n        return (MuleChildDefinitionParser) super.addDelegate(delegate);\n    }","commit_id":"06634bb95f1e95b0ae429980d882d357fb68ad46","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void addDelegate(MuleDefinitionParser delegate)\n    {\n        if (size() > 0)\n        {\n            throw new IllegalStateException(\"Children must implement child interface\");\n        }\n        super.addDelegate(delegate);\n    }","id":43978,"modified_method":"protected MuleDefinitionParser addDelegate(MuleDefinitionParser delegate)\n    {\n        if (size() > 0)\n        {\n            return addDelegateAsChild(delegate);\n        }\n        else\n        {\n            return super.addDelegate(delegate);\n        }\n    }","commit_id":"06634bb95f1e95b0ae429980d882d357fb68ad46","url":"https://github.com/mulesoft/mule"},{"original_method":"public ComponentDefinitionParser(Class beanClass)\n    {\n        this.beanClass = beanClass;\n    }","id":43979,"modified_method":"public ComponentDefinitionParser(Class clazz)\n    {\n        super(clazz, true);\n    }","commit_id":"06634bb95f1e95b0ae429980d882d357fb68ad46","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"admin-agent\", new MuleAdminAgentDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new ThreadingProfileDefinitionParser(\"defaultThreadingProfile\"));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"defaultMessageDispatcherThreadingProfile\"));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"defaultMessageReceiverThreadingProfile\"));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\"));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-component-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\"));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\"));\n        registerBeanDefinitionParser(\"dispatcher-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerMuleDefinitionParser(\"transformer\", new ParentDefinitionParser()).addAlias(\"ref\", \"transformer\");\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"transformer-no-action\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-message-properties\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-string\", new TransformerDefinitionParser(ByteArrayToString.class));\n        registerBeanDefinitionParser(\"transformer-string-to-byte-array\", new TransformerDefinitionParser(StringToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-append-string\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        //TODO RM*: Need to review these, since Spring have some facilities for configuring the transactionManager\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"transaction-manager-jndi\", new MuleOrphanDefinitionParser(GenericTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-weblogic\", new MuleOrphanDefinitionParser(WeblogicTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-jboss\", new MuleOrphanDefinitionParser(JBossTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-jrun\", new MuleOrphanDefinitionParser(JRunTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-resin\", new MuleOrphanDefinitionParser(Resin3TransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-websphere\", new MuleOrphanDefinitionParser(WebsphereTransactionManagerLookupFactory.class, true));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"response-endpoint\", new GenericEndpointDefinitionParser(ResponseEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n        registerBeanDefinitionParser(\"transaction-factory\", new ObjectFactoryDefinitionParser(\"factory\"));\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        //TODO RM*\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolverSet\", null));\n        //registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        // Components\n        BeanDefinitionParser bdpSedaComponent = new ComponentDefinitionParser(SedaComponent.class);\n        registerBeanDefinitionParser(\"seda-component\", bdpSedaComponent);        \n        registerBeanDefinitionParser(\"service\", bdpSedaComponent);\n        \n        // Common POJO Services\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n        registerBeanDefinitionParser(\"rest-service-component\",\n                                     new SingleParentFamilyDefinitionParser(new SimplePojoServiceDefinitionParser(RestServiceWrapper.class))\n                                             .addChildDelegate(\"httpMethod\", new AttributeMapDefinitionParser(\"properties\"))\n                                             .addChildDelegate(\"serviceUrl\", new AttributeMapDefinitionParser(\"properties\"))\n                                             .addChildDelegate(\"urlFromMessage\", new AttributeMapDefinitionParser(\"properties\"))\n                                             .addChildDelegate(\"errorExpression\", new AttributeMapDefinitionParser(\"properties\"))\n        );\n        registerBeanDefinitionParser(\"no-args-call-component\", new SimplePojoServiceDefinitionParser(NoArgsCallWrapper.class));\n\n        //Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new PojoServiceDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new PojoServiceDefinitionParser(PrototypeObjectFactory.class));\n        BeanDefinitionParser bpdPooledObject = new PojoServiceDefinitionParser(PooledObjectFactory.class);\n        registerBeanDefinitionParser(\"pooled-object\", bpdPooledObject);        \n        registerBeanDefinitionParser(\"component\", bpdPooledObject);\n        \n        //Routers\n        registerBeanDefinitionParser(\"inbound-router\", new ChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new ChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"nested-router\", new ChildDefinitionParser(\"nestedRouter\", NestedRouterCollection.class));\n        registerBeanDefinitionParser(\"response-router\", new ChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //rest-service-component\n        registerBeanDefinitionParser(\"payloadParameterNames\", new ChildListDefinitionParser(\"payloadParameterNames\"));\n        registerBeanDefinitionParser(\"requiredParams\", new ChildMapEntryDefinitionParser(\"requiredParams\",\"key\",\"value\"));\n        registerBeanDefinitionParser(\"optionalParams\", new ChildMapEntryDefinitionParser(\"optionalParams\",\"key\",\"value\"));\n\n        //NoArgsCallWrapper\n        registerBeanDefinitionParser(\"delegateClass\", new AttributeMapDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"delegateInstance\", new AttributeMapDefinitionParser(\"properties\"));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new ForwardingRouterDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\"));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Nested binding\n        registerBeanDefinitionParser(\"binding\", new RouterDefinitionParser(\"router\", NestedRouter.class));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(\"router\", null));\n        registerMuleDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-response-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"single-response-router\", new RouterDefinitionParser(\"router\", SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"bean-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", BeanPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessagePropertyExtractor.class));\n        registerBeanDefinitionParser(\"payload-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", PayloadPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n\n        //Common Filters\n        registerMuleDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\"));\n        registerMuleDefinitionParser(\"add-properties\", new ChildMapDefinitionParser(\"addProperties\"));\n        registerMuleDefinitionParser(\"delete-properties\", new ChildListDefinitionParser(\"deleteProperties\"));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\"));\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","id":43980,"modified_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"admin-agent\", new MuleAdminAgentDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new ThreadingProfileDefinitionParser(\"defaultThreadingProfile\"));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"defaultMessageDispatcherThreadingProfile\"));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"defaultMessageReceiverThreadingProfile\"));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\"));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-component-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\"));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\"));\n        registerBeanDefinitionParser(\"dispatcher-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerMuleDefinitionParser(\"transformer\", new ParentDefinitionParser()).addAlias(\"ref\", \"transformer\");\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"transformer-no-action\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-message-properties\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-string\", new TransformerDefinitionParser(ByteArrayToString.class));\n        registerBeanDefinitionParser(\"transformer-string-to-byte-array\", new TransformerDefinitionParser(StringToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-append-string\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        //TODO RM*: Need to review these, since Spring have some facilities for configuring the transactionManager\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"transaction-manager-jndi\", new MuleOrphanDefinitionParser(GenericTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-weblogic\", new MuleOrphanDefinitionParser(WeblogicTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-jboss\", new MuleOrphanDefinitionParser(JBossTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-jrun\", new MuleOrphanDefinitionParser(JRunTransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-resin\", new MuleOrphanDefinitionParser(Resin3TransactionManagerLookupFactory.class, true));\n        registerBeanDefinitionParser(\"transaction-manager-websphere\", new MuleOrphanDefinitionParser(WebsphereTransactionManagerLookupFactory.class, true));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"response-endpoint\", new GenericEndpointDefinitionParser(ResponseEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n        registerBeanDefinitionParser(\"transaction-factory\", new ObjectFactoryDefinitionParser(\"factory\"));\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        //TODO RM*\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolverSet\", null));\n        //registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        // Components\n        BeanDefinitionParser bdpSedaComponent = new ComponentDefinitionParser(SedaComponent.class);\n        registerBeanDefinitionParser(\"seda-component\", bdpSedaComponent);\n        registerBeanDefinitionParser(\"service\", bdpSedaComponent);\n        registerBeanDefinitionParser(\"bridge-service\", new BridgeServiceDefinitionParser());\n\n        // Common POJO Services\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n        registerBeanDefinitionParser(\"rest-service-component\",\n                                     new SingleParentFamilyDefinitionParser(new SimplePojoServiceDefinitionParser(RestServiceWrapper.class))\n                                             .addChildDelegate(\"httpMethod\", new AttributeMapDefinitionParser(\"properties\"))\n                                             .addChildDelegate(\"serviceUrl\", new AttributeMapDefinitionParser(\"properties\"))\n                                             .addChildDelegate(\"urlFromMessage\", new AttributeMapDefinitionParser(\"properties\"))\n                                             .addChildDelegate(\"errorExpression\", new AttributeMapDefinitionParser(\"properties\"))\n        );\n        registerBeanDefinitionParser(\"no-args-call-component\", new SimplePojoServiceDefinitionParser(NoArgsCallWrapper.class));\n\n        //Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new PojoServiceDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new PojoServiceDefinitionParser(PrototypeObjectFactory.class));\n        BeanDefinitionParser bpdPooledObject = new PojoServiceDefinitionParser(PooledObjectFactory.class);\n        registerBeanDefinitionParser(\"pooled-object\", bpdPooledObject);\n        registerBeanDefinitionParser(\"component\", bpdPooledObject);\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound-router\", new ChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new ChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"nested-router\", new ChildDefinitionParser(\"nestedRouter\", NestedRouterCollection.class));\n        registerBeanDefinitionParser(\"response-router\", new ChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //rest-service-component\n        registerBeanDefinitionParser(\"payloadParameterNames\", new ChildListDefinitionParser(\"payloadParameterNames\"));\n        registerBeanDefinitionParser(\"requiredParams\", new ChildMapEntryDefinitionParser(\"requiredParams\",\"key\",\"value\"));\n        registerBeanDefinitionParser(\"optionalParams\", new ChildMapEntryDefinitionParser(\"optionalParams\",\"key\",\"value\"));\n\n        //NoArgsCallWrapper\n        registerBeanDefinitionParser(\"delegateClass\", new AttributeMapDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"delegateInstance\", new AttributeMapDefinitionParser(\"properties\"));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new ForwardingRouterDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\"));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Nested binding\n        registerBeanDefinitionParser(\"binding\", new RouterDefinitionParser(\"router\", NestedRouter.class));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(\"router\", null));\n        registerMuleDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-response-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"single-response-router\", new RouterDefinitionParser(\"router\", SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"bean-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", BeanPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessagePropertyExtractor.class));\n        registerBeanDefinitionParser(\"payload-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", PayloadPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n\n        //Common Filters\n        registerMuleDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\"));\n        registerMuleDefinitionParser(\"add-properties\", new ChildMapDefinitionParser(\"addProperties\"));\n        registerMuleDefinitionParser(\"delete-properties\", new ChildListDefinitionParser(\"deleteProperties\"));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\"));\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","commit_id":"06634bb95f1e95b0ae429980d882d357fb68ad46","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void addDelegate(MuleDefinitionParser delegate)\n    {\n        throw new UnsupportedOperationException(\"Delegates must be associated with attribute names\");\n    }","id":43981,"modified_method":"protected MuleDefinitionParser addDelegate(MuleDefinitionParser delegate)\n    {\n        throw new UnsupportedOperationException(\"Delegates must be associated with attribute names\");\n    }","commit_id":"06634bb95f1e95b0ae429980d882d357fb68ad46","url":"https://github.com/mulesoft/mule"},{"original_method":"KBaseUnitImpl(KProject kProject, String kBaseName) {\n        this(kProject, kBaseName, null);\n    }","id":43982,"modified_method":"public KBaseUnitImpl(KProject kProject, String kBaseName) {\n        this(kProject, kBaseName, null);\n    }","commit_id":"2735a0c984c257e61faa31268d5c38736b4e1bc4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public File buildKJar(File rootFolder, File outputFolder, String jarName) {\n        KProject kProject = (KProject)new XStream().fromXML(new File(rootFolder, KPROJECT_RELATIVE_PATH));\n        return writeKJar(rootFolder, outputFolder, jarName, kProject);\n    }","id":43983,"modified_method":"public File buildKJar(File rootFolder, File outputFolder, String jarName) {\n        KProject kProject = fromXML(new File(rootFolder, KPROJECT_RELATIVE_PATH));\n        return writeKJar(rootFolder, outputFolder, jarName, kProject);\n    }","commit_id":"2735a0c984c257e61faa31268d5c38736b4e1bc4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private KProject loadKProject() {\n        InputStream kProjectStream = null;\n        try {\n            kProjectStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(KPROJECT_JAR_PATH);\n            return (KProject)new XStream().fromXML(kProjectStream);\n        } finally {\n            try {\n                if (kProjectStream != null) {\n                    kProjectStream.close();\n                }\n            } catch (IOException e) { }\n        }\n    }","id":43984,"modified_method":"private KProject loadKProject() {\n        InputStream kProjectStream = null;\n        try {\n            kProjectStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(KPROJECT_JAR_PATH);\n            return fromXML(kProjectStream);\n        } finally {\n            try {\n                if (kProjectStream != null) {\n                    kProjectStream.close();\n                }\n            } catch (IOException e) { }\n        }\n    }","commit_id":"2735a0c984c257e61faa31268d5c38736b4e1bc4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public List<KBaseUnit> getKBaseUnits(File rootFolder, File sourceFolder) {\n        List<KBaseUnit> units = new ArrayList<KBaseUnit>();\n        KProject kProject = (KProject)new XStream().fromXML(new File(rootFolder, KPROJECT_RELATIVE_PATH));\n        for (KBase kBase : kProject.getKBases().values()) {\n            units.add(new KBaseUnitImpl( kProject, kBase.getQName(), sourceFolder ));\n        }\n        return units;\n    }","id":43985,"modified_method":"public List<KBaseUnit> getKBaseUnits(File rootFolder, File sourceFolder) {\n        List<KBaseUnit> units = new ArrayList<KBaseUnit>();\n        KProject kProject = fromXML(new File(rootFolder, KPROJECT_RELATIVE_PATH));\n        for (KBase kBase : kProject.getKBases().values()) {\n            units.add(new KBaseUnitImpl( kProject, kBase.getQName(), sourceFolder ));\n        }\n        return units;\n    }","commit_id":"2735a0c984c257e61faa31268d5c38736b4e1bc4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private File writeAsJar(File rootFolder, File outputFolder, String jarName, Map<String, String> entries) {\n        ZipOutputStream out = null;\n        try {\n            java.io.File jarFile = new java.io.File( outputFolder, jarName );\n            out = new ZipOutputStream( new FileOutputStream(jarFile) );\n\n            writeJarEntries( out, rootFolder, entries );\n            out.close();\n\n            return jarFile;\n        } catch ( IOException e ) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                out.close();\n            } catch (IOException e) { }\n        }\n    }","id":43986,"modified_method":"private File writeAsJar(File rootFolder, File outputFolder, String jarName, Map<String, String> entries) {\n        ZipOutputStream out = null;\n        try {\n            java.io.File jarFile = new java.io.File( outputFolder, jarName );\n            out = new ZipOutputStream( new FileOutputStream(jarFile) );\n\n            writeJarEntries( out, rootFolder, entries );\n            out.close();\n\n            return jarFile;\n        } catch ( IOException e ) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException e) { }\n        }\n    }","commit_id":"2735a0c984c257e61faa31268d5c38736b4e1bc4","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PomModel getPomModel() {\n        pomXml = srcMfs.getBytes( \"pom.xml\" );       \n        if ( pomXml == null) {\n            return null;\n        }\n        \n        PomModel pomModel = MinimalPomParser.parse( \"pom.xml\", new ByteArrayInputStream( pomXml ) );\n        return pomModel;\n    }","id":43987,"modified_method":"public PomModel getPomModel() {\n        pomXml = srcMfs.getBytes( \"pom.xml\" );       \n        if ( pomXml == null) {\n            return null;\n        }\n\n        return MinimalPomParser.parse( \"pom.xml\", new ByteArrayInputStream( pomXml ) );\n    }","commit_id":"769e3e105fd1085d722faa2455c9aaf115870e39","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private KieProject getKieProject() {\n        byte[] bytes = srcMfs.getBytes( KieContainer.KPROJECT_RELATIVE_PATH );\n        \n        if ( bytes == null ) {\n            bytes = srcMfs.getBytes( KieContainer.KPROJECT_JAR_PATH );\n        }\n        \n        \n        if ( bytes != null ) {\n            try {\n                return ( KieProjectImpl ) KieProjectImpl.fromXML( new ByteArrayInputStream( bytes ) );\n            } catch ( Exception e) {\n                invalidKieProject = true;  \n                messages.add( new MessageImpl( idGenerator++,\n                                               Level.ERROR,\n                                               \"kproject.xml\",\n                                               \"kproject.xml found, but unable to read\\n\" + e.getMessage() ) );                \n            }\n        }\n        \n        return null;\n    }","id":43988,"modified_method":"private KieProject getKieProject() {\n        byte[] bytes = srcMfs.getBytes( KieContainer.KPROJECT_RELATIVE_PATH );\n        \n        if ( bytes == null ) {\n            bytes = srcMfs.getBytes( KieContainer.KPROJECT_JAR_PATH );\n        }\n        \n        \n        if ( bytes != null ) {\n            try {\n                return KieProjectImpl.fromXML( new ByteArrayInputStream( bytes ) );\n            } catch ( Exception e) {\n                invalidKieProject = true;  \n                messages.add( new MessageImpl( idGenerator++,\n                                               Level.ERROR,\n                                               \"kproject.xml\",\n                                               \"kproject.xml found, but unable to read\\n\" + e.getMessage() ) );                \n            }\n        }\n        \n        return null;\n    }","commit_id":"769e3e105fd1085d722faa2455c9aaf115870e39","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public KieBase buildKieBase(KieBaseModel kieBase) {\n        KnowledgeBuilderConfiguration kConf = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration( null,\n                                                                                                        classLoader );\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder( kConf );\n        CompositeKnowledgeBuilder ckbuilder = kbuilder.batch();\n        addKBaseFileToBuilder( ckbuilder,\n                               kieBase );\n        if ( kieBase.getIncludes() != null ) {\n            for ( String include : kieBase.getIncludes() ) {\n                addKBaseFileToBuilder( ckbuilder,\n                                       kieProject.getKieBaseModels().get( include ) );\n            }\n        }\n        ckbuilder.build();\n\n        if ( kbuilder.hasErrors() ) {\n            for ( KnowledgeBuilderError error : kbuilder.getErrors() ) {\n                messages.add( new MessageImpl( idGenerator++,\n                                               error ) );\n            }\n            return null;\n        }\n\n        KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase( getKnowledgeBaseConfiguration( kieBase,\n                                                                                                            null,\n                                                                                                            classLoader ) );\n        knowledgeBase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n        return (KieBase) knowledgeBase;\n    }","id":43989,"modified_method":"public KieBase buildKieBase(KieBaseModel kieBase) {\n        KnowledgeBuilderConfiguration kConf = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration( null,\n                                                                                                        classLoader );\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder( kConf );\n        CompositeKnowledgeBuilder ckbuilder = kbuilder.batch();\n        addKBaseFileToBuilder( ckbuilder,\n                               kieBase );\n        if ( kieBase.getIncludes() != null ) {\n            for ( String include : kieBase.getIncludes() ) {\n                addKBaseFileToBuilder( ckbuilder,\n                                       kieProject.getKieBaseModels().get( include ) );\n            }\n        }\n        ckbuilder.build();\n\n        if ( kbuilder.hasErrors() ) {\n            for ( KnowledgeBuilderError error : kbuilder.getErrors() ) {\n                messages.add( new MessageImpl( idGenerator++,\n                                               error ) );\n            }\n            return null;\n        }\n\n        KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase( getKnowledgeBaseConfiguration( kieBase,\n                                                                                                            null,\n                                                                                                            classLoader ) );\n        knowledgeBase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n        return knowledgeBase;\n    }","commit_id":"769e3e105fd1085d722faa2455c9aaf115870e39","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private KieJar createKieJar(KieFactory kf, String... rules) throws IOException {\n        KieFileSystem kfs = kf.newKieFileSystem();\n        for (String rule : rules) {\n            String file = \"org/test/\" + rule + \".drl\";\n            kfs.write(\"src/main/resources/KBase1/\" + file, createDRL(rule));\n        }\n\n        KieProject kproj = kf.newKieProject()\n                .setGroupArtifactVersion(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        KieBaseModel kieBaseModel1 = kproj.newKieBaseModel(\"KBase1\")\n                .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        KieSessionModel ksession1 = kieBaseModel1.newKieSessionModel(\"KSession1\")\n                .setType( \"stateful\" )\n                .setClockType( ClockTypeOption.get(\"realtime\") );\n\n        kfs.write(KieContainer.KPROJECT_JAR_PATH, kproj.toXML());\n\n        KieBuilder kieBuilder = kf.newKieBuilder(kfs);\n        assertTrue(kieBuilder.build().isEmpty());\n        return kieBuilder.getKieJar();\n    }","id":43990,"modified_method":"private KieJar createKieJar(KieServices ks, KieFactory kf, String... rules) throws IOException {\n        KieFileSystem kfs = kf.newKieFileSystem();\n        for (String rule : rules) {\n            String file = \"org/test/\" + rule + \".drl\";\n            kfs.write(\"src/main/resources/KBase1/\" + file, createDRL(rule));\n        }\n\n        KieProject kproj = kf.newKieProject()\n                .setGroupArtifactVersion(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        KieBaseModel kieBaseModel1 = kproj.newKieBaseModel(\"KBase1\")\n                .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        KieSessionModel ksession1 = kieBaseModel1.newKieSessionModel(\"KSession1\")\n                .setType( \"stateful\" )\n                .setClockType( ClockTypeOption.get(\"realtime\") );\n\n        kfs.write(KieContainer.KPROJECT_JAR_PATH, kproj.toXML());\n\n        KieBuilder kieBuilder = ks.newKieBuilder(kfs);\n        assertTrue(kieBuilder.build().getInsertedMessages().isEmpty());\n        return kieBuilder.getKieJar();\n    }","commit_id":"769e3e105fd1085d722faa2455c9aaf115870e39","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test @Ignore\n    public void testKScannerWithKJarContainingClasses() throws Exception {\n        KieServices ks = KieServices.Factory.get();\n        KieFactory kf = KieFactory.Factory.get();\n\n        KieJar kJar1 = createKieJarWithClass(kf, 2, 7);\n        KieContainer kieContainer = ks.getKieContainer(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        MavenRepository repository = new MavenRepository();\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar1).asFile(), kPom);\n\n        KieScanner scanner = kf.newKieScanner(kieContainer);\n\n        KieSession ksession = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession, 14);\n\n        KieJar kJar2 = createKieJarWithClass(kf, 3, 5);\n\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar2).asFile(), kPom);\n\n        scanner.scanNow();\n\n        KieSession ksession2 = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession2, 15);\n    }","id":43991,"modified_method":"@Test @Ignore\n    public void testKScannerWithKJarContainingClasses() throws Exception {\n        KieServices ks = KieServices.Factory.get();\n        KieFactory kf = KieFactory.Factory.get();\n\n        KieJar kJar1 = createKieJarWithClass(ks, kf, 2, 7);\n        KieContainer kieContainer = ks.getKieContainer(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        MavenRepository repository = new MavenRepository();\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar1).asFile(), kPom);\n\n        KieScanner scanner = ks.newKieScanner(kieContainer);\n\n        KieSession ksession = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession, 14);\n\n        KieJar kJar2 = createKieJarWithClass(ks, kf, 3, 5);\n\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar2).asFile(), kPom);\n\n        scanner.scanNow();\n\n        KieSession ksession2 = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession2, 15);\n    }","commit_id":"769e3e105fd1085d722faa2455c9aaf115870e39","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private KieJar createKieJarWithClass(KieFactory kf, int value, int factor) throws IOException {\n        KieFileSystem kieFileSystem = kf.newKieFileSystem();\n\n        KieProject kproj = kf.newKieProject()\n                .setGroupArtifactVersion(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        KieBaseModel kieBaseModel1 = kproj.newKieBaseModel(\"KBase1\")\n                .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        KieSessionModel ksession1 = kieBaseModel1.newKieSessionModel(\"KSession1\")\n                .setType( \"stateful\" )\n                .setClockType( ClockTypeOption.get(\"realtime\") );\n\n        kieFileSystem\n                .write(KieContainer.KPROJECT_JAR_PATH, kproj.toXML())\n                .write(\"src/kbases/\" + kieBaseModel1.getName() + \"/rule1.drl\", createDRLForJavaSource(value))\n                .write(\"org/kie/test/Bean.java\", createJavaSource(factor));\n\n        KieBuilder kieBuilder = kf.newKieBuilder(kieFileSystem);\n        assertTrue(kieBuilder.build().isEmpty());\n        return kieBuilder.getKieJar();\n    }","id":43992,"modified_method":"private KieJar createKieJarWithClass(KieServices ks, KieFactory kf, int value, int factor) throws IOException {\n        KieFileSystem kieFileSystem = kf.newKieFileSystem();\n\n        KieProject kproj = kf.newKieProject()\n                .setGroupArtifactVersion(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        KieBaseModel kieBaseModel1 = kproj.newKieBaseModel(\"KBase1\")\n                .setEqualsBehavior( AssertBehaviorOption.EQUALITY )\n                .setEventProcessingMode( EventProcessingOption.STREAM );\n\n        KieSessionModel ksession1 = kieBaseModel1.newKieSessionModel(\"KSession1\")\n                .setType( \"stateful\" )\n                .setClockType( ClockTypeOption.get(\"realtime\") );\n\n        kieFileSystem\n                .write(KieContainer.KPROJECT_JAR_PATH, kproj.toXML())\n                .write(\"src/kbases/\" + kieBaseModel1.getName() + \"/rule1.drl\", createDRLForJavaSource(value))\n                .write(\"org/kie/test/Bean.java\", createJavaSource(factor));\n\n        KieBuilder kieBuilder = ks.newKieBuilder(kieFileSystem);\n        assertTrue(kieBuilder.build().getInsertedMessages().isEmpty());\n        return kieBuilder.getKieJar();\n    }","commit_id":"769e3e105fd1085d722faa2455c9aaf115870e39","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test @Ignore\n    public void testKScanner() throws Exception {\n        KieServices ks = KieServices.Factory.get();\n        KieFactory kf = KieFactory.Factory.get();\n\n        KieJar kJar1 = createKieJar(kf, \"rule1\", \"rule2\");\n        KieContainer kieContainer = ks.getKieContainer(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        MavenRepository repository = new MavenRepository();\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar1).asFile(), kPom);\n\n        // create a ksesion and check it works as expected\n        KieSession ksession = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession, \"rule1\", \"rule2\");\n\n        // create a new kjar\n        KieJar kJar2 = createKieJar(kf, \"rule2\", \"rule3\");\n\n        // deploy it on maven\n        repository.deployArtifact(\"org.drools\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar2).asFile(), kPom);\n\n        // since I am not calling start() on the scanner it means it won't have automatic scheduled scanning\n        KieScanner scanner = kf.newKieScanner(kieContainer);\n\n        // scan the maven repo to get the new kjar version and deploy it on the kcontainer\n        scanner.scanNow();\n\n        // create a ksesion and check it works as expected\n        KieSession ksession2 = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession2, \"rule2\", \"rule3\");\n    }","id":43993,"modified_method":"@Test @Ignore\n    public void testKScanner() throws Exception {\n        KieServices ks = KieServices.Factory.get();\n        KieFactory kf = KieFactory.Factory.get();\n\n        KieJar kJar1 = createKieJar(ks, kf, \"rule1\", \"rule2\");\n        KieContainer kieContainer = ks.getKieContainer(kf.newGav(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\"));\n\n        MavenRepository repository = new MavenRepository();\n        repository.deployArtifact(\"org.kie\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar1).asFile(), kPom);\n\n        // create a ksesion and check it works as expected\n        KieSession ksession = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession, \"rule1\", \"rule2\");\n\n        // create a new kjar\n        KieJar kJar2 = createKieJar(ks, kf, \"rule2\", \"rule3\");\n\n        // deploy it on maven\n        repository.deployArtifact(\"org.drools\", \"scanner-test\", \"1.0-SNAPSHOT\", ((InternalKieJar)kJar2).asFile(), kPom);\n\n        // since I am not calling start() on the scanner it means it won't have automatic scheduled scanning\n        KieScanner scanner = ks.newKieScanner(kieContainer);\n\n        // scan the maven repo to get the new kjar version and deploy it on the kcontainer\n        scanner.scanNow();\n\n        // create a ksesion and check it works as expected\n        KieSession ksession2 = kieContainer.getKieSession(\"KSession1\");\n        checkKSession(ksession2, \"rule2\", \"rule3\");\n    }","commit_id":"769e3e105fd1085d722faa2455c9aaf115870e39","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void compile(MemoryFileSystem mfs, String... sourceFile) {\n        EclipseJavaCompilerSettings settings = new EclipseJavaCompilerSettings();\n        settings.setSourceVersion( \"1.5\" );\n        settings.setTargetVersion( \"1.5\" );\n        EclipseJavaCompiler compiler = new EclipseJavaCompiler( settings );\n        CompilationResult res = compiler.compile( sourceFile, mfs, mfs );\n\n        if ( res.getErrors().length > 0 ) {\n            fail( res.getErrors()[0].getMessage() );\n        }\n    }","id":43994,"modified_method":"public void compile(MemoryFileSystem mfs, String... sourceFile) {\n        EclipseJavaCompilerSettings settings = new EclipseJavaCompilerSettings();\n        settings.setSourceVersion( \"1.5\" );\n        settings.setTargetVersion( \"1.5\" );\n        EclipseJavaCompiler compiler = new EclipseJavaCompiler( settings, \"\" );\n        CompilationResult res = compiler.compile( sourceFile, mfs, mfs );\n\n        if ( res.getErrors().length > 0 ) {\n            fail( res.getErrors()[0].getMessage() );\n        }\n    }","commit_id":"769e3e105fd1085d722faa2455c9aaf115870e39","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n   * Creates a file or directory at path.\n   *\n   * @param path the path\n   * @param options method options\n   * @return a {@link CreatePathResult} representing the modified inodes and created inodes during\n   *         path creation\n   * @throws FileAlreadyExistsException when there is already a file at path if we want to create a\n   *         directory there\n   * @throws BlockInfoException when blockSizeBytes is invalid\n   * @throws InvalidPathException when path is invalid, for example, (1) when there is nonexistent\n   *         necessary parent directories and recursive is false, (2) when one of the necessary\n   *         parent directories is actually a file\n   * @throws IOException if creating the path fails\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   */\n  public CreatePathResult createPath(AlluxioURI path, CreatePathOptions<?> options)\n      throws FileAlreadyExistsException, BlockInfoException, InvalidPathException, IOException,\n      FileDoesNotExistException {\n    if (path.isRoot()) {\n      LOG.info(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(path));\n      throw new FileAlreadyExistsException(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(path));\n    }\n    if (options instanceof CreateFileOptions) {\n      CreateFileOptions fileOptions = (CreateFileOptions) options;\n      if (fileOptions.getBlockSizeBytes() < 1) {\n        throw new BlockInfoException(\"Invalid block size \" + fileOptions.getBlockSizeBytes());\n      }\n    }\n\n    LOG.debug(\"createPath {}\", FormatUtils.parametersToString(path));\n\n    String[] pathComponents = PathUtils.getPathComponents(path.getPath());\n    String name = path.getName();\n\n    String[] parentPath = new String[pathComponents.length - 1];\n    System.arraycopy(pathComponents, 0, parentPath, 0, parentPath.length);\n\n    TraversalResult traversalResult = traverseToInode(parentPath, options.isPersisted());\n    // pathIndex is the index into pathComponents where we start filling in the path from the inode.\n    int pathIndex = parentPath.length;\n    if (!traversalResult.isFound()) {\n      // Then the path component at errorInd k doesn't exist. If it's not recursive, we throw an\n      // exception here. Otherwise we add the remaining path components to the list of components\n      // to create.\n      if (!options.isRecursive()) {\n        final String msg = new StringBuilder().append(\"File \").append(path)\n            .append(\" creation failed. Component \")\n            .append(traversalResult.getNonexistentPathIndex()).append(\"(\")\n            .append(parentPath[traversalResult.getNonexistentPathIndex()])\n            .append(\") does not exist\").toString();\n        LOG.info(\"FileDoesNotExistException: {}\", msg);\n        throw new FileDoesNotExistException(msg);\n      } else {\n        // We will start filling at the index of the non-existing step found by the traversal.\n        pathIndex = traversalResult.getNonexistentPathIndex();\n      }\n    }\n\n    if (!traversalResult.getInode().isDirectory()) {\n      throw new InvalidPathException(\"Could not traverse to parent directory of path \" + path\n          + \". Component \" + pathComponents[pathIndex - 1] + \" is not a directory.\");\n    }\n    InodeDirectory currentInodeDirectory = (InodeDirectory) traversalResult.getInode();\n    List<Inode<?>> createdInodes = Lists.newArrayList();\n    List<Inode<?>> modifiedInodes = Lists.newArrayList();\n    // Directory persistence will not happen until the end of this method.\n    List<Inode<?>> toPersistDirectories = Lists.newArrayList(traversalResult.getNonPersisted());\n    if (pathIndex < parentPath.length || currentInodeDirectory.getChild(name) == null) {\n      // (1) There are components in parent paths that need to be created. Or\n      // (2) The last component of the path needs to be created.\n      // In these two cases, the last traversed Inode will be modified.\n      modifiedInodes.add(currentInodeDirectory);\n    }\n\n    // Fill in the directories that were missing.\n    for (int k = pathIndex; k < parentPath.length; k++) {\n      Inode<?> dir =\n          new InodeDirectory(mDirectoryIdGenerator.getNewDirectoryId()).setName(pathComponents[k])\n              .setParentId(currentInodeDirectory.getId()).setPersistenceState(\n              options.isPersisted() ? PersistenceState.PERSISTED : PersistenceState.NOT_PERSISTED)\n              .setPermissionStatus(options.getPermissionStatus()\n                  .applyDirectoryUMask(MasterContext.getConf()));\n      dir.setPinned(currentInodeDirectory.isPinned());\n      currentInodeDirectory.addChild(dir);\n      currentInodeDirectory.setLastModificationTimeMs(options.getOperationTimeMs());\n      if (options.isPersisted()) {\n        toPersistDirectories.add(dir);\n      }\n      createdInodes.add(dir);\n      mInodes.add(dir);\n      currentInodeDirectory = (InodeDirectory) dir;\n    }\n\n    // Create the final path component. First we need to make sure that there isn't already a file\n    // here with that name. If there is an existing file that is a directory and we're creating a\n    // directory, update persistence property of the directories if needed, otherwise, throw\n    // FileAlreadyExistsException unless options.allowExists is true.\n    Inode<?> lastInode = currentInodeDirectory.getChild(name);\n    if (lastInode != null) {\n      if (lastInode.isDirectory() && options instanceof CreateDirectoryOptions && !lastInode\n          .isPersisted() && options.isPersisted()) {\n        // The final path component already exists and is not persisted, so it should be added\n        // to the non-persisted Inodes of traversalResult.\n        traversalResult.getNonPersisted().add(lastInode);\n        toPersistDirectories.add(lastInode);\n      } else if (!lastInode.isDirectory() || !(options instanceof CreateDirectoryOptions\n          && ((CreateDirectoryOptions) options).isAllowExists())) {\n        LOG.info(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(path));\n        throw new FileAlreadyExistsException(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(path));\n      }\n    } else {\n      if (options instanceof CreateDirectoryOptions) {\n        CreateDirectoryOptions directoryOptions = (CreateDirectoryOptions) options;\n        lastInode = new InodeDirectory(mDirectoryIdGenerator.getNewDirectoryId()).setName(name)\n            .setParentId(currentInodeDirectory.getId())\n            .setPermissionStatus(directoryOptions.getPermissionStatus()\n                .applyDirectoryUMask(MasterContext.getConf()))\n            .setMountPoint(directoryOptions.isMountPoint());\n        if (directoryOptions.isPersisted()) {\n          toPersistDirectories.add(lastInode);\n        }\n      }\n      if (options instanceof CreateFileOptions) {\n        CreateFileOptions fileOptions = (CreateFileOptions) options;\n        lastInode = new InodeFile(mContainerIdGenerator.getNewContainerId())\n            .setBlockSizeBytes(fileOptions.getBlockSizeBytes()).setTtl(fileOptions.getTtl())\n            .setName(name).setParentId(currentInodeDirectory.getId()).setPersistenceState(\n                fileOptions.isPersisted() ? PersistenceState.PERSISTED :\n                    PersistenceState.NOT_PERSISTED)\n            .setPermissionStatus(fileOptions.getPermissionStatus()\n                .applyFileUMask(MasterContext.getConf()));\n        if (currentInodeDirectory.isPinned()) {\n          // Update set of pinned file ids.\n          mPinnedInodeFileIds.add(lastInode.getId());\n        }\n      }\n      lastInode.setPinned(currentInodeDirectory.isPinned());\n\n      createdInodes.add(lastInode);\n      mInodes.add(lastInode);\n      currentInodeDirectory.addChild(lastInode);\n      currentInodeDirectory.setLastModificationTimeMs(options.getOperationTimeMs());\n    }\n\n    if (toPersistDirectories.size() > 0) {\n      Inode<?> lastToPersistInode = toPersistDirectories.get(toPersistDirectories.size() - 1);\n      String ufsPath = mMountTable.resolve(getPath(lastToPersistInode)).toString();\n      UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n      // Persists only the last directory, recursively creating necessary parent directories. Even\n      // if the directory already exists in the ufs, we mark it as persisted.\n      if (ufs.exists(ufsPath) || ufs.mkdirs(ufsPath, true)) {\n        for (Inode<?> inode : toPersistDirectories) {\n          inode.setPersistenceState(PersistenceState.PERSISTED);\n        }\n      }\n    }\n\n    LOG.debug(\"createFile: File Created: {} parent: \", lastInode, currentInodeDirectory);\n    return new CreatePathResult(modifiedInodes, createdInodes, traversalResult.getNonPersisted());\n  }","id":43995,"modified_method":"/**\n   * Creates a file or directory at path.\n   *\n   * @param path the path\n   * @param options method options\n   * @return a {@link CreatePathResult} representing the modified inodes and created inodes during\n   *         path creation\n   * @throws FileAlreadyExistsException when there is already a file at path if we want to create a\n   *         directory there\n   * @throws BlockInfoException when blockSizeBytes is invalid\n   * @throws InvalidPathException when path is invalid, for example, (1) when there is nonexistent\n   *         necessary parent directories and recursive is false, (2) when one of the necessary\n   *         parent directories is actually a file\n   * @throws IOException if creating the path fails\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   */\n  public CreatePathResult createPath(AlluxioURI path, CreatePathOptions<?> options)\n      throws FileAlreadyExistsException, BlockInfoException, InvalidPathException, IOException,\n      FileDoesNotExistException {\n    if (path.isRoot()) {\n      LOG.info(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(path));\n      throw new FileAlreadyExistsException(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(path));\n    }\n    if (options instanceof CreateFileOptions) {\n      CreateFileOptions fileOptions = (CreateFileOptions) options;\n      if (fileOptions.getBlockSizeBytes() < 1) {\n        throw new BlockInfoException(\"Invalid block size \" + fileOptions.getBlockSizeBytes());\n      }\n    }\n\n    LOG.debug(\"createPath {}\", FormatUtils.parametersToString(path));\n\n    String[] pathComponents = PathUtils.getPathComponents(path.getPath());\n    String name = path.getName();\n\n    String[] parentPath = new String[pathComponents.length - 1];\n    System.arraycopy(pathComponents, 0, parentPath, 0, parentPath.length);\n\n    TraversalResult traversalResult = traverseToInode(parentPath, options.isPersisted());\n    // pathIndex is the index into pathComponents where we start filling in the path from the inode.\n    int pathIndex = parentPath.length;\n    if (!traversalResult.isFound()) {\n      // Then the path component at errorInd k doesn't exist. If it's not recursive, we throw an\n      // exception here. Otherwise we add the remaining path components to the list of components\n      // to create.\n      if (!options.isRecursive()) {\n        final String msg = new StringBuilder().append(\"File \").append(path)\n            .append(\" creation failed. Component \")\n            .append(traversalResult.getNonexistentPathIndex()).append(\"(\")\n            .append(parentPath[traversalResult.getNonexistentPathIndex()])\n            .append(\") does not exist\").toString();\n        LOG.info(\"FileDoesNotExistException: {}\", msg);\n        throw new FileDoesNotExistException(msg);\n      } else {\n        // We will start filling at the index of the non-existing step found by the traversal.\n        pathIndex = traversalResult.getNonexistentPathIndex();\n      }\n    }\n\n    if (!traversalResult.getInode().isDirectory()) {\n      throw new InvalidPathException(\"Could not traverse to parent directory of path \" + path\n          + \". Component \" + pathComponents[pathIndex - 1] + \" is not a directory.\");\n    }\n    InodeDirectory currentInodeDirectory = (InodeDirectory) traversalResult.getInode();\n    List<Inode<?>> createdInodes = Lists.newArrayList();\n    List<Inode<?>> modifiedInodes = Lists.newArrayList();\n    // Directory persistence will not happen until the end of this method.\n    List<Inode<?>> toPersistDirectories = Lists.newArrayList(traversalResult.getNonPersisted());\n    if (pathIndex < parentPath.length || currentInodeDirectory.getChild(name) == null) {\n      // (1) There are components in parent paths that need to be created. Or\n      // (2) The last component of the path needs to be created.\n      // In these two cases, the last traversed Inode will be modified.\n      modifiedInodes.add(currentInodeDirectory);\n    }\n\n    PermissionStatus ps = new PermissionStatus(options.getPermissionStatus())\n        .applyDirectoryUMask(MasterContext.getConf());\n    // Fill in the directories that were missing.\n    for (int k = pathIndex; k < parentPath.length; k++) {\n      Inode<?> dir =\n          new InodeDirectory(mDirectoryIdGenerator.getNewDirectoryId()).setName(pathComponents[k])\n              .setParentId(currentInodeDirectory.getId()).setPersistenceState(\n              options.isPersisted() ? PersistenceState.PERSISTED : PersistenceState.NOT_PERSISTED)\n              .setPermissionStatus(ps);\n      dir.setPinned(currentInodeDirectory.isPinned());\n      currentInodeDirectory.addChild(dir);\n      currentInodeDirectory.setLastModificationTimeMs(options.getOperationTimeMs());\n      if (options.isPersisted()) {\n        toPersistDirectories.add(dir);\n      }\n      createdInodes.add(dir);\n      mInodes.add(dir);\n      currentInodeDirectory = (InodeDirectory) dir;\n    }\n\n    // Create the final path component. First we need to make sure that there isn't already a file\n    // here with that name. If there is an existing file that is a directory and we're creating a\n    // directory, update persistence property of the directories if needed, otherwise, throw\n    // FileAlreadyExistsException unless options.allowExists is true.\n    Inode<?> lastInode = currentInodeDirectory.getChild(name);\n    if (lastInode != null) {\n      if (lastInode.isDirectory() && options instanceof CreateDirectoryOptions && !lastInode\n          .isPersisted() && options.isPersisted()) {\n        // The final path component already exists and is not persisted, so it should be added\n        // to the non-persisted Inodes of traversalResult.\n        traversalResult.getNonPersisted().add(lastInode);\n        toPersistDirectories.add(lastInode);\n      } else if (!lastInode.isDirectory() || !(options instanceof CreateDirectoryOptions\n          && ((CreateDirectoryOptions) options).isAllowExists())) {\n        LOG.info(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(path));\n        throw new FileAlreadyExistsException(ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(path));\n      }\n    } else {\n      if (options instanceof CreateDirectoryOptions) {\n        CreateDirectoryOptions directoryOptions = (CreateDirectoryOptions) options;\n        ps = new PermissionStatus(directoryOptions.getPermissionStatus())\n            .applyDirectoryUMask(MasterContext.getConf());\n        lastInode = new InodeDirectory(mDirectoryIdGenerator.getNewDirectoryId()).setName(name)\n            .setParentId(currentInodeDirectory.getId())\n            .setPermissionStatus(ps)\n            .setMountPoint(directoryOptions.isMountPoint());\n        if (directoryOptions.isPersisted()) {\n          toPersistDirectories.add(lastInode);\n        }\n      }\n      if (options instanceof CreateFileOptions) {\n        CreateFileOptions fileOptions = (CreateFileOptions) options;\n        ps = new PermissionStatus(fileOptions.getPermissionStatus())\n            .applyFileUMask(MasterContext.getConf());\n        lastInode = new InodeFile(mContainerIdGenerator.getNewContainerId())\n            .setBlockSizeBytes(fileOptions.getBlockSizeBytes()).setTtl(fileOptions.getTtl())\n            .setName(name).setParentId(currentInodeDirectory.getId()).setPersistenceState(\n                fileOptions.isPersisted() ? PersistenceState.PERSISTED :\n                    PersistenceState.NOT_PERSISTED)\n            .setPermissionStatus(ps);\n        if (currentInodeDirectory.isPinned()) {\n          // Update set of pinned file ids.\n          mPinnedInodeFileIds.add(lastInode.getId());\n        }\n      }\n      lastInode.setPinned(currentInodeDirectory.isPinned());\n\n      createdInodes.add(lastInode);\n      mInodes.add(lastInode);\n      currentInodeDirectory.addChild(lastInode);\n      currentInodeDirectory.setLastModificationTimeMs(options.getOperationTimeMs());\n    }\n\n    if (toPersistDirectories.size() > 0) {\n      Inode<?> lastToPersistInode = toPersistDirectories.get(toPersistDirectories.size() - 1);\n      String ufsPath = mMountTable.resolve(getPath(lastToPersistInode)).toString();\n      UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n      // Persists only the last directory, recursively creating necessary parent directories. Even\n      // if the directory already exists in the ufs, we mark it as persisted.\n      if (ufs.exists(ufsPath) || ufs.mkdirs(ufsPath, true)) {\n        for (Inode<?> inode : toPersistDirectories) {\n          inode.setPersistenceState(PersistenceState.PERSISTED);\n        }\n      }\n    }\n\n    LOG.debug(\"createFile: File Created: {} parent: \", lastInode, currentInodeDirectory);\n    return new CreatePathResult(modifiedInodes, createdInodes, traversalResult.getNonPersisted());\n  }","commit_id":"473ae9ebb90abc63ba7b15399da7e09fd163737b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Applies default umask to new created directories.\n   *\n   * @param conf the runtime configuration of Alluxio\n   * @return a new {@link PermissionStatus}\n   */\n  public PermissionStatus applyDirectoryUMask(Configuration conf) {\n    FileSystemPermission newFileSystemPermission =\n        mPermission.applyUMask(FileSystemPermission.getUMask(conf));\n    return new PermissionStatus(mUserName, mGroupName, newFileSystemPermission);\n  }","id":43996,"modified_method":"/**\n   * Applies default umask to newly created directories.\n   *\n   * @param conf the runtime configuration of Alluxio\n   * @return a new {@link PermissionStatus}\n   */\n  public PermissionStatus applyDirectoryUMask(Configuration conf) {\n    mPermission =\n        mPermission.applyUMask(FileSystemPermission.getUMask(conf));\n    return this;\n  }","commit_id":"473ae9ebb90abc63ba7b15399da7e09fd163737b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Applies umask.\n   *\n   * @param umask the umask to apply\n   * @return a new {@link PermissionStatus}\n   */\n  public PermissionStatus applyUMask(FileSystemPermission umask) {\n    FileSystemPermission newFileSystemPermission = mPermission.applyUMask(umask);\n    return new PermissionStatus(mUserName, mGroupName, newFileSystemPermission);\n  }","id":43997,"modified_method":"/**\n   * Applies umask.\n   *\n   * @param umask the umask to apply\n   * @return a new {@link PermissionStatus}\n   */\n  public PermissionStatus applyUMask(FileSystemPermission umask) {\n    mPermission = mPermission.applyUMask(umask);\n    return this;\n  }","commit_id":"473ae9ebb90abc63ba7b15399da7e09fd163737b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Applies default umask to new created files.\n   *\n   * @param conf the runtime configuration of Alluxio\n   * @return a new {@link PermissionStatus}\n   */\n  public PermissionStatus applyFileUMask(Configuration conf) {\n    FileSystemPermission newFileSystemPermission =\n        mPermission.applyUMask(FileSystemPermission.getUMask(conf)).applyUMask(FILE_UMASK);\n    return new PermissionStatus(mUserName, mGroupName, newFileSystemPermission);\n  }","id":43998,"modified_method":"/**\n   * Applies default umask to newly created files.\n   *\n   * @param conf the runtime configuration of Alluxio\n   * @return a new {@link PermissionStatus}\n   */\n  public PermissionStatus applyFileUMask(Configuration conf) {\n    mPermission =\n        mPermission.applyUMask(FileSystemPermission.getUMask(conf)).applyUMask(FILE_UMASK);\n    return this;\n  }","commit_id":"473ae9ebb90abc63ba7b15399da7e09fd163737b","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        if (appendLibraryJS != null && appendLibraryJS.booleanValue()) {\n            getLog().info(\"Appending Kotlin Library JS to the generated file \" + outputFile);\n\n            appendFile(KOTLIN_JS_LIB_ECMA3);\n            appendFile(KOTLIN_JS_LIB);\n        }\n        super.execute();\n        if (copyLibraryJS != null && copyLibraryJS.booleanValue()) {\n            getLog().info(\"Copying kotlin JS library to \" + outputKotlinJSDir);\n\n            copyJsLibraryFile(KOTLIN_JS_LIB);\n            copyJsLibraryFile(KOTLIN_JS_LIB_ECMA3);\n            copyJsLibraryFile(KOTLIN_JS_LIB_ECMA5);\n        }\n    }","id":43999,"modified_method":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        super.execute();\n        if (appendLibraryJS != null && appendLibraryJS.booleanValue()) {\n            try {\n                Charset charset = Charset.defaultCharset();\n                File file = new File(outputFile);\n                String text = Files.toString(file, charset);\n                StringBuilder builder = new StringBuilder();\n                appendFile(KOTLIN_JS_LIB_ECMA3, builder);\n                appendFile(KOTLIN_JS_LIB, builder);\n                builder.append(\"\\n\");\n                builder.append(text);\n                Files.write(builder.toString(), file, charset);\n            } catch (IOException e) {\n                throw new MojoExecutionException(e.getMessage(), e);\n            }\n        }\n        if (copyLibraryJS != null && copyLibraryJS.booleanValue()) {\n            getLog().info(\"Copying kotlin JS library to \" + outputKotlinJSDir);\n\n            copyJsLibraryFile(KOTLIN_JS_LIB);\n            copyJsLibraryFile(KOTLIN_JS_LIB_ECMA3);\n            copyJsLibraryFile(KOTLIN_JS_LIB_ECMA5);\n        }\n    }","commit_id":"c09106fe6831446ca42ac68dc9d7923b06f7a4d4","url":"https://github.com/JetBrains/kotlin"}]