[{"original_method":"@Override\n\t\tpublic void visitINVOKESPECIAL(INVOKESPECIAL obj) {\n\t\t\thandleInstanceMethod(obj);\n\t\t}","id":76000,"modified_method":"@Override\n\t\tpublic void visitINVOKESPECIAL(INVOKESPECIAL obj) {\n\t\t\tif (returnsString(obj))\n\t\t\t\thandleInstanceMethod(obj);\n\t\t\telse super.visitINVOKESPECIAL(obj);\n\t\t}","commit_id":"908d9f33f6c4347292af37b8f66b03a912e0177c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private boolean inspectLocation(\n\t\t\tboolean sawCallToEquals,\n\t\t\tJavaClass jclass,\n\t\t\tConstantPoolGen cpg,\n\t\t\tMethod method,\n\t\t\tMethodGen methodGen,\n\t\t\tLinkedList<WarningWithProperties> refComparisonList,\n\t\t\tLinkedList<WarningWithProperties> stringComparisonList,\n\t\t\tRefComparisonTypeFrameModelingVisitor visitor,\n\t\t\tTypeDataflow typeDataflow, Location location) throws DataflowAnalysisException {\n\t\tInstruction ins = location.getHandle().getInstruction();\n\t\tshort opcode = ins.getOpcode();\n\t\tif (opcode == Constants.IF_ACMPEQ || opcode == Constants.IF_ACMPNE) {\n\t\t\tcheckRefComparison(\n\t\t\t\t\tlocation,\n\t\t\t\t\tjclass,\n\t\t\t\t\tmethodGen,\n\t\t\t\t\tvisitor,\n\t\t\t\t\ttypeDataflow,\n\t\t\t\t\tstringComparisonList,\n\t\t\t\t\trefComparisonList);\n\t\t} else if (invokeInstanceSet.get(opcode)) {\n\t\t\tInvokeInstruction inv = (InvokeInstruction) ins;\n\t\t\tString methodName = inv.getMethodName(cpg);\n\t\t\tString methodSig = inv.getSignature(cpg);\n\t\t\tif (isEqualsMethod(methodName, methodSig)) {\n\t\t\t\tsawCallToEquals = true;\n\t\t\t\tcheckEqualsComparison(location, jclass, method, methodGen, cpg, typeDataflow);\n\t\t\t}\n\t\t}\n\t\treturn sawCallToEquals;\n\t}","id":76001,"modified_method":"private boolean inspectLocation(\n\t\t\tboolean sawCallToEquals,\n\t\t\tJavaClass jclass,\n\t\t\tConstantPoolGen cpg,\n\t\t\tMethod method,\n\t\t\tMethodGen methodGen,\n\t\t\tLinkedList<WarningWithProperties> refComparisonList,\n\t\t\tLinkedList<WarningWithProperties> stringComparisonList,\n\t\t\tRefComparisonTypeFrameModelingVisitor visitor,\n\t\t\tTypeDataflow typeDataflow, Location location) throws DataflowAnalysisException {\n\t\tInstruction ins = location.getHandle().getInstruction();\n\t\tshort opcode = ins.getOpcode();\n\t\tif (opcode == Constants.IF_ACMPEQ || opcode == Constants.IF_ACMPNE) {\n\t\t\tcheckRefComparison(\n\t\t\t\t\tlocation,\n\t\t\t\t\tjclass,\n\t\t\t\t\tmethodGen,\n\t\t\t\t\tvisitor,\n\t\t\t\t\ttypeDataflow,\n\t\t\t\t\tstringComparisonList,\n\t\t\t\t\trefComparisonList);\n\t\t} else if (invokeInstanceSet.get(opcode)) {\n\t\t\tInvokeInstruction inv = (InvokeInstruction) ins;\n\t\t\tString methodName = inv.getMethodName(cpg);\n\t\t\tString methodSig = inv.getSignature(cpg);\n\t\t\tif (isEqualsMethod(methodName, methodSig)) {\n\t\t\t\tsawCallToEquals = true;\n\t\t\t\ttry {\n\t                ClassContext.dumpTypeDataflow(method, classContext.getCFG(method), typeDataflow);\n                } catch (CFGBuilderException e) {\n\t                // TODO Auto-generated catch block\n\t                e.printStackTrace();\n                }\n\t\t\t\tcheckEqualsComparison(location, jclass, method, methodGen, cpg, typeDataflow);\n\t\t\t}\n\t\t}\n\t\treturn sawCallToEquals;\n\t}","commit_id":"908d9f33f6c4347292af37b8f66b03a912e0177c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\tpublic void visitINVOKESTATIC(INVOKESTATIC obj) {\n\t\t\tconsumeStack(obj);\n\t\t\tif (returnsString(obj)) {\n\t\t\t\tString className = obj.getClassName(getCPG());\n\t\t\t\tif (className.equals(\"java.lang.String\")) {\n\t\t\t\t\tpushValue(dynamicStringTypeInstance);\n\t\t\t\t} else {\n\t\t\t\t\tpushReturnType(obj);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpushReturnType(obj);\n\t\t\t}\n\t\t}","id":76002,"modified_method":"@Override\n\t\tpublic void visitINVOKESTATIC(INVOKESTATIC obj) {\n\t\t\tif (returnsString(obj)) {\n\t\t\t\tconsumeStack(obj);\n\n\t\t\t\tString className = obj.getClassName(getCPG());\n\t\t\t\tif (className.equals(\"java.lang.String\")) {\n\t\t\t\t\tpushValue(dynamicStringTypeInstance);\n\t\t\t\t} else {\n\t\t\t\t\tpushReturnType(obj);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsuper.visitINVOKESTATIC(obj);\n\t\t\t}\n\t\t}","commit_id":"908d9f33f6c4347292af37b8f66b03a912e0177c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void handleInstanceMethod(InvokeInstruction obj) {\n\t\t\tconsumeStack(obj);\n\t\t\tif (returnsString(obj)) {\n\t\t\t\tString className = obj.getClassName(getCPG());\n\t\t\t\tString methodName = obj.getName(getCPG());\n\t\t\t\t// System.out.println(className + \".\" + methodName);\n\n\t\t\t\tif (methodName.equals(\"intern\") && className.equals(\"java.lang.String\")) {\n\t\t\t\t\tsawStringIntern = true;\n\t\t\t\t\tpushValue(staticStringTypeInstance);\n\t\t\t\t} else if (methodName.equals(\"toString\")\n\t\t\t\t\t\t|| className.equals(\"java.lang.String\")) {\n\t\t\t\t\tpushValue(dynamicStringTypeInstance);\n\t\t\t\t\t// System.out.println(\"  dynamic\");\n\t\t\t\t} else {\n\t                pushReturnType(obj);\n                }\n\t\t\t} else {\n\t            pushReturnType(obj);\n            }\n\t\t}","id":76003,"modified_method":"private void handleInstanceMethod(InvokeInstruction obj) {\n\n\t\t\tassert returnsString(obj);\n\t\t\tconsumeStack(obj);\n\t\t\tString className = obj.getClassName(getCPG());\n\t\t\tString methodName = obj.getName(getCPG());\n\t\t\t// System.out.println(className + \".\" + methodName);\n\n\t\t\tif (methodName.equals(\"intern\") && className.equals(\"java.lang.String\")) {\n\t\t\t\tsawStringIntern = true;\n\t\t\t\tpushValue(staticStringTypeInstance);\n\t\t\t} else if (methodName.equals(\"toString\")\n\t\t\t\t\t|| className.equals(\"java.lang.String\")) {\n\t\t\t\tpushValue(dynamicStringTypeInstance);\n\t\t\t\t// System.out.println(\"  dynamic\");\n\t\t\t} else {\n\t\t\t\tpushReturnType(obj);\n\t\t\t}\n\n\t\t}","commit_id":"908d9f33f6c4347292af37b8f66b03a912e0177c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n      PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    List<CoreLabel> rawWords2 =\n      tokenizerFactory.getTokenizer(new StringReader(sent2)).tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","id":76004,"modified_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n        PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    Tokenizer<CoreLabel> tok =\n        tokenizerFactory.getTokenizer(new StringReader(sent2));\n    List<CoreLabel> rawWords2 = tok.tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    // You can also use a TreePrint object to print trees and dependencies\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","commit_id":"6a17c35b067d4cf4e08dd2b34bd766f328695342","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n      PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    List<CoreLabel> rawWords2 =\n      tokenizerFactory.getTokenizer(new StringReader(sent2)).tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","id":76005,"modified_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n        PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    Tokenizer<CoreLabel> tok =\n        tokenizerFactory.getTokenizer(new StringReader(sent2));\n    List<CoreLabel> rawWords2 = tok.tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    // You can also use a TreePrint object to print trees and dependencies\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","commit_id":"7ced3a7885d75ec08f92145c42320ab8c1014c44","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n      PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    List<CoreLabel> rawWords2 =\n      tokenizerFactory.getTokenizer(new StringReader(sent2)).tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","id":76006,"modified_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n        PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    Tokenizer<CoreLabel> tok =\n        tokenizerFactory.getTokenizer(new StringReader(sent2));\n    List<CoreLabel> rawWords2 = tok.tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    // You can also use a TreePrint object to print trees and dependencies\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","commit_id":"fdf396a62d9a45cec41f09f390faf5870477c50b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n      PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    List<CoreLabel> rawWords2 =\n      tokenizerFactory.getTokenizer(new StringReader(sent2)).tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","id":76007,"modified_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n        PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    Tokenizer<CoreLabel> tok =\n        tokenizerFactory.getTokenizer(new StringReader(sent2));\n    List<CoreLabel> rawWords2 = tok.tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    // You can also use a TreePrint object to print trees and dependencies\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","commit_id":"63dabc9e0b83ad2200f765e67e4c3e1e8ea4b63b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n      PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    List<CoreLabel> rawWords2 =\n      tokenizerFactory.getTokenizer(new StringReader(sent2)).tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","id":76008,"modified_method":"/**\n   * demoAPI demonstrates other ways of calling the parser with\n   * already tokenized text, or in some cases, raw text that needs to\n   * be tokenized as a single sentence.  Output is handled with a\n   * TreePrint object.  Note that the options used when creating the\n   * TreePrint can determine what results to print out.  Once again,\n   * one can capture the output by passing a PrintWriter to\n   * TreePrint.printTree.\n   */\n  public static void demoAPI(LexicalizedParser lp) {\n    // This option shows parsing a list of correctly tokenized words\n    String[] sent = { \"This\", \"is\", \"an\", \"easy\", \"sentence\", \".\" };\n    List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);\n    Tree parse = lp.apply(rawWords);\n    parse.pennPrint();\n    System.out.println();\n\n    // This option shows loading and using an explicit tokenizer\n    String sent2 = \"This is another sentence.\";\n    TokenizerFactory<CoreLabel> tokenizerFactory =\n        PTBTokenizer.factory(new CoreLabelTokenFactory(), \"\");\n    Tokenizer<CoreLabel> tok =\n        tokenizerFactory.getTokenizer(new StringReader(sent2));\n    List<CoreLabel> rawWords2 = tok.tokenize();\n    parse = lp.apply(rawWords2);\n\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\n    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();\n    GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);\n    List<TypedDependency> tdl = gs.typedDependenciesCCprocessed();\n    System.out.println(tdl);\n    System.out.println();\n\n    // You can also use a TreePrint object to print trees and dependencies\n    TreePrint tp = new TreePrint(\"penn,typedDependenciesCollapsed\");\n    tp.printTree(parse);\n  }","commit_id":"00ba685d0aa118988f76840a6aa168b9752d7e6f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n    public void startUp(IngestJobContext context) throws IngestModuleException {    \n        jobId = context.getJobId();\n        refCounter.incrementAndGet(jobId);\n        try {\n            fileTypeDetector = new FileTypeDetector();\n        } catch (FileTypeDetector.FileTypeDetectorInitException ex) {\n            logger.log(Level.SEVERE, \"Error initializing FileTypeDetector\", ex); // NON-NLS\n            throw new IngestModuleException(\"Error initializing FileTypeDetector\"); // NON-NLS\n        }\n    }","id":76009,"modified_method":"@Override\n    public void startUp(IngestJobContext context) throws IngestModuleException {    \n        jobId = context.getJobId();\n        refCounter.incrementAndGet(jobId);\n        try {\n            fileTypeDetector = new FileTypeDetector();\n        } catch (FileTypeDetector.FileTypeDetectorInitException ex) {\n            logger.log(Level.SEVERE, NbBundle.getMessage(this.getClass(), \"ExifParserFileIngestModule.startUp.fileTypeDetectorInitializationException.msg\"), ex);\n            throw new IngestModuleException(NbBundle.getMessage(this.getClass(), \"ExifParserFileIngestModule.startUp.fileTypeDetectorInitializationException.msg\"));\n        }\n    }","commit_id":"34c5a1d6c905c2377b12e713d43735567be6c2c4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Detect the MIME type of a file, posting it to the blackboard if detection\n     * succeeds.\n     *\n     * @param file The file to test.\n     * @param moduleName The name of the module posting to the blackboard.\n     * @return The MIME type name id detection was successful, null otherwise.\n     * @throws TskCoreException if there is an error posting to the blackboard.\n     */\n    public String detectAndPostToBlackboard(AbstractFile file) throws TskCoreException {\n        String mimeType = detect(file);\n        if (null != mimeType) {\n            /**\n             * Add the file type attribute to the general info artifact. Note\n             * that no property change is fired for this blackboard posting\n             * because general info artifacts are different from other\n             * artifacts, e.g., they are not displayed in the results tree.\n             */\n            BlackboardArtifact getInfoArt = file.getGenInfoArtifact();\n            BlackboardAttribute batt = new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_FILE_TYPE_SIG.getTypeID(), FileTypeIdModuleFactory.getModuleName(), mimeType);\n            getInfoArt.addAttribute(batt);\n        }\n        return mimeType;\n    }","id":76010,"modified_method":"/**\n     * Detect the MIME type of a file, posting it to the blackboard if detection\n     * succeeds.\n     *\n     * @param file The file to test.\n     * @return The MIME type name id detection was successful, null otherwise.\n     * @throws TskCoreException if there is an error posting to the blackboard.\n     */\n    public String detectAndPostToBlackboard(AbstractFile file) throws TskCoreException {\n\n        String mimeType;\n        // Consistently mark unallocated and unused space as file type application/octet-stream\n        if ((file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS)\n                || (file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS)\n                || (file.isFile() == false)) {\n            mimeType = MimeTypes.OCTET_STREAM;\n        } else {\n            mimeType = detect(file);\n        }\n\n        if (null != mimeType) {\n            /**\n             * Add the file type attribute to the general info artifact. Note\n             * that no property change is fired for this blackboard posting\n             * because general info artifacts are different from other\n             * artifacts, e.g., they are not displayed in the results tree.\n             */\n            BlackboardArtifact getInfoArt = file.getGenInfoArtifact();\n            BlackboardAttribute batt = new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_FILE_TYPE_SIG.getTypeID(), FileTypeIdModuleFactory.getModuleName(), mimeType);\n            getInfoArt.addAttribute(batt);\n        }\n        return mimeType;\n    }","commit_id":"34c5a1d6c905c2377b12e713d43735567be6c2c4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public ProcessResult process(AbstractFile file) {\n\n        /**\n         * Skip unallocated space and unused blocks files.\n         */\n        if ((file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS)\n                || (file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS)\n                || (file.isFile() == false)) {\n            return ProcessResult.OK;\n        }\n\n        /**\n         * Skip known files if configured to do so.\n         */\n        if (settings.skipKnownFiles() && (file.getKnown() == FileKnown.KNOWN)) {\n            return ProcessResult.OK;\n        }\n\n        /**\n         * Attempt to detect the file type. Do it within an exception firewall,\n         * so that any issues with reading file content or complaints from tika\n         * do not take the module down.\n         */\n        try {\n            long startTime = System.currentTimeMillis();\n            fileTypeDetector.detectAndPostToBlackboard(file);\n            addToTotals(jobId, (System.currentTimeMillis() - startTime));\n            return ProcessResult.OK;\n        } catch (Exception e) {\n            logger.log(Level.WARNING, String.format(\"Error while attempting to determine file type of file %d\", file.getId()), e); //NON-NLS\n            return ProcessResult.ERROR;\n        }\n    }","id":76011,"modified_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public ProcessResult process(AbstractFile file) {\n\n        /**\n         * Skip known files if configured to do so.\n         */\n        if (settings.skipKnownFiles() && (file.getKnown() == FileKnown.KNOWN)) {\n            return ProcessResult.OK;\n        }\n\n        /**\n         * Attempt to detect the file type. Do it within an exception firewall,\n         * so that any issues with reading file content or complaints from tika\n         * do not take the module down.\n         */\n        try {\n            long startTime = System.currentTimeMillis();\n            fileTypeDetector.detectAndPostToBlackboard(file);\n            addToTotals(jobId, (System.currentTimeMillis() - startTime));\n            return ProcessResult.OK;\n        } catch (Exception e) {\n            logger.log(Level.WARNING, String.format(\"Error while attempting to determine file type of file %d\", file.getId()), e); //NON-NLS\n            return ProcessResult.ERROR;\n        }\n    }","commit_id":"34c5a1d6c905c2377b12e713d43735567be6c2c4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Initializes the module for new ingest run Sets up threads, timers,\n     * retrieves settings, keyword lists to run on\n     *\n     */\n    @Override\n    public void startUp(IngestJobContext context) throws IngestModuleException {\n        logger.log(Level.INFO, \"Initializing instance {0}\", instanceNum); //NON-NLS\n        initialized = false;       \n        jobId = context.getJobId();  \n        dataSourceId = context.getDataSource().getId();\n        \n        try {\n            fileTypeDetector = new FileTypeDetector();\n        } catch (FileTypeDetector.FileTypeDetectorInitException ex) {\n            logger.log(Level.SEVERE, \"Error initializing FileTypeDetector\", ex); // NON-NLS\n            throw new IngestModuleException(\"Error initializing FileTypeDetector\"); // NON-NLS\n        }\n        ingester = Server.getIngester();\n        this.context = context;\n\n        // increment the module reference count\n        // if first instance of this module for this job then check the server and existence of keywords\n        if (refCounter.incrementAndGet(jobId) == 1) {\n            final Server server = KeywordSearch.getServer();\n            try {\n                if (!server.isRunning()) {\n                    String msg = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.badInitMsg\");\n                    logger.log(Level.SEVERE, msg);\n                    String details = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.tryStopSolrMsg\", msg);\n                    services.postMessage(IngestMessage.createErrorMessage(KeywordSearchModuleFactory.getModuleName(), msg, details));\n                    throw new IngestModuleException(msg);\n                }\n            } catch (KeywordSearchModuleException ex) {\n                logger.log(Level.WARNING, \"Error checking if Solr server is running while initializing ingest\", ex); //NON-NLS\n                //this means Solr is not properly initialized\n                String msg = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.badInitMsg\");\n                String details = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.tryStopSolrMsg\", msg);\n                services.postMessage(IngestMessage.createErrorMessage(KeywordSearchModuleFactory.getModuleName(), msg, details));\n                throw new IngestModuleException(msg);\n            }\n            try {\n                // make an actual query to verify that server is responding\n                // we had cases where getStatus was OK, but the connection resulted in a 404\n                server.queryNumIndexedDocuments();\n            } catch (KeywordSearchModuleException | NoOpenCoreException ex) {\n                throw new IngestModuleException(\n                        NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.exception.errConnToSolr.msg\",\n                        ex.getMessage()));\n            }\n\n            // check if this job has any searchable keywords    \n            List<KeywordList> keywordLists = XmlKeywordSearchList.getCurrent().getListsL();\n            boolean hasKeywordsForSearch = false;\n            for (KeywordList keywordList : keywordLists) {\n                if (settings.keywordListIsEnabled(keywordList.getName()) && !keywordList.getKeywords().isEmpty()) {\n                    hasKeywordsForSearch = true;\n                    break;\n                }\n            }\n            if (!hasKeywordsForSearch) {\n                services.postMessage(IngestMessage.createWarningMessage(KeywordSearchModuleFactory.getModuleName(), NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.noKwInLstMsg\"),\n                        NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.onlyIdxKwSkipMsg\")));\n            }            \n        }\n        \n        //initialize extractors\n        stringExtractor = new StringsTextExtractor(this);\n        stringExtractor.setScripts(KeywordSearchSettings.getStringExtractScripts());\n        stringExtractor.setOptions(KeywordSearchSettings.getStringExtractOptions());\n\n        //log the scripts used for debugging\n        final StringBuilder sbScripts = new StringBuilder();\n        for (SCRIPT s : KeywordSearchSettings.getStringExtractScripts()) {\n            sbScripts.append(s.name()).append(\" \");\n        }\n        logger.log(Level.INFO, \"Using string extract scripts: {0}\", sbScripts.toString()); //NON-NLS\n\n        textExtractors = new ArrayList<>();\n        //order matters, more specific extractors first\n        textExtractors.add(new HtmlTextExtractor(this));\n        textExtractors.add(new TikaTextExtractor(this));\n        \n        indexer = new Indexer();\n        initialized = true;\n    }","id":76012,"modified_method":"/**\n     * Initializes the module for new ingest run Sets up threads, timers,\n     * retrieves settings, keyword lists to run on\n     *\n     */\n    @Override\n    public void startUp(IngestJobContext context) throws IngestModuleException {\n        logger.log(Level.INFO, \"Initializing instance {0}\", instanceNum); //NON-NLS\n        initialized = false;       \n        jobId = context.getJobId();  \n        dataSourceId = context.getDataSource().getId();\n        \n        try {\n            fileTypeDetector = new FileTypeDetector();\n        } catch (FileTypeDetector.FileTypeDetectorInitException ex) {\n            logger.log(Level.SEVERE, NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.startUp.fileTypeDetectorInitializationException.msg\"), ex);\n            throw new IngestModuleException(NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.startUp.fileTypeDetectorInitializationException.msg\"));\n        }\n        ingester = Server.getIngester();\n        this.context = context;\n\n        // increment the module reference count\n        // if first instance of this module for this job then check the server and existence of keywords\n        if (refCounter.incrementAndGet(jobId) == 1) {\n            final Server server = KeywordSearch.getServer();\n            try {\n                if (!server.isRunning()) {\n                    String msg = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.badInitMsg\");\n                    logger.log(Level.SEVERE, msg);\n                    String details = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.tryStopSolrMsg\", msg);\n                    services.postMessage(IngestMessage.createErrorMessage(KeywordSearchModuleFactory.getModuleName(), msg, details));\n                    throw new IngestModuleException(msg);\n                }\n            } catch (KeywordSearchModuleException ex) {\n                logger.log(Level.WARNING, \"Error checking if Solr server is running while initializing ingest\", ex); //NON-NLS\n                //this means Solr is not properly initialized\n                String msg = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.badInitMsg\");\n                String details = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.tryStopSolrMsg\", msg);\n                services.postMessage(IngestMessage.createErrorMessage(KeywordSearchModuleFactory.getModuleName(), msg, details));\n                throw new IngestModuleException(msg);\n            }\n            try {\n                // make an actual query to verify that server is responding\n                // we had cases where getStatus was OK, but the connection resulted in a 404\n                server.queryNumIndexedDocuments();\n            } catch (KeywordSearchModuleException | NoOpenCoreException ex) {\n                throw new IngestModuleException(\n                        NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.exception.errConnToSolr.msg\",\n                        ex.getMessage()));\n            }\n\n            // check if this job has any searchable keywords    \n            List<KeywordList> keywordLists = XmlKeywordSearchList.getCurrent().getListsL();\n            boolean hasKeywordsForSearch = false;\n            for (KeywordList keywordList : keywordLists) {\n                if (settings.keywordListIsEnabled(keywordList.getName()) && !keywordList.getKeywords().isEmpty()) {\n                    hasKeywordsForSearch = true;\n                    break;\n                }\n            }\n            if (!hasKeywordsForSearch) {\n                services.postMessage(IngestMessage.createWarningMessage(KeywordSearchModuleFactory.getModuleName(), NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.noKwInLstMsg\"),\n                        NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.init.onlyIdxKwSkipMsg\")));\n            }            \n        }\n        \n        //initialize extractors\n        stringExtractor = new StringsTextExtractor(this);\n        stringExtractor.setScripts(KeywordSearchSettings.getStringExtractScripts());\n        stringExtractor.setOptions(KeywordSearchSettings.getStringExtractOptions());\n\n        //log the scripts used for debugging\n        final StringBuilder sbScripts = new StringBuilder();\n        for (SCRIPT s : KeywordSearchSettings.getStringExtractScripts()) {\n            sbScripts.append(s.name()).append(\" \");\n        }\n        logger.log(Level.INFO, \"Using string extract scripts: {0}\", sbScripts.toString()); //NON-NLS\n\n        textExtractors = new ArrayList<>();\n        //order matters, more specific extractors first\n        textExtractors.add(new HtmlTextExtractor(this));\n        textExtractors.add(new TikaTextExtractor(this));\n        \n        indexer = new Indexer();\n        initialized = true;\n    }","commit_id":"34c5a1d6c905c2377b12e713d43735567be6c2c4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void startUp(IngestJobContext context) throws IngestModuleException {\n        this.context = context;\n        jobId = context.getJobId();\n\n        try {\n            fileTypeDetector = new FileTypeDetector();\n        } catch (FileTypeDetector.FileTypeDetectorInitException ex) {\n            logger.log(Level.SEVERE, \"Error initializing FileTypeDetector\", ex); // NON-NLS\n            throw new IngestModuleException(\"Error initializing FileTypeDetector\"); // NON-NLS\n        }\n\n        final Case currentCase = Case.getCurrentCase();\n\n        moduleDirRelative = Case.getModulesOutputDirRelPath() + File.separator + ArchiveFileExtractorModuleFactory.getModuleName();\n        moduleDirAbsolute = currentCase.getModulesOutputDirAbsPath() + File.separator + ArchiveFileExtractorModuleFactory.getModuleName();\n\n        \n        File unpackDirPathFile = new File(moduleDirAbsolute);\n        if (!unpackDirPathFile.exists()) {\n            try {\n                unpackDirPathFile.mkdirs();\n            } catch (SecurityException e) {\n                logger.log(Level.SEVERE, \"Error initializing output dir: \" + moduleDirAbsolute, e); //NON-NLS\n                String msg = NbBundle.getMessage(this.getClass(),\n                        \"SevenZipIngestModule.init.errInitModule.msg\", ArchiveFileExtractorModuleFactory.getModuleName());\n                String details = NbBundle.getMessage(this.getClass(),\n                        \"SevenZipIngestModule.init.errInitModule.details\",\n                        moduleDirAbsolute, e.getMessage());\n                services.postMessage(IngestMessage.createErrorMessage(ArchiveFileExtractorModuleFactory.getModuleName(), msg, details));\n                throw e;\n            }\n        }\n\n        if (!SevenZip.isInitializedSuccessfully() && (SevenZip.getLastInitializationException() == null)) {\n            try {\n                SevenZip.initSevenZipFromPlatformJAR();\n                String platform = SevenZip.getUsedPlatform();\n                logger.log(Level.INFO, \"7-Zip-JBinding library was initialized on supported platform: {0}\", platform); //NON-NLS\n            } catch (SevenZipNativeInitializationException e) {\n                logger.log(Level.SEVERE, \"Error initializing 7-Zip-JBinding library\", e); //NON-NLS\n                String msg = NbBundle.getMessage(this.getClass(), \"SevenZipIngestModule.init.errInitModule.msg\",\n                        ArchiveFileExtractorModuleFactory.getModuleName());\n                String details = NbBundle.getMessage(this.getClass(), \"SevenZipIngestModule.init.errCantInitLib\",\n                        e.getMessage());\n                services.postMessage(IngestMessage.createErrorMessage(ArchiveFileExtractorModuleFactory.getModuleName(), msg, details));\n                throw new RuntimeException(e);\n            }\n        }\n        \n        archiveDepthCountTree = new ArchiveDepthCountTree();\n    }","id":76013,"modified_method":"@Override\n    public void startUp(IngestJobContext context) throws IngestModuleException {\n        this.context = context;\n        jobId = context.getJobId();\n\n        try {\n            fileTypeDetector = new FileTypeDetector();\n        } catch (FileTypeDetector.FileTypeDetectorInitException ex) {\n            logger.log(Level.SEVERE, NbBundle.getMessage(this.getClass(), \"SevenZipIngestModule.startUp.fileTypeDetectorInitializationException.msg\"), ex);\n            throw new IngestModuleException(NbBundle.getMessage(this.getClass(), \"SevenZipIngestModule.startUp.fileTypeDetectorInitializationException.msg\"));\n        }\n\n        final Case currentCase = Case.getCurrentCase();\n\n        moduleDirRelative = Case.getModulesOutputDirRelPath() + File.separator + ArchiveFileExtractorModuleFactory.getModuleName();\n        moduleDirAbsolute = currentCase.getModulesOutputDirAbsPath() + File.separator + ArchiveFileExtractorModuleFactory.getModuleName();\n\n        \n        File unpackDirPathFile = new File(moduleDirAbsolute);\n        if (!unpackDirPathFile.exists()) {\n            try {\n                unpackDirPathFile.mkdirs();\n            } catch (SecurityException e) {\n                logger.log(Level.SEVERE, \"Error initializing output dir: \" + moduleDirAbsolute, e); //NON-NLS\n                String msg = NbBundle.getMessage(this.getClass(),\n                        \"SevenZipIngestModule.init.errInitModule.msg\", ArchiveFileExtractorModuleFactory.getModuleName());\n                String details = NbBundle.getMessage(this.getClass(),\n                        \"SevenZipIngestModule.init.errInitModule.details\",\n                        moduleDirAbsolute, e.getMessage());\n                services.postMessage(IngestMessage.createErrorMessage(ArchiveFileExtractorModuleFactory.getModuleName(), msg, details));\n                throw e;\n            }\n        }\n\n        if (!SevenZip.isInitializedSuccessfully() && (SevenZip.getLastInitializationException() == null)) {\n            try {\n                SevenZip.initSevenZipFromPlatformJAR();\n                String platform = SevenZip.getUsedPlatform();\n                logger.log(Level.INFO, \"7-Zip-JBinding library was initialized on supported platform: {0}\", platform); //NON-NLS\n            } catch (SevenZipNativeInitializationException e) {\n                logger.log(Level.SEVERE, \"Error initializing 7-Zip-JBinding library\", e); //NON-NLS\n                String msg = NbBundle.getMessage(this.getClass(), \"SevenZipIngestModule.init.errInitModule.msg\",\n                        ArchiveFileExtractorModuleFactory.getModuleName());\n                String details = NbBundle.getMessage(this.getClass(), \"SevenZipIngestModule.init.errCantInitLib\",\n                        e.getMessage());\n                services.postMessage(IngestMessage.createErrorMessage(ArchiveFileExtractorModuleFactory.getModuleName(), msg, details));\n                throw new RuntimeException(e);\n            }\n        }\n        \n        archiveDepthCountTree = new ArchiveDepthCountTree();\n    }","commit_id":"34c5a1d6c905c2377b12e713d43735567be6c2c4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public GitRootChecker(@NotNull Project project, @NotNull PlatformFacade platformFacade) {\n    myErrors = new GitRootErrorsFinder(project, platformFacade).find();\n    myProjectMappingIsInvalid = isProjectMappingInvalid();\n  }","id":76014,"modified_method":"public GitRootChecker(@NotNull Project project, @NotNull PlatformFacade platformFacade) {\n    myErrors = new GitRootErrorsFinder(project, platformFacade).find(new GitRootDetector(project, platformFacade).detect());\n    myProjectMappingIsInvalid = isProjectMappingInvalid();\n  }","commit_id":"9a7b237aebedfe06df9c4957cd0ee0d5c5e5e026","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public List<VirtualFile> convertRoots(@NotNull List<VirtualFile> result) {\n    GitRootDetectInfo detectInfo = new GitRootDetector(myProject, myPlatformFacade).detect();\n\n    ArrayList<VirtualFile> roots = new ArrayList<VirtualFile>();\n    if (hasProjectMapping()) {\n      roots.addAll(detectInfo.getRoots());\n    }\n\n    HashSet<VirtualFile> listed = new HashSet<VirtualFile>();\n    for (VirtualFile f : result) {\n      VirtualFile r = GitUtil.gitRootOrNull(f);\n      if (r != null && listed.add(r)) {\n        roots.add(r);\n      }\n    }\n    return roots;\n  }","id":76015,"modified_method":"@NotNull\n  public List<VirtualFile> convertRoots(@NotNull List<VirtualFile> result) {\n    if (myDetectedRoots == null) {\n      myDetectedRoots = new GitRootDetector(myProject, myPlatformFacade).detect().getRoots();\n    }\n\n    ArrayList<VirtualFile> roots = new ArrayList<VirtualFile>();\n    if (hasProjectMapping()) {\n      roots.addAll(myDetectedRoots);\n    }\n\n    HashSet<VirtualFile> listed = new HashSet<VirtualFile>();\n    for (VirtualFile f : result) {\n      VirtualFile r = GitUtil.gitRootOrNull(f);\n      if (r != null && listed.add(r)) {\n        if (!roots.contains(r)) {\n          roots.add(r);\n        }\n      }\n    }\n    return roots;\n  }","commit_id":"9a7b237aebedfe06df9c4957cd0ee0d5c5e5e026","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GitRootConverter(@NotNull Project project, @NotNull PlatformFacade facade) {\n    myProject = project;\n    myPlatformFacade = facade;\n  }","id":76016,"modified_method":"public GitRootConverter(@NotNull Project project, @NotNull PlatformFacade facade) {\n    myProject = project;\n    myPlatformFacade = facade;\n    myProject.getMessageBus().connect().subscribe(GitRepositoryManager.GIT_ROOTS_CHANGE, this);\n  }","commit_id":"9a7b237aebedfe06df9c4957cd0ee0d5c5e5e026","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void rescanAndNotifyIfNeeded() {\n    if (!mySettings.SHOW_VCS_ERROR_NOTIFICATIONS) {\n      return;\n    }\n\n    Collection<VcsRootError> errors = scan();\n    if (errors.isEmpty()) {\n      synchronized (NOTIFICATION_LOCK) {\n        expireNotification();\n      }\n      return;\n    }\n\n    Collection<String> unregisteredRoots = getUnregisteredRoots(errors);\n    Collection<String> invalidRoots = getInvalidRoots(errors);\n\n    String title = makeTitle(unregisteredRoots, invalidRoots);\n    String description = makeDescription(unregisteredRoots, invalidRoots);\n\n    synchronized (NOTIFICATION_LOCK) {\n      expireNotification();\n      myNotification = createNotification(IMPORTANT_ERROR_NOTIFICATION, title, description, ERROR,\n                                          new MyNotificationListener(myProject, mySettings));\n      myPlatformFacade.getNotificator(myProject).notify(myNotification);\n    }\n  }","id":76017,"modified_method":"public GitRootDetectInfo rescanAndNotifyIfNeeded() {\n    GitRootDetectInfo detectInfo = new GitRootDetector(myProject, myPlatformFacade).detect();\n\n    if (!mySettings.SHOW_VCS_ERROR_NOTIFICATIONS) {\n      return detectInfo;\n    }\n\n    Collection<VcsRootError> errors = scan(detectInfo);\n    if (errors.isEmpty()) {\n      synchronized (NOTIFICATION_LOCK) {\n        expireNotification();\n      }\n      return detectInfo;\n    }\n\n    Collection<String> unregisteredRoots = getUnregisteredRoots(errors);\n    Collection<String> invalidRoots = getInvalidRoots(errors);\n\n    String title = makeTitle(unregisteredRoots, invalidRoots);\n    String description = makeDescription(unregisteredRoots, invalidRoots);\n\n    synchronized (NOTIFICATION_LOCK) {\n      expireNotification();\n      myNotification = createNotification(IMPORTANT_ERROR_NOTIFICATION, title, description, ERROR,\n                                          new MyNotificationListener(myProject, mySettings, myPlatformFacade));\n      myPlatformFacade.getNotificator(myProject).notify(myNotification);\n    }\n    return detectInfo;\n  }","commit_id":"9a7b237aebedfe06df9c4957cd0ee0d5c5e5e026","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent event) {\n      if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n        if (event.getDescription().equals(\"configure\")) {\n          ShowSettingsUtil.getInstance().showSettingsDialog(myProject, ActionsBundle.message(\"group.VcsGroup.text\"));\n          Collection<VcsRootError> errorsAfterPossibleFix = GitRootProblemNotifier.getInstance(myProject).scan();\n          if (errorsAfterPossibleFix.isEmpty() && !notification.isExpired()) {\n            notification.expire();\n          }\n        }\n        else if (event.getDescription().equals(\"ignore\")) {\n          mySettings.SHOW_VCS_ERROR_NOTIFICATIONS = false;\n          notification.expire();\n        }\n      }\n    }","id":76018,"modified_method":"@Override\n    public void hyperlinkUpdate(@NotNull Notification notification, @NotNull HyperlinkEvent event) {\n      if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n        if (event.getDescription().equals(\"configure\")) {\n          ShowSettingsUtil.getInstance().showSettingsDialog(myProject, ActionsBundle.message(\"group.VcsGroup.text\"));\n          Collection<VcsRootError> errorsAfterPossibleFix = GitRootProblemNotifier.getInstance(myProject).scan(\n            new GitRootDetector(myProject, myPlatformFacade).detect());\n          if (errorsAfterPossibleFix.isEmpty() && !notification.isExpired()) {\n            notification.expire();\n          }\n        }\n        else if (event.getDescription().equals(\"ignore\")) {\n          mySettings.SHOW_VCS_ERROR_NOTIFICATIONS = false;\n          notification.expire();\n        }\n      }\n    }","commit_id":"9a7b237aebedfe06df9c4957cd0ee0d5c5e5e026","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MyNotificationListener(@NotNull Project project, @NotNull VcsConfiguration settings) {\n      myProject = project;\n      mySettings = settings;\n    }","id":76019,"modified_method":"private MyNotificationListener(@NotNull Project project, @NotNull VcsConfiguration settings, @NotNull PlatformFacade facade) {\n      myProject = project;\n      mySettings = settings;\n      myPlatformFacade = facade;\n    }","commit_id":"9a7b237aebedfe06df9c4957cd0ee0d5c5e5e026","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void scanWithLock() {\n    synchronized (SCAN_LOCK) {\n      if (myScanning) {\n        return;\n      }\n      myScanning = true;\n      myRootProblemNotifier.rescanAndNotifyIfNeeded();\n      myExecuteAfterScan.run();\n      myScanning = false;\n    }\n  }","id":76020,"modified_method":"private void scanWithLock() {\n    synchronized (SCAN_LOCK) {\n      if (myScanning) {\n        return;\n      }\n      myScanning = true;\n      GitRootDetectInfo detectInfo = myRootProblemNotifier.rescanAndNotifyIfNeeded();\n      myProject.getMessageBus().syncPublisher(GitRepositoryManager.GIT_ROOTS_CHANGE).gitRootsChanged(detectInfo.getRoots());\n      myExecuteAfterScan.run();\n      myScanning = false;\n    }\n  }","commit_id":"9a7b237aebedfe06df9c4957cd0ee0d5c5e5e026","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GitRootScanner(@NotNull Project project, @NotNull Runnable executeAfterScan) {\n    myExecuteAfterScan = executeAfterScan;\n\n    StartupManager.getInstance(project).runWhenProjectIsInitialized(new DumbAwareRunnable() {\n      @Override\n      public void run() {\n        myProjectIsInitialized = true;\n        scanIfReady();\n      }\n    });\n\n    final MessageBus messageBus = project.getMessageBus();\n    messageBus.connect().subscribe(ProjectLevelVcsManager.VCS_CONFIGURATION_CHANGED, this);\n    messageBus.connect().subscribe(VirtualFileManager.VFS_CHANGES, this);\n    messageBus.connect().subscribe(ProjectTopics.PROJECT_ROOTS, this);\n\n    myRootProblemNotifier = GitRootProblemNotifier.getInstance(project);\n  }","id":76021,"modified_method":"public GitRootScanner(@NotNull Project project, @NotNull Runnable executeAfterScan) {\n    myProject = project;\n    myExecuteAfterScan = executeAfterScan;\n\n    StartupManager.getInstance(project).runWhenProjectIsInitialized(new DumbAwareRunnable() {\n      @Override\n      public void run() {\n        myProjectIsInitialized = true;\n        scanIfReady();\n      }\n    });\n\n    final MessageBus messageBus = project.getMessageBus();\n    messageBus.connect().subscribe(ProjectLevelVcsManager.VCS_CONFIGURATION_CHANGED, this);\n    messageBus.connect().subscribe(VirtualFileManager.VFS_CHANGES, this);\n    messageBus.connect().subscribe(ProjectTopics.PROJECT_ROOTS, this);\n\n    myRootProblemNotifier = GitRootProblemNotifier.getInstance(project);\n  }","commit_id":"9a7b237aebedfe06df9c4957cd0ee0d5c5e5e026","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TikaContent(String content, Metadata metadata) {\n            this.content = content;\n            this.metadata = metadata;\n        }","id":76022,"modified_method":"public TikaContent(String content, Metadata metadata, MediaType mediaType) {\n            this.content = content;\n            this.metadata = metadata;\n            this.mediaType = mediaType;\n        }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create new Tika-based content extractor using the provided parser instance and\n     * optional media type validation. If validation is enabled, the implementation \n     * will try to detect the media type of the input and validate it against media types\n     * supported by the parser.\n     * @param parser parser instance\n     * @param validateMediaType enabled or disable media type validation\n     */\n    public TikaContentExtractor(final Parser parser, final boolean validateMediaType) {\n        this.parser = parser;\n        this.validateMediaType = validateMediaType;\n        this.detector = validateMediaType ? new DefaultDetector() : null;\n    }","id":76023,"modified_method":"/**\n     * Create new Tika-based content extractor using the provided parser instance and\n     * optional media type validation. If validation is enabled, the implementation parser\n     * will try to detect the media type of the input and validate it against media types\n     * supported by the parser.\n     * @param parser parser instance\n     * @param validateMediaType enabled or disable media type validationparser\n     */\n    public TikaContentExtractor(final Parser parser, final boolean validateMediaType) {\n        this(Collections.singletonList(parser), validateMediaType ? new DefaultDetector() : null);\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"TikaContent extractAll(final InputStream in, boolean extractContent) {\n        if (in == null) {\n            return null;\n        }\n        \n        try {\n            final Metadata metadata = new Metadata();            \n            final ParseContext context = new ParseContext();\n            \n            // Try to validate that input stream media type is supported by the parser \n            if (validateMediaType) {\n                final MediaType mediaType = detector.detect(in, metadata);\n                if (mediaType == null || !parser.getSupportedTypes(context).contains(mediaType)) {\n                    return null;\n                }\n            }\n            \n            final ToTextContentHandler handler = extractContent \n                ? new ToTextContentHandler() : new IgnoreContentHandler();\n            parser.parse(in, handler, metadata, context);\n            return new TikaContent(handler.toString(), metadata);\n        } catch (final IOException ex) {\n            LOG.log(Level.WARNING, \"Unable to extract media type from input stream\", ex);\n        } catch (final SAXException ex) {\n            LOG.log(Level.WARNING, \"Unable to parse input stream\", ex);\n        } catch (final TikaException ex) {\n            LOG.log(Level.WARNING, \"Unable to parse input stream\", ex);\n        }\n     \n        return null;\n    }","id":76024,"modified_method":"TikaContent extractAll(final InputStream in, boolean extractContent) {\n        if (in == null) {\n            return null;\n        }\n        \n        try {\n            final Metadata metadata = new Metadata();            \n            final ParseContext context = new ParseContext();\n            \n            // Try to validate that input stream media type is supported by the parser\n            MediaType mediaType = null;\n            Parser parser = null;\n            for (Parser p : parsers) {\n                if (detector != null) {\n                    mediaType = detector.detect(in, metadata);\n                    if (mediaType != null && p.getSupportedTypes(context).contains(mediaType)) {\n                        parser = p;\n                        break;\n                    }\n                } else {\n                    parser = p;\n                }\n            }\n            if (parser == null) {\n                return null;\n            }\n            \n            final ToTextContentHandler handler = extractContent \n                ? new ToTextContentHandler() : new IgnoreContentHandler();\n            parser.parse(in, handler, metadata, context);\n            return new TikaContent(handler.toString(), metadata, mediaType);\n        } catch (final IOException ex) {\n            LOG.log(Level.WARNING, \"Unable to extract media type from input stream\", ex);\n        } catch (final SAXException ex) {\n            LOG.log(Level.WARNING, \"Unable to parse input stream\", ex);\n        } catch (final TikaException ex) {\n            LOG.log(Level.WARNING, \"Unable to parse input stream\", ex);\n        }\n     \n        return null;\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Extract the metadata only from the input stream. Depending on media type validation,\n     * the detector could be run against input stream in order to ensure that parser supports this\n     * type of content. \n     * @param in input stream to extract the metadata from  \n     * @return the extracted document or null if extraction is not possible or was unsuccessful\n     */\n    public Document extractMetadata(final InputStream in) {\n        return extractAll(in, defaultDocumentMetadata, false, true);\n    }","id":76025,"modified_method":"/**\n     * Extract the metadata only from the input stream. Depending on media type validation,\n     * the detector could be run against input stream in order to ensure that parser supports this\n     * type of content. \n     * @param in input stream to extract the metadata from  \n     * @return the extracted document or null if extraction is not possible or was unsuccessful\n     */\n    public Document extractMetadata(final InputStream in) {\n        return extractAll(in, null, false, true);\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Extract the content and metadata from the input stream using DocumentMetadata descriptor to\n     * create a document with strongly typed fields. Depending on media type validation,\n     * the detector could be run against input stream in order to ensure that parser supports this\n     * type of content. \n     * @param in input stream to extract the content and metadata from  \n     * @param metadata document descriptor with field names and their types\n     * @return the extracted document or null if extraction is not possible or was unsuccessful\n     */\n    public Document extract(final InputStream in, final DocumentMetadata metadata) {\n        return extractAll(in, metadata, true, true);\n    }","id":76026,"modified_method":"/**\n     * Extract the content and metadata from the input stream. Depending on media type validation,\n     * the detector could be run against input stream in order to ensure that parser supports this\n     * type of content. \n     * @param in input stream to extract the content and metadata from  \n     * @param documentMetadata documentMetadata\n     * @return the extracted document or null if extraction is not possible or was unsuccessful\n     */\n    public Document extract(final InputStream in, final LuceneDocumentMetadata documentMetadata) {\n        return extractAll(in, documentMetadata, true, true);\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create new Tika-based content extractor using the provided parser instance and\n     * optional media type validation. If validation is enabled, the implementation \n     * will try to detect the media type of the input and validate it against media types\n     * supported by the parser.\n     * @param parser parser instance\n     * @param validateMediaType enabled or disable media type validation\n     */\n    public TikaLuceneContentExtractor(final Parser parser, final boolean validateMediaType) {\n        this(parser, validateMediaType, \"contents\");\n    }","id":76027,"modified_method":"/**\n     * Create new Tika-based content extractor using the provided parser instance and\n     * optional media type validation. If validation is enabled, the implementation \n     * will try to detect the media type of the input and validate it against media typesthis.contentFieldName\n     * supported by the parser.\n     * @param parser parser instance\n     * @param validateMediaType enabled or disable media type validation\n     */\n    public TikaLuceneContentExtractor(final Parser parser, final boolean validateMediaType) {\n        this(parser, validateMediaType, new LuceneDocumentMetadata());\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Extract the content and metadata from the input stream. Depending on media type validation,\n     * the detector could be run against input stream in order to ensure that parser supports this\n     * type of content. \n     * @param in input stream to extract the content and metadata from  \n     * @return the extracted document or null if extraction is not possible or was unsuccessful\n     */\n    public Document extract(final InputStream in) {\n        return extractAll(in, defaultDocumentMetadata, true, true);\n    }","id":76028,"modified_method":"/**\n     * Extract the content and metadata from the input stream. Depending on media type validation,\n     * the detector could be run against input stream in order to ensure that parser supports this\n     * type of content. \n     * @param in input stream to extract the content and metadata from  \n     * @return the extracted document or null if extraction is not possible or was unsuccessful\n     */\n    public Document extract(final InputStream in) {\n        return extractAll(in, null, true, true);\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Extract the content only from the input stream. Depending on media type validation,\n     * the detector could be run against input stream in order to ensure that parser supports this\n     * type of content. \n     * @param in input stream to extract the content from  \n     * @return the extracted document or null if extraction is not possible or was unsuccessful\n     */\n    public Document extractContent(final InputStream in) {\n        return extractAll(in, defaultDocumentMetadata, true, false);\n    }","id":76029,"modified_method":"/**\n     * Extract the content only from the input stream. Depending on media type validation,\n     * the detector could be run against input stream in order to ensure that parser supports this\n     * type of content. \n     * @param in input stream to extract the content from  \n     * @return the extracted document or null if extraction is not possible or was unsuccessful\n     */\n    public Document extractContent(final InputStream in) {\n        return extractAll(in, null, true, false);\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create new Tika-based content extractor using the provided parser instance and\n     * optional media type validation. If validation is enabled, the implementation \n     * will try to detect the media type of the input and validate it against media types\n     * supported by the parser.\n     * @param parser parser instance\n     * @param validateMediaType enabled or disable media type validation\n     * @param contentFieldName name of the content field, default is \"contents\"\n     */\n    public TikaLuceneContentExtractor(final Parser parser, final boolean validateMediaType, \n                                final String contentFieldName) {\n        extractor = new TikaContentExtractor(parser, validateMediaType);\n        defaultDocumentMetadata = new DocumentMetadata(contentFieldName);\n    }","id":76030,"modified_method":"/**\n     * Create new Tika-based content extractor using the provided parser instance and\n     * optional media type validation. If validation is enabled, the implementation \n     * will try to detect the media type of the input and validate it against media types\n     * supported by the parser.\n     * @param parser parser instancethis.contentFieldName\n     * @param validateMediaType enabled or disable media type validation\n     * @param documentMetadata documentMetadata\n     */\n    public TikaLuceneContentExtractor(final Parser parser, \n                                      final boolean validateMediaType, \n                                      final LuceneDocumentMetadata documentMetadata) {\n        this.extractor = new TikaContentExtractor(parser, validateMediaType);\n        this.defaultDocumentMetadata = documentMetadata;\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"private Document extractAll(final InputStream in, final DocumentMetadata documentMetadata, \n            boolean extractContent, boolean extractMetadata) {\n        \n        TikaContent content = extractor.extractAll(in, extractContent);\n        \n        if (content == null) {\n            return null;\n        }\n        final Document document = new Document();\n        if (content.getContent() != null) {\n            document.add(documentMetadata.contentField(content.getContent()));\n        } \n        \n        if (extractMetadata) {\n            Metadata metadata = content.getMetadata();\n            for (final String property: metadata.names()) {\n                document.add(documentMetadata.field(property, metadata.get(property)));\n            }\n        }\n        \n        return document;\n        \n    }","id":76031,"modified_method":"private Document extractAll(final InputStream in, \n                                LuceneDocumentMetadata documentMetadata, \n                                boolean extractContent, \n                                boolean extractMetadata) {\n        \n        TikaContent content = extractor.extractAll(in, extractContent);\n        \n        if (content == null) {\n            return null;\n        }\n        final Document document = new Document();\n        \n        if (documentMetadata == null) { \n            documentMetadata = defaultDocumentMetadata;\n        }\n        if (content.getContent() != null) {\n            document.add(getContentField(documentMetadata, content.getContent()));\n        } \n        \n        if (extractMetadata) {\n            Metadata metadata = content.getMetadata();\n            for (final String property: metadata.names()) {\n                document.add(getField(documentMetadata, property, metadata.get(property)));\n            }\n        }\n        \n        return document;\n        \n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testExtractedTextContentMatchesTypesAndSearchCriteria() throws Exception {\n        final DocumentMetadata documentMetadata = new DocumentMetadata(\"contents\")\n            .withField(\"modified\", Date.class);\n        \n        final Document document = extractor.extract(\n            getClass().getResourceAsStream(\"/files/testPDF.pdf\"), documentMetadata);\n        assertNotNull(\"Document should not be null\", document);\n        \n        writer.addDocument(document);\n        writer.commit();\n\n        assertEquals(1, getHits(\"modified==2007-09-15T09:02:31Z\").length);\n    }","id":76032,"modified_method":"@Test\n    public void testExtractedTextContentMatchesTypesAndSearchCriteria() throws Exception {\n        final LuceneDocumentMetadata documentMetadata = new LuceneDocumentMetadata(\"contents\")\n            .withField(\"modified\", Date.class);\n        \n        final Document document = extractor.extract(\n            getClass().getResourceAsStream(\"/files/testPDF.pdf\"), documentMetadata);\n        assertNotNull(\"Document should not be null\", document);\n        \n        writer.addDocument(document);\n        writer.commit();\n\n        assertEquals(1, getHits(\"modified==2007-09-15T09:02:31Z\").length);\n    }","commit_id":"8f99f30970db784a6d741fe76dbca517585d31cd","url":"https://github.com/apache/cxf"},{"original_method":"protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String stylesheet = (String) request.getAttribute(REQ_ATTRIBUTE_STYLESHEET);\n        if (stylesheet == null)\n            throw new ServletException(\"No stylesheet source specified!\");\n        Item inputNode = null;\n        String sourceAttrib = (String) request.getAttribute(REQ_ATTRIBUTE_INPUT);\n        if (sourceAttrib != null) {\n            Object sourceObj = request.getAttribute(sourceAttrib);\n            if (sourceObj != null) {\n                if (sourceObj instanceof Item) {\n                    inputNode = (Item) sourceObj;\n                    if (!Type.subTypeOf(inputNode.getType(), Type.NODE))\n                        throw new ServletException(\"Input for XSLT servlet is not a node. Read from attribute \" +\n                                sourceAttrib);\n                    LOG.debug(\"Taking XSLT input from request attribute \" + sourceAttrib);\n                } else\n                    throw new ServletException(\"Input for XSLT servlet is not a node. Read from attribute \" +\n                            sourceAttrib);\n            }\n        }\n\n        String userParam = (String) request.getAttribute(\"xslt.user\");\n        String passwd = (String) request.getAttribute(\"xslt.password\");\n        if (userParam == null) {\n            userParam = org.exist.security.SecurityManager.GUEST_USER;\n            passwd = userParam;\n        }\n\n        try {\n            pool = BrokerPool.getInstance();\n            UserImpl user = pool.getSecurityManager().getUser(userParam);\n            if (user != null) {\n                if (!user.validate(passwd)) {\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Wrong password or user\");\n                }\n            }\n\n            SAXTransformerFactory factory = TransformerFactoryAllocator.getTransformerFactory(pool);\n            Templates templates = getSource(user, request, response, factory, stylesheet);\n            if (templates == null)\n                return;\n            //do the transformation\n            DBBroker broker = null;\n            try {\n                broker = pool.get(user);\n                TransformerHandler handler = factory.newTransformerHandler(templates);\n                setParameters(request, handler.getTransformer());\n                Properties properties = handler.getTransformer().getOutputProperties();\n                setOutputProperties(request, properties);\n\n                String mediaType = properties.getProperty(\"media-type\");\n                String encoding = properties.getProperty(\"encoding\");\n                if (encoding == null)\n                    encoding = \"UTF-8\";\n                response.setCharacterEncoding(encoding);\n                if (mediaType != null) {\n                    if (encoding == null)\n                        response.setContentType(mediaType);\n                    \n                    //check, do mediaType have \"charset\"\n                    else if (mediaType.indexOf(\"charset\") == -1)\n                        response.setContentType(mediaType + \"; charset=\" + encoding);\n                    else \n                        response.setContentType(mediaType);\n                }\n\n                SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n                Writer writer = new BufferedWriter(response.getWriter());\n                sax.setOutput(writer, properties);\n                SAXResult result = new SAXResult(sax);\n                handler.setResult(result);\n                \n                Serializer serializer = broker.getSerializer();\n                serializer.reset();\n                Receiver receiver = new ReceiverToSAX(handler);\n                try {\n                    XIncludeFilter xinclude = new XIncludeFilter(serializer, receiver);\n                    receiver = xinclude;\n                    String moduleLoadPath;\n                    String base = (String) request.getAttribute(REQ_ATTRIBUTE_BASE);\n                    if (base != null)\n                        moduleLoadPath = getServletContext().getRealPath(base);\n                    else\n                        moduleLoadPath = getCurrentDir(request).getAbsolutePath();\n                    xinclude.setModuleLoadPath(moduleLoadPath);\n                    serializer.setReceiver(receiver);\n                    if (inputNode != null)\n                        serializer.toSAX((NodeValue)inputNode);\n                    else {\n                        SAXToReceiver saxreceiver = new SAXToReceiver(receiver);\n                        XMLReader reader = pool.getParserPool().borrowXMLReader();\n                        reader.setContentHandler(saxreceiver);\n                        reader.parse(new InputSource(request.getInputStream()));\n                    }\n                } catch (SAXException e) {\n                    throw new ServletException(\"SAX exception while transforming node: \" + e.getMessage(), e);\n                } finally {\n                    SerializerPool.getInstance().returnObject(sax);\n                }\n                writer.flush();\n                response.flushBuffer();\n\n            } catch (IOException e) {\n                throw new ServletException(\"IO exception while transforming node: \" + e.getMessage(), e);\n\n            } catch (TransformerException e) {\n                throw new ServletException(\"Exception while transforming node: \" + e.getMessage(), e);\n                \n            } catch (Throwable e){\n                LOG.error(e);\n                throw new ServletException(\"An error occurred: \" + e.getMessage(), e);\n\n            } finally {\n                pool.release(broker);\n            }\n        } catch (EXistException e) {\n            throw new ServletException(e.getMessage(), e);\n        }\n    }","id":76033,"modified_method":"protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String stylesheet = (String) request.getAttribute(REQ_ATTRIBUTE_STYLESHEET);\n        if (stylesheet == null)\n            throw new ServletException(\"No stylesheet source specified!\");\n        Item inputNode = null;\n        String sourceAttrib = (String) request.getAttribute(REQ_ATTRIBUTE_INPUT);\n        if (sourceAttrib != null) {\n            Object sourceObj = request.getAttribute(sourceAttrib);\n            if (sourceObj != null) {\n            \tif (sourceObj instanceof ValueSequence) {\n\t\t\t\t\tValueSequence seq = (ValueSequence) sourceObj;\n\t\t\t\t\t\n\t\t\t\t\tif (seq.size() == 1)\n\t\t\t\t\t\tsourceObj = seq.get(0);\n\t\t\t\t}\n            \t\n                if (sourceObj instanceof Item) {\n                    inputNode = (Item) sourceObj;\n                    if (!Type.subTypeOf(inputNode.getType(), Type.NODE))\n                        throw new ServletException(\"Input for XSLT servlet is not a node. Read from attribute \" +\n                                sourceAttrib);\n                    LOG.debug(\"Taking XSLT input from request attribute \" + sourceAttrib);\n                } else\n                    throw new ServletException(\"Input for XSLT servlet is not a node. Read from attribute \" +\n                            sourceAttrib);\n            }\n        }\n\n        String userParam = (String) request.getAttribute(\"xslt.user\");\n        String passwd = (String) request.getAttribute(\"xslt.password\");\n        if (userParam == null) {\n            userParam = org.exist.security.SecurityManager.GUEST_USER;\n            passwd = userParam;\n        }\n\n        try {\n            pool = BrokerPool.getInstance();\n            UserImpl user = pool.getSecurityManager().getUser(userParam);\n            if (user != null) {\n                if (!user.validate(passwd)) {\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Wrong password or user\");\n                }\n            }\n\n            SAXTransformerFactory factory = TransformerFactoryAllocator.getTransformerFactory(pool);\n            Templates templates = getSource(user, request, response, factory, stylesheet);\n            if (templates == null)\n                return;\n            //do the transformation\n            DBBroker broker = null;\n            try {\n                broker = pool.get(user);\n                TransformerHandler handler = factory.newTransformerHandler(templates);\n                setParameters(request, handler.getTransformer());\n                Properties properties = handler.getTransformer().getOutputProperties();\n                setOutputProperties(request, properties);\n\n                String mediaType = properties.getProperty(\"media-type\");\n                String encoding = properties.getProperty(\"encoding\");\n                if (encoding == null)\n                    encoding = \"UTF-8\";\n                response.setCharacterEncoding(encoding);\n                if (mediaType != null) {\n                    if (encoding == null)\n                        response.setContentType(mediaType);\n                    \n                    //check, do mediaType have \"charset\"\n                    else if (mediaType.indexOf(\"charset\") == -1)\n                        response.setContentType(mediaType + \"; charset=\" + encoding);\n                    else \n                        response.setContentType(mediaType);\n                }\n\n                SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n                Writer writer = new BufferedWriter(response.getWriter());\n                sax.setOutput(writer, properties);\n                SAXResult result = new SAXResult(sax);\n                handler.setResult(result);\n                \n                Serializer serializer = broker.getSerializer();\n                serializer.reset();\n                Receiver receiver = new ReceiverToSAX(handler);\n                try {\n                    XIncludeFilter xinclude = new XIncludeFilter(serializer, receiver);\n                    receiver = xinclude;\n                    String moduleLoadPath;\n                    String base = (String) request.getAttribute(REQ_ATTRIBUTE_BASE);\n                    if (base != null)\n                        moduleLoadPath = getServletContext().getRealPath(base);\n                    else\n                        moduleLoadPath = getCurrentDir(request).getAbsolutePath();\n                    xinclude.setModuleLoadPath(moduleLoadPath);\n                    serializer.setReceiver(receiver);\n                    if (inputNode != null)\n                        serializer.toSAX((NodeValue)inputNode);\n                    else {\n                        SAXToReceiver saxreceiver = new SAXToReceiver(receiver);\n                        XMLReader reader = pool.getParserPool().borrowXMLReader();\n                        reader.setContentHandler(saxreceiver);\n                        reader.parse(new InputSource(request.getInputStream()));\n                    }\n                } catch (SAXException e) {\n                    throw new ServletException(\"SAX exception while transforming node: \" + e.getMessage(), e);\n                } finally {\n                    SerializerPool.getInstance().returnObject(sax);\n                }\n                writer.flush();\n                response.flushBuffer();\n\n            } catch (IOException e) {\n                throw new ServletException(\"IO exception while transforming node: \" + e.getMessage(), e);\n\n            } catch (TransformerException e) {\n                throw new ServletException(\"Exception while transforming node: \" + e.getMessage(), e);\n                \n            } catch (Throwable e){\n                LOG.error(e);\n                throw new ServletException(\"An error occurred: \" + e.getMessage(), e);\n\n            } finally {\n                pool.release(broker);\n            }\n        } catch (EXistException e) {\n            throw new ServletException(e.getMessage(), e);\n        }\n    }","commit_id":"bb09d401fef3bdfd37eec0df8ad248cb53a89e6a","url":"https://github.com/eXist-db/exist"},{"original_method":"private Templates getSource(User user, HttpServletRequest request, HttpServletResponse response,\n                                SAXTransformerFactory factory, String stylesheet)\n        throws ServletException, IOException {\n        String base;\n        if(stylesheet.indexOf(':') == Constants.STRING_NOT_FOUND) {\n            File f = new File(stylesheet);\n            if (f.canRead())\n                stylesheet = f.toURI().toASCIIString();\n            else {\n                if (f.isAbsolute()) {\n                    f = new File(getServletContext().getRealPath(stylesheet));\n                    stylesheet = f.toURI().toASCIIString();\n                } else {\n                    f = new File(getCurrentDir(request), stylesheet);\n                    stylesheet = f.toURI().toASCIIString();\n                }\n                if (!f.canRead()) {\n                    response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Stylesheet not found\");\n                    return null;\n                }\n            }\n        }\n        int p = stylesheet.lastIndexOf(\"/\");\n        if(p != Constants.STRING_NOT_FOUND)\n            base = stylesheet.substring(0, p);\n        else\n            base = stylesheet;\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Loading stylesheet from \" + stylesheet);\n        CachedStylesheet cached = cache.get(stylesheet);\n        if(cached == null) {\n            cached = new CachedStylesheet(factory, user, stylesheet, base);\n            cache.put(stylesheet, cached);\n        }\n        return cached.getTemplates(user);\n    }","id":76034,"modified_method":"private Templates getSource(User user, HttpServletRequest request, HttpServletResponse response,\n                                SAXTransformerFactory factory, String stylesheet)\n        throws ServletException, IOException {\n        String base;\n        if(stylesheet.indexOf(':') == Constants.STRING_NOT_FOUND) {\n            File f = new File(stylesheet);\n            if (f.canRead())\n                stylesheet = f.toURI().toASCIIString();\n            else {\n                if (f.isAbsolute()) {\n                \tString url = getServletContext().getRealPath(stylesheet);\n                \tif (url == null) {\n                        response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Stylesheet not found (URL: \"+stylesheet+\")\");\n                        return null;\n                \t}\n                \t\t\n                    f = new File(url);\n                    stylesheet = f.toURI().toASCIIString();\n                } else {\n                    f = new File(getCurrentDir(request), stylesheet);\n                    stylesheet = f.toURI().toASCIIString();\n                }\n                if (!f.canRead()) {\n                    response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Stylesheet not found (URL: \"+stylesheet+\")\");\n                    return null;\n                }\n            }\n        }\n        int p = stylesheet.lastIndexOf(\"/\");\n        if(p != Constants.STRING_NOT_FOUND)\n            base = stylesheet.substring(0, p);\n        else\n            base = stylesheet;\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Loading stylesheet from \" + stylesheet);\n        CachedStylesheet cached = cache.get(stylesheet);\n        if(cached == null) {\n            cached = new CachedStylesheet(factory, user, stylesheet, base);\n            cache.put(stylesheet, cached);\n        }\n        return cached.getTemplates(user);\n    }","commit_id":"bb09d401fef3bdfd37eec0df8ad248cb53a89e6a","url":"https://github.com/eXist-db/exist"},{"original_method":"private String buildClassPath(PipelineContext context) {\n        StringBuffer classpath = new StringBuffer();\n        StringBuffer jarpath = new StringBuffer();\n\n        String propJarpath = getPropertySet().getString(JARPATH_PROPERTY);\n        String propClasspath = getPropertySet().getString(CLASSPATH_PROPERTY);\n\n        // Add classpath for jproperties if available\n        if(propClasspath != null)\n            classpath.append(propClasspath).append(PATH_SEPARATOR);\n\n        // Add jar path from properties\n        if(propJarpath != null)\n            jarpath.append(propJarpath).append(PATH_SEPARATOR);\n\n        // Add jar path from webapp if available\n        ExternalContext externalContext = (ExternalContext) context.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n        if(externalContext != null) {\n            jarpath.append(externalContext.getRealPath(\"WEB-INF/lib\"));\n            classpath.append(externalContext.getRealPath(\"WEB-INF/classes\")).append(PATH_SEPARATOR);\n        }\n\n        for (StringTokenizer tokenizer = new StringTokenizer(jarpath.toString(), PATH_SEPARATOR); tokenizer.hasMoreElements();) {\n            String path = tokenizer.nextToken();\n\n            // Find jars in path\n            File[] jars = new File(path).listFiles(new FileFilter() {\n                public boolean accept(File pathname) {\n                    String absolutePath = pathname.getAbsolutePath();\n                    return absolutePath.endsWith(\".jar\") || absolutePath.endsWith(\".zip\");\n                }\n            });\n\n            // Add them to string buffer\n            if (jars != null) {\n                for (int i = 0; i < jars.length; i++)\n                    classpath.append(jars[i].getAbsolutePath()).append(PATH_SEPARATOR);\n            }\n        }\n\n        if(logger.isDebugEnabled())\n            logger.debug(\"Classpath: \"+ classpath.toString());\n        return classpath.length() == 0 ? null : classpath.toString();\n    }","id":76035,"modified_method":"private String buildClassPath(PipelineContext context) {\n        StringBuffer classpath = new StringBuffer();\n        StringBuffer jarpath = new StringBuffer();\n\n        String propJarpath = getPropertySet().getString(JARPATH_PROPERTY);\n        String propClasspath = getPropertySet().getString(CLASSPATH_PROPERTY);\n\n        // Add classpath for jproperties if available\n        if (propClasspath != null)\n            classpath.append(propClasspath).append(PATH_SEPARATOR);\n\n        // Add jar path from properties\n        if (propJarpath != null)\n            jarpath.append(propJarpath).append(PATH_SEPARATOR);\n\n        // Add jar path from webapp if available\n        ExternalContext externalContext = (ExternalContext) context.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n        boolean gotLibDir = false;\n        if (externalContext != null) {\n            String webInfLibPath = externalContext.getRealPath(\"WEB-INF/lib\");\n            if (webInfLibPath != null) {\n                jarpath.append(webInfLibPath).append(PATH_SEPARATOR);\n                gotLibDir = true;\n            }\n            String webInfClasses = externalContext.getRealPath(\"WEB-INF/classes\");\n            if (webInfClasses != null)\n                classpath.append(webInfClasses).append(PATH_SEPARATOR);\n        }\n\n        // Try to add directory containing current JAR file\n        if (!gotLibDir) {\n            try {\n                URL url = getClass().getClassLoader().getResource(\"org/orbeon/oxf/processor/JavaProcessor.class\");\n                if (url.getProtocol().equals(\"jar\")) {\n                    String file = url.getFile();\n                    if (file.indexOf(\"!\") != -1)\n                        file = file.substring(0, file.indexOf(\"!\"));\n\n                    if (file.startsWith(\"file:/\"))\n                        file = file.substring(\"file:/\".length());\n\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"Found current JAR file: \" + file);\n                    \n                    File jarDirectory = new File(file).getParentFile();\n                    jarpath.append(jarDirectory.getCanonicalPath()).append(PATH_SEPARATOR);\n                }\n            } catch (IOException e) {\n                throw new OXFException(e);\n            }\n        }\n\n        for (StringTokenizer tokenizer = new StringTokenizer(jarpath.toString(), PATH_SEPARATOR); tokenizer.hasMoreElements();) {\n            String path = tokenizer.nextToken();\n\n            // Find jars in path\n            File[] jars = new File(path).listFiles(new FileFilter() {\n                public boolean accept(File pathname) {\n                    String absolutePath = pathname.getAbsolutePath();\n                    return absolutePath.endsWith(\".jar\") || absolutePath.endsWith(\".zip\");\n                }\n            });\n\n            // Add them to string buffer\n            if (jars != null) {\n                for (int i = 0; i < jars.length; i++)\n                    classpath.append(jars[i].getAbsolutePath()).append(PATH_SEPARATOR);\n            }\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(\"Classpath: \"+ classpath.toString());\n        return classpath.length() == 0 ? null : classpath.toString();\n    }","commit_id":"1dbb135631eb1db6e96cde1c907d95a0ee5a8fca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static long getLastModified(\n\t\tServletContext servletContext, String resourcePath, boolean cache) {\n\n\t\tif (resourcePath.startsWith(Http.HTTP) ||\n\t\t\tresourcePath.startsWith(Http.HTTPS)) {\n\n\t\t\tint pos = resourcePath.indexOf(Http.PROTOCOL_DELIMITER);\n\n\t\t\tresourcePath = resourcePath.substring(pos + 3);\n\t\t}\n\n\t\tint pos = resourcePath.indexOf(StringPool.SLASH);\n\n\t\tif (pos != -1) {\n\t\t\tresourcePath = resourcePath.substring(pos);\n\t\t}\n\n\t\tif (cache) {\n\t\t\tLong lastModified = (Long)servletContext.getAttribute(\n\t\t\t\tServletContextUtil.class.getName() + StringPool.PERIOD +\n\t\t\t\t\tresourcePath);\n\n\t\t\tif (lastModified != null) {\n\t\t\t\treturn lastModified.longValue();\n\t\t\t}\n\t\t}\n\n\t\tlong lastModified = 0;\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tresourcePath);\n\n\t\tif (resourcePaths != null) {\n\t\t\tfor (String curResourcePath : resourcePaths) {\n\t\t\t\tif (curResourcePath.endsWith(StringPool.SLASH)) {\n\t\t\t\t\tlong curLastModified = getLastModified(\n\t\t\t\t\t\tservletContext, curResourcePath);\n\n\t\t\t\t\tif (curLastModified > lastModified) {\n\t\t\t\t\t\tlastModified = curLastModified;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tFile file = new File(\n\t\t\t\t\t\tservletContext.getRealPath(curResourcePath));\n\n\t\t\t\t\tif (file.lastModified() > lastModified) {\n\t\t\t\t\t\tlastModified = file.lastModified();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cache) {\n\t\t\tservletContext.setAttribute(\n\t\t\t\tServletContextUtil.class.getName() + StringPool.PERIOD +\n\t\t\t\t\tresourcePath,\n\t\t\t\tnew Long(lastModified));\n\t\t}\n\n\t\treturn lastModified;\n\t}","id":76036,"modified_method":"public static long getLastModified(\n\t\tServletContext servletContext, String resourcePath, boolean cache) {\n\n\t\tif (resourcePath.startsWith(Http.HTTP) ||\n\t\t\tresourcePath.startsWith(Http.HTTPS)) {\n\n\t\t\tint pos = resourcePath.indexOf(Http.PROTOCOL_DELIMITER);\n\n\t\t\tresourcePath = resourcePath.substring(pos + 3);\n\t\t}\n\n\t\tint pos = resourcePath.indexOf(StringPool.SLASH);\n\n\t\tif (pos != -1) {\n\t\t\tresourcePath = resourcePath.substring(pos);\n\t\t}\n\n\t\tif (cache) {\n\t\t\tLong lastModified = (Long)servletContext.getAttribute(\n\t\t\t\tServletContextUtil.class.getName() + StringPool.PERIOD +\n\t\t\t\t\tresourcePath);\n\n\t\t\tif (lastModified != null) {\n\t\t\t\treturn lastModified.longValue();\n\t\t\t}\n\t\t}\n\n\t\tlong lastModified = 0;\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tresourcePath);\n\n\t\tif (resourcePaths != null) {\n\t\t\tfor (String curResourcePath : resourcePaths) {\n\t\t\t\tif (curResourcePath.endsWith(StringPool.SLASH)) {\n\t\t\t\t\tlong curLastModified = getLastModified(\n\t\t\t\t\t\tservletContext, curResourcePath);\n\n\t\t\t\t\tif (curLastModified > lastModified) {\n\t\t\t\t\t\tlastModified = curLastModified;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString realPath = servletContext.getRealPath(\n\t\t\t\t\t\tcurResourcePath);\n\n\t\t\t\t\tif (realPath == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tFile file = new File(realPath);\n\n\t\t\t\t\tif (file.lastModified() > lastModified) {\n\t\t\t\t\t\tlastModified = file.lastModified();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cache) {\n\t\t\tservletContext.setAttribute(\n\t\t\t\tServletContextUtil.class.getName() + StringPool.PERIOD +\n\t\t\t\t\tresourcePath,\n\t\t\t\tnew Long(lastModified));\n\t\t}\n\n\t\treturn lastModified;\n\t}","commit_id":"7783ab1e6b909d5e7d5bee07f21c823f2441b9e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public RunnerAndConfigurationSettings createConfigurationByLocation(Location location) {\n    PsiElement element = location.getPsiElement();\n    PsiFileSystemItem file = element instanceof PsiDirectory ? (PsiDirectory) element : element.getContainingFile();\n    if (file == null) return null;\n    String path = file.getVirtualFile().getPath();\n\n    final RunnerAndConfigurationSettings result =\n      RunManager.getInstance(location.getProject()).createRunConfiguration(file.getName(), myPyTestConfigurationFactory);\n    PyTestRunConfiguration configuration = (PyTestRunConfiguration)result.getConfiguration();\n    configuration.setUseModuleSdk(true);\n    configuration.setModule(ModuleUtil.findModuleForPsiElement(element));\n\n    if (!new File(configuration.getRunnerScriptPath()).exists()) {\n      return null;\n    }\n\n    configuration.setTestToRun(path);\n\n    PyFunction pyFunction = findTestFunction(location);\n    if (pyFunction != null) {\n      String name = pyFunction.getName();\n      configuration.setKeywords(name);\n      configuration.setName(name + \" in \" + configuration.getName());\n    }\n    return result;\n  }","id":76037,"modified_method":"public RunnerAndConfigurationSettings createConfigurationByLocation(Location location) {\n    PsiElement element = location.getPsiElement();\n    PsiFileSystemItem file = element instanceof PsiDirectory ? (PsiDirectory) element : element.getContainingFile();\n    if (file == null) return null;\n    String path = file.getVirtualFile().getPath();\n\n    final RunnerAndConfigurationSettings result =\n      RunManager.getInstance(location.getProject()).createRunConfiguration(file.getName(), myPyTestConfigurationFactory);\n    PyTestRunConfiguration configuration = (PyTestRunConfiguration)result.getConfiguration();\n    configuration.setUseModuleSdk(true);\n    configuration.setModule(ModuleUtil.findModuleForPsiElement(element));\n\n    final String scriptPath = configuration.getRunnerScriptPath();\n    if (scriptPath == null || !new File(scriptPath).exists()) {\n      return null;\n    }\n\n    configuration.setTestToRun(path);\n\n    PyFunction pyFunction = findTestFunction(location);\n    if (pyFunction != null) {\n      String name = pyFunction.getName();\n      configuration.setKeywords(name);\n      configuration.setName(name + \" in \" + configuration.getName());\n    }\n    return result;\n  }","commit_id":"71bbb7012b27f4c493857d0d19cc77e3ebdea3d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected RunContentDescriptor doExecute(Project project, Executor executor, RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    final ServerSocket serverSocket;\n    try {\n      //noinspection SocketOpenedButNotSafelyClosed\n      serverSocket = new ServerSocket(0);\n    }\n    catch (IOException e) {\n      throw new ExecutionException(\"Failed to find free socket port\", e);\n    }\n\n    PythonCommandLineState pyState = (PythonCommandLineState) state;\n    final CommandLinePatcher debug_server_patcher = new CommandLinePatcher() {\n      public void patchCommandLine(GeneralCommandLine commandLine) {\n        final String[] args = new String[]{\n          PythonHelpersLocator.getHelperPath(\"pydev/pydevd.py\"),\n          \"--client\", \"127.0.0.1\",\n          \"--port\", String.valueOf(serverSocket.getLocalPort()),\n          \"--file\"\n        };\n        for (int i = 0; i < args.length; i++) {\n          commandLine.getParametersList().addAt(i, args[i]);\n        }\n      }\n    };\n    RunProfile profile = env.getRunProfile();\n    CommandLinePatcher run_config_patcher = null;\n    if (state instanceof PythonCommandLineState && profile instanceof PythonRunConfiguration) {\n      run_config_patcher = (PythonRunConfiguration)profile;\n    }\n    final ExecutionResult result = pyState.execute(debug_server_patcher, run_config_patcher);\n\n    final XDebugSession session = XDebuggerManager.getInstance(project).\n        startSession(this, env, contentToReuse, new XDebugProcessStarter() {\n          @NotNull\n          public XDebugProcess start(@NotNull final XDebugSession session) {\n            return new PyDebugProcess(session, serverSocket, result.getExecutionConsole(), result.getProcessHandler());\n          }\n        });\n    return session.getRunContentDescriptor();\n  }","id":76038,"modified_method":"protected RunContentDescriptor doExecute(Project project, Executor executor, RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    final ServerSocket serverSocket;\n    try {\n      //noinspection SocketOpenedButNotSafelyClosed\n      serverSocket = new ServerSocket(0);\n    }\n    catch (IOException e) {\n      throw new ExecutionException(\"Failed to find free socket port\", e);\n    }\n\n    PythonCommandLineState pyState = (PythonCommandLineState) state;\n    final CommandLinePatcher debug_server_patcher = new CommandLinePatcher() {\n      public void patchCommandLine(GeneralCommandLine commandLine) {\n        final String[] args = new String[]{\n          PythonHelpersLocator.getHelperPath(\"pydev/pydevd.py\"),\n          \"--client\", \"127.0.0.1\",\n          \"--port\", String.valueOf(serverSocket.getLocalPort()),\n          \"--file\"\n        };\n        // script name is the last parameter; all other params are for python interpreter; insert just before name\n        final ParametersList parameters_list = commandLine.getParametersList();\n        int parameter_offset = parameters_list.getList().size() - 1;\n        for (int i = 0; i < args.length; i++) {\n          parameters_list.addAt(i + parameter_offset, args[i]);\n        }\n      }\n    };\n    RunProfile profile = env.getRunProfile();\n    CommandLinePatcher run_config_patcher = null;\n    if (state instanceof PythonCommandLineState && profile instanceof PythonRunConfiguration) {\n      run_config_patcher = (PythonRunConfiguration)profile;\n    }\n    final ExecutionResult result = pyState.execute(debug_server_patcher, run_config_patcher);\n\n    final XDebugSession session = XDebuggerManager.getInstance(project).\n        startSession(this, env, contentToReuse, new XDebugProcessStarter() {\n          @NotNull\n          public XDebugProcess start(@NotNull final XDebugSession session) {\n            return new PyDebugProcess(session, serverSocket, result.getExecutionConsole(), result.getProcessHandler());\n          }\n        });\n    return session.getRunContentDescriptor();\n  }","commit_id":"8bc5a396f03f316e12ce133de7e9af72a2ac8bdc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getRunnerScriptPath() {\n    String sdkHome = getSdkHome();\n    String runnerExt = SystemInfo.isWindows ? \".exe\" : \"\";\n    File runner = new File(sdkHome, \"scripts/py.test\" + runnerExt);\n    return runner.getPath();\n  }","id":76039,"modified_method":"@Nullable\n  public String getRunnerScriptPath() {\n    // HACK -- current getSdkHome logic is somehow broken, because interpreter and its home are not linked\n    File bin_path = new File(getSdkHome()); // this is actually a binary path\n    final String PY_TEST = \"py.test\" + (SystemInfo.isWindows ? \".exe\" : \"\");\n    // poke around and see if we got something like runner\n    File runner = null;\n    File bin_dir = bin_path.getParentFile();\n    runner = new File(bin_dir, PY_TEST);\n    if (runner.exists()) return runner.getPath();\n    runner = new File(new File(bin_dir, \"scripts\"), PY_TEST);\n    if (runner.exists()) return runner.getPath();\n    runner = new File(new File(bin_dir.getParentFile(), \"scripts\"), PY_TEST);\n    if (runner.exists()) return runner.getPath();\n    return null;\n  }","commit_id":"8bc5a396f03f316e12ce133de7e9af72a2ac8bdc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    super.checkConfiguration();\n    if (!new File(getRunnerScriptPath()).exists()) {\n      throw new RuntimeConfigurationError(\"No py.test runner found in selected interpreter\");\n    }    \n  }","id":76040,"modified_method":"@Override\n  public void checkConfiguration() throws RuntimeConfigurationException {\n    super.checkConfiguration();\n    final String path = getRunnerScriptPath();\n    if (path == null || !new File(path).exists()) {\n      throw new RuntimeConfigurationError(\"No py.test runner found in selected interpreter\");\n    }    \n  }","commit_id":"8bc5a396f03f316e12ce133de7e9af72a2ac8bdc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected RunContentDescriptor doExecute(\n    Project project,\n    Executor executor,\n    RunProfileState state,\n    RunContentDescriptor contentToReuse,\n    ExecutionEnvironment env\n  ) throws ExecutionException\n  {\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    ExecutionResult executionResult;\n    RunProfile profile = env.getRunProfile();\n    if (state instanceof PythonCommandLineState && profile instanceof PythonRunConfiguration) {\n      executionResult = ((PythonCommandLineState)state).execute((PythonRunConfiguration)profile); // may patch env prior to run \n    }\n    else executionResult = state.execute(executor, this);\n    if (executionResult == null) return null;\n\n    final RunContentBuilder contentBuilder = new RunContentBuilder(project, this, executor);\n    contentBuilder.setExecutionResult(executionResult);\n    contentBuilder.setEnvironment(env);\n    return contentBuilder.showRunContent(contentToReuse);\n  }","id":76041,"modified_method":"@Override\n  protected RunContentDescriptor doExecute(\n    Project project,\n    Executor executor,\n    RunProfileState state,\n    RunContentDescriptor contentToReuse,\n    ExecutionEnvironment env\n  ) throws ExecutionException\n  {\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    ExecutionResult executionResult;\n    RunProfile profile = env.getRunProfile();\n    if (state instanceof PythonCommandLineState && profile instanceof CommandLinePatcher) {\n      executionResult = ((PythonCommandLineState)state).execute((CommandLinePatcher)profile);\n    }\n    else executionResult = state.execute(executor, this);\n    if (executionResult == null) return null;\n\n    final RunContentBuilder contentBuilder = new RunContentBuilder(project, this, executor);\n    contentBuilder.setExecutionResult(executionResult);\n    contentBuilder.setEnvironment(env);\n    return contentBuilder.showRunContent(contentToReuse);\n  }","commit_id":"8bc5a396f03f316e12ce133de7e9af72a2ac8bdc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addTestRunnerParameters(GeneralCommandLine cmd) {\n    ParamsGroup script_params = cmd.getParametersList().getParamsGroup(GROUP_SCRIPT);\n    assert script_params != null;\n    script_params.addParameter(myConfiguration.getRunnerScriptPath());\n    script_params.addParameters(\"-p\", \"pytest_teamcity\");\n    script_params.addParameters(getTestSpecs());\n\n  }","id":76042,"modified_method":"protected void addTestRunnerParameters(GeneralCommandLine cmd) throws ExecutionException {\n    ParamsGroup script_params = cmd.getParametersList().getParamsGroup(GROUP_SCRIPT);\n    assert script_params != null;\n    String runner = myConfiguration.getRunnerScriptPath();\n    if (runner == null)\n      throw new ExecutionException(\"No py.test runner found in selected interpreter\");\n    script_params.addParameter(runner);\n    script_params.addParameters(\"-p\", \"pytest_teamcity\");\n    script_params.addParameters(getTestSpecs());\n\n  }","commit_id":"5060301a4a90ddd9f9c7cf87be40c2b84eae7a6c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addDependencies(DependencyTree tree) throws IOException {\n        addPackages(tree);\n        List<DependencyTree> children = tree.getChildren();\n        for (DependencyTree child : children) {\n            if (excludePackageFilter.matches(child)) {\n                // ignore\n                LOG.debug(\"Excluded dependency: \" + child.getDependencyId());\n                continue;\n            } else if (excludeOptionalFilter.matches(child)) {\n                addOptionalDependency(child);\n                continue;\n            } else if (sharedFilter.matches(child) || requireBundleFilter.matches(child)) {\n                // lets add all the transitive dependencies as shared\n                addSharedDependency(child);\n            } else {\n                LOG.debug(\"Added non-shared dependency: \" + tree.getDependencyId());\n                nonSharedDependencies.add(child);\n                // we now need to recursively flatten all transitive dependencies (whether shared or not)\n                addDependencies(child);\n            }\n        }\n    }","id":76043,"modified_method":"protected void addDependencies(DependencyTree tree) throws IOException {\n        addPackages(tree);\n        List<DependencyTree> children = tree.getChildren();\n        for (DependencyTree child : children) {\n            addChildDependency(child);\n        }\n    }","commit_id":"625b7901361da6625bc506f87817927b4e07426a","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void resolve() throws RepositoryException, IOException, XmlPullParserException, BundleException {\n        PomDetails pomDetails = connection.resolvePomDetails();\n        if (!pomDetails.isValid()) {\n            LOG.warn(\"Cannot resolve pom.xml for \" + connection.getJarFile());\n            return;\n        }\n        DependencyTreeResult result = resolver.collectDependencies(pomDetails, offline);\n        this.rootTree = result.getTree();\n\n        String sharedFilterText = getManfiestProperty(ServiceConstants.INSTR_FAB_PROVIDED_DEPENDENCY);\n        String requireBundleFilterText = getManfiestProperty(ServiceConstants.INSTR_FAB_DEPENDENCY_REQUIRE_BUNDLE);\n        String excludeFilterText = getManfiestProperty(ServiceConstants.INSTR_FAB_EXCLUDE_DEPENDENCY);\n        String optionalDependencyText = getManfiestProperty(ServiceConstants.INSTR_FAB_OPTIONAL_DEPENDENCY);\n\n        sharedFilter = DependencyTreeFilters.parseShareFilter(sharedFilterText);\n        requireBundleFilter = DependencyTreeFilters.parseRequireBundleFilter(requireBundleFilterText);\n        excludePackageFilter = DependencyTreeFilters.parseExcludeFilter(excludeFilterText);\n        excludeOptionalFilter = DependencyTreeFilters.parseExcludeOptionalFilter(optionalDependencyText);\n\n        bundleClassPath.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH), \",\"));\n        requireBundles.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE), \",\"));\n        importPackages.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_IMPORT_PACKAGE), \",\"));\n\n\n        String name = getManfiestProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME);\n        if (name.length() <= 0) {\n            name = rootTree.getBundleSymbolicName();\n            instructions.setProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME, name);\n        }\n\n        LOG.debug(\"Resolving Dependencies for: \"+rootTree.getDependencyId());\n        addDependencies(rootTree);\n\n        // Build a ModuleDescriptor using the Jar Manifests headers..\n        Model model = pomDetails.getModel();\n        moduleId = new VersionedDependencyId(model);\n        ModuleRegistry.VersionedModule module = moduleRegistry.getVersionedModule(moduleId);\n        if( module==null || module.getFile()!=null ) {\n            registerModule(model);\n        }\n        resolveExtensions(model, rootTree);\n\n        for (DependencyTree dependencyTree : sharedDependencies) {\n            if (requireBundleFilter.matches(dependencyTree)) {\n                // lets figure out the bundle ID etc...\n                String bundleId = dependencyTree.getBundleSymbolicName();\n                Version version = new Version(VersionCleaner.clean(dependencyTree.getVersion()));\n                requireBundles.add(bundleId + \";bundle-version=\" + version + \"\");\n            } else {\n                // TODO don't think we need to do anything now since already the BND stuff figures out the import packages for any missing stuff?\n                if (processImportPackages) {\n                    // lets add all the import packages...\n                    importAllExportedPackages(dependencyTree);\n                }\n            }\n        }\n\n        for (DependencyTree dependencyTree : nonSharedDependencies) {\n            if (dependencyTree.isValidLibrary()) {\n                String url = dependencyTree.getUrl();\n                if (url != null) {\n                    String path = dependencyTree.getGroupId() + \".\" + dependencyTree.getArtifactId() + \".jar\";\n\n                    if (!bundleClassPath.contains(path)) {\n                        // try use a file if it exists\n                        File file = new File(url);\n                        if (file.exists()) {\n                            embeddedResources.put(path, file);\n                        } else {\n                            embeddedResources.put(path, new URL(url));\n                        }\n                        addBundleClassPath(path);\n                    }\n                }\n            }\n        }\n\n        // Remove dup dependencies..\n        nonSharedDependencies = filterOutDuplicates(nonSharedDependencies);\n        sharedDependencies = filterOutDuplicates(sharedDependencies);\n        installDependencies = filterOutDuplicates(installDependencies);\n        optionalDependencies = filterOutDuplicates(optionalDependencies);\n\n        LOG.debug(\"nonSharedDependencies:\");\n        for( DependencyTree d : nonSharedDependencies) {\n            LOG.debug(\"  \"+d.getDependencyId());\n        }\n        LOG.debug(\"sharedDependencies:\");\n        for( DependencyTree d : sharedDependencies) {\n            LOG.debug(\"  \"+d.getDependencyId());\n        }\n        LOG.debug(\"installDependencies:\");\n        for( DependencyTree d : installDependencies) {\n            LOG.debug(\"  \"+d.getDependencyId());\n        }\n\n        LOG.debug(\"resolved: bundleClassPath: \" + Strings.join(bundleClassPath, \"\\t\\n\"));\n        LOG.debug(\"resolved: requireBundles: \" + Strings.join(requireBundles, \"\\t\\n\"));\n        LOG.debug(\"resolved: importPackages: \" + Strings.join(importPackages, \"\\t\\n\"));\n\n        instructions.setProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH, Strings.join(bundleClassPath, \",\"));\n        instructions.setProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE, Strings.join(requireBundles, \",\"));\n        instructions.setProperty(ServiceConstants.INSTR_FAB_MODULE_ID, moduleId.toString());\n    }","id":76044,"modified_method":"public void resolve() throws RepositoryException, IOException, XmlPullParserException, BundleException {\n        PomDetails pomDetails = connection.resolvePomDetails();\n        if (!pomDetails.isValid()) {\n            LOG.warn(\"Cannot resolve pom.xml for \" + connection.getJarFile());\n            return;\n        }\n        DependencyTreeResult result = resolver.collectDependencies(pomDetails, offline);\n        this.rootTree = result.getTree();\n\n        sharedFilterText = emptyIfNull(getManfiestProperty(ServiceConstants.INSTR_FAB_PROVIDED_DEPENDENCY));\n        requireBundleFilterText = emptyIfNull(getManfiestProperty(ServiceConstants.INSTR_FAB_DEPENDENCY_REQUIRE_BUNDLE));\n        excludeFilterText = emptyIfNull(getManfiestProperty(ServiceConstants.INSTR_FAB_EXCLUDE_DEPENDENCY));\n        optionalDependencyText = emptyIfNull(getManfiestProperty(ServiceConstants.INSTR_FAB_OPTIONAL_DEPENDENCY));\n\n        sharedFilter = DependencyTreeFilters.parseShareFilter(sharedFilterText.trim());\n        requireBundleFilter = DependencyTreeFilters.parseRequireBundleFilter(requireBundleFilterText.trim());\n        excludePackageFilter = DependencyTreeFilters.parseExcludeFilter(excludeFilterText.trim());\n        excludeOptionalFilter = DependencyTreeFilters.parseExcludeOptionalFilter(optionalDependencyText.trim());\n\n        bundleClassPath.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH), \",\"));\n        requireBundles.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE), \",\"));\n        importPackages.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_IMPORT_PACKAGE), \",\"));\n\n\n        String name = getManfiestProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME);\n        if (name.length() <= 0) {\n            name = rootTree.getBundleSymbolicName();\n            instructions.setProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME, name);\n        }\n\n        LOG.debug(\"Resolving Dependencies for: \"+rootTree.getDependencyId());\n        addDependencies(rootTree);\n\n        // Build a ModuleDescriptor using the Jar Manifests headers..\n        Model model = pomDetails.getModel();\n        moduleId = new VersionedDependencyId(model);\n        ModuleRegistry.VersionedModule module = moduleRegistry.getVersionedModule(moduleId);\n        if( module==null || module.getFile()!=null ) {\n            registerModule(model);\n        }\n\n        resolveExtensions(model, rootTree);\n\n        for (DependencyTree dependencyTree : sharedDependencies) {\n            if (requireBundleFilter.matches(dependencyTree)) {\n                // lets figure out the bundle ID etc...\n                String bundleId = dependencyTree.getBundleSymbolicName();\n                Version version = new Version(VersionCleaner.clean(dependencyTree.getVersion()));\n                requireBundles.add(bundleId + \";bundle-version=\" + version + \"\");\n            } else {\n                // TODO don't think we need to do anything now since already the BND stuff figures out the import packages for any missing stuff?\n                if (processImportPackages) {\n                    // lets add all the import packages...\n                    importAllExportedPackages(dependencyTree);\n                }\n            }\n        }\n\n        for (DependencyTree dependencyTree : nonSharedDependencies) {\n            if (dependencyTree.isValidLibrary()) {\n                String url = dependencyTree.getUrl();\n                if (url != null) {\n                    String path = dependencyTree.getGroupId() + \".\" + dependencyTree.getArtifactId() + \".jar\";\n\n                    if (!bundleClassPath.contains(path)) {\n                        // try use a file if it exists\n                        File file = new File(url);\n                        if (file.exists()) {\n                            embeddedResources.put(path, file);\n                        } else {\n                            embeddedResources.put(path, new URL(url));\n                        }\n                        addBundleClassPath(path);\n                    }\n                }\n            }\n        }\n\n        // Remove dup dependencies..\n        nonSharedDependencies = filterOutDuplicates(nonSharedDependencies);\n        sharedDependencies = filterOutDuplicates(sharedDependencies);\n        installDependencies = filterOutDuplicates(installDependencies);\n        optionalDependencies = filterOutDuplicates(optionalDependencies);\n\n        LOG.debug(\"nonSharedDependencies:\");\n        for( DependencyTree d : nonSharedDependencies) {\n            LOG.debug(\"  \"+d.getDependencyId());\n        }\n        LOG.debug(\"sharedDependencies:\");\n        for( DependencyTree d : sharedDependencies) {\n            LOG.debug(\"  \"+d.getDependencyId());\n        }\n        LOG.debug(\"installDependencies:\");\n        for( DependencyTree d : installDependencies) {\n            LOG.debug(\"  \"+d.getDependencyId());\n        }\n\n        LOG.debug(\"resolved: bundleClassPath: \" + Strings.join(bundleClassPath, \"\\t\\n\"));\n        LOG.debug(\"resolved: requireBundles: \" + Strings.join(requireBundles, \"\\t\\n\"));\n        LOG.debug(\"resolved: importPackages: \" + Strings.join(importPackages, \"\\t\\n\"));\n\n        instructions.setProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH, Strings.join(bundleClassPath, \",\"));\n        instructions.setProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE, Strings.join(requireBundles, \",\"));\n        instructions.setProperty(ServiceConstants.INSTR_FAB_MODULE_ID, moduleId.toString());\n    }","commit_id":"625b7901361da6625bc506f87817927b4e07426a","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void resolveExtensions(Model model, DependencyTree root) throws IOException, RepositoryException, XmlPullParserException {\n        ModuleRegistry.VersionedModule module = moduleRegistry.getVersionedModule(moduleId);\n        if( module!=null ) {\n            Map<String, ModuleRegistry.VersionedModule> availableExtensions = module.getAvailableExtensions();\n            String extensionsString=\"\";\n            for (String enabledExtension : module.getEnabledExtensions()) {\n                ModuleRegistry.VersionedModule extensionModule = availableExtensions.get(enabledExtension);\n                if( extensionModule!=null ) {\n                    VersionedDependencyId id = extensionModule.getId();\n\n                    // lets resolve the dependency\n                    DependencyTreeResult result = resolver.collectDependencies(id.getGroupId(), id.getArtifactId(), id.getVersion(), id.getExtension(), id.getClassifier());\n                    if (result != null) {\n                        DependencyTree tree = result.getTree();\n                        LOG.debug(\"Adding extension: \" + tree.getDependencyId());\n                        if( extensionsString.length()!=0 ) {\n                            extensionsString += \" \";\n                        }\n                        extensionsString += id;\n                        addExtensionDependencies(tree);\n                    } else {\n                        LOG.debug(\"Could not resolve extension: \" + id);\n                    }\n                }\n            }\n            if( extensionsString.length()!= 0 ) {\n                instructions.put(ServiceConstants.INSTR_FAB_MODULE_ENABLED_EXTENSIONS, extensionsString);\n            }\n        }\n    }","id":76045,"modified_method":"protected void resolveExtensions(Model model, DependencyTree root) throws IOException, RepositoryException, XmlPullParserException {\n        ModuleRegistry.VersionedModule module = moduleRegistry.getVersionedModule(moduleId);\n        if( module!=null ) {\n            Map<String, ModuleRegistry.VersionedModule> availableExtensions = module.getAvailableExtensions();\n            String extensionsString=\"\";\n            for (String enabledExtension : module.getEnabledExtensions()) {\n                ModuleRegistry.VersionedModule extensionModule = availableExtensions.get(enabledExtension);\n                if( extensionModule!=null ) {\n                    VersionedDependencyId id = extensionModule.getId();\n\n                    // lets resolve the dependency\n                    DependencyTreeResult result = resolver.collectDependencies(id.getGroupId(), id.getArtifactId(), id.getVersion(), id.getExtension(), id.getClassifier());\n\n                    if (result != null) {\n                        DependencyTree tree = result.getTree();\n\n                        sharedFilterText += \" \" + emptyIfNull(tree.getManfiestEntry(ServiceConstants.INSTR_FAB_PROVIDED_DEPENDENCY));\n                        requireBundleFilterText += \" \" + emptyIfNull(tree.getManfiestEntry(ServiceConstants.INSTR_FAB_DEPENDENCY_REQUIRE_BUNDLE));\n                        excludeFilterText += \" \" + emptyIfNull(tree.getManfiestEntry(ServiceConstants.INSTR_FAB_EXCLUDE_DEPENDENCY));\n                        optionalDependencyText += \" \" + emptyIfNull(tree.getManfiestEntry(ServiceConstants.INSTR_FAB_OPTIONAL_DEPENDENCY));\n\n                        sharedFilter = DependencyTreeFilters.parseShareFilter(sharedFilterText.trim());\n                        requireBundleFilter = DependencyTreeFilters.parseRequireBundleFilter(requireBundleFilterText.trim());\n                        excludePackageFilter = DependencyTreeFilters.parseExcludeFilter(excludeFilterText.trim());\n                        excludeOptionalFilter = DependencyTreeFilters.parseExcludeOptionalFilter(optionalDependencyText.trim());\n\n                        LOG.debug(\"Adding extension: \" + tree.getDependencyId());\n                        if( extensionsString.length()!=0 ) {\n                            extensionsString += \" \";\n                        }\n                        extensionsString += id;\n                        addChildDependency(tree);\n\n                    } else {\n                        LOG.debug(\"Could not resolve extension: \" + id);\n                    }\n                }\n            }\n            if( extensionsString.length()!= 0 ) {\n                instructions.put(ServiceConstants.INSTR_FAB_MODULE_ENABLED_EXTENSIONS, extensionsString);\n            }\n        }\n    }","commit_id":"625b7901361da6625bc506f87817927b4e07426a","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void addExtensionDependencies(DependencyTree child) throws IOException {\n        LOG.debug(\"Added extension dependency: \" + child.getDependencyId());\n        if (excludePackageFilter.matches(child)) {\n            // ignore\n            LOG.debug(\"Excluded dependency: \" + child.getDependencyId());\n        } else if (excludeOptionalFilter.matches(child)) {\n            LOG.debug(\"Excluded optional dependency: \" + child.getDependencyId());\n        } else if (sharedFilter.matches(child) || requireBundleFilter.matches(child)) {\n            // lets add all the transitive dependencies as shared\n            addSharedDependency(child);\n        } else {\n            nonSharedDependencies.add(child);\n            // we now need to recursively flatten all transitive dependencies (whether shared or not)\n            addDependencies(child);\n        }\n    }","id":76046,"modified_method":"private void addChildDependency(DependencyTree child) throws IOException {\n        String dependencyId = child.getDependencyId().toString();\n        if( dependencyId.contains(\"jetty-all-server\") ) {\n            LOG.debug(\"test\");\n        }\n        if (excludePackageFilter.matches(child)) {\n            // ignore\n            LOG.debug(\"Excluded dependency: \" + dependencyId);\n            return;\n        } else if (excludeOptionalFilter.matches(child)) {\n            addOptionalDependency(child);\n            return;\n        } else if (sharedFilter.matches(child) || requireBundleFilter.matches(child)) {\n            // lets add all the transitive dependencies as shared\n            addSharedDependency(child);\n        } else {\n            LOG.debug(\"Added non-shared dependency: \" + dependencyId);\n            nonSharedDependencies.add(child);\n            // we now need to recursively flatten all transitive dependencies (whether shared or not)\n            addDependencies(child);\n        }\n    }","commit_id":"625b7901361da6625bc506f87817927b4e07426a","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private Map<String, Object> _convertObjectToMap(\n\t\tStatement statement, Object object, String prefix) {\n\n\t\tif (object instanceof Map) {\n\t\t\treturn (Map<String, Object>)object;\n\t\t}\n\n\t\tClass<?> clazz = object.getClass();\n\n\t\tHashMap destinationMap = new HashMap();\n\n\t\tBeanCopy\n\t\t\t.beans(object, destinationMap)\n\t\t\t.exclude(JSONIncludesManagerUtil.lookupExcludes(clazz))\n\t\t\t.copy();\n\n\t\tobject = destinationMap;\n\n\t\tString[] includes = JSONIncludesManagerUtil.lookupIncludes(clazz);\n\n\t\tfor (String include : includes) {\n\t\t\tif (Validator.isNotNull(prefix)) {\n\t\t\t\tinclude = prefix + StringPool.PERIOD + include;\n\t\t\t}\n\n\t\t\t_addInclude(statement, include);\n\t\t}\n\n\t\treturn (Map<String, Object>)object;\n\t}","id":76047,"modified_method":"private Map<String, Object> _convertObjectToMap(\n\t\tStatement statement, Object object, String prefix) {\n\n\t\tif (object instanceof Map) {\n\t\t\treturn (Map<String, Object>)object;\n\t\t}\n\n\t\tClass<?> clazz = object.getClass();\n\n\t\tHashMap<Object, Object> destinationMap = new HashMap<Object, Object>();\n\n\t\tBeanCopy beanCopy = BeanCopy.beans(object, destinationMap);\n\n\t\tbeanCopy.exclude(JSONIncludesManagerUtil.lookupExcludes(clazz));\n\n\t\tbeanCopy.copy();\n\n\t\tobject = destinationMap;\n\n\t\tString[] includes = JSONIncludesManagerUtil.lookupIncludes(clazz);\n\n\t\tfor (String include : includes) {\n\t\t\tif (Validator.isNotNull(prefix)) {\n\t\t\t\tinclude = prefix + StringPool.PERIOD + include;\n\t\t\t}\n\n\t\t\t_addInclude(statement, include);\n\t\t}\n\n\t\treturn (Map<String, Object>)object;\n\t}","commit_id":"808d79a552142f969a9c6f42fbe4aa1f6c6f9eb1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void copyProperties(\n\t\tObject source, Object target, Class<?> editable) {\n\n\t\ttry {\n\t\t\tBeanCopy.beans(source, target).includeAs(editable).copy();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":76048,"modified_method":"public void copyProperties(\n\t\tObject source, Object target, Class<?> editable) {\n\n\t\ttry {\n\t\t\tBeanCopy beanCopy = BeanCopy.beans(source, target);\n\n\t\t\tbeanCopy.includeAs(editable);\n\n\t\t\tbeanCopy.copy();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"fdcb1ee6ab90a86271f848888e2a85a6c0e3aafe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void copyProperties(\n\t\tObject source, Object target, String[] ignoreProperties) {\n\n\t\ttry {\n\t\t\tBeanCopy.beans(source, target).exclude(ignoreProperties).copy();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":76049,"modified_method":"public void copyProperties(\n\t\tObject source, Object target, String[] ignoreProperties) {\n\n\t\ttry {\n\t\t\tBeanCopy beanCopy = BeanCopy.beans(source, target);\n\n\t\t\tbeanCopy.exclude(ignoreProperties);\n\n\t\t\tbeanCopy.copy();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"fdcb1ee6ab90a86271f848888e2a85a6c0e3aafe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void copyProperties(Object source, Object target) {\n\t\ttry {\n\t\t\tBeanCopy.beans(source, target).copy();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":76050,"modified_method":"public void copyProperties(Object source, Object target) {\n\t\ttry {\n\t\t\tBeanCopy beanCopy = BeanCopy.beans(source, target);\n\n\t\t\tbeanCopy.copy();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"fdcb1ee6ab90a86271f848888e2a85a6c0e3aafe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public FieldVisitor visitField(\n\t\t\tint access, String name, String desc, String signature,\n\t\t\tObject value) {\n\n\t\treturn null;\n\t}","id":76051,"modified_method":"public FieldVisitor visitField(\n\t\tint access, String name, String description, String signature,\n\t\tObject value) {\n\n\t\treturn null;\n\t}","commit_id":"fdcb1ee6ab90a86271f848888e2a85a6c0e3aafe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MethodVisitor visitMethod(\n\t\t\tint access, String name, String desc, String signature,\n\t\t\tString[] exceptions) {\n\n\t\treturn null;\n\t}","id":76052,"modified_method":"public MethodVisitor visitMethod(\n\t\tint access, String name, String description, String signature,\n\t\tString[] exceptions) {\n\n\t\treturn null;\n\t}","commit_id":"fdcb1ee6ab90a86271f848888e2a85a6c0e3aafe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n\t\treturn null;\n\t}","id":76053,"modified_method":"public AnnotationVisitor visitAnnotation(\n\t\tString description, boolean visible) {\n\n\t\treturn null;\n\t}","commit_id":"fdcb1ee6ab90a86271f848888e2a85a6c0e3aafe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected File[] getPluginClassPathFiles() throws SystemException {\n\t\tClassLoader classLoader =\n\t\t\t_baseJSONWebServiceConfigurator.getClassLoader();\n\n\t\tURL servicePropertiesURL = classLoader.getResource(\n\t\t\t\"service.properties\");\n\n\t\tString servicePropertiesPath = null;\n\n\t\ttry {\n\t\t\tservicePropertiesPath = URLDecoder.decode(\n\t\t\t\tservicePropertiesURL.getPath(), StringPool.UTF8);\n\t\t}\n\t\tcatch (UnsupportedEncodingException uee) {\n\t\t\tthrow new SystemException(uee);\n\t\t}\n\n\t\tFile classPathFile = null;\n\n\t\tFile libDir = null;\n\n\t\tint pos = servicePropertiesPath.indexOf(\"_wl_cls_gen.jar!\");\n\n\t\tif (pos != -1) {\n\t\t\tString wlClsGenJarPath = servicePropertiesPath.substring(\n\t\t\t\t0, pos + 15);\n\n\t\t\tclassPathFile = new File(wlClsGenJarPath);\n\n\t\t\tlibDir = new File(classPathFile.getParent());\n\t\t}\n\t\telse {\n\t\t\tFile servicePropertiesFile = new File(servicePropertiesPath);\n\n\t\t\tclassPathFile = servicePropertiesFile.getParentFile();\n\n\t\t\tlibDir = new File(classPathFile.getParent(), \"lib\");\n\t\t}\n\n\t\tList<File> classPaths = new ArrayList<File>();\n\n\t\tclassPaths.add(classPathFile);\n\n\t\tFindFile findFile = new RegExpFindFile(\n\t\t\t\".*-(hook|portlet|web)-service.*\\\\.jar\");\n\n\t\tfindFile.searchPath(libDir);\n\n\t\tFile file = null;\n\n\t\twhile ((file = findFile.nextFile()) != null) {\n\t\t\tif (classPaths.contains(file)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclassPaths.add(file);\n\t\t}\n\n\t\tFile classesDir = new File(libDir.getParent(), \"classes\");\n\n\t\tif (!classPaths.contains(classesDir)) {\n\t\t\tclassPaths.add(classesDir);\n\t\t}\n\n\t\treturn classPaths.toArray(new File[classPaths.size()]);\n\t}","id":76054,"modified_method":"protected File[] getPluginClassPathFiles() throws SystemException {\n\t\tClassLoader classLoader =\n\t\t\t_baseJSONWebServiceConfigurator.getClassLoader();\n\n\t\tURL servicePropertiesURL = classLoader.getResource(\n\t\t\t\"service.properties\");\n\n\t\tString servicePropertiesPath = null;\n\n\t\ttry {\n\t\t\tservicePropertiesPath = URLDecoder.decode(\n\t\t\t\tservicePropertiesURL.getPath(), StringPool.UTF8);\n\t\t}\n\t\tcatch (UnsupportedEncodingException uee) {\n\t\t\tthrow new SystemException(uee);\n\t\t}\n\n\t\tFile classPathFile = null;\n\n\t\tFile libDir = null;\n\n\t\tint pos = servicePropertiesPath.indexOf(\"_wl_cls_gen.jar!\");\n\n\t\tif (pos != -1) {\n\t\t\tString wlClsGenJarPath = servicePropertiesPath.substring(\n\t\t\t\t0, pos + 15);\n\n\t\t\tclassPathFile = new File(wlClsGenJarPath);\n\n\t\t\tlibDir = new File(classPathFile.getParent());\n\t\t}\n\t\telse {\n\t\t\tFile servicePropertiesFile = new File(servicePropertiesPath);\n\n\t\t\tclassPathFile = servicePropertiesFile.getParentFile();\n\n\t\t\tlibDir = new File(classPathFile.getParent(), \"lib\");\n\t\t}\n\n\t\tList<File> classPaths = new ArrayList<File>();\n\n\t\tclassPaths.add(classPathFile);\n\n\t\tFindFile<?> findFile = new RegExpFindFile(\n\t\t\t\".*-(hook|portlet|web)-service.*\\\\.jar\");\n\n\t\tfindFile.searchPath(libDir);\n\n\t\tFile file = null;\n\n\t\twhile ((file = findFile.nextFile()) != null) {\n\t\t\tif (classPaths.contains(file)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclassPaths.add(file);\n\t\t}\n\n\t\tFile classesDir = new File(libDir.getParent(), \"classes\");\n\n\t\tif (!classPaths.contains(classesDir)) {\n\t\t\tclassPaths.add(classesDir);\n\t\t}\n\n\t\treturn classPaths.toArray(new File[classPaths.size()]);\n\t}","commit_id":"fdcb1ee6ab90a86271f848888e2a85a6c0e3aafe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void update() {\n        Task<?> task = updateAsync();\n        task.getUnchecked();\n    }","id":76055,"modified_method":"@Override\n    public void update() {\n        Task<?> task = updateAsync();\n        if (task != null) task.getUnchecked();\n    }","commit_id":"393a95c65bafdae203393006e634d05857dcc2c2","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  public void init(String[] args) {\n    Injector injector = Guice.createInjector(new ConfigModule(),\n                                             new IOModule(),\n                                             new SecurityModules().getDistributedModules(),\n                                             new DiscoveryRuntimeModule().getDistributedModules(),\n                                             new ZKClientModule());\n    this.zkClientService = injector.getInstance(ZKClientService.class);\n    this.authServer = injector.getInstance(ExternalAuthenticationServer.class);\n  }","id":76056,"modified_method":"@Override\n  public void init(String[] args) {\n    Injector injector = Guice.createInjector(new ConfigModule(),\n                                             new IOModule(),\n                                             new SecurityModules().getDistributedModules(),\n                                             new DiscoveryRuntimeModule().getDistributedModules(),\n                                             new ZKClientModule());\n    CConfiguration configuration = injector.getInstance(CConfiguration.class);\n\n    if (configuration.getBoolean(Constants.Security.CFG_SECURITY_ENABLED)) {\n      this.zkClientService = injector.getInstance(ZKClientService.class);\n      this.authServer = injector.getInstance(ExternalAuthenticationServer.class);\n    }\n  }","commit_id":"39028c0883a61ce68c7c324f0daccccec0c9560b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void stop() {\n    Futures.getUnchecked(Services.chainStop(authServer, zkClientService));\n  }","id":76057,"modified_method":"@Override\n  public void stop() {\n    if (authServer != null) {\n      LOG.info(\"Stopping AuthenticationServer.\");\n      Futures.getUnchecked(Services.chainStop(authServer, zkClientService));\n    }\n  }","commit_id":"39028c0883a61ce68c7c324f0daccccec0c9560b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void start() {\n    Services.chainStart(zkClientService, authServer);\n  }","id":76058,"modified_method":"@Override\n  public void start() {\n    if (authServer != null) {\n      LOG.info(\"Starting AuthenticationServer.\");\n      Services.chainStart(zkClientService, authServer);\n    } else {\n      LOG.info(\"AuthenticationServer not started since security is disabled.\");\n    }\n  }","commit_id":"39028c0883a61ce68c7c324f0daccccec0c9560b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Opportunity to do late-binding of the cluster that is being controlled. Must be called before start().\n     * Can pass in the 'cluster'.\n     */\n    @Override\n    public void bind(Map flags) {\n        if (flags.containsKey(\"serverPool\")) {\n            setConfigEvenIfOwned(SERVER_POOL, (Group) flags.get(\"serverPool\"));\n        } else if (flags.containsKey(\"cluster\")) {\n            // @deprecated since 0.5.0\n            LOG.warn(\"Deprecated use of AbstractController.cluster: entity {}; value {}\", this, flags.get(\"cluster\"));\n            setConfigEvenIfOwned(SERVER_POOL, (Group) flags.get(\"cluster\"));\n        }\n    }","id":76059,"modified_method":"/**\n     * Opportunity to do late-binding of the cluster that is being controlled. Must be called before start().\n     * Can pass in the 'serverPool'.\n     */\n    @Override\n    public void bind(Map flags) {\n        if (flags.containsKey(\"serverPool\")) {\n            setConfigEvenIfOwned(SERVER_POOL, (Group) flags.get(\"serverPool\"));\n        } \n    }","commit_id":"75b189354912079e04645bc520b3dc1420d20282","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void update() {\n        Task<?> task = updateAsync();\n        task.getUnchecked();\n    }","id":76060,"modified_method":"@Override\n    public void update() {\n        Task<?> task = updateAsync();\n        if (task != null) task.getUnchecked();\n    }","commit_id":"75b189354912079e04645bc520b3dc1420d20282","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void onManagementNoLongerMaster() {\n        isActive = false;\n        serverPoolMemberTrackerPolicy.reset();\n    }","id":76061,"modified_method":"@Override\n    public void onManagementNoLongerMaster() {\n        super.onManagementNoLongerMaster(); // TODO remove when deprecated method in parent removed\n        isActive = false;\n        serverPoolMemberTrackerPolicy.reset();\n    }","commit_id":"75b189354912079e04645bc520b3dc1420d20282","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected synchronized void addServerPoolMember(Entity member) {\n        String oldAddress = serverPoolTargets.get(member);\n        String newAddress = getAddressOfEntity(member);\n        if (newAddress == null) {\n            if (oldAddress != null) {\n                LOG.info(\"Removing from {}, member {} with old address {}, because inferred address is now null\", new Object[] {this, member, oldAddress});\n                serverPoolAddresses.remove(oldAddress);\n            }\n            \n        } else {\n            if (oldAddress != null) {\n                LOG.info(\"Replacing in  {}, member {} with old address {}, new address {}\", new Object[] {this, member, oldAddress, newAddress});\n                serverPoolAddresses.remove(oldAddress);\n            } else {\n                LOG.info(\"Adding to {}, new member {} with address {}\", new Object[] {this, member, newAddress});\n            }\n            serverPoolAddresses.add(newAddress);\n        }\n        \n        if (Objects.equal(oldAddress, newAddress)) {\n            if (LOG.isTraceEnabled()) LOG.trace(\"For {}, ignoring change in member {} because address still {}\", new Object[] {this, member, newAddress});\n            return;\n        }\n        \n        // TODO this does it synchronously; an async method leaning on `updateNeeded` and `update` might\n        // be more appropriate, especially when this is used in a listener\n        updateAsync();\n        serverPoolTargets.put(member, newAddress);\n    }","id":76062,"modified_method":"protected synchronized void addServerPoolMember(Entity member) {\n        String oldAddress = serverPoolTargets.get(member);\n        String newAddress = getAddressOfEntity(member);\n        if (newAddress == null) {\n            if (oldAddress != null) {\n                LOG.info(\"Removing from {}, member {} with old address {}, because inferred address is now null\", new Object[] {this, member, oldAddress});\n                serverPoolAddresses.remove(oldAddress);\n            }\n        } else if (Objects.equal(newAddress, oldAddress)) {\n            if (LOG.isTraceEnabled())\n                LOG.trace(\"Ignoring unchanged address \"+oldAddress);\n            return;\n        } else {\n            if (oldAddress != null) {\n                LOG.info(\"Replacing in {}, member {} with old address {}, new address {}\", new Object[] {this, member, oldAddress, newAddress});\n                serverPoolAddresses.remove(oldAddress);\n            } else {\n                LOG.info(\"Adding to {}, new member {} with address {}\", new Object[] {this, member, newAddress});\n            }\n            serverPoolAddresses.add(newAddress);\n        }\n        \n        if (Objects.equal(oldAddress, newAddress)) {\n            if (LOG.isTraceEnabled()) LOG.trace(\"For {}, ignoring change in member {} because address still {}\", new Object[] {this, member, newAddress});\n            return;\n        }\n        \n        // TODO this does it synchronously; an async method leaning on `updateNeeded` and `update` might\n        // be more appropriate, especially when this is used in a listener\n        updateAsync();\n        serverPoolTargets.put(member, newAddress);\n    }","commit_id":"75b189354912079e04645bc520b3dc1420d20282","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    protected void preStart() {\n        super.preStart();\n\n        ConfigToAttributes.apply(this, DOMAIN_NAME);\n        setAttribute(PROTOCOL, inferProtocol());\n        setAttribute(ROOT_URL, inferUrl());\n \n        checkNotNull(getPortNumberSensor(), \"no sensor configured to infer port number\");\n    }","id":76063,"modified_method":"@Override\n    protected void preStart() {\n        super.preStart();\n\n        ConfigToAttributes.apply(this);\n\n        setAttribute(PROTOCOL, inferProtocol());\n        setAttribute(ROOT_URL, inferUrl());\n \n        checkNotNull(getPortNumberSensor(), \"no sensor configured to infer port number\");\n    }","commit_id":"75b189354912079e04645bc520b3dc1420d20282","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public String configFile() {\n        // Check SSL configuration\n        ProxySslConfig ssl = driver.getEntity().getConfig(NginxController.SSL_CONFIG);\n        if (Strings.isEmpty(ssl.getCertificateDestination()) && Strings.isEmpty(ssl.getCertificateSourceUrl())) {\n            throw new IllegalStateException(\"ProxySslConfig can't have a null certificateDestination and null certificateSourceUrl. One or both need to be set\");\n        }\n\n        // For mapping by URL\n        Iterable<UrlMapping> mappings = ((NginxController) driver.getEntity()).getUrlMappings();\n        Multimap<String, UrlMapping> mappingsByDomain = LinkedHashMultimap.create();\n        for (UrlMapping mapping : mappings) {\n            Collection<String> addrs = mapping.getAttribute(UrlMapping.TARGET_ADDRESSES);\n            if (addrs != null && addrs.size() > 0) {\n                mappingsByDomain.put(mapping.getDomain(), mapping);\n            }\n        }\n        Map<String, Object> substitutions = MutableMap.<String, Object>of(\"ssl\", ssl, \"urlMappings\", mappings, \"domainMappings\", mappingsByDomain);\n\n        // Get template contents and process\n        String templateUrl = driver.getEntity().getConfig(NginxController.SERVER_CONF_TEMPLATE_URL);\n        String contents = ResourceUtils.create(driver.getEntity()).getResourceAsString(templateUrl);\n        return TemplateProcessor.processTemplateContents(contents, driver, substitutions);\n    }","id":76064,"modified_method":"public String configFile() {\n        // Check template URL exists\n        String templateUrl = driver.getEntity().getConfig(NginxController.SERVER_CONF_TEMPLATE_URL);\n        ResourceUtils.create(this).checkUrlExists(templateUrl);\n\n        // Check SSL configuration\n        ProxySslConfig ssl = driver.getEntity().getConfig(NginxController.SSL_CONFIG);\n        if (Strings.isEmpty(ssl.getCertificateDestination()) && Strings.isEmpty(ssl.getCertificateSourceUrl())) {\n            throw new IllegalStateException(\"ProxySslConfig can't have a null certificateDestination and null certificateSourceUrl. One or both need to be set\");\n        }\n\n        // For mapping by URL\n        Iterable<UrlMapping> mappings = ((NginxController) driver.getEntity()).getUrlMappings();\n        Multimap<String, UrlMapping> mappingsByDomain = LinkedHashMultimap.create();\n        for (UrlMapping mapping : mappings) {\n            Collection<String> addrs = mapping.getAttribute(UrlMapping.TARGET_ADDRESSES);\n            if (addrs != null && addrs.size() > 0) {\n                mappingsByDomain.put(mapping.getDomain(), mapping);\n            }\n        }\n        Map<String, Object> substitutions = MutableMap.<String, Object>of(\"ssl\", ssl, \"urlMappings\", mappings, \"domainMappings\", mappingsByDomain);\n\n        // Get template contents and process\n        String contents = ResourceUtils.create(driver.getEntity()).getResourceAsString(templateUrl);\n        return TemplateProcessor.processTemplateContents(contents, driver, substitutions);\n    }","commit_id":"75b189354912079e04645bc520b3dc1420d20282","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public String getConfigFile() {\n        NginxSshDriver driver = (NginxSshDriver)getDriver();\n        if (driver==null) {\n            if (LOG.isDebugEnabled()) LOG.debug(\"No driver for {}, so not generating config file (is entity stopping? state={})\", \n                this, getAttribute(NginxController.SERVICE_STATE));\n            return null;\n        }\n\n        String templateUrl = getConfig(NginxController.SERVER_CONF_TEMPLATE_URL);\n        if (ResourceUtils.create(this).doesUrlExist(templateUrl)) {\n            return NginxConfigTemplate.generator(driver).configFile();\n        } else {\n            return NginxConfigFileGenerator.generator(driver).configFile();\n        }\n    }","id":76065,"modified_method":"public String getConfigFile() {\n        NginxSshDriver driver = (NginxSshDriver)getDriver();\n        if (driver==null) {\n            if (LOG.isDebugEnabled()) LOG.debug(\"No driver for {}, so not generating config file (is entity stopping? state={})\", \n                this, getAttribute(NginxController.SERVICE_STATE));\n            return null;\n        }\n\n        String templateUrl = getConfig(NginxController.SERVER_CONF_TEMPLATE_URL);\n        if (templateUrl != null) {\n            return NginxConfigTemplate.generator(driver).configFile();\n        } else {\n            return NginxConfigFileGenerator.generator(driver).configFile();\n        }\n    }","commit_id":"75b189354912079e04645bc520b3dc1420d20282","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void customize() {\n        newScript(CUSTOMIZING)\n                .body.append(\n                        format(\"mkdir -p %s\", getRunDir()),\n                        format(\"cp -R %s/dist/{conf,html,logs,sbin} %s\", getExpandedInstallDir(), getRunDir())\n                )\n                .execute();\n\n        // Install static content archive, if specified\n        String archiveUrl = entity.getConfig(NginxController.STATIC_CONTENT_ARCHIVE_URL);\n        if (Strings.isNonBlank(archiveUrl)) {\n            // TODO from VanilaJavaApp - move this logic to superclass or helper\n            // If a local folder, then jar it up\n            if (new File(archiveUrl).isDirectory()) {\n                try {\n                    File jarFile = JarBuilder.buildJar(new File(archiveUrl));\n                    archiveUrl = jarFile.getAbsolutePath();\n                } catch (IOException e) {\n                    throw new IllegalStateException(\"Error archiving directory \"+archiveUrl, e);\n                }\n            }\n\n            int result = getMachine().installTo(resource, archiveUrl, getRunDir() + \"/\");\n            if (result != 0)\n                throw new IllegalStateException(format(\"unable to install static content archive %s for %s at %s\", archiveUrl, entity, getMachine()));\n\n            String destName = archiveUrl;\n            destName = destName.contains(\"?\") ? destName.substring(0, destName.indexOf('?')) : destName;\n            destName = destName.substring(destName.lastIndexOf('/') + 1);\n\n            try { // Use the location mutex to prevent package manager locking issues\n                getMachine().acquireMutex(\"installing\", \"customizing\"+getEntity().getId());\n\n                // if it's a jar, zip or tgz then expand\n                if (destName.toLowerCase().endsWith(\".zip\") || destName.toLowerCase().endsWith(\".jar\")) {\n                    result = getMachine().execCommands(\"unzipping\", ImmutableList.of(BashCommands.INSTALL_UNZIP, format(\"cd %s && unzip %s\", getRunDir(), destName)));\n                } else if (destName.toLowerCase().endsWith(\".tgz\") || destName.toLowerCase().endsWith(\".tar.gz\")) {\n                    result = getMachine().execCommands(\"untarring gz\", ImmutableList.of(BashCommands.INSTALL_TAR, format(\"cd %s && tar xvfz %s\", getRunDir(), destName)));\n                } else if (destName.toLowerCase().endsWith(\".tar\")) {\n                    result = getMachine().execCommands(\"untarring\", ImmutableList.of(BashCommands.INSTALL_TAR, format(\"cd %s && tar xvf %s\", getRunDir(), destName)));\n                }\n                if (result != 0)\n                    throw new IllegalStateException(format(\"unable to install static content for %s at %s (failed to expand archive %s)\", entity, getMachine(), archiveUrl));\n            } catch (InterruptedException e) {\n                throw new RuntimeInterruptedException(e);\n            } finally {\n                getMachine().releaseMutex(\"installing\");\n            }\n        }\n\n        customizationCompleted = true;\n        getEntity().doExtraConfigurationDuringStart();\n    }","id":76066,"modified_method":"@Override\n    public void customize() {\n        newScript(CUSTOMIZING)\n                .body.append(\n                        format(\"mkdir -p %s\", getRunDir()),\n                        format(\"cp -R %s/dist/{conf,html,logs,sbin} %s\", getExpandedInstallDir(), getRunDir())\n                )\n                .execute();\n\n        // Install static content archive, if specified\n        String archiveUrl = entity.getConfig(NginxController.STATIC_CONTENT_ARCHIVE_URL);\n        if (Strings.isNonBlank(archiveUrl)) {\n            // TODO from VanilaJavaApp - move this logic to superclass or helper\n            // If a local folder, then jar it up\n            if (new File(archiveUrl).isDirectory()) {\n                try {\n                    File jarFile = JarBuilder.buildJar(new File(archiveUrl));\n                    archiveUrl = jarFile.getAbsolutePath();\n                } catch (IOException e) {\n                    throw new IllegalStateException(\"Error archiving directory \"+archiveUrl, e);\n                }\n            }\n\n            int result = getMachine().installTo(resource, archiveUrl, getRunDir() + \"/\");\n            if (result != 0)\n                throw new IllegalStateException(format(\"unable to install static content archive %s for %s at %s\", archiveUrl, entity, getMachine()));\n\n            String destName = archiveUrl;\n            destName = destName.contains(\"?\") ? destName.substring(0, destName.indexOf('?')) : destName;\n            destName = destName.substring(destName.lastIndexOf('/') + 1);\n\n            try { // Use the location mutex to prevent package manager locking issues\n                getMachine().acquireMutex(\"installing\", \"customizing\"+getEntity().getId());\n\n                // if it's a jar, zip or tgz then expand\n                if (destName.toLowerCase().endsWith(\".zip\") || destName.toLowerCase().endsWith(\".jar\")) {\n                    result = getMachine().execCommands(\"unzipping\", ImmutableList.of(BashCommands.INSTALL_UNZIP, format(\"cd %s && unzip %s\", getRunDir(), destName)));\n                } else if (destName.toLowerCase().endsWith(\".tgz\") || destName.toLowerCase().endsWith(\".tar.gz\")) {\n                    result = getMachine().execCommands(\"untarring gz\", ImmutableList.of(BashCommands.INSTALL_TAR, format(\"cd %s && tar xvfz %s\", getRunDir(), destName)));\n                } else if (destName.toLowerCase().endsWith(\".tar\")) {\n                    result = getMachine().execCommands(\"untarring\", ImmutableList.of(BashCommands.INSTALL_TAR, format(\"cd %s && tar xvf %s\", getRunDir(), destName)));\n                }\n                if (result != 0)\n                    throw new IllegalStateException(format(\"unable to install static content for %s at %s (failed to expand archive %s)\", entity, getMachine(), archiveUrl));\n            } catch (InterruptedException e) {\n                throw Exceptions.propagate(e);\n            } finally {\n                getMachine().releaseMutex(\"installing\");\n            }\n        }\n\n        customizationCompleted = true;\n        getEntity().doExtraConfigurationDuringStart();\n    }","commit_id":"75b189354912079e04645bc520b3dc1420d20282","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private static DirectoryContent getDirectoryContent(VirtualFile directory, final ProgressIndicator progress) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Retrieving directory content for \" + directory);\n    }\n    final CvsInfo cvsInfo = CvsEntriesManager.getInstance().getCvsInfoFor(directory);\n    final DirectoryContent result = new DirectoryContent(cvsInfo);\n\n    VirtualFile[] children = CvsVfsUtil.getChildrenOf(directory);\n    if (children == null) children = VirtualFile.EMPTY_ARRAY;\n\n    final Collection<Entry> entries = cvsInfo.getEntries();\n\n    final HashMap<String, VirtualFile> nameToFileMap = new HashMap<String, VirtualFile>();\n    for (VirtualFile child : children) {\n      nameToFileMap.put(child.getName(), child);\n    }\n\n    for (final Entry entry : entries) {\n      progress.checkCanceled();\n      final String fileName = entry.getFileName();\n      if (entry.isDirectory()) {\n        if (nameToFileMap.containsKey(fileName)) {\n          final VirtualFile virtualFile = nameToFileMap.get(fileName);\n          if (isInContent(virtualFile)) {\n            result.addDirectory(new VirtualFileEntry(virtualFile, entry));\n          }\n        }\n        else if (!entry.isRemoved() && !FileTypeManager.getInstance().isFileIgnored(fileName)) {\n          result.addDeletedDirectory(entry);\n        }\n      }\n      else {\n        if (nameToFileMap.containsKey(fileName) || entry.isRemoved()) {\n          final VirtualFile virtualFile = nameToFileMap.get(fileName);\n          if (isInContent(virtualFile)) {\n            result.addFile(new VirtualFileEntry(virtualFile, entry));\n          }\n        }\n        else if (!entry.isAddedFile()) {\n          result.addDeletedFile(entry);\n        }\n      }\n      nameToFileMap.remove(fileName);\n    }\n\n    for (final String name : nameToFileMap.keySet()) {\n      progress.checkCanceled();\n      final VirtualFile unknown = nameToFileMap.get(name);\n      if (unknown.isDirectory()) {\n        if (isInContent(unknown)) {\n          result.addUnknownDirectory(unknown);\n        }\n      }\n      else {\n        if (isInContent(unknown)) {\n          final boolean isIgnored = result.getCvsInfo().getIgnoreFilter().shouldBeIgnored(unknown.getName());\n          if (isIgnored) {\n            result.addIgnoredFile(unknown);\n          }\n          else {\n            result.addUnknownFile(unknown);\n          }\n        }\n      }\n    }\n\n    return result;\n  }","id":76067,"modified_method":"private static DirectoryContent getDirectoryContent(VirtualFile directory, final ProgressIndicator progress) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Retrieving directory content for \" + directory);\n    }\n    final CvsInfo cvsInfo = CvsEntriesManager.getInstance().getCvsInfoFor(directory);\n    final DirectoryContent result = new DirectoryContent(cvsInfo);\n\n    final HashMap<String, VirtualFile> nameToFileMap = new HashMap<String, VirtualFile>();\n    for (VirtualFile child : CvsVfsUtil.getChildrenOf(directory)) {\n      nameToFileMap.put(child.getName(), child);\n    }\n\n    for (final Entry entry : cvsInfo.getEntries()) {\n      progress.checkCanceled();\n      final String fileName = entry.getFileName();\n      if (entry.isDirectory()) {\n        if (nameToFileMap.containsKey(fileName)) {\n          final VirtualFile virtualFile = nameToFileMap.get(fileName);\n          if (isInContent(virtualFile)) {\n            result.addDirectory(new VirtualFileEntry(virtualFile, entry));\n          }\n        }\n        else if (!entry.isRemoved() && !FileTypeManager.getInstance().isFileIgnored(fileName)) {\n          result.addDeletedDirectory(entry);\n        }\n      }\n      else {\n        if (nameToFileMap.containsKey(fileName) || entry.isRemoved()) {\n          final VirtualFile virtualFile = nameToFileMap.get(fileName);\n          if (isInContent(virtualFile)) {\n            result.addFile(new VirtualFileEntry(virtualFile, entry));\n          }\n        }\n        else if (!entry.isAddedFile()) {\n          result.addDeletedFile(entry);\n        }\n      }\n      nameToFileMap.remove(fileName);\n    }\n\n    for (final String name : nameToFileMap.keySet()) {\n      progress.checkCanceled();\n      final VirtualFile unknown = nameToFileMap.get(name);\n      if (unknown.isDirectory()) {\n        if (isInContent(unknown)) {\n          result.addUnknownDirectory(unknown);\n        }\n      }\n      else {\n        if (isInContent(unknown)) {\n          final boolean isIgnored = result.getCvsInfo().getIgnoreFilter().shouldBeIgnored(unknown.getName());\n          if (isIgnored) {\n            result.addIgnoredFile(unknown);\n          }\n          else {\n            result.addUnknownFile(unknown);\n          }\n        }\n      }\n    }\n\n    return result;\n  }","commit_id":"69ba97da203321eab7ba38f527e11548c2dc50cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processEntriesIn(@NotNull VirtualFile dir, VcsDirtyScope scope, ChangelistBuilder builder, boolean recursively,\n                                final ProgressIndicator progress) throws VcsException {\n    final FilePath path = VcsContextFactory.SERVICE.getInstance().createFilePathOn(dir);\n    if (!scope.belongsTo(path)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skipping out of scope path \" + path);\n      }\n      return;\n    }\n    final DirectoryContent dirContent = getDirectoryContent(dir, progress);\n\n    for (VirtualFile file : dirContent.getUnknownFiles()) {\n      builder.processUnversionedFile(file);\n    }\n    for (VirtualFile file : dirContent.getIgnoredFiles()) {\n      builder.processIgnoredFile(file);\n    }\n\n    for (Entry entry : dirContent.getDeletedDirectories()) {\n      builder.processLocallyDeletedFile(VcsUtil.getFilePath(CvsVfsUtil.getFileFor(dir, entry.getFileName()), true));\n    }\n\n    for (Entry entry : dirContent.getDeletedFiles()) {\n      builder.processLocallyDeletedFile(VcsUtil.getFilePath(CvsVfsUtil.getFileFor(dir, entry.getFileName()), false));\n    }\n\n    /*\n    final Collection<VirtualFile> unknownDirs = dirContent.getUnknownDirectories();\n    for (VirtualFile file : unknownDirs) {\n      builder.processUnversionedFile(file);\n    }\n    */\n\n    progress.checkCanceled();\n    checkSwitchedDir(dir, builder, scope);\n\n    if (CvsUtil.fileIsUnderCvs(dir) && dir.getChildren().length == 1 /* admin dir */ &&\n        dirContent.getDeletedFiles().isEmpty() && hasRemovedFiles(dirContent.getFiles())) {\n      // directory is going to be deleted\n      builder.processChange(new Change(CurrentContentRevision.create(path), CurrentContentRevision.create(path), FileStatus.DELETED), CvsVcs2.getKey());\n    }\n    for (VirtualFileEntry fileEntry : dirContent.getFiles()) {\n      processFile(dir, fileEntry.getVirtualFile(), fileEntry.getEntry(), builder, progress);\n    }\n\n    if (recursively) {\n      final VirtualFile[] children = CvsVfsUtil.getChildrenOf(dir);\n      if (children != null) {\n        for (VirtualFile file : children) {\n          progress.checkCanceled();\n          if (file.isDirectory()) {\n            final boolean isIgnored = myVcsManager.isIgnored(file);\n            if (!isIgnored) {\n              processEntriesIn(file, scope, builder, true, progress);\n            }\n            else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Skipping ignored path \" + file.getPath());\n              }\n            }\n          }\n        }\n      }\n    }\n  }","id":76068,"modified_method":"private void processEntriesIn(@NotNull VirtualFile dir, VcsDirtyScope scope, ChangelistBuilder builder, boolean recursively,\n                                final ProgressIndicator progress) throws VcsException {\n    final FilePath path = VcsContextFactory.SERVICE.getInstance().createFilePathOn(dir);\n    if (!scope.belongsTo(path)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skipping out of scope path \" + path);\n      }\n      return;\n    }\n    final DirectoryContent dirContent = getDirectoryContent(dir, progress);\n\n    for (VirtualFile file : dirContent.getUnknownFiles()) {\n      builder.processUnversionedFile(file);\n    }\n    for (VirtualFile file : dirContent.getIgnoredFiles()) {\n      builder.processIgnoredFile(file);\n    }\n\n    for (Entry entry : dirContent.getDeletedDirectories()) {\n      builder.processLocallyDeletedFile(VcsUtil.getFilePath(CvsVfsUtil.getFileFor(dir, entry.getFileName()), true));\n    }\n\n    for (Entry entry : dirContent.getDeletedFiles()) {\n      builder.processLocallyDeletedFile(VcsUtil.getFilePath(CvsVfsUtil.getFileFor(dir, entry.getFileName()), false));\n    }\n\n    /*\n    final Collection<VirtualFile> unknownDirs = dirContent.getUnknownDirectories();\n    for (VirtualFile file : unknownDirs) {\n      builder.processUnversionedFile(file);\n    }\n    */\n\n    progress.checkCanceled();\n    checkSwitchedDir(dir, builder, scope);\n\n    if (CvsUtil.fileIsUnderCvs(dir) && dir.getChildren().length == 1 /* admin dir */ &&\n        dirContent.getDeletedFiles().isEmpty() && hasRemovedFiles(dirContent.getFiles())) {\n      // directory is going to be deleted\n      builder.processChange(new Change(CurrentContentRevision.create(path), CurrentContentRevision.create(path), FileStatus.DELETED), CvsVcs2.getKey());\n    }\n    for (VirtualFileEntry fileEntry : dirContent.getFiles()) {\n      processFile(dir, fileEntry.getVirtualFile(), fileEntry.getEntry(), builder, progress);\n    }\n\n    if (recursively) {\n      for (VirtualFile file : CvsVfsUtil.getChildrenOf(dir)) {\n        progress.checkCanceled();\n        if (file.isDirectory()) {\n          if (!myVcsManager.isIgnored(file)) {\n            processEntriesIn(file, scope, builder, true, progress);\n          }\n          else {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Skipping ignored path \" + file.getPath());\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"69ba97da203321eab7ba38f527e11548c2dc50cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static VirtualFile[] getChildrenOf(final VirtualFile directory) {\n    return directory.isValid() ? directory.getChildren() : null;\n  }","id":76069,"modified_method":"@NotNull\n  public static VirtualFile[] getChildrenOf(final VirtualFile directory) {\n    if (!directory.isValid()) {\n      return VirtualFile.EMPTY_ARRAY;\n    }\n    final VirtualFile[] children = directory.getChildren();\n    return (children == null) ? VirtualFile.EMPTY_ARRAY : children;\n  }","commit_id":"69ba97da203321eab7ba38f527e11548c2dc50cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void listFilesAndDirectories(DirectoryObject directoryObject,\n                                      Collection<String> fileNames,\n                                      Collection<String> directoryNames,\n                                      ICvsFileSystem cvsFileSystem) {\n    VirtualFile virtualDirectory = getVirtualFile(directoryObject, cvsFileSystem);\n    if (virtualDirectory == null) return;\n    VirtualFile[] children = CvsVfsUtil.getChildrenOf(virtualDirectory);\n    if (children == null) return;\n\n    for (final VirtualFile fileOrDirectory : children) {\n      if (CvsUtil.CVS.equals(fileOrDirectory.getName())) continue;\n      if (!myProjectContentInfoProvider.fileIsUnderProject(fileOrDirectory)) continue;\n      final String name = fileOrDirectory.getName();\n      if (fileOrDirectory.isDirectory()) {\n        if (directoryNames != null) {\n          directoryNames.add(name);\n        }\n      }\n      else {\n        if (fileNames != null) {\n          LOG.assertTrue(name.length() > 0);\n          fileNames.add(name);\n        }\n      }\n    }\n\n  }","id":76070,"modified_method":"public void listFilesAndDirectories(DirectoryObject directoryObject,\n                                      Collection<String> fileNames,\n                                      Collection<String> directoryNames,\n                                      ICvsFileSystem cvsFileSystem) {\n    VirtualFile virtualDirectory = getVirtualFile(directoryObject, cvsFileSystem);\n    if (virtualDirectory == null) return;\n\n    for (final VirtualFile fileOrDirectory : CvsVfsUtil.getChildrenOf(virtualDirectory)) {\n      if (CvsUtil.CVS.equals(fileOrDirectory.getName())) continue;\n      if (!myProjectContentInfoProvider.fileIsUnderProject(fileOrDirectory)) continue;\n      final String name = fileOrDirectory.getName();\n      if (fileOrDirectory.isDirectory()) {\n        if (directoryNames != null) {\n          directoryNames.add(name);\n        }\n      }\n      else {\n        if (fileNames != null) {\n          LOG.assertTrue(!name.isEmpty());\n          fileNames.add(name);\n        }\n      }\n    }\n\n  }","commit_id":"69ba97da203321eab7ba38f527e11548c2dc50cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JSONArray getDDMFormFieldsJSONArray(\n\t\tDDMForm ddmForm, String script) {\n\n\t\tif (Validator.isNull(script)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJSONArray defaultDDMFormFieldsJSONArray = null;\n\n\t\tif (ddmForm != null) {\n\t\t\tdefaultDDMFormFieldsJSONArray = getDDMFormFieldsJSONArray(\n\t\t\t\tddmForm.getDDMFormFields(), ddmForm.getAvailableLocales(),\n\t\t\t\tddmForm.getDefaultLocale());\n\t\t}\n\n\t\ttry {\n\t\t\tDDMForm scriptDDMForm = _ddmFormJSONDeserializer.deserialize(\n\t\t\t\tscript);\n\n\t\t\treturn getDDMFormFieldsJSONArray(\n\t\t\t\tscriptDDMForm.getDDMFormFields(),\n\t\t\t\tscriptDDMForm.getAvailableLocales(),\n\t\t\t\tscriptDDMForm.getDefaultLocale());\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Unable to deserialize script\", pe);\n\t\t\t}\n\n\t\t\treturn defaultDDMFormFieldsJSONArray;\n\t\t}\n\t}","id":76071,"modified_method":"protected JSONArray getDDMFormFieldsJSONArray(\n\t\tDDMForm ddmForm, String script) {\n\n\t\tJSONArray ddmFormFieldsJSONArray = null;\n\n\t\tif (ddmForm != null) {\n\t\t\tddmFormFieldsJSONArray = getDDMFormFieldsJSONArray(\n\t\t\t\tddmForm.getDDMFormFields(), ddmForm.getAvailableLocales(),\n\t\t\t\tddmForm.getDefaultLocale());\n\t\t}\n\t\telse if (Validator.isNotNull(script)) {\n\t\t\ttry {\n\t\t\t\tDDMForm scriptDDMForm = _ddmFormJSONDeserializer.deserialize(\n\t\t\t\t\tscript);\n\n\t\t\t\tddmFormFieldsJSONArray = getDDMFormFieldsJSONArray(\n\t\t\t\t\tscriptDDMForm.getDDMFormFields(),\n\t\t\t\t\tscriptDDMForm.getAvailableLocales(),\n\t\t\t\t\tscriptDDMForm.getDefaultLocale());\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Unable to deserialize script\", pe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ddmFormFieldsJSONArray;\n\t}","commit_id":"3fdd0e0213eb3337f968262a1fe1e3bdcd93c7f4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<AssetVocabulary> getVocabularies() {\n\t\tList<AssetVocabulary> vocabularies =\n\t\t\tAssetVocabularyServiceUtil.getGroupVocabularies(getGroupIds());\n\n\t\tif (Validator.isNull(_className)) {\n\t\t\treturn vocabularies;\n\t\t}\n\n\t\tvocabularies = AssetUtil.filterVocabularies(\n\t\t\tvocabularies, _className, _classTypePK);\n\n\t\treturn ListUtil.filter(\n\t\t\tvocabularies,\n\t\t\tnew PredicateFilter<AssetVocabulary>() {\n\n\t\t\t\tpublic boolean filter(AssetVocabulary vocabulary) {\n\t\t\t\t\tint vocabularyCategoriesCount =\n\t\t\t\t\t\tAssetCategoryServiceUtil.getVocabularyCategoriesCount(\n\t\t\t\t\t\t\tvocabulary.getGroupId(),\n\t\t\t\t\t\t\tvocabulary.getVocabularyId());\n\n\t\t\t\t\tif (vocabularyCategoriesCount > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t});\n\t}","id":76072,"modified_method":"protected List<AssetVocabulary> getVocabularies() {\n\t\tList<AssetVocabulary> vocabularies =\n\t\t\tAssetVocabularyServiceUtil.getGroupVocabularies(\n\t\t\t\tgetGroupIds());\n\n\t\tif (Validator.isNotNull(_className)) {\n\t\t\tvocabularies = AssetUtil.filterVocabularies(\n\t\t\t\tvocabularies, _className, _classTypePK);\n\t\t}\n\n\t\treturn ListUtil.filter(\n\t\t\tvocabularies,\n\t\t\tnew PredicateFilter<AssetVocabulary>() {\n\n\t\t\t\tpublic boolean filter(AssetVocabulary vocabulary) {\n\t\t\t\t\tint vocabularyCategoriesCount =\n\t\t\t\t\t\tAssetCategoryServiceUtil.getVocabularyCategoriesCount(\n\t\t\t\t\t\t\tvocabulary.getGroupId(),\n\t\t\t\t\t\t\tvocabulary.getVocabularyId());\n\n\t\t\t\t\tif (vocabularyCategoriesCount > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"5e7db1de8cc1f57de3e2c533398113506fd8f07c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * The watchdog thread will be invoked every WAKEUP_INTERVAL time, to check if any thread that be monitored\n     * has not updated its time stamp more than WATCHDOG_THRESHOLD millisecond. Same stack trace messages are\n     * rate limited by MIN_LOG_INTERVAL.\n     */\n    @Override\n    public void run() {\n        Thread.currentThread().setName(\"Latency Watchdog\");\n        System.out.printf(\"Latency Watchdog enabled -- threshold:%d(ms) wakeup_interval:%d(ms) min_log_interval:%d(ms)\\n\",\n                WATCHDOG_THRESHOLD, WAKEUP_INTERVAL, MIN_LOG_INTERVAL);\n        while (true) {\n            for (Entry<Thread, AtomicLong> entry : sLatencyMap.entrySet()) {\n                Thread t = entry.getKey();\n                long timestamp = entry.getValue().get();\n                long now = System.currentTimeMillis();\n                if ((now - timestamp > WATCHDOG_THRESHOLD) && t.getState() != Thread.State.TERMINATED) {\n                    StringBuilder sb = new StringBuilder();\n                    sb.append(t.getName() + \" has been delayed for more than \" + WATCHDOG_THRESHOLD + \" milliseconds\\n\");\n                    for (StackTraceElement ste : t.getStackTrace()) {\n                        sb.append(ste);\n                        sb.append(\"\\n\");\n                    }\n                    RateLimitedLogger.tryLogForMessage(sb.toString(), now, MIN_LOG_INTERVAL, TimeUnit.MILLISECONDS, LOG, Level.ERROR);\n                }\n            }\n            try {\n                Thread.sleep(WAKEUP_INTERVAL);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }","id":76073,"modified_method":"/**\n     * The watchdog thread will be invoked every WAKEUP_INTERVAL time, to check if any thread that be monitored\n     * has not updated its time stamp more than WATCHDOG_THRESHOLD millisecond. Same stack trace messages are\n     * rate limited by MIN_LOG_INTERVAL.\n     */\n    @Override\n    public void run() {\n        Thread.currentThread().setName(\"Latency Watchdog\");\n        LOG.info(String.format(\"Latency Watchdog enabled -- threshold:%d(ms) \" +\n                               \"wakeup_interval:%d(ms) min_log_interval:%d(ms)\\n\",\n                               WATCHDOG_THRESHOLD, WAKEUP_INTERVAL, MIN_LOG_INTERVAL));\n        while (true) {\n            for (Entry<Thread, AtomicLong> entry : sLatencyMap.entrySet()) {\n                Thread t = entry.getKey();\n                long timestamp = entry.getValue().get();\n                long now = System.currentTimeMillis();\n                if ((now - timestamp > WATCHDOG_THRESHOLD) && t.getState() != Thread.State.TERMINATED) {\n                    StringBuilder sb = new StringBuilder();\n                    sb.append(t.getName() + \" has been delayed for more than \" + WATCHDOG_THRESHOLD + \" milliseconds\\n\");\n                    for (StackTraceElement ste : t.getStackTrace()) {\n                        sb.append(ste);\n                        sb.append(\"\\n\");\n                    }\n                    RateLimitedLogger.tryLogForMessage(sb.toString(), now, MIN_LOG_INTERVAL, TimeUnit.MILLISECONDS, LOG, Level.INFO);\n                }\n            }\n            try {\n                Thread.sleep(WAKEUP_INTERVAL);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"a48519825a1cb8d99a997ed6463820195a86fc5e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Update latency watchdog time stamp for current thread.\n     */\n    public static void pet() {\n        if (!sEnable)\n            return;\n\n        Thread thread = Thread.currentThread();\n        AtomicLong oldVal = sLatencyMap.get(thread);\n        if (oldVal == null) {\n            sLatencyMap.put(thread, new AtomicLong(System.currentTimeMillis()));\n        } else {\n            oldVal.lazySet(System.currentTimeMillis());\n        }\n    }","id":76074,"modified_method":"/**\n     * Update latency watchdog time stamp for current thread.\n     * Keep this method small so inlining and elimination can work their magic\n     */\n    public static void pet() {\n        if (!sEnable)\n            return;\n        petImpl();\n    }","commit_id":"a48519825a1cb8d99a997ed6463820195a86fc5e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        m_verbotenThreads.add(Thread.currentThread().getId());\n        try {\n            m_ih.starting(this);\n            m_ih.started(this);\n            while (m_shouldStop == false) {\n                if (LatencyWatchdog.isEnable()) {\n                    LatencyWatchdog.pet();\n                }\n\n                //Choose a non-blocking select if things are busy\n                if (m_hadWork) {\n                    m_selector.selectNow();\n                } else {\n                    m_selector.select();\n                }\n\n                m_hadWork = false;\n                Runnable task = null;\n                while ((task = m_tasks.poll()) != null) {\n                    m_hadWork = true;\n                    task.run();\n                }\n                dispatchReadStream();\n                drainWriteStream();\n            }\n        } catch (CancelledKeyException e) {\n            networkLog.warn(\n                    \"Had a cancelled key exception for \"\n                            + m_toString, e);\n        } catch (IOException e) {\n            final String trimmed = e.getMessage() == null ? \"\" : e.getMessage().trim();\n            if ((e instanceof IOException && (trimmed.equalsIgnoreCase(\"Connection reset by peer\") || trimmed.equalsIgnoreCase(\"broken pipe\"))) ||\n                    e instanceof AsynchronousCloseException ||\n                    e instanceof ClosedChannelException ||\n                    e instanceof ClosedByInterruptException) {\n                m_logger.debug( \"VoltPort died, probably of natural causes\", e);\n            } else {\n                e.printStackTrace();\n                networkLog.error( \"VoltPort died due to an unexpected exception\", e);\n            }\n        } catch (Throwable ex) {\n            ex.printStackTrace();\n            m_logger.error(null, ex);\n            m_shouldStop = true;\n        } finally {\n            m_verbotenThreads.remove(Thread.currentThread().getId());\n            try {\n                p_shutdown();\n            } catch (Throwable t) {\n                m_logger.error(\"Error shutting down Volt Network\", t);\n                t.printStackTrace();\n            }\n        }\n    }","id":76075,"modified_method":"@Override\n    public void run() {\n        m_verbotenThreads.add(Thread.currentThread().getId());\n        try {\n            m_ih.starting(this);\n            m_ih.started(this);\n            while (m_shouldStop == false) {\n                LatencyWatchdog.pet();\n\n                //Choose a non-blocking select if things are busy\n                if (m_hadWork) {\n                    m_selector.selectNow();\n                } else {\n                    m_selector.select();\n                }\n\n                m_hadWork = false;\n                Runnable task = null;\n                while ((task = m_tasks.poll()) != null) {\n                    m_hadWork = true;\n                    task.run();\n                }\n                dispatchReadStream();\n                drainWriteStream();\n            }\n        } catch (CancelledKeyException e) {\n            networkLog.warn(\n                    \"Had a cancelled key exception for \"\n                            + m_toString, e);\n        } catch (IOException e) {\n            final String trimmed = e.getMessage() == null ? \"\" : e.getMessage().trim();\n            if ((e instanceof IOException && (trimmed.equalsIgnoreCase(\"Connection reset by peer\") || trimmed.equalsIgnoreCase(\"broken pipe\"))) ||\n                    e instanceof AsynchronousCloseException ||\n                    e instanceof ClosedChannelException ||\n                    e instanceof ClosedByInterruptException) {\n                m_logger.debug( \"VoltPort died, probably of natural causes\", e);\n            } else {\n                e.printStackTrace();\n                networkLog.error( \"VoltPort died due to an unexpected exception\", e);\n            }\n        } catch (Throwable ex) {\n            ex.printStackTrace();\n            m_logger.error(null, ex);\n            m_shouldStop = true;\n        } finally {\n            m_verbotenThreads.remove(Thread.currentThread().getId());\n            try {\n                p_shutdown();\n            } catch (Throwable t) {\n                m_logger.error(\"Error shutting down Volt Network\", t);\n                t.printStackTrace();\n            }\n        }\n    }","commit_id":"a48519825a1cb8d99a997ed6463820195a86fc5e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void runForRejoin(SiteProcedureConnection siteConnection, TaskLog taskLog)\n    throws IOException\n    {\n        if (LatencyWatchdog.isEnable()) {\n            LatencyWatchdog.pet();\n        }\n\n        if (!m_txnState.isReadOnly()) {\n            taskLog.logTask(m_txnState.getNotice());\n        }\n\n        SpTransactionState txnState = (SpTransactionState)m_txnState;\n        final InitiateResponseMessage response =\n            new InitiateResponseMessage(txnState.m_initiationMsg);\n        response.m_sourceHSId = m_initiator.getHSId();\n        response.setRecovering(true);\n\n        // add an empty dummy response\n        response.setResults(new ClientResponseImpl(\n                    ClientResponse.SUCCESS,\n                    new VoltTable[0],\n                    null));\n\n        m_initiator.deliver(response);\n    }","id":76076,"modified_method":"@Override\n    public void runForRejoin(SiteProcedureConnection siteConnection, TaskLog taskLog)\n    throws IOException\n    {\n        LatencyWatchdog.pet();\n\n        if (!m_txnState.isReadOnly()) {\n            taskLog.logTask(m_txnState.getNotice());\n        }\n\n        SpTransactionState txnState = (SpTransactionState)m_txnState;\n        final InitiateResponseMessage response =\n            new InitiateResponseMessage(txnState.m_initiationMsg);\n        response.m_sourceHSId = m_initiator.getHSId();\n        response.setRecovering(true);\n\n        // add an empty dummy response\n        response.setResults(new ClientResponseImpl(\n                    ClientResponse.SUCCESS,\n                    new VoltTable[0],\n                    null));\n\n        m_initiator.deliver(response);\n    }","commit_id":"a48519825a1cb8d99a997ed6463820195a86fc5e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Run is invoked by a run-loop to execute this transaction. */\n    @Override\n    public void run(SiteProcedureConnection siteConnection)\n    {\n        if (LatencyWatchdog.isEnable()) {\n            LatencyWatchdog.pet();\n        }\n\n        waitOnDurabilityBackpressureFuture();\n        if (HOST_DEBUG_ENABLED) {\n            hostLog.debug(\"STARTING: \" + this);\n        }\n        if (!m_txnState.isReadOnly()) {\n            m_txnState.setBeginUndoToken(siteConnection.getLatestUndoToken());\n        }\n\n        // cast up here .. ugly.\n        SpTransactionState txnState = (SpTransactionState)m_txnState;\n        final InitiateResponseMessage response = processInitiateTask(txnState.m_initiationMsg, siteConnection);\n        if (!response.shouldCommit()) {\n            m_txnState.setNeedsRollback();\n        }\n        completeInitiateTask(siteConnection);\n        response.m_sourceHSId = m_initiator.getHSId();\n        m_initiator.deliver(response);\n        if (EXEC_TRACE_ENABLED) {\n            execLog.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        }\n        if (HOST_DEBUG_ENABLED) {\n            hostLog.debug(\"COMPLETE: \" + this);\n        }\n\n        logToDR(txnState, response);\n    }","id":76077,"modified_method":"/** Run is invoked by a run-loop to execute this transaction. */\n    @Override\n    public void run(SiteProcedureConnection siteConnection)\n    {\n        LatencyWatchdog.pet();\n\n        waitOnDurabilityBackpressureFuture();\n        if (HOST_DEBUG_ENABLED) {\n            hostLog.debug(\"STARTING: \" + this);\n        }\n        if (!m_txnState.isReadOnly()) {\n            m_txnState.setBeginUndoToken(siteConnection.getLatestUndoToken());\n        }\n\n        // cast up here .. ugly.\n        SpTransactionState txnState = (SpTransactionState)m_txnState;\n        final InitiateResponseMessage response = processInitiateTask(txnState.m_initiationMsg, siteConnection);\n        if (!response.shouldCommit()) {\n            m_txnState.setNeedsRollback();\n        }\n        completeInitiateTask(siteConnection);\n        response.m_sourceHSId = m_initiator.getHSId();\n        m_initiator.deliver(response);\n        if (EXEC_TRACE_ENABLED) {\n            execLog.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        }\n        if (HOST_DEBUG_ENABLED) {\n            hostLog.debug(\"COMPLETE: \" + this);\n        }\n\n        logToDR(txnState, response);\n    }","commit_id":"a48519825a1cb8d99a997ed6463820195a86fc5e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void runFromTaskLog(SiteProcedureConnection siteConnection)\n    {\n        if (LatencyWatchdog.isEnable()) {\n            LatencyWatchdog.pet();\n        }\n\n        if (HOST_TRACE_ENABLED) {\n            hostLog.trace(\"START replaying txn: \" + this);\n        }\n        if (!m_txnState.isReadOnly()) {\n            m_txnState.setBeginUndoToken(siteConnection.getLatestUndoToken());\n        }\n\n        // cast up here .. ugly.\n        SpTransactionState txnState = (SpTransactionState)m_txnState;\n        final InitiateResponseMessage response = processInitiateTask(txnState.m_initiationMsg, siteConnection);\n        if (!response.shouldCommit()) {\n            m_txnState.setNeedsRollback();\n        }\n        if (!m_txnState.isReadOnly()) {\n            assert(siteConnection.getLatestUndoToken() != Site.kInvalidUndoToken) :\n                \"[SP][RW] transaction found invalid latest undo token state in Iv2ExecutionSite.\";\n            assert(siteConnection.getLatestUndoToken() >= m_txnState.getBeginUndoToken()) :\n                \"[SP][RW] transaction's undo log token farther advanced than latest known value.\";\n            assert (m_txnState.getBeginUndoToken() != Site.kInvalidUndoToken) :\n                \"[SP][RW] with invalid undo token in completeInitiateTask.\";\n\n            // the truncation point token SHOULD be part of m_txn. However, the\n            // legacy interaces don't work this way and IV2 hasn't changed this\n            // ownership yet. But truncateUndoLog is written assuming the right\n            // eventual encapsulation.\n            siteConnection.truncateUndoLog(m_txnState.needsRollback(),\n                    m_txnState.getBeginUndoToken(),\n                    m_txnState.m_spHandle,\n                    m_txnState.getUndoLog());\n        }\n        m_txnState.setDone();\n        if (EXEC_TRACE_ENABLED) {\n            execLog.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        }\n        if (HOST_TRACE_ENABLED) {\n            hostLog.trace(\"COMPLETE replaying txn: \" + this);\n        }\n\n        logToDR(txnState, response);\n    }","id":76078,"modified_method":"@Override\n    public void runFromTaskLog(SiteProcedureConnection siteConnection)\n    {\n        LatencyWatchdog.pet();\n\n        if (HOST_TRACE_ENABLED) {\n            hostLog.trace(\"START replaying txn: \" + this);\n        }\n        if (!m_txnState.isReadOnly()) {\n            m_txnState.setBeginUndoToken(siteConnection.getLatestUndoToken());\n        }\n\n        // cast up here .. ugly.\n        SpTransactionState txnState = (SpTransactionState)m_txnState;\n        final InitiateResponseMessage response = processInitiateTask(txnState.m_initiationMsg, siteConnection);\n        if (!response.shouldCommit()) {\n            m_txnState.setNeedsRollback();\n        }\n        if (!m_txnState.isReadOnly()) {\n            assert(siteConnection.getLatestUndoToken() != Site.kInvalidUndoToken) :\n                \"[SP][RW] transaction found invalid latest undo token state in Iv2ExecutionSite.\";\n            assert(siteConnection.getLatestUndoToken() >= m_txnState.getBeginUndoToken()) :\n                \"[SP][RW] transaction's undo log token farther advanced than latest known value.\";\n            assert (m_txnState.getBeginUndoToken() != Site.kInvalidUndoToken) :\n                \"[SP][RW] with invalid undo token in completeInitiateTask.\";\n\n            // the truncation point token SHOULD be part of m_txn. However, the\n            // legacy interaces don't work this way and IV2 hasn't changed this\n            // ownership yet. But truncateUndoLog is written assuming the right\n            // eventual encapsulation.\n            siteConnection.truncateUndoLog(m_txnState.needsRollback(),\n                    m_txnState.getBeginUndoToken(),\n                    m_txnState.m_spHandle,\n                    m_txnState.getUndoLog());\n        }\n        m_txnState.setDone();\n        if (EXEC_TRACE_ENABLED) {\n            execLog.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_SendingCompletedWUToDtxn.name(), null);\n        }\n        if (HOST_TRACE_ENABLED) {\n            hostLog.trace(\"COMPLETE replaying txn: \" + this);\n        }\n\n        logToDR(txnState, response);\n    }","commit_id":"a48519825a1cb8d99a997ed6463820195a86fc5e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run() {\n        final ThreadLocalRandom r = ThreadLocalRandom.current();\n        if (m_coreBindId != null) {\n            // Remove Affinity for now to make this dependency dissapear from the client.\n            // Goal is to remove client dependency on this class in the medium term.\n            //PosixJNAAffinity.INSTANCE.setAffinity(m_coreBindId);\n        }\n        try {\n            while (m_shouldStop == false) {\n                try {\n                    while (m_shouldStop == false) {\n                        if (LatencyWatchdog.isEnable()) {\n                            LatencyWatchdog.pet();\n                        }\n\n                        final int readyKeys = m_selector.select();\n\n                        /*\n                         * Run the task queue immediately after selection to catch\n                         * any tasks that weren't a result of readiness selection\n                         */\n                        Runnable task = null;\n                        while ((task = m_tasks.poll()) != null) {\n                            task.run();\n                        }\n\n                        if (readyKeys > 0) {\n                            optimizedInvokeCallbacks(r);\n                        }\n\n                        /*\n                         * Poll the task queue again in case new tasks were created\n                         * by invoking callbacks.\n                         */\n                        task = null;\n                        while ((task = m_tasks.poll()) != null) {\n                            task.run();\n                        }\n                    }\n                } catch (Throwable ex) {\n                    ex.printStackTrace();\n                    m_logger.error(null, ex);\n                }\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            try {\n                p_shutdown();\n            } catch (Throwable t) {\n                m_logger.error(\"Error shutting down Volt Network\", t);\n                t.printStackTrace();\n            }\n        }\n    }","id":76079,"modified_method":"@Override\n    public void run() {\n        final ThreadLocalRandom r = ThreadLocalRandom.current();\n        if (m_coreBindId != null) {\n            // Remove Affinity for now to make this dependency dissapear from the client.\n            // Goal is to remove client dependency on this class in the medium term.\n            //PosixJNAAffinity.INSTANCE.setAffinity(m_coreBindId);\n        }\n        try {\n            while (m_shouldStop == false) {\n                try {\n                    while (m_shouldStop == false) {\n                        LatencyWatchdog.pet();\n\n                        final int readyKeys = m_selector.select();\n\n                        /*\n                         * Run the task queue immediately after selection to catch\n                         * any tasks that weren't a result of readiness selection\n                         */\n                        Runnable task = null;\n                        while ((task = m_tasks.poll()) != null) {\n                            task.run();\n                        }\n\n                        if (readyKeys > 0) {\n                            optimizedInvokeCallbacks(r);\n                        }\n\n                        /*\n                         * Poll the task queue again in case new tasks were created\n                         * by invoking callbacks.\n                         */\n                        task = null;\n                        while ((task = m_tasks.poll()) != null) {\n                            task.run();\n                        }\n                    }\n                } catch (Throwable ex) {\n                    ex.printStackTrace();\n                    m_logger.error(null, ex);\n                }\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            try {\n                p_shutdown();\n            } catch (Throwable t) {\n                m_logger.error(\"Error shutting down Volt Network\", t);\n                t.printStackTrace();\n            }\n        }\n    }","commit_id":"a48519825a1cb8d99a997ed6463820195a86fc5e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    private static Iterable<Class<? extends ServerModule>> serverModulesOrDefault(\n            Class<? extends ServerModule>[] serverModules )\n    {\n        if ( serverModules == null || serverModules.length == 0 )\n        {\n            return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ThirdPartyJAXRSModule.class,\n                    WebAdminModule.class );\n        }\n        return Arrays.asList( serverModules );\n    }","id":76080,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    private static Iterable<Class<? extends ServerModule>> serverModulesOrDefault(\n            Class<? extends ServerModule>[] serverModules )\n    {\n        if ( serverModules == null || serverModules.length == 0 )\n        {\n            return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class,\n                    ThirdPartyJAXRSModule.class, WebAdminModule.class );\n        }\n        return Arrays.asList( serverModules );\n    }","commit_id":"7e2882dab2c5e317a00048ed34c0ac4a21292b73","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    @Ignore(\"Unclear contract: remove the index itself? That is unsupported in the new index api\")\n    public void shouldGet200AndBeAbleToRemoveIndexing() throws DatabaseBlockedException, JsonParseException\n    {\n        ClientResponse response = Client.create().resource( functionalTestHelper.nodeUri() ).type( MediaType.APPLICATION_FORM_URLENCODED ).accept(\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class );\n        String nodeUri = response.getHeaders().getFirst( HttpHeaders.LOCATION );\n        String key = \"key_remove\";\n        String value = \"value\";\n        String indexUri = Client.create().resource( functionalTestHelper.indexUri() + \"/node/\" + key + \"/\" + value ).entity( JsonHelper.createJsonFrom( nodeUri ),\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class ).getHeaders().getFirst( HttpHeaders.LOCATION );\n        assertEquals( 1, helper.getIndexedNodes( \"node\", key, value ).size() );\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NO_CONTENT.getStatusCode(), response.getStatus() );\n        assertEquals( 0, helper.getIndexedNodes( \"node\", key, value ).size() );\n\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n    }","id":76081,"modified_method":"/**\n     * FIXME: this is a duplicate of\n     * {@link IndexNodeFunctionalTest#shouldGet200AndBeAbleToRemoveIndexing()}\n     * it should at least be adapted for relationships\n     */\n    @Test\n    @Ignore(\"Unclear contract: remove the index itself? That is unsupported in the new index api\")\n    public void shouldGet200AndBeAbleToRemoveIndexing() throws DatabaseBlockedException, JsonParseException\n    {\n        ClientResponse response = Client.create().resource( functionalTestHelper.nodeUri() ).type( MediaType.APPLICATION_FORM_URLENCODED ).accept(\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class );\n        String nodeUri = response.getHeaders().getFirst( HttpHeaders.LOCATION );\n        String key = \"key_remove\";\n        String value = \"value\";\n        String indexUri = Client.create().resource( functionalTestHelper.indexUri() + \"/node/\" + key + \"/\" + value ).entity( JsonHelper.createJsonFrom( nodeUri ),\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class ).getHeaders().getFirst( HttpHeaders.LOCATION );\n        assertEquals( 1, helper.getIndexedNodes( \"node\", key, value ).size() );\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NO_CONTENT.getStatusCode(), response.getStatus() );\n        assertEquals( 0, helper.getIndexedNodes( \"node\", key, value ).size() );\n\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n    }","commit_id":"7e2882dab2c5e317a00048ed34c0ac4a21292b73","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setupServer() throws IOException {\n        // FIXME: is it bad that we need all modules here in order to operate?\n        // The reason we split the bootstrap class was to be able to load\n        // different modules for different product lines... needs fixing.\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().withSpecificServerModules(\n                DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class, ThirdPartyJAXRSModule.class,\n                WebAdminModule.class ).build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n    }","id":76082,"modified_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n    }","commit_id":"7e2882dab2c5e317a00048ed34c0ac4a21292b73","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public Iterable<Class<? extends ServerModule>> getServerModules()\n    {\n        return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ThirdPartyJAXRSModule.class,\n                WebAdminModule.class );\n    }","id":76083,"modified_method":"@Override\n    @SuppressWarnings( \"unchecked\" )\n    public Iterable<Class<? extends ServerModule>> getServerModules()\n    {\n        return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class,\n                ThirdPartyJAXRSModule.class, WebAdminModule.class );\n    }","commit_id":"7e2882dab2c5e317a00048ed34c0ac4a21292b73","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPickupRelativeUrisForWebAdminAndWebAdminRest() throws IOException {\n        String webAdminDataUri = \"/a/different/webadmin/data/uri/\";\n        String webAdminManagementUri = \"/a/different/webadmin/management/uri/\";\n\n        // FIXME: is it bad that we need all modules here in order to operate?\n        // The reason we split the bootstrap class was to be able to load\n        // different modules for different product lines... needs fixing.\n        server = server().withRandomDatabaseDir().withRelativeWebDataAdminUriPath( webAdminDataUri ).withRelativeWebAdminUriPath(\n                webAdminManagementUri ).withSpecificServerModules( DiscoveryModule.class, RESTApiModule.class,\n                ManagementApiModule.class, ThirdPartyJAXRSModule.class, WebAdminModule.class ).withPassingStartupHealthcheck().build();\n        server.start();\n\n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:7474\" + webAdminDataUri).accept(MediaType.TEXT_HTML).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n\n        response = client.resource(\"http://localhost:7474\" + webAdminManagementUri).accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n    }","id":76084,"modified_method":"@Test\n    public void shouldPickupRelativeUrisForWebAdminAndWebAdminRest() throws IOException {\n        String webAdminDataUri = \"/a/different/webadmin/data/uri/\";\n        String webAdminManagementUri = \"/a/different/webadmin/management/uri/\";\n\n        server = server().withRandomDatabaseDir().withRelativeWebDataAdminUriPath( webAdminDataUri ).withRelativeWebAdminUriPath(\n                webAdminManagementUri ).withPassingStartupHealthcheck().build();\n        server.start();\n\n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:7474\" + webAdminDataUri).accept(MediaType.TEXT_HTML).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n\n        response = client.resource(\"http://localhost:7474\" + webAdminManagementUri).accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n    }","commit_id":"7e2882dab2c5e317a00048ed34c0ac4a21292b73","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    private static Iterable<Class<? extends ServerModule>> serverModulesOrDefault(\n            Class<? extends ServerModule>[] serverModules )\n    {\n        if ( serverModules == null || serverModules.length == 0 )\n        {\n            return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ThirdPartyJAXRSModule.class,\n                    WebAdminModule.class );\n        }\n        return Arrays.asList( serverModules );\n    }","id":76085,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    private static Iterable<Class<? extends ServerModule>> serverModulesOrDefault(\n            Class<? extends ServerModule>[] serverModules )\n    {\n        if ( serverModules == null || serverModules.length == 0 )\n        {\n            return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class,\n                    ThirdPartyJAXRSModule.class, WebAdminModule.class );\n        }\n        return Arrays.asList( serverModules );\n    }","commit_id":"443bb894645232aafaa4dbc8fa7ac16959e54594","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    @Ignore(\"Unclear contract: remove the index itself? That is unsupported in the new index api\")\n    public void shouldGet200AndBeAbleToRemoveIndexing() throws DatabaseBlockedException, JsonParseException\n    {\n        ClientResponse response = Client.create().resource( functionalTestHelper.nodeUri() ).type( MediaType.APPLICATION_FORM_URLENCODED ).accept(\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class );\n        String nodeUri = response.getHeaders().getFirst( HttpHeaders.LOCATION );\n        String key = \"key_remove\";\n        String value = \"value\";\n        String indexUri = Client.create().resource( functionalTestHelper.indexUri() + \"/node/\" + key + \"/\" + value ).entity( JsonHelper.createJsonFrom( nodeUri ),\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class ).getHeaders().getFirst( HttpHeaders.LOCATION );\n        assertEquals( 1, helper.getIndexedNodes( \"node\", key, value ).size() );\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NO_CONTENT.getStatusCode(), response.getStatus() );\n        assertEquals( 0, helper.getIndexedNodes( \"node\", key, value ).size() );\n\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n    }","id":76086,"modified_method":"/**\n     * FIXME: this is a duplicate of\n     * {@link IndexNodeFunctionalTest#shouldGet200AndBeAbleToRemoveIndexing()}\n     * it should at least be adapted for relationships\n     */\n    @Test\n    @Ignore(\"Unclear contract: remove the index itself? That is unsupported in the new index api\")\n    public void shouldGet200AndBeAbleToRemoveIndexing() throws DatabaseBlockedException, JsonParseException\n    {\n        ClientResponse response = Client.create().resource( functionalTestHelper.nodeUri() ).type( MediaType.APPLICATION_FORM_URLENCODED ).accept(\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class );\n        String nodeUri = response.getHeaders().getFirst( HttpHeaders.LOCATION );\n        String key = \"key_remove\";\n        String value = \"value\";\n        String indexUri = Client.create().resource( functionalTestHelper.indexUri() + \"/node/\" + key + \"/\" + value ).entity( JsonHelper.createJsonFrom( nodeUri ),\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class ).getHeaders().getFirst( HttpHeaders.LOCATION );\n        assertEquals( 1, helper.getIndexedNodes( \"node\", key, value ).size() );\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NO_CONTENT.getStatusCode(), response.getStatus() );\n        assertEquals( 0, helper.getIndexedNodes( \"node\", key, value ).size() );\n\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n    }","commit_id":"443bb894645232aafaa4dbc8fa7ac16959e54594","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setupServer() throws IOException {\n        // FIXME: is it bad that we need all modules here in order to operate?\n        // The reason we split the bootstrap class was to be able to load\n        // different modules for different product lines... needs fixing.\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().withSpecificServerModules(\n                DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class, ThirdPartyJAXRSModule.class,\n                WebAdminModule.class ).build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n    }","id":76087,"modified_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n    }","commit_id":"443bb894645232aafaa4dbc8fa7ac16959e54594","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public Iterable<Class<? extends ServerModule>> getServerModules()\n    {\n        return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ThirdPartyJAXRSModule.class,\n                WebAdminModule.class );\n    }","id":76088,"modified_method":"@Override\n    @SuppressWarnings( \"unchecked\" )\n    public Iterable<Class<? extends ServerModule>> getServerModules()\n    {\n        return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class,\n                ThirdPartyJAXRSModule.class, WebAdminModule.class );\n    }","commit_id":"443bb894645232aafaa4dbc8fa7ac16959e54594","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPickupRelativeUrisForWebAdminAndWebAdminRest() throws IOException {\n        String webAdminDataUri = \"/a/different/webadmin/data/uri/\";\n        String webAdminManagementUri = \"/a/different/webadmin/management/uri/\";\n\n        // FIXME: is it bad that we need all modules here in order to operate?\n        // The reason we split the bootstrap class was to be able to load\n        // different modules for different product lines... needs fixing.\n        server = server().withRandomDatabaseDir().withRelativeWebDataAdminUriPath( webAdminDataUri ).withRelativeWebAdminUriPath(\n                webAdminManagementUri ).withSpecificServerModules( DiscoveryModule.class, RESTApiModule.class,\n                ManagementApiModule.class, ThirdPartyJAXRSModule.class, WebAdminModule.class ).withPassingStartupHealthcheck().build();\n        server.start();\n\n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:7474\" + webAdminDataUri).accept(MediaType.TEXT_HTML).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n\n        response = client.resource(\"http://localhost:7474\" + webAdminManagementUri).accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n    }","id":76089,"modified_method":"@Test\n    public void shouldPickupRelativeUrisForWebAdminAndWebAdminRest() throws IOException {\n        String webAdminDataUri = \"/a/different/webadmin/data/uri/\";\n        String webAdminManagementUri = \"/a/different/webadmin/management/uri/\";\n\n        server = server().withRandomDatabaseDir().withRelativeWebDataAdminUriPath( webAdminDataUri ).withRelativeWebAdminUriPath(\n                webAdminManagementUri ).withPassingStartupHealthcheck().build();\n        server.start();\n\n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:7474\" + webAdminDataUri).accept(MediaType.TEXT_HTML).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n\n        response = client.resource(\"http://localhost:7474\" + webAdminManagementUri).accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n    }","commit_id":"443bb894645232aafaa4dbc8fa7ac16959e54594","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    private static Iterable<Class<? extends ServerModule>> serverModulesOrDefault(\n            Class<? extends ServerModule>[] serverModules )\n    {\n        if ( serverModules == null || serverModules.length == 0 )\n        {\n            return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ThirdPartyJAXRSModule.class,\n                    WebAdminModule.class );\n        }\n        return Arrays.asList( serverModules );\n    }","id":76090,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    private static Iterable<Class<? extends ServerModule>> serverModulesOrDefault(\n            Class<? extends ServerModule>[] serverModules )\n    {\n        if ( serverModules == null || serverModules.length == 0 )\n        {\n            return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class,\n                    ThirdPartyJAXRSModule.class, WebAdminModule.class );\n        }\n        return Arrays.asList( serverModules );\n    }","commit_id":"da63c6fc7fc21e52faf5124cf296cd500ece6380","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    @Ignore(\"Unclear contract: remove the index itself? That is unsupported in the new index api\")\n    public void shouldGet200AndBeAbleToRemoveIndexing() throws DatabaseBlockedException, JsonParseException\n    {\n        ClientResponse response = Client.create().resource( functionalTestHelper.nodeUri() ).type( MediaType.APPLICATION_FORM_URLENCODED ).accept(\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class );\n        String nodeUri = response.getHeaders().getFirst( HttpHeaders.LOCATION );\n        String key = \"key_remove\";\n        String value = \"value\";\n        String indexUri = Client.create().resource( functionalTestHelper.indexUri() + \"/node/\" + key + \"/\" + value ).entity( JsonHelper.createJsonFrom( nodeUri ),\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class ).getHeaders().getFirst( HttpHeaders.LOCATION );\n        assertEquals( 1, helper.getIndexedNodes( \"node\", key, value ).size() );\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NO_CONTENT.getStatusCode(), response.getStatus() );\n        assertEquals( 0, helper.getIndexedNodes( \"node\", key, value ).size() );\n\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n    }","id":76091,"modified_method":"/**\n     * FIXME: this is a duplicate of\n     * {@link IndexNodeFunctionalTest#shouldGet200AndBeAbleToRemoveIndexing()}\n     * it should at least be adapted for relationships\n     */\n    @Test\n    @Ignore(\"Unclear contract: remove the index itself? That is unsupported in the new index api\")\n    public void shouldGet200AndBeAbleToRemoveIndexing() throws DatabaseBlockedException, JsonParseException\n    {\n        ClientResponse response = Client.create().resource( functionalTestHelper.nodeUri() ).type( MediaType.APPLICATION_FORM_URLENCODED ).accept(\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class );\n        String nodeUri = response.getHeaders().getFirst( HttpHeaders.LOCATION );\n        String key = \"key_remove\";\n        String value = \"value\";\n        String indexUri = Client.create().resource( functionalTestHelper.indexUri() + \"/node/\" + key + \"/\" + value ).entity( JsonHelper.createJsonFrom( nodeUri ),\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class ).getHeaders().getFirst( HttpHeaders.LOCATION );\n        assertEquals( 1, helper.getIndexedNodes( \"node\", key, value ).size() );\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NO_CONTENT.getStatusCode(), response.getStatus() );\n        assertEquals( 0, helper.getIndexedNodes( \"node\", key, value ).size() );\n\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n    }","commit_id":"da63c6fc7fc21e52faf5124cf296cd500ece6380","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setupServer() throws IOException {\n        // FIXME: is it bad that we need all modules here in order to operate?\n        // The reason we split the bootstrap class was to be able to load\n        // different modules for different product lines... needs fixing.\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().withSpecificServerModules(\n                DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class, ThirdPartyJAXRSModule.class,\n                WebAdminModule.class ).build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n    }","id":76092,"modified_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n    }","commit_id":"da63c6fc7fc21e52faf5124cf296cd500ece6380","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public Iterable<Class<? extends ServerModule>> getServerModules()\n    {\n        return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ThirdPartyJAXRSModule.class,\n                WebAdminModule.class );\n    }","id":76093,"modified_method":"@Override\n    @SuppressWarnings( \"unchecked\" )\n    public Iterable<Class<? extends ServerModule>> getServerModules()\n    {\n        return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class,\n                ThirdPartyJAXRSModule.class, WebAdminModule.class );\n    }","commit_id":"da63c6fc7fc21e52faf5124cf296cd500ece6380","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPickupRelativeUrisForWebAdminAndWebAdminRest() throws IOException {\n        String webAdminDataUri = \"/a/different/webadmin/data/uri/\";\n        String webAdminManagementUri = \"/a/different/webadmin/management/uri/\";\n\n        // FIXME: is it bad that we need all modules here in order to operate?\n        // The reason we split the bootstrap class was to be able to load\n        // different modules for different product lines... needs fixing.\n        server = server().withRandomDatabaseDir().withRelativeWebDataAdminUriPath( webAdminDataUri ).withRelativeWebAdminUriPath(\n                webAdminManagementUri ).withSpecificServerModules( DiscoveryModule.class, RESTApiModule.class,\n                ManagementApiModule.class, ThirdPartyJAXRSModule.class, WebAdminModule.class ).withPassingStartupHealthcheck().build();\n        server.start();\n\n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:7474\" + webAdminDataUri).accept(MediaType.TEXT_HTML).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n\n        response = client.resource(\"http://localhost:7474\" + webAdminManagementUri).accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n    }","id":76094,"modified_method":"@Test\n    public void shouldPickupRelativeUrisForWebAdminAndWebAdminRest() throws IOException {\n        String webAdminDataUri = \"/a/different/webadmin/data/uri/\";\n        String webAdminManagementUri = \"/a/different/webadmin/management/uri/\";\n\n        server = server().withRandomDatabaseDir().withRelativeWebDataAdminUriPath( webAdminDataUri ).withRelativeWebAdminUriPath(\n                webAdminManagementUri ).withPassingStartupHealthcheck().build();\n        server.start();\n\n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:7474\" + webAdminDataUri).accept(MediaType.TEXT_HTML).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n\n        response = client.resource(\"http://localhost:7474\" + webAdminManagementUri).accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n    }","commit_id":"da63c6fc7fc21e52faf5124cf296cd500ece6380","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    private static Iterable<Class<? extends ServerModule>> serverModulesOrDefault(\n            Class<? extends ServerModule>[] serverModules )\n    {\n        if ( serverModules == null || serverModules.length == 0 )\n        {\n            return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ThirdPartyJAXRSModule.class,\n                    WebAdminModule.class );\n        }\n        return Arrays.asList( serverModules );\n    }","id":76095,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    private static Iterable<Class<? extends ServerModule>> serverModulesOrDefault(\n            Class<? extends ServerModule>[] serverModules )\n    {\n        if ( serverModules == null || serverModules.length == 0 )\n        {\n            return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class,\n                    ThirdPartyJAXRSModule.class, WebAdminModule.class );\n        }\n        return Arrays.asList( serverModules );\n    }","commit_id":"a0ae85d9b9d99c8df18eb8926df2e961511b1d8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    @Ignore(\"Unclear contract: remove the index itself? That is unsupported in the new index api\")\n    public void shouldGet200AndBeAbleToRemoveIndexing() throws DatabaseBlockedException, JsonParseException\n    {\n        ClientResponse response = Client.create().resource( functionalTestHelper.nodeUri() ).type( MediaType.APPLICATION_FORM_URLENCODED ).accept(\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class );\n        String nodeUri = response.getHeaders().getFirst( HttpHeaders.LOCATION );\n        String key = \"key_remove\";\n        String value = \"value\";\n        String indexUri = Client.create().resource( functionalTestHelper.indexUri() + \"/node/\" + key + \"/\" + value ).entity( JsonHelper.createJsonFrom( nodeUri ),\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class ).getHeaders().getFirst( HttpHeaders.LOCATION );\n        assertEquals( 1, helper.getIndexedNodes( \"node\", key, value ).size() );\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NO_CONTENT.getStatusCode(), response.getStatus() );\n        assertEquals( 0, helper.getIndexedNodes( \"node\", key, value ).size() );\n\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n    }","id":76096,"modified_method":"/**\n     * FIXME: this is a duplicate of\n     * {@link IndexNodeFunctionalTest#shouldGet200AndBeAbleToRemoveIndexing()}\n     * it should at least be adapted for relationships\n     */\n    @Test\n    @Ignore(\"Unclear contract: remove the index itself? That is unsupported in the new index api\")\n    public void shouldGet200AndBeAbleToRemoveIndexing() throws DatabaseBlockedException, JsonParseException\n    {\n        ClientResponse response = Client.create().resource( functionalTestHelper.nodeUri() ).type( MediaType.APPLICATION_FORM_URLENCODED ).accept(\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class );\n        String nodeUri = response.getHeaders().getFirst( HttpHeaders.LOCATION );\n        String key = \"key_remove\";\n        String value = \"value\";\n        String indexUri = Client.create().resource( functionalTestHelper.indexUri() + \"/node/\" + key + \"/\" + value ).entity( JsonHelper.createJsonFrom( nodeUri ),\n                MediaType.APPLICATION_JSON ).post( ClientResponse.class ).getHeaders().getFirst( HttpHeaders.LOCATION );\n        assertEquals( 1, helper.getIndexedNodes( \"node\", key, value ).size() );\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NO_CONTENT.getStatusCode(), response.getStatus() );\n        assertEquals( 0, helper.getIndexedNodes( \"node\", key, value ).size() );\n\n        response = Client.create().resource( indexUri ).delete( ClientResponse.class );\n        assertEquals( Status.NOT_FOUND.getStatusCode(), response.getStatus() );\n    }","commit_id":"a0ae85d9b9d99c8df18eb8926df2e961511b1d8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setupServer() throws IOException {\n        // FIXME: is it bad that we need all modules here in order to operate?\n        // The reason we split the bootstrap class was to be able to load\n        // different modules for different product lines... needs fixing.\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().withSpecificServerModules(\n                DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class, ThirdPartyJAXRSModule.class,\n                WebAdminModule.class ).build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n    }","id":76097,"modified_method":"@Before\n    public void setupServer() throws IOException {\n        server = ServerBuilder.server().withRandomDatabaseDir().withPassingStartupHealthcheck().build();\n        server.start();\n        functionalTestHelper = new FunctionalTestHelper(server);\n    }","commit_id":"a0ae85d9b9d99c8df18eb8926df2e961511b1d8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public Iterable<Class<? extends ServerModule>> getServerModules()\n    {\n        return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ThirdPartyJAXRSModule.class,\n                WebAdminModule.class );\n    }","id":76098,"modified_method":"@Override\n    @SuppressWarnings( \"unchecked\" )\n    public Iterable<Class<? extends ServerModule>> getServerModules()\n    {\n        return Arrays.asList( DiscoveryModule.class, RESTApiModule.class, ManagementApiModule.class,\n                ThirdPartyJAXRSModule.class, WebAdminModule.class );\n    }","commit_id":"a0ae85d9b9d99c8df18eb8926df2e961511b1d8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPickupRelativeUrisForWebAdminAndWebAdminRest() throws IOException {\n        String webAdminDataUri = \"/a/different/webadmin/data/uri/\";\n        String webAdminManagementUri = \"/a/different/webadmin/management/uri/\";\n\n        // FIXME: is it bad that we need all modules here in order to operate?\n        // The reason we split the bootstrap class was to be able to load\n        // different modules for different product lines... needs fixing.\n        server = server().withRandomDatabaseDir().withRelativeWebDataAdminUriPath( webAdminDataUri ).withRelativeWebAdminUriPath(\n                webAdminManagementUri ).withSpecificServerModules( DiscoveryModule.class, RESTApiModule.class,\n                ManagementApiModule.class, ThirdPartyJAXRSModule.class, WebAdminModule.class ).withPassingStartupHealthcheck().build();\n        server.start();\n\n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:7474\" + webAdminDataUri).accept(MediaType.TEXT_HTML).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n\n        response = client.resource(\"http://localhost:7474\" + webAdminManagementUri).accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n    }","id":76099,"modified_method":"@Test\n    public void shouldPickupRelativeUrisForWebAdminAndWebAdminRest() throws IOException {\n        String webAdminDataUri = \"/a/different/webadmin/data/uri/\";\n        String webAdminManagementUri = \"/a/different/webadmin/management/uri/\";\n\n        server = server().withRandomDatabaseDir().withRelativeWebDataAdminUriPath( webAdminDataUri ).withRelativeWebAdminUriPath(\n                webAdminManagementUri ).withPassingStartupHealthcheck().build();\n        server.start();\n\n        Client client = Client.create();\n        ClientResponse response = client.resource(\"http://localhost:7474\" + webAdminDataUri).accept(MediaType.TEXT_HTML).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n\n        response = client.resource(\"http://localhost:7474\" + webAdminManagementUri).accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n        assertEquals(200, response.getStatus());\n    }","commit_id":"a0ae85d9b9d99c8df18eb8926df2e961511b1d8f","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void syncModel0(int offset, int limit) {\r\n\t\tint min = offset;\r\n\t\tint max = offset + limit - 1;\r\n\t\t\r\n\t\tfinal ListModel _model = _listbox.getModel();\r\n\t\tfinal int newsz = _model.getSize();\r\n\t\tfinal int oldsz = _listbox.getItemCount();\r\n\t\tfinal Paginal _pgi = _listbox.getPaginal();\r\n\t\tfinal boolean inPaging = inPagingMold();\r\n\t\tfinal boolean shallInvalidated = //Bug 3147518: avoid memory leak\r\n\t\t\t(min < 0 || min == 0) && (max < 0 || max >= newsz || max >= oldsz);\r\n\r\n\t\tint newcnt = newsz - oldsz;\r\n\t\tint atg = _pgi != null ? _listbox.getActivePage(): 0;\r\n\t\tListitemRenderer renderer = null;\r\n\t\tComponent next = null;\t\t\r\n\t\tif (oldsz > 0) {\r\n\t\t\tif (min < 0) min = 0;\r\n\t\t\telse if (min > oldsz - 1) min = oldsz - 1;\r\n\t\t\tif (max < 0) max = oldsz - 1;\r\n\t\t\telse if (max > oldsz - 1) max = oldsz - 1;\r\n\t\t\tif (min > max) {\r\n\t\t\t\tint t = min; min = max; max = t;\r\n\t\t\t}\r\n\r\n\t\t\tint cnt = max - min + 1; //# of affected\r\n\t\t\tif (_model instanceof GroupsListModel) {\r\n\t\t\t//detach all from end to front since groupfoot\r\n\t\t\t//must be detached before group\r\n\t\t\t\tnewcnt += cnt; //add affected later\r\n\t\t\t\tif ((shallInvalidated || newcnt > INVALIDATE_THRESHOLD) && !inPaging)\r\n\t\t\t\t\t_listbox.invalidate();\r\n\t\t\t\t\t\t//Bug 3147518: avoid memory leak\r\n\t\t\t\t\t\t//Also better performance (outer better than remove a lot)\r\n\r\n\t\t\t\tComponent comp = _listbox.getItemAtIndex(max);\r\n\t\t\t\tnext = comp.getNextSibling();\r\n\t\t\t\twhile (--cnt >= 0) {\r\n\t\t\t\t\tComponent p = comp.getPreviousSibling();\r\n\t\t\t\t\tcomp.detach();\r\n\t\t\t\t\tcomp = p;\r\n\t\t\t\t}\r\n\t\t\t} else { //ListModel\r\n\t\t\t\tint addcnt = 0;\r\n\t\t\t\tComponent item = _listbox.getItemAtIndex(min);\r\n\t\t\t\twhile (--cnt >= 0) {\r\n\t\t\t\t\tnext = item.getNextSibling();\r\n\r\n\t\t\t\t\tif (cnt < -newcnt) { //if shrink, -newcnt > 0\r\n\t\t\t\t\t\titem.detach(); //remove extra\r\n\t\t\t\t\t} else if (((Listitem)item).isLoaded()) {\r\n\t\t\t\t\t\tif (renderer == null)\r\n\t\t\t\t\t\t\trenderer = (ListitemRenderer) getRealRenderer();\r\n\t\t\t\t\t\titem.detach(); //always detach\r\n\t\t\t\t\t\t_listbox.insertBefore(newUnloadedItem(renderer, min), next);\r\n\t\t\t\t\t\t++addcnt;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t++min;\r\n\t\t\t\t\titem = next;//B2100338.,next item could be Paging, don't use Listitem directly\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ((shallInvalidated || addcnt > INVALIDATE_THRESHOLD || addcnt + newcnt > INVALIDATE_THRESHOLD)\r\n\t\t\t\t&& !inPagingMold())\r\n\t\t\t\t\t_listbox.invalidate();\r\n\t\t\t\t\t\t//Bug 3147518: avoid memory leak\r\n\t\t\t\t\t\t//Also better performance (outer better than remove a lot)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmin = 0;\r\n\t\t}\r\n\r\n\t\tfor (; --newcnt >= 0; ++min) {\r\n\t\t\tif (renderer == null)\r\n\t\t\t\trenderer = (ListitemRenderer)getRealRenderer();\r\n\t\t\t_listbox.insertBefore(newUnloadedItem(renderer, min), next);\r\n\t\t}\r\n\t\tif (_pgi != null) {\r\n\t\t\tif (atg >= _pgi.getPageCount())\r\n\t\t\t\tatg = _pgi.getPageCount() - 1;\r\n\t\t\t_pgi.setActivePage(atg);\r\n\t\t\tif (_pgi.getTotalSize() != newsz)\r\n\t\t\t\t_pgi.setTotalSize(newsz); //Bug ZK-1601: reset total size since model size may changed.\r\n\t\t}\r\n\t}","id":76100,"modified_method":"private void syncModel0(int offset, int limit) {\r\n\t\tint min = offset;\r\n\t\tint max = offset + limit - 1;\r\n\t\t\r\n\t\tfinal ListModel _model = _listbox.getModel();\r\n\t\tfinal int newsz = _model.getSize();\r\n\t\tfinal int oldsz = _listbox.getItemCount();\r\n\t\tfinal Paginal _pgi = _listbox.getPaginal();\r\n\t\tfinal boolean inPaging = inPagingMold();\r\n\t\tfinal boolean shallInvalidated = //Bug 3147518: avoid memory leak\r\n\t\t\t(min < 0 || min == 0) && (max < 0 || max >= newsz || max >= oldsz);\r\n\r\n\t\tint newcnt = newsz - oldsz;\r\n\t\tint atg = _pgi != null ? _listbox.getActivePage(): 0;\r\n\t\tListitemRenderer renderer = null;\r\n\t\tComponent next = null;\t\t\r\n\t\tif (oldsz > 0) {\r\n\t\t\tif (min < 0) min = 0;\r\n\t\t\telse if (min > oldsz - 1) min = oldsz - 1;\r\n\t\t\tif (max < 0) max = oldsz - 1;\r\n\t\t\telse if (max > oldsz - 1) max = oldsz - 1;\r\n\t\t\tif (min > max) {\r\n\t\t\t\tint t = min; min = max; max = t;\r\n\t\t\t}\r\n\r\n\t\t\tint cnt = max - min + 1; //# of affected\r\n\t\t\tif (_model instanceof GroupsListModel) {\r\n\t\t\t//detach all from end to front since groupfoot\r\n\t\t\t//must be detached before group\r\n\t\t\t\tnewcnt += cnt; //add affected later\r\n\t\t\t\tif ((shallInvalidated || newcnt > INVALIDATE_THRESHOLD) && !inPaging)\r\n\t\t\t\t\t_listbox.invalidate();\r\n\t\t\t\t\t\t//Bug 3147518: avoid memory leak\r\n\t\t\t\t\t\t//Also better performance (outer better than remove a lot)\r\n\r\n\t\t\t\tComponent comp = _listbox.getItemAtIndex(max);\r\n\t\t\t\tnext = comp.getNextSibling();\r\n\t\t\t\twhile (--cnt >= 0) {\r\n\t\t\t\t\tComponent p = comp.getPreviousSibling();\r\n\t\t\t\t\tcomp.detach();\r\n\t\t\t\t\tcomp = p;\r\n\t\t\t\t}\r\n\t\t\t} else { //ListModel\r\n\t\t\t\tint addcnt = 0;\r\n\t\t\t\tComponent item = _listbox.getItemAtIndex(min);\r\n\t\t\t\twhile (--cnt >= 0) {\r\n\t\t\t\t\tnext = item.getNextSibling();\r\n\r\n\t\t\t\t\tif (cnt < -newcnt) { //if shrink, -newcnt > 0\r\n\t\t\t\t\t\titem.detach(); //remove extra\r\n\t\t\t\t\t} else if (((Listitem)item).isLoaded()) {\r\n\t\t\t\t\t\tif (renderer == null)\r\n\t\t\t\t\t\t\trenderer = (ListitemRenderer) getRealRenderer();\r\n\r\n\t\t\t\t\t\t// ZK-2450: cache selected Index and item, added them back after detach item\r\n\t\t\t\t\t\tif(_pgi != null && ((Listitem) item).isSelected()) {\r\n\t\t\t\t\t\t\tint index = ((Listitem) item).getIndex();\r\n\t\t\t\t\t\t\titem.detach(); // always detach\r\n\t\t\t\t\t\t\tListitem newItem = newUnloadedItem(renderer, min);\r\n\t\t\t\t\t\t\t_listbox.insertBefore(newItem, next);\r\n\t\t\t\t\t\t\t_listbox.addItemToSelection(newItem);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\titem.detach(); //always detach\r\n\t\t\t\t\t\t\t_listbox.insertBefore(newUnloadedItem(renderer, min), next);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t++addcnt;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t++min;\r\n\t\t\t\t\titem = next;//B2100338.,next item could be Paging, don't use Listitem directly\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ((shallInvalidated || addcnt > INVALIDATE_THRESHOLD || addcnt + newcnt > INVALIDATE_THRESHOLD)\r\n\t\t\t\t&& !inPagingMold())\r\n\t\t\t\t\t_listbox.invalidate();\r\n\t\t\t\t\t\t//Bug 3147518: avoid memory leak\r\n\t\t\t\t\t\t//Also better performance (outer better than remove a lot)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmin = 0;\r\n\t\t}\r\n\r\n\t\tfor (; --newcnt >= 0; ++min) {\r\n\t\t\tif (renderer == null)\r\n\t\t\t\trenderer = (ListitemRenderer)getRealRenderer();\r\n\t\t\t_listbox.insertBefore(newUnloadedItem(renderer, min), next);\r\n\t\t}\r\n\t\tif (_pgi != null) {\r\n\t\t\tif (atg >= _pgi.getPageCount())\r\n\t\t\t\tatg = _pgi.getPageCount() - 1;\r\n\t\t\t_pgi.setActivePage(atg);\r\n\t\t\tif (_pgi.getTotalSize() != newsz)\r\n\t\t\t\t_pgi.setTotalSize(newsz); //Bug ZK-1601: reset total size since model size may changed.\r\n\t\t}\r\n\t}","commit_id":"7cfa4c1a4cc9502626b7d949e18fed3cdf169694","url":"https://github.com/zkoss/zk"},{"original_method":"public void service(Page page) {\n\t\t\ttry {\n\t\t\t\tfinal StringWriter out = new StringWriter();\n\t\t\t\tgetJspBody().invoke(out);\n\t\t\t\tUtils.adjustChildren(\n\t\t\t\t\tpage, null, page.getRoots(), out.toString());\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t}\n\t\t}","id":76101,"modified_method":"public void service(Page page) {\n\t\t\ttry {\n\t\t\t\tfinal StringWriter out = new StringWriter();\n\t\t\t\tgetJspBody().invoke(out);\n\t\t\t\tUtils.adjustChildren(\n\t\t\t\t\tpage, null, page.getRoots(), out.toString());\n\t\t\t} catch (Exception ex) {\n\t\t\t\tlog.realCauseBriefly(ex); //Apache Jasper Compiler eats ex\n\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t}\n\t\t}","commit_id":"e3651aeda418d779bd0529d8485eb477677f6b6a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Adjust the children based the output generated by the inner\n\t * tags of {@link BranchTag} (aka., body).\n\t *\n\t * @param page the page. Specified ony if parent is null (aka. root).\n\t * @param parent the parent component. If null, page must be specified.\n\t */\n\t/*package*/ static void adjustChildren(Page page, Component parent,\n\tCollection children, String body) {\nSystem.out.println(\"process:\\n\"+body);\n\t\tIterator it = new ArrayList(children).iterator();\n\t\tfor (int j = 0, len = body != null ? body.length(): 0; j < len;) {\n\t\t\tint k = body.indexOf(MARK_PREFIX, j);\n\t\t\tString s = (k >= 0 ? body.substring(j, k): body.substring(j)).trim();\n\t\t\tif (s.length() > 0) {\n\t\t\t\tfinal Inline inl = new Inline(s);\n\t\t\t\tif (it.hasNext()) {\n\t\t\t\t\tComponent child = (Component)it.next();\n\t\t\t\t\tparent.insertBefore(inl, child);\n\t\t\t\t} else {\n\t\t\t\t\tparent.appendChild(inl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (it.hasNext())\n\t\t\t((Component)it.next()).detach();\n\t}","id":76102,"modified_method":"/** Adjust the children based the output generated by the inner\n\t * tags of {@link BranchTag} (aka., body).\n\t *\n\t * @param page the page. Specified ony if parent is null (aka. root).\n\t * @param parent the parent component. If null, page must be specified.\n\t */\n\t/*package*/ static void adjustChildren(Page page, Component parent,\n\tCollection children, String body) {\n\t\tListIterator it = new ArrayList(children).listIterator();\n\t\tfor (int j = 0, len = body != null ? body.length(): 0; j < len;) {\n\t\t\tint k = body.indexOf(MARK_PREFIX, j);\n\t\t\tString txt =  null, uuid = null;\n\t\t\tif (k >= 0) {\n\t\t\t\tint l = k + MARK_PREFIX.length();\n\t\t\t\tint m = body.indexOf(MARK_POSTFIX, l);\n\t\t\t\tif (m <= l) { //not found or empty uuid\n\t\t\t\t\tk = -1;\n\t\t\t\t} else {\n\t\t\t\t\ttxt = body.substring(j, k).trim();\n\t\t\t\t\tuuid = body.substring(l, m);\n\t\t\t\t\tk = m + MARK_POSTFIX.length();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k < 0)\n\t\t\t\ttxt = body.substring(j).trim();\n\n\t\t\tif (txt.length() > 0) {\n\t\t\t\tfinal Inline inl = new Inline(txt);\n\t\t\t\tfinal Component child = matchNext(it, uuid);\n\t\t\t\tif (child != null) {\n\t\t\t\t\tif (parent != null)\n\t\t\t\t\t\tparent.insertBefore(inl, child);\n\t\t\t\t\telse\n\t\t\t\t\t\tinl.setPageBefore(page, child);\n\t\t\t\t} else {\n\t\t\t\t\tif (parent != null)\n\t\t\t\t\t\tparent.appendChild(inl);\n\t\t\t\t\telse\n\t\t\t\t\t\tinl.setPage(page);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (k < 0) break; //no more\n\t\t\tj = k;\n\t\t}\n\n\t\twhile (it.hasNext())\n\t\t\t((Component)it.next()).detach();\n\t}","commit_id":"e3651aeda418d779bd0529d8485eb477677f6b6a","url":"https://github.com/zkoss/zk"},{"original_method":"public Component newComponent() {\n\t\treturn new Window();\n\t}","id":76103,"modified_method":"public Component newComponent() {\n\t\tfinal Window wnd = new Window();\n\t\twnd.setTitle(_title);\n\t\treturn wnd;\n\t}","commit_id":"e3651aeda418d779bd0529d8485eb477677f6b6a","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void filter(Document document)\n    {\n        for (Node p : findEmptyParagraphSequences(document)) {\n            Node next = p.getNextSibling();\n            // Remove the first empty paragraph.\n            p.getParentNode().removeChild(p);\n            // Replace the following ones with a <br> element.\n            while (isEmptyLine(next)) {\n                Node following = next.getNextSibling();\n                next.getParentNode().insertBefore(document.createElement(\"br\"), next);\n                next.getParentNode().removeChild(next);\n                next = following;\n            }\n        }\n    }","id":76104,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void filter(Document document)\n    {\n        for (Node p : findEmptyParagraphSequences(document)) {\n            Node next = p.getNextSibling();\n            // Remove the first empty paragraph.\n            p.getParentNode().removeChild(p);\n            // Replace the following ones by their children elements.\n            while (isEmptyLine(next)) {\n                Node following = next.getNextSibling();\n                while (null != next.getFirstChild()) {\n                    Node child = next.removeChild(next.getFirstChild());\n                    next.getParentNode().insertBefore(child, next);\n                }\n                next.getParentNode().removeChild(next);\n                next = following;\n            }\n        }\n    }","commit_id":"3256b70315d8aa4c03ed14386a8adbc750d237d2","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public byte[] referrerHash() {\r\n        // return the creator's hash\r\n        return entry.getColBytes(col_referrer, true);\r\n    }","id":76105,"modified_method":"public byte[] referrerHash() {\r\n        // return the creator's hash or null if there is none\r\n        // FIXME: There seem to be some malformed entries in the databasees like \"null\\0\\0\\0\\0\\0\\0\\0\\0\"\r\n        final byte[] r = entry.getColBytes(col_referrer, true);\r\n        if (r != null) {\r\n            int i = r.length;\r\n            while (i > 0) {\r\n                if (r[--i] == 0) return null;\r\n            }\r\n        }\r\n        return r;\r\n    }","commit_id":"ef467a03034299ea096e28147920959d0a13e3fa","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public plasmaCrawlBalancer(File stackFile) {\r\n        stack = kelondroStack.open(stackFile, new kelondroRow(\"byte[] urlhash-\" + yacySeedDB.commonHashLength, kelondroBase64Order.enhancedCoder, 0));\r\n        domainStacks = new HashMap();\r\n    }","id":76106,"modified_method":"public plasmaCrawlBalancer(File stackFile) {\r\n        stack = kelondroStack.open(stackFile, new kelondroRow(\"byte[] urlhash-\" + yacySeedDB.commonHashLength, kelondroBase64Order.enhancedCoder, 0));\r\n        domainStacks = new HashMap();\r\n        domainAccess = new HashMap();\r\n    }","commit_id":"8c1d2e022761fbc3289cacc577804510034c9f7b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private Entry pop(plasmaCrawlBalancer balancer) throws IOException {\r\n        // this is a filo - pop\r\n        if (balancer.size() > 0) {\r\n            String hash = new String(balancer.get());\r\n            if (hash == null) throw new IOException(\"hash is null\");\r\n            Entry e = new Entry(hash);\r\n            stackIndex.remove(e.hash);\r\n            return e;\r\n        } else {\r\n            throw new IOException(\"balancer stack is empty\");\r\n        }\r\n    }","id":76107,"modified_method":"private Entry pop(plasmaCrawlBalancer balancer) throws IOException {\r\n        // this is a filo - pop\r\n        if (balancer.size() > 0) {\r\n            String hash = balancer.get(minimumDelta);\r\n            if (hash == null) throw new IOException(\"hash is null\");\r\n            Entry e = new Entry(hash);\r\n            stackIndex.remove(e.hash);\r\n            return e;\r\n        } else {\r\n            throw new IOException(\"balancer stack is empty\");\r\n        }\r\n    }","commit_id":"8c1d2e022761fbc3289cacc577804510034c9f7b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public kelondroProfile profile() {\n        if (index0 != null) return index0.profile();\n        if (index1 != null) return index1.profile();\n        return null;\n    }","id":76108,"modified_method":"public kelondroProfile profile() {\n        if (index0 == null) return index1.profile();\n        if (index1 == null) return index0.profile();\n        return kelondroProfile.consolidate(index0.profile(), index1.profile());\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized int geti(byte[] key) throws IOException {\n        assert (key != null);\n        //assert (!(serverLog.allZero(key)));\n        if (index0 != null) {\n            if (index1 == null) {\n                // finish initialization phase\n                if (index0 instanceof kelondroRowSet) {\n                    ((kelondroRowSet) index0).sort();\n                    ((kelondroRowSet) index0).uniq(10000);\n                }\n                index1 = new kelondroRowSet(rowdef, 0);\n                //System.out.println(\"finished initialization phase at size = \" + index0.size() + \" in geti\");\n            }\n            kelondroRow.Entry indexentry = index0.get(key);\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            if (indexentry != null) return (int) indexentry.getColLong(1);\n        }\n        if (index1 != null) {\n            kelondroRow.Entry indexentry = index1.get(key);\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            if (indexentry != null) return (int) indexentry.getColLong(1);\n        }\n        //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n        return -1;\n    }","id":76109,"modified_method":"public synchronized int geti(byte[] key) throws IOException {\n        assert (key != null);\n        //assert (!(serverLog.allZero(key)));\n        if (index0 != null) {\n            if (index1 == null) {\n                // finish initialization phase\n                if (index0 instanceof kelondroRowSet) {\n                    ((kelondroRowSet) index0).sort();\n                    ((kelondroRowSet) index0).uniq(10000);\n                }\n                index1 = new kelondroRowSet(rowdef, 0);\n                //System.out.println(\"finished initialization phase at size = \" + index0.size() + \" in geti\");\n            }\n            kelondroRow.Entry indexentry = index0.get(key);\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            if (indexentry != null) return (int) indexentry.getColLong(1);\n        }\n        assert (index1 != null);\n        kelondroRow.Entry indexentry = index1.get(key);\n        //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n        if (indexentry == null) return -1;\n        return (int) indexentry.getColLong(1);\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized kelondroCloneableIterator rows(boolean up, byte[] firstKey) throws IOException {\n        // returns the row-iterator of the underlying kelondroIndex\n        // col[0] = key\n        // col[1] = integer as {b265}\n        if ((index0 != null) && (index1 == null)) {\n            // finish initialization phase\n            if (index0 instanceof kelondroRowSet) {\n                ((kelondroRowSet) index0).sort();\n                ((kelondroRowSet) index0).uniq(10000);\n            }\n            index1 = new kelondroRowSet(rowdef, 0);\n            //System.out.println(\"finished initialization phase at size = \" + index0.size() + \" in rows\");\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            return index0.rows(up, firstKey);\n        }\n        if ((index0 == null) && (index1 != null)) {\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            return index1.rows(up, firstKey);\n        }\n        assert ((index0 != null) && (index1 != null));\n        //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n        return new kelondroMergeIterator(index0.rows(up, firstKey), index1.rows(up, firstKey), rowdef.objectOrder, kelondroMergeIterator.simpleMerge, true);\n    }","id":76110,"modified_method":"public synchronized kelondroCloneableIterator rows(boolean up, byte[] firstKey) throws IOException {\n        // returns the row-iterator of the underlying kelondroIndex\n        // col[0] = key\n        // col[1] = integer as {b265}\n        if ((index0 != null) && (index1 == null)) {\n            // finish initialization phase\n            if (index0 instanceof kelondroRowSet) {\n                ((kelondroRowSet) index0).sort();\n                ((kelondroRowSet) index0).uniq(10000);\n            }\n            index1 = new kelondroRowSet(rowdef, 0);\n            //System.out.println(\"finished initialization phase at size = \" + index0.size() + \" in rows\");\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            return index0.rows(up, firstKey);\n        }\n        assert (index1 != null);\n        if (index0 == null) {\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            return index1.rows(up, firstKey);\n        }\n        //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n        return new kelondroMergeIterator(\n                index0.rows(up, firstKey),\n                index1.rows(up, firstKey),\n                rowdef.objectOrder,\n                kelondroMergeIterator.simpleMerge,\n                true);\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Iterator rows() {\n    \treturn new kelondroMergeIterator(\n    \t\t\t\tindex0.rows(true, null),\n    \t\t\t\tindex1.rows(true, null),\n    \t\t\t\trowdef.objectOrder,\n    \t\t\t\tkelondroMergeIterator.simpleMerge,\n                    true);\n    }","id":76111,"modified_method":"public Iterator rows() {\n        if (index0 != null) {\n            if (index1 == null) {\n                // finish initialization phase\n                index0.sort();\n                index0.uniq(10000);\n                index1 = new kelondroRowSet(rowdef, 0); \n            }\n            return index0.rows(true, null);\n        }\n        assert (index1 != null);\n    \tif (index0 == null) {\n            return index1.rows(true, null);\n        }\n        return new kelondroMergeIterator(\n    \t\t\t\tindex0.rows(true, null),\n    \t\t\t\tindex1.rows(true, null),\n    \t\t\t\trowdef.objectOrder,\n    \t\t\t\tkelondroMergeIterator.simpleMerge,\n                    true);\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public byte[] getb(int ii) {\n    \tbyte[] key = kelondroNaturalOrder.encodeLong((long) ii, 4);\n        kelondroRow.Entry indexentry = index0.get(key);\n        if (indexentry == null) indexentry = index1.get(key);\n        if (indexentry == null) return null;\n        return indexentry.getColBytes(1);\n    }","id":76112,"modified_method":"public byte[] getb(int ii) {\n        assert ii >= 0 : \"i = \" + ii;\n    \tbyte[] key = kelondroNaturalOrder.encodeLong((long) ii, 4);\n        if (index0 != null) {\n            if (index1 == null) {\n                // finish initialization phase\n                index0.sort();\n                index0.uniq(10000);\n                index1 = new kelondroRowSet(rowdef, 0); \n            }\n            kelondroRow.Entry indexentry = index0.get(key);\n            if (indexentry != null) return indexentry.getColBytes(1);\n        }\n        assert (index1 != null);\n        kelondroRow.Entry indexentry = index1.get(key);\n        if (indexentry == null) return null;\n        return indexentry.getColBytes(1);\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public byte[] removeb(int ii) {\n        if ((index0.size() == 0) && (index1.size() == 0)) return null;\n        byte[] key = kelondroNaturalOrder.encodeLong((long) ii, 4);\n        kelondroRow.Entry indexentry = index0.remove(key);\n        if (indexentry != null) {\n        \treturn indexentry.getColBytes(1);\n        }\n        indexentry = index1.remove(key);\n        if (indexentry == null) return null;\n        return indexentry.getColBytes(1);\n    }","id":76113,"modified_method":"public byte[] removeb(int ii) {\n        assert ii >= 0 : \"i = \" + ii;\n        \n        byte[] key = kelondroNaturalOrder.encodeLong((long) ii, 4);\n        if (index0 != null) {\n            if (index1 == null) {\n                // finish initialization phase\n                index0.sort();\n                index0.uniq(10000);\n                index1 = new kelondroRowSet(rowdef, 0); \n            }\n            kelondroRow.Entry indexentry = index0.remove(key);\n            if (indexentry != null) {\n                return indexentry.getColBytes(1);\n            }\n            // else remove it from the index1\n        }\n        // at this point index1 cannot be null\n        assert (index1 != null);\n        if (index1.size() == 0) return null;\n        kelondroRow.Entry indexentry = index1.remove(key);\n        if (indexentry == null) return null;\n        return indexentry.getColBytes(1);\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public long memoryNeededForGrow() {\n        return index1.memoryNeededForGrow();\n    }","id":76114,"modified_method":"public long memoryNeededForGrow() {\n        if (index1 == null) \n            return index0.memoryNeededForGrow();\n        else\n            return index1.memoryNeededForGrow();\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void flush() {\n        index0.sort();\n        index0.trim(true);\n        index1.sort();\n        index1.trim(true);\n    }","id":76115,"modified_method":"public void flush() {\n        if (index0 != null) {\n            index0.sort();\n            index0.trim(true);\n        }\n        if (index1 != null) {\n            index1.sort();\n            index1.trim(true);\n        }\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public kelondroProfile profile() {\n    \treturn kelondroProfile.consolidate(index0.profile(), index1.profile());\n    }","id":76116,"modified_method":"public kelondroProfile profile() {\n        if (index0 == null) return index1.profile();\n        if (index1 == null) return index0.profile();\n        return kelondroProfile.consolidate(index0.profile(), index1.profile());\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public kelondroIntBytesMap(int payloadSize, int initSize) {\n    \trowdef = new kelondroRow(\"Cardinal key-4 {b256}, byte[] payload-\" + payloadSize, kelondroNaturalOrder.naturalOrder, 0);\n        index0 = new kelondroRowSet(rowdef, initSize);\n        index1 = new kelondroRowSet(rowdef, 0);\n        initPhase = true;\n    }","id":76117,"modified_method":"public kelondroIntBytesMap(int payloadSize, int initSize) {\n    \trowdef = new kelondroRow(\"Cardinal key-4 {b256}, byte[] payload-\" + payloadSize, kelondroNaturalOrder.naturalOrder, 0);\n        index0 = new kelondroRowSet(rowdef, initSize);\n        index1 = null;\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public int size() {\n        return index0.size() + index1.size();\n    }","id":76118,"modified_method":"public int size() {\n        if ((index0 != null) && (index1 == null)) {\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            return index0.size();\n        }\n        if ((index0 == null) && (index1 != null)) {\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            return index1.size();\n        }\n        assert ((index0 != null) && (index1 != null));\n        //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n        return index0.size() + index1.size();\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public byte[] putb(int ii, byte[] value) {\n    \tinitPhase = false;\n    \tkelondroRow.Entry newentry = rowdef.newEntry();\n        newentry.setCol(0, (long) ii);\n        newentry.setCol(1, value);\n        kelondroRow.Entry indexentry = index0.get(kelondroNaturalOrder.encodeLong((long) ii, 4));\n    \tif (indexentry != null) {\n    \t\tindex0.put(newentry);\n    \t\treturn indexentry.getColBytes(1);\n    \t}\n        kelondroRow.Entry oldentry = index1.put(newentry);\n        if (oldentry == null) return null;\n        return oldentry.getColBytes(1);\n    }","id":76119,"modified_method":"public byte[] putb(int ii, byte[] value) {\n        assert ii >= 0 : \"i = \" + ii;\n        assert value != null;\n        byte[] key = kelondroNaturalOrder.encodeLong((long) ii, 4);\n        if (index0 != null) {\n            if (index1 == null) {\n                // finish initialization phase\n                index0.sort();\n                index0.uniq(10000);\n                index1 = new kelondroRowSet(rowdef, 0); \n            }\n            kelondroRow.Entry indexentry = index0.get(key);\n            if (indexentry != null) {\n                byte[] oldv = indexentry.getColBytes(1);\n                indexentry.setCol(0, key);\n                indexentry.setCol(1, value);\n                index0.put(indexentry);\n                return oldv;\n            }\n            // else place it in the index1\n        }\n        // at this point index1 cannot be null\n        assert (index1 != null);\n        \n        kelondroRow.Entry newentry = rowdef.newEntry();\n        newentry.setCol(0, (long) ii);\n        newentry.setCol(1, value);\n        kelondroRow.Entry oldentry = index1.put(newentry);\n        if (oldentry == null) return null;\n        return oldentry.getColBytes(1);\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void addb(int ii, byte[] value) {\n    \tassert initPhase;\n        kelondroRow.Entry newentry = index0.row().newEntry();\n        newentry.setCol(0, (long) ii);\n        newentry.setCol(1, value);\n        index0.addUnique(newentry);\n    }","id":76120,"modified_method":"public void addb(int ii, byte[] value) {\n    \tassert index1 == null; // valid only in init-phase\n        assert ii >= 0 : \"i = \" + ii;\n        assert value != null;\n        kelondroRow.Entry newentry = index0.row().newEntry();\n        newentry.setCol(0, (long) ii);\n        newentry.setCol(1, value);\n        index0.addUnique(newentry);\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public byte[] removeoneb() {\n    \tif ((index0.size() == 0) && (index1.size() == 0)) return null;\n    \tif (index1.size() == 0) {\n    \t\tkelondroRow.Entry indexentry = index0.removeOne();\n            if (indexentry == null) return null;\n            return indexentry.getColBytes(1);\n    \t}\n        kelondroRow.Entry indexentry = index1.removeOne();\n        if (indexentry == null) return null;\n        return indexentry.getColBytes(1);\n    }","id":76121,"modified_method":"public byte[] removeoneb() {\n        if ((index1 != null) && (index1.size() != 0)) {\n            kelondroRow.Entry indexentry = index1.removeOne();\n            assert (indexentry != null);\n            if (indexentry == null) return null;\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            return indexentry.getColBytes(1);\n        }\n        if ((index0 != null) && (index0.size() != 0)) {\n            kelondroRow.Entry indexentry = index0.removeOne();\n            assert (indexentry != null);\n            if (indexentry == null) return null;\n            //assert consistencyAnalysis0() : \"consistency problem: \" + consistencyAnalysis();\n            return indexentry.getColBytes(1);\n        }\n        return null;\n    }","commit_id":"3c5ff7f73533bb129dacbc3725f292011cc0c4ed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, BlogsEntry entry)\n\t\tthrows Exception {\n\n\t\tElement entryElement = portletDataContext.getExportDataElement(entry);\n\n\t\tif (entry.isSmallImage()) {\n\t\t\tImage smallImage = ImageLocalServiceUtil.fetchImage(\n\t\t\t\tentry.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(entry.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\t\tportletDataContext, entry,\n\t\t\t\t\t\tentry.getSmallImageURL().concat(StringPool.SPACE),\n\t\t\t\t\t\ttrue);\n\n\t\t\t\tentry.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\tentry,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\tsmallImage.getType());\n\n\t\t\t\tentryElement.addAttribute(\"small-image-path\", smallImagePath);\n\n\t\t\t\tentry.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tString content = ExportImportHelperUtil.replaceExportContentReferences(\n\t\t\tportletDataContext, entry, entry.getContent(),\n\t\t\tportletDataContext.getBooleanParameter(\n\t\t\t\tBlogsPortletDataHandler.NAMESPACE, \"referenced-content\"));\n\n\t\tentry.setContent(content);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tentryElement, ExportImportPathUtil.getModelPath(entry), entry);\n\t}","id":76122,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, BlogsEntry entry)\n\t\tthrows Exception {\n\n\t\tElement entryElement = portletDataContext.getExportDataElement(entry);\n\n\t\tif (entry.isSmallImage()) {\n\t\t\tImage smallImage = ImageLocalServiceUtil.fetchImage(\n\t\t\t\tentry.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(entry.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\t\tportletDataContext, entry,\n\t\t\t\t\t\tentry.getSmallImageURL() + StringPool.SPACE, true);\n\n\t\t\t\tentry.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\tentry,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\tsmallImage.getType());\n\n\t\t\t\tentryElement.addAttribute(\"small-image-path\", smallImagePath);\n\n\t\t\t\tentry.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tString content = ExportImportHelperUtil.replaceExportContentReferences(\n\t\t\tportletDataContext, entry, entry.getContent(),\n\t\t\tportletDataContext.getBooleanParameter(\n\t\t\t\tBlogsPortletDataHandler.NAMESPACE, \"referenced-content\"));\n\n\t\tentry.setContent(content);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tentryElement, ExportImportPathUtil.getModelPath(entry), entry);\n\t}","commit_id":"f281bd901a042336a6d9d9e9af194bfb3701fea5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, BlogsEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(entry.getUserUuid());\n\n\t\tElement entryElement =\n\t\t\tportletDataContext.getImportDataStagedModelElement(entry);\n\n\t\tString content = ExportImportHelperUtil.replaceImportContentReferences(\n\t\t\tportletDataContext, entry, entry.getContent());\n\n\t\tentry.setContent(content);\n\n\t\tCalendar displayDateCal = CalendarFactoryUtil.getCalendar();\n\n\t\tdisplayDateCal.setTime(entry.getDisplayDate());\n\n\t\tint displayDateMonth = displayDateCal.get(Calendar.MONTH);\n\t\tint displayDateDay = displayDateCal.get(Calendar.DATE);\n\t\tint displayDateYear = displayDateCal.get(Calendar.YEAR);\n\t\tint displayDateHour = displayDateCal.get(Calendar.HOUR);\n\t\tint displayDateMinute = displayDateCal.get(Calendar.MINUTE);\n\n\t\tif (displayDateCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\tdisplayDateHour += 12;\n\t\t}\n\n\t\tboolean allowPingbacks = entry.isAllowPingbacks();\n\t\tboolean allowTrackbacks = entry.isAllowTrackbacks();\n\t\tString[] trackbacks = StringUtil.split(entry.getTrackbacks());\n\n\t\tString smallImageFileName = null;\n\t\tInputStream smallImageInputStream = null;\n\n\t\ttry {\n\t\t\tif (entry.isSmallImage()) {\n\t\t\t\tString smallImagePath = entryElement.attributeValue(\n\t\t\t\t\t\"small-image-path\");\n\n\t\t\t\tif (Validator.isNotNull(entry.getSmallImageURL())) {\n\t\t\t\t\tString smallImageURL =\n\t\t\t\t\t\tExportImportHelperUtil.replaceImportContentReferences(\n\t\t\t\t\t\t\tportletDataContext, entry,\n\t\t\t\t\t\t\tentry.getSmallImageURL());\n\n\t\t\t\t\tentry.setSmallImageURL(smallImageURL);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(smallImagePath)) {\n\t\t\t\t\tsmallImageFileName = String.valueOf(\n\t\t\t\t\t\tentry.getSmallImageId()).concat(\n\t\t\t\t\t\t\tStringPool.PERIOD).concat(\n\t\t\t\t\t\t\t\tentry.getSmallImageType());\n\n\t\t\t\t\tsmallImageInputStream =\n\t\t\t\t\t\tportletDataContext.getZipEntryAsInputStream(\n\t\t\t\t\t\t\tsmallImagePath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tServiceContext serviceContext =\n\t\t\t\tportletDataContext.createServiceContext(entry);\n\n\t\t\tBlogsEntry importedEntry = null;\n\n\t\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\t\tserviceContext.setAttribute(\"urlTitle\", entry.getUrlTitle());\n\n\t\t\t\tBlogsEntry existingEntry =\n\t\t\t\t\tBlogsEntryLocalServiceUtil.fetchBlogsEntryByUuidAndGroupId(\n\t\t\t\t\t\tentry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\t\tif (existingEntry == null) {\n\t\t\t\t\tserviceContext.setUuid(entry.getUuid());\n\n\t\t\t\t\timportedEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tuserId, entry.getTitle(), entry.getDeckTitle(),\n\t\t\t\t\t\tentry.getDescription(), entry.getContent(),\n\t\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\t\tdisplayDateHour, displayDateMinute, allowPingbacks,\n\t\t\t\t\t\tallowTrackbacks, trackbacks, entry.isSmallImage(),\n\t\t\t\t\t\tentry.getSmallImageURL(), smallImageFileName,\n\t\t\t\t\t\tsmallImageInputStream, serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedEntry = BlogsEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\t\tuserId, existingEntry.getEntryId(), entry.getTitle(),\n\t\t\t\t\t\tentry.getDeckTitle(), entry.getDescription(),\n\t\t\t\t\t\tentry.getContent(), displayDateMonth, displayDateDay,\n\t\t\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\t\t\tallowPingbacks, allowTrackbacks, trackbacks,\n\t\t\t\t\t\tentry.isSmallImage(), entry.getSmallImageURL(),\n\t\t\t\t\t\tsmallImageFileName, smallImageInputStream,\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tuserId, entry.getTitle(), entry.getDeckTitle(),\n\t\t\t\t\tentry.getDescription(), entry.getContent(),\n\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\tdisplayDateHour, displayDateMinute, allowPingbacks,\n\t\t\t\t\tallowTrackbacks, trackbacks, entry.isSmallImage(),\n\t\t\t\t\tentry.getSmallImageURL(), smallImageFileName,\n\t\t\t\t\tsmallImageInputStream, serviceContext);\n\t\t\t}\n\n\t\t\tportletDataContext.importClassedModel(entry, importedEntry);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(smallImageInputStream);\n\t\t}\n\t}","id":76123,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, BlogsEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(entry.getUserUuid());\n\n\t\tElement entryElement =\n\t\t\tportletDataContext.getImportDataStagedModelElement(entry);\n\n\t\tString content = ExportImportHelperUtil.replaceImportContentReferences(\n\t\t\tportletDataContext, entry, entry.getContent());\n\n\t\tentry.setContent(content);\n\n\t\tCalendar displayDateCal = CalendarFactoryUtil.getCalendar();\n\n\t\tdisplayDateCal.setTime(entry.getDisplayDate());\n\n\t\tint displayDateMonth = displayDateCal.get(Calendar.MONTH);\n\t\tint displayDateDay = displayDateCal.get(Calendar.DATE);\n\t\tint displayDateYear = displayDateCal.get(Calendar.YEAR);\n\t\tint displayDateHour = displayDateCal.get(Calendar.HOUR);\n\t\tint displayDateMinute = displayDateCal.get(Calendar.MINUTE);\n\n\t\tif (displayDateCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\tdisplayDateHour += 12;\n\t\t}\n\n\t\tboolean allowPingbacks = entry.isAllowPingbacks();\n\t\tboolean allowTrackbacks = entry.isAllowTrackbacks();\n\t\tString[] trackbacks = StringUtil.split(entry.getTrackbacks());\n\n\t\tString smallImageFileName = null;\n\t\tInputStream smallImageInputStream = null;\n\n\t\ttry {\n\t\t\tif (entry.isSmallImage()) {\n\t\t\t\tString smallImagePath = entryElement.attributeValue(\n\t\t\t\t\t\"small-image-path\");\n\n\t\t\t\tif (Validator.isNotNull(entry.getSmallImageURL())) {\n\t\t\t\t\tString smallImageURL =\n\t\t\t\t\t\tExportImportHelperUtil.replaceImportContentReferences(\n\t\t\t\t\t\t\tportletDataContext, entry,\n\t\t\t\t\t\t\tentry.getSmallImageURL());\n\n\t\t\t\t\tentry.setSmallImageURL(smallImageURL);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(smallImagePath)) {\n\t\t\t\t\tsmallImageFileName =\n\t\t\t\t\t\tentry.getSmallImageId() + StringPool.PERIOD +\n\t\t\t\t\t\t\tentry.getSmallImageType();\n\n\t\t\t\t\tsmallImageInputStream =\n\t\t\t\t\t\tportletDataContext.getZipEntryAsInputStream(\n\t\t\t\t\t\t\tsmallImagePath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tServiceContext serviceContext =\n\t\t\t\tportletDataContext.createServiceContext(entry);\n\n\t\t\tBlogsEntry importedEntry = null;\n\n\t\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\t\tserviceContext.setAttribute(\"urlTitle\", entry.getUrlTitle());\n\n\t\t\t\tBlogsEntry existingEntry =\n\t\t\t\t\tBlogsEntryLocalServiceUtil.fetchBlogsEntryByUuidAndGroupId(\n\t\t\t\t\t\tentry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\t\tif (existingEntry == null) {\n\t\t\t\t\tserviceContext.setUuid(entry.getUuid());\n\n\t\t\t\t\timportedEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tuserId, entry.getTitle(), entry.getDeckTitle(),\n\t\t\t\t\t\tentry.getDescription(), entry.getContent(),\n\t\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\t\tdisplayDateHour, displayDateMinute, allowPingbacks,\n\t\t\t\t\t\tallowTrackbacks, trackbacks, entry.isSmallImage(),\n\t\t\t\t\t\tentry.getSmallImageURL(), smallImageFileName,\n\t\t\t\t\t\tsmallImageInputStream, serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedEntry = BlogsEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\t\tuserId, existingEntry.getEntryId(), entry.getTitle(),\n\t\t\t\t\t\tentry.getDeckTitle(), entry.getDescription(),\n\t\t\t\t\t\tentry.getContent(), displayDateMonth, displayDateDay,\n\t\t\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\t\t\tallowPingbacks, allowTrackbacks, trackbacks,\n\t\t\t\t\t\tentry.isSmallImage(), entry.getSmallImageURL(),\n\t\t\t\t\t\tsmallImageFileName, smallImageInputStream,\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tuserId, entry.getTitle(), entry.getDeckTitle(),\n\t\t\t\t\tentry.getDescription(), entry.getContent(),\n\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\tdisplayDateHour, displayDateMinute, allowPingbacks,\n\t\t\t\t\tallowTrackbacks, trackbacks, entry.isSmallImage(),\n\t\t\t\t\tentry.getSmallImageURL(), smallImageFileName,\n\t\t\t\t\tsmallImageInputStream, serviceContext);\n\t\t\t}\n\n\t\t\tportletDataContext.importClassedModel(entry, importedEntry);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(smallImageInputStream);\n\t\t}\n\t}","commit_id":"f281bd901a042336a6d9d9e9af194bfb3701fea5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tElement templateElement = portletDataContext.getExportDataElement(\n\t\t\ttemplate);\n\n\t\tDDMStructure structure = DDMStructureLocalServiceUtil.fetchStructure(\n\t\t\ttemplate.getClassPK());\n\n\t\tif (structure != null) {\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, template, structure,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\t\t}\n\n\t\tif (template.isSmallImage()) {\n\t\t\tImage smallImage = ImageLocalServiceUtil.fetchImage(\n\t\t\t\ttemplate.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\t\tportletDataContext, template,\n\t\t\t\t\t\ttemplate.getSmallImageURL().concat(StringPool.SPACE),\n\t\t\t\t\t\ttrue);\n\n\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\ttemplate,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\ttemplateElement.addAttribute(\n\t\t\t\t\t\"small-image-path\", smallImagePath);\n\n\t\t\t\ttemplate.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDDMPortletDataHandler.NAMESPACE, \"referenced-content\")) {\n\n\t\t\tString content =\n\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\tportletDataContext, template, template.getScript(), true);\n\n\t\t\ttemplate.setScript(content);\n\t\t}\n\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(\n\t\t\ttemplate.getCompanyId());\n\n\t\tif (defaultUserId == template.getUserId()) {\n\t\t\ttemplateElement.addAttribute(\"preloaded\", \"true\");\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\ttemplateElement, ExportImportPathUtil.getModelPath(template),\n\t\t\ttemplate);\n\t}","id":76124,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tElement templateElement = portletDataContext.getExportDataElement(\n\t\t\ttemplate);\n\n\t\tDDMStructure structure = DDMStructureLocalServiceUtil.fetchStructure(\n\t\t\ttemplate.getClassPK());\n\n\t\tif (structure != null) {\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, template, structure,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\t\t}\n\n\t\tif (template.isSmallImage()) {\n\t\t\tImage smallImage = ImageLocalServiceUtil.fetchImage(\n\t\t\t\ttemplate.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\t\tportletDataContext, template,\n\t\t\t\t\t\ttemplate.getSmallImageURL() + StringPool.SPACE,\n\t\t\t\t\t\ttrue);\n\n\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\ttemplate,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\ttemplateElement.addAttribute(\n\t\t\t\t\t\"small-image-path\", smallImagePath);\n\n\t\t\t\ttemplate.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDDMPortletDataHandler.NAMESPACE, \"referenced-content\")) {\n\n\t\t\tString content =\n\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\tportletDataContext, template, template.getScript(), true);\n\n\t\t\ttemplate.setScript(content);\n\t\t}\n\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(\n\t\t\ttemplate.getCompanyId());\n\n\t\tif (defaultUserId == template.getUserId()) {\n\t\t\ttemplateElement.addAttribute(\"preloaded\", \"true\");\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\ttemplateElement, ExportImportPathUtil.getModelPath(template),\n\t\t\ttemplate);\n\t}","commit_id":"f281bd901a042336a6d9d9e9af194bfb3701fea5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, JournalArticle article)\n\t\tthrows Exception {\n\n\t\tElement articleElement = portletDataContext.getExportDataElement(\n\t\t\tarticle);\n\n\t\tarticleElement.addAttribute(\n\t\t\t\"article-resource-uuid\", article.getArticleResourceUuid());\n\n\t\tif (article.getFolderId() !=\n\t\t\t\tJournalFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, article, article.getFolder(),\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\n\t\tDDMStructure ddmStructure = DDMStructureLocalServiceUtil.getStructure(\n\t\t\tarticle.getGroupId(),\n\t\t\tPortalUtil.getClassNameId(JournalArticle.class),\n\t\t\tarticle.getStructureId(), true);\n\n\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\tportletDataContext, article, ddmStructure,\n\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\n\t\tDDMTemplate ddmTemplate = DDMTemplateLocalServiceUtil.getTemplate(\n\t\t\tarticle.getGroupId(), PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tarticle.getTemplateId(), true);\n\n\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\tportletDataContext, article, ddmTemplate,\n\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\n\t\tif (Validator.isNotNull(article.getLayoutUuid())) {\n\t\t\tLayout layout = LayoutLocalServiceUtil.getLayoutByUuidAndCompanyId(\n\t\t\t\tarticle.getLayoutUuid(), portletDataContext.getCompanyId());\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tarticle, articleElement, layout,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_DEPENDENCY, true);\n\t\t}\n\n\t\tif (article.isSmallImage()) {\n\t\t\tImage smallImage = ImageLocalServiceUtil.fetchImage(\n\t\t\t\tarticle.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(article.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\t\tportletDataContext, article,\n\t\t\t\t\t\tarticle.getSmallImageURL().concat(StringPool.SPACE),\n\t\t\t\t\t\ttrue);\n\n\t\t\t\tarticle.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\tarticle,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\tsmallImage.getType());\n\n\t\t\t\tarticleElement.addAttribute(\"small-image-path\", smallImagePath);\n\n\t\t\t\tarticle.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tList<JournalArticleImage> articleImages =\n\t\t\tJournalArticleImageLocalServiceUtil.getArticleImages(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion());\n\n\t\tfor (JournalArticleImage articleImage : articleImages) {\n\t\t\texportArticleImage(\n\t\t\t\tportletDataContext, articleImage, article, articleElement);\n\t\t}\n\n\t\tarticle.setStatusByUserUuid(article.getStatusByUserUuid());\n\n\t\tString content = ExportImportHelperUtil.replaceExportContentReferences(\n\t\t\tportletDataContext, article, article.getContent(),\n\t\t\tportletDataContext.getBooleanParameter(\n\t\t\t\tJournalPortletDataHandler.NAMESPACE, \"referenced-content\"));\n\n\t\tarticle.setContent(content);\n\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(\n\t\t\tarticle.getCompanyId());\n\n\t\tif (defaultUserId == article.getUserId()) {\n\t\t\tarticleElement.addAttribute(\"preloaded\", \"true\");\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tarticleElement, ExportImportPathUtil.getModelPath(article),\n\t\t\tarticle);\n\t}","id":76125,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, JournalArticle article)\n\t\tthrows Exception {\n\n\t\tElement articleElement = portletDataContext.getExportDataElement(\n\t\t\tarticle);\n\n\t\tarticleElement.addAttribute(\n\t\t\t\"article-resource-uuid\", article.getArticleResourceUuid());\n\n\t\tif (article.getFolderId() !=\n\t\t\t\tJournalFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, article, article.getFolder(),\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\n\t\tDDMStructure ddmStructure = DDMStructureLocalServiceUtil.getStructure(\n\t\t\tarticle.getGroupId(),\n\t\t\tPortalUtil.getClassNameId(JournalArticle.class),\n\t\t\tarticle.getStructureId(), true);\n\n\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\tportletDataContext, article, ddmStructure,\n\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\n\t\tDDMTemplate ddmTemplate = DDMTemplateLocalServiceUtil.getTemplate(\n\t\t\tarticle.getGroupId(), PortalUtil.getClassNameId(DDMStructure.class),\n\t\t\tarticle.getTemplateId(), true);\n\n\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\tportletDataContext, article, ddmTemplate,\n\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\n\t\tif (Validator.isNotNull(article.getLayoutUuid())) {\n\t\t\tLayout layout = LayoutLocalServiceUtil.getLayoutByUuidAndCompanyId(\n\t\t\t\tarticle.getLayoutUuid(), portletDataContext.getCompanyId());\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tarticle, articleElement, layout,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_DEPENDENCY, true);\n\t\t}\n\n\t\tif (article.isSmallImage()) {\n\t\t\tImage smallImage = ImageLocalServiceUtil.fetchImage(\n\t\t\t\tarticle.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(article.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\t\tportletDataContext, article,\n\t\t\t\t\t\tarticle.getSmallImageURL() + StringPool.SPACE, true);\n\n\t\t\t\tarticle.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\tarticle,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\tsmallImage.getType());\n\n\t\t\t\tarticleElement.addAttribute(\"small-image-path\", smallImagePath);\n\n\t\t\t\tarticle.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tList<JournalArticleImage> articleImages =\n\t\t\tJournalArticleImageLocalServiceUtil.getArticleImages(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion());\n\n\t\tfor (JournalArticleImage articleImage : articleImages) {\n\t\t\texportArticleImage(\n\t\t\t\tportletDataContext, articleImage, article, articleElement);\n\t\t}\n\n\t\tarticle.setStatusByUserUuid(article.getStatusByUserUuid());\n\n\t\tString content = ExportImportHelperUtil.replaceExportContentReferences(\n\t\t\tportletDataContext, article, article.getContent(),\n\t\t\tportletDataContext.getBooleanParameter(\n\t\t\t\tJournalPortletDataHandler.NAMESPACE, \"referenced-content\"));\n\n\t\tarticle.setContent(content);\n\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(\n\t\t\tarticle.getCompanyId());\n\n\t\tif (defaultUserId == article.getUserId()) {\n\t\t\tarticleElement.addAttribute(\"preloaded\", \"true\");\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tarticleElement, ExportImportPathUtil.getModelPath(article),\n\t\t\tarticle);\n\t}","commit_id":"f281bd901a042336a6d9d9e9af194bfb3701fea5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public LazyPointerImpl(PsiElement element) {\n    if (element instanceof PsiCompiledElement) {\n      myElement = element;\n    }\n    else if (element instanceof PsiMember) {\n      myPointer = setupPointer(element);\n    }\n    else {\n      myAnchor = new PsiAnchor(element);\n    }\n  }","id":76126,"modified_method":"public LazyPointerImpl(E element) {\n    myElementClass = element.getClass();\n    if (element instanceof PsiCompiledElement) {\n      myElement = element;\n    }\n    else if (element instanceof PsiMember) {\n      myPointer = setupPointer(element);\n    }\n    else {\n      myAnchor = new PsiAnchor(element);\n    }\n  }","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getElement() {\n    if (myElement != null) return myElement.isValid() ? myElement : null;\n    if (myPointer != null) return myPointer.getElement();\n    return myAnchor.retrieve();\n  }","id":76127,"modified_method":"public E getElement() {\n    if (myElement != null) return myElement.isValid() ? myElement : null;\n    if (myPointer != null) return (E) myPointer.getElement();\n    final PsiElement psiElement = myAnchor.retrieve();\n    if (psiElement != null) {\n      return myElementClass.isAssignableFrom(psiElement.getClass()) ? (E) psiElement : null;\n    }\n\n    return null;\n  }","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull public abstract SmartPsiElementPointer createSmartPsiElementPointer(PsiElement element);","id":76128,"modified_method":"@NotNull public abstract <E extends PsiElement> SmartPsiElementPointer<E> createSmartPsiElementPointer(E element);","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull public abstract SmartPsiElementPointer createLazyPointer(PsiElement element);","id":76129,"modified_method":"@NotNull public abstract <E extends PsiElement> SmartPsiElementPointer<E> createLazyPointer(E element);","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public SmartPsiElementPointer createSmartPsiElementPointer(PsiElement element) {\n    if (!element.isValid()) {\n      LOG.assertTrue(false, \"Invalid element:\" + element);\n    }\n\n    SmartPointerEx pointer = new SmartPsiElementPointerImpl(myProject, element);\n    initPointer(element, pointer);\n\n    return pointer;\n  }","id":76130,"modified_method":"@NotNull\n  public <E extends PsiElement> SmartPsiElementPointer<E> createSmartPsiElementPointer(E element) {\n    if (!element.isValid()) {\n      LOG.assertTrue(false, \"Invalid element:\" + element);\n    }\n\n    SmartPointerEx<E> pointer = new SmartPsiElementPointerImpl<E>(myProject, element);\n    initPointer(element, pointer);\n\n    return pointer;\n  }","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public SmartPsiElementPointer createLazyPointer(PsiElement element) {\n    LazyPointerImpl pointer = new LazyPointerImpl(element);\n    initPointer(element, pointer);\n    return pointer;\n  }","id":76131,"modified_method":"@NotNull\n  public <E extends PsiElement> SmartPsiElementPointer<E> createLazyPointer(E element) {\n    LazyPointerImpl<E> pointer = new LazyPointerImpl<E>(element);\n    initPointer(element, pointer);\n    return pointer;\n  }","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initPointer(PsiElement element, SmartPointerEx pointer) {\n    PsiFile file = element.getContainingFile();\n    if (file != null) {\n      synchronized (file) {\n        Document document = PsiDocumentManager.getInstance(myProject).getCachedDocument(file);\n        if (document != null) {\n          //[ven] this is a really NASTY hack; when no smart pointer is kept on UsageInfo then remove this conditional\n          if (!(element instanceof PsiFile)) {\n            PsiDocumentManagerImpl documentManager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(myProject);\n            LOG.assertTrue(!documentManager.isUncommited(document) || documentManager.isCommitingDocument(document), \"Document for : \" + file + \" is not commited\");\n          }\n        }\n\n        ArrayList<WeakReference<SmartPointerEx>> pointers = file.getUserData(SMART_POINTERS_IN_PSI_FILE_KEY);\n        if (pointers == null) {\n          pointers = new ArrayList<WeakReference<SmartPointerEx>>();\n          file.putUserData(SMART_POINTERS_IN_PSI_FILE_KEY, pointers);\n        }\n        pointers.add(new WeakReference<SmartPointerEx>(pointer));\n\n        Boolean isFasten = file.getUserData(BELTS_ARE_FASTEN_KEY);\n        if (isFasten == Boolean.TRUE) {\n          pointer.fastenBelt();\n        }\n      }\n    }\n  }","id":76132,"modified_method":"private <E extends PsiElement> void initPointer(E element, SmartPointerEx<E> pointer) {\n    PsiFile file = element.getContainingFile();\n    if (file != null) {\n      synchronized (file) {\n        Document document = PsiDocumentManager.getInstance(myProject).getCachedDocument(file);\n        if (document != null) {\n          //[ven] this is a really NASTY hack; when no smart pointer is kept on UsageInfo then remove this conditional\n          if (!(element instanceof PsiFile)) {\n            PsiDocumentManagerImpl documentManager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(myProject);\n            LOG.assertTrue(!documentManager.isUncommited(document) || documentManager.isCommitingDocument(document), \"Document for : \" + file + \" is not commited\");\n          }\n        }\n\n        ArrayList<WeakReference<SmartPointerEx>> pointers = file.getUserData(SMART_POINTERS_IN_PSI_FILE_KEY);\n        if (pointers == null) {\n          pointers = new ArrayList<WeakReference<SmartPointerEx>>();\n          file.putUserData(SMART_POINTERS_IN_PSI_FILE_KEY, pointers);\n        }\n        pointers.add(new WeakReference<SmartPointerEx>(pointer));\n\n        Boolean isFasten = file.getUserData(BELTS_ARE_FASTEN_KEY);\n        if (isFasten == Boolean.TRUE) {\n          pointer.fastenBelt();\n        }\n      }\n    }\n  }","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SmartPsiElementPointerImpl(Project project, PsiElement element) {\n    myProject = project;\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    myElement = element;\n    myElementInfo = null;\n\n    // Assert document commited.\n    PsiFile file = element.getContainingFile();\n    if (file != null) {\n      PsiDocumentManagerImpl documentManager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(project);\n      Document doc = documentManager.getCachedDocument(file);\n      if (doc != null) {\n        //[ven] this is a really NASTY hack; when no smart pointer is kept on UsageInfo then remove this conditional\n        if (!(element instanceof PsiFile)) {\n          LOG.assertTrue(!documentManager.isUncommited(doc) || documentManager.isCommitingDocument(doc));\n        }\n      }\n    }\n  }","id":76133,"modified_method":"public SmartPsiElementPointerImpl(Project project, E element) {\n    myProject = project;\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    myElement = element;\n    myElementInfo = null;\n\n    // Assert document commited.\n    PsiFile file = element.getContainingFile();\n    if (file != null) {\n      PsiDocumentManagerImpl documentManager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(project);\n      Document doc = documentManager.getCachedDocument(file);\n      if (doc != null) {\n        //[ven] this is a really NASTY hack; when no smart pointer is kept on UsageInfo then remove this conditional\n        if (!(element instanceof PsiFile)) {\n          LOG.assertTrue(!documentManager.isUncommited(doc) || documentManager.isCommitingDocument(doc));\n        }\n      }\n    }\n  }","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getElement() {\n    if (myElement != null && !myElement.isValid()) {\n      if (myElementInfo == null) {\n        myElement = null;\n      }\n      else {\n        PsiElement restored = myElementInfo.restoreElement();\n        if (restored != null && (!areElementKindEqual(restored, myElement) || !restored.isValid())) {\n          restored = null;\n        }\n        myElement = restored;\n      }\n    }\n\n    if (myElementInfo != null && myElement != null) {\n      Document document = myElementInfo.getDocumentToSynchronize();\n      if (document != null && PsiDocumentManager.getInstance(myProject).isUncommited(document)) return myElement; // keep element info if document is modified\n    }\n    myElementInfo = null;\n\n    return myElement;\n  }","id":76134,"modified_method":"public E getElement() {\n    if (myElement != null && !myElement.isValid()) {\n      if (myElementInfo == null) {\n        myElement = null;\n      }\n      else {\n        PsiElement restored = myElementInfo.restoreElement();\n        if (restored != null && (!areElementKindEqual(restored, myElement) || !restored.isValid())) {\n          restored = null;\n        }\n\n        myElement = (E) restored;\n      }\n    }\n\n    if (myElementInfo != null && myElement != null) {\n      Document document = myElementInfo.getDocumentToSynchronize();\n      if (document != null && PsiDocumentManager.getInstance(myProject).isUncommited(document)) return myElement; // keep element info if document is modified\n    }\n    myElementInfo = null;\n\n    return myElement;\n  }","commit_id":"faa454a4fa415c0a1abb6a0ae9d15c22777dd9da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void analyze(String fileName) throws IOException {\n        LineNumberReader r = new LineNumberReader(new FileReader(fileName));\n        int totalLineCount = 0, traversedLineCount = 0;\n        TreeMap<String, QueryStats> queries = new TreeMap<String, QueryStats>();\n        while (true) {\n            String line = r.readLine();\n            if (line == null) {\n                break;\n            }\n            totalLineCount++;\n            String number = retrieve(line, \"Traversed \", \" nodes \");\n            if (number == null) {\n                continue;\n            }\n            traversedLineCount++;\n            line = line.substring(line.indexOf(\"Traversed \" + number + \" nodes \"));\n            // String index = retrieve(line, \"nodes using index \", \" with filter\");\n            String rawQuery = retrieve(line, \"Filter(query=\", null);\n            String query = filterParams(rawQuery);\n            if (query == null) {\n                System.out.println(\"Unknown line: \" + line);\n            }\n            String xpath = retrieve(query, \"/* xpath: \", \"*/, \");\n            String key = query;\n            if (xpath != null) {\n                key = xpath;\n                int index = query.indexOf(xpath);\n                query = query.substring(0, index) + query.substring(index + xpath.length());\n            }\n            QueryStats q = queries.get(key);\n            if (q == null) {\n                q = new QueryStats();\n                queries.put(key, q);\n                q.query = query;\n                q.xpath = xpath;\n            }\n            q.lineCount++;\n            int nodes = Integer.parseInt(number);\n            if (nodes > q.maxNodeCount) {\n                q.longestQuery = rawQuery;\n                q.maxNodeCount = nodes;\n            }\n            if (q.lastNodeCount == 0 || nodes < q.lastNodeCount) {\n                // start\n                q.runCount++;\n                q.lastNodeCount = 0;\n            } else {\n                // continuation\n            }\n            q.nodeCount += nodes - q.lastNodeCount;\n            q.lastNodeCount = nodes;\n        }\n        System.out.println(\"File: \" + fileName);\n        System.out.println(\"Lines: \" + totalLineCount);\n        System.out.println(\"Lines with 'Traversed': \" + traversedLineCount);\n        ArrayList<QueryStats> list = new ArrayList<QueryStats>();\n        list.addAll(queries.values());\n        Collections.sort(list);\n        for (QueryStats q : list) {\n            System.out.println();\n            if (q.xpath != null) {\n                System.out.println(\"  XPath: \" + q.xpath);\n            }\n            System.out.println(\"  SQL-2: \" + q.query);\n            System.out.println(\"  Longest: \" + q.longestQuery);\n            System.out.printf(\"  %,d nodes traversed; \" + \n                    \"ran %,d times, max %,d nodes, %,d lines\\n\",\n                    q.nodeCount, \n                    q.runCount, q.maxNodeCount, q.lineCount                    \n                    );\n        }\n        System.out.println();\n        r.close();\n    }","id":76135,"modified_method":"private static void analyze(String fileName) throws IOException {\n        LineNumberReader r = new LineNumberReader(new FileReader(fileName));\n        int totalLineCount = 0, traversedLineCount = 0;\n        TreeMap<String, QueryStats> queries = new TreeMap<String, QueryStats>();\n        while (true) {\n            String line = r.readLine();\n            if (line == null) {\n                break;\n            }\n            totalLineCount++;\n            String number = retrieve(line, \"Traversed \", \" nodes \");\n            if (number == null) {\n                continue;\n            }\n            traversedLineCount++;\n            line = line.substring(line.indexOf(\"Traversed \" + number + \" nodes \"));\n            String index = retrieve(line, \"nodes using index \", \" with filter\");\n            String rawQuery = retrieve(line, \"Filter(query=\", null);\n            if (rawQuery == null) {\n                System.out.println(\"Unknown line: \" + line);\n            }\n            String rawXpath = retrieve(rawQuery, \"/* xpath: \", \"*/, \");\n            String query = filterParams(rawQuery);\n            if (rawXpath != null) {\n                rawQuery = rawXpath;\n                query = filterParams(rawXpath);\n            }\n            String key = query;\n            QueryStats q = queries.get(key);\n            if (q == null) {\n                q = new QueryStats();\n                queries.put(key, q);\n                q.query = query;\n            }\n            q.index = index;\n            q.lineCount++;\n            int nodes = Integer.parseInt(number);\n            if (nodes > q.maxNodeCount) {\n                q.longestQuery = rawQuery;\n                q.maxNodeCount = nodes;\n            }\n            if (q.lastNodeCount == 0 || nodes < q.lastNodeCount) {\n                // start\n                q.runCount++;\n                q.lastNodeCount = 0;\n            } else {\n                // continuation\n            }\n            q.nodeCount += nodes - q.lastNodeCount;\n            q.lastNodeCount = nodes;\n        }\n        System.out.println(\"File: \" + fileName);\n        System.out.println(\"Lines: \" + totalLineCount);\n        System.out.println(\"Lines with 'Traversed': \" + traversedLineCount);\n        ArrayList<QueryStats> list = new ArrayList<QueryStats>();\n        list.addAll(queries.values());\n        Collections.sort(list);\n        for (QueryStats q : list) {\n            System.out.println();\n            System.out.println(\"  Query: \" + formatQuery(q.query));\n            if (!q.query.equals(q.longestQuery)) {\n                System.out.println(\"  Longest: \" + formatQuery(q.longestQuery));\n            }\n            if (q.index != null) {\n                System.out.println(\"  Index: \" + q.index);\n            }\n            System.out.printf(\"  %,d nodes traversed; \" + \n                    \"ran %,d times, max %,d nodes, %,d lines\\n\",\n                    q.nodeCount, \n                    q.runCount, q.maxNodeCount, q.lineCount                    \n                    );\n        }\n        System.out.println();\n        r.close();\n    }","commit_id":"4ac1715b4abbe64ca788cc3334f5a2400fd3d9cb","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n  public Object createAnchor(Object element) {\n    if (element instanceof PsiElement) {\n      PsiElement psiElement = (PsiElement)element;\n      PsiAnchor anchor = psiElement.getUserData(PSI_ANCHORIZER_ANCHOR);\n      if (anchor == null) {\n        if (!psiElement.isValid()) return psiElement;\n        psiElement.putUserData(PSI_ANCHORIZER_ANCHOR, anchor = PsiAnchor.create(psiElement));\n      }\n      return anchor;\n    }\n    return super.createAnchor(element);\n  }","id":76136,"modified_method":"@Override\n  public Object createAnchor(Object element) {\n    if (element instanceof PsiElement) {\n      final PsiElement psiElement = (PsiElement)element;\n\n      return ApplicationManager.getApplication().runReadAction(new Computable<Object>() {\n        @Override\n        public Object compute() {\n          PsiAnchor anchor = psiElement.getUserData(PSI_ANCHORIZER_ANCHOR);\n          if (!psiElement.isValid()) {\n            return anchor != null ? anchor : psiElement;\n          }\n\n          if (anchor == null || anchor.retrieve() != psiElement) {\n            psiElement.putUserData(PSI_ANCHORIZER_ANCHOR, anchor = PsiAnchor.create(psiElement));\n          }\n          return anchor;\n        }\n      });\n    }\n    return super.createAnchor(element);\n  }","commit_id":"01a6bf4c966a71c878ac19f8616d312c2a18e921","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public Object retrieveElement(Object pointer) {\n    if (pointer instanceof PsiAnchor) {\n      return ((PsiAnchor)pointer).retrieve();\n    }\n\n    return super.retrieveElement(pointer);\n  }","id":76137,"modified_method":"@Override\n  @Nullable\n  public Object retrieveElement(Object pointer) {\n    if (pointer instanceof PsiAnchor) {\n      PsiElement retrieve = ((PsiAnchor)pointer).retrieve();\n      if (retrieve == null) {\n        System.out.println(\"Null anchor: \" + pointer);\n      }\n      return retrieve;\n    }\n\n    return super.retrieveElement(pointer);\n  }","commit_id":"01a6bf4c966a71c878ac19f8616d312c2a18e921","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void fastenBelt() {\n    if (myAnchor != null) {\n      myPointer = setupPointer(myAnchor.retrieve());\n      ((SmartPointerEx)myPointer).fastenBelt();\n      myAnchor = null;\n    }\n  }","id":76138,"modified_method":"public void fastenBelt() {\n    if (myAnchor != null) {\n      final PsiElement element = myAnchor.retrieve();\n      if (element != null) {\n        myPointer = setupPointer(element);\n        ((SmartPointerEx)myPointer).fastenBelt();\n        myAnchor = null;\n      }\n      else myAnchor = null;\n    }\n  }","commit_id":"4217181efcd92f85e3f6a66a04dd787efa38cd2a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void connectRelationship( RelationshipRecord rel ) \n\t\tthrows IOException \n\t{\n\t\tNodeRecord firstNode = getNodeRecord( rel.getFirstNode() );\n\t\tif ( firstNode == null )\n\t\t{\n\t\t\tfirstNode = getNodeStore().getRecord( rel.getFirstNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( firstNode );\n\t\t}\n\t\tNodeRecord secondNode = getNodeRecord( rel.getSecondNode() );\n\t\tif ( secondNode == null )\n\t\t{\n\t\t\tsecondNode = getNodeStore().getRecord( rel.getSecondNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( secondNode );\n\t\t}\n\t\tassert firstNode.getNextRel() != rel.getId();\n\t\tassert secondNode.getNextRel() != rel.getId();\n\t\trel.setFirstNextRel( firstNode.getNextRel() );\n\t\trel.setSecondNextRel( secondNode.getNextRel() );\n\t\tif ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tfirstNode.getNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tfirstNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tfirstNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\tif ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tsecondNode.getNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tsecondNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tsecondNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\tfirstNode.setNextRel( rel.getId() );\n\t\tsecondNode.setNextRel( rel.getId() );\n\t}","id":76139,"modified_method":"private void connectRelationship( RelationshipRecord rel ) \n\t\tthrows IOException \n\t{\n\t\tNodeRecord firstNode = getNodeRecord( rel.getFirstNode() );\n\t\tif ( firstNode == null )\n\t\t{\n\t\t\tfirstNode = getNodeStore().getRecord( rel.getFirstNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( firstNode );\n\t\t}\n\t\tNodeRecord secondNode = getNodeRecord( rel.getSecondNode() );\n\t\tif ( secondNode == null )\n\t\t{\n\t\t\tsecondNode = getNodeStore().getRecord( rel.getSecondNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( secondNode );\n\t\t}\n\t\tassert firstNode.getNextRel() != rel.getId();\n\t\tassert secondNode.getNextRel() != rel.getId();\n\t\trel.setFirstNextRel( firstNode.getNextRel() );\n\t\trel.setSecondNextRel( secondNode.getNextRel() );\n\t\tif ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tfirstNode.getNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tfirstNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tfirstNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t}\n\t\tif ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tsecondNode.getNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tsecondNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tsecondNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t}\n\t\tfirstNode.setNextRel( rel.getId() );\n\t\tsecondNode.setNextRel( rel.getId() );\n\t}","commit_id":"190df50d90b0c3e2f6a79cd0c2dbcaeb63d28456","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void disconnectRelationship( RelationshipRecord rel )\n\t\tthrows IOException\n\t{\n\t\t// update first node prev\n\t\tif ( rel.getFirstPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update first node next\n\t\tif ( rel.getFirstNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update second node prev\n\t\tif ( rel.getSecondPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update second node next\n\t\tif ( rel.getSecondNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t}","id":76140,"modified_method":"private void disconnectRelationship( RelationshipRecord rel )\n\t\tthrows IOException\n\t{\n\t\t// update first node prev\n\t\tif ( rel.getFirstPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update first node next\n\t\tif ( rel.getFirstNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update second node prev\n\t\tif ( rel.getSecondPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update second node next\n\t\tif ( rel.getSecondNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t}","commit_id":"190df50d90b0c3e2f6a79cd0c2dbcaeb63d28456","url":"https://github.com/neo4j/neo4j"},{"original_method":"synchronized void dumpStack()\n\t{\n\t\tSystem.out.println( \"Total lock count: readCount=\" + readCount + \n\t\t\t\" writeCount=\" + writeCount );\n\t\t\n\t\tSystem.out.println( \"Waiting list:\" );\n\t\tjava.util.Iterator itr = waitingThreadList.iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tWaitElement we = (WaitElement) itr.next();\n\t\t\tSystem.out.print( \"[\" + we.element.thread + \"(\" +\n\t\t\t\twe.element.readCount + \"r,\" + we.element.writeCount + \"w),\" +\n\t\t\t\twe.lockType + \"]\" );\n\t\t\tif ( itr.hasNext() )\n\t\t\t{\n\t\t\t\tSystem.out.print( \",\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println( \"Locking threads:\" );\n\t\titr = threadLockElementMap.values().iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tThreadLockElement tle = (ThreadLockElement) itr.next();\n\t\t\tSystem.out.println( \"\" + tle.thread + \"(\" +\n\t\t\t\ttle.readCount + \"r,\" + tle.writeCount + \"w)\" );\n\t\t}\n\t}","id":76141,"modified_method":"synchronized void dumpStack()\n\t{\n\t\tSystem.out.println( \"Total lock count: readCount=\" + readCount + \n\t\t\t\" writeCount=\" + writeCount + \" for \" + resource );\n\t\t\n\t\tSystem.out.println( \"Waiting list:\" );\n\t\tjava.util.Iterator itr = waitingThreadList.iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tWaitElement we = (WaitElement) itr.next();\n\t\t\tSystem.out.print( \"[\" + we.element.thread + \"(\" +\n\t\t\t\twe.element.readCount + \"r,\" + we.element.writeCount + \"w),\" +\n\t\t\t\twe.lockType + \"]\" );\n\t\t\tif ( itr.hasNext() )\n\t\t\t{\n\t\t\t\tSystem.out.print( \",\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println( \"Locking threads:\" );\n\t\titr = threadLockElementMap.values().iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tThreadLockElement tle = (ThreadLockElement) itr.next();\n\t\t\tSystem.out.println( \"\" + tle.thread + \"(\" +\n\t\t\t\ttle.readCount + \"r,\" + tle.writeCount + \"w)\" );\n\t\t}\n\t}","commit_id":"190df50d90b0c3e2f6a79cd0c2dbcaeb63d28456","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void testBrokenDone()\n\t{\n\t\ttry\n\t\t{\n\t\t\tXid xid = new XidImpl( new byte[4], new byte[4] );\n\t\t\tXAResource xaRes = xaCon.getXaResource();\n\t\t\txaRes.start( xid, XAResource.TMNOFLAGS );\n\t\t\tint node1 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node1 );\n\t\t\tint node2 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node2 );\n\t\t\tint n1prop1 = ds.nextId( PropertyStore.class );\n\t\t\txaCon.getNodeConsumer().addProperty( node1, n1prop1, \n\t\t\t\tindex( \"prop1\" ), \"string1\" );\n\t\t\txaRes.end( xid, XAResource.TMSUCCESS );\n\t\t\txaRes.prepare( xid );\n\t\t\txaRes.commit( xid, false );\n//\t\t\tds.truncateLogicalLog();\n//\t\t\tjava.nio.channels.FileChannel fileChannel = \n//\t\t\t\tnew java.io.RandomAccessFile( \n//\t\t\t\t\t\"nioneo_logical.log\", \"rw\" ).getChannel();\n//\t\t\tfileChannel.truncate( fileChannel.size() - 3 );\n//\t\t\tfileChannel.force( false );\n//\t\t\tfileChannel.close();\n//\t\t\tcopyLogicalLog();\n//\t\t\tds.close();\n//\t\t\trenameLogicalLog();\n\t\t\tds = new NeoStoreXaDataSource( \"neo\", \"nioneo_logical.log\" );\n\t\t\txaCon = ( NeoStoreXaConnection ) ds.getXaConnection();\n\t\t\txaRes = xaCon.getXaResource();\n\t\t\tassertEquals( 1, xaRes.recover( XAResource.TMNOFLAGS ).length );\n\t\t\txaCon.clearAllTransactions();\n\t\t}\n\t\tcatch ( Exception e )\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tfail( \"\" + e );\n\t\t}\n\t}","id":76142,"modified_method":"public void testBrokenDone()\n\t{\n\t\ttry\n\t\t{\n\t\t\tXid xid = new XidImpl( new byte[4], new byte[4] );\n\t\t\tXAResource xaRes = xaCon.getXaResource();\n\t\t\txaRes.start( xid, XAResource.TMNOFLAGS );\n\t\t\tint node1 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node1 );\n\t\t\tint node2 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node2 );\n\t\t\tint n1prop1 = ds.nextId( PropertyStore.class );\n\t\t\txaCon.getNodeConsumer().addProperty( node1, n1prop1, \n\t\t\t\tindex( \"prop1\" ), \"string1\" );\n\t\t\txaRes.end( xid, XAResource.TMSUCCESS );\n\t\t\txaRes.prepare( xid );\n\t\t\tcopyLogicalLog();\n\t\t\txaRes.commit( xid, false );\n\t\t\tds.truncateLogicalLog();\n\t\t\tcopyLogicalLog();\n\t\t\tds.close();\n\t\t\trenameLogicalLog();\n//\t\t\tjava.nio.channels.FileChannel fileChannel = \n//\t\t\t\tnew java.io.RandomAccessFile( \n//\t\t\t\t\t\"nioneo_logical.log\", \"rw\" ).getChannel();\n//\t\t\tfileChannel.truncate( fileChannel.size() - 3 );\n//\t\t\tfileChannel.force( false );\n//\t\t\tfileChannel.close();\n\t\t\tds = new NeoStoreXaDataSource( \"neo\", \"nioneo_logical.log\" );\n\t\t\txaCon = ( NeoStoreXaConnection ) ds.getXaConnection();\n\t\t\txaRes = xaCon.getXaResource();\n\t\t\tassertEquals( 1, xaRes.recover( XAResource.TMNOFLAGS ).length );\n\t\t\txaCon.clearAllTransactions();\n\t\t}\n\t\tcatch ( Exception e )\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tfail( \"\" + e );\n\t\t}\n\t}","commit_id":"190df50d90b0c3e2f6a79cd0c2dbcaeb63d28456","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void releaseCommands( int param )\n\t{\n\t\tif ( param == Status.STATUS_COMMITTED || \n\t\t\tparam == Status.STATUS_ROLLEDBACK )\n\t\t{\n\t\t\tLockReleaser.getManager().releaseLocks();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch ( param )\n\t\t\t{\n\t\t\t\tcase Status.STATUS_ACTIVE:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ACTIVE\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_COMMITTING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_COMMITING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_MARKED_ROLLBACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_MARKED_ROLLBACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_NO_TRANSACTION:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_NO_TRANSACTION\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARED:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARED\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_ROLLING_BACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ROLLING_BACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_UNKNOWN:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_UNKNOWN\" );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.severe( \"Unexpected and unknown tx status after \" +\n\t\t\t\t\t\t\t   \"completion: [\" + param + \"].\" );\n\t\t\t}\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}","id":76143,"modified_method":"private void releaseCommands( int param )\n\t{\n/*\t\tif ( param == Status.STATUS_COMMITTED || \n\t\t\tparam == Status.STATUS_ROLLEDBACK )\n\t\t{*/\n\t\t\tLockReleaser.getManager().releaseLocks();\n/*\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch ( param )\n\t\t\t{\n\t\t\t\tcase Status.STATUS_ACTIVE:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ACTIVE\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_COMMITTING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_COMMITING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_MARKED_ROLLBACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_MARKED_ROLLBACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_NO_TRANSACTION:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_NO_TRANSACTION\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARED:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARED\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_ROLLING_BACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ROLLING_BACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_UNKNOWN:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_UNKNOWN\" );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.severe( \"Unexpected and unknown tx status after \" +\n\t\t\t\t\t\t\t   \"completion: [\" + param + \"].\" );\n\t\t\t}\n\t\t\tthrow new RuntimeException();\n\t\t}*/\n\t}","commit_id":"190df50d90b0c3e2f6a79cd0c2dbcaeb63d28456","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void disconnectRelationship( RelationshipRecord rel )\n\t\tthrows IOException\n\t{\n\t\t// update first node prev\n\t\tif ( rel.getFirstPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update first node next\n\t\tif ( rel.getFirstNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update second node prev\n\t\tif ( rel.getSecondPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update second node next\n\t\tif ( rel.getSecondNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t}","id":76144,"modified_method":"private void disconnectRelationship( RelationshipRecord rel )\n\t\tthrows IOException\n\t{\n\t\t// update first node prev\n\t\tif ( rel.getFirstPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update first node next\n\t\tif ( rel.getFirstNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update second node prev\n\t\tif ( rel.getSecondPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update second node next\n\t\tif ( rel.getSecondNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t}","commit_id":"09213f3a522d650a8c5b0b91b674588dfc8269e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void connectRelationship( RelationshipRecord rel ) \n\t\tthrows IOException \n\t{\n\t\tNodeRecord firstNode = getNodeRecord( rel.getFirstNode() );\n\t\tif ( firstNode == null )\n\t\t{\n\t\t\tfirstNode = getNodeStore().getRecord( rel.getFirstNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( firstNode );\n\t\t}\n\t\tNodeRecord secondNode = getNodeRecord( rel.getSecondNode() );\n\t\tif ( secondNode == null )\n\t\t{\n\t\t\tsecondNode = getNodeStore().getRecord( rel.getSecondNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( secondNode );\n\t\t}\n\t\tassert firstNode.getNextRel() != rel.getId();\n\t\tassert secondNode.getNextRel() != rel.getId();\n\t\trel.setFirstNextRel( firstNode.getNextRel() );\n\t\trel.setSecondNextRel( secondNode.getNextRel() );\n\t\tif ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tfirstNode.getNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tfirstNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tfirstNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\tif ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tsecondNode.getNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tsecondNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tsecondNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\tfirstNode.setNextRel( rel.getId() );\n\t\tsecondNode.setNextRel( rel.getId() );\n\t}","id":76145,"modified_method":"private void connectRelationship( RelationshipRecord rel ) \n\t\tthrows IOException \n\t{\n\t\tNodeRecord firstNode = getNodeRecord( rel.getFirstNode() );\n\t\tif ( firstNode == null )\n\t\t{\n\t\t\tfirstNode = getNodeStore().getRecord( rel.getFirstNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( firstNode );\n\t\t}\n\t\tNodeRecord secondNode = getNodeRecord( rel.getSecondNode() );\n\t\tif ( secondNode == null )\n\t\t{\n\t\t\tsecondNode = getNodeStore().getRecord( rel.getSecondNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( secondNode );\n\t\t}\n\t\tassert firstNode.getNextRel() != rel.getId();\n\t\tassert secondNode.getNextRel() != rel.getId();\n\t\trel.setFirstNextRel( firstNode.getNextRel() );\n\t\trel.setSecondNextRel( secondNode.getNextRel() );\n\t\tif ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tfirstNode.getNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tfirstNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tfirstNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t}\n\t\tif ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tsecondNode.getNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tsecondNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tsecondNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t}\n\t\tfirstNode.setNextRel( rel.getId() );\n\t\tsecondNode.setNextRel( rel.getId() );\n\t}","commit_id":"09213f3a522d650a8c5b0b91b674588dfc8269e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"synchronized void dumpStack()\n\t{\n\t\tSystem.out.println( \"Total lock count: readCount=\" + readCount + \n\t\t\t\" writeCount=\" + writeCount );\n\t\t\n\t\tSystem.out.println( \"Waiting list:\" );\n\t\tjava.util.Iterator itr = waitingThreadList.iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tWaitElement we = (WaitElement) itr.next();\n\t\t\tSystem.out.print( \"[\" + we.element.thread + \"(\" +\n\t\t\t\twe.element.readCount + \"r,\" + we.element.writeCount + \"w),\" +\n\t\t\t\twe.lockType + \"]\" );\n\t\t\tif ( itr.hasNext() )\n\t\t\t{\n\t\t\t\tSystem.out.print( \",\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println( \"Locking threads:\" );\n\t\titr = threadLockElementMap.values().iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tThreadLockElement tle = (ThreadLockElement) itr.next();\n\t\t\tSystem.out.println( \"\" + tle.thread + \"(\" +\n\t\t\t\ttle.readCount + \"r,\" + tle.writeCount + \"w)\" );\n\t\t}\n\t}","id":76146,"modified_method":"synchronized void dumpStack()\n\t{\n\t\tSystem.out.println( \"Total lock count: readCount=\" + readCount + \n\t\t\t\" writeCount=\" + writeCount + \" for \" + resource );\n\t\t\n\t\tSystem.out.println( \"Waiting list:\" );\n\t\tjava.util.Iterator itr = waitingThreadList.iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tWaitElement we = (WaitElement) itr.next();\n\t\t\tSystem.out.print( \"[\" + we.element.thread + \"(\" +\n\t\t\t\twe.element.readCount + \"r,\" + we.element.writeCount + \"w),\" +\n\t\t\t\twe.lockType + \"]\" );\n\t\t\tif ( itr.hasNext() )\n\t\t\t{\n\t\t\t\tSystem.out.print( \",\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println( \"Locking threads:\" );\n\t\titr = threadLockElementMap.values().iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tThreadLockElement tle = (ThreadLockElement) itr.next();\n\t\t\tSystem.out.println( \"\" + tle.thread + \"(\" +\n\t\t\t\ttle.readCount + \"r,\" + tle.writeCount + \"w)\" );\n\t\t}\n\t}","commit_id":"09213f3a522d650a8c5b0b91b674588dfc8269e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void testBrokenDone()\n\t{\n\t\ttry\n\t\t{\n\t\t\tXid xid = new XidImpl( new byte[4], new byte[4] );\n\t\t\tXAResource xaRes = xaCon.getXaResource();\n\t\t\txaRes.start( xid, XAResource.TMNOFLAGS );\n\t\t\tint node1 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node1 );\n\t\t\tint node2 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node2 );\n\t\t\tint n1prop1 = ds.nextId( PropertyStore.class );\n\t\t\txaCon.getNodeConsumer().addProperty( node1, n1prop1, \n\t\t\t\tindex( \"prop1\" ), \"string1\" );\n\t\t\txaRes.end( xid, XAResource.TMSUCCESS );\n\t\t\txaRes.prepare( xid );\n\t\t\txaRes.commit( xid, false );\n//\t\t\tds.truncateLogicalLog();\n//\t\t\tjava.nio.channels.FileChannel fileChannel = \n//\t\t\t\tnew java.io.RandomAccessFile( \n//\t\t\t\t\t\"nioneo_logical.log\", \"rw\" ).getChannel();\n//\t\t\tfileChannel.truncate( fileChannel.size() - 3 );\n//\t\t\tfileChannel.force( false );\n//\t\t\tfileChannel.close();\n//\t\t\tcopyLogicalLog();\n//\t\t\tds.close();\n//\t\t\trenameLogicalLog();\n\t\t\tds = new NeoStoreXaDataSource( \"neo\", \"nioneo_logical.log\" );\n\t\t\txaCon = ( NeoStoreXaConnection ) ds.getXaConnection();\n\t\t\txaRes = xaCon.getXaResource();\n\t\t\tassertEquals( 1, xaRes.recover( XAResource.TMNOFLAGS ).length );\n\t\t\txaCon.clearAllTransactions();\n\t\t}\n\t\tcatch ( Exception e )\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tfail( \"\" + e );\n\t\t}\n\t}","id":76147,"modified_method":"public void testBrokenDone()\n\t{\n\t\ttry\n\t\t{\n\t\t\tXid xid = new XidImpl( new byte[4], new byte[4] );\n\t\t\tXAResource xaRes = xaCon.getXaResource();\n\t\t\txaRes.start( xid, XAResource.TMNOFLAGS );\n\t\t\tint node1 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node1 );\n\t\t\tint node2 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node2 );\n\t\t\tint n1prop1 = ds.nextId( PropertyStore.class );\n\t\t\txaCon.getNodeConsumer().addProperty( node1, n1prop1, \n\t\t\t\tindex( \"prop1\" ), \"string1\" );\n\t\t\txaRes.end( xid, XAResource.TMSUCCESS );\n\t\t\txaRes.prepare( xid );\n\t\t\tcopyLogicalLog();\n\t\t\txaRes.commit( xid, false );\n\t\t\tds.truncateLogicalLog();\n\t\t\tcopyLogicalLog();\n\t\t\tds.close();\n\t\t\trenameLogicalLog();\n//\t\t\tjava.nio.channels.FileChannel fileChannel = \n//\t\t\t\tnew java.io.RandomAccessFile( \n//\t\t\t\t\t\"nioneo_logical.log\", \"rw\" ).getChannel();\n//\t\t\tfileChannel.truncate( fileChannel.size() - 3 );\n//\t\t\tfileChannel.force( false );\n//\t\t\tfileChannel.close();\n\t\t\tds = new NeoStoreXaDataSource( \"neo\", \"nioneo_logical.log\" );\n\t\t\txaCon = ( NeoStoreXaConnection ) ds.getXaConnection();\n\t\t\txaRes = xaCon.getXaResource();\n\t\t\tassertEquals( 1, xaRes.recover( XAResource.TMNOFLAGS ).length );\n\t\t\txaCon.clearAllTransactions();\n\t\t}\n\t\tcatch ( Exception e )\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tfail( \"\" + e );\n\t\t}\n\t}","commit_id":"09213f3a522d650a8c5b0b91b674588dfc8269e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void releaseCommands( int param )\n\t{\n\t\tif ( param == Status.STATUS_COMMITTED || \n\t\t\tparam == Status.STATUS_ROLLEDBACK )\n\t\t{\n\t\t\tLockReleaser.getManager().releaseLocks();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch ( param )\n\t\t\t{\n\t\t\t\tcase Status.STATUS_ACTIVE:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ACTIVE\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_COMMITTING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_COMMITING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_MARKED_ROLLBACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_MARKED_ROLLBACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_NO_TRANSACTION:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_NO_TRANSACTION\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARED:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARED\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_ROLLING_BACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ROLLING_BACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_UNKNOWN:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_UNKNOWN\" );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.severe( \"Unexpected and unknown tx status after \" +\n\t\t\t\t\t\t\t   \"completion: [\" + param + \"].\" );\n\t\t\t}\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}","id":76148,"modified_method":"private void releaseCommands( int param )\n\t{\n/*\t\tif ( param == Status.STATUS_COMMITTED || \n\t\t\tparam == Status.STATUS_ROLLEDBACK )\n\t\t{*/\n\t\t\tLockReleaser.getManager().releaseLocks();\n/*\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch ( param )\n\t\t\t{\n\t\t\t\tcase Status.STATUS_ACTIVE:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ACTIVE\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_COMMITTING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_COMMITING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_MARKED_ROLLBACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_MARKED_ROLLBACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_NO_TRANSACTION:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_NO_TRANSACTION\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARED:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARED\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_ROLLING_BACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ROLLING_BACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_UNKNOWN:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_UNKNOWN\" );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.severe( \"Unexpected and unknown tx status after \" +\n\t\t\t\t\t\t\t   \"completion: [\" + param + \"].\" );\n\t\t\t}\n\t\t\tthrow new RuntimeException();\n\t\t}*/\n\t}","commit_id":"09213f3a522d650a8c5b0b91b674588dfc8269e1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void connectRelationship( RelationshipRecord rel ) \n\t\tthrows IOException \n\t{\n\t\tNodeRecord firstNode = getNodeRecord( rel.getFirstNode() );\n\t\tif ( firstNode == null )\n\t\t{\n\t\t\tfirstNode = getNodeStore().getRecord( rel.getFirstNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( firstNode );\n\t\t}\n\t\tNodeRecord secondNode = getNodeRecord( rel.getSecondNode() );\n\t\tif ( secondNode == null )\n\t\t{\n\t\t\tsecondNode = getNodeStore().getRecord( rel.getSecondNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( secondNode );\n\t\t}\n\t\tassert firstNode.getNextRel() != rel.getId();\n\t\tassert secondNode.getNextRel() != rel.getId();\n\t\trel.setFirstNextRel( firstNode.getNextRel() );\n\t\trel.setSecondNextRel( secondNode.getNextRel() );\n\t\tif ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tfirstNode.getNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tfirstNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tfirstNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\tif ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tsecondNode.getNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tsecondNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tsecondNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\tfirstNode.setNextRel( rel.getId() );\n\t\tsecondNode.setNextRel( rel.getId() );\n\t}","id":76149,"modified_method":"private void connectRelationship( RelationshipRecord rel ) \n\t\tthrows IOException \n\t{\n\t\tNodeRecord firstNode = getNodeRecord( rel.getFirstNode() );\n\t\tif ( firstNode == null )\n\t\t{\n\t\t\tfirstNode = getNodeStore().getRecord( rel.getFirstNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( firstNode );\n\t\t}\n\t\tNodeRecord secondNode = getNodeRecord( rel.getSecondNode() );\n\t\tif ( secondNode == null )\n\t\t{\n\t\t\tsecondNode = getNodeStore().getRecord( rel.getSecondNode(), \n\t\t\t\treadFromBuffer );\n\t\t\taddNodeRecord( secondNode );\n\t\t}\n\t\tassert firstNode.getNextRel() != rel.getId();\n\t\tassert secondNode.getNextRel() != rel.getId();\n\t\trel.setFirstNextRel( firstNode.getNextRel() );\n\t\trel.setSecondNextRel( secondNode.getNextRel() );\n\t\tif ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tfirstNode.getNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tfirstNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tfirstNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == firstNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t}\n\t\tif ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\tsecondNode.getNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\t\tsecondNode.getNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\tsecondNode.getNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == secondNode.getId() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getId() );\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tthrow new RuntimeException( firstNode + \" dont match \" +\n\t\t\t\t\tnextRel );\n\t\t\t}\n\t\t}\n\t\tfirstNode.setNextRel( rel.getId() );\n\t\tsecondNode.setNextRel( rel.getId() );\n\t}","commit_id":"b924bb1c16c319ccfd797f270dcbad2c02da2bfb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void disconnectRelationship( RelationshipRecord rel )\n\t\tthrows IOException\n\t{\n\t\t// update first node prev\n\t\tif ( rel.getFirstPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update first node next\n\t\tif ( rel.getFirstNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update second node prev\n\t\tif ( rel.getSecondPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t\t// update second node next\n\t\tif ( rel.getSecondNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tlockManager.getWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t\taddRelationshipLockToTransaction( lockableRel );\n\t\t}\n\t}","id":76150,"modified_method":"private void disconnectRelationship( RelationshipRecord rel )\n\t\tthrows IOException\n\t{\n\t\t// update first node prev\n\t\tif ( rel.getFirstPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getFirstPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getFirstNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update first node next\n\t\tif ( rel.getFirstNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getFirstNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getFirstNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getFirstNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getFirstPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update second node prev\n\t\tif ( rel.getSecondPrevRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord prevRel = getRelationshipRecord( \n\t\t\t\trel.getSecondPrevRel() );\n\t\t\tif ( prevRel == null )\n\t\t\t{\n\t\t\t\tprevRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondPrevRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( prevRel );\n\t\t\t}\n\t\t\tif ( prevRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setFirstNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse if ( prevRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tprevRel.setSecondNextRel( rel.getSecondNextRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( prevRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t\t// update second node next\n\t\tif ( rel.getSecondNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n\t\t{\n\t\t\tRelationship lockableRel = new LockableRelationship( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tgetWriteLock( lockableRel );\n\t\t\tRelationshipRecord nextRel = getRelationshipRecord( \n\t\t\t\trel.getSecondNextRel() );\n\t\t\tif ( nextRel == null )\n\t\t\t{\n\t\t\t\tnextRel = getRelationshipStore().getRecord( \n\t\t\t\t\trel.getSecondNextRel(), readFromBuffer );\n\t\t\t\taddRelationshipRecord( nextRel );\n\t\t\t}\n\t\t\tif ( nextRel.getFirstNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setFirstPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse if ( nextRel.getSecondNode() == rel.getSecondNode() )\n\t\t\t{\n\t\t\t\tnextRel.setSecondPrevRel( rel.getSecondPrevRel() );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new RuntimeException( nextRel + \n\t\t\t\t\t\" don't match \" + rel );\n\t\t\t}\n\t\t}\n\t}","commit_id":"b924bb1c16c319ccfd797f270dcbad2c02da2bfb","url":"https://github.com/neo4j/neo4j"},{"original_method":"synchronized void dumpStack()\n\t{\n\t\tSystem.out.println( \"Total lock count: readCount=\" + readCount + \n\t\t\t\" writeCount=\" + writeCount );\n\t\t\n\t\tSystem.out.println( \"Waiting list:\" );\n\t\tjava.util.Iterator itr = waitingThreadList.iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tWaitElement we = (WaitElement) itr.next();\n\t\t\tSystem.out.print( \"[\" + we.element.thread + \"(\" +\n\t\t\t\twe.element.readCount + \"r,\" + we.element.writeCount + \"w),\" +\n\t\t\t\twe.lockType + \"]\" );\n\t\t\tif ( itr.hasNext() )\n\t\t\t{\n\t\t\t\tSystem.out.print( \",\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println( \"Locking threads:\" );\n\t\titr = threadLockElementMap.values().iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tThreadLockElement tle = (ThreadLockElement) itr.next();\n\t\t\tSystem.out.println( \"\" + tle.thread + \"(\" +\n\t\t\t\ttle.readCount + \"r,\" + tle.writeCount + \"w)\" );\n\t\t}\n\t}","id":76151,"modified_method":"synchronized void dumpStack()\n\t{\n\t\tSystem.out.println( \"Total lock count: readCount=\" + readCount + \n\t\t\t\" writeCount=\" + writeCount + \" for \" + resource );\n\t\t\n\t\tSystem.out.println( \"Waiting list:\" );\n\t\tjava.util.Iterator itr = waitingThreadList.iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tWaitElement we = (WaitElement) itr.next();\n\t\t\tSystem.out.print( \"[\" + we.element.thread + \"(\" +\n\t\t\t\twe.element.readCount + \"r,\" + we.element.writeCount + \"w),\" +\n\t\t\t\twe.lockType + \"]\" );\n\t\t\tif ( itr.hasNext() )\n\t\t\t{\n\t\t\t\tSystem.out.print( \",\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println( \"Locking threads:\" );\n\t\titr = threadLockElementMap.values().iterator();\n\t\twhile ( itr.hasNext() )\n\t\t{\n\t\t\tThreadLockElement tle = (ThreadLockElement) itr.next();\n\t\t\tSystem.out.println( \"\" + tle.thread + \"(\" +\n\t\t\t\ttle.readCount + \"r,\" + tle.writeCount + \"w)\" );\n\t\t}\n\t}","commit_id":"b924bb1c16c319ccfd797f270dcbad2c02da2bfb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void testBrokenDone()\n\t{\n\t\ttry\n\t\t{\n\t\t\tXid xid = new XidImpl( new byte[4], new byte[4] );\n\t\t\tXAResource xaRes = xaCon.getXaResource();\n\t\t\txaRes.start( xid, XAResource.TMNOFLAGS );\n\t\t\tint node1 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node1 );\n\t\t\tint node2 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node2 );\n\t\t\tint n1prop1 = ds.nextId( PropertyStore.class );\n\t\t\txaCon.getNodeConsumer().addProperty( node1, n1prop1, \n\t\t\t\tindex( \"prop1\" ), \"string1\" );\n\t\t\txaRes.end( xid, XAResource.TMSUCCESS );\n\t\t\txaRes.prepare( xid );\n\t\t\txaRes.commit( xid, false );\n//\t\t\tds.truncateLogicalLog();\n//\t\t\tjava.nio.channels.FileChannel fileChannel = \n//\t\t\t\tnew java.io.RandomAccessFile( \n//\t\t\t\t\t\"nioneo_logical.log\", \"rw\" ).getChannel();\n//\t\t\tfileChannel.truncate( fileChannel.size() - 3 );\n//\t\t\tfileChannel.force( false );\n//\t\t\tfileChannel.close();\n//\t\t\tcopyLogicalLog();\n//\t\t\tds.close();\n//\t\t\trenameLogicalLog();\n\t\t\tds = new NeoStoreXaDataSource( \"neo\", \"nioneo_logical.log\" );\n\t\t\txaCon = ( NeoStoreXaConnection ) ds.getXaConnection();\n\t\t\txaRes = xaCon.getXaResource();\n\t\t\tassertEquals( 1, xaRes.recover( XAResource.TMNOFLAGS ).length );\n\t\t\txaCon.clearAllTransactions();\n\t\t}\n\t\tcatch ( Exception e )\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tfail( \"\" + e );\n\t\t}\n\t}","id":76152,"modified_method":"public void testBrokenDone()\n\t{\n\t\ttry\n\t\t{\n\t\t\tXid xid = new XidImpl( new byte[4], new byte[4] );\n\t\t\tXAResource xaRes = xaCon.getXaResource();\n\t\t\txaRes.start( xid, XAResource.TMNOFLAGS );\n\t\t\tint node1 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node1 );\n\t\t\tint node2 = ds.nextId( Node.class );\n\t\t\txaCon.getNodeConsumer().createNode( node2 );\n\t\t\tint n1prop1 = ds.nextId( PropertyStore.class );\n\t\t\txaCon.getNodeConsumer().addProperty( node1, n1prop1, \n\t\t\t\tindex( \"prop1\" ), \"string1\" );\n\t\t\txaRes.end( xid, XAResource.TMSUCCESS );\n\t\t\txaRes.prepare( xid );\n\t\t\tcopyLogicalLog();\n\t\t\txaRes.commit( xid, false );\n\t\t\tds.truncateLogicalLog();\n\t\t\tcopyLogicalLog();\n\t\t\tds.close();\n\t\t\trenameLogicalLog();\n//\t\t\tjava.nio.channels.FileChannel fileChannel = \n//\t\t\t\tnew java.io.RandomAccessFile( \n//\t\t\t\t\t\"nioneo_logical.log\", \"rw\" ).getChannel();\n//\t\t\tfileChannel.truncate( fileChannel.size() - 3 );\n//\t\t\tfileChannel.force( false );\n//\t\t\tfileChannel.close();\n\t\t\tds = new NeoStoreXaDataSource( \"neo\", \"nioneo_logical.log\" );\n\t\t\txaCon = ( NeoStoreXaConnection ) ds.getXaConnection();\n\t\t\txaRes = xaCon.getXaResource();\n\t\t\tassertEquals( 1, xaRes.recover( XAResource.TMNOFLAGS ).length );\n\t\t\txaCon.clearAllTransactions();\n\t\t}\n\t\tcatch ( Exception e )\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tfail( \"\" + e );\n\t\t}\n\t}","commit_id":"b924bb1c16c319ccfd797f270dcbad2c02da2bfb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void releaseCommands( int param )\n\t{\n\t\tif ( param == Status.STATUS_COMMITTED || \n\t\t\tparam == Status.STATUS_ROLLEDBACK )\n\t\t{\n\t\t\tLockReleaser.getManager().releaseLocks();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch ( param )\n\t\t\t{\n\t\t\t\tcase Status.STATUS_ACTIVE:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ACTIVE\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_COMMITTING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_COMMITING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_MARKED_ROLLBACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_MARKED_ROLLBACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_NO_TRANSACTION:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_NO_TRANSACTION\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARED:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARED\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_ROLLING_BACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ROLLING_BACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_UNKNOWN:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_UNKNOWN\" );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.severe( \"Unexpected and unknown tx status after \" +\n\t\t\t\t\t\t\t   \"completion: [\" + param + \"].\" );\n\t\t\t}\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}","id":76153,"modified_method":"private void releaseCommands( int param )\n\t{\n/*\t\tif ( param == Status.STATUS_COMMITTED || \n\t\t\tparam == Status.STATUS_ROLLEDBACK )\n\t\t{*/\n\t\t\tLockReleaser.getManager().releaseLocks();\n/*\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch ( param )\n\t\t\t{\n\t\t\t\tcase Status.STATUS_ACTIVE:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ACTIVE\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_COMMITTING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_COMMITING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_MARKED_ROLLBACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_MARKED_ROLLBACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_NO_TRANSACTION:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_NO_TRANSACTION\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARED:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARED\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_PREPARING:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_PREPARING\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_ROLLING_BACK:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_ROLLING_BACK\" );\n\t\t\t\t\tbreak;\n\t\t\t\tcase Status.STATUS_UNKNOWN:\n\t\t\t\t\tlog.severe( \"Unexpected tx status after completion: \" +\n\t\t\t\t\t\t\t   \"STATUS_UNKNOWN\" );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog.severe( \"Unexpected and unknown tx status after \" +\n\t\t\t\t\t\t\t   \"completion: [\" + param + \"].\" );\n\t\t\t}\n\t\t\tthrow new RuntimeException();\n\t\t}*/\n\t}","commit_id":"b924bb1c16c319ccfd797f270dcbad2c02da2bfb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void invoke() {\n            m_ensure.step(8);\n        }","id":76154,"modified_method":"public void invoke() {\n            m_ensure.step(9);\n        }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"public void stop() {\n            m_ensure.step(10);\n        }","id":76155,"modified_method":"public void stop() {\n            m_ensure.step(11);\n        }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"public void invoke(Runnable run) {\n            m_ensure.step(6);\n            m_originalService.invoke(run);\n            m_injectedService.invoke();\n        }","id":76156,"modified_method":"public void invoke(Runnable run) {\n            m_ensure.step(7);\n            m_originalService.invoke(run);\n            m_injectedService.invoke();\n        }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"public void start() {\n            m_ensure.step(4);\n        }","id":76157,"modified_method":"public void start() {\n            m_ensure.step(5);\n        }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testDynamicallyAddAndRemoveAspect(BundleContext context) {\n        DependencyManager m = new DependencyManager(context);\n        // helper class that ensures certain steps get executed in sequence\n        Ensure e = new Ensure();\n        // create a service provider and consumer\n        Service sp = m.createService().setImplementation(new ServiceProvider(e)).setInterface(ServiceInterface.class.getName(), null);\n        Service sp2 = m.createService().setImplementation(new ServiceProvider2(e)).setInterface(ServiceInterface2.class.getName(), null);\n        Service sc = m.createService().setImplementation(new ServiceConsumer(e)).add(m.createServiceDependency().setService(ServiceInterface.class).setRequired(true));\n        Service sa = m.createAspectService(ServiceInterface.class, \"(|(!(\" + Constants.SERVICE_RANKING + \"=*))(\" + Constants.SERVICE_RANKING + \"<=0))\", new ServiceAspect(e), new Properties() {{ put(Constants.SERVICE_RANKING, Integer.valueOf(1)); }} );\n        m.add(sc);\n        m.add(sp);\n        m.add(sp2);\n        e.waitForStep(3, 2000);\n        m.add(sa);\n        e.waitForStep(4, 2000);\n        e.step(5);\n        e.waitForStep(8, 2000);\n        m.remove(sa);\n        e.waitForStep(10, 2000);\n        e.step(11);\n        e.waitForStep(12, 2000);\n        m.remove(sp2);\n        m.remove(sp);\n        m.remove(sc);\n    }","id":76158,"modified_method":"@Test\n    public void testDynamicallyAddAndRemoveAspect(BundleContext context) {\n        DependencyManager m = new DependencyManager(context);\n        // helper class that ensures certain steps get executed in sequence\n        Ensure e = new Ensure();\n        // create a service provider and consumer\n        Service sp = m.createService().setImplementation(new ServiceProvider(e)).setInterface(ServiceInterface.class.getName(), null);\n        Service sp2 = m.createService().setImplementation(new ServiceProvider2(e)).setInterface(ServiceInterface2.class.getName(), null);\n        Service sc = m.createService().setImplementation(new ServiceConsumer(e)).add(m.createServiceDependency().setService(ServiceInterface.class).setRequired(true));\n        Service sa = m.createAspectService(ServiceInterface.class, \"(|(!(\" + Constants.SERVICE_RANKING + \"=*))(\" + Constants.SERVICE_RANKING + \"<=0))\", new ServiceAspect(e), new Properties() {{ put(Constants.SERVICE_RANKING, Integer.valueOf(1)); }} );\n        m.add(sc);\n        m.add(sp);\n        e.waitForStep(3, 2000);\n        m.add(sa);\n        e.waitForStep(4, 2000);\n        m.add(sp2);\n        e.waitForStep(5, 2000);\n        e.step(6);\n        e.waitForStep(9, 2000);\n        m.remove(sa);\n        e.waitForStep(11, 2000);\n        e.step(12);\n        e.waitForStep(13, 2000);\n        m.remove(sp2);\n        m.remove(sp);\n        m.remove(sc);\n    }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"public void init() {\n            m_service.add(m_manager.createServiceDependency().setInstanceBound(true).setRequired(true).setService(ServiceInterface2.class));\n        }","id":76159,"modified_method":"public void init() {\n            m_service.add(m_manager.createServiceDependency().setInstanceBound(true).setRequired(true).setService(ServiceInterface2.class));\n            m_ensure.step(4);\n        }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"public void run() {\n            m_ensure.step(1);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 2));\n            m_ensure.step(3);\n            m_ensure.waitForStep(5, 2000);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 7));\n            m_ensure.step(9);\n            m_ensure.waitForStep(11, 2000);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 12));\n        }","id":76160,"modified_method":"public void run() {\n            m_ensure.step(1);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 2));\n            m_ensure.step(3);\n            m_ensure.waitForStep(6, 2000);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 8));\n            m_ensure.step(10);\n            m_ensure.waitForStep(12, 2000);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 13));\n        }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Wait until we arrive at least at step <code>nr<\/code> in the process, or fail if that\n     * takes more than <code>timeout<\/code> milliseconds. If you invoke wait on a thread,\n     * you are effectively assuming some other thread will invoke the <code>step(nr)<\/code>\n     * method.\n     * \n     * @param nr the step to wait for\n     * @param timeout the number of milliseconds to wait\n     */\n    public synchronized void waitForStep(int nr, int timeout) {\n        final int initialTimeout = timeout;\n        if (DEBUG) {\n            System.out.println(\"[Ensure \" + INSTANCE + \"] waiting for step \" + nr);\n        }\n        while (step < nr && timeout > 0) {\n            try {\n                wait(RESOLUTION);\n                timeout -= RESOLUTION;\n            }\n            catch (InterruptedException e) {}\n        }\n        if (step < nr) {\n            throw new IllegalStateException(\"Timed out waiting for \" + initialTimeout + \" ms for step \" + nr + \", we are still at step \" + step);\n        }\n        if (DEBUG) {\n            System.out.println(\"[Ensure \" + INSTANCE + \"] arrived at step \" + nr);\n        }\n    }","id":76161,"modified_method":"/**\n     * Wait until we arrive at least at step <code>nr<\/code> in the process, or fail if that\n     * takes more than <code>timeout<\/code> milliseconds. If you invoke wait on a thread,\n     * you are effectively assuming some other thread will invoke the <code>step(nr)<\/code>\n     * method.\n     * \n     * @param nr the step to wait for\n     * @param timeout the number of milliseconds to wait\n     */\n    public synchronized void waitForStep(int nr, int timeout) {\n        final int initialTimeout = timeout;\n        if (DEBUG) {\n            STREAM.println(\"[Ensure \" + INSTANCE + \"] waiting for step \" + nr);\n        }\n        while (step < nr && timeout > 0) {\n            try {\n                wait(RESOLUTION);\n                timeout -= RESOLUTION;\n            }\n            catch (InterruptedException e) {}\n        }\n        if (step < nr) {\n            throw new IllegalStateException(\"Timed out waiting for \" + initialTimeout + \" ms for step \" + nr + \", we are still at step \" + step);\n        }\n        if (DEBUG) {\n            STREAM.println(\"[Ensure \" + INSTANCE + \"] arrived at step \" + nr);\n        }\n    }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Mark this point as step <code>nr<\/code>.\n     * \n     * @param nr the step we are in\n     */\n    public synchronized void step(int nr) {\n        step++;\n        Assert.assertEquals(nr, step);\n        if (DEBUG) {\n            System.out.println(\"[Ensure \" + INSTANCE + \"] step \" + step);\n        }\n        notifyAll();\n    }","id":76162,"modified_method":"/**\n     * Mark this point as step <code>nr<\/code>.\n     * \n     * @param nr the step we are in\n     */\n    public synchronized void step(int nr) {\n        step++;\n        Assert.assertEquals(nr, step);\n        if (DEBUG) {\n            STREAM.println(\"[Ensure \" + INSTANCE + \"] step \" + step);\n        }\n        notifyAll();\n    }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"private void deactivateService(State state) {\n        String destroy;\n        synchronized (this) {\n            destroy = m_callbackDestroy;\n        }\n        // invoke the destroy callback\n        invoke(destroy);\n        // destroy the service instance\n        destroyService(state);\n        // flag that our instance was destroyed\n        m_isInstantiated = false;\n    }","id":76163,"modified_method":"private void deactivateService(State state) {\n        String destroy;\n        synchronized (this) {\n            destroy = m_callbackDestroy;\n        }\n        // flag that our instance was destroyed\n        m_isInstantiated = false;\n        // invoke the destroy callback\n        invoke(destroy);\n        // destroy the service instance\n        destroyService(state);\n    }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"private void activateService(State state) {\n        String init;\n        synchronized (this) {\n            init = m_callbackInit;\n        }\n        // service activation logic, first we initialize the service instance itself\n        // meaning it is created if necessary and the bundle context is set\n        initService();\n        // now is the time to configure the service, meaning all required\n        // dependencies will be set and any callbacks called\n        configureService(state);\n        // then we invoke the init callback so the service can further initialize\n        // itself\n        invoke(init);\n        // flag that our instance has been created\n        m_isInstantiated = true;\n        // see if any of this caused further state changes\n        calculateStateChanges();\n    }","id":76164,"modified_method":"private void activateService(State state) {\n        String init;\n        synchronized (this) {\n            init = m_callbackInit;\n        }\n        // service activation logic, first we initialize the service instance itself\n        // meaning it is created if necessary and the bundle context is set\n        initService();\n        // now is the time to configure the service, meaning all required\n        // dependencies will be set and any callbacks called\n        configureService(state);\n        // flag that our instance has been created\n        m_isInstantiated = true;\n        // then we invoke the init callback so the service can further initialize\n        // itself\n        invoke(init);\n        // see if any of this caused further state changes\n        calculateStateChanges();\n    }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"public synchronized String toString() {\n        if (m_stringValue == null) {\n            // we only need to determine this once, but we do it lazily\n            StringBuffer buf = new StringBuffer();\n            buf.append(\"State[\" + STATES[m_state] + \"|\");\n            List deps = m_deps;\n            for (int i = 0; i < deps.size(); i++) {\n                Dependency dep = (Dependency) deps.get(i);\n                buf.append(\"(\" + dep + (dep.isRequired() ? \" R\" : \" O\") + (dep.isAvailable() ? \" +\" : \" -\") + \")\");\n            }\n            m_stringValue = buf.toString();\n        }\n        return m_stringValue;\n    }","id":76165,"modified_method":"public synchronized String toString() {\n        if (m_stringValue == null) {\n            // we only need to determine this once, but we do it lazily\n            StringBuffer buf = new StringBuffer();\n            buf.append(\"State[\" + STATES[m_state]);\n            List deps = m_deps;\n            for (int i = 0; i < deps.size(); i++) {\n                if (i == 0) {\n                    buf.append(\"|\");\n                }\n                Dependency dep = (Dependency) deps.get(i);\n                buf.append(\"(\" + (dep.isRequired() ? \"Req \" : \"   \") + (dep.isAvailable() ? \"Avl \" : \"    \") + (dep.isInstanceBound() ? \"InB \" : \"    \") + (dep.isPropagated() ? \"Prp \" : \"    \") + dep + \")\");\n            }\n            buf.append(\"]\");\n            m_stringValue = buf.toString();\n        }\n        return m_stringValue;\n    }","commit_id":"78e5dfc53275c258ce221acf6fffb3014c2db7cf","url":"https://github.com/apache/felix"},{"original_method":"/** Minimizes the native infos such that UiEngine creates\n\t * the minimal number of components.\n\t */\n\tprivate void minimizeNative(NativeInfo compInfo) {\n\t\t//Optimize 1: merge to prolog\n\t\tfor (Iterator it = compInfo.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Object o = it.next();\n\t\t\tif (o instanceof NativeInfo) {\n\t\t\t\tfinal NativeInfo childInfo = (NativeInfo)o;\n\t\t\t\tif (!childInfo.getChildren().isEmpty())\n\t\t\t\t\tbreak;\n\t\t\t\tchildInfo.setParentDirectly(null);\n\t\t\t} else if (o instanceof ComponentInfo) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcompInfo.addPrologChild0(o);\n\t\t\tit.remove(); //detach it from the children list first\n\t\t}\n\n\t\t//Optimize 2: merge to epilog\n\t\tint sz = compInfo.getChildren().size();\n\t\tif (sz >= 0) {\n\t\t\tfinal ListIterator it = compInfo.getChildren().listIterator(sz);\n\t\t\twhile (it.hasPrevious()) {\n\t\t\t\tfinal Object o = it.previous();\n\t\t\t\tif (o instanceof NativeInfo) {\n\t\t\t\t\tfinal NativeInfo childInfo = (NativeInfo)o;\n\t\t\t\t\tif (!childInfo.getChildren().isEmpty()) {\n\t\t\t\t\t\tit.next();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchildInfo.setParentDirectly(null);\n\t\t\t\t} else if (o instanceof ComponentInfo) {\n\t\t\t\t\tit.next();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tfinal Object o = it.next();\n\t\t\t\tcompInfo.addEpilogChild0(o);\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\n\t\t//Optimize 3: merge to split child\n\t\tif (compInfo.getChildren().size() == 1\n\t\t&& compInfo.getSplitChild() == null /*just in case*/) {\n\t\t\tfinal Iterator it = compInfo.getChildren().iterator();\n\t\t\tfinal Object o = it.next();\n\t\t\tif (o instanceof NativeInfo) {\n\t\t\t\tfinal NativeInfo childInfo = (NativeInfo)o;\n\t\t\t\tchildInfo.setParentDirectly(null);\n\t\t\t\tcompInfo.setSplitChild(childInfo);\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t}","id":76166,"modified_method":"/** Minimizes the native infos such that UiEngine creates\n\t * the minimal number of components.\n\t */\n\tprivate void optimizeNativeInfos(NativeInfo compInfo) {\n\t\t//Optimize 1: merge to prolog\n\t\tfor (Iterator it = compInfo.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Object o = it.next();\n\t\t\tif (o instanceof NativeInfo) {\n\t\t\t\tfinal NativeInfo childInfo = (NativeInfo)o;\n\t\t\t\tif (!childInfo.getChildren().isEmpty())\n\t\t\t\t\tbreak;\n\t\t\t\tchildInfo.setParentDirectly(null);\n\t\t\t} else if (o instanceof ComponentInfo) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcompInfo.addPrologChild0(o);\n\t\t\tit.remove(); //detach it from the children list first\n\t\t}\n\n\t\t//Optimize 2: merge to epilog\n\t\tint sz = compInfo.getChildren().size();\n\t\tif (sz >= 0) {\n\t\t\tfinal ListIterator it = compInfo.getChildren().listIterator(sz);\n\t\t\twhile (it.hasPrevious()) {\n\t\t\t\tfinal Object o = it.previous();\n\t\t\t\tif (o instanceof NativeInfo) {\n\t\t\t\t\tfinal NativeInfo childInfo = (NativeInfo)o;\n\t\t\t\t\tif (!childInfo.getChildren().isEmpty()) {\n\t\t\t\t\t\tit.next();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchildInfo.setParentDirectly(null);\n\t\t\t\t} else if (o instanceof ComponentInfo) {\n\t\t\t\t\tit.next();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tfinal Object o = it.next();\n\t\t\t\tcompInfo.addEpilogChild0(o);\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\n\t\t//Optimize 3: merge to split child\n\t\tif (compInfo.getChildren().size() == 1\n\t\t&& compInfo.getSplitChild() == null /*just in case*/) {\n\t\t\tfinal Iterator it = compInfo.getChildren().iterator();\n\t\t\tfinal Object o = it.next();\n\t\t\tif (o instanceof NativeInfo) {\n\t\t\t\tfinal NativeInfo childInfo = (NativeInfo)o;\n\t\t\t\tchildInfo.setParentDirectly(null);\n\t\t\t\tcompInfo.setSplitChild(childInfo);\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t}","commit_id":"105ce7ad39191561b75f51504242877f0059e6f3","url":"https://github.com/zkoss/zk"},{"original_method":"/** Parse an component definition specified in the given element.\n\t */\n\tprivate void parse(PageDefinition pgdef, NodeInfo parent,\n\tElement el, AnnotationHelper annHelper)\n\tthrows Exception {\n\t\tfinal String nm = el.getLocalName();\n\t\tfinal Namespace ns = el.getNamespace();\n\t\tfinal String pref = ns != null ? ns.getPrefix(): \"\";\n\t\tfinal String uri = ns != null ? ns.getURI(): \"\";\n\t\tfinal LanguageDefinition langdef = pgdef.getLanguageDefinition();\n\t\tif (\"zscript\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseZScript(parent, el, annHelper);\n\t\t} else if (\"attribute\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tif (!(parent instanceof ComponentInfo))\n\t\t\t\tthrow new UiException(\"<attribute> cannot be the root element, \"+el.getLocator());\n\n\t\t\tparseAttribute((ComponentInfo)parent, el, annHelper);\n\t\t} else if (\"custom-attributes\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseCustomAttributes(parent, el, annHelper);\n\t\t} else if (\"variables\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseVariables(parent, el, annHelper);\n\t\t} else if (LanguageDefinition.ANNO_NAMESPACE.equals(uri)) {\n\t\t\tparseAnnotation(el, annHelper);\n\t\t} else {\n\t\t\t//if (D.ON && log.debugable()) log.debug(\"component: \"+nm+\", ns:\"+ns);\n\n\t\t\tfinal ComponentInfo compInfo;\n\t\t\tif (\"zk\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since <zk> doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new ComponentInfo(parent, ComponentDefinition.ZK); \n\t\t\t} else if (LanguageDefinition.NATIVE_NAMESPACE.equals(uri)) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since inline doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new NativeInfo(\n\t\t\t\t\tparent, langdef.getNativeDefinition(), nm);\n\t\t\t} else {\n\t\t\t\tif (LanguageDefinition.ZK_NAMESPACE.equals(uri))\n\t\t\t\t\tthrow new UiException(\"Unknown ZK component: \"+el+\", \"+el.getLocator());\n\n\t\t\t\tfinal LanguageDefinition complangdef;\n\t\t\t\tif (isDefault(langdef, pref, uri)) {\n\t\t\t\t\tcomplangdef = langdef;\n\t\t\t\t} else {\n\t\t\t\t\tcomplangdef = LanguageDefinition.lookup(uri);\n\t\t\t\t}\n\n\t\t\t\tComponentDefinition compdef =\n\t\t\t\t\tpgdef.getComponentDefinitionMap().get(nm);\n\t\t\t\tif (compdef != null) {\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t} else if (complangdef.hasComponentDefinition(nm)) {\n\t\t\t\t\tcompdef = complangdef.getComponentDefinition(nm);\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t} else {\n\t\t\t\t\tcompdef = complangdef.getDynamicTagDefinition();\n\t\t\t\t\tif (compdef == null)\n\t\t\t\t\t\tthrow new DefinitionNotFoundException(\"Component definition not found: \"+nm+\" in \"+complangdef+\", \"+el.getLocator());\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef, nm);\n\t\t\t\t}\n\n\t\t\t\t//process use first because addProperty needs it\n\t\t\t\tfinal String use = el.getAttributeValue(\"use\");\n\t\t\t\tif (use != null) {\n\t\t\t\t\tnoEmpty(\"use\", use, el);\n\t\t\t\t\tnoEL(\"use\", use, el);\n\t\t\t\t\tcompInfo.setImplementationClass(use);\n\t\t\t\t\t\t//Resolve later since might defined in zscript\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ifc = null, unless = null,\n\t\t\t\tforEach = null, forEachBegin = null, forEachEnd = null;\n\t\t\tAnnotationHelper attrAnnHelper = null;\n\t\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\t\tfinal String attval = attr.getValue();\n\t\t\t\tif (attrns != null\n\t\t\t\t&& LanguageDefinition.ANNO_NAMESPACE.equals(attrns.getURI())) {\n\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\tattrAnnHelper.addByRawValue(attnm, attval);\n\t\t\t\t} else if (\"forward\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setForward(attval);\n\t\t\t\t} else if (\"if\".equals(attnm)) {\n\t\t\t\t\tifc = attval;\n\t\t\t\t} else if (\"unless\".equals(attnm)) {\n\t\t\t\t\tunless = attval;\n\t\t\t\t} else if (\"forEach\".equals(attnm)) {\n\t\t\t\t\tforEach = attval;\n\t\t\t\t} else if (\"forEachBegin\".equals(attnm)) {\n\t\t\t\t\tforEachBegin = attval;\n\t\t\t\t} else if (\"forEachEnd\".equals(attnm)) {\n\t\t\t\t\tforEachEnd = attval;\n\t\t\t\t} else if (\"fulfill\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setFulfill(attval);\n\t\t\t\t} else if (!\"use\".equals(attnm)) {\n\t\t\t\t\tfinal Namespace attns = attr.getNamespace();\n\t\t\t\t\tfinal String attpref = attns != null ? attns.getPrefix(): \"\";\n\t\t\t\t\tfinal String attruri = attns != null ? attns.getURI(): \"\";\n\t\t\t\t\tif (!\"xmlns\".equals(attpref)\n\t\t\t\t\t&& !(\"xmlns\".equals(attnm) && \"\".equals(attpref))\n\t\t\t\t\t&& !\"http://www.w3.org/2001/XMLSchema-instance\".equals(attruri)) {\n\t\t\t\t\t\tfinal int len = attval.length();\n\t\t\t\t\t\tif (len >= 3 && attval.charAt(0) == '@'\n\t\t\t\t\t\t&& attval.charAt(1) == '{' && attval.charAt(len-1) == '}') { //annotation\n\t\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\t\tattrAnnHelper.addByCompoundValue(\n\t\t\t\t\t\t\t\tattval.substring(2, len -1));\n\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo,\n\t\t\t\t\t\t\t\t\"self\".equals(attnm) ? null: attnm, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddAttribute(compInfo, attns, attnm, attval, null);\n\t\t\t\t\t\t\tif (attrAnnHelper != null)\n\t\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo, attnm, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcompInfo.setCondition(ConditionImpl.getInstance(ifc, unless));\n\t\t\tcompInfo.setForEach(forEach, forEachBegin, forEachEnd);\n\t\t\tannHelper.applyAnnotations(compInfo, null, true);\n\n\t\t\tparse(pgdef, compInfo, el.getChildren(), annHelper); //recursive\n\n\t\t\t//optimize native components\n/*\t\t\tif (compInfo instanceof NativeInfo\n\t\t\t&& !compInfo.getChildren().isEmpty())\n\t\t\t\tminimizeNative((NativeInfo)compInfo);\n*/\t\t}\n\t}","id":76167,"modified_method":"/** Parse an component definition specified in the given element.\n\t */\n\tprivate void parse(PageDefinition pgdef, NodeInfo parent,\n\tElement el, AnnotationHelper annHelper)\n\tthrows Exception {\n\t\tfinal String nm = el.getLocalName();\n\t\tfinal Namespace ns = el.getNamespace();\n\t\tfinal String pref = ns != null ? ns.getPrefix(): \"\";\n\t\tfinal String uri = ns != null ? ns.getURI(): \"\";\n\t\tfinal LanguageDefinition langdef = pgdef.getLanguageDefinition();\n\t\tif (\"zscript\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseZScript(parent, el, annHelper);\n\t\t} else if (\"attribute\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tif (!(parent instanceof ComponentInfo))\n\t\t\t\tthrow new UiException(\"<attribute> cannot be the root element, \"+el.getLocator());\n\n\t\t\tparseAttribute((ComponentInfo)parent, el, annHelper);\n\t\t} else if (\"custom-attributes\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseCustomAttributes(parent, el, annHelper);\n\t\t} else if (\"variables\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\tparseVariables(parent, el, annHelper);\n\t\t} else if (LanguageDefinition.ANNO_NAMESPACE.equals(uri)) {\n\t\t\tparseAnnotation(el, annHelper);\n\t\t} else {\n\t\t\t//if (D.ON && log.debugable()) log.debug(\"component: \"+nm+\", ns:\"+ns);\n\n\t\t\tfinal ComponentInfo compInfo;\n\t\t\tif (\"zk\".equals(nm) && isZkElement(langdef, nm, pref, uri)) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since <zk> doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new ComponentInfo(parent, ComponentDefinition.ZK); \n\t\t\t} else if (LanguageDefinition.NATIVE_NAMESPACE.equals(uri)) {\n\t\t\t\tif (annHelper.clear())\n\t\t\t\t\tlog.warning(\"Annotations are ignored since inline doesn't support them, \"+el.getLocator());\n\t\t\t\tcompInfo = new NativeInfo(\n\t\t\t\t\tparent, langdef.getNativeDefinition(), nm);\n\t\t\t} else {\n\t\t\t\tif (LanguageDefinition.ZK_NAMESPACE.equals(uri))\n\t\t\t\t\tthrow new UiException(\"Unknown ZK component: \"+el+\", \"+el.getLocator());\n\n\t\t\t\tfinal LanguageDefinition complangdef;\n\t\t\t\tif (isDefault(langdef, pref, uri)) {\n\t\t\t\t\tcomplangdef = langdef;\n\t\t\t\t} else {\n\t\t\t\t\tcomplangdef = LanguageDefinition.lookup(uri);\n\t\t\t\t}\n\n\t\t\t\tComponentDefinition compdef =\n\t\t\t\t\tpgdef.getComponentDefinitionMap().get(nm);\n\t\t\t\tif (compdef != null) {\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t} else if (complangdef.hasComponentDefinition(nm)) {\n\t\t\t\t\tcompdef = complangdef.getComponentDefinition(nm);\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef);\n\t\t\t\t} else {\n\t\t\t\t\tcompdef = complangdef.getDynamicTagDefinition();\n\t\t\t\t\tif (compdef == null)\n\t\t\t\t\t\tthrow new DefinitionNotFoundException(\"Component definition not found: \"+nm+\" in \"+complangdef+\", \"+el.getLocator());\n\t\t\t\t\tcompInfo = new ComponentInfo(parent, compdef, nm);\n\t\t\t\t}\n\n\t\t\t\t//process use first because addProperty needs it\n\t\t\t\tfinal String use = el.getAttributeValue(\"use\");\n\t\t\t\tif (use != null) {\n\t\t\t\t\tnoEmpty(\"use\", use, el);\n\t\t\t\t\tnoEL(\"use\", use, el);\n\t\t\t\t\tcompInfo.setImplementationClass(use);\n\t\t\t\t\t\t//Resolve later since might defined in zscript\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString ifc = null, unless = null,\n\t\t\t\tforEach = null, forEachBegin = null, forEachEnd = null;\n\t\t\tAnnotationHelper attrAnnHelper = null;\n\t\t\tfor (Iterator it = el.getAttributeItems().iterator();\n\t\t\tit.hasNext();) {\n\t\t\t\tfinal Attribute attr = (Attribute)it.next();\n\t\t\t\tfinal Namespace attrns = attr.getNamespace();\n\t\t\t\tfinal String attnm = attr.getLocalName();\n\t\t\t\tfinal String attval = attr.getValue();\n\t\t\t\tif (attrns != null\n\t\t\t\t&& LanguageDefinition.ANNO_NAMESPACE.equals(attrns.getURI())) {\n\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\tattrAnnHelper.addByRawValue(attnm, attval);\n\t\t\t\t} else if (\"forward\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setForward(attval);\n\t\t\t\t} else if (\"if\".equals(attnm)) {\n\t\t\t\t\tifc = attval;\n\t\t\t\t} else if (\"unless\".equals(attnm)) {\n\t\t\t\t\tunless = attval;\n\t\t\t\t} else if (\"forEach\".equals(attnm)) {\n\t\t\t\t\tforEach = attval;\n\t\t\t\t} else if (\"forEachBegin\".equals(attnm)) {\n\t\t\t\t\tforEachBegin = attval;\n\t\t\t\t} else if (\"forEachEnd\".equals(attnm)) {\n\t\t\t\t\tforEachEnd = attval;\n\t\t\t\t} else if (\"fulfill\".equals(attnm)) {\n\t\t\t\t\tcompInfo.setFulfill(attval);\n\t\t\t\t} else if (!\"use\".equals(attnm)) {\n\t\t\t\t\tfinal Namespace attns = attr.getNamespace();\n\t\t\t\t\tfinal String attpref = attns != null ? attns.getPrefix(): \"\";\n\t\t\t\t\tfinal String attruri = attns != null ? attns.getURI(): \"\";\n\t\t\t\t\tif (!\"xmlns\".equals(attpref)\n\t\t\t\t\t&& !(\"xmlns\".equals(attnm) && \"\".equals(attpref))\n\t\t\t\t\t&& !\"http://www.w3.org/2001/XMLSchema-instance\".equals(attruri)) {\n\t\t\t\t\t\tfinal int len = attval.length();\n\t\t\t\t\t\tif (len >= 3 && attval.charAt(0) == '@'\n\t\t\t\t\t\t&& attval.charAt(1) == '{' && attval.charAt(len-1) == '}') { //annotation\n\t\t\t\t\t\t\tif (attrAnnHelper == null)\n\t\t\t\t\t\t\t\tattrAnnHelper = new AnnotationHelper();\n\t\t\t\t\t\t\tattrAnnHelper.addByCompoundValue(\n\t\t\t\t\t\t\t\tattval.substring(2, len -1));\n\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo,\n\t\t\t\t\t\t\t\t\"self\".equals(attnm) ? null: attnm, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddAttribute(compInfo, attns, attnm, attval, null);\n\t\t\t\t\t\t\tif (attrAnnHelper != null)\n\t\t\t\t\t\t\t\tattrAnnHelper.applyAnnotations(compInfo, attnm, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcompInfo.setCondition(ConditionImpl.getInstance(ifc, unless));\n\t\t\tcompInfo.setForEach(forEach, forEachBegin, forEachEnd);\n\t\t\tannHelper.applyAnnotations(compInfo, null, true);\n\n\t\t\tparse(pgdef, compInfo, el.getChildren(), annHelper); //recursive\n\n\t\t\t//optimize native components\n\t\t\tif (compInfo instanceof NativeInfo\n\t\t\t&& !compInfo.getChildren().isEmpty())\n\t\t\t\toptimizeNativeInfos((NativeInfo)compInfo);\n\t\t}\n\t}","commit_id":"105ce7ad39191561b75f51504242877f0059e6f3","url":"https://github.com/zkoss/zk"},{"original_method":"public Component[] createComponents(Execution exec,\n\tPageDefinition pagedef, Page page, Component parent, Map arg) {\n\t\tif (pagedef == null)\n\t\t\tthrow new IllegalArgumentException(\"pagedef\");\n\t\tif (parent != null)\n\t\t\tpage = parent.getPage();\n\t\telse if (page != null)\n\t\t\tparent = ((PageCtrl)page).getDefaultParent();\n\n\t\tfinal ExecutionCtrl execCtrl = (ExecutionCtrl)exec;\n\t\tif (!execCtrl.isActivated())\n\t\t\tthrow new IllegalStateException(\"Not activated yet\");\n\n\t\tfinal Page old = execCtrl.getCurrentPage();\n\t\tfinal PageDefinition olddef = execCtrl.getCurrentPageDefinition();\n\t\tif (page != null)\n\t\t\texecCtrl.setCurrentPage(page);\n\t\texecCtrl.setCurrentPageDefinition(pagedef);\n\t\texec.pushArg(arg != null ? arg: Collections.EMPTY_MAP);\n\n\t\t//Note: we add taglib, stylesheets and var-resolvers to the page\n\t\t//it might cause name pollution but we got no choice since they\n\t\t//are used as long as components created by this method are alive\n\t\tif (page != null) page.addFunctionMapper(pagedef.getFunctionMapper());\n\t\tinitVariableResolvers(pagedef, page);\n\n\t\tfinal Initiators inits = Initiators.doInit(pagedef, page);\n\t\ttry {\n\t\t\tfinal Component[] cs = execCreate(\n\t\t\t\t((WebAppCtrl)exec.getDesktop().getWebApp()).getUiFactory(),\n\t\t\t\texec, page, pagedef, parent);\n\t\t\tinits.doAfterCompose(page);\n\t\t\treturn cs;\n\t\t} catch (Throwable ex) {\n\t\t\tinits.doCatch(ex);\n\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t} finally {\n\t\t\texec.popArg();\n\t\t\texecCtrl.setCurrentPage(old); //restore it\n\t\t\texecCtrl.setCurrentPageDefinition(olddef); //restore it\n\n\t\t\tinits.doFinally();\n\t\t}\n\t}","id":76168,"modified_method":"public Component[] createComponents(Execution exec,\n\tPageDefinition pagedef, Page page, Component parent, Map arg) {\n\t\tif (pagedef == null)\n\t\t\tthrow new IllegalArgumentException(\"pagedef\");\n\t\tif (parent != null)\n\t\t\tpage = parent.getPage();\n\t\telse if (page != null)\n\t\t\tparent = ((PageCtrl)page).getDefaultParent();\n\n\t\tfinal ExecutionCtrl execCtrl = (ExecutionCtrl)exec;\n\t\tif (!execCtrl.isActivated())\n\t\t\tthrow new IllegalStateException(\"Not activated yet\");\n\n\t\tfinal Page old = execCtrl.getCurrentPage();\n\t\tfinal PageDefinition olddef = execCtrl.getCurrentPageDefinition();\n\t\tif (page != null)\n\t\t\texecCtrl.setCurrentPage(page);\n\t\texecCtrl.setCurrentPageDefinition(pagedef);\n\t\texec.pushArg(arg != null ? arg: Collections.EMPTY_MAP);\n\n\t\t//Note: we add taglib, stylesheets and var-resolvers to the page\n\t\t//it might cause name pollution but we got no choice since they\n\t\t//are used as long as components created by this method are alive\n\t\tif (page != null) page.addFunctionMapper(pagedef.getFunctionMapper());\n\t\tinitVariableResolvers(pagedef, page);\n\n\t\tfinal Initiators inits = Initiators.doInit(pagedef, page);\n\t\ttry {\n\t\t\tfinal Component[] cs = execCreate(\n\t\t\t\tnew CreateInfo(\n\t\t\t\t\t((WebAppCtrl)exec.getDesktop().getWebApp()).getUiFactory(),\n\t\t\t\t\texec, page),\n\t\t\t\tpagedef, parent);\n\t\t\tinits.doAfterCompose(page);\n\t\t\treturn cs;\n\t\t} catch (Throwable ex) {\n\t\t\tinits.doCatch(ex);\n\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t} finally {\n\t\t\texec.popArg();\n\t\t\texecCtrl.setCurrentPage(old); //restore it\n\t\t\texecCtrl.setCurrentPageDefinition(olddef); //restore it\n\n\t\t\tinits.doFinally();\n\t\t}\n\t}","commit_id":"105ce7ad39191561b75f51504242877f0059e6f3","url":"https://github.com/zkoss/zk"},{"original_method":"/** Cycle 1:\n\t * Creates all child components defined in the specified definition.\n\t * @return the first component being created.\n\t */\n\tprivate static final Component[] execCreate(UiFactory uf,\n\tExecution exec, Page page, NodeInfo parentInfo, Component parent)\n\tthrows IOException {\n\t\tif (parentInfo instanceof ComponentInfo) {\n\t\t\tfinal ComponentInfo pi = (ComponentInfo)parentInfo;\n\t\t\tfinal String fulfill = pi.getFulfill();\n\t\t\tif (fulfill != null) { //defer the creation of children\n\t\t\t\tnew FulfillListener(fulfill, pi, parent);\n\t\t\t\treturn new Component[0];\n\t\t\t}\n\t\t}\n\t\treturn execCreate0(uf, exec, page, parentInfo, parent);\n\t}","id":76169,"modified_method":"/** Cycle 1:\n\t * Creates all child components defined in the specified definition.\n\t * @return the first component being created.\n\t */\n\tprivate static final Component[] execCreate(\n\tCreateInfo ci, NodeInfo parentInfo, Component parent)\n\tthrows IOException {\n\t\tif (parentInfo instanceof ComponentInfo) {\n\t\t\tfinal ComponentInfo pi = (ComponentInfo)parentInfo;\n\t\t\tfinal String fulfill = pi.getFulfill();\n\t\t\tif (fulfill != null) { //defer the creation of children\n\t\t\t\tnew FulfillListener(fulfill, pi, parent);\n\t\t\t\treturn new Component[0];\n\t\t\t}\n\t\t}\n\t\treturn execCreate0(ci, parentInfo, parent);\n\t}","commit_id":"105ce7ad39191561b75f51504242877f0059e6f3","url":"https://github.com/zkoss/zk"},{"original_method":"public void onEvent(Event evt) throws Exception {\n\t\t\t_target.removeEventListener(_evtnm, this); //one shot only\n\n\t\t\tfinal Execution exec = Executions.getCurrent();\n\t\t\texecCreate0(\n\t\t\t\t((WebAppCtrl)exec.getDesktop().getWebApp()).getUiFactory(),\n\t\t\t\texec, _comp.getPage(), _compInfo, _comp);\n\t\t}","id":76170,"modified_method":"public void onEvent(Event evt) throws Exception {\n\t\t\t_target.removeEventListener(_evtnm, this); //one shot only\n\n\t\t\tfinal Execution exec = Executions.getCurrent();\n\t\t\texecCreate0(\n\t\t\t\tnew CreateInfo(\n\t\t\t\t\t((WebAppCtrl)exec.getDesktop().getWebApp()).getUiFactory(),\n\t\t\t\t\texec, _comp.getPage()),\n\t\t\t\t_compInfo, _comp);\n\t\t}","commit_id":"105ce7ad39191561b75f51504242877f0059e6f3","url":"https://github.com/zkoss/zk"},{"original_method":"private static Component[] execCreateChild(UiFactory uf,\n\tExecution exec, Page page, Component parent,\n\tComponentInfo childInfo) throws IOException {\n\t\tfinal ComponentDefinition childdef = childInfo.getComponentDefinition();\n\t\tif (ComponentDefinition.ZK == childdef) {\n\t\t\treturn execCreate(uf, exec, page, childInfo, parent);\n\t\t} else if (childdef.isInlineMacro()) {\n\t\t\tfinal Map props = new HashMap();\n\t\t\tprops.put(\"includer\", parent);\n\t\t\tchildInfo.evalProperties(props, page, parent, true);\n\t\t\treturn new Component[] {\n\t\t\t\texec.createComponents(childdef.getMacroURI(), parent, props)};\n\t\t} else {\n\t\t\tfinal Component child = uf.newComponent(page, parent, childInfo);\n\n\t\t\texecCreate(uf, exec, page, childInfo, child); //recursive\n\n\t\t\tif (child instanceof AfterCompose)\n\t\t\t\t((AfterCompose)child).afterCompose();\n\n\t\t\tComponentsCtrl.applyForward(child, childInfo.getForward());\n\t\t\t\t//applies the forward condition\n\t\t\t\t//1) we did it after all child created, so it may reference\n\t\t\t\t//to it child (thought rarely happens)\n\t\t\t\t//2) we did it after afterCompose, so what specified\n\t\t\t\t//here has higher priority than class defined by app dev\n\n\t\t\tif (Events.isListened(child, Events.ON_CREATE, false))\n\t\t\t\tEvents.postEvent(\n\t\t\t\t\tnew CreateEvent(Events.ON_CREATE, child, exec.getArg()));\n\n\t\t\treturn new Component[] {child};\n\t\t}\n\t}","id":76171,"modified_method":"private static Component[] execCreateChild(\n\tCreateInfo ci, Component parent, ComponentInfo childInfo)\n\tthrows IOException {\n\t\tfinal ComponentDefinition childdef = childInfo.getComponentDefinition();\n\t\tif (ComponentDefinition.ZK == childdef) {\n\t\t\treturn execCreate(ci, childInfo, parent);\n\t\t} else if (childdef.isInlineMacro()) {\n\t\t\tfinal Map props = new HashMap();\n\t\t\tprops.put(\"includer\", parent);\n\t\t\tchildInfo.evalProperties(props, ci.page, parent, true);\n\t\t\treturn new Component[] {\n\t\t\t\tci.exec.createComponents(childdef.getMacroURI(), parent, props)};\n\t\t} else {\n\t\t\tfinal Component child =\n\t\t\t\tci.uf.newComponent(ci.page, parent, childInfo);\n\n\t\t\tfinal boolean bNative = childInfo instanceof NativeInfo;\n\t\t\tif (bNative)\n\t\t\t\tcreatePrologAndSplit(ci, (NativeInfo)childInfo, child);\n\n\t\t\texecCreate(ci, childInfo, child); //recursive\n\n\t\t\tif (bNative)\n\t\t\t\tcreateEpilog(ci, (NativeInfo)childInfo, child);\n\n\t\t\tif (child instanceof AfterCompose)\n\t\t\t\t((AfterCompose)child).afterCompose();\n\n\t\t\tComponentsCtrl.applyForward(child, childInfo.getForward());\n\t\t\t\t//applies the forward condition\n\t\t\t\t//1) we did it after all child created, so it may reference\n\t\t\t\t//to it child (thought rarely happens)\n\t\t\t\t//2) we did it after afterCompose, so what specified\n\t\t\t\t//here has higher priority than class defined by app dev\n\n\t\t\tif (Events.isListened(child, Events.ON_CREATE, false))\n\t\t\t\tEvents.postEvent(\n\t\t\t\t\tnew CreateEvent(Events.ON_CREATE, child, ci.exec.getArg()));\n\n\t\t\treturn new Component[] {child};\n\t\t}\n\t}","commit_id":"105ce7ad39191561b75f51504242877f0059e6f3","url":"https://github.com/zkoss/zk"},{"original_method":"/** It assumes exactly one of pagedef and richlet is not null.\n\t */\n\tpublic void execNewPage0(final Execution exec, final PageDefinition pagedef,\n\tfinal Richlet richlet, final Page page, final Writer out) throws IOException {\n\t\t//Update the device type first. If this is the second page and not\n\t\t//belonging to the same device type, an exception is thrown\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal LanguageDefinition langdef = //default page\n\t\t\tpagedef != null ? pagedef.getLanguageDefinition():\n\t\t\trichlet != null ? richlet.getLanguageDefinition(): null;\n\t\tif (langdef != null)\n\t\t\tdesktop.setDeviceType(langdef.getDeviceType()); //set and check!\n\n\t\t//It is possible this method is invoked when processing other exec\n\t\tfinal Execution oldexec = Executions.getCurrent();\n\t\tfinal ExecutionCtrl oldexecCtrl = (ExecutionCtrl)oldexec;\n\t\tfinal UiVisualizer olduv =\n\t\t\toldexecCtrl != null ? (UiVisualizer)oldexecCtrl.getVisualizer(): null;\n\n\t\tfinal UiVisualizer uv;\n\t\tif (olduv != null) uv = doReactivate(exec, olduv);\n\t\telse uv = doActivate(exec, null, false);\n\n\t\tfinal ExecutionCtrl execCtrl = (ExecutionCtrl)exec;\n\t\tfinal Page old = execCtrl.getCurrentPage();\n\t\tfinal PageDefinition olddef = execCtrl.getCurrentPageDefinition();\n\t\texecCtrl.setCurrentPage(page);\n\t\texecCtrl.setCurrentPageDefinition(pagedef);\n\n\t\tfinal Configuration config = _wapp.getConfiguration();\n\t\tboolean cleaned = false;\n\t\ttry {\n\t\t\tconfig.invokeExecutionInits(exec, oldexec);\n\n\t\t\tif (olduv != null) {\n\t\t\t\tfinal Component owner = olduv.getOwner();\n\t\t\t\tif (owner != null) {\n\t\t\t\t\t((PageCtrl)page).setOwner(owner);\n//\t\t\t\t\tif (D.ON && log.finerable()) log.finer(\"Set owner of \"+page+\" to \"+owner);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Cycle 1: Creates all components\n\n\t\t\t//Note:\n\t\t\t//1) stylesheet, tablib are inited in Page's contructor\n\t\t\t//2) we add variable resolvers before init because\n\t\t\t//init's zscirpt might depend on it.\n\t\t\tif (pagedef != null) {\n\t\t\t\tpage.addFunctionMapper(pagedef.getFunctionMapper());\n\t\t\t\tinitVariableResolvers(pagedef, page);\n\n\t\t\t\tfinal Initiators inits = Initiators.doInit(pagedef, page);\n\t\t\t\ttry {\n\t\t\t\t\t//Request 1472813: sendRedirect in init; test: sendRedirectNow.zul\n\t\t\t\t\tpagedef.init(page, !uv.isEverAsyncUpdate() && !uv.isAborting());\n\t\t\t\t\tif (!uv.isAborting() && !exec.isVoided())\n\t\t\t\t\t\texecCreate(\n\t\t\t\t\t\t\t((WebAppCtrl)_wapp).getUiFactory(),\n\t\t\t\t\t\t\texec, page, pagedef, null);\n\t\t\t\t\tinits.doAfterCompose(page);\n\t\t\t\t} catch(Throwable ex) {\n\t\t\t\t\tinits.doCatch(ex);\n\t\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t\t} finally {\n\t\t\t\t\tinits.doFinally();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//FUTURE: a way to allow richlet to set page ID\n\t\t\t\t((PageCtrl)page).init(new PageConfig() {\n\t\t\t\t\tpublic String getId() {return null;}\n\t\t\t\t\tpublic String getUuid() {return null;}\n\t\t\t\t\tpublic String getTitle() {return null;}\n\t\t\t\t\tpublic String getStyle() {return null;}\n\t\t\t\t\tpublic String getHeaders() {return null;}\n\t\t\t\t\tpublic String getRootAttributes() {return null;}\n\t\t\t\t});\n\t\t\t\trichlet.service(page);\n\t\t\t}\n\t\t\tif (exec.isVoided())\n\t\t\t\treturn; //don't generate any output\n\n\t\t\t//Cycle 2: process pending events\n\t\t\t//Unlike execUpdate, execution is aborted here if any exception\n\t\t\tEvent event = nextEvent(uv);\n\t\t\tdo {\n\t\t\t\tfor (; event != null; event = nextEvent(uv))\n\t\t\t\t\tprocess(desktop, event);\n\t\t\t\tresumeAll(desktop, uv, null);\n\t\t\t} while ((event = nextEvent(uv)) != null);\n\n\t\t\t//Cycle 2a: Handle aborting reason\n\t\t\tfinal AbortingReason abrn = uv.getAbortingReason();\n\t\t\tif (abrn != null)\n\t\t\t\tabrn.execute(); //always execute even if !isAborting\n\n\t\t\t//Cycle 3: Redraw the page (and responses)\n\t\t\tList responses = uv.getResponses();\n\n\t\t\tif (olduv != null && olduv.addToFirstAsyncUpdate(responses))\n\t\t\t\tresponses = null;\n\t\t\t\t//A new ZK page might be included by an async update\n\t\t\t\t//(example: ZUL's include).\n\t\t\t\t//If so, we cannot generate the responses in the page.\n\t\t\t\t//Rather, we shall add them to the async update.\n\n\t\t\t((PageCtrl)page).redraw(responses, out);\n\t\t} catch (Throwable ex) {\n\t\t\tcleaned = true;\n\t\t\tfinal List errs = new LinkedList();\n\t\t\terrs.add(ex);\n\t\t\tconfig.invokeExecutionCleanups(exec, oldexec, errs);\n\t\t\t\t//CONSIDER: whether to pass cleanup's error to users\n\n\t\t\tif (!errs.isEmpty()) {\n\t\t\t\tex = (Throwable)errs.get(0);\n\t\t\t\tif (ex instanceof IOException) throw (IOException)ex;\n\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!cleaned) config.invokeExecutionCleanups(exec, oldexec, null);\n\t\t\t\t//CONSIDER: whether to pass cleanup's error to users\n\n\t\t\texecCtrl.setCurrentPage(old); //restore it\n\t\t\texecCtrl.setCurrentPageDefinition(olddef); //restore it\n\n\t\t\tif (olduv != null) doDereactivate(exec, olduv);\n\t\t\telse doDeactivate(exec);\n\t\t}\n\t}","id":76172,"modified_method":"/** It assumes exactly one of pagedef and richlet is not null.\n\t */\n\tpublic void execNewPage0(final Execution exec, final PageDefinition pagedef,\n\tfinal Richlet richlet, final Page page, final Writer out) throws IOException {\n\t\t//Update the device type first. If this is the second page and not\n\t\t//belonging to the same device type, an exception is thrown\n\t\tfinal Desktop desktop = exec.getDesktop();\n\t\tfinal LanguageDefinition langdef = //default page\n\t\t\tpagedef != null ? pagedef.getLanguageDefinition():\n\t\t\trichlet != null ? richlet.getLanguageDefinition(): null;\n\t\tif (langdef != null)\n\t\t\tdesktop.setDeviceType(langdef.getDeviceType()); //set and check!\n\n\t\t//It is possible this method is invoked when processing other exec\n\t\tfinal Execution oldexec = Executions.getCurrent();\n\t\tfinal ExecutionCtrl oldexecCtrl = (ExecutionCtrl)oldexec;\n\t\tfinal UiVisualizer olduv =\n\t\t\toldexecCtrl != null ? (UiVisualizer)oldexecCtrl.getVisualizer(): null;\n\n\t\tfinal UiVisualizer uv;\n\t\tif (olduv != null) uv = doReactivate(exec, olduv);\n\t\telse uv = doActivate(exec, null, false);\n\n\t\tfinal ExecutionCtrl execCtrl = (ExecutionCtrl)exec;\n\t\tfinal Page old = execCtrl.getCurrentPage();\n\t\tfinal PageDefinition olddef = execCtrl.getCurrentPageDefinition();\n\t\texecCtrl.setCurrentPage(page);\n\t\texecCtrl.setCurrentPageDefinition(pagedef);\n\n\t\tfinal Configuration config = _wapp.getConfiguration();\n\t\tboolean cleaned = false;\n\t\ttry {\n\t\t\tconfig.invokeExecutionInits(exec, oldexec);\n\n\t\t\tif (olduv != null) {\n\t\t\t\tfinal Component owner = olduv.getOwner();\n\t\t\t\tif (owner != null) {\n\t\t\t\t\t((PageCtrl)page).setOwner(owner);\n//\t\t\t\t\tif (D.ON && log.finerable()) log.finer(\"Set owner of \"+page+\" to \"+owner);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Cycle 1: Creates all components\n\n\t\t\t//Note:\n\t\t\t//1) stylesheet, tablib are inited in Page's contructor\n\t\t\t//2) we add variable resolvers before init because\n\t\t\t//init's zscirpt might depend on it.\n\t\t\tif (pagedef != null) {\n\t\t\t\tpage.addFunctionMapper(pagedef.getFunctionMapper());\n\t\t\t\tinitVariableResolvers(pagedef, page);\n\n\t\t\t\tfinal Initiators inits = Initiators.doInit(pagedef, page);\n\t\t\t\ttry {\n\t\t\t\t\t//Request 1472813: sendRedirect in init; test: sendRedirectNow.zul\n\t\t\t\t\tpagedef.init(page, !uv.isEverAsyncUpdate() && !uv.isAborting());\n\t\t\t\t\tif (!uv.isAborting() && !exec.isVoided())\n\t\t\t\t\t\texecCreate(\n\t\t\t\t\t\t\tnew CreateInfo(\n\t\t\t\t\t\t\t\t((WebAppCtrl)_wapp).getUiFactory(),\n\t\t\t\t\t\t\t\texec, page),\n\t\t\t\t\t\t\tpagedef, null);\n\t\t\t\t\tinits.doAfterCompose(page);\n\t\t\t\t} catch(Throwable ex) {\n\t\t\t\t\tinits.doCatch(ex);\n\t\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t\t} finally {\n\t\t\t\t\tinits.doFinally();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//FUTURE: a way to allow richlet to set page ID\n\t\t\t\t((PageCtrl)page).init(new PageConfig() {\n\t\t\t\t\tpublic String getId() {return null;}\n\t\t\t\t\tpublic String getUuid() {return null;}\n\t\t\t\t\tpublic String getTitle() {return null;}\n\t\t\t\t\tpublic String getStyle() {return null;}\n\t\t\t\t\tpublic String getHeaders() {return null;}\n\t\t\t\t\tpublic String getRootAttributes() {return null;}\n\t\t\t\t});\n\t\t\t\trichlet.service(page);\n\t\t\t}\n\t\t\tif (exec.isVoided())\n\t\t\t\treturn; //don't generate any output\n\n\t\t\t//Cycle 2: process pending events\n\t\t\t//Unlike execUpdate, execution is aborted here if any exception\n\t\t\tEvent event = nextEvent(uv);\n\t\t\tdo {\n\t\t\t\tfor (; event != null; event = nextEvent(uv))\n\t\t\t\t\tprocess(desktop, event);\n\t\t\t\tresumeAll(desktop, uv, null);\n\t\t\t} while ((event = nextEvent(uv)) != null);\n\n\t\t\t//Cycle 2a: Handle aborting reason\n\t\t\tfinal AbortingReason abrn = uv.getAbortingReason();\n\t\t\tif (abrn != null)\n\t\t\t\tabrn.execute(); //always execute even if !isAborting\n\n\t\t\t//Cycle 3: Redraw the page (and responses)\n\t\t\tList responses = uv.getResponses();\n\n\t\t\tif (olduv != null && olduv.addToFirstAsyncUpdate(responses))\n\t\t\t\tresponses = null;\n\t\t\t\t//A new ZK page might be included by an async update\n\t\t\t\t//(example: ZUL's include).\n\t\t\t\t//If so, we cannot generate the responses in the page.\n\t\t\t\t//Rather, we shall add them to the async update.\n\n\t\t\t((PageCtrl)page).redraw(responses, out);\n\t\t} catch (Throwable ex) {\n\t\t\tcleaned = true;\n\t\t\tfinal List errs = new LinkedList();\n\t\t\terrs.add(ex);\n\t\t\tconfig.invokeExecutionCleanups(exec, oldexec, errs);\n\t\t\t\t//CONSIDER: whether to pass cleanup's error to users\n\n\t\t\tif (!errs.isEmpty()) {\n\t\t\t\tex = (Throwable)errs.get(0);\n\t\t\t\tif (ex instanceof IOException) throw (IOException)ex;\n\t\t\t\tthrow UiException.Aide.wrap(ex);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!cleaned) config.invokeExecutionCleanups(exec, oldexec, null);\n\t\t\t\t//CONSIDER: whether to pass cleanup's error to users\n\n\t\t\texecCtrl.setCurrentPage(old); //restore it\n\t\t\texecCtrl.setCurrentPageDefinition(olddef); //restore it\n\n\t\t\tif (olduv != null) doDereactivate(exec, olduv);\n\t\t\telse doDeactivate(exec);\n\t\t}\n\t}","commit_id":"105ce7ad39191561b75f51504242877f0059e6f3","url":"https://github.com/zkoss/zk"},{"original_method":"private static final Component[] execCreate0(UiFactory uf,\n\tExecution exec, Page page, NodeInfo parentInfo, Component parent)\n\tthrows IOException {\n\t\tfinal List created = new LinkedList();\n\t\tfinal PageDefinition pagedef = parentInfo.getPageDefinition();\n\t\t\t//note: don't use page.getDefinition because createComponents\n\t\t\t//might be called from a page other than instance's\n\t\tfor (Iterator it = parentInfo.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Object obj = it.next();\n\t\t\tif (obj instanceof ComponentInfo) {\n\t\t\t\tfinal ComponentInfo childInfo = (ComponentInfo)obj;\n\t\t\t\tfinal ForEach forEach = childInfo.getForEach(page, parent);\n\t\t\t\tif (forEach == null) {\n\t\t\t\t\tif (isEffective(childInfo, page, parent)) {\n\t\t\t\t\t\tfinal Component[] children =\n\t\t\t\t\t\t\texecCreateChild(uf, exec, page, parent, childInfo);\n\t\t\t\t\t\tfor (int j = 0; j < children.length; ++j)\n\t\t\t\t\t\t\tcreated.add(children[j]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (forEach.next()) {\n\t\t\t\t\t\tif (isEffective(childInfo, page, parent)) {\n\t\t\t\t\t\t\tfinal Component[] children =\n\t\t\t\t\t\t\t\texecCreateChild(uf, exec, page, parent, childInfo);\n\t\t\t\t\t\t\tfor (int j = 0; j < children.length; ++j)\n\t\t\t\t\t\t\t\tcreated.add(children[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (obj instanceof ZScript) {\n\t\t\t\tfinal ZScript zscript = (ZScript)obj;\n\t\t\t\tif (zscript.isDeferred()) {\n\t\t\t\t\t((PageCtrl)page).addDeferredZScript(parent, zscript);\n\t\t\t\t} else if (isEffective(zscript, page, parent)) {\n\t\t\t\t\tfinal Map backup = new HashMap();\n\t\t\t\t\tfinal Namespace ns = parent != null ?\n\t\t\t\t\t\tNamespaces.beforeInterpret(backup, parent, false):\n\t\t\t\t\t\tNamespaces.beforeInterpret(backup, page, false);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpage.interpret(zscript.getLanguage(),\n\t\t\t\t\t\t\tzscript.getContent(page, parent), ns);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tNamespaces.afterInterpret(backup, ns, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (obj instanceof AttributesInfo) {\n\t\t\t\tfinal AttributesInfo attrs = (AttributesInfo)obj;\n\t\t\t\tif (parent != null) attrs.apply(parent);\n\t\t\t\telse attrs.apply(page);\n\t\t\t} else if (obj instanceof VariablesInfo) {\n\t\t\t\tfinal VariablesInfo vars = (VariablesInfo)obj;\n\t\t\t\tif (parent != null) vars.apply(parent);\n\t\t\t\telse vars.apply(page);\n\t\t\t} else {\n\t\t\t\tthrow new IllegalStateException(\"Unknown object: \"+obj);\n\t\t\t}\n\t\t}\n\t\treturn (Component[])created.toArray(new Component[created.size()]);\n\t}","id":76173,"modified_method":"private static final Component[] execCreate0(\n\tCreateInfo ci, NodeInfo parentInfo, Component parent)\n\tthrows IOException {\n\t\tfinal List created = new LinkedList();\n\t\tfinal Page page = ci.page;\n\t\tfinal PageDefinition pagedef = parentInfo.getPageDefinition();\n\t\t\t//note: don't use page.getDefinition because createComponents\n\t\t\t//might be called from a page other than instance's\n\t\tfor (Iterator it = parentInfo.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Object meta = it.next();\n\t\t\tif (meta instanceof ComponentInfo) {\n\t\t\t\tfinal ComponentInfo childInfo = (ComponentInfo)meta;\n\t\t\t\tfinal ForEach forEach = childInfo.getForEach(page, parent);\n\t\t\t\tif (forEach == null) {\n\t\t\t\t\tif (isEffective(childInfo, page, parent)) {\n\t\t\t\t\t\tfinal Component[] children =\n\t\t\t\t\t\t\texecCreateChild(ci, parent, childInfo);\n\t\t\t\t\t\tfor (int j = 0; j < children.length; ++j)\n\t\t\t\t\t\t\tcreated.add(children[j]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (forEach.next()) {\n\t\t\t\t\t\tif (isEffective(childInfo, page, parent)) {\n\t\t\t\t\t\t\tfinal Component[] children =\n\t\t\t\t\t\t\t\texecCreateChild(ci, parent, childInfo);\n\t\t\t\t\t\t\tfor (int j = 0; j < children.length; ++j)\n\t\t\t\t\t\t\t\tcreated.add(children[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texecNonComponent(page, parent, meta);\n\t\t\t}\n\t\t}\n\t\treturn (Component[])created.toArray(new Component[created.size()]);\n\t}","commit_id":"105ce7ad39191561b75f51504242877f0059e6f3","url":"https://github.com/zkoss/zk"},{"original_method":"public long run(long rowid, long ignore)\n    {\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = getSeededRandomNumberGenerator();\n\n        // Insert a new record\n        SampleRecord record = new SampleRecord(rowid, rand);\n        voltQueueSQL(\n                      insert\n                    , getVoltPrivateRealTransactionIdDontUseMe()\n                    , rowid\n                    , record.rowid_group\n                    , record.type_null_tinyint\n                    , record.type_not_null_tinyint\n                    , record.type_null_smallint\n                    , record.type_not_null_smallint\n                    , record.type_null_integer\n                    , record.type_not_null_integer\n                    , record.type_null_bigint\n                    , record.type_not_null_bigint\n                    , record.type_null_timestamp\n                    , record.type_not_null_timestamp\n                    , record.type_null_float\n                    , record.type_not_null_float\n                    , record.type_null_decimal\n                    , record.type_not_null_decimal\n                    , record.type_null_varchar25\n                    , record.type_not_null_varchar25\n                    , record.type_null_varchar128\n                    , record.type_not_null_varchar128\n                    , record.type_null_varchar1024\n                    , record.type_not_null_varchar1024\n                    );\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return getVoltPrivateRealTransactionIdDontUseMe();\n    }","id":76174,"modified_method":"public long run(long rowid, long ignore)\n    {\n        @SuppressWarnings(\"deprecation\")\n        long txid = getVoltPrivateRealTransactionIdDontUseMe();\n\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = new Random(txid);\n\n\n        // Insert a new record\n        SampleRecord record = new SampleRecord(rowid, rand);\n        voltQueueSQL(\n                      insert\n                    , txid\n                    , rowid\n                    , record.rowid_group\n                    , record.type_null_tinyint\n                    , record.type_not_null_tinyint\n                    , record.type_null_smallint\n                    , record.type_not_null_smallint\n                    , record.type_null_integer\n                    , record.type_not_null_integer\n                    , record.type_null_bigint\n                    , record.type_not_null_bigint\n                    , record.type_null_timestamp\n                    , record.type_not_null_timestamp\n                    , record.type_null_float\n                    , record.type_not_null_float\n                    , record.type_null_decimal\n                    , record.type_not_null_decimal\n                    , record.type_null_varchar25\n                    , record.type_not_null_varchar25\n                    , record.type_null_varchar128\n                    , record.type_not_null_varchar128\n                    , record.type_null_varchar1024\n                    , record.type_not_null_varchar1024\n                    );\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return txid;\n    }","commit_id":"145b18610c05a2ea2cfa51b83b259e4222d4cc6e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public long run(long rowid, int reversed)\n    {\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = getSeededRandomNumberGenerator();\n\n        // Insert a new record\n        SampleRecord record = new SampleRecord(rowid, rand);\n        /*\n          Uncomment this to duplicate the export data in memory.\n          Useful for debugging export data correctness, but not useful\n          for not running out of memory....\n\n        voltQueueSQL(\n                      insert\n                    , getVoltPrivateRealTransactionIdDontUseMe()\n                    , rowid\n                    , record.rowid_group\n                    , record.type_null_tinyint\n                    , record.type_not_null_tinyint\n                    , record.type_null_smallint\n                    , record.type_not_null_smallint\n                    , record.type_null_integer\n                    , record.type_not_null_integer\n                    , record.type_null_bigint\n                    , record.type_not_null_bigint\n                    , record.type_null_timestamp\n                    , record.type_not_null_timestamp\n                    , record.type_null_float\n                    , record.type_not_null_float\n                    , record.type_null_decimal\n                    , record.type_not_null_decimal\n                    , record.type_null_varchar25\n                    , record.type_not_null_varchar25\n                    , record.type_null_varchar128\n                    , record.type_not_null_varchar128\n                    , record.type_null_varchar1024\n                    , record.type_not_null_varchar1024\n                    );\n        */\n        voltQueueSQL(\n                     export\n                     , getVoltPrivateRealTransactionIdDontUseMe()\n                     , rowid\n                     , record.rowid_group\n                     , record.type_null_tinyint\n                     , record.type_not_null_tinyint\n                     , record.type_null_smallint\n                     , record.type_not_null_smallint\n                     , record.type_null_integer\n                     , record.type_not_null_integer\n                     , record.type_null_bigint\n                     , record.type_not_null_bigint\n                     , record.type_null_timestamp\n                     , record.type_not_null_timestamp\n                     , record.type_null_float\n                     , record.type_not_null_float\n                     , record.type_null_decimal\n                     , record.type_not_null_decimal\n                     , record.type_null_varchar25\n                     , record.type_not_null_varchar25\n                     , record.type_null_varchar128\n                     , record.type_not_null_varchar128\n                     , record.type_null_varchar1024\n                     , record.type_not_null_varchar1024\n        );\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return getVoltPrivateRealTransactionIdDontUseMe();\n    }","id":76175,"modified_method":"public long run(long rowid, int reversed)\n    {\n        @SuppressWarnings(\"deprecation\")\n        long txid = getVoltPrivateRealTransactionIdDontUseMe();\n\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = new Random(txid);\n\n        // Insert a new record\n        SampleRecord record = new SampleRecord(rowid, rand);\n        /*\n          Uncomment this to duplicate the export data in memory.\n          Useful for debugging export data correctness, but not useful\n          for not running out of memory....\n\n        voltQueueSQL(\n                      insert\n                    , getVoltPrivateRealTransactionIdDontUseMe()\n                    , rowid\n                    , record.rowid_group\n                    , record.type_null_tinyint\n                    , record.type_not_null_tinyint\n                    , record.type_null_smallint\n                    , record.type_not_null_smallint\n                    , record.type_null_integer\n                    , record.type_not_null_integer\n                    , record.type_null_bigint\n                    , record.type_not_null_bigint\n                    , record.type_null_timestamp\n                    , record.type_not_null_timestamp\n                    , record.type_null_float\n                    , record.type_not_null_float\n                    , record.type_null_decimal\n                    , record.type_not_null_decimal\n                    , record.type_null_varchar25\n                    , record.type_not_null_varchar25\n                    , record.type_null_varchar128\n                    , record.type_not_null_varchar128\n                    , record.type_null_varchar1024\n                    , record.type_not_null_varchar1024\n                    );\n        */\n\n        voltQueueSQL(\n                     export\n                     , txid\n                     , rowid\n                     , record.rowid_group\n                     , record.type_null_tinyint\n                     , record.type_not_null_tinyint\n                     , record.type_null_smallint\n                     , record.type_not_null_smallint\n                     , record.type_null_integer\n                     , record.type_not_null_integer\n                     , record.type_null_bigint\n                     , record.type_not_null_bigint\n                     , record.type_null_timestamp\n                     , record.type_not_null_timestamp\n                     , record.type_null_float\n                     , record.type_not_null_float\n                     , record.type_null_decimal\n                     , record.type_not_null_decimal\n                     , record.type_null_varchar25\n                     , record.type_not_null_varchar25\n                     , record.type_null_varchar128\n                     , record.type_not_null_varchar128\n                     , record.type_null_varchar1024\n                     , record.type_not_null_varchar1024\n        );\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return txid;\n    }","commit_id":"145b18610c05a2ea2cfa51b83b259e4222d4cc6e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public long run(long rowid, int reversed)\n    {\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = getSeededRandomNumberGenerator();\n\n        // Insert a new record\n        SampleRecord record = new SampleRecord(rowid, rand);\n        /*\n          Uncomment this to duplicate the export data in memory.\n          Useful for debugging export data correctness, but not useful\n          for not running out of memory....\n\n        voltQueueSQL(\n                      insert\n                    , getVoltPrivateRealTransactionIdDontUseMe()\n                    , rowid\n                    , record.rowid_group\n                    , record.type_null_tinyint\n                    , record.type_not_null_tinyint\n                    , record.type_null_smallint\n                    , record.type_not_null_smallint\n                    , record.type_null_integer\n                    , record.type_not_null_integer\n                    , record.type_null_bigint\n                    , record.type_not_null_bigint\n                    , record.type_null_timestamp\n                    , record.type_not_null_timestamp\n                    , record.type_null_float\n                    , record.type_not_null_float\n                    , record.type_null_decimal\n                    , record.type_not_null_decimal\n                    , record.type_null_varchar25\n                    , record.type_not_null_varchar25\n                    , record.type_null_varchar128\n                    , record.type_not_null_varchar128\n                    , record.type_null_varchar1024\n                    , record.type_not_null_varchar1024\n                    );\n        */\n        voltQueueSQL(\n                     export\n                     , getVoltPrivateRealTransactionIdDontUseMe()\n                     , rowid\n                     , record.rowid_group\n                     , record.type_null_tinyint\n                     , record.type_not_null_tinyint\n                     , record.type_null_smallint\n                     , record.type_not_null_smallint\n                     , record.type_null_integer\n                     , record.type_not_null_integer\n                     , record.type_null_bigint\n                     , record.type_not_null_bigint\n                     , record.type_null_timestamp\n                     , record.type_not_null_timestamp\n                     , record.type_null_float\n                     , record.type_not_null_float\n                     , record.type_null_decimal\n                     , record.type_not_null_decimal\n                     , record.type_null_varchar25\n                     , record.type_not_null_varchar25\n                     , record.type_null_varchar128\n                     , record.type_not_null_varchar128\n                     , record.type_null_varchar1024\n                     , record.type_not_null_varchar1024\n        );\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return getVoltPrivateRealTransactionIdDontUseMe();\n    }","id":76176,"modified_method":"public long run(long rowid, int reversed)\n    {\n        @SuppressWarnings(\"deprecation\")\n        long txid = getVoltPrivateRealTransactionIdDontUseMe();\n\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = new Random(txid);\n\n        // Insert a new record\n        SampleRecord record = new SampleRecord(rowid, rand);\n        /*\n          Uncomment this to duplicate the export data in memory.\n          Useful for debugging export data correctness, but not useful\n          for not running out of memory....\n\n        voltQueueSQL(\n                      insert\n                    , txid\n                    , rowid\n                    , record.rowid_group\n                    , record.type_null_tinyint\n                    , record.type_not_null_tinyint\n                    , record.type_null_smallint\n                    , record.type_not_null_smallint\n                    , record.type_null_integer\n                    , record.type_not_null_integer\n                    , record.type_null_bigint\n                    , record.type_not_null_bigint\n                    , record.type_null_timestamp\n                    , record.type_not_null_timestamp\n                    , record.type_null_float\n                    , record.type_not_null_float\n                    , record.type_null_decimal\n                    , record.type_not_null_decimal\n                    , record.type_null_varchar25\n                    , record.type_not_null_varchar25\n                    , record.type_null_varchar128\n                    , record.type_not_null_varchar128\n                    , record.type_null_varchar1024\n                    , record.type_not_null_varchar1024\n                    );\n        */\n        voltQueueSQL(\n                     export\n                     , txid\n                     , rowid\n                     , record.rowid_group\n                     , record.type_null_tinyint\n                     , record.type_not_null_tinyint\n                     , record.type_null_smallint\n                     , record.type_not_null_smallint\n                     , record.type_null_integer\n                     , record.type_not_null_integer\n                     , record.type_null_bigint\n                     , record.type_not_null_bigint\n                     , record.type_null_timestamp\n                     , record.type_not_null_timestamp\n                     , record.type_null_float\n                     , record.type_not_null_float\n                     , record.type_null_decimal\n                     , record.type_not_null_decimal\n                     , record.type_null_varchar25\n                     , record.type_not_null_varchar25\n                     , record.type_null_varchar128\n                     , record.type_not_null_varchar128\n                     , record.type_null_varchar1024\n                     , record.type_not_null_varchar1024\n        );\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return txid;\n    }","commit_id":"145b18610c05a2ea2cfa51b83b259e4222d4cc6e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(long rowid, long ignore)\n    {\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = getSeededRandomNumberGenerator();\n\n        // Check if the record exists first\n        voltQueueSQL(check, rowid);\n\n        // If the record exist perform an update or delete\n        if(voltExecuteSQL()[0].getRowCount() > 0)\n        {\n            // Randomly decide whether to delete (or update) the record\n            if (rand.nextBoolean())\n                voltQueueSQL(delete, rowid);\n            else\n            {\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              update\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            , rowid\n                            );\n            }\n        }\n        else\n        {\n                // Insert a new record\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              insert\n                            , rowid\n                            , record.rowid_group\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            );\n        }\n\n        // Execute last SQL batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return null;\n    }","id":76177,"modified_method":"public VoltTable[] run(long rowid, long ignore)\n    {\n        @SuppressWarnings(\"deprecation\")\n        long txid = getVoltPrivateRealTransactionIdDontUseMe();\n\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = new Random(txid);\n\n        // Check if the record exists first\n        voltQueueSQL(check, rowid);\n\n        // If the record exist perform an update or delete\n        if(voltExecuteSQL()[0].getRowCount() > 0)\n        {\n            // Randomly decide whether to delete (or update) the record\n            if (rand.nextBoolean())\n                voltQueueSQL(delete, rowid);\n            else\n            {\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              update\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            , rowid\n                            );\n            }\n        }\n        else\n        {\n                // Insert a new record\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              insert\n                            , rowid\n                            , record.rowid_group\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            );\n        }\n\n        // Execute last SQL batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return null;\n    }","commit_id":"145b18610c05a2ea2cfa51b83b259e4222d4cc6e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(long rowid, long ignore)\n    {\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = getSeededRandomNumberGenerator();\n\n        // Check if the record exists first\n        voltQueueSQL(check, rowid);\n\n        // Grab resultset for possibly existing record\n        VoltTable item = voltExecuteSQL()[0];\n\n        // If the record exist perform an update or delete\n        if(item.getRowCount() > 0)\n        {\n            // Randomly decide whether to delete (or update) the record\n            if (rand.nextBoolean())\n            {\n                voltQueueSQL(delete, rowid);\n                // Export deletion\n                VoltTableRow row = item.fetchRow(0);\n                voltQueueSQL(\n                              export\n                            , getVoltPrivateRealTransactionIdDontUseMe()\n                            , rowid\n                            , row.get( 1, VoltType.TINYINT)\n                            , row.get( 2, VoltType.TINYINT)\n                            , row.get( 3, VoltType.TINYINT)\n                            , row.get( 4, VoltType.SMALLINT)\n                            , row.get( 5, VoltType.SMALLINT)\n                            , row.get( 6, VoltType.INTEGER)\n                            , row.get( 7, VoltType.INTEGER)\n                            , row.get( 8, VoltType.BIGINT)\n                            , row.get( 9, VoltType.BIGINT)\n                            , row.get(10, VoltType.TIMESTAMP)\n                            , row.get(11, VoltType.TIMESTAMP)\n                            , row.get(12, VoltType.FLOAT)\n                            , row.get(13, VoltType.FLOAT)\n                            , row.get(14, VoltType.DECIMAL)\n                            , row.get(15, VoltType.DECIMAL)\n                            , row.get(16, VoltType.STRING)\n                            , row.get(17, VoltType.STRING)\n                            , row.get(18, VoltType.STRING)\n                            , row.get(19, VoltType.STRING)\n                            , row.get(20, VoltType.STRING)\n                            , row.get(21, VoltType.STRING)\n                            );\n            }\n            else\n            {\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              update\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            , rowid\n                            );\n            }\n        }\n        else\n        {\n                // Insert a new record\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              insert\n                            , rowid\n                            , record.rowid_group\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            );\n        }\n\n        // Execute last SQL batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return null;\n    }","id":76178,"modified_method":"public VoltTable[] run(long rowid, long ignore)\n    {\n        @SuppressWarnings(\"deprecation\")\n        long txid = getVoltPrivateRealTransactionIdDontUseMe();\n\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = new Random(txid);\n\n        // Check if the record exists first\n        voltQueueSQL(check, rowid);\n\n        // Grab resultset for possibly existing record\n        VoltTable item = voltExecuteSQL()[0];\n\n        // If the record exist perform an update or delete\n        if(item.getRowCount() > 0)\n        {\n            // Randomly decide whether to delete (or update) the record\n            if (rand.nextBoolean())\n            {\n                voltQueueSQL(delete, rowid);\n                // Export deletion\n                VoltTableRow row = item.fetchRow(0);\n                voltQueueSQL(\n                              export\n                            , txid\n                            , rowid\n                            , row.get( 1, VoltType.TINYINT)\n                            , row.get( 2, VoltType.TINYINT)\n                            , row.get( 3, VoltType.TINYINT)\n                            , row.get( 4, VoltType.SMALLINT)\n                            , row.get( 5, VoltType.SMALLINT)\n                            , row.get( 6, VoltType.INTEGER)\n                            , row.get( 7, VoltType.INTEGER)\n                            , row.get( 8, VoltType.BIGINT)\n                            , row.get( 9, VoltType.BIGINT)\n                            , row.get(10, VoltType.TIMESTAMP)\n                            , row.get(11, VoltType.TIMESTAMP)\n                            , row.get(12, VoltType.FLOAT)\n                            , row.get(13, VoltType.FLOAT)\n                            , row.get(14, VoltType.DECIMAL)\n                            , row.get(15, VoltType.DECIMAL)\n                            , row.get(16, VoltType.STRING)\n                            , row.get(17, VoltType.STRING)\n                            , row.get(18, VoltType.STRING)\n                            , row.get(19, VoltType.STRING)\n                            , row.get(20, VoltType.STRING)\n                            , row.get(21, VoltType.STRING)\n                            );\n            }\n            else\n            {\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              update\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            , rowid\n                            );\n            }\n        }\n        else\n        {\n                // Insert a new record\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              insert\n                            , rowid\n                            , record.rowid_group\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            );\n        }\n\n        // Execute last SQL batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return null;\n    }","commit_id":"145b18610c05a2ea2cfa51b83b259e4222d4cc6e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(long rowid, long ignore)\n    {\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = getSeededRandomNumberGenerator();\n\n        // Check if the record exists first\n        voltQueueSQL(check, rowid);\n\n        // If the record exist perform an update or delete\n        if(voltExecuteSQL()[0].getRowCount() > 0)\n        {\n            // Randomly decide whether to delete (or update) the record\n            if (rand.nextBoolean())\n                voltQueueSQL(delete, rowid);\n            else\n            {\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              update\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            , rowid\n                            );\n            }\n        }\n        else\n        {\n                // Insert a new record\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              insert\n                            , rowid\n                            , record.rowid_group\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            );\n        }\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return null;\n    }","id":76179,"modified_method":"public VoltTable[] run(long rowid, long ignore)\n    {\n        @SuppressWarnings(\"deprecation\")\n        long txid = getVoltPrivateRealTransactionIdDontUseMe();\n\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = new Random(txid);\n\n        // Check if the record exists first\n        voltQueueSQL(check, rowid);\n\n        // If the record exist perform an update or delete\n        if(voltExecuteSQL()[0].getRowCount() > 0)\n        {\n            // Randomly decide whether to delete (or update) the record\n            if (rand.nextBoolean())\n                voltQueueSQL(delete, rowid);\n            else\n            {\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              update\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            , rowid\n                            );\n            }\n        }\n        else\n        {\n                // Insert a new record\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              insert\n                            , rowid\n                            , record.rowid_group\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            );\n        }\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return null;\n    }","commit_id":"145b18610c05a2ea2cfa51b83b259e4222d4cc6e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(long rowid, long ignore)\n    {\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = getSeededRandomNumberGenerator();\n\n        // Check if the record exists first\n        voltQueueSQL(check, rowid);\n\n        // Grab resultset for possibly existing record\n        VoltTable item = voltExecuteSQL()[0];\n\n        // If the record exist perform an update or delete\n        if(item.getRowCount() > 0)\n        {\n            // Randomly decide whether to delete (or update) the record\n            if (rand.nextBoolean())\n            {\n                voltQueueSQL(delete, rowid);\n                // Export deletion\n                VoltTableRow row = item.fetchRow(0);\n                voltQueueSQL(\n                              export\n                            , getVoltPrivateRealTransactionIdDontUseMe()\n                            , rowid\n                            , row.get( 1, VoltType.TINYINT)\n                            , row.get( 2, VoltType.TINYINT)\n                            , row.get( 3, VoltType.TINYINT)\n                            , row.get( 4, VoltType.SMALLINT)\n                            , row.get( 5, VoltType.SMALLINT)\n                            , row.get( 6, VoltType.INTEGER)\n                            , row.get( 7, VoltType.INTEGER)\n                            , row.get( 8, VoltType.BIGINT)\n                            , row.get( 9, VoltType.BIGINT)\n                            , row.get(10, VoltType.TIMESTAMP)\n                            , row.get(11, VoltType.TIMESTAMP)\n                            , row.get(12, VoltType.FLOAT)\n                            , row.get(13, VoltType.FLOAT)\n                            , row.get(14, VoltType.DECIMAL)\n                            , row.get(15, VoltType.DECIMAL)\n                            , row.get(16, VoltType.STRING)\n                            , row.get(17, VoltType.STRING)\n                            , row.get(18, VoltType.STRING)\n                            , row.get(19, VoltType.STRING)\n                            , row.get(20, VoltType.STRING)\n                            , row.get(21, VoltType.STRING)\n                            );\n            }\n            else\n            {\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              update\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            , rowid\n                            );\n            }\n        }\n        else\n        {\n                // Insert a new record\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              insert\n                            , rowid\n                            , record.rowid_group\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            );\n        }\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return null;\n    }","id":76180,"modified_method":"public VoltTable[] run(long rowid, long ignore)\n    {\n        @SuppressWarnings(\"deprecation\")\n        long txid = getVoltPrivateRealTransactionIdDontUseMe();\n\n        // Critical for proper determinism: get a cluster-wide consistent Random instance\n        Random rand = new Random(txid);\n\n        // Check if the record exists first\n        voltQueueSQL(check, rowid);\n\n        // Grab resultset for possibly existing record\n        VoltTable item = voltExecuteSQL()[0];\n\n        // If the record exist perform an update or delete\n        if(item.getRowCount() > 0)\n        {\n            // Randomly decide whether to delete (or update) the record\n            if (rand.nextBoolean())\n            {\n                voltQueueSQL(delete, rowid);\n                // Export deletion\n                VoltTableRow row = item.fetchRow(0);\n                voltQueueSQL(\n                              export\n                            , txid\n                            , rowid\n                            , row.get( 1, VoltType.TINYINT)\n                            , row.get( 2, VoltType.TINYINT)\n                            , row.get( 3, VoltType.TINYINT)\n                            , row.get( 4, VoltType.SMALLINT)\n                            , row.get( 5, VoltType.SMALLINT)\n                            , row.get( 6, VoltType.INTEGER)\n                            , row.get( 7, VoltType.INTEGER)\n                            , row.get( 8, VoltType.BIGINT)\n                            , row.get( 9, VoltType.BIGINT)\n                            , row.get(10, VoltType.TIMESTAMP)\n                            , row.get(11, VoltType.TIMESTAMP)\n                            , row.get(12, VoltType.FLOAT)\n                            , row.get(13, VoltType.FLOAT)\n                            , row.get(14, VoltType.DECIMAL)\n                            , row.get(15, VoltType.DECIMAL)\n                            , row.get(16, VoltType.STRING)\n                            , row.get(17, VoltType.STRING)\n                            , row.get(18, VoltType.STRING)\n                            , row.get(19, VoltType.STRING)\n                            , row.get(20, VoltType.STRING)\n                            , row.get(21, VoltType.STRING)\n                            );\n            }\n            else\n            {\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              update\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            , rowid\n                            );\n            }\n        }\n        else\n        {\n                // Insert a new record\n                SampleRecord record = new SampleRecord(rowid, rand);\n                voltQueueSQL(\n                              insert\n                            , rowid\n                            , record.rowid_group\n                            , record.type_null_tinyint\n                            , record.type_not_null_tinyint\n                            , record.type_null_smallint\n                            , record.type_not_null_smallint\n                            , record.type_null_integer\n                            , record.type_not_null_integer\n                            , record.type_null_bigint\n                            , record.type_not_null_bigint\n                            , record.type_null_timestamp\n                            , record.type_not_null_timestamp\n                            , record.type_null_float\n                            , record.type_not_null_float\n                            , record.type_null_decimal\n                            , record.type_not_null_decimal\n                            , record.type_null_varchar25\n                            , record.type_not_null_varchar25\n                            , record.type_null_varchar128\n                            , record.type_not_null_varchar128\n                            , record.type_null_varchar1024\n                            , record.type_not_null_varchar1024\n                            );\n        }\n\n        // Execute last statement batch\n        voltExecuteSQL(true);\n\n        // Retun to caller\n        return null;\n    }","commit_id":"145b18610c05a2ea2cfa51b83b259e4222d4cc6e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Path to JSON file is mandatory\");\n\n    String jsonFileName = (String) params.getArgList().get(0);\n    LocationSpec spec = json.readValue(new File(jsonFileName), LocationSpec.class);\n\n    ClientResponse response = client.post(uriFor(\"/v1/locations\"),\n        MediaType.APPLICATION_JSON_TYPE, spec, ClientResponse.class);\n\n    System.out.println(\"Ok: \" + response.getLocation());\n  }","id":76181,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Path to JSON file is mandatory\");\n\n    String jsonFileName = (String) params.getArgList().get(0);\n    LocationSpec spec = json.readValue(new File(jsonFileName), LocationSpec.class);\n\n    ClientResponse response = client.resource(uriFor(\"/v1/locations\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, spec);\n\n    out.println(\"Ok: \" + response.getLocation());\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected URI uriFor(String resource) {\n    return URI.create(endpoint + resource);\n  }","id":76182,"modified_method":"protected URI uriFor(String resource) {\n    return URI.create(getEndpoint() + resource);\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private String getEndpointFromCommandLineOrEnv(CommandLine params) {\n    String endpointFromEnv = System.getenv(\"BROOKLYN_ENDPOINT\");\n\n    // the command line has precedence over the environment\n    return params.getOptionValue(\"endpoint\",\n        (endpointFromEnv != null) ? endpointFromEnv : \"http://localhost:8080\");\n\n  }","id":76183,"modified_method":"private void setEndpointFromCommandLineOrEnvironment(CommandLine params) {\n    String endpointFromEnv = System.getenv(\"BROOKLYN_ENDPOINT\");\n\n    // the command line has precedence over the environment\n    this.endpoint = params.getOptionValue(\"endpoint\",\n        (endpointFromEnv != null) ? endpointFromEnv : \"http://localhost:8080\");\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(AbstractService<?> service, CommandLine params) throws Exception {\n    JerseyClientConfiguration config = new JerseyClientConfiguration();\n    config.setTimeout(Duration.seconds(2));\n\n    endpoint = getEndpointFromCommandLineOrEnv(params);\n\n    try {\n      run(service.getJson(), buildJerseyClient(service, config), params);\n\n    } catch (Exception e) {\n      System.err.println(e.getMessage());\n      System.exit(-1);\n    }\n  }","id":76184,"modified_method":"@Override\n  protected void run(AbstractService<?> service, CommandLine params) throws Exception {\n    try {\n      buildJerseyClientAndRun(System.out, System.err, service.getJson(), params);\n\n    } catch (Exception e) {\n      System.exit(-1);\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected JerseyClient buildJerseyClient(AbstractService<?> service, JerseyClientConfiguration configuration) {\n\n    final HttpClient client = new HttpClientFactory(configuration).build();\n    final ApacheHttpClient4Handler handler = new ApacheHttpClient4Handler(client, null, true);\n\n    final ApacheHttpClient4Config config = new DefaultApacheHttpClient4Config();\n    config.getSingletons().add(new JacksonMessageBodyProvider(service.getJson()));\n\n    final JerseyClient jerseyClient = new JerseyClient(handler, config);\n    jerseyClient.setExecutorService(buildThreadPool(configuration));\n\n    if (configuration.isGzipEnabled()) {\n      jerseyClient.addFilter(new GZIPContentEncodingFilter());\n    }\n\n    return jerseyClient;\n  }","id":76185,"modified_method":"private JerseyClient buildJerseyClient(Json json, JerseyClientConfiguration configuration) {\n\n    final HttpClient client = new HttpClientFactory(configuration).build();\n    final ApacheHttpClient4Handler handler = new ApacheHttpClient4Handler(client, null, true);\n\n    final ApacheHttpClient4Config config = new DefaultApacheHttpClient4Config();\n    config.getSingletons().add(new JacksonMessageBodyProvider(json));\n\n    final JerseyClient jerseyClient = new JerseyClient(handler, config);\n    jerseyClient.setExecutorService(buildThreadPool(configuration));\n\n    if (configuration.isGzipEnabled()) {\n      jerseyClient.addFilter(new GZIPContentEncodingFilter());\n    }\n\n    return jerseyClient;\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected URI expandIfRelative(URI uri) {\n    if (uri.getHost() != null) {\n      return uri;\n    }\n    return URI.create(endpoint + uri.getPath());\n  }","id":76186,"modified_method":"protected URI expandIfRelative(URI uri) {\n    if (uri.getHost() != null) {\n      return uri;\n    }\n    return URI.create(getEndpoint() + uri.getPath());\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n   * Override this method to implement command functionality\n   */\n  protected abstract void run(Json json, JerseyClient client, CommandLine params) throws Exception;","id":76187,"modified_method":"/**\n   * Override this method to implement command functionality\n   */\n  protected abstract void run(PrintStream out, PrintStream err, Json json,\n                              Client client, CommandLine params) throws Exception;","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Application name is mandatory\");\n\n    String name = (String) params.getArgList().get(0);\n    ClientResponse response = client.delete(uriFor(\"/v1/applications/\" + name),\n        ClientResponse.class);\n\n    System.out.println(\"Ok, status: \" + response.getStatus());\n  }","id":76188,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Application name is mandatory\");\n\n    String name = (String) params.getArgList().get(0);\n    ClientResponse response = client.resource(uriFor(\"/v1/applications/\" + name))\n        .delete(ClientResponse.class);\n\n    out.println(\"Ok, status: \" + response.getStatus());\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Effector URI is mandatory\");\n\n    URI effectorUri = uriFor((String) params.getArgList().get(0));\n    ClientResponse response = client.resource(effectorUri)\n        .type(MediaType.APPLICATION_JSON_TYPE)\n        .entity(ImmutableMap.<String, String>of())\n        .post(ClientResponse.class);\n\n    checkState(response.getStatus() == Response.Status.ACCEPTED.getStatusCode(),\n        \"Got unexpected response: \" + response.toString());\n  }","id":76189,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Effector URI is mandatory\");\n\n    URI effectorUri = uriFor((String) params.getArgList().get(0));\n    ClientResponse response = client.resource(effectorUri)\n        .type(MediaType.APPLICATION_JSON_TYPE)\n        .entity(ImmutableMap.<String, String>of())\n        .post(ClientResponse.class);\n\n    checkState(response.getStatus() == Response.Status.ACCEPTED.getStatusCode(),\n        \"Got unexpected response: \" + response.toString());\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    List<Application> applications = client.resource(uriFor(\"/v1/applications\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<Application>>() {\n        });\n\n    String tableFormat = \"%20s %10s\\n\";\n    System.out.printf(tableFormat, \"Application\", \"Status\");\n\n    for (Application application : applications) {\n      System.out.printf(tableFormat, application.getSpec().getName(), application.getStatus());\n    }\n  }","id":76190,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    List<Application> applications = client.resource(uriFor(\"/v1/applications\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<Application>>() {\n        });\n\n    String tableFormat = \"%20s %10s\\n\";\n    out.printf(tableFormat, \"Application\", \"Status\");\n\n    for (Application application : applications) {\n      out.printf(tableFormat, application.getSpec().getName(), application.getStatus());\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    List<String> entities = client.resource(uriFor(\"/v1/catalog/entities\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<String>>() {\n        });\n    for (String entity : entities) {\n      System.out.println(entity);\n    }\n  }","id":76191,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params\n  ) throws Exception {\n    List<String> entities = client.resource(uriFor(\"/v1/catalog/entities\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<String>>() {\n        });\n    for (String entity : entities) {\n      out.println(entity);\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    List<String> policies = client.resource(uriFor(\"/v1/catalog/policies\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<String>>() {\n        });\n    for (String policy : policies) {\n      System.out.println(policy);\n    }\n  }","id":76192,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    List<String> policies = client.resource(uriFor(\"/v1/catalog/policies\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<String>>() {\n        });\n    for (String policy : policies) {\n      out.println(policy);\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"The type of the entity is mandatory\");\n\n    String type = (String) params.getArgList().get(0);\n    List<String> keys = client.resource(uriFor(\"/v1/catalog/entities/\" + type))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<String>>() {\n        });\n\n    for (String key : keys) {\n      System.out.println(key);\n    }\n  }","id":76193,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"The type of the entity is mandatory\");\n\n    String type = (String) params.getArgList().get(0);\n    List<String> keys = client.resource(uriFor(\"/v1/catalog/entities/\" + type))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<String>>() {\n        });\n\n    for (String key : keys) {\n      out.println(key);\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Application name is mandatory\");\n\n    String name = (String) params.getArgList().get(0);\n    Application application = client.resource(uriFor(\"/v1/applications/\" + name))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(Application.class);\n\n    queryAllEntities(client, application.getLinks().get(\"entities\"));\n  }","id":76194,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Application name is mandatory\");\n\n    String name = (String) params.getArgList().get(0);\n    Application application = client.resource(uriFor(\"/v1/applications/\" + name))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(Application.class);\n\n    queryAllEntities(out, client, application.getLinks().get(\"entities\"));\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void queryListOfEffectors(JerseyClient client, URI effectorsUri) {\n    Set<EffectorSummary> effectors = client.resource(expandIfRelative(effectorsUri))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<Set<EffectorSummary>>() {\n        });\n    for (EffectorSummary summary : effectors) {\n      System.out.println(\"\\t\" + summary.getReturnType() + \" \" +\n          summary.getName() + \" \" + summary.getParameters());\n      System.out.println(\"\\t\" + summary.getLinks().get(\"self\") + \"\\n\");\n    }\n  }","id":76195,"modified_method":"private void queryListOfEffectors(PrintStream out, Client client, URI effectorsUri) {\n    Set<EffectorSummary> effectors = client.resource(expandIfRelative(effectorsUri))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<Set<EffectorSummary>>() {\n        });\n    for (EffectorSummary summary : effectors) {\n      out.println(\"\\t\" + summary.getReturnType() + \" \" +\n          summary.getName() + \" \" + summary.getParameters());\n      out.println(\"\\t\" + summary.getLinks().get(\"self\") + \"\\n\");\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void queryAllEntities(JerseyClient client, URI resource) {\n    Set<EntitySummary> entities = client.resource(expandIfRelative(resource))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<Set<EntitySummary>>() {\n        });\n\n    for (EntitySummary summary : entities) {\n      System.out.println(summary.getLinks().get(\"self\") + \" #\" + summary.getType());\n      queryListOfEffectors(client, summary.getLinks().get(\"effectors\"));\n      queryAllEntities(client, summary.getLinks().get(\"children\"));\n    }\n  }","id":76196,"modified_method":"private void queryAllEntities(PrintStream out, Client client, URI resource) {\n    Set<EntitySummary> entities = client.resource(expandIfRelative(resource))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<Set<EntitySummary>>() {\n        });\n\n    for (EntitySummary summary : entities) {\n      out.println(summary.getLinks().get(\"self\") + \" #\" + summary.getType());\n      queryListOfEffectors(out, client, summary.getLinks().get(\"effectors\"));\n      queryAllEntities(out, client, summary.getLinks().get(\"children\"));\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    List<LocationSummary> locations = client.resource(uriFor(\"/v1/locations\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<LocationSummary>>() {\n        });\n    for (LocationSummary summary : locations) {\n      System.out.println(summary.toString());\n    }\n  }","id":76197,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    List<LocationSummary> locations = client.resource(uriFor(\"/v1/locations\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<List<LocationSummary>>() {\n        });\n    for (LocationSummary summary : locations) {\n      out.println(summary.toString());\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Path to Groovy file is mandatory.\");\n\n    String scriptFileName = (String) params.getArgList().get(0);\n    String groovyScript = Joiner.on(\"\\n\").join(Files.readLines(new File(scriptFileName),\n        Charset.forName(\"utf-8\")));\n\n    ClientResponse response = client.resource(uriFor(\"/v1/catalog\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, groovyScript);\n\n    System.out.println(\"Ok, create: \" + response.getLocation());\n  }","id":76198,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Path to Groovy file is mandatory.\");\n\n    String scriptFileName = (String) params.getArgList().get(0);\n    String groovyScript = Joiner.on(\"\\n\").join(Files.readLines(new File(scriptFileName),\n        Charset.forName(\"utf-8\")));\n\n    ClientResponse response = client.resource(uriFor(\"/v1/catalog\"))\n        .type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, groovyScript);\n\n    out.println(\"Ok, create: \" + response.getLocation());\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void queryAllSensors(JerseyClient client, URI sensorsUri) {\n    Set<SensorSummary> sensors = client.resource(expandIfRelative(sensorsUri))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<Set<SensorSummary>>() {\n        });\n    for (SensorSummary summary : sensors) {\n      String value = client.resource(expandIfRelative(summary.getLinks().get(\"self\")))\n          .type(MediaType.APPLICATION_JSON_TYPE).get(String.class);\n      System.out.println(\"\\t\" + summary.getName() + \" = \" + value);\n    }\n    System.out.println();\n  }","id":76199,"modified_method":"private void queryAllSensors(PrintStream out, Client client, URI sensorsUri) {\n    Set<SensorSummary> sensors = client.resource(expandIfRelative(sensorsUri))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<Set<SensorSummary>>() {\n        });\n    for (SensorSummary summary : sensors) {\n      String value = client.resource(expandIfRelative(summary.getLinks().get(\"self\")))\n          .type(MediaType.APPLICATION_JSON_TYPE).get(String.class);\n      out.println(\"\\t\" + summary.getName() + \" = \" + value);\n    }\n    out.println();\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void queryAllEntities(JerseyClient client, URI resource) {\n    Set<EntitySummary> entities = client.resource(expandIfRelative(resource))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<Set<EntitySummary>>() {\n        });\n\n    for (EntitySummary summary : entities) {\n      System.out.println(summary.getLinks().get(\"self\") + \" #\" + summary.getType());\n      queryAllSensors(client, summary.getLinks().get(\"sensors\"));\n      queryAllEntities(client, summary.getLinks().get(\"children\"));\n    }\n  }","id":76200,"modified_method":"private void queryAllEntities(PrintStream out, Client client, URI resource) {\n    Set<EntitySummary> entities = client.resource(expandIfRelative(resource))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(new GenericType<Set<EntitySummary>>() {\n        });\n\n    for (EntitySummary summary : entities) {\n      out.println(summary.getLinks().get(\"self\") + \" #\" + summary.getType());\n      queryAllSensors(out, client, summary.getLinks().get(\"sensors\"));\n      queryAllEntities(out, client, summary.getLinks().get(\"children\"));\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Application name is mandatory\");\n\n    String name = (String) params.getArgList().get(0);\n    Application application = client.resource(uriFor(\"/v1/applications/\" + name))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(Application.class);\n\n    queryAllEntities(client, application.getLinks().get(\"entities\"));\n  }","id":76201,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Application name is mandatory\");\n\n    String name = (String) params.getArgList().get(0);\n    Application application = client.resource(uriFor(\"/v1/applications/\" + name))\n        .type(MediaType.APPLICATION_JSON_TYPE).get(Application.class);\n\n    queryAllEntities(out, client, application.getLinks().get(\"entities\"));\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void run(Json json, JerseyClient client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Path to JSON file is mandatory\");\n\n    String jsonFileName = (String) params.getArgList().get(0);\n    ApplicationSpec spec = json.readValue(new File(jsonFileName), ApplicationSpec.class);\n\n    if (params.hasOption(\"name\")) {\n      spec = ApplicationSpec.builder().from(spec).name(params.getOptionValue(\"name\")).build();\n    }\n\n    ClientResponse response = client.post(uriFor(\"/v1/applications\"),\n        MediaType.APPLICATION_JSON_TYPE, spec, ClientResponse.class);\n\n    if (response.getStatus() != Response.Status.CREATED.getStatusCode()) {\n      ApiError error = response.getEntity(ApiError.class);\n      throw new RuntimeException(error.getMessage());\n    }\n\n    System.out.println(\"Starting at \" + response.getLocation());\n\n    Status status;\n    do {\n      System.out.print(\".\");\n      System.out.flush();\n      Thread.sleep(1000);\n\n      status = getApplicationStatus(client, response.getLocation());\n    } while (status != Status.RUNNING && status != Status.ERROR);\n\n    if (status == Status.RUNNING) {\n      System.out.println(\"Done.\");\n    } else {\n      System.out.println(\"Error.\");\n    }\n  }","id":76202,"modified_method":"@Override\n  protected void run(PrintStream out, PrintStream err, Json json,\n                     Client client, CommandLine params) throws Exception {\n    checkArgument(params.getArgList().size() >= 1, \"Path to JSON file is mandatory\");\n\n    String jsonFileName = (String) params.getArgList().get(0);\n    ApplicationSpec spec = json.readValue(new File(jsonFileName), ApplicationSpec.class);\n\n    if (params.hasOption(\"name\")) {\n      spec = ApplicationSpec.builder().from(spec).name(params.getOptionValue(\"name\")).build();\n    }\n\n    ClientResponse response = client.resource(uriFor(\"/v1/applications\"))\n        .type(MediaType.APPLICATION_JSON).post(ClientResponse.class, spec);\n\n    if (response.getStatus() != Response.Status.CREATED.getStatusCode()) {\n      ApiError error = response.getEntity(ApiError.class);\n      throw new RuntimeException(error.getMessage());\n    }\n\n    out.println(\"Starting at \" + response.getLocation());\n\n    Status status;\n    do {\n      out.print(\".\");\n      out.flush();\n      Thread.sleep(1000);\n\n      status = getApplicationStatus(client, response.getLocation());\n    } while (status != Status.RUNNING && status != Status.ERROR);\n\n    if (status == Status.RUNNING) {\n      out.println(\"Done.\");\n    } else {\n      err.println(\"Error.\");\n    }\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private Status getApplicationStatus(JerseyClient client, URI uri) {\n    Application application = client.get(uri, MediaType.APPLICATION_JSON_TYPE, Application.class);\n    return application.getStatus();\n  }","id":76203,"modified_method":"private Status getApplicationStatus(Client client, URI uri) {\n    Application application = client.resource(uri)\n        .type(MediaType.APPLICATION_JSON_TYPE).get(Application.class);\n    return application.getStatus();\n  }","commit_id":"e670d4d63a720c501044e50bd57cc03dfa09b928","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private String createMissingReplacement(PsiElement element) {\n    String text = element.getText();\n    String[] lines = LineTokenizer.tokenize(text, true);\n    StringBuilder newText = new StringBuilder();\n    int ind = lines.length - 1;\n    for (int i = 0; i != lines.length-1; ++i) {\n      String line = lines[i];\n      if (line.contains(myPrefix)) {\n        ind = i;\n        break;\n      }\n      newText.append(line);\n    }\n    PyFunction fun = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n    PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(fun.getStatementList(), PsiWhiteSpace.class);\n    newText.deleteCharAt(newText.length()-1);\n    newText.append((whitespace != null ? whitespace.getText() : \"\\n\"));\n\n    for (int i = 0; i != myMissing.size(); ++i) {\n      String s = myMissing.get(i);\n      newText.append(myPrefix).append(\"param \").append(s).append(\": \");\n      if (i != myMissing.size()-1)\n        newText.append((whitespace != null ? whitespace.getText() : \"\\n\"));\n    }\n    newText.append(\"\\n\");\n    for (int i = ind; i != lines.length; ++i) {\n      String line = lines[i];\n      newText.append(line);\n    }\n    return newText.toString();\n  }","id":76204,"modified_method":"private String createMissingReplacement(PsiElement element) {\n    String text = element.getText();\n    String[] lines = LineTokenizer.tokenize(text, true);\n    StringBuilder newText = new StringBuilder();\n    int ind = lines.length - 1;\n    for (int i = 0; i != lines.length-1; ++i) {\n      String line = lines[i];\n      if (line.contains(myPrefix)) {\n        ind = i;\n        break;\n      }\n      newText.append(line);\n    }\n    PyFunction fun = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n    PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(fun.getStatementList(), PsiWhiteSpace.class);\n    String ws = \"\\n\";\n    if (whitespace != null) {\n      String[] spaces = whitespace.getText().split(\"\\n\");\n      if (spaces.length > 1)\n        ws = ws + whitespace.getText().split(\"\\n\")[1];\n    }\n    newText.deleteCharAt(newText.length()-1);\n    newText.append(ws);\n\n    for (int i = 0; i != myMissing.size(); ++i) {\n      String s = myMissing.get(i);\n      newText.append(myPrefix).append(\"param \").append(s).append(\": \");\n      if (i != myMissing.size()-1)\n        newText.append(ws);\n    }\n    newText.append(\"\\n\");\n    for (int i = ind; i != lines.length; ++i) {\n      String line = lines[i];\n      newText.append(line);\n    }\n    return newText.toString();\n  }","commit_id":"def2d8ab53606d4edf54f0b7203a805d35817f6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyFunction function = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyFunction.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    PythonDocumentationProvider documentationProvider = new PythonDocumentationProvider();\n    PyStatementList list = function.getStatementList();\n    PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(list, PsiWhiteSpace.class);\n    String docContent = documentationProvider.generateDocumentationContentStub(function, (whitespace != null? whitespace.getText() : \"\\n\"));\n    PyExpressionStatement string = elementGenerator.createFromText(LanguageLevel.forElement(function), PyExpressionStatement.class,\n                                                                       \"\\\"\\\"\\\"\" + docContent + \"\\\"\\\"\\\"\");\n    if (list.getStatements().length != 0)\n      list.addBefore(string, list.getStatements()[0]);\n  }","id":76205,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    PyFunction function = PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PyFunction.class);\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n    PythonDocumentationProvider documentationProvider = new PythonDocumentationProvider();\n    PyStatementList list = function.getStatementList();\n    PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(list, PsiWhiteSpace.class);\n    String ws = \"\\n\";\n    if (whitespace != null) {\n      String[] spaces = whitespace.getText().split(\"\\n\");\n      if (spaces.length > 1)\n        ws = ws + whitespace.getText().split(\"\\n\")[1];\n    }\n    String docContent = documentationProvider.generateDocumentationContentStub(function, ws);\n    PyExpressionStatement string = elementGenerator.createFromText(LanguageLevel.forElement(function), PyExpressionStatement.class,\n                                                                       \"\\\"\\\"\\\"\" + docContent + \"\\\"\\\"\\\"\");\n    if (list.getStatements().length != 0)\n      list.addBefore(string, list.getStatements()[0]);\n  }","commit_id":"def2d8ab53606d4edf54f0b7203a805d35817f6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Result preprocessEnter(PsiFile file,\n                                Editor editor,\n                                Ref<Integer> caretOffset,\n                                Ref<Integer> caretAdvance,\n                                DataContext dataContext,\n                                EditorActionHandler originalHandler) {\n    if (!(file instanceof PyFile)) {\n      return Result.Continue;\n    }\n    final Boolean isSplitLine = DataManager.getInstance().loadFromDataContext(dataContext, SplitLineAction.SPLIT_LINE_KEY);\n    if (isSplitLine != null) {\n      return Result.Continue;\n    }\n    Document doc = editor.getDocument();\n    PsiDocumentManager.getInstance(file.getProject()).commitDocument(doc);\n    final int offset = caretOffset.get();\n    final PsiElement element = file.findElementAt(offset);\n    if (element == null) {\n      return Result.Continue;\n    }\n    CodeInsightSettings codeInsightSettings = CodeInsightSettings.getInstance();\n    if (codeInsightSettings.JAVADOC_STUB_ON_ENTER && inDocComment(element)) {\n      PythonDocumentationProvider provider = new PythonDocumentationProvider();\n      PyFunction fun = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n      if (fun != null) {\n        PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(fun.getStatementList(), PsiWhiteSpace.class);\n        String docStub = provider.generateDocumentationContentStub(fun, (whitespace != null ? whitespace.getText() : \"\\n\"));\n        docStub += element.getParent().getText().substring(0,3);\n        if (docStub != null && docStub.length() != 0) {\n          editor.getDocument().insertString(editor.getCaretModel().getOffset(), docStub);\n          return Result.Continue;\n        }\n      }\n      PyElement klass = PsiTreeUtil.getParentOfType(element, PyClass.class, PyFile.class);\n      if (klass != null) {\n        String whitespace = \"\\n\";\n        if (klass instanceof PyClass) {\n          PsiWhiteSpace ws = PsiTreeUtil.getPrevSiblingOfType(((PyClass)klass).getStatementList(), PsiWhiteSpace.class);\n          if (ws != null)\n            whitespace = ws.getText();\n        }\n\n        editor.getDocument().insertString(editor.getCaretModel().getOffset(), whitespace+element.getParent().getText().substring(0,3));\n        return Result.Continue;\n      }\n    }\n\n    if (offset > 0) {\n      final PsiElement beforeCaret = file.findElementAt(offset-1);\n      if (beforeCaret instanceof PsiWhiteSpace && beforeCaret.getText().indexOf('\\\\') > 0) {\n        // we've got a backslash at EOL already, don't need another one\n        return Result.Continue;\n      }\n    }\n    PsiElement statementBefore = findStatementBeforeCaret(file, offset);\n    PsiElement statementAfter = findStatementAfterCaret(file, offset);\n    if (statementBefore != statementAfter) {  // Enter pressed at statement break\n      return Result.Continue;\n    }\n    if (statementBefore == null) {  // empty file\n      return Result.Continue;\n    }\n\n    if (PsiTreeUtil.hasErrorElements(statementBefore)) {\n      final Boolean autoWrapping = DataManager.getInstance().loadFromDataContext(dataContext, AutoHardWrapHandler.AUTO_WRAP_LINE_IN_PROGRESS_KEY);\n      if (autoWrapping == null) {\n        // code is already bad, don't mess it up even further\n        return Result.Continue;\n      }\n      // if we're in middle of typing, it's expected that we will have error elements\n    }\n\n    if (inFromImportParentheses(statementBefore, offset)) {\n      return Result.Continue;\n    }\n\n    PsiElement wrappableBefore = findWrappable(file, offset, true);\n    PsiElement wrappableAfter = findWrappable(file, offset, false);\n    if (!(wrappableBefore instanceof PsiComment)) {\n      while (wrappableBefore != null) {\n        PsiElement next = PsiTreeUtil.getParentOfType(wrappableBefore, IMPLICIT_WRAP_CLASSES);\n        if (next == null) {\n          break;\n        }\n        wrappableBefore = next;\n      }\n    }\n    if (!(wrappableAfter instanceof PsiComment)) {\n      while (wrappableAfter != null) {\n        PsiElement next = PsiTreeUtil.getParentOfType(wrappableAfter, IMPLICIT_WRAP_CLASSES);\n        if (next == null) {\n          break;\n        }\n        wrappableAfter = next;\n      }\n    }\n    if (wrappableBefore instanceof PsiComment || wrappableAfter instanceof PsiComment) {\n      return Result.Continue;\n    }\n    if (wrappableAfter == null || wrappableBefore != wrappableAfter) {\n      doc.insertString(offset, \"\\\\\");\n      caretOffset.set(offset+1);\n    }\n    return Result.Continue;\n  }","id":76206,"modified_method":"@Override\n  public Result preprocessEnter(PsiFile file,\n                                Editor editor,\n                                Ref<Integer> caretOffset,\n                                Ref<Integer> caretAdvance,\n                                DataContext dataContext,\n                                EditorActionHandler originalHandler) {\n    if (!(file instanceof PyFile)) {\n      return Result.Continue;\n    }\n    final Boolean isSplitLine = DataManager.getInstance().loadFromDataContext(dataContext, SplitLineAction.SPLIT_LINE_KEY);\n    if (isSplitLine != null) {\n      return Result.Continue;\n    }\n    Document doc = editor.getDocument();\n    PsiDocumentManager.getInstance(file.getProject()).commitDocument(doc);\n    final int offset = caretOffset.get();\n    final PsiElement element = file.findElementAt(offset);\n    if (element == null) {\n      return Result.Continue;\n    }\n    CodeInsightSettings codeInsightSettings = CodeInsightSettings.getInstance();\n    if (codeInsightSettings.JAVADOC_STUB_ON_ENTER && inDocComment(element)) {\n      PythonDocumentationProvider provider = new PythonDocumentationProvider();\n      PyFunction fun = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n      if (fun != null) {\n        PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(fun.getStatementList(), PsiWhiteSpace.class);\n        String ws = \"\\n\";\n        if (whitespace != null) {\n          String[] spaces = whitespace.getText().split(\"\\n\");\n          if (spaces.length > 1)\n            ws = ws + whitespace.getText().split(\"\\n\")[1];\n        }\n        String docStub = provider.generateDocumentationContentStub(fun, ws);\n        docStub += element.getParent().getText().substring(0,3);\n        if (docStub != null && docStub.length() != 0) {\n          editor.getDocument().insertString(editor.getCaretModel().getOffset(), docStub);\n          return Result.Continue;\n        }\n      }\n      PyElement klass = PsiTreeUtil.getParentOfType(element, PyClass.class, PyFile.class);\n      if (klass != null) {\n        String ws = \"\\n\";\n        if (klass instanceof PyClass) {\n          PsiWhiteSpace whitespace = PsiTreeUtil.getPrevSiblingOfType(((PyClass)klass).getStatementList(), PsiWhiteSpace.class);\n          if (whitespace != null) {\n            String[] spaces = whitespace.getText().split(\"\\n\");\n            if (spaces.length > 1)\n              ws = ws + whitespace.getText().split(\"\\n\")[1];\n          }\n        }\n\n        editor.getDocument().insertString(editor.getCaretModel().getOffset(), ws+element.getParent().getText().substring(0,3));\n        return Result.Continue;\n      }\n    }\n\n    if (offset > 0) {\n      final PsiElement beforeCaret = file.findElementAt(offset-1);\n      if (beforeCaret instanceof PsiWhiteSpace && beforeCaret.getText().indexOf('\\\\') > 0) {\n        // we've got a backslash at EOL already, don't need another one\n        return Result.Continue;\n      }\n    }\n    PsiElement statementBefore = findStatementBeforeCaret(file, offset);\n    PsiElement statementAfter = findStatementAfterCaret(file, offset);\n    if (statementBefore != statementAfter) {  // Enter pressed at statement break\n      return Result.Continue;\n    }\n    if (statementBefore == null) {  // empty file\n      return Result.Continue;\n    }\n\n    if (PsiTreeUtil.hasErrorElements(statementBefore)) {\n      final Boolean autoWrapping = DataManager.getInstance().loadFromDataContext(dataContext, AutoHardWrapHandler.AUTO_WRAP_LINE_IN_PROGRESS_KEY);\n      if (autoWrapping == null) {\n        // code is already bad, don't mess it up even further\n        return Result.Continue;\n      }\n      // if we're in middle of typing, it's expected that we will have error elements\n    }\n\n    if (inFromImportParentheses(statementBefore, offset)) {\n      return Result.Continue;\n    }\n\n    PsiElement wrappableBefore = findWrappable(file, offset, true);\n    PsiElement wrappableAfter = findWrappable(file, offset, false);\n    if (!(wrappableBefore instanceof PsiComment)) {\n      while (wrappableBefore != null) {\n        PsiElement next = PsiTreeUtil.getParentOfType(wrappableBefore, IMPLICIT_WRAP_CLASSES);\n        if (next == null) {\n          break;\n        }\n        wrappableBefore = next;\n      }\n    }\n    if (!(wrappableAfter instanceof PsiComment)) {\n      while (wrappableAfter != null) {\n        PsiElement next = PsiTreeUtil.getParentOfType(wrappableAfter, IMPLICIT_WRAP_CLASSES);\n        if (next == null) {\n          break;\n        }\n        wrappableAfter = next;\n      }\n    }\n    if (wrappableBefore instanceof PsiComment || wrappableAfter instanceof PsiComment) {\n      return Result.Continue;\n    }\n    if (wrappableAfter == null || wrappableBefore != wrappableAfter) {\n      doc.insertString(offset, \"\\\\\");\n      caretOffset.set(offset+1);\n    }\n    return Result.Continue;\n  }","commit_id":"def2d8ab53606d4edf54f0b7203a805d35817f6a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    StringBuilder result = new StringBuilder(\"composite class path item:\");\n\n    for (IClassPathItem child:myChildren){\n      result.append(child.toString()).append(\"\\n\");\n    }\n\n    return result.toString();\n  }","id":76207,"modified_method":"public String toString() {\n    StringBuilder result = new StringBuilder(\"classpath {\\n\");\n\n    for (IClassPathItem child : myChildren) {\n      for (String s : child.toString().split(\"/[\\n]/\")) {\n        result.append('\\t').append(s).append(\"\\n\");\n      }\n    }\n\n    result.append(\"}\");\n    return result.toString();\n  }","commit_id":"2af38113547a13219cc7bfa6b59c46767611c92a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String toString() {\n    return \"file class path item \" + myClassPath;\n  }","id":76208,"modified_method":"public String toString() {\n    return \"file-cp: \" + myClassPath;\n  }","commit_id":"2af38113547a13219cc7bfa6b59c46767611c92a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String toString() {\n    return \"jar file class path item : \" + myIFile;\n  }","id":76209,"modified_method":"public String toString() {\n    return \"jar-cp: \" + myIFile;\n  }","commit_id":"2af38113547a13219cc7bfa6b59c46767611c92a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private jetbrains.mps.plugin.CompilationResult compile(Set<IModule> modules) {\n    boolean hasAnythingToCompile = false;\n\n    for (IModule m : modules) {\n      if (m.isCompileInMPS()) {\n        hasAnythingToCompile = true;\n      }\n    }\n\n    if (!hasAnythingToCompile) {\n      return new jetbrains.mps.plugin.CompilationResult(0, 0, false, false);\n    }\n\n    IClassPathItem classPathItems = computeDependenciesClassPath(modules);\n    JavaCompiler compiler = new JavaCompiler(classPathItems);\n\n\n    for (IModule m : modules) {\n      if (areClassesUpToDate(m)) {\n        continue;\n      }\n\n      if (!m.isCompileInMPS()) {\n        LOG.warning(\"Module which compiled in IDEA depend on module which has to be compiled in MPS:\" + m.getModuleFqName(), m);\n        continue;\n      }\n\n      ModuleSources sources = getModuleSources(m);\n\n      for (IFile f : sources.getFilesToDelete()) {\n        f.delete();\n      }\n\n      for (JavaFile f : sources.getFilesToCompile()) {\n        compiler.addSource(f.getClassName(), f.getContents());\n        myContainingModules.put(f.getClassName(), m);\n      }\n    }\n\n    compiler.compile();\n\n    int errorCount = 0;\n    int outputtedErrors = 0;\n\n    for (CompilationResult cr : compiler.getCompilationResults()) {\n      Set<String> classesWithErrors = new HashSet<String>();\n      if (cr.getErrors() != null) {\n        for (final CategorizedProblem cp : cr.getErrors()) {\n          String fileName = new String(cp.getOriginatingFileName());\n          final String fqName = fileName.substring(0, fileName.length() - MPSExtentions.DOT_JAVAFILE.length()).replace(File.separatorChar, '.');\n          classesWithErrors.add(fqName);\n\n          IModule containingModule = myContainingModules.get(fqName);\n          assert containingModule != null;\n          JavaFile javaFile = myModuleSources.get(containingModule).getJavaFile(fqName);\n\n          String messageStirng = new String(cp.getOriginatingFileName()) + \" : \" + cp.getMessage();\n\n          //final SNode nodeToShow = getNodeByLine(cp, fqName);\n\n          Object hintObject = new FileWithPosition(javaFile.getFile(), cp.getSourceStart());\n\n          if (cp.isWarning()) {\n            LOG.warning(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", hintObject);\n          } else {\n            if (outputtedErrors < MAX_ERRORS) {\n              outputtedErrors++;\n              LOG.error(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", hintObject);\n            }\n          }\n        }\n\n        errorCount += cr.getErrors().length;\n      }\n\n      for (ClassFile cf : cr.getClassFiles()) {\n        String fqName = getName(cf.getCompoundName());\n        String containerClassName = fqName;\n        if (containerClassName.contains(\"$\")) {\n          int index = containerClassName.indexOf('$');\n          containerClassName = containerClassName.substring(0, index);\n        }\n        if (myContainingModules.containsKey(containerClassName)) {\n          IModule m = myContainingModules.get(containerClassName);\n          File classesGen = m.getClassesGen().toFile();\n          String packageName = NameUtil.namespaceFromLongName(fqName);\n          File outputDir = new File(classesGen + File.separator + packageName.replace('.', File.separatorChar));\n          if (!outputDir.exists()) {\n            if (!outputDir.mkdirs()) {\n              throw new RuntimeException(\"Can't create \" + outputDir.getPath() + \" directory\");\n            }\n          }\n          String className = NameUtil.shortNameFromLongName(fqName);\n          File output = new File(outputDir, className + \".class\");\n          if (!classesWithErrors.contains(containerClassName)) {\n            FileOutputStream os = null;\n            try {\n              os = new FileOutputStream(output);\n              os.write(cf.getBytes());\n            } catch (IOException e) {\n              LOG.error(\"Can't write to \" + output.getAbsolutePath());\n            } finally {\n              if (os != null) {\n                try {\n                  os.close();\n                } catch (IOException e) {\n                  LOG.error(e);\n                }\n              }\n            }\n          } else {\n            if (output.exists() && !(output.delete())) {\n              LOG.error(\"Can't delete \" + output.getPath());\n            }\n          }\n        } else {\n          LOG.error(\"I don't know in which module's output path I should place class file for \" + fqName);\n        }\n      }\n    }\n\n    for (IModule module : modules) {\n      ModuleSources sources = getModuleSources(module);\n      for (ResourceFile toCopy : sources.getResourcesToCopy()) {\n        String fqName = toCopy.getPath();\n\n        fqName = fqName.substring(0, fqName.length() - toCopy.getFile().getName().length());\n        String path = fqName.replace('/', File.separatorChar) + toCopy.getFile().getName();\n\n        FileUtil.copyFile(\n          toCopy.getFile().toFile(),\n          module.getClassesGen().child(path).toFile()\n        );\n      }\n    }\n\n    for (IModule module : modules) {\n      module.updateClassPath();\n    }\n\n    return new jetbrains.mps.plugin.CompilationResult(errorCount, 0, false);\n  }","id":76210,"modified_method":"private jetbrains.mps.plugin.CompilationResult compile(Set<IModule> modules) {\n    boolean hasAnythingToCompile = false;\n\n    for (IModule m : modules) {\n      if (m.isCompileInMPS()) {\n        hasAnythingToCompile = true;\n      }\n    }\n\n    if (!hasAnythingToCompile) {\n      return new jetbrains.mps.plugin.CompilationResult(0, 0, false, false);\n    }\n\n    IClassPathItem classPathItems = computeDependenciesClassPath(modules);\n    JavaCompiler compiler = new JavaCompiler(classPathItems);\n\n\n    for (IModule m : modules) {\n      if (areClassesUpToDate(m)) {\n        continue;\n      }\n\n      if (!m.isCompileInMPS()) {\n        LOG.warning(\"Module which compiled in IDEA depend on module which has to be compiled in MPS:\" + m.getModuleFqName(), m);\n        continue;\n      }\n\n      ModuleSources sources = getModuleSources(m);\n\n      for (IFile f : sources.getFilesToDelete()) {\n        f.delete();\n      }\n\n      for (JavaFile f : sources.getFilesToCompile()) {\n        compiler.addSource(f.getClassName(), f.getContents());\n        myContainingModules.put(f.getClassName(), m);\n      }\n    }\n\n    compiler.compile();\n\n    int errorCount = 0;\n    int outputtedErrors = 0;\n\n    for (CompilationResult cr : compiler.getCompilationResults()) {\n      Set<String> classesWithErrors = new HashSet<String>();\n      if (cr.getErrors() != null) {\n        for (final CategorizedProblem cp : cr.getErrors()) {\n          String fileName = new String(cp.getOriginatingFileName());\n          final String fqName = fileName.substring(0, fileName.length() - MPSExtentions.DOT_JAVAFILE.length()).replace(File.separatorChar, '.');\n          classesWithErrors.add(fqName);\n\n          IModule containingModule = myContainingModules.get(fqName);\n          assert containingModule != null;\n          JavaFile javaFile = myModuleSources.get(containingModule).getJavaFile(fqName);\n\n          String messageStirng = new String(cp.getOriginatingFileName()) + \" : \" + cp.getMessage();\n\n          //final SNode nodeToShow = getNodeByLine(cp, fqName);\n\n          Object hintObject = new FileWithPosition(javaFile.getFile(), cp.getSourceStart());\n\n          if (cp.isWarning()) {\n            LOG.warning(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", hintObject);\n          } else {\n            if(outputtedErrors == 0) {\n              LOG.error(\"Errors encountered:\\nModules: \" + modules.toString() + \"\\nClasspath: \" + classPathItems +\"\\n\");\n            }\n            if (outputtedErrors < MAX_ERRORS) {\n              outputtedErrors++;\n              LOG.error(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", hintObject);\n            }\n          }\n        }\n\n        errorCount += cr.getErrors().length;\n      }\n\n      for (ClassFile cf : cr.getClassFiles()) {\n        String fqName = getName(cf.getCompoundName());\n        String containerClassName = fqName;\n        if (containerClassName.contains(\"$\")) {\n          int index = containerClassName.indexOf('$');\n          containerClassName = containerClassName.substring(0, index);\n        }\n        if (myContainingModules.containsKey(containerClassName)) {\n          IModule m = myContainingModules.get(containerClassName);\n          File classesGen = m.getClassesGen().toFile();\n          String packageName = NameUtil.namespaceFromLongName(fqName);\n          File outputDir = new File(classesGen + File.separator + packageName.replace('.', File.separatorChar));\n          if (!outputDir.exists()) {\n            if (!outputDir.mkdirs()) {\n              throw new RuntimeException(\"Can't create \" + outputDir.getPath() + \" directory\");\n            }\n          }\n          String className = NameUtil.shortNameFromLongName(fqName);\n          File output = new File(outputDir, className + \".class\");\n          if (!classesWithErrors.contains(containerClassName)) {\n            FileOutputStream os = null;\n            try {\n              os = new FileOutputStream(output);\n              os.write(cf.getBytes());\n            } catch (IOException e) {\n              LOG.error(\"Can't write to \" + output.getAbsolutePath());\n            } finally {\n              if (os != null) {\n                try {\n                  os.close();\n                } catch (IOException e) {\n                  LOG.error(e);\n                }\n              }\n            }\n          } else {\n            if (output.exists() && !(output.delete())) {\n              LOG.error(\"Can't delete \" + output.getPath());\n            }\n          }\n        } else {\n          LOG.error(\"I don't know in which module's output path I should place class file for \" + fqName);\n        }\n      }\n    }\n\n    for (IModule module : modules) {\n      ModuleSources sources = getModuleSources(module);\n      for (ResourceFile toCopy : sources.getResourcesToCopy()) {\n        String fqName = toCopy.getPath();\n\n        fqName = fqName.substring(0, fqName.length() - toCopy.getFile().getName().length());\n        String path = fqName.replace('/', File.separatorChar) + toCopy.getFile().getName();\n\n        FileUtil.copyFile(\n          toCopy.getFile().toFile(),\n          module.getClassesGen().child(path).toFile()\n        );\n      }\n    }\n\n    for (IModule module : modules) {\n      module.updateClassPath();\n    }\n\n    return new jetbrains.mps.plugin.CompilationResult(errorCount, 0, false);\n  }","commit_id":"2af38113547a13219cc7bfa6b59c46767611c92a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void setupSuiteScopeCluster() throws Exception {\n        createIndex(\"idx\");\n        createIndex(\"idx_unmapped\");\n\n        interval = randomIntBetween(1, 50);\n        numDocs = randomIntBetween(10, 500);\n        minNumber = -200;\n        maxNumber = 200;\n\n        List<IndexRequestBuilder> builders = new ArrayList<>();\n        for (int docs = 0; docs < numDocs; docs++) {\n            builders.add(client().prepareIndex(\"idx\", \"type\").setSource(newDocBuilder()));\n        }\n\n        client().preparePutIndexedScript().setId(\"my_script\").setScriptLang(GroovyScriptEngineService.NAME)\n                .setSource(\"{ \\\"script\\\": \\\"Double.isNaN(_value0) ? false : (_value0 + _value1 > 100)\\\" }\").get();\n\n        indexRandom(true, builders);\n        ensureSearchable();\n    }","id":76211,"modified_method":"@Override\n    public void setupSuiteScopeCluster() throws Exception {\n        createIndex(\"idx\");\n        createIndex(\"idx_unmapped\");\n        createIndex(\"idx_with_gaps\");\n\n        interval = randomIntBetween(1, 50);\n        numDocs = randomIntBetween(10, 500);\n        minNumber = -200;\n        maxNumber = 200;\n\n        List<IndexRequestBuilder> builders = new ArrayList<>();\n        for (int docs = 0; docs < numDocs; docs++) {\n            builders.add(client().prepareIndex(\"idx\", \"type\").setSource(newDocBuilder()));\n        }\n        builders.add(client().prepareIndex(\"idx_with_gaps\", \"type\").setSource(newDocBuilder(1, 1, 0, 0)));\n        builders.add(client().prepareIndex(\"idx_with_gaps\", \"type\").setSource(newDocBuilder(1, 2, 0, 0)));\n        builders.add(client().prepareIndex(\"idx_with_gaps\", \"type\").setSource(newDocBuilder(3, 1, 0, 0)));\n        builders.add(client().prepareIndex(\"idx_with_gaps\", \"type\").setSource(newDocBuilder(3, 3, 0, 0)));\n\n        client().preparePutIndexedScript().setId(\"my_script\").setScriptLang(GroovyScriptEngineService.NAME)\n                .setSource(\"{ \\\"script\\\": \\\"Double.isNaN(_value0) ? false : (_value0 + _value1 > 100)\\\" }\").get();\n\n        indexRandom(true, builders);\n        ensureSearchable();\n    }","commit_id":"15588a499104c73b95df831c74cab79db3f3257b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private XContentBuilder newDocBuilder() throws IOException {\n        XContentBuilder jsonBuilder = jsonBuilder();\n        jsonBuilder.startObject();\n        jsonBuilder.field(FIELD_1_NAME, randomIntBetween(minNumber, maxNumber));\n        jsonBuilder.field(FIELD_2_NAME, randomIntBetween(minNumber, maxNumber));\n        jsonBuilder.field(FIELD_3_NAME, randomIntBetween(minNumber, maxNumber));\n        jsonBuilder.field(FIELD_4_NAME, randomIntBetween(minNumber, maxNumber));\n        jsonBuilder.endObject();\n        return jsonBuilder;\n    }","id":76212,"modified_method":"private XContentBuilder newDocBuilder() throws IOException {\n        return newDocBuilder(randomIntBetween(minNumber, maxNumber), randomIntBetween(minNumber, maxNumber),\n                randomIntBetween(minNumber, maxNumber), randomIntBetween(minNumber, maxNumber));\n    }","commit_id":"15588a499104c73b95df831c74cab79db3f3257b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {\n        List<B> reducedBuckets = reduceBuckets(aggregations, reduceContext);\n\n        // adding empty buckets if needed\n        if (minDocCount == 0) {\n            addEmptyBuckets(reducedBuckets);\n        }\n\n        if (order == InternalOrder.KEY_ASC) {\n            // nothing to do, data are already sorted since shards return\n            // sorted buckets and the merge-sort performed by reduceBuckets\n            // maintains order\n        } else if (order == InternalOrder.KEY_DESC) {\n            // we just need to reverse here...\n            List<B> reverse = new ArrayList<>(reducedBuckets);\n            Collections.reverse(reverse);\n            reducedBuckets = reverse;\n        } else {\n            // sorted by sub-aggregation, need to fall back to a costly n*log(n) sort\n            CollectionUtil.introSort(reducedBuckets, order.comparator());\n        }\n\n        return getFactory().create(getName(), reducedBuckets, order, minDocCount, emptyBucketInfo, formatter, keyed, pipelineAggregators(),\n                getMetaData());\n    }","id":76213,"modified_method":"@Override\n    public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {\n        List<B> reducedBuckets = reduceBuckets(aggregations, reduceContext);\n\n        // adding empty buckets if needed\n        if (minDocCount == 0) {\n            addEmptyBuckets(reducedBuckets, reduceContext);\n        }\n\n        if (order == InternalOrder.KEY_ASC) {\n            // nothing to do, data are already sorted since shards return\n            // sorted buckets and the merge-sort performed by reduceBuckets\n            // maintains order\n        } else if (order == InternalOrder.KEY_DESC) {\n            // we just need to reverse here...\n            List<B> reverse = new ArrayList<>(reducedBuckets);\n            Collections.reverse(reverse);\n            reducedBuckets = reverse;\n        } else {\n            // sorted by sub-aggregation, need to fall back to a costly n*log(n) sort\n            CollectionUtil.introSort(reducedBuckets, order.comparator());\n        }\n\n        return getFactory().create(getName(), reducedBuckets, order, minDocCount, emptyBucketInfo, formatter, keyed, pipelineAggregators(),\n                getMetaData());\n    }","commit_id":"15588a499104c73b95df831c74cab79db3f3257b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void addEmptyBuckets(List<B> list) {\n        B lastBucket = null;\n        ExtendedBounds bounds = emptyBucketInfo.bounds;\n        ListIterator<B> iter = list.listIterator();\n\n        // first adding all the empty buckets *before* the actual data (based on th extended_bounds.min the user requested)\n        if (bounds != null) {\n            B firstBucket = iter.hasNext() ? list.get(iter.nextIndex()) : null;\n            if (firstBucket == null) {\n                if (bounds.min != null && bounds.max != null) {\n                    long key = bounds.min;\n                    long max = bounds.max;\n                    while (key <= max) {\n                        iter.add(getFactory().createBucket(key, 0, emptyBucketInfo.subAggregations, keyed, formatter));\n                        key = emptyBucketInfo.rounding.nextRoundingValue(key);\n                    }\n                }\n            } else {\n                if (bounds.min != null) {\n                    long key = bounds.min;\n                    if (key < firstBucket.key) {\n                        while (key < firstBucket.key) {\n                            iter.add(getFactory().createBucket(key, 0, emptyBucketInfo.subAggregations, keyed, formatter));\n                            key = emptyBucketInfo.rounding.nextRoundingValue(key);\n                        }\n                    }\n                }\n            }\n        }\n\n        // now adding the empty buckets within the actual data,\n        // e.g. if the data series is [1,2,3,7] there're 3 empty buckets that will be created for 4,5,6\n        while (iter.hasNext()) {\n            B nextBucket = list.get(iter.nextIndex());\n            if (lastBucket != null) {\n                long key = emptyBucketInfo.rounding.nextRoundingValue(lastBucket.key);\n                while (key < nextBucket.key) {\n                    iter.add(getFactory().createBucket(key, 0, emptyBucketInfo.subAggregations, keyed, formatter));\n                    key = emptyBucketInfo.rounding.nextRoundingValue(key);\n                }\n                assert key == nextBucket.key;\n            }\n            lastBucket = iter.next();\n        }\n\n        // finally, adding the empty buckets *after* the actual data (based on the extended_bounds.max requested by the user)\n        if (bounds != null && lastBucket != null && bounds.max != null && bounds.max > lastBucket.key) {\n            long key = emptyBucketInfo.rounding.nextRoundingValue(lastBucket.key);\n            long max = bounds.max;\n            while (key <= max) {\n                iter.add(getFactory().createBucket(key, 0, emptyBucketInfo.subAggregations, keyed, formatter));\n                key = emptyBucketInfo.rounding.nextRoundingValue(key);\n            }\n        }\n    }","id":76214,"modified_method":"private void addEmptyBuckets(List<B> list, ReduceContext reduceContext) {\n        B lastBucket = null;\n        ExtendedBounds bounds = emptyBucketInfo.bounds;\n        ListIterator<B> iter = list.listIterator();\n\n        // first adding all the empty buckets *before* the actual data (based on th extended_bounds.min the user requested)\n        InternalAggregations reducedEmptySubAggs = InternalAggregations.reduce(Collections.singletonList(emptyBucketInfo.subAggregations),\n                reduceContext);\n        if (bounds != null) {\n            B firstBucket = iter.hasNext() ? list.get(iter.nextIndex()) : null;\n            if (firstBucket == null) {\n                if (bounds.min != null && bounds.max != null) {\n                    long key = bounds.min;\n                    long max = bounds.max;\n                    while (key <= max) {\n                        iter.add(getFactory().createBucket(key, 0,\n                                reducedEmptySubAggs,\n                                keyed, formatter));\n                        key = emptyBucketInfo.rounding.nextRoundingValue(key);\n                    }\n                }\n            } else {\n                if (bounds.min != null) {\n                    long key = bounds.min;\n                    if (key < firstBucket.key) {\n                        while (key < firstBucket.key) {\n                            iter.add(getFactory().createBucket(key, 0,\n                                    reducedEmptySubAggs,\n                                    keyed, formatter));\n                            key = emptyBucketInfo.rounding.nextRoundingValue(key);\n                        }\n                    }\n                }\n            }\n        }\n\n        // now adding the empty buckets within the actual data,\n        // e.g. if the data series is [1,2,3,7] there're 3 empty buckets that will be created for 4,5,6\n        while (iter.hasNext()) {\n            B nextBucket = list.get(iter.nextIndex());\n            if (lastBucket != null) {\n                long key = emptyBucketInfo.rounding.nextRoundingValue(lastBucket.key);\n                while (key < nextBucket.key) {\n                    iter.add(getFactory().createBucket(key, 0,\n                            reducedEmptySubAggs, keyed,\n                            formatter));\n                    key = emptyBucketInfo.rounding.nextRoundingValue(key);\n                }\n                assert key == nextBucket.key;\n            }\n            lastBucket = iter.next();\n        }\n\n        // finally, adding the empty buckets *after* the actual data (based on the extended_bounds.max requested by the user)\n        if (bounds != null && lastBucket != null && bounds.max != null && bounds.max > lastBucket.key) {\n            long key = emptyBucketInfo.rounding.nextRoundingValue(lastBucket.key);\n            long max = bounds.max;\n            while (key <= max) {\n                iter.add(getFactory().createBucket(key, 0,\n                        reducedEmptySubAggs, keyed,\n                        formatter));\n                key = emptyBucketInfo.rounding.nextRoundingValue(key);\n            }\n        }\n    }","commit_id":"15588a499104c73b95df831c74cab79db3f3257b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testEmptyAggregation() throws Exception {\n        Map<String, Object> varsMap = new HashMap<>();\n        varsMap.put(\"multiplier\", 1);\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"_agg\", new ArrayList<>());\n        params.put(\"vars\", varsMap);\n\n        SearchResponse searchResponse = client().prepareSearch(\"empty_bucket_idx\")\n                .setQuery(matchAllQuery())\n                .addAggregation(histogram(\"histo\").field(\"value\").interval(1l).minDocCount(0)\n                        .subAggregation(\n                        scriptedMetric(\"scripted\")\n                                .params(params)\n                                                .initScript(new Script(\"vars.multiplier = 3\"))\n                                                .mapScript(new Script(\"_agg.add(vars.multiplier)\"))\n                                                .combineScript(\n                                                        new Script(\n                                                                \"newaggregation = []; sum = 0;for (a in _agg) { sum += a}; newaggregation.add(sum); return newaggregation\"))\n                                                .reduceScript(\n                                                        new Script(\n                                                                \"newaggregation = []; sum = 0;for (aggregation in _aggs) { for (a in aggregation) { sum += a} }; newaggregation.add(sum); return newaggregation\"))))\n                .execute().actionGet();\n\n        assertThat(searchResponse.getHits().getTotalHits(), equalTo(2l));\n        Histogram histo = searchResponse.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        Histogram.Bucket bucket = histo.getBuckets().get(1);\n        assertThat(bucket, notNullValue());\n\n        ScriptedMetric scriptedMetric = bucket.getAggregations().get(\"scripted\");\n        assertThat(scriptedMetric, notNullValue());\n        assertThat(scriptedMetric.getName(), equalTo(\"scripted\"));\n        assertThat(scriptedMetric.aggregation(), nullValue());\n    }","id":76215,"modified_method":"public void testEmptyAggregation() throws Exception {\n        Map<String, Object> varsMap = new HashMap<>();\n        varsMap.put(\"multiplier\", 1);\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"_agg\", new ArrayList<>());\n        params.put(\"vars\", varsMap);\n\n        SearchResponse searchResponse = client().prepareSearch(\"empty_bucket_idx\")\n                .setQuery(matchAllQuery())\n                .addAggregation(histogram(\"histo\").field(\"value\").interval(1l).minDocCount(0)\n                        .subAggregation(\n                        scriptedMetric(\"scripted\")\n                                .params(params)\n                                                .initScript(new Script(\"vars.multiplier = 3\"))\n                                                .mapScript(new Script(\"_agg.add(vars.multiplier)\"))\n                                                .combineScript(\n                                                        new Script(\n                                                                \"newaggregation = []; sum = 0;for (a in _agg) { sum += a}; newaggregation.add(sum); return newaggregation\"))\n                                                .reduceScript(\n                                                        new Script(\n                                                                \"newaggregation = []; sum = 0;for (aggregation in _aggs) { for (a in aggregation) { sum += a} }; newaggregation.add(sum); return newaggregation\"))))\n                .execute().actionGet();\n\n        assertThat(searchResponse.getHits().getTotalHits(), equalTo(2l));\n        Histogram histo = searchResponse.getAggregations().get(\"histo\");\n        assertThat(histo, notNullValue());\n        Histogram.Bucket bucket = histo.getBuckets().get(1);\n        assertThat(bucket, notNullValue());\n\n        ScriptedMetric scriptedMetric = bucket.getAggregations().get(\"scripted\");\n        assertThat(scriptedMetric, notNullValue());\n        assertThat(scriptedMetric.getName(), equalTo(\"scripted\"));\n        assertThat(scriptedMetric.aggregation(), notNullValue());\n        assertThat(scriptedMetric.aggregation(), instanceOf(List.class));\n        List<Integer> aggregationResult = (List<Integer>) scriptedMetric.aggregation();\n        assertThat(aggregationResult.size(), equalTo(1));\n        assertThat(aggregationResult.get(0), equalTo(0));\n    }","commit_id":"15588a499104c73b95df831c74cab79db3f3257b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        Object replyTo = event.getMessage().getReplyTo();\n        ReplyToHandler replyToHandler = getReplyToHandler(event.getMessage(),\n            (InboundEndpoint) event.getEndpoint());\n        // Do not propagate REPLY_TO beyond the inbound endpoint\n        event.getMessage().setReplyTo(null);\n\n        MuleEvent resultEvent = processNext(event);\n\n        // Allow components to stop processing of the ReplyTo property (e.g. CXF)\n        final String replyToStop = (String) resultEvent.getMessage().getProperty(MuleProperties.MULE_REPLY_TO_STOP_PROPERTY, PropertyScope.INVOCATION);\n        if (resultEvent != null\n            && !BooleanUtils.toBoolean(replyToStop))\n        {\n            processReplyTo(event, resultEvent, replyToHandler, replyTo);\n        }\n\n        return resultEvent;\n    }","id":76216,"modified_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        Object replyTo = event.getMessage().getReplyTo();\n        ReplyToHandler replyToHandler = getReplyToHandler(event.getMessage(),\n            (InboundEndpoint) event.getEndpoint());\n        // Do not propagate REPLY_TO beyond the inbound endpoint\n        event.getMessage().setReplyTo(null);\n\n        MuleEvent resultEvent = processNext(event);\n\n        // Allow components to stop processing of the ReplyTo property (e.g. CXF)\n        final String replyToStop = resultEvent.getMessage().getInvocationProperty(MuleProperties.MULE_REPLY_TO_STOP_PROPERTY);\n        if (resultEvent != null && !BooleanUtils.toBoolean(replyToStop))\n        {\n            processReplyTo(event, resultEvent, replyToHandler, replyTo);\n        }\n\n        return resultEvent;\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"protected boolean returnException(MuleEvent event, HttpMethod httpMethod)\n    {\n        String disableCheck = (String) event.getMessage().getProperty(HttpConnector.HTTP_DISABLE_STATUS_CODE_EXCEPTION_CHECK, PropertyScope.INVOCATION);\n        if (disableCheck == null)\n        {\n            disableCheck = (String) event.getMessage().getProperty(HttpConnector.HTTP_DISABLE_STATUS_CODE_EXCEPTION_CHECK, PropertyScope.OUTBOUND); \n        }\n        return httpMethod.getStatusCode() >= ERROR_STATUS_CODE_RANGE_START\n                && !BooleanUtils.toBoolean(disableCheck);\n    }","id":76217,"modified_method":"protected boolean returnException(MuleEvent event, HttpMethod httpMethod)\n    {\n        String disableCheck = event.getMessage().getInvocationProperty(HttpConnector.HTTP_DISABLE_STATUS_CODE_EXCEPTION_CHECK);\n        if (disableCheck == null)\n        {\n            disableCheck = (String) event.getMessage().getProperty(HttpConnector.HTTP_DISABLE_STATUS_CODE_EXCEPTION_CHECK, PropertyScope.OUTBOUND); \n        }\n        return httpMethod.getStatusCode() >= ERROR_STATUS_CODE_RANGE_START\n                && !BooleanUtils.toBoolean(disableCheck);\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"protected HttpResponse createResponse(Object src, String encoding, MuleMessage msg)\n            throws IOException, TransformerException\n    {\n        HttpResponse response = new HttpResponse();\n\n        Object tmp = msg.getProperty(HttpConnector.HTTP_STATUS_PROPERTY, PropertyScope.OUTBOUND);\n        int status = HttpConstants.SC_OK;\n\n        if (tmp != null)\n        {\n            status = Integer.valueOf(tmp.toString());\n        } \n        else if (msg.getExceptionPayload() != null) \n        {\n            status = HttpConstants.SC_INTERNAL_SERVER_ERROR;\n        }\n        \n        String version = (String) msg.getProperty(HttpConnector.HTTP_VERSION_PROPERTY, PropertyScope.INBOUND);\n        if (version == null)\n        {\n            version = HttpConstants.HTTP11;\n        }\n        String date = new SimpleDateFormat(HttpConstants.DATE_FORMAT, Locale.US).format(new Date());\n\n        String contentType = (String) msg.getProperty(HttpConstants.HEADER_CONTENT_TYPE, PropertyScope.INBOUND);\n        if (contentType == null)\n        {\n            contentType = (String) msg.getProperty(HttpConstants.HEADER_CONTENT_TYPE, PropertyScope.INVOCATION);\n        }\n\n        // MULE-4047 Don't explicitly set the content-type to a default value here, \n        // otherwise any settings on the servlet/transport will be happily ignored.\n        //if (contentType == null)\n        //{\n        //    contentType = HttpConstants.DEFAULT_CONTENT_TYPE;\n        //\n        //    if (encoding != null)\n        //    {\n        //        contentType += \"; charset=\" + encoding;\n        //    }\n        //    logger.warn(\"Content-Type was not set, defaulting to: \" + contentType);\n        //}\n\n        response.setStatusLine(HttpVersion.parse(version), status);\n        if (contentType != null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE, contentType));\n        }\n        response.setHeader(new Header(HttpConstants.HEADER_DATE, date));\n        response.setHeader(new Header(HttpConstants.HEADER_SERVER, server));\n        if (msg.getOutboundProperty(HttpConstants.HEADER_EXPIRES) == null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_EXPIRES, date));\n        }\n        \n        String etag = (String) msg.getProperty(HttpConstants.HEADER_ETAG, PropertyScope.OUTBOUND);\n        if (etag != null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_ETAG, etag));\n        }\n        response.setFallbackCharset(encoding);\n\n        @SuppressWarnings(\"unchecked\")\n        Collection<String> headerNames = HttpConstants.RESPONSE_HEADER_NAMES.values();\n\n        for (String headerName : headerNames)\n        {\n            String value = msg.getStringProperty(headerName, PropertyScope.INVOCATION, null);\n            if (value == null)\n            {\n                value = msg.getStringProperty(headerName, PropertyScope.OUTBOUND, null);\n            }\n            if (value != null)\n            {\n                response.setHeader(new Header(headerName, value));\n            }\n        }\n\n        //TODO: This is the legacy way of setting custom headers and can be removed in 3.0\n        // Custom responseHeaderNames\n        Map customHeaders = msg.getOutboundProperty(HttpConnector.HTTP_CUSTOM_HEADERS_MAP_PROPERTY);\n        if (customHeaders != null)\n        {\n            Map.Entry entry;\n            for (Iterator iterator = customHeaders.entrySet().iterator(); iterator.hasNext();)\n            {\n                entry = (Map.Entry) iterator.next();\n                if (entry.getValue() != null)\n                {\n                    response.setHeader(new Header(entry.getKey().toString(), entry.getValue().toString()));\n                }\n            }\n        }\n\n        //attach the outbound properties to the message\n        for (String headerName : msg.getPropertyNames(PropertyScope.OUTBOUND))\n        {\n            Object v = msg.getProperty(headerName, PropertyScope.OUTBOUND);\n            if (v != null)\n            {\n                response.setHeader(new Header(headerName, v.toString()));\n            }\n        }\n\n        // Mule properties\n        String user = msg.getStringProperty(MuleProperties.MULE_USER_PROPERTY, PropertyScope.OUTBOUND, null);\n        if (user != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_USER_PROPERTY, user));\n        }\n        if (msg.getCorrelationId() != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_CORRELATION_ID_PROPERTY,\n                    msg.getCorrelationId()));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_GROUP_SIZE_PROPERTY,\n                    String.valueOf(msg.getCorrelationGroupSize())));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_SEQUENCE_PROPERTY,\n                    String.valueOf(msg.getCorrelationSequence())));\n        }\n        if (msg.getReplyTo() != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_REPLY_TO_PROPERTY,\n                    msg.getReplyTo().toString()));\n        }\n\n        response.setBody(msg);\n\n        return response;\n    }","id":76218,"modified_method":"protected HttpResponse createResponse(Object src, String encoding, MuleMessage msg)\n            throws IOException, TransformerException\n    {\n        HttpResponse response = new HttpResponse();\n\n        Object tmp = msg.getProperty(HttpConnector.HTTP_STATUS_PROPERTY, PropertyScope.OUTBOUND);\n        int status = HttpConstants.SC_OK;\n\n        if (tmp != null)\n        {\n            status = Integer.valueOf(tmp.toString());\n        } \n        else if (msg.getExceptionPayload() != null) \n        {\n            status = HttpConstants.SC_INTERNAL_SERVER_ERROR;\n        }\n        \n        String version = (String) msg.getProperty(HttpConnector.HTTP_VERSION_PROPERTY, PropertyScope.INBOUND);\n        if (version == null)\n        {\n            version = HttpConstants.HTTP11;\n        }\n        String date = new SimpleDateFormat(HttpConstants.DATE_FORMAT, Locale.US).format(new Date());\n\n        String contentType = (String) msg.getProperty(HttpConstants.HEADER_CONTENT_TYPE, PropertyScope.INBOUND);\n        if (contentType == null)\n        {\n            contentType = msg.getInvocationProperty(HttpConstants.HEADER_CONTENT_TYPE);\n        }\n\n        // MULE-4047 Don't explicitly set the content-type to a default value here, \n        // otherwise any settings on the servlet/transport will be happily ignored.\n        //if (contentType == null)\n        //{\n        //    contentType = HttpConstants.DEFAULT_CONTENT_TYPE;\n        //\n        //    if (encoding != null)\n        //    {\n        //        contentType += \"; charset=\" + encoding;\n        //    }\n        //    logger.warn(\"Content-Type was not set, defaulting to: \" + contentType);\n        //}\n\n        response.setStatusLine(HttpVersion.parse(version), status);\n        if (contentType != null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_CONTENT_TYPE, contentType));\n        }\n        response.setHeader(new Header(HttpConstants.HEADER_DATE, date));\n        response.setHeader(new Header(HttpConstants.HEADER_SERVER, server));\n        if (msg.getOutboundProperty(HttpConstants.HEADER_EXPIRES) == null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_EXPIRES, date));\n        }\n        \n        String etag = (String) msg.getProperty(HttpConstants.HEADER_ETAG, PropertyScope.OUTBOUND);\n        if (etag != null)\n        {\n            response.setHeader(new Header(HttpConstants.HEADER_ETAG, etag));\n        }\n        response.setFallbackCharset(encoding);\n\n        @SuppressWarnings(\"unchecked\")\n        Collection<String> headerNames = HttpConstants.RESPONSE_HEADER_NAMES.values();\n\n        for (String headerName : headerNames)\n        {\n            String value = msg.getStringProperty(headerName, PropertyScope.INVOCATION, null);\n            if (value == null)\n            {\n                value = msg.getStringProperty(headerName, PropertyScope.OUTBOUND, null);\n            }\n            if (value != null)\n            {\n                response.setHeader(new Header(headerName, value));\n            }\n        }\n\n        //TODO: This is the legacy way of setting custom headers and can be removed in 3.0\n        // Custom responseHeaderNames\n        Map customHeaders = msg.getOutboundProperty(HttpConnector.HTTP_CUSTOM_HEADERS_MAP_PROPERTY);\n        if (customHeaders != null)\n        {\n            Map.Entry entry;\n            for (Iterator iterator = customHeaders.entrySet().iterator(); iterator.hasNext();)\n            {\n                entry = (Map.Entry) iterator.next();\n                if (entry.getValue() != null)\n                {\n                    response.setHeader(new Header(entry.getKey().toString(), entry.getValue().toString()));\n                }\n            }\n        }\n\n        //attach the outbound properties to the message\n        for (String headerName : msg.getPropertyNames(PropertyScope.OUTBOUND))\n        {\n            Object v = msg.getProperty(headerName, PropertyScope.OUTBOUND);\n            if (v != null)\n            {\n                response.setHeader(new Header(headerName, v.toString()));\n            }\n        }\n\n        // Mule properties\n        String user = msg.getStringProperty(MuleProperties.MULE_USER_PROPERTY, PropertyScope.OUTBOUND, null);\n        if (user != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_USER_PROPERTY, user));\n        }\n        if (msg.getCorrelationId() != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_CORRELATION_ID_PROPERTY,\n                    msg.getCorrelationId()));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_GROUP_SIZE_PROPERTY,\n                    String.valueOf(msg.getCorrelationGroupSize())));\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX\n                    + MuleProperties.MULE_CORRELATION_SEQUENCE_PROPERTY,\n                    String.valueOf(msg.getCorrelationSequence())));\n        }\n        if (msg.getReplyTo() != null)\n        {\n            response.setHeader(new Header(CUSTOM_HEADER_PREFIX + MuleProperties.MULE_REPLY_TO_PROPERTY,\n                    msg.getReplyTo().toString()));\n        }\n\n        response.setBody(msg);\n\n        return response;\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public Object transform(MuleMessage msg, String outputEncoding) throws TransformerException\n    {\n        Object src = msg.getPayload();\n\n        String endpointString = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, PropertyScope.OUTBOUND, null);\n        if (endpointString == null)\n        {\n            endpointString = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, PropertyScope.INVOCATION, null); \n        }\n        if (endpointString == null)\n        {\n            throw new TransformerException(\n                    HttpMessages.eventPropertyNotSetCannotProcessRequest(\n                            MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n\n        String method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, PropertyScope.INVOCATION, null);\n        if (method == null)\n        {\n            method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, PropertyScope.OUTBOUND, \"POST\");\n        }\n        try\n        {\n            //Allow Expressions to be embedded\n            endpointString = endpointString.replaceAll(\"%23\", \"#\");\n            endpointString = muleContext.getExpressionManager().parse(endpointString, msg, true);\n            URI uri = new URI(endpointString);\n            HttpMethod httpMethod;\n\n            if (HttpConstants.METHOD_GET.equals(method))\n            {\n                httpMethod = new GetMethod(uri.toString());\n                String getBodyParam = msg.getStringProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY, PropertyScope.INVOCATION,\n                                                                  HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                if (getBodyParam == null)\n                {\n                    msg.getStringProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY, PropertyScope.OUTBOUND,\n                                          HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                }\n                String paramName = URLEncoder.encode(getBodyParam, outputEncoding);\n\n                String paramValue;\n                Boolean encode =  msg.getProperty(HttpConnector.HTTP_ENCODE_PARAMVALUE, PropertyScope.INVOCATION, null);\n                if (encode == null)\n                {\n                    encode = msg.getOutboundProperty(HttpConnector.HTTP_ENCODE_PARAMVALUE, true);\n                }\n                \n                if (encode)\n                {\n                    paramValue = URLEncoder.encode(src.toString(), outputEncoding);\n                }\n                else\n                {\n                    paramValue = src.toString();\n                }\n\n                String query = uri.getRawQuery();\n                if (!(src instanceof NullPayload) && !StringUtils.EMPTY.equals(src))\n                {\n                    if (query == null)\n                    {\n                        query = paramName + \"=\" + paramValue;\n                    }\n                    else\n                    {\n                        query += \"&\" + paramName + \"=\" + paramValue;\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            }\n            else if (HttpConstants.METHOD_POST.equalsIgnoreCase(method))\n            {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                String paramName = msg.getStringProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, PropertyScope.OUTBOUND, null);\n                if (paramName == null)\n                {\n                    paramName = msg.getStringProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, PropertyScope.INVOCATION, null);\n                }\n\n                if (src instanceof Map)\n                {\n                    for (Iterator iterator = ((Map)src).entrySet().iterator(); iterator.hasNext();)\n                    {\n                        Map.Entry entry = (Map.Entry)iterator.next();\n                        postMethod.addParameter(entry.getKey().toString(), entry.getValue().toString());\n                    }\n                }\n                else if(paramName!=null)\n                {\n                    postMethod.addParameter(paramName, src.toString());\n\n                }\n                else\n                {\n                    // Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod, msg);\n                    setupEntityMethod(src, outputEncoding, msg, uri, postMethod);\n                }\n\n                httpMethod = postMethod;\n            }\n            else if (HttpConstants.METHOD_PUT.equalsIgnoreCase(method))\n            {\n                PutMethod putMethod = new PutMethod(uri.toString());\n\n                setupEntityMethod(src, outputEncoding, msg, uri, putMethod);\n\n                httpMethod = putMethod;\n            }\n            else if (HttpConstants.METHOD_DELETE.equalsIgnoreCase(method))\n            {\n                httpMethod = new DeleteMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_HEAD.equalsIgnoreCase(method))\n            {\n                httpMethod = new HeadMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_OPTIONS.equalsIgnoreCase(method))\n            {\n                httpMethod = new OptionsMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_TRACE.equalsIgnoreCase(method))\n            {\n                httpMethod = new TraceMethod(uri.toString());\n            }\n            else\n            {\n                throw new TransformerException(HttpMessages.unsupportedMethod(method));\n            }\n\n            // Allow the user to set HttpMethodParams as an object on the message\n            HttpMethodParams params = (HttpMethodParams) msg.removeProperty(HttpConnector.HTTP_PARAMS_PROPERTY);\n            if (params != null)\n            {\n                httpMethod.setParams(params);\n            }\n            else\n            {\n                // TODO we should probably set other properties here\n                String httpVersion = msg.getStringProperty(HttpConnector.HTTP_VERSION_PROPERTY, PropertyScope.OUTBOUND,\n                                                           HttpConstants.HTTP11);\n                if (HttpConstants.HTTP10.equals(httpVersion))\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_0);\n                }\n                else\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_1);\n                }\n            }\n\n            setHeaders(httpMethod, msg);\n\n            return httpMethod;\n        }\n        catch (Exception e)\n        {\n            throw new TransformerException(this, e);\n        }\n    }","id":76219,"modified_method":"@Override\n    public Object transform(MuleMessage msg, String outputEncoding) throws TransformerException\n    {\n        Object src = msg.getPayload();\n\n        String endpointString = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, PropertyScope.OUTBOUND, null);\n        if (endpointString == null)\n        {\n            endpointString = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, PropertyScope.INVOCATION, null); \n        }\n        if (endpointString == null)\n        {\n            throw new TransformerException(\n                    HttpMessages.eventPropertyNotSetCannotProcessRequest(\n                            MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n\n        String method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, PropertyScope.INVOCATION, null);\n        if (method == null)\n        {\n            method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, PropertyScope.OUTBOUND, \"POST\");\n        }\n        try\n        {\n            //Allow Expressions to be embedded\n            endpointString = endpointString.replaceAll(\"%23\", \"#\");\n            endpointString = muleContext.getExpressionManager().parse(endpointString, msg, true);\n            URI uri = new URI(endpointString);\n            HttpMethod httpMethod;\n\n            if (HttpConstants.METHOD_GET.equals(method))\n            {\n                httpMethod = new GetMethod(uri.toString());\n                String getBodyParam = msg.getStringProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY, PropertyScope.INVOCATION,\n                                                                  HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                if (getBodyParam == null)\n                {\n                    msg.getStringProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY, PropertyScope.OUTBOUND,\n                                          HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                }\n                String paramName = URLEncoder.encode(getBodyParam, outputEncoding);\n\n                String paramValue;\n                Boolean encode = msg.getInvocationProperty(HttpConnector.HTTP_ENCODE_PARAMVALUE);\n                if (encode == null)\n                {\n                    encode = msg.getOutboundProperty(HttpConnector.HTTP_ENCODE_PARAMVALUE, true);\n                }\n                \n                if (encode)\n                {\n                    paramValue = URLEncoder.encode(src.toString(), outputEncoding);\n                }\n                else\n                {\n                    paramValue = src.toString();\n                }\n\n                String query = uri.getRawQuery();\n                if (!(src instanceof NullPayload) && !StringUtils.EMPTY.equals(src))\n                {\n                    if (query == null)\n                    {\n                        query = paramName + \"=\" + paramValue;\n                    }\n                    else\n                    {\n                        query += \"&\" + paramName + \"=\" + paramValue;\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            }\n            else if (HttpConstants.METHOD_POST.equalsIgnoreCase(method))\n            {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                String paramName = msg.getStringProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, PropertyScope.OUTBOUND, null);\n                if (paramName == null)\n                {\n                    paramName = msg.getStringProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, PropertyScope.INVOCATION, null);\n                }\n\n                if (src instanceof Map)\n                {\n                    for (Iterator iterator = ((Map)src).entrySet().iterator(); iterator.hasNext();)\n                    {\n                        Map.Entry entry = (Map.Entry)iterator.next();\n                        postMethod.addParameter(entry.getKey().toString(), entry.getValue().toString());\n                    }\n                }\n                else if(paramName!=null)\n                {\n                    postMethod.addParameter(paramName, src.toString());\n\n                }\n                else\n                {\n                    // Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod, msg);\n                    setupEntityMethod(src, outputEncoding, msg, uri, postMethod);\n                }\n\n                httpMethod = postMethod;\n            }\n            else if (HttpConstants.METHOD_PUT.equalsIgnoreCase(method))\n            {\n                PutMethod putMethod = new PutMethod(uri.toString());\n\n                setupEntityMethod(src, outputEncoding, msg, uri, putMethod);\n\n                httpMethod = putMethod;\n            }\n            else if (HttpConstants.METHOD_DELETE.equalsIgnoreCase(method))\n            {\n                httpMethod = new DeleteMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_HEAD.equalsIgnoreCase(method))\n            {\n                httpMethod = new HeadMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_OPTIONS.equalsIgnoreCase(method))\n            {\n                httpMethod = new OptionsMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_TRACE.equalsIgnoreCase(method))\n            {\n                httpMethod = new TraceMethod(uri.toString());\n            }\n            else\n            {\n                throw new TransformerException(HttpMessages.unsupportedMethod(method));\n            }\n\n            // Allow the user to set HttpMethodParams as an object on the message\n            HttpMethodParams params = (HttpMethodParams) msg.removeProperty(HttpConnector.HTTP_PARAMS_PROPERTY);\n            if (params != null)\n            {\n                httpMethod.setParams(params);\n            }\n            else\n            {\n                // TODO we should probably set other properties here\n                String httpVersion = msg.getStringProperty(HttpConnector.HTTP_VERSION_PROPERTY, PropertyScope.OUTBOUND,\n                                                           HttpConstants.HTTP11);\n                if (HttpConstants.HTTP10.equals(httpVersion))\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_0);\n                }\n                else\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_1);\n                }\n            }\n\n            setHeaders(httpMethod, msg);\n\n            return httpMethod;\n        }\n        catch (Exception e)\n        {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Object processAction(MuleEvent event) throws Exception\n    {\n        // An object representing the new state of the process\n        Object process;\n\n        // Create a map of process variables based on the message properties.\n        Map processVariables = new HashMap();\n        if (event != null)\n        {\n            populateProcessVariables(event, processVariables, PropertyScope.INVOCATION);\n            populateProcessVariables(event, processVariables, PropertyScope.OUTBOUND);\n\n            Object payload = event.transformMessage();\n            if (payload != null && !(payload instanceof NullPayload))\n            {\n                // Store the message's payload as a process variable.\n                processVariables.put(ProcessConnector.PROCESS_VARIABLE_INCOMING, payload);\n\n                // Store the endpoint on which the message was received as a process\n                // variable.\n                String originatingEndpoint = event.getMessage().getStringProperty(\n                    MuleProperties.MULE_ORIGINATING_ENDPOINT_PROPERTY, null);\n                if (StringUtils.isNotEmpty(originatingEndpoint))\n                {\n                    processVariables.put(ProcessConnector.PROCESS_VARIABLE_INCOMING_SOURCE,\n                        originatingEndpoint);\n                }\n            }\n        }\n\n        // Retrieve the parameters\n        Object processType = event.getMessage().getProperty(ProcessConnector.PROPERTY_PROCESS_TYPE, PropertyScope.INVOCATION);\n        processVariables.remove(ProcessConnector.PROPERTY_PROCESS_TYPE);\n\n        // TODO MULE-1220 The processId for BPM is sort of like a session and so we could probably use\n        // Mule's SessionHandler interface for managing this.  \n        Object processId;\n        String processIdField = connector.getProcessIdField();\n\n        //TODO this is redundent but I'm not sure what the correct behaviour is\n        if (StringUtils.isNotEmpty(processIdField))\n        {\n            processId = event.getMessage().getProperty(processIdField, PropertyScope.INVOCATION);\n        }\n        // If processId is explicitly set for the message, this overrides the\n        // processIdField.\n        processId = event.getMessage().getProperty(ProcessConnector.PROPERTY_PROCESS_ID, PropertyScope.INVOCATION, null);\n        if (processId == null)\n        {\n            processId = event.getMessage().getOutboundProperty(ProcessConnector.PROPERTY_PROCESS_ID); \n        }\n        processVariables.remove(ProcessConnector.PROPERTY_PROCESS_ID);\n\n        // Default action is \"advance\"\n        String action = event.getMessage().getStringProperty(ProcessConnector.PROPERTY_ACTION, PropertyScope.INVOCATION,\n            ProcessConnector.ACTION_ADVANCE);\n        processVariables.remove(ProcessConnector.PROPERTY_ACTION);\n\n        Object transition = event.getMessage().getProperty(ProcessConnector.PROPERTY_TRANSITION, PropertyScope.INVOCATION);\n        processVariables.remove(ProcessConnector.PROPERTY_TRANSITION);\n\n        // Decode the URI, for example:\n        // bpm://testProcess/4561?action=advance\n        String temp;\n        temp = event.getEndpoint().getEndpointURI().getHost();\n        if (StringUtils.isNotEmpty(temp))\n        {\n            processType = temp;\n        }\n        temp = event.getEndpoint().getEndpointURI().getPath();\n        if (StringUtils.isNotEmpty(temp))\n        {\n            // Strip the leading \"/\" from the path.\n            if (temp.startsWith(\"/\"))\n            {\n                temp = StringUtils.right(temp, temp.length() - 1);\n            }\n            // If there are any remaining \"/\", we don't know what to do with them.\n            if (temp.indexOf(\"/\") != -1)\n            {\n                throw new IllegalArgumentException(\"Unexpected format in the path of the URL: \" + temp);\n            }\n            processId = temp;\n        }\n\n        // //////////////////////////////////////////////////////////////////////\n\n        // Start a new process.\n        if (processId == null || action.equals(ProcessConnector.ACTION_START))\n        {\n            if (processType != null)\n            {\n                process = connector.getBpms().startProcess(processType, transition, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"New process started, ID = \" + connector.getBpms().getId(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process type is missing, cannot start a new process.\");\n            }\n        }\n\n        // Don't advance the process, just update the process variables.\n        else if (action.equals(ProcessConnector.ACTION_UPDATE))\n        {\n            if (processId != null)\n            {\n                process = connector.getBpms().updateProcess(processId, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"Process variables updated, ID = \" + connector.getBpms().getId(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot update process.\");\n            }\n        }\n\n        // Abort the running process (end abnormally).\n        else if (action.equals(ProcessConnector.ACTION_ABORT))\n        {\n            if (processId != null)\n            {\n                connector.getBpms().abortProcess(processId);\n                process = NullPayload.getInstance();\n                logger.info(\"Process aborted, ID = \" + processId);\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot abort process.\");\n            }\n        }\n\n        // Advance the already-running process one step.\n        else\n        {\n            if (processId != null)\n            {\n                process = connector.getBpms().advanceProcess(processId, transition, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"Process advanced, ID = \" + connector.getBpms().getId(process)\n                                    + \", new state = \" + connector.getBpms().getState(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot advance process.\");\n            }\n        }\n\n        return process;\n    }","id":76220,"modified_method":"protected Object processAction(MuleEvent event) throws Exception\n    {\n        // An object representing the new state of the process\n        Object process;\n\n        // Create a map of process variables based on the message properties.\n        Map processVariables = new HashMap();\n        if (event != null)\n        {\n            populateProcessVariables(event, processVariables, PropertyScope.INVOCATION);\n            populateProcessVariables(event, processVariables, PropertyScope.OUTBOUND);\n\n            Object payload = event.transformMessage();\n            if (payload != null && !(payload instanceof NullPayload))\n            {\n                // Store the message's payload as a process variable.\n                processVariables.put(ProcessConnector.PROCESS_VARIABLE_INCOMING, payload);\n\n                // Store the endpoint on which the message was received as a process\n                // variable.\n                String originatingEndpoint = event.getMessage().getStringProperty(\n                    MuleProperties.MULE_ORIGINATING_ENDPOINT_PROPERTY, null);\n                if (StringUtils.isNotEmpty(originatingEndpoint))\n                {\n                    processVariables.put(ProcessConnector.PROCESS_VARIABLE_INCOMING_SOURCE,\n                        originatingEndpoint);\n                }\n            }\n        }\n\n        // Retrieve the parameters\n        Object processType = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_PROCESS_TYPE);\n        processVariables.remove(ProcessConnector.PROPERTY_PROCESS_TYPE);\n\n        // TODO MULE-1220 The processId for BPM is sort of like a session and so we could probably use\n        // Mule's SessionHandler interface for managing this.  \n        Object processId;\n        String processIdField = connector.getProcessIdField();\n\n        //TODO this is redundent but I'm not sure what the correct behaviour is\n        if (StringUtils.isNotEmpty(processIdField))\n        {\n            processId = event.getMessage().getInvocationProperty(processIdField);\n        }\n        // If processId is explicitly set for the message, this overrides the\n        // processIdField.\n        processId = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_PROCESS_ID);\n        if (processId == null)\n        {\n            processId = event.getMessage().getOutboundProperty(ProcessConnector.PROPERTY_PROCESS_ID); \n        }\n        processVariables.remove(ProcessConnector.PROPERTY_PROCESS_ID);\n\n        // Default action is \"advance\"\n        String action = event.getMessage().getStringProperty(ProcessConnector.PROPERTY_ACTION, PropertyScope.INVOCATION,\n            ProcessConnector.ACTION_ADVANCE);\n        processVariables.remove(ProcessConnector.PROPERTY_ACTION);\n\n        Object transition = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_TRANSITION);\n        processVariables.remove(ProcessConnector.PROPERTY_TRANSITION);\n\n        // Decode the URI, for example:\n        // bpm://testProcess/4561?action=advance\n        String temp;\n        temp = event.getEndpoint().getEndpointURI().getHost();\n        if (StringUtils.isNotEmpty(temp))\n        {\n            processType = temp;\n        }\n        temp = event.getEndpoint().getEndpointURI().getPath();\n        if (StringUtils.isNotEmpty(temp))\n        {\n            // Strip the leading \"/\" from the path.\n            if (temp.startsWith(\"/\"))\n            {\n                temp = StringUtils.right(temp, temp.length() - 1);\n            }\n            // If there are any remaining \"/\", we don't know what to do with them.\n            if (temp.indexOf(\"/\") != -1)\n            {\n                throw new IllegalArgumentException(\"Unexpected format in the path of the URL: \" + temp);\n            }\n            processId = temp;\n        }\n\n        // //////////////////////////////////////////////////////////////////////\n\n        // Start a new process.\n        if (processId == null || action.equals(ProcessConnector.ACTION_START))\n        {\n            if (processType != null)\n            {\n                process = connector.getBpms().startProcess(processType, transition, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"New process started, ID = \" + connector.getBpms().getId(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process type is missing, cannot start a new process.\");\n            }\n        }\n\n        // Don't advance the process, just update the process variables.\n        else if (action.equals(ProcessConnector.ACTION_UPDATE))\n        {\n            if (processId != null)\n            {\n                process = connector.getBpms().updateProcess(processId, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"Process variables updated, ID = \" + connector.getBpms().getId(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot update process.\");\n            }\n        }\n\n        // Abort the running process (end abnormally).\n        else if (action.equals(ProcessConnector.ACTION_ABORT))\n        {\n            if (processId != null)\n            {\n                connector.getBpms().abortProcess(processId);\n                process = NullPayload.getInstance();\n                logger.info(\"Process aborted, ID = \" + processId);\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot abort process.\");\n            }\n        }\n\n        // Advance the already-running process one step.\n        else\n        {\n            if (processId != null)\n            {\n                process = connector.getBpms().advanceProcess(processId, transition, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"Process advanced, ID = \" + connector.getBpms().getId(process)\n                                    + \", new state = \" + connector.getBpms().getState(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot advance process.\");\n            }\n        }\n\n        return process;\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    protected void doDispatch(MuleEvent event) throws Exception\n    {\n        JobConfig jobConfig = (JobConfig) endpoint.getProperty(QuartzConnector.PROPERTY_JOB_CONFIG);\n        if (jobConfig == null)\n        {\n            throw new IllegalArgumentException(CoreMessages.objectIsNull(QuartzConnector.PROPERTY_JOB_CONFIG).getMessage());\n        }\n\n        JobDetail jobDetail = new JobDetail();\n        // make the job name unique per endpoint (MULE-753)\n        jobDetail.setName(event.getEndpoint().getEndpointURI().getAddress() + \"-\" + event.getId());\n\n        JobDataMap jobDataMap = new JobDataMap();\n        MuleMessage msg = event.getMessage();\n        // populate from invocation and outbound scopes only\n        for (String key : msg.getPropertyNames(PropertyScope.INVOCATION))\n        {\n            jobDataMap.put(key, msg.getProperty(key, PropertyScope.INVOCATION));\n        }\n        for (String key : msg.getPropertyNames(PropertyScope.OUTBOUND))\n        {\n            jobDataMap.put(key, msg.getProperty(key, PropertyScope.OUTBOUND));\n        }\n\n        if (jobConfig instanceof ScheduledDispatchJobConfig) \n        {\n            ScheduledDispatchJobConfig scheduledDispatchJobConfig = (ScheduledDispatchJobConfig) jobConfig;\n            String endpointRef = event.getMuleContext().getExpressionManager().parse(\n                scheduledDispatchJobConfig.getEndpointRef(), event.getMessage());\n\n            jobDataMap.put(\"endpointRef\", endpointRef);\n        }\n        jobDetail.setJobDataMap(jobDataMap);\n\n        Job job = null;\n        // work out what we're actually calling\n        Object payload = event.transformMessage();\n\n        if(jobConfig instanceof CustomJobConfig)\n        {\n            job = ((CustomJobConfig) jobConfig).getJob();\n        }\n        else if(jobConfig instanceof CustomJobFromMessageConfig)\n        {\n            job = ((CustomJobFromMessageConfig) jobConfig).getJob(msg);\n            //rewrite the jobConfig to the real Jobconfig on the message\n            jobConfig = ((CustomJobFromMessageConfig) jobConfig).getJobConfig(msg);\n        }\n\n        jobDataMap.put(QuartzConnector.PROPERTY_JOB_CONFIG, jobConfig);        \n        jobDetail.setJobClass(jobConfig.getJobClass());\n        // If there has been a job created or found then we default to a customJob configuration\n        if (job != null)\n        {\n            jobDataMap.put(QuartzConnector.PROPERTY_JOB_OBJECT, job);\n            jobDetail.setJobClass(CustomJob.class);\n        }\n       \n        // The payload will be ignored by the CustomJob - don't know why we need it here\n        //RM: The custom job may want the message and the Job type may not be delegating job\n        jobDataMap.put(QuartzConnector.PROPERTY_PAYLOAD, payload);\n\n        Trigger trigger;\n        String cronExpression = jobDataMap.getString(QuartzConnector.PROPERTY_CRON_EXPRESSION);\n        String repeatInterval = jobDataMap.getString(QuartzConnector.PROPERTY_REPEAT_INTERVAL);\n        String repeatCount = jobDataMap.getString(QuartzConnector.PROPERTY_REPEAT_COUNT);\n        String startDelay = jobDataMap.getString(QuartzConnector.PROPERTY_START_DELAY);\n        String groupName = jobConfig.getGroupName();\n        String jobGroupName = jobConfig.getJobGroupName();\n\n        if (groupName == null)\n        {\n            groupName = QuartzConnector.DEFAULT_GROUP_NAME;\n        }\n        if (jobGroupName == null)\n        {\n            jobGroupName = groupName;\n        }\n\n        jobDetail.setGroup(groupName);\n\n        if (cronExpression != null)\n        {\n            CronTrigger ctrigger = new CronTrigger();\n            ctrigger.setCronExpression(cronExpression);\n            trigger = ctrigger;\n        }\n        else if (repeatInterval != null)\n        {\n            SimpleTrigger strigger = new SimpleTrigger();\n            strigger.setRepeatInterval(Long.parseLong(repeatInterval));\n            if (repeatCount != null)\n            {\n                strigger.setRepeatCount(Integer.parseInt(repeatCount));\n            }\n            else\n            {\n                strigger.setRepeatCount(-1);\n            }\n            trigger = strigger;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\n                QuartzMessages.cronExpressionOrIntervalMustBeSet().getMessage());\n        }\n        trigger.setName(event.getEndpoint().getEndpointURI().toString() + \"-\" + event.getId());\n        trigger.setGroup(groupName);\n        trigger.setJobName(jobDetail.getName());\n        trigger.setJobGroup(jobGroupName);\n\n        Scheduler scheduler = ((QuartzConnector) this.getConnector()).getQuartzScheduler();\n\n        // Minimize the the time window capturing the start time and scheduling the job.\n        long start = System.currentTimeMillis();\n        if (startDelay != null)\n        {\n            start += Long.parseLong(startDelay);\n        }\n        trigger.setStartTime(new Date(start));\n\n        scheduler.scheduleJob(jobDetail, trigger);\n    }","id":76221,"modified_method":"@Override\n    protected void doDispatch(MuleEvent event) throws Exception\n    {\n        JobConfig jobConfig = (JobConfig) endpoint.getProperty(QuartzConnector.PROPERTY_JOB_CONFIG);\n        if (jobConfig == null)\n        {\n            throw new IllegalArgumentException(CoreMessages.objectIsNull(QuartzConnector.PROPERTY_JOB_CONFIG).getMessage());\n        }\n\n        JobDetail jobDetail = new JobDetail();\n        // make the job name unique per endpoint (MULE-753)\n        jobDetail.setName(event.getEndpoint().getEndpointURI().getAddress() + \"-\" + event.getId());\n\n        JobDataMap jobDataMap = new JobDataMap();\n        MuleMessage msg = event.getMessage();\n        // populate from invocation and outbound scopes only\n        for (String key : msg.getPropertyNames(PropertyScope.INVOCATION))\n        {\n            jobDataMap.put(key, msg.getInvocationProperty(key));\n        }\n        for (String key : msg.getPropertyNames(PropertyScope.OUTBOUND))\n        {\n            jobDataMap.put(key, msg.getProperty(key, PropertyScope.OUTBOUND));\n        }\n\n        if (jobConfig instanceof ScheduledDispatchJobConfig) \n        {\n            ScheduledDispatchJobConfig scheduledDispatchJobConfig = (ScheduledDispatchJobConfig) jobConfig;\n            String endpointRef = event.getMuleContext().getExpressionManager().parse(\n                scheduledDispatchJobConfig.getEndpointRef(), event.getMessage());\n\n            jobDataMap.put(\"endpointRef\", endpointRef);\n        }\n        jobDetail.setJobDataMap(jobDataMap);\n\n        Job job = null;\n        // work out what we're actually calling\n        Object payload = event.transformMessage();\n\n        if(jobConfig instanceof CustomJobConfig)\n        {\n            job = ((CustomJobConfig) jobConfig).getJob();\n        }\n        else if(jobConfig instanceof CustomJobFromMessageConfig)\n        {\n            job = ((CustomJobFromMessageConfig) jobConfig).getJob(msg);\n            //rewrite the jobConfig to the real Jobconfig on the message\n            jobConfig = ((CustomJobFromMessageConfig) jobConfig).getJobConfig(msg);\n        }\n\n        jobDataMap.put(QuartzConnector.PROPERTY_JOB_CONFIG, jobConfig);        \n        jobDetail.setJobClass(jobConfig.getJobClass());\n        // If there has been a job created or found then we default to a customJob configuration\n        if (job != null)\n        {\n            jobDataMap.put(QuartzConnector.PROPERTY_JOB_OBJECT, job);\n            jobDetail.setJobClass(CustomJob.class);\n        }\n       \n        // The payload will be ignored by the CustomJob - don't know why we need it here\n        //RM: The custom job may want the message and the Job type may not be delegating job\n        jobDataMap.put(QuartzConnector.PROPERTY_PAYLOAD, payload);\n\n        Trigger trigger;\n        String cronExpression = jobDataMap.getString(QuartzConnector.PROPERTY_CRON_EXPRESSION);\n        String repeatInterval = jobDataMap.getString(QuartzConnector.PROPERTY_REPEAT_INTERVAL);\n        String repeatCount = jobDataMap.getString(QuartzConnector.PROPERTY_REPEAT_COUNT);\n        String startDelay = jobDataMap.getString(QuartzConnector.PROPERTY_START_DELAY);\n        String groupName = jobConfig.getGroupName();\n        String jobGroupName = jobConfig.getJobGroupName();\n\n        if (groupName == null)\n        {\n            groupName = QuartzConnector.DEFAULT_GROUP_NAME;\n        }\n        if (jobGroupName == null)\n        {\n            jobGroupName = groupName;\n        }\n\n        jobDetail.setGroup(groupName);\n\n        if (cronExpression != null)\n        {\n            CronTrigger ctrigger = new CronTrigger();\n            ctrigger.setCronExpression(cronExpression);\n            trigger = ctrigger;\n        }\n        else if (repeatInterval != null)\n        {\n            SimpleTrigger strigger = new SimpleTrigger();\n            strigger.setRepeatInterval(Long.parseLong(repeatInterval));\n            if (repeatCount != null)\n            {\n                strigger.setRepeatCount(Integer.parseInt(repeatCount));\n            }\n            else\n            {\n                strigger.setRepeatCount(-1);\n            }\n            trigger = strigger;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\n                QuartzMessages.cronExpressionOrIntervalMustBeSet().getMessage());\n        }\n        trigger.setName(event.getEndpoint().getEndpointURI().toString() + \"-\" + event.getId());\n        trigger.setGroup(groupName);\n        trigger.setJobName(jobDetail.getName());\n        trigger.setJobGroup(jobGroupName);\n\n        Scheduler scheduler = ((QuartzConnector) this.getConnector()).getQuartzScheduler();\n\n        // Minimize the the time window capturing the start time and scheduling the job.\n        long start = System.currentTimeMillis();\n        if (startDelay != null)\n        {\n            start += Long.parseLong(startDelay);\n        }\n        trigger.setStartTime(new Date(start));\n\n        scheduler.scheduleJob(jobDetail, trigger);\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Helper method for Dispatchers and Receives to extract the correct method from\n     * a Remote object\n     *\n     * @param remoteObject The remote object on which to invoke the method\n     * @param event The current event being processed\n     * @throws org.mule.api.MuleException\n     * @throws NoSuchMethodException\n     * @throws ClassNotFoundException\n     */\n    public Method getMethodObject(Remote remoteObject, MuleEvent event)\n        throws MuleException, NoSuchMethodException, ClassNotFoundException\n    {\n        EndpointURI endpointUri = event.getEndpoint().getEndpointURI();\n        String methodName = MapUtils.getString(endpointUri.getParams(), MuleProperties.MULE_METHOD_PROPERTY,\n            null);\n\n        if (null == methodName)\n        {\n            methodName = (String)event.getMessage().removeProperty(MuleProperties.MULE_METHOD_PROPERTY, PropertyScope.INVOCATION);\n\n            if (null == methodName)\n            {\n                throw new DispatchException(\n                    RmiMessages.messageParamServiceMethodNotSet(), \n                    event.getMessage(), event.getEndpoint());\n            }\n        }\n\n        Class[] argTypes = getArgTypes(event.getMessage().getProperty(RmiConnector.PROPERTY_SERVICE_METHOD_PARAM_TYPES, PropertyScope.INVOCATION), event);\n\n        try\n        {\n            return remoteObject.getClass().getMethod(methodName, argTypes);\n        }\n        catch (NoSuchMethodException e)\n        {\n            throw new NoSuchMethodException(\n                CoreMessages.methodWithParamsNotFoundOnObject(methodName, ArrayUtils.toString(argTypes),\n                    remoteObject.getClass()).toString());\n        }\n        catch (SecurityException e)\n        {\n            throw e;\n        }\n    }","id":76222,"modified_method":"/**\n     * Helper method for Dispatchers and Receives to extract the correct method from\n     * a Remote object\n     *\n     * @param remoteObject The remote object on which to invoke the method\n     * @param event The current event being processed\n     * @throws org.mule.api.MuleException\n     * @throws NoSuchMethodException\n     * @throws ClassNotFoundException\n     */\n    public Method getMethodObject(Remote remoteObject, MuleEvent event)\n        throws MuleException, NoSuchMethodException, ClassNotFoundException\n    {\n        EndpointURI endpointUri = event.getEndpoint().getEndpointURI();\n        String methodName = MapUtils.getString(endpointUri.getParams(), MuleProperties.MULE_METHOD_PROPERTY,\n            null);\n\n        if (null == methodName)\n        {\n            methodName = (String)event.getMessage().removeProperty(MuleProperties.MULE_METHOD_PROPERTY, PropertyScope.INVOCATION);\n\n            if (null == methodName)\n            {\n                throw new DispatchException(\n                    RmiMessages.messageParamServiceMethodNotSet(), \n                    event.getMessage(), event.getEndpoint());\n            }\n        }\n\n        Class[] argTypes = getArgTypes(event.getMessage().getInvocationProperty(RmiConnector.PROPERTY_SERVICE_METHOD_PARAM_TYPES), event);\n\n        try\n        {\n            return remoteObject.getClass().getMethod(methodName, argTypes);\n        }\n        catch (NoSuchMethodException e)\n        {\n            throw new NoSuchMethodException(\n                CoreMessages.methodWithParamsNotFoundOnObject(methodName, ArrayUtils.toString(argTypes),\n                    remoteObject.getClass()).toString());\n        }\n        catch (SecurityException e)\n        {\n            throw e;\n        }\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * We do all this together here rather than chaining them in order to conserve\n     * 2.x exception handling behaviour\n     */\n    public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        ExceptionListener exceptionListener = service.getExceptionListener();\n        MuleEvent resultEvent = null;\n        try\n        {\n            Object replyTo = event.getMessage().getReplyTo();\n            ReplyToHandler replyToHandler = getReplyToHandler(event.getMessage(),\n                (InboundEndpoint) event.getEndpoint());\n            // Do not propagate REPLY_TO beyond the inbound endpoint\n            //event.getMessage().setReplyTo(null);\n\n            resultEvent = service.getComponent().process(event);\n            resultEvent = processNext(resultEvent);\n            resultEvent = receiveAsyncReplyMessageProcessor.process(resultEvent);\n\n            // Allow components to stop processing of the ReplyTo property (e.g.\n            // CXF)\n            if (resultEvent != null)\n            {\n                String replyToStop = (String) resultEvent.getMessage().getProperty(MuleProperties.MULE_REPLY_TO_STOP_PROPERTY, PropertyScope.INVOCATION);\n                if (!event.isSynchronous() || !BooleanUtils.toBoolean(replyToStop))\n                {\n                    processReplyTo(event, resultEvent, replyToHandler, replyTo);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            event.getSession().setValid(false);\n\n            if (e instanceof MessagingException)\n            {\n                exceptionListener.exceptionThrown(e);\n            }\n            else\n            {\n                exceptionListener.exceptionThrown(new MessagingException(\n                    CoreMessages.eventProcessingFailedFor(service.getName()), event.getMessage(), e));\n            }\n            if (event.isSynchronous())\n            {\n                if (resultEvent == null)\n                {\n                    if (exceptionListener != null && exceptionListener instanceof AbstractExceptionListener\n                        && ((AbstractExceptionListener) exceptionListener).getReturnMessage() != null)\n                    {\n                        resultEvent = new DefaultMuleEvent(\n                            ((AbstractExceptionListener) exceptionListener).getReturnMessage(), event);\n                    }\n                    else\n                    {\n                        resultEvent = new DefaultMuleEvent(new DefaultMuleMessage(NullPayload.getInstance(),\n                            event.getMessage(), event.getMuleContext()), event);\n                    }\n                }\n                ExceptionPayload exceptionPayload = event.getMessage().getExceptionPayload();\n                if (exceptionPayload == null)\n                {\n                    exceptionPayload = new DefaultExceptionPayload(e);\n                }\n                resultEvent.getMessage().setExceptionPayload(exceptionPayload);\n            }\n        }\n        return resultEvent;\n    }","id":76223,"modified_method":"/**\n     * We do all this together here rather than chaining them in order to conserve\n     * 2.x exception handling behaviour\n     */\n    public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        ExceptionListener exceptionListener = service.getExceptionListener();\n        MuleEvent resultEvent = null;\n        try\n        {\n            Object replyTo = event.getMessage().getReplyTo();\n            ReplyToHandler replyToHandler = getReplyToHandler(event.getMessage(),\n                (InboundEndpoint) event.getEndpoint());\n            // Do not propagate REPLY_TO beyond the inbound endpoint\n            //event.getMessage().setReplyTo(null);\n\n            resultEvent = service.getComponent().process(event);\n            resultEvent = processNext(resultEvent);\n            resultEvent = receiveAsyncReplyMessageProcessor.process(resultEvent);\n\n            // Allow components to stop processing of the ReplyTo property (e.g.\n            // CXF)\n            if (resultEvent != null)\n            {\n                String replyToStop = resultEvent.getMessage().getInvocationProperty(MuleProperties.MULE_REPLY_TO_STOP_PROPERTY);\n                if (!event.isSynchronous() || !BooleanUtils.toBoolean(replyToStop))\n                {\n                    processReplyTo(event, resultEvent, replyToHandler, replyTo);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            event.getSession().setValid(false);\n\n            if (e instanceof MessagingException)\n            {\n                exceptionListener.exceptionThrown(e);\n            }\n            else\n            {\n                exceptionListener.exceptionThrown(new MessagingException(\n                    CoreMessages.eventProcessingFailedFor(service.getName()), event.getMessage(), e));\n            }\n            if (event.isSynchronous())\n            {\n                if (resultEvent == null)\n                {\n                    if (exceptionListener != null && exceptionListener instanceof AbstractExceptionListener\n                        && ((AbstractExceptionListener) exceptionListener).getReturnMessage() != null)\n                    {\n                        resultEvent = new DefaultMuleEvent(\n                            ((AbstractExceptionListener) exceptionListener).getReturnMessage(), event);\n                    }\n                    else\n                    {\n                        resultEvent = new DefaultMuleEvent(new DefaultMuleMessage(NullPayload.getInstance(),\n                            event.getMessage(), event.getMuleContext()), event);\n                    }\n                }\n                ExceptionPayload exceptionPayload = event.getMessage().getExceptionPayload();\n                if (exceptionPayload == null)\n                {\n                    exceptionPayload = new DefaultExceptionPayload(e);\n                }\n                resultEvent.getMessage().setExceptionPayload(exceptionPayload);\n            }\n        }\n        return resultEvent;\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"public boolean accept(MuleMessage msg)\n    {\n         Object accept = msg.getProperty(toString(), PropertyScope.INVOCATION);\n         \n         if (accept == null && SxcFilteringOutboundRouter.getCurrentMessage() == null) \n         {\n             return false;\n         }\n         else if (accept == null)\n         {\n             throw new UndefinedMatchException();\n         }\n         \n         return (Boolean) accept;\n    }","id":76224,"modified_method":"public boolean accept(MuleMessage msg)\n    {\n        Object accept = msg.getInvocationProperty(toString());\n         \n         if (accept == null && SxcFilteringOutboundRouter.getCurrentMessage() == null) \n         {\n             return false;\n         }\n         else if (accept == null)\n         {\n             throw new UndefinedMatchException();\n         }\n         \n         return (Boolean) accept;\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testMessageSerialization() throws Exception\n    {\n        ObjectToXml t1 = createObject(ObjectToXml.class);\n        t1.setAcceptMuleMessage(true);\n\n        MuleMessage msg = new DefaultMuleMessage(\"test\", muleContext);\n        msg.setEncoding(\"UTF-8\");\n        msg.setCorrelationId(\"1234\");\n        msg.setProperty(\"number\", Integer.valueOf(1), PropertyScope.INVOCATION);\n        msg.setProperty(\"object\", new Apple(), PropertyScope.OUTBOUND);\n        msg.setProperty(\"string\", \"hello\", PropertyScope.OUTBOUND);\n\n        String xml = (String) t1.transform(msg);\n        assertNotNull(xml);\n\n        XmlToObject t2 = createObject(XmlToObject.class);\n\n        Object result = t2.transform(xml);\n        assertNotNull(result);\n        assertTrue(result instanceof MuleMessage);\n\n        msg = (MuleMessage) result;\n\n        assertEquals(\"test\", msg.getPayloadAsString());\n        assertEquals(new Apple(), msg.getProperty(\"object\", PropertyScope.OUTBOUND));\n        //with different case\n        assertEquals(new Apple(), msg.getProperty(\"oBjeCt\", PropertyScope.OUTBOUND));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.INVOCATION));\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.SESSION));\n\n        assertEquals(\"hello\", msg.getOutboundProperty(\"string\"));\n        //with different case\n        assertEquals(\"hello\", msg.getOutboundProperty(\"String\"));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"string\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"string\", PropertyScope.INVOCATION));\n        assertNull(msg.getProperty(\"string\", PropertyScope.SESSION));\n\n        assertEquals(new Integer(1), msg.getProperty(\"number\", PropertyScope.INVOCATION));\n        //with different case\n        assertEquals(new Integer(1), msg.getProperty(\"NUMBER\", PropertyScope.INVOCATION));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"number\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"number\", PropertyScope.OUTBOUND));\n        assertNull(msg.getProperty(\"number\", PropertyScope.SESSION));\n\n        assertEquals(\"1234\", msg.getCorrelationId());\n        assertEquals(\"UTF-8\", msg.getEncoding());\n\n        Set<String> keys = msg.getPropertyNames();\n        assertEquals(5, keys.size());\n\n        //Remove Mule properties\n        keys.remove(MuleProperties.MULE_CORRELATION_ID_PROPERTY);\n        keys.remove(MuleProperties.MULE_ENCODING_PROPERTY);\n\n        for (String key : keys)\n        {\n            assertTrue(key.equals(\"number\") || key.equals(\"string\") || key.equals(\"object\"));\n            assertFalse(key.equals(\"NUMBER\") || key.equals(\"STRING\") || key.equals(\"OBJECT\"));\n        }\n    }","id":76225,"modified_method":"public void testMessageSerialization() throws Exception\n    {\n        ObjectToXml t1 = createObject(ObjectToXml.class);\n        t1.setAcceptMuleMessage(true);\n\n        MuleMessage msg = new DefaultMuleMessage(\"test\", muleContext);\n        msg.setEncoding(\"UTF-8\");\n        msg.setCorrelationId(\"1234\");\n        msg.setProperty(\"number\", Integer.valueOf(1), PropertyScope.INVOCATION);\n        msg.setProperty(\"object\", new Apple(), PropertyScope.OUTBOUND);\n        msg.setProperty(\"string\", \"hello\", PropertyScope.OUTBOUND);\n\n        String xml = (String) t1.transform(msg);\n        assertNotNull(xml);\n\n        XmlToObject t2 = createObject(XmlToObject.class);\n\n        Object result = t2.transform(xml);\n        assertNotNull(result);\n        assertTrue(result instanceof MuleMessage);\n\n        msg = (MuleMessage) result;\n\n        assertEquals(\"test\", msg.getPayloadAsString());\n        assertEquals(new Apple(), msg.getProperty(\"object\", PropertyScope.OUTBOUND));\n        //with different case\n        assertEquals(new Apple(), msg.getProperty(\"oBjeCt\", PropertyScope.OUTBOUND));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.INBOUND));\n        assertNull(msg.getInvocationProperty(\"oBjeCt\"));\n        assertNull(msg.getProperty(\"oBjeCt\", PropertyScope.SESSION));\n\n        assertEquals(\"hello\", msg.getOutboundProperty(\"string\"));\n        //with different case\n        assertEquals(\"hello\", msg.getOutboundProperty(\"String\"));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"string\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"string\", PropertyScope.INVOCATION));\n        assertNull(msg.getProperty(\"string\", PropertyScope.SESSION));\n\n        assertEquals(new Integer(1), msg.getProperty(\"number\", PropertyScope.INVOCATION));\n        //with different case\n        assertEquals(new Integer(1), msg.getProperty(\"NUMBER\", PropertyScope.INVOCATION));\n        //Make sure we don't have the property in a different scope\n        assertNull(msg.getProperty(\"number\", PropertyScope.INBOUND));\n        assertNull(msg.getProperty(\"number\", PropertyScope.OUTBOUND));\n        assertNull(msg.getProperty(\"number\", PropertyScope.SESSION));\n\n        assertEquals(\"1234\", msg.getCorrelationId());\n        assertEquals(\"UTF-8\", msg.getEncoding());\n\n        Set<String> keys = msg.getPropertyNames();\n        assertEquals(5, keys.size());\n\n        //Remove Mule properties\n        keys.remove(MuleProperties.MULE_CORRELATION_ID_PROPERTY);\n        keys.remove(MuleProperties.MULE_ENCODING_PROPERTY);\n\n        for (String key : keys)\n        {\n            assertTrue(key.equals(\"number\") || key.equals(\"string\") || key.equals(\"object\"));\n            assertFalse(key.equals(\"NUMBER\") || key.equals(\"STRING\") || key.equals(\"OBJECT\"));\n        }\n    }","commit_id":"bb996f50d5ceae93ccdde8b417f7e8872daefa4a","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates the JAX-RS Server instance\n     * @return the server\n     */\n    public Server create() {\n        try {\n            serviceFactory.setBus(getBus());\n            checkResources(true);\n            if (serviceFactory.getService() == null) {\n                serviceFactory.setServiceName(getServiceName());\n                serviceFactory.create();\n                updateClassResourceProviders();\n            }\n            \n            Endpoint ep = createEndpoint();\n            server = new ServerImpl(getBus(), \n                                    ep, \n                                    getDestinationFactory(), \n                                    getBindingFactory());\n\n            Invoker invoker = serviceFactory.getInvoker(); \n            if (invoker == null) {\n                ep.getService().setInvoker(createInvoker());\n            } else {\n                ep.getService().setInvoker(invoker);\n            }\n            \n            ProviderFactory factory = setupFactory(ep);\n            ep.put(Application.class.getName(), appProvider);\n            factory.setApplicationProvider(appProvider);\n            \n            factory.setRequestPreprocessor(\n                new RequestPreprocessor(languageMappings, extensionMappings));\n            if (rc != null) {\n                ep.put(\"org.apache.cxf.jaxrs.comparator\", rc);\n            }\n            checkPrivateEndpoint(ep);\n            \n            getServiceFactory().sendEvent(FactoryBeanListener.Event.SERVER_CREATED,\n                                          server, \n                                          null,\n                                          null);\n            \n            applyFeatures();\n            \n            if (start) {\n                server.start();\n            }\n        } catch (EndpointException e) {\n            throw new ServiceConstructionException(e);\n        } catch (BusException e) {\n            throw new ServiceConstructionException(e);\n        } catch (IOException e) {\n            throw new ServiceConstructionException(e);\n        } catch (Exception e) {\n            throw new ServiceConstructionException(e);\n        }\n\n        return server;\n    }","id":76226,"modified_method":"/**\n     * Creates the JAX-RS Server instance\n     * @return the server\n     */\n    public Server create() {\n        ClassLoader origLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            Bus bus = getBus();\n            ClassLoader loader = bus.getExtension(ClassLoader.class);\n            if (loader != null) {\n                Thread.currentThread().setContextClassLoader(loader);\n            }\n            serviceFactory.setBus(bus);\n            checkResources(true);\n            if (serviceFactory.getService() == null) {\n                serviceFactory.setServiceName(getServiceName());\n                serviceFactory.create();\n                updateClassResourceProviders();\n            }\n            \n            Endpoint ep = createEndpoint();\n            server = new ServerImpl(getBus(), \n                                    ep, \n                                    getDestinationFactory(), \n                                    getBindingFactory());\n\n            Invoker invoker = serviceFactory.getInvoker(); \n            if (invoker == null) {\n                ep.getService().setInvoker(createInvoker());\n            } else {\n                ep.getService().setInvoker(invoker);\n            }\n            \n            ProviderFactory factory = setupFactory(ep);\n            ep.put(Application.class.getName(), appProvider);\n            factory.setApplicationProvider(appProvider);\n            \n            factory.setRequestPreprocessor(\n                new RequestPreprocessor(languageMappings, extensionMappings));\n            if (rc != null) {\n                ep.put(\"org.apache.cxf.jaxrs.comparator\", rc);\n            }\n            checkPrivateEndpoint(ep);\n            \n            getServiceFactory().sendEvent(FactoryBeanListener.Event.SERVER_CREATED,\n                                          server, \n                                          null,\n                                          null);\n            \n            applyFeatures();\n            \n            if (start) {\n                server.start();\n            }\n        } catch (EndpointException e) {\n            throw new ServiceConstructionException(e);\n        } catch (BusException e) {\n            throw new ServiceConstructionException(e);\n        } catch (IOException e) {\n            throw new ServiceConstructionException(e);\n        } catch (Exception e) {\n            throw new ServiceConstructionException(e);\n        } finally {\n            Thread.currentThread().setContextClassLoader(origLoader);\n        }\n\n        return server;\n    }","commit_id":"291115bb032d4e1d64c3c04faad2b0472ed1a1c1","url":"https://github.com/apache/cxf"},{"original_method":"public CxfRsConsumer(CxfRsEndpoint endpoint, Processor processor) {\n        super(endpoint, processor);\n        CxfRsInvoker cxfRsInvoker = new CxfRsInvoker(endpoint, this);\n        JAXRSServerFactoryBean svrBean = endpoint.createJAXRSServerFactoryBean();\n        svrBean.setInvoker(cxfRsInvoker);\n        server = svrBean.create();\n    }","id":76227,"modified_method":"public CxfRsConsumer(CxfRsEndpoint endpoint, Processor processor) {\n        super(endpoint, processor);\n        CxfRsInvoker cxfRsInvoker = new CxfRsInvoker(endpoint, this);\n        JAXRSServerFactoryBean svrBean = endpoint.createJAXRSServerFactoryBean();\n        Bus bus = ((CxfRsEndpoint)getEndpoint()).getBus();\n        // We need to apply the bus setting from the CxfRsEndpoint which is not use the default bus\n        if (bus != null) {\n            svrBean.setBus(bus);\n        }\n        svrBean.setInvoker(cxfRsInvoker);\n        server = svrBean.create();\n    }","commit_id":"e245099687443f85925a22044bb07885890cbce0","url":"https://github.com/apache/camel"},{"original_method":"public Bus getBus() {\n        if (bus == null) {\n            bus = CxfEndpointUtils.createBus(getCamelContext());\n            LOG.debug(\"Using DefaultBus {}\", bus);\n        }\n\n        if (!getBusHasBeenCalled.getAndSet(true) && isSetDefaultBus) {\n            BusFactory.setDefaultBus(bus);\n            LOG.debug(\"Set bus {} as thread default bus\", bus);\n        }\n        return bus;\n    }","id":76228,"modified_method":"public Bus getBus() {\n        return bus;\n    }","commit_id":"e245099687443f85925a22044bb07885890cbce0","url":"https://github.com/apache/camel"},{"original_method":"public void setBus(Bus bus) {\n        this.bus = bus;\n    }","id":76229,"modified_method":"public void setBus(Bus bus) {\n        this.bus = bus;\n        if (isSetDefaultBus) {\n            BusFactory.setDefaultBus(bus);\n            LOG.debug(\"Set bus {} as thread default bus\", bus);\n        }\n    }","commit_id":"e245099687443f85925a22044bb07885890cbce0","url":"https://github.com/apache/camel"},{"original_method":"protected void invokeProxyClient(Exchange exchange) throws Exception {\n        Message inMessage = exchange.getIn();\n        Object[] varValues = inMessage.getHeader(CxfConstants.CAMEL_CXF_RS_VAR_VALUES, Object[].class);\n        String methodName = inMessage.getHeader(CxfConstants.OPERATION_NAME, String.class);\n        Client target = null;\n        \n        JAXRSClientFactoryBean cfb = clientFactoryBeanCache.get(CxfEndpointUtils\n                                   .getEffectiveAddress(exchange, ((CxfRsEndpoint)getEndpoint()).getAddress()));\n\n        cfb.setBus(((CxfRsEndpoint)getEndpoint()).getBus());\n        \n        if (varValues == null) {\n            target = cfb.create();\n        } else {\n            target = cfb.createWithValues(varValues);\n        }\n        // find out the method which we want to invoke\n        JAXRSServiceFactoryBean sfb = cfb.getServiceFactory();\n        sfb.getResourceClasses();\n        // check the null body first\n        Object[] parameters = null;\n        if (inMessage.getBody() != null) {\n            parameters = inMessage.getBody(Object[].class);\n        }\n        // get the method\n        Method method = findRightMethod(sfb.getResourceClasses(), methodName, getParameterTypes(parameters));\n        // Will send out the message to\n        // Need to deal with the sub resource class\n        Object response = method.invoke(target, parameters);\n        int statesCode = target.getResponse().getStatus();\n        if (throwException) {\n            if (response instanceof Response) {\n                Integer respCode = ((Response) response).getStatus();\n                if (respCode > 207) {\n                    throw populateCxfRsProducerException(exchange, (Response) response, respCode);\n                }\n            }\n        }\n        CxfRsEndpoint cxfRsEndpoint = (CxfRsEndpoint) getEndpoint();\n        CxfRsBinding binding = cxfRsEndpoint.getBinding();\n        \n        if (exchange.getPattern().isOutCapable()) {\n            LOG.trace(\"Response body = {}\", response);\n            exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());\n            exchange.getOut().setBody(binding.bindResponseToCamelBody(response, exchange));\n            exchange.getOut().getHeaders().putAll(binding.bindResponseHeadersToCamelHeaders(response, exchange));\n            exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, statesCode);\n        }\n    }","id":76230,"modified_method":"protected void invokeProxyClient(Exchange exchange) throws Exception {\n        Message inMessage = exchange.getIn();\n        Object[] varValues = inMessage.getHeader(CxfConstants.CAMEL_CXF_RS_VAR_VALUES, Object[].class);\n        String methodName = inMessage.getHeader(CxfConstants.OPERATION_NAME, String.class);\n        Client target = null;\n        \n        JAXRSClientFactoryBean cfb = clientFactoryBeanCache.get(CxfEndpointUtils\n                                   .getEffectiveAddress(exchange, ((CxfRsEndpoint)getEndpoint()).getAddress()));\n        Bus bus = ((CxfRsEndpoint)getEndpoint()).getBus();\n        // We need to apply the bus setting from the CxfRsEndpoint which is not use the default bus\n        if (bus != null) {\n            cfb.setBus(bus);\n        }\n        if (varValues == null) {\n            target = cfb.create();\n        } else {\n            target = cfb.createWithValues(varValues);\n        }\n        // find out the method which we want to invoke\n        JAXRSServiceFactoryBean sfb = cfb.getServiceFactory();\n        sfb.getResourceClasses();\n        // check the null body first\n        Object[] parameters = null;\n        if (inMessage.getBody() != null) {\n            parameters = inMessage.getBody(Object[].class);\n        }\n        // get the method\n        Method method = findRightMethod(sfb.getResourceClasses(), methodName, getParameterTypes(parameters));\n        // Will send out the message to\n        // Need to deal with the sub resource class\n        Object response = method.invoke(target, parameters);\n        int statesCode = target.getResponse().getStatus();\n        if (throwException) {\n            if (response instanceof Response) {\n                Integer respCode = ((Response) response).getStatus();\n                if (respCode > 207) {\n                    throw populateCxfRsProducerException(exchange, (Response) response, respCode);\n                }\n            }\n        }\n        CxfRsEndpoint cxfRsEndpoint = (CxfRsEndpoint) getEndpoint();\n        CxfRsBinding binding = cxfRsEndpoint.getBinding();\n        \n        if (exchange.getPattern().isOutCapable()) {\n            LOG.trace(\"Response body = {}\", response);\n            exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());\n            exchange.getOut().setBody(binding.bindResponseToCamelBody(response, exchange));\n            exchange.getOut().getHeaders().putAll(binding.bindResponseHeadersToCamelHeaders(response, exchange));\n            exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, statesCode);\n        }\n    }","commit_id":"e245099687443f85925a22044bb07885890cbce0","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected void invokeHttpClient(Exchange exchange) throws Exception {\n        Message inMessage = exchange.getIn();\n        JAXRSClientFactoryBean cfb = clientFactoryBeanCache.get(CxfEndpointUtils\n            .getEffectiveAddress(exchange, ((CxfRsEndpoint)getEndpoint()).getAddress()));\n        \n        cfb.setBus(((CxfRsEndpoint)getEndpoint()).getBus());\n        WebClient client = cfb.createWebClient();\n        String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n        Class<?> responseClass = inMessage.getHeader(CxfConstants.CAMEL_CXF_RS_RESPONSE_CLASS, Class.class);\n        Type genericType = inMessage.getHeader(CxfConstants.CAMEL_CXF_RS_RESPONSE_GENERIC_TYPE, Type.class);\n        String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"HTTP method = {}\", httpMethod);\n            LOG.trace(\"path = {}\", path);\n            LOG.trace(\"responseClass = {}\", responseClass);\n        }\n\n        // set the path\n        if (path != null) {\n            client.path(path);\n        }\n\n        CxfRsEndpoint cxfRsEndpoint = (CxfRsEndpoint) getEndpoint();\n        // check if there is a query map in the message header\n        Map<String, String> maps = inMessage.getHeader(CxfConstants.CAMEL_CXF_RS_QUERY_MAP, Map.class);\n        if (maps == null) {\n            // Get the map from HTTP_QUERY header\n            String queryString = inMessage.getHeader(Exchange.HTTP_QUERY, String.class);\n            if (queryString != null) {\n                maps = getQueryParametersFromQueryString(queryString,\n                                                         IOHelper.getCharsetName(exchange));\n            }\n        }\n        if (maps == null) {\n            maps = cxfRsEndpoint.getParameters();\n        }\n        if (maps != null) {\n            for (Map.Entry<String, String> entry : maps.entrySet()) {\n                client.query(entry.getKey(), entry.getValue());\n            }\n        }\n\n        CxfRsBinding binding = cxfRsEndpoint.getBinding();\n\n        // set the body\n        Object body = null;\n        if (!\"GET\".equals(httpMethod)) {\n            // need to check the request object.           \n            body = binding.bindCamelMessageBodyToRequestBody(inMessage, exchange);\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Request body = \" + body);\n            }\n        }\n\n        // set headers\n        client.headers(binding.bindCamelHeadersToRequestHeaders(inMessage.getHeaders(), exchange));\n\n        // invoke the client\n        Object response = null;\n        if (responseClass == null || Response.class.equals(responseClass)) {\n            response = client.invoke(httpMethod, body);\n        } else {\n            if (Collection.class.isAssignableFrom(responseClass)) {\n                if (genericType instanceof ParameterizedType) {\n                    // Get the collection member type first\n                    Type[] actualTypeArguments = ((ParameterizedType) genericType).getActualTypeArguments();\n                    response = client.invokeAndGetCollection(httpMethod, body, (Class<?>) actualTypeArguments[0]);\n                    \n                } else {\n                    throw new CamelExchangeException(\"Header \" + CxfConstants.CAMEL_CXF_RS_RESPONSE_GENERIC_TYPE + \" not found in message\", exchange);\n                }\n            } else {\n                response = client.invoke(httpMethod, body, responseClass);\n            }\n        }\n        int statesCode = client.getResponse().getStatus();\n        //Throw exception on a response > 207\n        //http://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n        if (throwException) {\n            if (response instanceof Response) {\n                Integer respCode = ((Response) response).getStatus();\n                if (respCode > 207) {\n                    throw populateCxfRsProducerException(exchange, (Response) response, respCode);\n                }\n            }\n        }\n        // set response\n        if (exchange.getPattern().isOutCapable()) {\n            LOG.trace(\"Response body = {}\", response);\n            exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());\n            exchange.getOut().setBody(binding.bindResponseToCamelBody(response, exchange));\n            exchange.getOut().getHeaders().putAll(binding.bindResponseHeadersToCamelHeaders(response, exchange));\n            exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, statesCode);\n        }\n    }","id":76231,"modified_method":"@SuppressWarnings(\"unchecked\")\n    protected void invokeHttpClient(Exchange exchange) throws Exception {\n        Message inMessage = exchange.getIn();\n        JAXRSClientFactoryBean cfb = clientFactoryBeanCache.get(CxfEndpointUtils\n            .getEffectiveAddress(exchange, ((CxfRsEndpoint)getEndpoint()).getAddress()));\n        Bus bus = ((CxfRsEndpoint)getEndpoint()).getBus();\n        // We need to apply the bus setting from the CxfRsEndpoint which is not use the default bus\n        if (bus != null) {\n            cfb.setBus(bus);\n        }\n        WebClient client = cfb.createWebClient();\n        String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);\n        Class<?> responseClass = inMessage.getHeader(CxfConstants.CAMEL_CXF_RS_RESPONSE_CLASS, Class.class);\n        Type genericType = inMessage.getHeader(CxfConstants.CAMEL_CXF_RS_RESPONSE_GENERIC_TYPE, Type.class);\n        String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"HTTP method = {}\", httpMethod);\n            LOG.trace(\"path = {}\", path);\n            LOG.trace(\"responseClass = {}\", responseClass);\n        }\n\n        // set the path\n        if (path != null) {\n            client.path(path);\n        }\n\n        CxfRsEndpoint cxfRsEndpoint = (CxfRsEndpoint) getEndpoint();\n        // check if there is a query map in the message header\n        Map<String, String> maps = inMessage.getHeader(CxfConstants.CAMEL_CXF_RS_QUERY_MAP, Map.class);\n        if (maps == null) {\n            // Get the map from HTTP_QUERY header\n            String queryString = inMessage.getHeader(Exchange.HTTP_QUERY, String.class);\n            if (queryString != null) {\n                maps = getQueryParametersFromQueryString(queryString,\n                                                         IOHelper.getCharsetName(exchange));\n            }\n        }\n        if (maps == null) {\n            maps = cxfRsEndpoint.getParameters();\n        }\n        if (maps != null) {\n            for (Map.Entry<String, String> entry : maps.entrySet()) {\n                client.query(entry.getKey(), entry.getValue());\n            }\n        }\n\n        CxfRsBinding binding = cxfRsEndpoint.getBinding();\n\n        // set the body\n        Object body = null;\n        if (!\"GET\".equals(httpMethod)) {\n            // need to check the request object.           \n            body = binding.bindCamelMessageBodyToRequestBody(inMessage, exchange);\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Request body = \" + body);\n            }\n        }\n\n        // set headers\n        client.headers(binding.bindCamelHeadersToRequestHeaders(inMessage.getHeaders(), exchange));\n\n        // invoke the client\n        Object response = null;\n        if (responseClass == null || Response.class.equals(responseClass)) {\n            response = client.invoke(httpMethod, body);\n        } else {\n            if (Collection.class.isAssignableFrom(responseClass)) {\n                if (genericType instanceof ParameterizedType) {\n                    // Get the collection member type first\n                    Type[] actualTypeArguments = ((ParameterizedType) genericType).getActualTypeArguments();\n                    response = client.invokeAndGetCollection(httpMethod, body, (Class<?>) actualTypeArguments[0]);\n                    \n                } else {\n                    throw new CamelExchangeException(\"Header \" + CxfConstants.CAMEL_CXF_RS_RESPONSE_GENERIC_TYPE + \" not found in message\", exchange);\n                }\n            } else {\n                response = client.invoke(httpMethod, body, responseClass);\n            }\n        }\n        int statesCode = client.getResponse().getStatus();\n        //Throw exception on a response > 207\n        //http://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n        if (throwException) {\n            if (response instanceof Response) {\n                Integer respCode = ((Response) response).getStatus();\n                if (respCode > 207) {\n                    throw populateCxfRsProducerException(exchange, (Response) response, respCode);\n                }\n            }\n        }\n        // set response\n        if (exchange.getPattern().isOutCapable()) {\n            LOG.trace(\"Response body = {}\", response);\n            exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());\n            exchange.getOut().setBody(binding.bindResponseToCamelBody(response, exchange));\n            exchange.getOut().getHeaders().putAll(binding.bindResponseHeadersToCamelHeaders(response, exchange));\n            exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, statesCode);\n        }\n    }","commit_id":"e245099687443f85925a22044bb07885890cbce0","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"ClientEndpoint{\");\n        sb.append(\"conn=\").append(conn);\n        sb.append(\", uuid='\").append(uuid).append('\\'');\n        sb.append(\", firstConnection=\").append(firstConnection);\n        sb.append(\", authenticated=\").append(authenticated);\n        sb.append('}');\n        return sb.toString();\n    }","id":76232,"modified_method":"@Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(\"ClientEndpoint{\");\n        sb.append(\"conn=\").append(conn);\n        sb.append(\", uuid='\").append(uuid).append('\\'');\n        sb.append(\", firstConnection=\").append(firstConnection);\n        sb.append(\", authenticated=\").append(authenticated);\n        sb.append('}');\n        return sb.toString();\n    }","commit_id":"b3f1423824cbd495b11ed1dc4b2f9780f56d8eec","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"void destroy() throws LoginException {\n        runDestroyActions();\n        logout();\n        addTransactionBackupLogForClients();\n        authenticated = false;\n    }","id":76233,"modified_method":"void destroy() throws LoginException {\n        for (Runnable destroyAction : destroyActions) {\n            try {\n                destroyAction.run();\n            } catch (Exception e) {\n                getLogger().warning(\"Exception during destroy action\", e);\n            }\n        }\n\n        LoginContext lc = loginContext;\n        if (lc != null) {\n            lc.logout();\n        }\n        for (TransactionContext context : transactionContextMap.values()) {\n            Transaction transaction = TransactionAccessor.getTransaction(context);\n            if (context.isXAManaged() && transaction.getState() == PREPARED) {\n                TransactionManagerServiceImpl transactionManager =\n                        (TransactionManagerServiceImpl) clientEngine.getTransactionManagerService();\n                transactionManager.addTxBackupLogForClientRecovery(transaction);\n            } else {\n                try {\n                    context.rollbackTransaction();\n                } catch (HazelcastInstanceNotActiveException e) {\n                    getLogger().finest(e);\n                } catch (Exception e) {\n                    getLogger().warning(e);\n                }\n            }\n        }\n        authenticated = false;\n    }","commit_id":"b3f1423824cbd495b11ed1dc4b2f9780f56d8eec","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void setListenerRegistration(final String service, final String topic, final String id) {\n        destroyActions.add(new Runnable() {\n            public void run() {\n                final EventService eventService = clientEngine.getEventService();\n                eventService.deregisterListener(service, topic, id);\n            }\n        });\n    }","id":76234,"modified_method":"public void setListenerRegistration(final String service, final String topic, final String id) {\n        destroyActions.add(new Runnable() {\n            @Override\n            public void run() {\n                EventService eventService = clientEngine.getEventService();\n                eventService.deregisterListener(service, topic, id);\n            }\n        });\n    }","commit_id":"b3f1423824cbd495b11ed1dc4b2f9780f56d8eec","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void sendResponse(final Object response, int callId) {\n        if (response == null) {\n            sendClientResponse(ClientEngineImpl.NULL, callId, false);\n        } else if (response instanceof Throwable) {\n            ClientExceptionConverter converter = ClientExceptionConverters.get(getClientType());\n            Object clientResponse = converter.convert((Throwable) response);\n            sendClientResponse(clientResponse, callId, true);\n        }\n    }","id":76235,"modified_method":"public void sendResponse(Object response, int callId) {\n        boolean isError = false;\n        Object clientResponseObject;\n        if (response == null) {\n            clientResponseObject = ClientEngineImpl.NULL;\n        } else if (response instanceof Throwable) {\n            isError = true;\n            ClientExceptionConverter converter = ClientExceptionConverters.get(getClientType());\n            clientResponseObject = converter.convert((Throwable) response);\n        } else {\n            clientResponseObject = response;\n        }\n        ClientResponse clientResponse = new ClientResponse(clientEngine.toData(clientResponseObject), isError, callId);\n        clientEngine.sendResponse(this, clientResponse);\n    }","commit_id":"b3f1423824cbd495b11ed1dc4b2f9780f56d8eec","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"ClientEndpoint(ClientEngineImpl clientEngine, Connection conn, String uuid) {\n        this.clientEngine = clientEngine;\n        this.conn = conn;\n        this.socketAddress = getAddress(conn);\n        this.uuid = uuid;\n    }","id":76236,"modified_method":"ClientEndpoint(ClientEngineImpl clientEngine, Connection conn, String uuid) {\n        this.clientEngine = clientEngine;\n        this.conn = conn;\n        if (conn instanceof TcpIpConnection) {\n            TcpIpConnection tcpIpConnection = (TcpIpConnection) conn;\n            socketAddress = tcpIpConnection.getSocketChannelWrapper().socket().getRemoteSocketAddress();\n        } else {\n            socketAddress = null;\n        }\n        this.uuid = uuid;\n    }","commit_id":"b3f1423824cbd495b11ed1dc4b2f9780f56d8eec","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void setDistributedObjectListener(final String id) {\n        destroyActions.add(new Runnable() {\n            public void run() {\n                clientEngine.getProxyService().removeProxyListener(id);\n            }\n        });\n    }","id":76237,"modified_method":"public void setDistributedObjectListener(final String id) {\n        destroyActions.add(new Runnable() {\n            @Override\n            public void run() {\n                clientEngine.getProxyService().removeProxyListener(id);\n            }\n        });\n    }","commit_id":"b3f1423824cbd495b11ed1dc4b2f9780f56d8eec","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Subject getSubject() {\n        if (loginContext == null) {\n            return null;\n        } else {\n            return loginContext.getSubject();\n        }\n    }","id":76238,"modified_method":"public Subject getSubject() {\n        return loginContext != null ? loginContext.getSubject() : null;\n    }","commit_id":"b3f1423824cbd495b11ed1dc4b2f9780f56d8eec","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/** Convert n to an InstallableData, or return null\n\t * \tif we don't know how to convert it.\n\t */\n\tpublic InstallableResource convertNode(final Node n,\n\t        final int priority)\n\tthrows Exception {\n\t\tInstallableResource result = null;\n\n\t\t// We only consider CONFIG_NODE_TYPE nodes\n\t\tif(n.isNodeType(CONFIG_NODE_TYPE)) {\n\t\t    final Dictionary<String, Object> dict = load(n);\n\t\t\tresult = new InstallableResource(n.getPath(), null, dict, computeDigest(dict), null, priority);\n\t\t\tlog.debug(\"Converted node {} to {}\", n.getPath(), result);\n\t\t} else {\n\t\t\tlog.debug(\"Node is not a {} node, ignored:{}\", CONFIG_NODE_TYPE, n.getPath());\n\t\t}\n\t\treturn result;\n\t}","id":76239,"modified_method":"/** Convert n to an InstallableData, or return null\n\t * \tif we don't know how to convert it.\n\t */\n\tpublic InstallableResource convertNode(final Node n,\n\t        final int priority)\n\tthrows RepositoryException {\n\t\tInstallableResource result = null;\n\n\t\t// We only consider CONFIG_NODE_TYPE nodes\n\t\tif(n.isNodeType(CONFIG_NODE_TYPE)) {\n\t\t    final Dictionary<String, Object> dict = load(n);\n\t\t\tresult = new InstallableResource(n.getPath(), null, dict, computeDigest(dict), null, priority);\n\t\t\tlog.debug(\"Converted node {} to {}\", n.getPath(), result);\n\t\t} else {\n\t\t\tlog.debug(\"Node is not a {} node, ignored:{}\", CONFIG_NODE_TYPE, n.getPath());\n\t\t}\n\t\treturn result;\n\t}","commit_id":"c55491ebd41c53196488cc92c76273bc889135cd","url":"https://github.com/apache/sling"},{"original_method":"@Override\n        public final void run() {\n            log.info(\"Background thread {} starting\", Thread.currentThread().getName());\n            while(active) {\n                runOneCycle();\n            }\n            log.info(\"Background thread {} done\", Thread.currentThread().getName());\n            counters[RUN_LOOP_COUNTER] = -1;\n        }","id":76240,"modified_method":"@Override\n        public final void run() {\n            log.info(\"Background thread {} starting\", Thread.currentThread().getName());\n            try {\n                // open session\n                session = repository.loginAdministrative(repository.getDefaultWorkspace());\n\n                for (String path : roots) {\n                    listeners.add(new RootFolderListener(session, folderNameFilter, path, updateFoldersListTimer));\n                    log.debug(\"Configured root folder: {}\", path);\n                }\n\n                // Watch for events on the root - that might be one of our root folders\n                session.getWorkspace().getObservationManager().addEventListener(JcrInstaller.this,\n                        Event.NODE_ADDED | Event.NODE_REMOVED,\n                        \"/\",\n                        false, // isDeep\n                        null,\n                        null,\n                        true); // noLocal\n                log.debug(\"Watching for node events on / to detect removal/add of our root folders\");\n\n\n                // Find paths to watch and create WatchedFolders to manage them\n                watchedFolders = new LinkedList<WatchedFolder>();\n                for(String root : roots) {\n                    findPathsToWatch(root, watchedFolders);\n                }\n\n                // Scan watchedFolders and register resources with installer\n                final List<InstallableResource> resources = new LinkedList<InstallableResource>();\n                for(WatchedFolder f : watchedFolders) {\n                    final WatchedFolder.ScanResult r = f.scan();\n                    log.debug(\"Startup: {} provides resources {}\", f, r.toAdd);\n                    resources.addAll(r.toAdd);\n                }\n\n                log.debug(\"Registering {} resources with OSGi installer: {}\", resources.size(), resources);\n                installer.registerResources(URL_SCHEME, resources);\n            } catch (final RepositoryException re) {\n                log.error(\"Repository exception during startup - deactivating installer!\", re);\n                active = false;\n                final ComponentContext ctx = componentContext;\n                if ( ctx  != null ) {\n                    final String name = (String) componentContext.getProperties().get(\n                            ComponentConstants.COMPONENT_NAME);\n                    ctx.disableComponent(name);\n                }\n            }\n            while (active) {\n                runOneCycle();\n            }\n            log.info(\"Background thread {} done\", Thread.currentThread().getName());\n            counters[RUN_LOOP_COUNTER] = -1;\n        }","commit_id":"c55491ebd41c53196488cc92c76273bc889135cd","url":"https://github.com/apache/sling"},{"original_method":"protected void activate(ComponentContext context) throws Exception {\n        log.info(\"Activating Apache Sling JCR Installer\");\n\n        // open session\n    \tsession = repository.loginAdministrative(repository.getDefaultWorkspace());\n\n    \t// Setup converters\n    \tconverters.add(new FileNodeConverter());\n    \tconverters.add(new ConfigNodeConverter());\n\n    \t// Configurable max depth, system property (via bundle context) overrides default value\n    \tfinal Object obj = getPropertyValue(context, PROP_INSTALL_FOLDER_MAX_DEPTH);\n    \tif (obj != null) {\n    \t\t// depending on where it's coming from, obj might be a string or integer\n    \t\tmaxWatchedFolderDepth = Integer.valueOf(String.valueOf(obj)).intValue();\n            log.debug(\"Using configured ({}) folder name max depth '{}'\", PROP_INSTALL_FOLDER_MAX_DEPTH, maxWatchedFolderDepth);\n    \t} else {\n            maxWatchedFolderDepth = DEFAULT_FOLDER_MAX_DEPTH;\n            log.debug(\"Using default folder max depth {}, not provided by {}\", maxWatchedFolderDepth, PROP_INSTALL_FOLDER_MAX_DEPTH);\n    \t}\n\n    \t// Configurable folder regexp, system property overrides default value\n    \tString folderNameRegexp = (String)getPropertyValue(context, FOLDER_NAME_REGEXP_PROPERTY);\n    \tif(folderNameRegexp != null) {\n    \t\tfolderNameRegexp = folderNameRegexp.trim();\n            log.debug(\"Using configured ({}) folder name regexp '{}'\", FOLDER_NAME_REGEXP_PROPERTY, folderNameRegexp);\n    \t} else {\n    \t    folderNameRegexp = DEFAULT_FOLDER_NAME_REGEXP;\n            log.debug(\"Using default folder name regexp '{}', not provided by {}\", folderNameRegexp, FOLDER_NAME_REGEXP_PROPERTY);\n    \t}\n\n    \t// Setup folder filtering and watching\n        folderNameFilter = new FolderNameFilter(OsgiUtil.toStringArray(context.getProperties().get(PROP_SEARCH_PATH), DEFAULT_SEARCH_PATH),\n                folderNameRegexp, settings.getRunModes());\n        roots = folderNameFilter.getRootPaths();\n        for (String path : roots) {\n            listeners.add(new RootFolderListener(session, folderNameFilter, path, updateFoldersListTimer));\n            log.debug(\"Configured root folder: {}\", path);\n        }\n\n        // Watch for events on the root - that might be one of our root folders\n        session.getWorkspace().getObservationManager().addEventListener(this,\n                Event.NODE_ADDED | Event.NODE_REMOVED,\n                \"/\",\n                false, // isDeep\n                null,\n                null,\n                true); // noLocal\n        log.debug(\"Watching for node events on / to detect removal/add of our root folders\");\n\n\n    \t// Find paths to watch and create WatchedFolders to manage them\n    \twatchedFolders = new LinkedList<WatchedFolder>();\n    \tfor(String root : roots) {\n    \t\tfindPathsToWatch(root, watchedFolders);\n    \t}\n\n    \t// Scan watchedFolders and register resources with installer\n    \tfinal List<InstallableResource> resources = new LinkedList<InstallableResource>();\n    \tfor(WatchedFolder f : watchedFolders) {\n    \t\tfinal WatchedFolder.ScanResult r = f.scan();\n    \t\tlog.debug(\"Startup: {} provides resources {}\", f, r.toAdd);\n    \t\tresources.addAll(r.toAdd);\n    \t}\n\n    \tlog.debug(\"Registering {} resources with OSGi installer: {}\", resources.size(), resources);\n    \tinstaller.registerResources(URL_SCHEME, resources);\n\n    \tif (backgroundThread != null) {\n    \t    throw new IllegalStateException(\"Expected backgroundThread to be null in activate()\");\n    \t}\n        backgroundThread = new StoppableThread();\n        backgroundThread.start();\n    }","id":76241,"modified_method":"/**\n     * Activate this component.\n     */\n    protected void activate(final ComponentContext context) {\n        if (backgroundThread != null) {\n            throw new IllegalStateException(\"Expected backgroundThread to be null in activate()\");\n        }\n        this.componentContext = context;\n        log.info(\"Activating Apache Sling JCR Installer\");\n\n    \t// Setup converters\n    \tconverters.add(new FileNodeConverter());\n    \tconverters.add(new ConfigNodeConverter());\n\n    \t// Configurable max depth, system property (via bundle context) overrides default value\n    \tfinal Object obj = getPropertyValue(context, PROP_INSTALL_FOLDER_MAX_DEPTH);\n    \tif (obj != null) {\n    \t\t// depending on where it's coming from, obj might be a string or integer\n    \t\tmaxWatchedFolderDepth = Integer.valueOf(String.valueOf(obj)).intValue();\n            log.debug(\"Using configured ({}) folder name max depth '{}'\", PROP_INSTALL_FOLDER_MAX_DEPTH, maxWatchedFolderDepth);\n    \t} else {\n            maxWatchedFolderDepth = DEFAULT_FOLDER_MAX_DEPTH;\n            log.debug(\"Using default folder max depth {}, not provided by {}\", maxWatchedFolderDepth, PROP_INSTALL_FOLDER_MAX_DEPTH);\n    \t}\n\n    \t// Configurable folder regexp, system property overrides default value\n    \tString folderNameRegexp = (String)getPropertyValue(context, FOLDER_NAME_REGEXP_PROPERTY);\n    \tif(folderNameRegexp != null) {\n    \t\tfolderNameRegexp = folderNameRegexp.trim();\n            log.debug(\"Using configured ({}) folder name regexp '{}'\", FOLDER_NAME_REGEXP_PROPERTY, folderNameRegexp);\n    \t} else {\n    \t    folderNameRegexp = DEFAULT_FOLDER_NAME_REGEXP;\n            log.debug(\"Using default folder name regexp '{}', not provided by {}\", folderNameRegexp, FOLDER_NAME_REGEXP_PROPERTY);\n    \t}\n\n    \t// Setup folder filtering and watching\n        folderNameFilter = new FolderNameFilter(OsgiUtil.toStringArray(context.getProperties().get(PROP_SEARCH_PATH), DEFAULT_SEARCH_PATH),\n                folderNameRegexp, settings.getRunModes());\n        roots = folderNameFilter.getRootPaths();\n        backgroundThread = new StoppableThread();\n        backgroundThread.start();\n    }","commit_id":"c55491ebd41c53196488cc92c76273bc889135cd","url":"https://github.com/apache/sling"},{"original_method":"InstallableResource convertNode(Node n, int priority)\n    \tthrows Exception;","id":76242,"modified_method":"InstallableResource convertNode(Node n, int priority)\n    \tthrows RepositoryException;","commit_id":"c55491ebd41c53196488cc92c76273bc889135cd","url":"https://github.com/apache/sling"},{"original_method":"protected void deactivate(ComponentContext context) {\n    \tlog.info(\"Deactivating Apache Sling JCR Installer\");\n\n    \tfinal long timeout = 30000L;\n    \ttry {\n            backgroundThread.active = false;\n            log.debug(\"Waiting for \" + backgroundThread.getName() + \" Thread to end...\");\n            backgroundThread.join(timeout);\n            backgroundThread = null;\n    \t} catch(InterruptedException iex) {\n    \t    throw new IllegalStateException(\"backgroundThread.join interrupted after \" + timeout + \" msec\");\n    \t}\n\n        try {\n            folderNameFilter = null;\n            watchedFolders = null;\n            converters.clear();\n            if(session != null) {\n                for(RootFolderListener wfc : listeners) {\n                    wfc.cleanup(session);\n                }\n                session.getWorkspace().getObservationManager().removeEventListener(this);\n                session.logout();\n                session = null;\n            }\n            listeners.clear();\n        } catch(Exception e) {\n            log.warn(\"Exception in deactivate()\", e);\n        }\n    }","id":76243,"modified_method":"/**\n     * Deactivate this component\n     */\n    protected void deactivate(final ComponentContext context) {\n    \tlog.info(\"Deactivating Apache Sling JCR Installer\");\n\n    \tfinal long timeout = 30000L;\n        backgroundThread.active = false;\n        log.debug(\"Waiting for \" + backgroundThread.getName() + \" Thread to end...\");\n    \ttry {\n            backgroundThread.join(timeout);\n    \t} catch(InterruptedException iex) {\n    \t    throw new IllegalStateException(\"backgroundThread.join interrupted after \" + timeout + \" msec\");\n    \t}\n        backgroundThread = null;\n\n        folderNameFilter = null;\n        watchedFolders = null;\n        converters.clear();\n        try {\n            if (session != null) {\n                for(RootFolderListener wfc : listeners) {\n                    wfc.cleanup(session);\n                }\n                session.getWorkspace().getObservationManager().removeEventListener(this);\n            }\n        } catch (final RepositoryException e) {\n            log.warn(\"Exception in deactivate()\", e);\n        }\n        if ( session != null ) {\n            session.logout();\n            session = null;\n        }\n        listeners.clear();\n        this.componentContext = null;\n    }","commit_id":"c55491ebd41c53196488cc92c76273bc889135cd","url":"https://github.com/apache/sling"},{"original_method":"/** Return a JcrInstaller setup for testing */\n    static synchronized JcrInstaller getJcrInstaller(SlingRepository repository,\n            OsgiInstaller osgiInstaller) throws Exception {\n        final JcrInstaller installer = new JcrInstaller();\n        setField(installer, \"repository\", repository);\n        setField(installer, \"installer\", osgiInstaller);\n        setField(installer, \"settings\", new MockSettings(RUN_MODES));\n\n        installer.activate(getMockComponentContext());\n        return installer;\n    }","id":76244,"modified_method":"/** Return a JcrInstaller setup for testing */\n    static synchronized JcrInstaller getJcrInstaller(SlingRepository repository,\n            OsgiInstaller osgiInstaller) throws Exception {\n        final JcrInstaller installer = new JcrInstaller();\n        setField(installer, \"repository\", repository);\n        setField(installer, \"installer\", osgiInstaller);\n        setField(installer, \"settings\", new MockSettings(RUN_MODES));\n\n        installer.activate(getMockComponentContext());\n        Thread.sleep(1000);\n        return installer;\n    }","commit_id":"c55491ebd41c53196488cc92c76273bc889135cd","url":"https://github.com/apache/sling"},{"original_method":"/** Scan the contents of our folder and return the corresponding InstallableResource */\n    ScanResult scan() throws Exception {\n        log.debug(\"Scanning {}\", path);\n        needsScan = false;\n\n        Node folder = null;\n        if(session.itemExists(path)) {\n        \tItem i = session.getItem(path);\n        \tif(i.isNode()) {\n        \t\tfolder = (Node)i;\n        \t}\n        }\n\n        // Return an InstallableResource for all child nodes for which we have a NodeConverter\n        final ScanResult result = new ScanResult();\n        final Set<String> resourcesSeen = new HashSet<String>();\n        if(folder != null) {\n            final NodeIterator it = folder.getNodes();\n            while(it.hasNext()) {\n            \tfinal Node n = it.nextNode();\n            \tfor(JcrInstaller.NodeConverter nc : converters) {\n            \t\tfinal InstallableResource r = nc.convertNode(n, priority);\n            \t\tif(r != null) {\n            \t\t\tresourcesSeen.add(r.getId());\n            \t\t    final String oldDigest = digests.get(r.getId());\n            \t\t    if(r.getDigest().equals(oldDigest)) {\n            \t\t    \tlog.debug(\"Digest didn't change, ignoring \" + r);\n            \t\t    } else {\n                            result.toAdd.add(r);\n            \t\t    }\n            \t\t\tbreak;\n            \t\t}\n            \t}\n            }\n        }\n\n        // Resources that existed but are not in resourcesSeen need to be\n        // unregistered from OsgiInstaller\n        for(String url : existingResourceUrls) {\n        \tif(!resourcesSeen.contains(url)) {\n                result.toRemove.add(url);\n        \t}\n        }\n        for(String u : result.toRemove) {\n        \texistingResourceUrls.remove(u);\n        \tdigests.remove(u);\n        }\n\n        // Update saved digests of the resources that we're returning\n        for(InstallableResource r : result.toAdd) {\n            existingResourceUrls.add(r.getId());\n            digests.put(r.getId(), r.getDigest());\n        }\n\n        return result;\n    }","id":76245,"modified_method":"/** Scan the contents of our folder and return the corresponding InstallableResource */\n    ScanResult scan() throws RepositoryException {\n        log.debug(\"Scanning {}\", path);\n        needsScan = false;\n\n        Node folder = null;\n        if(session.itemExists(path)) {\n        \tItem i = session.getItem(path);\n        \tif(i.isNode()) {\n        \t\tfolder = (Node)i;\n        \t}\n        }\n\n        // Return an InstallableResource for all child nodes for which we have a NodeConverter\n        final ScanResult result = new ScanResult();\n        final Set<String> resourcesSeen = new HashSet<String>();\n        if(folder != null) {\n            final NodeIterator it = folder.getNodes();\n            while(it.hasNext()) {\n            \tfinal Node n = it.nextNode();\n            \tfor(JcrInstaller.NodeConverter nc : converters) {\n            \t\tfinal InstallableResource r = nc.convertNode(n, priority);\n            \t\tif(r != null) {\n            \t\t\tresourcesSeen.add(r.getId());\n            \t\t    final String oldDigest = digests.get(r.getId());\n            \t\t    if(r.getDigest().equals(oldDigest)) {\n            \t\t    \tlog.debug(\"Digest didn't change, ignoring \" + r);\n            \t\t    } else {\n                            result.toAdd.add(r);\n            \t\t    }\n            \t\t\tbreak;\n            \t\t}\n            \t}\n            }\n        }\n\n        // Resources that existed but are not in resourcesSeen need to be\n        // unregistered from OsgiInstaller\n        for(String url : existingResourceUrls) {\n        \tif(!resourcesSeen.contains(url)) {\n                result.toRemove.add(url);\n        \t}\n        }\n        for(String u : result.toRemove) {\n        \texistingResourceUrls.remove(u);\n        \tdigests.remove(u);\n        }\n\n        // Update saved digests of the resources that we're returning\n        for(InstallableResource r : result.toAdd) {\n            existingResourceUrls.add(r.getId());\n            digests.put(r.getId(), r.getDigest());\n        }\n\n        return result;\n    }","commit_id":"c55491ebd41c53196488cc92c76273bc889135cd","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Unregister and fire the event if requested\n     * @param fireEvent boolean\n     */\n    void unregister(boolean fireEvent)\n    {\n        RegistrationState currRegState = getRegistrationState();\n\n        messenger.logout();\n\n        if(fireEvent)\n        {\n            fireRegistrationStateChanged(\n                currRegState,\n                RegistrationState.UNREGISTERED,\n                RegistrationStateChangeEvent.REASON_USER_REQUEST, null);\n        }\n    }","id":76246,"modified_method":"/**\n     * Unregister and fire the event if requested\n     * @param fireEvent boolean\n     */\n    void unregister(boolean fireEvent)\n    {\n        RegistrationState currRegState = getRegistrationState();\n\n        if(messenger != null)\n            messenger.logout();\n\n        if(fireEvent)\n        {\n            fireRegistrationStateChanged(\n                currRegState,\n                RegistrationState.UNREGISTERED,\n                RegistrationStateChangeEvent.REASON_USER_REQUEST, null);\n        }\n    }","commit_id":"24fccd9c6afa8b1aaf75aae40d502a52af269966","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void logout(MsnMessenger msnMessenger)\n        {\n            logger.trace(\"logout\");\n            unregister(false);\n//            if(isRegistered())\n//                fireRegistrationStateChanged(\n//                    getRegistrationState(),\n//                    RegistrationState.UNREGISTERED,\n//                    RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n\n        }","id":76247,"modified_method":"public void logout(MsnMessenger msnMessenger)\n        {\n            logger.trace(\"logout\");\n            unregister(true);\n//            if(isRegistered())\n//                fireRegistrationStateChanged(\n//                    getRegistrationState(),\n//                    RegistrationState.UNREGISTERED,\n//                    RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n\n        }","commit_id":"24fccd9c6afa8b1aaf75aae40d502a52af269966","url":"https://github.com/jitsi/jitsi"},{"original_method":"protected ClusterExecutorImpl getClusterExecutorImpl(\n\t\t\tboolean useMockReceiver, boolean loadSpringXML)\n\t\tthrows Exception {\n\n\t\t_initialize(loadSpringXML);\n\n\t\tClusterExecutorImpl clusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\tclusterExecutorImpl.afterPropertiesSet();\n\t\tclusterExecutorImpl.setShortcutLocalMethod(true);\n\n\t\tif (useMockReceiver) {\n\t\t\tclusterExecutorImpl.getControlChannel().setReceiver(\n\t\t\t\tnew MockClusterRequestReceiver(clusterExecutorImpl));\n\t\t}\n\n\t\tclusterExecutorImpl.initialize();\n\n\t\treturn clusterExecutorImpl;\n\t}","id":76248,"modified_method":"protected ClusterExecutorImpl getClusterExecutorImpl(\n\t\t\tboolean useMockReceiver, boolean loadSpringXML)\n\t\tthrows Exception {\n\n\t\t_initialize(loadSpringXML);\n\n\t\tClusterExecutorImpl clusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\tclusterExecutorImpl.afterPropertiesSet();\n\n\t\tclusterExecutorImpl.setShortcutLocalMethod(true);\n\n\t\tif (useMockReceiver) {\n\t\t\tChannel channel = clusterExecutorImpl.getControlChannel();\n\n\t\t\tchannel.setReceiver(\n\t\t\t\tnew MockClusterRequestReceiver(clusterExecutorImpl));\n\t\t}\n\n\t\tclusterExecutorImpl.initialize();\n\n\t\treturn clusterExecutorImpl;\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateView(\n\t\tClusterExecutorImpl localClusterExecutorImpl,\n\t\tClusterExecutorImpl... remoteClusterExecutorImpls) {\n\n\t\tfinal JChannel localJChannel =\n\t\t\tlocalClusterExecutorImpl.getControlChannel();\n\n\t\torg.jgroups.Address address = localJChannel.getAddress();\n\n\t\tList<org.jgroups.Address> addresses =\n\t\t\tnew ArrayList<org.jgroups.Address>();\n\n\t\taddresses.add(address);\n\n\t\tfor (ClusterExecutorImpl clusterExecutorImpl :\n\t\t\tremoteClusterExecutorImpls) {\n\n\t\t\tJChannel jChannel = clusterExecutorImpl.getControlChannel();\n\n\t\t\taddresses.add(jChannel.getAddress());\n\t\t}\n\n\t\tfinal View view = new View(\n\t\t\taddress, System.currentTimeMillis(), addresses);\n\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tReceiver receiver = localJChannel.getReceiver();\n\n\t\t\t\treceiver.viewAccepted(view);\n\t\t\t}\n\t\t}.start();\n\t}","id":76249,"modified_method":"protected void updateView(\n\t\tClusterExecutorImpl localClusterExecutorImpl,\n\t\tClusterExecutorImpl... remoteClusterExecutorImpls) {\n\n\t\tfinal JChannel localJChannel =\n\t\t\tlocalClusterExecutorImpl.getControlChannel();\n\n\t\torg.jgroups.Address jAddress = localJChannel.getAddress();\n\n\t\tList<org.jgroups.Address> jAddresses =\n\t\t\tnew ArrayList<org.jgroups.Address>();\n\n\t\tjAddresses.add(jAddress);\n\n\t\tfor (ClusterExecutorImpl clusterExecutorImpl :\n\t\t\t\tremoteClusterExecutorImpls) {\n\n\t\t\tJChannel jChannel = clusterExecutorImpl.getControlChannel();\n\n\t\t\tjAddresses.add(jChannel.getAddress());\n\t\t}\n\n\t\tfinal View view = new View(\n\t\t\tjAddress, System.currentTimeMillis(), jAddresses);\n\n\t\tnew Thread() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tReceiver receiver = localJChannel.getReceiver();\n\n\t\t\t\treceiver.viewAccepted(view);\n\t\t\t}\n\n\t\t}.start();\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void assertClusterEvent(\n\t\t\tClusterEvent clusterEvent,\n\t\t\tClusterEventType exceptedClusterEventType,\n\t\t\tClusterNode... expectedClusterNodes)\n\t\tthrows Exception {\n\n\t\tAssert.assertEquals(\n\t\t\texceptedClusterEventType, clusterEvent.getClusterEventType());\n\n\t\tList<ClusterNode> clusterNodes = clusterEvent.getClusterNodes();\n\n\t\tAssert.assertEquals(expectedClusterNodes.length, clusterNodes.size());\n\n\t\tfor (int i = 0; i < expectedClusterNodes.length; i++) {\n\t\t\tAssert.assertTrue(clusterNodes.contains(expectedClusterNodes[i]));\n\t\t}\n\t}","id":76250,"modified_method":"protected void assertClusterEvent(\n\t\t\tClusterEvent clusterEvent,\n\t\t\tClusterEventType exceptedClusterEventType,\n\t\t\tClusterNode... expectedClusterNodes)\n\t\tthrows Exception {\n\n\t\tAssert.assertEquals(\n\t\t\texceptedClusterEventType, clusterEvent.getClusterEventType());\n\n\t\tList<ClusterNode> clusterNodes = clusterEvent.getClusterNodes();\n\n\t\tAssert.assertEquals(expectedClusterNodes.length, clusterNodes.size());\n\n\t\tfor (ClusterNode expectedClusterNode : expectedClusterNodes) {\n\t\t\tAssert.assertTrue(clusterNodes.contains(expectedClusterNode));\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _initialize(boolean loadSpringXML) {\n\t\tif (_initialized) {\n\t\t\treturn;\n\t\t}\n\n\t\tcom.liferay.portal.kernel.util.PropsUtil.setProps(new PropsImpl());\n\n\t\tPortalUUIDUtil portalUUIDUtil = new PortalUUIDUtil();\n\n\t\tportalUUIDUtil.setPortalUUID(new PortalUUIDImpl());\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\tPortalExecutorManagerUtil portalExecutorManagerUtil =\n\t\t\tnew PortalExecutorManagerUtil();\n\n\t\tportalExecutorManagerUtil.setPortalExecutorManager(\n\t\t\tnew MockPortalExecutorManager());\n\n\t\tif (loadSpringXML) {\n\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\t\tPortletClassLoaderUtil.setClassLoader(classLoader);\n\n\t\t\tApplicationContext applicationContext =\n\t\t\t\tnew FileSystemXmlApplicationContext(\n\t\t\t\t\t\"portal-impl/test/unit/com/liferay/portal/cluster/\" +\n\t\t\t\t\t\t\"test-spring.xml\");\n\n\t\t\tBeanLocator beanLocator = new BeanLocatorImpl(\n\t\t\t\tclassLoader, applicationContext);\n\n\t\t\tPortalBeanLocatorUtil.setBeanLocator(beanLocator);\n\n\t\t\tPortletBeanLocatorUtil.setBeanLocator(\n\t\t\t\t_SERVLET_CONTEXT_NAME, beanLocator);\n\t\t}\n\n\t\tJDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterBase.class.getName(), Level.FINE);\n\n\t\t_initialized = true;\n\t}","id":76251,"modified_method":"private void _initialize(boolean loadSpringXML) {\n\t\tif (_initialized) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\tPortalUUIDUtil portalUUIDUtil = new PortalUUIDUtil();\n\n\t\tportalUUIDUtil.setPortalUUID(new PortalUUIDImpl());\n\n\t\tPropsUtil.setProps(new PropsImpl());\n\n\t\tPortalExecutorManagerUtil portalExecutorManagerUtil =\n\t\t\tnew PortalExecutorManagerUtil();\n\n\t\tportalExecutorManagerUtil.setPortalExecutorManager(\n\t\t\tnew MockPortalExecutorManager());\n\n\t\tif (loadSpringXML) {\n\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\n\t\t\tPortletClassLoaderUtil.setClassLoader(classLoader);\n\n\t\t\tApplicationContext applicationContext =\n\t\t\t\tnew FileSystemXmlApplicationContext(\n\t\t\t\t\t\"portal-impl/test/unit/com/liferay/portal/cluster/\" +\n\t\t\t\t\t\t\"test-spring.xml\");\n\n\t\t\tBeanLocator beanLocator = new BeanLocatorImpl(\n\t\t\t\tclassLoader, applicationContext);\n\n\t\t\tPortalBeanLocatorUtil.setBeanLocator(beanLocator);\n\n\t\t\tPortletBeanLocatorUtil.setBeanLocator(\n\t\t\t\tSERVLET_CONTEXT_NAME, beanLocator);\n\t\t}\n\n\t\tJDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterBase.class.getName(), Level.FINE);\n\n\t\t_initialized = true;\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void assertLogger(\n\t\tList<LogRecord> logRecords, String message, Class<?> exceptionClass) {\n\n\t\tif (message == null) {\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\n\t\t\treturn;\n\t\t}\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(message, logRecord.getMessage());\n\n\t\tif (exceptionClass == null) {\n\t\t\tAssert.assertNull(logRecord.getThrown());\n\t\t}\n\t\telse {\n\t\t\tAssert.assertEquals(\n\t\t\t\texceptionClass, logRecord.getThrown().getClass());\n\t\t}\n\n\t\tlogRecords.clear();\n\t}","id":76252,"modified_method":"protected void assertLogger(\n\t\tList<LogRecord> logRecords, String message, Class<?> exceptionClass) {\n\n\t\tif (message == null) {\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\n\t\t\treturn;\n\t\t}\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(message, logRecord.getMessage());\n\n\t\tif (exceptionClass == null) {\n\t\t\tAssert.assertNull(logRecord.getThrown());\n\t\t}\n\t\telse {\n\t\t\tThrowable throwable = logRecord.getThrown();\n\n\t\t\tAssert.assertEquals(exceptionClass, throwable.getClass());\n\t\t}\n\n\t\tlogRecords.clear();\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByLocalMethod3() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tString timestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_3, timestamp);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), destAddress,\n\t\t\t\ttimestamp);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76253,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByLocalMethod3() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod3MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\ttimestamp);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByLocalMethod1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tString destClusterId =\n\t\t\t\tclusterExecutorImpl.getLocalClusterNode().getClusterNodeId();\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_1, \"\");\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destClusterId);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(), null,\n\t\t\t\tdestAddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76254,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByLocalMethod1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, StringPool.BLANK);\n\n\t\t\tClusterNode clusterNode = clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, clusterNode.getClusterNodeId());\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(), null,\n\t\t\t\taddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByLocalMethod2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(_TEST_METHOD_KEY_2);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), destAddress,\n\t\t\t\t\"Return value is not serializable\");\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76255,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByLocalMethod2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod2MethodKey);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\t\"Return value is not serializable\");\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByShortcutMethod() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(true, false);\n\n\t\t\tMockClusterRequestReceiver mockClusterRequestReceiver =\n\t\t\t\t(MockClusterRequestReceiver)\n\t\t\t\t\tclusterExecutorImpl.getControlChannel().getReceiver();\n\n\t\t\tClusterRequest localClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tClusterMessageType.NOTIFY,\n\t\t\t\tlocalClusterRequest.getClusterMessageType());\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\t//Test when shortcutLocalMethod is false\n\n\t\t\tString timestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tclusterExecutorImpl.setShortcutLocalMethod(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tlocalClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tClusterMessageType.EXECUTE,\n\t\t\t\tlocalClusterRequest.getClusterMessageType());\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, destAddress);\n\n\t\t\t//Test when shortcutLocalMethod is true\n\n\t\t\ttimestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tclusterExecutorImpl.setShortcutLocalMethod(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tlocalClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertNull(localClusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, destAddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76256,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByShortcutMethod() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(true, false);\n\n\t\t\tChannel channel = clusterExecutorImpl.getControlChannel();\n\n\t\t\tMockClusterRequestReceiver mockClusterRequestReceiver =\n\t\t\t\t(MockClusterRequestReceiver)channel.getReceiver();\n\n\t\t\tClusterRequest localClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tClusterMessageType.NOTIFY,\n\t\t\t\tlocalClusterRequest.getClusterMessageType());\n\n\t\t\t// shortcutLocalMethod is false\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterExecutorImpl.setShortcutLocalMethod(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tlocalClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tClusterMessageType.EXECUTE,\n\t\t\t\tlocalClusterRequest.getClusterMessageType());\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\n\t\t\t// shortcutLocalMethod is true\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(testMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterExecutorImpl.setShortcutLocalMethod(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tlocalClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertNull(localClusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testPortalPortConfigured1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\tupdateView(clusterExecutorImpl1);\n\n\t\t\tclusterEvent = mockClusterEventListener.waitDepartMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.DEPART, clusterNode2);\n\n\t\t\tAssert.assertEquals(-1, clusterNode2.getPort());\n\n\t\t\tint newPort = 80;\n\n\t\t\tclusterExecutorImpl2.portalPortConfigured(newPort);\n\n\t\t\tAssert.assertEquals(newPort, clusterNode2.getPort());\n\n\t\t\tclusterEvent = mockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76257,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testPortalPortConfigured1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\tupdateView(clusterExecutorImpl1);\n\n\t\t\tclusterEvent = mockClusterEventListener.waitDepartMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.DEPART, clusterNode2);\n\n\t\t\tAssert.assertEquals(-1, clusterNode2.getPort());\n\n\t\t\tclusterExecutorImpl2.portalPortConfigured(80);\n\n\t\t\tAssert.assertEquals(80, clusterNode2.getPort());\n\n\t\t\tclusterEvent = mockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteBySkipLocal() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\t//Test when skipLocal is false\n\n\t\t\tString timestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tclusterRequest.setSkipLocal(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, destAddress);\n\n\t\t\t//Test when skipLocal is true\n\n\t\t\ttimestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tclusterRequest.setSkipLocal(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tAssert.assertEquals(0, futureClusterResponses.get().size());\n\t\t\tAssert.assertFalse(TestBean.TIMESTAMP.equals(timestamp));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76258,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteBySkipLocal() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\t// skipLocal is false\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setSkipLocal(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\n\t\t\t// skipLocal is true\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(testMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setSkipLocal(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tAssert.assertEquals(0, futureClusterResponses.get().size());\n\t\t\tAssert.assertFalse(TestBean.TIMESTAMP.equals(timestamp));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class, InetAddressUtilExceptionAdvice.class,\n\t\t\tJChannelExceptionAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testErrorlogAndExceptions() throws Exception {\n\t\tJDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterBase.class.getName(), Level.FINE);\n\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tcom.liferay.portal.kernel.util.PropsUtil.setProps(new PropsImpl());\n\n\t\t\tPortalUUIDUtil portalUUIDUtil = new PortalUUIDUtil();\n\n\t\t\tportalUUIDUtil.setPortalUUID(new PortalUUIDImpl());\n\n\t\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\t\tPortalExecutorManagerUtil portalExecutorManagerUtil =\n\t\t\t\tnew PortalExecutorManagerUtil();\n\n\t\t\tportalExecutorManagerUtil.setPortalExecutorManager(\n\t\t\t\tnew ClusterExecutorImplTest.MockPortalExecutorManager());\n\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterExecutorImpl.class.getName(), Level.SEVERE);\n\n\t\t\tclusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\t\tclusterExecutorImpl.initSystemProperties();\n\t\t\tclusterExecutorImpl.initChannels();\n\n\t\t\t//Initialization without bind address, failed.\n\t\t\tclusterExecutorImpl.initialize();\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to determine local network address\",\n\t\t\t\tException.class);\n\n\t\t\t//Initialization with bind address, successed.\n\t\t\tclusterExecutorImpl.initBindAddress();\n\t\t\tclusterExecutorImpl.initialize();\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send notify message\", Exception.class);\n\n\t\t\tclusterExecutorImpl.portalPortConfigured(80);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to determine configure node port\",\n\t\t\t\tException.class);\n\n\t\t\tClusterRequest clusterRequest =\n\t\t\t\tClusterRequest.createMulticastRequest(null);\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to send multicast request\", e.getMessage());\n\t\t\t}\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, new AddressImpl(new MockAddress()));\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to send unicast request\", e.getMessage());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76259,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class, InetAddressUtilExceptionAdvice.class,\n\t\t\tJChannelExceptionAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testErrorLogAndExceptions() throws Exception {\n\t\tJDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterBase.class.getName(), Level.FINE);\n\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\t\tPortalUUIDUtil portalUUIDUtil = new PortalUUIDUtil();\n\n\t\t\tportalUUIDUtil.setPortalUUID(new PortalUUIDImpl());\n\n\t\t\tPropsUtil.setProps(new PropsImpl());\n\n\t\t\tPortalExecutorManagerUtil portalExecutorManagerUtil =\n\t\t\t\tnew PortalExecutorManagerUtil();\n\n\t\t\tportalExecutorManagerUtil.setPortalExecutorManager(\n\t\t\t\tnew ClusterExecutorImplTest.MockPortalExecutorManager());\n\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterExecutorImpl.class.getName(), Level.SEVERE);\n\n\t\t\tclusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\t\tclusterExecutorImpl.initChannels();\n\t\t\tclusterExecutorImpl.initSystemProperties();\n\n\t\t\tclusterExecutorImpl.initialize();\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to determine local network address\",\n\t\t\t\tException.class);\n\n\t\t\tclusterExecutorImpl.initBindAddress();\n\n\t\t\tclusterExecutorImpl.initialize();\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send notify message\", Exception.class);\n\n\t\t\tclusterExecutorImpl.portalPortConfigured(80);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to determine configure node port\",\n\t\t\t\tException.class);\n\n\t\t\tClusterRequest clusterRequest =\n\t\t\t\tClusterRequest.createMulticastRequest(null);\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to send multicast request\", e.getMessage());\n\t\t\t}\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, new AddressImpl(new MockAddress()));\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to send unicast request\", e.getMessage());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByFireAndForget() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\t\tString timestamp = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\t//Test when fireAndForget flag is false\n\n\t\t\ttimestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tClusterRequest clusterRequest =\n\t\t\t\tClusterRequest.createMulticastRequest(methodHandler);\n\n\t\t\tclusterRequest.setFireAndForget(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, clusterExecutorImpl1.getClusterNodeAddresses());\n\n\t\t\t//Test when fireAndForget flag is true\n\n\t\t\ttimestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\t\tmethodHandler);\n\n\t\t\tclusterRequest.setFireAndForget(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl1.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tfutureClusterResponses.get(1000, TimeUnit.MILLISECONDS);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (TimeoutException e) {\n\t\t\tAssert.assertEquals(TestBean.TIMESTAMP, timestamp);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76260,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByFireAndForget() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\t\tString timestamp = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\t// fireAndForget is false\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tClusterRequest clusterRequest =\n\t\t\t\tClusterRequest.createMulticastRequest(methodHandler);\n\n\t\t\tclusterRequest.setFireAndForget(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, clusterExecutorImpl1.getClusterNodeAddresses());\n\n\t\t\t// fireAndForget is true\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(testMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\t\tmethodHandler);\n\n\t\t\tclusterRequest.setFireAndForget(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl1.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tfutureClusterResponses.get(1000, TimeUnit.MILLISECONDS);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (TimeoutException e) {\n\t\t\tAssert.assertEquals(TestBean.TIMESTAMP, timestamp);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testGetMethods2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode1 =\n\t\t\t\tclusterExecutorImpl1.getLocalClusterNode();\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\t\t\tAddress address1 =\n\t\t\t\tclusterExecutorImpl1.getLocalClusterNodeAddress();\n\t\t\tAddress address2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tAssert.assertNotNull(clusterNode1);\n\t\t\tAssert.assertNotNull(clusterNode2);\n\t\t\tAssert.assertNotNull(address1);\n\t\t\tAssert.assertNotNull(address2);\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\t//Test getClusterNodeAddresses\n\t\t\tList<Address> addresses =\n\t\t\t\tclusterExecutorImpl1.getClusterNodeAddresses();\n\n\t\t\tAssert.assertEquals(2, addresses.size());\n\t\t\tAssert.assertTrue(addresses.contains(address1));\n\t\t\tAssert.assertTrue(addresses.contains(address2));\n\n\t\t\t//Test getClusterNodes\n\t\t\tList<ClusterNode> clusterNodes =\n\t\t\t\tclusterExecutorImpl1.getClusterNodes();\n\n\t\t\tAssert.assertEquals(2, clusterNodes.size());\n\t\t\tAssert.assertTrue(clusterNodes.contains(clusterNode1));\n\t\t\tAssert.assertTrue(clusterNodes.contains(clusterNode2));\n\n\t\t\t//Test isClusterNodeAlive1\n\t\t\tboolean clusterNodeAlive = clusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\tclusterNode2.getClusterNodeId());\n\n\t\t\tAssert.assertTrue(clusterNodeAlive);\n\n\t\t\t//Test isClusterNodeAlive2\n\t\t\tclusterNodeAlive = clusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\taddress2);\n\n\t\t\tAssert.assertTrue(clusterNodeAlive);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76261,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testGetMethods2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode1 =\n\t\t\t\tclusterExecutorImpl1.getLocalClusterNode();\n\n\t\t\tAssert.assertNotNull(clusterNode1);\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tAssert.assertNotNull(clusterNode2);\n\n\t\t\tAddress address1 =\n\t\t\t\tclusterExecutorImpl1.getLocalClusterNodeAddress();\n\n\t\t\tAssert.assertNotNull(address1);\n\n\t\t\tAddress address2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tAssert.assertNotNull(address2);\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\tList<Address> addresses =\n\t\t\t\tclusterExecutorImpl1.getClusterNodeAddresses();\n\n\t\t\tAssert.assertEquals(2, addresses.size());\n\t\t\tAssert.assertTrue(addresses.contains(address1));\n\t\t\tAssert.assertTrue(addresses.contains(address2));\n\n\t\t\tList<ClusterNode> clusterNodes =\n\t\t\t\tclusterExecutorImpl1.getClusterNodes();\n\n\t\t\tAssert.assertEquals(2, clusterNodes.size());\n\t\t\tAssert.assertTrue(clusterNodes.contains(clusterNode1));\n\t\t\tAssert.assertTrue(clusterNodes.contains(clusterNode2));\n\n\t\t\tboolean clusterNodeAlive = clusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\tclusterNode2.getClusterNodeId());\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tclusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\t\tclusterNode2.getClusterNodeId()));\n\n\t\t\tclusterNodeAlive = clusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\taddress2);\n\n\t\t\tAssert.assertTrue(clusterNodeAlive);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testClusterEventListener2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\t\tClusterExecutorImpl.class, \"_clusterEventListeners\");\n\n\t\t\tCopyOnWriteArrayList<ClusterEventListener> listeners =\n\t\t\t\t(CopyOnWriteArrayList<ClusterEventListener>)\n\t\t\t\t\tfield.get(clusterExecutorImpl);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tlisteners.add(mockClusterEventListener);\n\n\t\t\tAssert.assertEquals(1, listeners.size());\n\n\t\t\t//Test add\n\t\t\tclusterExecutorImpl.addClusterEventListener(\n\t\t\t\tnew MockClusterEventListener());\n\n\t\t\tAssert.assertEquals(1, listeners.size());\n\n\t\t\t//Test remove\n\t\t\tclusterExecutorImpl.removeClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tAssert.assertEquals(1, listeners.size());\n\n\t\t\t//Test get\n\t\t\tList<ClusterEventListener> clusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertTrue(clusterEventListeners.isEmpty());\n\n\t\t\t//Test set\n\t\t\tclusterEventListeners = new ArrayList<ClusterEventListener>();\n\n\t\t\tclusterEventListeners.add(new MockClusterEventListener());\n\n\t\t\tclusterExecutorImpl.setClusterEventListeners(clusterEventListeners);\n\n\t\t\tAssert.assertEquals(1, listeners.size());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76262,"modified_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testClusterEventListener2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\t\tClusterExecutorImpl.class, \"_clusterEventListeners\");\n\n\t\t\tList<ClusterEventListener> fieldClusterEventListeners =\n\t\t\t\t(List<ClusterEventListener>)field.get(clusterExecutorImpl);\n\n\t\t\tClusterEventListener clusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tfieldClusterEventListeners.add(clusterEventListener);\n\n\t\t\tAssert.assertEquals(1, fieldClusterEventListeners.size());\n\n\t\t\t// Add\n\n\t\t\tclusterExecutorImpl.addClusterEventListener(\n\t\t\t\tnew MockClusterEventListener());\n\n\t\t\tAssert.assertEquals(1, fieldClusterEventListeners.size());\n\n\t\t\t// Remove\n\n\t\t\tclusterExecutorImpl.removeClusterEventListener(\n\t\t\t\tclusterEventListener);\n\n\t\t\tAssert.assertEquals(1, fieldClusterEventListeners.size());\n\n\t\t\t// Get\n\n\t\t\tList<ClusterEventListener> clusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertTrue(clusterEventListeners.isEmpty());\n\n\t\t\t// Set\n\n\t\t\tclusterEventListeners = new ArrayList<ClusterEventListener>();\n\n\t\t\tclusterEventListeners.add(new MockClusterEventListener());\n\n\t\t\tclusterExecutorImpl.setClusterEventListeners(clusterEventListeners);\n\n\t\t\tAssert.assertEquals(1, fieldClusterEventListeners.size());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tEnableClusterExecutorDebugAdvice.class, EnableLiveUsersAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testClusterEventListener1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tList<ClusterEventListener> clusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(2, clusterEventListeners.size());\n\n\t\t\t//Test add\n\t\t\tClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(3, clusterEventListeners.size());\n\n\t\t\t//Test remove\n\t\t\tclusterExecutorImpl.removeClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(2, clusterEventListeners.size());\n\n\t\t\t//Test set\n\t\t\tclusterEventListeners = new ArrayList<ClusterEventListener>();\n\n\t\t\tclusterEventListeners.add(mockClusterEventListener);\n\n\t\t\tclusterExecutorImpl.setClusterEventListeners(clusterEventListeners);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(3, clusterEventListeners.size());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76263,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tEnableClusterExecutorDebugAdvice.class, EnableLiveUsersAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testClusterEventListener1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tList<ClusterEventListener> clusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(2, clusterEventListeners.size());\n\n\t\t\t// Add\n\n\t\t\tClusterEventListener clusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl.addClusterEventListener(clusterEventListener);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(3, clusterEventListeners.size());\n\n\t\t\t// Remove\n\n\t\t\tclusterExecutorImpl.removeClusterEventListener(\n\t\t\t\tclusterEventListener);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(2, clusterEventListeners.size());\n\n\t\t\t// Set\n\n\t\t\tclusterEventListeners = new ArrayList<ClusterEventListener>();\n\n\t\t\tclusterEventListeners.add(clusterEventListener);\n\n\t\t\tclusterExecutorImpl.setClusterEventListeners(clusterEventListeners);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(3, clusterEventListeners.size());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByLocalMethod4() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, destAddress);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), destAddress,\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76264,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteByLocalMethod4() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteWithCallBack1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tString timestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tMockClusterResponseCallback mockClusterResponseCallback =\n\t\t\t\tnew MockClusterResponseCallback();\n\n\t\t\tclusterExecutorImpl.execute(\n\t\t\t\tclusterRequest, mockClusterResponseCallback);\n\n\t\t\tClusterNodeResponses clusterNodeResponses =\n\t\t\t\tmockClusterResponseCallback.waitMessage();\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tclusterNodeResponses, clusterRequest.getUuid(), timestamp,\n\t\t\t\tdestAddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76265,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testExecuteWithCallBack1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tMockClusterResponseCallback mockClusterResponseCallback =\n\t\t\t\tnew MockClusterResponseCallback();\n\n\t\t\tclusterExecutorImpl.execute(\n\t\t\t\tclusterRequest, mockClusterResponseCallback);\n\n\t\t\tClusterNodeResponses clusterNodeResponses =\n\t\t\t\tmockClusterResponseCallback.waitMessage();\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tclusterNodeResponses, clusterRequest.getUuid(), timestamp,\n\t\t\t\taddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processClusterRequest(\n\t\tClusterRequest clusterRequest, Address sourceAddress) {\n\n\t\tClusterMessageType clusterMessageType =\n\t\t\tclusterRequest.getClusterMessageType();\n\n\t\tif (clusterMessageType.equals(ClusterMessageType.NOTIFY) ||\n\t\t\tclusterMessageType.equals(ClusterMessageType.UPDATE)) {\n\n\t\t\t_clusterExecutorImpl.memberJoined(\n\t\t\t\tsourceAddress, clusterRequest.getOriginatingClusterNode());\n\n\t\t\tif (clusterMessageType.equals(ClusterMessageType.NOTIFY)) {\n\t\t\t\thandleResponse(sourceAddress, clusterRequest, null, null);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tMethodHandler methodHandler = clusterRequest.getMethodHandler();\n\n\t\tObject returnValue = null;\n\t\tException exception = null;\n\n\t\tif (methodHandler != null) {\n\t\t\ttry {\n\t\t\t\tClusterInvokeThreadLocal.setEnabled(false);\n\n\t\t\t\treturnValue = invoke(\n\t\t\t\t\tclusterRequest.getServletContextName(),\n\t\t\t\t\tclusterRequest.getBeanIdentifier(), methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\texception = e;\n\n\t\t\t\t_log.error(\"Failed to invoke method \" + methodHandler, e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tClusterInvokeThreadLocal.setEnabled(true);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texception = new ClusterException(\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\n\t\tif (!clusterRequest.isFireAndForget()) {\n\t\t\thandleResponse(\n\t\t\t\tsourceAddress, clusterRequest, returnValue, exception);\n\t\t}\n\t}","id":76266,"modified_method":"protected void processClusterRequest(\n\t\tClusterRequest clusterRequest, Address sourceAddress) {\n\n\t\tClusterMessageType clusterMessageType =\n\t\t\tclusterRequest.getClusterMessageType();\n\n\t\tif (clusterMessageType.equals(ClusterMessageType.NOTIFY) ||\n\t\t\tclusterMessageType.equals(ClusterMessageType.UPDATE)) {\n\n\t\t\t_clusterExecutorImpl.memberJoined(\n\t\t\t\tsourceAddress, clusterRequest.getOriginatingClusterNode());\n\n\t\t\tif (clusterMessageType.equals(ClusterMessageType.NOTIFY)) {\n\t\t\t\thandleResponse(sourceAddress, clusterRequest, null, null);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tMethodHandler methodHandler = clusterRequest.getMethodHandler();\n\n\t\tObject returnValue = null;\n\t\tException exception = null;\n\n\t\tif (methodHandler != null) {\n\t\t\ttry {\n\t\t\t\tClusterInvokeThreadLocal.setEnabled(false);\n\n\t\t\t\treturnValue = invoke(\n\t\t\t\t\tclusterRequest.getServletContextName(),\n\t\t\t\t\tclusterRequest.getBeanIdentifier(), methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\texception = e;\n\n\t\t\t\t_log.error(\"Unable to invoke method \" + methodHandler, e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tClusterInvokeThreadLocal.setEnabled(true);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texception = new ClusterException(\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\n\t\tif (!clusterRequest.isFireAndForget()) {\n\t\t\thandleResponse(\n\t\t\t\tsourceAddress, clusterRequest, returnValue, exception);\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void handleResponse(\n\t\tAddress address, ClusterRequest clusterRequest, Object returnValue,\n\t\tException exception) {\n\n\t\tClusterNodeResponse clusterNodeResponse =\n\t\t\t_clusterExecutorImpl.generateClusterNodeResponse(\n\t\t\t\tclusterRequest, returnValue, exception);\n\n\t\tChannel controlChannel = _clusterExecutorImpl.getControlChannel();\n\n\t\ttry {\n\t\t\tcontrolChannel.send(\n\t\t\t\t(org.jgroups.Address)address.getRealAddress(),\n\t\t\t\tclusterNodeResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\n\t\t\t\t\"Unable to send response message \" + clusterNodeResponse, e);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_log.error(t, t);\n\t\t}\n\t}","id":76267,"modified_method":"protected void handleResponse(\n\t\tAddress address, ClusterRequest clusterRequest, Object returnValue,\n\t\tException exception) {\n\n\t\tClusterNodeResponse clusterNodeResponse =\n\t\t\t_clusterExecutorImpl.generateClusterNodeResponse(\n\t\t\t\tclusterRequest, returnValue, exception);\n\n\t\tChannel channel = _clusterExecutorImpl.getControlChannel();\n\n\t\ttry {\n\t\t\tchannel.send(\n\t\t\t\t(org.jgroups.Address)address.getRealAddress(),\n\t\t\t\tclusterNodeResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\n\t\t\t\t\"Unable to send response message \" + clusterNodeResponse, e);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_log.error(t, t);\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke8() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, true);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, true);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tString timestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tclusterRequest.setServletContextName(_SERVLET_CONTEXT_NAME);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, destAddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76268,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke8() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, true);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, true);\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setServletContextName(SERVLET_CONTEXT_NAME);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke5() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, destAddress);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), destAddress,\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76269,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke5() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke9() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, true);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, true);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\tnew MethodKey(TestBean.class.getName(), \"nonExisitedMethod\"));\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tclusterRequest.setServletContextName(_SERVLET_CONTEXT_NAME);\n\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterRequestReceiver.class.getName(), Level.SEVERE);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), destAddress,\n\t\t\t\tnull);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Failed to invoke method \" + methodHandler,\n\t\t\t\tNoSuchMethodException.class);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76270,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke9() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, true);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, true);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\tnew MethodKey(TestBean.class.getName(), \"nonexistentMethod\"));\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setServletContextName(SERVLET_CONTEXT_NAME);\n\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterRequestReceiver.class.getName(), Level.SEVERE);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\tnull);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to invoke method \" + methodHandler,\n\t\t\t\tNoSuchMethodException.class);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke6() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, true);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, true);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(_TEST_METHOD_KEY_4);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tclusterRequest.setBeanIdentifier(_BEAN_IDENTIFIER);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\tSERIALIZABLE_RETRUN_VALUE, destAddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76271,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke6() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, true);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, true);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod4MethodKey);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setBeanIdentifier(BEAN_IDENTIFIER);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\tSERIALIZABLE_RETRUN_VALUE, address);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke4() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tString timestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_3, timestamp);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tJDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterRequestReceiver.class.getName(), Level.SEVERE);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), destAddress,\n\t\t\t\ttimestamp);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76272,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke4() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod3MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tJDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tClusterRequestReceiver.class.getName(), Level.SEVERE);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\ttimestamp);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke7() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, true);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, true);\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(_TEST_METHOD_KEY_4);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tclusterRequest.setBeanIdentifier(_BEAN_IDENTIFIER);\n\t\t\tclusterRequest.setServletContextName(_SERVLET_CONTEXT_NAME);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\tSERIALIZABLE_RETRUN_VALUE, destAddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76273,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke7() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, true);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, true);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod4MethodKey);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setBeanIdentifier(BEAN_IDENTIFIER);\n\t\t\tclusterRequest.setServletContextName(SERVLET_CONTEXT_NAME);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\tSERIALIZABLE_RETRUN_VALUE, address);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_1, \"\");\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(), null,\n\t\t\t\tdestAddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76274,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, StringPool.BLANK);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(), null,\n\t\t\t\taddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke3() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(_TEST_METHOD_KEY_2);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), destAddress,\n\t\t\t\t\"Return value is not serializable\");\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76275,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke3() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod2MethodKey);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\t\"Return value is not serializable\");\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress destAddress =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tString timestamp = Long.toString(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\t_TEST_METHOD_KEY_1, timestamp);\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, destAddress);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, destAddress);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":76276,"modified_method":"@AdviseWith(adviceClasses = {EnableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testInvoke2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"62cc9b2a92d2854a74863bfc71fe13861f26ab6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Transactional(isolation = Isolation.SERIALIZABLE)\n\tpublic Lock lock(\n\t\t\tString className, String key, String owner,\n\t\t\tboolean retrieveFromCache, boolean replaceOldLock,\n\t\t\tboolean[] isNewLock, String oldOwner)\n\t\tthrows SystemException {\n\n\t\tif (isNewLock == null || isNewLock.length == 0) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tLock lock = lockPersistence.fetchByC_K(\n\t\t\tclassName, key, retrieveFromCache);\n\n\t\tif (lock != null) {\n\t\t\tif (lock.isExpired() || replaceOldLock) {\n\t\t\t\tif (!lock.getOwner().equals(oldOwner)) {\n\t\t\t\t\treturn lock;\n\t\t\t\t}\n\n\t\t\t\tlockPersistence.remove(lock);\n\n\t\t\t\tlock = null;\n\t\t\t}\n\t\t\telse if (!lock.getOwner().equals(owner)) {\n\t\t\t\treturn lock;\n\t\t\t}\n\t\t}\n\n\t\tif (lock == null) {\n\t\t\tlong lockId = counterLocalService.increment();\n\n\t\t\tlock = lockPersistence.create(lockId);\n\n\t\t\tlock.setCreateDate(new Date());\n\t\t\tlock.setClassName(className);\n\t\t\tlock.setKey(key);\n\t\t\tlock.setOwner(owner);\n\n\t\t\tlockPersistence.update(lock, false);\n\t\t}\n\n\t\tisNewLock[0] = true;\n\n\t\treturn lock;\n\t}","id":76277,"modified_method":"@Transactional(isolation = Isolation.SERIALIZABLE)\n\tpublic Lock lock(\n\t\t\tString className, String key, String oldOwner, String newOwner,\n\t\t\tboolean retrieveFromCache, boolean replaceOldLock)\n\t\tthrows SystemException {\n\n\t\tLock lock = lockPersistence.fetchByC_K(\n\t\t\tclassName, key, retrieveFromCache);\n\n\t\tif (lock != null) {\n\t\t\tString owner = lock.getOwner();\n\n\t\t\tif (lock.isExpired() || replaceOldLock) {\n\t\t\t\tif (!owner.equals(oldOwner)) {\n\t\t\t\t\treturn lock;\n\t\t\t\t}\n\n\t\t\t\tlockPersistence.remove(lock);\n\n\t\t\t\tlock = null;\n\t\t\t}\n\t\t\telse if (!owner.equals(newOwner)) {\n\t\t\t\treturn lock;\n\t\t\t}\n\t\t}\n\n\t\tif (lock == null) {\n\t\t\tlong lockId = counterLocalService.increment();\n\n\t\t\tlock = lockPersistence.create(lockId);\n\n\t\t\tlock.setCreateDate(new Date());\n\t\t\tlock.setClassName(className);\n\t\t\tlock.setKey(key);\n\t\t\tlock.setOwner(newOwner);\n\n\t\t\tlockPersistence.update(lock, false);\n\t\t}\n\n\t\treturn lock;\n\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static com.liferay.portal.model.Lock lock(\n\t\tjava.lang.String className, java.lang.String key,\n\t\tjava.lang.String owner, boolean retrieveFromCache,\n\t\tboolean replaceOldLock, boolean[] isNewLock, java.lang.String oldOwner)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService()\n\t\t\t\t   .lock(className, key, owner, retrieveFromCache,\n\t\t\treplaceOldLock, isNewLock, oldOwner);\n\t}","id":76278,"modified_method":"public static com.liferay.portal.model.Lock lock(\n\t\tjava.lang.String className, java.lang.String key,\n\t\tjava.lang.String oldOwner, java.lang.String newOwner,\n\t\tboolean retrieveFromCache, boolean replaceOldLock)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService()\n\t\t\t\t   .lock(className, key, oldOwner, newOwner, retrieveFromCache,\n\t\t\treplaceOldLock);\n\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public com.liferay.portal.model.Lock lock(java.lang.String className,\n\t\tjava.lang.String key, java.lang.String owner,\n\t\tboolean retrieveFromCache, boolean replaceOldLock, boolean[] isNewLock,\n\t\tjava.lang.String oldOwner)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn _lockLocalService.lock(className, key, owner, retrieveFromCache,\n\t\t\treplaceOldLock, isNewLock, oldOwner);\n\t}","id":76279,"modified_method":"public com.liferay.portal.model.Lock lock(java.lang.String className,\n\t\tjava.lang.String key, java.lang.String oldOwner,\n\t\tjava.lang.String newOwner, boolean retrieveFromCache,\n\t\tboolean replaceOldLock)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException {\n\t\treturn _lockLocalService.lock(className, key, oldOwner, newOwner,\n\t\t\tretrieveFromCache, replaceOldLock);\n\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void start() throws SchedulerException {\n\t\ttry {\n\t\t\tif (PropsValues.CLUSTER_LINK_ENABLED) {\n\t\t\t\t_memeorySchedulerClusterEventListener =\n\t\t\t\t\tnew MemorySchedulerClusterEventListener();\n\n\t\t\t\tClusterExecutorUtil.addClusterEventListener(\n\t\t\t\t\t_memeorySchedulerClusterEventListener);\n\n\t\t\t\tlockMemorySchedulerCluster(false, null);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to start scheduler\", e);\n\t\t}\n\n\t\t_schedulerEngine.start();\n\t}","id":76280,"modified_method":"public void start() throws SchedulerException {\n\t\ttry {\n\t\t\tif (PropsValues.CLUSTER_LINK_ENABLED) {\n\t\t\t\t_memorySchedulerClusterEventListener =\n\t\t\t\t\tnew MemorySchedulerClusterEventListener();\n\n\t\t\t\tClusterExecutorUtil.addClusterEventListener(\n\t\t\t\t\t_memorySchedulerClusterEventListener);\n\n\t\t\t\tlockMemorySchedulerCluster(false, null);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to start scheduler\", e);\n\t\t}\n\n\t\t_schedulerEngine.start();\n\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateMemorySchedulerClusterMaster() throws SchedulerException {\n\t\ttry {\n\t\t\tLock lock = lockMemorySchedulerCluster(false, null);\n\n\t\t\tif (ClusterExecutorUtil.isClusterNodeAlive(lock.getOwner())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlockMemorySchedulerCluster(true, lock.getOwner());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to updae memory scheduler cluster master\", e);\n\t\t}\n\t}","id":76281,"modified_method":"public void updateMemorySchedulerClusterMaster() throws SchedulerException {\n\t\ttry {\n\t\t\tLock lock = lockMemorySchedulerCluster(false, null);\n\n\t\t\tif (ClusterExecutorUtil.isClusterNodeAlive(lock.getOwner())) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlockMemorySchedulerCluster(true, lock.getOwner());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to update memory scheduler cluster master\", e);\n\t\t}\n\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void shutdown() throws SchedulerException {\n\t\ttry {\n\t\t\tif (PropsValues.CLUSTER_LINK_ENABLED) {\n\t\t\t\tClusterExecutorUtil.removeClusterEventListener(\n\t\t\t\t\t_memeorySchedulerClusterEventListener);\n\n\t\t\t\tLockLocalServiceUtil.unlock(\n\t\t\t\t\t_classNameForLock, _classNameForLock, _localClusterNodeId,\n\t\t\t\t\t_retrieveFromCache);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to shutdown scheduler\", e);\n\t\t}\n\n\t\t_schedulerEngine.shutdown();\n\t}","id":76282,"modified_method":"public void shutdown() throws SchedulerException {\n\t\ttry {\n\t\t\tif (PropsValues.CLUSTER_LINK_ENABLED) {\n\t\t\t\tClusterExecutorUtil.removeClusterEventListener(\n\t\t\t\t\t_memorySchedulerClusterEventListener);\n\n\t\t\t\tLockLocalServiceUtil.unlock(\n\t\t\t\t\t_classNameForLock, _classNameForLock, _localClusterNodeId,\n\t\t\t\t\t_retrieveFromCache);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to shutdown scheduler\", e);\n\t\t}\n\n\t\t_schedulerEngine.shutdown();\n\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processClusterEvent(ClusterEvent clusterEvent) {\n\t\t\tClusterEventType clusterEventType =\n\t\t\t\tclusterEvent.getClusterEventType();\n\n\t\t\tif (!clusterEventType.equals(ClusterEventType.DEPART)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tupdateMemorySchedulerClusterMaster();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"Update memeory scheduler cluster lock failed\",\n\t\t\t\t\t\tex);\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":76283,"modified_method":"public void processClusterEvent(ClusterEvent clusterEvent) {\n\t\t\tClusterEventType clusterEventType =\n\t\t\t\tclusterEvent.getClusterEventType();\n\n\t\t\tif (!clusterEventType.equals(ClusterEventType.DEPART)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tupdateMemorySchedulerClusterMaster();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to update memory scheduler cluster lock\", e);\n\t\t\t}\n\t\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Lock lockMemorySchedulerCluster(\n\t\t\tboolean replaceOldLock, String oldOwner)\n\t\tthrows Exception {\n\n\t\tif (_localClusterNodeId == null) {\n\t\t\t_localClusterNodeId =\n\t\t\t\tClusterExecutorUtil.getLocalClusterNode().getClusterNodeId();\n\t\t}\n\n\t\tboolean[] isNewLock = new boolean[1];\n\n\t\tLock lock = LockLocalServiceUtil.lock(\n\t\t\t_classNameForLock, _classNameForLock, _localClusterNodeId,\n\t\t\t_retrieveFromCache, replaceOldLock, isNewLock, oldOwner);\n\n\t\treturn lock;\n\t}","id":76284,"modified_method":"protected Lock lockMemorySchedulerCluster(\n\t\t\tboolean replaceOldLock, String oldOwner)\n\t\tthrows Exception {\n\n\t\tif (_localClusterNodeId == null) {\n\t\t\tClusterNode clusterNode = ClusterExecutorUtil.getLocalClusterNode();\n\n\t\t\t_localClusterNodeId = clusterNode.getClusterNodeId();\n\t\t}\n\n\t\tLock lock = LockLocalServiceUtil.lock(\n\t\t\t_classNameForLock, _classNameForLock, oldOwner, _localClusterNodeId,\n\t\t\t_retrieveFromCache, replaceOldLock);\n\n\t\treturn lock;\n\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isMemorySchedulerClusterLockOwner(Lock lock)\n\t\tthrows Exception {\n\n\t\tString localClusterNodeId =\n\t\t\tClusterExecutorUtil.getLocalClusterNode().getClusterNodeId();\n\n\t\tif (localClusterNodeId.equals(lock.getOwner())) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":76285,"modified_method":"protected boolean isMemorySchedulerClusterLockOwner(Lock lock)\n\t\tthrows Exception {\n\n\t\tClusterNode clusterNode = ClusterExecutorUtil.getLocalClusterNode();\n\n\t\tString localClusterNodeId = clusterNode.getClusterNodeId();\n\n\t\tif (localClusterNodeId.equals(lock.getOwner())) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"7272f9718f4776e83c8c24c4ee1b776ca0695707","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected final DomElement getMergedRoot(DomElement element) {\n    Set<XmlFile> files = getFilesToMerge(element);\n\n    final XmlFile xmlFile = element.getRoot().getFile();\n    if (xmlFile != null) {\n      files = new HashSet<XmlFile>(files);\n      files.add(xmlFile);\n    }\n\n    ArrayList<T> roots = new ArrayList<T>(files.size());\n    for (XmlFile file: files) {\n      roots.add(element.getManager().<T>getFileElement(file).getRootElement());\n    }\n\n    if (roots.size() == 1) {\n      return roots.iterator().next();\n    }\n\n    if (myMerger == null) {\n      myMerger = element.getManager().createModelMerger();\n    }\n    return myMerger.mergeModels(getRootElementClass(), roots);\n  }","id":76286,"modified_method":"protected final DomElement getMergedRoot(DomElement element) {\n    Set<XmlFile> files = getFilesToMerge(element);\n\n    final XmlFile xmlFile = element.getRoot().getFile();\n    if (xmlFile != null) {\n      files = new HashSet<XmlFile>(files);\n      files.add(xmlFile);\n    }\n\n    ArrayList<T> roots = new ArrayList<T>(files.size());\n    for (XmlFile file: files) {\n      final DomFileElement<T> fileElement = element.getManager().getFileElement(file);\n      if (fileElement != null) {\n        roots.add(fileElement.getRootElement());\n      }\n    }\n\n    if (roots.size() == 1) {\n      return roots.iterator().next();\n    }\n\n    if (myMerger == null) {\n      myMerger = element.getManager().createModelMerger();\n    }\n    return myMerger.mergeModels(getRootElementClass(), roots);\n  }","commit_id":"302a468d4ee0ef79a863ea63346865c480a47ff6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Module getModule() {\n    return DomUtil.getFileElement(getInvocationElement()).getRootElement().getModule();\n  }","id":76287,"modified_method":"public Module getModule() {\n    final DomFileElement<DomElement> fileElement = DomUtil.getFileElement(getInvocationElement());\n    if (fileElement == null) {\n      final XmlElement xmlElement = getInvocationElement().getXmlElement();\n      return xmlElement == null? null : ModuleUtil.findModuleForPsiElement(xmlElement);\n    }\n    return fileElement.getRootElement().getModule();\n  }","commit_id":"21ca5533e07a18e8d671224a31c27ff28b8b5174","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void registerExtensions(@NotNull AntDomElement antDomElement, @NotNull DomExtensionsRegistrar registrar) {\n    final XmlElement xmlElement = antDomElement.getXmlElement();\n    if (xmlElement instanceof XmlTag) {\n\n      //final AntDomProject antProject = antDomElement.getParentOfType(AntDomProject.class, false);\n      //assert antProject != null;\n      //final ReflectedProject reflected = ReflectedProject.getProject(antProject.getClassLoader());\n\n      final Set<String> names = new HashSet<String>();\n      for (XmlTag tag : ((XmlTag)xmlElement).getSubTags()) {\n        names.add(tag.getName());\n      }\n      final DomGenericInfo genericInfo = antDomElement.getGenericInfo();\n      for (String name : names) {\n        if (genericInfo.getCollectionChildDescription(name) == null) { // not defined yet\n          registrar.registerCollectionChildrenExtension(new XmlName(name), AntDomElement.class);\n        }\n      }\n    }\n  }","id":76288,"modified_method":"public void registerExtensions(@NotNull AntDomElement antDomElement, @NotNull DomExtensionsRegistrar registrar) {\n    final XmlElement xmlElement = antDomElement.getXmlElement();\n    if (xmlElement instanceof XmlTag) {\n      final XmlTag xmlTag = (XmlTag)xmlElement;\n      final String tagName = xmlTag.getName(); // todo: support namespace\n\n      final ReflectedProject reflected = ReflectedProject.getProject(antDomElement.getAntProject().getClassLoader());\n\n      final Set<String> names = new HashSet<String>();\n      for (XmlTag tag : xmlTag.getSubTags()) {\n        names.add(tag.getName());\n      }\n      final DomGenericInfo genericInfo = antDomElement.getGenericInfo();\n      for (String name : names) {\n        if (genericInfo.getCollectionChildDescription(name) == null) { // not defined yet\n          registrar.registerCollectionChildrenExtension(new XmlName(name), AntDomElement.class);\n        }\n      }\n    }\n  }","commit_id":"867df8ee3cd1848e9c8fd0cda1de1cbaf01c0554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isMyFile(@NotNull XmlFile file, @Nullable Module module) {\n    return super.isMyFile(file, module) && AntLanguageExtension.isAntFile(file);\n  }","id":76289,"modified_method":"public boolean isMyFile(@NotNull XmlFile file, @Nullable Module module) {\n    return super.isMyFile(file, module) && isAntFile(file);\n  }","commit_id":"867df8ee3cd1848e9c8fd0cda1de1cbaf01c0554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntDomFileDescription() {\n    super(AntDomProject.class, \"project\");\n  }","id":76290,"modified_method":"public AntDomFileDescription() {\n    super(AntDomProject.class, PROJECT_TAG_NAME);\n  }","commit_id":"867df8ee3cd1848e9c8fd0cda1de1cbaf01c0554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Attribute(\"default\")\n  public abstract GenericAttributeValue<String> getDefaultTargetName();","id":76291,"modified_method":"@Attribute(\"default\")\n  @Convert(value = AntDomTargetConverter.class)\n  public abstract GenericAttributeValue<String> getDefaultTarget();","commit_id":"867df8ee3cd1848e9c8fd0cda1de1cbaf01c0554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public final AntDomTarget getTarget(String name) {\n    for (AntDomTarget target : getTargets()) {\n      if (name.equals(target.getName().getValue())) {\n        return target;\n      }\n    }\n    return null;\n  }","id":76292,"modified_method":"@Nullable\n  public final AntDomTarget findTarget(String name) {\n    // todo: consider imported targes\n    // todo: search from the including project if any\n    for (AntDomTarget target : getDeclaredTargets()) {\n      if (name.equals(target.getName().getValue())) {\n        return target;\n      }\n    }\n    return null;\n  }","commit_id":"867df8ee3cd1848e9c8fd0cda1de1cbaf01c0554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SubTagList(\"target\")\n  public abstract List<AntDomTarget> getTargets();","id":76293,"modified_method":"@SubTagList(\"target\")\n  public abstract List<AntDomTarget> getDeclaredTargets();","commit_id":"867df8ee3cd1848e9c8fd0cda1de1cbaf01c0554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String resolveString(@Nullable String unresolvedText, @NotNull ConvertContext context) {\n    final DomElement element = context.getInvocationElement();\n    return null;\n  }","id":76294,"modified_method":"public String resolveString(@Nullable String unresolvedText, @NotNull ConvertContext context) {\n    //final DomElement element = context.getInvocationElement();\n    return unresolvedText; // todo\n  }","commit_id":"867df8ee3cd1848e9c8fd0cda1de1cbaf01c0554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static AntDomProject getAntDomProject(PsiFile psiFile) {\n    if (psiFile instanceof XmlFile) {\n      final DomManager domManager = DomManager.getDomManager(psiFile.getProject());\n      return domManager.getFileElement((XmlFile)psiFile, AntDomProject.class).getRootElement();\n    }\n    return null;\n  }","id":76295,"modified_method":"@Nullable\n  public static AntDomProject getAntDomProject(PsiFile psiFile) {\n    if (psiFile instanceof XmlFile) {\n      final DomManager domManager = DomManager.getDomManager(psiFile.getProject());\n      final DomFileElement<AntDomProject> fileElement = domManager.getFileElement((XmlFile)psiFile, AntDomProject.class);\n      return fileElement != null? fileElement.getRootElement() : null;\n    }\n    return null;\n  }","commit_id":"867df8ee3cd1848e9c8fd0cda1de1cbaf01c0554","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** \n     *  Caller must add family to RI also.\n     *  throws on all errors\n     *\n     *  @param family non-null, must match that we were initialized with or will throw GSE\n     *  @param h non-null\n     *  @return non-null base 64 signature string to be added to the RI\n     *  @throws GeneralSecurityException on null hash, null or changed family, or signing error\n     */\n    public String sign(String family, Hash h) throws GeneralSecurityException {\n        if (_privkey == null)\n            throw new GeneralSecurityException(\"family name set, must restart router\");\n        if (h == null)\n            throw new GeneralSecurityException(\"null router hash\");\n        if (!_fname.equals(family))\n            throw new GeneralSecurityException(\"family name changed, must restart router\");\n        byte[] nb = DataHelper.getUTF8(_fname);\n        int len = nb.length + Hash.HASH_LENGTH;\n        byte[] b = new byte[len];\n        System.arraycopy(nb, 0, b, 0, nb.length);\n        System.arraycopy(h.getData(), 0, b, nb.length, Hash.HASH_LENGTH);\n        Signature sig = _context.dsa().sign(b, _privkey);\n        if (sig == null)\n            throw new GeneralSecurityException(\"sig failed\");\n        return sig.toBase64();\n    }","id":76296,"modified_method":"/** \n     *  Caller must add family to RI also.\n     *  throws on all errors\n     *\n     *  @param family non-null, must match that we were initialized with or will throw GSE\n     *  @param h non-null\n     *  @return non-null options to be added to the RI\n     *  @throws GeneralSecurityException on null hash, null or changed family, or signing error\n     */\n    public Map<String, String> sign(String family, Hash h) throws GeneralSecurityException {\n        if (_privkey == null) {\n            _log.logAlways(Log.WARN, \"family name now set, must restart router to generate or load keys\");\n            throw new GeneralSecurityException(\"family name now set, must restart router to generate or load keys\");\n        }\n        if (h == null)\n            throw new GeneralSecurityException(\"null router hash\");\n        if (!_fname.equals(family)) {\n            _log.logAlways(Log.WARN, \"family name changed, must restart router to generate or load new keys\");\n            throw new GeneralSecurityException(\"family name changed, must restart router to generate or load new keys\");\n        }\n        byte[] nb = DataHelper.getUTF8(_fname);\n        int len = nb.length + Hash.HASH_LENGTH;\n        byte[] b = new byte[len];\n        System.arraycopy(nb, 0, b, 0, nb.length);\n        System.arraycopy(h.getData(), 0, b, nb.length, Hash.HASH_LENGTH);\n        Signature sig = _context.dsa().sign(b, _privkey);\n        if (sig == null)\n            throw new GeneralSecurityException(\"sig failed\");\n        Map<String, String> rv = new HashMap<String, String>(3);\n        rv.put(OPT_NAME, family);\n        rv.put(OPT_KEY, _pubkey.getType().getCode() + \";\" + _pubkey.toBase64());\n        rv.put(OPT_SIG, sig.toBase64());\n        return rv;\n    }","commit_id":"3a4e82f025981025b6fe7b5465444d07178429f3","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** \n     *  Verify the family signature in a RouterInfo.\n     *  @return true if good sig or if no family specified at all\n     */\n    public boolean verify(RouterInfo ri) {\n        String name = ri.getOption(OPT_NAME);\n        if (name == null)\n            return true;\n        Hash h = ri.getHash();\n        String ssig = ri.getOption(OPT_SIG);\n        if (ssig == null) {\n            if (_log.shouldInfo())\n                _log.info(\"No sig for \" + h + ' ' + name);\n            return false;\n        }\n        String nameAndSig = _verified.get(h);\n        String riNameAndSig = name + ssig;\n        if (nameAndSig != null) {\n            if (nameAndSig.equals(riNameAndSig))\n                return true;\n            // name or sig changed\n            _verified.remove(h);\n        }\n        SigningPublicKey spk;\n        if (name.equals(_fname)) {\n            // us\n            spk = _pubkey;\n        } else {\n            if (_negativeCache.contains(h))\n                return false;\n            spk = loadCert(name);\n            if (spk == null) {\n                _negativeCache.add(h);\n                if (_log.shouldInfo())\n                    _log.info(\"No cert for \" + h + ' ' + name);\n                return false;\n            }\n        }\n        byte[] bsig = Base64.decode(ssig);\n        if (bsig == null) {\n            _negativeCache.add(h);\n            if (_log.shouldInfo())\n                _log.info(\"Bad sig for \" + h + ' ' + name + ' ' + ssig);\n            return false;\n        }\n        Signature sig;\n        try {\n            sig = new Signature(spk.getType(), bsig);\n        } catch (IllegalArgumentException iae) {\n            // wrong size (type mismatch)\n            _negativeCache.add(h);\n            if (_log.shouldInfo())\n                _log.info(\"Bad sig for \" + ri, iae);\n            return false;\n        }\n        byte[] nb = DataHelper.getUTF8(name);\n        byte[] b = new byte[nb.length + Hash.HASH_LENGTH];\n        System.arraycopy(nb, 0, b, 0, nb.length);\n        System.arraycopy(ri.getHash().getData(), 0, b, nb.length, Hash.HASH_LENGTH);\n        boolean rv = _context.dsa().verifySignature(sig, b, spk);\n        if (rv)\n            _verified.put(h, riNameAndSig);\n        else\n            _negativeCache.add(h);\n        if (_log.shouldInfo())\n            _log.info(\"Verified? \" + rv + \" for \" + h + ' ' + name + ' ' + ssig);\n        return rv;\n    }","id":76297,"modified_method":"/** \n     *  Verify the family signature in a RouterInfo.\n     *  @return true if good sig or if no family specified at all\n     */\n    public boolean verify(RouterInfo ri) {\n        String name = ri.getOption(OPT_NAME);\n        if (name == null)\n            return true;\n        Hash h = ri.getHash();\n        String ssig = ri.getOption(OPT_SIG);\n        if (ssig == null) {\n            if (_log.shouldInfo())\n                _log.info(\"No sig for \" + h + ' ' + name);\n            return false;\n        }\n        String nameAndSig = _verified.get(h);\n        String riNameAndSig = name + ssig;\n        if (nameAndSig != null) {\n            if (nameAndSig.equals(riNameAndSig))\n                return true;\n            // name or sig changed\n            _verified.remove(h);\n        }\n        SigningPublicKey spk;\n        if (name.equals(_fname)) {\n            // us\n            spk = _pubkey;\n        } else {\n            if (_negativeCache.contains(h))\n                return false;\n            spk = loadCert(name);\n            if (spk == null) {\n                // look for a b64 key in the RI\n                String skey = ri.getOption(OPT_KEY);\n                if (skey != null) {\n                    int semi = skey.indexOf(\";\");\n                    if (semi > 0) {\n                        try {\n                            int code = Integer.parseInt(skey.substring(0, semi));\n                            SigType type = SigType.getByCode(code);\n                            if (type != null) {\n                                byte[] bkey = Base64.decode(skey.substring(semi + 1));\n                                if (bkey != null) {\n                                    spk = new SigningPublicKey(type, bkey);\n                                }\n                            }\n                        } catch (NumberFormatException e) {\n                            if (_log.shouldInfo())\n                                _log.info(\"Bad b64 family key: \" + ri, e);\n                        } catch (IllegalArgumentException e) {\n                            if (_log.shouldInfo())\n                                _log.info(\"Bad b64 family key: \" + ri, e);\n                        } catch (ArrayIndexOutOfBoundsException e) {\n                            if (_log.shouldInfo())\n                                _log.info(\"Bad b64 family key: \" + ri, e);\n                        }\n                    }\n                }\n                if (spk == null) {\n                    _negativeCache.add(h);\n                    if (_log.shouldInfo())\n                        _log.info(\"No cert or valid key for \" + h + ' ' + name);\n                    return false;\n                }\n            }\n        }\n        if (!spk.getType().isAvailable()) {\n            _negativeCache.add(h);\n            if (_log.shouldInfo())\n                _log.info(\"Unsupported crypto for sig for \" + h);\n            return false;\n        }\n        byte[] bsig = Base64.decode(ssig);\n        if (bsig == null) {\n            _negativeCache.add(h);\n            if (_log.shouldInfo())\n                _log.info(\"Bad sig for \" + h + ' ' + name + ' ' + ssig);\n            return false;\n        }\n        Signature sig;\n        try {\n            sig = new Signature(spk.getType(), bsig);\n        } catch (IllegalArgumentException iae) {\n            // wrong size (type mismatch)\n            _negativeCache.add(h);\n            if (_log.shouldInfo())\n                _log.info(\"Bad sig for \" + ri, iae);\n            return false;\n        }\n        byte[] nb = DataHelper.getUTF8(name);\n        byte[] b = new byte[nb.length + Hash.HASH_LENGTH];\n        System.arraycopy(nb, 0, b, 0, nb.length);\n        System.arraycopy(ri.getHash().getData(), 0, b, nb.length, Hash.HASH_LENGTH);\n        boolean rv = _context.dsa().verifySignature(sig, b, spk);\n        if (rv)\n            _verified.put(h, riNameAndSig);\n        else\n            _negativeCache.add(h);\n        if (_log.shouldInfo())\n            _log.info(\"Verified? \" + rv + \" for \" + h + ' ' + name + ' ' + ssig);\n        return rv;\n    }","commit_id":"3a4e82f025981025b6fe7b5465444d07178429f3","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Retrieve a snapshot of the statistics that should be published.\n     *\n     *  This includes all standard options (as of 0.9.24, network ID and caps)\n     *\n     *  @param current router hash, non-null\n     *  @since 0.9.24\n     */\n    public Properties publishStatistics(Hash h) { \n        Properties stats = new Properties();\n        stats.setProperty(\"router.version\", RouterVersion.VERSION);\n        // scheduled for removal, never used\n        if (CoreVersion.VERSION.equals(\"0.9.23\"))\n            stats.setProperty(\"coreVersion\", CoreVersion.VERSION);\n        stats.setProperty(RouterInfo.PROP_NETWORK_ID, Integer.toString(Router.NETWORK_ID));\n        stats.setProperty(RouterInfo.PROP_CAPABILITIES, _context.router().getCapabilities());\n\n        // No longer expose, to make build tracking more expensive\n        // stats.setProperty(\"router.id\", RouterVersion.ID);\n        // stats.setProperty(\"core.id\", CoreVersion.ID);\n\n/***\n        int newlines = 0;\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(Router.IDENTLOG);\n            int c = -1;\n            // perhaps later filter this to only include ident changes this\n            // day/week/month\n            while ( (c = in.read()) != -1) {\n                if (c == '\\n')\n                    newlines++;\n            }\n        } catch (IOException ioe) {\n            // ignore\n        } finally {\n            if (in != null)\n                try { in.close(); } catch (IOException ioe) {}\n        }\n        if (newlines > 0)\n            stats.setProperty(\"stat_identities\", newlines+\"\");\n***/\n        \n        if (_context.getBooleanPropertyDefaultTrue(PROP_PUBLISH_RANKINGS) &&\n            _context.random().nextInt(RANDOM_INCLUDE_STATS) == 0) {\n            //long publishedUptime = _context.router().getUptime();\n            // Don't publish these for first hour\n            // Disabled in 0.9\n            //if (publishedUptime > 62*60*1000)\n            //    includeAverageThroughput(stats);\n            //includeRate(\"router.invalidMessageTime\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"router.duplicateMessageId\", stats, new long[] { 24*60*60*1000 });\n            //includeRate(\"tunnel.duplicateIV\", stats, new long[] { 24*60*60*1000 });\n            //includeRate(\"tunnel.fragmentedDropped\", stats, new long[] { 10*60*1000, 3*60*60*1000 });\n            //includeRate(\"tunnel.fullFragments\", stats, new long[] { 10*60*1000, 3*60*60*1000 });\n            //includeRate(\"tunnel.smallFragments\", stats, new long[] { 10*60*1000, 3*60*60*1000 });\n            //includeRate(\"tunnel.testFailedTime\", stats, new long[] { 10*60*1000 });\n            \n            //includeRate(\"tunnel.batchDelaySent\", stats, new long[] { 10*60*1000, 60*60*1000 });\n            //includeRate(\"tunnel.batchMultipleCount\", stats, new long[] { 10*60*1000, 60*60*1000 });\n            //includeRate(\"tunnel.corruptMessage\", stats, new long[] { 60*60*1000l, 3*60*60*1000l });\n            \n            //includeRate(\"router.throttleTunnelProbTestSlow\", stats, new long[] { 60*60*1000 });\n            //includeRate(\"router.throttleTunnelProbTooFast\", stats, new long[] { 60*60*1000 });\n            //includeRate(\"router.throttleTunnelProcessingTime1m\", stats, new long[] { 60*60*1000 });\n\n            //includeRate(\"router.fastPeers\", stats, new long[] { 60*60*1000 });\n            \n            //includeRate(\"udp.statusOK\", stats, new long[] { 20*60*1000 });\n            //includeRate(\"udp.statusDifferent\", stats, new long[] { 20*60*1000 });\n            //includeRate(\"udp.statusReject\", stats, new long[] { 20*60*1000 });\n            //includeRate(\"udp.statusUnknown\", stats, new long[] { 20*60*1000 });\n            //includeRate(\"udp.statusKnownCharlie\", stats, new long[] { 1*60*1000, 10*60*1000 });\n            //includeRate(\"udp.addressUpdated\", stats, new long[] { 1*60*1000 });\n            //includeRate(\"udp.addressTestInsteadOfUpdate\", stats, new long[] { 1*60*1000 });\n\n            //includeRate(\"clock.skew\", stats, new long[] { 10*60*1000, 3*60*60*1000, 24*60*60*1000 });\n            \n            //includeRate(\"transport.sendProcessingTime\", stats, new long[] { 60*60*1000 });\n            //includeRate(\"jobQueue.jobRunSlow\", stats, new long[] { 10*60*1000l, 60*60*1000l });\n            //includeRate(\"crypto.elGamal.encrypt\", stats, new long[] { 60*60*1000 });\n            // total event count can be used to track uptime\n            includeRate(\"tunnel.participatingTunnels\", stats, new long[] { 60*60*1000 }, true);\n            //includeRate(\"tunnel.testSuccessTime\", stats, new long[] { 10*60*1000l });\n            //includeRate(\"client.sendAckTime\", stats, new long[] { 60*60*1000 }, true);\n            //includeRate(\"udp.sendConfirmTime\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"udp.sendVolleyTime\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"udp.ignoreRecentDuplicate\", stats, new long[] { 60*1000 });\n            //includeRate(\"udp.congestionOccurred\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"stream.con.sendDuplicateSize\", stats, new long[] { 60*60*1000 });\n            //includeRate(\"stream.con.receiveDuplicateSize\", stats, new long[] { 60*60*1000 });\n\n            //stats.setProperty(\"stat__rateKey\", \"avg;maxAvg;pctLifetime;[sat;satLim;maxSat;maxSatLim;][num;lifetimeFreq;maxFreq]\");\n            \n            //includeRate(\"tunnel.decryptRequestTime\", stats, new long[] { 60*1000, 10*60*1000 });\n            //includeRate(\"udp.packetDequeueTime\", stats, new long[] { 60*1000 });\n            //includeRate(\"udp.packetVerifyTime\", stats, new long[] { 60*1000 });\n            \n            //includeRate(\"tunnel.buildRequestTime\", stats, new long[] { 10*60*1000 });\n            long rate = 60*60*1000;\n            //includeTunnelRates(\"Client\", stats, rate);\n            includeTunnelRates(\"Exploratory\", stats, rate);\n            //includeRate(\"tunnel.rejectTimeout\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"tunnel.rejectOverloaded\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"tunnel.acceptLoad\", stats, new long[] { 10*60*1000 });\n        }\n\n        // So that we will still get build requests - not required since 0.7.9 2010-01-12\n        // scheduled for removal\n        if (CoreVersion.VERSION.equals(\"0.9.23\"))\n            stats.setProperty(\"stat_uptime\", \"90m\");\n        if (FloodfillNetworkDatabaseFacade.isFloodfill(_context.router().getRouterInfo())) {\n            int ri = _context.router().getUptime() > 30*60*1000 ?\n                     _context.netDb().getKnownRouters() :\n                     3000 + _context.random().nextInt(1000);   // so it isn't obvious we restarted\n            stats.setProperty(\"netdb.knownRouters\", String.valueOf(ri));\n            int ls = _context.router().getUptime() > 30*60*1000 ?\n                     _context.netDb().getKnownLeaseSets() :\n                     30 + _context.random().nextInt(40);   // so it isn't obvious we restarted\n            stats.setProperty(\"netdb.knownLeaseSets\", String.valueOf(ls));\n        }\n\n        String contact = _context.getProperty(PROP_CONTACT_NAME);\n        if (contact != null)\n            stats.setProperty(\"contact\", contact);\n\n        String family = _context.getProperty(FamilyKeyCrypto.PROP_FAMILY_NAME);\n        if (family != null) {\n            stats.setProperty(FamilyKeyCrypto.OPT_NAME, family);\n            String sig = null;\n            RouterInfo oldRI = _context.router().getRouterInfo();\n            if (oldRI != null) {\n                // don't do it if family changed\n                if (family.equals(oldRI.getOption(FamilyKeyCrypto.OPT_NAME))) {\n                    // copy over the signature\n                    sig = oldRI.getOption(FamilyKeyCrypto.OPT_SIG);\n                    if (sig != null)\n                        stats.setProperty(FamilyKeyCrypto.OPT_SIG, sig);\n                }\n            }\n            if (sig == null) {\n                FamilyKeyCrypto fkc = _context.router().getFamilyKeyCrypto();\n                if (fkc != null) {\n                    try {\n                        sig = fkc.sign(family, h);\n                        stats.setProperty(FamilyKeyCrypto.OPT_SIG, sig);\n                    } catch (GeneralSecurityException gse) {\n                        _log.error(\"Failed to sign router family\", gse);\n                    }\n                }\n            }\n        }\n\n        return stats;\n    }","id":76298,"modified_method":"/**\n     *  Retrieve a snapshot of the statistics that should be published.\n     *\n     *  This includes all standard options (as of 0.9.24, network ID and caps)\n     *\n     *  @param current router hash, non-null\n     *  @since 0.9.24\n     */\n    public Properties publishStatistics(Hash h) { \n        Properties stats = new Properties();\n        stats.setProperty(\"router.version\", RouterVersion.VERSION);\n        // scheduled for removal, never used\n        if (CoreVersion.VERSION.equals(\"0.9.23\"))\n            stats.setProperty(\"coreVersion\", CoreVersion.VERSION);\n        stats.setProperty(RouterInfo.PROP_NETWORK_ID, Integer.toString(Router.NETWORK_ID));\n        stats.setProperty(RouterInfo.PROP_CAPABILITIES, _context.router().getCapabilities());\n\n        // No longer expose, to make build tracking more expensive\n        // stats.setProperty(\"router.id\", RouterVersion.ID);\n        // stats.setProperty(\"core.id\", CoreVersion.ID);\n\n/***\n        int newlines = 0;\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(Router.IDENTLOG);\n            int c = -1;\n            // perhaps later filter this to only include ident changes this\n            // day/week/month\n            while ( (c = in.read()) != -1) {\n                if (c == '\\n')\n                    newlines++;\n            }\n        } catch (IOException ioe) {\n            // ignore\n        } finally {\n            if (in != null)\n                try { in.close(); } catch (IOException ioe) {}\n        }\n        if (newlines > 0)\n            stats.setProperty(\"stat_identities\", newlines+\"\");\n***/\n        \n        if (_context.getBooleanPropertyDefaultTrue(PROP_PUBLISH_RANKINGS) &&\n            _context.random().nextInt(RANDOM_INCLUDE_STATS) == 0) {\n            //long publishedUptime = _context.router().getUptime();\n            // Don't publish these for first hour\n            // Disabled in 0.9\n            //if (publishedUptime > 62*60*1000)\n            //    includeAverageThroughput(stats);\n            //includeRate(\"router.invalidMessageTime\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"router.duplicateMessageId\", stats, new long[] { 24*60*60*1000 });\n            //includeRate(\"tunnel.duplicateIV\", stats, new long[] { 24*60*60*1000 });\n            //includeRate(\"tunnel.fragmentedDropped\", stats, new long[] { 10*60*1000, 3*60*60*1000 });\n            //includeRate(\"tunnel.fullFragments\", stats, new long[] { 10*60*1000, 3*60*60*1000 });\n            //includeRate(\"tunnel.smallFragments\", stats, new long[] { 10*60*1000, 3*60*60*1000 });\n            //includeRate(\"tunnel.testFailedTime\", stats, new long[] { 10*60*1000 });\n            \n            //includeRate(\"tunnel.batchDelaySent\", stats, new long[] { 10*60*1000, 60*60*1000 });\n            //includeRate(\"tunnel.batchMultipleCount\", stats, new long[] { 10*60*1000, 60*60*1000 });\n            //includeRate(\"tunnel.corruptMessage\", stats, new long[] { 60*60*1000l, 3*60*60*1000l });\n            \n            //includeRate(\"router.throttleTunnelProbTestSlow\", stats, new long[] { 60*60*1000 });\n            //includeRate(\"router.throttleTunnelProbTooFast\", stats, new long[] { 60*60*1000 });\n            //includeRate(\"router.throttleTunnelProcessingTime1m\", stats, new long[] { 60*60*1000 });\n\n            //includeRate(\"router.fastPeers\", stats, new long[] { 60*60*1000 });\n            \n            //includeRate(\"udp.statusOK\", stats, new long[] { 20*60*1000 });\n            //includeRate(\"udp.statusDifferent\", stats, new long[] { 20*60*1000 });\n            //includeRate(\"udp.statusReject\", stats, new long[] { 20*60*1000 });\n            //includeRate(\"udp.statusUnknown\", stats, new long[] { 20*60*1000 });\n            //includeRate(\"udp.statusKnownCharlie\", stats, new long[] { 1*60*1000, 10*60*1000 });\n            //includeRate(\"udp.addressUpdated\", stats, new long[] { 1*60*1000 });\n            //includeRate(\"udp.addressTestInsteadOfUpdate\", stats, new long[] { 1*60*1000 });\n\n            //includeRate(\"clock.skew\", stats, new long[] { 10*60*1000, 3*60*60*1000, 24*60*60*1000 });\n            \n            //includeRate(\"transport.sendProcessingTime\", stats, new long[] { 60*60*1000 });\n            //includeRate(\"jobQueue.jobRunSlow\", stats, new long[] { 10*60*1000l, 60*60*1000l });\n            //includeRate(\"crypto.elGamal.encrypt\", stats, new long[] { 60*60*1000 });\n            // total event count can be used to track uptime\n            includeRate(\"tunnel.participatingTunnels\", stats, new long[] { 60*60*1000 }, true);\n            //includeRate(\"tunnel.testSuccessTime\", stats, new long[] { 10*60*1000l });\n            //includeRate(\"client.sendAckTime\", stats, new long[] { 60*60*1000 }, true);\n            //includeRate(\"udp.sendConfirmTime\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"udp.sendVolleyTime\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"udp.ignoreRecentDuplicate\", stats, new long[] { 60*1000 });\n            //includeRate(\"udp.congestionOccurred\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"stream.con.sendDuplicateSize\", stats, new long[] { 60*60*1000 });\n            //includeRate(\"stream.con.receiveDuplicateSize\", stats, new long[] { 60*60*1000 });\n\n            //stats.setProperty(\"stat__rateKey\", \"avg;maxAvg;pctLifetime;[sat;satLim;maxSat;maxSatLim;][num;lifetimeFreq;maxFreq]\");\n            \n            //includeRate(\"tunnel.decryptRequestTime\", stats, new long[] { 60*1000, 10*60*1000 });\n            //includeRate(\"udp.packetDequeueTime\", stats, new long[] { 60*1000 });\n            //includeRate(\"udp.packetVerifyTime\", stats, new long[] { 60*1000 });\n            \n            //includeRate(\"tunnel.buildRequestTime\", stats, new long[] { 10*60*1000 });\n            long rate = 60*60*1000;\n            //includeTunnelRates(\"Client\", stats, rate);\n            includeTunnelRates(\"Exploratory\", stats, rate);\n            //includeRate(\"tunnel.rejectTimeout\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"tunnel.rejectOverloaded\", stats, new long[] { 10*60*1000 });\n            //includeRate(\"tunnel.acceptLoad\", stats, new long[] { 10*60*1000 });\n        }\n\n        // So that we will still get build requests - not required since 0.7.9 2010-01-12\n        // scheduled for removal\n        if (CoreVersion.VERSION.equals(\"0.9.23\"))\n            stats.setProperty(\"stat_uptime\", \"90m\");\n        if (FloodfillNetworkDatabaseFacade.isFloodfill(_context.router().getRouterInfo())) {\n            int ri = _context.router().getUptime() > 30*60*1000 ?\n                     _context.netDb().getKnownRouters() :\n                     3000 + _context.random().nextInt(1000);   // so it isn't obvious we restarted\n            stats.setProperty(\"netdb.knownRouters\", String.valueOf(ri));\n            int ls = _context.router().getUptime() > 30*60*1000 ?\n                     _context.netDb().getKnownLeaseSets() :\n                     30 + _context.random().nextInt(40);   // so it isn't obvious we restarted\n            stats.setProperty(\"netdb.knownLeaseSets\", String.valueOf(ls));\n        }\n\n        String contact = _context.getProperty(PROP_CONTACT_NAME);\n        if (contact != null)\n            stats.setProperty(\"contact\", contact);\n\n        String family = _context.getProperty(FamilyKeyCrypto.PROP_FAMILY_NAME);\n        if (family != null) {\n            stats.setProperty(FamilyKeyCrypto.OPT_NAME, family);\n            String sig = null;\n            String key = null;\n            RouterInfo oldRI = _context.router().getRouterInfo();\n            if (oldRI != null) {\n                // don't do it if family changed\n                if (family.equals(oldRI.getOption(FamilyKeyCrypto.OPT_NAME))) {\n                    // copy over the pubkey and signature\n                    key = oldRI.getOption(FamilyKeyCrypto.OPT_KEY);\n                    if (key != null)\n                        stats.setProperty(FamilyKeyCrypto.OPT_KEY, key);\n                    sig = oldRI.getOption(FamilyKeyCrypto.OPT_SIG);\n                    if (sig != null)\n                        stats.setProperty(FamilyKeyCrypto.OPT_SIG, sig);\n                }\n            }\n            if (sig == null || key == null) {\n                FamilyKeyCrypto fkc = _context.router().getFamilyKeyCrypto();\n                if (fkc != null) {\n                    try {\n                        stats.putAll(fkc.sign(family, h));\n                    } catch (GeneralSecurityException gse) {\n                        _log.error(\"Failed to sign router family\", gse);\n                        stats.remove(FamilyKeyCrypto.OPT_KEY);\n                        stats.remove(FamilyKeyCrypto.OPT_SIG);\n                    }\n                }\n            }\n        }\n\n        return stats;\n    }","commit_id":"3a4e82f025981025b6fe7b5465444d07178429f3","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * @param args\n     */\n    public static void main(String[] args) throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n        Curves curve = ECDSA.Curves.P256;\n        ECDSA ecdsa = new ECDSA(curve);\n        String toSign = \"test\";\n        byte[] signedBytes = toSign.getBytes(\"utf-8\");\n        byte[] sig = ecdsa.sign(signedBytes);\n        System.out.println(\"Curve in use : \" + curve.toString());\n        System.out.println(ecdsa.getPublicKey().toString());\n        System.out.println(\"ToSign   : \"+toSign + \" (\"+toHex(signedBytes)+\")\");\n        System.out.println(\"Signature: \"+ toHex(sig));\n        System.out.println(\"Verify?  : \"+ecdsa.verify(sig, signedBytes));\n        \n        SimpleFieldSet sfs = ecdsa.asFieldSet(true);\n        System.out.println(\"\\nSerialized to: \");\n        System.out.println(sfs.toString());\n        System.out.println(\"Restored to: \");\n        ECDSA ecdsa2 = new ECDSA(sfs.getSubset(curve.name()), curve);\n        System.out.println(ecdsa2.getPublicKey());\n        System.out.println(\"Verify?  : \"+ecdsa2.verify(sig, signedBytes));\n    }","id":76299,"modified_method":"/**\n     * @param args\n     */\n    public static void main(String[] args) throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n        Curves curve = ECDSA.Curves.P256;\n        ECDSA ecdsa = new ECDSA(curve);\n        String toSign = \"test\";\n        byte[] signedBytes = toSign.getBytes(\"utf-8\");\n        //byte[] sig = ecdsa.sign(signedBytes);\n        byte[] sig = ecdsa.signToNetworkFormat(signedBytes, 0, signedBytes.length);\n        System.out.println(\"Curve in use : \" + curve.toString());\n        System.out.println(ecdsa.getPublicKey().toString());\n        System.out.println(\"ToSign   : \"+toSign + \" (\"+toHex(signedBytes)+\")\");\n        System.out.println(\"Signature: \"+ toHex(sig));\n        System.out.println(\"Verify?  : \"+ecdsa.verify(sig, signedBytes));\n        \n        SimpleFieldSet sfs = ecdsa.asFieldSet(true);\n        System.out.println(\"\\nSerialized to: \");\n        System.out.println(sfs.toString());\n        System.out.println(\"Restored to: \");\n        ECDSA ecdsa2 = new ECDSA(sfs.getSubset(curve.name()), curve);\n        System.out.println(ecdsa2.getPublicKey());\n        System.out.println(\"Verify?  : \"+ecdsa2.verify(sig, signedBytes));\n        \n        System.out.println(\"Let's ensure that the signature always fits into \"+ecdsa.curve.maxSigSize+\" bytes.\");\n        int max = 0;\n        for(int i=0; i<10000; i++) {\n            max = Math.max(max, ecdsa.sign(signedBytes).length);\n        }\n        System.out.println(max);\n    }","commit_id":"8a3ea932e966afef7b9bfe57ac6378bfba94111d","url":"https://github.com/freenet/fred"},{"original_method":"byte[] ecdsaSign(byte[] hash) {\n\t    return ecdsaP256.sign(hash);\n\t}","id":76300,"modified_method":"byte[] ecdsaSign(byte[] stuff) {\n\t    return ecdsaP256.signToNetworkFormat(stuff, 0, stuff.length);\n\t}","commit_id":"8a3ea932e966afef7b9bfe57ac6378bfba94111d","url":"https://github.com/freenet/fred"},{"original_method":"private String ecdsaSignRef(String mySignedReference) throws NodeInitException {\n\t    if(logMINOR) Logger.minor(this, \"Signing reference:\\n\"+mySignedReference);\n\n\t    try{\n\t        byte[] ref = mySignedReference.getBytes(\"UTF-8\");\n\t        byte[] sig = ecdsaSign(ref);\n\t        if(logMINOR && !ECDSA.verify(Curves.P256, getECDSAP256Pubkey(), sig, ref))\n\t            throw new NodeInitException(NodeInitException.EXIT_EXCEPTION_TO_DEBUG, mySignedReference);\n\t        return Base64.encode(sig);\n\t    } catch(UnsupportedEncodingException e){\n\t        //duh ?\n\t        Logger.error(this, \"Error while signing the node identity!\" + e, e);\n\t        System.err.println(\"Error while signing the node identity!\"+e);\n\t        e.printStackTrace();\n\t        throw new NodeInitException(NodeInitException.EXIT_CRAPPY_JVM, \"Impossible: JVM doesn't support UTF-8\");\n\t    }\n\t}","id":76301,"modified_method":"private String ecdsaSignRef(String mySignedReference) throws NodeInitException {\n\t    if(logMINOR) Logger.minor(this, \"Signing reference:\\n\"+mySignedReference);\n\n\t    try{\n\t        byte[] ref = mySignedReference.getBytes(\"UTF-8\");\n\t        // We don't need a padded signature here\n\t        byte[] sig = ecdsaP256.sign(ref);\n\t        if(logMINOR && !ECDSA.verify(Curves.P256, getECDSAP256Pubkey(), sig, ref))\n\t            throw new NodeInitException(NodeInitException.EXIT_EXCEPTION_TO_DEBUG, mySignedReference);\n\t        return Base64.encode(sig);\n\t    } catch(UnsupportedEncodingException e){\n\t        //duh ?\n\t        Logger.error(this, \"Error while signing the node identity!\" + e, e);\n\t        System.err.println(\"Error while signing the node identity!\"+e);\n\t        e.printStackTrace();\n\t        throw new NodeInitException(NodeInitException.EXIT_CRAPPY_JVM, \"Impossible: JVM doesn't support UTF-8\");\n\t    }\n\t}","commit_id":"8a3ea932e966afef7b9bfe57ac6378bfba94111d","url":"https://github.com/freenet/fred"},{"original_method":"private void importOldIndentOptions(@NonNls Element element) {\n    final List options = element.getChildren(\"option\");\n    for (Object option1 : options) {\n      @NonNls Element option = (Element)option1;\n      @NonNls final String name = option.getAttributeValue(\"name\");\n      if (\"TAB_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.TAB_SIZE = value;\n        JSP_INDENT_OPTIONS.TAB_SIZE = value;\n        XML_INDENT_OPTIONS.TAB_SIZE = value;\n        OTHER_INDENT_OPTIONS.TAB_SIZE = value;\n      }\n      else if (\"INDENT_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.INDENT_SIZE = value;\n        JSP_INDENT_OPTIONS.INDENT_SIZE = value;\n        XML_INDENT_OPTIONS.INDENT_SIZE = value;\n        OTHER_INDENT_OPTIONS.INDENT_SIZE = value;\n      }\n      else if (\"CONTINUATION_INDENT_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        JSP_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        XML_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        OTHER_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n      }\n      else if (\"USE_TAB_CHARACTER\".equals(name)) {\n        final boolean value = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        JAVA_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        JSP_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        XML_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        OTHER_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n      }\n      else if (\"SMART_TABS\".equals(name)) {\n        final boolean value = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        JAVA_INDENT_OPTIONS.SMART_TABS = value;\n        JSP_INDENT_OPTIONS.SMART_TABS = value;\n        XML_INDENT_OPTIONS.SMART_TABS = value;\n        OTHER_INDENT_OPTIONS.SMART_TABS = value;\n      } else if (\"SPACE_AFTER_UNARY_OPERATOR\".equals(name)) {\n        final boolean value = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        SPACE_AROUND_UNARY_OPERATOR = value;\n      }\n    }\n  }","id":76302,"modified_method":"private boolean importOldIndentOptions(@NonNls Element element) {\n    final List options = element.getChildren(\"option\");\n    boolean optionsImported = false;\n    for (Object option1 : options) {\n      @NonNls Element option = (Element)option1;\n      @NonNls final String name = option.getAttributeValue(\"name\");\n      if (\"TAB_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.TAB_SIZE = value;\n        JSP_INDENT_OPTIONS.TAB_SIZE = value;\n        XML_INDENT_OPTIONS.TAB_SIZE = value;\n        OTHER_INDENT_OPTIONS.TAB_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"INDENT_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.INDENT_SIZE = value;\n        JSP_INDENT_OPTIONS.INDENT_SIZE = value;\n        XML_INDENT_OPTIONS.INDENT_SIZE = value;\n        OTHER_INDENT_OPTIONS.INDENT_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"CONTINUATION_INDENT_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        JSP_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        XML_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        OTHER_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"USE_TAB_CHARACTER\".equals(name)) {\n        final boolean value = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        JAVA_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        JSP_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        XML_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        OTHER_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        optionsImported = true;\n      }\n      else if (\"SMART_TABS\".equals(name)) {\n        final boolean value = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        JAVA_INDENT_OPTIONS.SMART_TABS = value;\n        JSP_INDENT_OPTIONS.SMART_TABS = value;\n        XML_INDENT_OPTIONS.SMART_TABS = value;\n        OTHER_INDENT_OPTIONS.SMART_TABS = value;\n        optionsImported = true;\n      } else if (\"SPACE_AFTER_UNARY_OPERATOR\".equals(name)) {\n        final boolean value = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        SPACE_AROUND_UNARY_OPERATOR = value;\n        optionsImported = true;\n      }\n    }\n    return optionsImported;\n  }","commit_id":"719279583ffe98186171af3b89a81b66e6f1a66e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    DefaultJDOMExternalizer.readExternal(this, element);\n    if (LAYOUT_STATIC_IMPORTS_SEPARATELY) {\n      // add <all other static imports> entry if there is none\n      boolean found = false;\n      for (PackageEntry entry : IMPORT_LAYOUT_TABLE.getEntries()) {\n        if (entry == PackageEntry.ALL_OTHER_STATIC_IMPORTS_ENTRY) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        PackageEntry last = IMPORT_LAYOUT_TABLE.getEntryCount() == 0 ? null : IMPORT_LAYOUT_TABLE.getEntryAt(IMPORT_LAYOUT_TABLE.getEntryCount() - 1);\n        if (last != PackageEntry.BLANK_LINE_ENTRY) {\n          IMPORT_LAYOUT_TABLE.addEntry(PackageEntry.BLANK_LINE_ENTRY);\n        }\n        IMPORT_LAYOUT_TABLE.addEntry(PackageEntry.ALL_OTHER_STATIC_IMPORTS_ENTRY);\n      }\n    }\n    importOldIndentOptions(element);\n    for (final CustomCodeStyleSettings settings : myCustomSettings.values()) {\n      settings.readExternal(element);\n    }\n\n    final List list = element.getChildren(ADDITIONAL_INDENT_OPTIONS);\n    if (list != null) {\n      for(Object o:list) {\n        if (o instanceof Element) {\n          final Element additionalIndentElement = (Element)o;\n          final String fileTypeId = additionalIndentElement.getAttributeValue(FILETYPE);\n\n          if (fileTypeId != null && fileTypeId.length() > 0) {\n            FileType target = FileTypeManager.getInstance().getFileTypeByExtension(fileTypeId);\n            if (FileTypes.UNKNOWN == target || FileTypes.PLAIN_TEXT == target || target.getDefaultExtension().length() == 0) {\n              target = new TempFileType(fileTypeId);\n            }\n\n            final IndentOptions options = new IndentOptions();\n            options.readExternal(additionalIndentElement);\n            registerAdditionalIndentOptions(target, options);\n          }\n        }\n      }\n    }\n\n    myCommonSettingsManager.readExternal(element);\n\n    copyOldIndentOptions(\"java\", JAVA_INDENT_OPTIONS);\n    copyOldIndentOptions(\"jsp\", JSP_INDENT_OPTIONS);\n    copyOldIndentOptions(\"xml\", XML_INDENT_OPTIONS);\n  }","id":76303,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    DefaultJDOMExternalizer.readExternal(this, element);\n    if (LAYOUT_STATIC_IMPORTS_SEPARATELY) {\n      // add <all other static imports> entry if there is none\n      boolean found = false;\n      for (PackageEntry entry : IMPORT_LAYOUT_TABLE.getEntries()) {\n        if (entry == PackageEntry.ALL_OTHER_STATIC_IMPORTS_ENTRY) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        PackageEntry last = IMPORT_LAYOUT_TABLE.getEntryCount() == 0 ? null : IMPORT_LAYOUT_TABLE.getEntryAt(IMPORT_LAYOUT_TABLE.getEntryCount() - 1);\n        if (last != PackageEntry.BLANK_LINE_ENTRY) {\n          IMPORT_LAYOUT_TABLE.addEntry(PackageEntry.BLANK_LINE_ENTRY);\n        }\n        IMPORT_LAYOUT_TABLE.addEntry(PackageEntry.ALL_OTHER_STATIC_IMPORTS_ENTRY);\n      }\n    }\n    boolean oldOptionsImported = importOldIndentOptions(element);\n    for (final CustomCodeStyleSettings settings : myCustomSettings.values()) {\n      settings.readExternal(element);\n    }\n\n    final List list = element.getChildren(ADDITIONAL_INDENT_OPTIONS);\n    if (list != null) {\n      for(Object o:list) {\n        if (o instanceof Element) {\n          final Element additionalIndentElement = (Element)o;\n          final String fileTypeId = additionalIndentElement.getAttributeValue(FILETYPE);\n\n          if (fileTypeId != null && fileTypeId.length() > 0) {\n            FileType target = FileTypeManager.getInstance().getFileTypeByExtension(fileTypeId);\n            if (FileTypes.UNKNOWN == target || FileTypes.PLAIN_TEXT == target || target.getDefaultExtension().length() == 0) {\n              target = new TempFileType(fileTypeId);\n            }\n\n            final IndentOptions options = new IndentOptions();\n            options.readExternal(additionalIndentElement);\n            registerAdditionalIndentOptions(target, options);\n          }\n        }\n      }\n    }\n\n    myCommonSettingsManager.readExternal(element);\n\n    if (oldOptionsImported) {\n      copyOldIndentOptions(\"java\", JAVA_INDENT_OPTIONS);\n      copyOldIndentOptions(\"jsp\", JSP_INDENT_OPTIONS);\n      copyOldIndentOptions(\"xml\", XML_INDENT_OPTIONS);\n    }\n  }","commit_id":"719279583ffe98186171af3b89a81b66e6f1a66e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    List<? extends PsiElement> class_list = new ParentMatcher(PyClass.class).search(referenceExpression);\n    boolean within_our_class = class_list != null && class_list.get(0) == this;\n    Set<String> names_already = context.get(PyType.CTX_NAMES);\n    List<Object> ret = new ArrayList<Object>();\n    Condition<String> underscore_filter = new PyUtil.UnderscoreFilter(PyUtil.getInitialUnderscores(referenceExpression.getName()));\n    // from providers\n    for(PyClassMembersProvider provider: Extensions.getExtensions(PyClassMembersProvider.EP_NAME)) {\n      for (PyDynamicMember member : provider.getMembers(myClass)) {\n        final String name = member.getName();\n        if (underscore_filter.value(name)) {\n          ret.add(LookupElementBuilder.create(name).setIcon(member.getIcon()).setTypeText(member.getShortType()));\n        }\n      }\n    }\n    // from our own class\n    final VariantsProcessor processor = new VariantsProcessor(\n      referenceExpression, new PyResolveUtil.FilterNotInstance(myClass), underscore_filter\n    );\n    myClass.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n    if (names_already != null) {\n      for (LookupElement le : processor.getResultList()) {\n        String name = le.getLookupString();\n        if (names_already.contains(name)) continue;\n        if (! within_our_class && isClassPrivate(name)) continue;\n        names_already.add(name);\n        ret.add(le);\n      }\n    }\n    else ret.addAll(processor.getResultList());\n    for (PyClass ancestor : myClass.getSuperClasses()) {\n      Object[] ancestry = (new PyClassType(ancestor, true)).getCompletionVariants(referenceExpression, context);\n      for (Object ob : ancestry) {\n        if (ob instanceof LookupElementBuilder) {\n          final LookupElementBuilder lookup_elt = (LookupElementBuilder)ob;\n          if (! isClassPrivate(lookup_elt.getLookupString())) ret.add(lookup_elt.setTypeText(ancestor.getName()));\n        } else {\n          if (! isClassPrivate(ob.toString())) ret.add(ob);\n        }\n      }\n      ret.addAll(Arrays.asList(ancestry));\n    }\n    return ret.toArray();\n  }","id":76304,"modified_method":"public Object[] getCompletionVariants(final PyQualifiedExpression referenceExpression, ProcessingContext context) {\n    List<? extends PsiElement> class_list = new ParentMatcher(PyClass.class).search(referenceExpression);\n    boolean within_our_class = class_list != null && class_list.get(0) == this;\n    Set<String> names_already = context.get(PyType.CTX_NAMES);\n    List<Object> ret = new ArrayList<Object>();\n    Condition<String> underscore_filter = new PyUtil.UnderscoreFilter(PyUtil.getInitialUnderscores(referenceExpression.getName()));\n    // from providers\n    for(PyClassMembersProvider provider: Extensions.getExtensions(PyClassMembersProvider.EP_NAME)) {\n      for (PyDynamicMember member : provider.getMembers(myClass)) {\n        final String name = member.getName();\n        if (underscore_filter.value(name)) {\n          ret.add(LookupElementBuilder.create(name).setIcon(member.getIcon()).setTypeText(member.getShortType()));\n        }\n      }\n    }\n    // from our own class\n    final VariantsProcessor processor = new VariantsProcessor(\n      referenceExpression, new PyResolveUtil.FilterNotInstance(myClass), underscore_filter\n    );\n    myClass.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n    if (names_already != null) {\n      for (LookupElement le : processor.getResultList()) {\n        String name = le.getLookupString();\n        if (names_already.contains(name)) continue;\n        if (! within_our_class && isClassPrivate(name)) continue;\n        names_already.add(name);\n        ret.add(le);\n      }\n    }\n    else ret.addAll(processor.getResultList());\n    for (PyClass ancestor : myClass.getSuperClasses()) {\n      Object[] ancestry = (new PyClassType(ancestor, true)).getCompletionVariants(referenceExpression, context);\n      for (Object ob : ancestry) {\n        if (ob instanceof LookupElementBuilder) {\n          final LookupElementBuilder lookup_elt = (LookupElementBuilder)ob;\n          if (! isClassPrivate(lookup_elt.getLookupString())) ret.add(lookup_elt.setTypeText(ancestor.getName()));\n        } else {\n          if (! isClassPrivate(ob.toString())) ret.add(ob);\n        }\n      }\n      ret.addAll(Arrays.asList(ancestry));\n    }\n    return ret.toArray();\n  }","commit_id":"f92fc0a5772605d575c3ffcc22f1f3a52e9be02d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyImportReferenceImpl(PyReferenceExpressionImpl element) {\n    super(element);\n  }","id":76305,"modified_method":"public PyImportReferenceImpl(PyReferenceExpressionImpl element) {\n    super(element);\n    myElement = element;\n  }","commit_id":"f92fc0a5772605d575c3ffcc22f1f3a52e9be02d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    final VariantsProcessor processor = new VariantsProcessor(referenceExpression);\n    myClass.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n    return processor.getResult();\n  }","id":76306,"modified_method":"public Object[] getCompletionVariants(final PyQualifiedExpression referenceExpression, ProcessingContext context) {\n    final VariantsProcessor processor = new VariantsProcessor(referenceExpression);\n    myClass.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n    return processor.getResult();\n  }","commit_id":"f92fc0a5772605d575c3ffcc22f1f3a52e9be02d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    Set<String> names_already = context.get(CTX_NAMES);\n    List<Object> result = new ArrayList<Object>();\n    ResolveImportUtil.ROLE_IN_IMPORT role = ResolveImportUtil.getRoleInImport(referenceExpression.getReference());\n    if (role == NONE) { // when not inside import, add regular attributes\n      final VariantsProcessor processor = new VariantsProcessor(referenceExpression);\n      myModule.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n      if (names_already != null) {\n        for (LookupElement le : processor.getResultList()) {\n          String name = le.getLookupString();\n          if (!names_already.contains(name)) {\n            result.add(le);\n            names_already.add(name);\n          }\n        }\n      }\n      else result.addAll(processor.getResultList());\n    }\n    else /*if (role == AS_MODULE)*/ { // when being imported, add submodules\n      for (PsiFileSystemItem pfsi : getSubmodulesList()) {\n        String s = pfsi.getName();\n        int pos = s.lastIndexOf('.'); // it may not contain a dot, except in extension; cut it off.\n        if (pos > 0) s = s.substring(0, pos);\n        if (!PyNames.isIdentifier(s)) continue;\n        if (names_already != null) {\n          if (names_already.contains(s)) continue;\n          else names_already.add(s);\n        }\n        result.add(LookupElementBuilder.create(pfsi, s).setPresentableText(s));\n      }\n    }\n    return result.toArray();\n  }","id":76307,"modified_method":"public Object[] getCompletionVariants(final PyQualifiedExpression referenceExpression, ProcessingContext context) {\n    Set<String> names_already = context.get(CTX_NAMES);\n    List<Object> result = new ArrayList<Object>();\n    ResolveImportUtil.ROLE_IN_IMPORT role = ResolveImportUtil.getRoleInImport(referenceExpression.getReference());\n    if (role == NONE) { // when not inside import, add regular attributes\n      final VariantsProcessor processor = new VariantsProcessor(referenceExpression);\n      myModule.processDeclarations(processor, ResolveState.initial(), null, referenceExpression);\n      if (names_already != null) {\n        for (LookupElement le : processor.getResultList()) {\n          String name = le.getLookupString();\n          if (!names_already.contains(name)) {\n            result.add(le);\n            names_already.add(name);\n          }\n        }\n      }\n      else result.addAll(processor.getResultList());\n    }\n    else /*if (role == AS_MODULE)*/ { // when being imported, add submodules\n      for (PsiFileSystemItem pfsi : getSubmodulesList()) {\n        String s = pfsi.getName();\n        int pos = s.lastIndexOf('.'); // it may not contain a dot, except in extension; cut it off.\n        if (pos > 0) s = s.substring(0, pos);\n        if (!PyNames.isIdentifier(s)) continue;\n        if (names_already != null) {\n          if (names_already.contains(s)) continue;\n          else names_already.add(s);\n        }\n        result.add(LookupElementBuilder.create(pfsi, s).setPresentableText(s));\n      }\n    }\n    return result.toArray();\n  }","commit_id":"f92fc0a5772605d575c3ffcc22f1f3a52e9be02d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getCompletionVariants(final PyReferenceExpression referenceExpression, ProcessingContext context) {\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","id":76308,"modified_method":"public Object[] getCompletionVariants(final PyQualifiedExpression referenceExpression, ProcessingContext context) {\n    return ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","commit_id":"f92fc0a5772605d575c3ffcc22f1f3a52e9be02d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ASTNode getNameElement() {\n    return getNode().findChildByType(PyTokenTypes.IDENTIFIER);\n  }","id":76309,"modified_method":"@Nullable\n  public ASTNode getNameElement() {\n    return getNode().findChildByType(PyTokenTypes.IDENTIFIER);\n  }","commit_id":"f92fc0a5772605d575c3ffcc22f1f3a52e9be02d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement setName(@NotNull String name) throws IncorrectOperationException {\n    final ASTNode nameElement = PyElementGenerator.getInstance(getProject()).createNameIdentifier(name);\n    getNode().replaceChild(getNameElement(), nameElement);\n    return this;\n  }","id":76310,"modified_method":"public PsiElement setName(@NotNull String name) throws IncorrectOperationException {\n    final ASTNode oldNameElement = getNameElement();\n    if (oldNameElement != null) {\n      final ASTNode nameElement = PyElementGenerator.getInstance(getProject()).createNameIdentifier(name);\n      getNode().replaceChild(oldNameElement, nameElement);\n    }\n    return this;\n  }","commit_id":"f92fc0a5772605d575c3ffcc22f1f3a52e9be02d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getDisplayName() {\n    return DISPLAY_NAME;\n  }","id":76311,"modified_method":"@NotNull\n  public String getDisplayName() {\n    return InspectionsBundle.message(\"inspection.javadoc.ref.display.name\");\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private ProblemDescriptor[] checkMember(final PsiDocCommentOwner docCommentOwner, final InspectionManager manager, final boolean isOnTheFly) {\n    ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>();\n    final PsiDocComment docComment = docCommentOwner.getDocComment();\n    if (docComment == null) return null;\n\n    final Set<PsiJavaCodeReferenceElement> references = new HashSet<PsiJavaCodeReferenceElement>();\n    docComment.accept(getVisitor(references, docCommentOwner, problems, manager, isOnTheFly));\n    for (PsiJavaCodeReferenceElement reference : references) {\n      final List<PsiClass> classesToImport = new ImportClassFix(reference).getClassesToImport();\n      final PsiElement referenceNameElement = reference.getReferenceNameElement();\n      problems.add(manager.createProblemDescriptor(referenceNameElement != null ? referenceNameElement : reference, cannotResolveSymbolMessage(\"<code>\" + reference.getText() + \"<\/code>\"),\n                                                   !isOnTheFly || classesToImport.isEmpty() ? null : new AddImportFix(classesToImport), ProblemHighlightType.LIKE_UNKNOWN_SYMBOL,\n                                                   isOnTheFly));\n    }\n\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","id":76312,"modified_method":"@Nullable\n  private ProblemDescriptor[] checkMember(final PsiDocCommentOwner docCommentOwner, final InspectionManager manager, final boolean isOnTheFly) {\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>();\n    final PsiDocComment docComment = docCommentOwner.getDocComment();\n    if (docComment == null) return null;\n\n    final Set<PsiJavaCodeReferenceElement> references = new HashSet<PsiJavaCodeReferenceElement>();\n    docComment.accept(getVisitor(references, docCommentOwner, problems, manager, isOnTheFly));\n    for (PsiJavaCodeReferenceElement reference : references) {\n      final List<PsiClass> classesToImport = new ImportClassFix(reference).getClassesToImport();\n      final PsiElement referenceNameElement = reference.getReferenceNameElement();\n      problems.add(manager.createProblemDescriptor(referenceNameElement != null ? referenceNameElement : reference,\n                                                   cannotResolveSymbolMessage(\"<code>\" + reference.getText() + \"<\/code>\"),\n                                                   !isOnTheFly || classesToImport.isEmpty() ? null : new AddImportFix(classesToImport),\n                                                   ProblemHighlightType.LIKE_UNKNOWN_SYMBOL, isOnTheFly));\n    }\n\n    return problems.isEmpty() ? null : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ProblemDescriptor createDescriptor(@NotNull PsiElement element, String template, InspectionManager manager,\n                                                    boolean onTheFly) {\n    return manager.createProblemDescriptor(element, template, onTheFly, (LocalQuickFix [])null, ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n  }","id":76313,"modified_method":"private static ProblemDescriptor createDescriptor(@NotNull PsiElement element, String template, InspectionManager manager,\n                                                    boolean onTheFly) {\n    return manager.createProblemDescriptor(element, template, onTheFly, null, ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void visitRefInDocTag(final PsiDocTag tag, final JavadocManager manager, final PsiElement context, ArrayList<ProblemDescriptor> problems,\n                                      InspectionManager inspectionManager,\n                                      boolean onTheFly) {\n    final String tagName = tag.getName();\n    PsiDocTagValue value = tag.getValueElement();\n    if (value == null) return;\n    final JavadocTagInfo info = manager.getTagInfo(tagName);\n    if (info != null && !info.isValidInContext(context)) return;\n    String message = info == null || !info.isInline() ? null : info.checkTagValue(value);\n    if (message != null){\n      problems.add(createDescriptor(value, message, inspectionManager, onTheFly));\n    }\n    final PsiReference reference = value.getReference();\n    if (reference != null) {\n      PsiElement element = reference.resolve();\n      if (element == null) {\n        final int textOffset = value.getTextOffset();\n\n        if (textOffset != value.getTextRange().getEndOffset()) {\n          final PsiDocTagValue valueElement = tag.getValueElement();\n          if (valueElement != null) {\n            final CharSequence paramName =\n              value.getContainingFile().getViewProvider().getContents().subSequence(textOffset, value.getTextRange().getEndOffset());\n            @NonNls String params = \"<code>\" + paramName + \"<\/code>\";\n\n            final List<LocalQuickFix> fixes = new ArrayList<LocalQuickFix>();\n            if (onTheFly && \"param\".equals(tagName)) {\n              final PsiDocCommentOwner commentOwner = PsiTreeUtil.getParentOfType(tag, PsiDocCommentOwner.class);\n              if (commentOwner instanceof PsiMethod) {\n                final PsiMethod method = (PsiMethod)commentOwner;\n                final PsiParameter[] parameters = method.getParameterList().getParameters();\n                final PsiDocTag[] tags = tag.getContainingComment().getTags();\n                final Set<String> unboundParams = new HashSet<String>();\n                for (PsiParameter parameter : parameters) {\n                  if (!JavaDocLocalInspection.isFound(tags, parameter)) {\n                    unboundParams.add(parameter.getName());\n                  }\n                }\n                if (!unboundParams.isEmpty()) {\n                  fixes.add(new RenameReferenceQuickFix(unboundParams));\n                }\n              }\n            }\n            fixes.add(new RemoveTagFix(tagName, paramName, tag));\n\n            problems.add(inspectionManager.createProblemDescriptor(valueElement, reference.getRangeInElement(), cannotResolveSymbolMessage(params),\n                                                                   ProblemHighlightType.LIKE_UNKNOWN_SYMBOL, onTheFly,\n                                                                   fixes.toArray(new LocalQuickFix[fixes.size()])));\n          }\n        }\n      }\n    }\n  }","id":76314,"modified_method":"public static void visitRefInDocTag(final PsiDocTag tag,\n                                      final JavadocManager manager,\n                                      final PsiElement context,\n                                      final ArrayList<ProblemDescriptor> problems,\n                                      final InspectionManager inspectionManager,\n                                      final boolean onTheFly) {\n    final String tagName = tag.getName();\n    final PsiDocTagValue value = tag.getValueElement();\n    if (value == null) return;\n    final JavadocTagInfo info = manager.getTagInfo(tagName);\n    if (info != null && !info.isValidInContext(context)) return;\n    final String message = info == null || !info.isInline() ? null : info.checkTagValue(value);\n    if (message != null){\n      problems.add(createDescriptor(value, message, inspectionManager, onTheFly));\n    }\n\n    final PsiReference reference = value.getReference();\n    if (reference == null) return;\n    final PsiElement element = reference.resolve();\n    if (element != null) return;\n    final int textOffset = value.getTextOffset();\n    if (textOffset == value.getTextRange().getEndOffset()) return;\n    final PsiDocTagValue valueElement = tag.getValueElement();\n    if (valueElement == null) return;\n\n    final CharSequence paramName = value.getContainingFile().getViewProvider().getContents().subSequence(textOffset, value.getTextRange().getEndOffset());\n    final String params = \"<code>\" + paramName + \"<\/code>\";\n    final List<LocalQuickFix> fixes = new ArrayList<LocalQuickFix>();\n    if (onTheFly && \"param\".equals(tagName)) {\n      final PsiDocCommentOwner commentOwner = PsiTreeUtil.getParentOfType(tag, PsiDocCommentOwner.class);\n      if (commentOwner instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)commentOwner;\n        final PsiParameter[] parameters = method.getParameterList().getParameters();\n        final PsiDocTag[] tags = tag.getContainingComment().getTags();\n        final Set<String> unboundParams = new HashSet<String>();\n        for (PsiParameter parameter : parameters) {\n          if (!JavaDocLocalInspection.isFound(tags, parameter)) {\n            unboundParams.add(parameter.getName());\n          }\n        }\n        if (!unboundParams.isEmpty()) {\n          fixes.add(new RenameReferenceQuickFix(unboundParams));\n        }\n      }\n    }\n    fixes.add(new RemoveTagFix(tagName, paramName, tag));\n\n    problems.add(inspectionManager.createProblemDescriptor(valueElement, reference.getRangeInElement(), cannotResolveSymbolMessage(params),\n                                                           ProblemHighlightType.LIKE_UNKNOWN_SYMBOL, onTheFly,\n                                                           fixes.toArray(new LocalQuickFix[fixes.size()])));\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param methodSignature\n   * @param superMethodSignature\n   * @return null if signatures do not match\n   */\n  public static PsiSubstitutor getSuperMethodSignatureSubstitutor(MethodSignature methodSignature, MethodSignature superMethodSignature) {\n    PsiSubstitutor result = getSuperMethodSignatureSubstitutorImpl(methodSignature, superMethodSignature);\n    if (result == null) return null;\n\n    PsiTypeParameter[] methoTypeParameters = methodSignature.getTypeParameters();\n    PsiTypeParameter[] superTypeParameters = superMethodSignature.getTypeParameters();\n    PsiSubstitutor methodSubstitutor = methodSignature.getSubstitutor();\n\n    //check bounds\n    for (int i = 0; i < methoTypeParameters.length; i++) {\n      PsiTypeParameter methoTypeParameter = methoTypeParameters[i];\n      PsiTypeParameter superTypeParameter = superTypeParameters[i];\n      final Set<PsiType> methoSupers = new HashSet<PsiType>();\n      for (PsiClassType methoSuper : methoTypeParameter.getSuperTypes()) {\n        methoSupers.add(methodSubstitutor.substitute(methoSuper));\n      }\n\n      final Set<PsiType> superSupers = new HashSet<PsiType>();\n      for (PsiClassType superSuper : superTypeParameter.getSuperTypes()) {\n        superSupers.add(methodSubstitutor.substitute(PsiUtil.captureToplevelWildcards(result.substitute(superSuper), methoTypeParameter)));\n      }\n      if (!methoSupers.equals(superSupers)) return null;\n    }\n    return result;\n  }","id":76315,"modified_method":"/**\n   * @param methodSignature method signature\n   * @param superMethodSignature super method signature\n   * @return null if signatures do not match\n   */\n  @Nullable\n  public static PsiSubstitutor getSuperMethodSignatureSubstitutor(MethodSignature methodSignature, MethodSignature superMethodSignature) {\n    PsiSubstitutor result = getSuperMethodSignatureSubstitutorImpl(methodSignature, superMethodSignature);\n    if (result == null) return null;\n\n    PsiTypeParameter[] methodTypeParameters = methodSignature.getTypeParameters();\n    PsiTypeParameter[] superTypeParameters = superMethodSignature.getTypeParameters();\n    PsiSubstitutor methodSubstitutor = methodSignature.getSubstitutor();\n\n    //check bounds\n    for (int i = 0; i < methodTypeParameters.length; i++) {\n      PsiTypeParameter methodTypeParameter = methodTypeParameters[i];\n      PsiTypeParameter superTypeParameter = superTypeParameters[i];\n      final Set<PsiType> methodSupers = new HashSet<PsiType>();\n      for (PsiClassType methodSuper : methodTypeParameter.getSuperTypes()) {\n        methodSupers.add(methodSubstitutor.substitute(methodSuper));\n      }\n\n      final Set<PsiType> superSupers = new HashSet<PsiType>();\n      for (PsiClassType superSuper : superTypeParameter.getSuperTypes()) {\n        superSupers.add(methodSubstitutor.substitute(PsiUtil.captureToplevelWildcards(result.substitute(superSuper), methodTypeParameter)));\n      }\n      if (!methodSupers.equals(superSupers)) return null;\n    }\n\n    return result;\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean areParametersErasureEqual(PsiMethod method1, PsiMethod method2) {\n    return METHOD_PARAMETERS_ERASURE_EQUALITY.equals(method1.getSignature(PsiSubstitutor.EMPTY),\n                                                     method2.getSignature(PsiSubstitutor.EMPTY));\n  }","id":76316,"modified_method":"public static boolean areParametersErasureEqual(PsiMethod method1, PsiMethod method2) {\n    return areSignaturesErasureEqual(method1.getSignature(PsiSubstitutor.EMPTY), method2.getSignature(PsiSubstitutor.EMPTY));\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiMethod findMethodBySuperMethod(final PsiClass aClass, PsiMethod method, final boolean checkBases) {\n    List<Pair<PsiMethod, PsiSubstitutor>> pairs = aClass.findMethodsAndTheirSubstitutorsByName(method.getName(), checkBases);\n    for (Pair<PsiMethod, PsiSubstitutor> pair : pairs) {\n      PsiMethod candidate = pair.first;\n      PsiSubstitutor substitutor = pair.second;\n      MethodSignature candidateSignature = candidate.getSignature(substitutor);\n      PsiSubstitutor superSubstitutor = TypeConversionUtil.getClassSubstitutor(method.getContainingClass(), candidate.getContainingClass(), substitutor);\n      if (superSubstitutor == null) continue;\n      MethodSignature superSignature = method.getSignature(superSubstitutor);\n      if (isSubsignature(superSignature, candidateSignature)) return candidate;\n    }\n    return null;\n  }","id":76317,"modified_method":"@Nullable\n  public static PsiMethod findMethodBySuperMethod(final PsiClass aClass, PsiMethod method, final boolean checkBases) {\n    List<Pair<PsiMethod, PsiSubstitutor>> pairs = aClass.findMethodsAndTheirSubstitutorsByName(method.getName(), checkBases);\n    for (Pair<PsiMethod, PsiSubstitutor> pair : pairs) {\n      PsiMethod candidate = pair.first;\n      PsiSubstitutor substitutor = pair.second;\n      MethodSignature candidateSignature = candidate.getSignature(substitutor);\n      final PsiClass methodClass = method.getContainingClass();\n      final PsiClass candidateClass = candidate.getContainingClass();\n      if (methodClass == null || candidateClass == null) continue;\n      PsiSubstitutor superSubstitutor = TypeConversionUtil.getClassSubstitutor(methodClass, candidateClass, substitutor);\n      if (superSubstitutor == null) continue;\n      MethodSignature superSignature = method.getSignature(superSubstitutor);\n      if (isSubsignature(superSignature, candidateSignature)) return candidate;\n    }\n    return null;\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PsiReference getReferenceInScope(PsiElement scope, PsiElement element) {\n    final String name = element.getText();\n\n\n    final String[] signature = getSignature();\n\n    if (signature == null) {\n      final PsiVariable[] vars = getAllVariables(scope, this);\n      for (PsiVariable var : vars) {\n        if (!var.getName().equals(name)) continue;\n        return new MyReference(var);\n      }\n    }\n\n    final PsiMethod[] methods = getAllMethods(scope, this);\n\n    nextMethod:\n    for (PsiMethod method : methods) {\n      if (!method.getName().equals(name)) continue;\n\n      if (signature == null) {\n        return new MyReference(method);\n      }\n      else {\n        final PsiParameter[] parameters = method.getParameterList().getParameters();\n        if (parameters.length != signature.length) continue;\n        for (int j = 0; j < parameters.length; j++) {\n          PsiParameter parameter = parameters[j];\n          PsiType type1 = TypeConversionUtil.erasure(parameter.getType());\n          String type2 = signature[j];\n          if (!Comparing.strEqual(type1.getPresentableText(), type2) && !Comparing.strEqual(type1.getCanonicalText(), type2)) {\n            String shortName = \"\";\n            PsiClass psiClass = PsiUtil.resolveClassInType(type1);\n            while (psiClass != null) {\n              shortName = psiClass.getName() + (shortName.length() > 0 ? \".\" + shortName : \"\");\n              psiClass = PsiTreeUtil.getParentOfType(psiClass, PsiClass.class);\n            }\n            if (!Comparing.strEqual(shortName, type2)) {\n              continue nextMethod;\n            }\n          }\n        }\n\n        return new MyReference(method) {\n          @NotNull\n          public PsiElement[] getVariants() {\n            final List<PsiMethod> lst = new ArrayList<PsiMethod>();\n            for (PsiMethod method : methods) {\n              if (name.equals(method.getName())) {\n                lst.add(method);\n              }\n            }\n            return lst.toArray(new PsiMethod[lst.size()]);\n          }\n        };\n      }\n    }\n    return null;\n  }","id":76318,"modified_method":"@Nullable\n  private PsiReference getReferenceInScope(PsiElement scope, PsiElement element) {\n    final String name = element.getText();\n    final String[] signature = getSignature();\n\n    if (signature == null) {\n      final PsiVariable[] vars = getAllVariables(scope, this);\n      for (PsiVariable var : vars) {\n        if (!var.getName().equals(name)) continue;\n        return new MyReference(var);\n      }\n    }\n\n    final MethodSignature methodSignature;\n    if (signature != null) {\n      final List<PsiType> types = Lists.newArrayListWithCapacity(signature.length);\n      final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(element.getProject()).getElementFactory();\n      for (String s : signature) {\n        try {\n          types.add(elementFactory.createTypeFromText(s, scope));\n        }\n        catch (IncorrectOperationException e) {\n          types.add(PsiType.NULL);\n        }\n      }\n      methodSignature = MethodSignatureUtil.createMethodSignature(name, types.toArray(new PsiType[types.size()]),\n                                                                  PsiTypeParameter.EMPTY_ARRAY, PsiSubstitutor.EMPTY);\n    }\n    else {\n      methodSignature = MethodSignatureUtil.createMethodSignature(name, PsiType.EMPTY_ARRAY,\n                                                                  PsiTypeParameter.EMPTY_ARRAY, PsiSubstitutor.EMPTY);\n    }\n\n    final PsiMethod[] methods = getAllMethods(scope, this);\n    for (PsiMethod method : methods) {\n      if (!method.getName().equals(name) ||\n          !MethodSignatureUtil.areSignaturesErasureEqual(methodSignature, method.getSignature(PsiSubstitutor.EMPTY))) continue;\n      return new MyReference(method) {\n        @NotNull\n        public PsiElement[] getVariants() {\n          final List<PsiMethod> lst = new ArrayList<PsiMethod>();\n          for (PsiMethod method : methods) {\n            if (name.equals(method.getName())) {\n              lst.add(method);\n            }\n          }\n          return lst.toArray(new PsiMethod[lst.size()]);\n        }\n      };\n    }\n\n    return null;\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String getCanonicalText() {\n      return getNameElement().getText();\n    }","id":76319,"modified_method":"@NotNull\n    public String getCanonicalText() {\n      final PsiElement nameElement = getNameElement();\n      assert nameElement != null;\n      return nameElement.getText();\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement resolve() {\n      return myReferencee;\n    }","id":76320,"modified_method":"public PsiElement resolve() {\n      return myReferredElement;\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public JavaResolveResult[] multiResolve(boolean incompleteCode) {\n      return myReferencee == null ? JavaResolveResult.EMPTY_ARRAY : new JavaResolveResult[]{new CandidateInfo(myReferencee, PsiSubstitutor.EMPTY)};\n    }","id":76321,"modified_method":"@NotNull\n    public JavaResolveResult[] multiResolve(boolean incompleteCode) {\n      return myReferredElement == null ? JavaResolveResult.EMPTY_ARRAY\n                                  : new JavaResolveResult[]{new CandidateInfo(myReferredElement, PsiSubstitutor.EMPTY)};\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TextRange getRangeInElement() {\n      final ASTNode sharp = findChildByType(DOC_TAG_VALUE_SHARP_TOKEN);\n      if (sharp == null) return new TextRange(0, getTextLength());\n      final PsiElement nextSibling = SourceTreeToPsiMap.treeElementToPsi(sharp).getNextSibling();\n      if(nextSibling != null){\n        final int startOffset = nextSibling.getTextRange().getStartOffset() - getTextRange().getStartOffset();\n        int endOffset = nextSibling.getTextRange().getEndOffset() - getTextRange().getStartOffset();\n        final PsiElement nextParSibling = nextSibling.getNextSibling();\n        if(nextParSibling != null && \"(\".equals(nextParSibling.getText())){\n          endOffset ++;\n          PsiElement nextElement = nextParSibling.getNextSibling();\n          if(nextElement != null && SourceTreeToPsiMap.psiElementToTree(nextElement).getElementType() == DOC_TAG_VALUE_TOKEN){\n            endOffset += nextElement.getTextLength();\n            nextElement = nextElement.getNextSibling();\n          }\n          if(nextElement != null && \")\".equals(nextElement.getText())){\n            endOffset ++;\n          }\n        }\n        return new TextRange(startOffset, endOffset);\n      }\n      return new TextRange(getTextLength(), getTextLength());\n    }","id":76322,"modified_method":"public TextRange getRangeInElement() {\n      final ASTNode sharp = findChildByType(DOC_TAG_VALUE_SHARP_TOKEN);\n      if (sharp == null) return new TextRange(0, getTextLength());\n      final PsiElement nextSibling = SourceTreeToPsiMap.treeToPsiNotNull(sharp).getNextSibling();\n      if (nextSibling != null) {\n        final int startOffset = nextSibling.getTextRange().getStartOffset() - getTextRange().getStartOffset();\n        int endOffset = nextSibling.getTextRange().getEndOffset() - getTextRange().getStartOffset();\n        final PsiElement nextParSibling = nextSibling.getNextSibling();\n        if (nextParSibling != null && \"(\".equals(nextParSibling.getText())) {\n          endOffset++;\n          PsiElement nextElement = nextParSibling.getNextSibling();\n          if (nextElement != null && SourceTreeToPsiMap.psiToTreeNotNull(nextElement).getElementType() == DOC_TAG_VALUE_TOKEN) {\n            endOffset += nextElement.getTextLength();\n            nextElement = nextElement.getNextSibling();\n          }\n          if (nextElement != null && \")\".equals(nextElement.getText())) {\n            endOffset++;\n          }\n        }\n        return new TextRange(startOffset, endOffset);\n      }\n      return new TextRange(getTextLength(), getTextLength());\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public JavaResolveResult advancedResolve(boolean incompleteCode) {\n      return myReferencee == null ? JavaResolveResult.EMPTY : new CandidateInfo(myReferencee, PsiSubstitutor.EMPTY);\n    }","id":76323,"modified_method":"@NotNull\n    public JavaResolveResult advancedResolve(boolean incompleteCode) {\n      return myReferredElement == null ? JavaResolveResult.EMPTY\n                                  : new CandidateInfo(myReferredElement, PsiSubstitutor.EMPTY);\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String[] getSignature() {\n    PsiElement element = getNameElement().getNextSibling();\n\n    while (element != null && !(element instanceof PsiDocTagValue)) {\n      element = element.getNextSibling();\n    }\n\n    if (element == null) return null;\n\n    List<String> types = new ArrayList<String>();\n    for (PsiElement child = element.getFirstChild(); child != null; child = child.getNextSibling()) {\n      if (child.getNode().getElementType() == DOC_TYPE_HOLDER) {\n        final String[] typeStrings = child.getText().split(\"[, ]\");  //avoid param types list parsing hmm mathod(paramType1, paramType2, ...) -> typeElement1, identifier2, ...\n        if (typeStrings != null) {\n          for (String type : typeStrings) {\n            if (type.length() > 0) {\n              types.add(type);\n            }\n          }\n        }\n      }\n    }\n\n    return ArrayUtil.toStringArray(types);\n  }","id":76324,"modified_method":"@Nullable\n  public String[] getSignature() {\n    PsiElement element = getNameElement();\n    if (element == null) return null;\n\n    element = element.getNextSibling();\n    while (element != null && !(element instanceof PsiDocTagValue)) {\n      element = element.getNextSibling();\n    }\n    if (element == null) return null;\n\n    List<String> types = new ArrayList<String>();\n    for (PsiElement child = element.getFirstChild(); child != null; child = child.getNextSibling()) {\n      if (child.getNode().getElementType() == DOC_TYPE_HOLDER) {\n        final String[] typeStrings = child.getText().split(\"[, ]\");  //avoid param types list parsing hmm method(paramType1, paramType2, ...) -> typeElement1, identifier2, ...\n        if (typeStrings != null) {\n          for (String type : typeStrings) {\n            if (type.length() > 0) {\n              types.add(type);\n            }\n          }\n        }\n      }\n    }\n\n    return ArrayUtil.toStringArray(types);\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getNameElement() {\n    final ASTNode sharp = findChildByType(DOC_TAG_VALUE_SHARP_TOKEN);\n    if (sharp == null) return null;\n    return SourceTreeToPsiMap.treeElementToPsi(sharp).getNextSibling();\n  }","id":76325,"modified_method":"@Nullable\n  public PsiElement getNameElement() {\n    final ASTNode sharp = findChildByType(DOC_TAG_VALUE_SHARP_TOKEN);\n    return sharp != null ? SourceTreeToPsiMap.treeToPsiNotNull(sharp).getNextSibling() : null;\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement bindToText(PsiClass containingClass, StringBuffer newText) {\n      PsiComment comment =\n        JavaPsiFacade.getInstance(containingClass.getProject()).getElementFactory().createCommentFromText(newText.toString(), null);\n      PsiElement tag = PsiTreeUtil.getChildOfType(comment, PsiDocTag.class);\n      PsiElement ref = PsiTreeUtil.getChildOfType(tag, PsiDocMethodOrFieldRef.class);\n      return replace(ref);\n    }","id":76326,"modified_method":"public PsiElement bindToText(PsiClass containingClass, StringBuffer newText) {\n      PsiElementFactory elementFactory = JavaPsiFacade.getInstance(containingClass.getProject()).getElementFactory();\n      PsiComment comment = elementFactory.createCommentFromText(newText.toString(), null);\n      PsiElement tag = PsiTreeUtil.getChildOfType(comment, PsiDocTag.class);\n      PsiElement ref = PsiTreeUtil.getChildOfType(tag, PsiDocMethodOrFieldRef.class);\n      assert ref != null : newText;\n      return replace(ref);\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n      if (isReferenceTo(element)) return PsiDocMethodOrFieldRef.this;\n      final String name = getNameElement().getText();\n      final String newName;\n\n      final PsiMethod method;\n      final PsiField field;\n      final boolean hasSignature;\n      final PsiClass containingClass;\n      if (element instanceof PsiMethod) {\n        method = (PsiMethod)element;\n        hasSignature = getSignature() != null;\n        containingClass = method.getContainingClass();\n        newName = method.getName();\n      } else if (element instanceof PsiField) {\n        field = (PsiField) element;\n        hasSignature = false;\n        containingClass = field.getContainingClass();\n        method = null;\n        newName = field.getName();\n      } else {\n        throw new IncorrectOperationException();\n      }\n\n\n      if (getFirstChild().getNode().getElementType() == ElementType.DOC_REFERENCE_HOLDER) {\n        PsiJavaCodeReferenceElement referenceElement = (PsiJavaCodeReferenceElement) getFirstChild().getFirstChild();\n        referenceElement.bindToElement(containingClass);\n      }\n      else {\n        if (!PsiTreeUtil.isAncestor(containingClass, PsiDocMethodOrFieldRef.this, true)) {\n          final PsiReferenceExpression ref =\n            JavaPsiFacade.getInstance(containingClass.getProject()).getElementFactory().createReferenceExpression(containingClass);\n          addAfter(ref, null);\n        }\n      }\n\n      if (hasSignature || !name.equals(newName)) {\n        String text = getText();\n\n        @NonNls StringBuffer newText = new StringBuffer();\n        newText.append(\"/** @see \");\n        if (name.equals(newName)) { // hasSignature is true here, so we can search for '('\n          newText.append(text.substring(0, text.indexOf('(')));\n        }\n        else {\n          final int sharpIndex = text.indexOf('#');\n          if (sharpIndex >= 0) {\n            newText.append(text.substring(0, sharpIndex + 1));\n          }\n          newText.append(newName);\n        }\n        if (hasSignature) {\n          newText.append('(');\n          PsiParameter[] parameters = method.getParameterList().getParameters();\n          for (int i = 0; i < parameters.length; i++) {\n            PsiParameter parameter = parameters[i];\n            if (i > 0) newText.append(\",\");\n            newText.append(parameter.getType().getCanonicalText());\n          }\n          newText.append(')');\n        }\n        newText.append(\"*/\");\n\n        return bindToText(containingClass, newText);\n      }\n\n      return PsiDocMethodOrFieldRef.this;\n    }","id":76327,"modified_method":"public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n      if (isReferenceTo(element)) return PsiDocMethodOrFieldRef.this;\n      final PsiElement nameElement = getNameElement();\n      assert nameElement != null;\n      final String name = nameElement.getText();\n      final String newName;\n\n      final PsiMethod method;\n      final PsiField field;\n      final boolean hasSignature;\n      final PsiClass containingClass;\n      if (element instanceof PsiMethod) {\n        method = (PsiMethod)element;\n        hasSignature = getSignature() != null;\n        containingClass = method.getContainingClass();\n        newName = method.getName();\n      } else if (element instanceof PsiField) {\n        field = (PsiField) element;\n        hasSignature = false;\n        containingClass = field.getContainingClass();\n        method = null;\n        newName = field.getName();\n      } else {\n        throw new IncorrectOperationException();\n      }\n\n      final PsiElement child = getFirstChild();\n      if (containingClass != null && child != null && child.getNode().getElementType() == ElementType.DOC_REFERENCE_HOLDER) {\n        final PsiJavaCodeReferenceElement referenceElement = (PsiJavaCodeReferenceElement) child.getFirstChild();\n        assert referenceElement != null;\n        referenceElement.bindToElement(containingClass);\n      }\n      else {\n        if (containingClass != null && !PsiTreeUtil.isAncestor(containingClass, PsiDocMethodOrFieldRef.this, true)) {\n          final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(containingClass.getProject()).getElementFactory();\n          final PsiReferenceExpression ref = elementFactory.createReferenceExpression(containingClass);\n          addAfter(ref, null);\n        }\n      }\n\n      if (hasSignature || !name.equals(newName)) {\n        String text = getText();\n\n        @NonNls StringBuffer newText = new StringBuffer();\n        newText.append(\"/** @see \");\n        if (name.equals(newName)) { // hasSignature is true here, so we can search for '('\n          newText.append(text.substring(0, text.indexOf('(')));\n        }\n        else {\n          final int sharpIndex = text.indexOf('#');\n          if (sharpIndex >= 0) {\n            newText.append(text.substring(0, sharpIndex + 1));\n          }\n          newText.append(newName);\n        }\n        if (hasSignature) {\n          newText.append('(');\n          PsiParameter[] parameters = method.getParameterList().getParameters();\n          for (int i = 0; i < parameters.length; i++) {\n            PsiParameter parameter = parameters[i];\n            if (i > 0) newText.append(\",\");\n            newText.append(parameter.getType().getCanonicalText());\n          }\n          newText.append(')');\n        }\n        newText.append(\"*/\");\n\n        return bindToText(containingClass, newText);\n      }\n\n      return PsiDocMethodOrFieldRef.this;\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n      final PsiElement element = getNameElement();\n      final ASTNode treeElement = SourceTreeToPsiMap.psiElementToTree(element);\n      final CharTable charTableByTree = SharedImplUtil.findCharTableByTree(treeElement);\n      LeafElement newToken = Factory.createSingleLeafElement(DOC_TAG_VALUE_TOKEN, newElementName, charTableByTree, getManager());\n      ((CompositeElement)treeElement.getTreeParent()).replaceChildInternal(SourceTreeToPsiMap.psiElementToTree(element), newToken);\n      return SourceTreeToPsiMap.treeElementToPsi(newToken);\n    }","id":76328,"modified_method":"public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n      final PsiElement nameElement = getNameElement();\n      assert nameElement != null;\n      final ASTNode treeElement = SourceTreeToPsiMap.psiToTreeNotNull(nameElement);\n      final CharTable charTableByTree = SharedImplUtil.findCharTableByTree(treeElement);\n      final LeafElement newToken = Factory.createSingleLeafElement(DOC_TAG_VALUE_TOKEN, newElementName, charTableByTree, getManager());\n      ((CompositeElement)treeElement.getTreeParent()).replaceChildInternal(SourceTreeToPsiMap.psiToTreeNotNull(nameElement), newToken);\n      return SourceTreeToPsiMap.treeToPsiNotNull(newToken);\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MyReference(PsiElement referencee) {\n      myReferencee = referencee;\n    }","id":76329,"modified_method":"public MyReference(PsiElement referredElement) {\n      myReferredElement = referredElement;\n    }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getTextOffset() {\n    final PsiElement element = getNameElement();\n\n    if (element != null) {\n      return element.getTextRange().getStartOffset();\n    }\n\n    return getTextRange().getEndOffset();\n  }","id":76330,"modified_method":"public int getTextOffset() {\n    final PsiElement element = getNameElement();\n    return element != null ? element.getTextRange().getStartOffset() : getTextRange().getEndOffset();\n  }","commit_id":"c3b799c246fec8676644af5db5f26f46fe923288","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkInlineTags(final InspectionManager inspectionManager,\n                               final ArrayList<ProblemDescriptor> problems,\n                               final PsiElement[] dataElements,\n                               final JavadocManager manager) {\n    for (PsiElement dataElement : dataElements) {\n      if (dataElement instanceof PsiInlineDocTag) {\n        final PsiInlineDocTag inlineDocTag = (PsiInlineDocTag)dataElement;\n        if (manager.getTagInfo(inlineDocTag.getName()) == null) {\n          problems.add(createDescriptor(inlineDocTag.getNameElement(), InspectionsBundle.message(\"inspection.javadoc.problem.wrong.tag\", \"<code>\" + inlineDocTag.getName() + \"<\/code>\"), new AddUnknownTagToCustoms(inlineDocTag), inspectionManager));\n        }\n      }\n    }\n  }","id":76331,"modified_method":"private void checkInlineTags(final InspectionManager inspectionManager,\n                               final ArrayList<ProblemDescriptor> problems,\n                               final PsiElement[] dataElements,\n                               final JavadocManager manager) {\n    for (PsiElement dataElement : dataElements) {\n      if (dataElement instanceof PsiInlineDocTag) {\n        final PsiInlineDocTag inlineDocTag = (PsiInlineDocTag)dataElement;\n        if (manager.getTagInfo(inlineDocTag.getName()) == null) {\n          final PsiElement nameElement = inlineDocTag.getNameElement();\n          if (nameElement != null) {\n            problems.add(createDescriptor(nameElement, InspectionsBundle.message(\"inspection.javadoc.problem.wrong.tag\", \"<code>\" + inlineDocTag.getName() + \"<\/code>\"), new AddUnknownTagToCustoms(inlineDocTag), inspectionManager));\n          }\n        }\n      }\n    }\n  }","commit_id":"8b76cf1b34621cfd0939723ab000eeb9b53ff58c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reportError(final ASTNode nameIdentifier, final String s, ProblemKind kind, final IntentionAction... fixes) {\n      final ValidationHost.ErrorType errorType = kind == ProblemKind.ERROR ? ValidationHost.ErrorType.ERROR: ValidationHost.ErrorType.WARNING;\n      myHost.addMessage(nameIdentifier.getPsi(), s, errorType, fixes);\n    }","id":76332,"modified_method":"public void reportError(final ASTNode nameIdentifier, final String s, ProblemKind kind, final IntentionAction... fixes) {\n      final ValidationHost.ErrorType errorType = kind == ProblemKind.ERROR ? ValidationHost.ErrorType.ERROR: ValidationHost.ErrorType.WARNING;\n      if (myHost instanceof IdeValidationHost) {\n        ((IdeValidationHost) myHost).addMessageWithFixes(nameIdentifier.getPsi(), s, errorType, fixes);\n      }\n      else {\n        myHost.addMessage(nameIdentifier.getPsi(), s, errorType);\n      }\n    }","commit_id":"eb90676dbbc99ac6d455c9b5fced7e79f08b8197","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void addErrorMessage(final XmlElement element,\n                                      final String message,\n                                      final Validator.ValidationHost host,\n                                      final IntentionAction... intentionActions) {\n    if (element instanceof XmlAttributeValue) {\n      final ASTNode node = element.getNode();\n      final ASTNode value = node == null ? null : XmlChildRole.ATTRIBUTE_VALUE_VALUE_FINDER.findChild(node);\n      if (value instanceof PsiElement) {\n        host.addMessage((PsiElement)value, message, Validator.ValidationHost.ErrorType.ERROR, intentionActions);\n      }\n      else {\n        host.addMessage(element, message, Validator.ValidationHost.ErrorType.ERROR, intentionActions);\n      }\n    }\n    else if (element instanceof XmlAttributeImpl) {\n      host.addMessage(((XmlAttributeImpl)element).getNameElement(), message, Validator.ValidationHost.ErrorType.ERROR, intentionActions);\n    }\n    else if (element instanceof XmlTag) {\n      final XmlToken startingTag = XmlTagUtil.getStartTagNameElement((XmlTag)element);\n      if (startingTag != null) {\n        host.addMessage(startingTag, message, Validator.ValidationHost.ErrorType.ERROR, intentionActions);\n      }\n      final XmlToken closingTag = XmlTagUtil.getEndTagNameElement((XmlTag)element);\n      if (closingTag != null) {\n        host.addMessage(closingTag, message, Validator.ValidationHost.ErrorType.ERROR, intentionActions);\n      }\n    }\n    else {\n      host.addMessage(element, message, Validator.ValidationHost.ErrorType.ERROR, intentionActions);\n    }\n  }","id":76333,"modified_method":"private static void addErrorMessage(final XmlElement element,\n                                      final String message,\n                                      final Validator.ValidationHost host,\n                                      final IntentionAction... intentionActions) {\n\n    PsiElement target = element;\n    PsiElement secondaryTarget = null;\n\n    if (element instanceof XmlAttributeValue) {\n      final ASTNode node = element.getNode();\n      final ASTNode value = node == null ? null : XmlChildRole.ATTRIBUTE_VALUE_VALUE_FINDER.findChild(node);\n      if (value instanceof PsiElement) {\n        target = (PsiElement) value;\n      }\n    }\n    else if (element instanceof XmlAttributeImpl) {\n      target = ((XmlAttributeImpl)element).getNameElement();\n    }\n    else if (element instanceof XmlTag) {\n      target = XmlTagUtil.getStartTagNameElement((XmlTag)element);\n      secondaryTarget = XmlTagUtil.getEndTagNameElement((XmlTag)element);\n    }\n\n    if (host instanceof IdeValidationHost) {\n      if (target != null) {\n        ((IdeValidationHost)host).addMessageWithFixes(target, message, Validator.ValidationHost.ErrorType.ERROR, intentionActions);\n      }\n      if (secondaryTarget != null) {\n        ((IdeValidationHost)host).addMessageWithFixes(secondaryTarget, message, Validator.ValidationHost.ErrorType.ERROR, intentionActions);\n      }\n    }\n    else {\n      if (target != null) {\n        host.addMessage(target, message, Validator.ValidationHost.ErrorType.ERROR);\n      }\n      if (secondaryTarget != null) {\n        host.addMessage(secondaryTarget, message, Validator.ValidationHost.ErrorType.ERROR);\n      }\n    }\n  }","commit_id":"eb90676dbbc99ac6d455c9b5fced7e79f08b8197","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected PsiElement resolveInner(T o) {\n    if (o instanceof PsiElement) {\n      return (PsiElement)o;\n    }\n    if (o instanceof DomElement) {\n      return ((DomElement)o).getGenericInfo().getNameElement((DomElement)o);\n    }\n    if (o instanceof MergedObject) {\n      final List<T> list = ((MergedObject<T>)o).getImplementations();\n      for (final T o1 : list) {\n        final PsiElement psiElement = resolveInner(o1);\n        if (psiElement != null) {\n          return psiElement;\n        }\n      }\n    }\n    if (o != null) {\n      return getValueElement();\n    }\n    else {\n      return null;\n    }\n  }","id":76334,"modified_method":"protected PsiElement resolveInner(T o) {\n    if (o instanceof PsiElement) {\n      return (PsiElement)o;\n    }\n    if (o instanceof DomElement) {\n      final XmlElement element = ((DomElement)o).getGenericInfo().getNameElement((DomElement)o);\n      return element != null? element : ((DomElement)o).getXmlElement();\n    }\n    if (o instanceof MergedObject) {\n      final List<T> list = ((MergedObject<T>)o).getImplementations();\n      for (final T o1 : list) {\n        final PsiElement psiElement = resolveInner(o1);\n        if (psiElement != null) {\n          return psiElement;\n        }\n      }\n    }\n    if (o != null) {\n      return getValueElement();\n    }\n    else {\n      return null;\n    }\n  }","commit_id":"ab3829364d1971bbf398ce211fd918c3b730f4a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NonNls\n  public final String getName() {\n    final String s = ElementPresentationManager.getElementName(myElement);\n    if (s != null) return s;\n\n    return ElementPresentationManager.getNameFromNameValue(getNameElement(myElement), false);\n  }","id":76335,"modified_method":"@NonNls\n  public final String getName() {\n    final String s = ElementPresentationManager.getElementName(myElement);\n    if (s != null) return s;\n\n    final GenericDomValue value = getNameElement(myElement);\n    return value == null ? null : value.getStringValue();\n  }","commit_id":"4c8fef1e79c90bd88f053925704f1b60ddea62db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String getElementName(Object element) {\n    for (final Function<Object, String> function : ourNameProviders) {\n      final String s = function.fun(element);\n      if (s != null) {\n        return s;\n      }\n    }\n    return getNameFromNameValue(invokeNameValueMethod(element), false);\n  }","id":76336,"modified_method":"@Nullable\n  public static String getElementName(Object element) {\n    for (final Function<Object, String> function : ourNameProviders) {\n      final String s = function.fun(element);\n      if (s != null) {\n        return s;\n      }\n    }\n    Object o = invokeNameValueMethod(element);\n    return o == null || o instanceof String ? (String)o : ((GenericValue)o).getStringValue();\n  }","commit_id":"4c8fef1e79c90bd88f053925704f1b60ddea62db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void getProductContentAsText(String productId, GenericValue product, String productContentTypeId, Locale locale, String mimeTypeId, GenericDelegator delegator, LocalDispatcher dispatcher, Writer outWriter) throws GeneralException, IOException {\n        if (productId == null && product != null) {\n            productId = product.getString(\"productId\");\n        }\n        \n        if (delegator == null && product != null) {\n            delegator = product.getDelegator();\n        }\n        \n        if (UtilValidate.isEmpty(mimeTypeId)) {\n            mimeTypeId = \"text/html\";\n        }\n\n        if (delegator == null) {\n            throw new GeneralRuntimeException(\"Unable to find a delegator to use!\");\n        }\n        \n        String candidateFieldName = ModelUtil.dbNameToVarName(productContentTypeId);        \n        ModelEntity productModel = delegator.getModelEntity(\"Product\");\n        if (productModel.isField(candidateFieldName)) {\n            if (product == null) {\n                product = delegator.findByPrimaryKeyCache(\"Product\", UtilMisc.toMap(\"productId\", productId));\n            }\n            if (product != null) {\n                String candidateValue = product.getString(candidateFieldName);\n                if (UtilValidate.isNotEmpty(candidateValue)) {\n                    outWriter.write(candidateValue);\n                    return;\n                }\n            }\n        }\n        \n        List productContentList = delegator.findByAndCache(\"ProductContent\", UtilMisc.toMap(\"productId\", productId, \"productContentTypeId\", productContentTypeId), UtilMisc.toList(\"-fromDate\"));\n        productContentList = EntityUtil.filterByDate(productContentList);\n        GenericValue productContent = EntityUtil.getFirst(productContentList);\n        if (productContent != null) {\n            // when rendering the product content, always include the Product and ProductContent records that this comes from\n            Map inContext = new HashMap();\n            inContext.put(\"product\", product);\n            inContext.put(\"productContent\", productContent);\n            ContentWorker.renderContentAsText(dispatcher, delegator, productContent.getString(\"contentId\"), outWriter, inContext, locale, mimeTypeId, false);\n        }\n    }","id":76337,"modified_method":"public static void getProductContentAsText(String productId, GenericValue product, String productContentTypeId, Locale locale, String mimeTypeId, GenericDelegator delegator, LocalDispatcher dispatcher, Writer outWriter) throws GeneralException, IOException {\n        if (productId == null && product != null) {\n            productId = product.getString(\"productId\");\n        }\n        \n        if (delegator == null && product != null) {\n            delegator = product.getDelegator();\n        }\n        \n        if (UtilValidate.isEmpty(mimeTypeId)) {\n            mimeTypeId = \"text/html\";\n        }\n\n        if (delegator == null) {\n            throw new GeneralRuntimeException(\"Unable to find a delegator to use!\");\n        }\n        \n        String candidateFieldName = ModelUtil.dbNameToVarName(productContentTypeId);        \n        ModelEntity productModel = delegator.getModelEntity(\"Product\");\n        if (productModel.isField(candidateFieldName)) {\n            if (product == null) {\n                product = delegator.findByPrimaryKeyCache(\"Product\", UtilMisc.toMap(\"productId\", productId));\n            }\n            if (product != null) {\n                String candidateValue = product.getString(candidateFieldName);\n                if (UtilValidate.isNotEmpty(candidateValue)) {\n                    outWriter.write(candidateValue);\n                    return;\n                } else if (\"Y\".equals(product.getString(\"isVariant\"))) {\n                    // look up the virtual product\n                    GenericValue parent = ProductWorker.getParentProduct(productId, delegator);\n                    Debug.log(\"Parent product: \" + parent, module);\n                    if (parent != null) {\n                        candidateValue = parent.getString(candidateFieldName);\n                        if (UtilValidate.isNotEmpty(candidateValue)) {\n                            outWriter.write(candidateValue);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        \n        List productContentList = delegator.findByAndCache(\"ProductContent\", UtilMisc.toMap(\"productId\", productId, \"productContentTypeId\", productContentTypeId), UtilMisc.toList(\"-fromDate\"));\n        productContentList = EntityUtil.filterByDate(productContentList);\n        GenericValue productContent = EntityUtil.getFirst(productContentList);\n        if (productContent != null) {\n            // when rendering the product content, always include the Product and ProductContent records that this comes from\n            Map inContext = new HashMap();\n            inContext.put(\"product\", product);\n            inContext.put(\"productContent\", productContent);\n            ContentWorker.renderContentAsText(dispatcher, delegator, productContent.getString(\"contentId\"), outWriter, inContext, locale, mimeTypeId, false);\n        }\n    }","commit_id":"90c77da6bf321753b58c822d465123f5afcba103","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map processExtendSubscriptionByProduct(DispatchContext dctx, Map context) throws GenericServiceException{\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        String productId = (String) context.get(\"productId\");\n        Integer qty = (Integer) context.get(\"quantity\");\n        if (qty == null) {\n            qty = new Integer(1);\n        }\n        \n        Timestamp orderCreatedDate = (Timestamp) context.get(\"orderCreatedDate\");\n        if (orderCreatedDate == null) {\n            orderCreatedDate = UtilDateTime.nowTimestamp();   \n        }\n        try {\n            List productSubscriptionResourceList = delegator.findByAndCache(\"ProductSubscriptionResource\", UtilMisc.toMap(\"productId\", productId));\n            productSubscriptionResourceList = EntityUtil.filterByDate(productSubscriptionResourceList, orderCreatedDate, null, null, true);\n            productSubscriptionResourceList = EntityUtil.filterByDate(productSubscriptionResourceList, orderCreatedDate, \"purchaseFromDate\", \"purchaseThruDate\", true);\n\n            if (productSubscriptionResourceList.size() == 0) {\n                String msg = \"No ProductSubscriptionResource found for productId: \" + productId;\n                Debug.logError(msg, module);\n                return ServiceUtil.returnError(msg); \n            }\n\n            Iterator productSubscriptionResourceIter = productSubscriptionResourceList.iterator();\n            while (productSubscriptionResourceIter.hasNext()) {\n                GenericValue productSubscriptionResource = (GenericValue) productSubscriptionResourceIter.next();\n\n                Long useTime = (Long) productSubscriptionResource.get(\"useTime\");\n                Integer newUseTime = new Integer(0);\n                if (useTime != null) {\n                    newUseTime = new Integer(useTime.intValue() * qty.intValue());\n                }\n                context.put(\"useTime\", newUseTime);\n                context.put(\"useTimeUomId\", productSubscriptionResource.get(\"useTimeUomId\"));\n                context.put(\"useRoleTypeId\", productSubscriptionResource.get(\"useRoleTypeId\"));\n                context.put(\"subscriptionResourceId\", productSubscriptionResource.get(\"subscriptionResourceId\"));\n                context.put(\"productId\", productId);\n                context.put(\"orderId\", context.get(\"orderId\"));\n                \n                Map ctx = dctx.getModelService(\"processExtendSubscription\").makeValid(context, ModelService.IN_PARAM);\n                Map processExtendSubscriptionResult = dispatcher.runSync(\"processExtendSubscription\", ctx);\n                if (ServiceUtil.isError(processExtendSubscriptionResult)) {\n                    return ServiceUtil.returnError(\"Error processing subscriptions for Product with ID [\" + productId + \"]\", null, null, processExtendSubscriptionResult);\n                }\n            }\n        } catch(GenericEntityException e) {\n            Debug.logError(e, e.toString(), module);\n            return ServiceUtil.returnError(e.toString());\n        }\n        Map result = ServiceUtil.returnSuccess();\n        return result;\n    }","id":76338,"modified_method":"public static Map processExtendSubscriptionByProduct(DispatchContext dctx, Map context) throws GenericServiceException{\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        String productId = (String) context.get(\"productId\");\n        Integer qty = (Integer) context.get(\"quantity\");\n        if (qty == null) {\n            qty = new Integer(1);\n        }\n        \n        Timestamp orderCreatedDate = (Timestamp) context.get(\"orderCreatedDate\");\n        if (orderCreatedDate == null) {\n            orderCreatedDate = UtilDateTime.nowTimestamp();   \n        }\n        try {\n            List productSubscriptionResourceList = delegator.findByAndCache(\"ProductSubscriptionResource\", UtilMisc.toMap(\"productId\", productId));\n            productSubscriptionResourceList = EntityUtil.filterByDate(productSubscriptionResourceList, orderCreatedDate, null, null, true);\n            productSubscriptionResourceList = EntityUtil.filterByDate(productSubscriptionResourceList, orderCreatedDate, \"purchaseFromDate\", \"purchaseThruDate\", true);\n\n            if (productSubscriptionResourceList.size() == 0) {\n                String msg = \"No ProductSubscriptionResource found for productId: \" + productId;\n                Debug.logError(msg, module);\n                return ServiceUtil.returnError(msg); \n            }\n\n            Iterator productSubscriptionResourceIter = productSubscriptionResourceList.iterator();\n            while (productSubscriptionResourceIter.hasNext()) {\n                GenericValue productSubscriptionResource = (GenericValue) productSubscriptionResourceIter.next();\n\n                Long useTime = (Long) productSubscriptionResource.get(\"useTime\");\n                Integer newUseTime = new Integer(0);\n                if (useTime != null) {\n                    newUseTime = new Integer(useTime.intValue() * qty.intValue());\n                }\n                context.put(\"useTime\", newUseTime);\n                context.put(\"useTimeUomId\", productSubscriptionResource.get(\"useTimeUomId\"));\n                context.put(\"useRoleTypeId\", productSubscriptionResource.get(\"useRoleTypeId\"));\n                context.put(\"subscriptionResourceId\", productSubscriptionResource.get(\"subscriptionResourceId\"));\n                \n                Map ctx = dctx.getModelService(\"processExtendSubscription\").makeValid(context, ModelService.IN_PARAM);\n                Map processExtendSubscriptionResult = dispatcher.runSync(\"processExtendSubscription\", ctx);\n                if (ServiceUtil.isError(processExtendSubscriptionResult)) {\n                    return ServiceUtil.returnError(\"Error processing subscriptions for Product with ID [\" + productId + \"]\", null, null, processExtendSubscriptionResult);\n                }\n            }\n        } catch(GenericEntityException e) {\n            Debug.logError(e, e.toString(), module);\n            return ServiceUtil.returnError(e.toString());\n        }\n        \n        return ServiceUtil.returnSuccess();\n    }","commit_id":"90c77da6bf321753b58c822d465123f5afcba103","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map processExtendSubscriptionByOrder(DispatchContext dctx, Map context) throws GenericServiceException{\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        String orderId = (String) context.get(\"orderId\");\n        \n        Debug.logInfo(\"In processExtendSubscriptionByOrder service with orderId: \" + orderId, module);\n        \n        GenericValue orderHeader = null;\n        try {\n            List orderRoleList = delegator.findByAnd(\"OrderRole\", UtilMisc.toMap(\"orderId\", orderId, \"roleTypeId\", \"END_USER_CUSTOMER\"));\n            if (orderRoleList.size() > 0 ) {\n                GenericValue orderRole = (GenericValue)orderRoleList.get(0);\n                String partyId = (String) orderRole.get(\"partyId\");\n                context.put(\"partyId\", partyId);\n            } else {\n                String msg = \"No OrderRole found for orderId:\" + orderId;\n                Debug.logError(msg, module);\n                return ServiceUtil.returnError(msg); \n            }\n            orderHeader = delegator.findByPrimaryKeyCache(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId));\n            if (orderHeader == null) {\n                String msg = \"No OrderHeader found for orderId:\" + orderId;\n                Debug.logError(msg, module);\n                return ServiceUtil.returnError(msg); \n            }\n            Timestamp orderCreatedDate = (Timestamp) orderHeader.get(\"orderDate\");\n            context.put(\"orderCreatedDate\", orderCreatedDate);\n            List orderItemList = orderHeader.getRelated(\"OrderItem\");\n            Iterator orderItemIter = orderItemList.iterator();\n            while (orderItemIter.hasNext()) {\n                GenericValue orderItem = (GenericValue)orderItemIter.next();   \n                Double qty = (Double) orderItem.get(\"quantity\");\n                String productId = (String) orderItem.get(\"productId\");\n                if (UtilValidate.isEmpty(productId)) {\n                    continue;\n                }\n                List productSubscriptionResourceList = delegator.findByAndCache(\"ProductSubscriptionResource\", UtilMisc.toMap(\"productId\", productId));\n                List productSubscriptionResourceListFiltered = EntityUtil.filterByDate(productSubscriptionResourceList, true);\n                if (productSubscriptionResourceListFiltered.size() > 0) {\n                    context.put(\"productId\", productId);\n                    context.put(\"orderId\", orderId);\n                    context.put(\"orderItemSeqId\", orderItem.get(\"orderItemSeqId\"));\n                    context.put(\"quantity\", new Integer(qty.intValue()));\n                    Map ctx = dctx.getModelService(\"processExtendSubscriptionByProduct\").makeValid(context, ModelService.IN_PARAM);\n                    Map thisResult = dispatcher.runSync(\"processExtendSubscriptionByProduct\", ctx);\n                    if (ServiceUtil.isError(thisResult)) {\n                        return ServiceUtil.returnError(\"Error processing subscriptions for Order with ID [\" + orderId + \"]\", null, null, thisResult);\n                    }\n                }\n            }\n        } catch(GenericEntityException e) {\n            Debug.logError(e.toString(), module);\n            return ServiceUtil.returnError(e.toString());\n        }\n        Map result = ServiceUtil.returnSuccess();\n        return result;\n    }","id":76339,"modified_method":"public static Map processExtendSubscriptionByOrder(DispatchContext dctx, Map context) throws GenericServiceException{\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        String orderId = (String) context.get(\"orderId\");\n        \n        Debug.logInfo(\"In processExtendSubscriptionByOrder service with orderId: \" + orderId, module);\n        \n        GenericValue orderHeader = null;\n        try {\n            List orderRoleList = delegator.findByAnd(\"OrderRole\", UtilMisc.toMap(\"orderId\", orderId, \"roleTypeId\", \"END_USER_CUSTOMER\"));\n            if (orderRoleList.size() > 0 ) {\n                GenericValue orderRole = (GenericValue)orderRoleList.get(0);\n                String partyId = (String) orderRole.get(\"partyId\");\n                context.put(\"partyId\", partyId);\n            } else {\n                String msg = \"No OrderRole found for orderId:\" + orderId;\n                Debug.logError(msg, module);\n                return ServiceUtil.returnError(msg); \n            }\n            orderHeader = delegator.findByPrimaryKeyCache(\"OrderHeader\", UtilMisc.toMap(\"orderId\", orderId));\n            if (orderHeader == null) {\n                String msg = \"No OrderHeader found for orderId:\" + orderId;\n                Debug.logError(msg, module);\n                return ServiceUtil.returnError(msg); \n            }\n            Timestamp orderCreatedDate = (Timestamp) orderHeader.get(\"orderDate\");\n            context.put(\"orderCreatedDate\", orderCreatedDate);\n            List orderItemList = orderHeader.getRelated(\"OrderItem\");\n            Iterator orderItemIter = orderItemList.iterator();\n            while (orderItemIter.hasNext()) {\n                GenericValue orderItem = (GenericValue)orderItemIter.next();   \n                Double qty = (Double) orderItem.get(\"quantity\");\n                String productId = (String) orderItem.get(\"productId\");\n                if (UtilValidate.isEmpty(productId)) {\n                    continue;\n                }\n                List productSubscriptionResourceList = delegator.findByAndCache(\"ProductSubscriptionResource\", UtilMisc.toMap(\"productId\", productId));\n                List productSubscriptionResourceListFiltered = EntityUtil.filterByDate(productSubscriptionResourceList, true);\n                if (productSubscriptionResourceListFiltered.size() > 0) {\n                    context.put(\"subscriptionTypeId\", \"PRODUCT_SUBSCR\");\n                    context.put(\"productId\", productId);\n                    context.put(\"orderId\", orderId);\n                    context.put(\"orderItemSeqId\", orderItem.get(\"orderItemSeqId\"));\n                    context.put(\"inventoryItemId\", orderItem.get(\"fromInventoryItemId\"));\n                    context.put(\"quantity\", new Integer(qty.intValue()));\n                    Map ctx = dctx.getModelService(\"processExtendSubscriptionByProduct\").makeValid(context, ModelService.IN_PARAM);\n                    Map thisResult = dispatcher.runSync(\"processExtendSubscriptionByProduct\", ctx);\n                    if (ServiceUtil.isError(thisResult)) {\n                        return ServiceUtil.returnError(\"Error processing subscriptions for Order with ID [\" + orderId + \"]\", null, null, thisResult);\n                    }\n                }\n            }\n        } catch(GenericEntityException e) {\n            Debug.logError(e.toString(), module);\n            return ServiceUtil.returnError(e.toString());\n        }\n\n        return ServiceUtil.returnSuccess();\n    }","commit_id":"90c77da6bf321753b58c822d465123f5afcba103","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map processExtendSubscription(DispatchContext dctx, Map context) throws GenericServiceException{\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        \n        String partyId = (String) context.get(\"partyId\");\n        String subscriptionResourceId = (String) context.get(\"subscriptionResourceId\");\n        String roleTypeId = (String) context.get(\"useRoleTypeId\");\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        Integer useTime = (Integer) context.get(\"useTime\");\n        String useTimeUomId = (String) context.get(\"useTimeUomId\");\n        String alwaysCreateNewRecordStr = (String) context.get(\"alwaysCreateNewRecord\");\n        boolean alwaysCreateNewRecord = !\"N\".equals(alwaysCreateNewRecordStr);\n        \n        GenericValue lastSubscription = null;\n        try {\n            List subscriptionList = delegator.findByAndCache(\"Subscription\", UtilMisc.toMap(\"partyId\", partyId, \"subscriptionResourceId\", subscriptionResourceId));\n            List listFiltered = EntityUtil.filterByDate(subscriptionList, true);\n            List listOrdered = EntityUtil.orderBy(listFiltered, UtilMisc.toList(\"-fromDate\"));\n            if (listOrdered.size() > 0) {\n                lastSubscription = (GenericValue) listOrdered.get(0);\n            }\n        } catch (GenericEntityException e) {\n            return ServiceUtil.returnError(e.toString());\n        }\n\n        GenericValue newSubscription = null;\n        if (lastSubscription == null || alwaysCreateNewRecord) {\n            newSubscription = delegator.makeValue(\"Subscription\", null);\n            newSubscription.set(\"subscriptionResourceId\", subscriptionResourceId);\n            newSubscription.set(\"partyId\", partyId);\n            newSubscription.set(\"roleTypeId\", roleTypeId);\n            newSubscription.set(\"productId\", context.get(\"productId\"));\n            newSubscription.set(\"orderId\", context.get(\"orderId\"));\n            newSubscription.set(\"orderItemSeqId\", context.get(\"orderItemSeqId\"));\n        } else {\n            newSubscription = lastSubscription;\n        }\n        \n        Timestamp thruDate = lastSubscription != null ? (Timestamp) lastSubscription.get(\"thruDate\") : null;\n        if (thruDate == null) {\n            // no thruDate? start with NOW\n            thruDate = nowTimestamp;\n            newSubscription.set(\"fromDate\", nowTimestamp);\n        } else {\n            // there is a thru date... if it is in the past, bring it up to NOW before adding on the time period\n            //don't want to penalize for skipping time, in other words if they had a subscription last year for a month and buy another month, we want that second month to start now and not last year\n            if (thruDate.before(nowTimestamp)) {\n                thruDate = nowTimestamp;\n            } else {\n                newSubscription.set(\"fromDate\", thruDate);\n            }\n        }\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(thruDate);\n        int field = Calendar.MONTH;\n        if (\"TF_day\".equals(useTimeUomId)) {\n            field = Calendar.DAY_OF_YEAR;   \n        } else if (\"TF_wk\".equals(useTimeUomId)) {\n            field = Calendar.WEEK_OF_YEAR;   \n        } else if (\"TF_mon\".equals(useTimeUomId)) {\n            field = Calendar.MONTH;   \n        } else if (\"TF_yr\".equals(useTimeUomId)) {\n            field = Calendar.YEAR;   \n        } else {\n            Debug.logWarning(\"Don't know anything about useTimeUomId [\" + useTimeUomId + \"], defaulting to month\", module);\n        }\n        calendar.add(field, useTime.intValue());\n        thruDate = new Timestamp(calendar.getTimeInMillis());\n        newSubscription.set(\"thruDate\", thruDate);\n        \n        Map result = ServiceUtil.returnSuccess();\n        try {\n            if (lastSubscription != null && !alwaysCreateNewRecord) {\n                Map updateSubscriptionMap = dctx.getModelService(\"updateSubscription\").makeValid(newSubscription, ModelService.IN_PARAM);\n                updateSubscriptionMap.put(\"userLogin\", delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\")));\n\n                Map updateSubscriptionResult = dispatcher.runSync(\"updateSubscription\", updateSubscriptionMap);\n                result.put(\"subscriptionId\", updateSubscriptionMap.get(\"subscriptionId\"));\n                if (ServiceUtil.isError(updateSubscriptionResult)) {\n                    return ServiceUtil.returnError(\"Error processing subscription update with ID [\" + updateSubscriptionMap.get(\"subscriptionId\") + \"]\", null, null, updateSubscriptionResult);\n                }\n            } else {\n                Map createPartyRoleMap = new HashMap();\n                if (UtilValidate.isNotEmpty(roleTypeId)) {\n                    createPartyRoleMap.put(\"partyId\", partyId);\n                    createPartyRoleMap.put(\"roleTypeId\", roleTypeId);\n                    createPartyRoleMap.put(\"userLogin\", userLogin);\n                    Map createPartyRoleResult = dispatcher.runSync(\"createPartyRole\", createPartyRoleMap);\n                    if (ServiceUtil.isError(createPartyRoleResult)) {\n                        return ServiceUtil.returnError(\"Error creating new PartyRole while processing subscription update with resource ID [\" + subscriptionResourceId + \"]\", null, null, createPartyRoleResult);\n                    }\n                }\n                Map createSubscriptionMap = dctx.getModelService(\"createSubscription\").makeValid(newSubscription, ModelService.IN_PARAM);\n                createSubscriptionMap.put(\"userLogin\", delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\")));\n\n                Map createSubscriptionResult = dispatcher.runSync(\"createSubscription\", createSubscriptionMap);\n                if (ServiceUtil.isError(createSubscriptionResult)) {\n                    return ServiceUtil.returnError(\"Error creating subscription while processing with resource ID [\" + subscriptionResourceId + \"]\", null, null, createSubscriptionResult);\n                }\n                result.put(\"subscriptionId\", createSubscriptionResult.get(\"subscriptionId\"));\n            }\n        } catch (GenericEntityException e) {\n            return ServiceUtil.returnError(e.toString());\n        } catch (GenericServiceException e) {\n            return ServiceUtil.returnError(e.toString());\n        }\n        return result;\n    }","id":76340,"modified_method":"public static Map processExtendSubscription(DispatchContext dctx, Map context) throws GenericServiceException{\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        \n        String partyId = (String) context.get(\"partyId\");\n        String subscriptionResourceId = (String) context.get(\"subscriptionResourceId\");\n        String roleTypeId = (String) context.get(\"useRoleTypeId\");\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        Integer useTime = (Integer) context.get(\"useTime\");\n        String useTimeUomId = (String) context.get(\"useTimeUomId\");\n        String alwaysCreateNewRecordStr = (String) context.get(\"alwaysCreateNewRecord\");\n        boolean alwaysCreateNewRecord = !\"N\".equals(alwaysCreateNewRecordStr);\n        \n        GenericValue lastSubscription = null;\n        try {\n            List subscriptionList = delegator.findByAndCache(\"Subscription\", UtilMisc.toMap(\"partyId\", partyId, \"subscriptionResourceId\", subscriptionResourceId));\n            List listFiltered = EntityUtil.filterByDate(subscriptionList, true);\n            List listOrdered = EntityUtil.orderBy(listFiltered, UtilMisc.toList(\"-fromDate\"));\n            if (listOrdered.size() > 0) {\n                lastSubscription = (GenericValue) listOrdered.get(0);\n            }\n        } catch (GenericEntityException e) {\n            return ServiceUtil.returnError(e.toString());\n        }\n\n        GenericValue newSubscription = null;\n        if (lastSubscription == null || alwaysCreateNewRecord) {\n            newSubscription = delegator.makeValue(\"Subscription\", null);\n            newSubscription.set(\"subscriptionResourceId\", subscriptionResourceId);\n            newSubscription.set(\"partyId\", partyId);\n            newSubscription.set(\"roleTypeId\", roleTypeId);\n            newSubscription.set(\"productId\", context.get(\"productId\"));\n            newSubscription.set(\"orderId\", context.get(\"orderId\"));\n            newSubscription.set(\"orderItemSeqId\", context.get(\"orderItemSeqId\"));\n        } else {\n            newSubscription = lastSubscription;\n        }\n        newSubscription.set(\"inventoryItemId\", context.get(\"inventoryItemId\"));\n\n        Timestamp thruDate = lastSubscription != null ? (Timestamp) lastSubscription.get(\"thruDate\") : null;\n        if (thruDate == null) {\n            // no thruDate? start with NOW\n            thruDate = nowTimestamp;\n            newSubscription.set(\"fromDate\", nowTimestamp);\n        } else {\n            // there is a thru date... if it is in the past, bring it up to NOW before adding on the time period\n            //don't want to penalize for skipping time, in other words if they had a subscription last year for a month and buy another month, we want that second month to start now and not last year\n            if (thruDate.before(nowTimestamp)) {\n                thruDate = nowTimestamp;\n            } else {\n                newSubscription.set(\"fromDate\", thruDate);\n            }\n        }\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(thruDate);\n        int[] times = UomWorker.uomTimeToCalTime(useTimeUomId);\n        if (times != null) {\n            calendar.add(times[0], (useTime.intValue() * times[1]));\n        } else {\n            Debug.logWarning(\"Don't know anything about useTimeUomId [\" + useTimeUomId + \"], defaulting to month\", module);\n        }\n       \n        thruDate = new Timestamp(calendar.getTimeInMillis());\n        newSubscription.set(\"thruDate\", thruDate);\n        \n        Map result = ServiceUtil.returnSuccess();\n        try {\n            if (lastSubscription != null && !alwaysCreateNewRecord) {\n                Map updateSubscriptionMap = dctx.getModelService(\"updateSubscription\").makeValid(newSubscription, ModelService.IN_PARAM);\n                updateSubscriptionMap.put(\"userLogin\", delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\")));\n\n                Map updateSubscriptionResult = dispatcher.runSync(\"updateSubscription\", updateSubscriptionMap);\n                result.put(\"subscriptionId\", updateSubscriptionMap.get(\"subscriptionId\"));\n                if (ServiceUtil.isError(updateSubscriptionResult)) {\n                    return ServiceUtil.returnError(\"Error processing subscription update with ID [\" + updateSubscriptionMap.get(\"subscriptionId\") + \"]\", null, null, updateSubscriptionResult);\n                }\n            } else {\n                Map createPartyRoleMap = new HashMap();\n                if (UtilValidate.isNotEmpty(roleTypeId)) {\n                    createPartyRoleMap.put(\"partyId\", partyId);\n                    createPartyRoleMap.put(\"roleTypeId\", roleTypeId);\n                    createPartyRoleMap.put(\"userLogin\", userLogin);\n                    Map createPartyRoleResult = dispatcher.runSync(\"createPartyRole\", createPartyRoleMap);\n                    if (ServiceUtil.isError(createPartyRoleResult)) {\n                        return ServiceUtil.returnError(\"Error creating new PartyRole while processing subscription update with resource ID [\" + subscriptionResourceId + \"]\", null, null, createPartyRoleResult);\n                    }\n                }\n                Map createSubscriptionMap = dctx.getModelService(\"createSubscription\").makeValid(newSubscription, ModelService.IN_PARAM);\n                createSubscriptionMap.put(\"userLogin\", delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\")));\n\n                Map createSubscriptionResult = dispatcher.runSync(\"createSubscription\", createSubscriptionMap);\n                if (ServiceUtil.isError(createSubscriptionResult)) {\n                    return ServiceUtil.returnError(\"Error creating subscription while processing with resource ID [\" + subscriptionResourceId + \"]\", null, null, createSubscriptionResult);\n                }\n                result.put(\"subscriptionId\", createSubscriptionResult.get(\"subscriptionId\"));\n            }\n        } catch (GenericEntityException e) {\n            return ServiceUtil.returnError(e.toString());\n        } catch (GenericServiceException e) {\n            return ServiceUtil.returnError(e.toString());\n        }\n        return result;\n    }","commit_id":"90c77da6bf321753b58c822d465123f5afcba103","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map receiveConfirmBod(DispatchContext ctx, Map context) {\r\n        \r\n        GenericDelegator delegator = ctx.getDelegator();\r\n        LocalDispatcher dispatcher = ctx.getDispatcher();\r\n        InputStream in = (InputStream) context.get(\"inputStream\");\r\n        OutputStream out = (OutputStream) context.get(\"outputStream\");\r\n        Map oagisMsgInfoContext = new HashMap();\r\n        Map oagisMsgErrorContext = new HashMap();\r\n        GenericValue userLogin = null;\r\n        Timestamp timestamp = null;\r\n        timestamp = UtilDateTime.nowTimestamp();\r\n        String errMsg = null;\r\n        try{\r\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\",UtilMisc.toMap(\"userLoginId\",\"admin\"));\r\n            Document doc = UtilXml.readXmlDocument(in, true, \"RecieveConfirmBod\");\r\n            Element confirmBodElement = doc.getDocumentElement();\r\n            confirmBodElement.normalize();\r\n            Element docCtrlAreaElement = UtilXml.firstChildElement(confirmBodElement, \"N1:CNTROLAREA\");\r\n            Element bsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"N1:BSR\");\r\n            String bsrVerb = UtilXml.childElementValue(bsrElement, \"N2:VERB\");\r\n            String bsrNoun = UtilXml.childElementValue(bsrElement, \"N2:NOUN\");\r\n            String bsrRevision = UtilXml.childElementValue(bsrElement, \"N2:REVISION\");\r\n            \r\n            Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"N1:SENDER\");\r\n            String logicalId = UtilXml.childElementValue(docSenderElement, \"N2:LOGICALID\");\r\n            String component = UtilXml.childElementValue(docSenderElement, \"N2:COMPONENT\");\r\n            String task = UtilXml.childElementValue(docSenderElement, \"N2:TASK\");\r\n            String referenceId = UtilXml.childElementValue(docSenderElement, \"N2:REFERENCEID\");\r\n            String confirmation = UtilXml.childElementValue(docSenderElement, \"N2:CONFIRMATION\");\r\n            String language = UtilXml.childElementValue(docSenderElement, \"N2:LANGUAGE\");\r\n            String codepage = UtilXml.childElementValue(docSenderElement, \"N2:CODEPAGE\");\r\n            String authId = UtilXml.childElementValue(docSenderElement, \"N2:AUTHID\");\r\n            \r\n            String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"N1:DATETIMEANY\");\r\n            \r\n            oagisMsgInfoContext.put(\"logicalId\", logicalId);\r\n            oagisMsgInfoContext.put(\"component\", component);\r\n            oagisMsgInfoContext.put(\"task\", task);\r\n            oagisMsgInfoContext.put(\"referenceId\", referenceId);\r\n            oagisMsgInfoContext.put(\"authId\", authId);\r\n            oagisMsgInfoContext.put(\"recievedDate\", timestamp);\r\n            oagisMsgInfoContext.put(\"confirmation\", confirmation);\r\n            oagisMsgInfoContext.put(\"bsrVerb\", bsrVerb);\r\n            oagisMsgInfoContext.put(\"bsrNoun\", bsrNoun);\r\n            oagisMsgInfoContext.put(\"bsrRevision\", bsrRevision);\r\n            oagisMsgInfoContext.put(\"userLogin\", userLogin);\r\n            Debug.logInfo(\"==============oagisMsgInfoContext===== \"+oagisMsgInfoContext, module);\r\n            \r\n            Element dataAreaElement = UtilXml.firstChildElement(confirmBodElement, \"n:DATAAREA\");\r\n            Element dataAreaConfirmBodElement = UtilXml.firstChildElement(dataAreaElement, \"n:CONFIRM_BOD\");\r\n            Element dataAreaConfirmElement = UtilXml.firstChildElement(dataAreaConfirmBodElement, \"n:CONFIRM\");\r\n            Element dataAreaCtrlElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"N1:CNTROLAREA\");\r\n            Element dataAreaSenderElement = UtilXml.firstChildElement(dataAreaCtrlElement, \"N1:SENDER\");\r\n            String dataAreaLogicalId = UtilXml.childElementValue(dataAreaSenderElement, \"N2:LOGICALID\");\r\n            String dataAreaComponent = UtilXml.childElementValue(dataAreaSenderElement, \"N2:COMPONENT\");\r\n            String dataAreaTask = UtilXml.childElementValue(dataAreaSenderElement, \"N2:TASK\");\r\n            String dataAreaReferenceId = UtilXml.childElementValue(dataAreaSenderElement, \"N2:REFERENCEID\");\r\n            \r\n            String dataAreaDate = UtilXml.childElementValue(dataAreaCtrlElement, \"N1:DATETIMEANY\");\r\n            \r\n            String origRef = UtilXml.childElementValue(dataAreaConfirmElement, \"N2:ORIGREF\");\r\n            \r\n            Element dataAreaConfirmMsgElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"n:CONFIRMMSG\");\r\n            String description = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"N2:DESCRIPTN\");\r\n            String reasonCode = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"N2:REASONCODE\");\r\n            \r\n            oagisMsgErrorContext.put(\"logicalId\", dataAreaLogicalId);\r\n            oagisMsgErrorContext.put(\"component\", dataAreaComponent);\r\n            oagisMsgErrorContext.put(\"task\", dataAreaTask);\r\n            oagisMsgErrorContext.put(\"referenceId\", dataAreaReferenceId);\r\n            oagisMsgErrorContext.put(\"reasonCode\", reasonCode);\r\n            oagisMsgErrorContext.put(\"description\", description);\r\n            oagisMsgErrorContext.put(\"userLogin\", userLogin);\r\n            Debug.logInfo(\"==============oagisErrorMsgContext===== \"+oagisMsgErrorContext, module);\r\n            \r\n            Map resultMap = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoContext);\r\n            Debug.logInfo(\"==========resultMap-1======\" +resultMap, module);\r\n            resultMap = dispatcher.runSync(\"createOagisMessageErrorInfo\", oagisMsgErrorContext);\r\n            Debug.logInfo(\"==========resultMap-2======\" +resultMap, module);\r\n            \r\n        }catch (Exception e){\r\n            errMsg = \"Error running method receiveConfirmBod\";\r\n            Debug.logError(e, errMsg, module);\r\n        }\r\n        PrintWriter writer = new PrintWriter(new OutputStreamWriter(out));\r\n        if (errMsg!= null){\r\n            writer.println(\"Service failed\");\r\n            writer.flush();\r\n            return ServiceUtil.returnError(\"Service failed\");\r\n        } else {\r\n            writer.println(\"Service Completed Successfully\");\r\n            writer.flush();\r\n            Map result = ServiceUtil.returnSuccess(\"Service Completed Successfully\");\r\n            return result;    \r\n        }\r\n        \r\n    }","id":76341,"modified_method":"public static Map receiveConfirmBod(DispatchContext ctx, Map context) {\r\n        \r\n        GenericDelegator delegator = ctx.getDelegator();\r\n        LocalDispatcher dispatcher = ctx.getDispatcher();\r\n        InputStream in = (InputStream) context.get(\"inputStream\");\r\n        OutputStream out = (OutputStream) context.get(\"outputStream\");\r\n        Map oagisMsgInfoContext = new HashMap();\r\n        Map oagisMsgErrorContext = new HashMap();\r\n        GenericValue userLogin = null;\r\n        Timestamp timestamp = null;\r\n        timestamp = UtilDateTime.nowTimestamp();\r\n        String errMsg = null;\r\n        try{\r\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\",UtilMisc.toMap(\"userLoginId\",\"admin\"));\r\n            Document doc = UtilXml.readXmlDocument(in, true, \"RecieveConfirmBod\");\r\n            Element confirmBodElement = doc.getDocumentElement();\r\n            confirmBodElement.normalize();\r\n            Element docCtrlAreaElement = UtilXml.firstChildElement(confirmBodElement, \"N1:CNTROLAREA\");\r\n            Element bsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"N1:BSR\");\r\n            String bsrVerb = UtilXml.childElementValue(bsrElement, \"N2:VERB\");\r\n            String bsrNoun = UtilXml.childElementValue(bsrElement, \"N2:NOUN\");\r\n            String bsrRevision = UtilXml.childElementValue(bsrElement, \"N2:REVISION\");\r\n            \r\n            Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"N1:SENDER\");\r\n            String logicalId = UtilXml.childElementValue(docSenderElement, \"N2:LOGICALID\");\r\n            String component = UtilXml.childElementValue(docSenderElement, \"N2:COMPONENT\");\r\n            String task = UtilXml.childElementValue(docSenderElement, \"N2:TASK\");\r\n            String referenceId = UtilXml.childElementValue(docSenderElement, \"N2:REFERENCEID\");\r\n            String confirmation = UtilXml.childElementValue(docSenderElement, \"N2:CONFIRMATION\");\r\n            String language = UtilXml.childElementValue(docSenderElement, \"N2:LANGUAGE\");\r\n            String codepage = UtilXml.childElementValue(docSenderElement, \"N2:CODEPAGE\");\r\n            String authId = UtilXml.childElementValue(docSenderElement, \"N2:AUTHID\");\r\n            \r\n            String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"N1:DATETIMEANY\");\r\n            \r\n            oagisMsgInfoContext.put(\"logicalId\", logicalId);\r\n            oagisMsgInfoContext.put(\"component\", component);\r\n            oagisMsgInfoContext.put(\"task\", task);\r\n            oagisMsgInfoContext.put(\"referenceId\", referenceId);\r\n            oagisMsgInfoContext.put(\"authId\", authId);\r\n            oagisMsgInfoContext.put(\"recievedDate\", timestamp);\r\n            oagisMsgInfoContext.put(\"confirmation\", confirmation);\r\n            oagisMsgInfoContext.put(\"bsrVerb\", bsrVerb);\r\n            oagisMsgInfoContext.put(\"bsrNoun\", bsrNoun);\r\n            oagisMsgInfoContext.put(\"bsrRevision\", bsrRevision);\r\n            oagisMsgInfoContext.put(\"userLogin\", userLogin);\r\n            Debug.logInfo(\"==============oagisMsgInfoContext===== \"+oagisMsgInfoContext, module);\r\n            \r\n            Element dataAreaElement = UtilXml.firstChildElement(confirmBodElement, \"n:DATAAREA\");\r\n            Element dataAreaConfirmBodElement = UtilXml.firstChildElement(dataAreaElement, \"n:CONFIRM_BOD\");\r\n            Element dataAreaConfirmElement = UtilXml.firstChildElement(dataAreaConfirmBodElement, \"n:CONFIRM\");\r\n            Element dataAreaCtrlElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"N1:CNTROLAREA\");\r\n            Element dataAreaSenderElement = UtilXml.firstChildElement(dataAreaCtrlElement, \"N1:SENDER\");\r\n            String dataAreaLogicalId = UtilXml.childElementValue(dataAreaSenderElement, \"N2:LOGICALID\");\r\n            String dataAreaComponent = UtilXml.childElementValue(dataAreaSenderElement, \"N2:COMPONENT\");\r\n            String dataAreaTask = UtilXml.childElementValue(dataAreaSenderElement, \"N2:TASK\");\r\n            String dataAreaReferenceId = UtilXml.childElementValue(dataAreaSenderElement, \"N2:REFERENCEID\");\r\n            \r\n            String dataAreaDate = UtilXml.childElementValue(dataAreaCtrlElement, \"N1:DATETIMEANY\");\r\n            \r\n            String origRef = UtilXml.childElementValue(dataAreaConfirmElement, \"N2:ORIGREF\");\r\n            \r\n            Element dataAreaConfirmMsgElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"n:CONFIRMMSG\");\r\n            String description = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"N2:DESCRIPTN\");\r\n            String reasonCode = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"N2:REASONCODE\");\r\n            \r\n            oagisMsgErrorContext.put(\"logicalId\", dataAreaLogicalId);\r\n            oagisMsgErrorContext.put(\"component\", dataAreaComponent);\r\n            oagisMsgErrorContext.put(\"task\", dataAreaTask);\r\n            oagisMsgErrorContext.put(\"referenceId\", dataAreaReferenceId);\r\n            oagisMsgErrorContext.put(\"reasonCode\", reasonCode);\r\n            oagisMsgErrorContext.put(\"description\", description);\r\n            oagisMsgErrorContext.put(\"userLogin\", userLogin);\r\n            Debug.logInfo(\"==============oagisErrorMsgContext===== \"+oagisMsgErrorContext, module);\r\n            \r\n            Map resultMap = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoContext);\r\n            Debug.logInfo(\"==========resultMap-1======\" +resultMap, module);\r\n            resultMap = dispatcher.runSync(\"createOagisMessageErrorInfo\", oagisMsgErrorContext);\r\n            Debug.logInfo(\"==========resultMap-2======\" +resultMap, module);\r\n            \r\n        }catch (Exception e){\r\n            errMsg = \"Error running method receiveConfirmBod\";\r\n            Debug.logError(e, errMsg, module);\r\n            return ServiceUtil.returnError(\"Error running method receiveConfirmBod\");\r\n        }\r\n        return ServiceUtil.returnSuccess(\"Service Completed Successfully\");\r\n        \r\n    }","commit_id":"9cd57c80ad3ab1d58661de6c6552e9ded170446b","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map sendConfirmBod(DispatchContext ctx, Map context) {\r\n        \r\n        GenericDelegator delegator = ctx.getDelegator();\r\n        LocalDispatcher dispatcher = ctx.getDispatcher();\r\n        OutputStream out = (OutputStream) context.get(\"outputStream\");\r\n\r\n        Map bodyParameters = new HashMap();\r\n        Map confirmBodContext = new HashMap();\r\n        Map oagisMsgInfoContext = new HashMap();\r\n        String bodyScreenUri = \"component://oagis/widget/MessageInfoScreens.xml#ConfirmBod\";\r\n        Timestamp timestamp = null;\r\n        timestamp = UtilDateTime.nowTimestamp();\r\n        GenericValue userLogin = null;\r\n        try\r\n        {\r\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"admin\"));\r\n        } catch (GenericEntityException e) {\r\n            Debug.logError(e, \"Error getting userLogin\", module);\r\n        }\r\n        \r\n        String logicalId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.LOGICALID\");\r\n        String authId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.AUTHID\");\r\n        String referenceId = delegator.getNextSeqId(\"OagisMessageInfo\");\r\n        \r\n        String errorLogicalId = (String) context.get(\"logicalId\");\r\n        String errorComponent = (String) context.get(\"component\");\r\n        String errorTask = (String) context.get(\"task\");\r\n        String errorReferenceId = (String) context.get(\"referenceId\");\r\n        String errorDescription = (String) context.get(\"description\");\r\n        String errorReasonCode = (String) context.get(\"reasonCode\");\r\n        \r\n        bodyParameters.put(\"logicalId\", logicalId);\r\n        bodyParameters.put(\"referenceId\", referenceId);\r\n        bodyParameters.put(\"authId\", authId);\r\n        bodyParameters.put(\"sentDate\", timestamp);\r\n        \r\n        bodyParameters.put(\"errorLogicalId\", errorLogicalId);\r\n        bodyParameters.put(\"errorComponent\", errorComponent);\r\n        bodyParameters.put(\"errorTask\", errorTask);\r\n        bodyParameters.put(\"errorReferenceId\", errorReferenceId);\r\n        bodyParameters.put(\"errorDescription\", errorDescription);\r\n        bodyParameters.put(\"errorReasonCode\", errorReasonCode);\r\n        \r\n        if (((String) context.get(\"orderId\")) != null){\r\n            String origRef = (String) context.get(\"orderId\");\r\n            bodyParameters.put(\"origRef\", origRef);\r\n        } else\r\n            if (((String) context.get(\"returnId\")) != null){\r\n                String origRef = (String) context.get(\"returnId\");\r\n                bodyParameters.put(\"origRef\", origRef);\r\n            }else\r\n                if (((String) context.get(\"shipmentId\")) != null){\r\n                    String origRef = (String) context.get(\"shipmentId\");\r\n                    bodyParameters.put(\"origRef\", origRef);\r\n                }\r\n        \r\n        confirmBodContext.put(\"bodyParameters\", bodyParameters);\r\n        confirmBodContext.put(\"bodyScreenUri\", bodyScreenUri);\r\n        \r\n        try\r\n        {\r\n            Map exportMsgResult = dispatcher.runSync(\"exportMsgFromScreen\", confirmBodContext);\r\n            if (ServiceUtil.isError(exportMsgResult)) return exportMsgResult;\r\n            String messageBody = (String)exportMsgResult.get(\"body\");\r\n            PrintWriter writer = new PrintWriter(new OutputStreamWriter(out));\r\n            writer.print(messageBody);\r\n        } catch (GenericServiceException e){\r\n            Debug.logError(e, \"Error while generating message\", module);\r\n        }\r\n        \r\n        oagisMsgInfoContext.put(\"logicalId\", logicalId);\r\n        oagisMsgInfoContext.put(\"component\", \"EXCEPTION\");\r\n        oagisMsgInfoContext.put(\"task\", \"RECIEPT\");\r\n        oagisMsgInfoContext.put(\"referenceId\", referenceId);\r\n        oagisMsgInfoContext.put(\"authId\", authId);\r\n        oagisMsgInfoContext.put(\"sentDate\", timestamp);\r\n        oagisMsgInfoContext.put(\"confirmation\", \"0\");\r\n        oagisMsgInfoContext.put(\"bsrVerb\", \"CONFIRM\");\r\n        oagisMsgInfoContext.put(\"bsrNoun\", \"BOD\");\r\n        oagisMsgInfoContext.put(\"bsrRevision\", \"004\");\r\n        oagisMsgInfoContext.put(\"userLogin\", userLogin);\r\n        \r\n        try\r\n        {\r\n            Map oagisMsgInfoResult = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoContext);\r\n            if (ServiceUtil.isError(oagisMsgInfoResult)) return oagisMsgInfoResult;\r\n        } catch (GenericServiceException e) {\r\n            Debug.logError(e, \"Saving message to database failed\", module);\r\n        }\r\n        return ServiceUtil.returnSuccess(\"Service Completed Successfully\");\r\n    }","id":76342,"modified_method":"public static Map sendConfirmBod(DispatchContext ctx, Map context) {\r\n        \r\n        GenericDelegator delegator = ctx.getDelegator();\r\n        LocalDispatcher dispatcher = ctx.getDispatcher();\r\n        OutputStream out = (OutputStream) context.get(\"outputStream\");\r\n\r\n        Map bodyParameters = new HashMap();\r\n        Map confirmBodContext = new HashMap();\r\n        Map oagisMsgInfoContext = new HashMap();\r\n        Map exportMsgResult = new HashMap();\r\n        String bodyScreenUri = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Template.ConfirmBod\");\r\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSS'Z'Z\");\r\n        Date date = new Date();\r\n        String sentDate = null;\r\n        sentDate = dateFormat.format(date);\r\n        try{\r\n            date = dateFormat.parse(sentDate);    \r\n        } catch (ParseException e) {\r\n            Debug.logError(e, \"Error parsing Date\", module);\r\n        }\r\n        Timestamp timestamp = new Timestamp(date.getTime());\r\n        \r\n        GenericValue userLogin = null;\r\n        try\r\n        {\r\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"admin\"));\r\n        } catch (GenericEntityException e) {\r\n            Debug.logError(e, \"Error getting userLogin\", module);\r\n        }\r\n        \r\n        String logicalId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.LOGICALID\");\r\n        String authId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.AUTHID\");\r\n        String referenceId = delegator.getNextSeqId(\"OagisMessageInfo\");\r\n        \r\n        String errorLogicalId = (String) context.get(\"logicalId\");\r\n        String errorComponent = (String) context.get(\"component\");\r\n        String errorTask = (String) context.get(\"task\");\r\n        String errorReferenceId = (String) context.get(\"referenceId\");\r\n        String errorDescription = (String) context.get(\"description\");\r\n        String errorReasonCode = (String) context.get(\"reasonCode\");\r\n        \r\n        bodyParameters.put(\"logicalId\", logicalId);\r\n        bodyParameters.put(\"referenceId\", referenceId);\r\n        bodyParameters.put(\"authId\", authId);\r\n        bodyParameters.put(\"sentDate\", sentDate);\r\n        \r\n        bodyParameters.put(\"errorLogicalId\", errorLogicalId);\r\n        bodyParameters.put(\"errorComponent\", errorComponent);\r\n        bodyParameters.put(\"errorTask\", errorTask);\r\n        bodyParameters.put(\"errorReferenceId\", errorReferenceId);\r\n        bodyParameters.put(\"errorDescription\", errorDescription);\r\n        bodyParameters.put(\"errorReasonCode\", errorReasonCode);\r\n        \r\n        if (((String) context.get(\"orderId\")) != null){\r\n            String origRef = (String) context.get(\"orderId\");\r\n            bodyParameters.put(\"origRef\", origRef);\r\n        } else\r\n            if (((String) context.get(\"returnId\")) != null){\r\n                String origRef = (String) context.get(\"returnId\");\r\n                bodyParameters.put(\"origRef\", origRef);\r\n            }else\r\n                if (((String) context.get(\"shipmentId\")) != null){\r\n                    String origRef = (String) context.get(\"shipmentId\");\r\n                    bodyParameters.put(\"origRef\", origRef);\r\n                }\r\n        \r\n        confirmBodContext.put(\"bodyParameters\", bodyParameters);\r\n        confirmBodContext.put(\"bodyScreenUri\", bodyScreenUri);\r\n        \r\n        try\r\n        {\r\n            exportMsgResult = dispatcher.runSync(\"exportMsgFromScreen\", confirmBodContext);\r\n            if (ServiceUtil.isError(exportMsgResult)) return exportMsgResult;\r\n            // TODO: Push messasge to partner server.\r\n            \r\n        } catch (GenericServiceException e){\r\n            Debug.logError(e, \"Error while generating message\", module);\r\n        }\r\n\r\n        oagisMsgInfoContext.put(\"logicalId\", logicalId);\r\n        oagisMsgInfoContext.put(\"component\", \"EXCEPTION\");\r\n        oagisMsgInfoContext.put(\"task\", \"RECIEPT\");\r\n        oagisMsgInfoContext.put(\"referenceId\", referenceId);\r\n        oagisMsgInfoContext.put(\"authId\", authId);\r\n        oagisMsgInfoContext.put(\"sentDate\", timestamp);\r\n        oagisMsgInfoContext.put(\"confirmation\", \"0\");\r\n        oagisMsgInfoContext.put(\"bsrVerb\", \"CONFIRM\");\r\n        oagisMsgInfoContext.put(\"bsrNoun\", \"BOD\");\r\n        oagisMsgInfoContext.put(\"bsrRevision\", \"004\");\r\n        oagisMsgInfoContext.put(\"userLogin\", userLogin);\r\n        try\r\n        {\r\n            Map oagisMsgInfoResult = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoContext);\r\n            if (ServiceUtil.isError(oagisMsgInfoResult)) return oagisMsgInfoResult;\r\n            \r\n        } catch (GenericServiceException e) {\r\n            Debug.logError(e, \"Saving message to database failed\", module);\r\n        }\r\n        return ServiceUtil.returnSuccess(\"Service Completed Successfully\");\r\n    }","commit_id":"9cd57c80ad3ab1d58661de6c6552e9ded170446b","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map setCommEventComplete(DispatchContext dctx, Map context) {\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        String communicationEventId = (String) context.get(\"communicationEventId\");\n        \n        // assume it's a success unless updateCommunicationEvent gives us an error\n        Map result = ServiceUtil.returnSuccess();\n        try {\n            Map tmpResult = dispatcher.runSync(\"updateCommunicationEvent\", UtilMisc.<String, Object>toMap(\"communicationEventId\", communicationEventId,\n                    \"statusId\", \"COM_COMPLETE\", \"userLogin\", userLogin));\n            if (ServiceUtil.isError(result)) {\n                result = ServiceUtil.returnError(ServiceUtil.getErrorMessage(result));\n            }\n        } catch (GenericServiceException esx) {\n            return ServiceUtil.returnError(esx.getMessage());\n        }\n\n        return result;\n    }","id":76343,"modified_method":"public static Map setCommEventComplete(DispatchContext dctx, Map context) {\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        String communicationEventId = (String) context.get(\"communicationEventId\");\n        \n        try {\n            Map<String, Object> result = dispatcher.runSync(\"updateCommunicationEvent\", UtilMisc.<String, Object>toMap(\"communicationEventId\", communicationEventId,\n                    \"statusId\", \"COM_COMPLETE\", \"userLogin\", userLogin));\n            if (ServiceUtil.isError(result)) {\n                return ServiceUtil.returnError(ServiceUtil.getErrorMessage(result));\n            }\n        } catch (GenericServiceException esx) {\n            return ServiceUtil.returnError(esx.getMessage());\n        }\n\n        return ServiceUtil.returnSuccess();\n    }","commit_id":"1c6884cfd682c04711e242fb4be1a7d3217cf97b","url":"https://github.com/apache/ofbiz"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n\n        final String eventID = post.get(\"eventID\", \"\");\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final int item = post.getInt(\"item\", -1);\n        final RequestHeader.FileType fileType = header.fileType();\n\n        // default settings for blank item\n        prop.put(\"content\", \"0\");\n        prop.put(\"rss\", \"0\");\n        prop.put(\"references\", \"0\");\n        prop.put(\"rssreferences\", \"0\");\n        prop.put(\"dynamic\", \"0\");\n\n        // find search event\n        final SearchEvent theSearch = SearchEventCache.getEvent(eventID);\n        if (theSearch == null) {\n            // the event does not exist, show empty page\n            return prop;\n        }\n\n        // dynamically update count values\n        prop.put(\"offset\", theSearch.query.neededResults() - theSearch.query.itemsPerPage() + 1);\n        prop.put(\"itemscount\", Formatter.number(Math.min((item < 0) ? theSearch.query.neededResults() : item + 1, theSearch.getResultCount())));\n        prop.put(\"itemsperpage\", Formatter.number(theSearch.query.itemsPerPage));\n        prop.put(\"totalcount\", Formatter.number(theSearch.getResultCount(), true));\n        prop.put(\"localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n        prop.put(\"remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n        prop.put(\"remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n        prop.put(\"remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n        prop.put(\"navurlBase\", QueryParams.navurlBase(RequestHeader.FileType.HTML, theSearch.query, null, false).toString());\n        final String target_special_pattern = sb.getConfig(SwitchboardConstants.SEARCH_TARGET_SPECIAL_PATTERN, \"\");\n\n        long timeout = item == 0 ? 10000 : (theSearch.query.isLocal() ? 1000 : 3000);\n        \n        if (theSearch.query.contentdom == Classification.ContentDomain.TEXT || theSearch.query.contentdom == Classification.ContentDomain.ALL) {\n            // text search\n\n            // generate result object\n            final ResultEntry result = theSearch.oneResult(item, timeout);\n            if (result == null) return prop; // no content\n            final String resultUrlstring = result.urlstring();\n            final DigestURL resultURL = result.url();\n            final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n            final int port = resultURL.getPort();\n            DigestURL faviconURL = null;\n            if ((fileType == FileType.HTML || fileType == FileType.JSON) && !sb.isIntranetMode()) try {\n                faviconURL = new DigestURL(resultURL.getProtocol() + \"://\" + resultURL.getHost() + ((port != -1) ? (\":\" + port) : \"\") + \"/favicon.ico\");\n            } catch (final MalformedURLException e1) {\n                ConcurrentLog.logException(e1);\n                faviconURL = null;\n            }\n            final String resource = theSearch.query.domType.toString();\n            final String origQ = theSearch.query.getQueryGoal().getQueryString(true);\n            prop.put(\"content\", 1); // switch on specific content\n            prop.put(\"content_authorized\", authenticated ? \"1\" : \"0\");\n            final String urlhash = ASCII.String(result.hash());\n            if (authenticated) { // only needed if authorized\n                boolean bookmarkexists;\n                try { // check url exists in bookkmarks\n                    bookmarkexists = sb.bookmarksDB.getBookmark(urlhash) != null;\n                } catch (IOException ex) {\n                    bookmarkexists = false;\n                }\n                prop.put(\"content_authorized_bookmark\", !bookmarkexists);\n                // bookmark icon check for YMarks\n                //prop.put(\"content_authorized_bookmark\", sb.tables.bookmarks.hasBookmark(\"admin\", urlhash) ? \"0\" : \"1\");\n                prop.putHTML(\"content_authorized_bookmark_bookmarklink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&resource=\" + resource + \"&time=3&bookmarkref=\" + urlhash + \"&bookmarkurl=\" + crypt.simpleEncode(resultUrlstring) + \"&urlmaskfilter=.*\");\n                prop.put(\"content_authorized_recommend\", (sb.peers.newsPool.getSpecific(NewsPool.OUTGOING_DB, NewsPool.CATEGORY_SURFTIPP_ADD, \"url\", resultUrlstring) == null) ? \"1\" : \"0\");\n                prop.putHTML(\"content_authorized_recommend_deletelink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&deleteref=\" + urlhash + \"&urlmaskfilter=.*\");\n                prop.putHTML(\"content_authorized_recommend_recommendlink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&recommendref=\" + urlhash + \"&urlmaskfilter=.*\");\n                prop.put(\"content_authorized_urlhash\", urlhash);\n            }\n            prop.putHTML(\"content_title\", result.title());\n            prop.putXML(\"content_title-xml\", result.title());\n            prop.putJSON(\"content_title-json\", result.title());\n            prop.putHTML(\"content_showPictures_link\", resultUrlstring);\n            //prop.putHTML(\"content_link\", resultUrlstring);\n\n// START interaction\n            if (sb.getConfigBool(\"proxyURL.useforresults\", false) && sb.getConfigBool(\"proxyURL\", false)) {\n                String modifyURL = resultUrlstring;\n                // check if url is allowed to view\n                final String tmprewritecfg = sb.getConfig(\"proxyURL.rewriteURLs\", \"all\");\n                if (tmprewritecfg.equals(\"all\")) {\n                    modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                } else if (tmprewritecfg.equals(\"domainlist\")) { // check if url is allowed to view\n                    try {\n                        if (sb.crawlStacker.urlInAcceptedDomain(new DigestURL(resultUrlstring)) == null) {\n                            modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                        }\n                    } catch (final MalformedURLException e) {\n                        ConcurrentLog.logException(e);\n                    }\n                } else if (tmprewritecfg.equals(\"yacy\")) {\n                    try {\n                        if ((new DigestURL(resultUrlstring).getHost().endsWith(\".yacy\"))) {\n                            modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                        }\n                    } catch (final MalformedURLException e) {\n                        ConcurrentLog.logException(e);\n                    }\n                }\n                prop.putXML(\"content_link\", modifyURL); // putXML for rss\n            } else {\n                prop.putXML(\"content_link\", resultUrlstring); // putXML for rss\n            }\n            \n//            prop.putHTML(\"content_value\", Interaction.TripleGet(result.urlstring(), \"http://virtual.x/hasvalue\", \"anonymous\"));\n// END interaction\n\n            boolean isAtomFeed = header.get(HeaderFramework.CONNECTION_PROP_EXT, \"\").equals(\"atom\");\n            String resultFileName = resultURL.getFileName();\n            prop.putHTML(\"content_target\", target);\n            //if (faviconURL != null && fileType == FileType.HTML) sb.loader.loadIfNotExistBackground(faviconURL, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n            prop.putHTML(\"content_faviconCode\", URLLicense.aquireLicense(faviconURL)); // acquire license for favicon url loading\n            prop.put(\"content_urlhash\", urlhash);\n            prop.put(\"content_ranking\", Float.toString(result.score()));\n            Date[] events = result.events();\n            boolean showEvent = events != null && events.length > 0 && sb.getConfig(\"search.navigation\", \"\").indexOf(\"date\",0) >= 0;\n            prop.put(\"content_showEvent\", showEvent ? 1 : 0);\n            if (fileType == FileType.HTML) { // html template specific settings\n                prop.put(\"content_showDate\", sb.getConfigBool(\"search.result.show.date\", true) && !showEvent ? 1 : 0);\n                prop.put(\"content_showSize\", sb.getConfigBool(\"search.result.show.size\", true) ? 1 : 0);\n                prop.put(\"content_showMetadata\", sb.getConfigBool(\"search.result.show.metadata\", true) ? 1 : 0);\n                prop.put(\"content_showParser\", sb.getConfigBool(\"search.result.show.parser\", true) ? 1 : 0);\n                prop.put(\"content_showCitation\", sb.getConfigBool(\"search.result.show.citation\", true) ? 1 : 0);\n                prop.put(\"content_showPictures\", sb.getConfigBool(\"search.result.show.pictures\", true) ? 1 : 0);\n                prop.put(\"content_showCache\", sb.getConfigBool(\"search.result.show.cache\", true) && Cache.has(resultURL.hash()) ? 1 : 0);\n                prop.put(\"content_showProxy\", sb.getConfigBool(\"search.result.show.proxy\", true) ? 1 : 0);\n                prop.put(\"content_showHostBrowser\", sb.getConfigBool(\"search.result.show.hostbrowser\", true) ? 1 : 0);\n                prop.put(\"content_showVocabulary\", sb.getConfigBool(\"search.result.show.vocabulary\", true) ? 1 : 0);\n\n                if (showEvent) prop.put(\"content_showEvent_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(events[0]));\n                prop.put(\"content_showDate_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(result.modified()));\n                prop.putHTML(\"content_showSize_sizename\", RSSMessage.sizename(result.filesize()));\n                prop.put(\"content_showMetadata_urlhash\", urlhash);\n                prop.put(\"content_showParser_urlhash\", urlhash);\n                prop.put(\"content_showCitation_urlhash\", urlhash);\n                prop.putHTML(\"content_showPictures_former\", origQ);\n                prop.put(\"content_showCache_link\", resultUrlstring);\n                prop.put(\"content_showProxy_link\", resultUrlstring);\n                prop.put(\"content_showHostBrowser_link\", resultUrlstring);\n                if (sb.getConfigBool(\"search.result.show.vocabulary\", true)) {\n                    URIMetadataNode node = result.getNode();\n                    int c = 0;\n                    for (Map.Entry<String, Object> entry: node.entrySet()) {\n                        String key = entry.getKey();\n                        if (key.startsWith(\"vocabulary_\") && key.endsWith(\"_sxt\")) {\n                            @SuppressWarnings(\"unchecked\")\n                            Collection<String> terms = (Collection<String>) entry.getValue();\n                            prop.putHTML(\"content_showVocabulary_vocabulary_\" + c + \"_name\", key.substring(11, key.length() - 4));\n                            prop.putHTML(\"content_showVocabulary_vocabulary_\" + c + \"_terms\", terms.toString());\n                            c++;\n                        }\n                    }\n                    prop.put(\"content_showVocabulary_vocabulary\", c);\n                    prop.put(\"content_showVocabulary\", 1);\n                } else {\n                    prop.put(\"content_showVocabulary_vocabulary\", 0);\n                    prop.put(\"content_showVocabulary\", 0);\n                }\n            }\n            prop.put(\"content_urlhexhash\", Seed.b64Hash2hexHash(urlhash));\n            prop.putHTML(\"content_urlname\", nxTools.shortenURLString(result.urlname(), MAX_URL_LENGTH));\n            prop.put(\"content_date822\", isAtomFeed ? ISO8601Formatter.FORMATTER.format(result.modified()) : HeaderFramework.formatRFC1123(result.modified()));\n            if (showEvent) prop.put(\"content_showEvent_date822\", isAtomFeed ? ISO8601Formatter.FORMATTER.format(events[0]) : HeaderFramework.formatRFC1123(events[0]));\n            //prop.put(\"content_ybr\", RankingProcess.ybr(result.hash()));\n            prop.putHTML(\"content_size\", Integer.toString(result.filesize())); // we don't use putNUM here because that number shall be usable as sorting key. To print the size, use 'sizename'\n            prop.putHTML(\"content_sizename\", RSSMessage.sizename(result.filesize()));            \n            prop.putHTML(\"content_host\", resultURL.getHost() == null ? \"\" : resultURL.getHost());\n            prop.putXML(\"content_file\", resultFileName); // putXML for rss\n            prop.putXML(\"content_path\", resultURL.getPath()); // putXML for rss\n            prop.put(\"content_nl\", (item == theSearch.query.offset) ? 0 : 1);\n            prop.putHTML(\"content_publisher\", result.publisher());\n            prop.putHTML(\"content_creator\", result.creator());// author\n            prop.putHTML(\"content_subject\", result.subject());\n            final Iterator<String> query = theSearch.query.getQueryGoal().getIncludeStrings();\n            final StringBuilder s = new StringBuilder(theSearch.query.getQueryGoal().getIncludeSize() * 20);\n            while (query.hasNext()) s.append('+').append(query.next());\n            final String words = (s.length() > 0) ? s.substring(1) : \"\";\n            prop.putHTML(\"content_words\", words);\n            prop.putHTML(\"content_showParser_words\", words);\n            prop.putHTML(\"content_former\", origQ);\n            final TextSnippet snippet = result.textSnippet();\n            final String desc = (snippet == null) ? \"\" : snippet.descriptionline(theSearch.query.getQueryGoal());\n            prop.put(\"content_description\", desc);\n            prop.putXML(\"content_description-xml\", desc);\n            prop.putJSON(\"content_description-json\", desc);\n            prop.put(\"content_mimetype\",result.getNode().mime()); // for atom <link> type attribute\n            final HeuristicResult heuristic = theSearch.getHeuristic(result.hash());\n            if (heuristic == null) {\n                prop.put(\"content_heuristic\", 0);\n            } else {\n                if (heuristic.redundant) {\n                    prop.put(\"content_heuristic\", 1);\n                } else {\n                    prop.put(\"content_heuristic\", 2);\n                }\n                prop.put(\"content_heuristic_name\", heuristic.heuristicName);\n            }\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theSearch.query.id(true), SearchEventType.FINALIZATION, \"\" + item, 0, 0), false);\n            final String ext = MultiProtocolURL.getFileExtension(resultFileName);\n            if (MultiProtocolURL.isImage(ext)) {\n                final String license = URLLicense.aquireLicense(resultURL);\n                prop.put(\"content_code\", license);\n            } else {\n                prop.put(\"content_code\", \"\");\n            }\n            if (result.lat() == 0.0d || result.lon() == 0.0d) {\n                prop.put(\"content_loc\", 0);\n            } else {\n                prop.put(\"content_loc\", 1);\n                prop.put(\"content_loc_lat\", result.lat());\n                prop.put(\"content_loc_lon\", result.lon());\n            }\n            final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n            final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n            boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n            boolean stealthmode = p2pmode && theSearch.query.isLocal();\n            if ((sb.getConfigBool(SwitchboardConstants.HEURISTIC_SEARCHRESULTS, false) ||\n                (sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false) && sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ENABLED, false) && Memory.load() < 1.0)) &&\n                !stealthmode) sb.heuristicSearchResults(resultUrlstring);\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if (theSearch.query.contentdom == Classification.ContentDomain.IMAGE) {\n            // image search; shows thumbnails\n\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            SearchEvent.ImageResult image = null;\n            try {\n                image = theSearch.oneImageResult(item, timeout);\n                final String imageUrlstring = image.imageUrl.toNormalform(true);\n                final String imageUrlExt = MultiProtocolURL.getFileExtension(image.imageUrl.getFileName());\n                final String target = sb.getConfig(imageUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n                final String license = URLLicense.aquireLicense(image.imageUrl); // this is just the license key to get the image forwarded through the YaCy thumbnail viewer, not an actual lawful license\n                //sb.loader.loadIfNotExistBackground(image.imageUrl, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n                prop.putHTML(\"content_item_hrefCache\", \"/ViewImage.\" + (\"gif\".equals(imageUrlExt) ? \"gif\" : \"png\") + \"?maxwidth=128&maxheight=128&isStatic=true&quadratic=&url=\" + imageUrlstring);\n                prop.putHTML(\"content_item_href\", imageUrlstring);\n                prop.putHTML(\"content_item_target\", target);\n                prop.put(\"content_item_code\", license);\n                prop.putHTML(\"content_item_name\", shorten(image.imagetext, MAX_NAME_LENGTH));\n                prop.put(\"content_item_mimetype\", image.mimetype);\n                prop.put(\"content_item_fileSize\", 0);\n                prop.put(\"content_item_width\", image.width);\n                prop.put(\"content_item_height\", image.height);\n                prop.put(\"content_item_attr\", \"\"/*(ms.attr.equals(\"-1 x -1\")) ? \"\" : \"(\" + ms.attr + \")\"*/); // attributes, here: original size of image\n                prop.put(\"content_item_urlhash\", ASCII.String(image.imageUrl.hash()));\n                prop.put(\"content_item_source\", image.sourceUrl.toNormalform(true));\n                prop.putXML(\"content_item_source-xml\", image.sourceUrl.toNormalform(true));\n                prop.put(\"content_item_sourcedom\", image.sourceUrl.getHost());\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            } catch (MalformedURLException e) {\n                prop.put(\"content_item\", \"0\");\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if ((theSearch.query.contentdom == ContentDomain.AUDIO) ||\n            (theSearch.query.contentdom == ContentDomain.VIDEO) ||\n            (theSearch.query.contentdom == ContentDomain.APP)) {\n            // any other media content\n\n            // generate result object\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_hrefshort\", nxTools.shortenURLString(resultUrlstring, MAX_URL_LENGTH));\n                prop.putHTML(\"content_item_target\", target);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_col\", (item % 2 == 0) ? \"0\" : \"1\");\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        return prop;\n    }","id":76344,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n\n        final String eventID = post.get(\"eventID\", \"\");\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final int item = post.getInt(\"item\", -1);\n        final RequestHeader.FileType fileType = header.fileType();\n\n        // default settings for blank item\n        prop.put(\"content\", \"0\");\n        prop.put(\"rss\", \"0\");\n        prop.put(\"references\", \"0\");\n        prop.put(\"rssreferences\", \"0\");\n        prop.put(\"dynamic\", \"0\");\n\n        // find search event\n        final SearchEvent theSearch = SearchEventCache.getEvent(eventID);\n        if (theSearch == null) {\n            // the event does not exist, show empty page\n            return prop;\n        }\n\n        // dynamically update count values\n        prop.put(\"offset\", theSearch.query.neededResults() - theSearch.query.itemsPerPage() + 1);\n        prop.put(\"itemscount\", Formatter.number(Math.min((item < 0) ? theSearch.query.neededResults() : item + 1, theSearch.getResultCount())));\n        prop.put(\"itemsperpage\", Formatter.number(theSearch.query.itemsPerPage));\n        prop.put(\"totalcount\", Formatter.number(theSearch.getResultCount(), true));\n        prop.put(\"localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n        prop.put(\"remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n        prop.put(\"remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n        prop.put(\"remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n        prop.put(\"navurlBase\", QueryParams.navurlBase(RequestHeader.FileType.HTML, theSearch.query, null, false).toString());\n        final String target_special_pattern = sb.getConfig(SwitchboardConstants.SEARCH_TARGET_SPECIAL_PATTERN, \"\");\n\n        long timeout = item == 0 ? 10000 : (theSearch.query.isLocal() ? 1000 : 3000);\n        \n        if (theSearch.query.contentdom == Classification.ContentDomain.TEXT || theSearch.query.contentdom == Classification.ContentDomain.ALL) {\n            // text search\n\n            // generate result object\n            final ResultEntry result = theSearch.oneResult(item, timeout);\n            if (result == null) return prop; // no content\n            final String resultUrlstring = result.urlstring();\n            final DigestURL resultURL = result.url();\n            final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n            final int port = resultURL.getPort();\n            DigestURL faviconURL = null;\n            if ((fileType == FileType.HTML || fileType == FileType.JSON) && !sb.isIntranetMode()) try {\n                faviconURL = new DigestURL(resultURL.getProtocol() + \"://\" + resultURL.getHost() + ((port != -1) ? (\":\" + port) : \"\") + \"/favicon.ico\");\n            } catch (final MalformedURLException e1) {\n                ConcurrentLog.logException(e1);\n                faviconURL = null;\n            }\n            final String resource = theSearch.query.domType.toString();\n            final String origQ = theSearch.query.getQueryGoal().getQueryString(true);\n            prop.put(\"content\", 1); // switch on specific content\n            prop.put(\"content_authorized\", authenticated ? \"1\" : \"0\");\n            final String urlhash = ASCII.String(result.hash());\n            if (authenticated) { // only needed if authorized\n                boolean bookmarkexists;\n                try { // check url exists in bookkmarks\n                    bookmarkexists = sb.bookmarksDB.getBookmark(urlhash) != null;\n                } catch (IOException ex) {\n                    bookmarkexists = false;\n                }\n                prop.put(\"content_authorized_bookmark\", !bookmarkexists);\n                // bookmark icon check for YMarks\n                //prop.put(\"content_authorized_bookmark\", sb.tables.bookmarks.hasBookmark(\"admin\", urlhash) ? \"0\" : \"1\");\n                prop.putHTML(\"content_authorized_bookmark_bookmarklink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&resource=\" + resource + \"&time=3&bookmarkref=\" + urlhash + \"&bookmarkurl=\" + crypt.simpleEncode(resultUrlstring) + \"&urlmaskfilter=.*\");\n                prop.put(\"content_authorized_recommend\", (sb.peers.newsPool.getSpecific(NewsPool.OUTGOING_DB, NewsPool.CATEGORY_SURFTIPP_ADD, \"url\", resultUrlstring) == null) ? \"1\" : \"0\");\n                prop.putHTML(\"content_authorized_recommend_deletelink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&deleteref=\" + urlhash + \"&urlmaskfilter=.*\");\n                prop.putHTML(\"content_authorized_recommend_recommendlink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&recommendref=\" + urlhash + \"&urlmaskfilter=.*\");\n                prop.put(\"content_authorized_urlhash\", urlhash);\n            }\n            prop.putHTML(\"content_title\", result.title());\n            prop.putXML(\"content_title-xml\", result.title());\n            prop.putJSON(\"content_title-json\", result.title());\n            prop.putHTML(\"content_showPictures_link\", resultUrlstring);\n            //prop.putHTML(\"content_link\", resultUrlstring);\n\n// START interaction\n            if (sb.getConfigBool(\"proxyURL.useforresults\", false) && sb.getConfigBool(\"proxyURL\", false)) {\n                String modifyURL = resultUrlstring;\n                // check if url is allowed to view\n                final String tmprewritecfg = sb.getConfig(\"proxyURL.rewriteURLs\", \"all\");\n                if (tmprewritecfg.equals(\"all\")) {\n                    modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                } else if (tmprewritecfg.equals(\"domainlist\")) { // check if url is allowed to view\n                    try {\n                        if (sb.crawlStacker.urlInAcceptedDomain(new DigestURL(resultUrlstring)) == null) {\n                            modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                        }\n                    } catch (final MalformedURLException e) {\n                        ConcurrentLog.logException(e);\n                    }\n                } else if (tmprewritecfg.equals(\"yacy\")) {\n                    try {\n                        if ((new DigestURL(resultUrlstring).getHost().endsWith(\".yacy\"))) {\n                            modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                        }\n                    } catch (final MalformedURLException e) {\n                        ConcurrentLog.logException(e);\n                    }\n                }\n                prop.putXML(\"content_link\", modifyURL); // putXML for rss\n            } else {\n                prop.putXML(\"content_link\", resultUrlstring); // putXML for rss\n            }\n            \n//            prop.putHTML(\"content_value\", Interaction.TripleGet(result.urlstring(), \"http://virtual.x/hasvalue\", \"anonymous\"));\n// END interaction\n\n            boolean isAtomFeed = header.get(HeaderFramework.CONNECTION_PROP_EXT, \"\").equals(\"atom\");\n            String resultFileName = resultURL.getFileName();\n            prop.putHTML(\"content_target\", target);\n            //if (faviconURL != null && fileType == FileType.HTML) sb.loader.loadIfNotExistBackground(faviconURL, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n            prop.putHTML(\"content_faviconCode\", URLLicense.aquireLicense(faviconURL)); // acquire license for favicon url loading\n            prop.put(\"content_urlhash\", urlhash);\n            prop.put(\"content_ranking\", Float.toString(result.score()));\n            Date[] events = result.events();\n            boolean showEvent = events != null && events.length > 0 && sb.getConfig(\"search.navigation\", \"\").indexOf(\"date\",0) >= 0;\n            prop.put(\"content_showEvent\", showEvent ? 1 : 0);\n            if (fileType == FileType.HTML) { // html template specific settings\n                prop.put(\"content_showDate\", sb.getConfigBool(\"search.result.show.date\", true) && !showEvent ? 1 : 0);\n                prop.put(\"content_showSize\", sb.getConfigBool(\"search.result.show.size\", true) ? 1 : 0);\n                prop.put(\"content_showMetadata\", sb.getConfigBool(\"search.result.show.metadata\", true) ? 1 : 0);\n                prop.put(\"content_showParser\", sb.getConfigBool(\"search.result.show.parser\", true) ? 1 : 0);\n                prop.put(\"content_showCitation\", sb.getConfigBool(\"search.result.show.citation\", true) ? 1 : 0);\n                prop.put(\"content_showPictures\", sb.getConfigBool(\"search.result.show.pictures\", true) ? 1 : 0);\n                prop.put(\"content_showCache\", sb.getConfigBool(\"search.result.show.cache\", true) && Cache.has(resultURL.hash()) ? 1 : 0);\n                prop.put(\"content_showProxy\", sb.getConfigBool(\"search.result.show.proxy\", true) && sb.getConfigBool(\"proxyURL\", false) ? 1 : 0);\n                prop.put(\"content_showHostBrowser\", sb.getConfigBool(\"search.result.show.hostbrowser\", true) ? 1 : 0);\n                prop.put(\"content_showVocabulary\", sb.getConfigBool(\"search.result.show.vocabulary\", true) ? 1 : 0);\n\n                if (showEvent) prop.put(\"content_showEvent_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(events[0]));\n                prop.put(\"content_showDate_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(result.modified()));\n                prop.putHTML(\"content_showSize_sizename\", RSSMessage.sizename(result.filesize()));\n                prop.put(\"content_showMetadata_urlhash\", urlhash);\n                prop.put(\"content_showParser_urlhash\", urlhash);\n                prop.put(\"content_showCitation_urlhash\", urlhash);\n                prop.putHTML(\"content_showPictures_former\", origQ);\n                prop.put(\"content_showCache_link\", resultUrlstring);\n                prop.put(\"content_showProxy_link\", resultUrlstring);\n                prop.put(\"content_showHostBrowser_link\", resultUrlstring);\n                if (sb.getConfigBool(\"search.result.show.vocabulary\", true)) {\n                    URIMetadataNode node = result.getNode();\n                    int c = 0;\n                    for (Map.Entry<String, Object> entry: node.entrySet()) {\n                        String key = entry.getKey();\n                        if (key.startsWith(\"vocabulary_\") && key.endsWith(\"_sxt\")) {\n                            @SuppressWarnings(\"unchecked\")\n                            Collection<String> terms = (Collection<String>) entry.getValue();\n                            prop.putHTML(\"content_showVocabulary_vocabulary_\" + c + \"_name\", key.substring(11, key.length() - 4));\n                            prop.putHTML(\"content_showVocabulary_vocabulary_\" + c + \"_terms\", terms.toString());\n                            c++;\n                        }\n                    }\n                    prop.put(\"content_showVocabulary_vocabulary\", c);\n                    prop.put(\"content_showVocabulary\", 1);\n                } else {\n                    prop.put(\"content_showVocabulary_vocabulary\", 0);\n                    prop.put(\"content_showVocabulary\", 0);\n                }\n            }\n            prop.put(\"content_urlhexhash\", Seed.b64Hash2hexHash(urlhash));\n            prop.putHTML(\"content_urlname\", nxTools.shortenURLString(result.urlname(), MAX_URL_LENGTH));\n            prop.put(\"content_date822\", isAtomFeed ? ISO8601Formatter.FORMATTER.format(result.modified()) : HeaderFramework.formatRFC1123(result.modified()));\n            if (showEvent) prop.put(\"content_showEvent_date822\", isAtomFeed ? ISO8601Formatter.FORMATTER.format(events[0]) : HeaderFramework.formatRFC1123(events[0]));\n            //prop.put(\"content_ybr\", RankingProcess.ybr(result.hash()));\n            prop.putHTML(\"content_size\", Integer.toString(result.filesize())); // we don't use putNUM here because that number shall be usable as sorting key. To print the size, use 'sizename'\n            prop.putHTML(\"content_sizename\", RSSMessage.sizename(result.filesize()));            \n            prop.putHTML(\"content_host\", resultURL.getHost() == null ? \"\" : resultURL.getHost());\n            prop.putXML(\"content_file\", resultFileName); // putXML for rss\n            prop.putXML(\"content_path\", resultURL.getPath()); // putXML for rss\n            prop.put(\"content_nl\", (item == theSearch.query.offset) ? 0 : 1);\n            prop.putHTML(\"content_publisher\", result.publisher());\n            prop.putHTML(\"content_creator\", result.creator());// author\n            prop.putHTML(\"content_subject\", result.subject());\n            final Iterator<String> query = theSearch.query.getQueryGoal().getIncludeStrings();\n            final StringBuilder s = new StringBuilder(theSearch.query.getQueryGoal().getIncludeSize() * 20);\n            while (query.hasNext()) s.append('+').append(query.next());\n            final String words = (s.length() > 0) ? s.substring(1) : \"\";\n            prop.putHTML(\"content_words\", words);\n            prop.putHTML(\"content_showParser_words\", words);\n            prop.putHTML(\"content_former\", origQ);\n            final TextSnippet snippet = result.textSnippet();\n            final String desc = (snippet == null) ? \"\" : snippet.descriptionline(theSearch.query.getQueryGoal());\n            prop.put(\"content_description\", desc);\n            prop.putXML(\"content_description-xml\", desc);\n            prop.putJSON(\"content_description-json\", desc);\n            prop.put(\"content_mimetype\",result.getNode().mime()); // for atom <link> type attribute\n            final HeuristicResult heuristic = theSearch.getHeuristic(result.hash());\n            if (heuristic == null) {\n                prop.put(\"content_heuristic\", 0);\n            } else {\n                if (heuristic.redundant) {\n                    prop.put(\"content_heuristic\", 1);\n                } else {\n                    prop.put(\"content_heuristic\", 2);\n                }\n                prop.put(\"content_heuristic_name\", heuristic.heuristicName);\n            }\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theSearch.query.id(true), SearchEventType.FINALIZATION, \"\" + item, 0, 0), false);\n            final String ext = MultiProtocolURL.getFileExtension(resultFileName);\n            if (MultiProtocolURL.isImage(ext)) {\n                final String license = URLLicense.aquireLicense(resultURL);\n                prop.put(\"content_code\", license);\n            } else {\n                prop.put(\"content_code\", \"\");\n            }\n            if (result.lat() == 0.0d || result.lon() == 0.0d) {\n                prop.put(\"content_loc\", 0);\n            } else {\n                prop.put(\"content_loc\", 1);\n                prop.put(\"content_loc_lat\", result.lat());\n                prop.put(\"content_loc_lon\", result.lon());\n            }\n            final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n            final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n            boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n            boolean stealthmode = p2pmode && theSearch.query.isLocal();\n            if ((sb.getConfigBool(SwitchboardConstants.HEURISTIC_SEARCHRESULTS, false) ||\n                (sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false) && sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ENABLED, false) && Memory.load() < 1.0)) &&\n                !stealthmode) sb.heuristicSearchResults(resultUrlstring);\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if (theSearch.query.contentdom == Classification.ContentDomain.IMAGE) {\n            // image search; shows thumbnails\n\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            SearchEvent.ImageResult image = null;\n            try {\n                image = theSearch.oneImageResult(item, timeout);\n                final String imageUrlstring = image.imageUrl.toNormalform(true);\n                final String imageUrlExt = MultiProtocolURL.getFileExtension(image.imageUrl.getFileName());\n                final String target = sb.getConfig(imageUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n                final String license = URLLicense.aquireLicense(image.imageUrl); // this is just the license key to get the image forwarded through the YaCy thumbnail viewer, not an actual lawful license\n                //sb.loader.loadIfNotExistBackground(image.imageUrl, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n                prop.putHTML(\"content_item_hrefCache\", \"/ViewImage.\" + (\"gif\".equals(imageUrlExt) ? \"gif\" : \"png\") + \"?maxwidth=128&maxheight=128&isStatic=true&quadratic=&url=\" + imageUrlstring);\n                prop.putHTML(\"content_item_href\", imageUrlstring);\n                prop.putHTML(\"content_item_target\", target);\n                prop.put(\"content_item_code\", license);\n                prop.putHTML(\"content_item_name\", shorten(image.imagetext, MAX_NAME_LENGTH));\n                prop.put(\"content_item_mimetype\", image.mimetype);\n                prop.put(\"content_item_fileSize\", 0);\n                prop.put(\"content_item_width\", image.width);\n                prop.put(\"content_item_height\", image.height);\n                prop.put(\"content_item_attr\", \"\"/*(ms.attr.equals(\"-1 x -1\")) ? \"\" : \"(\" + ms.attr + \")\"*/); // attributes, here: original size of image\n                prop.put(\"content_item_urlhash\", ASCII.String(image.imageUrl.hash()));\n                prop.put(\"content_item_source\", image.sourceUrl.toNormalform(true));\n                prop.putXML(\"content_item_source-xml\", image.sourceUrl.toNormalform(true));\n                prop.put(\"content_item_sourcedom\", image.sourceUrl.getHost());\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            } catch (MalformedURLException e) {\n                prop.put(\"content_item\", \"0\");\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if ((theSearch.query.contentdom == ContentDomain.AUDIO) ||\n            (theSearch.query.contentdom == ContentDomain.VIDEO) ||\n            (theSearch.query.contentdom == ContentDomain.APP)) {\n            // any other media content\n\n            // generate result object\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_hrefshort\", nxTools.shortenURLString(resultUrlstring, MAX_URL_LENGTH));\n                prop.putHTML(\"content_item_target\", target);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_col\", (item % 2 == 0) ? \"0\" : \"1\");\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        return prop;\n    }","commit_id":"4c907bec89d08762b5896863b46b6d7e617bc836","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        \n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        int commit = 0;\n        \n        // load all options for network definitions\n        final File networkBootstrapLocationsFile = new File(new File(sb.getRootPath(), \"defaults\"), \"yacy.networks\");\n        final HashSet<String> networkBootstrapLocations = FileUtils.loadList(networkBootstrapLocationsFile);\n        \n        \n        if (post != null) {\n            \n            // store this call as api call\n            sb.tables.recordAPICall(post, \"ConfigNetwork.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"network settings\");\n            \n            if (post.containsKey(\"changeNetwork\")) {\n                final String networkDefinition = post.get(\"networkDefinition\", \"defaults/yacy.network.freeworld.unit\");\n                if (networkDefinition.equals(sb.getConfig(\"network.unit.definition\", \"\"))) {\n                    // no change\n                    commit = 3;\n                } else {\n                    // shut down old network and index, start up new network and index\n                    commit = 1;\n                    sb.switchNetwork(networkDefinition);\n                    // check if the password is given\n                    if (sb.getConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\").length() == 0) {\n                        prop.put(\"commitPasswordWarning\", \"1\");\n                    }\n                }\n            }\n            \n            if (post.containsKey(\"save\")) {\n                boolean crawlResponse = post.get(\"crawlResponse\", \"off\").equals(\"on\");\n                \n                // DHT control\n                boolean indexDistribute = post.get(\"indexDistribute\", \"\").equals(\"on\");\n                boolean indexReceive = post.get(\"indexReceive\", \"\").equals(\"on\");\n                final boolean robinsonmode = post.get(\"network\", \"\").equals(\"robinson\");\n                final String clustermode = post.get(\"cluster.mode\", \"publicpeer\");\n                if (robinsonmode) {\n                    indexDistribute = false;\n                    indexReceive = false;\n                    if ((clustermode.equals(\"privatepeer\")) || (clustermode.equals(\"publicpeer\"))) {\n                        prop.put(\"commitRobinsonWithoutRemoteIndexing\", \"1\");\n                        crawlResponse = false;\n                    }\n                    if ((clustermode.equals(\"privatecluster\")) || (clustermode.equals(\"publiccluster\"))) {\n                        prop.put(\"commitRobinsonWithRemoteIndexing\", \"1\");\n                        crawlResponse = true;\n                    }\n                    commit = 1;\n                } else {\n                    if (!indexDistribute && !indexReceive) {\n                        prop.put(\"commitDHTIsRobinson\", \"1\");\n                        commit = 2;\n                    } else if (indexDistribute && indexReceive) {\n                        commit = 1;\n                    } else {\n                        if (!indexReceive) prop.put(\"commitDHTNoGlobalSearch\", \"1\");\n                        commit = 1;\n                    }\n                    if (!crawlResponse) {\n                        prop.put(\"commitCrawlPlea\", \"1\");\n                    }\n                }\n                \n                if (indexDistribute) {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, true);\n                } else {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, false);\n                }\n    \n                if (post.get(\"indexDistributeWhileCrawling\",\"\").equals(\"on\")) {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_CRAWLING, true);\n                } else {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_CRAWLING, false);\n                }\n    \n                if (post.get(\"indexDistributeWhileIndexing\",\"\").equals(\"on\")) {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_INDEXING, true);\n                } else {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_INDEXING, false);\n                }\n    \n                if (indexReceive) {\n                    sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true);\n                    sb.peers.mySeed().setFlagAcceptRemoteIndex(true);\n                } else {\n                    sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false);\n                    sb.peers.mySeed().setFlagAcceptRemoteIndex(false);\n                }\n    \n                if (post.get(\"indexReceiveBlockBlacklist\", \"\").equals(\"on\")) {\n                    sb.setConfig(\"indexReceiveBlockBlacklist\", true);\n                } else {\n                    sb.setConfig(\"indexReceiveBlockBlacklist\", false);\n                }\n                    \n                if (post.containsKey(\"peertags\")) {\n                    sb.peers.mySeed().setPeerTags(MapTools.string2set(normalizedList(post.get(\"peertags\")), \",\"));\n                }\n                \n                sb.setConfig(\"cluster.mode\", post.get(\"cluster.mode\", \"publicpeer\"));\n                \n                // read remote crawl request settings\n                sb.setConfig(\"crawlResponse\", (crawlResponse) ? \"true\" : \"false\");\n                int newppm = 1;\n                try {\n                    newppm = Math.max(1, Integer.parseInt(post.get(\"acceptCrawlLimit\", \"1\")));\n                } catch (final NumberFormatException e) {}\n                final long newBusySleep = Math.max(100, 60000 / newppm);\n                \n                // propagate to crawler\n                final BusyThread rct = sb.getThread(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_BUSYSLEEP, newBusySleep);\n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_IDLESLEEP, newBusySleep * 3);\n                rct.setBusySleep(newBusySleep);\n                rct.setIdleSleep(newBusySleep * 3);\n                \n                // propagate to loader\n                final BusyThread rcl = sb.getThread(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER);\n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_BUSYSLEEP, newBusySleep * 5);\n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_IDLESLEEP, newBusySleep * 10);\n                rcl.setBusySleep(newBusySleep * 5);\n                rcl.setIdleSleep(newBusySleep * 10);\n                \n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_BUSYSLEEP, Long.toString(newBusySleep));\n                \n                sb.setConfig(\"cluster.peers.ipport\", checkIPPortList(post.get(\"cluster.peers.ipport\", \"\")));\n                sb.setConfig(\"cluster.peers.yacydomain\", checkYaCyDomainList(post.get(\"cluster.peers.yacydomain\", \"\")));\n                \n                // update the cluster hash set\n                sb.clusterhashes = sb.peers.clusterHashes(sb.getConfig(\"cluster.peers.yacydomain\", \"\"));\n            }            \n        }\n        \n        // write answer code\n        prop.put(\"commit\", commit);\n        \n        // write remote crawl request settings\n        prop.put(\"crawlResponse\", sb.getConfigBool(\"crawlResponse\", false) ? \"1\" : \"0\");\n        long RTCbusySleep = 100;\n        try {\n            RTCbusySleep = Math.max(1, Integer.parseInt(env.getConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_BUSYSLEEP, \"100\")));\n        } catch (final NumberFormatException e) {}\n        final int RTCppm = (int) (60000L / RTCbusySleep);\n        prop.put(\"acceptCrawlLimit\", RTCppm);\n        \n        final boolean indexDistribute = sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\n        final boolean indexReceive = sb.getConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, \"true\").equals(\"true\");\n        prop.put(\"indexDistributeChecked\", (indexDistribute) ? \"1\" : \"0\");\n        prop.put(\"indexDistributeWhileCrawling.on\", (sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_CRAWLING, \"true\").equals(\"true\")) ? \"1\" : \"0\");\n        prop.put(\"indexDistributeWhileCrawling.off\", (sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_CRAWLING, \"true\").equals(\"true\")) ? \"0\" : \"1\");\n        prop.put(\"indexDistributeWhileIndexing.on\", (sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_INDEXING, \"true\").equals(\"true\")) ? \"1\" : \"0\");\n        prop.put(\"indexDistributeWhileIndexing.off\", (sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_INDEXING, \"true\").equals(\"true\")) ? \"0\" : \"1\");\n        prop.put(\"indexReceiveChecked\", (indexReceive) ? \"1\" : \"0\");\n        prop.put(\"indexReceiveBlockBlacklistChecked.on\", (sb.getConfig(\"indexReceiveBlockBlacklist\", \"true\").equals(\"true\")) ? \"1\" : \"0\");\n        prop.put(\"indexReceiveBlockBlacklistChecked.off\", (sb.getConfig(\"indexReceiveBlockBlacklist\", \"true\").equals(\"true\")) ? \"0\" : \"1\");\n        prop.putHTML(\"peertags\", MapTools.set2string(sb.peers.mySeed().getPeerTags(), \",\", false));\n\n        // set seed information directly\n        sb.peers.mySeed().setFlagAcceptRemoteCrawl(sb.getConfigBool(\"crawlResponse\", false));\n        sb.peers.mySeed().setFlagAcceptRemoteIndex(indexReceive);\n        \n        // set p2p/robinson mode flags and values\n        prop.put(\"p2p.checked\", (indexDistribute || indexReceive) ? \"1\" : \"0\");\n        prop.put(\"robinson.checked\", (indexDistribute || indexReceive) ? \"0\" : \"1\");\n        prop.putHTML(\"cluster.peers.ipport\", sb.getConfig(\"cluster.peers.ipport\", \"\"));\n        prop.putHTML(\"cluster.peers.yacydomain\", sb.getConfig(\"cluster.peers.yacydomain\", \"\"));\n        String hashes = \"\";\n        for (byte[] h:sb.clusterhashes.keySet()) hashes += \", \" + new String(h);\n        if (hashes.length() > 2) hashes = hashes.substring(2);\n        prop.put(\"cluster.peers.yacydomain.hashes\", hashes);\n        \n        // set p2p mode flags\n        prop.put(\"privatepeerChecked\", (sb.getConfig(\"cluster.mode\", \"\").equals(\"privatepeer\")) ? \"1\" : \"0\");\n        prop.put(\"privateclusterChecked\", (sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\")) ? \"1\" : \"0\");\n        prop.put(\"publicclusterChecked\", (sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\")) ? \"1\" : \"0\");\n        prop.put(\"publicpeerChecked\", (sb.getConfig(\"cluster.mode\", \"\").equals(\"publicpeer\")) ? \"1\" : \"0\");\n        \n        // set network configuration\n        prop.putHTML(\"network.unit.definition\", sb.getConfig(\"network.unit.definition\", \"\"));\n        prop.putHTML(\"network.unit.name\", sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"));\n        prop.putHTML(\"network.unit.description\", sb.getConfig(\"network.unit.description\", \"\"));\n        prop.putHTML(\"network.unit.domain\", sb.getConfig(\"network.unit.domain\", \"\"));\n        prop.putHTML(\"network.unit.dht\", sb.getConfig(\"network.unit.dht\", \"\"));\n        networkBootstrapLocations.remove(sb.getConfig(\"network.unit.definition\", \"\"));\n        int c = 0;\n        for (final String s: networkBootstrapLocations) prop.put(\"networks_\" + c++ + \"_network\", s);\n        prop.put(\"networks\", c);\n        \n        return prop;\n    }","id":76345,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        \n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        int commit = 0;\n        \n        // load all options for network definitions\n        final File networkBootstrapLocationsFile = new File(new File(sb.getRootPath(), \"defaults\"), \"yacy.networks\");\n        final HashSet<String> networkBootstrapLocations = FileUtils.loadList(networkBootstrapLocationsFile);\n        \n        \n        if (post != null) {\n            \n            // store this call as api call\n            sb.tables.recordAPICall(post, \"ConfigNetwork.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"network settings\");\n            \n            if (post.containsKey(\"changeNetwork\")) {\n                final String networkDefinition = post.get(\"networkDefinition\", \"defaults/yacy.network.freeworld.unit\");\n                if (networkDefinition.equals(sb.getConfig(\"network.unit.definition\", \"\"))) {\n                    // no change\n                    commit = 3;\n                } else {\n                    // shut down old network and index, start up new network and index\n                    commit = 1;\n                    sb.switchNetwork(networkDefinition);\n                    // check if the password is given\n                    if (sb.getConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\").length() == 0) {\n                        prop.put(\"commitPasswordWarning\", \"1\");\n                    }\n                }\n            }\n            \n            if (post.containsKey(\"save\")) {\n                boolean crawlResponse = post.get(\"crawlResponse\", \"off\").equals(\"on\");\n                \n                // DHT control\n                boolean indexDistribute = post.get(\"indexDistribute\", \"\").equals(\"on\");\n                boolean indexReceive = post.get(\"indexReceive\", \"\").equals(\"on\");\n                final boolean robinsonmode = post.get(\"network\", \"\").equals(\"robinson\");\n                final String clustermode = post.get(\"cluster.mode\", \"publicpeer\");\n                if (robinsonmode) {\n                    indexDistribute = false;\n                    indexReceive = false;\n                    if ((clustermode.equals(\"privatepeer\")) || (clustermode.equals(\"publicpeer\"))) {\n                        prop.put(\"commitRobinsonWithoutRemoteIndexing\", \"1\");\n                        crawlResponse = false;\n                    }\n                    if ((clustermode.equals(\"privatecluster\")) || (clustermode.equals(\"publiccluster\"))) {\n                        prop.put(\"commitRobinsonWithRemoteIndexing\", \"1\");\n                        crawlResponse = true;\n                    }\n                    commit = 1;\n                } else {\n                    if (!indexDistribute && !indexReceive) {\n                        prop.put(\"commitDHTIsRobinson\", \"1\");\n                        commit = 2;\n                    } else if (indexDistribute && indexReceive) {\n                        commit = 1;\n                    } else {\n                        if (!indexReceive) prop.put(\"commitDHTNoGlobalSearch\", \"1\");\n                        commit = 1;\n                    }\n                    if (!crawlResponse) {\n                        prop.put(\"commitCrawlPlea\", \"1\");\n                    }\n                }\n                \n                if (indexDistribute) {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, true);\n                } else {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, false);\n                }\n    \n                if (post.get(\"indexDistributeWhileCrawling\",\"\").equals(\"on\")) {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_CRAWLING, true);\n                } else {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_CRAWLING, false);\n                }\n    \n                if (post.get(\"indexDistributeWhileIndexing\",\"\").equals(\"on\")) {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_INDEXING, true);\n                } else {\n                    sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_INDEXING, false);\n                }\n    \n                if (indexReceive) {\n                    sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true);\n                    sb.peers.mySeed().setFlagAcceptRemoteIndex(true);\n                } else {\n                    sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false);\n                    sb.peers.mySeed().setFlagAcceptRemoteIndex(false);\n                    sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, false);\n                }\n    \n                if (post.get(\"indexReceiveBlockBlacklist\", \"\").equals(\"on\")) {\n                    sb.setConfig(\"indexReceiveBlockBlacklist\", true);\n                } else {\n                    sb.setConfig(\"indexReceiveBlockBlacklist\", false);\n                }\n                    \n                if (post.containsKey(\"peertags\")) {\n                    sb.peers.mySeed().setPeerTags(MapTools.string2set(normalizedList(post.get(\"peertags\")), \",\"));\n                }\n                \n                sb.setConfig(\"cluster.mode\", post.get(\"cluster.mode\", \"publicpeer\"));\n                \n                // read remote crawl request settings\n                sb.setConfig(\"crawlResponse\", (crawlResponse) ? \"true\" : \"false\");\n                int newppm = 1;\n                try {\n                    newppm = Math.max(1, Integer.parseInt(post.get(\"acceptCrawlLimit\", \"1\")));\n                } catch (final NumberFormatException e) {}\n                final long newBusySleep = Math.max(100, 60000 / newppm);\n                \n                // propagate to crawler\n                final BusyThread rct = sb.getThread(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_BUSYSLEEP, newBusySleep);\n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_IDLESLEEP, newBusySleep * 3);\n                rct.setBusySleep(newBusySleep);\n                rct.setIdleSleep(newBusySleep * 3);\n                \n                // propagate to loader\n                final BusyThread rcl = sb.getThread(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER);\n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_BUSYSLEEP, newBusySleep * 5);\n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_CRAWL_LOADER_IDLESLEEP, newBusySleep * 10);\n                rcl.setBusySleep(newBusySleep * 5);\n                rcl.setIdleSleep(newBusySleep * 10);\n                \n                sb.setConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_BUSYSLEEP, Long.toString(newBusySleep));\n                \n                sb.setConfig(\"cluster.peers.ipport\", checkIPPortList(post.get(\"cluster.peers.ipport\", \"\")));\n                sb.setConfig(\"cluster.peers.yacydomain\", checkYaCyDomainList(post.get(\"cluster.peers.yacydomain\", \"\")));\n                \n                // update the cluster hash set\n                sb.clusterhashes = sb.peers.clusterHashes(sb.getConfig(\"cluster.peers.yacydomain\", \"\"));\n            }            \n        }\n        \n        // write answer code\n        prop.put(\"commit\", commit);\n        \n        // write remote crawl request settings\n        prop.put(\"crawlResponse\", sb.getConfigBool(\"crawlResponse\", false) ? \"1\" : \"0\");\n        long RTCbusySleep = 100;\n        try {\n            RTCbusySleep = Math.max(1, Integer.parseInt(env.getConfig(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL_BUSYSLEEP, \"100\")));\n        } catch (final NumberFormatException e) {}\n        final int RTCppm = (int) (60000L / RTCbusySleep);\n        prop.put(\"acceptCrawlLimit\", RTCppm);\n        \n        final boolean indexDistribute = sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\n        final boolean indexReceive = sb.getConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, \"true\").equals(\"true\");\n        prop.put(\"indexDistributeChecked\", (indexDistribute) ? \"1\" : \"0\");\n        prop.put(\"indexDistributeWhileCrawling.on\", (sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_CRAWLING, \"true\").equals(\"true\")) ? \"1\" : \"0\");\n        prop.put(\"indexDistributeWhileCrawling.off\", (sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_CRAWLING, \"true\").equals(\"true\")) ? \"0\" : \"1\");\n        prop.put(\"indexDistributeWhileIndexing.on\", (sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_INDEXING, \"true\").equals(\"true\")) ? \"1\" : \"0\");\n        prop.put(\"indexDistributeWhileIndexing.off\", (sb.getConfig(SwitchboardConstants.INDEX_DIST_ALLOW_WHILE_INDEXING, \"true\").equals(\"true\")) ? \"0\" : \"1\");\n        prop.put(\"indexReceiveChecked\", (indexReceive) ? \"1\" : \"0\");\n        prop.put(\"indexReceiveBlockBlacklistChecked.on\", (sb.getConfig(\"indexReceiveBlockBlacklist\", \"true\").equals(\"true\")) ? \"1\" : \"0\");\n        prop.put(\"indexReceiveBlockBlacklistChecked.off\", (sb.getConfig(\"indexReceiveBlockBlacklist\", \"true\").equals(\"true\")) ? \"0\" : \"1\");\n        prop.putHTML(\"peertags\", MapTools.set2string(sb.peers.mySeed().getPeerTags(), \",\", false));\n\n        // set seed information directly\n        sb.peers.mySeed().setFlagAcceptRemoteCrawl(sb.getConfigBool(\"crawlResponse\", false));\n        sb.peers.mySeed().setFlagAcceptRemoteIndex(indexReceive);\n        \n        // set p2p/robinson mode flags and values\n        prop.put(\"p2p.checked\", (indexDistribute || indexReceive) ? \"1\" : \"0\");\n        prop.put(\"robinson.checked\", (indexDistribute || indexReceive) ? \"0\" : \"1\");\n        prop.putHTML(\"cluster.peers.ipport\", sb.getConfig(\"cluster.peers.ipport\", \"\"));\n        prop.putHTML(\"cluster.peers.yacydomain\", sb.getConfig(\"cluster.peers.yacydomain\", \"\"));\n        String hashes = \"\";\n        for (byte[] h:sb.clusterhashes.keySet()) hashes += \", \" + new String(h);\n        if (hashes.length() > 2) hashes = hashes.substring(2);\n        prop.put(\"cluster.peers.yacydomain.hashes\", hashes);\n        \n        // set p2p mode flags\n        prop.put(\"privatepeerChecked\", (sb.getConfig(\"cluster.mode\", \"\").equals(\"privatepeer\")) ? \"1\" : \"0\");\n        prop.put(\"privateclusterChecked\", (sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\")) ? \"1\" : \"0\");\n        prop.put(\"publicclusterChecked\", (sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\")) ? \"1\" : \"0\");\n        prop.put(\"publicpeerChecked\", (sb.getConfig(\"cluster.mode\", \"\").equals(\"publicpeer\")) ? \"1\" : \"0\");\n        \n        // set network configuration\n        prop.putHTML(\"network.unit.definition\", sb.getConfig(\"network.unit.definition\", \"\"));\n        prop.putHTML(\"network.unit.name\", sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"));\n        prop.putHTML(\"network.unit.description\", sb.getConfig(\"network.unit.description\", \"\"));\n        prop.putHTML(\"network.unit.domain\", sb.getConfig(\"network.unit.domain\", \"\"));\n        prop.putHTML(\"network.unit.dht\", sb.getConfig(\"network.unit.dht\", \"\"));\n        networkBootstrapLocations.remove(sb.getConfig(\"network.unit.definition\", \"\"));\n        int c = 0;\n        for (final String s: networkBootstrapLocations) prop.put(\"networks_\" + c++ + \"_network\", s);\n        prop.put(\"networks\", c);\n        \n        return prop;\n    }","commit_id":"945e0ba5a5b1843cbe7d05a9536dd8dfe05620a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * checks the resources and pauses crawls if necessary\n     */\n    public void resourceObserverJob() {\n    \tMemoryControl.setDHTkbytes(getMinFreeMemory());\n\n    \tnormalizedDiskFree = getNormalizedDiskFree();\n    \tnormalizedMemoryFree = getNormalizedMemoryFree();\n\n    \tif (normalizedDiskFree < HIGH || normalizedMemoryFree < HIGH) {\n\n    \t\tif (normalizedDiskFree < HIGH) { // pause crawls\n    \t\t\tif (!sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)) {\n    \t\t\t\tlog.logInfo(\"pausing local crawls\");\n    \t\t\t\tsb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\n    \t\t\t}\n    \t\t\tif (!sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL)) {\n    \t\t\t\tlog.logInfo(\"pausing remote triggered crawls\");\n    \t\t\t\tsb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\n    \t\t\t}\n    \t\t}\n\n    \t\tif ((normalizedDiskFree == LOW || normalizedMemoryFree < HIGH) && sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false)) {\n    \t\t\tlog.logInfo(\"disabling index receive\");\n    \t\t\tsb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false);\n    \t\t\tsb.peers.mySeed().setFlagAcceptRemoteIndex(false);\n    \t\t\tdisabledDHT = true;\n    \t\t}\n    \t}\n    \t\n    \telse {\n    \t\tif(disabledDHT) { // we were wrong!\n    \t\t\tlog.logInfo(\"enabling index receive\");\n    \t\t\tsb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true);\n    \t\t\tsb.peers.mySeed().setFlagAcceptRemoteIndex(true);\n    \t\t\tdisabledDHT = false;\n    \t\t}\n    \t\tlog.logInfo(\"resources ok\");\n    \t}\n    }","id":76346,"modified_method":"/**\n     * checks the resources and pauses crawls if necessary\n     */\n    public void resourceObserverJob() {\n    \tMemoryControl.setDHTkbytes(getMinFreeMemory());\n\n    \tnormalizedDiskFree = getNormalizedDiskFree();\n    \tnormalizedMemoryFree = getNormalizedMemoryFree();\n\n    \tif (normalizedDiskFree < HIGH || normalizedMemoryFree < HIGH) {\n\n    \t\tif (normalizedDiskFree < HIGH) { // pause crawls\n    \t\t\tif (!sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)) {\n    \t\t\t\tlog.logInfo(\"pausing local crawls\");\n    \t\t\t\tsb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\n    \t\t\t}\n    \t\t\tif (!sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL)) {\n    \t\t\t\tlog.logInfo(\"pausing remote triggered crawls\");\n    \t\t\t\tsb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\n    \t\t\t}\n    \t\t}\n\n    \t\tif ((normalizedDiskFree == LOW || normalizedMemoryFree < HIGH) && sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false)) {\n    \t\t\tlog.logInfo(\"disabling index receive\");\n    \t\t\tsb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false);\n    \t\t\tsb.peers.mySeed().setFlagAcceptRemoteIndex(false);\n    \t\t\tsb.setConfig(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true);\n    \t\t}\n    \t}\n    \t\n    \telse {\n    \t\tif(sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, false)) { // we were wrong!\n    \t\t\tlog.logInfo(\"enabling index receive\");\n    \t\t\tsb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true);\n    \t\t\tsb.peers.mySeed().setFlagAcceptRemoteIndex(true);\n    \t\t\tsb.setConfig(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, false);\n    \t\t}\n    \t\tlog.logInfo(\"resources ok\");\n    \t}\n    }","commit_id":"945e0ba5a5b1843cbe7d05a9536dd8dfe05620a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        // access control\r\n        boolean publicPage = sb.getConfigBool(\"publicSearchpage\", true);\r\n        final boolean authorizedAccess = sb.verifyAuthentication(header, false);\r\n        if ((post != null) && (post.containsKey(\"publicPage\"))) {\r\n            if (!authorizedAccess) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            publicPage = post.get(\"publicPage\", \"0\").equals(\"1\");\r\n            sb.setConfig(\"publicSearchpage\", publicPage);\r\n        }\r\n        \r\n        final boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        final boolean browserPopUpTrigger = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_TRIGGER, \"true\").equals(\"true\");\r\n        if (browserPopUpTrigger) {\r\n            final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n            if (browserPopUpPage.startsWith(\"index\") || browserPopUpPage.startsWith(\"yacysearch\")) display = 2;\r\n        }\r\n\r\n        final int searchoptions = (post == null) ? 0 : post.getInt(\"searchoptions\", 0);\r\n        final String former = (post == null) ? \"\" : post.get(\"former\", \"\");\r\n        final int count = Math.min(100, (post == null) ? 10 : post.getInt(\"count\", 10));\r\n        final int maximumRecords = Integer.parseInt((sb.getConfig(SwitchboardConstants.DEFAULT_SEARCHITEMS, \"10\")));\r\n        final String urlmaskfilter = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\");\r\n        final String prefermaskfilter = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        final String constraint = (post == null) ? \"\" : post.get(\"constraint\", \"\");\r\n        final String cat = (post == null) ? \"href\" : post.get(\"cat\", \"href\");\r\n        final int type = (post == null) ? 0 : post.getInt(\"type\", 0);\r\n        \r\n        final boolean indexDistributeGranted = sb.getConfigBool(SwitchboardConstants.INDEX_DIST_ALLOW, true);\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true);\r\n        //global = global && indexDistributeGranted && indexReceiveGranted;\r\n        \r\n        // search domain\r\n        ContentDomain contentdom = ContentDomain.TEXT;\r\n        final String cds = (post == null) ? \"text\" : post.get(\"contentdom\", \"text\");\r\n        if (cds.equals(\"text\")) contentdom = ContentDomain.TEXT;\r\n        if (cds.equals(\"audio\")) contentdom = ContentDomain.AUDIO;\r\n        if (cds.equals(\"video\")) contentdom = ContentDomain.VIDEO;\r\n        if (cds.equals(\"image\")) contentdom = ContentDomain.IMAGE;\r\n        if (cds.equals(\"app\")) contentdom = ContentDomain.APP;\r\n        \r\n        // we create empty entries for template strings\r\n        String promoteSearchPageGreeting = env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        if (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        prop.putHTML(SwitchboardConstants.GREETING, promoteSearchPageGreeting);\r\n        prop.put(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(SwitchboardConstants.GREETING_LARGE_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n        prop.putHTML(\"former\", former);\r\n        prop.put(\"num-results\", \"0\");\r\n        prop.put(\"excluded\", \"0\");\r\n        prop.put(\"combine\", \"0\");\r\n        prop.put(\"resultbottomline\", \"0\");\r\n        prop.put(\"searchoptions\", searchoptions);\r\n        prop.put(\"searchoptions_maximumRecords\", maximumRecords);\r\n        prop.put(\"searchoptions_count-10\", (count == 10) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-50\", (count == 50) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-100\", (count == 100) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global\", global ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global-disabled\", (indexReceiveGranted && indexDistributeGranted) ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_resource-global-disabled_reason\", (indexReceiveGranted) ? \"0\" : (indexDistributeGranted ? \"1\" : \"2\"));\r\n        prop.put(\"searchoptions_resource-local\", global ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_urlmaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_urlmaskoptions_urlmaskfilter\", urlmaskfilter);\r\n        prop.put(\"searchoptions_prefermaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_prefermaskoptions_prefermaskfilter\", prefermaskfilter);\r\n        prop.put(\"searchoptions_indexofChecked\", \"\");\r\n        prop.put(\"searchoptions_publicSearchpage\", (publicPage) ? \"0\" : \"1\");\r\n        prop.put(\"results\", \"\");\r\n        prop.putHTML(\"cat\", cat);\r\n        prop.put(\"type\", type);\r\n        prop.put(\"depth\", \"0\");\r\n        prop.put(\"display\", display);\r\n        prop.putHTML(\"constraint\", constraint);\r\n        prop.put(\"searchoptions_display\", display);\r\n        prop.put(\"searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n        // online caution timing\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        return prop;\r\n    }","id":76347,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        // access control\r\n        boolean publicPage = sb.getConfigBool(\"publicSearchpage\", true);\r\n        final boolean authorizedAccess = sb.verifyAuthentication(header, false);\r\n        if ((post != null) && (post.containsKey(\"publicPage\"))) {\r\n            if (!authorizedAccess) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            publicPage = post.get(\"publicPage\", \"0\").equals(\"1\");\r\n            sb.setConfig(\"publicSearchpage\", publicPage);\r\n        }\r\n        \r\n        final boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        final boolean browserPopUpTrigger = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_TRIGGER, \"true\").equals(\"true\");\r\n        if (browserPopUpTrigger) {\r\n            final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n            if (browserPopUpPage.startsWith(\"index\") || browserPopUpPage.startsWith(\"yacysearch\")) display = 2;\r\n        }\r\n\r\n        final int searchoptions = (post == null) ? 0 : post.getInt(\"searchoptions\", 0);\r\n        final String former = (post == null) ? \"\" : post.get(\"former\", \"\");\r\n        final int count = Math.min(100, (post == null) ? 10 : post.getInt(\"count\", 10));\r\n        final int maximumRecords = Integer.parseInt((sb.getConfig(SwitchboardConstants.DEFAULT_SEARCHITEMS, \"10\")));\r\n        final String urlmaskfilter = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\");\r\n        final String prefermaskfilter = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        final String constraint = (post == null) ? \"\" : post.get(\"constraint\", \"\");\r\n        final String cat = (post == null) ? \"href\" : post.get(\"cat\", \"href\");\r\n        final int type = (post == null) ? 0 : post.getInt(\"type\", 0);\r\n        \r\n        final boolean indexDistributeGranted = sb.getConfigBool(SwitchboardConstants.INDEX_DIST_ALLOW, true);\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true) ||\r\n        \t\t\t\t\t\t\t\t\tsb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true);\r\n        //global = global && indexDistributeGranted && indexReceiveGranted;\r\n        \r\n        // search domain\r\n        ContentDomain contentdom = ContentDomain.TEXT;\r\n        final String cds = (post == null) ? \"text\" : post.get(\"contentdom\", \"text\");\r\n        if (cds.equals(\"text\")) contentdom = ContentDomain.TEXT;\r\n        if (cds.equals(\"audio\")) contentdom = ContentDomain.AUDIO;\r\n        if (cds.equals(\"video\")) contentdom = ContentDomain.VIDEO;\r\n        if (cds.equals(\"image\")) contentdom = ContentDomain.IMAGE;\r\n        if (cds.equals(\"app\")) contentdom = ContentDomain.APP;\r\n        \r\n        // we create empty entries for template strings\r\n        String promoteSearchPageGreeting = env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        if (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        prop.putHTML(SwitchboardConstants.GREETING, promoteSearchPageGreeting);\r\n        prop.put(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(SwitchboardConstants.GREETING_LARGE_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_LARGE_IMAGE, \"\"));\r\n        prop.putHTML(\"former\", former);\r\n        prop.put(\"num-results\", \"0\");\r\n        prop.put(\"excluded\", \"0\");\r\n        prop.put(\"combine\", \"0\");\r\n        prop.put(\"resultbottomline\", \"0\");\r\n        prop.put(\"searchoptions\", searchoptions);\r\n        prop.put(\"searchoptions_maximumRecords\", maximumRecords);\r\n        prop.put(\"searchoptions_count-10\", (count == 10) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-50\", (count == 50) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-100\", (count == 100) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global\", global ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global-disabled\", (indexReceiveGranted && indexDistributeGranted) ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_resource-global-disabled_reason\", (indexReceiveGranted) ? \"0\" : (indexDistributeGranted ? \"1\" : \"2\"));\r\n        prop.put(\"searchoptions_resource-local\", global ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_urlmaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_urlmaskoptions_urlmaskfilter\", urlmaskfilter);\r\n        prop.put(\"searchoptions_prefermaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_prefermaskoptions_prefermaskfilter\", prefermaskfilter);\r\n        prop.put(\"searchoptions_indexofChecked\", \"\");\r\n        prop.put(\"searchoptions_publicSearchpage\", (publicPage) ? \"0\" : \"1\");\r\n        prop.put(\"results\", \"\");\r\n        prop.putHTML(\"cat\", cat);\r\n        prop.put(\"type\", type);\r\n        prop.put(\"depth\", \"0\");\r\n        prop.put(\"display\", display);\r\n        prop.putHTML(\"constraint\", constraint);\r\n        prop.put(\"searchoptions_display\", display);\r\n        prop.put(\"searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n        // online caution timing\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        return prop;\r\n    }","commit_id":"945e0ba5a5b1843cbe7d05a9536dd8dfe05620a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        final boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if (!authenticated) display = 2;\r\n        // display == 0: shop top menu\r\n        // display == 1: show top and left menu\r\n        // display == 2: do not show any menu\r\n        final boolean browserPopUpTrigger = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_TRIGGER, \"true\").equals(\"true\");\r\n        if (browserPopUpTrigger) {\r\n            final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n            if (browserPopUpPage.startsWith(\"index\") || browserPopUpPage.startsWith(\"yacysearch\")) display = 2;\r\n        }\r\n        String promoteSearchPageGreeting = env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        if (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n        \r\n        // get query\r\n        String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim(); // SRU compliance\r\n        String querystring = originalquerystring;\r\n        boolean fetchSnippets = (post != null && post.get(\"verify\", \"false\").equals(\"true\"));\r\n        final serverObjects prop = new serverObjects();\r\n\r\n        // get segment\r\n        Segment indexSegment = null;\r\n        if (post != null && post.containsKey(\"segment\")) {\r\n            String segmentName = post.get(\"segment\");\r\n            if (sb.indexSegments.segmentExist(segmentName)) {\r\n                indexSegment = sb.indexSegments.segment(segmentName);\r\n            }\r\n        } else {\r\n            // take default segment\r\n            indexSegment = sb.indexSegments.segment(Segments.Process.PUBLIC);\r\n        }\r\n        \r\n        //final boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        if (post == null || indexSegment == null || env == null || !searchAllowed) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"display\", display);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"count\", \"10\");\r\n            prop.put(\"offset\", \"0\");\r\n            prop.put(\"resource\", \"global\");\r\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\r\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\r\n            prop.put(\"tenant\", (post == null) ? \"\" : post.get(\"tenant\", \"\"));\r\n            prop.put(\"indexof\", \"off\");\r\n            prop.put(\"constraint\", \"\");\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n            prop.put(\"verify\", (post == null) ? \"true\" : post.get(\"verify\", \"true\"));\r\n            prop.put(\"contentdom\", \"text\");\r\n            prop.put(\"contentdomCheckText\", \"1\");\r\n            prop.put(\"contentdomCheckAudio\", \"0\");\r\n            prop.put(\"contentdomCheckVideo\", \"0\");\r\n            prop.put(\"contentdomCheckImage\", \"0\");\r\n            prop.put(\"contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            prop.put(\"num-results_totalcount\", 0);\r\n            prop.put(\"num-results_offset\", 0);\r\n            prop.put(\"num-results_itemsPerPage\", 10);\r\n            prop.put(\"geoinfo\", \"0\");\r\n            prop.put(\"rss_queryenc\", \"\");\r\n            prop.put(\"meanCount\", 5);\r\n            return prop;\r\n        }\r\n        \r\n        // check for JSONP\r\n        if (post.containsKey(\"callback\")) {\r\n        \tfinal String jsonp = post.get(\"callback\")+ \"([\";\r\n        \tprop.put(\"jsonp-start\", jsonp);\r\n        \tprop.put(\"jsonp-end\", \"])\");\r\n        } else {\r\n        \tprop.put(\"jsonp-start\", \"\");\r\n        \tprop.put(\"jsonp-end\", \"\");\r\n        }\r\n        \r\n        // collect search attributes\r\n        boolean newsearch = post.hasValue(\"query\") && post.hasValue(\"former\") && !post.get(\"query\",\"\").equalsIgnoreCase(post.get(\"former\",\"\")); //new search term\r\n        \r\n        int itemsPerPage = Math.min((authenticated) ? 1000 : 10, post.getInt(\"maximumRecords\", post.getInt(\"count\", 10))); // SRU syntax with old property as alternative\r\n        int offset = (newsearch) ? 0 : post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n        \r\n        boolean global = post.get(\"resource\", \"local\").equals(\"global\");\r\n        final boolean indexof = (post != null && post.get(\"indexof\",\"\").equals(\"on\")); \r\n        \r\n        String urlmask = null;\r\n        String originalUrlMask = null;\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) { // option search all\r\n            originalUrlMask = \".*\";\r\n        } else if (!newsearch && post.containsKey(\"urlmaskfilter\")) {\r\n            originalUrlMask = post.get(\"urlmaskfilter\", \".*\");\r\n        } else {\r\n            originalUrlMask = \".*\";\r\n        }\r\n\r\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        if (prefermask.length() > 0 && prefermask.indexOf(\".*\") < 0) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        Bitfield constraint = (post != null && post.containsKey(\"constraint\") && post.get(\"constraint\", \"\").length() > 0) ? new Bitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new Bitfield(4);\r\n            constraint.set(Condenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true);\r\n        global = global && indexReceiveGranted; // if the user does not want indexes from remote peers, it cannot be a global search\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        \r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        final ContentDomain contentdom = ContentDomain.contentdomParser((post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdom != ContentDomain.TEXT) && (itemsPerPage <= 32)) itemsPerPage = 64;\r\n        \r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) trackerHandles = new TreeSet<Long>();\r\n        boolean block = false;\r\n        if (Domains.matchesList(client, sb.networkBlacklist)) {\r\n        \tglobal = false;\r\n            fetchSnippets = false;\r\n            block = true;\r\n            Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: BLACKLISTED CLIENT FROM \" + client + \" gets no permission to search\");\r\n        } else if (Domains.matchesList(client, sb.networkWhitelist)) {\r\n        \tLog.logInfo(\"LOCAL_SEARCH\", \"ACCECC CONTROL: WHITELISTED CLIENT FROM \" + client + \" gets no search restrictions\");\r\n        } else if (global || fetchSnippets) {\r\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\r\n            synchronized (trackerHandles) {\r\n                int accInOneSecond = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 1000)).size();\r\n                int accInThreeSeconds = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\r\n                int accInOneMinute = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\r\n                int accInTenMinutes = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\r\n                if (accInTenMinutes > 600) {\r\n                    global = false;\r\n                    fetchSnippets = false;\r\n                    block = true;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: CLIENT FROM \" + client + \": \" + accInTenMinutes + \" searches in ten minutes, fully blocked (no results generated)\");\r\n                } else if (accInOneMinute > 200) {\r\n                    global = false;\r\n                    fetchSnippets = false;\r\n                    block = true;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: CLIENT FROM \" + client + \": \" + accInOneMinute + \" searches in one minute, fully blocked (no results generated)\");\r\n                } else if (accInThreeSeconds > 1) {\r\n                    global = false;\r\n                    fetchSnippets = false;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \" searches in three seconds, blocked global search and snippets\");\r\n                } else if (accInOneSecond > 2) {\r\n                    global = false;\r\n                    fetchSnippets = false;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: CLIENT FROM \" + client + \": \" + accInOneSecond + \" searches in one second, blocked global search and snippets\");\r\n                }\r\n            }\r\n        }\r\n        \r\n        if ((!block) && (post == null || post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n            \r\n            // check available memory and clean up if necessary\r\n            if (!MemoryControl.request(8000000L, false)) {\r\n                indexSegment.urlMetadata().clearCache();\r\n                SearchEventCache.cleanupEvents(true);\r\n            }\r\n            \r\n            final RankingProfile ranking = sb.getRanking();\r\n\r\n            if (querystring.indexOf(\"NEAR\") >= 0) {\r\n            \tquerystring = querystring.replace(\"NEAR\", \"\");\r\n            \tranking.coeff_worddistance = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"RECENT\") >= 0) {\r\n            \tquerystring = querystring.replace(\"RECENT\", \"\");\r\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\r\n            }\r\n            int lrp = querystring.indexOf(\"LANGUAGE:\");\r\n            String lr = \"\";\r\n            if (lrp >= 0) {\r\n                if (querystring.length() >= (lrp + 11))\r\n                \tlr = querystring.substring(lrp + 9, lrp + 11);\r\n                querystring = querystring.replace(\"LANGUAGE:\" + lr, \"\");\r\n                lr = lr.toLowerCase();\r\n            }\r\n            int inurl = querystring.indexOf(\"inurl:\");\r\n            if (inurl >= 0) {\r\n                int ftb = querystring.indexOf(' ', inurl);\r\n                if (ftb == -1) ftb = querystring.length();\r\n                String urlstr = querystring.substring(inurl + 6, ftb);\r\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\r\n                if(urlstr.length() > 0) urlmask = \".*\" + urlstr + \".*\";\r\n            }\r\n            int filetype = querystring.indexOf(\"filetype:\");\r\n            if (filetype >= 0) {\r\n                int ftb = querystring.indexOf(' ', filetype);\r\n                if (ftb == -1) ftb = querystring.length();\r\n                String ft = querystring.substring(filetype + 9, ftb);\r\n                querystring = querystring.replace(\"filetype:\" + ft, \"\");\r\n                while (ft.length() > 0 && ft.charAt(0) == '.') ft = ft.substring(1);\r\n                if(ft.length() > 0) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\\\\.\" + ft;\r\n                    } else {\r\n                        urlmask = urlmask + \".*\\\\.\" + ft;\r\n                    }\r\n                }\r\n            }\r\n            String tenant = null;\r\n            if (post.containsKey(\"tenant\")) {\r\n                tenant = post.get(\"tenant\");\r\n                if (tenant != null && tenant.length() == 0) tenant = null;\r\n                if (tenant != null) {\r\n                \tif (urlmask == null) urlmask = \".*\" + tenant + \".*\"; else urlmask = \".*\" + tenant + urlmask;\r\n                }\r\n            }\r\n            int site = querystring.indexOf(\"site:\");\r\n            String sitehash = null;\r\n            if (site >= 0) {\r\n                int ftb = querystring.indexOf(' ', site);\r\n                if (ftb == -1) ftb = querystring.length();\r\n                String domain = querystring.substring(site + 5, ftb);\r\n                querystring = querystring.replace(\"site:\" + domain, \"\");\r\n                while (domain.length() > 0 && domain.charAt(0) == '.') domain = domain.substring(1);\r\n                while (domain.endsWith(\".\")) domain = domain.substring(0, domain.length() - 1);\r\n                sitehash = DigestURI.domhash(domain);\r\n            }\r\n            int authori = querystring.indexOf(\"author:\");\r\n        \tString authorhash = null;\r\n            if (authori >= 0) {\r\n            \t// check if the author was given with single quotes or without\r\n            \tboolean quotes = false;\r\n            \tif (querystring.charAt(authori + 7) == (char) 39) {\r\n            \t\tquotes = true;\r\n            \t}\r\n            \tString author;\r\n            \tif (quotes) {\r\n            \t\tint ftb = querystring.indexOf((char) 39, authori + 8);\r\n                    if (ftb == -1) ftb = querystring.length() + 1;\r\n                    author = querystring.substring(authori + 8, ftb);\r\n                    querystring = querystring.replace(\"author:'\" + author + \"'\", \"\");\r\n            \t} else {\r\n            \t\tint ftb = querystring.indexOf(' ', authori);\r\n            \t\tif (ftb == -1) ftb = querystring.length();\r\n            \t\tauthor = querystring.substring(authori + 7, ftb);\r\n                    querystring = querystring.replace(\"author:\" + author, \"\");\r\n            \t}\r\n            \tauthorhash = new String(Word.word2hash(author));\r\n            }\r\n            int tld = querystring.indexOf(\"tld:\");\r\n            if (tld >= 0) {\r\n                int ftb = querystring.indexOf(' ', tld);\r\n                if (ftb == -1) ftb = querystring.length();\r\n                String domain = querystring.substring(tld + 4, ftb);\r\n                querystring = querystring.replace(\"tld:\" + domain, \"\");\r\n                while (domain.length() > 0 && domain.charAt(0) == '.') domain = domain.substring(1);\r\n                if (domain.indexOf('.') < 0) domain = \"\\\\.\" + domain; // is tld\r\n                if (domain.length() > 0) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \"[a-zA-Z]*://[^/]*\" + domain + \"/.*\";\r\n                    } else {\r\n                        urlmask = \"[a-zA-Z]*://[^/]*\" + domain + \"/.*\" + urlmask;\r\n                    }\r\n                }\r\n            }\r\n            if (urlmask == null || urlmask.length() == 0) urlmask = originalUrlMask; //if no urlmask was given\r\n           \r\n            // read the language from the language-restrict option 'lr'\r\n            // if no one is given, use the user agent or the system language as default\r\n            String language = (post == null) ? lr : post.get(\"lr\", lr);\r\n            if (language.startsWith(\"lang_\")) language = language.substring(5);\r\n            if (!ISO639.exists(language)) {\r\n                // find out language of the user by reading of the user-agent string\r\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\r\n                if (agent == null) agent = System.getProperty(\"user.language\");\r\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\r\n                if (language == null) language = \"en\";\r\n            }\r\n            \r\n            // navigation\r\n            String navigation = (post == null) ? \"\" : post.get(\"nav\", \"\");\r\n            \r\n            // the query\r\n            final TreeSet<String>[] query = QueryParams.cleanQuery(querystring.trim()); // converts also umlaute\r\n            \r\n            int maxDistance = (querystring.indexOf('\"') >= 0) ? maxDistance = query.length - 1 : Integer.MAX_VALUE;\r\n\r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = SetTools.joinConstructive(query[0], Switchboard.stopwords);\r\n            if (!filtered.isEmpty()) {\r\n                SetTools.excludeDestructive(query[0], Switchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post != null && post.containsKey(\"deleteref\")) try {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                \r\n                // delete the index entry locally\r\n                final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                indexSegment.termIndex().remove(Word.words2hashes(query[0]), delHash);\r\n\r\n                // make new news message with negative voting\r\n                final HashMap<String, String> map = new HashMap<String, String>();\r\n                map.put(\"urlhash\", delHash);\r\n                map.put(\"vote\", \"negative\");\r\n                map.put(\"refid\", \"\");\r\n                sb.peers.newsPool.publishMyNews(yacyNewsRecord.newRecord(sb.peers.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n            } catch (IOException e) {\r\n                Log.logException(e);\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post != null && post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                final URIMetadataRow urlentry = indexSegment.urlMetadata().load(recommendHash, null, 0);\r\n                if (urlentry != null) {\r\n                    final URIMetadataRow.Components metadata = urlentry.metadata();\r\n                    Document document;\r\n                    document = LoaderDispatcher.retrieveDocument(metadata.url(), true, 5000, true, false);\r\n                    if (document != null) {\r\n                        // create a news message\r\n                        final HashMap<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", metadata.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", metadata.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", document.dc_title().replace(',', ' '));\r\n                        map.put(\"author\", document.dc_creator());\r\n                        map.put(\"tags\", document.dc_subject(' '));\r\n                        sb.peers.newsPool.publishMyNews(yacyNewsRecord.newRecord(sb.peers.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                        document.close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            //final boolean yacyonline = ((sb.webIndex.seedDB != null) && (sb.webIndex.seedDB.mySeed() != null) && (sb.webIndex.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) /* && (yacyonline)*/ && (sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false));\r\n        \r\n            // do the search\r\n            final TreeSet<byte[]> queryHashes = Word.words2hashes(query[0]);\r\n            final QueryParams theQuery = new QueryParams(\r\n        \t\t\toriginalquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tWord.words2hashes(query[1]),\r\n        \t\t\tWord.words2hashes(query[2]),\r\n        \t\t\ttenant,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdom,\r\n                    language,\r\n                    navigation,\r\n                    fetchSnippets,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? QueryParams.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? QueryParams.SEARCHDOM_GLOBALDHT : QueryParams.SEARCHDOM_LOCAL),\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    sitehash,\r\n                    authorhash,\r\n                    DigestURI.TLD_any_zone_filter,\r\n                    client,\r\n                    authenticated,\r\n                    indexSegment,\r\n                    ranking);\r\n            EventTracker.update(\"SEARCH\", new ProfilingGraph.searchEvent(theQuery.id(true), SearchEvent.INITIALIZATION, 0, 0), false, 30000, ProfilingGraph.maxTime);\r\n            \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(10000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(Switchboard.blueList);\r\n            \r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + QueryParams.hashSet2hashString(theQuery.queryHashes) + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            RSSFeed.channels(RSSFeed.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            final long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (SearchEventCache.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            final SearchEvent theSearch = SearchEventCache.getEvent(theQuery, sb.peers, sb.crawlResults, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            try {Thread.sleep(100);} catch (InterruptedException e1) {} // wait a little time to get first results in the search\r\n            \r\n            // generate result object\r\n            //serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + (System.currentTimeMillis() - timestamp) + \" ms\");\r\n            //serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + (System.currentTimeMillis() - timestamp) + \" ms\");\r\n                \r\n            // calc some more cross-reference\r\n            //serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + (System.currentTimeMillis() - timestamp) + \" ms\");\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalIndexCount() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    (System.currentTimeMillis() - timestamp) + \" ms\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalIndexCount() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.result().getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.result().getSnippetComputationTime();\r\n            sb.localSearches.add(theQuery);\r\n                        \r\n            // check suggestions\r\n            int meanMax = 0;\r\n            if (post != null && post.containsKey(\"meanCount\")) {\r\n            \ttry {\r\n            \t    meanMax = Integer.parseInt(post.get(\"meanCount\"));            \t\r\n            \t} catch (NumberFormatException e) {}\r\n            }\r\n            prop.put(\"meanCount\", meanMax);\r\n            if (meanMax > 0) {\r\n                DidYouMean didYouMean = new DidYouMean(indexSegment.termIndex());\r\n            \tIterator<String> meanIt = didYouMean.getSuggestions(querystring, 300, 10).iterator();\r\n                int meanCount = 0;\r\n                String suggestion;\r\n                while(meanCount<meanMax && meanIt.hasNext()) {\r\n                \tsuggestion = meanIt.next();\r\n                \tprop.put(\"didYouMean_suggestions_\"+meanCount+\"_word\", suggestion);\r\n                \tprop.put(\"didYouMean_suggestions_\"+meanCount+\"_url\",\r\n                \t\t\"/yacysearch.html\" + \"?display=\" + display +\r\n    \t                \"&search=\" + suggestion +\r\n    \t                \"&maximumRecords=\"+ theQuery.displayResults() +\r\n    \t                \"&startRecord=\" + (0 * theQuery.displayResults()) +\r\n    \t                \"&resource=\" + ((theQuery.isLocal()) ? \"local\" : \"global\") +\r\n    \t                \"&verify=\" + ((theQuery.onlineSnippetFetch) ? \"true\" : \"false\") +\r\n    \t                \"&nav=\" + theQuery.navigators +\r\n    \t                \"&urlmaskfilter=\" + originalUrlMask +\r\n    \t                \"&prefermaskfilter=\" + theQuery.prefer +\r\n    \t                \"&cat=href&amp;constraint=\" + ((theQuery.constraint == null) ? \"\" : theQuery.constraint.exportB64()) +\r\n    \t                \"&contentdom=\" + theQuery.contentdom() +\r\n    \t                \"&former=\" + theQuery.queryString(true) +\r\n    \t                \"&meanCount=\" + meanMax\r\n    \t             );\r\n                \tprop.put(\"didYouMean_suggestions_\"+meanCount+\"_sep\",\"|\");\r\n                \tmeanCount++;\r\n                }\r\n                prop.put(\"didYouMean_suggestions_\"+(meanCount-1)+\"_sep\",\"\");\r\n                prop.put(\"didYouMean\", meanCount>0 ? 1:0);\r\n                prop.put(\"didYouMean_suggestions\", meanCount);\r\n            } else {\r\n                prop.put(\"didYouMean\", 0);\r\n            }\r\n            \r\n            // find geographic info\r\n            Set<Location> coordinates = LibraryProvider.geoDB.find(originalquerystring);\r\n            if (coordinates == null || coordinates.isEmpty() || offset > 0) {\r\n                prop.put(\"geoinfo\", \"0\");\r\n            } else {\r\n                int i = 0;\r\n                for (Location c: coordinates) {\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0) / 10000.0);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0) / 10000.0);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\r\n                    i++;\r\n                    if (i >= 5) break;\r\n                }\r\n                prop.put(\"geoinfo_loc\", i);\r\n                prop.put(\"geoinfo\", \"1\");\r\n            }\r\n            \r\n            // update the search tracker\r\n            try {\r\n                synchronized (trackerHandles) {\r\n                \ttrackerHandles.add(theQuery.handle);\r\n                \tif (trackerHandles.size() > 1000) trackerHandles.remove(trackerHandles.first());\r\n                \tsb.localSearchTracker.put(client, trackerHandles);\r\n                }\r\n            \tif (sb.localSearchTracker.size() > 1000) sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\r\n            } catch (Exception e) {\r\n                Log.logException(e);\r\n            }\r\n            \r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", Formatter.number(0, true));\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", Formatter.number(theSearch.getRankingResult().getLocalIndexCount() + theSearch.getRankingResult().getRemoteResourceSize(), true));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.getRankingResult().getLocalIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.getRankingResult().getRemoteResourceSize(), true));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.getRankingResult().getRemoteIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.getRankingResult().getRemotePeerCount(), true));\r\n            \r\n            // compose page navigation\r\n            final StringBuilder resnav = new StringBuilder();\r\n            final int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdl.gif\\\" width=\\\"16\\\" height=\\\"16\\\">&nbsp;\");\r\n            } else {\r\n            \tresnav.append(\"<a href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage - 1, display, theQuery, originalUrlMask, null, navigation));\r\n            \tresnav.append(\"\\\"><img src=\\\"env/grafics/navdl.gif\\\" width=\\\"16\\\" height=\\\"16\\\"><\/a>&nbsp;\");\r\n            }\r\n            final int numberofpages = Math.min(10, Math.max(1 + thispage, 1 + ((theSearch.getRankingResult().getLocalIndexCount() < 11) ? Math.max(30, theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) : theSearch.getRankingResult().getLocalIndexCount()) / theQuery.displayResults()));\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<img src=\\\"env/grafics/navs\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" width=\\\"16\\\" height=\\\"16\\\">&nbsp;\");\r\n                } else {\r\n                    resnav.append(\"<a href=\\\"\");\r\n                    resnav.append(QueryParams.navurl(\"html\", i, display, theQuery, originalUrlMask, null, navigation));\r\n                    resnav.append(\"\\\"><img src=\\\"env/grafics/navd\");\r\n                \tresnav.append(i + 1);\r\n                \tresnav.append(\".gif\\\" width=\\\"16\\\" height=\\\"16\\\"><\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdr.gif\\\" width=\\\"16\\\" height=\\\"16\\\">\");\r\n            } else {\r\n                resnav.append(\"<a href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage + 1, display, theQuery, originalUrlMask, null, navigation));\r\n                resnav.append(\"\\\"><img src=\\\"env/grafics/navdr.gif\\\" width=\\\"16\\\" height=\\\"16\\\"><\/a>\");\r\n            }\r\n            String resnavs = resnav.toString();\r\n            prop.put(\"num-results_resnav\", resnavs);\r\n            prop.put(\"pageNavBottom\", (theSearch.getRankingResult().getLocalIndexCount() - offset > 6) ? 1 : 0); // if there are more results than may fit on the page we add a navigation at the bottom\r\n            prop.put(\"pageNavBottom_resnav\", resnavs);\r\n        \r\n            // generate the search result lines; the content will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n                prop.put(\"results_\" + i + \"_display\", display);\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (!filtered.isEmpty()) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.isEmpty()) {\r\n                if (post == null || post.get(\"query\", post.get(\"search\", \"\")).length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(':') == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"display\", display);\r\n        prop.put(\"display\", display);\r\n        prop.putHTML(\"former\", originalquerystring);\r\n        prop.put(\"count\", itemsPerPage);\r\n        prop.put(\"offset\", offset);\r\n        prop.put(\"resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"urlmaskfilter\", originalUrlMask);\r\n        prop.putHTML(\"prefermaskfilter\", prefermask);\r\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"verify\", (fetchSnippets) ? \"true\" : \"false\");\r\n        prop.put(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\r\n        prop.put(\"searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putXML(\"rss_query\", originalquerystring);\r\n        prop.put(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\r\n                \r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":76348,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        final boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if (!authenticated) display = 2;\r\n        // display == 0: shop top menu\r\n        // display == 1: show top and left menu\r\n        // display == 2: do not show any menu\r\n        final boolean browserPopUpTrigger = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_TRIGGER, \"true\").equals(\"true\");\r\n        if (browserPopUpTrigger) {\r\n            final String  browserPopUpPage = sb.getConfig(SwitchboardConstants.BROWSER_POP_UP_PAGE, \"ConfigBasic.html\");\r\n            if (browserPopUpPage.startsWith(\"index\") || browserPopUpPage.startsWith(\"yacysearch\")) display = 2;\r\n        }\r\n        String promoteSearchPageGreeting = env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        if (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n        \r\n        // get query\r\n        String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim(); // SRU compliance\r\n        String querystring = originalquerystring;\r\n        boolean fetchSnippets = (post != null && post.get(\"verify\", \"false\").equals(\"true\"));\r\n        final serverObjects prop = new serverObjects();\r\n\r\n        // get segment\r\n        Segment indexSegment = null;\r\n        if (post != null && post.containsKey(\"segment\")) {\r\n            String segmentName = post.get(\"segment\");\r\n            if (sb.indexSegments.segmentExist(segmentName)) {\r\n                indexSegment = sb.indexSegments.segment(segmentName);\r\n            }\r\n        } else {\r\n            // take default segment\r\n            indexSegment = sb.indexSegments.segment(Segments.Process.PUBLIC);\r\n        }\r\n        \r\n        //final boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        if (post == null || indexSegment == null || env == null || !searchAllowed) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"display\", display);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"count\", \"10\");\r\n            prop.put(\"offset\", \"0\");\r\n            prop.put(\"resource\", \"global\");\r\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\r\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\r\n            prop.put(\"tenant\", (post == null) ? \"\" : post.get(\"tenant\", \"\"));\r\n            prop.put(\"indexof\", \"off\");\r\n            prop.put(\"constraint\", \"\");\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n            prop.put(\"verify\", (post == null) ? \"true\" : post.get(\"verify\", \"true\"));\r\n            prop.put(\"contentdom\", \"text\");\r\n            prop.put(\"contentdomCheckText\", \"1\");\r\n            prop.put(\"contentdomCheckAudio\", \"0\");\r\n            prop.put(\"contentdomCheckVideo\", \"0\");\r\n            prop.put(\"contentdomCheckImage\", \"0\");\r\n            prop.put(\"contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            prop.put(\"num-results_totalcount\", 0);\r\n            prop.put(\"num-results_offset\", 0);\r\n            prop.put(\"num-results_itemsPerPage\", 10);\r\n            prop.put(\"geoinfo\", \"0\");\r\n            prop.put(\"rss_queryenc\", \"\");\r\n            prop.put(\"meanCount\", 5);\r\n            return prop;\r\n        }\r\n        \r\n        // check for JSONP\r\n        if (post.containsKey(\"callback\")) {\r\n        \tfinal String jsonp = post.get(\"callback\")+ \"([\";\r\n        \tprop.put(\"jsonp-start\", jsonp);\r\n        \tprop.put(\"jsonp-end\", \"])\");\r\n        } else {\r\n        \tprop.put(\"jsonp-start\", \"\");\r\n        \tprop.put(\"jsonp-end\", \"\");\r\n        }\r\n        \r\n        // collect search attributes\r\n        boolean newsearch = post.hasValue(\"query\") && post.hasValue(\"former\") && !post.get(\"query\",\"\").equalsIgnoreCase(post.get(\"former\",\"\")); //new search term\r\n        \r\n        int itemsPerPage = Math.min((authenticated) ? 1000 : 10, post.getInt(\"maximumRecords\", post.getInt(\"count\", 10))); // SRU syntax with old property as alternative\r\n        int offset = (newsearch) ? 0 : post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n        \r\n        boolean global = post.get(\"resource\", \"local\").equals(\"global\");\r\n        final boolean indexof = (post != null && post.get(\"indexof\",\"\").equals(\"on\")); \r\n        \r\n        String urlmask = null;\r\n        String originalUrlMask = null;\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) { // option search all\r\n            originalUrlMask = \".*\";\r\n        } else if (!newsearch && post.containsKey(\"urlmaskfilter\")) {\r\n            originalUrlMask = post.get(\"urlmaskfilter\", \".*\");\r\n        } else {\r\n            originalUrlMask = \".*\";\r\n        }\r\n\r\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        if (prefermask.length() > 0 && prefermask.indexOf(\".*\") < 0) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        Bitfield constraint = (post != null && post.containsKey(\"constraint\") && post.get(\"constraint\", \"\").length() > 0) ? new Bitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new Bitfield(4);\r\n            constraint.set(Condenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true) ||\r\n        \t\t\t\t\t\t\t\t\tsb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true);\r\n        global = global && indexReceiveGranted; // if the user does not want indexes from remote peers, it cannot be a global search\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        \r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        final ContentDomain contentdom = ContentDomain.contentdomParser((post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdom != ContentDomain.TEXT) && (itemsPerPage <= 32)) itemsPerPage = 64;\r\n        \r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) trackerHandles = new TreeSet<Long>();\r\n        boolean block = false;\r\n        if (Domains.matchesList(client, sb.networkBlacklist)) {\r\n        \tglobal = false;\r\n            fetchSnippets = false;\r\n            block = true;\r\n            Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: BLACKLISTED CLIENT FROM \" + client + \" gets no permission to search\");\r\n        } else if (Domains.matchesList(client, sb.networkWhitelist)) {\r\n        \tLog.logInfo(\"LOCAL_SEARCH\", \"ACCECC CONTROL: WHITELISTED CLIENT FROM \" + client + \" gets no search restrictions\");\r\n        } else if (global || fetchSnippets) {\r\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\r\n            synchronized (trackerHandles) {\r\n                int accInOneSecond = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 1000)).size();\r\n                int accInThreeSeconds = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\r\n                int accInOneMinute = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\r\n                int accInTenMinutes = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\r\n                if (accInTenMinutes > 600) {\r\n                    global = false;\r\n                    fetchSnippets = false;\r\n                    block = true;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: CLIENT FROM \" + client + \": \" + accInTenMinutes + \" searches in ten minutes, fully blocked (no results generated)\");\r\n                } else if (accInOneMinute > 200) {\r\n                    global = false;\r\n                    fetchSnippets = false;\r\n                    block = true;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: CLIENT FROM \" + client + \": \" + accInOneMinute + \" searches in one minute, fully blocked (no results generated)\");\r\n                } else if (accInThreeSeconds > 1) {\r\n                    global = false;\r\n                    fetchSnippets = false;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \" searches in three seconds, blocked global search and snippets\");\r\n                } else if (accInOneSecond > 2) {\r\n                    global = false;\r\n                    fetchSnippets = false;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCECC CONTROL: CLIENT FROM \" + client + \": \" + accInOneSecond + \" searches in one second, blocked global search and snippets\");\r\n                }\r\n            }\r\n        }\r\n        \r\n        if ((!block) && (post == null || post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n            \r\n            // check available memory and clean up if necessary\r\n            if (!MemoryControl.request(8000000L, false)) {\r\n                indexSegment.urlMetadata().clearCache();\r\n                SearchEventCache.cleanupEvents(true);\r\n            }\r\n            \r\n            final RankingProfile ranking = sb.getRanking();\r\n\r\n            if (querystring.indexOf(\"NEAR\") >= 0) {\r\n            \tquerystring = querystring.replace(\"NEAR\", \"\");\r\n            \tranking.coeff_worddistance = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"RECENT\") >= 0) {\r\n            \tquerystring = querystring.replace(\"RECENT\", \"\");\r\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\r\n            }\r\n            int lrp = querystring.indexOf(\"LANGUAGE:\");\r\n            String lr = \"\";\r\n            if (lrp >= 0) {\r\n                if (querystring.length() >= (lrp + 11))\r\n                \tlr = querystring.substring(lrp + 9, lrp + 11);\r\n                querystring = querystring.replace(\"LANGUAGE:\" + lr, \"\");\r\n                lr = lr.toLowerCase();\r\n            }\r\n            int inurl = querystring.indexOf(\"inurl:\");\r\n            if (inurl >= 0) {\r\n                int ftb = querystring.indexOf(' ', inurl);\r\n                if (ftb == -1) ftb = querystring.length();\r\n                String urlstr = querystring.substring(inurl + 6, ftb);\r\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\r\n                if(urlstr.length() > 0) urlmask = \".*\" + urlstr + \".*\";\r\n            }\r\n            int filetype = querystring.indexOf(\"filetype:\");\r\n            if (filetype >= 0) {\r\n                int ftb = querystring.indexOf(' ', filetype);\r\n                if (ftb == -1) ftb = querystring.length();\r\n                String ft = querystring.substring(filetype + 9, ftb);\r\n                querystring = querystring.replace(\"filetype:\" + ft, \"\");\r\n                while (ft.length() > 0 && ft.charAt(0) == '.') ft = ft.substring(1);\r\n                if(ft.length() > 0) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\\\\.\" + ft;\r\n                    } else {\r\n                        urlmask = urlmask + \".*\\\\.\" + ft;\r\n                    }\r\n                }\r\n            }\r\n            String tenant = null;\r\n            if (post.containsKey(\"tenant\")) {\r\n                tenant = post.get(\"tenant\");\r\n                if (tenant != null && tenant.length() == 0) tenant = null;\r\n                if (tenant != null) {\r\n                \tif (urlmask == null) urlmask = \".*\" + tenant + \".*\"; else urlmask = \".*\" + tenant + urlmask;\r\n                }\r\n            }\r\n            int site = querystring.indexOf(\"site:\");\r\n            String sitehash = null;\r\n            if (site >= 0) {\r\n                int ftb = querystring.indexOf(' ', site);\r\n                if (ftb == -1) ftb = querystring.length();\r\n                String domain = querystring.substring(site + 5, ftb);\r\n                querystring = querystring.replace(\"site:\" + domain, \"\");\r\n                while (domain.length() > 0 && domain.charAt(0) == '.') domain = domain.substring(1);\r\n                while (domain.endsWith(\".\")) domain = domain.substring(0, domain.length() - 1);\r\n                sitehash = DigestURI.domhash(domain);\r\n            }\r\n            int authori = querystring.indexOf(\"author:\");\r\n        \tString authorhash = null;\r\n            if (authori >= 0) {\r\n            \t// check if the author was given with single quotes or without\r\n            \tboolean quotes = false;\r\n            \tif (querystring.charAt(authori + 7) == (char) 39) {\r\n            \t\tquotes = true;\r\n            \t}\r\n            \tString author;\r\n            \tif (quotes) {\r\n            \t\tint ftb = querystring.indexOf((char) 39, authori + 8);\r\n                    if (ftb == -1) ftb = querystring.length() + 1;\r\n                    author = querystring.substring(authori + 8, ftb);\r\n                    querystring = querystring.replace(\"author:'\" + author + \"'\", \"\");\r\n            \t} else {\r\n            \t\tint ftb = querystring.indexOf(' ', authori);\r\n            \t\tif (ftb == -1) ftb = querystring.length();\r\n            \t\tauthor = querystring.substring(authori + 7, ftb);\r\n                    querystring = querystring.replace(\"author:\" + author, \"\");\r\n            \t}\r\n            \tauthorhash = new String(Word.word2hash(author));\r\n            }\r\n            int tld = querystring.indexOf(\"tld:\");\r\n            if (tld >= 0) {\r\n                int ftb = querystring.indexOf(' ', tld);\r\n                if (ftb == -1) ftb = querystring.length();\r\n                String domain = querystring.substring(tld + 4, ftb);\r\n                querystring = querystring.replace(\"tld:\" + domain, \"\");\r\n                while (domain.length() > 0 && domain.charAt(0) == '.') domain = domain.substring(1);\r\n                if (domain.indexOf('.') < 0) domain = \"\\\\.\" + domain; // is tld\r\n                if (domain.length() > 0) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \"[a-zA-Z]*://[^/]*\" + domain + \"/.*\";\r\n                    } else {\r\n                        urlmask = \"[a-zA-Z]*://[^/]*\" + domain + \"/.*\" + urlmask;\r\n                    }\r\n                }\r\n            }\r\n            if (urlmask == null || urlmask.length() == 0) urlmask = originalUrlMask; //if no urlmask was given\r\n           \r\n            // read the language from the language-restrict option 'lr'\r\n            // if no one is given, use the user agent or the system language as default\r\n            String language = (post == null) ? lr : post.get(\"lr\", lr);\r\n            if (language.startsWith(\"lang_\")) language = language.substring(5);\r\n            if (!ISO639.exists(language)) {\r\n                // find out language of the user by reading of the user-agent string\r\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\r\n                if (agent == null) agent = System.getProperty(\"user.language\");\r\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\r\n                if (language == null) language = \"en\";\r\n            }\r\n            \r\n            // navigation\r\n            String navigation = (post == null) ? \"\" : post.get(\"nav\", \"\");\r\n            \r\n            // the query\r\n            final TreeSet<String>[] query = QueryParams.cleanQuery(querystring.trim()); // converts also umlaute\r\n            \r\n            int maxDistance = (querystring.indexOf('\"') >= 0) ? maxDistance = query.length - 1 : Integer.MAX_VALUE;\r\n\r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = SetTools.joinConstructive(query[0], Switchboard.stopwords);\r\n            if (!filtered.isEmpty()) {\r\n                SetTools.excludeDestructive(query[0], Switchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post != null && post.containsKey(\"deleteref\")) try {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                \r\n                // delete the index entry locally\r\n                final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                indexSegment.termIndex().remove(Word.words2hashes(query[0]), delHash);\r\n\r\n                // make new news message with negative voting\r\n                final HashMap<String, String> map = new HashMap<String, String>();\r\n                map.put(\"urlhash\", delHash);\r\n                map.put(\"vote\", \"negative\");\r\n                map.put(\"refid\", \"\");\r\n                sb.peers.newsPool.publishMyNews(yacyNewsRecord.newRecord(sb.peers.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n            } catch (IOException e) {\r\n                Log.logException(e);\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post != null && post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                final URIMetadataRow urlentry = indexSegment.urlMetadata().load(recommendHash, null, 0);\r\n                if (urlentry != null) {\r\n                    final URIMetadataRow.Components metadata = urlentry.metadata();\r\n                    Document document;\r\n                    document = LoaderDispatcher.retrieveDocument(metadata.url(), true, 5000, true, false);\r\n                    if (document != null) {\r\n                        // create a news message\r\n                        final HashMap<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", metadata.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", metadata.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", document.dc_title().replace(',', ' '));\r\n                        map.put(\"author\", document.dc_creator());\r\n                        map.put(\"tags\", document.dc_subject(' '));\r\n                        sb.peers.newsPool.publishMyNews(yacyNewsRecord.newRecord(sb.peers.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                        document.close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            //final boolean yacyonline = ((sb.webIndex.seedDB != null) && (sb.webIndex.seedDB.mySeed() != null) && (sb.webIndex.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && indexReceiveGranted; /* && (yacyonline)*/ \r\n        \r\n            // do the search\r\n            final TreeSet<byte[]> queryHashes = Word.words2hashes(query[0]);\r\n            final QueryParams theQuery = new QueryParams(\r\n        \t\t\toriginalquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tWord.words2hashes(query[1]),\r\n        \t\t\tWord.words2hashes(query[2]),\r\n        \t\t\ttenant,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdom,\r\n                    language,\r\n                    navigation,\r\n                    fetchSnippets,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? QueryParams.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? QueryParams.SEARCHDOM_GLOBALDHT : QueryParams.SEARCHDOM_LOCAL),\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    sitehash,\r\n                    authorhash,\r\n                    DigestURI.TLD_any_zone_filter,\r\n                    client,\r\n                    authenticated,\r\n                    indexSegment,\r\n                    ranking);\r\n            EventTracker.update(\"SEARCH\", new ProfilingGraph.searchEvent(theQuery.id(true), SearchEvent.INITIALIZATION, 0, 0), false, 30000, ProfilingGraph.maxTime);\r\n            \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(10000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(Switchboard.blueList);\r\n            \r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + QueryParams.hashSet2hashString(theQuery.queryHashes) + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            RSSFeed.channels(RSSFeed.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            final long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (SearchEventCache.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            final SearchEvent theSearch = SearchEventCache.getEvent(theQuery, sb.peers, sb.crawlResults, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            try {Thread.sleep(100);} catch (InterruptedException e1) {} // wait a little time to get first results in the search\r\n            \r\n            // generate result object\r\n            //serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + (System.currentTimeMillis() - timestamp) + \" ms\");\r\n            //serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + (System.currentTimeMillis() - timestamp) + \" ms\");\r\n                \r\n            // calc some more cross-reference\r\n            //serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + (System.currentTimeMillis() - timestamp) + \" ms\");\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalIndexCount() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    (System.currentTimeMillis() - timestamp) + \" ms\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalIndexCount() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.result().getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.result().getSnippetComputationTime();\r\n            sb.localSearches.add(theQuery);\r\n                        \r\n            // check suggestions\r\n            int meanMax = 0;\r\n            if (post != null && post.containsKey(\"meanCount\")) {\r\n            \ttry {\r\n            \t    meanMax = Integer.parseInt(post.get(\"meanCount\"));            \t\r\n            \t} catch (NumberFormatException e) {}\r\n            }\r\n            prop.put(\"meanCount\", meanMax);\r\n            if (meanMax > 0) {\r\n                DidYouMean didYouMean = new DidYouMean(indexSegment.termIndex());\r\n            \tIterator<String> meanIt = didYouMean.getSuggestions(querystring, 300, 10).iterator();\r\n                int meanCount = 0;\r\n                String suggestion;\r\n                while(meanCount<meanMax && meanIt.hasNext()) {\r\n                \tsuggestion = meanIt.next();\r\n                \tprop.put(\"didYouMean_suggestions_\"+meanCount+\"_word\", suggestion);\r\n                \tprop.put(\"didYouMean_suggestions_\"+meanCount+\"_url\",\r\n                \t\t\"/yacysearch.html\" + \"?display=\" + display +\r\n    \t                \"&search=\" + suggestion +\r\n    \t                \"&maximumRecords=\"+ theQuery.displayResults() +\r\n    \t                \"&startRecord=\" + (0 * theQuery.displayResults()) +\r\n    \t                \"&resource=\" + ((theQuery.isLocal()) ? \"local\" : \"global\") +\r\n    \t                \"&verify=\" + ((theQuery.onlineSnippetFetch) ? \"true\" : \"false\") +\r\n    \t                \"&nav=\" + theQuery.navigators +\r\n    \t                \"&urlmaskfilter=\" + originalUrlMask +\r\n    \t                \"&prefermaskfilter=\" + theQuery.prefer +\r\n    \t                \"&cat=href&amp;constraint=\" + ((theQuery.constraint == null) ? \"\" : theQuery.constraint.exportB64()) +\r\n    \t                \"&contentdom=\" + theQuery.contentdom() +\r\n    \t                \"&former=\" + theQuery.queryString(true) +\r\n    \t                \"&meanCount=\" + meanMax\r\n    \t             );\r\n                \tprop.put(\"didYouMean_suggestions_\"+meanCount+\"_sep\",\"|\");\r\n                \tmeanCount++;\r\n                }\r\n                prop.put(\"didYouMean_suggestions_\"+(meanCount-1)+\"_sep\",\"\");\r\n                prop.put(\"didYouMean\", meanCount>0 ? 1:0);\r\n                prop.put(\"didYouMean_suggestions\", meanCount);\r\n            } else {\r\n                prop.put(\"didYouMean\", 0);\r\n            }\r\n            \r\n            // find geographic info\r\n            Set<Location> coordinates = LibraryProvider.geoDB.find(originalquerystring);\r\n            if (coordinates == null || coordinates.isEmpty() || offset > 0) {\r\n                prop.put(\"geoinfo\", \"0\");\r\n            } else {\r\n                int i = 0;\r\n                for (Location c: coordinates) {\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0) / 10000.0);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0) / 10000.0);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\r\n                    i++;\r\n                    if (i >= 5) break;\r\n                }\r\n                prop.put(\"geoinfo_loc\", i);\r\n                prop.put(\"geoinfo\", \"1\");\r\n            }\r\n            \r\n            // update the search tracker\r\n            try {\r\n                synchronized (trackerHandles) {\r\n                \ttrackerHandles.add(theQuery.handle);\r\n                \tif (trackerHandles.size() > 1000) trackerHandles.remove(trackerHandles.first());\r\n                \tsb.localSearchTracker.put(client, trackerHandles);\r\n                }\r\n            \tif (sb.localSearchTracker.size() > 1000) sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\r\n            } catch (Exception e) {\r\n                Log.logException(e);\r\n            }\r\n            \r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", Formatter.number(0, true));\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", Formatter.number(theSearch.getRankingResult().getLocalIndexCount() + theSearch.getRankingResult().getRemoteResourceSize(), true));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.getRankingResult().getLocalIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.getRankingResult().getRemoteResourceSize(), true));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.getRankingResult().getRemoteIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.getRankingResult().getRemotePeerCount(), true));\r\n            \r\n            // compose page navigation\r\n            final StringBuilder resnav = new StringBuilder();\r\n            final int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdl.gif\\\" width=\\\"16\\\" height=\\\"16\\\">&nbsp;\");\r\n            } else {\r\n            \tresnav.append(\"<a href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage - 1, display, theQuery, originalUrlMask, null, navigation));\r\n            \tresnav.append(\"\\\"><img src=\\\"env/grafics/navdl.gif\\\" width=\\\"16\\\" height=\\\"16\\\"><\/a>&nbsp;\");\r\n            }\r\n            final int numberofpages = Math.min(10, Math.max(1 + thispage, 1 + ((theSearch.getRankingResult().getLocalIndexCount() < 11) ? Math.max(30, theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) : theSearch.getRankingResult().getLocalIndexCount()) / theQuery.displayResults()));\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<img src=\\\"env/grafics/navs\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" width=\\\"16\\\" height=\\\"16\\\">&nbsp;\");\r\n                } else {\r\n                    resnav.append(\"<a href=\\\"\");\r\n                    resnav.append(QueryParams.navurl(\"html\", i, display, theQuery, originalUrlMask, null, navigation));\r\n                    resnav.append(\"\\\"><img src=\\\"env/grafics/navd\");\r\n                \tresnav.append(i + 1);\r\n                \tresnav.append(\".gif\\\" width=\\\"16\\\" height=\\\"16\\\"><\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdr.gif\\\" width=\\\"16\\\" height=\\\"16\\\">\");\r\n            } else {\r\n                resnav.append(\"<a href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage + 1, display, theQuery, originalUrlMask, null, navigation));\r\n                resnav.append(\"\\\"><img src=\\\"env/grafics/navdr.gif\\\" width=\\\"16\\\" height=\\\"16\\\"><\/a>\");\r\n            }\r\n            String resnavs = resnav.toString();\r\n            prop.put(\"num-results_resnav\", resnavs);\r\n            prop.put(\"pageNavBottom\", (theSearch.getRankingResult().getLocalIndexCount() - offset > 6) ? 1 : 0); // if there are more results than may fit on the page we add a navigation at the bottom\r\n            prop.put(\"pageNavBottom_resnav\", resnavs);\r\n        \r\n            // generate the search result lines; the content will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n                prop.put(\"results_\" + i + \"_display\", display);\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (!filtered.isEmpty()) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.isEmpty()) {\r\n                if (post == null || post.get(\"query\", post.get(\"search\", \"\")).length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(':') == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"display\", display);\r\n        prop.put(\"display\", display);\r\n        prop.putHTML(\"former\", originalquerystring);\r\n        prop.put(\"count\", itemsPerPage);\r\n        prop.put(\"offset\", offset);\r\n        prop.put(\"resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"urlmaskfilter\", originalUrlMask);\r\n        prop.putHTML(\"prefermaskfilter\", prefermask);\r\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"verify\", (fetchSnippets) ? \"true\" : \"false\");\r\n        prop.put(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\r\n        prop.put(\"searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putXML(\"rss_query\", originalquerystring);\r\n        prop.put(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\r\n                \r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"945e0ba5a5b1843cbe7d05a9536dd8dfe05620a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void writeopensearchcfg(final Switchboard sb, final serverObjects post) {\n        // read index schema table flags\n\n        final File f = new File(sb.getDataPath(), \"DATA/SETTINGS/heuristicopensearch.conf\");\n        try {\n            Configuration cfg = new Configuration(f);\n            final Iterator<Configuration.Entry> cfgentries = cfg.entryIterator();\n            Configuration.Entry entry;\n            boolean modified = false; // flag to remember changes\n            while (cfgentries.hasNext()) {\n                entry = cfgentries.next();\n                final String sfn = post.get(\"ossys_url_\" + entry.key());\n                if (sfn != null) {\n                    if (!sfn.equals(entry.getValue())) {\n                        entry.setValue(sfn);\n                        modified = true;\n    }\n                }\n                // set enable flag\n                String v = post.get(\"ossys_\" + entry.key());\n                boolean c = v != null && v.equals(\"checked\");\n                if (entry.enabled() != c) {\n                    entry.setEnable(c);\n                    modified = true;\n                }\n                // delete entry from config\n                v = post.get(\"ossys_del_\" + entry.key());\n                c = v != null && v.equals(\"checked\");\n                if (c) {\n                    cfgentries.remove();\n                    modified = true;\n                }\n            }\n            if (modified) { // save settings to config file if modified\n                try {\n                    cfg.commit();\n                } catch (IOException ex) {\n                }\n            }\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n        \n        // re-read config (and create/update work table)\n        if (sb.getConfigBool(\"heuristic.opensearch\", true)) {\n            OpenSearchConnector os = new OpenSearchConnector(sb, true);\n        }\n    }","id":76349,"modified_method":"private static void writeopensearchcfg(final Switchboard sb, final serverObjects post) {\n        // read index schema table flags\n\n        final File f = new File(sb.getDataPath(), \"DATA/SETTINGS/heuristicopensearch.conf\");\n        try {\n            Configuration cfg = new Configuration(f);\n            final Iterator<Configuration.Entry> cfgentries = cfg.entryIterator();\n            Configuration.Entry entry;\n            boolean modified = false; // flag to remember changes\n            while (cfgentries.hasNext()) {\n                entry = cfgentries.next();\n                final String sfn = post.get(\"ossys_url_\" + entry.key());\n                if (sfn != null) {\n                    if (!sfn.equals(entry.getValue())) {\n                        entry.setValue(sfn);\n                        modified = true;\n    }\n                }\n                // set enable flag\n                String v = post.get(\"ossys_\" + entry.key());\n                boolean c = v != null && v.equals(\"checked\");\n                if (entry.enabled() != c) {\n                    entry.setEnable(c);\n                    modified = true;\n                }\n                // delete entry from config\n                v = post.get(\"ossys_del_\" + entry.key());\n                c = v != null && v.equals(\"checked\");\n                if (c) {\n                    cfgentries.remove();\n                    modified = true;\n                }\n            }\n            if (modified) { // save settings to config file if modified\n                try {\n                    cfg.commit();\n                } catch (IOException ex) {\n                }\n            }\n        } catch (IOException e) {\n            Log.logException(e);\n        }\n        \n        // re-read config (and create/update work table)\n        if (sb.getConfigBool(SwitchboardConstants.HEURISTIC_OPENSEARCH, true)) {\n            OpenSearchConnector os = new OpenSearchConnector(sb, true);\n        }\n    }","commit_id":"6115bef335346f38088b225088235a50547c1b46","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public boolean cleanupJob() {\n        \n        try {\n            // flush caches in used libraries\n            pdfParser.clean_up_idiotic_PDFParser_font_cache_which_eats_up_tons_of_megabytes(); // eats up megabytes, see http://markmail.org/thread/quk5odee4hbsauhu\n            \n            // clear caches\n            if (WordCache.sizeCommonWords() > 1000) WordCache.clearCommonWords();\n            Word.clearCache();\n            Domains.clear();\n            \n            // clean up image stack\n            ResultImages.clearQueues();\n            \n        \t// flush the document compressor cache\n        \tCache.commit();\n        \tDigest.cleanup(); // don't let caches become permanent memory leaks\n\n            // clear caches if necessary\n            if ( !MemoryControl.request(128000000L, false) ) {\n                this.index.clearCache();\n                SearchEventCache.cleanupEvents(false);\n                this.trail.clear();\n            }\n\n            // set a random password if no password is configured\n            if ( getConfigBool(\"adminAccountForLocalhost\", false)\n                && getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").isEmpty() ) {\n                // make a 'random' password\n                setConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"0000\" + this.genRandomPassword());\n                setConfig(\"adminAccount\", \"\");\n            }\n\n            // refresh recrawl dates\n            try {\n                CrawlProfile selentry;\n                for ( final byte[] handle : this.crawler.getActive() ) {\n                    selentry = this.crawler.getActive(handle);\n                    assert selentry.handle() != null : \"profile.name = \" + selentry.collectionName();\n                    if ( selentry.handle() == null ) {\n                        this.crawler.removeActive(handle);\n                        continue;\n                    }\n                    boolean insert = false;\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_PROXY) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_PROXY_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_LOCAL_TEXT) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_LOCAL_TEXT_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_GLOBAL_TEXT) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_GLOBAL_TEXT_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_LOCAL_MEDIA) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_LOCAL_MEDIA_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_GLOBAL_MEDIA) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_GLOBAL_MEDIA_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SURROGATE) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SURROGATE_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( insert ) {\n                        this.crawler.putActive(UTF8.getBytes(selentry.handle()), selentry);\n                    }\n                }\n            } catch ( final Exception e ) {\n                Log.logException(e);\n            }\n\n            execAPIActions();\n\n            // close unused connections\n            ConnectionInfo.cleanUp();\n\n            // clean up delegated stack\n            checkInterruption();\n            if ( (this.crawlQueues.delegatedURL.stackSize() > 1000) ) {\n                if ( this.log.isFine() ) {\n                    this.log.logFine(\"Cleaning Delegated-URLs report stack, \"\n                        + this.crawlQueues.delegatedURL.stackSize()\n                        + \" entries on stack\");\n                }\n                this.crawlQueues.delegatedURL.clearStack();\n            }\n\n            // clean up error stack\n            checkInterruption();\n            if ( (this.crawlQueues.errorURL.stackSize() > 1000) ) {\n                if ( this.log.isFine() ) {\n                    this.log.logFine(\"Cleaning Error-URLs report stack, \"\n                        + this.crawlQueues.errorURL.stackSize()\n                        + \" entries on stack\");\n                }\n                this.crawlQueues.errorURL.clearStack();\n            }\n\n            // clean up loadedURL stack\n            for ( final EventOrigin origin : EventOrigin.values() ) {\n                checkInterruption();\n                if ( ResultURLs.getStackSize(origin) > 1000 ) {\n                    if ( this.log.isFine() ) {\n                        this.log.logFine(\"Cleaning Loaded-URLs report stack, \"\n                            + ResultURLs.getStackSize(origin)\n                            + \" entries on stack \"\n                            + origin.getCode());\n                    }\n                    ResultURLs.clearStack(origin);\n                }\n            }\n\n            // clean up profiles\n            checkInterruption();\n            //cleanProfiles();\n            int cleanup =  this.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL) ? 0 : this.crawler.cleanFinishesProfiles(this.crawlQueues);\n            if (cleanup > 0) log.logInfo(\"cleanup removed \" + cleanup + \" crawl profiles\");\n            \n            // clean up news\n            checkInterruption();\n            try {\n                if ( this.log.isFine() ) {\n                    this.log.logFine(\"Cleaning Incoming News, \"\n                        + this.peers.newsPool.size(NewsPool.INCOMING_DB)\n                        + \" entries on stack\");\n                }\n                this.peers.newsPool.automaticProcess(this.peers);\n            } catch ( final Exception e ) {\n                Log.logException(e);\n            }\n            if ( getConfigBool(\"cleanup.deletionProcessedNews\", true) ) {\n                this.peers.newsPool.clear(NewsPool.PROCESSED_DB);\n            }\n            if ( getConfigBool(\"cleanup.deletionPublishedNews\", true) ) {\n                this.peers.newsPool.clear(NewsPool.PUBLISHED_DB);\n            }\n\n            // clean up seed-dbs\n            if ( getConfigBool(\"routing.deleteOldSeeds.permission\", true) ) {\n                final long deleteOldSeedsTime =\n                    getConfigLong(\"routing.deleteOldSeeds.time\", 7) * 24 * 3600000;\n                Iterator<Seed> e = this.peers.seedsSortedDisconnected(true, Seed.LASTSEEN);\n                Seed seed = null;\n                final List<String> deleteQueue = new ArrayList<String>();\n                checkInterruption();\n                // clean passive seeds\n                while ( e.hasNext() ) {\n                    seed = e.next();\n                    if ( seed != null ) {\n                        //list is sorted -> break when peers are too young to delete\n                        if ( !seed.isLastSeenTimeout(deleteOldSeedsTime) ) {\n                            break;\n                        }\n                        deleteQueue.add(seed.hash);\n                    }\n                }\n                for ( int i = 0; i < deleteQueue.size(); ++i ) {\n                    this.peers.removeDisconnected(deleteQueue.get(i));\n                }\n                deleteQueue.clear();\n                e = this.peers.seedsSortedPotential(true, Seed.LASTSEEN);\n                checkInterruption();\n                // clean potential seeds\n                while ( e.hasNext() ) {\n                    seed = e.next();\n                    if ( seed != null ) {\n                        //list is sorted -> break when peers are too young to delete\n                        if ( !seed.isLastSeenTimeout(deleteOldSeedsTime) ) {\n                            break;\n                        }\n                        deleteQueue.add(seed.hash);\n                    }\n                }\n                for ( int i = 0; i < deleteQueue.size(); ++i ) {\n                    this.peers.removePotential(deleteQueue.get(i));\n                }\n            }\n\n            // check if update is available and\n            // if auto-update is activated perform an automatic installation and restart\n            final yacyRelease updateVersion = yacyRelease.rulebasedUpdateInfo(false);\n            if ( updateVersion != null ) {\n                // there is a version that is more recent. Load it and re-start with it\n                this.log.logInfo(\"AUTO-UPDATE: downloading more recent release \" + updateVersion.getUrl());\n                final File downloaded = updateVersion.downloadRelease();\n                final boolean devenvironment = new File(this.getAppPath(), \".git\").exists();\n                if ( devenvironment ) {\n                    this.log\n                        .logInfo(\"AUTO-UPDATE: omitting update because this is a development environment\");\n                } else if ( (downloaded == null) || (!downloaded.exists()) || (downloaded.length() == 0) ) {\n                    this.log\n                        .logInfo(\"AUTO-UPDATE: omitting update because download failed (file cannot be found, is too small or signature is bad)\");\n                } else {\n                    yacyRelease.deployRelease(downloaded);\n                    terminate(10, \"auto-update to install \" + downloaded.getName());\n                    this.log.logInfo(\"AUTO-UPDATE: deploy and restart initiated\");\n                }\n            }\n\n            // initiate broadcast about peer startup to spread supporter url\n            if ( !isRobinsonMode() && this.peers.newsPool.size(NewsPool.OUTGOING_DB) == 0 ) {\n                // read profile\n                final Properties profile = new Properties();\n                FileInputStream fileIn = null;\n                try {\n                    fileIn = new FileInputStream(new File(\"DATA/SETTINGS/profile.txt\"));\n                    profile.load(fileIn);\n                } catch ( final IOException e ) {\n                } finally {\n                    if ( fileIn != null ) {\n                        try {\n                            fileIn.close();\n                        } catch ( final Exception e ) {\n                        }\n                    }\n                }\n                final String homepage = (String) profile.get(\"homepage\");\n                if ( (homepage != null) && (homepage.length() > 10) ) {\n                    final Properties news = new Properties();\n                    news.put(\"homepage\", profile.get(\"homepage\"));\n                    this.peers.newsPool.publishMyNews(\n                        this.peers.mySeed(),\n                        NewsPool.CATEGORY_PROFILE_BROADCAST,\n                        news);\n                }\n            }\n\n            // update the cluster set\n            this.clusterhashes = this.peers.clusterHashes(getConfig(\"cluster.peers.yacydomain\", \"\"));\n\n            // check if we are reachable and try to map port again if not (e.g. when router rebooted)\n            if ( getConfigBool(SwitchboardConstants.UPNP_ENABLED, false) && this.peers.mySeed().isJunior() ) {\n                UPnP.addPortMapping();\n            }\n\n            // after all clean up is done, check the resource usage\n            this.observer.resourceObserverJob();\n\n            // cleanup cached search failures\n            if ( getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false)\n                && this.peers.mySeed().getFlagAcceptRemoteIndex() ) {\n                this.tables.cleanFailURLS(getConfigLong(\"cleanup.failedSearchURLtimeout\", -1));\n            }\n\n            // periodically store the triple store\n            if (getConfigBool(\"triplestore.persistent\", false)) {\n                JenaTripleStore.saveAll();\n            }\n\n            // if no crawl is running and processing is activated:\n            // execute the (post-) processing steps for all entries that have a process tag assigned\n            if (this.crawlQueues.coreCrawlJobSize() == 0) {\n                index.fulltext().getDefaultConfiguration().postprocessing(index);\n                index.fulltext().getWebgraphConfiguration().postprocessing(index);\n            }\n            \n            return true;\n        } catch ( final InterruptedException e ) {\n            this.log.logInfo(\"cleanupJob: Shutdown detected\");\n            return false;\n        }\n    }","id":76350,"modified_method":"public boolean cleanupJob() {\n        \n        try {\n            // flush caches in used libraries\n            pdfParser.clean_up_idiotic_PDFParser_font_cache_which_eats_up_tons_of_megabytes(); // eats up megabytes, see http://markmail.org/thread/quk5odee4hbsauhu\n            \n            // clear caches\n            if (WordCache.sizeCommonWords() > 1000) WordCache.clearCommonWords();\n            Word.clearCache();\n            Domains.clear();\n            \n            // clean up image stack\n            ResultImages.clearQueues();\n            \n        \t// flush the document compressor cache\n        \tCache.commit();\n        \tDigest.cleanup(); // don't let caches become permanent memory leaks\n\n            // clear caches if necessary\n            if ( !MemoryControl.request(128000000L, false) ) {\n                this.index.clearCache();\n                SearchEventCache.cleanupEvents(false);\n                this.trail.clear();\n            }\n\n            // set a random password if no password is configured\n            if ( getConfigBool(\"adminAccountForLocalhost\", false)\n                && getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").isEmpty() ) {\n                // make a 'random' password\n                setConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"0000\" + this.genRandomPassword());\n                setConfig(\"adminAccount\", \"\");\n            }\n\n            // stop greedylearning if limit is reached\n            if (getConfigBool(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false)) {\n                long cs = this.index.fulltext().collectionSize();\n                if (cs > getConfigInt(SwitchboardConstants.GREEDYLEARNING_LIMIT_DOCCOUNT, 0)) {\n                    setConfig(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false);\n                    log.logInfo(\"finishing greedy learning phase, size=\" +cs);\n                }\n            }\n            \n            // refresh recrawl dates\n            try {\n                CrawlProfile selentry;\n                for ( final byte[] handle : this.crawler.getActive() ) {\n                    selentry = this.crawler.getActive(handle);\n                    assert selentry.handle() != null : \"profile.name = \" + selentry.collectionName();\n                    if ( selentry.handle() == null ) {\n                        this.crawler.removeActive(handle);\n                        continue;\n                    }\n                    boolean insert = false;\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_PROXY) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_PROXY_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_LOCAL_TEXT) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_LOCAL_TEXT_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_GLOBAL_TEXT) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_GLOBAL_TEXT_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_LOCAL_MEDIA) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_LOCAL_MEDIA_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_GLOBAL_MEDIA) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SNIPPET_GLOBAL_MEDIA_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( selentry.name().equals(CrawlSwitchboard.CRAWL_PROFILE_SURROGATE) ) {\n                        selentry.put(CrawlProfile.RECRAWL_IF_OLDER, Long.toString(CrawlProfile.getRecrawlDate(CrawlSwitchboard.CRAWL_PROFILE_SURROGATE_RECRAWL_CYCLE)));\n                        insert = true;\n                    }\n                    if ( insert ) {\n                        this.crawler.putActive(UTF8.getBytes(selentry.handle()), selentry);\n                    }\n                }\n            } catch ( final Exception e ) {\n                Log.logException(e);\n            }\n\n            execAPIActions();\n\n            // close unused connections\n            ConnectionInfo.cleanUp();\n\n            // clean up delegated stack\n            checkInterruption();\n            if ( (this.crawlQueues.delegatedURL.stackSize() > 1000) ) {\n                if ( this.log.isFine() ) {\n                    this.log.logFine(\"Cleaning Delegated-URLs report stack, \"\n                        + this.crawlQueues.delegatedURL.stackSize()\n                        + \" entries on stack\");\n                }\n                this.crawlQueues.delegatedURL.clearStack();\n            }\n\n            // clean up error stack\n            checkInterruption();\n            if ( (this.crawlQueues.errorURL.stackSize() > 1000) ) {\n                if ( this.log.isFine() ) {\n                    this.log.logFine(\"Cleaning Error-URLs report stack, \"\n                        + this.crawlQueues.errorURL.stackSize()\n                        + \" entries on stack\");\n                }\n                this.crawlQueues.errorURL.clearStack();\n            }\n\n            // clean up loadedURL stack\n            for ( final EventOrigin origin : EventOrigin.values() ) {\n                checkInterruption();\n                if ( ResultURLs.getStackSize(origin) > 1000 ) {\n                    if ( this.log.isFine() ) {\n                        this.log.logFine(\"Cleaning Loaded-URLs report stack, \"\n                            + ResultURLs.getStackSize(origin)\n                            + \" entries on stack \"\n                            + origin.getCode());\n                    }\n                    ResultURLs.clearStack(origin);\n                }\n            }\n\n            // clean up profiles\n            checkInterruption();\n            //cleanProfiles();\n            int cleanup =  this.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL) ? 0 : this.crawler.cleanFinishesProfiles(this.crawlQueues);\n            if (cleanup > 0) log.logInfo(\"cleanup removed \" + cleanup + \" crawl profiles\");\n            \n            // clean up news\n            checkInterruption();\n            try {\n                if ( this.log.isFine() ) {\n                    this.log.logFine(\"Cleaning Incoming News, \"\n                        + this.peers.newsPool.size(NewsPool.INCOMING_DB)\n                        + \" entries on stack\");\n                }\n                this.peers.newsPool.automaticProcess(this.peers);\n            } catch ( final Exception e ) {\n                Log.logException(e);\n            }\n            if ( getConfigBool(\"cleanup.deletionProcessedNews\", true) ) {\n                this.peers.newsPool.clear(NewsPool.PROCESSED_DB);\n            }\n            if ( getConfigBool(\"cleanup.deletionPublishedNews\", true) ) {\n                this.peers.newsPool.clear(NewsPool.PUBLISHED_DB);\n            }\n\n            // clean up seed-dbs\n            if ( getConfigBool(\"routing.deleteOldSeeds.permission\", true) ) {\n                final long deleteOldSeedsTime =\n                    getConfigLong(\"routing.deleteOldSeeds.time\", 7) * 24 * 3600000;\n                Iterator<Seed> e = this.peers.seedsSortedDisconnected(true, Seed.LASTSEEN);\n                Seed seed = null;\n                final List<String> deleteQueue = new ArrayList<String>();\n                checkInterruption();\n                // clean passive seeds\n                while ( e.hasNext() ) {\n                    seed = e.next();\n                    if ( seed != null ) {\n                        //list is sorted -> break when peers are too young to delete\n                        if ( !seed.isLastSeenTimeout(deleteOldSeedsTime) ) {\n                            break;\n                        }\n                        deleteQueue.add(seed.hash);\n                    }\n                }\n                for ( int i = 0; i < deleteQueue.size(); ++i ) {\n                    this.peers.removeDisconnected(deleteQueue.get(i));\n                }\n                deleteQueue.clear();\n                e = this.peers.seedsSortedPotential(true, Seed.LASTSEEN);\n                checkInterruption();\n                // clean potential seeds\n                while ( e.hasNext() ) {\n                    seed = e.next();\n                    if ( seed != null ) {\n                        //list is sorted -> break when peers are too young to delete\n                        if ( !seed.isLastSeenTimeout(deleteOldSeedsTime) ) {\n                            break;\n                        }\n                        deleteQueue.add(seed.hash);\n                    }\n                }\n                for ( int i = 0; i < deleteQueue.size(); ++i ) {\n                    this.peers.removePotential(deleteQueue.get(i));\n                }\n            }\n\n            // check if update is available and\n            // if auto-update is activated perform an automatic installation and restart\n            final yacyRelease updateVersion = yacyRelease.rulebasedUpdateInfo(false);\n            if ( updateVersion != null ) {\n                // there is a version that is more recent. Load it and re-start with it\n                this.log.logInfo(\"AUTO-UPDATE: downloading more recent release \" + updateVersion.getUrl());\n                final File downloaded = updateVersion.downloadRelease();\n                final boolean devenvironment = new File(this.getAppPath(), \".git\").exists();\n                if ( devenvironment ) {\n                    this.log\n                        .logInfo(\"AUTO-UPDATE: omitting update because this is a development environment\");\n                } else if ( (downloaded == null) || (!downloaded.exists()) || (downloaded.length() == 0) ) {\n                    this.log\n                        .logInfo(\"AUTO-UPDATE: omitting update because download failed (file cannot be found, is too small or signature is bad)\");\n                } else {\n                    yacyRelease.deployRelease(downloaded);\n                    terminate(10, \"auto-update to install \" + downloaded.getName());\n                    this.log.logInfo(\"AUTO-UPDATE: deploy and restart initiated\");\n                }\n            }\n\n            // initiate broadcast about peer startup to spread supporter url\n            if ( !isRobinsonMode() && this.peers.newsPool.size(NewsPool.OUTGOING_DB) == 0 ) {\n                // read profile\n                final Properties profile = new Properties();\n                FileInputStream fileIn = null;\n                try {\n                    fileIn = new FileInputStream(new File(\"DATA/SETTINGS/profile.txt\"));\n                    profile.load(fileIn);\n                } catch ( final IOException e ) {\n                } finally {\n                    if ( fileIn != null ) {\n                        try {\n                            fileIn.close();\n                        } catch ( final Exception e ) {\n                        }\n                    }\n                }\n                final String homepage = (String) profile.get(\"homepage\");\n                if ( (homepage != null) && (homepage.length() > 10) ) {\n                    final Properties news = new Properties();\n                    news.put(\"homepage\", profile.get(\"homepage\"));\n                    this.peers.newsPool.publishMyNews(\n                        this.peers.mySeed(),\n                        NewsPool.CATEGORY_PROFILE_BROADCAST,\n                        news);\n                }\n            }\n\n            // update the cluster set\n            this.clusterhashes = this.peers.clusterHashes(getConfig(\"cluster.peers.yacydomain\", \"\"));\n\n            // check if we are reachable and try to map port again if not (e.g. when router rebooted)\n            if ( getConfigBool(SwitchboardConstants.UPNP_ENABLED, false) && this.peers.mySeed().isJunior() ) {\n                UPnP.addPortMapping();\n            }\n\n            // after all clean up is done, check the resource usage\n            this.observer.resourceObserverJob();\n\n            // cleanup cached search failures\n            if ( getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false)\n                && this.peers.mySeed().getFlagAcceptRemoteIndex() ) {\n                this.tables.cleanFailURLS(getConfigLong(\"cleanup.failedSearchURLtimeout\", -1));\n            }\n\n            // periodically store the triple store\n            if (getConfigBool(\"triplestore.persistent\", false)) {\n                JenaTripleStore.saveAll();\n            }\n\n            // if no crawl is running and processing is activated:\n            // execute the (post-) processing steps for all entries that have a process tag assigned\n            if (this.crawlQueues.coreCrawlJobSize() == 0) {\n                if (this.crawlQueues.noticeURL.isEmpty()) this.crawlQueues.noticeURL.clear(); // flushes more caches                \n                index.fulltext().getDefaultConfiguration().postprocessing(index);\n                index.fulltext().getWebgraphConfiguration().postprocessing(index);\n            }\n            \n            return true;\n        } catch ( final InterruptedException e ) {\n            this.log.logInfo(\"cleanupJob: Shutdown detected\");\n            return false;\n        }\n    }","commit_id":"6115bef335346f38088b225088235a50547c1b46","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public final void heuristicSearchResults(final String host) {\n        new Thread() {\n\n            @Override\n            public void run() {\n\n                // get the links for a specific site\n                final DigestURI startUrl;\n                try {\n                    startUrl = new DigestURI(host);\n                } catch (final MalformedURLException e) {\n                    Log.logException(e);\n                    return;\n                }\n\n                final Map<DigestURI, String> links;\n                DigestURI url;\n                try {\n                    links = Switchboard.this.loader.loadLinks(startUrl, CacheStrategy.IFFRESH, BlacklistType.SEARCH, TextSnippet.snippetMinLoadDelay, 2000);\n                    if (links != null) {\n                        if (links.size() < 1000) { // limit to 1000 to skip large index pages\n                            final Iterator<DigestURI> i = links.keySet().iterator();\n                            final boolean globalcrawljob = Switchboard.this.getConfigBool(\"heuristic.searchresults.crawlglobal\",false);\n                            Collection<DigestURI> urls = new ArrayList<DigestURI>();\n                            while (i.hasNext()) {\n                                url = i.next();\n                                boolean islocal = (url.getHost() == null && startUrl.getHost() == null) || (url.getHost() != null && startUrl.getHost() != null && url.getHost().contentEquals(startUrl.getHost()));\n                                // add all external links or links to different page to crawler\n                                if ( !islocal ) {// || (!startUrl.getPath().endsWith(url.getPath()))) {\n                                    urls.add(url);\n                                }\n                            }\n                            addToCrawler(urls, globalcrawljob);\n                        }\n                    }\n                } catch (final Throwable e) {\n                    Log.logException(e);\n                }\n            }\n        }.start();\n    }","id":76351,"modified_method":"public final void heuristicSearchResults(final String url) {\n        new Thread() {\n\n            @Override\n            public void run() {\n\n                // get the links for a specific site\n                final DigestURI startUrl;\n                try {\n                    startUrl = new DigestURI(url);\n                } catch (final MalformedURLException e) {\n                    Log.logException(e);\n                    return;\n                }\n\n                final Map<DigestURI, String> links;\n                DigestURI url;\n                try {\n                    links = Switchboard.this.loader.loadLinks(startUrl, CacheStrategy.IFFRESH, BlacklistType.SEARCH, TextSnippet.snippetMinLoadDelay, 2000);\n                    if (links != null) {\n                        if (links.size() < 1000) { // limit to 1000 to skip large index pages\n                            final Iterator<DigestURI> i = links.keySet().iterator();\n                            final boolean globalcrawljob = Switchboard.this.getConfigBool(SwitchboardConstants.HEURISTIC_SEARCHRESULTS_CRAWLGLOBAL,false);\n                            Collection<DigestURI> urls = new ArrayList<DigestURI>();\n                            while (i.hasNext()) {\n                                url = i.next();\n                                boolean islocal = (url.getHost() == null && startUrl.getHost() == null) || (url.getHost() != null && startUrl.getHost() != null && url.getHost().contentEquals(startUrl.getHost()));\n                                // add all external links or links to different page to crawler\n                                if ( !islocal ) {// || (!startUrl.getPath().endsWith(url.getPath()))) {\n                                    urls.add(url);\n                                }\n                            }\n                            addToCrawler(urls, globalcrawljob);\n                        }\n                    }\n                } catch (final Throwable e) {\n                    Log.logException(e);\n                }\n            }\n        }.start();\n    }","commit_id":"6115bef335346f38088b225088235a50547c1b46","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void switchNetwork(final String networkDefinition) throws FileNotFoundException, IOException {\n        this.log.logInfo(\"SWITCH NETWORK: switching to '\" + networkDefinition + \"'\");\n        // pause crawls\n        final boolean lcp = crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\n        if ( !lcp ) {\n            pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, \"network switch to \" + networkDefinition);\n        }\n        final boolean rcp = crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\n        if ( !rcp ) {\n            pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, \"network switch to \" + networkDefinition);\n        }\n        // trigger online caution\n        this.proxyLastAccess = System.currentTimeMillis() + 3000; // at least 3 seconds online caution to prevent unnecessary action on database meanwhile\n        this.log.logInfo(\"SWITCH NETWORK: SHUT DOWN OF OLD INDEX DATABASE...\");\n        // clean search events which have cached relations to the old index\n        SearchEventCache.cleanupEvents(true);\n\n        // switch the networks\n        synchronized ( this ) {\n\n            // remember the solr scheme\n            CollectionConfiguration collectionConfiguration = this.index.fulltext().getDefaultConfiguration();\n            WebgraphConfiguration webgraphConfiguration = this.index.fulltext().getWebgraphConfiguration();\n\n            // shut down\n            this.crawler.close();\n            if ( this.dhtDispatcher != null ) {\n                this.dhtDispatcher.close();\n            }\n            synchronized ( this.index ) {\n                this.index.close();\n            }\n            this.crawlStacker.announceClose();\n            this.crawlStacker.close();\n            this.webStructure.close();\n\n            this.log.logInfo(\"SWITCH NETWORK: START UP OF NEW INDEX DATABASE...\");\n\n            // new properties\n            setConfig(\"network.unit.definition\", networkDefinition);\n            overwriteNetworkDefinition();\n            final File indexPrimaryPath =\n                getDataPath(SwitchboardConstants.INDEX_PRIMARY_PATH, SwitchboardConstants.INDEX_PATH_DEFAULT);\n            final int wordCacheMaxCount =\n                (int) getConfigLong(SwitchboardConstants.WORDCACHE_MAX_COUNT, 20000);\n            final long fileSizeMax =\n                (OS.isWindows) ? this.getConfigLong(\"filesize.max.win\", Integer.MAX_VALUE) : this.getConfigLong(\"filesize.max.other\", Integer.MAX_VALUE);\n            final int redundancy = (int) this.getConfigLong(\"network.unit.dhtredundancy.senior\", 1);\n            final int partitionExponent = (int) this.getConfigLong(\"network.unit.dht.partitionExponent\", 0);\n            final String networkName = getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\n            this.networkRoot = new File(new File(indexPrimaryPath, networkName), \"NETWORK\");\n            this.queuesRoot = new File(new File(indexPrimaryPath, networkName), \"QUEUES\");\n            this.networkRoot.mkdirs();\n            this.queuesRoot.mkdirs();\n\n            // clear statistic data\n            ResultURLs.clearStacks();\n\n            // remove heuristics\n            setConfig(\"heuristic.site\", false);\n            setConfig(\"heuristic.blekko\", false);\n            setConfig(\"heuristic.twitter\", false);\n\n            // relocate\n            this.peers.relocate(\n                this.networkRoot,\n                redundancy,\n                partitionExponent,\n                this.useTailCache,\n                this.exceed134217727);\n            this.index = new Segment(this.log, new File(new File(indexPrimaryPath, networkName), \"SEGMENTS\"), collectionConfiguration, webgraphConfiguration);\n            if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_RWI, true)) this.index.connectRWI(wordCacheMaxCount, fileSizeMax);\n            if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_CITATION, true)) this.index.connectCitation(wordCacheMaxCount, fileSizeMax);\n            if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_FULLTEXT, true)) {\n                this.index.fulltext().connectLocalSolr();\n                this.index.connectUrlDb(this.useTailCache, this.exceed134217727);\n            }\n            this.index.writeWebgraph(this.getConfigBool(SwitchboardConstants.CORE_SERVICE_WEBGRAPH, false));\n\n            // set up the solr interface\n            final String solrurls = getConfig(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_URL, \"http://127.0.0.1:8983/solr\");\n            final boolean usesolr = getConfigBool(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_ENABLED, false) & solrurls.length() > 0;\n\n            if (usesolr && solrurls != null && solrurls.length() > 0) {\n                try {\n                    ArrayList<RemoteInstance> instances = RemoteInstance.getShardInstances(solrurls, null, null);\n                    this.index.fulltext().connectRemoteSolr(instances);\n                } catch ( final IOException e ) {\n                    Log.logException(e);\n                }\n            }\n\n            // create a crawler\n            this.crawlQueues.relocate(this.queuesRoot); // cannot be closed because the busy threads are working with that object\n            this.crawler = new CrawlSwitchboard(networkName, this.log, this.queuesRoot);\n\n            // init a DHT transmission dispatcher\n            this.dhtDispatcher =\n                (this.peers.sizeConnected() == 0) ? null : new Dispatcher(\n                    this.index,\n                    this.peers,\n                    true,\n                    10000);\n\n            // create new web structure\n            this.webStructure = new WebStructureGraph(new File(this.queuesRoot, \"webStructure.map\"));\n\n            // load domainList\n            try {\n                this.domainList = null;\n                if ( !getConfig(\"network.unit.domainlist\", \"\").equals(\"\") ) {\n                    final Reader r =\n                        getConfigFileFromWebOrLocally(getConfig(\"network.unit.domainlist\", \"\"), getAppPath()\n                            .getAbsolutePath(), new File(this.networkRoot, \"domainlist.txt\"));\n                    this.domainList = new FilterEngine();\n                    this.domainList.loadList(new BufferedReader(r), null);\n                }\n            } catch ( final FileNotFoundException e ) {\n                this.log.logSevere(\"CONFIG: domainlist not found: \" + e.getMessage());\n            } catch ( final IOException e ) {\n                this.log.logSevere(\"CONFIG: error while retrieving domainlist: \" + e.getMessage());\n            }\n\n            this.crawlStacker =\n                new CrawlStacker(\n                    this.robots,\n                    this.crawlQueues,\n                    this.crawler,\n                    this.index,\n                    this.peers,\n                    \"local.any\".indexOf(getConfig(SwitchboardConstants.NETWORK_DOMAIN, \"global\")) >= 0,\n                    \"global.any\".indexOf(getConfig(SwitchboardConstants.NETWORK_DOMAIN, \"global\")) >= 0,\n                    this.domainList);\n\n        }\n        Domains.setNoLocalCheck(isAllIPMode()); // possibly switch off localIP check\n\n        // start up crawl jobs\n        continueCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\n        continueCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\n        this.log\n            .logInfo(\"SWITCH NETWORK: FINISHED START UP, new network is now '\" + networkDefinition + \"'.\");\n\n        // set the network-specific remote crawl ppm\n        setRemotecrawlPPM(Math.max(1, (int) getConfigLong(\"network.unit.remotecrawl.speed\", 60)));\n    }","id":76352,"modified_method":"public void switchNetwork(final String networkDefinition) throws FileNotFoundException, IOException {\n        this.log.logInfo(\"SWITCH NETWORK: switching to '\" + networkDefinition + \"'\");\n        // pause crawls\n        final boolean lcp = crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\n        if ( !lcp ) {\n            pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, \"network switch to \" + networkDefinition);\n        }\n        final boolean rcp = crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\n        if ( !rcp ) {\n            pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, \"network switch to \" + networkDefinition);\n        }\n        // trigger online caution\n        this.proxyLastAccess = System.currentTimeMillis() + 3000; // at least 3 seconds online caution to prevent unnecessary action on database meanwhile\n        this.log.logInfo(\"SWITCH NETWORK: SHUT DOWN OF OLD INDEX DATABASE...\");\n        // clean search events which have cached relations to the old index\n        SearchEventCache.cleanupEvents(true);\n\n        // switch the networks\n        synchronized ( this ) {\n\n            // remember the solr scheme\n            CollectionConfiguration collectionConfiguration = this.index.fulltext().getDefaultConfiguration();\n            WebgraphConfiguration webgraphConfiguration = this.index.fulltext().getWebgraphConfiguration();\n\n            // shut down\n            this.crawler.close();\n            if ( this.dhtDispatcher != null ) {\n                this.dhtDispatcher.close();\n            }\n            synchronized ( this.index ) {\n                this.index.close();\n            }\n            this.crawlStacker.announceClose();\n            this.crawlStacker.close();\n            this.webStructure.close();\n\n            this.log.logInfo(\"SWITCH NETWORK: START UP OF NEW INDEX DATABASE...\");\n\n            // new properties\n            setConfig(\"network.unit.definition\", networkDefinition);\n            overwriteNetworkDefinition();\n            final File indexPrimaryPath =\n                getDataPath(SwitchboardConstants.INDEX_PRIMARY_PATH, SwitchboardConstants.INDEX_PATH_DEFAULT);\n            final int wordCacheMaxCount =\n                (int) getConfigLong(SwitchboardConstants.WORDCACHE_MAX_COUNT, 20000);\n            final long fileSizeMax =\n                (OS.isWindows) ? this.getConfigLong(\"filesize.max.win\", Integer.MAX_VALUE) : this.getConfigLong(\"filesize.max.other\", Integer.MAX_VALUE);\n            final int redundancy = (int) this.getConfigLong(\"network.unit.dhtredundancy.senior\", 1);\n            final int partitionExponent = (int) this.getConfigLong(\"network.unit.dht.partitionExponent\", 0);\n            final String networkName = getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\n            this.networkRoot = new File(new File(indexPrimaryPath, networkName), \"NETWORK\");\n            this.queuesRoot = new File(new File(indexPrimaryPath, networkName), \"QUEUES\");\n            this.networkRoot.mkdirs();\n            this.queuesRoot.mkdirs();\n\n            // clear statistic data\n            ResultURLs.clearStacks();\n\n            // remove heuristics\n            setConfig(SwitchboardConstants.HEURISTIC_SITE, false);\n            setConfig(SwitchboardConstants.HEURISTIC_BLEKKO, false);\n            setConfig(SwitchboardConstants.HEURISTIC_TWITTER, false);\n\n            // relocate\n            this.peers.relocate(\n                this.networkRoot,\n                redundancy,\n                partitionExponent,\n                this.useTailCache,\n                this.exceed134217727);\n            this.index = new Segment(this.log, new File(new File(indexPrimaryPath, networkName), \"SEGMENTS\"), collectionConfiguration, webgraphConfiguration);\n            if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_RWI, true)) this.index.connectRWI(wordCacheMaxCount, fileSizeMax);\n            if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_CITATION, true)) this.index.connectCitation(wordCacheMaxCount, fileSizeMax);\n            if (this.getConfigBool(SwitchboardConstants.CORE_SERVICE_FULLTEXT, true)) {\n                this.index.fulltext().connectLocalSolr();\n                this.index.connectUrlDb(this.useTailCache, this.exceed134217727);\n            }\n            this.index.writeWebgraph(this.getConfigBool(SwitchboardConstants.CORE_SERVICE_WEBGRAPH, false));\n\n            // set up the solr interface\n            final String solrurls = getConfig(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_URL, \"http://127.0.0.1:8983/solr\");\n            final boolean usesolr = getConfigBool(SwitchboardConstants.FEDERATED_SERVICE_SOLR_INDEXING_ENABLED, false) & solrurls.length() > 0;\n\n            if (usesolr && solrurls != null && solrurls.length() > 0) {\n                try {\n                    ArrayList<RemoteInstance> instances = RemoteInstance.getShardInstances(solrurls, null, null);\n                    this.index.fulltext().connectRemoteSolr(instances);\n                } catch ( final IOException e ) {\n                    Log.logException(e);\n                }\n            }\n\n            // create a crawler\n            this.crawlQueues.relocate(this.queuesRoot); // cannot be closed because the busy threads are working with that object\n            this.crawler = new CrawlSwitchboard(networkName, this.log, this.queuesRoot);\n\n            // init a DHT transmission dispatcher\n            this.dhtDispatcher =\n                (this.peers.sizeConnected() == 0) ? null : new Dispatcher(\n                    this.index,\n                    this.peers,\n                    true,\n                    10000);\n\n            // create new web structure\n            this.webStructure = new WebStructureGraph(new File(this.queuesRoot, \"webStructure.map\"));\n\n            // load domainList\n            try {\n                this.domainList = null;\n                if ( !getConfig(\"network.unit.domainlist\", \"\").equals(\"\") ) {\n                    final Reader r =\n                        getConfigFileFromWebOrLocally(getConfig(\"network.unit.domainlist\", \"\"), getAppPath()\n                            .getAbsolutePath(), new File(this.networkRoot, \"domainlist.txt\"));\n                    this.domainList = new FilterEngine();\n                    this.domainList.loadList(new BufferedReader(r), null);\n                }\n            } catch ( final FileNotFoundException e ) {\n                this.log.logSevere(\"CONFIG: domainlist not found: \" + e.getMessage());\n            } catch ( final IOException e ) {\n                this.log.logSevere(\"CONFIG: error while retrieving domainlist: \" + e.getMessage());\n            }\n\n            this.crawlStacker =\n                new CrawlStacker(\n                    this.robots,\n                    this.crawlQueues,\n                    this.crawler,\n                    this.index,\n                    this.peers,\n                    \"local.any\".indexOf(getConfig(SwitchboardConstants.NETWORK_DOMAIN, \"global\")) >= 0,\n                    \"global.any\".indexOf(getConfig(SwitchboardConstants.NETWORK_DOMAIN, \"global\")) >= 0,\n                    this.domainList);\n\n        }\n        Domains.setNoLocalCheck(isAllIPMode()); // possibly switch off localIP check\n\n        // start up crawl jobs\n        continueCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\n        continueCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\n        this.log\n            .logInfo(\"SWITCH NETWORK: FINISHED START UP, new network is now '\" + networkDefinition + \"'.\");\n\n        // set the network-specific remote crawl ppm\n        setRemotecrawlPPM(Math.max(1, (int) getConfigLong(\"network.unit.remotecrawl.speed\", 60)));\n    }","commit_id":"6115bef335346f38088b225088235a50547c1b46","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(\n        final RequestHeader header,\n        final serverObjects post,\n        final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        final boolean searchAllowed =\n            sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header);\n\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        if ( !authenticated ) {\n            final UserDB.Entry user = sb.userDB.getUser(header);\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\n        }\n        final boolean localhostAccess = header.accessFromLocalhost();\n        final String promoteSearchPageGreeting =\n            (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ? env.getConfig(\n                \"network.unit.description\",\n                \"\") : env.getConfig(SwitchboardConstants.GREETING, \"\");\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\n        \n        // get query\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\n        String querystring = originalquerystring.replace('+', ' ').trim();\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", sb.getConfig(\"search.verify\", \"\")));\n        \n        final servletProperties prop = new servletProperties();\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n\n        //get focus option\n        prop.put(\"focus\", ((post == null) ? true : post.get(\"focus\", \"1\").equals(\"1\")) ? 1 : 0);\n\n        // produce vocabulary navigation sidebars\n        Collection<Tagging> vocabularies = LibraryProvider.autotagging.getVocabularies();\n        int j = 0;\n        for (Tagging v: vocabularies) {\n            prop.put(\"sidebarVocabulary_\" + j + \"_vocabulary\", v.getName());\n            j++;\n        }\n        prop.put(\"sidebarVocabulary\", j);\n\n        // get segment\n        Segment indexSegment = sb.index;\n\n        final String EXT = header.get(\"EXT\", \"\");\n        final boolean rss = EXT.equals(\"rss\");\n        final boolean json = EXT.equals(\"json\");\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\n        \n        // adding some additional properties needed for the rss feed\n        String hostName = header.get(\"Host\", Domains.LOCALHOST);\n        if ( hostName.indexOf(':', 0) == -1 ) {\n            hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8090\"));\n        }\n        prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\n        prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\n        prop.put(\"thisaddress\", hostName);\n        final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n        final boolean indexReceiveGranted =\n            sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true)\n                || sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true)\n                || clustersearch;\n        boolean global = post == null || (post.get(\"resource\", \"local\").equals(\"global\") && sb.peers.sizeConnected() > 0 && indexReceiveGranted);\n        prop.put(\"topmenu_resource-select\", (sb.peers == null || sb.peers.sizeConnected() == 0 || !indexReceiveGranted) ? 0 : global ? 1 : 2);\n        \n        if ( post == null || indexSegment == null || env == null || !searchAllowed ) {\n            // we create empty entries for template strings\n            prop.put(\"searchagain\", \"0\");\n            prop.put(\"former\", \"\");\n            prop.put(\"count\", \"10\");\n            prop.put(\"offset\", \"0\");\n            prop.put(\"resource\", \"global\");\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\n            prop.put(\"tenant\", (post == null) ? \"\" : post.get(\"tenant\", \"\"));\n            prop.put(\"indexof\", \"off\");\n            prop.put(\"constraint\", \"\");\n            prop.put(\"cat\", \"href\");\n            prop.put(\"depth\", \"0\");\n            prop.put(\n                \"search.verify\",\n                (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\n            prop.put(\n                \"search.navigation\",\n                (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n            prop.put(\"contentdom\", \"text\");\n            prop.put(\"contentdomCheckText\", \"1\");\n            prop.put(\"contentdomCheckAudio\", \"0\");\n            prop.put(\"contentdomCheckVideo\", \"0\");\n            prop.put(\"contentdomCheckImage\", \"0\");\n            prop.put(\"contentdomCheckApp\", \"0\");\n            prop.put(\"excluded\", \"0\");\n            prop.put(\"results\", \"\");\n            prop.put(\"resultTable\", \"0\");\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\n            prop.put(\"num-results_totalcount\", 0);\n            prop.put(\"num-results_offset\", 0);\n            prop.put(\"num-results_itemsPerPage\", 10);\n            prop.put(\"geoinfo\", \"0\");\n            prop.put(\"rss_queryenc\", \"\");\n            prop.put(\"meanCount\", 5);\n            return prop;\n        }\n\n        // check for JSONP\n        if ( post.containsKey(\"callback\") ) {\n            final String jsonp = post.get(\"callback\") + \"([\";\n            prop.put(\"jsonp-start\", jsonp);\n            prop.put(\"jsonp-end\", \"])\");\n        } else {\n            prop.put(\"jsonp-start\", \"\");\n            prop.put(\"jsonp-end\", \"\");\n        }\n\n        // Adding CORS Access header for yacysearch.rss output\n        if ( rss ) {\n            final ResponseHeader outgoingHeader = new ResponseHeader(200);\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\n            prop.setOutgoingHeader(outgoingHeader);\n        }\n\n        // collect search attributes\n\n        int itemsPerPage =\n            Math.min(\n                (authenticated)\n                    ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()\n                        ? 100\n                        : 5000) : (snippetFetchStrategy != null\n                        && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000),\n                post.getInt(\"maximumRecords\", post.getInt(\"count\", post.getInt(\"rows\", 10)))); // SRU syntax with old property as alternative\n        int startRecord = post.getInt(\"startRecord\", post.getInt(\"offset\", post.getInt(\"start\", 0)));\n\n        final boolean indexof = (post != null && post.get(\"indexof\", \"\").equals(\"on\"));\n\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\n        if ( !prefermask.isEmpty() && prefermask.indexOf(\".*\", 0) < 0 ) {\n            prefermask = \".*\" + prefermask + \".*\";\n        }\n\n        Bitfield constraint =\n            (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty())\n                ? new Bitfield(4, post.get(\"constraint\", \"______\"))\n                : null;\n        if ( indexof ) {\n            constraint = new Bitfield(4);\n            constraint.set(Condenser.flag_cat_indexof, true);\n        }\n\n        // SEARCH\n        final boolean intranetMode = sb.isIntranetMode() || sb.isAllIPMode();\n\n        // increase search statistic counter\n        if ( !global ) {\n            // we count only searches on the local peer here, because global searches\n            // are counted on the target peer to preserve privacy of the searcher\n            if ( authenticated ) {\n                // local or authenticated search requests are counted separately\n                // because they are not part of a public available peer statistic\n                sb.searchQueriesRobinsonFromLocal++;\n            } else {\n                // robinson-searches from non-authenticated requests are public\n                // and may be part of the public available statistic\n                sb.searchQueriesRobinsonFromRemote++;\n            }\n        }\n\n        // find search domain\n        final Classification.ContentDomain contentdom =\n            ContentDomain.contentdomParser(post == null ? \"all\" : post.get(\"contentdom\", \"all\"));\n\n        // patch until better search profiles are available\n        if (contentdom == ContentDomain.IMAGE && (itemsPerPage == 10 || itemsPerPage == 100)) {\n            itemsPerPage = 64;\n        } else if ( contentdom != ContentDomain.IMAGE && itemsPerPage > 50 && itemsPerPage < 100 ) {\n            itemsPerPage = 10;\n        }\n\n        // check the search tracker\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\n        if ( trackerHandles == null ) {\n            trackerHandles = new TreeSet<Long>();\n        }\n        boolean block = false;\n        if ( Domains.matchesList(client, sb.networkBlacklist) ) {\n            global = false;\n            if ( snippetFetchStrategy != null ) {\n                snippetFetchStrategy = null;\n            }\n            block = true;\n            Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \"\n                + client\n                + \" gets no permission to search\");\n        } else if ( Domains.matchesList(client, sb.networkWhitelist) ) {\n            Log.logInfo(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \"\n                + client\n                + \" gets no search restrictions\");\n        } else if ( !authenticated && !localhostAccess && !intranetMode ) {\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\n            synchronized ( trackerHandles ) {\n                final int accInThreeSeconds =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\n                final int accInOneMinute =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\n                final int accInTenMinutes =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\n                // protections against too strong YaCy network load, reduces remote search\n                if ( global ) {\n                    if ( accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1 ) {\n                        global = false;\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed global search\");\n                    }\n                }\n                // protection against too many remote server snippet loads (protects traffic on server)\n                if ( snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ) {\n                    if ( accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1 ) {\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed remote snippet loading\");\n                    }\n                }\n                // general load protection\n                if ( accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60 ) {\n                    block = true;\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                        + client\n                        + \": \"\n                        + accInThreeSeconds\n                        + \"/3s, \"\n                        + accInOneMinute\n                        + \"/60s, \"\n                        + accInTenMinutes\n                        + \"/600s, \"\n                        + \" requests, disallowed search\");\n                }\n            }\n        }\n\n        if ( !block && (post == null || post.get(\"cat\", \"href\").equals(\"href\")) ) {\n            String urlmask = null;\n            String tld = null;\n            String inlink = null;\n\n            // check available memory and clean up if necessary\n            if ( !MemoryControl.request(8000000L, false) ) {\n                indexSegment.clearCache();\n                SearchEventCache.cleanupEvents(false);\n            }\n\n            final RankingProfile ranking = sb.getRanking();\n            final QueryModifier modifier = new QueryModifier();\n            querystring = modifier.parse(querystring);\n\n            // read collection\n            modifier.collection = post.get(\"collection\", \"\");\n            \n            int stp = querystring.indexOf('*');\n            if (stp >= 0) {\n                querystring = querystring.substring(0, stp) + Segment.catchallString + querystring.substring(stp + 1);\n            }\n            if ( querystring.indexOf(\"/near\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/near\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_worddistance = RankingProfile.COEFF_MAX;\n                modifier.add(\"/near\");\n            }\n            if ( querystring.indexOf(\"/date\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/date\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\n                modifier.add(\"/date\");\n            }\n\n            if ( querystring.indexOf(\"/location\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/location\", \"\");\n                if ( constraint == null ) {\n                    constraint = new Bitfield(4);\n                }\n                constraint.set(Condenser.flag_cat_haslocation, true);\n                modifier.add(\"/location\");\n            }\n\n            final int lrp = querystring.indexOf(\"/language/\", 0);\n            String language = \"\";\n            if ( lrp >= 0 ) {\n                if ( querystring.length() >= (lrp + 12) ) {\n                    language = querystring.substring(lrp + 10, lrp + 12);\n                }\n                querystring = querystring.replace(\"/language/\" + language, \"\");\n                language = language.toLowerCase();\n                modifier.add(\"/language/\" + language);\n            }\n\n            final int inurlp = querystring.indexOf(\"inurl:\", 0);\n            if ( inurlp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inurlp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                final String urlstr = querystring.substring(inurlp + 6, ftb);\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\n                if ( !urlstr.isEmpty() ) {\n                    urlmask = urlmask == null ? \".*\" + urlstr + \".*\" : urlmask + urlstr + \".*\";\n                }\n                modifier.add(\"inurl:\" + urlstr);\n            }\n\n            final int inlinkp = querystring.indexOf(\"inlink:\", 0);\n            if ( inlinkp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inlinkp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                inlink = querystring.substring(inlinkp + 7, ftb);\n                querystring = querystring.replace(\"inlink:\" + inlink, \"\");\n                modifier.add(\"inlink:\" + inlink);\n            }\n\n            int voc = 0;\n            Collection<Tagging.Metatag> metatags = new ArrayList<Tagging.Metatag>(1);\n            while ((voc = querystring.indexOf(\"/vocabulary/\", 0)) >= 0) {\n                String vocabulary = \"\";\n                int ve = querystring.indexOf(' ', voc + 12);\n                if (ve < 0) {\n                    vocabulary = querystring.substring(voc);\n                    querystring = querystring.substring(0, voc).trim();\n                } else {\n                    vocabulary = querystring.substring(voc, ve);\n                    querystring = querystring.substring(0, voc) + querystring.substring(ve);\n                }\n                modifier.add(vocabulary);\n                vocabulary = vocabulary.substring(12);\n                int p = vocabulary.indexOf('/');\n                if (p > 0) {\n                    String k = vocabulary.substring(0, p);\n                    String v = vocabulary.substring(p + 1);\n                    metatags.add(LibraryProvider.autotagging.metatag(k, v));\n                }\n            }\n\n            int radius = 0;\n            double lon = 0.0d, lat = 0.0d, rad = 0.0d;\n            if ((radius = querystring.indexOf(\"/radius/\")) >= 0) {\n                int ve = querystring.indexOf(' ', radius + 8);\n                String geo = \"\";\n                if (ve < 0) {\n                    geo = querystring.substring(radius);\n                    querystring = querystring.substring(0, radius).trim();\n                } else {\n                    geo = querystring.substring(radius, ve);\n                    querystring = querystring.substring(0, radius) + querystring.substring(ve);\n                }\n                geo = geo.substring(8);\n                String[] sp = geo.split(\"/\");\n                if (sp.length == 3) try {\n                    lat = Double.parseDouble(sp[0]);\n                    lon = Double.parseDouble(sp[1]);\n                    rad = Double.parseDouble(sp[2]);\n                } catch (NumberFormatException e) {\n                    lon = 0.0d; lat = 0.0d; rad = 0.0d;\n                }\n            }\n\n            final int heuristicBlekko = querystring.indexOf(\"/heuristic/blekko\", 0);\n            if ( heuristicBlekko >= 0 ) {\n                querystring = querystring.replace(\"/heuristic/blekko\", \"\");\n                modifier.add(\"/heuristic/blekko\");\n            }\n            \n            final int heuristicTwitter = querystring.indexOf(\"/heuristic/twitter\", 0);\n            if ( heuristicBlekko >= 0 ) {\n                querystring = querystring.replace(\"/heuristic/twitter\", \"\");\n                modifier.add(\"/heuristic/twitter\");\n            }\n\n            final int tldp = querystring.indexOf(\"tld:\", 0);\n            if (tldp >= 0) {\n                int ftb = querystring.indexOf(' ', tldp);\n                if (ftb == -1) ftb = querystring.length();\n                tld = querystring.substring(tldp + 4, ftb);\n                querystring = querystring.replace(\"tld:\" + tld, \"\");\n                modifier.add(\"tld:\" + tld);\n                while ( tld.length() > 0 && tld.charAt(0) == '.' ) {\n                    tld = tld.substring(1);\n                }\n                if (tld.length() == 0) tld = null;\n            }\n            if (urlmask == null || urlmask.isEmpty()) urlmask = \".*\"; //if no urlmask was given\n\n            // read the language from the language-restrict option 'lr'\n            // if no one is given, use the user agent or the system language as default\n            language = (post == null) ? language : post.get(\"lr\", language);\n            if ( language.startsWith(\"lang_\") ) {\n                language = language.substring(5);\n            }\n            if ( !ISO639.exists(language) ) {\n                // find out language of the user by reading of the user-agent string\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\n                if ( agent == null ) {\n                    agent = System.getProperty(\"user.language\");\n                }\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\n                if ( language == null ) {\n                    language = \"en\";\n                }\n            }\n\n            // the query\n            final QueryGoal qg = new QueryGoal(originalquerystring, querystring.trim());\n            final int maxDistance = (querystring.indexOf('\"', 0) >= 0) ? qg.getAllHashes().size() - 1 : Integer.MAX_VALUE;\n\n            // filter out stopwords\n            final SortedSet<String> filtered = SetTools.joinConstructiveByTest(qg.getIncludeStrings(), Switchboard.stopwords); //find matching stopwords\n            if ( !filtered.isEmpty() ) {\n                SetTools.excludeDestructiveByTestSmallInLarge(qg.getIncludeStrings(), filtered); //remove stopwords\n            }\n\n            // if a minus-button was hit, remove a special reference first\n            if ( post != null && post.containsKey(\"deleteref\") ) {\n                try {\n                    if ( !sb.verifyAuthentication(header) ) {\n                    \tprop.authenticationRequired();\n                        return prop;\n                    }\n\n                    // delete the index entry locally\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\n                    if (indexSegment.termIndex() != null) indexSegment.termIndex().remove(qg.getIncludeHashes(), delHash.getBytes());\n\n                    // make new news message with negative voting\n                    if ( !sb.isRobinsonMode() ) {\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"urlhash\", delHash);\n                        map.put(\"vote\", \"negative\");\n                        map.put(\"refid\", \"\");\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_VOTE_ADD,\n                            map);\n                    }\n\n                    // delete the search history since this still shows the entry\n                    SearchEventCache.delete(delHash);\n                } catch ( final IOException e ) {\n                    Log.logException(e);\n                }\n            }\n\n            // if a plus-button was hit, create new voting message\n            if ( post != null && post.containsKey(\"recommendref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\n                final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(recommendHash));\n                if ( urlentry != null ) {\n                    Document[] documents = null;\n                    try {\n                        documents =\n                            sb.loader.loadDocuments(\n                                sb.loader.request(urlentry.url(), true, false),\n                                CacheStrategy.IFEXIST,\n                                Integer.MAX_VALUE, BlacklistType.SEARCH, TextSnippet.snippetMinLoadDelay, ClientIdentification.DEFAULT_TIMEOUT);\n                    } catch ( final IOException e ) {\n                    } catch ( final Parser.Failure e ) {\n                    }\n                    if ( documents != null ) {\n                        // create a news message\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"url\", urlentry.url().toNormalform(true).replace(',', '|'));\n                        map.put(\"title\", urlentry.dc_title().replace(',', ' '));\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\n                        map.put(\"author\", documents[0].dc_creator());\n                        map.put(\"tags\", documents[0].dc_subject(' '));\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_ADD,\n                            map);\n                        documents[0].close();\n                    }\n                }\n            }\n\n            // if a bookmarks-button was hit, create new bookmark entry\n            if ( post != null && post.containsKey(\"bookmarkref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                final String bookmarkHash = post.get(\"bookmarkref\", \"\"); // urlhash\n                final DigestURI url = indexSegment.fulltext().getURL(UTF8.getBytes(bookmarkHash));\n                if ( url != null ) {\n                    try {\n                        sb.tables.bookmarks.createBookmark(\n                            sb.loader,\n                            url,\n                            YMarkTables.USER_ADMIN,\n                            true,\n                            \"searchresult\",\n                            \"/search\");\n                    } catch ( final Throwable e ) {\n                    }\n                }\n            }\n\n            // check filters\n            try {\n                Pattern.compile(urlmask);\n            } catch ( final PatternSyntaxException ex ) {\n                SearchEvent.log.logWarning(\"Illegal URL mask, not a valid regex: \" + urlmask);\n                prop.put(\"urlmaskerror\", 1);\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\n                urlmask = \".*\";\n            }\n\n            try {\n                Pattern.compile(prefermask);\n            } catch ( final PatternSyntaxException ex ) {\n                SearchEvent.log.logWarning(\"Illegal prefer mask, not a valid regex: \" + prefermask);\n                prop.put(\"prefermaskerror\", 1);\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\n                prefermask = \"\";\n            }\n\n            // do the search\n            final QueryParams theQuery =\n                new QueryParams(\n                    qg,\n                    modifier,\n                    maxDistance,\n                    prefermask,\n                    contentdom,\n                    language,\n                    metatags,\n                    snippetFetchStrategy,\n                    itemsPerPage,\n                    startRecord,\n                    urlmask, tld, inlink,\n                    clustersearch && global ? QueryParams.Searchdom.CLUSTER : (global && indexReceiveGranted\n                        ? QueryParams.Searchdom.GLOBAL\n                        : QueryParams.Searchdom.LOCAL),\n                    20,\n                    constraint,\n                    true,\n                    DigestURI.hosthashess(sb.getConfig(\"search.excludehosth\", \"\")),\n                    DigestURI.TLD_any_zone_filter,\n                    client,\n                    authenticated,\n                    indexSegment,\n                    ranking,\n                    header.get(RequestHeader.USER_AGENT, \"\"),\n                    sb.getConfigBool(SwitchboardConstants.SEARCH_VERIFY_DELETE, false)\n                        && sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false)\n                        && sb.peers.mySeed().getFlagAcceptRemoteIndex(),\n                    false,\n                    lat, lon, rad);\n            EventTracker.delete(EventTracker.EClass.SEARCH);\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(\n                theQuery.id(true),\n                SearchEventType.INITIALIZATION,\n                \"\",\n                0,\n                0), false);\n\n            // tell all threads to do nothing for a specific time\n            sb.intermissionAllThreads(3000);\n\n            // filter out words that appear in bluelist\n            theQuery.getQueryGoal().filterOut(Switchboard.blueList);\n\n            // log\n            Log.logInfo(\n                \"LOCAL_SEARCH\",\n                \"INIT WORD SEARCH: \"\n                    + theQuery.getQueryGoal().getOriginalQueryString(false)\n                    + \":\"\n                    + QueryParams.hashSet2hashString(theQuery.getQueryGoal().getIncludeHashes())\n                    + \" - \"\n                    + theQuery.neededResults()\n                    + \" links to be computed, \"\n                    + theQuery.itemsPerPage()\n                    + \" lines to be displayed\");\n            EventChannel.channels(EventChannel.LOCALSEARCH).addMessage(\n                new RSSMessage(\"Local Search Request\", theQuery.getQueryGoal().getOriginalQueryString(false), \"\"));\n            final long timestamp = System.currentTimeMillis();\n\n            // create a new search event\n            if ( SearchEventCache.getEvent(theQuery.id(false)) == null ) {\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\n                startRecord = 0;\n            }\n            final SearchEvent theSearch =\n                SearchEventCache.getEvent(\n                    theQuery,\n                    sb.peers,\n                    sb.tables,\n                    (sb.isRobinsonMode()) ? sb.clusterhashes : null,\n                    false,\n                    sb.loader,\n                    (int) sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\n                    sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXTIME_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)),\n                    (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_ROBINSON, 0),\n                    (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_MULTIWORD, 0));\n\n            if ( startRecord == 0 ) {\n                if ( modifier.sitehost != null && sb.getConfigBool(\"heuristic.site\", false) && authenticated ) {\n                    sb.heuristicSite(theSearch, modifier.sitehost);\n                }\n                if ( (heuristicBlekko >= 0 || sb.getConfigBool(\"heuristic.blekko\", false)) && authenticated ) {\n                    sb.heuristicRSS(\"http://blekko.com/ws/$+/rss\", theSearch, \"blekko\");\n                }\n                if ( (heuristicTwitter >= 0 || sb.getConfigBool(\"heuristic.twitter\", false)) && authenticated ) {\n                    sb.heuristicRSS(\"http://search.twitter.com/search.rss?rpp=50&q=$\", theSearch, \"twitter\");\n                }\n                if (sb.getConfigBool(\"heuristic.opensearch\", false) && authenticated) {\n                    OpenSearchConnector.query(sb, theSearch);\n                }\n            }\n\n            // log\n            Log.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \"\n                + theQuery.getQueryGoal().getOriginalQueryString(false)\n                + \" - \"\n                + \"local_rwi_available(\" + theSearch.local_rwi_available.get() + \"), \"\n                + \"local_rwi_stored(\" + theSearch.local_rwi_stored.get() + \"), \"\n                + \"remote_rwi_available(\" + theSearch.remote_rwi_available.get() + \"), \"\n                + \"remote_rwi_stored(\" + theSearch.remote_rwi_stored.get() + \"), \"\n                + \"remote_rwi_peerCount(\" + theSearch.remote_rwi_peerCount.get() + \"), \"\n                + \"local_solr_available(\" + theSearch.local_solr_available.get() + \"), \"\n                + \"local_solr_stored(\" + theSearch.local_solr_stored.get() + \"), \"\n                + \"remote_solr_available(\" + theSearch.remote_solr_available.get() + \"), \"\n                + \"remote_solr_stored(\" + theSearch.remote_solr_stored.get() + \"), \"\n                + \"remote_solr_peerCount(\" + theSearch.remote_solr_peerCount.get() + \"), \"\n                + (System.currentTimeMillis() - timestamp)\n                + \" ms\");\n\n            // prepare search statistics\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\n            AccessTracker.add(AccessTracker.Location.local, theQuery, theSearch.getResultCount());\n\n            // check suggestions\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\n\n            prop.put(\"meanCount\", meanMax);\n            if ( meanMax > 0 && !json && !rss && sb.index.connectedRWI()) {\n                final DidYouMean didYouMean = new DidYouMean(indexSegment, new StringBuilder(querystring));\n                final Iterator<StringBuilder> meanIt = didYouMean.getSuggestions(100, 5).iterator();\n                int meanCount = 0;\n                String suggestion;\n                try {\n                    meanCollect: while ( meanCount < meanMax && meanIt.hasNext() ) {\n                        try {\n                            suggestion = meanIt.next().toString();\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_word\", suggestion);\n                            prop.put(\n                                \"didYouMean_suggestions_\" + meanCount + \"_url\",\n                                QueryParams.navurl(\n                                    \"html\",\n                                    0,\n                                    theQuery,\n                                    suggestion).toString());\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_sep\", \"|\");\n                            meanCount++;\n                        } catch (ConcurrentModificationException e) {break meanCollect;}\n                    }\n                } catch (ConcurrentModificationException e) {}\n                prop.put(\"didYouMean_suggestions_\" + (meanCount - 1) + \"_sep\", \"\");\n                prop.put(\"didYouMean\", meanCount > 0 ? 1 : 0);\n                prop.put(\"didYouMean_suggestions\", meanCount);\n            } else {\n                prop.put(\"didYouMean\", 0);\n            }\n\n            // find geographic info\n            final SortedSet<GeoLocation> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\n            if ( coordinates == null || coordinates.isEmpty() || startRecord > 0 ) {\n                prop.put(\"geoinfo\", \"0\");\n            } else {\n                int i = 0;\n                for ( final GeoLocation c : coordinates ) {\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\n                    i++;\n                    if ( i >= 10 ) {\n                        break;\n                    }\n                }\n                prop.put(\"geoinfo_loc\", i);\n                prop.put(\"geoinfo\", \"1\");\n            }\n\n            // update the search tracker\n            try {\n                synchronized ( trackerHandles ) {\n                    trackerHandles.add(theQuery.starttime);\n                    while ( trackerHandles.size() > 600 ) {\n                        if ( !trackerHandles.remove(trackerHandles.first()) ) {\n                            break;\n                        }\n                    }\n                }\n                sb.localSearchTracker.put(client, trackerHandles);\n                if ( sb.localSearchTracker.size() > 100 ) {\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\n                }\n                if ( MemoryControl.shortStatus() ) {\n                    sb.localSearchTracker.clear();\n                }\n            } catch ( final Exception e ) {\n                Log.logException(e);\n            }\n\n            prop.put(\"num-results_offset\", startRecord == 0 ? 0 : startRecord + 1);\n            prop.put(\"num-results_itemscount\", Formatter.number(startRecord + theSearch.query.itemsPerPage > theSearch.getResultCount() ? startRecord + theSearch.getResultCount() % theSearch.query.itemsPerPage : startRecord + theSearch.query.itemsPerPage, true));\n            prop.put(\"num-results_itemsPerPage\", Formatter.number(itemsPerPage));\n            prop.put(\"num-results_totalcount\", Formatter.number(theSearch.getResultCount()));\n            prop.put(\"num-results_globalresults\", global && (indexReceiveGranted || clustersearch) ? \"1\" : \"0\");\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n\n            // compose page navigation\n            final StringBuilder resnav = new StringBuilder(200);\n            final int thispage = startRecord / theQuery.itemsPerPage();\n            if ( thispage == 0 ) {\n                resnav\n                    .append(\"<img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\n            } else {\n                resnav.append(\"<a id=\\\"prevpage\\\" href=\\\"\");\n                resnav.append(QueryParams.navurl(\"html\", thispage - 1, theQuery, null).toString());\n                resnav\n                    .append(\"\\\"><img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\n            }\n            final int numberofpages = Math.min(10, 1 + ((theSearch.getResultCount() - 1) / theQuery.itemsPerPage()));\n\n            for ( int i = 0; i < numberofpages; i++ ) {\n                if ( i == thispage ) {\n                    resnav.append(\"<img src=\\\"env/grafics/navs\");\n                    resnav.append(i + 1);\n                    resnav.append(\".gif\\\" alt=\\\"page\");\n                    resnav.append(i + 1);\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\n                } else {\n                    resnav.append(\"<a href=\\\"\");\n                    resnav.append(QueryParams.navurl(\"html\", i, theQuery, null).toString());\n                    resnav.append(\"\\\"><img src=\\\"env/grafics/navd\");\n                    resnav.append(i + 1);\n                    resnav.append(\".gif\\\" alt=\\\"page\");\n                    resnav.append(i + 1);\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\n                }\n            }\n            if ( thispage >= numberofpages ) {\n                resnav\n                    .append(\"<img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" />\");\n            } else {\n                resnav.append(\"<a id=\\\"nextpage\\\" href=\\\"\");\n                resnav.append(QueryParams.navurl(\"html\", thispage + 1, theQuery, null).toString());\n                resnav.append(\"\\\"><img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>\");\n            }\n            final String resnavs = resnav.toString();\n            prop.put(\"num-results_resnav\", resnavs);\n            prop.put(\"pageNavBottom\", (theSearch.getResultCount() - startRecord > 6) ? 1 : 0); // if there are more results than may fit on the page we add a navigation at the bottom\n            prop.put(\"pageNavBottom_resnav\", resnavs);\n\n            // generate the search result lines; the content will be produced by another servlet\n            for ( int i = 0; i < theQuery.itemsPerPage(); i++ ) {\n                prop.put(\"results_\" + i + \"_item\", startRecord + i);\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\n            }\n            prop.put(\"results\", theQuery.itemsPerPage());\n            prop\n                .put(\n                    \"resultTable\",\n                    (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO)\n                        ? 1\n                        : 0);\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\n\n            // process result of search\n            if ( !filtered.isEmpty() ) {\n                prop.put(\"excluded\", \"1\");\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\n            } else {\n                prop.put(\"excluded\", \"0\");\n            }\n\n            if ( prop == null || prop.isEmpty() ) {\n                if ( post.get(\"query\", post.get(\"search\", \"\")).length() < 2 ) {\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\n                } else {\n                    prop.put(\"num-results\", \"1\"); // no results\n                }\n            } else {\n                prop.put(\"num-results\", \"3\");\n            }\n\n            prop.put(\"cat\", \"href\");\n            prop.put(\"depth\", \"0\");\n\n        }\n\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\n        prop.putHTML(\"former\", originalquerystring);\n        prop.put(\"count\", itemsPerPage);\n        prop.put(\"offset\", startRecord);\n        prop.put(\"resource\", global ? \"global\" : \"local\");\n        prop.putHTML(\"prefermaskfilter\", prefermask);\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\n        prop.put(\"search.verify\", snippetFetchStrategy == null\n            ? sb.getConfig(\"search.verify\", \"iffresh\")\n            : snippetFetchStrategy.toName());\n        prop.put(\n            \"search.navigation\",\n            (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n        prop.put(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\n        prop.put(\n            \"searchdomswitches\",\n            sb.getConfigBool(\"search.text\", true)\n                || sb.getConfigBool(\"search.audio\", true)\n                || sb.getConfigBool(\"search.video\", true)\n                || sb.getConfigBool(\"search.image\", true)\n                || sb.getConfigBool(\"search.app\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchtext_check\", (contentdom == ContentDomain.TEXT || contentdom == ContentDomain.ALL) ? \"1\" : \"0\");\n        prop.put(\"searchdomswitches_searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\n        prop.put(\"searchdomswitches_searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\n        prop.put(\"searchdomswitches_searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\n        prop.put(\"searchdomswitches_searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\n\n        // copy properties for \"more options\" link\n        prop.put(\"searchdomswitches_count\", prop.get(\"count\"));\n        prop.put(\"searchdomswitches_urlmaskfilter\", prop.get(\"urlmaskfilter\"));\n        prop.put(\"searchdomswitches_prefermaskfilter\", prop.get(\"prefermaskfilter\"));\n        prop.put(\"searchdomswitches_cat\", prop.get(\"cat\"));\n        prop.put(\"searchdomswitches_constraint\", prop.get(\"constraint\"));\n        prop.put(\"searchdomswitches_contentdom\", prop.get(\"contentdom\"));\n        prop.put(\"searchdomswitches_former\", prop.get(\"former\"));\n        prop.put(\"searchdomswitches_meanCount\", prop.get(\"meanCount\"));\n\n        // for RSS: don't HTML encode some elements\n        prop.putXML(\"rss_query\", originalquerystring);\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\n\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        // hostname and port (assume locahost if nothing helps)\n        final InetAddress hostIP = Domains.myPublicLocalIP();\n        prop.put(\"myhost\", hostIP != null ? hostIP.getHostAddress() : Domains.LOCALHOST);\n        prop.put(\"myport\", serverCore.getPortNr(sb.getConfig(\"port\", \"8090\")));\n\n        // return rewrite properties\n        return prop;\n    }","id":76353,"modified_method":"public static serverObjects respond(\n        final RequestHeader header,\n        final serverObjects post,\n        final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        final boolean searchAllowed =\n            sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header);\n\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        if ( !authenticated ) {\n            final UserDB.Entry user = sb.userDB.getUser(header);\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\n        }\n        final boolean localhostAccess = header.accessFromLocalhost();\n        final String promoteSearchPageGreeting =\n            (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ? env.getConfig(\n                \"network.unit.description\",\n                \"\") : env.getConfig(SwitchboardConstants.GREETING, \"\");\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\n        \n        // get query\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\n        String querystring = originalquerystring.replace('+', ' ').trim();\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", sb.getConfig(\"search.verify\", \"\")));\n        \n        final servletProperties prop = new servletProperties();\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n\n        //get focus option\n        prop.put(\"focus\", ((post == null) ? true : post.get(\"focus\", \"1\").equals(\"1\")) ? 1 : 0);\n\n        // produce vocabulary navigation sidebars\n        Collection<Tagging> vocabularies = LibraryProvider.autotagging.getVocabularies();\n        int j = 0;\n        for (Tagging v: vocabularies) {\n            prop.put(\"sidebarVocabulary_\" + j + \"_vocabulary\", v.getName());\n            j++;\n        }\n        prop.put(\"sidebarVocabulary\", j);\n\n        // get segment\n        Segment indexSegment = sb.index;\n\n        final String EXT = header.get(\"EXT\", \"\");\n        final boolean rss = EXT.equals(\"rss\");\n        final boolean json = EXT.equals(\"json\");\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\n        \n        // adding some additional properties needed for the rss feed\n        String hostName = header.get(\"Host\", Domains.LOCALHOST);\n        if ( hostName.indexOf(':', 0) == -1 ) {\n            hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8090\"));\n        }\n        prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\n        prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\n        prop.put(\"thisaddress\", hostName);\n        final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n        final boolean indexReceiveGranted =\n            sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true)\n                || sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true)\n                || clustersearch;\n        boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n        boolean global = post == null || (post.get(\"resource\", \"local\").equals(\"global\") && p2pmode);\n        boolean stealthmode = p2pmode && !global;\n        prop.put(\"topmenu_resource-select\", stealthmode ? 2 : global ? 1 : 0);\n        \n        if ( post == null || indexSegment == null || env == null || !searchAllowed ) {\n            if (indexSegment == null) Log.logInfo(\"yacysearch\", \"indexSegment == null\");\n            // we create empty entries for template strings\n            prop.put(\"searchagain\", \"0\");\n            prop.put(\"former\", \"\");\n            prop.put(\"count\", \"10\");\n            prop.put(\"offset\", \"0\");\n            prop.put(\"resource\", \"global\");\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\n            prop.put(\"tenant\", (post == null) ? \"\" : post.get(\"tenant\", \"\"));\n            prop.put(\"indexof\", \"off\");\n            prop.put(\"constraint\", \"\");\n            prop.put(\"cat\", \"href\");\n            prop.put(\"depth\", \"0\");\n            prop.put(\n                \"search.verify\",\n                (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\n            prop.put(\n                \"search.navigation\",\n                (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n            prop.put(\"contentdom\", \"text\");\n            prop.put(\"contentdomCheckText\", \"1\");\n            prop.put(\"contentdomCheckAudio\", \"0\");\n            prop.put(\"contentdomCheckVideo\", \"0\");\n            prop.put(\"contentdomCheckImage\", \"0\");\n            prop.put(\"contentdomCheckApp\", \"0\");\n            prop.put(\"excluded\", \"0\");\n            prop.put(\"results\", \"\");\n            prop.put(\"resultTable\", \"0\");\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\n            prop.put(\"num-results_totalcount\", 0);\n            prop.put(\"num-results_offset\", 0);\n            prop.put(\"num-results_itemsPerPage\", 10);\n            prop.put(\"geoinfo\", \"0\");\n            prop.put(\"rss_queryenc\", \"\");\n            prop.put(\"meanCount\", 5);\n            return prop;\n        }\n\n        // check for JSONP\n        if ( post.containsKey(\"callback\") ) {\n            final String jsonp = post.get(\"callback\") + \"([\";\n            prop.put(\"jsonp-start\", jsonp);\n            prop.put(\"jsonp-end\", \"])\");\n        } else {\n            prop.put(\"jsonp-start\", \"\");\n            prop.put(\"jsonp-end\", \"\");\n        }\n\n        // Adding CORS Access header for yacysearch.rss output\n        if ( rss ) {\n            final ResponseHeader outgoingHeader = new ResponseHeader(200);\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\n            prop.setOutgoingHeader(outgoingHeader);\n        }\n\n        // collect search attributes\n\n        int itemsPerPage =\n            Math.min(\n                (authenticated)\n                    ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()\n                        ? 100\n                        : 5000) : (snippetFetchStrategy != null\n                        && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000),\n                post.getInt(\"maximumRecords\", post.getInt(\"count\", post.getInt(\"rows\", 10)))); // SRU syntax with old property as alternative\n        int startRecord = post.getInt(\"startRecord\", post.getInt(\"offset\", post.getInt(\"start\", 0)));\n\n        final boolean indexof = (post != null && post.get(\"indexof\", \"\").equals(\"on\"));\n\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\n        if ( !prefermask.isEmpty() && prefermask.indexOf(\".*\", 0) < 0 ) {\n            prefermask = \".*\" + prefermask + \".*\";\n        }\n\n        Bitfield constraint =\n            (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty())\n                ? new Bitfield(4, post.get(\"constraint\", \"______\"))\n                : null;\n        if ( indexof ) {\n            constraint = new Bitfield(4);\n            constraint.set(Condenser.flag_cat_indexof, true);\n        }\n\n        // SEARCH\n        final boolean intranetMode = sb.isIntranetMode() || sb.isAllIPMode();\n\n        // increase search statistic counter\n        if ( !global ) {\n            // we count only searches on the local peer here, because global searches\n            // are counted on the target peer to preserve privacy of the searcher\n            if ( authenticated ) {\n                // local or authenticated search requests are counted separately\n                // because they are not part of a public available peer statistic\n                sb.searchQueriesRobinsonFromLocal++;\n            } else {\n                // robinson-searches from non-authenticated requests are public\n                // and may be part of the public available statistic\n                sb.searchQueriesRobinsonFromRemote++;\n            }\n        }\n\n        // find search domain\n        final Classification.ContentDomain contentdom =\n            ContentDomain.contentdomParser(post == null ? \"all\" : post.get(\"contentdom\", \"all\"));\n\n        // patch until better search profiles are available\n        if (contentdom == ContentDomain.IMAGE && (itemsPerPage == 10 || itemsPerPage == 100)) {\n            itemsPerPage = 64;\n        } else if ( contentdom != ContentDomain.IMAGE && itemsPerPage > 50 && itemsPerPage < 100 ) {\n            itemsPerPage = 10;\n        }\n\n        // check the search tracker\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\n        if ( trackerHandles == null ) {\n            trackerHandles = new TreeSet<Long>();\n        }\n        boolean block = false;\n        if ( Domains.matchesList(client, sb.networkBlacklist) ) {\n            global = false;\n            if ( snippetFetchStrategy != null ) {\n                snippetFetchStrategy = null;\n            }\n            block = true;\n            Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \"\n                + client\n                + \" gets no permission to search\");\n        } else if ( Domains.matchesList(client, sb.networkWhitelist) ) {\n            Log.logInfo(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \"\n                + client\n                + \" gets no search restrictions\");\n        } else if ( !authenticated && !localhostAccess && !intranetMode ) {\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\n            synchronized ( trackerHandles ) {\n                final int accInThreeSeconds =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\n                final int accInOneMinute =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\n                final int accInTenMinutes =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\n                // protections against too strong YaCy network load, reduces remote search\n                if ( global ) {\n                    if ( accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1 ) {\n                        global = false;\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed global search\");\n                    }\n                }\n                // protection against too many remote server snippet loads (protects traffic on server)\n                if ( snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ) {\n                    if ( accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1 ) {\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed remote snippet loading\");\n                    }\n                }\n                // general load protection\n                if ( accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60 ) {\n                    block = true;\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                        + client\n                        + \": \"\n                        + accInThreeSeconds\n                        + \"/3s, \"\n                        + accInOneMinute\n                        + \"/60s, \"\n                        + accInTenMinutes\n                        + \"/600s, \"\n                        + \" requests, disallowed search\");\n                }\n            }\n        }\n\n        if ( !block && (post == null || post.get(\"cat\", \"href\").equals(\"href\")) ) {\n            String urlmask = null;\n            String tld = null;\n            String inlink = null;\n\n            // check available memory and clean up if necessary\n            if ( !MemoryControl.request(8000000L, false) ) {\n                indexSegment.clearCache();\n                SearchEventCache.cleanupEvents(false);\n            }\n\n            final RankingProfile ranking = sb.getRanking();\n            final QueryModifier modifier = new QueryModifier();\n            querystring = modifier.parse(querystring);\n\n            // read collection\n            modifier.collection = post.get(\"collection\", \"\");\n            \n            int stp = querystring.indexOf('*');\n            if (stp >= 0) {\n                querystring = querystring.substring(0, stp) + Segment.catchallString + querystring.substring(stp + 1);\n            }\n            if ( querystring.indexOf(\"/near\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/near\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_worddistance = RankingProfile.COEFF_MAX;\n                modifier.add(\"/near\");\n            }\n            if ( querystring.indexOf(\"/date\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/date\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\n                modifier.add(\"/date\");\n            }\n\n            if ( querystring.indexOf(\"/location\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/location\", \"\");\n                if ( constraint == null ) {\n                    constraint = new Bitfield(4);\n                }\n                constraint.set(Condenser.flag_cat_haslocation, true);\n                modifier.add(\"/location\");\n            }\n\n            final int lrp = querystring.indexOf(\"/language/\", 0);\n            String language = \"\";\n            if ( lrp >= 0 ) {\n                if ( querystring.length() >= (lrp + 12) ) {\n                    language = querystring.substring(lrp + 10, lrp + 12);\n                }\n                querystring = querystring.replace(\"/language/\" + language, \"\");\n                language = language.toLowerCase();\n                modifier.add(\"/language/\" + language);\n            }\n\n            final int inurlp = querystring.indexOf(\"inurl:\", 0);\n            if ( inurlp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inurlp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                final String urlstr = querystring.substring(inurlp + 6, ftb);\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\n                if ( !urlstr.isEmpty() ) {\n                    urlmask = urlmask == null ? \".*\" + urlstr + \".*\" : urlmask + urlstr + \".*\";\n                }\n                modifier.add(\"inurl:\" + urlstr);\n            }\n\n            final int inlinkp = querystring.indexOf(\"inlink:\", 0);\n            if ( inlinkp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inlinkp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                inlink = querystring.substring(inlinkp + 7, ftb);\n                querystring = querystring.replace(\"inlink:\" + inlink, \"\");\n                modifier.add(\"inlink:\" + inlink);\n            }\n\n            int voc = 0;\n            Collection<Tagging.Metatag> metatags = new ArrayList<Tagging.Metatag>(1);\n            while ((voc = querystring.indexOf(\"/vocabulary/\", 0)) >= 0) {\n                String vocabulary = \"\";\n                int ve = querystring.indexOf(' ', voc + 12);\n                if (ve < 0) {\n                    vocabulary = querystring.substring(voc);\n                    querystring = querystring.substring(0, voc).trim();\n                } else {\n                    vocabulary = querystring.substring(voc, ve);\n                    querystring = querystring.substring(0, voc) + querystring.substring(ve);\n                }\n                modifier.add(vocabulary);\n                vocabulary = vocabulary.substring(12);\n                int p = vocabulary.indexOf('/');\n                if (p > 0) {\n                    String k = vocabulary.substring(0, p);\n                    String v = vocabulary.substring(p + 1);\n                    metatags.add(LibraryProvider.autotagging.metatag(k, v));\n                }\n            }\n\n            int radius = 0;\n            double lon = 0.0d, lat = 0.0d, rad = 0.0d;\n            if ((radius = querystring.indexOf(\"/radius/\")) >= 0) {\n                int ve = querystring.indexOf(' ', radius + 8);\n                String geo = \"\";\n                if (ve < 0) {\n                    geo = querystring.substring(radius);\n                    querystring = querystring.substring(0, radius).trim();\n                } else {\n                    geo = querystring.substring(radius, ve);\n                    querystring = querystring.substring(0, radius) + querystring.substring(ve);\n                }\n                geo = geo.substring(8);\n                String[] sp = geo.split(\"/\");\n                if (sp.length == 3) try {\n                    lat = Double.parseDouble(sp[0]);\n                    lon = Double.parseDouble(sp[1]);\n                    rad = Double.parseDouble(sp[2]);\n                } catch (NumberFormatException e) {\n                    lon = 0.0d; lat = 0.0d; rad = 0.0d;\n                }\n            }\n\n            final int heuristicBlekko = querystring.indexOf(\"/heuristic/blekko\", 0);\n            if ( heuristicBlekko >= 0 ) {\n                querystring = querystring.replace(\"/heuristic/blekko\", \"\");\n                modifier.add(\"/heuristic/blekko\");\n            }\n            \n            final int heuristicTwitter = querystring.indexOf(\"/heuristic/twitter\", 0);\n            if ( heuristicTwitter >= 0 ) {\n                querystring = querystring.replace(\"/heuristic/twitter\", \"\");\n                modifier.add(\"/heuristic/twitter\");\n            }\n\n            final int tldp = querystring.indexOf(\"tld:\", 0);\n            if (tldp >= 0) {\n                int ftb = querystring.indexOf(' ', tldp);\n                if (ftb == -1) ftb = querystring.length();\n                tld = querystring.substring(tldp + 4, ftb);\n                querystring = querystring.replace(\"tld:\" + tld, \"\");\n                modifier.add(\"tld:\" + tld);\n                while ( tld.length() > 0 && tld.charAt(0) == '.' ) {\n                    tld = tld.substring(1);\n                }\n                if (tld.length() == 0) tld = null;\n            }\n            if (urlmask == null || urlmask.isEmpty()) urlmask = \".*\"; //if no urlmask was given\n\n            // read the language from the language-restrict option 'lr'\n            // if no one is given, use the user agent or the system language as default\n            language = (post == null) ? language : post.get(\"lr\", language);\n            if ( language.startsWith(\"lang_\") ) {\n                language = language.substring(5);\n            }\n            if ( !ISO639.exists(language) ) {\n                // find out language of the user by reading of the user-agent string\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\n                if ( agent == null ) {\n                    agent = System.getProperty(\"user.language\");\n                }\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\n                if ( language == null ) {\n                    language = \"en\";\n                }\n            }\n\n            // the query\n            final QueryGoal qg = new QueryGoal(originalquerystring, querystring.trim());\n            final int maxDistance = (querystring.indexOf('\"', 0) >= 0) ? qg.getAllHashes().size() - 1 : Integer.MAX_VALUE;\n\n            // filter out stopwords\n            final SortedSet<String> filtered = SetTools.joinConstructiveByTest(qg.getIncludeStrings(), Switchboard.stopwords); //find matching stopwords\n            if ( !filtered.isEmpty() ) {\n                SetTools.excludeDestructiveByTestSmallInLarge(qg.getIncludeStrings(), filtered); //remove stopwords\n            }\n\n            // if a minus-button was hit, remove a special reference first\n            if ( post != null && post.containsKey(\"deleteref\") ) {\n                try {\n                    if ( !sb.verifyAuthentication(header) ) {\n                    \tprop.authenticationRequired();\n                        return prop;\n                    }\n\n                    // delete the index entry locally\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\n                    if (indexSegment.termIndex() != null) indexSegment.termIndex().remove(qg.getIncludeHashes(), delHash.getBytes());\n\n                    // make new news message with negative voting\n                    if ( !sb.isRobinsonMode() ) {\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"urlhash\", delHash);\n                        map.put(\"vote\", \"negative\");\n                        map.put(\"refid\", \"\");\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_VOTE_ADD,\n                            map);\n                    }\n\n                    // delete the search history since this still shows the entry\n                    SearchEventCache.delete(delHash);\n                } catch ( final IOException e ) {\n                    Log.logException(e);\n                }\n            }\n\n            // if a plus-button was hit, create new voting message\n            if ( post != null && post.containsKey(\"recommendref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\n                final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(recommendHash));\n                if ( urlentry != null ) {\n                    Document[] documents = null;\n                    try {\n                        documents =\n                            sb.loader.loadDocuments(\n                                sb.loader.request(urlentry.url(), true, false),\n                                CacheStrategy.IFEXIST,\n                                Integer.MAX_VALUE, BlacklistType.SEARCH, TextSnippet.snippetMinLoadDelay, ClientIdentification.DEFAULT_TIMEOUT);\n                    } catch ( final IOException e ) {\n                    } catch ( final Parser.Failure e ) {\n                    }\n                    if ( documents != null ) {\n                        // create a news message\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"url\", urlentry.url().toNormalform(true).replace(',', '|'));\n                        map.put(\"title\", urlentry.dc_title().replace(',', ' '));\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\n                        map.put(\"author\", documents[0].dc_creator());\n                        map.put(\"tags\", documents[0].dc_subject(' '));\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_ADD,\n                            map);\n                        documents[0].close();\n                    }\n                }\n            }\n\n            // if a bookmarks-button was hit, create new bookmark entry\n            if ( post != null && post.containsKey(\"bookmarkref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                final String bookmarkHash = post.get(\"bookmarkref\", \"\"); // urlhash\n                final DigestURI url = indexSegment.fulltext().getURL(UTF8.getBytes(bookmarkHash));\n                if ( url != null ) {\n                    try {\n                        sb.tables.bookmarks.createBookmark(\n                            sb.loader,\n                            url,\n                            YMarkTables.USER_ADMIN,\n                            true,\n                            \"searchresult\",\n                            \"/search\");\n                    } catch ( final Throwable e ) {\n                    }\n                }\n            }\n\n            // check filters\n            try {\n                Pattern.compile(urlmask);\n            } catch ( final PatternSyntaxException ex ) {\n                SearchEvent.log.logWarning(\"Illegal URL mask, not a valid regex: \" + urlmask);\n                prop.put(\"urlmaskerror\", 1);\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\n                urlmask = \".*\";\n            }\n\n            try {\n                Pattern.compile(prefermask);\n            } catch ( final PatternSyntaxException ex ) {\n                SearchEvent.log.logWarning(\"Illegal prefer mask, not a valid regex: \" + prefermask);\n                prop.put(\"prefermaskerror\", 1);\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\n                prefermask = \"\";\n            }\n\n            // do the search\n            final QueryParams theQuery =\n                new QueryParams(\n                    qg,\n                    modifier,\n                    maxDistance,\n                    prefermask,\n                    contentdom,\n                    language,\n                    metatags,\n                    snippetFetchStrategy,\n                    itemsPerPage,\n                    startRecord,\n                    urlmask, tld, inlink,\n                    clustersearch && global ? QueryParams.Searchdom.CLUSTER : (global && indexReceiveGranted\n                        ? QueryParams.Searchdom.GLOBAL\n                        : QueryParams.Searchdom.LOCAL),\n                    20,\n                    constraint,\n                    true,\n                    DigestURI.hosthashess(sb.getConfig(\"search.excludehosth\", \"\")),\n                    DigestURI.TLD_any_zone_filter,\n                    client,\n                    authenticated,\n                    indexSegment,\n                    ranking,\n                    header.get(RequestHeader.USER_AGENT, \"\"),\n                    sb.getConfigBool(SwitchboardConstants.SEARCH_VERIFY_DELETE, false)\n                        && sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false)\n                        && sb.peers.mySeed().getFlagAcceptRemoteIndex(),\n                    false,\n                    lat, lon, rad);\n            EventTracker.delete(EventTracker.EClass.SEARCH);\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(\n                theQuery.id(true),\n                SearchEventType.INITIALIZATION,\n                \"\",\n                0,\n                0), false);\n\n            // tell all threads to do nothing for a specific time\n            sb.intermissionAllThreads(3000);\n\n            // filter out words that appear in bluelist\n            theQuery.getQueryGoal().filterOut(Switchboard.blueList);\n\n            // log\n            Log.logInfo(\n                \"LOCAL_SEARCH\",\n                \"INIT WORD SEARCH: \"\n                    + theQuery.getQueryGoal().getOriginalQueryString(false)\n                    + \":\"\n                    + QueryParams.hashSet2hashString(theQuery.getQueryGoal().getIncludeHashes())\n                    + \" - \"\n                    + theQuery.neededResults()\n                    + \" links to be computed, \"\n                    + theQuery.itemsPerPage()\n                    + \" lines to be displayed\");\n            EventChannel.channels(EventChannel.LOCALSEARCH).addMessage(\n                new RSSMessage(\"Local Search Request\", theQuery.getQueryGoal().getOriginalQueryString(false), \"\"));\n            final long timestamp = System.currentTimeMillis();\n\n            // create a new search event\n            if ( SearchEventCache.getEvent(theQuery.id(false)) == null ) {\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\n                startRecord = 0;\n            }\n            final SearchEvent theSearch =\n                SearchEventCache.getEvent(\n                    theQuery,\n                    sb.peers,\n                    sb.tables,\n                    (sb.isRobinsonMode()) ? sb.clusterhashes : null,\n                    false,\n                    sb.loader,\n                    (int) sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\n                    sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXTIME_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)),\n                    (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_ROBINSON, 0),\n                    (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_MULTIWORD, 0));\n\n            if ( startRecord == 0 ) {\n                if ( modifier.sitehost != null && sb.getConfigBool(SwitchboardConstants.HEURISTIC_SITE, false) && authenticated && !stealthmode) {\n                    sb.heuristicSite(theSearch, modifier.sitehost);\n                }\n                if ( (heuristicBlekko >= 0 || sb.getConfigBool(SwitchboardConstants.HEURISTIC_BLEKKO, false)) && authenticated && !stealthmode ) {\n                    sb.heuristicRSS(\"http://blekko.com/ws/$+/rss\", theSearch, \"blekko\");\n                }\n                if ( (heuristicTwitter >= 0 || sb.getConfigBool(SwitchboardConstants.HEURISTIC_TWITTER, false)) && authenticated && !stealthmode ) {\n                    sb.heuristicRSS(\"http://search.twitter.com/search.rss?rpp=50&q=$\", theSearch, \"twitter\");\n                }\n                if (sb.getConfigBool(SwitchboardConstants.HEURISTIC_OPENSEARCH, false) && authenticated && !stealthmode) {\n                    OpenSearchConnector.query(sb, theSearch);\n                }\n            }\n\n            // log\n            Log.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \"\n                + theQuery.getQueryGoal().getOriginalQueryString(false)\n                + \" - \"\n                + \"local_rwi_available(\" + theSearch.local_rwi_available.get() + \"), \"\n                + \"local_rwi_stored(\" + theSearch.local_rwi_stored.get() + \"), \"\n                + \"remote_rwi_available(\" + theSearch.remote_rwi_available.get() + \"), \"\n                + \"remote_rwi_stored(\" + theSearch.remote_rwi_stored.get() + \"), \"\n                + \"remote_rwi_peerCount(\" + theSearch.remote_rwi_peerCount.get() + \"), \"\n                + \"local_solr_available(\" + theSearch.local_solr_available.get() + \"), \"\n                + \"local_solr_stored(\" + theSearch.local_solr_stored.get() + \"), \"\n                + \"remote_solr_available(\" + theSearch.remote_solr_available.get() + \"), \"\n                + \"remote_solr_stored(\" + theSearch.remote_solr_stored.get() + \"), \"\n                + \"remote_solr_peerCount(\" + theSearch.remote_solr_peerCount.get() + \"), \"\n                + (System.currentTimeMillis() - timestamp)\n                + \" ms\");\n\n            // prepare search statistics\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\n            AccessTracker.add(AccessTracker.Location.local, theQuery, theSearch.getResultCount());\n\n            // check suggestions\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\n\n            prop.put(\"meanCount\", meanMax);\n            if ( meanMax > 0 && !json && !rss && sb.index.connectedRWI()) {\n                final DidYouMean didYouMean = new DidYouMean(indexSegment, new StringBuilder(querystring));\n                final Iterator<StringBuilder> meanIt = didYouMean.getSuggestions(100, 5).iterator();\n                int meanCount = 0;\n                String suggestion;\n                try {\n                    meanCollect: while ( meanCount < meanMax && meanIt.hasNext() ) {\n                        try {\n                            suggestion = meanIt.next().toString();\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_word\", suggestion);\n                            prop.put(\n                                \"didYouMean_suggestions_\" + meanCount + \"_url\",\n                                QueryParams.navurl(\n                                    \"html\",\n                                    0,\n                                    theQuery,\n                                    suggestion).toString());\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_sep\", \"|\");\n                            meanCount++;\n                        } catch (ConcurrentModificationException e) {break meanCollect;}\n                    }\n                } catch (ConcurrentModificationException e) {}\n                prop.put(\"didYouMean_suggestions_\" + (meanCount - 1) + \"_sep\", \"\");\n                prop.put(\"didYouMean\", meanCount > 0 ? 1 : 0);\n                prop.put(\"didYouMean_suggestions\", meanCount);\n            } else {\n                prop.put(\"didYouMean\", 0);\n            }\n\n            // find geographic info\n            final SortedSet<GeoLocation> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\n            if ( coordinates == null || coordinates.isEmpty() || startRecord > 0 ) {\n                prop.put(\"geoinfo\", \"0\");\n            } else {\n                int i = 0;\n                for ( final GeoLocation c : coordinates ) {\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\n                    i++;\n                    if ( i >= 10 ) {\n                        break;\n                    }\n                }\n                prop.put(\"geoinfo_loc\", i);\n                prop.put(\"geoinfo\", \"1\");\n            }\n\n            // update the search tracker\n            try {\n                synchronized ( trackerHandles ) {\n                    trackerHandles.add(theQuery.starttime);\n                    while ( trackerHandles.size() > 600 ) {\n                        if ( !trackerHandles.remove(trackerHandles.first()) ) {\n                            break;\n                        }\n                    }\n                }\n                sb.localSearchTracker.put(client, trackerHandles);\n                if ( sb.localSearchTracker.size() > 100 ) {\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\n                }\n                if ( MemoryControl.shortStatus() ) {\n                    sb.localSearchTracker.clear();\n                }\n            } catch ( final Exception e ) {\n                Log.logException(e);\n            }\n\n            prop.put(\"num-results_offset\", startRecord == 0 ? 0 : startRecord + 1);\n            prop.put(\"num-results_itemscount\", Formatter.number(startRecord + theSearch.query.itemsPerPage > theSearch.getResultCount() ? startRecord + theSearch.getResultCount() % theSearch.query.itemsPerPage : startRecord + theSearch.query.itemsPerPage, true));\n            prop.put(\"num-results_itemsPerPage\", Formatter.number(itemsPerPage));\n            prop.put(\"num-results_totalcount\", Formatter.number(theSearch.getResultCount()));\n            prop.put(\"num-results_globalresults\", global && (indexReceiveGranted || clustersearch) ? \"1\" : \"0\");\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n\n            // compose page navigation\n            final StringBuilder resnav = new StringBuilder(200);\n            final int thispage = startRecord / theQuery.itemsPerPage();\n            if ( thispage == 0 ) {\n                resnav\n                    .append(\"<img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\n            } else {\n                resnav.append(\"<a id=\\\"prevpage\\\" href=\\\"\");\n                resnav.append(QueryParams.navurl(\"html\", thispage - 1, theQuery, null).toString());\n                resnav\n                    .append(\"\\\"><img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\n            }\n            final int numberofpages = Math.min(10, 1 + ((theSearch.getResultCount() - 1) / theQuery.itemsPerPage()));\n\n            for ( int i = 0; i < numberofpages; i++ ) {\n                if ( i == thispage ) {\n                    resnav.append(\"<img src=\\\"env/grafics/navs\");\n                    resnav.append(i + 1);\n                    resnav.append(\".gif\\\" alt=\\\"page\");\n                    resnav.append(i + 1);\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\n                } else {\n                    resnav.append(\"<a href=\\\"\");\n                    resnav.append(QueryParams.navurl(\"html\", i, theQuery, null).toString());\n                    resnav.append(\"\\\"><img src=\\\"env/grafics/navd\");\n                    resnav.append(i + 1);\n                    resnav.append(\".gif\\\" alt=\\\"page\");\n                    resnav.append(i + 1);\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\n                }\n            }\n            if ( thispage >= numberofpages ) {\n                resnav\n                    .append(\"<img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" />\");\n            } else {\n                resnav.append(\"<a id=\\\"nextpage\\\" href=\\\"\");\n                resnav.append(QueryParams.navurl(\"html\", thispage + 1, theQuery, null).toString());\n                resnav.append(\"\\\"><img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>\");\n            }\n            final String resnavs = resnav.toString();\n            prop.put(\"num-results_resnav\", resnavs);\n            prop.put(\"pageNavBottom\", (theSearch.getResultCount() - startRecord > 6) ? 1 : 0); // if there are more results than may fit on the page we add a navigation at the bottom\n            prop.put(\"pageNavBottom_resnav\", resnavs);\n\n            // generate the search result lines; the content will be produced by another servlet\n            for ( int i = 0; i < theQuery.itemsPerPage(); i++ ) {\n                prop.put(\"results_\" + i + \"_item\", startRecord + i);\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\n            }\n            prop.put(\"results\", theQuery.itemsPerPage());\n            prop\n                .put(\n                    \"resultTable\",\n                    (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO)\n                        ? 1\n                        : 0);\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\n\n            // process result of search\n            if ( !filtered.isEmpty() ) {\n                prop.put(\"excluded\", \"1\");\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\n            } else {\n                prop.put(\"excluded\", \"0\");\n            }\n\n            if ( prop == null || prop.isEmpty() ) {\n                if ( post.get(\"query\", post.get(\"search\", \"\")).length() < 2 ) {\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\n                } else {\n                    prop.put(\"num-results\", \"1\"); // no results\n                }\n            } else {\n                prop.put(\"num-results\", \"3\");\n            }\n\n            prop.put(\"cat\", \"href\");\n            prop.put(\"depth\", \"0\");\n\n        }\n\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\n        prop.putHTML(\"former\", originalquerystring);\n        prop.put(\"count\", itemsPerPage);\n        prop.put(\"offset\", startRecord);\n        prop.put(\"resource\", global ? \"global\" : \"local\");\n        prop.putHTML(\"prefermaskfilter\", prefermask);\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\n        prop.put(\"search.verify\", snippetFetchStrategy == null\n            ? sb.getConfig(\"search.verify\", \"iffresh\")\n            : snippetFetchStrategy.toName());\n        prop.put(\n            \"search.navigation\",\n            (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n        prop.put(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\n        prop.put(\n            \"searchdomswitches\",\n            sb.getConfigBool(\"search.text\", true)\n                || sb.getConfigBool(\"search.audio\", true)\n                || sb.getConfigBool(\"search.video\", true)\n                || sb.getConfigBool(\"search.image\", true)\n                || sb.getConfigBool(\"search.app\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\n        prop.put(\"searchdomswitches_searchtext_check\", (contentdom == ContentDomain.TEXT || contentdom == ContentDomain.ALL) ? \"1\" : \"0\");\n        prop.put(\"searchdomswitches_searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\n        prop.put(\"searchdomswitches_searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\n        prop.put(\"searchdomswitches_searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\n        prop.put(\"searchdomswitches_searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\n\n        // copy properties for \"more options\" link\n        prop.put(\"searchdomswitches_count\", prop.get(\"count\"));\n        prop.put(\"searchdomswitches_urlmaskfilter\", prop.get(\"urlmaskfilter\"));\n        prop.put(\"searchdomswitches_prefermaskfilter\", prop.get(\"prefermaskfilter\"));\n        prop.put(\"searchdomswitches_cat\", prop.get(\"cat\"));\n        prop.put(\"searchdomswitches_constraint\", prop.get(\"constraint\"));\n        prop.put(\"searchdomswitches_contentdom\", prop.get(\"contentdom\"));\n        prop.put(\"searchdomswitches_former\", prop.get(\"former\"));\n        prop.put(\"searchdomswitches_meanCount\", prop.get(\"meanCount\"));\n\n        // for RSS: don't HTML encode some elements\n        prop.putXML(\"rss_query\", originalquerystring);\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\n\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        // hostname and port (assume locahost if nothing helps)\n        final InetAddress hostIP = Domains.myPublicLocalIP();\n        prop.put(\"myhost\", hostIP != null ? hostIP.getHostAddress() : Domains.LOCALHOST);\n        prop.put(\"myport\", serverCore.getPortNr(sb.getConfig(\"port\", \"8090\")));\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"6115bef335346f38088b225088235a50547c1b46","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n\n        final String eventID = post.get(\"eventID\", \"\");\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final int item = post.getInt(\"item\", -1);\n        final boolean auth = Domains.isLocalhost(header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"\")) || sb.verifyAuthentication(header);\n        final RequestHeader.FileType fileType = header.fileType();\n\n        // default settings for blank item\n        prop.put(\"content\", \"0\");\n        prop.put(\"rss\", \"0\");\n        prop.put(\"references\", \"0\");\n        prop.put(\"rssreferences\", \"0\");\n        prop.put(\"dynamic\", \"0\");\n\n        // find search event\n        final SearchEvent theSearch = SearchEventCache.getEvent(eventID);\n        if (theSearch == null) {\n            // the event does not exist, show empty page\n            return prop;\n        }\n\n        // dynamically update count values\n        prop.put(\"offset\", theSearch.query.neededResults() - theSearch.query.itemsPerPage() + 1);\n        prop.put(\"itemscount\", Formatter.number(Math.min((item < 0) ? theSearch.query.neededResults() : item + 1, theSearch.getResultCount())));\n        prop.put(\"itemsperpage\", Formatter.number(theSearch.query.itemsPerPage));\n        prop.put(\"totalcount\", Formatter.number(theSearch.getResultCount(), true));\n        prop.put(\"localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n        prop.put(\"remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n        prop.put(\"remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n        prop.put(\"remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n        prop.put(\"navurlBase\", QueryParams.navurlBase(\"html\", theSearch.query, null).toString());\n        final String target_special_pattern = sb.getConfig(SwitchboardConstants.SEARCH_TARGET_SPECIAL_PATTERN, \"\");\n\n        long timeout = item == 0 ? 10000 : (theSearch.query.isLocal() ? 1000 : 3000);\n        \n        if (theSearch.query.contentdom == Classification.ContentDomain.TEXT || theSearch.query.contentdom == Classification.ContentDomain.ALL) {\n            // text search\n\n            // generate result object\n            final ResultEntry result = theSearch.oneResult(item, timeout);\n            if (result == null) return prop; // no content\n            final String resultUrlstring = result.urlstring();\n            final DigestURI resultURL = result.url();\n            final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n            final int port = resultURL.getPort();\n            DigestURI faviconURL = null;\n            if ((fileType == FileType.HTML || fileType == FileType.JSON) && !sb.isIntranetMode()) try {\n                faviconURL = new DigestURI(resultURL.getProtocol() + \"://\" + resultURL.getHost() + ((port != -1) ? (\":\" + port) : \"\") + \"/favicon.ico\");\n            } catch (final MalformedURLException e1) {\n                Log.logException(e1);\n                faviconURL = null;\n            }\n            final String resource = theSearch.query.domType.toString();\n            final String origQ = theSearch.query.getQueryGoal().getOriginalQueryString(true);\n            prop.put(\"content\", 1); // switch on specific content\n            prop.put(\"content_showDate\", sb.getConfigBool(\"search.result.show.date\", true) ? 1 : 0);\n            prop.put(\"content_showSize\", sb.getConfigBool(\"search.result.show.size\", true) ? 1 : 0);\n            prop.put(\"content_showMetadata\", sb.getConfigBool(\"search.result.show.metadata\", true) ? 1 : 0);\n            prop.put(\"content_showParser\", sb.getConfigBool(\"search.result.show.parser\", true) ? 1 : 0);\n            prop.put(\"content_showPictures\", sb.getConfigBool(\"search.result.show.pictures\", true) ? 1 : 0);\n            prop.put(\"content_showCache\", sb.getConfigBool(\"search.result.show.cache\", true) && Cache.has(resultURL.hash()) ? 1 : 0);\n            prop.put(\"content_showProxy\", sb.getConfigBool(\"search.result.show.proxy\", true) ? 1 : 0);\n            prop.put(\"content_showHostBrowser\", sb.getConfigBool(\"search.result.show.hostbrowser\", true) ? 1 : 0);\n            prop.put(\"content_showTags\", sb.getConfigBool(\"search.result.show.tags\", false) ? 1 : 0);\n            prop.put(\"content_authorized\", authenticated ? \"1\" : \"0\");\n            final String urlhash = ASCII.String(result.hash());\n            prop.put(\"content_authorized_bookmark\", sb.tables.bookmarks.hasBookmark(\"admin\", urlhash) ? \"0\" : \"1\");\n            prop.putHTML(\"content_authorized_bookmark_bookmarklink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&bookmarkref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.put(\"content_authorized_recommend\", (sb.peers.newsPool.getSpecific(NewsPool.OUTGOING_DB, NewsPool.CATEGORY_SURFTIPP_ADD, \"url\", resultUrlstring) == null) ? \"1\" : \"0\");\n            prop.putHTML(\"content_authorized_recommend_deletelink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&deleteref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.putHTML(\"content_authorized_recommend_recommendlink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&recommendref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.put(\"content_authorized_urlhash\", urlhash);\n            final String resulthashString = urlhash;\n            prop.putHTML(\"content_title\", result.title());\n            prop.putXML(\"content_title-xml\", result.title());\n            prop.putJSON(\"content_title-json\", result.title());\n            prop.putHTML(\"content_showPictures_link\", resultUrlstring);\n            //prop.putHTML(\"content_link\", resultUrlstring);\n\n// START interaction\n            String modifyURL = resultUrlstring;\n\t\t\tif (sb.getConfigBool(\"proxyURL.useforresults\", false)) {\n\t\t\t\t// check if url is allowed to view\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"all\")) {\n\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t}\n\n\t\t\t\t// check if url is allowed to view\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"domainlist\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (sb.crawlStacker.urlInAcceptedDomain(new DigestURI (modifyURL)) == null) {\n\t\t\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"yacy\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif ((new DigestURI (modifyURL).getHost().endsWith(\".yacy\"))) {\n\t\t\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            prop.putHTML(\"content_link\", modifyURL);\n//            prop.putHTML(\"content_value\", Interaction.TripleGet(result.urlstring(), \"http://virtual.x/hasvalue\", \"anonymous\"));\n// END interaction\n\n            prop.putHTML(\"content_target\", target);\n            if (faviconURL != null && fileType == FileType.HTML) sb.loader.loadIfNotExistBackground(faviconURL, 1024 * 1024 * 10, null, TextSnippet.snippetMinLoadDelay, ClientIdentification.DEFAULT_TIMEOUT);\n            prop.putHTML(\"content_faviconCode\", URLLicense.aquireLicense(faviconURL)); // acquire license for favicon url loading\n            prop.put(\"content_urlhash\", resulthashString);\n            prop.put(\"content_ranking\", result.ranking());\n            prop.put(\"content_showMetadata_urlhash\", resulthashString);\n            prop.put(\"content_showCache_link\", resultUrlstring);\n            prop.put(\"content_showProxy_link\", resultUrlstring);\n            prop.put(\"content_showHostBrowser_link\", resultUrlstring);\n            prop.put(\"content_showParser_urlhash\", resulthashString);\n            prop.put(\"content_showTags_urlhash\", resulthashString);\n            prop.put(\"content_urlhexhash\", Seed.b64Hash2hexHash(resulthashString));\n            prop.putHTML(\"content_urlname\", nxTools.shortenURLString(result.urlname(), MAX_URL_LENGTH));\n            prop.put(\"content_showDate_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(result.modified()));\n            prop.put(\"content_date822\", HeaderFramework.formatRFC1123(result.modified()));\n            //prop.put(\"content_ybr\", RankingProcess.ybr(result.hash()));\n            prop.putHTML(\"content_size\", Integer.toString(result.filesize())); // we don't use putNUM here because that number shall be usable as sorting key. To print the size, use 'sizename'\n            prop.putHTML(\"content_sizename\", RSSMessage.sizename(result.filesize()));\n            prop.putHTML(\"content_showSize_sizename\", RSSMessage.sizename(result.filesize()));\n            prop.putHTML(\"content_host\", resultURL.getHost() == null ? \"\" : resultURL.getHost());\n            prop.putHTML(\"content_file\", resultURL.getFileName());\n            prop.putHTML(\"content_path\", resultURL.getPath());\n            prop.put(\"content_nl\", (item == theSearch.query.offset) ? 0 : 1);\n            prop.putHTML(\"content_publisher\", result.publisher());\n            prop.putHTML(\"content_creator\", result.creator());// author\n            prop.putHTML(\"content_subject\", result.subject());\n            final List<String> query = theSearch.query.getQueryGoal().getAllStrings();\n            final StringBuilder s = new StringBuilder(query.size() * 20);\n            for (final String t: query) {\n                s.append('+').append(t);\n            }\n            final String words = (s.length() > 0) ? s.substring(1) : \"\";\n            prop.putHTML(\"content_words\", words);\n            prop.putHTML(\"content_showParser_words\", words);\n            prop.putHTML(\"content_former\", origQ);\n            prop.putHTML(\"content_showPictures_former\", origQ);\n            final TextSnippet snippet = result.textSnippet();\n            final String desc = (snippet == null) ? \"\" : snippet.isMarked() ? snippet.getLineRaw() : snippet.getLineMarked(theSearch.query.getQueryGoal());\n            prop.put(\"content_description\", desc);\n            prop.putXML(\"content_description-xml\", desc);\n            prop.putJSON(\"content_description-json\", desc);\n            final HeuristicResult heuristic = theSearch.getHeuristic(result.hash());\n            if (heuristic == null) {\n                prop.put(\"content_heuristic\", 0);\n            } else {\n                if (heuristic.redundant) {\n                    prop.put(\"content_heuristic\", 1);\n                } else {\n                    prop.put(\"content_heuristic\", 2);\n                }\n                prop.put(\"content_heuristic_name\", heuristic.heuristicName);\n            }\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theSearch.query.id(true), SearchEventType.FINALIZATION, \"\" + item, 0, 0), false);\n            final String ext = resultURL.getFileExtension().toLowerCase();\n            if (ext.equals(\"png\") || ext.equals(\"jpg\") || ext.equals(\"gif\")) {\n                final String license = URLLicense.aquireLicense(resultURL);\n                prop.put(\"content_code\", license);\n            } else {\n                prop.put(\"content_code\", \"\");\n            }\n            if (result.lat() == 0.0d || result.lon() == 0.0d) {\n                prop.put(\"content_loc\", 0);\n            } else {\n                prop.put(\"content_loc\", 1);\n                prop.put(\"content_loc_lat\", result.lat());\n                prop.put(\"content_loc_lon\", result.lon());\n            }\n            if (sb.getConfigBool(\"heuristic.searchresults\",false)) sb.heuristicSearchResults(resultUrlstring);\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if (theSearch.query.contentdom == Classification.ContentDomain.IMAGE) {\n            // image search; shows thumbnails\n\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            //final MediaSnippet ms = theSearch.result().oneImage(item);\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n                final String license = URLLicense.aquireLicense(ms.url());\n                sb.loader.loadIfNotExistBackground(ms.url(), 1024 * 1024 * 10, null, TextSnippet.snippetMinLoadDelay, ClientIdentification.DEFAULT_TIMEOUT);\n                prop.putHTML(\"content_item_hrefCache\", (auth) ? \"/ViewImage.png?url=\" + resultUrlstring : resultUrlstring);\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_target\", target);\n                prop.put(\"content_item_code\", license);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_mimetype\", \"\");\n                prop.put(\"content_item_fileSize\", 0);\n                prop.put(\"content_item_width\", 0);\n                prop.put(\"content_item_height\", 0);\n                prop.put(\"content_item_attr\", \"\"/*(ms.attr.equals(\"-1 x -1\")) ? \"\" : \"(\" + ms.attr + \")\"*/); // attributes, here: original size of image\n                prop.put(\"content_item_urlhash\", ASCII.String(ms.url().hash()));\n                prop.put(\"content_item_source\", ms.url().toNormalform(true));\n                prop.putXML(\"content_item_source-xml\", ms.url().toNormalform(true));\n                prop.put(\"content_item_sourcedom\", ms.url().getHost());\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if ((theSearch.query.contentdom == ContentDomain.AUDIO) ||\n            (theSearch.query.contentdom == ContentDomain.VIDEO) ||\n            (theSearch.query.contentdom == ContentDomain.APP)) {\n            // any other media content\n\n            // generate result object\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_hrefshort\", nxTools.shortenURLString(resultUrlstring, MAX_URL_LENGTH));\n                prop.putHTML(\"content_item_target\", target);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_col\", (item % 2 == 0) ? \"0\" : \"1\");\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        return prop;\n    }","id":76354,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n\n        final String eventID = post.get(\"eventID\", \"\");\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final int item = post.getInt(\"item\", -1);\n        final boolean auth = Domains.isLocalhost(header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"\")) || sb.verifyAuthentication(header);\n        final RequestHeader.FileType fileType = header.fileType();\n\n        // default settings for blank item\n        prop.put(\"content\", \"0\");\n        prop.put(\"rss\", \"0\");\n        prop.put(\"references\", \"0\");\n        prop.put(\"rssreferences\", \"0\");\n        prop.put(\"dynamic\", \"0\");\n\n        // find search event\n        final SearchEvent theSearch = SearchEventCache.getEvent(eventID);\n        if (theSearch == null) {\n            // the event does not exist, show empty page\n            return prop;\n        }\n\n        // dynamically update count values\n        prop.put(\"offset\", theSearch.query.neededResults() - theSearch.query.itemsPerPage() + 1);\n        prop.put(\"itemscount\", Formatter.number(Math.min((item < 0) ? theSearch.query.neededResults() : item + 1, theSearch.getResultCount())));\n        prop.put(\"itemsperpage\", Formatter.number(theSearch.query.itemsPerPage));\n        prop.put(\"totalcount\", Formatter.number(theSearch.getResultCount(), true));\n        prop.put(\"localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n        prop.put(\"remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n        prop.put(\"remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n        prop.put(\"remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n        prop.put(\"navurlBase\", QueryParams.navurlBase(\"html\", theSearch.query, null).toString());\n        final String target_special_pattern = sb.getConfig(SwitchboardConstants.SEARCH_TARGET_SPECIAL_PATTERN, \"\");\n\n        long timeout = item == 0 ? 10000 : (theSearch.query.isLocal() ? 1000 : 3000);\n        \n        if (theSearch.query.contentdom == Classification.ContentDomain.TEXT || theSearch.query.contentdom == Classification.ContentDomain.ALL) {\n            // text search\n\n            // generate result object\n            final ResultEntry result = theSearch.oneResult(item, timeout);\n            if (result == null) return prop; // no content\n            final String resultUrlstring = result.urlstring();\n            final DigestURI resultURL = result.url();\n            final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n            final int port = resultURL.getPort();\n            DigestURI faviconURL = null;\n            if ((fileType == FileType.HTML || fileType == FileType.JSON) && !sb.isIntranetMode()) try {\n                faviconURL = new DigestURI(resultURL.getProtocol() + \"://\" + resultURL.getHost() + ((port != -1) ? (\":\" + port) : \"\") + \"/favicon.ico\");\n            } catch (final MalformedURLException e1) {\n                Log.logException(e1);\n                faviconURL = null;\n            }\n            final String resource = theSearch.query.domType.toString();\n            final String origQ = theSearch.query.getQueryGoal().getOriginalQueryString(true);\n            prop.put(\"content\", 1); // switch on specific content\n            prop.put(\"content_showDate\", sb.getConfigBool(\"search.result.show.date\", true) ? 1 : 0);\n            prop.put(\"content_showSize\", sb.getConfigBool(\"search.result.show.size\", true) ? 1 : 0);\n            prop.put(\"content_showMetadata\", sb.getConfigBool(\"search.result.show.metadata\", true) ? 1 : 0);\n            prop.put(\"content_showParser\", sb.getConfigBool(\"search.result.show.parser\", true) ? 1 : 0);\n            prop.put(\"content_showPictures\", sb.getConfigBool(\"search.result.show.pictures\", true) ? 1 : 0);\n            prop.put(\"content_showCache\", sb.getConfigBool(\"search.result.show.cache\", true) && Cache.has(resultURL.hash()) ? 1 : 0);\n            prop.put(\"content_showProxy\", sb.getConfigBool(\"search.result.show.proxy\", true) ? 1 : 0);\n            prop.put(\"content_showHostBrowser\", sb.getConfigBool(\"search.result.show.hostbrowser\", true) ? 1 : 0);\n            prop.put(\"content_showTags\", sb.getConfigBool(\"search.result.show.tags\", false) ? 1 : 0);\n            prop.put(\"content_authorized\", authenticated ? \"1\" : \"0\");\n            final String urlhash = ASCII.String(result.hash());\n            prop.put(\"content_authorized_bookmark\", sb.tables.bookmarks.hasBookmark(\"admin\", urlhash) ? \"0\" : \"1\");\n            prop.putHTML(\"content_authorized_bookmark_bookmarklink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&bookmarkref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.put(\"content_authorized_recommend\", (sb.peers.newsPool.getSpecific(NewsPool.OUTGOING_DB, NewsPool.CATEGORY_SURFTIPP_ADD, \"url\", resultUrlstring) == null) ? \"1\" : \"0\");\n            prop.putHTML(\"content_authorized_recommend_deletelink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&deleteref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.putHTML(\"content_authorized_recommend_recommendlink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&recommendref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.put(\"content_authorized_urlhash\", urlhash);\n            final String resulthashString = urlhash;\n            prop.putHTML(\"content_title\", result.title());\n            prop.putXML(\"content_title-xml\", result.title());\n            prop.putJSON(\"content_title-json\", result.title());\n            prop.putHTML(\"content_showPictures_link\", resultUrlstring);\n            //prop.putHTML(\"content_link\", resultUrlstring);\n\n// START interaction\n            String modifyURL = resultUrlstring;\n\t\t\tif (sb.getConfigBool(\"proxyURL.useforresults\", false)) {\n\t\t\t\t// check if url is allowed to view\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"all\")) {\n\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t}\n\n\t\t\t\t// check if url is allowed to view\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"domainlist\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (sb.crawlStacker.urlInAcceptedDomain(new DigestURI (modifyURL)) == null) {\n\t\t\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"yacy\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif ((new DigestURI (modifyURL).getHost().endsWith(\".yacy\"))) {\n\t\t\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            prop.putHTML(\"content_link\", modifyURL);\n//            prop.putHTML(\"content_value\", Interaction.TripleGet(result.urlstring(), \"http://virtual.x/hasvalue\", \"anonymous\"));\n// END interaction\n\n            prop.putHTML(\"content_target\", target);\n            if (faviconURL != null && fileType == FileType.HTML) sb.loader.loadIfNotExistBackground(faviconURL, 1024 * 1024 * 10, null, TextSnippet.snippetMinLoadDelay, ClientIdentification.DEFAULT_TIMEOUT);\n            prop.putHTML(\"content_faviconCode\", URLLicense.aquireLicense(faviconURL)); // acquire license for favicon url loading\n            prop.put(\"content_urlhash\", resulthashString);\n            prop.put(\"content_ranking\", result.ranking());\n            prop.put(\"content_showMetadata_urlhash\", resulthashString);\n            prop.put(\"content_showCache_link\", resultUrlstring);\n            prop.put(\"content_showProxy_link\", resultUrlstring);\n            prop.put(\"content_showHostBrowser_link\", resultUrlstring);\n            prop.put(\"content_showParser_urlhash\", resulthashString);\n            prop.put(\"content_showTags_urlhash\", resulthashString);\n            prop.put(\"content_urlhexhash\", Seed.b64Hash2hexHash(resulthashString));\n            prop.putHTML(\"content_urlname\", nxTools.shortenURLString(result.urlname(), MAX_URL_LENGTH));\n            prop.put(\"content_showDate_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(result.modified()));\n            prop.put(\"content_date822\", HeaderFramework.formatRFC1123(result.modified()));\n            //prop.put(\"content_ybr\", RankingProcess.ybr(result.hash()));\n            prop.putHTML(\"content_size\", Integer.toString(result.filesize())); // we don't use putNUM here because that number shall be usable as sorting key. To print the size, use 'sizename'\n            prop.putHTML(\"content_sizename\", RSSMessage.sizename(result.filesize()));\n            prop.putHTML(\"content_showSize_sizename\", RSSMessage.sizename(result.filesize()));\n            prop.putHTML(\"content_host\", resultURL.getHost() == null ? \"\" : resultURL.getHost());\n            prop.putHTML(\"content_file\", resultURL.getFileName());\n            prop.putHTML(\"content_path\", resultURL.getPath());\n            prop.put(\"content_nl\", (item == theSearch.query.offset) ? 0 : 1);\n            prop.putHTML(\"content_publisher\", result.publisher());\n            prop.putHTML(\"content_creator\", result.creator());// author\n            prop.putHTML(\"content_subject\", result.subject());\n            final List<String> query = theSearch.query.getQueryGoal().getAllStrings();\n            final StringBuilder s = new StringBuilder(query.size() * 20);\n            for (final String t: query) {\n                s.append('+').append(t);\n            }\n            final String words = (s.length() > 0) ? s.substring(1) : \"\";\n            prop.putHTML(\"content_words\", words);\n            prop.putHTML(\"content_showParser_words\", words);\n            prop.putHTML(\"content_former\", origQ);\n            prop.putHTML(\"content_showPictures_former\", origQ);\n            final TextSnippet snippet = result.textSnippet();\n            final String desc = (snippet == null) ? \"\" : snippet.isMarked() ? snippet.getLineRaw() : snippet.getLineMarked(theSearch.query.getQueryGoal());\n            prop.put(\"content_description\", desc);\n            prop.putXML(\"content_description-xml\", desc);\n            prop.putJSON(\"content_description-json\", desc);\n            final HeuristicResult heuristic = theSearch.getHeuristic(result.hash());\n            if (heuristic == null) {\n                prop.put(\"content_heuristic\", 0);\n            } else {\n                if (heuristic.redundant) {\n                    prop.put(\"content_heuristic\", 1);\n                } else {\n                    prop.put(\"content_heuristic\", 2);\n                }\n                prop.put(\"content_heuristic_name\", heuristic.heuristicName);\n            }\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theSearch.query.id(true), SearchEventType.FINALIZATION, \"\" + item, 0, 0), false);\n            final String ext = resultURL.getFileExtension().toLowerCase();\n            if (ext.equals(\"png\") || ext.equals(\"jpg\") || ext.equals(\"gif\")) {\n                final String license = URLLicense.aquireLicense(resultURL);\n                prop.put(\"content_code\", license);\n            } else {\n                prop.put(\"content_code\", \"\");\n            }\n            if (result.lat() == 0.0d || result.lon() == 0.0d) {\n                prop.put(\"content_loc\", 0);\n            } else {\n                prop.put(\"content_loc\", 1);\n                prop.put(\"content_loc_lat\", result.lat());\n                prop.put(\"content_loc_lon\", result.lon());\n            }\n            final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n            final boolean indexReceiveGranted =\n                sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true)\n                    || sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true)\n                    || clustersearch;\n            boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n            boolean global = post == null || (post.get(\"resource\", \"local\").equals(\"global\") && p2pmode);\n            boolean stealthmode = p2pmode && !global;\n            if ((sb.getConfigBool(SwitchboardConstants.HEURISTIC_SEARCHRESULTS, false) ||\n                    (sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false) && sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ENABLED, false))) &&\n                 !stealthmode) sb.heuristicSearchResults(resultUrlstring);\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if (theSearch.query.contentdom == Classification.ContentDomain.IMAGE) {\n            // image search; shows thumbnails\n\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            //final MediaSnippet ms = theSearch.result().oneImage(item);\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n                final String license = URLLicense.aquireLicense(ms.url());\n                sb.loader.loadIfNotExistBackground(ms.url(), 1024 * 1024 * 10, null, TextSnippet.snippetMinLoadDelay, ClientIdentification.DEFAULT_TIMEOUT);\n                prop.putHTML(\"content_item_hrefCache\", (auth) ? \"/ViewImage.png?url=\" + resultUrlstring : resultUrlstring);\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_target\", target);\n                prop.put(\"content_item_code\", license);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_mimetype\", \"\");\n                prop.put(\"content_item_fileSize\", 0);\n                prop.put(\"content_item_width\", 0);\n                prop.put(\"content_item_height\", 0);\n                prop.put(\"content_item_attr\", \"\"/*(ms.attr.equals(\"-1 x -1\")) ? \"\" : \"(\" + ms.attr + \")\"*/); // attributes, here: original size of image\n                prop.put(\"content_item_urlhash\", ASCII.String(ms.url().hash()));\n                prop.put(\"content_item_source\", ms.url().toNormalform(true));\n                prop.putXML(\"content_item_source-xml\", ms.url().toNormalform(true));\n                prop.put(\"content_item_sourcedom\", ms.url().getHost());\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if ((theSearch.query.contentdom == ContentDomain.AUDIO) ||\n            (theSearch.query.contentdom == ContentDomain.VIDEO) ||\n            (theSearch.query.contentdom == ContentDomain.APP)) {\n            // any other media content\n\n            // generate result object\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_hrefshort\", nxTools.shortenURLString(resultUrlstring, MAX_URL_LENGTH));\n                prop.putHTML(\"content_item_target\", target);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_col\", (item % 2 == 0) ? \"0\" : \"1\");\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        return prop;\n    }","commit_id":"6115bef335346f38088b225088235a50547c1b46","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(\r\n        final RequestHeader header,\r\n        final serverObjects post,\r\n        final serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n\r\n        // check if the basic configuration was accessed before and forward\r\n        prop.put(\"forwardToConfigBasic\", 0);\r\n        if ( (post == null || !post.containsKey(\"noforward\"))\r\n            && sb.getConfig(\"server.servlets.submitted\", \"\").indexOf(\"ConfigBasic.html\", 0) < 0\r\n            && Seed.isDefaultPeerName(sb.peers.mySeed().getName()) ) {\r\n            // forward to ConfigBasic\r\n            prop.put(\"forwardToConfigBasic\", 1);\r\n        }\r\n        if ( post != null ) {\r\n            post.remove(\"noforward\");\r\n        }\r\n\r\n        if ( post != null && !post.isEmpty() ) {\r\n            if ( sb.adminAuthenticated(header) < 2 ) {\r\n            \tprop.authenticationRequired();\r\n                return prop;\r\n            }\r\n            boolean redirect = false;\r\n            if ( post.containsKey(\"login\") ) {\r\n                prop.put(serverObjects.ACTION_LOCATION, \"\");\r\n                return prop;\r\n            } else if ( post.containsKey(\"pauseCrawlJob\") ) {\r\n                final String jobType = post.get(\"jobType\");\r\n                if ( \"localCrawl\".equals(jobType) ) {\r\n                    sb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, \"user demand on Status.html\");\r\n                } else if ( \"remoteTriggeredCrawl\".equals(jobType) ) {\r\n                    sb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, \"user demand on Status.html\");\r\n                }\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"continueCrawlJob\") ) {\r\n                final String jobType = post.get(\"jobType\");\r\n                if ( \"localCrawl\".equals(jobType) ) {\r\n                    sb.continueCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\r\n                } else if ( \"remoteTriggeredCrawl\".equals(jobType) ) {\r\n                    sb.continueCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\r\n                }\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"ResetTraffic\") ) {\r\n                ByteCount.resetCount();\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"popup\") ) {\r\n                final boolean trigger_enabled = post.getBoolean(\"popup\");\r\n                sb.setConfig(\"browserPopUpTrigger\", trigger_enabled);\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"tray\") ) {\r\n                final boolean trigger_enabled = post.getBoolean(\"tray\");\r\n                sb.setConfig(\"trayIcon\", trigger_enabled);\r\n                redirect = true;\r\n            }\r\n\r\n            if ( redirect ) {\r\n                prop.put(serverObjects.ACTION_LOCATION, \"\");\r\n                return prop;\r\n            }\r\n        }\r\n\r\n        // update seed info\r\n        //sb.updateMySeed(); // don't do this here. if Solr is stuck, this makes it worse. And it prevents that we can click on the Thread Dump menu.\r\n\r\n        final boolean adminaccess = sb.adminAuthenticated(header) >= 2;\r\n        if ( adminaccess ) {\r\n            prop.put(\"showPrivateTable\", \"1\");\r\n            prop.put(\"privateStatusTable\", \"Status_p.inc\");\r\n        } else {\r\n            prop.put(\"showPrivateTable\", \"0\");\r\n            prop.put(\"privateStatusTable\", \"\");\r\n        }\r\n\r\n        // password protection\r\n        if ( (sb.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").isEmpty())\r\n            && (!sb.getConfigBool(\"adminAccountForLocalhost\", false)) ) {\r\n            prop.put(\"protection\", \"0\"); // not protected\r\n            prop.put(\"urgentSetPassword\", \"1\");\r\n        } else {\r\n            prop.put(\"protection\", \"1\"); // protected\r\n        }\r\n\r\n        if ( sb.getConfigBool(\"adminAccountForLocalhost\", false) ) {\r\n            prop.put(\"unrestrictedLocalAccess\", 1);\r\n        }\r\n\r\n        // resource observer status\r\n        if ( adminaccess ) {\r\n            if ( !sb.observer.getDiskAvailable() ) {\r\n                final String minFree = Formatter.bytesToString(sb.observer.getMinFreeDiskSpace());\r\n                prop.put(\"warningDiskSpaceLow\", \"1\");\r\n                prop.put(\"warningDiskSpaceLow_minSpace\", minFree);\r\n            }\r\n            if ( !sb.observer.getMemoryAvailable() ) {\r\n                final String minFree =\r\n                    Formatter.bytesToString(sb.observer.getMinFreeMemory() * 1024L * 1024L);\r\n                prop.put(\"warningMemoryLow\", \"1\");\r\n                prop.put(\"warningMemoryLow_minSpace\", minFree);\r\n            }\r\n\r\n        }\r\n\r\n        // version information\r\n        //final String versionstring = yacyVersion.combined2prettyVersion(sb.getConfig(\"version\",\"0.1\"));\r\n        final String versionstring =\r\n            yacyBuildProperties.getVersion() + \"/\" + yacyBuildProperties.getSVNRevision();\r\n        prop.put(\"versionpp\", versionstring);\r\n\r\n        // place some more hints\r\n        if (adminaccess && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() == 0) {\r\n            prop.put(\"hintCrawlStart\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() > 500) {\r\n            prop.put(\"hintCrawlMonitor\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && \"intranet|webportal|allip\".indexOf(env.getConfig(SwitchboardConstants.NETWORK_NAME, \"unspecified\")) >= 0) {\r\n            prop.put(\"hintSupport\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)) {\r\n            prop.put(\"warningCrawlPaused\", \"1\");\r\n        }\r\n\r\n        // hostname and port\r\n        final String extendedPortString = sb.getConfig(\"port\", \"8090\");\r\n        final int pos = extendedPortString.indexOf(':', 0);\r\n        prop.put(\"port\", extendedPortString);\r\n        if ( pos != -1 ) {\r\n            prop.put(\"extPortFormat\", \"1\");\r\n            prop.putHTML(\"extPortFormat_extPort\", extendedPortString);\r\n        } else {\r\n            prop.put(\"extPortFormat\", \"0\");\r\n        }\r\n        final InetAddress hostIP = Domains.myPublicLocalIP();\r\n        prop.put(\"host\", hostIP != null ? hostIP.getHostAddress() : \"Unkown IP\");\r\n\r\n        // ssl support\r\n        prop.put(\"sslSupport\", sb.getConfig(\"keyStore\", \"\").isEmpty() || !sb.getConfigBool(\"server.https\", false) ? 0 : 1);\r\n        if (sb.getConfigBool(\"server.https\", false)) prop.put(\"sslSupport_sslPort\", sb.getHttpServer().getSslPort());\r\n        \r\n        if ( sb.getConfigBool(\"remoteProxyUse\", false) ) {\r\n            prop.put(\"remoteProxy\", \"1\");\r\n            prop.putXML(\"remoteProxy_host\", sb.getConfig(\"remoteProxyHost\", \"<unknown>\"));\r\n            prop.putXML(\"remoteProxy_port\", sb.getConfig(\"remoteProxyPort\", \"<unknown>\"));\r\n            prop.put(\"remoteProxy_4Yacy\", sb.getConfigBool(\"remoteProxyUse4Yacy\", true) ? \"0\" : \"1\");\r\n        } else {\r\n            prop.put(\"remoteProxy\", \"0\"); // not used\r\n        }\r\n\r\n        // peer information\r\n        String thisHash = \"\";\r\n        final String thisName = sb.peers.mySeed().getName();\r\n        if ( sb.peers.mySeed() == null ) {\r\n            thisHash = \"not assigned\";\r\n            prop.put(\"peerAddress\", \"0\"); // not assigned\r\n            prop.put(\"peerStatistics\", \"0\"); // unknown\r\n        } else {\r\n            final long uptime = 60000 * sb.peers.mySeed().getLong(Seed.UPTIME, 0L);\r\n            prop.put(\"peerStatistics\", \"1\");\r\n            prop.put(\"peerStatistics_uptime\", PeerActions.formatInterval(uptime));\r\n            prop.putNum(\"peerStatistics_pagesperminute\", sb.peers.mySeed().getPPM());\r\n            prop.putNum(\r\n                \"peerStatistics_queriesperhour\",\r\n                Math.round(6000d * sb.peers.mySeed().getQPM()) / 100d);\r\n            prop.putNum(\"peerStatistics_links\", sb.peers.mySeed().getLinkCount());\r\n            prop.put(\"peerStatistics_words\", Formatter.number(sb.peers.mySeed().getWordCount()));\r\n            prop.putNum(\"peerStatistics_disconnects\", sb.peers.peerActions.disconnects);\r\n            prop.put(\"peerStatistics_connects\", Formatter.number(sb.peers.mySeed().get(Seed.CCOUNT, \"0\")));\r\n            thisHash = sb.peers.mySeed().hash;\r\n            if ( sb.peers.mySeed().getPublicAddress() == null ) {\r\n                prop.put(\"peerAddress\", \"0\"); // not assigned + instructions\r\n                prop.put(\"warningGoOnline\", \"1\");\r\n            } else {\r\n                prop.put(\"peerAddress\", \"1\"); // Address\r\n                prop.put(\"peerAddress_address\", sb.peers.mySeed().getPublicAddress());\r\n                prop.putXML(\"peerAddress_peername\", sb.peers.mySeed().getName().toLowerCase());\r\n            }\r\n        }\r\n        final String peerStatus =\r\n            ((sb.peers.mySeed() == null) ? Seed.PEERTYPE_VIRGIN : sb.peers.mySeed().get(\r\n                Seed.PEERTYPE,\r\n                Seed.PEERTYPE_VIRGIN));\r\n\r\n        if ( Seed.PEERTYPE_VIRGIN.equals(peerStatus)\r\n            && \"freeworld\".equals(sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"))\r\n            && !SwitchboardConstants.CLUSTER_MODE_PRIVATE_PEER.equals(sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\"))) {\r\n            prop.put(PEERSTATUS, \"0\");\r\n            prop.put(\"urgentStatusVirgin\", \"1\");\r\n        } else if ( Seed.PEERTYPE_JUNIOR.equals(peerStatus)\r\n            && \"freeworld\".equals(sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"))\r\n            && !SwitchboardConstants.CLUSTER_MODE_PRIVATE_PEER.equals(sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\"))) {\r\n            prop.put(PEERSTATUS, \"1\");\r\n            prop.put(\"warningStatusJunior\", \"1\");\r\n        } else if ( Seed.PEERTYPE_SENIOR.equals(peerStatus) ) {\r\n            prop.put(PEERSTATUS, \"2\");\r\n            prop.put(\"hintStatusSenior\", \"1\");\r\n        } else if ( Seed.PEERTYPE_PRINCIPAL.equals(peerStatus) ) {\r\n            prop.put(PEERSTATUS, \"3\");\r\n            prop.put(\"hintStatusPrincipal\", \"1\");\r\n            prop.putHTML(\"hintStatusPrincipal_seedURL\", sb.peers.mySeed().get(Seed.SEEDLISTURL, \"?\"));\r\n        }\r\n        prop.putHTML(\"peerName\", thisName);\r\n        prop.put(\"hash\", thisHash);\r\n\r\n        final String seedUploadMethod = sb.getConfig(\"seedUploadMethod\", \"\");\r\n        if ( !\"none\".equalsIgnoreCase(seedUploadMethod)\r\n            || (\"\".equals(seedUploadMethod) && (sb.getConfig(\"seedFTPPassword\", \"\").length() > 0 || sb\r\n                .getConfig(\"seedFilePath\", \"\")\r\n                .length() > 0)) ) {\r\n            if ( \"\".equals(seedUploadMethod) ) {\r\n                if ( sb.getConfig(\"seedFTPPassword\", \"\").length() > 0 ) {\r\n                    sb.setConfig(\"seedUploadMethod\", \"Ftp\");\r\n                }\r\n                if ( sb.getConfig(\"seedFilePath\", \"\").length() > 0 ) {\r\n                    sb.setConfig(\"seedUploadMethod\", \"File\");\r\n                }\r\n            }\r\n\r\n            if ( \"ftp\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"1\"); // enabled\r\n                prop.putHTML(\"seedServer_seedServer\", sb.getConfig(\"seedFTPServer\", \"\"));\r\n            } else if ( \"scp\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"1\"); // enabled\r\n                prop.putHTML(\"seedServer_seedServer\", sb.getConfig(\"seedScpServer\", \"\"));\r\n            } else if ( \"file\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"2\"); // enabled\r\n                prop.putHTML(\"seedServer_seedFile\", sb.getConfig(\"seedFilePath\", \"\"));\r\n            }\r\n            prop.put(\r\n                \"seedServer_lastUpload\",\r\n                PeerActions.formatInterval(System.currentTimeMillis() - sb.peers.lastSeedUpload_timeStamp));\r\n        } else {\r\n            prop.put(SEEDSERVER, \"0\"); // disabled\r\n        }\r\n\r\n        if ( sb.peers != null && sb.peers.sizeConnected() > 0 ) {\r\n            prop.put(\"otherPeers\", \"1\");\r\n            prop.putNum(\"otherPeers_num\", sb.peers.sizeConnected());\r\n        } else {\r\n            prop.put(\"otherPeers\", \"0\"); // not online\r\n        }\r\n\r\n        if ( !sb.getConfigBool(\"browserPopUpTrigger\", false) ) {\r\n            prop.put(\"popup\", \"0\");\r\n        } else {\r\n            prop.put(\"popup\", \"1\");\r\n        }\r\n\r\n        if ( !OS.isWindows ) {\r\n            prop.put(\"tray\", \"2\");\r\n        } else if ( !sb.getConfigBool(\"trayIcon\", false) ) {\r\n            prop.put(\"tray\", \"0\");\r\n        } else {\r\n            prop.put(\"tray\", \"1\");\r\n        }\r\n\r\n        // memory usage and system attributes\r\n        prop.put(\"freeMemory\", Formatter.bytesToString(MemoryControl.free()));\r\n        prop.put(\"totalMemory\", Formatter.bytesToString(MemoryControl.total()));\r\n        prop.put(\"maxMemory\", Formatter.bytesToString(MemoryControl.maxMemory()));\r\n        prop.put(\"processors\", WorkflowProcessor.availableCPU);\r\n        prop.put(\"load\", Memory.load());\r\n\r\n        // proxy traffic\r\n        //prop.put(\"trafficIn\",bytesToString(httpdByteCountInputStream.getGlobalCount()));\r\n        prop.put(\"trafficProxy\", Formatter.bytesToString(ByteCount.getAccountCount(ByteCount.PROXY)));\r\n        prop.put(\"trafficCrawler\", Formatter.bytesToString(ByteCount.getAccountCount(ByteCount.CRAWLER)));\r\n\r\n        // connection information\r\n        final YaCyHttpServer httpd =  sb.getHttpServer();\r\n\r\n        prop.putNum(\"connectionsActive\", httpd.getJobCount());\r\n        prop.putNum(\"connectionsMax\", httpd.getMaxSessionCount());\r\n\r\n        // Queue information\r\n        final int loaderJobCount = sb.crawlQueues.workerSize();\r\n        final int loaderMaxCount = sb.getConfigInt(SwitchboardConstants.CRAWLER_THREADS_ACTIVE_MAX, 10);\r\n        final int loaderPercent = (loaderMaxCount == 0) ? 0 : loaderJobCount * 100 / loaderMaxCount;\r\n        prop.putNum(\"loaderQueueSize\", loaderJobCount);\r\n        prop.putNum(\"loaderQueueMax\", loaderMaxCount);\r\n        prop.put(\"loaderQueuePercent\", (loaderPercent > 100) ? 100 : loaderPercent);\r\n\r\n        prop.putNum(\"localCrawlQueueSize\", sb\r\n            .getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)\r\n            .getJobCount());\r\n        prop.put(\"localCrawlPaused\", sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)\r\n            ? \"1\"\r\n            : \"0\");\r\n\r\n        prop.putNum(\r\n            \"remoteTriggeredCrawlQueueSize\",\r\n            sb.getThread(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL).getJobCount());\r\n        prop.put(\r\n            \"remoteTriggeredCrawlPaused\",\r\n            sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL) ? \"1\" : \"0\");\r\n\r\n        prop.putNum(\"stackCrawlQueueSize\", sb.crawlStacker.size());\r\n\r\n        // return rewrite properties\r\n        prop.put(\"date\", (new Date()).toString());\r\n        return prop;\r\n    }","id":76355,"modified_method":"public static serverObjects respond(\r\n        final RequestHeader header,\r\n        final serverObjects post,\r\n        final serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n\r\n        // check if the basic configuration was accessed before and forward\r\n        prop.put(\"forwardToConfigBasic\", 0);\r\n        if ( (post == null || !post.containsKey(\"noforward\"))\r\n            && sb.getConfig(\"server.servlets.submitted\", \"\").indexOf(\"ConfigBasic.html\", 0) < 0\r\n            && Seed.isDefaultPeerName(sb.peers.mySeed().getName()) ) {\r\n            // forward to ConfigBasic\r\n            prop.put(\"forwardToConfigBasic\", 1);\r\n        }\r\n        if ( post != null ) {\r\n            post.remove(\"noforward\");\r\n        }\r\n\r\n        if ( post != null && !post.isEmpty() ) {\r\n            if ( sb.adminAuthenticated(header) < 2 ) {\r\n            \tprop.authenticationRequired();\r\n                return prop;\r\n            }\r\n            boolean redirect = false;\r\n            if ( post.containsKey(\"login\") ) {\r\n                prop.put(serverObjects.ACTION_LOCATION, \"\");\r\n                return prop;\r\n            } else if ( post.containsKey(\"pauseCrawlJob\") ) {\r\n                final String jobType = post.get(\"jobType\");\r\n                if ( \"localCrawl\".equals(jobType) ) {\r\n                    sb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, \"user demand on Status.html\");\r\n                } else if ( \"remoteTriggeredCrawl\".equals(jobType) ) {\r\n                    sb.pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, \"user demand on Status.html\");\r\n                }\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"continueCrawlJob\") ) {\r\n                final String jobType = post.get(\"jobType\");\r\n                if ( \"localCrawl\".equals(jobType) ) {\r\n                    sb.continueCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL);\r\n                } else if ( \"remoteTriggeredCrawl\".equals(jobType) ) {\r\n                    sb.continueCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL);\r\n                }\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"ResetTraffic\") ) {\r\n                ByteCount.resetCount();\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"popup\") ) {\r\n                final boolean trigger_enabled = post.getBoolean(\"popup\");\r\n                sb.setConfig(\"browserPopUpTrigger\", trigger_enabled);\r\n                redirect = true;\r\n            } else if ( post.containsKey(\"tray\") ) {\r\n                final boolean trigger_enabled = post.getBoolean(\"tray\");\r\n                sb.setConfig(\"trayIcon\", trigger_enabled);\r\n                redirect = true;\r\n            }\r\n\r\n            if ( redirect ) {\r\n                prop.put(serverObjects.ACTION_LOCATION, \"\");\r\n                return prop;\r\n            }\r\n        }\r\n\r\n        // update seed info\r\n        //sb.updateMySeed(); // don't do this here. if Solr is stuck, this makes it worse. And it prevents that we can click on the Thread Dump menu.\r\n\r\n        final boolean adminaccess = sb.adminAuthenticated(header) >= 2;\r\n        if ( adminaccess ) {\r\n            prop.put(\"showPrivateTable\", \"1\");\r\n            prop.put(\"privateStatusTable\", \"Status_p.inc\");\r\n        } else {\r\n            prop.put(\"showPrivateTable\", \"0\");\r\n            prop.put(\"privateStatusTable\", \"\");\r\n        }\r\n\r\n        // password protection\r\n        if ( (sb.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").isEmpty())\r\n            && (!sb.getConfigBool(\"adminAccountForLocalhost\", false)) ) {\r\n            prop.put(\"protection\", \"0\"); // not protected\r\n            prop.put(\"urgentSetPassword\", \"1\");\r\n        } else {\r\n            prop.put(\"protection\", \"1\"); // protected\r\n        }\r\n\r\n        if ( sb.getConfigBool(\"adminAccountForLocalhost\", false) ) {\r\n            prop.put(\"unrestrictedLocalAccess\", 1);\r\n        }\r\n\r\n        // resource observer status\r\n        if ( adminaccess ) {\r\n            if ( !sb.observer.getDiskAvailable() ) {\r\n                final String minFree = Formatter.bytesToString(sb.observer.getMinFreeDiskSpace());\r\n                prop.put(\"warningDiskSpaceLow\", \"1\");\r\n                prop.put(\"warningDiskSpaceLow_minSpace\", minFree);\r\n            }\r\n            if ( !sb.observer.getMemoryAvailable() ) {\r\n                final String minFree =\r\n                    Formatter.bytesToString(sb.observer.getMinFreeMemory() * 1024L * 1024L);\r\n                prop.put(\"warningMemoryLow\", \"1\");\r\n                prop.put(\"warningMemoryLow_minSpace\", minFree);\r\n            }\r\n\r\n        }\r\n\r\n        // version information\r\n        //final String versionstring = yacyVersion.combined2prettyVersion(sb.getConfig(\"version\",\"0.1\"));\r\n        final String versionstring =\r\n            yacyBuildProperties.getVersion() + \"/\" + yacyBuildProperties.getSVNRevision();\r\n        prop.put(\"versionpp\", versionstring);\r\n\r\n        // place some more hints\r\n        if (adminaccess && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() == 0) {\r\n            prop.put(\"hintCrawlStart\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() > 500) {\r\n            prop.put(\"hintCrawlMonitor\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && \"intranet|webportal|allip\".indexOf(env.getConfig(SwitchboardConstants.NETWORK_NAME, \"unspecified\")) >= 0) {\r\n            prop.put(\"hintSupport\", \"1\");\r\n        }\r\n\r\n        if (adminaccess && sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)) {\r\n            prop.put(\"warningCrawlPaused\", \"1\");\r\n        }\r\n\r\n        // hostname and port\r\n        final String extendedPortString = sb.getConfig(\"port\", \"8090\");\r\n        final int pos = extendedPortString.indexOf(':', 0);\r\n        prop.put(\"port\", extendedPortString);\r\n        if ( pos != -1 ) {\r\n            prop.put(\"extPortFormat\", \"1\");\r\n            prop.putHTML(\"extPortFormat_extPort\", extendedPortString);\r\n        } else {\r\n            prop.put(\"extPortFormat\", \"0\");\r\n        }\r\n        final InetAddress hostIP = Domains.myPublicLocalIP();\r\n        prop.put(\"host\", hostIP != null ? hostIP.getHostAddress() : \"Unkown IP\");\r\n\r\n        // ssl support\r\n        prop.put(\"sslSupport\", sb.getConfig(\"keyStore\", \"\").isEmpty() || !sb.getConfigBool(\"server.https\", false) ? 0 : 1);\r\n        if (sb.getConfigBool(\"server.https\", false)) prop.put(\"sslSupport_sslPort\", sb.getHttpServer().getSslPort());\r\n        \r\n        // proxy information\r\n        if ( sb.getConfigBool(\"remoteProxyUse\", false) ) {\r\n            prop.put(\"remoteProxy\", \"1\");\r\n            prop.putXML(\"remoteProxy_host\", sb.getConfig(\"remoteProxyHost\", \"<unknown>\"));\r\n            prop.putXML(\"remoteProxy_port\", sb.getConfig(\"remoteProxyPort\", \"<unknown>\"));\r\n            prop.put(\"remoteProxy_4Yacy\", sb.getConfigBool(\"remoteProxyUse4Yacy\", true) ? \"0\" : \"1\");\r\n        } else {\r\n            prop.put(\"remoteProxy\", \"0\"); // not used\r\n        }\r\n        prop.put(\"info_isTransparentProxy\", sb.getConfigBool(\"isTransparentProxy\", false) ? \"on\" : \"off\");          \r\n        prop.put(\"info_proxyURL\", sb.getConfigBool(\"proxyURL\", false) ? \"on\" : \"off\");       \r\n        \r\n        // peer information\r\n        String thisHash = \"\";\r\n        final String thisName = sb.peers.mySeed().getName();\r\n        if ( sb.peers.mySeed() == null ) {\r\n            thisHash = \"not assigned\";\r\n            prop.put(\"peerAddress\", \"0\"); // not assigned\r\n            prop.put(\"peerStatistics\", \"0\"); // unknown\r\n        } else {\r\n            final long uptime = 60000 * sb.peers.mySeed().getLong(Seed.UPTIME, 0L);\r\n            prop.put(\"peerStatistics\", \"1\");\r\n            prop.put(\"peerStatistics_uptime\", PeerActions.formatInterval(uptime));\r\n            prop.putNum(\"peerStatistics_pagesperminute\", sb.peers.mySeed().getPPM());\r\n            prop.putNum(\r\n                \"peerStatistics_queriesperhour\",\r\n                Math.round(6000d * sb.peers.mySeed().getQPM()) / 100d);\r\n            prop.putNum(\"peerStatistics_links\", sb.peers.mySeed().getLinkCount());\r\n            prop.put(\"peerStatistics_words\", Formatter.number(sb.peers.mySeed().getWordCount()));\r\n            prop.putNum(\"peerStatistics_disconnects\", sb.peers.peerActions.disconnects);\r\n            prop.put(\"peerStatistics_connects\", Formatter.number(sb.peers.mySeed().get(Seed.CCOUNT, \"0\")));\r\n            thisHash = sb.peers.mySeed().hash;\r\n            if ( sb.peers.mySeed().getPublicAddress() == null ) {\r\n                prop.put(\"peerAddress\", \"0\"); // not assigned + instructions\r\n                prop.put(\"warningGoOnline\", \"1\");\r\n            } else {\r\n                prop.put(\"peerAddress\", \"1\"); // Address\r\n                prop.put(\"peerAddress_address\", sb.peers.mySeed().getPublicAddress());\r\n                prop.putXML(\"peerAddress_peername\", sb.peers.mySeed().getName().toLowerCase());\r\n            }\r\n        }\r\n        final String peerStatus =\r\n            ((sb.peers.mySeed() == null) ? Seed.PEERTYPE_VIRGIN : sb.peers.mySeed().get(\r\n                Seed.PEERTYPE,\r\n                Seed.PEERTYPE_VIRGIN));\r\n\r\n        if ( Seed.PEERTYPE_VIRGIN.equals(peerStatus)\r\n            && \"freeworld\".equals(sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"))\r\n            && !SwitchboardConstants.CLUSTER_MODE_PRIVATE_PEER.equals(sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\"))) {\r\n            prop.put(PEERSTATUS, \"0\");\r\n            prop.put(\"urgentStatusVirgin\", \"1\");\r\n        } else if ( Seed.PEERTYPE_JUNIOR.equals(peerStatus)\r\n            && \"freeworld\".equals(sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\"))\r\n            && !SwitchboardConstants.CLUSTER_MODE_PRIVATE_PEER.equals(sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\"))) {\r\n            prop.put(PEERSTATUS, \"1\");\r\n            prop.put(\"warningStatusJunior\", \"1\");\r\n        } else if ( Seed.PEERTYPE_SENIOR.equals(peerStatus) ) {\r\n            prop.put(PEERSTATUS, \"2\");\r\n            prop.put(\"hintStatusSenior\", \"1\");\r\n        } else if ( Seed.PEERTYPE_PRINCIPAL.equals(peerStatus) ) {\r\n            prop.put(PEERSTATUS, \"3\");\r\n            prop.put(\"hintStatusPrincipal\", \"1\");\r\n            prop.putHTML(\"hintStatusPrincipal_seedURL\", sb.peers.mySeed().get(Seed.SEEDLISTURL, \"?\"));\r\n        }\r\n        prop.putHTML(\"peerName\", thisName);\r\n        prop.put(\"hash\", thisHash);\r\n\r\n        final String seedUploadMethod = sb.getConfig(\"seedUploadMethod\", \"\");\r\n        if ( !\"none\".equalsIgnoreCase(seedUploadMethod)\r\n            || (\"\".equals(seedUploadMethod) && (sb.getConfig(\"seedFTPPassword\", \"\").length() > 0 || sb\r\n                .getConfig(\"seedFilePath\", \"\")\r\n                .length() > 0)) ) {\r\n            if ( \"\".equals(seedUploadMethod) ) {\r\n                if ( sb.getConfig(\"seedFTPPassword\", \"\").length() > 0 ) {\r\n                    sb.setConfig(\"seedUploadMethod\", \"Ftp\");\r\n                }\r\n                if ( sb.getConfig(\"seedFilePath\", \"\").length() > 0 ) {\r\n                    sb.setConfig(\"seedUploadMethod\", \"File\");\r\n                }\r\n            }\r\n\r\n            if ( \"ftp\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"1\"); // enabled\r\n                prop.putHTML(\"seedServer_seedServer\", sb.getConfig(\"seedFTPServer\", \"\"));\r\n            } else if ( \"scp\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"1\"); // enabled\r\n                prop.putHTML(\"seedServer_seedServer\", sb.getConfig(\"seedScpServer\", \"\"));\r\n            } else if ( \"file\".equalsIgnoreCase(seedUploadMethod) ) {\r\n                prop.put(SEEDSERVER, \"2\"); // enabled\r\n                prop.putHTML(\"seedServer_seedFile\", sb.getConfig(\"seedFilePath\", \"\"));\r\n            }\r\n            prop.put(\r\n                \"seedServer_lastUpload\",\r\n                PeerActions.formatInterval(System.currentTimeMillis() - sb.peers.lastSeedUpload_timeStamp));\r\n        } else {\r\n            prop.put(SEEDSERVER, \"0\"); // disabled\r\n        }\r\n\r\n        if ( sb.peers != null && sb.peers.sizeConnected() > 0 ) {\r\n            prop.put(\"otherPeers\", \"1\");\r\n            prop.putNum(\"otherPeers_num\", sb.peers.sizeConnected());\r\n        } else {\r\n            prop.put(\"otherPeers\", \"0\"); // not online\r\n        }\r\n\r\n        if ( !sb.getConfigBool(\"browserPopUpTrigger\", false) ) {\r\n            prop.put(\"popup\", \"0\");\r\n        } else {\r\n            prop.put(\"popup\", \"1\");\r\n        }\r\n\r\n        if ( !OS.isWindows ) {\r\n            prop.put(\"tray\", \"2\");\r\n        } else if ( !sb.getConfigBool(\"trayIcon\", false) ) {\r\n            prop.put(\"tray\", \"0\");\r\n        } else {\r\n            prop.put(\"tray\", \"1\");\r\n        }\r\n\r\n        // memory usage and system attributes\r\n        prop.put(\"freeMemory\", Formatter.bytesToString(MemoryControl.free()));\r\n        prop.put(\"totalMemory\", Formatter.bytesToString(MemoryControl.total()));\r\n        prop.put(\"maxMemory\", Formatter.bytesToString(MemoryControl.maxMemory()));\r\n        prop.put(\"processors\", WorkflowProcessor.availableCPU);\r\n        prop.put(\"load\", Memory.load());\r\n\r\n        // proxy traffic\r\n        //prop.put(\"trafficIn\",bytesToString(httpdByteCountInputStream.getGlobalCount()));\r\n        prop.put(\"trafficProxy\", Formatter.bytesToString(ByteCount.getAccountCount(ByteCount.PROXY)));\r\n        prop.put(\"trafficCrawler\", Formatter.bytesToString(ByteCount.getAccountCount(ByteCount.CRAWLER)));\r\n\r\n        // connection information\r\n        final YaCyHttpServer httpd =  sb.getHttpServer();\r\n\r\n        prop.putNum(\"connectionsActive\", httpd.getJobCount());\r\n        prop.putNum(\"connectionsMax\", httpd.getMaxSessionCount());\r\n\r\n        // Queue information\r\n        final int loaderJobCount = sb.crawlQueues.workerSize();\r\n        final int loaderMaxCount = sb.getConfigInt(SwitchboardConstants.CRAWLER_THREADS_ACTIVE_MAX, 10);\r\n        final int loaderPercent = (loaderMaxCount == 0) ? 0 : loaderJobCount * 100 / loaderMaxCount;\r\n        prop.putNum(\"loaderQueueSize\", loaderJobCount);\r\n        prop.putNum(\"loaderQueueMax\", loaderMaxCount);\r\n        prop.put(\"loaderQueuePercent\", (loaderPercent > 100) ? 100 : loaderPercent);\r\n\r\n        prop.putNum(\"localCrawlQueueSize\", sb\r\n            .getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)\r\n            .getJobCount());\r\n        prop.put(\"localCrawlPaused\", sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL)\r\n            ? \"1\"\r\n            : \"0\");\r\n\r\n        prop.putNum(\r\n            \"remoteTriggeredCrawlQueueSize\",\r\n            sb.getThread(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL).getJobCount());\r\n        prop.put(\r\n            \"remoteTriggeredCrawlPaused\",\r\n            sb.crawlJobIsPaused(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL) ? \"1\" : \"0\");\r\n\r\n        prop.putNum(\"stackCrawlQueueSize\", sb.crawlStacker.size());\r\n\r\n        // return rewrite properties\r\n        prop.put(\"date\", (new Date()).toString());\r\n        return prop;\r\n    }","commit_id":"eaf596a2571bb4131189b06383880e76ac3cea73","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n\n        final String eventID = post.get(\"eventID\", \"\");\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final int item = post.getInt(\"item\", -1);\n        final boolean auth = Domains.isLocalhost(header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"\")) || sb.verifyAuthentication(header);\n        final RequestHeader.FileType fileType = header.fileType();\n\n        // default settings for blank item\n        prop.put(\"content\", \"0\");\n        prop.put(\"rss\", \"0\");\n        prop.put(\"references\", \"0\");\n        prop.put(\"rssreferences\", \"0\");\n        prop.put(\"dynamic\", \"0\");\n\n        // find search event\n        final SearchEvent theSearch = SearchEventCache.getEvent(eventID);\n        if (theSearch == null) {\n            // the event does not exist, show empty page\n            return prop;\n        }\n\n        // dynamically update count values\n        prop.put(\"offset\", theSearch.query.neededResults() - theSearch.query.itemsPerPage() + 1);\n        prop.put(\"itemscount\", Formatter.number(Math.min((item < 0) ? theSearch.query.neededResults() : item + 1, theSearch.getResultCount())));\n        prop.put(\"itemsperpage\", Formatter.number(theSearch.query.itemsPerPage));\n        prop.put(\"totalcount\", Formatter.number(theSearch.getResultCount(), true));\n        prop.put(\"localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n        prop.put(\"remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n        prop.put(\"remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n        prop.put(\"remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n        prop.put(\"navurlBase\", QueryParams.navurlBase(\"html\", theSearch.query, null).toString());\n        final String target_special_pattern = sb.getConfig(SwitchboardConstants.SEARCH_TARGET_SPECIAL_PATTERN, \"\");\n\n        long timeout = item == 0 ? 10000 : (theSearch.query.isLocal() ? 1000 : 3000);\n        \n        if (theSearch.query.contentdom == Classification.ContentDomain.TEXT || theSearch.query.contentdom == Classification.ContentDomain.ALL) {\n            // text search\n\n            // generate result object\n            final ResultEntry result = theSearch.oneResult(item, timeout);\n            if (result == null) return prop; // no content\n            final String resultUrlstring = result.urlstring();\n            final DigestURL resultURL = result.url();\n            final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n            final int port = resultURL.getPort();\n            DigestURL faviconURL = null;\n            if ((fileType == FileType.HTML || fileType == FileType.JSON) && !sb.isIntranetMode()) try {\n                faviconURL = new DigestURL(resultURL.getProtocol() + \"://\" + resultURL.getHost() + ((port != -1) ? (\":\" + port) : \"\") + \"/favicon.ico\");\n            } catch (final MalformedURLException e1) {\n                ConcurrentLog.logException(e1);\n                faviconURL = null;\n            }\n            final String resource = theSearch.query.domType.toString();\n            final String origQ = theSearch.query.getQueryGoal().getOriginalQueryString(true);\n            prop.put(\"content\", 1); // switch on specific content\n            prop.put(\"content_showDate\", sb.getConfigBool(\"search.result.show.date\", true) ? 1 : 0);\n            prop.put(\"content_showSize\", sb.getConfigBool(\"search.result.show.size\", true) ? 1 : 0);\n            prop.put(\"content_showMetadata\", sb.getConfigBool(\"search.result.show.metadata\", true) ? 1 : 0);\n            prop.put(\"content_showParser\", sb.getConfigBool(\"search.result.show.parser\", true) ? 1 : 0);\n            prop.put(\"content_showCitation\", sb.getConfigBool(\"search.result.show.citation\", true) ? 1 : 0);\n            prop.put(\"content_showPictures\", sb.getConfigBool(\"search.result.show.pictures\", true) ? 1 : 0);\n            prop.put(\"content_showCache\", sb.getConfigBool(\"search.result.show.cache\", true) && Cache.has(resultURL.hash()) ? 1 : 0);\n            prop.put(\"content_showProxy\", sb.getConfigBool(\"search.result.show.proxy\", true) ? 1 : 0);\n            prop.put(\"content_showHostBrowser\", sb.getConfigBool(\"search.result.show.hostbrowser\", true) ? 1 : 0);\n            prop.put(\"content_showTags\", sb.getConfigBool(\"search.result.show.tags\", false) ? 1 : 0);\n            prop.put(\"content_authorized\", authenticated ? \"1\" : \"0\");\n            final String urlhash = ASCII.String(result.hash());\n            prop.put(\"content_authorized_bookmark\", sb.tables.bookmarks.hasBookmark(\"admin\", urlhash) ? \"0\" : \"1\");\n            prop.putHTML(\"content_authorized_bookmark_bookmarklink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&bookmarkref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.put(\"content_authorized_recommend\", (sb.peers.newsPool.getSpecific(NewsPool.OUTGOING_DB, NewsPool.CATEGORY_SURFTIPP_ADD, \"url\", resultUrlstring) == null) ? \"1\" : \"0\");\n            prop.putHTML(\"content_authorized_recommend_deletelink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&deleteref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.putHTML(\"content_authorized_recommend_recommendlink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&recommendref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.put(\"content_authorized_urlhash\", urlhash);\n            final String resulthashString = urlhash;\n            prop.putHTML(\"content_title\", result.title());\n            prop.putXML(\"content_title-xml\", result.title());\n            prop.putJSON(\"content_title-json\", result.title());\n            prop.putHTML(\"content_showPictures_link\", resultUrlstring);\n            //prop.putHTML(\"content_link\", resultUrlstring);\n\n// START interaction\n            String modifyURL = resultUrlstring;\n\t\t\tif (sb.getConfigBool(\"proxyURL.useforresults\", false)) {\n\t\t\t\t// check if url is allowed to view\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"all\")) {\n\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t}\n\n\t\t\t\t// check if url is allowed to view\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"domainlist\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (sb.crawlStacker.urlInAcceptedDomain(new DigestURL (modifyURL)) == null) {\n\t\t\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (final MalformedURLException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"yacy\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif ((new DigestURL (modifyURL).getHost().endsWith(\".yacy\"))) {\n\t\t\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (final MalformedURLException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            prop.putHTML(\"content_link\", modifyURL);\n//            prop.putHTML(\"content_value\", Interaction.TripleGet(result.urlstring(), \"http://virtual.x/hasvalue\", \"anonymous\"));\n// END interaction\n\n            String resultFileName = resultURL.getFileName();\n            prop.putHTML(\"content_target\", target);\n            if (faviconURL != null && fileType == FileType.HTML) sb.loader.loadIfNotExistBackground(faviconURL, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n            prop.putHTML(\"content_faviconCode\", URLLicense.aquireLicense(faviconURL)); // acquire license for favicon url loading\n            prop.put(\"content_urlhash\", resulthashString);\n            prop.put(\"content_ranking\", result.ranking());\n            prop.put(\"content_showMetadata_urlhash\", resulthashString);\n            prop.put(\"content_showCache_link\", resultUrlstring);\n            prop.put(\"content_showProxy_link\", resultUrlstring);\n            prop.put(\"content_showHostBrowser_link\", resultUrlstring);\n            prop.put(\"content_showParser_urlhash\", resulthashString);\n            prop.put(\"content_showCitation_urlhash\", resulthashString);\n            prop.put(\"content_showTags_urlhash\", resulthashString);\n            prop.put(\"content_urlhexhash\", Seed.b64Hash2hexHash(resulthashString));\n            prop.putHTML(\"content_urlname\", nxTools.shortenURLString(result.urlname(), MAX_URL_LENGTH));\n            prop.put(\"content_showDate_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(result.modified()));\n            prop.put(\"content_date822\", HeaderFramework.formatRFC1123(result.modified()));\n            //prop.put(\"content_ybr\", RankingProcess.ybr(result.hash()));\n            prop.putHTML(\"content_size\", Integer.toString(result.filesize())); // we don't use putNUM here because that number shall be usable as sorting key. To print the size, use 'sizename'\n            prop.putHTML(\"content_sizename\", RSSMessage.sizename(result.filesize()));\n            prop.putHTML(\"content_showSize_sizename\", RSSMessage.sizename(result.filesize()));\n            prop.putHTML(\"content_host\", resultURL.getHost() == null ? \"\" : resultURL.getHost());\n            prop.putHTML(\"content_file\", resultFileName);\n            prop.putHTML(\"content_path\", resultURL.getPath());\n            prop.put(\"content_nl\", (item == theSearch.query.offset) ? 0 : 1);\n            prop.putHTML(\"content_publisher\", result.publisher());\n            prop.putHTML(\"content_creator\", result.creator());// author\n            prop.putHTML(\"content_subject\", result.subject());\n            final Iterator<String> query = theSearch.query.getQueryGoal().getIncludeStrings();\n            final StringBuilder s = new StringBuilder(theSearch.query.getQueryGoal().getIncludeSize() * 20);\n            while (query.hasNext()) s.append('+').append(query.next());\n            final String words = (s.length() > 0) ? s.substring(1) : \"\";\n            prop.putHTML(\"content_words\", words);\n            prop.putHTML(\"content_showParser_words\", words);\n            prop.putHTML(\"content_former\", origQ);\n            prop.putHTML(\"content_showPictures_former\", origQ);\n            final TextSnippet snippet = result.textSnippet();\n            final String desc = (snippet == null) ? \"\" : snippet.isMarked() ? snippet.getLineRaw() : snippet.getLineMarked(theSearch.query.getQueryGoal());\n            prop.put(\"content_description\", desc);\n            prop.putXML(\"content_description-xml\", desc);\n            prop.putJSON(\"content_description-json\", desc);\n            final HeuristicResult heuristic = theSearch.getHeuristic(result.hash());\n            if (heuristic == null) {\n                prop.put(\"content_heuristic\", 0);\n            } else {\n                if (heuristic.redundant) {\n                    prop.put(\"content_heuristic\", 1);\n                } else {\n                    prop.put(\"content_heuristic\", 2);\n                }\n                prop.put(\"content_heuristic_name\", heuristic.heuristicName);\n            }\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theSearch.query.id(true), SearchEventType.FINALIZATION, \"\" + item, 0, 0), false);\n            final String ext = MultiProtocolURL.getFileExtension(resultFileName).toLowerCase();\n            if (MultiProtocolURL.isImage(ext)) {\n                final String license = URLLicense.aquireLicense(resultURL);\n                prop.put(\"content_code\", license);\n            } else {\n                prop.put(\"content_code\", \"\");\n            }\n            if (result.lat() == 0.0d || result.lon() == 0.0d) {\n                prop.put(\"content_loc\", 0);\n            } else {\n                prop.put(\"content_loc\", 1);\n                prop.put(\"content_loc_lat\", result.lat());\n                prop.put(\"content_loc_lon\", result.lon());\n            }\n            final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n            final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n            boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n            boolean stealthmode = p2pmode && theSearch.query.isLocal();\n            if ((sb.getConfigBool(SwitchboardConstants.HEURISTIC_SEARCHRESULTS, false) ||\n                (sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false) && sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ENABLED, false) && Memory.load() < 1.0)) &&\n                !stealthmode) sb.heuristicSearchResults(resultUrlstring);\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if (theSearch.query.contentdom == Classification.ContentDomain.IMAGE) {\n            // image search; shows thumbnails\n\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            SearchEvent.ImageResult image = null;\n            try {\n                image = theSearch.oneImageResult(item, timeout);\n                final String imageUrlstring = image.imageUrl.toNormalform(true);\n                final String target = sb.getConfig(imageUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n                final String license = URLLicense.aquireLicense(image.imageUrl);\n                sb.loader.loadIfNotExistBackground(image.imageUrl, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n                prop.putHTML(\"content_item_hrefCache\", (auth) ? \"/ViewImage.png?url=\" + imageUrlstring : imageUrlstring);\n                prop.putHTML(\"content_item_href\", imageUrlstring);\n                prop.putHTML(\"content_item_target\", target);\n                prop.put(\"content_item_code\", license);\n                prop.putHTML(\"content_item_name\", shorten(image.imagetext, MAX_NAME_LENGTH));\n                prop.put(\"content_item_mimetype\", image.mimetype);\n                prop.put(\"content_item_fileSize\", 0);\n                prop.put(\"content_item_width\", image.width);\n                prop.put(\"content_item_height\", image.height);\n                prop.put(\"content_item_attr\", \"\"/*(ms.attr.equals(\"-1 x -1\")) ? \"\" : \"(\" + ms.attr + \")\"*/); // attributes, here: original size of image\n                prop.put(\"content_item_urlhash\", ASCII.String(image.imageUrl.hash()));\n                prop.put(\"content_item_source\", image.sourceUrl.toNormalform(true));\n                prop.putXML(\"content_item_source-xml\", image.sourceUrl.toNormalform(true));\n                prop.put(\"content_item_sourcedom\", image.sourceUrl.getHost());\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            } catch (MalformedURLException e) {\n                prop.put(\"content_item\", \"0\");\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if ((theSearch.query.contentdom == ContentDomain.AUDIO) ||\n            (theSearch.query.contentdom == ContentDomain.VIDEO) ||\n            (theSearch.query.contentdom == ContentDomain.APP)) {\n            // any other media content\n\n            // generate result object\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_hrefshort\", nxTools.shortenURLString(resultUrlstring, MAX_URL_LENGTH));\n                prop.putHTML(\"content_item_target\", target);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_col\", (item % 2 == 0) ? \"0\" : \"1\");\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        return prop;\n    }","id":76356,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n\n        final String eventID = post.get(\"eventID\", \"\");\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final int item = post.getInt(\"item\", -1);\n        final boolean auth = Domains.isLocalhost(header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"\")) || sb.verifyAuthentication(header);\n        final RequestHeader.FileType fileType = header.fileType();\n\n        // default settings for blank item\n        prop.put(\"content\", \"0\");\n        prop.put(\"rss\", \"0\");\n        prop.put(\"references\", \"0\");\n        prop.put(\"rssreferences\", \"0\");\n        prop.put(\"dynamic\", \"0\");\n\n        // find search event\n        final SearchEvent theSearch = SearchEventCache.getEvent(eventID);\n        if (theSearch == null) {\n            // the event does not exist, show empty page\n            return prop;\n        }\n\n        // dynamically update count values\n        prop.put(\"offset\", theSearch.query.neededResults() - theSearch.query.itemsPerPage() + 1);\n        prop.put(\"itemscount\", Formatter.number(Math.min((item < 0) ? theSearch.query.neededResults() : item + 1, theSearch.getResultCount())));\n        prop.put(\"itemsperpage\", Formatter.number(theSearch.query.itemsPerPage));\n        prop.put(\"totalcount\", Formatter.number(theSearch.getResultCount(), true));\n        prop.put(\"localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n        prop.put(\"remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n        prop.put(\"remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n        prop.put(\"remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n        prop.put(\"navurlBase\", QueryParams.navurlBase(\"html\", theSearch.query, null).toString());\n        final String target_special_pattern = sb.getConfig(SwitchboardConstants.SEARCH_TARGET_SPECIAL_PATTERN, \"\");\n\n        long timeout = item == 0 ? 10000 : (theSearch.query.isLocal() ? 1000 : 3000);\n        \n        if (theSearch.query.contentdom == Classification.ContentDomain.TEXT || theSearch.query.contentdom == Classification.ContentDomain.ALL) {\n            // text search\n\n            // generate result object\n            final ResultEntry result = theSearch.oneResult(item, timeout);\n            if (result == null) return prop; // no content\n            final String resultUrlstring = result.urlstring();\n            final DigestURL resultURL = result.url();\n            final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n            final int port = resultURL.getPort();\n            DigestURL faviconURL = null;\n            if ((fileType == FileType.HTML || fileType == FileType.JSON) && !sb.isIntranetMode()) try {\n                faviconURL = new DigestURL(resultURL.getProtocol() + \"://\" + resultURL.getHost() + ((port != -1) ? (\":\" + port) : \"\") + \"/favicon.ico\");\n            } catch (final MalformedURLException e1) {\n                ConcurrentLog.logException(e1);\n                faviconURL = null;\n            }\n            final String resource = theSearch.query.domType.toString();\n            final String origQ = theSearch.query.getQueryGoal().getOriginalQueryString(true);\n            prop.put(\"content\", 1); // switch on specific content\n            prop.put(\"content_showDate\", sb.getConfigBool(\"search.result.show.date\", true) ? 1 : 0);\n            prop.put(\"content_showSize\", sb.getConfigBool(\"search.result.show.size\", true) ? 1 : 0);\n            prop.put(\"content_showMetadata\", sb.getConfigBool(\"search.result.show.metadata\", true) ? 1 : 0);\n            prop.put(\"content_showParser\", sb.getConfigBool(\"search.result.show.parser\", true) ? 1 : 0);\n            prop.put(\"content_showCitation\", sb.getConfigBool(\"search.result.show.citation\", true) ? 1 : 0);\n            prop.put(\"content_showPictures\", sb.getConfigBool(\"search.result.show.pictures\", true) ? 1 : 0);\n            prop.put(\"content_showCache\", sb.getConfigBool(\"search.result.show.cache\", true) && Cache.has(resultURL.hash()) ? 1 : 0);\n            prop.put(\"content_showProxy\", sb.getConfigBool(\"search.result.show.proxy\", true) ? 1 : 0);\n            prop.put(\"content_showHostBrowser\", sb.getConfigBool(\"search.result.show.hostbrowser\", true) ? 1 : 0);\n            prop.put(\"content_showTags\", sb.getConfigBool(\"search.result.show.tags\", false) ? 1 : 0);\n            prop.put(\"content_authorized\", authenticated ? \"1\" : \"0\");\n            final String urlhash = ASCII.String(result.hash());\n            prop.put(\"content_authorized_bookmark\", sb.tables.bookmarks.hasBookmark(\"admin\", urlhash) ? \"0\" : \"1\");\n            prop.putHTML(\"content_authorized_bookmark_bookmarklink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&bookmarkref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.put(\"content_authorized_recommend\", (sb.peers.newsPool.getSpecific(NewsPool.OUTGOING_DB, NewsPool.CATEGORY_SURFTIPP_ADD, \"url\", resultUrlstring) == null) ? \"1\" : \"0\");\n            prop.putHTML(\"content_authorized_recommend_deletelink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&deleteref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.putHTML(\"content_authorized_recommend_recommendlink\", \"/yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&recommendref=\" + urlhash + \"&urlmaskfilter=.*\");\n            prop.put(\"content_authorized_urlhash\", urlhash);\n            final String resulthashString = urlhash;\n            prop.putHTML(\"content_title\", result.title());\n            prop.putXML(\"content_title-xml\", result.title());\n            prop.putJSON(\"content_title-json\", result.title());\n            prop.putHTML(\"content_showPictures_link\", resultUrlstring);\n            //prop.putHTML(\"content_link\", resultUrlstring);\n\n// START interaction\n            String modifyURL = resultUrlstring;\n\t\t\tif (sb.getConfigBool(\"proxyURL.useforresults\", false) && sb.getConfigBool(\"proxyURL\", false)) {\n\t\t\t\t// check if url is allowed to view\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"all\")) {\n\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t}\n\n\t\t\t\t// check if url is allowed to view\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"domainlist\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (sb.crawlStacker.urlInAcceptedDomain(new DigestURL (modifyURL)) == null) {\n\t\t\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (final MalformedURLException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sb.getConfig(\"proxyURL.rewriteURLs\", \"all\").equals(\"yacy\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif ((new DigestURL (modifyURL).getHost().endsWith(\".yacy\"))) {\n\t\t\t\t\t\t\tmodifyURL = \"./proxy.html?url=\"+modifyURL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (final MalformedURLException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            prop.putHTML(\"content_link\", modifyURL);\n//            prop.putHTML(\"content_value\", Interaction.TripleGet(result.urlstring(), \"http://virtual.x/hasvalue\", \"anonymous\"));\n// END interaction\n\n            String resultFileName = resultURL.getFileName();\n            prop.putHTML(\"content_target\", target);\n            if (faviconURL != null && fileType == FileType.HTML) sb.loader.loadIfNotExistBackground(faviconURL, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n            prop.putHTML(\"content_faviconCode\", URLLicense.aquireLicense(faviconURL)); // acquire license for favicon url loading\n            prop.put(\"content_urlhash\", resulthashString);\n            prop.put(\"content_ranking\", result.ranking());\n            prop.put(\"content_showMetadata_urlhash\", resulthashString);\n            prop.put(\"content_showCache_link\", resultUrlstring);\n            prop.put(\"content_showProxy_link\", resultUrlstring);\n            prop.put(\"content_showHostBrowser_link\", resultUrlstring);\n            prop.put(\"content_showParser_urlhash\", resulthashString);\n            prop.put(\"content_showCitation_urlhash\", resulthashString);\n            prop.put(\"content_showTags_urlhash\", resulthashString);\n            prop.put(\"content_urlhexhash\", Seed.b64Hash2hexHash(resulthashString));\n            prop.putHTML(\"content_urlname\", nxTools.shortenURLString(result.urlname(), MAX_URL_LENGTH));\n            prop.put(\"content_showDate_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(result.modified()));\n            prop.put(\"content_date822\", HeaderFramework.formatRFC1123(result.modified()));\n            //prop.put(\"content_ybr\", RankingProcess.ybr(result.hash()));\n            prop.putHTML(\"content_size\", Integer.toString(result.filesize())); // we don't use putNUM here because that number shall be usable as sorting key. To print the size, use 'sizename'\n            prop.putHTML(\"content_sizename\", RSSMessage.sizename(result.filesize()));\n            prop.putHTML(\"content_showSize_sizename\", RSSMessage.sizename(result.filesize()));\n            prop.putHTML(\"content_host\", resultURL.getHost() == null ? \"\" : resultURL.getHost());\n            prop.putHTML(\"content_file\", resultFileName);\n            prop.putHTML(\"content_path\", resultURL.getPath());\n            prop.put(\"content_nl\", (item == theSearch.query.offset) ? 0 : 1);\n            prop.putHTML(\"content_publisher\", result.publisher());\n            prop.putHTML(\"content_creator\", result.creator());// author\n            prop.putHTML(\"content_subject\", result.subject());\n            final Iterator<String> query = theSearch.query.getQueryGoal().getIncludeStrings();\n            final StringBuilder s = new StringBuilder(theSearch.query.getQueryGoal().getIncludeSize() * 20);\n            while (query.hasNext()) s.append('+').append(query.next());\n            final String words = (s.length() > 0) ? s.substring(1) : \"\";\n            prop.putHTML(\"content_words\", words);\n            prop.putHTML(\"content_showParser_words\", words);\n            prop.putHTML(\"content_former\", origQ);\n            prop.putHTML(\"content_showPictures_former\", origQ);\n            final TextSnippet snippet = result.textSnippet();\n            final String desc = (snippet == null) ? \"\" : snippet.isMarked() ? snippet.getLineRaw() : snippet.getLineMarked(theSearch.query.getQueryGoal());\n            prop.put(\"content_description\", desc);\n            prop.putXML(\"content_description-xml\", desc);\n            prop.putJSON(\"content_description-json\", desc);\n            final HeuristicResult heuristic = theSearch.getHeuristic(result.hash());\n            if (heuristic == null) {\n                prop.put(\"content_heuristic\", 0);\n            } else {\n                if (heuristic.redundant) {\n                    prop.put(\"content_heuristic\", 1);\n                } else {\n                    prop.put(\"content_heuristic\", 2);\n                }\n                prop.put(\"content_heuristic_name\", heuristic.heuristicName);\n            }\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theSearch.query.id(true), SearchEventType.FINALIZATION, \"\" + item, 0, 0), false);\n            final String ext = MultiProtocolURL.getFileExtension(resultFileName).toLowerCase();\n            if (MultiProtocolURL.isImage(ext)) {\n                final String license = URLLicense.aquireLicense(resultURL);\n                prop.put(\"content_code\", license);\n            } else {\n                prop.put(\"content_code\", \"\");\n            }\n            if (result.lat() == 0.0d || result.lon() == 0.0d) {\n                prop.put(\"content_loc\", 0);\n            } else {\n                prop.put(\"content_loc\", 1);\n                prop.put(\"content_loc_lat\", result.lat());\n                prop.put(\"content_loc_lon\", result.lon());\n            }\n            final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n            final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n            boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n            boolean stealthmode = p2pmode && theSearch.query.isLocal();\n            if ((sb.getConfigBool(SwitchboardConstants.HEURISTIC_SEARCHRESULTS, false) ||\n                (sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false) && sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ENABLED, false) && Memory.load() < 1.0)) &&\n                !stealthmode) sb.heuristicSearchResults(resultUrlstring);\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if (theSearch.query.contentdom == Classification.ContentDomain.IMAGE) {\n            // image search; shows thumbnails\n\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            SearchEvent.ImageResult image = null;\n            try {\n                image = theSearch.oneImageResult(item, timeout);\n                final String imageUrlstring = image.imageUrl.toNormalform(true);\n                final String target = sb.getConfig(imageUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n                final String license = URLLicense.aquireLicense(image.imageUrl);\n                sb.loader.loadIfNotExistBackground(image.imageUrl, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n                prop.putHTML(\"content_item_hrefCache\", (auth) ? \"/ViewImage.png?url=\" + imageUrlstring : imageUrlstring);\n                prop.putHTML(\"content_item_href\", imageUrlstring);\n                prop.putHTML(\"content_item_target\", target);\n                prop.put(\"content_item_code\", license);\n                prop.putHTML(\"content_item_name\", shorten(image.imagetext, MAX_NAME_LENGTH));\n                prop.put(\"content_item_mimetype\", image.mimetype);\n                prop.put(\"content_item_fileSize\", 0);\n                prop.put(\"content_item_width\", image.width);\n                prop.put(\"content_item_height\", image.height);\n                prop.put(\"content_item_attr\", \"\"/*(ms.attr.equals(\"-1 x -1\")) ? \"\" : \"(\" + ms.attr + \")\"*/); // attributes, here: original size of image\n                prop.put(\"content_item_urlhash\", ASCII.String(image.imageUrl.hash()));\n                prop.put(\"content_item_source\", image.sourceUrl.toNormalform(true));\n                prop.putXML(\"content_item_source-xml\", image.sourceUrl.toNormalform(true));\n                prop.put(\"content_item_sourcedom\", image.sourceUrl.getHost());\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            } catch (MalformedURLException e) {\n                prop.put(\"content_item\", \"0\");\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if ((theSearch.query.contentdom == ContentDomain.AUDIO) ||\n            (theSearch.query.contentdom == ContentDomain.VIDEO) ||\n            (theSearch.query.contentdom == ContentDomain.APP)) {\n            // any other media content\n\n            // generate result object\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_hrefshort\", nxTools.shortenURLString(resultUrlstring, MAX_URL_LENGTH));\n                prop.putHTML(\"content_item_target\", target);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_col\", (item % 2 == 0) ? \"0\" : \"1\");\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        return prop;\n    }","commit_id":"eaf596a2571bb4131189b06383880e76ac3cea73","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public CreateSigningCertificateResponseType createSigningCertificate(CreateSigningCertificateType request) throws EucalyptusCloudException {\n    CreateSigningCertificateResponseType reply = request.getReply( );\n    reply.getResponseMetadata( ).setRequestId( reply.getCorrelationId( ) );\n    Context ctx = Contexts.lookup( );\n    User requestUser = ctx.getUser( );\n    Account account = getRealAccount( ctx, request.getDelegateAccount( ) );\n    User userFound = requestUser;\n    if ( !Strings.isNullOrEmpty( request.getUserName( ) ) ) {\n      userFound = lookupUserByName( account, request.getUserName( ) );\n    }\n    try {\n      KeyPair keyPair = Certs.generateKeyPair( );\n      Certificate cert = Privileged.createSigningCertificate( requestUser, account, userFound, keyPair );\n      SigningCertificateType result = reply.getCreateSigningCertificateResult( ).getCertificate( );\n      result.setUserName( userFound.getName( ) );\n      result.setCertificateId( cert.getCertificateId( ) );\n      result.setCertificateBody( cert.getPem( ) );\n      result.setPrivateKey( X509CertHelper.privateKeyToPem( keyPair.getPrivate( ) ) );\n      result.setStatus( \"Active\" );\n      result.setUploadDate( cert.getCreateDate( ) );\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      if ( e instanceof AuthException ) {\n        if ( AuthException.ACCESS_DENIED.equals( e.getMessage( ) ) ) {\n          throw new EuareException( HttpResponseStatus.FORBIDDEN, EuareException.NOT_AUTHORIZED, \"Not authorized to create signing certificate of \" + request.getUserName( ) + \"by \" + requestUser.getName( ) );\n        }\n      }\n      throw new EucalyptusCloudException( e );\n    }\n    return reply;\n  }","id":76357,"modified_method":"public CreateSigningCertificateResponseType createSigningCertificate(CreateSigningCertificateType request) throws EucalyptusCloudException {\n    CreateSigningCertificateResponseType reply = request.getReply( );\n    reply.getResponseMetadata( ).setRequestId( reply.getCorrelationId( ) );\n    Context ctx = Contexts.lookup( );\n    User requestUser = ctx.getUser( );\n    Account account = getRealAccount( ctx, request.getDelegateAccount( ) );\n    User userFound = requestUser;\n    if ( !Strings.isNullOrEmpty( request.getUserName( ) ) ) {\n      userFound = lookupUserByName( account, request.getUserName( ) );\n    }\n    try {\n      KeyPair keyPair = Certs.generateKeyPair( );\n      Certificate cert = Privileged.createSigningCertificate( requestUser, account, userFound, keyPair );\n      SigningCertificateType result = reply.getCreateSigningCertificateResult( ).getCertificate( );\n      result.setUserName( userFound.getName( ) );\n      result.setCertificateId( cert.getCertificateId( ) );\n      result.setCertificateBody( B64.url.decString( cert.getPem( ) ) );\n      result.setPrivateKey( X509CertHelper.privateKeyToPem( keyPair.getPrivate( ) ) );\n      result.setStatus( \"Active\" );\n      result.setUploadDate( cert.getCreateDate( ) );\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      if ( e instanceof AuthException ) {\n        if ( AuthException.ACCESS_DENIED.equals( e.getMessage( ) ) ) {\n          throw new EuareException( HttpResponseStatus.FORBIDDEN, EuareException.NOT_AUTHORIZED, \"Not authorized to create signing certificate of \" + request.getUserName( ) + \"by \" + requestUser.getName( ) );\n        }\n      }\n      throw new EucalyptusCloudException( e );\n    }\n    return reply;\n  }","commit_id":"4482b956e3a9c18ef1c4bb4f8a88b20c2b92acbb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static SearchResultRow serializeCert( User user, Certificate cert ) throws Exception {\n    SearchResultRow result = new SearchResultRow( );\n    result.addField( cert.getCertificateId( ) );\n    result.addField( cert.isActive( ).toString( ) );\n    result.addField( cert.isRevoked( ).toString( ) );\n    result.addField( cert.getCreateDate( ) == null ? \"\" : cert.getCreateDate( ).toString( ) );\n    result.addField( QueryBuilder.get( ).start( CategoryConstants.USER ).and( ACCOUNT, user.getAccount( ).getName( ) ).and( NAME, user.getName( ) ).url( ) );\n    result.addField( cert.getPem( ) );\n    return result;\n  }","id":76358,"modified_method":"private static SearchResultRow serializeCert( User user, Certificate cert ) throws Exception {\n    SearchResultRow result = new SearchResultRow( );\n    result.addField( cert.getCertificateId( ) );\n    result.addField( cert.isActive( ).toString( ) );\n    result.addField( cert.isRevoked( ).toString( ) );\n    result.addField( cert.getCreateDate( ) == null ? \"\" : cert.getCreateDate( ).toString( ) );\n    result.addField( QueryBuilder.get( ).start( CategoryConstants.USER ).and( ACCOUNT, user.getAccount( ).getName( ) ).and( NAME, user.getName( ) ).url( ) );\n    result.addField( B64.url.decString( cert.getPem( ) ) );\n    return result;\n  }","commit_id":"4ff01494be98ae523da48293f60631fbe112eb0f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public UploadSigningCertificateResponseType uploadSigningCertificate(UploadSigningCertificateType request) throws EucalyptusCloudException {\n    UploadSigningCertificateResponseType reply = request.getReply( );\n    reply.getResponseMetadata( ).setRequestId( reply.getCorrelationId( ) );\n    String action = PolicySpec.requestToAction( request );\n    User requestUser = Permissions.getUserById( request.getUserId( ) );\n    Account account = Permissions.getUserAccount( requestUser );\n    User userFound = null;\n    try {\n      userFound = account.lookupUserByName( request.getUserName( ) );\n    } catch ( Exception e ) {\n      if ( e instanceof AuthException && AuthException.NO_SUCH_USER.equals( e.getMessage( ) ) ) {\n        throw new EuareException( 404, EuareException.NO_SUCH_ENTITY, \"Can not find user \" + request.getUserName( ) );\n      } else {\n        throw new EucalyptusCloudException( e );\n      }\n    }\n    if ( !Permissions.isAuthorized( PolicySpec.IAM_RESOURCE_USER, getUserFullName( userFound ), account, action, requestUser ) ) {\n      throw new EuareException( 403, EuareException.NOT_AUTHORIZED,\n                                \"Not authorized to upload signing certificate of \" + request.getUserName( ) + \"by \" + requestUser.getName( ) );\n    }\n    Certificate cert = null;\n    try {\n      for ( Certificate c : userFound.getCertificates( ) ) {\n        if ( c.getPem( ).equals( request.getCertificateBody( ) ) ) {\n          if ( !c.isRevoked( ) ) {\n            throw new EuareException( 409, EuareException.DUPLICATE_CERTIFICATE, \"Trying to upload duplicate certificate: \" + c.getId( ) );        \n          } else {\n            userFound.removeCertificate( c.getId( ) );\n          }\n        }\n      }\n      X509Certificate x509 = X509CertHelper.toCertificate( request.getCertificateBody( ) );\n      if ( x509 == null ) {\n        throw new EuareException( 400, EuareException.INVALID_CERTIFICATE, \"Invalid certificate \" + request.getCertificateBody( ) );        \n      }\n      cert = userFound.addCertificate( x509 );\n    } catch ( Exception e ) {\n      throw new EucalyptusCloudException( e );\n    }\n    SigningCertificateType result = reply.getUploadSigningCertificateResult( ).getCertificate( );\n    result.setUserName( userFound.getName( ) );\n    result.setCertificateId( cert.getId( ) );\n    result.setCertificateBody( request.getCertificateBody( ) );\n    result.setStatus( \"Active\" );\n    result.setUploadDate( cert.getCreateDate( ) );\n    return reply;\n  }","id":76359,"modified_method":"public UploadSigningCertificateResponseType uploadSigningCertificate(UploadSigningCertificateType request) throws EucalyptusCloudException {\n    UploadSigningCertificateResponseType reply = request.getReply( );\n    reply.getResponseMetadata( ).setRequestId( reply.getCorrelationId( ) );\n    String action = PolicySpec.requestToAction( request );\n    User requestUser = Permissions.getUserById( request.getUserId( ) );\n    Account account = Permissions.getUserAccount( requestUser );\n    User userFound = null;\n    try {\n      userFound = account.lookupUserByName( request.getUserName( ) );\n    } catch ( Exception e ) {\n      if ( e instanceof AuthException && AuthException.NO_SUCH_USER.equals( e.getMessage( ) ) ) {\n        throw new EuareException( 404, EuareException.NO_SUCH_ENTITY, \"Can not find user \" + request.getUserName( ) );\n      } else {\n        throw new EucalyptusCloudException( e );\n      }\n    }\n    if ( !Permissions.isAuthorized( PolicySpec.IAM_RESOURCE_USER, getUserFullName( userFound ), account, action, requestUser ) ) {\n      throw new EuareException( 403, EuareException.NOT_AUTHORIZED,\n                                \"Not authorized to upload signing certificate of \" + request.getUserName( ) + \"by \" + requestUser.getName( ) );\n    }\n    String encodedPem = B64.url.encString( request.getCertificateBody( ) );\n    Certificate cert = null;\n    try {\n      for ( Certificate c : userFound.getCertificates( ) ) {\n        if ( c.getPem( ).equals( encodedPem ) ) {\n          if ( !c.isRevoked( ) ) {\n            throw new EuareException( 409, EuareException.DUPLICATE_CERTIFICATE, \"Trying to upload duplicate certificate: \" + c.getId( ) );        \n          } else {\n            userFound.removeCertificate( c.getId( ) );\n          }\n        }\n      }\n      X509Certificate x509 = X509CertHelper.toCertificate( encodedPem );\n      if ( x509 == null ) {\n        throw new EuareException( 400, EuareException.INVALID_CERTIFICATE, \"Invalid certificate \" + request.getCertificateBody( ) );        \n      }\n      cert = userFound.addCertificate( x509 );\n    } catch ( Exception e ) {\n      throw new EucalyptusCloudException( e );\n    }\n    SigningCertificateType result = reply.getUploadSigningCertificateResult( ).getCertificate( );\n    result.setUserName( userFound.getName( ) );\n    result.setCertificateId( cert.getId( ) );\n    result.setCertificateBody( request.getCertificateBody( ) );\n    result.setStatus( \"Active\" );\n    result.setUploadDate( cert.getCreateDate( ) );\n    return reply;\n  }","commit_id":"772d0c6ca189574a81a89a23c8c784d1e61ab4e5","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListSigningCertificatesResponseType listSigningCertificates(ListSigningCertificatesType request) throws EucalyptusCloudException {\n    ListSigningCertificatesResponseType reply = request.getReply( );\n    reply.getResponseMetadata( ).setRequestId( reply.getCorrelationId( ) );\n    String action = PolicySpec.requestToAction( request );\n    User requestUser = Permissions.getUserById( request.getUserId( ) );\n    Account account = Permissions.getUserAccount( requestUser );\n    User userFound = null;\n    try {\n      userFound = account.lookupUserByName( request.getUserName( ) );\n    } catch ( Exception e ) {\n      if ( e instanceof AuthException && AuthException.NO_SUCH_USER.equals( e.getMessage( ) ) ) {\n        throw new EuareException( 404, EuareException.NO_SUCH_ENTITY, \"Can not find user \" + request.getUserName( ) );\n      } else {\n        throw new EucalyptusCloudException( e );\n      }\n    }\n    if ( !Permissions.isAuthorized( PolicySpec.IAM_RESOURCE_USER, getUserFullName( userFound ), account, action, requestUser ) ) {\n      throw new EuareException( 403, EuareException.NOT_AUTHORIZED,\n                                \"Not authorized to list signing certificates for \" + request.getUserName( ) + \" by \" + requestUser.getName( ) );\n    }\n    // TODO(Ye Wen, 01/26/2011): support pagination\n    ListSigningCertificatesResultType result = reply.getListSigningCertificatesResult( );\n    result.setIsTruncated( false );\n    ArrayList<SigningCertificateType> certs = result.getCertificates( ).getMemberList( );\n    try {\n      for ( Certificate cert : userFound.getCertificates( ) ) {\n        if ( !cert.isRevoked( ) ) {\n          SigningCertificateType c = new SigningCertificateType( );\n          c.setUserName( userFound.getName( ) );\n          c.setCertificateId( cert.getId( ) );\n          c.setCertificateBody( cert.getPem( ) );\n          c.setStatus( cert.isActive( ) ? \"Active\" : \"Inactive\" );\n          c.setUploadDate( cert.getCreateDate( ) );\n          certs.add( c );\n        }\n      }\n    } catch ( Exception e ) {\n      throw new EucalyptusCloudException( e );\n    }\n    return reply;\n  }","id":76360,"modified_method":"public ListSigningCertificatesResponseType listSigningCertificates(ListSigningCertificatesType request) throws EucalyptusCloudException {\n    ListSigningCertificatesResponseType reply = request.getReply( );\n    reply.getResponseMetadata( ).setRequestId( reply.getCorrelationId( ) );\n    String action = PolicySpec.requestToAction( request );\n    User requestUser = Permissions.getUserById( request.getUserId( ) );\n    Account account = Permissions.getUserAccount( requestUser );\n    User userFound = null;\n    try {\n      userFound = account.lookupUserByName( request.getUserName( ) );\n    } catch ( Exception e ) {\n      if ( e instanceof AuthException && AuthException.NO_SUCH_USER.equals( e.getMessage( ) ) ) {\n        throw new EuareException( 404, EuareException.NO_SUCH_ENTITY, \"Can not find user \" + request.getUserName( ) );\n      } else {\n        throw new EucalyptusCloudException( e );\n      }\n    }\n    if ( !Permissions.isAuthorized( PolicySpec.IAM_RESOURCE_USER, getUserFullName( userFound ), account, action, requestUser ) ) {\n      throw new EuareException( 403, EuareException.NOT_AUTHORIZED,\n                                \"Not authorized to list signing certificates for \" + request.getUserName( ) + \" by \" + requestUser.getName( ) );\n    }\n    // TODO(Ye Wen, 01/26/2011): support pagination\n    ListSigningCertificatesResultType result = reply.getListSigningCertificatesResult( );\n    result.setIsTruncated( false );\n    ArrayList<SigningCertificateType> certs = result.getCertificates( ).getMemberList( );\n    try {\n      for ( Certificate cert : userFound.getCertificates( ) ) {\n        if ( !cert.isRevoked( ) ) {\n          SigningCertificateType c = new SigningCertificateType( );\n          c.setUserName( userFound.getName( ) );\n          c.setCertificateId( cert.getId( ) );\n          c.setCertificateBody( B64.url.decString( cert.getPem( ) ) );\n          c.setStatus( cert.isActive( ) ? \"Active\" : \"Inactive\" );\n          c.setUploadDate( cert.getCreateDate( ) );\n          certs.add( c );\n        }\n      }\n    } catch ( Exception e ) {\n      throw new EucalyptusCloudException( e );\n    }\n    return reply;\n  }","commit_id":"772d0c6ca189574a81a89a23c8c784d1e61ab4e5","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void trigger(\n\t\tFileVersion sourceFileVersion, FileVersion destinationFileVersion) {\n\n\t\tPDFProcessor pdfProcessor = getPDFProcessor();\n\n\t\tpdfProcessor.trigger(sourceFileVersion, destinationFileVersion);\n\t}","id":76361,"modified_method":"public static void trigger(\n\t\tFileVersion sourceFileVersion, FileVersion destinationFileVersion) {\n\n\t\tPDFProcessor pdfProcessor = getPDFProcessor();\n\n\t\tif (pdfProcessor != null) {\n\t\t\tpdfProcessor.trigger(sourceFileVersion, destinationFileVersion);\n\t\t}\n\t}","commit_id":"015667382d789033059bf58b205f63f793bc63d4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Folder updateFolder(\n\t\t\tlong folderId, String title, String description,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tRepository repository = getRepository();\n\n\t\tFolder folder = repository.updateFolder(\n\t\t\tfolderId, title, description, serviceContext);\n\n\t\t_repositoryEventTrigger.trigger(\n\t\t\tRepositoryEventType.Update.class, Folder.class, folder);\n\n\t\treturn folder;\n\t}","id":76362,"modified_method":"@Override\n\tpublic Folder updateFolder(\n\t\t\tlong folderId, String title, String description,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tRepository repository = getRepository();\n\n\t\tFolder folder = repository.updateFolder(\n\t\t\tfolderId, title, description, serviceContext);\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t_repositoryEventTrigger.trigger(\n\t\t\t\tRepositoryEventType.Update.class, Folder.class, folder);\n\t\t}\n\n\t\treturn folder;\n\t}","commit_id":"479c7f56052eb659cfd10ce2172fa69f74f1ce2c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileVersion cancelCheckOut(long fileEntryId) throws PortalException {\n\t\tRepository repository = getRepository();\n\n\t\tFileVersion fileVersion = repository.cancelCheckOut(fileEntryId);\n\n\t\t_repositoryEventTrigger.trigger(\n\t\t\tRepositoryEventType.Update.class, FileEntry.class,\n\t\t\tfileVersion.getFileEntry());\n\n\t\treturn fileVersion;\n\t}","id":76363,"modified_method":"@Override\n\tpublic FileVersion cancelCheckOut(long fileEntryId) throws PortalException {\n\t\tRepository repository = getRepository();\n\n\t\tFileVersion fileVersion = repository.cancelCheckOut(fileEntryId);\n\n\t\tif (fileVersion != null) {\n\t\t\t_repositoryEventTrigger.trigger(\n\t\t\t\tRepositoryEventType.Update.class, FileEntry.class,\n\t\t\t\tfileVersion.getFileEntry());\n\t\t}\n\n\t\treturn fileVersion;\n\t}","commit_id":"7cec389d345a01c3d20d63999fc46386c5c0d9f0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void publishBundleModule(IModule[] module, IProgressMonitor monitor) throws CoreException {\n\t\tfinal IProject project = module[0].getProject();\n        boolean installLocally = getServer().getAttribute(ISlingLaunchpadServer.PROP_INSTALL_LOCALLY, true);\n\t\tmonitor.beginTask(\"deploying via local install\", 5);\n\n        try {\n            OsgiClient osgiClient = Activator.getDefault().getOsgiClientFactory()\n                    .createOsgiClient(ServerUtil.getRepositoryInfo(getServer(), monitor));\n\n            IJavaProject javaProject = ProjectHelper.asJavaProject(project);\n\n            IFolder outputFolder = (IFolder) project.getWorkspace().getRoot().findMember(javaProject.getOutputLocation());\n            IPath outputLocation = outputFolder.getLocation();\n            monitor.worked(1);\n\n            if ( installLocally ) {\n                osgiClient.installLocalBundle(outputLocation.toOSString());\n                monitor.worked(4);\n            } else {\n\n                JarBuilder builder = new JarBuilder();\n                InputStream bundle = builder.buildJar(outputFolder);\n                monitor.worked(1);\n                \n                osgiClient.installLocalBundle(bundle, outputFolder.getLocation().toOSString());\n                monitor.worked(3);\n            }\n\n            setModulePublishState(module, IServer.PUBLISH_STATE_NONE);\n\n        } catch (URISyntaxException e1) {\n            throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, e1.getMessage(), e1));\n        } catch (OsgiClientException e1) {\n            throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"Failed installing bundle : \"\n                    + e1.getMessage(), e1));\n        } finally {\n            monitor.done();\n        }\n\t}","id":76364,"modified_method":"private void publishBundleModule(IModule[] module, IProgressMonitor monitor) throws CoreException {\n\t\tfinal IProject project = module[0].getProject();\n        boolean installLocally = getServer().getAttribute(ISlingLaunchpadServer.PROP_INSTALL_LOCALLY, true);\n\t\tmonitor.beginTask(\"deploying via local install\", 5);\n\n        try {\n            OsgiClient osgiClient = Activator.getDefault().getOsgiClientFactory()\n                    .createOsgiClient(ServerUtil.getRepositoryInfo(getServer(), monitor));\n\n            Version supportBundleVersion = osgiClient\n                    .getBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME);\n            monitor.worked(1);\n            if (supportBundleVersion == null) {\n                throw new CoreException(new Status(Status.ERROR, Activator.PLUGIN_ID,\n                        \"The support bundle was not found, please install it via the server properties page\"));\n            }\n\n            IJavaProject javaProject = ProjectHelper.asJavaProject(project);\n\n            IFolder outputFolder = (IFolder) project.getWorkspace().getRoot().findMember(javaProject.getOutputLocation());\n            IPath outputLocation = outputFolder.getLocation();\n            monitor.worked(1);\n\n            if ( installLocally ) {\n                osgiClient.installLocalBundle(outputLocation.toOSString());\n                monitor.worked(3);\n            } else {\n\n                JarBuilder builder = new JarBuilder();\n                InputStream bundle = builder.buildJar(outputFolder);\n                monitor.worked(1);\n                \n                osgiClient.installLocalBundle(bundle, outputFolder.getLocation().toOSString());\n                monitor.worked(2);\n            }\n\n            setModulePublishState(module, IServer.PUBLISH_STATE_NONE);\n\n        } catch (URISyntaxException e1) {\n            throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, e1.getMessage(), e1));\n        } catch (OsgiClientException e1) {\n            throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"Failed installing bundle : \"\n                    + e1.getMessage(), e1));\n        } finally {\n            monitor.done();\n        }\n\t}","commit_id":"f02879a8d9c119c42eb5e7b24325e39734d81c87","url":"https://github.com/apache/sling"},{"original_method":"protected void updateProjectConfigurations(List<IProject> projects, IProgressMonitor monitor) throws CoreException {\n\t\tfor (Iterator<IProject> it = projects.iterator(); it.hasNext();) {\n\t\t\tIProject project = it.next();\n\t\t\tMavenPlugin.getProjectConfigurationManager().updateProjectConfiguration(project, monitor);\n\t\t}\n\t}","id":76365,"modified_method":"protected void updateProjectConfigurations(List<IProject> projects, boolean forceDependencyUpdate, IProgressMonitor monitor) throws CoreException {\n\t\tfor (Iterator<IProject> it = projects.iterator(); it.hasNext();) {\n\t\t\tIProject project = it.next();\n\t\t\tMavenPlugin.getProjectConfigurationManager().updateProjectConfiguration(new MavenUpdateRequest(project, /*mavenConfiguration.isOffline()*/false, forceDependencyUpdate), monitor);\n\t\t}\n\t}","commit_id":"114b059fc0146d98450e2d6bdd854914c8e30f43","url":"https://github.com/apache/sling"},{"original_method":"private boolean performFinish(IProgressMonitor monitor) throws Exception {\n\n\t\tIPath location = chooseArchetypePage.getLocation();\n\t\tArchetype archetype = chooseArchetypePage.getSelectedArchetype();\n\t\tString groupId = archetypeParametersPage.getGroupId();\n\t\tString artifactId = archetypeParametersPage.getArtifactId();\n\t\tString version = archetypeParametersPage.getVersion();\n\t\tString javaPackage = archetypeParametersPage.getJavaPackage();\n\t\tProperties properties = archetypeParametersPage.getProperties();\n\t\tProjectImportConfiguration configuration = new ProjectImportConfiguration();\n\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tList<IProject> projects = MavenPlugin.getProjectConfigurationManager().createArchetypeProjects(\n\t\t\t\tlocation, archetype, groupId, artifactId, version, javaPackage, properties, configuration, monitor);\n\t\t\n\t\tmonitor.worked(3);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tList<IProject> contentProjects = new LinkedList<IProject>();\n\t\tList<IProject> bundleProjects = new LinkedList<IProject>();\n\t\tIProject reactorProject = null;\n\t\tfor (Iterator<IProject> it = projects.iterator(); it.hasNext();) {\n\t\t\tIProject project = it.next();\n\t\t\tIFile pomFile = project.getFile(\"pom.xml\");\n\t\t\tif (!pomFile.exists()) {\n\t\t\t\t// then ignore this project - we only deal with maven projects\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal Model model = MavenPlugin.getMavenModelManager().readMavenModel(pomFile);\n\t\t\tfinal String packaging = model.getPackaging();\n\n\t\t\tif (\"content-package\".equals(packaging)) {\n\t\t\t\tcontentProjects.add(project);\n\t\t\t} else if (\"bundle\".equals(packaging)) {\n\t\t\t\tbundleProjects.add(project);\n\t\t\t} else if (\"pom\".equals(packaging)) {\n\t\t\t\tif (reactorProject==null) {\n\t\t\t\t\treactorProject = project;\n\t\t\t\t} else {\n\t\t\t\t\tIPath currLocation = project.getFullPath();\n\t\t\t\t\tIPath prevLocation = reactorProject.getFullPath();\n\t\t\t\t\tif (currLocation.isPrefixOf(prevLocation)) {\n\t\t\t\t\t\t// assume reactor is up in the folder structure\n\t\t\t\t\t\treactorProject = project;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tIServer server = setupServerWizardPage.getOrCreateServer();\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (Iterator<IProject> it = contentProjects.iterator(); it.hasNext();) {\n\t\t\tIProject aContentProject = it.next();\n\t\t\tconfigureContentProject(aContentProject, projects, monitor);\n\t\t}\n\t\tfor (Iterator<IProject> it = bundleProjects.iterator(); it.hasNext();) {\n\t\t\tIProject aBundleProject = it.next();\n\t\t\tconfigureBundleProject(aBundleProject, projects, monitor);\n\t\t}\n\t\t\n\t\tconfigureReactorProject(reactorProject, monitor);\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfinishConfiguration(projects, server, monitor);\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tupdateProjectConfigurations(projects, monitor);\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tmonitor.worked(2);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tIServerWorkingCopy wc = server.createWorkingCopy();\n\t\t// add the bundle and content projects, ie modules, to the server\n\t\tList<IModule> modules = new LinkedList<IModule>();\n\t\tfor (Iterator<IProject> it = bundleProjects.iterator(); it.hasNext();) {\n\t\t\tIProject project = it.next();\n\t\t\tIModule module = ServerUtil.getModule(project);\n\t\t\tmodules.add(module);\n\t\t}\n\t\tfor (Iterator<IProject> it = contentProjects.iterator(); it.hasNext();) {\n\t\t\tIProject project = it.next();\n\t\t\tIModule module = ServerUtil.getModule(project);\n\t\t\tmodules.add(module);\n\t\t}\n\t\twc.modifyModules(modules.toArray(new IModule[modules.size()]), new IModule[0], monitor);\n\t\tIServer newServer = wc.save(true, monitor);\n\t\tnewServer.start(ILaunchManager.RUN_MODE, monitor);\n\t\t\n\t\tmonitor.worked(2);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tILaunchConfiguration launchConfig = \n\t\t\t\tDebugPlugin.getDefault().getLaunchManager().getLaunchConfiguration(reactorProject.getFolder(\".settings\").getFolder(\".launches\").getFile(\"initial_install.launch\"));\n\t\tif (launchConfig!=null) {\n\t\t\tILaunch theLaunch = launchConfig.launch(ILaunchManager.RUN_MODE, monitor, true);\n\t\t\tmonitor.setTaskName(\"mvn install\");\n\t\t\twhile(!theLaunch.isTerminated()) {\n\t\t\t\tThread.sleep(500);\n\t\t\t\tmonitor.worked(1);\n\t\t\t}\n\t\t}\n\t\t\n\t\twc.getOriginal().publish(IServer.PUBLISH_FULL, monitor);\n\t\t\n\t\t// also add 'java 1.6' and 'jst.ejb 3.1'\n//\t\tIFacetedProject fp2 = ProjectFacetsManager.create(uiProject, true, null);\n//\t\tIProjectFacet java = ProjectFacetsManager.getProjectFacet(\"java\");\n//\t\tfp2.installProjectFacet(java.getVersion(\"1.6\"), null, null);\n//\t\tIProjectFacet dynamicWebModule = ProjectFacetsManager.getProjectFacet(\"jst.web\");\n//\t\tfp2.installProjectFacet(dynamicWebModule.getLatestVersion(), null, null);\n\n\t\tmonitor.worked(2);\n\t\tmonitor.done();\n\t\treturn true;\n\t}","id":76366,"modified_method":"private boolean performFinish(IProgressMonitor monitor) throws Exception {\n\n\t\tIPath location = chooseArchetypePage.getLocation();\n\t\tArchetype archetype = chooseArchetypePage.getSelectedArchetype();\n\t\tString groupId = archetypeParametersPage.getGroupId();\n\t\tString artifactId = archetypeParametersPage.getArtifactId();\n\t\tString version = archetypeParametersPage.getVersion();\n\t\tString javaPackage = archetypeParametersPage.getJavaPackage();\n\t\tProperties properties = archetypeParametersPage.getProperties();\n\t\tProjectImportConfiguration configuration = new ProjectImportConfiguration();\n\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\tIServer server = setupServerWizardPage.getOrCreateServer();\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tList<IProject> projects = MavenPlugin.getProjectConfigurationManager().createArchetypeProjects(\n\t\t\t\tlocation, archetype, groupId, artifactId, version, javaPackage, properties, configuration, monitor);\n\t\t\n\t\tmonitor.worked(3);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tList<IProject> contentProjects = new LinkedList<IProject>();\n\t\tList<IProject> bundleProjects = new LinkedList<IProject>();\n\t\tIProject reactorProject = null;\n\t\tfor (Iterator<IProject> it = projects.iterator(); it.hasNext();) {\n\t\t\tIProject project = it.next();\n\t\t\tIFile pomFile = project.getFile(\"pom.xml\");\n\t\t\tif (!pomFile.exists()) {\n\t\t\t\t// then ignore this project - we only deal with maven projects\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal Model model = MavenPlugin.getMavenModelManager().readMavenModel(pomFile);\n\t\t\tfinal String packaging = model.getPackaging();\n\n\t\t\tif (\"content-package\".equals(packaging)) {\n\t\t\t\tcontentProjects.add(project);\n\t\t\t} else if (\"bundle\".equals(packaging)) {\n\t\t\t\tbundleProjects.add(project);\n\t\t\t} else if (\"pom\".equals(packaging)) {\n\t\t\t\tif (reactorProject==null) {\n\t\t\t\t\treactorProject = project;\n\t\t\t\t} else {\n\t\t\t\t\tIPath currLocation = project.getFullPath();\n\t\t\t\t\tIPath prevLocation = reactorProject.getFullPath();\n\t\t\t\t\tif (currLocation.isPrefixOf(prevLocation)) {\n\t\t\t\t\t\t// assume reactor is up in the folder structure\n\t\t\t\t\t\treactorProject = project;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (Iterator<IProject> it = contentProjects.iterator(); it.hasNext();) {\n\t\t\tIProject aContentProject = it.next();\n\t\t\tconfigureContentProject(aContentProject, projects, monitor);\n\t\t}\n\t\tfor (Iterator<IProject> it = bundleProjects.iterator(); it.hasNext();) {\n\t\t\tIProject aBundleProject = it.next();\n\t\t\tconfigureBundleProject(aBundleProject, projects, monitor);\n\t\t}\n\t\t\n\t\tconfigureReactorProject(reactorProject, monitor);\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfinishConfiguration(projects, server, monitor);\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tupdateProjectConfigurations(projects, true, monitor);\n\t\tmonitor.worked(1);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tIServerWorkingCopy wc = server.createWorkingCopy();\n\t\t// add the bundle and content projects, ie modules, to the server\n\t\tList<IModule> modules = new LinkedList<IModule>();\n\t\tfor (Iterator<IProject> it = bundleProjects.iterator(); it.hasNext();) {\n\t\t\tIProject project = it.next();\n\t\t\tIModule module = ServerUtil.getModule(project);\n\t\t\tmodules.add(module);\n\t\t}\n\t\tfor (Iterator<IProject> it = contentProjects.iterator(); it.hasNext();) {\n\t\t\tIProject project = it.next();\n\t\t\tIModule module = ServerUtil.getModule(project);\n\t\t\tmodules.add(module);\n\t\t}\n\t\twc.modifyModules(modules.toArray(new IModule[modules.size()]), new IModule[0], monitor);\n\t\tIServer newServer = wc.save(true, monitor);\n\t\tnewServer.start(ILaunchManager.RUN_MODE, monitor);\n\t\t\n\t\tmonitor.worked(2);\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tILaunchConfiguration launchConfig = \n\t\t\t\tDebugPlugin.getDefault().getLaunchManager().getLaunchConfiguration(reactorProject.getFolder(\".settings\").getFolder(\".launches\").getFile(\"initial_install.launch\"));\n\t\tif (launchConfig!=null) {\n\t\t\tILaunch theLaunch = launchConfig.launch(ILaunchManager.RUN_MODE, monitor, true);\n\t\t\tmonitor.setTaskName(\"mvn install\");\n\t\t\twhile(!theLaunch.isTerminated()) {\n\t\t\t\tThread.sleep(500);\n\t\t\t\tmonitor.worked(1);\n\t\t\t}\n\t\t}\n\t\t\n\t\twc.getOriginal().publish(IServer.PUBLISH_FULL, monitor);\n\t\t\n\t\t// also add 'java 1.6' and 'jst.ejb 3.1'\n//\t\tIFacetedProject fp2 = ProjectFacetsManager.create(uiProject, true, null);\n//\t\tIProjectFacet java = ProjectFacetsManager.getProjectFacet(\"java\");\n//\t\tfp2.installProjectFacet(java.getVersion(\"1.6\"), null, null);\n//\t\tIProjectFacet dynamicWebModule = ProjectFacetsManager.getProjectFacet(\"jst.web\");\n//\t\tfp2.installProjectFacet(dynamicWebModule.getLatestVersion(), null, null);\n\n\t\tmonitor.worked(2);\n\t\tupdateProjectConfigurations(projects, false, monitor);\n\t\tmonitor.worked(1);\n\t\tmonitor.done();\n\t\treturn true;\n\t}","commit_id":"114b059fc0146d98450e2d6bdd854914c8e30f43","url":"https://github.com/apache/sling"},{"original_method":"private void publishContentModule(int kind, int deltaKind, IModule[] module, IProgressMonitor monitor)\n            throws CoreException, SerializationException, IOException {\n\n        Logger logger = Activator.getDefault().getPluginLogger();\n\n\t\tRepository repository = ServerUtil.getConnectedRepository(getServer(), monitor);\n        \n        // TODO it would be more efficient to have a module -> filter mapping\n        // it would be simpler to implement this in SlingContentModuleAdapter, but\n        // the behaviour for resources being filtered out is deletion, and that\n        // would be an incorrect ( or at least suprising ) behaviour at development time\n\n        List<IModuleResource> addedOrUpdatedResources = new ArrayList<IModuleResource>();\n        IModuleResource[] allResources = getResources(module);\n        Set<IPath> handledPaths = new HashSet<IPath>();\n\n        switch (deltaKind) {\n            case ServerBehaviourDelegate.CHANGED:\n                for (IModuleResourceDelta resourceDelta : getPublishedResourceDelta(module)) {\n\n                    StringBuilder deltaTrace = new StringBuilder();\n                    deltaTrace.append(\"- processing delta kind \");\n\n                    switch (resourceDelta.getKind()) {\n                        case IModuleResourceDelta.ADDED:\n                            deltaTrace.append(\"ADDED \");\n                            break;\n                        case IModuleResourceDelta.CHANGED:\n                            deltaTrace.append(\"CHANGED \");\n                            break;\n                        case IModuleResourceDelta.NO_CHANGE:\n                            deltaTrace.append(\"NO_CHANGE \");\n                            break;\n                        case IModuleResourceDelta.REMOVED:\n                            deltaTrace.append(\"REMOVED \");\n                            break;\n                        default:\n                            deltaTrace.append(\"UNKNOWN - \").append(resourceDelta.getKind());\n                    }\n\n                    deltaTrace.append(\"for resource \").append(resourceDelta.getModuleResource());\n\n                    logger.trace(deltaTrace.toString());\n\n                    switch (resourceDelta.getKind()) {\n                        case IModuleResourceDelta.ADDED:\n                        case IModuleResourceDelta.CHANGED:\n                        case IModuleResourceDelta.NO_CHANGE: // TODO is this needed?\n                            Command<?> command = addFileCommand(repository, resourceDelta.getModuleResource());\n\n                            if (command != null) {\n                                ensureParentIsPublished(resourceDelta.getModuleResource(), repository, allResources,\n                                        handledPaths);\n                                addedOrUpdatedResources.add(resourceDelta.getModuleResource());\n                            }\n                            execute(command);\n                            break;\n                        case IModuleResourceDelta.REMOVED:\n                            execute(removeFileCommand(repository, resourceDelta.getModuleResource()));\n                            break;\n                    }\n                }\n                break;\n\n            case ServerBehaviourDelegate.ADDED:\n            case ServerBehaviourDelegate.NO_CHANGE: // TODO is this correct ?\n                for (IModuleResource resource : getResources(module)) {\n                    Command<?> command = addFileCommand(repository, resource);\n                    execute(command);\n                    if (command != null) {\n                        addedOrUpdatedResources.add(resource);\n                    }\n                }\n                break;\n            case ServerBehaviourDelegate.REMOVED:\n                for (IModuleResource resource : getResources(module)) {\n                    execute(removeFileCommand(repository, resource));\n                }\n                break;\n        }\n\n        // reorder the child nodes at the end, when all create/update/deletes have been processed\n        for (IModuleResource resource : addedOrUpdatedResources) {\n            execute(reorderChildNodesCommand(repository, resource));\n        }\n\n\n        // set state to published\n        super.publishModule(kind, deltaKind, module, monitor);\n        setModulePublishState(module, IServer.PUBLISH_STATE_NONE);\n//        setServerPublishState(IServer.PUBLISH_STATE_NONE);\n\t}","id":76367,"modified_method":"private void publishContentModule(int kind, int deltaKind, IModule[] module, IProgressMonitor monitor)\n            throws CoreException, SerializationException, IOException {\n\n        Logger logger = Activator.getDefault().getPluginLogger();\n\n\t\tRepository repository = ServerUtil.getConnectedRepository(getServer(), monitor);\n        if (repository == null) {\n            throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID,\n                    \"Unable to find a repository for server \" + getServer()));\n        }\n        \n        // TODO it would be more efficient to have a module -> filter mapping\n        // it would be simpler to implement this in SlingContentModuleAdapter, but\n        // the behaviour for resources being filtered out is deletion, and that\n        // would be an incorrect ( or at least suprising ) behaviour at development time\n\n        List<IModuleResource> addedOrUpdatedResources = new ArrayList<IModuleResource>();\n        IModuleResource[] allResources = getResources(module);\n        Set<IPath> handledPaths = new HashSet<IPath>();\n\n        switch (deltaKind) {\n            case ServerBehaviourDelegate.CHANGED:\n                for (IModuleResourceDelta resourceDelta : getPublishedResourceDelta(module)) {\n\n                    StringBuilder deltaTrace = new StringBuilder();\n                    deltaTrace.append(\"- processing delta kind \");\n\n                    switch (resourceDelta.getKind()) {\n                        case IModuleResourceDelta.ADDED:\n                            deltaTrace.append(\"ADDED \");\n                            break;\n                        case IModuleResourceDelta.CHANGED:\n                            deltaTrace.append(\"CHANGED \");\n                            break;\n                        case IModuleResourceDelta.NO_CHANGE:\n                            deltaTrace.append(\"NO_CHANGE \");\n                            break;\n                        case IModuleResourceDelta.REMOVED:\n                            deltaTrace.append(\"REMOVED \");\n                            break;\n                        default:\n                            deltaTrace.append(\"UNKNOWN - \").append(resourceDelta.getKind());\n                    }\n\n                    deltaTrace.append(\"for resource \").append(resourceDelta.getModuleResource());\n\n                    logger.trace(deltaTrace.toString());\n\n                    switch (resourceDelta.getKind()) {\n                        case IModuleResourceDelta.ADDED:\n                        case IModuleResourceDelta.CHANGED:\n                        case IModuleResourceDelta.NO_CHANGE: // TODO is this needed?\n                            Command<?> command = addFileCommand(repository, resourceDelta.getModuleResource());\n\n                            if (command != null) {\n                                ensureParentIsPublished(resourceDelta.getModuleResource(), repository, allResources,\n                                        handledPaths);\n                                addedOrUpdatedResources.add(resourceDelta.getModuleResource());\n                            }\n                            execute(command);\n                            break;\n                        case IModuleResourceDelta.REMOVED:\n                            execute(removeFileCommand(repository, resourceDelta.getModuleResource()));\n                            break;\n                    }\n                }\n                break;\n\n            case ServerBehaviourDelegate.ADDED:\n            case ServerBehaviourDelegate.NO_CHANGE: // TODO is this correct ?\n                for (IModuleResource resource : getResources(module)) {\n                    Command<?> command = addFileCommand(repository, resource);\n                    execute(command);\n                    if (command != null) {\n                        addedOrUpdatedResources.add(resource);\n                    }\n                }\n                break;\n            case ServerBehaviourDelegate.REMOVED:\n                for (IModuleResource resource : getResources(module)) {\n                    execute(removeFileCommand(repository, resource));\n                }\n                break;\n        }\n\n        // reorder the child nodes at the end, when all create/update/deletes have been processed\n        for (IModuleResource resource : addedOrUpdatedResources) {\n            execute(reorderChildNodesCommand(repository, resource));\n        }\n\n\n        // set state to published\n        super.publishModule(kind, deltaKind, module, monitor);\n        setModulePublishState(module, IServer.PUBLISH_STATE_NONE);\n//        setServerPublishState(IServer.PUBLISH_STATE_NONE);\n\t}","commit_id":"003ad2060ffd181d2a65b29f9c56a7972809cd8b","url":"https://github.com/apache/sling"},{"original_method":"public void start(IProgressMonitor monitor) throws CoreException {\n\n        boolean success = false;\n        Result<ResourceProxy> result = null;\n        monitor.beginTask(\"Starting server\", 5);\n        \n        try {\n            if (getServer().getMode().equals(ILaunchManager.DEBUG_MODE)) {\n                debuggerConnection = new JVMDebuggerConnection();\n                success = debuggerConnection.connectInDebugMode(launch, getServer(), monitor);\n\n            } else {\n\n                Repository repository;\n                try {\n                    repository = ServerUtil.connectRepository(getServer(), monitor);\n                } catch (CoreException e) {\n                    setServerState(IServer.STATE_STOPPED);\n                    throw e;\n                }\n                \n                monitor.worked(2); // 2/5 done\n                \n                Command<ResourceProxy> command = repository.newListChildrenNodeCommand(\"/\");\n                result = command.execute();\n                success = result.isSuccess();\n                \n                monitor.worked(1); // 3/5 done\n                \n                RepositoryInfo repositoryInfo;\n                try {\n                    repositoryInfo = ServerUtil.getRepositoryInfo(getServer(), monitor);\n                    OsgiClient client = Activator.getDefault().getOsgiClientFactory().createOsgiClient(repositoryInfo);\n                    EmbeddedArtifactLocator artifactLocator = Activator.getDefault().getArtifactLocator();\n                    Version remoteVersion = client.getBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME);\n                    \n                    monitor.worked(1); // 4/5 done\n                    \n                    final EmbeddedArtifact supportBundle = artifactLocator.loadToolingSupportBundle();\n\n                    final Version embeddedVersion = new Version(supportBundle.getVersion());\n                    \n                    ISlingLaunchpadServer launchpadServer = (ISlingLaunchpadServer) getServer().loadAdapter(SlingLaunchpadServer.class,\n                            monitor);\n                    if (remoteVersion == null || remoteVersion.compareTo(embeddedVersion) < 0) {\n                        InputStream contents = null;\n                        try {\n                            contents = supportBundle.openInputStream();\n                            client.installBundle(contents, supportBundle.getName());\n                        } finally {\n                            IOUtils.closeQuietly(contents);\n                        }\n                        remoteVersion = embeddedVersion;\n\n                    }\n                    launchpadServer.setBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME, remoteVersion,\n                            monitor);\n                    \n                    monitor.worked(1); // 5/5 done\n                    \n                } catch ( IOException e) {\n                    Activator.getDefault().getPluginLogger()\n                        .warn(\"Failed reading the installation support bundle\", e);\n                } catch (URISyntaxException e) {\n                    Activator.getDefault().getPluginLogger()\n                            .warn(\"Failed retrieving information about the installation support bundle\", e);\n                } catch (OsgiClientException e) {\n                    Activator.getDefault().getPluginLogger()\n                            .warn(\"Failed retrieving information about the installation support bundle\", e);\n                }\n            }\n\n            if (success) {\n                setServerState(IServer.STATE_STARTED);\n            } else {\n                setServerState(IServer.STATE_STOPPED);\n                String message = \"Unable to connect to the Server. Please make sure a server instance is running \";\n                if (result != null) {\n                    message += \" (\" + result.toString() + \")\";\n                }\n                throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, message));\n            }\n        } finally {\n            monitor.done();\n        }\n    }","id":76368,"modified_method":"public void start(IProgressMonitor monitor) throws CoreException {\n\n        boolean success = false;\n        Result<ResourceProxy> result = null;\n        monitor.beginTask(\"Starting server\", 5);\n        \n        Repository repository;\n        try {\n            repository = ServerUtil.connectRepository(getServer(), monitor);\n        } catch (CoreException e) {\n            setServerState(IServer.STATE_STOPPED);\n            throw e;\n        }\n\n        monitor.worked(2); // 2/5 done\n\n        try {\n            if (getServer().getMode().equals(ILaunchManager.DEBUG_MODE)) {\n                debuggerConnection = new JVMDebuggerConnection();\n                success = debuggerConnection.connectInDebugMode(launch, getServer(), monitor);\n\n                monitor.worked(3); // 5/5 done\n\n            } else {\n                \n                Command<ResourceProxy> command = repository.newListChildrenNodeCommand(\"/\");\n                result = command.execute();\n                success = result.isSuccess();\n                \n                monitor.worked(1); // 3/5 done\n                \n                RepositoryInfo repositoryInfo;\n                try {\n                    repositoryInfo = ServerUtil.getRepositoryInfo(getServer(), monitor);\n                    OsgiClient client = Activator.getDefault().getOsgiClientFactory().createOsgiClient(repositoryInfo);\n                    EmbeddedArtifactLocator artifactLocator = Activator.getDefault().getArtifactLocator();\n                    Version remoteVersion = client.getBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME);\n                    \n                    monitor.worked(1); // 4/5 done\n                    \n                    final EmbeddedArtifact supportBundle = artifactLocator.loadToolingSupportBundle();\n\n                    final Version embeddedVersion = new Version(supportBundle.getVersion());\n                    \n                    ISlingLaunchpadServer launchpadServer = (ISlingLaunchpadServer) getServer().loadAdapter(SlingLaunchpadServer.class,\n                            monitor);\n                    if (remoteVersion == null || remoteVersion.compareTo(embeddedVersion) < 0) {\n                        InputStream contents = null;\n                        try {\n                            contents = supportBundle.openInputStream();\n                            client.installBundle(contents, supportBundle.getName());\n                        } finally {\n                            IOUtils.closeQuietly(contents);\n                        }\n                        remoteVersion = embeddedVersion;\n\n                    }\n                    launchpadServer.setBundleVersion(EmbeddedArtifactLocator.SUPPORT_BUNDLE_SYMBOLIC_NAME, remoteVersion,\n                            monitor);\n                    \n                    monitor.worked(1); // 5/5 done\n                    \n                } catch ( IOException e) {\n                    Activator.getDefault().getPluginLogger()\n                        .warn(\"Failed reading the installation support bundle\", e);\n                } catch (URISyntaxException e) {\n                    Activator.getDefault().getPluginLogger()\n                            .warn(\"Failed retrieving information about the installation support bundle\", e);\n                } catch (OsgiClientException e) {\n                    Activator.getDefault().getPluginLogger()\n                            .warn(\"Failed retrieving information about the installation support bundle\", e);\n                }\n            }\n\n            if (success) {\n                setServerState(IServer.STATE_STARTED);\n            } else {\n                setServerState(IServer.STATE_STOPPED);\n                String message = \"Unable to connect to the Server. Please make sure a server instance is running \";\n                if (result != null) {\n                    message += \" (\" + result.toString() + \")\";\n                }\n                throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, message));\n            }\n        } finally {\n            monitor.done();\n        }\n    }","commit_id":"003ad2060ffd181d2a65b29f9c56a7972809cd8b","url":"https://github.com/apache/sling"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","id":76369,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","commit_id":"bbc15a55c35e5d261ab43dbb988430e4c8bf18df","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            writeSlaveContext( buffer, slaveContext );\n            serializer.write( buffer );\n            client.channel.write(buffer);\n\n            // Read response\n            ChannelBuffer message =\n//                client.blockingReadHandler.read();\n                client.blockingReadHandler.read( 20, TimeUnit.SECONDS );\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = readTransactionStreams( message );\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":76370,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            client.channel.write(buffer);\n\n            // Read response\n            ChannelBuffer message =\n//                client.blockingReadHandler.read();\n                client.blockingReadHandler.read( 20, TimeUnit.SECONDS );\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( message ) : TransactionStreams.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"bbc15a55c35e5d261ab43dbb988430e4c8bf18df","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } );\n    }","id":76371,"modified_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","commit_id":"bbc15a55c35e5d261ab43dbb988430e4c8bf18df","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.machineId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<Long>();\n        }\n//        finally\n//        {\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n//            rollbackThisAndResumeOther( otherTx );\n//        }\n    }","id":76372,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.machineId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<Long>();\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n//            rollbackThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"bbc15a55c35e5d261ab43dbb988430e4c8bf18df","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 1000;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n\n        return packResponse( context, new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), ALL );\n    }","id":76373,"modified_method":"public IdAllocation allocateIds( IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = ID_GRAB_SIZE;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new IdAllocation( ids, generator.getHighId(), generator.getDefragCount() ); \n    }","commit_id":"bbc15a55c35e5d261ab43dbb988430e4c8bf18df","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","id":76374,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","commit_id":"bbc15a55c35e5d261ab43dbb988430e4c8bf18df","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","id":76375,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","commit_id":"1729ba53b0c16058fae03fc7b026126536b9768d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            writeSlaveContext( buffer, slaveContext );\n            serializer.write( buffer );\n            client.channel.write(buffer);\n\n            // Read response\n            ChannelBuffer message =\n//                client.blockingReadHandler.read();\n                client.blockingReadHandler.read( 20, TimeUnit.SECONDS );\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = readTransactionStreams( message );\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":76376,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            client.channel.write(buffer);\n\n            // Read response\n            ChannelBuffer message =\n//                client.blockingReadHandler.read();\n                client.blockingReadHandler.read( 20, TimeUnit.SECONDS );\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( message ) : TransactionStreams.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"1729ba53b0c16058fae03fc7b026126536b9768d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } );\n    }","id":76377,"modified_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","commit_id":"1729ba53b0c16058fae03fc7b026126536b9768d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.machineId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<Long>();\n        }\n//        finally\n//        {\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n//            rollbackThisAndResumeOther( otherTx );\n//        }\n    }","id":76378,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.machineId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<Long>();\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n//            rollbackThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"1729ba53b0c16058fae03fc7b026126536b9768d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 1000;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n\n        return packResponse( context, new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), ALL );\n    }","id":76379,"modified_method":"public IdAllocation allocateIds( IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = ID_GRAB_SIZE;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new IdAllocation( ids, generator.getHighId(), generator.getDefragCount() ); \n    }","commit_id":"1729ba53b0c16058fae03fc7b026126536b9768d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","id":76380,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","commit_id":"1729ba53b0c16058fae03fc7b026126536b9768d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","id":76381,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        SlaveContext context = type.includesSlaveContext() ? readSlaveContext( buffer ) : null;\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","commit_id":"7f1ddd5520ad39f7a4d95189a2136d19c2acd4c3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } );\n    }","id":76382,"modified_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","commit_id":"7f1ddd5520ad39f7a4d95189a2136d19c2acd4c3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            writeSlaveContext( buffer, slaveContext );\n            serializer.write( buffer );\n            client.channel.write(buffer);\n\n            // Read response\n            ChannelBuffer message =\n//                client.blockingReadHandler.read();\n                client.blockingReadHandler.read( 20, TimeUnit.SECONDS );\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = readTransactionStreams( message );\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":76383,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            client.channel.write(buffer);\n\n            // Read response\n            ChannelBuffer message =\n//                client.blockingReadHandler.read();\n                client.blockingReadHandler.read( 20, TimeUnit.SECONDS );\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( message ) : TransactionStreams.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"7f1ddd5520ad39f7a4d95189a2136d19c2acd4c3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.machineId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<Long>();\n        }\n//        finally\n//        {\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n//            rollbackThisAndResumeOther( otherTx );\n//        }\n    }","id":76384,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.machineId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<Long>();\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n//            rollbackThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"7f1ddd5520ad39f7a4d95189a2136d19c2acd4c3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 1000;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n\n        return packResponse( context, new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), ALL );\n    }","id":76385,"modified_method":"public IdAllocation allocateIds( IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = ID_GRAB_SIZE;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new IdAllocation( ids, generator.getHighId(), generator.getDefragCount() ); \n    }","commit_id":"7f1ddd5520ad39f7a4d95189a2136d19c2acd4c3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = receiver.receive(\n                        broker.getMaster().allocateIds( receiver.getSlaveContext(), idType ) );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","id":76386,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.somethingIsWrong( e );\n            throw e;\n        }\n    }","commit_id":"7f1ddd5520ad39f7a4d95189a2136d19c2acd4c3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void startPlugin(final String filename, final boolean store) {\n\t\tif (filename.trim().length() == 0)\n\t\t\treturn;\n\t\tfinal PluginProgress pluginProgress = new PluginProgress(filename);\n\t\tsynchronized (startingPlugins) {\n\t\t\tstartingPlugins.add(pluginProgress);\n\t\t}\n\t\tnode.executor.execute(new Runnable() {\n\n\t\t\tpublic void run() {\n\t\t\t\tLogger.normal(this, \"Loading plugin: \" + filename);\n\t\t\t\tFredPlugin plug;\n\t\t\t\ttry {\n\t\t\t\t\tplug = loadPlugin(filename);\n\t\t\t\t\tpluginProgress.setProgress(PluginProgress.STARTING);\n\t\t\t\t\tPluginInfoWrapper pi = PluginHandler.startPlugin(PluginManager.this, filename, plug, new PluginRespirator(node, PluginManager.this));\n\t\t\t\t\tsynchronized (pluginWrappers) {\n\t\t\t\t\t\tpluginWrappers.add(pi);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.normal(this, \"Plugin loaded: \" + filename);\n\t\t\t\t} catch (PluginNotFoundException e) {\n\t\t\t\t\tLogger.normal(this, \"Loading plugin failed (\" + filename + ')', e);\n\t\t\t\t\tString message = e.getMessage();\n\t\t\t\t\tcore.alerts.register(new SimpleUserAlert(true, l10n(\"pluginLoadingFailedTitle\"), l10n(\"pluginLoadingFailedWithMessage\", new String[] { \"name\", \"message\" }, new String[] { filename, message }), l10n(\"pluginLoadingFailedShort\", \"name\", filename), UserAlert.ERROR, PluginManager.class));\n\t\t\t\t} catch (UnsupportedClassVersionError e) {\n\t\t\t\t\tLogger.error(this, \"Could not load plugin \" + filename + \" : \" + e, e);\n\t\t\t\t\tSystem.err.println(\"Could not load plugin \" + filename + \" : \" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tString jvmVersion = System.getProperty(\"java.version\");\n\t\t\t\t\tif (jvmVersion.startsWith(\"1.4.\") || jvmVersion.equals(\"1.4\")) {\n\t\t\t\t\t\tSystem.err.println(\"Plugin \" + filename + \" appears to require a later JVM\");\n\t\t\t\t\t\tLogger.error(this, \"Plugin \" + filename + \" appears to require a later JVM\");\n\t\t\t\t\t\tcore.alerts.register(new SimpleUserAlert(true, l10n(\"pluginReqNewerJVMTitle\", \"name\", filename), l10n(\"pluginReqNewerJVM\", \"name\", filename), l10n(\"pluginLoadingFailedShort\", \"name\", filename), UserAlert.ERROR, PluginManager.class));\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tsynchronized (startingPlugins) {\n\t\t\t\t\t\tstartingPlugins.remove(pluginProgress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* try not to destroy the config. */\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (store)\n\t\t\t\t\t\tcore.storeConfig();\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"Plugin Starter\");\n\t}","id":76387,"modified_method":"public void startPluginURL(final String filename, boolean store) {\n\t\trealStartPlugin(new PluginDownLoaderURL(), filename, store);\n\t}","commit_id":"7ccaa584a530ccd2e7cf9e5813d7ef64f7b8d4f8","url":"https://github.com/freenet/fred"},{"original_method":"public PluginManager(Node node) {\n\t\ttoadletList = new HashMap();\n\t\tpluginWrappers = new Vector();\n\t\tthis.node = node;\n\t\tthis.core = node.clientCore;\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\n\t\tpmconfig = new SubConfig(\"pluginmanager\", node.config);\n\t\t// Start plugins in the config\n\t\tpmconfig.register(\"loadplugin\", null, 9, true, false, \"PluginManager.loadedOnStartup\", \"PluginManager.loadedOnStartupLong\",\n\t\t\t\tnew StringArrCallback() {\n\t\t\tpublic String[] get() {\n\t\t\t\treturn getConfigLoadString();\n\t\t\t}\n\n\t\t\tpublic void set(String[] val) throws InvalidConfigValueException {\n\t\t\t\t//if(storeDir.equals(new File(val))) return;\n\t\t\t\t// FIXME\n\t\t\t\tthrow new InvalidConfigValueException(L10n.getString(\"PluginManager.cannotSetOnceLoaded\"));\n\t\t\t}\n\t\t});\n\n\t\tString fns[] = pmconfig.getStringArr(\"loadplugin\");\n\t\tif (fns != null) {\n\t\t\tfor (String name : fns)\n\t\t\t\tstartPlugin(name, false);\n\t\t}\n\n\t\tpmconfig.finishedInitialization();\n\t\t/*System.err.println(\"=================================\");\n\t\t  pmconfig.finishedInitialization();\n\t\t  fns = pmconfig.getStringArr(\"loadplugin\");\n\t\t  for (int i = 0 ; i < fns.length ; i++)\n\t\t  System.err.println(\"Load: \" + StringArrOption.decode(fns[i]));\n\t\t  System.err.println(\"=================================\");\n\t\t */\n\t}","id":76388,"modified_method":"public PluginManager(Node node) {\n\t\t\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tlogDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\t// config \n\t\t\n\t\ttoadletList = new HashMap();\n\t\tpluginWrappers = new Vector();\n\t\tthis.node = node;\n\t\tthis.core = node.clientCore;\n\t\t\n\t\tif(logMINOR) Logger.minor(this, \"Starting Plugin Manager\");\n\t\t\n\t\tif(logDEBUG) Logger.debug(this, \"Initialize Plugin Manager config\");\n\t\t\n\t\tclient = core.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS, true);\n\t\t\n\n\t\tpmconfig = new SubConfig(\"pluginmanager\", node.config);\n//\t\tpmconfig.register(\"configfile\", \"fplugins.ini\", 9, true, true, \"PluginConfig.configFile\", \"PluginConfig.configFileLong\",\n//\t\t\t\tnew StringCallback() {\n//\t\t\tpublic String get() {\n//\t\t\t\treturn configFile;\n//\t\t\t}\n//\n//\t\t\tpublic void set(String val) throws InvalidConfigValueException {\n//\t\t\t\tconfigFile = val;\n//\t\t\t}\n//\t\t});\n//\t\tconfigFile = pmconfig.getString(\"configfile\");\n//\t\tpmconfig.register(\"installdir\", \"fplugins\", 9, true, true, \"PluginConfig.installDir\", \"PluginConfig.installDirLong\",\n//\t\t\t\tnew StringCallback() {\n//\t\t\tpublic String get() {\n//\t\t\t\treturn installDir;\n//\t\t\t\t//return getConfigLoadString();\n//\t\t\t}\n//\n//\t\t\tpublic void set(String val) throws InvalidConfigValueException {\n//\t\t\t\tinstallDir = val;\n//\t\t\t\t//if(storeDir.equals(new File(val))) return;\n//\t\t\t\t// FIXME\n//\t\t\t\t//throw new InvalidConfigValueException(L10n.getString(\"PluginManager.cannotSetOnceLoaded\"));\n//\t\t\t}\n//\t\t});\n//\t\tinstallDir = pmconfig.getString(\"installdir\");\n\n\t\t// Start plugins in the config\n\t\tpmconfig.register(\"loadplugin\", null, 9, true, false, \"PluginManager.loadedOnStartup\", \"PluginManager.loadedOnStartupLong\",\n\t\t\t\tnew StringArrCallback() {\n\t\t\tpublic String[] get() {\n\t\t\t\treturn getConfigLoadString();\n\t\t\t}\n\n\t\t\tpublic void set(String[] val) throws InvalidConfigValueException {\n\t\t\t\t//if(storeDir.equals(new File(val))) return;\n\t\t\t\t// FIXME\n\t\t\t\tthrow new InvalidConfigValueException(L10n.getString(\"PluginManager.cannotSetOnceLoaded\"));\n\t\t\t}\n\t\t});\n\n\t\tString fns[] = pmconfig.getStringArr(\"loadplugin\");\n\t\tif (fns != null) {\n\t\t\tfor (String name : fns)\n\t\t\t\tstartPluginAuto(name, false);\n\t\t}\n\n\t\tpmconfig.finishedInitialization();\n\t}","commit_id":"7ccaa584a530ccd2e7cf9e5813d7ef64f7b8d4f8","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tries to load a plugin from the given name. If the name only contains the\n\t * name of a plugin it is loaded from the plugin directory, if found,\n\t * otherwise it's loaded from the project server. If the name contains a\n\t * complete url and the short file already exists in the plugin directory\n\t * it's loaded from the plugin directory, otherwise it's retrieved from the\n\t * remote server.\n\t * \n\t * @param name\n\t *            The specification of the plugin\n\t * @return An instanciated object of the plugin\n\t * @throws PluginNotFoundException\n\t *             If anything goes wrong.\n\t */\n\tprivate FredPlugin loadPlugin(String name) throws PluginNotFoundException {\n\t\tURL pluginUrl = null;\n\t\t/* check if name is a local file. */\n\t\tFile pluginFile = new File(name);\n\t\tif (pluginFile.exists() && pluginFile.isFile()) {\n\t\t\ttry {\n\t\t\t\tpluginUrl = pluginFile.toURI().toURL();\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\tthrow new PluginNotFoundException(\"can not convert local path\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* check if name contains a URL. */\n\t\t\ttry {\n\t\t\t\tpluginUrl = new URL(name);\n\t\t\t} catch (MalformedURLException mue1) {\n\t\t\t}\n\t\t}\n\t\tif (pluginUrl == null) {\n\t\t\ttry {\n\t\t\t\tpluginUrl = new URL(\"http://downloads.freenetproject.org/alpha/plugins/\" + name + \".jar.url\");\n\t\t\t} catch (MalformedURLException mue1) {\n\t\t\t\tLogger.error(this, \"could not build plugin url for \" + name, mue1);\n\t\t\t\tthrow new PluginNotFoundException(\"could not build plugin url for \" + name, mue1);\n\t\t\t}\n\t\t}\n\n\t\t/* check for plugin directory. */\n\t\tFile pluginDirectory = new File(node.getNodeDir(), \"plugins\");\n\t\tif ((pluginDirectory.exists() && !pluginDirectory.isDirectory()) || (!pluginDirectory.exists() && !pluginDirectory.mkdirs())) {\n\t\t\tLogger.error(this, \"could not create plugin directory\");\n\t\t\tthrow new PluginNotFoundException(\"could not create plugin directory\");\n\t\t}\n\n\t\t/* get plugin filename. */\n\t\tString completeFilename = pluginUrl.getPath();\n\t\tString filename = completeFilename.substring(completeFilename.lastIndexOf('/') + 1);\n\t\t// The URL to the JAR file might end with .url because of the insane download server that redirects to a JAR file\n\t\t// in response to a request for a file ending '.url'. Strip it off if so, since we want our JAR to end with '.jar'.\n\t\tif (filename.endsWith(\".url\")) {\n\t\t\tfilename = filename.substring(0, filename.length() - 4);\n\t\t}\n\t\tpluginFile = new File(pluginDirectory, filename);\n\n\t\t/* check if file needs to be downloaded. */\n\t\tif (logMINOR) {\n\t\t\tLogger.minor(this, \"plugin file \" + pluginFile.getAbsolutePath() + \" exists: \" + pluginFile.exists());\n\t\t}\n\t\tint RETRIES = 5;\n\t\tfor(int i=0;i<RETRIES;i++) {\n\t\t\tif (!pluginFile.exists() || pluginFile.length() == 0) {\n\t\t\t\ttry {\n\t\t\t\t\tFile tempPluginFile = null;\n\t\t\t\t\tOutputStream pluginOutputStream = null;\n\t\t\t\t\tURLConnection urlConnection = null;\n\t\t\t\t\tInputStream pluginInputStream = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttempPluginFile = File.createTempFile(\"plugin-\", \".jar\", pluginDirectory);\n\t\t\t\t\t\tpluginOutputStream = new FileOutputStream(tempPluginFile);\n\t\t\t\t\t\turlConnection = pluginUrl.openConnection();\n\t\t\t\t\t\turlConnection.setUseCaches(false);\n\t\t\t\t\t\turlConnection.setAllowUserInteraction(false);\n\t\t\t\t\t\turlConnection.connect();\n\t\t\t\t\t\tpluginInputStream = urlConnection.getInputStream();\n\t\t\t\t\t\tbyte[] buffer = new byte[1024];\n\t\t\t\t\t\tint read;\n\t\t\t\t\t\twhile ((read = pluginInputStream.read(buffer)) != -1) {\n\t\t\t\t\t\t\tpluginOutputStream.write(buffer, 0, read);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpluginOutputStream.close();\n\t\t\t\t\t\tif(tempPluginFile.length() == 0)\n\t\t\t\t\t\t\tthrow new PluginNotFoundException(\"downloaded zero length file\");\n\t\t\t\t\t\tif(!FileUtil.renameTo(tempPluginFile, pluginFile)) {\n\t\t\t\t\t\t\tLogger.error(this, \"could not rename temp file to plugin file\");\n\t\t\t\t\t\t\tthrow new PluginNotFoundException(\"could not rename temp file to plugin file\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException ioe1) {\n\t\t\t\t\t\tLogger.error(this, \"could not load plugin\", ioe1);\n\t\t\t\t\t\tif (tempPluginFile != null) {\n\t\t\t\t\t\t\ttempPluginFile.delete();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new PluginNotFoundException(\"could not load plugin: \" + ioe1.getMessage(), ioe1);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tCloser.close(pluginOutputStream);\n\t\t\t\t\t\tCloser.close(pluginInputStream);\n\t\t\t\t\t}\n\t\t\t\t} catch (PluginNotFoundException e) {\n\t\t\t\t\tif(i < RETRIES-1) {\n\t\t\t\t\t\tLogger.normal(this, \"Failed to load plugin: \"+e, e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else throw e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* now get the manifest file. */\n\t\tJarFile pluginJarFile = null;\n\t\tString pluginMainClassName = null;\n\t\ttry {\n\t\t\tpluginJarFile = new JarFile(pluginFile);\n\t\t\tManifest manifest = pluginJarFile.getManifest();\n\t\t\tif (manifest == null) {\n\t\t\t\tLogger.error(this, \"could not load manifest from plugin file\");\n\t\t\t\tpluginFile.delete();\n\t\t\t\tthrow new PluginNotFoundException(\"could not load manifest from plugin file\");\n\t\t\t}\n\t\t\tAttributes mainAttributes = manifest.getMainAttributes();\n\t\t\tif (mainAttributes == null) {\n\t\t\t\tLogger.error(this, \"manifest does not contain attributes\");\n\t\t\t\tpluginFile.delete();\n\t\t\t\tthrow new PluginNotFoundException(\"manifest does not contain attributes\");\n\t\t\t}\n\t\t\tpluginMainClassName = mainAttributes.getValue(\"Plugin-Main-Class\");\n\t\t\tif (pluginMainClassName == null) {\n\t\t\t\tLogger.error(this, \"manifest does not contain a Plugin-Main-Class attribute\");\n\t\t\t\tpluginFile.delete();\n\t\t\t\tthrow new PluginNotFoundException(\"manifest does not contain a Plugin-Main-Class attribute\");\n\t\t\t}\n\t\t} catch (JarException je1) {\n\t\t\tLogger.error(this, \"could not process jar file\", je1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not process jar file\", je1);\n\t\t} catch (ZipException ze1) {\n\t\t\tLogger.error(this, \"could not process jar file\", ze1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not process jar file\", ze1);\n\t\t} catch (IOException ioe1) {\n\t\t\tLogger.error(this, \"error processing jar file\", ioe1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"error procesesing jar file\", ioe1);\n\t\t} finally {\n\t\t\tCloser.close(pluginJarFile);\n\t\t}\n\n\t\ttry {\n\t\t\tJarClassLoader jarClassLoader = new JarClassLoader(pluginFile);\n\t\t\tClass pluginMainClass = jarClassLoader.loadClass(pluginMainClassName);\n\t\t\tObject object = pluginMainClass.newInstance();\n\t\t\tif (!(object instanceof FredPlugin)) {\n\t\t\t\tLogger.error(this, \"plugin main class is not a plugin\");\n\t\t\t\tpluginFile.delete();\n\t\t\t\tthrow new PluginNotFoundException(\"plugin main class is not a plugin\");\n\t\t\t}\n\t\t\treturn (FredPlugin) object;\n\t\t} catch (IOException ioe1) {\n\t\t\tLogger.error(this, \"could not load plugin\", ioe1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not load plugin\", ioe1);\n\t\t} catch (ClassNotFoundException cnfe1) {\n\t\t\tLogger.error(this, \"could not find plugin class\", cnfe1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not find plugin class\", cnfe1);\n\t\t} catch (InstantiationException ie1) {\n\t\t\tLogger.error(this, \"could not instantiate plugin\", ie1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not instantiate plugin\", ie1);\n\t\t} catch (IllegalAccessException iae1) {\n\t\t\tLogger.error(this, \"could not access plugin main class\", iae1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not access plugin main class\", iae1);\n\t\t} catch (NoClassDefFoundError ncdfe1) {\n\t\t\tLogger.error(this, \"could not find class def, may a missing lib?\", ncdfe1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not find class def, may a missing lib?\", ncdfe1);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"unexcpected error while plugin loading\", t);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"unexcpected error while plugin loading \"+t, t);\n\t\t}\n\t}","id":76389,"modified_method":"/**\n\t * Tries to load a plugin from the given name. If the name only contains the\n\t * name of a plugin it is loaded from the plugin directory, if found,\n\t * otherwise it's loaded from the project server. If the name contains a\n\t * complete url and the short file already exists in the plugin directory\n\t * it's loaded from the plugin directory, otherwise it's retrieved from the\n\t * remote server.\n\t * @param pdl \n\t * \n\t * @param name\n\t *            The specification of the plugin\n\t * @return An instanciated object of the plugin\n\t * @throws PluginNotFoundException\n\t *             If anything goes wrong.\n\t */\n\tprivate FredPlugin loadPlugin(PluginDownLoader pdl, String name) throws PluginNotFoundException {\n\t\t\n\t\tpdl.setSource(name);\n\t\t\n\t\t/* check for plugin directory. */\n\t\tFile pluginDirectory = new File(node.getNodeDir(), \"plugins\");\n\t\tif ((pluginDirectory.exists() && !pluginDirectory.isDirectory()) || (!pluginDirectory.exists() && !pluginDirectory.mkdirs())) {\n\t\t\tLogger.error(this, \"could not create plugin directory\");\n\t\t\tthrow new PluginNotFoundException(\"could not create plugin directory\");\n\t\t}\n\n\t\t/* get plugin filename. */\n\t\tString filename = pdl.getPluginName(name);\n\t\tFile pluginFile = new File(pluginDirectory, filename);\n\n\t\t/* check if file needs to be downloaded. */\n\t\tif (logMINOR) {\n\t\t\tLogger.minor(this, \"plugin file \" + pluginFile.getAbsolutePath() + \" exists: \" + pluginFile.exists());\n\t\t}\n\t\tint RETRIES = 5;\n\t\tfor(int i=0;i<RETRIES;i++) {\n\t\t\tif (!pluginFile.exists() || pluginFile.length() == 0) {\n\t\t\t\ttry {\n\t\t\t\t\tFile tempPluginFile = null;\n\t\t\t\t\tOutputStream pluginOutputStream = null;\n\t\t\t\t\tInputStream pluginInputStream = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttempPluginFile = File.createTempFile(\"plugin-\", \".jar\", pluginDirectory);\n\t\t\t\t\t\ttempPluginFile.deleteOnExit();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tpluginOutputStream = new FileOutputStream(tempPluginFile);\n\t\t\t\t\t\tpluginInputStream = pdl.getInputStream();\n\t\t\t\t\t\tbyte[] buffer = new byte[1024];\n\t\t\t\t\t\tint read;\n\t\t\t\t\t\twhile ((read = pluginInputStream.read(buffer)) != -1) {\n\t\t\t\t\t\t\tpluginOutputStream.write(buffer, 0, read);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpluginOutputStream.close();\n\t\t\t\t\t\tif(tempPluginFile.length() == 0)\n\t\t\t\t\t\t\tthrow new PluginNotFoundException(\"downloaded zero length file\");\n\t\t\t\t\t\tif(!FileUtil.renameTo(tempPluginFile, pluginFile)) {\n\t\t\t\t\t\t\tLogger.error(this, \"could not rename temp file to plugin file\");\n\t\t\t\t\t\t\tthrow new PluginNotFoundException(\"could not rename temp file to plugin file\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException ioe1) {\n\t\t\t\t\t\tLogger.error(this, \"could not load plugin\", ioe1);\n\t\t\t\t\t\tif (tempPluginFile != null) {\n\t\t\t\t\t\t\ttempPluginFile.delete();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new PluginNotFoundException(\"could not load plugin: \" + ioe1.getMessage(), ioe1);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tCloser.close(pluginOutputStream);\n\t\t\t\t\t\tCloser.close(pluginInputStream);\n\t\t\t\t\t}\n\t\t\t\t} catch (PluginNotFoundException e) {\n\t\t\t\t\tif(i < RETRIES-1) {\n\t\t\t\t\t\tLogger.normal(this, \"Failed to load plugin: \"+e, e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else throw e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* now get the manifest file. */\n\t\tJarFile pluginJarFile = null;\n\t\tString pluginMainClassName = null;\n\t\ttry {\n\t\t\tpluginJarFile = new JarFile(pluginFile);\n\t\t\tManifest manifest = pluginJarFile.getManifest();\n\t\t\tif (manifest == null) {\n\t\t\t\tLogger.error(this, \"could not load manifest from plugin file\");\n\t\t\t\tpluginFile.delete();\n\t\t\t\tthrow new PluginNotFoundException(\"could not load manifest from plugin file\");\n\t\t\t}\n\t\t\tAttributes mainAttributes = manifest.getMainAttributes();\n\t\t\tif (mainAttributes == null) {\n\t\t\t\tLogger.error(this, \"manifest does not contain attributes\");\n\t\t\t\tpluginFile.delete();\n\t\t\t\tthrow new PluginNotFoundException(\"manifest does not contain attributes\");\n\t\t\t}\n\t\t\tpluginMainClassName = mainAttributes.getValue(\"Plugin-Main-Class\");\n\t\t\tif (pluginMainClassName == null) {\n\t\t\t\tLogger.error(this, \"manifest does not contain a Plugin-Main-Class attribute\");\n\t\t\t\tpluginFile.delete();\n\t\t\t\tthrow new PluginNotFoundException(\"manifest does not contain a Plugin-Main-Class attribute\");\n\t\t\t}\n\t\t} catch (JarException je1) {\n\t\t\tLogger.error(this, \"could not process jar file\", je1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not process jar file\", je1);\n\t\t} catch (ZipException ze1) {\n\t\t\tLogger.error(this, \"could not process jar file\", ze1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not process jar file\", ze1);\n\t\t} catch (IOException ioe1) {\n\t\t\tLogger.error(this, \"error processing jar file\", ioe1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"error procesesing jar file\", ioe1);\n\t\t} finally {\n\t\t\tCloser.close(pluginJarFile);\n\t\t}\n\n\t\ttry {\n\t\t\tJarClassLoader jarClassLoader = new JarClassLoader(pluginFile);\n\t\t\tClass pluginMainClass = jarClassLoader.loadClass(pluginMainClassName);\n\t\t\tObject object = pluginMainClass.newInstance();\n\t\t\tif (!(object instanceof FredPlugin)) {\n\t\t\t\tLogger.error(this, \"plugin main class is not a plugin\");\n\t\t\t\tpluginFile.delete();\n\t\t\t\tthrow new PluginNotFoundException(\"plugin main class is not a plugin\");\n\t\t\t}\n\t\t\treturn (FredPlugin) object;\n\t\t} catch (IOException ioe1) {\n\t\t\tLogger.error(this, \"could not load plugin\", ioe1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not load plugin\", ioe1);\n\t\t} catch (ClassNotFoundException cnfe1) {\n\t\t\tLogger.error(this, \"could not find plugin class\", cnfe1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not find plugin class\", cnfe1);\n\t\t} catch (InstantiationException ie1) {\n\t\t\tLogger.error(this, \"could not instantiate plugin\", ie1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not instantiate plugin\", ie1);\n\t\t} catch (IllegalAccessException iae1) {\n\t\t\tLogger.error(this, \"could not access plugin main class\", iae1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not access plugin main class\", iae1);\n\t\t} catch (NoClassDefFoundError ncdfe1) {\n\t\t\tLogger.error(this, \"could not find class def, may a missing lib?\", ncdfe1);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"could not find class def, may a missing lib?\", ncdfe1);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"unexcpected error while plugin loading\", t);\n\t\t\tpluginFile.delete();\n\t\t\tthrow new PluginNotFoundException(\"unexcpected error while plugin loading \"+t, t);\n\t\t}\n\t}","commit_id":"7ccaa584a530ccd2e7cf9e5813d7ef64f7b8d4f8","url":"https://github.com/freenet/fred"},{"original_method":"private void showUnofficialPluginLoader(ToadletContext toadletContext, HTMLNode contentNode) {\n\t\t/* box for unofficial plugins. */\n\t\tHTMLNode addOtherPluginBox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\taddOtherPluginBox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"loadOtherPlugin\"));\n\t\tHTMLNode addOtherPluginContent = addOtherPluginBox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode addOtherForm = toadletContext.addFormChild(addOtherPluginContent, \".\", \"addOtherPluginForm\");\n\t\taddOtherForm.addChild(\"div\", l10n(\"loadOtherPluginText\"));\n\t\taddOtherForm.addChild(\"#\", (l10n(\"loadOtherURLLabel\") + \": \"));\n\t\taddOtherForm.addChild(\"input\", new String[] { \"type\", \"name\", \"size\" }, new String[] { \"text\", \"plugin-url\", \"80\" });\n\t\taddOtherForm.addChild(\"#\", \" \");\n\t\taddOtherForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"submit-other\", l10n(\"Load\") });\n\t}","id":76390,"modified_method":"private void showUnofficialPluginLoader(ToadletContext toadletContext, HTMLNode contentNode) {\n\t\t/* box for unofficial plugins. */\n\t\tHTMLNode addOtherPluginBox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\taddOtherPluginBox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"loadOtherPlugin\"));\n\t\tHTMLNode addOtherPluginContent = addOtherPluginBox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode addOtherForm = toadletContext.addFormChild(addOtherPluginContent, \".\", \"addOtherPluginForm\");\n\t\taddOtherForm.addChild(\"div\", l10n(\"loadOtherPluginText\"));\n\t\taddOtherForm.addChild(\"#\", (l10n(\"loadOtherURLLabel\") + \": \"));\n\t\taddOtherForm.addChild(\"input\", new String[] { \"type\", \"name\", \"size\" }, new String[] { \"text\", \"plugin-url\", \"80\" });\n\t\taddOtherForm.addChild(\"#\", \" \");\n\t\taddOtherForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"submit-other\", l10n(\"Load\") });\n\t\taddOtherForm.addChild(\"br\");\n\t\taddOtherForm.addChild(\"input\", new String[] { \"type\", \"name\", \"checked\" }, new String[] { \"checkbox\", \"fileonly\", \"checked\" });\n\t\taddOtherForm.addChild(\"#\", \" \" + l10n(\"fileonly\"));\n\t}","commit_id":"7ccaa584a530ccd2e7cf9e5813d7ef64f7b8d4f8","url":"https://github.com/freenet/fred"},{"original_method":"public void handlePost(URI uri, HTTPRequest request, ToadletContext ctx)\n\tthrows ToadletContextClosedException, IOException {\n\n\t\tMultiValueTable headers = new MultiValueTable();\n\n\t\tString pass = request.getPartAsString(\"formPassword\", 32);\n\t\tif((pass == null) || !pass.equals(core.formPassword)) {\n\t\t\theaders.put(\"Location\", \"/plugins/\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, l10n(\"unauthorizedTitle\"), l10n(\"unauthorized\"));\n\t\t\treturn;\n\t\t}\n\n\t\tString path=request.getPath();\n\n\t\t// remove leading / and plugins/ from path\n\t\tif(path.startsWith(\"/\")) path = path.substring(1);\n\t\tif(path.startsWith(\"plugins/\")) path = path.substring(\"plugins/\".length());\n\n\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Pproxy received POST on \"+path);\n\n\t\tPluginManager pm = node.pluginManager;\n\n\t\tif(path.length()>0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tString plugin = null;\n\t\t\t\t// split path into plugin class name and 'daa' path for plugin\n\t\t\t\tint to = path.indexOf(\"/\");\n\t\t\t\tif(to == -1)\n\t\t\t\t{\n\t\t\t\t\tplugin = path;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplugin = path.substring(0, to);\n\t\t\t\t}\n\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pm.handleHTTPPost(plugin, request));\n\t\t\t}\n\t\t\tcatch (RedirectPluginHTTPException e) {\n\t\t\t\twriteTemporaryRedirect(ctx, e.message, e.newLocation);\n\t\t\t}\n\t\t\tcatch (NotFoundPluginHTTPException e) {\n\t\t\t\tsendErrorPage(ctx, NotFoundPluginHTTPException.code, e.message, e.location);\n\t\t\t}\n\t\t\tcatch (AccessDeniedPluginHTTPException e) {\n\t\t\t\tsendErrorPage(ctx, AccessDeniedPluginHTTPException.code, e.message, e.location);\n\t\t\t}\n\t\t\tcatch (DownloadPluginHTTPException e) {\n\t\t\t\t// FIXME: maybe it ought to be defined like sendErrorPage : in toadlets\n\n\t\t\t\tMultiValueTable head = new MultiValueTable();\n\t\t\t\thead.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + e.filename + '\"');\n\t\t\t\tctx.sendReplyHeaders(DownloadPluginHTTPException.CODE, \"Found\", head, e.mimeType, e.data.length);\n\t\t\t\tctx.writeData(e.data);\n\t\t\t}\n\t\t\tcatch(PluginHTTPException e)\n\t\t\t{\n\t\t\t\tsendErrorPage(ctx, PluginHTTPException.code, e.message, e.location);\n\t\t\t}\n\t\t\tcatch(Throwable t)\n\t\t\t{\n\t\t\t\twriteInternalError(t, ctx);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPageMaker pageMaker = ctx.getPageMaker();\n\n\t\t\tif (request.isPartSet(\"submit-official\") || request.isPartSet(\"submit-other\")) {\n\t\t\t\tString pluginName = null;\n\t\t\t\tif (request.isPartSet(\"submit-official\")) {\n\t\t\t\t\tpluginName = request.getPartAsString(\"plugin-name\", 40);\n\t\t\t\t} else {\n\t\t\t\t\tpluginName = request.getPartAsString(\"plugin-url\", 200);\n\t\t\t\t}\n\t\t\t\tpm.startPlugin(pluginName, true);\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.isPartSet(\"dismiss-user-alert\")) {\n\t\t\t\tint userAlertHashCode = request.getIntPart(\"disable\", -1);\n\t\t\t\tcore.alerts.dismissAlert(userAlertHashCode);\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.isPartSet(\"cancel\")){\n\t\t\t\theaders.put(\"Location\", \"/plugins/\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.getPartAsString(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tString pluginThreadName = request.getPartAsString(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH);\n\t\t\t\tString pluginSpecification = getPluginSpecification(pm, pluginThreadName);\n\t\t\t\tpm.killPlugin(pluginThreadName, MAX_THREADED_UNLOAD_WAIT_TIME);\n\t\t\t\tif (request.isPartSet(\"purge\")) {\n\t\t\t\t\tpm.removeCachedCopy(pluginSpecification);\n\t\t\t\t}\n\t\t\t\tHTMLNode pageNode = pageMaker.getPageNode(l10n(\"plugins\"), ctx);\n\t\t\t\tHTMLNode contentNode = pageMaker.getContentNode(pageNode);\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-success\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"pluginUnloaded\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"pluginUnloadedWithName\", \"name\", pluginThreadName));\n\t\t\t\tinfoboxContent.addChild(\"br\");\n\t\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/plugins/\", l10n(\"returnToPluginPage\"));\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t}if (request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tHTMLNode pageNode = pageMaker.getPageNode(l10n(\"plugins\"), ctx);\n\t\t\t\tHTMLNode contentNode = pageMaker.getContentNode(pageNode);\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-query\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"unloadPluginTitle\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"unloadPluginWithName\", \"name\", request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH)));\n\t\t\t\tHTMLNode unloadForm = \n\t\t\t\t\tctx.addFormChild(infoboxContent, \"/plugins/\", \"unloadPluginConfirmForm\");\n\t\t\t\tunloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"unloadconfirm\", request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH) });\n\t\t\t\tHTMLNode tempNode = unloadForm.addChild(\"p\");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\" }, new String[] { \"checkbox\", \"purge\" });\n\t\t\t\ttempNode.addChild(\"#\", l10n(\"unloadPurge\"));\n\t\t\t\ttempNode = unloadForm.addChild(\"p\");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"confirm\", l10n(\"unload\") });\n\t\t\t\ttempNode.addChild(\"#\", \" \");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\") });\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t} else if (request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tHTMLNode pageNode = pageMaker.getPageNode(l10n(\"plugins\"), ctx);\n\t\t\t\tHTMLNode contentNode = pageMaker.getContentNode(pageNode);\n\t\t\t\tHTMLNode reloadBox = contentNode.addChild(pageMaker.getInfobox(\"infobox infobox-query\", l10n(\"reloadPluginTitle\")));\n\t\t\t\tHTMLNode reloadContent = pageMaker.getContentNode(reloadBox);\n\t\t\t\treloadContent.addChild(\"p\", l10n(\"reloadExplanation\"));\n\t\t\t\treloadContent.addChild(\"p\", l10n(\"reloadWarning\"));\n\t\t\t\tHTMLNode reloadForm = ctx.addFormChild(reloadContent, \"/plugins/\", \"reloadPluginConfirmForm\");\n\t\t\t\treloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"reloadconfirm\", request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH) });\n\t\t\t\tHTMLNode tempNode = reloadForm.addChild(\"p\");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\" }, new String[] { \"checkbox\", \"purge\" });\n\t\t\t\ttempNode.addChild(\"#\", l10n(\"reloadPurgeWarning\"));\n\t\t\t\ttempNode = reloadForm.addChild(\"p\");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"confirm\", l10n(\"reload\") });\n\t\t\t\ttempNode.addChild(\"#\", \" \");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\") });\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t}else if (request.getPartAsString(\"reloadconfirm\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tboolean purge = request.isPartSet(\"purge\");\n\t\t\t\tString pluginThreadName = request.getPartAsString(\"reloadconfirm\", MAX_PLUGIN_NAME_LENGTH);\n\t\t\t\tString fn = getPluginSpecification(pm, pluginThreadName);\n\n\t\t\t\tif (fn == null) {\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"pluginNotFoundReloadTitle\"), \n\t\t\t\t\t\t\tL10n.getString(\"PluginToadlet.pluginNotFoundReload\"));\n\t\t\t\t} else {\n\t\t\t\t\tpm.killPlugin(pluginThreadName, MAX_THREADED_UNLOAD_WAIT_TIME);\n\t\t\t\t\tif (purge) {\n\t\t\t\t\t\tpm.removeCachedCopy(fn);\n\t\t\t\t\t}\n\t\t\t\t\tpm.startPlugin(fn, true);\n\n\t\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}else {\n\t\t\t\t// Ignore\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t}\n\n\t\t}\n\n\t}","id":76391,"modified_method":"public void handlePost(URI uri, HTTPRequest request, ToadletContext ctx)\n\tthrows ToadletContextClosedException, IOException {\n\n\t\tMultiValueTable headers = new MultiValueTable();\n\n\t\tString pass = request.getPartAsString(\"formPassword\", 32);\n\t\tif((pass == null) || !pass.equals(core.formPassword)) {\n\t\t\theaders.put(\"Location\", \"/plugins/\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, l10n(\"unauthorizedTitle\"), l10n(\"unauthorized\"));\n\t\t\treturn;\n\t\t}\n\n\t\tString path=request.getPath();\n\n\t\t// remove leading / and plugins/ from path\n\t\tif(path.startsWith(\"/\")) path = path.substring(1);\n\t\tif(path.startsWith(\"plugins/\")) path = path.substring(\"plugins/\".length());\n\n\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Pproxy received POST on \"+path);\n\n\t\tPluginManager pm = node.pluginManager;\n\n\t\tif(path.length()>0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tString plugin = null;\n\t\t\t\t// split path into plugin class name and 'daa' path for plugin\n\t\t\t\tint to = path.indexOf(\"/\");\n\t\t\t\tif(to == -1)\n\t\t\t\t{\n\t\t\t\t\tplugin = path;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplugin = path.substring(0, to);\n\t\t\t\t}\n\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pm.handleHTTPPost(plugin, request));\n\t\t\t}\n\t\t\tcatch (RedirectPluginHTTPException e) {\n\t\t\t\twriteTemporaryRedirect(ctx, e.message, e.newLocation);\n\t\t\t}\n\t\t\tcatch (NotFoundPluginHTTPException e) {\n\t\t\t\tsendErrorPage(ctx, NotFoundPluginHTTPException.code, e.message, e.location);\n\t\t\t}\n\t\t\tcatch (AccessDeniedPluginHTTPException e) {\n\t\t\t\tsendErrorPage(ctx, AccessDeniedPluginHTTPException.code, e.message, e.location);\n\t\t\t}\n\t\t\tcatch (DownloadPluginHTTPException e) {\n\t\t\t\t// FIXME: maybe it ought to be defined like sendErrorPage : in toadlets\n\n\t\t\t\tMultiValueTable head = new MultiValueTable();\n\t\t\t\thead.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + e.filename + '\"');\n\t\t\t\tctx.sendReplyHeaders(DownloadPluginHTTPException.CODE, \"Found\", head, e.mimeType, e.data.length);\n\t\t\t\tctx.writeData(e.data);\n\t\t\t}\n\t\t\tcatch(PluginHTTPException e)\n\t\t\t{\n\t\t\t\tsendErrorPage(ctx, PluginHTTPException.code, e.message, e.location);\n\t\t\t}\n\t\t\tcatch(Throwable t)\n\t\t\t{\n\t\t\t\twriteInternalError(t, ctx);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPageMaker pageMaker = ctx.getPageMaker();\n\t\t\t\n\t\t\tif (request.isPartSet(\"submit-official\")) {\n\t\t\t\tString pluginName = null;\n\t\t\t\tpluginName = request.getPartAsString(\"plugin-name\", 40);\n\t\t\t\tpm.startPluginOfficial(pluginName, true);\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.isPartSet(\"submit-other\")) {\n\t\t\t\tString pluginName = null;\n\t\t\t\tpluginName = request.getPartAsString(\"plugin-url\", 200);\n\t\t\t\tboolean fileonly = \"on\".equalsIgnoreCase(request.getPartAsString(\"fileonly\", 20));\n\t\t\t\tif (fileonly) \n\t\t\t\t\tpm.startPluginFile(pluginName, true);\n\t\t\t\telse\n\t\t\t\t\tpm.startPluginURL(pluginName, true);\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.isPartSet(\"submit-freenet\")) {\n\t\t\t\tString pluginName = null;\n\t\t\t\tpluginName = request.getPartAsString(\"plugin-uri\", 300);\n\t\t\t\tpm.startPluginFreenet(pluginName, true);\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.isPartSet(\"dismiss-user-alert\")) {\n\t\t\t\tint userAlertHashCode = request.getIntPart(\"disable\", -1);\n\t\t\t\tcore.alerts.dismissAlert(userAlertHashCode);\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.isPartSet(\"cancel\")){\n\t\t\t\theaders.put(\"Location\", \"/plugins/\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.getPartAsString(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tString pluginThreadName = request.getPartAsString(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH);\n\t\t\t\tString pluginSpecification = getPluginSpecification(pm, pluginThreadName);\n\t\t\t\tpm.killPlugin(pluginThreadName, MAX_THREADED_UNLOAD_WAIT_TIME);\n\t\t\t\tif (request.isPartSet(\"purge\")) {\n\t\t\t\t\tpm.removeCachedCopy(pluginSpecification);\n\t\t\t\t}\n\t\t\t\tHTMLNode pageNode = pageMaker.getPageNode(l10n(\"plugins\"), ctx);\n\t\t\t\tHTMLNode contentNode = pageMaker.getContentNode(pageNode);\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-success\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"pluginUnloaded\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"pluginUnloadedWithName\", \"name\", pluginThreadName));\n\t\t\t\tinfoboxContent.addChild(\"br\");\n\t\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/plugins/\", l10n(\"returnToPluginPage\"));\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t}if (request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tHTMLNode pageNode = pageMaker.getPageNode(l10n(\"plugins\"), ctx);\n\t\t\t\tHTMLNode contentNode = pageMaker.getContentNode(pageNode);\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-query\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"unloadPluginTitle\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"unloadPluginWithName\", \"name\", request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH)));\n\t\t\t\tHTMLNode unloadForm = \n\t\t\t\t\tctx.addFormChild(infoboxContent, \"/plugins/\", \"unloadPluginConfirmForm\");\n\t\t\t\tunloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"unloadconfirm\", request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH) });\n\t\t\t\tHTMLNode tempNode = unloadForm.addChild(\"p\");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\" }, new String[] { \"checkbox\", \"purge\" });\n\t\t\t\ttempNode.addChild(\"#\", l10n(\"unloadPurge\"));\n\t\t\t\ttempNode = unloadForm.addChild(\"p\");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"confirm\", l10n(\"unload\") });\n\t\t\t\ttempNode.addChild(\"#\", \" \");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\") });\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t} else if (request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tHTMLNode pageNode = pageMaker.getPageNode(l10n(\"plugins\"), ctx);\n\t\t\t\tHTMLNode contentNode = pageMaker.getContentNode(pageNode);\n\t\t\t\tHTMLNode reloadBox = contentNode.addChild(pageMaker.getInfobox(\"infobox infobox-query\", l10n(\"reloadPluginTitle\")));\n\t\t\t\tHTMLNode reloadContent = pageMaker.getContentNode(reloadBox);\n\t\t\t\treloadContent.addChild(\"p\", l10n(\"reloadExplanation\"));\n\t\t\t\treloadContent.addChild(\"p\", l10n(\"reloadWarning\"));\n\t\t\t\tHTMLNode reloadForm = ctx.addFormChild(reloadContent, \"/plugins/\", \"reloadPluginConfirmForm\");\n\t\t\t\treloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"reloadconfirm\", request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH) });\n\t\t\t\tHTMLNode tempNode = reloadForm.addChild(\"p\");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\" }, new String[] { \"checkbox\", \"purge\" });\n\t\t\t\ttempNode.addChild(\"#\", l10n(\"reloadPurgeWarning\"));\n\t\t\t\ttempNode = reloadForm.addChild(\"p\");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"confirm\", l10n(\"reload\") });\n\t\t\t\ttempNode.addChild(\"#\", \" \");\n\t\t\t\ttempNode.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", L10n.getString(\"Toadlet.cancel\") });\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t\treturn;\n\t\t\t}else if (request.getPartAsString(\"reloadconfirm\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tboolean purge = request.isPartSet(\"purge\");\n\t\t\t\tString pluginThreadName = request.getPartAsString(\"reloadconfirm\", MAX_PLUGIN_NAME_LENGTH);\n\t\t\t\tString fn = getPluginSpecification(pm, pluginThreadName);\n\n\t\t\t\tif (fn == null) {\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"pluginNotFoundReloadTitle\"), \n\t\t\t\t\t\t\tL10n.getString(\"PluginToadlet.pluginNotFoundReload\"));\n\t\t\t\t} else {\n\t\t\t\t\tpm.killPlugin(pluginThreadName, MAX_THREADED_UNLOAD_WAIT_TIME);\n\t\t\t\t\tif (purge) {\n\t\t\t\t\t\tpm.removeCachedCopy(fn);\n\t\t\t\t\t}\n\t\t\t\t\t// FIXME\n\t\t\t\t\tpm.startPluginAuto(fn, true);\n\n\t\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}else {\n\t\t\t\t// Ignore\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t}\n\n\t\t}\n\n\t}","commit_id":"7ccaa584a530ccd2e7cf9e5813d7ef64f7b8d4f8","url":"https://github.com/freenet/fred"},{"original_method":"public void handleGet(URI uri, HTTPRequest request, ToadletContext ctx)\n\tthrows ToadletContextClosedException, IOException {\n\n\t\t//String basepath = \"/plugins/\";\n\t\tString path = request.getPath();\n\n\t\t// remove leading / and plugins/ from path\n\t\tif(path.startsWith(\"/\")) path = path.substring(1);\n\t\tif(path.startsWith(\"plugins/\")) path = path.substring(\"plugins/\".length());\n\n\t\tPluginManager pm = node.pluginManager;\n\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Pproxy fetching \"+path);\n\t\ttry {\n\t\t\tif (path.equals(\"\")) {\n\t\t\t\tif (!ctx.isAllowedFullAccess()) {\n\t\t\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", L10n.getString(\"Toadlet.unauthorized\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tIterator/* <PluginProgress> */loadingPlugins = pm.getStartingPlugins().iterator();\n\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"pluginsWithNodeName\", \"name\", core.getMyName()), ctx);\n\t\t\t\tif (loadingPlugins.hasNext()) {\n\t\t\t\t\t/* okay, add a refresh. */\n\t\t\t\t\tHTMLNode headNode = ctx.getPageMaker().getHeadNode(pageNode);\n\t\t\t\t\theadNode.addChild(\"meta\", new String[] { \"http-equiv\", \"content\" }, new String[] { \"refresh\", \"10; url=\" });\n\t\t\t\t}\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\n\t\t\t\tcontentNode.addChild(core.alerts.createSummary());\n\n\t\t\t\tUserAlert[] userAlerts = core.alerts.getAlerts();\n\t\t\t\tfor (int index = 0, count = userAlerts.length; index < count; index++) {\n\t\t\t\t\tUserAlert userAlert = userAlerts[index];\n\t\t\t\t\tif (userAlert.isValid() && (userAlert.getUserIdentifier() == PluginManager.class)) {\n\t\t\t\t\t\tcontentNode.addChild(core.alerts.renderAlert(userAlert));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* find which plugins have already been loaded. */\n\t\t\t\tList/*<String>*/ availablePlugins = findAvailablePlugins();\n\t\t\t\tIterator/*<PluginInfoWrapper>*/ loadedPlugins = pm.getPlugins().iterator();\n\t\t\t\twhile (loadedPlugins.hasNext()) {\n\t\t\t\t\tPluginInfoWrapper pluginInfoWrapper = (PluginInfoWrapper) loadedPlugins.next();\n\t\t\t\t\tString pluginName = pluginInfoWrapper.getPluginClassName();\n\t\t\t\t\tString shortPluginName = pluginName.substring(pluginName.lastIndexOf('.') + 1);\n\t\t\t\t\tavailablePlugins.remove(shortPluginName);\n\t\t\t\t}\n\t\t\t\twhile (loadingPlugins.hasNext()) {\n\t\t\t\t\tPluginProgress pluginProgress = (PluginProgress) loadingPlugins.next();\n\t\t\t\t\tString pluginName = pluginProgress.getName();\n\t\t\t\t\tavailablePlugins.remove(pluginName);\n\t\t\t\t}\n\n\t\t\t\tshowStartingPlugins(pm, contentNode);\n\t\t\t\tshowPluginList(ctx, pm, contentNode);\n\t\t\t\tshowOfficialPluginLoader(ctx, contentNode, availablePlugins);\n\t\t\t\tshowUnofficialPluginLoader(ctx, contentNode);\n\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\t// split path into plugin class name and 'data' path for plugin\n\t\t\t\tint to = path.indexOf(\"/\");\n\t\t\t\tString plugin;\n\t\t\t\tif (to == -1) {\n\t\t\t\t\tplugin = path;\n\t\t\t\t} else {\n\t\t\t\t\tplugin = path.substring(0, to);\n\t\t\t\t}\n\n\t\t\t\t// Plugin may need to know where it was accessed from, so it can e.g. produce relative URLs.\n\t\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkPage(\"plugin\", pm.handleHTTPGet(plugin, data)));\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pm.handleHTTPGet(plugin, request));\t\t\t\t\n\t\t\t}\n\n\t\t\t//FetchResult result = fetch(key);\n\t\t\t//writeReply(ctx, 200, result.getMimeType(), \"OK\", result.asBucket());\n\t\t} catch (RedirectPluginHTTPException e) {\n\t\t\twriteTemporaryRedirect(ctx, e.message, e.newLocation);\n\t\t} catch (NotFoundPluginHTTPException e) {\n\t\t\tsendErrorPage(ctx, NotFoundPluginHTTPException.code, e.message, e.location);\n\t\t} catch (AccessDeniedPluginHTTPException e) {\n\t\t\tsendErrorPage(ctx, AccessDeniedPluginHTTPException.code, e.message, e.location);\n\t\t} catch (DownloadPluginHTTPException e) {\n\t\t\t// FIXME: maybe it ought to be defined like sendErrorPage : in toadlets\n\n\t\t\tMultiValueTable head = new MultiValueTable();\n\t\t\thead.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + e.filename + '\"');\n\t\t\tctx.sendReplyHeaders(DownloadPluginHTTPException.CODE, \"Found\", head, e.mimeType, e.data.length);\n\t\t\tctx.writeData(e.data);\n\t\t} catch(PluginHTTPException e) {\n\t\t\tsendErrorPage(ctx, PluginHTTPException.code, e.message, e.location);\n\t\t} catch (Throwable t) {\n\t\t\tctx.forceDisconnect();\n\t\t\twriteInternalError(t, ctx);\n\t\t}\n\t}","id":76392,"modified_method":"public void handleGet(URI uri, HTTPRequest request, ToadletContext ctx)\n\tthrows ToadletContextClosedException, IOException {\n\n\t\t//String basepath = \"/plugins/\";\n\t\tString path = request.getPath();\n\n\t\t// remove leading / and plugins/ from path\n\t\tif(path.startsWith(\"/\")) path = path.substring(1);\n\t\tif(path.startsWith(\"plugins/\")) path = path.substring(\"plugins/\".length());\n\n\t\tPluginManager pm = node.pluginManager;\n\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Pproxy fetching \"+path);\n\t\ttry {\n\t\t\tif (path.equals(\"\")) {\n\t\t\t\tif (!ctx.isAllowedFullAccess()) {\n\t\t\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", L10n.getString(\"Toadlet.unauthorized\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tIterator/* <PluginProgress> */loadingPlugins = pm.getStartingPlugins().iterator();\n\n\t\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(l10n(\"pluginsWithNodeName\", \"name\", core.getMyName()), ctx);\n\t\t\t\tif (loadingPlugins.hasNext()) {\n\t\t\t\t\t/* okay, add a refresh. */\n\t\t\t\t\tHTMLNode headNode = ctx.getPageMaker().getHeadNode(pageNode);\n\t\t\t\t\theadNode.addChild(\"meta\", new String[] { \"http-equiv\", \"content\" }, new String[] { \"refresh\", \"10; url=\" });\n\t\t\t\t}\n\t\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\n\t\t\t\tcontentNode.addChild(core.alerts.createSummary());\n\n\t\t\t\tUserAlert[] userAlerts = core.alerts.getAlerts();\n\t\t\t\tfor (int index = 0, count = userAlerts.length; index < count; index++) {\n\t\t\t\t\tUserAlert userAlert = userAlerts[index];\n\t\t\t\t\tif (userAlert.isValid() && (userAlert.getUserIdentifier() == PluginManager.class)) {\n\t\t\t\t\t\tcontentNode.addChild(core.alerts.renderAlert(userAlert));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* find which plugins have already been loaded. */\n\t\t\t\tList<String> availablePlugins = pm.findAvailablePlugins();\n\t\t\t\tIterator/*<PluginInfoWrapper>*/ loadedPlugins = pm.getPlugins().iterator();\n\t\t\t\twhile (loadedPlugins.hasNext()) {\n\t\t\t\t\tPluginInfoWrapper pluginInfoWrapper = (PluginInfoWrapper) loadedPlugins.next();\n\t\t\t\t\tString pluginName = pluginInfoWrapper.getPluginClassName();\n\t\t\t\t\tString shortPluginName = pluginName.substring(pluginName.lastIndexOf('.') + 1);\n\t\t\t\t\tavailablePlugins.remove(shortPluginName);\n\t\t\t\t}\n\t\t\t\twhile (loadingPlugins.hasNext()) {\n\t\t\t\t\tPluginProgress pluginProgress = (PluginProgress) loadingPlugins.next();\n\t\t\t\t\tString pluginName = pluginProgress.getName();\n\t\t\t\t\tavailablePlugins.remove(pluginName);\n\t\t\t\t}\n\n\t\t\t\tshowStartingPlugins(pm, contentNode);\n\t\t\t\tshowPluginList(ctx, pm, contentNode);\n\t\t\t\tshowOfficialPluginLoader(ctx, contentNode, availablePlugins);\n\t\t\t\tshowUnofficialPluginLoader(ctx, contentNode);\n\t\t\t\tshowFreenetPluginLoader(ctx, contentNode);\n\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\t// split path into plugin class name and 'data' path for plugin\n\t\t\t\tint to = path.indexOf(\"/\");\n\t\t\t\tString plugin;\n\t\t\t\tif (to == -1) {\n\t\t\t\t\tplugin = path;\n\t\t\t\t} else {\n\t\t\t\t\tplugin = path.substring(0, to);\n\t\t\t\t}\n\n\t\t\t\t// Plugin may need to know where it was accessed from, so it can e.g. produce relative URLs.\n\t\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkPage(\"plugin\", pm.handleHTTPGet(plugin, data)));\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pm.handleHTTPGet(plugin, request));\t\t\t\t\n\t\t\t}\n\n\t\t\t//FetchResult result = fetch(key);\n\t\t\t//writeReply(ctx, 200, result.getMimeType(), \"OK\", result.asBucket());\n\t\t} catch (RedirectPluginHTTPException e) {\n\t\t\twriteTemporaryRedirect(ctx, e.message, e.newLocation);\n\t\t} catch (NotFoundPluginHTTPException e) {\n\t\t\tsendErrorPage(ctx, NotFoundPluginHTTPException.code, e.message, e.location);\n\t\t} catch (AccessDeniedPluginHTTPException e) {\n\t\t\tsendErrorPage(ctx, AccessDeniedPluginHTTPException.code, e.message, e.location);\n\t\t} catch (DownloadPluginHTTPException e) {\n\t\t\t// FIXME: maybe it ought to be defined like sendErrorPage : in toadlets\n\n\t\t\tMultiValueTable head = new MultiValueTable();\n\t\t\thead.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + e.filename + '\"');\n\t\t\tctx.sendReplyHeaders(DownloadPluginHTTPException.CODE, \"Found\", head, e.mimeType, e.data.length);\n\t\t\tctx.writeData(e.data);\n\t\t} catch(PluginHTTPException e) {\n\t\t\tsendErrorPage(ctx, PluginHTTPException.code, e.message, e.location);\n\t\t} catch (Throwable t) {\n\t\t\tctx.forceDisconnect();\n\t\t\twriteInternalError(t, ctx);\n\t\t}\n\t}","commit_id":"7ccaa584a530ccd2e7cf9e5813d7ef64f7b8d4f8","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Process a single command.\n     * @throws IOException If we could not write the data to stdout.\n     */\n    private boolean processLine(BufferedReader reader, final OutputStream out) throws IOException {\n        String line;\n        StringBuffer outsb = new StringBuffer();\n        try {\n            line = reader.readLine();\n        } catch (IOException e) {\n            outsb.append(\"Bye... (\").append(e).append(')');\n            System.err.println(\"Bye... (\"+e+ ')');\n            return true;\n        }\n        boolean getCHKOnly = false;\n        if(line == null) return true;\n        String uline = line.toUpperCase();\n        if(Logger.shouldLog(Logger.MINOR, this))\n        \tLogger.minor(this, \"Command: \"+line);\n        if(uline.startsWith(\"GET:\")) {\n            // Should have a key next\n            String key = line.substring(\"GET:\".length()).trim();\n            Logger.normal(this, \"Key: \"+key);\n            FreenetURI uri;\n            try {\n                uri = new FreenetURI(key);\n                Logger.normal(this, \"Key: \"+uri);\n            } catch (MalformedURLException e2) {\n                outsb.append(\"Malformed URI: \").append(key).append(\" : \").append(e2);\n\t\toutsb.append(\"\\r\\n\");\n\t\tout.write(outsb.toString().getBytes());\n\t\tout.flush();\n                return false;\n            }\n            try {\n\t\t\t\tFetchResult result = client.fetch(uri);\n\t\t\t\tClientMetadata cm = result.getMetadata();\n                outsb.append(\"Content MIME type: \").append(cm.getMIMEType());\n\t\t\t\tBucket data = result.asBucket();\n\t\t\t\t// FIXME limit it above\n\t\t\t\tif(data.size() > 32*1024) {\n\t\t\t\t\tSystem.err.println(\"Data is more than 32K: \"+data.size());\n\t\t\t\t\toutsb.append(\"Data is more than 32K: \").append(data.size());\n\t\t\t\t\toutsb.append(\"\\r\\n\");\n\t\t\t\t\tout.write(outsb.toString().getBytes());\n\t\t\t\t\tout.flush();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbyte[] dataBytes = BucketTools.toByteArray(data);\n\t\t\t\tboolean evil = false;\n\t\t\t\tfor(int i=0;i<dataBytes.length;i++) {\n\t\t\t\t\t// Look for escape codes\n\t\t\t\t\tif(dataBytes[i] == '\\n') continue;\n\t\t\t\t\tif(dataBytes[i] == '\\r') continue;\n\t\t\t\t\tif(dataBytes[i] < 32) evil = true;\n\t\t\t\t}\n\t\t\t\tif(evil) {\n\t\t\t\t\tSystem.err.println(\"Data may contain escape codes which could cause the terminal to run arbitrary commands! Save it to a file if you must with GETFILE:\");\n\t\t\t\t\toutsb.append(\"Data may contain escape codes which could cause the terminal to run arbitrary commands! Save it to a file if you must with GETFILE:\");\n\t\t\t\t\toutsb.append(\"\\r\\n\");\n\t\t\t\t\tout.write(outsb.toString().getBytes());\n\t\t\t\t\tout.flush();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\toutsb.append(\"Data:\\r\\n\");\n\t\t\t\toutsb.append(new String(dataBytes));\n\t\t\t} catch (FetchException e) {\n                outsb.append(\"Error: \").append(e.getMessage()).append(\"\\r\\n\");\n            \tif((e.getMode() == FetchException.SPLITFILE_ERROR) && (e.errorCodes != null)) {\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tif(e.newURI != null)\n                    outsb.append(\"Permanent redirect: \").append(e.newURI).append(\"\\r\\n\");\n\t\t\t}\n        } else if(uline.startsWith(\"GETFILE:\")) {\n            // Should have a key next\n            String key = line.substring(\"GETFILE:\".length()).trim();\n            Logger.normal(this, \"Key: \"+key);\n            FreenetURI uri;\n            try {\n                uri = new FreenetURI(key);\n            } catch (MalformedURLException e2) {\n                outsb.append(\"Malformed URI: \").append(key).append(\" : \").append(e2);\n\t\toutsb.append(\"\\r\\n\");\n\t\tout.write(outsb.toString().getBytes());\n\t\tout.flush();\n                return false;\n            }\n            try {\n            \tlong startTime = System.currentTimeMillis();\n\t\t\t\tFetchResult result = client.fetch(uri);\n\t\t\t\tClientMetadata cm = result.getMetadata();\n                outsb.append(\"Content MIME type: \").append(cm.getMIMEType());\n\t\t\t\tBucket data = result.asBucket();\n                // Now calculate filename\n                String fnam = uri.getDocName();\n                fnam = sanitize(fnam);\n                if(fnam.length() == 0) {\n                    fnam = \"freenet-download-\"+HexUtil.bytesToHex(BucketTools.hash(data), 0, 10);\n                    String ext = DefaultMIMETypes.getExtension(cm.getMIMEType());\n                    if((ext != null) && !ext.equals(\"\"))\n                    \tfnam += '.' + ext;\n                }\n                File f = new File(downloadsDir, fnam);\n                if(f.exists()) {\n                    outsb.append(\"File exists already: \").append(fnam);\n                    fnam = \"freenet-\"+System.currentTimeMillis()+ '-' +fnam;\n                }\n                FileOutputStream fos = null;\n                try {\n                    fos = new FileOutputStream(f);\n                    BucketTools.copyTo(data, fos, Long.MAX_VALUE);\n                    fos.close();\n                    outsb.append(\"Written to \").append(fnam);\n                } catch (IOException e) {\n                    outsb.append(\"Could not write file: caught \").append(e);\n                    e.printStackTrace();\n                } finally {\n                    if(fos != null) try {\n                        fos.close();\n                    } catch (IOException e1) {\n                        // Ignore\n                    }\n                }\n                long endTime = System.currentTimeMillis();\n                long sz = data.size();\n                double rate = 1000.0 * sz / (endTime-startTime);\n                outsb.append(\"Download rate: \").append(rate).append(\" bytes / second\");\n\t\t\t} catch (FetchException e) {\n                outsb.append(\"Error: \").append(e.getMessage());\n            \tif((e.getMode() == FetchException.SPLITFILE_ERROR) && (e.errorCodes != null)) {\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tif(e.newURI != null)\n                    outsb.append(\"Permanent redirect: \").append(e.newURI).append(\"\\r\\n\");\n\t\t\t}\n    } else if(uline.startsWith(\"UPDATE\")) {\n    \toutsb.append(\"starting the update process\");\n    \t// FIXME run on separate thread\n    \tn.ps.queueTimedJob(new Runnable() {\n    \t\tpublic void run() {\n    \t\t    freenet.support.Logger.OSThread.logPID(this);\n    \t\t\tn.getNodeUpdater().arm();\n    \t\t}\n    \t}, 0);\n    \toutsb.append(\"\\r\\n\");\n    \tout.write(outsb.toString().getBytes());\n    \tout.flush();\n    \treturn false;\n    }else if(uline.startsWith(\"FILTER:\")) {\n    \tline = line.substring(\"FILTER:\".length()).trim();\n    \toutsb.append(\"Here is the result:\\r\\n\");\n    \t\n    \tfinal String content = readLines(reader, false);\n    \tfinal Bucket data = new ArrayBucket(content.getBytes(\"UTF-8\"));\n    \ttry {\n    \t\tFilterOutput output = ContentFilter.filter(data, new ArrayBucketFactory(), \"text/html\", new URI(\"http://127.0.0.1:8888/\"), null);\n    \t\t\n    \t\tBufferedInputStream bis = new BufferedInputStream(output.data.getInputStream());\n    \t\twhile(bis.available() > 0){\n    \t\t\toutsb.append((char)bis.read());\n    \t\t}\n    \t\tbis.close();\n    \t\toutput.data.free();\n    \t} catch (IOException e) {\n    \t\toutsb.append(\"Bucket error?: \" + e.getMessage());\n    \t\tLogger.error(this, \"Bucket error?: \" + e, e);\n    \t} catch (URISyntaxException e) {\n    \t\toutsb.append(\"Internal error: \" + e.getMessage());\n    \t\tLogger.error(this, \"Internal error: \" + e, e);\n    \t} finally {\n    \t\tdata.free();\n    \t}\n    \toutsb.append(\"\\r\\n\");\n    }else if(uline.startsWith(\"BLOW\")) {\n    \tn.getNodeUpdater().blow(\"caught an  IOException : (Incompetent Operator) :p\");\n    \toutsb.append(\"\\r\\n\");\n    \tout.write(outsb.toString().getBytes());\n    \tout.flush();\n    \treturn false;\n\t} else if(uline.startsWith(\"SHUTDOWN\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Shutting node down.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\tn.exit(\"Shutdown from console\");\n\t} else if(uline.startsWith(\"RESTART\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Restarting the node.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\tn.getNodeStarter().restart();\n\t} else if(uline.startsWith(\"QUIT\") && (core.directTMCI == this)) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"QUIT command not available in console mode.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn false;\n        } else if(uline.startsWith(\"QUIT\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Closing connection.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn true;\n        } else if(uline.startsWith(\"MEMSTAT\")) {\n\t\tRuntime rt = Runtime.getRuntime();\n\t\tfloat freeMemory = (float) rt.freeMemory();\n\t\tfloat totalMemory = (float) rt.totalMemory();\n\t\tfloat maxMemory = (float) rt.maxMemory();\n\n\t\tlong usedJavaMem = (long)(totalMemory - freeMemory);\n\t\tlong allocatedJavaMem = (long)totalMemory;\n\t\tlong maxJavaMem = (long)maxMemory;\n\t\tint availableCpus = rt.availableProcessors();\n\t\tNumberFormat thousendPoint = NumberFormat.getInstance();\n\n\t\tThreadGroup tg = Thread.currentThread().getThreadGroup();\n\t\twhile(tg.getParent() != null) tg = tg.getParent();\n\t\tint threadCount = tg.activeCount();\n\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Used Java memory:\\u00a0\" + SizeUtil.formatSize(usedJavaMem, true)+\"\\r\\n\");\n\t\tsb.append(\"Allocated Java memory:\\u00a0\" + SizeUtil.formatSize(allocatedJavaMem, true)+\"\\r\\n\");\n\t\tsb.append(\"Maximum Java memory:\\u00a0\" + SizeUtil.formatSize(maxJavaMem, true)+\"\\r\\n\");\n\t\tsb.append(\"Running threads:\\u00a0\" + thousendPoint.format(threadCount)+\"\\r\\n\");\n\t\tsb.append(\"Available CPUs:\\u00a0\" + availableCpus+\"\\r\\n\");\n\t\tsb.append(\"Java Version:\\u00a0\" + System.getProperty(\"java.version\")+\"\\r\\n\");\n\t\tsb.append(\"JVM Vendor:\\u00a0\" + System.getProperty(\"java.vendor\")+\"\\r\\n\");\n\t\tsb.append(\"JVM Version:\\u00a0\" + System.getProperty(\"java.version\")+\"\\r\\n\");\n\t\tsb.append(\"OS Name:\\u00a0\" + System.getProperty(\"os.name\")+\"\\r\\n\");\n\t\tsb.append(\"OS Version:\\u00a0\" + System.getProperty(\"os.version\")+\"\\r\\n\");\n\t\tsb.append(\"OS Architecture:\\u00a0\" + System.getProperty(\"os.arch\")+\"\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn false;\n\t} else if(uline.startsWith(\"HELP\")) {\n\t\tprintHeader(out);\n\t\toutsb.append(\"\\r\\n\");\n\t\tout.write(outsb.toString().getBytes());\n\t\tout.flush();\n\t\treturn false;\n        } else if(uline.startsWith(\"PUT:\") || (getCHKOnly = uline.startsWith(\"GETCHK:\"))) {\n        \tif(getCHKOnly)\n        \t\tline = line.substring((\"GETCHK:\").length()).trim();\n        \telse\n        \t\tline = line.substring(\"PUT:\".length()).trim();\n            String content;\n            if(line.length() > 0) {\n                // Single line insert\n                content = line;\n            } else {\n                // Multiple line insert\n                content = readLines(reader, false);\n            }\n            // Insert\n            byte[] data = content.getBytes();\n            \n            InsertBlock block = new InsertBlock(new ArrayBucket(data), null, FreenetURI.EMPTY_CHK_URI);\n\n            FreenetURI uri;\n            try {\n            \turi = client.insert(block, getCHKOnly, null);\n            } catch (InsertException e) {\n                outsb.append(\"Error: \").append(e.getMessage());\n            \tif(e.uri != null)\n                    outsb.append(\"URI would have been: \").append(e.uri);\n            \tint mode = e.getMode();\n            \tif((mode == InsertException.FATAL_ERRORS_IN_BLOCKS) || (mode == InsertException.TOO_MANY_RETRIES_IN_BLOCKS)) {\n                    outsb.append(\"Splitfile-specific error:\\n\").append(e.errorCodes.toVerboseString());\n            \t}\n\t\toutsb.append(\"\\r\\n\");\n\t\tout.write(outsb.toString().getBytes());\n\t\tout.flush();\n            \treturn false;\n            }\n\n            outsb.append(\"URI: \").append(uri);\n            ////////////////////////////////////////////////////////////////////////////////\n        } else if(uline.startsWith(\"PUTDIR:\") || (uline.startsWith(\"PUTSSKDIR\")) || (getCHKOnly = uline.startsWith(\"GETCHKDIR:\"))) {\n        \t// TODO: Check for errors?\n        \tboolean ssk = false;\n        \tif(uline.startsWith(\"PUTDIR:\"))\n        \t\tline = line.substring(\"PUTDIR:\".length());\n        \telse if(uline.startsWith(\"PUTSSKDIR:\")) {\n        \t\tline = line.substring(\"PUTSSKDIR:\".length());\n        \t\tssk = true;\n        \t} else if(uline.startsWith(\"GETCHKDIR:\"))\n        \t\tline = line.substring((\"GETCHKDIR:\").length());\n        \telse {\n        \t\tSystem.err.println(\"Impossible\");\n        \t\toutsb.append(\"Impossible\");\n        \t}\n        \t\n        \tline = line.trim();\n        \t\n        \tif(line.length() < 1) {\n        \t\tprintHeader(out);\n\t\t\toutsb.append(\"\\r\\n\");\n\t\t\tout.write(outsb.toString().getBytes());\n\t\t\tout.flush();\n        \t\treturn false;\n        \t}\n        \t\n        \tString defaultFile = null;\n        \t\n        \tFreenetURI insertURI = FreenetURI.EMPTY_CHK_URI;\n        \t\n        \t// set default file?\n        \tif (line.matches(\"^.*#.*$\")) {\n        \t\tString[] split = line.split(\"#\");\n        \t\tif(ssk) {\n        \t\t\tinsertURI = new FreenetURI(split[0]);\n        \t\t\tline = split[1];\n        \t\t\tif(split.length > 2)\n        \t\t\t\tdefaultFile = split[2];\n        \t\t} else {\n        \t\t\tdefaultFile = split[1];\n        \t\t\tline = split[0];\n        \t\t}\n        \t}\n        \t\n        \tHashMap bucketsByName =\n        \t\tmakeBucketsByName(line);\n        \t\n        \tif(defaultFile == null) {\n        \t\tString[] defaultFiles = \n        \t\t\tnew String[] { \"index.html\", \"index.htm\", \"default.html\", \"default.htm\" };\n        \t\tfor(int i=0;i<defaultFiles.length;i++) {\n        \t\t\tif(bucketsByName.containsKey(defaultFiles[i])) {\n        \t\t\t\tdefaultFile = defaultFiles[i];\n        \t\t\t\tbreak;\n        \t\t\t}        \t\t\t\t\n        \t\t}\n        \t}\n        \t\n        \tFreenetURI uri;\n\t\t\ttry {\n\t\t\t\turi = client.insertManifest(insertURI, bucketsByName, defaultFile);\n\t\t\t\turi = uri.addMetaStrings(new String[] { \"\" });\n\t        \toutsb.append(\"=======================================================\");\n                outsb.append(\"URI: \").append(uri);\n\t        \toutsb.append(\"=======================================================\");\n\t\t\t} catch (InsertException e) {\n                outsb.append(\"Finished insert but: \").append(e.getMessage());\n            \tif(e.uri != null) {\n            \t\turi = e.uri;\n    \t\t\t\turi = uri.addMetaStrings(new String[] { \"\" });\n                    outsb.append(\"URI would have been: \").append(uri);\n            \t}\n            \tif(e.errorCodes != null) {\n            \t\toutsb.append(\"Splitfile errors breakdown:\");\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tLogger.error(this, \"Caught \"+e, e);\n\t\t\t}\n            \n        } else if(uline.startsWith(\"PUTFILE:\") || (getCHKOnly = uline.startsWith(\"GETCHKFILE:\"))) {\n            // Just insert to local store\n        \tif(getCHKOnly) {\n        \t\tline = line.substring((\"GETCHKFILE:\").length()).trim();\n        \t} else {\n        \t\tline = line.substring(\"PUTFILE:\".length()).trim();\n        \t}\n            String mimeType = DefaultMIMETypes.guessMIMEType(line, false);\n            if (line.indexOf('#') > -1) {\n            \tString[] splittedLine = line.split(\"#\");\n            \tline = splittedLine[0];\n            \tmimeType = splittedLine[1];\n            }\n            File f = new File(line);\n            outsb.append(\"Attempting to read file \").append(line);\n            long startTime = System.currentTimeMillis();\n            try {\n            \tif(!(f.exists() && f.canRead())) {\n            \t\tthrow new FileNotFoundException();\n            \t}\n            \t\n            \t// Guess MIME type\n                outsb.append(\" using MIME type: \").append(mimeType).append(\"\\r\\n\");\n            \tif(mimeType.equals(DefaultMIMETypes.DEFAULT_MIME_TYPE))\n            \t\tmimeType = \"\"; // don't need to override it\n            \t\n            \tFileBucket fb = new FileBucket(f, true, false, false, false, false);\n            \tInsertBlock block = new InsertBlock(fb, new ClientMetadata(mimeType), FreenetURI.EMPTY_CHK_URI);\n\n            \tstartTime = System.currentTimeMillis();\n            \tFreenetURI uri = client.insert(block, getCHKOnly, f.getName());\n            \t\n            \t// FIXME depends on CHK's still being renamable\n                //uri = uri.setDocName(f.getName());\n\n                outsb.append(\"URI: \").append(uri).append(\"\\r\\n\");\n            \tlong endTime = System.currentTimeMillis();\n                long sz = f.length();\n                double rate = 1000.0 * sz / (endTime-startTime);\n                outsb.append(\"Upload rate: \").append(rate).append(\" bytes / second\\r\\n\");\n            } catch (FileNotFoundException e1) {\n                outsb.append(\"File not found\");\n            } catch (InsertException e) {\n                outsb.append(\"Finished insert but: \").append(e.getMessage());\n            \tif(e.uri != null) {\n                    outsb.append(\"URI would have been: \").append(e.uri);\n                \tlong endTime = System.currentTimeMillis();\n                    long sz = f.length();\n                    double rate = 1000.0 * sz / (endTime-startTime);\n                    outsb.append(\"Upload rate: \").append(rate).append(\" bytes / second\");\n            \t}\n            \tif(e.errorCodes != null) {\n            \t\toutsb.append(\"Splitfile errors breakdown:\");\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            } catch (Throwable t) {\n                outsb.append(\"Insert threw: \").append(t);\n                t.printStackTrace();\n            }\n        } else if(uline.startsWith(\"MAKESSK\")) {\n        \tInsertableClientSSK key = InsertableClientSSK.createRandom(r, \"\");\n            outsb.append(\"Insert URI: \").append(key.getInsertURI().toString(false, false)).append(\"\\r\\n\");\n            outsb.append(\"Request URI: \").append(key.getURI().toString(false, false)).append(\"\\r\\n\");\n        \tFreenetURI insertURI = key.getInsertURI().setDocName(\"testsite\");\n        \tString fixedInsertURI = insertURI.toString(false, false);\n            outsb.append(\"Note that you MUST add a filename to the end of the above URLs e.g.:\\r\\n\").append(fixedInsertURI).append(\"\\r\\n\");\n            outsb.append(\"Normally you will then do PUTSSKDIR:<insert URI>#<directory to upload>, for example:\\r\\nPUTSSKDIR:\").append(fixedInsertURI).append(\"#directoryToUpload/\\r\\n\");\n            outsb.append(\"This will then produce a manifest site containing all the files, the default document can be accessed at\\r\\n\").append(key.getURI().toString(false, false)).append(\"testsite/\");\n        } else if(uline.startsWith(\"PUTSSK:\")) {\n        \tString cmd = line.substring(\"PUTSSK:\".length());\n        \tcmd = cmd.trim();\n        \tif(cmd.indexOf(';') <= 0) {\n        \t\toutsb.append(\"No target URI provided.\");\n        \t\toutsb.append(\"PUTSSK:<insert uri>;<url to redirect to>\");\n\t\t\toutsb.append(\"\\r\\n\");\n\t\t\tout.write(outsb.toString().getBytes());\n\t\t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tString[] split = cmd.split(\";\");\n        \tString insertURI = split[0];\n        \tString targetURI = split[1];\n            outsb.append(\"Insert URI: \").append(insertURI);\n            outsb.append(\"Target URI: \").append(targetURI);\n        \tFreenetURI insert = new FreenetURI(insertURI);\n        \tFreenetURI target = new FreenetURI(targetURI);\n        \ttry {\n\t\t\t\tFreenetURI result = client.insertRedirect(insert, target);\n                outsb.append(\"Successfully inserted to fetch URI: \").append(result);\n\t\t\t} catch (InsertException e) {\n                outsb.append(\"Finished insert but: \").append(e.getMessage());\n            \tLogger.normal(this, \"Error: \"+e, e);\n            \tif(e.uri != null) {\n                    outsb.append(\"URI would have been: \").append(e.uri);\n            \t}\n\t\t\t}\n        \t\n        } else if(uline.startsWith(\"STATUS\")) {\n        \toutsb.append(\"DARKNET:\\n\");\n            SimpleFieldSet fs = n.exportDarknetPublicFieldSet();\n            outsb.append(fs.toString());\n            if(n.isOpennetEnabled()) {\n            \toutsb.append(\"OPENNET:\\n\");\n            \tfs = n.exportOpennetPublicFieldSet();\n                outsb.append(fs.toString());\n            }\n            outsb.append(n.getStatus());\n            if(Version.buildNumber()<Version.highestSeenBuild){\n                outsb.append(\"The latest version is : \").append(Version.highestSeenBuild);\n            }\n        } else if(uline.startsWith(\"ADDPEER:\") || uline.startsWith(\"CONNECT:\")) {\n            String key = null;\n            if(uline.startsWith(\"CONNECT:\")) {\n                key = line.substring(\"CONNECT:\".length()).trim();\n            } else {\n                key = line.substring(\"ADDPEER:\".length()).trim();\n            }\n            \n            String content = null;\n            if(key.length() > 0) {\n                // Filename\n            \tBufferedReader in;\n                outsb.append(\"Trying to add peer to node by noderef in \").append(key).append(\"\\r\\n\");\n                File f = new File(key);\n                if (f.isFile()) {\n                \toutsb.append(\"Given string seems to be a file, loading...\\r\\n\");\n                \tin = new BufferedReader(new FileReader(f));\n                } else {\n                \toutsb.append(\"Given string seems to be an URL, loading...\\r\\n\");\n                    URL url = new URL(key);\n                    URLConnection uc = url.openConnection();\n                \tin = new BufferedReader(\n                \t\t\t// FIXME get charset from uc.getContentType()\n                \t\t\tnew InputStreamReader(uc.getInputStream()));\n                }\n                content = readLines(in, true);\n                in.close();\n            } else {\n                content = readLines(reader, true);\n            }\n            if(content == null) return false;\n            if(content.equals(\"\")) return false;\n            addPeer(content);\n        \n        } else if(uline.startsWith(\"NAME:\")) {\n            outsb.append(\"Node name currently: \").append(n.getMyName());\n            String key = line.substring(\"NAME:\".length()).trim();\n            outsb.append(\"New name: \").append(key);\n            \n            try{\n            \tn.setName(key);\n                if(Logger.shouldLog(Logger.MINOR, this))\n                \tLogger.minor(this, \"Setting node.name to \"+key);\n            }catch(Exception e){\n            \tLogger.error(this, \"Error setting node's name\", e);\n    \t\t}\n            core.storeConfig();\n        } else if(uline.startsWith(\"DISABLEPEER:\")) {\n        \tString nodeIdentifier = (line.substring(\"DISABLEPEER:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tif(disablePeer(nodeIdentifier)) {\n                outsb.append(\"disable succeeded for \").append(nodeIdentifier);\n        \t} else {\n                outsb.append(\"disable failed for \").append(nodeIdentifier);\n        \t}\n        \toutsb.append(\"\\r\\n\");\n        } else if(uline.startsWith(\"ENABLEPEER:\")) {\n        \tString nodeIdentifier = (line.substring(\"ENABLEPEER:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tif(enablePeer(nodeIdentifier)) {\n                outsb.append(\"enable succeeded for \").append(nodeIdentifier);\n        \t} else {\n                outsb.append(\"enable failed for \").append(nodeIdentifier);\n        \t}\n        \toutsb.append(\"\\r\\n\");\n\t\t} else if(uline.startsWith(\"SETPEERLISTENONLY:\")) {\n\t\t\tString nodeIdentifier = (line.substring(\"SETPEERLISTENONLY:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n\t\t\tPeerNode pn = n.getPeerNode(nodeIdentifier);\n        \tif(pn == null) {\n        \t\tout.write((\"n.getPeerNode() failed to get peer details for \"+nodeIdentifier+\"\\r\\n\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n\t\t\tif(!(pn instanceof DarknetPeerNode)) {\n\t\t\t\tout.write((\"Error: \"+nodeIdentifier+\" identifies a non-darknet peer and this command is only available for darknet peers\\r\\n\\r\\n\").getBytes());\n\t\t\t\tout.flush();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tDarknetPeerNode dpn = (DarknetPeerNode) pn;\n\t\t\tdpn.setListenOnly(true);\n            outsb.append(\"set ListenOnly suceeded for \").append(nodeIdentifier).append(\"\\r\\n\");\n\t\t} else if(uline.startsWith(\"UNSETPEERLISTENONLY:\")) {\n\t\t\tString nodeIdentifier = (line.substring(\"UNSETPEERLISTENONLY:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n\t\t\tPeerNode pn = n.getPeerNode(nodeIdentifier);\n        \tif(pn == null) {\n        \t\tout.write((\"n.getPeerNode() failed to get peer details for \"+nodeIdentifier+\"\\r\\n\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n\t\t\tif(!(pn instanceof DarknetPeerNode)) {\n\t\t\t\tout.write((\"Error: \"+nodeIdentifier+\" identifies a non-darknet peer and this command is only available for darknet peers\\r\\n\\r\\n\").getBytes());\n\t\t\t\tout.flush();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tDarknetPeerNode dpn = (DarknetPeerNode) pn;\n\t\t\tdpn.setListenOnly(false);\n            outsb.append(\"unset ListenOnly suceeded for \").append(nodeIdentifier).append(\"\\r\\n\");\n        } else if(uline.startsWith(\"HAVEPEER:\")) {\n        \tString nodeIdentifier = (line.substring(\"HAVEPEER:\".length())).trim();\n        \tif(havePeer(nodeIdentifier)) {\n                outsb.append(\"true for \").append(nodeIdentifier);\n        \t} else {\n                outsb.append(\"false for \").append(nodeIdentifier);\n        \t}\n        \toutsb.append(\"\\r\\n\");\n        } else if(uline.startsWith(\"REMOVEPEER:\") || uline.startsWith(\"DISCONNECT:\")) {\n        \tString nodeIdentifier = null;\n        \tif(uline.startsWith(\"DISCONNECT:\")) {\n        \t\tnodeIdentifier = line.substring(\"DISCONNECT:\".length());\n        \t} else {\n        \t\tnodeIdentifier = line.substring(\"REMOVEPEER:\".length());\n        \t}\n        \tif(removePeer(nodeIdentifier)) {\n                outsb.append(\"peer removed for \").append(nodeIdentifier);\n        \t} else {\n                outsb.append(\"peer removal failed for \").append(nodeIdentifier);\n        \t}\n        \toutsb.append(\"\\r\\n\");\n        } else if(uline.startsWith(\"PEER:\")) {\n        \tString nodeIdentifier = (line.substring(\"PEER:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tPeerNode pn = n.getPeerNode(nodeIdentifier);\n        \tif(pn == null) {\n        \t\tout.write((\"n.getPeerNode() failed to get peer details for \"+nodeIdentifier+\"\\r\\n\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tSimpleFieldSet fs = pn.exportFieldSet();\n        \toutsb.append(fs.toString());\n        } else if(uline.startsWith(\"PEERWMD:\")) {\n        \tString nodeIdentifier = (line.substring(\"PEERWMD:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tPeerNode pn = n.getPeerNode(nodeIdentifier);\n        \tif(pn == null) {\n        \t\tout.write((\"n.getPeerNode() failed to get peer details for \"+nodeIdentifier+\"\\r\\n\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tSimpleFieldSet fs = pn.exportFieldSet();\n        \tSimpleFieldSet meta = pn.exportMetadataFieldSet();\n        \tif(!meta.isEmpty())\n        \t \tfs.put(\"metadata\", meta);\n        \toutsb.append(fs.toString());\n        } else if(uline.startsWith(\"PEERS\")) {\n        \toutsb.append(n.getTMCIPeerList());\n        \toutsb.append(\"PEERS done.\\r\\n\");\n        } else if(uline.startsWith(\"PROBE:\")) {\n        \tString s = uline.substring(\"PROBE:\".length()).trim();\n        \tdouble d = Double.parseDouble(s);\n        \tif(d > 1.0 || d < 0.0) {\n        \t\tSystem.err.println(\"Unacceptable target location: \"+d);\n        \t\treturn false;\n        \t}\n        \tProbeCallback cb = new ProbeCallback() {\n\t\t\t\tpublic void onCompleted(String reason, double target, double best, double nearest, long id, short counter, short uniqueCounter, short linearCounter) {\n\t\t\t\t\tString msg = \"Completed probe request: \"+target+\" -> \"+best+\"\\r\\nNearest actually hit \"+nearest+\", \"+counter+\" nodes (\"+uniqueCounter+\" unique, \"+linearCounter+\" hops), id \"+id+\"\\r\\n\";\n\t\t\t\t\ttry {\n\t\t\t\t\t\tout.write(msg.getBytes());\n\t\t\t\t\t\tout.flush();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Already closed. :(\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized(TextModeClientInterface.this) {\n\t\t\t\t\t\tdoneSomething = true;\n\t\t\t\t\t\tTextModeClientInterface.this.notifyAll();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void onTrace(long uid, double target, double nearest, double best, short htl, short counter, double location, long nodeUID, double[] peerLocs, long[] peerUIDs, double[] locsNotVisited, short forkCount, short linearCounter, String reason, long prevUID) {\n\t\t\t\t\tString msg = \"Probe trace: UID=\"+uid+\" target=\"+target+\" nearest=\"+nearest+\" best=\"+best+\" htl=\"+htl+\" counter=\"+counter+\" linear=\"+linearCounter+\" location=\"+location+\"node UID=\"+nodeUID+\" prev UID=\"+prevUID+\" peer locs=\"+StringArray.toString(peerLocs)+\" peer UIDs=\"+StringArray.toString(peerUIDs)+\" locs not visited = \"+StringArray.toString(locsNotVisited)+\" forks: \"+forkCount+\" reason=\"+reason+'\\n';\n\t\t\t\t\ttry {\n\t\t\t\t\t\tout.write(msg.getBytes());\n\t\t\t\t\t\tout.flush();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void onRejectOverload() {\n\t\t\t\t\tString msg = \"Probe trace received RejectOverload\\n\";\n\t\t\t\t\ttry {\n\t\t\t\t\t\tout.write(msg.getBytes());\n\t\t\t\t\t\tout.flush();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Ignore\n\t\t\t\t\t}\n\t\t\t\t}\n        \t};\n        \toutsb.append(\"Probing keyspace around \"+d+\" ...\");\n        \tn.dispatcher.startProbe(d, cb, NodeDispatcher.PROBE_TYPE_RESETTING_HTL);\n        \tsynchronized(this) {\n        \t\twhile(!doneSomething) {\n        \t\t\ttry {\n        \t\t\t\twait(5000);\n        \t\t\t} catch (InterruptedException e) {\n        \t\t\t\t// Ignore\n        \t\t\t}\n        \t\t}\n        \t\tdoneSomething = false;\n        \t}\n        } else if(uline.startsWith(\"PROBEALL\")) {\n        \tuline = uline.substring(\"PROBEALL\".length());\n        \tif(uline.startsWith(\":\")) uline = uline.substring(1);\n        \tif(uline.length() == 0) {\n        \t\tprobeAll(NodeDispatcher.PROBE_TYPE_RESETTING_HTL);\n        \t} else {\n        \t\tprobeAll(Fields.parseInt(uline, NodeDispatcher.PROBE_TYPE_RESETTING_HTL));\n        \t}\n        } else if(uline.startsWith(\"PLUGLOAD:\")) {\n        \tif (line.substring(\"PLUGLOAD:\".length()).trim().equals(\"?\")) {\n        \t\toutsb.append(\"  PLUGLOAD: pluginName         - Load official plugin from freenetproject.org\\r\\n\");\n        \t\toutsb.append(\"  PLUGLOAD: file://<filename>  - Load plugin from file\\r\\n\");\n        \t\toutsb.append(\"  PLUGLOAD: http://...         - Load plugin from online file\\r\\n\");\n        \t} else {\n        \t\tString name = line.substring(\"PLUGLOAD:\".length()).trim();\n        \t\tn.pluginManager.startPlugin(name, true);\n        \t}\n        } else if(uline.startsWith(\"PLUGLIST\")) {\n        \toutsb.append(n.pluginManager.dumpPlugins());\n        } else if(uline.startsWith(\"PLUGKILL:\")) {\n        \tn.pluginManager.killPlugin(line.substring(\"PLUGKILL:\".length()).trim(), 60*1000);\n        } else if(uline.startsWith(\"ANNOUNCE\")) {\n        \tOpennetManager om = n.getOpennet();\n        \tif(om == null) {\n        \t\toutsb.append(\"OPENNET DISABLED, cannot announce.\");\n        \t\treturn false;\n        \t}\n        \tuline = uline.substring(\"ANNOUNCE\".length());\n        \tfinal double target;\n        \tif(uline.charAt(0) == ':') {\n        \t\ttarget = Double.parseDouble(uline.substring(1));\n        \t} else {\n        \t\ttarget = n.random.nextDouble();\n        \t}\n        \tom.announce(target, new AnnouncementCallback() {\n        \t\tprivate void write(String msg) {\n        \t\t\ttry {\n        \t\t\t\tout.write((\"ANNOUNCE:\"+target+\":\"+msg+\"\\r\\n\").getBytes());\n        \t\t\t\tout.flush();\n        \t\t\t} catch (IOException e) {\n        \t\t\t\t// Ignore\n        \t\t\t}\n        \t\t}\n\t\t\t\tpublic void addedNode(PeerNode pn) {\n\t\t\t\t\twrite(\"Added node \"+pn.shortToString());\n\t\t\t\t}\n\n\t\t\t\tpublic void bogusNoderef(String reason) {\n\t\t\t\t\twrite(\"Bogus noderef: \"+reason);\n\t\t\t\t}\n\n\t\t\t\tpublic void completed() {\n\t\t\t\t\twrite(\"Completed announcement.\");\n\t\t\t\t}\n\n\t\t\t\tpublic void nodeFailed(PeerNode pn, String reason) {\n\t\t\t\t\twrite(\"Node failed: \"+pn+\" \"+reason);\n\t\t\t\t}\n\n\t\t\t\tpublic void noMoreNodes() {\n\t\t\t\t\twrite(\"Route Not Found\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic void nodeNotWanted() {\n\t\t\t\t\twrite(\"Hop doesn't want me.\");\n\t\t\t\t}\n\t\t\t\tpublic void nodeNotAdded() {\n\t\t\t\t\twrite(\"Node not added as we don't want it for some reason.\");\n\t\t\t\t}\n        \t\t\n        \t});\n        } else {\n        \tif(uline.length() > 0)\n        \t\tprintHeader(out);\n        }\n        outsb.append(\"\\r\\n\");\n        out.write(outsb.toString().getBytes());\n        out.flush();\n        return false;\n    }","id":76393,"modified_method":"/**\n     * Process a single command.\n     * @throws IOException If we could not write the data to stdout.\n     */\n    private boolean processLine(BufferedReader reader, final OutputStream out) throws IOException {\n        String line;\n        StringBuffer outsb = new StringBuffer();\n        try {\n            line = reader.readLine();\n        } catch (IOException e) {\n            outsb.append(\"Bye... (\").append(e).append(')');\n            System.err.println(\"Bye... (\"+e+ ')');\n            return true;\n        }\n        boolean getCHKOnly = false;\n        if(line == null) return true;\n        String uline = line.toUpperCase();\n        if(Logger.shouldLog(Logger.MINOR, this))\n        \tLogger.minor(this, \"Command: \"+line);\n        if(uline.startsWith(\"GET:\")) {\n            // Should have a key next\n            String key = line.substring(\"GET:\".length()).trim();\n            Logger.normal(this, \"Key: \"+key);\n            FreenetURI uri;\n            try {\n                uri = new FreenetURI(key);\n                Logger.normal(this, \"Key: \"+uri);\n            } catch (MalformedURLException e2) {\n                outsb.append(\"Malformed URI: \").append(key).append(\" : \").append(e2);\n\t\toutsb.append(\"\\r\\n\");\n\t\tout.write(outsb.toString().getBytes());\n\t\tout.flush();\n                return false;\n            }\n            try {\n\t\t\t\tFetchResult result = client.fetch(uri);\n\t\t\t\tClientMetadata cm = result.getMetadata();\n                outsb.append(\"Content MIME type: \").append(cm.getMIMEType());\n\t\t\t\tBucket data = result.asBucket();\n\t\t\t\t// FIXME limit it above\n\t\t\t\tif(data.size() > 32*1024) {\n\t\t\t\t\tSystem.err.println(\"Data is more than 32K: \"+data.size());\n\t\t\t\t\toutsb.append(\"Data is more than 32K: \").append(data.size());\n\t\t\t\t\toutsb.append(\"\\r\\n\");\n\t\t\t\t\tout.write(outsb.toString().getBytes());\n\t\t\t\t\tout.flush();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbyte[] dataBytes = BucketTools.toByteArray(data);\n\t\t\t\tboolean evil = false;\n\t\t\t\tfor(int i=0;i<dataBytes.length;i++) {\n\t\t\t\t\t// Look for escape codes\n\t\t\t\t\tif(dataBytes[i] == '\\n') continue;\n\t\t\t\t\tif(dataBytes[i] == '\\r') continue;\n\t\t\t\t\tif(dataBytes[i] < 32) evil = true;\n\t\t\t\t}\n\t\t\t\tif(evil) {\n\t\t\t\t\tSystem.err.println(\"Data may contain escape codes which could cause the terminal to run arbitrary commands! Save it to a file if you must with GETFILE:\");\n\t\t\t\t\toutsb.append(\"Data may contain escape codes which could cause the terminal to run arbitrary commands! Save it to a file if you must with GETFILE:\");\n\t\t\t\t\toutsb.append(\"\\r\\n\");\n\t\t\t\t\tout.write(outsb.toString().getBytes());\n\t\t\t\t\tout.flush();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\toutsb.append(\"Data:\\r\\n\");\n\t\t\t\toutsb.append(new String(dataBytes));\n\t\t\t} catch (FetchException e) {\n                outsb.append(\"Error: \").append(e.getMessage()).append(\"\\r\\n\");\n            \tif((e.getMode() == FetchException.SPLITFILE_ERROR) && (e.errorCodes != null)) {\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tif(e.newURI != null)\n                    outsb.append(\"Permanent redirect: \").append(e.newURI).append(\"\\r\\n\");\n\t\t\t}\n        } else if(uline.startsWith(\"GETFILE:\")) {\n            // Should have a key next\n            String key = line.substring(\"GETFILE:\".length()).trim();\n            Logger.normal(this, \"Key: \"+key);\n            FreenetURI uri;\n            try {\n                uri = new FreenetURI(key);\n            } catch (MalformedURLException e2) {\n                outsb.append(\"Malformed URI: \").append(key).append(\" : \").append(e2);\n\t\toutsb.append(\"\\r\\n\");\n\t\tout.write(outsb.toString().getBytes());\n\t\tout.flush();\n                return false;\n            }\n            try {\n            \tlong startTime = System.currentTimeMillis();\n\t\t\t\tFetchResult result = client.fetch(uri);\n\t\t\t\tClientMetadata cm = result.getMetadata();\n                outsb.append(\"Content MIME type: \").append(cm.getMIMEType());\n\t\t\t\tBucket data = result.asBucket();\n                // Now calculate filename\n                String fnam = uri.getDocName();\n                fnam = sanitize(fnam);\n                if(fnam.length() == 0) {\n                    fnam = \"freenet-download-\"+HexUtil.bytesToHex(BucketTools.hash(data), 0, 10);\n                    String ext = DefaultMIMETypes.getExtension(cm.getMIMEType());\n                    if((ext != null) && !ext.equals(\"\"))\n                    \tfnam += '.' + ext;\n                }\n                File f = new File(downloadsDir, fnam);\n                if(f.exists()) {\n                    outsb.append(\"File exists already: \").append(fnam);\n                    fnam = \"freenet-\"+System.currentTimeMillis()+ '-' +fnam;\n                }\n                FileOutputStream fos = null;\n                try {\n                    fos = new FileOutputStream(f);\n                    BucketTools.copyTo(data, fos, Long.MAX_VALUE);\n                    fos.close();\n                    outsb.append(\"Written to \").append(fnam);\n                } catch (IOException e) {\n                    outsb.append(\"Could not write file: caught \").append(e);\n                    e.printStackTrace();\n                } finally {\n                    if(fos != null) try {\n                        fos.close();\n                    } catch (IOException e1) {\n                        // Ignore\n                    }\n                }\n                long endTime = System.currentTimeMillis();\n                long sz = data.size();\n                double rate = 1000.0 * sz / (endTime-startTime);\n                outsb.append(\"Download rate: \").append(rate).append(\" bytes / second\");\n\t\t\t} catch (FetchException e) {\n                outsb.append(\"Error: \").append(e.getMessage());\n            \tif((e.getMode() == FetchException.SPLITFILE_ERROR) && (e.errorCodes != null)) {\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tif(e.newURI != null)\n                    outsb.append(\"Permanent redirect: \").append(e.newURI).append(\"\\r\\n\");\n\t\t\t}\n    } else if(uline.startsWith(\"UPDATE\")) {\n    \toutsb.append(\"starting the update process\");\n    \t// FIXME run on separate thread\n    \tn.ps.queueTimedJob(new Runnable() {\n    \t\tpublic void run() {\n    \t\t    freenet.support.Logger.OSThread.logPID(this);\n    \t\t\tn.getNodeUpdater().arm();\n    \t\t}\n    \t}, 0);\n    \toutsb.append(\"\\r\\n\");\n    \tout.write(outsb.toString().getBytes());\n    \tout.flush();\n    \treturn false;\n    }else if(uline.startsWith(\"FILTER:\")) {\n    \tline = line.substring(\"FILTER:\".length()).trim();\n    \toutsb.append(\"Here is the result:\\r\\n\");\n    \t\n    \tfinal String content = readLines(reader, false);\n    \tfinal Bucket data = new ArrayBucket(content.getBytes(\"UTF-8\"));\n    \ttry {\n    \t\tFilterOutput output = ContentFilter.filter(data, new ArrayBucketFactory(), \"text/html\", new URI(\"http://127.0.0.1:8888/\"), null);\n    \t\t\n    \t\tBufferedInputStream bis = new BufferedInputStream(output.data.getInputStream());\n    \t\twhile(bis.available() > 0){\n    \t\t\toutsb.append((char)bis.read());\n    \t\t}\n    \t\tbis.close();\n    \t\toutput.data.free();\n    \t} catch (IOException e) {\n    \t\toutsb.append(\"Bucket error?: \" + e.getMessage());\n    \t\tLogger.error(this, \"Bucket error?: \" + e, e);\n    \t} catch (URISyntaxException e) {\n    \t\toutsb.append(\"Internal error: \" + e.getMessage());\n    \t\tLogger.error(this, \"Internal error: \" + e, e);\n    \t} finally {\n    \t\tdata.free();\n    \t}\n    \toutsb.append(\"\\r\\n\");\n    }else if(uline.startsWith(\"BLOW\")) {\n    \tn.getNodeUpdater().blow(\"caught an  IOException : (Incompetent Operator) :p\");\n    \toutsb.append(\"\\r\\n\");\n    \tout.write(outsb.toString().getBytes());\n    \tout.flush();\n    \treturn false;\n\t} else if(uline.startsWith(\"SHUTDOWN\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Shutting node down.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\tn.exit(\"Shutdown from console\");\n\t} else if(uline.startsWith(\"RESTART\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Restarting the node.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\tn.getNodeStarter().restart();\n\t} else if(uline.startsWith(\"QUIT\") && (core.directTMCI == this)) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"QUIT command not available in console mode.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn false;\n        } else if(uline.startsWith(\"QUIT\")) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Closing connection.\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn true;\n        } else if(uline.startsWith(\"MEMSTAT\")) {\n\t\tRuntime rt = Runtime.getRuntime();\n\t\tfloat freeMemory = (float) rt.freeMemory();\n\t\tfloat totalMemory = (float) rt.totalMemory();\n\t\tfloat maxMemory = (float) rt.maxMemory();\n\n\t\tlong usedJavaMem = (long)(totalMemory - freeMemory);\n\t\tlong allocatedJavaMem = (long)totalMemory;\n\t\tlong maxJavaMem = (long)maxMemory;\n\t\tint availableCpus = rt.availableProcessors();\n\t\tNumberFormat thousendPoint = NumberFormat.getInstance();\n\n\t\tThreadGroup tg = Thread.currentThread().getThreadGroup();\n\t\twhile(tg.getParent() != null) tg = tg.getParent();\n\t\tint threadCount = tg.activeCount();\n\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"Used Java memory:\\u00a0\" + SizeUtil.formatSize(usedJavaMem, true)+\"\\r\\n\");\n\t\tsb.append(\"Allocated Java memory:\\u00a0\" + SizeUtil.formatSize(allocatedJavaMem, true)+\"\\r\\n\");\n\t\tsb.append(\"Maximum Java memory:\\u00a0\" + SizeUtil.formatSize(maxJavaMem, true)+\"\\r\\n\");\n\t\tsb.append(\"Running threads:\\u00a0\" + thousendPoint.format(threadCount)+\"\\r\\n\");\n\t\tsb.append(\"Available CPUs:\\u00a0\" + availableCpus+\"\\r\\n\");\n\t\tsb.append(\"Java Version:\\u00a0\" + System.getProperty(\"java.version\")+\"\\r\\n\");\n\t\tsb.append(\"JVM Vendor:\\u00a0\" + System.getProperty(\"java.vendor\")+\"\\r\\n\");\n\t\tsb.append(\"JVM Version:\\u00a0\" + System.getProperty(\"java.version\")+\"\\r\\n\");\n\t\tsb.append(\"OS Name:\\u00a0\" + System.getProperty(\"os.name\")+\"\\r\\n\");\n\t\tsb.append(\"OS Version:\\u00a0\" + System.getProperty(\"os.version\")+\"\\r\\n\");\n\t\tsb.append(\"OS Architecture:\\u00a0\" + System.getProperty(\"os.arch\")+\"\\r\\n\");\n\t\tout.write(sb.toString().getBytes());\n\t\tout.flush();\n\t\treturn false;\n\t} else if(uline.startsWith(\"HELP\")) {\n\t\tprintHeader(out);\n\t\toutsb.append(\"\\r\\n\");\n\t\tout.write(outsb.toString().getBytes());\n\t\tout.flush();\n\t\treturn false;\n        } else if(uline.startsWith(\"PUT:\") || (getCHKOnly = uline.startsWith(\"GETCHK:\"))) {\n        \tif(getCHKOnly)\n        \t\tline = line.substring((\"GETCHK:\").length()).trim();\n        \telse\n        \t\tline = line.substring(\"PUT:\".length()).trim();\n            String content;\n            if(line.length() > 0) {\n                // Single line insert\n                content = line;\n            } else {\n                // Multiple line insert\n                content = readLines(reader, false);\n            }\n            // Insert\n            byte[] data = content.getBytes();\n            \n            InsertBlock block = new InsertBlock(new ArrayBucket(data), null, FreenetURI.EMPTY_CHK_URI);\n\n            FreenetURI uri;\n            try {\n            \turi = client.insert(block, getCHKOnly, null);\n            } catch (InsertException e) {\n                outsb.append(\"Error: \").append(e.getMessage());\n            \tif(e.uri != null)\n                    outsb.append(\"URI would have been: \").append(e.uri);\n            \tint mode = e.getMode();\n            \tif((mode == InsertException.FATAL_ERRORS_IN_BLOCKS) || (mode == InsertException.TOO_MANY_RETRIES_IN_BLOCKS)) {\n                    outsb.append(\"Splitfile-specific error:\\n\").append(e.errorCodes.toVerboseString());\n            \t}\n\t\toutsb.append(\"\\r\\n\");\n\t\tout.write(outsb.toString().getBytes());\n\t\tout.flush();\n            \treturn false;\n            }\n\n            outsb.append(\"URI: \").append(uri);\n            ////////////////////////////////////////////////////////////////////////////////\n        } else if(uline.startsWith(\"PUTDIR:\") || (uline.startsWith(\"PUTSSKDIR\")) || (getCHKOnly = uline.startsWith(\"GETCHKDIR:\"))) {\n        \t// TODO: Check for errors?\n        \tboolean ssk = false;\n        \tif(uline.startsWith(\"PUTDIR:\"))\n        \t\tline = line.substring(\"PUTDIR:\".length());\n        \telse if(uline.startsWith(\"PUTSSKDIR:\")) {\n        \t\tline = line.substring(\"PUTSSKDIR:\".length());\n        \t\tssk = true;\n        \t} else if(uline.startsWith(\"GETCHKDIR:\"))\n        \t\tline = line.substring((\"GETCHKDIR:\").length());\n        \telse {\n        \t\tSystem.err.println(\"Impossible\");\n        \t\toutsb.append(\"Impossible\");\n        \t}\n        \t\n        \tline = line.trim();\n        \t\n        \tif(line.length() < 1) {\n        \t\tprintHeader(out);\n\t\t\toutsb.append(\"\\r\\n\");\n\t\t\tout.write(outsb.toString().getBytes());\n\t\t\tout.flush();\n        \t\treturn false;\n        \t}\n        \t\n        \tString defaultFile = null;\n        \t\n        \tFreenetURI insertURI = FreenetURI.EMPTY_CHK_URI;\n        \t\n        \t// set default file?\n        \tif (line.matches(\"^.*#.*$\")) {\n        \t\tString[] split = line.split(\"#\");\n        \t\tif(ssk) {\n        \t\t\tinsertURI = new FreenetURI(split[0]);\n        \t\t\tline = split[1];\n        \t\t\tif(split.length > 2)\n        \t\t\t\tdefaultFile = split[2];\n        \t\t} else {\n        \t\t\tdefaultFile = split[1];\n        \t\t\tline = split[0];\n        \t\t}\n        \t}\n        \t\n        \tHashMap bucketsByName =\n        \t\tmakeBucketsByName(line);\n        \t\n        \tif(defaultFile == null) {\n        \t\tString[] defaultFiles = \n        \t\t\tnew String[] { \"index.html\", \"index.htm\", \"default.html\", \"default.htm\" };\n        \t\tfor(int i=0;i<defaultFiles.length;i++) {\n        \t\t\tif(bucketsByName.containsKey(defaultFiles[i])) {\n        \t\t\t\tdefaultFile = defaultFiles[i];\n        \t\t\t\tbreak;\n        \t\t\t}        \t\t\t\t\n        \t\t}\n        \t}\n        \t\n        \tFreenetURI uri;\n\t\t\ttry {\n\t\t\t\turi = client.insertManifest(insertURI, bucketsByName, defaultFile);\n\t\t\t\turi = uri.addMetaStrings(new String[] { \"\" });\n\t        \toutsb.append(\"=======================================================\");\n                outsb.append(\"URI: \").append(uri);\n\t        \toutsb.append(\"=======================================================\");\n\t\t\t} catch (InsertException e) {\n                outsb.append(\"Finished insert but: \").append(e.getMessage());\n            \tif(e.uri != null) {\n            \t\turi = e.uri;\n    \t\t\t\turi = uri.addMetaStrings(new String[] { \"\" });\n                    outsb.append(\"URI would have been: \").append(uri);\n            \t}\n            \tif(e.errorCodes != null) {\n            \t\toutsb.append(\"Splitfile errors breakdown:\");\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            \tLogger.error(this, \"Caught \"+e, e);\n\t\t\t}\n            \n        } else if(uline.startsWith(\"PUTFILE:\") || (getCHKOnly = uline.startsWith(\"GETCHKFILE:\"))) {\n            // Just insert to local store\n        \tif(getCHKOnly) {\n        \t\tline = line.substring((\"GETCHKFILE:\").length()).trim();\n        \t} else {\n        \t\tline = line.substring(\"PUTFILE:\".length()).trim();\n        \t}\n            String mimeType = DefaultMIMETypes.guessMIMEType(line, false);\n            if (line.indexOf('#') > -1) {\n            \tString[] splittedLine = line.split(\"#\");\n            \tline = splittedLine[0];\n            \tmimeType = splittedLine[1];\n            }\n            File f = new File(line);\n            outsb.append(\"Attempting to read file \").append(line);\n            long startTime = System.currentTimeMillis();\n            try {\n            \tif(!(f.exists() && f.canRead())) {\n            \t\tthrow new FileNotFoundException();\n            \t}\n            \t\n            \t// Guess MIME type\n                outsb.append(\" using MIME type: \").append(mimeType).append(\"\\r\\n\");\n            \tif(mimeType.equals(DefaultMIMETypes.DEFAULT_MIME_TYPE))\n            \t\tmimeType = \"\"; // don't need to override it\n            \t\n            \tFileBucket fb = new FileBucket(f, true, false, false, false, false);\n            \tInsertBlock block = new InsertBlock(fb, new ClientMetadata(mimeType), FreenetURI.EMPTY_CHK_URI);\n\n            \tstartTime = System.currentTimeMillis();\n            \tFreenetURI uri = client.insert(block, getCHKOnly, f.getName());\n            \t\n            \t// FIXME depends on CHK's still being renamable\n                //uri = uri.setDocName(f.getName());\n\n                outsb.append(\"URI: \").append(uri).append(\"\\r\\n\");\n            \tlong endTime = System.currentTimeMillis();\n                long sz = f.length();\n                double rate = 1000.0 * sz / (endTime-startTime);\n                outsb.append(\"Upload rate: \").append(rate).append(\" bytes / second\\r\\n\");\n            } catch (FileNotFoundException e1) {\n                outsb.append(\"File not found\");\n            } catch (InsertException e) {\n                outsb.append(\"Finished insert but: \").append(e.getMessage());\n            \tif(e.uri != null) {\n                    outsb.append(\"URI would have been: \").append(e.uri);\n                \tlong endTime = System.currentTimeMillis();\n                    long sz = f.length();\n                    double rate = 1000.0 * sz / (endTime-startTime);\n                    outsb.append(\"Upload rate: \").append(rate).append(\" bytes / second\");\n            \t}\n            \tif(e.errorCodes != null) {\n            \t\toutsb.append(\"Splitfile errors breakdown:\");\n            \t\toutsb.append(e.errorCodes.toVerboseString());\n            \t}\n            } catch (Throwable t) {\n                outsb.append(\"Insert threw: \").append(t);\n                t.printStackTrace();\n            }\n        } else if(uline.startsWith(\"MAKESSK\")) {\n        \tInsertableClientSSK key = InsertableClientSSK.createRandom(r, \"\");\n            outsb.append(\"Insert URI: \").append(key.getInsertURI().toString(false, false)).append(\"\\r\\n\");\n            outsb.append(\"Request URI: \").append(key.getURI().toString(false, false)).append(\"\\r\\n\");\n        \tFreenetURI insertURI = key.getInsertURI().setDocName(\"testsite\");\n        \tString fixedInsertURI = insertURI.toString(false, false);\n            outsb.append(\"Note that you MUST add a filename to the end of the above URLs e.g.:\\r\\n\").append(fixedInsertURI).append(\"\\r\\n\");\n            outsb.append(\"Normally you will then do PUTSSKDIR:<insert URI>#<directory to upload>, for example:\\r\\nPUTSSKDIR:\").append(fixedInsertURI).append(\"#directoryToUpload/\\r\\n\");\n            outsb.append(\"This will then produce a manifest site containing all the files, the default document can be accessed at\\r\\n\").append(key.getURI().toString(false, false)).append(\"testsite/\");\n        } else if(uline.startsWith(\"PUTSSK:\")) {\n        \tString cmd = line.substring(\"PUTSSK:\".length());\n        \tcmd = cmd.trim();\n        \tif(cmd.indexOf(';') <= 0) {\n        \t\toutsb.append(\"No target URI provided.\");\n        \t\toutsb.append(\"PUTSSK:<insert uri>;<url to redirect to>\");\n\t\t\toutsb.append(\"\\r\\n\");\n\t\t\tout.write(outsb.toString().getBytes());\n\t\t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tString[] split = cmd.split(\";\");\n        \tString insertURI = split[0];\n        \tString targetURI = split[1];\n            outsb.append(\"Insert URI: \").append(insertURI);\n            outsb.append(\"Target URI: \").append(targetURI);\n        \tFreenetURI insert = new FreenetURI(insertURI);\n        \tFreenetURI target = new FreenetURI(targetURI);\n        \ttry {\n\t\t\t\tFreenetURI result = client.insertRedirect(insert, target);\n                outsb.append(\"Successfully inserted to fetch URI: \").append(result);\n\t\t\t} catch (InsertException e) {\n                outsb.append(\"Finished insert but: \").append(e.getMessage());\n            \tLogger.normal(this, \"Error: \"+e, e);\n            \tif(e.uri != null) {\n                    outsb.append(\"URI would have been: \").append(e.uri);\n            \t}\n\t\t\t}\n        \t\n        } else if(uline.startsWith(\"STATUS\")) {\n        \toutsb.append(\"DARKNET:\\n\");\n            SimpleFieldSet fs = n.exportDarknetPublicFieldSet();\n            outsb.append(fs.toString());\n            if(n.isOpennetEnabled()) {\n            \toutsb.append(\"OPENNET:\\n\");\n            \tfs = n.exportOpennetPublicFieldSet();\n                outsb.append(fs.toString());\n            }\n            outsb.append(n.getStatus());\n            if(Version.buildNumber()<Version.highestSeenBuild){\n                outsb.append(\"The latest version is : \").append(Version.highestSeenBuild);\n            }\n        } else if(uline.startsWith(\"ADDPEER:\") || uline.startsWith(\"CONNECT:\")) {\n            String key = null;\n            if(uline.startsWith(\"CONNECT:\")) {\n                key = line.substring(\"CONNECT:\".length()).trim();\n            } else {\n                key = line.substring(\"ADDPEER:\".length()).trim();\n            }\n            \n            String content = null;\n            if(key.length() > 0) {\n                // Filename\n            \tBufferedReader in;\n                outsb.append(\"Trying to add peer to node by noderef in \").append(key).append(\"\\r\\n\");\n                File f = new File(key);\n                if (f.isFile()) {\n                \toutsb.append(\"Given string seems to be a file, loading...\\r\\n\");\n                \tin = new BufferedReader(new FileReader(f));\n                } else {\n                \toutsb.append(\"Given string seems to be an URL, loading...\\r\\n\");\n                    URL url = new URL(key);\n                    URLConnection uc = url.openConnection();\n                \tin = new BufferedReader(\n                \t\t\t// FIXME get charset from uc.getContentType()\n                \t\t\tnew InputStreamReader(uc.getInputStream()));\n                }\n                content = readLines(in, true);\n                in.close();\n            } else {\n                content = readLines(reader, true);\n            }\n            if(content == null) return false;\n            if(content.equals(\"\")) return false;\n            addPeer(content);\n        \n        } else if(uline.startsWith(\"NAME:\")) {\n            outsb.append(\"Node name currently: \").append(n.getMyName());\n            String key = line.substring(\"NAME:\".length()).trim();\n            outsb.append(\"New name: \").append(key);\n            \n            try{\n            \tn.setName(key);\n                if(Logger.shouldLog(Logger.MINOR, this))\n                \tLogger.minor(this, \"Setting node.name to \"+key);\n            }catch(Exception e){\n            \tLogger.error(this, \"Error setting node's name\", e);\n    \t\t}\n            core.storeConfig();\n        } else if(uline.startsWith(\"DISABLEPEER:\")) {\n        \tString nodeIdentifier = (line.substring(\"DISABLEPEER:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tif(disablePeer(nodeIdentifier)) {\n                outsb.append(\"disable succeeded for \").append(nodeIdentifier);\n        \t} else {\n                outsb.append(\"disable failed for \").append(nodeIdentifier);\n        \t}\n        \toutsb.append(\"\\r\\n\");\n        } else if(uline.startsWith(\"ENABLEPEER:\")) {\n        \tString nodeIdentifier = (line.substring(\"ENABLEPEER:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tif(enablePeer(nodeIdentifier)) {\n                outsb.append(\"enable succeeded for \").append(nodeIdentifier);\n        \t} else {\n                outsb.append(\"enable failed for \").append(nodeIdentifier);\n        \t}\n        \toutsb.append(\"\\r\\n\");\n\t\t} else if(uline.startsWith(\"SETPEERLISTENONLY:\")) {\n\t\t\tString nodeIdentifier = (line.substring(\"SETPEERLISTENONLY:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n\t\t\tPeerNode pn = n.getPeerNode(nodeIdentifier);\n        \tif(pn == null) {\n        \t\tout.write((\"n.getPeerNode() failed to get peer details for \"+nodeIdentifier+\"\\r\\n\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n\t\t\tif(!(pn instanceof DarknetPeerNode)) {\n\t\t\t\tout.write((\"Error: \"+nodeIdentifier+\" identifies a non-darknet peer and this command is only available for darknet peers\\r\\n\\r\\n\").getBytes());\n\t\t\t\tout.flush();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tDarknetPeerNode dpn = (DarknetPeerNode) pn;\n\t\t\tdpn.setListenOnly(true);\n            outsb.append(\"set ListenOnly suceeded for \").append(nodeIdentifier).append(\"\\r\\n\");\n\t\t} else if(uline.startsWith(\"UNSETPEERLISTENONLY:\")) {\n\t\t\tString nodeIdentifier = (line.substring(\"UNSETPEERLISTENONLY:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n\t\t\tPeerNode pn = n.getPeerNode(nodeIdentifier);\n        \tif(pn == null) {\n        \t\tout.write((\"n.getPeerNode() failed to get peer details for \"+nodeIdentifier+\"\\r\\n\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n\t\t\tif(!(pn instanceof DarknetPeerNode)) {\n\t\t\t\tout.write((\"Error: \"+nodeIdentifier+\" identifies a non-darknet peer and this command is only available for darknet peers\\r\\n\\r\\n\").getBytes());\n\t\t\t\tout.flush();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tDarknetPeerNode dpn = (DarknetPeerNode) pn;\n\t\t\tdpn.setListenOnly(false);\n            outsb.append(\"unset ListenOnly suceeded for \").append(nodeIdentifier).append(\"\\r\\n\");\n        } else if(uline.startsWith(\"HAVEPEER:\")) {\n        \tString nodeIdentifier = (line.substring(\"HAVEPEER:\".length())).trim();\n        \tif(havePeer(nodeIdentifier)) {\n                outsb.append(\"true for \").append(nodeIdentifier);\n        \t} else {\n                outsb.append(\"false for \").append(nodeIdentifier);\n        \t}\n        \toutsb.append(\"\\r\\n\");\n        } else if(uline.startsWith(\"REMOVEPEER:\") || uline.startsWith(\"DISCONNECT:\")) {\n        \tString nodeIdentifier = null;\n        \tif(uline.startsWith(\"DISCONNECT:\")) {\n        \t\tnodeIdentifier = line.substring(\"DISCONNECT:\".length());\n        \t} else {\n        \t\tnodeIdentifier = line.substring(\"REMOVEPEER:\".length());\n        \t}\n        \tif(removePeer(nodeIdentifier)) {\n                outsb.append(\"peer removed for \").append(nodeIdentifier);\n        \t} else {\n                outsb.append(\"peer removal failed for \").append(nodeIdentifier);\n        \t}\n        \toutsb.append(\"\\r\\n\");\n        } else if(uline.startsWith(\"PEER:\")) {\n        \tString nodeIdentifier = (line.substring(\"PEER:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tPeerNode pn = n.getPeerNode(nodeIdentifier);\n        \tif(pn == null) {\n        \t\tout.write((\"n.getPeerNode() failed to get peer details for \"+nodeIdentifier+\"\\r\\n\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tSimpleFieldSet fs = pn.exportFieldSet();\n        \toutsb.append(fs.toString());\n        } else if(uline.startsWith(\"PEERWMD:\")) {\n        \tString nodeIdentifier = (line.substring(\"PEERWMD:\".length())).trim();\n        \tif(!havePeer(nodeIdentifier)) {\n        \t\tout.write((\"no peer for \"+nodeIdentifier+\"\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tPeerNode pn = n.getPeerNode(nodeIdentifier);\n        \tif(pn == null) {\n        \t\tout.write((\"n.getPeerNode() failed to get peer details for \"+nodeIdentifier+\"\\r\\n\\r\\n\").getBytes());\n        \t\tout.flush();\n        \t\treturn false;\n        \t}\n        \tSimpleFieldSet fs = pn.exportFieldSet();\n        \tSimpleFieldSet meta = pn.exportMetadataFieldSet();\n        \tif(!meta.isEmpty())\n        \t \tfs.put(\"metadata\", meta);\n        \toutsb.append(fs.toString());\n        } else if(uline.startsWith(\"PEERS\")) {\n        \toutsb.append(n.getTMCIPeerList());\n        \toutsb.append(\"PEERS done.\\r\\n\");\n        } else if(uline.startsWith(\"PROBE:\")) {\n        \tString s = uline.substring(\"PROBE:\".length()).trim();\n        \tdouble d = Double.parseDouble(s);\n        \tif(d > 1.0 || d < 0.0) {\n        \t\tSystem.err.println(\"Unacceptable target location: \"+d);\n        \t\treturn false;\n        \t}\n        \tProbeCallback cb = new ProbeCallback() {\n\t\t\t\tpublic void onCompleted(String reason, double target, double best, double nearest, long id, short counter, short uniqueCounter, short linearCounter) {\n\t\t\t\t\tString msg = \"Completed probe request: \"+target+\" -> \"+best+\"\\r\\nNearest actually hit \"+nearest+\", \"+counter+\" nodes (\"+uniqueCounter+\" unique, \"+linearCounter+\" hops), id \"+id+\"\\r\\n\";\n\t\t\t\t\ttry {\n\t\t\t\t\t\tout.write(msg.getBytes());\n\t\t\t\t\t\tout.flush();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Already closed. :(\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized(TextModeClientInterface.this) {\n\t\t\t\t\t\tdoneSomething = true;\n\t\t\t\t\t\tTextModeClientInterface.this.notifyAll();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void onTrace(long uid, double target, double nearest, double best, short htl, short counter, double location, long nodeUID, double[] peerLocs, long[] peerUIDs, double[] locsNotVisited, short forkCount, short linearCounter, String reason, long prevUID) {\n\t\t\t\t\tString msg = \"Probe trace: UID=\"+uid+\" target=\"+target+\" nearest=\"+nearest+\" best=\"+best+\" htl=\"+htl+\" counter=\"+counter+\" linear=\"+linearCounter+\" location=\"+location+\"node UID=\"+nodeUID+\" prev UID=\"+prevUID+\" peer locs=\"+StringArray.toString(peerLocs)+\" peer UIDs=\"+StringArray.toString(peerUIDs)+\" locs not visited = \"+StringArray.toString(locsNotVisited)+\" forks: \"+forkCount+\" reason=\"+reason+'\\n';\n\t\t\t\t\ttry {\n\t\t\t\t\t\tout.write(msg.getBytes());\n\t\t\t\t\t\tout.flush();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void onRejectOverload() {\n\t\t\t\t\tString msg = \"Probe trace received RejectOverload\\n\";\n\t\t\t\t\ttry {\n\t\t\t\t\t\tout.write(msg.getBytes());\n\t\t\t\t\t\tout.flush();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Ignore\n\t\t\t\t\t}\n\t\t\t\t}\n        \t};\n        \toutsb.append(\"Probing keyspace around \"+d+\" ...\");\n        \tn.dispatcher.startProbe(d, cb, NodeDispatcher.PROBE_TYPE_RESETTING_HTL);\n        \tsynchronized(this) {\n        \t\twhile(!doneSomething) {\n        \t\t\ttry {\n        \t\t\t\twait(5000);\n        \t\t\t} catch (InterruptedException e) {\n        \t\t\t\t// Ignore\n        \t\t\t}\n        \t\t}\n        \t\tdoneSomething = false;\n        \t}\n        } else if(uline.startsWith(\"PROBEALL\")) {\n        \tuline = uline.substring(\"PROBEALL\".length());\n        \tif(uline.startsWith(\":\")) uline = uline.substring(1);\n        \tif(uline.length() == 0) {\n        \t\tprobeAll(NodeDispatcher.PROBE_TYPE_RESETTING_HTL);\n        \t} else {\n        \t\tprobeAll(Fields.parseInt(uline, NodeDispatcher.PROBE_TYPE_RESETTING_HTL));\n        \t}\n        } else if(uline.startsWith(\"PLUGLOAD\")) {\n        \tif(uline.startsWith(\"PLUGLOAD:O:\")) {\n        \t\tString name = line.substring(\"PLUGLOAD:O:\".length()).trim();\n        \t\tn.pluginManager.startPluginOfficial(name, true);\n        \t} else if(uline.startsWith(\"PLUGLOAD:F:\")) {\n        \t\tString name = line.substring(\"PLUGLOAD:F:\".length()).trim();\n        \t\tn.pluginManager.startPluginFile(name, true);\n        \t} else if(uline.startsWith(\"PLUGLOAD:U:\")) {\n        \t\tString name = line.substring(\"PLUGLOAD:U:\".length()).trim();\n        \t\tn.pluginManager.startPluginURL(name, true);\n        \t} else if(uline.startsWith(\"PLUGLOAD:K:\")) {\n        \t\tString name = line.substring(\"PLUGLOAD:K:\".length()).trim();\n        \t\tn.pluginManager.startPluginFreenet(name, true);\n        \t} else {\n        \t\toutsb.append(\"  PLUGLOAD:O: pluginName         - Load official plugin from freenetproject.org\\r\\n\");\n        \t\toutsb.append(\"  PLUGLOAD:F: file://<filename>  - Load plugin from file\\r\\n\");\n        \t\toutsb.append(\"  PLUGLOAD:U: http://...         - Load plugin from online file\\r\\n\");\n        \t\toutsb.append(\"  PLUGLOAD:K: freenet key        - Load plugin from freenet uri\\r\\n\");\n        \t}\n        } else if(uline.startsWith(\"PLUGLIST\")) {\n        \toutsb.append(n.pluginManager.dumpPlugins());\n        } else if(uline.startsWith(\"PLUGKILL:\")) {\n        \tn.pluginManager.killPlugin(line.substring(\"PLUGKILL:\".length()).trim(), 60*1000);\n        } else if(uline.startsWith(\"ANNOUNCE\")) {\n        \tOpennetManager om = n.getOpennet();\n        \tif(om == null) {\n        \t\toutsb.append(\"OPENNET DISABLED, cannot announce.\");\n        \t\treturn false;\n        \t}\n        \tuline = uline.substring(\"ANNOUNCE\".length());\n        \tfinal double target;\n        \tif(uline.charAt(0) == ':') {\n        \t\ttarget = Double.parseDouble(uline.substring(1));\n        \t} else {\n        \t\ttarget = n.random.nextDouble();\n        \t}\n        \tom.announce(target, new AnnouncementCallback() {\n        \t\tprivate void write(String msg) {\n        \t\t\ttry {\n        \t\t\t\tout.write((\"ANNOUNCE:\"+target+\":\"+msg+\"\\r\\n\").getBytes());\n        \t\t\t\tout.flush();\n        \t\t\t} catch (IOException e) {\n        \t\t\t\t// Ignore\n        \t\t\t}\n        \t\t}\n\t\t\t\tpublic void addedNode(PeerNode pn) {\n\t\t\t\t\twrite(\"Added node \"+pn.shortToString());\n\t\t\t\t}\n\n\t\t\t\tpublic void bogusNoderef(String reason) {\n\t\t\t\t\twrite(\"Bogus noderef: \"+reason);\n\t\t\t\t}\n\n\t\t\t\tpublic void completed() {\n\t\t\t\t\twrite(\"Completed announcement.\");\n\t\t\t\t}\n\n\t\t\t\tpublic void nodeFailed(PeerNode pn, String reason) {\n\t\t\t\t\twrite(\"Node failed: \"+pn+\" \"+reason);\n\t\t\t\t}\n\n\t\t\t\tpublic void noMoreNodes() {\n\t\t\t\t\twrite(\"Route Not Found\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic void nodeNotWanted() {\n\t\t\t\t\twrite(\"Hop doesn't want me.\");\n\t\t\t\t}\n\t\t\t\tpublic void nodeNotAdded() {\n\t\t\t\t\twrite(\"Node not added as we don't want it for some reason.\");\n\t\t\t\t}\n        \t\t\n        \t});\n        } else {\n        \tif(uline.length() > 0)\n        \t\tprintHeader(out);\n        }\n        outsb.append(\"\\r\\n\");\n        out.write(outsb.toString().getBytes());\n        out.flush();\n        return false;\n    }","commit_id":"7ccaa584a530ccd2e7cf9e5813d7ef64f7b8d4f8","url":"https://github.com/freenet/fred"},{"original_method":"private WIZARD_STEP getPreviousStep(WIZARD_STEP currentStep, WIZARD_PRESET preset) {\n\n\t\t//Might be obvious, but still: No breaks needed in cases because their only contents are returns.\n\n\t\t//First pages for the presets\n\t\tif (preset == WIZARD_PRESET.HIGH) {\n\t\t\tswitch (currentStep) {\n\t\t\t\tcase SECURITY_NETWORK:\n\t\t\t\tcase SECURITY_PHYSICAL:\n\t\t\t\t\t//Go back to the beginning from the warning or the physical security page.\n\t\t\t\t\treturn WIZARD_STEP.WELCOME;\n\t\t\t}\n\t\t} else  if (preset == WIZARD_PRESET.LOW) {\n\t\t\tswitch (currentStep) {\n\t\t\t\tcase DATASTORE_SIZE:\n\t\t\t\t\t//Go back to the beginning from the datastore page.\n\t\t\t\t\treturn WIZARD_STEP.WELCOME;\n\t\t\t}\n\t\t}\n\n\t\t//Otherwise normal order.\n\t\tswitch (currentStep) {\n\t\t\tcase MISC:\n\t\t\tcase BROWSER_WARNING:\n\t\t\t\treturn WIZARD_STEP.WELCOME;\n\t\t\tcase OPENNET:\n\t\t\t\treturn WIZARD_STEP.MISC;\n\t\t\tcase SECURITY_NETWORK:\n\t\t\t\treturn WIZARD_STEP.OPENNET;\n\t\t\tcase SECURITY_PHYSICAL:\n\t\t\t\treturn WIZARD_STEP.SECURITY_NETWORK;\n\t\t\tcase NAME_SELECTION:\n\t\t\t\treturn WIZARD_STEP.SECURITY_PHYSICAL;\n\t\t\tcase DATASTORE_SIZE:\n\t\t\t\treturn WIZARD_STEP.NAME_SELECTION;\n\t\t\tcase BANDWIDTH:\n\t\t\t\treturn WIZARD_STEP.DATASTORE_SIZE;\n\t\t\tcase BANDWIDTH_MONTHLY:\n\t\t\tcase BANDWIDTH_RATE:\n\t\t\t\treturn WIZARD_STEP.BANDWIDTH;\n\t\t}\n\n\t\t//Should be matched by this point, unknown step.\n\t\treturn WIZARD_STEP.WELCOME;\n\t}","id":76394,"modified_method":"public static WIZARD_STEP getPreviousStep(WIZARD_STEP currentStep, WIZARD_PRESET preset) {\n\n\t\t//Might be obvious, but still: No breaks needed in cases because their only contents are returns.\n\n\t\t//First pages for the presets\n\t\tif (preset == WIZARD_PRESET.HIGH) {\n\t\t\tswitch (currentStep) {\n\t\t\t\tcase SECURITY_NETWORK:\n\t\t\t\tcase SECURITY_PHYSICAL:\n\t\t\t\t\t//Go back to the beginning from the warning or the physical security page.\n\t\t\t\t\treturn WIZARD_STEP.WELCOME;\n\t\t\t}\n\t\t} else  if (preset == WIZARD_PRESET.LOW) {\n\t\t\tswitch (currentStep) {\n\t\t\t\tcase DATASTORE_SIZE:\n\t\t\t\t\t//Go back to the beginning from the datastore page.\n\t\t\t\t\treturn WIZARD_STEP.WELCOME;\n\t\t\t}\n\t\t}\n\n\t\t//Otherwise normal order.\n\t\tswitch (currentStep) {\n\t\t\tcase MISC:\n\t\t\tcase BROWSER_WARNING:\n\t\t\t\treturn WIZARD_STEP.WELCOME;\n\t\t\tcase OPENNET:\n\t\t\t\treturn WIZARD_STEP.MISC;\n\t\t\tcase SECURITY_NETWORK:\n\t\t\t\treturn WIZARD_STEP.OPENNET;\n\t\t\tcase SECURITY_PHYSICAL:\n\t\t\t\treturn WIZARD_STEP.SECURITY_NETWORK;\n\t\t\tcase NAME_SELECTION:\n\t\t\t\treturn WIZARD_STEP.SECURITY_PHYSICAL;\n\t\t\tcase DATASTORE_SIZE:\n\t\t\t\treturn WIZARD_STEP.NAME_SELECTION;\n\t\t\tcase BANDWIDTH:\n\t\t\t\treturn WIZARD_STEP.DATASTORE_SIZE;\n\t\t\tcase BANDWIDTH_MONTHLY:\n\t\t\tcase BANDWIDTH_RATE:\n\t\t\t\treturn WIZARD_STEP.BANDWIDTH;\n\t\t}\n\n\t\t//Should be matched by this point, unknown step.\n\t\treturn WIZARD_STEP.WELCOME;\n\t}","commit_id":"6691ad16aa5cefa1208b8cee7b2f0d75259d2f09","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodPOST(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\n\t\tString passwd = request.getPartAsStringFailsafe(\"formPassword\", 32);\n\t\tboolean noPassword = (passwd == null) || !passwd.equals(core.formPassword);\n\t\tif(noPassword) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No password (\"+passwd+\" should be \"+core.formPassword+ ')');\n\t\t\tsuper.writeTemporaryRedirect(ctx, \"invalid/unhandled data\", \"/\");\n\t\t\treturn;\n\t\t}\n\n\t\tWIZARD_STEP currentStep;\n\t\ttry {\n\t\t\t//Attempt to parse the current step, defaulting to WELCOME if unspecified or invalid.\n\t\t\tString currentValue = request.getPartAsStringFailsafe(\"step\", 20);\n\t\t\tcurrentStep = currentValue.isEmpty() ? WIZARD_STEP.WELCOME : WIZARD_STEP.valueOf(currentValue);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\t//Failed to parse enum value, default to welcome.\n\t\t\t//TODO: Should this be an error page instead?\n\t\t\tcurrentStep = WIZARD_STEP.WELCOME;\n\t\t}\n\n\t\tPersistFields persistFields = new PersistFields(request);\n\t\tString redirectTarget;\n\n\t\tif (currentStep.equals(WIZARD_STEP.WELCOME) &&\n\t\t        (request.isPartSet(\"presetLow\") || request.isPartSet(\"presetHigh\") || request.isPartSet(\"presetNone\"))) {\n\n\t\t\t/*Apply presets and UPnP is enabled first to allow it time to load (and thus enable\n\t\t\t  autodetection) before hitting the bandwidth page. This also effectively sets the preset field.*/\n\t\t\tStringBuilder redirectTo = new StringBuilder(TOADLET_URL+\"?step=BROWSER_WARNING&incognito=\");\n\t\t\tredirectTo.append(request.getPartAsStringFailsafe(\"incognito\", 5));\n\n\t\t\t//Translate button name to preset value on the query string.\n\t\t\tif (request.isPartSet(\"presetLow\")) {\n\t\t\t\t//Low security preset\n\t\t\t\tstepMISC.setUPnP(true);\n\t\t\t\tstepMISC.setAutoUpdate(true);\n\t\t\t\tredirectTo.append(\"&preset=LOW&opennet=true\");\n\t\t\t\tstepSECURITY_NETWORK.setThreatLevel(SecurityLevels.NETWORK_THREAT_LEVEL.LOW);\n\t\t\t\tstepSECURITY_PHYSICAL.setThreatLevel(SecurityLevels.PHYSICAL_THREAT_LEVEL.NORMAL,\n\t\t\t\t        stepSECURITY_PHYSICAL.getCurrentLevel());\n\t\t\t} else if (request.isPartSet(\"presetHigh\")) {\n\t\t\t\t//High security preset\n\t\t\t\tstepMISC.setUPnP(true);\n\t\t\t\tstepMISC.setAutoUpdate(true);\n\t\t\t\tredirectTo.append(\"&preset=HIGH&opennet=false\");\n\t\t\t}\n\n\t\t\tsuper.writeTemporaryRedirect(ctx, \"Wizard redirecting.\", redirectTo.toString());\n\t\t\treturn;\n\t\t} else if (request.isPartSet(\"back\")) {\n\t\t\t//User chose back, return to previous page.\n\t\t\tredirectTarget = getPreviousStep(currentStep, persistFields.preset).name();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tredirectTarget = steps.get(currentStep).postStep(request);\n\n\t\t\t\t//Opennet step can change the persisted value for opennet.\n\t\t\t\tif (currentStep == WIZARD_STEP.OPENNET) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tHTTPRequest newRequest = new HTTPRequestImpl(new URI(\n\t\t\t\t\t\t        stepURL(redirectTarget)), \"GET\");\n\t\t\t\t\t\t//Only continue if a value for opennet has been selected.\n\t\t\t\t\t\tif (newRequest.isPartSet(\"opennet\")) {\n\t\t\t\t\t\t\tredirectTarget = WIZARD_STEP.SECURITY_NETWORK.name();\n\t\t\t\t\t\t\tpersistFields = new PersistFields(persistFields.preset, newRequest);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\t\tLogger.error(this, \"Unexpected invalid query string from OPENNET step! \"+e, e);\n\t\t\t\t\t\tredirectTarget = WIZARD_STEP.WELCOME.name();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tString title;\n\t\t\t\tif (e.getMessage().equals(\"cantWriteNewMasterKeysFile\")) {\n\t\t\t\t\t//Recognized as being unable to write to the master keys file.\n\t\t\t\t\ttitle = NodeL10n.getBase().getString(\"SecurityLevels.cantWriteNewMasterKeysFileTitle\");\n\t\t\t\t} else {\n\t\t\t\t\t//Some other error.\n\t\t\t\t\ttitle = NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\");\n\t\t\t\t}\n\n\t\t\t\t//Very loud error message, with descriptive title and header if possible.\n\t\t\t\tStringBuilder msg = new StringBuilder(\"<html><head><title>\").append(title).\n\t\t\t\t        append(\"<\/title><\/head><body><h1>\").append(title).append(\"<\/h1><pre>\");\n\n\t\t\t\t//Print stack trace.\n\t\t\t\tStringWriter sw = new StringWriter();\n\t\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\t\te.printStackTrace(pw);\n\t\t\t\tpw.flush();\n\t\t\t\tmsg.append(sw.toString()).append(\"<\/pre>\");\n\n\t\t\t\t//Include internal exception if one exists.\n\t\t\t\tThrowable internal = e.getCause();\n\t\t\t\tif (internal != null) {\n\t\t\t\t\tmsg.append(\"<h1>\").\n\t\t\t\t\t        append(NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\")).\n\t\t\t\t\t        append(\"<\/h1>\").append(\"<pre>\");\n\n\t\t\t\t\tsw = new StringWriter();\n\t\t\t\t\tpw = new PrintWriter(sw);\n\t\t\t\t\tinternal.printStackTrace(pw);\n\t\t\t\t\tpw.flush();\n\t\t\t\t\tmsg.append(sw.toString()).append(\"<\/pre>\");\n\t\t\t\t}\n\t\t\t\tmsg.append(\"<\/body><\/html>\");\n\t\t\t\twriteHTMLReply(ctx, 500, \"Internal Error\", msg.toString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.writeTemporaryRedirect(ctx, \"Wizard redirect\", stepURL(persistFields.appendTo(redirectTarget)));\n\t}","id":76395,"modified_method":"public void handleMethodPOST(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", NodeL10n.getBase().getString(\"Toadlet.unauthorized\"));\n\t\t\treturn;\n\t\t}\n\n\t\tString passwd = request.getPartAsStringFailsafe(\"formPassword\", 32);\n\t\tboolean noPassword = (passwd == null) || !passwd.equals(core.formPassword);\n\t\tif(noPassword) {\n\t\t\tif(logMINOR) Logger.minor(this, \"No password (\"+passwd+\" should be \"+core.formPassword+ ')');\n\t\t\tsuper.writeTemporaryRedirect(ctx, \"invalid/unhandled data\", \"/\");\n\t\t\treturn;\n\t\t}\n\n\t\tWIZARD_STEP currentStep;\n\t\ttry {\n\t\t\t//Attempt to parse the current step, defaulting to WELCOME if unspecified or invalid.\n\t\t\tString currentValue = request.getPartAsStringFailsafe(\"step\", 20);\n\t\t\tcurrentStep = currentValue.isEmpty() ? WIZARD_STEP.WELCOME : WIZARD_STEP.valueOf(currentValue);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\t//Failed to parse enum value, default to welcome.\n\t\t\t//TODO: Should this be an error page instead?\n\t\t\tcurrentStep = WIZARD_STEP.WELCOME;\n\t\t}\n\n\t\tPersistFields persistFields = new PersistFields(request);\n\t\tString redirectTarget;\n\n\t\tif (currentStep.equals(WIZARD_STEP.WELCOME) &&\n\t\t        (request.isPartSet(\"presetLow\") || request.isPartSet(\"presetHigh\") || request.isPartSet(\"presetNone\"))) {\n\n\t\t\t/*Apply presets and UPnP is enabled first to allow it time to load (and thus enable\n\t\t\t  autodetection) before hitting the bandwidth page. This also effectively sets the preset field.*/\n\t\t\tStringBuilder redirectTo = new StringBuilder(TOADLET_URL+\"?step=BROWSER_WARNING&incognito=\");\n\t\t\tredirectTo.append(request.getPartAsStringFailsafe(\"incognito\", 5));\n\n\t\t\t//Translate button name to preset value on the query string.\n\t\t\tif (request.isPartSet(\"presetLow\")) {\n\t\t\t\t//Low security preset\n\t\t\t\tstepMISC.setUPnP(true);\n\t\t\t\tstepMISC.setAutoUpdate(true);\n\t\t\t\tredirectTo.append(\"&preset=LOW&opennet=true\");\n\t\t\t\tstepSECURITY_NETWORK.setThreatLevel(SecurityLevels.NETWORK_THREAT_LEVEL.LOW);\n\t\t\t\tstepSECURITY_PHYSICAL.setThreatLevel(SecurityLevels.PHYSICAL_THREAT_LEVEL.NORMAL,\n\t\t\t\t        stepSECURITY_PHYSICAL.getCurrentLevel());\n\t\t\t} else if (request.isPartSet(\"presetHigh\")) {\n\t\t\t\t//High security preset\n\t\t\t\tstepMISC.setUPnP(true);\n\t\t\t\tstepMISC.setAutoUpdate(true);\n\t\t\t\tredirectTo.append(\"&preset=HIGH&opennet=false\");\n\t\t\t}\n\n\t\t\tsuper.writeTemporaryRedirect(ctx, \"Wizard set preset\", redirectTo.toString());\n\t\t\treturn;\n\t\t} else if (request.isPartSet(\"back\")) {\n\t\t\t//User chose back, return to previous page.\n\t\t\tredirectTarget = getPreviousStep(currentStep, persistFields.preset).name();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tredirectTarget = steps.get(currentStep).postStep(request);\n\n\t\t\t\t//Opennet step can change the persisted value for opennet.\n\t\t\t\tif (currentStep == WIZARD_STEP.OPENNET) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tHTTPRequest newRequest = new HTTPRequestImpl(new URI(\n\t\t\t\t\t\t        stepURL(redirectTarget)), \"GET\");\n\t\t\t\t\t\t//Only continue if a value for opennet has been selected.\n\t\t\t\t\t\tif (newRequest.isPartSet(\"opennet\")) {\n\t\t\t\t\t\t\tredirectTarget = WIZARD_STEP.SECURITY_NETWORK.name();\n\t\t\t\t\t\t\tpersistFields = new PersistFields(persistFields.preset, newRequest);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\t\tLogger.error(this, \"Unexpected invalid query string from OPENNET step! \"+e, e);\n\t\t\t\t\t\tredirectTarget = WIZARD_STEP.WELCOME.name();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tString title;\n\t\t\t\tif (e.getMessage().equals(\"cantWriteNewMasterKeysFile\")) {\n\t\t\t\t\t//Recognized as being unable to write to the master keys file.\n\t\t\t\t\ttitle = NodeL10n.getBase().getString(\"SecurityLevels.cantWriteNewMasterKeysFileTitle\");\n\t\t\t\t} else {\n\t\t\t\t\t//Some other error.\n\t\t\t\t\ttitle = NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\");\n\t\t\t\t}\n\n\t\t\t\t//Very loud error message, with descriptive title and header if possible.\n\t\t\t\tStringBuilder msg = new StringBuilder(\"<html><head><title>\").append(title).\n\t\t\t\t        append(\"<\/title><\/head><body><h1>\").append(title).append(\"<\/h1><pre>\");\n\n\t\t\t\t//Print stack trace.\n\t\t\t\tStringWriter sw = new StringWriter();\n\t\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\t\te.printStackTrace(pw);\n\t\t\t\tpw.flush();\n\t\t\t\tmsg.append(sw.toString()).append(\"<\/pre>\");\n\n\t\t\t\t//Include internal exception if one exists.\n\t\t\t\tThrowable internal = e.getCause();\n\t\t\t\tif (internal != null) {\n\t\t\t\t\tmsg.append(\"<h1>\").\n\t\t\t\t\t        append(NodeL10n.getBase().getString(\"Toadlet.internalErrorPleaseReport\")).\n\t\t\t\t\t        append(\"<\/h1>\").append(\"<pre>\");\n\n\t\t\t\t\tsw = new StringWriter();\n\t\t\t\t\tpw = new PrintWriter(sw);\n\t\t\t\t\tinternal.printStackTrace(pw);\n\t\t\t\t\tpw.flush();\n\t\t\t\t\tmsg.append(sw.toString()).append(\"<\/pre>\");\n\t\t\t\t}\n\t\t\t\tmsg.append(\"<\/body><\/html>\");\n\t\t\t\twriteHTMLReply(ctx, 500, \"Internal Error\", msg.toString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.writeTemporaryRedirect(ctx, \"Wizard redirect\", stepURL(persistFields.appendTo(redirectTarget)));\n\t}","commit_id":"6691ad16aa5cefa1208b8cee7b2f0d75259d2f09","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic String postStep(HTTPRequest request) {\n\t\tString networkThreatLevel = request.getPartAsStringFailsafe(\"security-levels.networkThreatLevel\", 128);\n\t\tSecurityLevels.NETWORK_THREAT_LEVEL newThreatLevel = SecurityLevels.parseNetworkThreatLevel(networkThreatLevel);\n\n\t\t//Used in case of redirect either for retry or confirmation.\n\t\tStringBuilder redirectTo = new StringBuilder(FirstTimeWizardToadlet.WIZARD_STEP.SECURITY_NETWORK.name());\n\n\t\t/*If the user didn't select a network security level before clicking continue or the selected\n\t\t* security level could not be determined, redirect to the same page.*/\n\t\tif(newThreatLevel == null || !request.isPartSet(\"security-levels.networkThreatLevel\")) {\n\t\t\treturn redirectTo.toString();\n\t\t}\n\t\tif((newThreatLevel == SecurityLevels.NETWORK_THREAT_LEVEL.MAXIMUM || newThreatLevel == SecurityLevels.NETWORK_THREAT_LEVEL.HIGH)) {\n\t\t\t//Make the user aware of the effects of high or maximum network threat if selected.\n\t\t\t//They must check a box acknowledging its affects to proceed.\n\t\t\tif((!request.isPartSet(\"security-levels.networkThreatLevel.confirm\")) &&\n\t\t\t        (!request.isPartSet(\"security-levels.networkThreatLevel.tryConfirm\"))) {\n\t\t\t\tdisplayConfirmationBox(redirectTo, networkThreatLevel);\n\t\t\t\treturn redirectTo.toString();\n\t\t\t} else if((!request.isPartSet(\"security-levels.networkThreatLevel.confirm\")) &&\n\t\t\t\t        request.isPartSet(\"security-levels.networkThreatLevel.tryConfirm\")) {\n\t\t\t\t//If the user did not check the box. If in a preset, redisplay the page, The user can\n\t\t\t\t//press cancel to go back.\n\t\t\t\tif (request.isPartSet(\"preset\")) {\n\t\t\t\t\tdisplayConfirmationBox(redirectTo, networkThreatLevel);\n\t\t\t\t\treturn redirectTo.toString();\n\t\t\t\t}\n\n\t\t\t\t//If in detailed mode, the user can choose between levels, so return to level selection.\n\t\t\t\treturn redirectTo.toString();\n\t\t\t}\n\t\t}\n\t\t//The user selected low or normal security, or confirmed high or maximum. Set the configuration\n\t\t//and continue to the physical security step.\n\t\tsetThreatLevel(newThreatLevel);\n\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.SECURITY_PHYSICAL.name();\n\t}","id":76396,"modified_method":"@Override\n\tpublic String postStep(HTTPRequest request) {\n\t\tString networkThreatLevel = request.getPartAsStringFailsafe(\"security-levels.networkThreatLevel\", 128);\n\t\tSecurityLevels.NETWORK_THREAT_LEVEL newThreatLevel = SecurityLevels.parseNetworkThreatLevel(networkThreatLevel);\n\n\t\t//Used in case of redirect either for retry or confirmation.\n\t\tStringBuilder redirectTo = new StringBuilder(FirstTimeWizardToadlet.WIZARD_STEP.SECURITY_NETWORK.name());\n\n\t\t/*If the user didn't select a network security level before clicking continue or the selected\n\t\t* security level could not be determined, redirect to the same page.*/\n\t\tif(newThreatLevel == null || !request.isPartSet(\"security-levels.networkThreatLevel\")) {\n\t\t\treturn redirectTo.toString();\n\t\t}\n\n\t\tPersistFields persistFields = new PersistFields(request);\n\t\tboolean isInPreset = persistFields.isUsingPreset();\n\t\tif (request.isPartSet(\"return-from-confirm\")) {\n\t\t\t//User clicked back from a confirmation page\n\t\t\tif (isInPreset) {\n\t\t\t\t//In a preset, go back a step\n\t\t\t\treturn FirstTimeWizardToadlet.getPreviousStep(\n\t\t\t\t        FirstTimeWizardToadlet.WIZARD_STEP.SECURITY_NETWORK, persistFields.preset).name();\n\t\t\t}\n\n\t\t\t//Not in a preset, redisplay level choice.\n\t\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.SECURITY_NETWORK.name();\n\t\t}\n\t\tif((newThreatLevel == SecurityLevels.NETWORK_THREAT_LEVEL.MAXIMUM || newThreatLevel == SecurityLevels.NETWORK_THREAT_LEVEL.HIGH)) {\n\t\t\t//Make the user aware of the effects of high or maximum network threat if selected.\n\t\t\t//They must check a box acknowledging its affects to proceed.\n\t\t\tif((!request.isPartSet(\"security-levels.networkThreatLevel.confirm\")) &&\n\t\t\t        (!request.isPartSet(\"security-levels.networkThreatLevel.tryConfirm\"))) {\n\t\t\t\tdisplayConfirmationBox(redirectTo, networkThreatLevel);\n\t\t\t\treturn redirectTo.toString();\n\t\t\t} else if((!request.isPartSet(\"security-levels.networkThreatLevel.confirm\")) &&\n\t\t\t\t        request.isPartSet(\"security-levels.networkThreatLevel.tryConfirm\")) {\n\t\t\t\t//If the user did not check the box and clicked next, redisplay the prompt.\n\t\t\t\tdisplayConfirmationBox(redirectTo, networkThreatLevel);\n\t\t\t\treturn redirectTo.toString();\n\t\t\t}\n\t\t}\n\t\t//The user selected low or normal security, or confirmed high or maximum. Set the configuration\n\t\t//and continue to the physical security step.\n\t\tsetThreatLevel(newThreatLevel);\n\t\treturn FirstTimeWizardToadlet.WIZARD_STEP.SECURITY_PHYSICAL.name();\n\t}","commit_id":"6691ad16aa5cefa1208b8cee7b2f0d75259d2f09","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void getStep(HTTPRequest request, PageHelper helper) {\n\t\tHTMLNode contentNode = helper.getPageContent(WizardL10n.l10n(\"networkSecurityPageTitle\"));\n\t\tString opennetParam = request.getParam(\"opennet\", \"false\");\n\t\tboolean opennet = Fields.stringToBool(opennetParam, false);\n\n\t\tif (request.isParameterSet(\"confirm\")) {\n\t\t\tString networkThreatLevel = request.getParam(\"security-levels.networkThreatLevel\");\n\t\t\tSecurityLevels.NETWORK_THREAT_LEVEL newThreatLevel = SecurityLevels.parseNetworkThreatLevel(networkThreatLevel);\n\n\t\t\tHTMLNode infoboxContent = helper.getInfobox(\"infobox-information\",\n\t\t\t        WizardL10n.l10n(\"networkThreatLevelConfirmTitle.\"+newThreatLevel), contentNode, null, false);\n\n\t\t\tHTMLNode formNode = helper.addFormChild(infoboxContent, \".\", \"configFormSecLevels\");\n\t\t\tformNode.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"hidden\", \"security-levels.networkThreatLevel\", networkThreatLevel });\n\t\t\tif(newThreatLevel == SecurityLevels.NETWORK_THREAT_LEVEL.MAXIMUM) {\n\t\t\t\tHTMLNode p = formNode.addChild(\"p\");\n\t\t\t\tNodeL10n.getBase().addL10nSubstitution(p, \"SecurityLevels.maximumNetworkThreatLevelWarning\",\n\t\t\t\t        new String[] { \"bold\" },\n\t\t\t\t        new HTMLNode[] { HTMLNode.STRONG });\n\t\t\t\tp.addChild(\"#\", \" \");\n\t\t\t\tNodeL10n.getBase().addL10nSubstitution(p, \"SecurityLevels.maxSecurityYouNeedFriends\",\n\t\t\t\t        new String[] { \"bold\" },\n\t\t\t\t        new HTMLNode[] { HTMLNode.STRONG });\n\t\t\t\tformNode.addChild(\"p\").addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"checkbox\", \"security-levels.networkThreatLevel.confirm\", \"off\" },\n\t\t\t\t        WizardL10n.l10nSec(\"maximumNetworkThreatLevelCheckbox\"));\n\t\t\t} else /*if(newThreatLevel == NETWORK_THREAT_LEVEL.HIGH)*/ {\n\t\t\t\tHTMLNode p = formNode.addChild(\"p\");\n\t\t\t\tNodeL10n.getBase().addL10nSubstitution(p, \"FirstTimeWizardToadlet.highNetworkThreatLevelWarning\",\n\t\t\t\t        new String[] { \"bold\", \"addAFriend\", \"friends\" },\n\t\t\t\t        new HTMLNode[] { HTMLNode.STRONG,\n\t\t\t\t                new HTMLNode(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.addFriendTitle\")),\n\t\t\t\t                new HTMLNode(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.categoryFriends\"))});\n\t\t\t\tHTMLNode checkbox = formNode.addChild(\"p\").addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"checkbox\", \"security-levels.networkThreatLevel.confirm\", \"off\" });\n\t\t\t\tNodeL10n.getBase().addL10nSubstitution(checkbox,\n\t\t\t\t        \"FirstTimeWizardToadlet.highNetworkThreatLevelCheckbox\",\n\t\t\t\t        new String[] { \"bold\", \"addAFriend\" },\n\t\t\t\t        new HTMLNode[] { HTMLNode.STRONG,\n\t\t\t\t                new HTMLNode(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.addFriendTitle\")),});\n\t\t\t}\n\t\t\tformNode.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"hidden\", \"security-levels.networkThreatLevel.tryConfirm\", \"on\" });\n\t\t\tformNode.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"submit\", \"back\", NodeL10n.getBase().getString(\"Toadlet.back\")});\n\t\t\tformNode.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"submit\", \"next\", NodeL10n.getBase().getString(\"Toadlet.next\")});\n\t\t\treturn;\n\t\t}\n\n\t\t//Add choices and description depending on whether opennet was selected.\n\t\tHTMLNode form;\n\t\tif(opennet) {\n\t\t\tHTMLNode infoboxContent = helper.getInfobox(\"infobox-normal\",\n\t\t\t        WizardL10n.l10n(\"networkThreatLevelHeaderOpennet\"), contentNode, null, false);\n\t\t\tinfoboxContent.addChild(\"p\", WizardL10n.l10n(\"networkThreatLevelIntroOpennet\"));\n\n\t\t\tform = helper.addFormChild(infoboxContent, \".\", \"networkSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"opennetDiv\");\n\t\t\tfor(SecurityLevels.NETWORK_THREAT_LEVEL level : SecurityLevels.NETWORK_THREAT_LEVEL.OPENNET_VALUES) {\n\t\t\t\tsecurityLevelChoice(div, level);\n\t\t\t}\n\t\t} else {\n\t\t\tHTMLNode infoboxContent = helper.getInfobox(\"infobox-normal\",\n\t\t\t        WizardL10n.l10n(\"networkThreatLevelHeaderDarknet\"), contentNode, null, false);\n\t\t\tinfoboxContent.addChild(\"p\", WizardL10n.l10n(\"networkThreatLevelIntroDarknet\"));\n\n\t\t\tform = helper.addFormChild(infoboxContent, \".\", \"networkSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"darknetDiv\");\n\t\t\tfor(SecurityLevels.NETWORK_THREAT_LEVEL level : SecurityLevels.NETWORK_THREAT_LEVEL.DARKNET_VALUES) {\n\t\t\t\tsecurityLevelChoice(div, level);\n\t\t\t}\n\t\t\tform.addChild(\"p\").addChild(\"b\", WizardL10n.l10nSec(\"networkThreatLevel.opennetFriendsWarning\"));\n\t\t}\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"networkSecurityF\", WizardL10n.l10n(\"continue\")});\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"cancel\", NodeL10n.getBase().getString(\"Toadlet.cancel\")});\n\t}","id":76397,"modified_method":"@Override\n\tpublic void getStep(HTTPRequest request, PageHelper helper) {\n\t\tHTMLNode contentNode = helper.getPageContent(WizardL10n.l10n(\"networkSecurityPageTitle\"));\n\t\tString opennetParam = request.getParam(\"opennet\", \"false\");\n\t\tboolean opennet = Fields.stringToBool(opennetParam, false);\n\n\t\tif (request.isParameterSet(\"confirm\")) {\n\t\t\tString networkThreatLevel = request.getParam(\"security-levels.networkThreatLevel\");\n\t\t\tSecurityLevels.NETWORK_THREAT_LEVEL newThreatLevel = SecurityLevels.parseNetworkThreatLevel(networkThreatLevel);\n\n\t\t\tHTMLNode infoboxContent = helper.getInfobox(\"infobox-information\",\n\t\t\t        WizardL10n.l10n(\"networkThreatLevelConfirmTitle.\"+newThreatLevel), contentNode, null, false);\n\n\t\t\tHTMLNode formNode = helper.addFormChild(infoboxContent, \".\", \"configFormSecLevels\");\n\t\t\tformNode.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"hidden\", \"security-levels.networkThreatLevel\", networkThreatLevel });\n\t\t\tif(newThreatLevel == SecurityLevels.NETWORK_THREAT_LEVEL.MAXIMUM) {\n\t\t\t\tHTMLNode p = formNode.addChild(\"p\");\n\t\t\t\tNodeL10n.getBase().addL10nSubstitution(p, \"SecurityLevels.maximumNetworkThreatLevelWarning\",\n\t\t\t\t        new String[] { \"bold\" },\n\t\t\t\t        new HTMLNode[] { HTMLNode.STRONG });\n\t\t\t\tp.addChild(\"#\", \" \");\n\t\t\t\tNodeL10n.getBase().addL10nSubstitution(p, \"SecurityLevels.maxSecurityYouNeedFriends\",\n\t\t\t\t        new String[] { \"bold\" },\n\t\t\t\t        new HTMLNode[] { HTMLNode.STRONG });\n\t\t\t\tformNode.addChild(\"p\").addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"checkbox\", \"security-levels.networkThreatLevel.confirm\", \"off\" },\n\t\t\t\t        WizardL10n.l10nSec(\"maximumNetworkThreatLevelCheckbox\"));\n\t\t\t} else /*if(newThreatLevel == NETWORK_THREAT_LEVEL.HIGH)*/ {\n\t\t\t\tHTMLNode p = formNode.addChild(\"p\");\n\t\t\t\tNodeL10n.getBase().addL10nSubstitution(p, \"FirstTimeWizardToadlet.highNetworkThreatLevelWarning\",\n\t\t\t\t        new String[] { \"bold\", \"addAFriend\", \"friends\" },\n\t\t\t\t        new HTMLNode[] { HTMLNode.STRONG,\n\t\t\t\t                new HTMLNode(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.addFriendTitle\")),\n\t\t\t\t                new HTMLNode(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.categoryFriends\"))});\n\t\t\t\tHTMLNode checkbox = formNode.addChild(\"p\").addChild(\"input\",\n\t\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t\t        new String[] { \"checkbox\", \"security-levels.networkThreatLevel.confirm\", \"off\" });\n\t\t\t\tNodeL10n.getBase().addL10nSubstitution(checkbox,\n\t\t\t\t        \"FirstTimeWizardToadlet.highNetworkThreatLevelCheckbox\",\n\t\t\t\t        new String[] { \"bold\", \"addAFriend\" },\n\t\t\t\t        new HTMLNode[] { HTMLNode.STRONG,\n\t\t\t\t                new HTMLNode(\"#\", NodeL10n.getBase().getString(\"FProxyToadlet.addFriendTitle\")),});\n\t\t\t}\n\t\t\tformNode.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"hidden\", \"security-levels.networkThreatLevel.tryConfirm\", \"on\" });\n\t\t\tformNode.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"submit\", \"return-from-confirm\", NodeL10n.getBase().getString(\"Toadlet.back\")});\n\t\t\tformNode.addChild(\"input\",\n\t\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t\t        new String[] { \"submit\", \"next\", NodeL10n.getBase().getString(\"Toadlet.next\")});\n\t\t\treturn;\n\t\t}\n\n\t\t//Add choices and description depending on whether opennet was selected.\n\t\tHTMLNode form;\n\t\tif(opennet) {\n\t\t\tHTMLNode infoboxContent = helper.getInfobox(\"infobox-normal\",\n\t\t\t        WizardL10n.l10n(\"networkThreatLevelHeaderOpennet\"), contentNode, null, false);\n\t\t\tinfoboxContent.addChild(\"p\", WizardL10n.l10n(\"networkThreatLevelIntroOpennet\"));\n\n\t\t\tform = helper.addFormChild(infoboxContent, \".\", \"networkSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"opennetDiv\");\n\t\t\tfor(SecurityLevels.NETWORK_THREAT_LEVEL level : SecurityLevels.NETWORK_THREAT_LEVEL.OPENNET_VALUES) {\n\t\t\t\tsecurityLevelChoice(div, level);\n\t\t\t}\n\t\t} else {\n\t\t\tHTMLNode infoboxContent = helper.getInfobox(\"infobox-normal\",\n\t\t\t        WizardL10n.l10n(\"networkThreatLevelHeaderDarknet\"), contentNode, null, false);\n\t\t\tinfoboxContent.addChild(\"p\", WizardL10n.l10n(\"networkThreatLevelIntroDarknet\"));\n\n\t\t\tform = helper.addFormChild(infoboxContent, \".\", \"networkSecurityForm\");\n\t\t\tHTMLNode div = form.addChild(\"div\", \"class\", \"darknetDiv\");\n\t\t\tfor(SecurityLevels.NETWORK_THREAT_LEVEL level : SecurityLevels.NETWORK_THREAT_LEVEL.DARKNET_VALUES) {\n\t\t\t\tsecurityLevelChoice(div, level);\n\t\t\t}\n\t\t\tform.addChild(\"p\").addChild(\"b\", WizardL10n.l10nSec(\"networkThreatLevel.opennetFriendsWarning\"));\n\t\t}\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"back\", NodeL10n.getBase().getString(\"Toadlet.back\")});\n\t\tform.addChild(\"input\",\n\t\t        new String[] { \"type\", \"name\", \"value\" },\n\t\t        new String[] { \"submit\", \"next\", NodeL10n.getBase().getString(\"Toadlet.next\")});\n\t}","commit_id":"6691ad16aa5cefa1208b8cee7b2f0d75259d2f09","url":"https://github.com/freenet/fred"},{"original_method":"/**\n         * Before we touch I/O streams, we need to make sure all the remote I/O operations are locally completed,\n         * or else we end up switching the log traffic at unaligned moments.\n         */\n        private void sync() {\n            try {\n                Channel.current().syncLocalIO();\n            } catch (InterruptedException e) {\n                // our signature doesn't allow us to throw InterruptedException, so we process it later\n                Thread.currentThread().interrupt();\n            }\n        }","id":76398,"modified_method":"/**\n         * Before we touch I/O streams, we need to make sure all the remote I/O operations are locally completed,\n         * or else we end up switching the log traffic at unaligned moments.\n         */\n        private void sync() {\n            try {\n                Channel ch = Channel.current();\n                if (ch!=null)\n                    ch.syncLocalIO();\n            } catch (InterruptedException e) {\n                // our signature doesn't allow us to throw InterruptedException, so we process it later\n                Thread.currentThread().interrupt();\n            }\n        }","commit_id":"78c1d5d6d851dd510ff758ae2e4eb568dcd72436","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Ensures that the query parsing wasn't invoked via the delete by query api.\n     */\n    public static void ensureNotDeleteByQuery(String name, QueryParseContext parseContext) {\n        if (TransportShardDeleteByQueryAction.DELETE_BY_QUERY_API.equals(SearchContext.current().source())) {\n            throw new QueryParsingException(parseContext.index(), \"[\" + name + \"] unsupported in delete_by_query api\");\n        }\n    }","id":76399,"modified_method":"/**\n     * Ensures that the query parsing wasn't invoked via the delete by query api.\n     */\n    public static void ensureNotDeleteByQuery(String name, QueryParseContext parseContext) {\n        SearchContext context = SearchContext.current();\n        if (context == null) {\n            throw new QueryParsingException(parseContext.index(), \"[\" + name + \"] query and filter requires a search context\");\n        }\n\n        if (TransportShardDeleteByQueryAction.DELETE_BY_QUERY_API.equals(context.source())) {\n            throw new QueryParsingException(parseContext.index(), \"[\" + name + \"] query and filter unsupported in delete_by_query api\");\n        }\n    }","commit_id":"319878eb1ee2926f74408db95bb4a0a43fd2c5a3","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Interrupt the execution,\n     * but instead of marking the build as aborted, mark it as specified result.\n     *\n     * @since 1.417\n     */\n    public void interrupt(Result result) {\n        Authentication a = Jenkins.getAuthentication();\n        if (a!=ACL.SYSTEM)\n            interrupt(result, new UserInterruption(User.current()));    // worth recording who did it\n        else\n            interrupt(result, new CauseOfInterruption[0]);\n    }","id":76400,"modified_method":"/**\n     * Interrupt the execution,\n     * but instead of marking the build as aborted, mark it as specified result.\n     *\n     * @since 1.417\n     */\n    public void interrupt(Result result) {\n        Authentication a = Jenkins.getAuthentication();\n        User u = User.current();\n        \n        if (a!=ACL.SYSTEM && u!=null)\n            interrupt(result, new UserInterruption(u));    // worth recording who did it\n        else\n            interrupt(result, new CauseOfInterruption[0]);\n    }","commit_id":"9ac09aee3e58783f5f9a69a6c6a5e60f6eb5fea2","url":"https://github.com/kohsuke/hudson"},{"original_method":"public Boolean call() throws Exception {\n            if (File.pathSeparatorChar==';')    return false;   // Windows\n            \n            OutputStream o = Channel.current().getUnderlyingOutput();\n            if (o instanceof StandardOutputStream) {\n                StandardOutputStream stdout = (StandardOutputStream)o;\n\n                // duplicate the OS file descriptor and create FileOutputStream around it\n                int out = GNUCLibrary.LIBC.dup(1);\n                if (out<0)      throw new IOException(\"Failed to dup(1)\");\n                Constructor<FileDescriptor> c = FileDescriptor.class.getDeclaredConstructor(int.class);\n                c.setAccessible(true);\n                FileOutputStream fos = new FileOutputStream(c.newInstance(out));\n\n                // swap it into channel so that it'll use the new file descriptor\n                stdout.swap(fos);\n\n                // close fd=1 (stdout) and duplicate fd=2 (stderr) into fd=1 (stdout)\n                GNUCLibrary.LIBC.close(1);\n                GNUCLibrary.LIBC.dup2(2,1);\n                return true;\n            }\n            return false;\n        }","id":76401,"modified_method":"public Boolean call() throws Exception {\n            if (File.pathSeparatorChar==';')    return false;   // Windows\n\n            Channel c = Channel.current();\n\n            StandardOutputStream sos = (StandardOutputStream) c.getProperty(StandardOutputStream.class);\n            if (sos!=null) {\n                swap(sos);\n                return true;\n            }\n\n            OutputStream o = c.getUnderlyingOutput();\n            if (o instanceof StandardOutputStream) {\n                swap((StandardOutputStream) o);\n                return true;\n            }\n\n            return false;\n        }","commit_id":"e7d75dc5382e8e47c73f10f6077df3283d8c5a6a","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n        public void executeAsync(final BuildCallable<?,?> program) throws IOException {\n            recordAsynchronousExecution(\n                    Channel.current().callAsync(\n                            new AsyncInvoker(core,program)));\n        }","id":76402,"modified_method":"@Override\n        public void executeAsync(final BuildCallable<?,?> program) throws IOException {\n            \n            Channel ch = this.channel != null ? this.channel : Channel.current();\n            \n            if (ch == null) {\n                throw new NullPointerException(\"current channel not available!\");\n            }\n            \n            recordAsynchronousExecution(\n                    ch.callAsync(\n                            new AsyncInvoker(core,program)));\n        }","commit_id":"609b321e6ee0963908dddda048d572f2550e75aa","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected Maven3Builder(BuildListener listener,Map<ModuleName,ProxyImpl2> proxies, Map<ModuleName,List<MavenReporter>> reporters, List<String> goals, Map<String, String> systemProps, MavenBuildInformation mavenBuildInformation) {\n        super( listener, goals, systemProps );\n        this.mavenBuildInformation = mavenBuildInformation;\n        sourceProxies = new HashMap<ModuleName, ProxyImpl2>(proxies);\n        this.proxies = new HashMap<ModuleName, MavenBuildProxy2>(proxies);\n        for (Entry<ModuleName,MavenBuildProxy2> e : this.proxies.entrySet())\n            e.setValue(new FilterImpl(e.getValue(), this.mavenBuildInformation));\n\n        this.reporters.putAll( reporters );\n    }","id":76403,"modified_method":"protected Maven3Builder(BuildListener listener,Map<ModuleName,ProxyImpl2> proxies, Map<ModuleName,List<MavenReporter>> reporters, List<String> goals, Map<String, String> systemProps, MavenBuildInformation mavenBuildInformation) {\n        super( listener, goals, systemProps );\n        this.mavenBuildInformation = mavenBuildInformation;\n        sourceProxies = new HashMap<ModuleName, ProxyImpl2>(proxies);\n        this.proxies = new HashMap<ModuleName, MavenBuildProxy2>(proxies);\n        for (Entry<ModuleName,MavenBuildProxy2> e : this.proxies.entrySet())\n            e.setValue(new FilterImpl(e.getValue(), this.mavenBuildInformation, Channel.current()));\n\n        this.reporters.putAll( reporters );\n    }","commit_id":"609b321e6ee0963908dddda048d572f2550e75aa","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Called each time the underlying rich text area gains the focus.\n     */\n    protected void onFocus()\n    {\n        // Nothing here by default. May be overridden by browser specific implementations.\n    }","id":76404,"modified_method":"/**\n     * Called each time the underlying rich text area gains the focus.\n     */\n    protected void onFocus()\n    {\n        // It seems the edited content wasn't submitted so we have to unmark the unwanted BRs in order to avoid\n        // conflicts with the rich text area's history mechanism.\n        unmarkUnwantedBRs();\n    }","commit_id":"40ec16a8c114500281d0a0426394fafb3cdf8587","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Called before the underlying rich text area looses focus.\n     */\n    protected void onBeforeBlur()\n    {\n        // Nothing here by default. May be overridden by browser specific implementations.\n    }","id":76405,"modified_method":"/**\n     * Called before the underlying rich text area looses focus.\n     */\n    protected void onBeforeBlur()\n    {\n        // The edited content might be submitted so we have to mark the BRs that have been added to allow the user to\n        // edit the empty block elements. These BRs will be removed from rich text area's HTML output on the server\n        // side.\n        markUnwantedBRs();\n    }","commit_id":"40ec16a8c114500281d0a0426394fafb3cdf8587","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, XRichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        textArea.getCommandManager().registerCommand(Command.INSERT_IMAGE, new InsertImageExecutable());\n        if (getTextArea().getCommandManager().isSupported(Command.INSERT_IMAGE)) {\n            image = new PushButton(Images.INSTANCE.image().createImage(), this);\n            image.setTitle(Strings.INSTANCE.image());\n            toolBarExtension.addFeature(\"image\", image);\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getTextArea().addClickListener(this);\n            getUIExtensionList().add(toolBarExtension);\n            selectionPreserver = new SelectionPreserver(textArea);\n            ImageMetaDataExtractor extractor = new ImageMetaDataExtractor();\n            // do the initial extracting on the loaded document\n            extractor.onInnerHTMLChange(getTextArea().getDocument().getDocumentElement());\n            getTextArea().getDocument().addInnerHTMLListener(new ImageMetaDataExtractor());\n\n            // Create an image behavior adjuster for this text area\n            new ImageBehaviorAdjuster(getTextArea());\n        }\n    }","id":76406,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, XRichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        textArea.getCommandManager().registerCommand(Command.INSERT_IMAGE, new InsertImageExecutable());\n        if (getTextArea().getCommandManager().isSupported(Command.INSERT_IMAGE)) {\n            image = new PushButton(Images.INSTANCE.image().createImage(), this);\n            image.setTitle(Strings.INSTANCE.image());\n            toolBarExtension.addFeature(\"image\", image);\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getTextArea().addClickListener(this);\n            getUIExtensionList().add(toolBarExtension);\n            selectionPreserver = new SelectionPreserver(textArea);\n            // Create an image metadata extractor for this text area\n            metaDataExtractor = new ImageMetaDataExtractor();\n            // do the initial extracting on the loaded document\n            metaDataExtractor.onInnerHTMLChange(getTextArea().getDocument().getDocumentElement());\n            getTextArea().getDocument().addInnerHTMLListener(new ImageMetaDataExtractor());\n\n            // Create an image behavior adjuster for this text area\n            behaviorAdjuster = new ImageBehaviorAdjuster();\n            behaviorAdjuster.setTextArea(getTextArea());\n            getTextArea().addKeyboardListener(behaviorAdjuster);\n        }\n    }","commit_id":"40ec16a8c114500281d0a0426394fafb3cdf8587","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#destroy()\n     */\n    public void destroy()\n    {\n        image.removeFromParent();\n        image.removeClickListener(this);\n        image = null;\n\n        imageDialog.hide();\n        imageDialog.removeFromParent();\n        imageDialog = null;\n\n        toolBarExtension.clearFeatures();\n\n        getTextArea().removeClickListener(this);\n\n        super.destroy();\n    }","id":76407,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#destroy()\n     */\n    public void destroy()\n    {\n        image.removeFromParent();\n        image.removeClickListener(this);\n        image = null;\n\n        imageDialog.hide();\n        imageDialog.removeFromParent();\n        imageDialog = null;\n\n        if (toolBarExtension.getFeatures().length > 0) {        \n            toolBarExtension.clearFeatures();\n            getTextArea().removeClickListener(this);\n            // If a metadata extractor was created and setup, remove it\n            if (metaDataExtractor != null) {\n                getTextArea().getDocument().removeInnerHTMLListener(metaDataExtractor);\n                metaDataExtractor = null;\n            }\n            // If a behavior adjuster was created and setup, remove it\n            if (behaviorAdjuster != null) {\n                getTextArea().removeKeyboardListener(behaviorAdjuster);\n                behaviorAdjuster = null;\n            }\n        }\n\n        super.destroy();\n    }","commit_id":"40ec16a8c114500281d0a0426394fafb3cdf8587","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#destroy()\n     */\n    public void destroy()\n    {\n        if (link != null) {\n            link.removeFromParent();\n            link.removeClickListener(this);\n            link = null;\n\n            if (linkDialog != null) {\n                linkDialog.hide();\n                linkDialog.removeFromParent();\n                linkDialog.removePopupListener(this);\n                linkDialog = null;\n            }\n        }\n\n        if (unlink != null) {\n            unlink.removeFromParent();\n            unlink.removeClickListener(this);\n            unlink = null;\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getTextArea().removeClickListener(this);\n            toolBarExtension.clearFeatures();\n        }\n        super.destroy();\n    }","id":76408,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#destroy()\n     */\n    public void destroy()\n    {\n        if (link != null) {\n            link.removeFromParent();\n            link.removeClickListener(this);\n            link = null;\n\n            if (linkDialog != null) {\n                linkDialog.hide();\n                linkDialog.removeFromParent();\n                linkDialog.removePopupListener(this);\n                linkDialog = null;\n            }\n        }\n\n        if (unlink != null) {\n            unlink.removeFromParent();\n            unlink.removeClickListener(this);\n            unlink = null;\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getTextArea().removeClickListener(this);\n            toolBarExtension.clearFeatures();\n            // if a link metadata extractor has been created and setup, remove it\n            if (metaDataExtractor != null) {\n                getTextArea().getDocument().removeInnerHTMLListener(metaDataExtractor);\n                metaDataExtractor = null;\n            }\n        }\n        super.destroy();\n    }","commit_id":"40ec16a8c114500281d0a0426394fafb3cdf8587","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, RichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        if (getTextArea().getCommandManager().isSupported(Command.CREATE_LINK)) {\n            link = new PushButton(Images.INSTANCE.link().createImage(), this);\n            link.setTitle(Strings.INSTANCE.link());\n            toolBarExtension.addFeature(\"link\", link);\n        }\n\n        if (getTextArea().getCommandManager().isSupported(Command.UNLINK)) {\n            unlink = new PushButton(Images.INSTANCE.unlink().createImage(), this);\n            unlink.setTitle(Strings.INSTANCE.unlink());\n            toolBarExtension.addFeature(\"unlink\", unlink);\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getTextArea().addClickListener(this);\n            getUIExtensionList().add(toolBarExtension);\n            selectionPreserver = new SelectionPreserver(textArea);\n            LinkMetaDataExtractor extractor = new LinkMetaDataExtractor();\n            // do the initial extracting on the loaded document\n            extractor.onInnerHTMLChange(getTextArea().getDocument().getDocumentElement());\n            getTextArea().getDocument().addInnerHTMLListener(extractor);\n        }\n    }","id":76409,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, RichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        if (getTextArea().getCommandManager().isSupported(Command.CREATE_LINK)) {\n            link = new PushButton(Images.INSTANCE.link().createImage(), this);\n            link.setTitle(Strings.INSTANCE.link());\n            toolBarExtension.addFeature(\"link\", link);\n        }\n\n        if (getTextArea().getCommandManager().isSupported(Command.UNLINK)) {\n            unlink = new PushButton(Images.INSTANCE.unlink().createImage(), this);\n            unlink.setTitle(Strings.INSTANCE.unlink());\n            toolBarExtension.addFeature(\"unlink\", unlink);\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getTextArea().addClickListener(this);\n            getUIExtensionList().add(toolBarExtension);\n            selectionPreserver = new SelectionPreserver(textArea);\n            // Initialize the metadata extractor, to handle link metadatas\n            metaDataExtractor = new LinkMetaDataExtractor();\n            // do the initial extracting on the loaded document\n            metaDataExtractor.onInnerHTMLChange(getTextArea().getDocument().getDocumentElement());\n            getTextArea().getDocument().addInnerHTMLListener(metaDataExtractor);\n        }\n    }","commit_id":"40ec16a8c114500281d0a0426394fafb3cdf8587","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() != null) {\n        // We only do queue mapping when it's a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId = submissionContext.getApplicationId();\n    ResourceRequest amReq =\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority = rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi = UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn't exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery && YarnConfiguration.isAclEnabled(conf)\n        && scheduler instanceof CapacityScheduler &&\n        !authorizer.checkPermission(new AccessRequest(\n            ((CapacityScheduler) scheduler)\n                .getQueue(submissionContext.getQueue()).getPrivilegedEntity(),\n            userUgi, SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n            submissionContext.getApplicationId().toString(),\n            submissionContext.getApplicationName())) &&\n        !authorizer.checkPermission(new AccessRequest(\n            ((CapacityScheduler) scheduler)\n                .getQueue(submissionContext.getQueue()).getPrivilegedEntity(),\n            userUgi, SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n            submissionContext.getApplicationId().toString(),\n            submissionContext.getApplicationName()))) {\n      throw new AccessControlException(\n          \"User \" + user + \" does not have permission to submit \"\n              + applicationId + \" to queue \" + submissionContext.getQueue());\n    }\n\n    // Create RMApp\n    RMAppImpl application = new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !=\n        null) {\n      String message = \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs = submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }","id":76410,"modified_method":"private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() != null) {\n        // We only do queue mapping when it's a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId = submissionContext.getApplicationId();\n    ResourceRequest amReq =\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority = rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi = UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn't exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery && YarnConfiguration.isAclEnabled(conf)\n        && scheduler instanceof CapacityScheduler) {\n      String queueName = submissionContext.getQueue();\n      String appName = submissionContext.getApplicationName();\n      CSQueue csqueue = ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null != csqueue\n          && !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName))\n          && !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName))) {\n        throw new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue());\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application = new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !=\n        null) {\n      String message = \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs = submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }","commit_id":"3c33158d1cb38ee4ab3baa21752a3cdf0bdc8ccc","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testApplicationACLs() throws Exception {\n\n    verifyOwnerAccess();\n\n    verifySuperUserAccess();\n\n    verifyFriendAccess();\n\n    verifyEnemyAccess();\n\n    verifyAdministerQueueUserAccess();\n  }","id":76411,"modified_method":"@Test\n  public void testApplicationACLs() throws Exception {\n\n    verifyOwnerAccess();\n\n    verifySuperUserAccess();\n\n    verifyFriendAccess();\n\n    verifyEnemyAccess();\n\n    verifyAdministerQueueUserAccess();\n\n    verifyInvalidQueueWithAcl();\n  }","commit_id":"3c33158d1cb38ee4ab3baa21752a3cdf0bdc8ccc","url":"https://github.com/apache/hadoop"},{"original_method":"public synchronized QueueReference getQueueReference() {\n        String key = getComponent().getQueueKey(getEndpointUri());\n        QueueReference ref =  getComponent().getQueueReference(key);\n        if (ref == null) {\n            LOG.warn(\"There was no queue reference for the endpoint {0}\", getEndpointUri());\n        }\n        return ref;\n    }","id":76412,"modified_method":"/**\n     * Get's the {@link QueueReference} for the this endpoint.\n     * @return the reference, or <tt>null<\/tt> if no queue reference exists.\n     */\n    public synchronized QueueReference getQueueReference() {\n        String key = getComponent().getQueueKey(getEndpointUri());\n        QueueReference ref = getComponent().getQueueReference(key);\n        return ref;\n    }","commit_id":"7bd1a7dea8d5e8d441daf991f57c08a3aa3fb3bd","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Strategy method for adding the exchange to the queue.\n     * <p>\n     * Will perform a blocking \"put\" if blockWhenFull is true, otherwise it will\n     * simply add which will throw exception if the queue is full\n     * \n     * @param exchange the exchange to add to the queue\n     */\n    protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableException {\n        QueueReference queueReference = endpoint.getQueueReference();\n        BlockingQueue<Exchange> queue = queueReference.getQueue();\n\n        if (endpoint.isFailIfNoConsumers() && !queueReference.hasConsumers()) {\n            throw new SedaConsumerNotAvailableException(\"No consumers available on endpoint: \" + endpoint, exchange);\n        }\n        if (blockWhenFull) {\n            try {\n                queue.put(exchange);\n            } catch (InterruptedException e) {\n                // ignore\n                log.debug(\"Put interrupted, are we stopping? {}\", isStopping() || isStopped());\n            }\n        } else {\n            queue.add(exchange);\n        }\n    }","id":76413,"modified_method":"/**\n     * Strategy method for adding the exchange to the queue.\n     * <p>\n     * Will perform a blocking \"put\" if blockWhenFull is true, otherwise it will\n     * simply add which will throw exception if the queue is full\n     * \n     * @param exchange the exchange to add to the queue\n     */\n    protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableException {\n        BlockingQueue<Exchange> queue = null;\n        QueueReference queueReference = endpoint.getQueueReference();\n        if (queueReference != null) {\n            queue = queueReference.getQueue();\n        }\n        if (queue == null) {\n            throw new SedaConsumerNotAvailableException(\"No queue available on endpoint: \" + endpoint, exchange);\n        }\n\n        if (endpoint.isFailIfNoConsumers() && !queueReference.hasConsumers()) {\n            throw new SedaConsumerNotAvailableException(\"No consumers available on endpoint: \" + endpoint, exchange);\n        }\n        if (blockWhenFull) {\n            try {\n                queue.put(exchange);\n            } catch (InterruptedException e) {\n                // ignore\n                log.debug(\"Put interrupted, are we stopping? {}\", isStopping() || isStopped());\n            }\n        } else {\n            queue.add(exchange);\n        }\n    }","commit_id":"7bd1a7dea8d5e8d441daf991f57c08a3aa3fb3bd","url":"https://github.com/apache/camel"},{"original_method":"public ControllerDynamicMethods( GroovyObject controller,GrailsControllerHelper helper,final HttpServletRequest request, HttpServletResponse response) throws IntrospectionException {\n        super(controller);\n\n        this.controllerClass = helper.getControllerClassByName(controller.getClass().getName());\n        this.grailsAttributes = helper.getGrailsAttributes();\n\n        // add dynamic properties\n        addDynamicProperty(new GetParamsDynamicProperty(request,response));\n        addDynamicProperty(new GetSessionDynamicProperty(request,response));\n        addDynamicProperty(new GenericDynamicProperty(REQUEST_PROPERTY, HttpServletRequest.class,new GrailsHttpServletRequest( request,controller),true) );\n        addDynamicProperty(new GenericDynamicProperty(RESPONSE_PROPERTY, HttpServletResponse.class,response,true) );\n        addDynamicProperty(new GenericDynamicProperty(SERVLET_CONTEXT, ServletContext.class,helper.getServletContext(),true) );\n        addDynamicProperty(new GenericDynamicProperty(FLASH_SCOPE_PROPERTY, FlashScope.class,grailsAttributes.getFlashScope(request),false) );\n        addDynamicProperty(new GenericDynamicProperty(ERRORS_PROPERTY, Errors.class, null, false));\n        addDynamicProperty(new GenericDynamicProperty(MODEL_AND_VIEW_PROPERTY, ModelAndView.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(GRAILS_ATTRIBUTES, GrailsApplicationAttributes.class,grailsAttributes,true));\n        addDynamicProperty(new GenericDynamicProperty(GRAILS_APPLICATION, GrailsApplication.class,grailsAttributes.getGrailsApplication(),true));\n        addDynamicProperty(new GenericDynamicProperty(ACTION_URI_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(CONTROLLER_URI_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(ACTION_NAME_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(CONTROLLER_NAME_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(RENDER_VIEW_PROPERTY,Boolean.class, Boolean.TRUE,false));\n        addDynamicProperty(new GenericDynamicProperty(LOG_PROPERTY, Log.class,\n            LogFactory.getLog(controllerClass.getFullName()),true));\n\n        // add dynamic methods\n        addDynamicMethodInvocation( new RedirectDynamicMethod(helper,request,response) );\n        addDynamicMethodInvocation( new ChainDynamicMethod(helper, request, response ) );\n        addDynamicMethodInvocation( new RenderDynamicMethod(helper,request,response));\n        addDynamicMethodInvocation( new BindDynamicMethod(request,response));\n\n        // the getViewUri(name,request) method that retrieves the name of a view for current controller\n        addDynamicMethodInvocation( new AbstractDynamicMethodInvocation(GET_VIEW_URI_PATTERN){\n\n            public Object invoke(Object target, Object[] arguments) {\n                if(arguments.length==0)\n                    throw new MissingMethodException(GET_VIEW_URI,target.getClass(),arguments);\n                if(arguments[0] == null)\n                    throw new IllegalArgumentException(\"Argument [viewName] of method [\" + GET_VIEW_URI + \"] cannot be null\");\n\n                return grailsAttributes.getViewUri(arguments[0].toString(), request);\n            }\n\n        });\n\n        // the getTemplateUri(name,request) method that retrieves the name of a template for current controller        \n        addDynamicMethodInvocation( new AbstractDynamicMethodInvocation(GET_TEMPLATE_URI_PATTERN){\n\n            public Object invoke(Object target, Object[] arguments) {\n                if(arguments.length==0)\n                    throw new MissingMethodException(GET_TEMPLATE_URI,target.getClass(),arguments);\n                if(arguments[0] == null)\n                    throw new IllegalArgumentException(\"Argument [templateName] of method [\" + GET_TEMPLATE_URI + \"] cannot be null\");\n\n                return grailsAttributes.getTemplateUri(arguments[0].toString(),request);\n            }\n\n        });\n\n        // the hasErrors() dynamic method that checks of there are any errors in the controller\n        addDynamicMethodInvocation( new AbstractDynamicMethodInvocation(HAS_ERRORS_METHOD_PATTERN) {\n            public Object invoke(Object target, Object[] arguments) {\n                GroovyObject controller = (GroovyObject)target;\n                Errors errors = (Errors)controller.getProperty(ERRORS_PROPERTY);\n                return Boolean.valueOf(errors.hasErrors());\n            }\n        });\n\n        this.scaffolding = this.controllerClass.isScaffolding();\n\n        // if the controller is scaffolding get the scaffolder, then loop through all the\n        // support actions by the scaffolder and register dynamic properties for those that don't exist\n        if(this.scaffolding) {\n            this.scaffolder = helper.getScaffolderForController(controllerClass.getFullName());\n            if(this.scaffolder == null) {\n                throw new IllegalStateException(\"Scaffolder is null when controller scaffold property is set to 'true'\");\n            }\n            String[] scaffoldActions = this.scaffolder.getSupportedActionNames();\n            for (int i = 0; i < scaffoldActions.length; i++) {\n                try {\n                    controller.getProperty(scaffoldActions[i]);\n                }\n                catch(MissingPropertyException mpe) {\n                    addDynamicProperty(new GenericDynamicProperty(\tscaffoldActions[i],\n                                                                    Closure.class,\n                                                                    scaffolder.getAction(controller,scaffoldActions[i]),\n                                                                    true));\n                }\n            }\n        }\n    }","id":76414,"modified_method":"public ControllerDynamicMethods( GroovyObject controller,GrailsControllerHelper helper,final HttpServletRequest request, HttpServletResponse response) throws IntrospectionException {\n        super(controller);\n\n        this.controllerClass = helper.getControllerClassByName(controller.getClass().getName());\n        this.grailsAttributes = helper.getGrailsAttributes();\n\n        // add dynamic properties\n        addDynamicProperty(new GetParamsDynamicProperty(request,response));\n        addDynamicProperty(new GetSessionDynamicProperty(request,response));\n        addDynamicProperty(new GenericDynamicProperty(REQUEST_PROPERTY, HttpServletRequest.class,new GrailsHttpServletRequest( request,controller),true) );\n        addDynamicProperty(new GenericDynamicProperty(RESPONSE_PROPERTY, HttpServletResponse.class,response,true) );\n        addDynamicProperty(new GenericDynamicProperty(SERVLET_CONTEXT, ServletContext.class,helper.getServletContext(),true) );\n        addDynamicProperty(new GenericDynamicProperty(FLASH_SCOPE_PROPERTY, FlashScope.class,grailsAttributes.getFlashScope(request),false) );\n        addDynamicProperty(new GenericDynamicProperty(ERRORS_PROPERTY, Errors.class, null, false));\n        addDynamicProperty(new GenericDynamicProperty(MODEL_AND_VIEW_PROPERTY, ModelAndView.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(GRAILS_ATTRIBUTES, GrailsApplicationAttributes.class,grailsAttributes,true));\n        addDynamicProperty(new GenericDynamicProperty(GRAILS_APPLICATION, GrailsApplication.class,grailsAttributes.getGrailsApplication(),true));\n        addDynamicProperty(new GenericDynamicProperty(ACTION_URI_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(CONTROLLER_URI_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(ACTION_NAME_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(CONTROLLER_NAME_PROPERTY,String.class,null,false));\n        addDynamicProperty(new GenericDynamicProperty(RENDER_VIEW_PROPERTY,Boolean.class, Boolean.TRUE,false));\n        addDynamicProperty(new GenericDynamicProperty(LOG_PROPERTY, Log.class,\n            LogFactory.getLog(controllerClass.getFullName()),true));\n\n        // add dynamic methods\n        addDynamicMethodInvocation( new RedirectDynamicMethod(helper,request,response) );\n        addDynamicMethodInvocation( new ChainDynamicMethod(helper, request, response ) );\n        addDynamicMethodInvocation( new RenderDynamicMethod(helper,request,response));\n        addDynamicMethodInvocation( new BindDynamicMethod(request,response));\n\n        // the getViewUri(name,request) method that retrieves the name of a view for current controller\n        addDynamicMethodInvocation( new AbstractDynamicMethodInvocation(GET_VIEW_URI_PATTERN){\n\n            public Object invoke(Object target, Object[] arguments) {\n                if(arguments.length==0)\n                    throw new MissingMethodException(GET_VIEW_URI,target.getClass(),arguments);\n                if(arguments[0] == null)\n                    throw new IllegalArgumentException(\"Argument [viewName] of method [\" + GET_VIEW_URI + \"] cannot be null\");\n\n                return grailsAttributes.getViewUri(arguments[0].toString(), request);\n            }\n\n        });\n\n        // the getTemplateUri(name,request) method that retrieves the name of a template for current controller        \n        addDynamicMethodInvocation( new AbstractDynamicMethodInvocation(GET_TEMPLATE_URI_PATTERN){\n\n            public Object invoke(Object target, Object[] arguments) {\n                if(arguments.length==0)\n                    throw new MissingMethodException(GET_TEMPLATE_URI,target.getClass(),arguments);\n                if(arguments[0] == null)\n                    throw new IllegalArgumentException(\"Argument [templateName] of method [\" + GET_TEMPLATE_URI + \"] cannot be null\");\n\n                return grailsAttributes.getTemplateUri(arguments[0].toString(),request);\n            }\n\n        });\n\n        // the hasErrors() dynamic method that checks of there are any errors in the controller\n        addDynamicMethodInvocation( new AbstractDynamicMethodInvocation(HAS_ERRORS_METHOD_PATTERN) {\n            public Object invoke(Object target, Object[] arguments) {\n                GroovyObject controller = (GroovyObject)target;\n                Errors errors = (Errors)controller.getProperty(ERRORS_PROPERTY);\n                return Boolean.valueOf(errors.hasErrors());\n            }\n        });\n\n        this.scaffolding = this.controllerClass.isScaffolding();\n\n        // if the controller is scaffolding get the scaffolder, then loop through all the\n        // support actions by the scaffolder and register dynamic properties for those that don't exist\n        if(this.scaffolding) {\n            this.scaffolder = helper.getScaffolderForController(controllerClass.getFullName());\n            if(this.scaffolder == null) {\n                throw new IllegalStateException(\"Scaffolder is null when controller scaffold property is set to 'true'\");\n            }\n            String[] scaffoldActions = this.scaffolder.getSupportedActionNames();\n            for (int i = 0; i < scaffoldActions.length; i++) {\n            \tMap properties = DefaultGroovyMethods.getProperties(controller);\n            \tif(!properties.containsKey(scaffoldActions[i])) {\n                    addDynamicProperty(new GenericDynamicProperty(\tscaffoldActions[i],\n                                                                    Closure.class,\n                                                                    scaffolder.getAction(controller,scaffoldActions[i]),\n                                                                    true));\n                }\n            }\n        }\n    }","commit_id":"a48f9fd4652e0de8accb2b9b0e0da10d193553a0","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Get the value of the named property, with support for static properties in both Java and Groovy classes\n     * (which as of Groovy JSR 1.0 RC 01 only have getters in the metaClass)\n     * @param name\n     * @param type\n     * @return The property value or null\n     */\n    protected Object getPropertyValue(String name, Class type) {\n\n        // Handle standard java beans normal or static properties\n        BeanWrapper ref = getReference();\n        Object value = null;\n        if (ref.isReadableProperty(name)) {\n            value = ref.getPropertyValue(name);\n        }\n        else{\n            // Groovy workaround\n            Object inst = ref.getWrappedInstance();\n            if (inst instanceof GroovyObject)\n            {\n            \t\n                try {\n\t\t\t\t\tvalue = ((GroovyObject)inst).getProperty(name);\n\t\t\t\t} catch (MissingPropertyException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n            }\n        }\n\n        if(value != null && (type.isAssignableFrom(value.getClass())\n            || GrailsClassUtils.isMatchBetweenPrimativeAndWrapperTypes(type, value.getClass()))) {\n            return value;\n        }\n        else\n        {\n            return null;\n        }\n    }","id":76415,"modified_method":"/**\n     * Get the value of the named property, with support for static properties in both Java and Groovy classes\n     * (which as of Groovy JSR 1.0 RC 01 only have getters in the metaClass)\n     * @param name\n     * @param type\n     * @return The property value or null\n     */\n    protected Object getPropertyValue(String name, Class type) {\n\n        // Handle standard java beans normal or static properties\n        BeanWrapper ref = getReference();\n        Object value = null;\n        if (ref.isReadableProperty(name)) {\n            value = ref.getPropertyValue(name);\n        }\n        else{\n            // Groovy workaround\n            Object inst = ref.getWrappedInstance();\n            if (inst instanceof GroovyObject)\n            {\n            \tfinal Map properties = DefaultGroovyMethods.getProperties(inst);\n            \tif(properties.containsKey(name)) {\n            \t\tvalue = properties.get(name);\n            \t}\n            }\n        }\n\n        if(value != null && (type.isAssignableFrom(value.getClass())\n            || GrailsClassUtils.isMatchBetweenPrimativeAndWrapperTypes(type, value.getClass()))) {\n            return value;\n        }\n        else\n        {\n            return null;\n        }\n    }","commit_id":"c55bbeca1d3d8f2a94454d98ecaf3a33107b86bd","url":"https://github.com/grails/grails-core"},{"original_method":"protected int doStartTagInternal() {\n      GroovyObject tagLib = getTagLib(getTagName());\n        if(tagLib != null) {\n            sw = new StringWriter();\n            out = new PrintWriter(sw);\n            tagLib.setProperty( TagLibDynamicMethods.OUT_PROPERTY, out );\n            Object tagLibProp;\n            try {\n                tagLibProp = tagLib.getProperty(getTagName());\n            } catch (MissingPropertyException mpe) {\n                throw new GrailsTagException(\"Tag [\"+getTagName()+\"] does not exist in tag library [\"+tagLib.getClass().getName()+\"]\");\n            }\n            if(tagLibProp instanceof Closure) {\n                Closure body = new Closure(this) {\n                    public Object doCall() {\n                        return call();\n                    }\n                    public Object doCall(Object o) {\n                        return call(new Object[]{o});\n                    }\n                    public Object doCall(Object[] args) {\n                        return call(args);\n                    }\n                    public Object call(Object[] args) {\n                        invocationCount++;\n                        if(args.length > 0) {\n                            invocationArgs.add(args[0]);\n                        }\n                        else {\n                            invocationArgs.add(ZERO_ARGUMENTS);\n                        }\n                        out.print(\"<jsp-body-gen\"+invocationCount+\">\");\n                        return null;\n                    }\n                };\n                Closure tag = (Closure)tagLibProp;\n                if(tag.getParameterTypes().length == 1) {\n                    tag.call( new Object[]{ attributes });\n                    if(body != null) {\n                        body.call();\n                    }\n                }\n                if(tag.getParameterTypes().length == 2) {\n                    tag.call( new Object[] { attributes, body });\n                }\n            }else {\n               throw new GrailsTagException(\"Tag [\"+getTagName()+\"] does not exist in tag library [\"+tagLib.getClass().getName()+\"]\");\n            }\n        }\n        else {\n            throw new GrailsTagException(\"Tag [\"+getTagName()+\"] does not exist. No tag library found.\");\n        }\n\n        Collections.reverse(invocationArgs);\n        setCurrentArgument();\n        return EVAL_BODY_BUFFERED;\n    }","id":76416,"modified_method":"protected int doStartTagInternal() {\n      GroovyObject tagLib = getTagLib(getTagName());\n        if(tagLib != null) {\n            sw = new StringWriter();\n            out = new PrintWriter(sw);\n            tagLib.setProperty( TagLibDynamicMethods.OUT_PROPERTY, out );\n            Object tagLibProp;\n            final Map tagLibProperties = DefaultGroovyMethods.getProperties(tagLib);\n            if(tagLibProperties.containsKey(getTagName())) {\n                tagLibProp = tagLibProperties.get(getTagName());\n            } else {\n                throw new GrailsTagException(\"Tag [\"+getTagName()+\"] does not exist in tag library [\"+tagLib.getClass().getName()+\"]\");\n            }\n            if(tagLibProp instanceof Closure) {\n                Closure body = new Closure(this) {\n                    public Object doCall() {\n                        return call();\n                    }\n                    public Object doCall(Object o) {\n                        return call(new Object[]{o});\n                    }\n                    public Object doCall(Object[] args) {\n                        return call(args);\n                    }\n                    public Object call(Object[] args) {\n                        invocationCount++;\n                        if(args.length > 0) {\n                            invocationArgs.add(args[0]);\n                        }\n                        else {\n                            invocationArgs.add(ZERO_ARGUMENTS);\n                        }\n                        out.print(\"<jsp-body-gen\"+invocationCount+\">\");\n                        return null;\n                    }\n                };\n                Closure tag = (Closure)tagLibProp;\n                if(tag.getParameterTypes().length == 1) {\n                    tag.call( new Object[]{ attributes });\n                    if(body != null) {\n                        body.call();\n                    }\n                }\n                if(tag.getParameterTypes().length == 2) {\n                    tag.call( new Object[] { attributes, body });\n                }\n            }else {\n               throw new GrailsTagException(\"Tag [\"+getTagName()+\"] does not exist in tag library [\"+tagLib.getClass().getName()+\"]\");\n            }\n        }\n        else {\n            throw new GrailsTagException(\"Tag [\"+getTagName()+\"] does not exist. No tag library found.\");\n        }\n\n        Collections.reverse(invocationArgs);\n        setCurrentArgument();\n        return EVAL_BODY_BUFFERED;\n    }","commit_id":"c55bbeca1d3d8f2a94454d98ecaf3a33107b86bd","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n\tpublic ToBeBuilt updateProject(final IProject project, IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 2);\n\t\tfinal ToBeBuilt toBeBuilt = super.updateProject(project, progress.newChild(1));\n\t\tif (!project.isAccessible() || progress.isCanceled())\n\t\t\treturn toBeBuilt;\n\t\tIJavaProject javaProject = JavaCore.create(project);\n\t\tif (javaProject.exists()) {\n\t\t\tIPackageFragmentRoot[] roots = javaProject.getPackageFragmentRoots();\n\t\t\tprogress.setWorkRemaining(roots.length);\n\t\t\tfinal Map<String, Long> updated = Maps.newHashMap();\n\t\t\tProjectOrder orderedProjects = ResourcesPlugin.getWorkspace().computeProjectOrder(ResourcesPlugin.getWorkspace().getRoot().getProjects());\n\t\t\tfor (final IPackageFragmentRoot root : roots) {\n\t\t\t\tif (progress.isCanceled())\n\t\t\t\t\treturn toBeBuilt;\n\t\t\t\tif (shouldHandle(root) && !isBuiltByUpstream(root, project, orderedProjects.projects)) {\n\t\t\t\t\tMap<URI, IStorage> rootData = storage2UriMapperJavaImpl.getAllEntries(root);\n\t\t\t\t\ttoBeBuilt.getToBeDeleted().addAll(rootData.keySet());\n\t\t\t\t\ttoBeBuilt.getToBeUpdated().addAll(rootData.keySet());\n\t\t\t\t}\n\t\t\t\tprogress.worked(1);\n\t\t\t}\n\t\t\tsynchronized (modificationStampCache) {\n\t\t\t\tmodificationStampCache.projectToModificationStamp.putAll(updated);\n\t\t\t}\n\t\t}\n\t\treturn toBeBuilt;\n\t}","id":76417,"modified_method":"@Override\n\tpublic ToBeBuilt updateProject(final IProject project, IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 2);\n\t\tfinal ToBeBuilt toBeBuilt = super.updateProject(project, progress.newChild(1));\n\t\tif (!project.isAccessible() || progress.isCanceled())\n\t\t\treturn toBeBuilt;\n\t\tIJavaProject javaProject = JavaCore.create(project);\n\t\tif (javaProject.exists()) {\n\t\t\tIPackageFragmentRoot[] roots = javaProject.getPackageFragmentRoots();\n\t\t\tprogress.setWorkRemaining(roots.length);\n\t\t\tfinal Map<String, Long> updated = Maps.newHashMap();\n\t\t\tProjectOrder orderedProjects = ResourcesPlugin.getWorkspace().computeProjectOrder(ResourcesPlugin.getWorkspace().getRoot().getProjects());\n\t\t\tfor (final IPackageFragmentRoot root : roots) {\n\t\t\t\tif (progress.isCanceled())\n\t\t\t\t\treturn toBeBuilt;\n\t\t\t\tif (shouldHandle(root) && !isBuiltByUpstream(root, project, orderedProjects.projects)) {\n\t\t\t\t\tMap<URI, IStorage> rootData = storage2UriMapperJavaImpl.getAllEntries(root);\n\t\t\t\t\tfor (Map.Entry<URI, IStorage> e : rootData.entrySet())\n\t\t\t\t\t\tif (uriValidator.canBuild(e.getKey(), e.getValue())) {\n\t\t\t\t\t\t\ttoBeBuilt.getToBeDeleted().add(e.getKey());\n\t\t\t\t\t\t\ttoBeBuilt.getToBeUpdated().add(e.getKey());\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprogress.worked(1);\n\t\t\t}\n\t\t\tsynchronized (modificationStampCache) {\n\t\t\t\tmodificationStampCache.projectToModificationStamp.putAll(updated);\n\t\t\t}\n\t\t}\n\t\treturn toBeBuilt;\n\t}","commit_id":"c91a35ad4312b76fe26dd5e680ba16036070c6d5","url":"https://github.com/eclipse/xtext"},{"original_method":"public PortletPreferenceImpl(PortletPreference portletPreference) {\n        this.portletPreferenceId = -1;\n        this.entityVersion = -1;\n        this.name = portletPreference.getName();\n        this.readOnly = portletPreference.isReadOnly();\n\n        final String[] values = portletPreference.getValues();\n        this.setValues(values);\n    }","id":76418,"modified_method":"public PortletPreferenceImpl(PortletPreference portletPreference) {\n        if (portletPreference.getName() == null) {\n            throw new IllegalArgumentException(\"name cannot be null\");\n        }\n        \n        this.portletPreferenceId = -1;\n        this.entityVersion = -1;\n        this.name = portletPreference.getName();\n        this.readOnly = portletPreference.isReadOnly();\n\n        final String[] values = portletPreference.getValues();\n        this.setValues(values);\n    }","commit_id":"29001610d9b1987510ad7749760bfe64fd4bf5f4","url":"https://github.com/Jasig/uPortal"},{"original_method":"public PortletPreferenceImpl(Preference preference) {\n    \tthis.portletPreferenceId = -1;\n    \tthis.entityVersion = -1;\n    \tthis.name = preference.getName();\n    \tthis.readOnly = preference.isReadOnly();\n    \t\n    \tthis.setValues(preference.getValues().toArray(new String[]{}));\n    }","id":76419,"modified_method":"public PortletPreferenceImpl(Preference preference) {\n        if (preference.getName() == null) {\n            throw new IllegalArgumentException(\"name cannot be null\");\n        }\n        \n        this.portletPreferenceId = -1;\n    \tthis.entityVersion = -1;\n    \tthis.name = preference.getName();\n    \tthis.readOnly = preference.isReadOnly();\n    \t\n    \tthis.setValues(preference.getValues().toArray(new String[]{}));\n    }","commit_id":"29001610d9b1987510ad7749760bfe64fd4bf5f4","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public void setValues(String[] values) {\n        if (values == null) {\n            this.values = null;\n        }\n        else if (this.values == null) {\n            this.values = new ArrayList<String>(Arrays.asList(values));\n        }\n        else {\n            this.values.clear();\n            this.values.addAll(Arrays.asList(values));\n        }\n    }","id":76420,"modified_method":"@Override\n    public void setValues(String[] values) {\n        if (values == null) {\n            this.values = null;\n            this.nullValues = true;\n        }\n        else if (this.values == null) {\n            this.values = new ArrayList<String>(Arrays.asList(values));\n            this.nullValues = false;\n        }\n        else {\n            this.nullValues = false;\n            this.values.clear();\n            for (final String value : values) {\n                if (value == null) {\n                    this.values.add(NULL_MARKER);\n                }\n                else {\n                    this.values.add(BaseNullSafeStringType.NOT_NULL_PREFIX + value);\n                }\n            }\n        }\n    }","commit_id":"29001610d9b1987510ad7749760bfe64fd4bf5f4","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public String[] getValues() {\n        if (this.values == null) {\n            return null;\n        }\n\n        return this.values.toArray(new String[this.values.size()]);\n    }","id":76421,"modified_method":"@Override\n    public String[] getValues() {\n        if (this.nullValues || this.values == null) {\n            return null;\n        }\n\n        final String[] valuesArray = new String[this.values.size()];\n        int index = 0;\n        for (final String value : this.values) {\n            if (NULL_MARKER.equals(value)) {\n                valuesArray[index++] = null;\n            }\n            else {\n                valuesArray[index++] = value.substring(1);\n            }\n        }\n        return valuesArray;\n    }","commit_id":"29001610d9b1987510ad7749760bfe64fd4bf5f4","url":"https://github.com/Jasig/uPortal"},{"original_method":"public PortletPreferenceImpl(PortletPreferenceImpl portletPreference) {\n        this.portletPreferenceId = -1;\n        this.entityVersion = -1;\n        this.name = portletPreference.getName();\n        this.readOnly = portletPreference.isReadOnly();\n        this.setValues(portletPreference.getValues());\n    }","id":76422,"modified_method":"public PortletPreferenceImpl(PortletPreferenceImpl portletPreference) {\n        if (portletPreference.getName() == null) {\n            throw new IllegalArgumentException(\"name cannot be null\");\n        }\n        \n        this.portletPreferenceId = -1;\n        this.entityVersion = -1;\n        this.name = portletPreference.getName();\n        this.readOnly = portletPreference.isReadOnly();\n        this.setValues(portletPreference.getValues());\n    }","commit_id":"29001610d9b1987510ad7749760bfe64fd4bf5f4","url":"https://github.com/Jasig/uPortal"},{"original_method":"public PortletPreferenceImpl(String name, boolean readOnly, String... values) {\n        this.portletPreferenceId = -1;\n        this.entityVersion = -1;\n        this.name = name;\n        this.readOnly = readOnly;\n        this.setValues(values);\n    }","id":76423,"modified_method":"public PortletPreferenceImpl(String name, boolean readOnly, String... values) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name cannot be null\");\n        }\n        \n        this.portletPreferenceId = -1;\n        this.entityVersion = -1;\n        this.name = name;\n        this.readOnly = readOnly;\n        this.setValues(values);\n    }","commit_id":"29001610d9b1987510ad7749760bfe64fd4bf5f4","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public void store(PortletWindow plutoPortletWindow, PortletRequest portletRequest, Map<String,PortletPreference> newPreferences) throws PortletContainerException {\n        final HttpServletRequest httpServletRequest = this.portalRequestUtils.getPortletHttpRequest(portletRequest);\n        \n        //Determine if the user is a guest\n        final boolean isGuest = isGuestUser(portletRequest);\n        \n        //If this is a guest and no prefs are being stored just return as the rest of the method is not needed for this case\n        if (isGuest && !(this.isStoreInEntity(portletRequest) || this.isStoreInMemory(portletRequest))) {\n            return;\n        }\n\n        final IPortletWindow portletWindow = this.portletWindowRegistry.convertPortletWindow(httpServletRequest, plutoPortletWindow);\n        IPortletEntity portletEntity = portletWindow.getPortletEntity();\n        final IPortletEntityId portletEntityId = portletEntity.getPortletEntityId();\n        final IPortletDefinition portletDefinition = portletEntity.getPortletDefinition();\n        final PortletDefinition portletDescriptor = this.portletDefinitionRegistry.getParentPortletDescriptor(portletDefinition.getPortletDefinitionId());\n\n        //Is this CONFIG mode\n        final boolean configMode = IPortletRenderer.CONFIG.equals(portletWindow.getPortletMode());\n        \n        //Get Map of descriptor and definition preferences to check new preferences against\n        final Map<String, PortletPreference> basePreferences = new HashMap<String, PortletPreference>();\n        \n        //Add deploy preferences\n        final List<IPortletPreference> descriptorPreferencesList = this.getDescriptorPreferences(portletDescriptor);\n        this.addPreferencesToMap(descriptorPreferencesList, basePreferences);\n  \n        //Get the definition and entity preferences objects\n        final IPortletPreferences definitionPreferences = portletDefinition.getPortletPreferences();\n        \n        final Lock prefLock;\n        if (configMode) {\n            //In config mode we don't worry about locking\n            prefLock = NoopLock.INSTANCE;\n        }\n        else {\n            prefLock = this.portletEntityRegistry.getPortletEntityLock(httpServletRequest, portletEntityId);\n        }\n\n        //Do a tryLock firsrt so that we can warn about concurrent preference modification if it fails\n        boolean locked = prefLock.tryLock();\n        try {\n            if (!locked) {\n                logger.warn(\"Concurrent portlet preferences modification by: \" + portletDefinition.getFName() +  \" \" +\n                        \"This has the potential for changes to preferences to be lost. \" +\n                        \"This portlet should be modified to synchronize its preference modifications appropriately\", new Throwable());\n                \n                prefLock.lock();\n                locked = true;\n                \n                //Refresh the portlet entity that may have been changed by the thread we were blocked by\n                if (!configMode) {\n                    portletEntity = this.portletEntityRegistry.getPortletEntity(httpServletRequest, portletEntityId);\n                }\n            }\n            \n            //Add definition preferences if not config mode\n            if (!configMode) {\n                final List<IPortletPreference> definitionPreferencesList = definitionPreferences.getPortletPreferences();\n                this.addPreferencesToMap(definitionPreferencesList, basePreferences);\n            }\n\n            final List<IPortletPreference> preferencesList = new ArrayList<IPortletPreference>(newPreferences.size());\n        \n            for (final PortletPreference internalPreference : newPreferences.values()) {\n                //Ignore preferences with null names\n                final String name = internalPreference.getName();\n                if (name == null) {\n                    continue;\n                }\n    \n                //Convert to a uPortal preference class to ensure quality check and persistence works\n                final IPortletPreference preference = new PortletPreferenceImpl(internalPreference);\n                \n                //If the preference exactly equals a descriptor or definition preference ignore it\n                final PortletPreference basePreference = basePreferences.get(name);\n                if (preference.equals(basePreference)) {\n                    continue;\n                }\n                \n                //New preference, add it to the list\n                preferencesList.add(preference);\n            }\n        \n            //If in config mode store the preferences on the definition\n            if (configMode) {\n                definitionPreferences.setPortletPreferences(preferencesList);\n                this.portletDefinitionRegistry.updatePortletDefinition(portletDefinition);\n            }\n            //If not a guest or if guest prefs are shared store them on the entity\n            else if (this.isStoreInEntity(portletRequest)) {\n                //Update the portlet entity with the new preferences\n                final IPortletPreferences entityPreferences = portletEntity.getPortletPreferences();\n                entityPreferences.setPortletPreferences(preferencesList);\n                this.portletEntityRegistry.storePortletEntity(httpServletRequest, portletEntity);\n            }\n            //Must be a guest and share must be off so store the prefs on the session\n            else {\n                //Store memory preferences\n                this.storeSessionPreferences(portletEntityId, httpServletRequest, preferencesList);\n            }\n        }\n        finally {\n            //check if locked, needed due to slighly more complex logic around the tryLock and logging\n            if (locked) {\n                prefLock.unlock();\n            }\n        }\n    }","id":76424,"modified_method":"@Transactional\n\t@Override\n    public void store(PortletWindow plutoPortletWindow, PortletRequest portletRequest, Map<String,PortletPreference> newPreferences) throws PortletContainerException {\n        final HttpServletRequest httpServletRequest = this.portalRequestUtils.getPortletHttpRequest(portletRequest);\n        \n        //Determine if the user is a guest\n        final boolean isGuest = isGuestUser(portletRequest);\n        \n        //If this is a guest and no prefs are being stored just return as the rest of the method is not needed for this case\n        if (isGuest && !(this.isStoreInEntity(portletRequest) || this.isStoreInMemory(portletRequest))) {\n            return;\n        }\n\n        final IPortletWindow portletWindow = this.portletWindowRegistry.convertPortletWindow(httpServletRequest, plutoPortletWindow);\n        IPortletEntity portletEntity = portletWindow.getPortletEntity();\n        final IPortletEntityId portletEntityId = portletEntity.getPortletEntityId();\n        final IPortletDefinition portletDefinition = portletEntity.getPortletDefinition();\n        final PortletDefinition portletDescriptor = this.portletDefinitionRegistry.getParentPortletDescriptor(portletDefinition.getPortletDefinitionId());\n\n        //Is this CONFIG mode\n        final boolean configMode = IPortletRenderer.CONFIG.equals(portletWindow.getPortletMode());\n        \n        //Get Map of descriptor and definition preferences to check new preferences against\n        final Map<String, PortletPreference> basePreferences = new HashMap<String, PortletPreference>();\n        \n        //Add deploy preferences\n        final List<IPortletPreference> descriptorPreferencesList = this.getDescriptorPreferences(portletDescriptor);\n        this.addPreferencesToMap(descriptorPreferencesList, basePreferences);\n  \n        //Get the definition and entity preferences objects\n        final IPortletPreferences definitionPreferences = portletDefinition.getPortletPreferences();\n        \n        final Lock prefLock;\n        if (configMode) {\n            //In config mode we don't worry about locking\n            prefLock = NoopLock.INSTANCE;\n        }\n        else {\n            prefLock = this.portletEntityRegistry.getPortletEntityLock(httpServletRequest, portletEntityId);\n        }\n\n        //Do a tryLock firsrt so that we can warn about concurrent preference modification if it fails\n        boolean locked = prefLock.tryLock();\n        try {\n            if (!locked) {\n                logger.warn(\"Concurrent portlet preferences modification by: \" + portletDefinition.getFName() +  \" \" +\n                        \"This has the potential for changes to preferences to be lost. \" +\n                        \"This portlet should be modified to synchronize its preference modifications appropriately\", new Throwable());\n                \n                prefLock.lock();\n                locked = true;\n                \n                //Refresh the portlet entity that may have been changed by the thread we were blocked by\n                if (!configMode) {\n                    portletEntity = this.portletEntityRegistry.getPortletEntity(httpServletRequest, portletEntityId);\n                }\n            }\n            \n            //Add definition preferences if not config mode\n            if (!configMode) {\n                final List<IPortletPreference> definitionPreferencesList = definitionPreferences.getPortletPreferences();\n                this.addPreferencesToMap(definitionPreferencesList, basePreferences);\n            }\n\n            final List<IPortletPreference> preferencesList = new ArrayList<IPortletPreference>(newPreferences.size());\n        \n            for (final PortletPreference internalPreference : newPreferences.values()) {\n                //Ignore preferences with null names\n                final String name = internalPreference.getName();\n                if (name == null) {\n                    throw new IllegalArgumentException(\"PortletPreference name cannot be null\");\n                }\n    \n                //Convert to a uPortal preference class to ensure quality check and persistence works\n                final IPortletPreference preference = new PortletPreferenceImpl(internalPreference);\n                \n                //If the preference exactly equals a descriptor or definition preference ignore it\n                final PortletPreference basePreference = basePreferences.get(name);\n                if (preference.equals(basePreference)) {\n                    continue;\n                }\n                \n                //New preference, add it to the list\n                preferencesList.add(preference);\n            }\n        \n            //If in config mode store the preferences on the definition\n            if (configMode) {\n                definitionPreferences.setPortletPreferences(preferencesList);\n                this.portletDefinitionRegistry.updatePortletDefinition(portletDefinition);\n            }\n            //If not a guest or if guest prefs are shared store them on the entity\n            else if (this.isStoreInEntity(portletRequest)) {\n                //Update the portlet entity with the new preferences\n                final IPortletPreferences entityPreferences = portletEntity.getPortletPreferences();\n                entityPreferences.setPortletPreferences(preferencesList);\n                this.portletEntityRegistry.storePortletEntity(httpServletRequest, portletEntity);\n            }\n            //Must be a guest and share must be off so store the prefs on the session\n            else {\n                //Store memory preferences\n                this.storeSessionPreferences(portletEntityId, httpServletRequest, preferencesList);\n            }\n        }\n        finally {\n            //check if locked, needed due to slighly more complex logic around the tryLock and logging\n            if (locked) {\n                prefLock.unlock();\n            }\n        }\n    }","commit_id":"29001610d9b1987510ad7749760bfe64fd4bf5f4","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void disposeComponent() {\n    LibraryInitializer.getInstance().removeContributor(this);\n    LibraryInitializer.getInstance().update();\n  }","id":76425,"modified_method":"public void disposeComponent() {\n    LibraryInitializer.getInstance().removeContributor(this);\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        LibraryInitializer.getInstance().update();\n      }\n    });\n  }","commit_id":"e5a784fde2aaff542436682c0157f1d6b5936451","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void initComponent() {\n    LibraryInitializer.getInstance().addContributor(this);\n  }","id":76426,"modified_method":"public void initComponent() {\n    LibraryInitializer.getInstance().addContributor(this);\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        LibraryInitializer.getInstance().update();\n      }\n    });\n  }","commit_id":"e5a784fde2aaff542436682c0157f1d6b5936451","url":"https://github.com/JetBrains/MPS"},{"original_method":"public LibraryManager(MPSModuleRepository repo) {\n    super(repo);\n  }","id":76427,"modified_method":"public LibraryManager(MPSModuleRepository repo, ModelConstraintsManager cm, StubReloadManager loader, ClassLoaderManager clm) {\n    super(repo);\n  }","commit_id":"e5a784fde2aaff542436682c0157f1d6b5936451","url":"https://github.com/JetBrains/MPS"},{"original_method":"public <M extends IModule> Set<M> getGlobalModules(Class<M> cls) {\n    Set<M> result = new HashSet<M>();\n    for (String path:getLibraries()){\n      result.addAll((Collection<? extends M>) LibraryInitializer.getInstance().getModules(path));\n    }\n\n    LibraryInitializer.getInstance().addGenerators(cls, new ArrayList<M>(result));\n\n    return result;\n  }","id":76428,"modified_method":"public <M extends IModule> Set<M> getGlobalModules(Class<M> cls) {\n    Set<M> result = new HashSet<M>();\n    for (String path : getLibraries()) {\n      for (IModule m : LibraryInitializer.getInstance().getModules(path)) {\n        if (cls.isAssignableFrom(m.getClass())) {\n          result.add((M) m);\n        }\n      }\n    }\n\n    LibraryInitializer.getInstance().addGenerators(cls, new ArrayList<M>(result));\n\n    return result;\n  }","commit_id":"e5a784fde2aaff542436682c0157f1d6b5936451","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void cacheAllApplicableRules(ConceptDeclaration inputConcept, ConceptDeclaration baseConcept) {\n    if (myRules_all.containsKey(inputConcept)) return;\n\n    List<AbstractConceptDeclaration> hierarchy = new ArrayList<AbstractConceptDeclaration>(5);\n    while (inputConcept != null) {\n      hierarchy.add(inputConcept);\n      if (myRules_all.containsKey(inputConcept)) {\n        break;\n      }\n      myRules_applicableInheritor.put(inputConcept, new ArrayList<Reduction_MappingRule>(5));\n      inputConcept = getExtendedConcept(inputConcept, baseConcept);\n    }\n\n    // collect interfaces in the right order\n    List<AbstractConceptDeclaration> interfacesHierarchy = new ArrayList<AbstractConceptDeclaration>(5);\n    for (AbstractConceptDeclaration hrrConcept : hierarchy) {\n      addInterfacesToHierarchy(((ConceptDeclaration)hrrConcept).getImplementses(), interfacesHierarchy);\n    }\n\n    hierarchy.addAll(interfacesHierarchy);\n    Collections.reverse(hierarchy);\n\n//    // test\n//    if(!interfacesHierarchy.isEmpty()) {\n//      System.out.println(\"---------\");\n//      for (AbstractConceptDeclaration cd : hierarchy) {\n//        System.out.println(cd.getName());\n//      }\n//      System.out.println(\"---------\");\n//    }\n//    // test\n\n    // rules for inheritor\n    List<Reduction_MappingRule> rulesForInheritor = null;\n    for (AbstractConceptDeclaration hrrConcept : hierarchy) {\n      rulesForInheritor = updateRulesForInheritor(hrrConcept, rulesForInheritor);\n      List<Reduction_MappingRule> list = myRules_applicableExactly.get(hrrConcept);\n      if (list != null) {\n        for (Reduction_MappingRule rule : list) {\n          if (rule.getApplyToConceptInheritors()) {\n            rulesForInheritor.add(rule);\n          }\n        }\n      }\n    }\n\n    // all rules\n    for (AbstractConceptDeclaration hrrConcept : hierarchy) {\n      if (myRules_all.containsKey(hrrConcept)) {\n        continue;\n      }\n      myRules_all.put(hrrConcept, new ArrayList<Reduction_MappingRule>(5));\n      List<Reduction_MappingRule> rulesExectly = myRules_applicableExactly.get(hrrConcept);\n      if (rulesExectly != null) {\n        myRules_all.get(hrrConcept).addAll(rulesExectly);\n      }\n      myRules_all.get(hrrConcept).addAll(myRules_applicableInheritor.get(hrrConcept));\n    }\n  }","id":76429,"modified_method":"private void cacheAllApplicableRules(ConceptDeclaration inputConcept, ConceptDeclaration baseConcept) {\n    if (myRules_all.containsKey(inputConcept)) return;\n\n    // create partial hierarhy where last concept is always 'processed'\n    List<ConceptDeclaration> partialHierarchy = new ArrayList<ConceptDeclaration>(5);\n    while (inputConcept != null) {\n      partialHierarchy.add(inputConcept);\n      if (myRules_all.containsKey(inputConcept)) {\n        break;\n      }\n      inputConcept = getExtendedConcept(inputConcept, baseConcept);\n    }\n\n    Collections.reverse(partialHierarchy); // first concept is always 'processed'\n\n    // for each concept: all rules rules applicable to it and rules applicable to inheritor \n    List<Reduction_MappingRule> rulesForInheritor = new ArrayList(myRules_applicableInheritor.get(partialHierarchy.get(0)));\n    for (ConceptDeclaration hrrConcept : partialHierarchy) {\n      if (myRules_all.containsKey(hrrConcept)) {\n        continue;  // skip first\n      }\n\n      myRules_all.put(hrrConcept, new ArrayList<Reduction_MappingRule>(rulesForInheritor));\n\n      List<Reduction_MappingRule> rulesApplicableExactly = myRules_applicableExactly.get(hrrConcept);\n      if (rulesApplicableExactly != null) {\n        myRules_all.get(hrrConcept).addAll(rulesApplicableExactly);\n        for (Reduction_MappingRule rule : rulesApplicableExactly) {\n          if (rule.getApplyToConceptInheritors()) {\n            rulesForInheritor.add(rule);\n          }\n        }\n      }\n\n      // add all rules applicable to implemented interfaces\n      Set<AbstractConceptDeclaration> implInterfaces = SModelUtil_new.getDirectlyImplementedInterfaces(hrrConcept);\n      for (AbstractConceptDeclaration implInterface : implInterfaces) {\n        List<Reduction_MappingRule> rulesApplicableToInterface = myRules_applicableExactly.get(implInterface);\n        if (rulesApplicableToInterface != null) {\n          for (Reduction_MappingRule rule : rulesApplicableToInterface) {\n            if (!rulesForInheritor.contains(rule)) {\n              myRules_all.get(hrrConcept).add(rule);\n              rulesForInheritor.add(rule);\n            }\n          }\n        }\n      }\n\n      myRules_applicableInheritor.put(hrrConcept, new ArrayList<Reduction_MappingRule>(rulesForInheritor));\n    }\n\n    // all rules\n//    for (ConceptDeclaration hrrConcept : partialHierarchy) {\n//      if (myRules_all.containsKey(hrrConcept)) {\n//        continue; // skip first\n//      }\n//      myRules_all.put(hrrConcept, new ArrayList<Reduction_MappingRule>(5));\n//      List<Reduction_MappingRule> rulesExectly = myRules_applicableExactly.get(hrrConcept);\n//      if (rulesExectly != null) {\n//        myRules_all.get(hrrConcept).addAll(rulesExectly);\n//      }\n//      myRules_all.get(hrrConcept).addAll(myRules_applicableInheritor.get(hrrConcept));\n//\n//    }\n  }","commit_id":"610e24b0216af3622261e00f00c5d134e18ef9d0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<Reduction_MappingRule> updateRulesForInheritor(AbstractConceptDeclaration concept, List<Reduction_MappingRule> addRulesForInheritor) {\n    List<Reduction_MappingRule> currentRulesForInheritor = myRules_applicableInheritor.get(concept);\n    if (addRulesForInheritor != null) {\n      currentRulesForInheritor.addAll(addRulesForInheritor);\n    }\n    return currentRulesForInheritor;\n  }","id":76430,"modified_method":"private List<Reduction_MappingRule> updateRulesForInheritor(ConceptDeclaration concept, List<Reduction_MappingRule> addRulesForInheritor) {\n    List<Reduction_MappingRule> currentRulesForInheritor = myRules_applicableInheritor.get(concept);\n    if (addRulesForInheritor != null) {\n      currentRulesForInheritor.addAll(addRulesForInheritor);\n    }\n    return currentRulesForInheritor;\n  }","commit_id":"610e24b0216af3622261e00f00c5d134e18ef9d0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addRule_applicableExactly(AbstractConceptDeclaration concept, Reduction_MappingRule rule) {\n    if (!myRules_applicableExactly.containsKey(concept)) {\n      myRules_applicableExactly.put(concept, new ArrayList<Reduction_MappingRule>());\n    }\n    myRules_applicableExactly.get(concept).add(rule);\n  }","id":76431,"modified_method":"private void addRule_applicableExactly(AbstractConceptDeclaration concept, Reduction_MappingRule rule) {\n    if (!myRules_applicableExactly.containsKey(concept)) {\n      myRules_applicableExactly.put(concept, new ArrayList<Reduction_MappingRule>(3));\n    }\n    myRules_applicableExactly.get(concept).add(rule);\n  }","commit_id":"610e24b0216af3622261e00f00c5d134e18ef9d0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<Message> receiveMessages(Queue queue, Map<String, String> receiveAttributes) throws SimpleQueueException {\n    List<Message> messages = Lists.newArrayList();\n    long now = SimpleQueueService.currentTimeSeconds();\n    try ( TransactionResource db =\n            Entities.transactionFor(MessageEntity.class) ) {\n      List<MessageEntity> messageEntityList = Entities.criteriaQuery(MessageEntity.class)\n        .whereEqual(MessageEntity_.accountId, queue.getAccountId())\n        .whereEqual(MessageEntity_.queueName, queue.getQueueName())\n        // messages with an expiration time of exactly now should expire, so we want the expiration\n        // timestamp to be strictly greater than now\n        .where(Entities.restriction(MessageEntity.class).gt(MessageEntity_.expiredTimestampSecs, now))\n        // messages with a visibility time of exactly now should be visible, so we want the the visibility\n        // timestamp to be less than or equal to now.\n        .where(Entities.restriction(MessageEntity.class).le(MessageEntity_.visibleTimestampSecs, now))\n        .list();\n      if (messageEntityList != null) {\n        for (MessageEntity messageEntity:messageEntityList) {\n          Message message = jsonToMessage(messageEntity.getMessageJson());\n          message.setMessageId(messageEntity.getMessageId());\n          // set receive timestamp if first time being received\n          if (messageEntity.getReceiveCount() == 0) {\n            message.getAttribute().add(new Attribute(Constants.APPROXIMATE_FIRST_RECEIVE_TIMESTAMP, \"\" + now));\n            // add the new attribute\n            messageEntity.setMessageJson(messageToJson(message));\n          }\n          // update visible timestamp (use visibility timeout)\n          int visibilityTimeout = queue.getVisibilityTimeout();\n          if (receiveAttributes.containsKey(Constants.VISIBILITY_TIMEOUT)) {\n            visibilityTimeout = Integer.parseInt(receiveAttributes.get(Constants.VISIBILITY_TIMEOUT));\n          }\n          messageEntity.setVisibleTimestampSecs(now + visibilityTimeout);\n          // update receive count (not stored in message json as updated often)\n          messageEntity.setLocalReceiveCount(messageEntity.getLocalReceiveCount() + 1);\n          messageEntity.setReceiveCount(messageEntity.getReceiveCount() + 1);\n\n          // Set the 'attributes' that are stored as first class fields\n          message.getAttribute().add(new Attribute(Constants.APPROXIMATE_RECEIVE_COUNT, \"\" + messageEntity.getReceiveCount()));\n          // send timestamp isn't updated but used in queries.  The attribute is in seconds though, so convert\n          message.getAttribute().add(new Attribute(Constants.SENT_TIMESTAMP, \"\" + (messageEntity.getSentTimestampSecs())));\n          message.setReceiptHandle(messageEntity.getAccountId() + \":\" + messageEntity.getQueueName() + \":\" + messageEntity.getMessageId() + \":\" + messageEntity.getLocalReceiveCount());\n          messages.add(message);\n        }\n      }\n      db.commit();\n      return messages;\n    }\n  }","id":76432,"modified_method":"@Override\n  public Collection<MessageWithReceiveCounts> receiveMessages(Queue queue, Map<String, String> receiveAttributes) throws SimpleQueueException {\n    List<MessageWithReceiveCounts> messagesWithExtraInfo = Lists.newArrayList();\n    long now = SimpleQueueService.currentTimeSeconds();\n    try ( TransactionResource db =\n            Entities.transactionFor(MessageEntity.class) ) {\n      List<MessageEntity> messageEntityList = Entities.criteriaQuery(MessageEntity.class)\n        .whereEqual(MessageEntity_.accountId, queue.getAccountId())\n        .whereEqual(MessageEntity_.queueName, queue.getQueueName())\n        // messages with an expiration time of exactly now should expire, so we want the expiration\n        // timestamp to be strictly greater than now\n        .where(Entities.restriction(MessageEntity.class).gt(MessageEntity_.expiredTimestampSecs, now))\n        // messages with a visibility time of exactly now should be visible, so we want the the visibility\n        // timestamp to be less than or equal to now.\n        .where(Entities.restriction(MessageEntity.class).le(MessageEntity_.visibleTimestampSecs, now))\n        .list();\n      if (messageEntityList != null) {\n        for (MessageEntity messageEntity:messageEntityList) {\n          Message message = jsonToMessage(messageEntity.getMessageJson());\n          message.setMessageId(messageEntity.getMessageId());\n          // set receive timestamp if first time being received\n          if (messageEntity.getReceiveCount() == 0) {\n            message.getAttribute().add(new Attribute(Constants.APPROXIMATE_FIRST_RECEIVE_TIMESTAMP, \"\" + now));\n            // add the new attribute\n            messageEntity.setMessageJson(messageToJson(message));\n          }\n          // update visible timestamp (use visibility timeout)\n          int visibilityTimeout = queue.getVisibilityTimeout();\n          if (receiveAttributes.containsKey(Constants.VISIBILITY_TIMEOUT)) {\n            visibilityTimeout = Integer.parseInt(receiveAttributes.get(Constants.VISIBILITY_TIMEOUT));\n          }\n          messageEntity.setVisibleTimestampSecs(now + visibilityTimeout);\n          // update receive count (not stored in message json as updated often)\n          messageEntity.setLocalReceiveCount(messageEntity.getLocalReceiveCount() + 1);\n          messageEntity.setReceiveCount(messageEntity.getReceiveCount() + 1);\n\n          // Set the 'attributes' that are stored as first class fields\n          message.getAttribute().add(new Attribute(Constants.APPROXIMATE_RECEIVE_COUNT, \"\" + messageEntity.getReceiveCount()));\n          // send timestamp isn't updated but used in queries.  The attribute is in seconds though, so convert\n          message.getAttribute().add(new Attribute(Constants.SENT_TIMESTAMP, \"\" + (messageEntity.getSentTimestampSecs())));\n          message.setReceiptHandle(messageEntity.getAccountId() + \":\" + messageEntity.getQueueName() + \":\" + messageEntity.getMessageId() + \":\" + messageEntity.getLocalReceiveCount());\n          MessageWithReceiveCounts messageWithReceiveCounts = new MessageWithReceiveCounts();\n          messageWithReceiveCounts.setMessage(message);\n          messageWithReceiveCounts.setLocalReceiveCount(messageEntity.getLocalReceiveCount());\n          messageWithReceiveCounts.setReceiveCount(messageEntity.getReceiveCount());\n          messagesWithExtraInfo.add(messageWithReceiveCounts);\n        }\n      }\n      db.commit();\n      return messagesWithExtraInfo;\n    }\n  }","commit_id":"6ba5173e7958fa1a277db5435cd4e9588179c314","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void setAndValidateAttributes(String accountId, Iterable<Attribute> requestAttributes, Map<String, String> attributeMap) throws SimpleQueueException {\n    for (Attribute attribute : requestAttributes) {\n      switch (attribute.getName()) {\n\n        case Constants.DELAY_SECONDS:\n          checkAttributeIntMinMax(attribute, 0, MAX_DELAY_SECONDS);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.MAXIMUM_MESSAGE_SIZE:\n          checkAttributeIntMinMax(attribute, 1024, MAX_MAXIMUM_MESSAGE_SIZE);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.MESSAGE_RETENTION_PERIOD:\n          checkAttributeIntMinMax(attribute, 60, MAX_MESSAGE_RETENTION_PERIOD);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.RECEIVE_MESSAGE_WAIT_TIME_SECONDS:\n          checkAttributeIntMinMax(attribute, 0, MAX_RECEIVE_MESSAGE_WAIT_TIME_SECONDS);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.VISIBILITY_TIMEOUT:\n          checkAttributeIntMinMax(attribute, 0, MAX_VISIBILITY_TIMEOUT);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.POLICY:\n\n          if (Strings.isNullOrEmpty(attribute.getValue())) {\n            attributeMap.remove(attribute.getName());\n            continue;\n          }\n\n          // TODO: we don't support wildcard Principal\n          try {\n            PolicyParser.getResourceInstance().parse(attribute.getValue());\n          } catch (PolicyParseException e) {\n            throw new InvalidParameterValueException(\"Invalid value for the parameter Policy. \");\n          }\n\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.REDRIVE_POLICY:\n\n          if (Strings.isNullOrEmpty(attribute.getValue())) {\n            attributeMap.remove(attribute.getName());\n            continue;\n          }\n\n          // TODO: maybe put this json stuff in its own class/method\n          JsonNode redrivePolicyJsonNode;\n          try {\n            redrivePolicyJsonNode = new ObjectMapper().readTree(attribute.getValue());\n          } catch (IOException e) {\n            throw new InvalidParameterValueException(\"Invalid value for the parameter RedrivePolicy. Reason: Redrive policy is not a valid JSON map.\");\n          }\n\n          if (redrivePolicyJsonNode == null || !redrivePolicyJsonNode.isObject()) {\n            throw new InvalidParameterValueException(\"Invalid value for the parameter RedrivePolicy. Reason: Redrive policy is not a valid JSON map.\");\n          }\n\n          if (!redrivePolicyJsonNode.has(\"maxReceiveCount\")) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Redrive policy does not contain mandatory attribute: maxReceiveCount.\");\n          }\n\n          if (!redrivePolicyJsonNode.has(\"deadLetterTargetArn\")) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Redrive policy does not contain mandatory attribute: deadLetterTargetArn.\");\n          }\n\n          if (redrivePolicyJsonNode.size() > 2) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Only following attributes are supported: [deadLetterTargetArn, maxReceiveCount].\");\n          }\n\n          JsonNode maxReceiveCountJsonNode = redrivePolicyJsonNode.get(\"maxReceiveCount\");\n          // note, if node is non-textual or has non-integer value, .asInt() will return 0, which is ok here.\n          if (maxReceiveCountJsonNode == null || (maxReceiveCountJsonNode.asInt() < 1) ||\n            (maxReceiveCountJsonNode.asInt() > MAX_MAX_RECEIVE_COUNT)) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Invalid value for maxReceiveCount: \" +\n              maxReceiveCountJsonNode + \", valid values are from 1 to\" + MAX_MAX_RECEIVE_COUNT + \" both \" +\n              \"inclusive.\");\n          }\n\n          JsonNode deadLetterTargetArnJsonNode = redrivePolicyJsonNode.get(\"deadLetterTargetArn\");\n          if (deadLetterTargetArnJsonNode == null || !(deadLetterTargetArnJsonNode.isTextual())) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Invalid value for deadLetterTargetArn.\");\n          }\n\n          Ern simpleQueueArn;\n          try {\n            simpleQueueArn = Ern.parse(deadLetterTargetArnJsonNode.textValue());\n          } catch (JSONException e) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Invalid value for deadLetterTargetArn.\");\n          }\n\n          if (!simpleQueueArn.getRegion().equals(RegionConfigurations.getRegionNameOrDefault())) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Dead-letter target must be in same region as the source.\");\n          }\n\n          if (!simpleQueueArn.getAccount().equals(accountId)) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Dead-letter target owner should be same as the source.\");\n          }\n\n          if (PersistenceFactory.getQueuePersistence().lookupQueue(simpleQueueArn.getAccount(), simpleQueueArn.getResourceName()) == null) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Dead letter target does not exist.\");\n          }\n\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        default:\n          throw new InvalidAttributeNameException(\"Unknown Attribute \" + attribute.getName());\n      }\n    }\n  }","id":76433,"modified_method":"private void setAndValidateAttributes(String accountId, Iterable<Attribute> requestAttributes, Map<String, String> attributeMap) throws SimpleQueueException {\n    for (Attribute attribute : requestAttributes) {\n      switch (attribute.getName()) {\n\n        case Constants.DELAY_SECONDS:\n          checkAttributeIntMinMax(attribute, 0, MAX_DELAY_SECONDS);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.MAXIMUM_MESSAGE_SIZE:\n          checkAttributeIntMinMax(attribute, 1024, MAX_MAXIMUM_MESSAGE_SIZE);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.MESSAGE_RETENTION_PERIOD:\n          checkAttributeIntMinMax(attribute, 60, MAX_MESSAGE_RETENTION_PERIOD);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.RECEIVE_MESSAGE_WAIT_TIME_SECONDS:\n          checkAttributeIntMinMax(attribute, 0, MAX_RECEIVE_MESSAGE_WAIT_TIME_SECONDS);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.VISIBILITY_TIMEOUT:\n          checkAttributeIntMinMax(attribute, 0, MAX_VISIBILITY_TIMEOUT);\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.POLICY:\n\n          if (Strings.isNullOrEmpty(attribute.getValue())) {\n            attributeMap.remove(attribute.getName());\n            continue;\n          }\n\n          // TODO: we don't support wildcard Principal\n          try {\n            PolicyParser.getResourceInstance().parse(attribute.getValue());\n          } catch (PolicyParseException e) {\n            throw new InvalidParameterValueException(\"Invalid value for the parameter Policy. \");\n          }\n\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        case Constants.REDRIVE_POLICY:\n\n          if (Strings.isNullOrEmpty(attribute.getValue())) {\n            attributeMap.remove(attribute.getName());\n            continue;\n          }\n\n          // TODO: maybe put this json stuff in its own class/method\n          JsonNode redrivePolicyJsonNode;\n          try {\n            redrivePolicyJsonNode = new ObjectMapper().readTree(attribute.getValue());\n          } catch (IOException e) {\n            throw new InvalidParameterValueException(\"Invalid value for the parameter RedrivePolicy. Reason: Redrive policy is not a valid JSON map.\");\n          }\n\n          if (redrivePolicyJsonNode == null || !redrivePolicyJsonNode.isObject()) {\n            throw new InvalidParameterValueException(\"Invalid value for the parameter RedrivePolicy. Reason: Redrive policy is not a valid JSON map.\");\n          }\n\n          if (!redrivePolicyJsonNode.has(Constants.MAX_RECEIVE_COUNT)) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Redrive policy does not contain mandatory attribute: \" + Constants.MAX_RECEIVE_COUNT + \".\");\n          }\n\n          if (!redrivePolicyJsonNode.has(Constants.DEAD_LETTER_TARGET_ARN)) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Redrive policy does not contain mandatory attribute: \" + Constants.DEAD_LETTER_TARGET_ARN + \".\");\n          }\n\n          if (redrivePolicyJsonNode.size() > 2) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Only following attributes are supported: [\" + Constants.DEAD_LETTER_TARGET_ARN + \", \" + Constants.MAX_RECEIVE_COUNT + \"].\");\n          }\n\n          JsonNode maxReceiveCountJsonNode = redrivePolicyJsonNode.get(Constants.MAX_RECEIVE_COUNT);\n          // note, if node is non-textual or has non-integer value, .asInt() will return 0, which is ok here.\n          if (maxReceiveCountJsonNode == null || (maxReceiveCountJsonNode.asInt() < 1) ||\n            (maxReceiveCountJsonNode.asInt() > MAX_MAX_RECEIVE_COUNT)) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Invalid value for \" + Constants.MAX_RECEIVE_COUNT + \": \" +\n              maxReceiveCountJsonNode + \", valid values are from 1 to\" + MAX_MAX_RECEIVE_COUNT + \" both \" +\n              \"inclusive.\");\n          }\n\n          JsonNode deadLetterTargetArnJsonNode = redrivePolicyJsonNode.get(Constants.DEAD_LETTER_TARGET_ARN);\n          if (deadLetterTargetArnJsonNode == null || !(deadLetterTargetArnJsonNode.isTextual())) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Invalid value for \" + Constants.DEAD_LETTER_TARGET_ARN + \".\");\n          }\n\n          Ern simpleQueueArn;\n          try {\n            simpleQueueArn = Ern.parse(deadLetterTargetArnJsonNode.textValue());\n          } catch (JSONException e) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Invalid value for \" + Constants.DEAD_LETTER_TARGET_ARN + \".\");\n          }\n\n          if (!simpleQueueArn.getRegion().equals(RegionConfigurations.getRegionNameOrDefault())) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Dead-letter target must be in same region as the source.\");\n          }\n\n          if (!simpleQueueArn.getAccount().equals(accountId)) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Dead-letter target owner should be same as the source.\");\n          }\n\n          if (PersistenceFactory.getQueuePersistence().lookupQueue(simpleQueueArn.getAccount(), simpleQueueArn.getResourceName()) == null) {\n            throw new InvalidParameterValueException(\"Value \" + attribute.getValue() + \" for parameter \" +\n              \"RedrivePolicy is invalid. Reason: Dead letter target does not exist.\");\n          }\n\n          attributeMap.put(attribute.getName(), attribute.getValue());\n          break;\n\n        default:\n          throw new InvalidAttributeNameException(\"Unknown Attribute \" + attribute.getName());\n      }\n    }\n  }","commit_id":"6ba5173e7958fa1a277db5435cd4e9588179c314","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListDeadLetterSourceQueuesResponseType listDeadLetterSourceQueues(ListDeadLetterSourceQueuesType request) throws EucalyptusCloudException {\n    ListDeadLetterSourceQueuesResponseType reply = request.getReply();\n    return reply;\n  }","id":76434,"modified_method":"public ListDeadLetterSourceQueuesResponseType listDeadLetterSourceQueues(ListDeadLetterSourceQueuesType request) throws EucalyptusCloudException {\n    ListDeadLetterSourceQueuesResponseType reply = request.getReply();\n    // TODO: IAM rather than own account for now\n    try {\n      final Context ctx = Contexts.lookup();\n      final String accountId = ctx.getAccountNumber();\n      QueueUrlParts queueUrlParts = getQueueUrlParts(request.getQueueUrl());\n      if (!queueUrlParts.getAccountId().equals(accountId)) {\n        throw new AccessDeniedException(\"Access to the resource \" + request.getQueueUrl() + \" is denied.\");\n      }\n      String queueName = queueUrlParts.getQueueName();\n\n      Queue deadLetterQueue = PersistenceFactory.getQueuePersistence().lookupQueue(accountId, queueName);\n      if (deadLetterQueue == null) {\n        throw new QueueDoesNotExistException(\"The specified queue does not exist.\");\n      }\n      String queueArn = \"arn:aws:sqs:\" + RegionConfigurations.getRegionNameOrDefault() + \":\" + accountId + \":\" + queueName;\n      Collection<Queue> sourceQueues = PersistenceFactory.getQueuePersistence().listDeadLetterSourceQueues(accountId, queueArn);\n      if (sourceQueues != null) {\n        for (Queue sourceQueue: sourceQueues) {\n          reply.getListDeadLetterSourceQueuesResult().getQueueUrl().add(getQueueUrlFromQueueUrlParts(new QueueUrlParts(sourceQueue.getAccountId(), sourceQueue.getQueueName())));\n        }\n      }\n    } catch (Exception ex) {\n      handleException(ex);\n    }\n    return reply;\n  }","commit_id":"6ba5173e7958fa1a277db5435cd4e9588179c314","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ReceiveMessageResponseType receiveMessage(ReceiveMessageType request) throws EucalyptusCloudException {\n    ReceiveMessageResponseType reply = request.getReply();\n    // TODO: IAM rather than own account for now\n    try {\n      final Context ctx = Contexts.lookup();\n      final String accountId = ctx.getAccountNumber();\n      QueueUrlParts queueUrlParts = getQueueUrlParts(request.getQueueUrl());\n      if (!queueUrlParts.getAccountId().equals(accountId)) {\n        throw new AccessDeniedException(\"Access to the resource \" + request.getQueueUrl() + \" is denied.\");\n      }\n      String queueName = queueUrlParts.getQueueName();\n\n      Queue queue = PersistenceFactory.getQueuePersistence().lookupQueue(accountId, queueName);\n      if (queue == null) {\n        throw new QueueDoesNotExistException(\"The specified queue does not exist.\");\n      }\n      Map<String, String> receiveAttributes = Maps.newHashMap();\n      if (request.getVisibilityTimeout() != null) {\n        if (request.getVisibilityTimeout() < 0 || request.getVisibilityTimeout() > MAX_VISIBILITY_TIMEOUT) {\n          throw new InvalidParameterValueException(\"VisibilityTimeout must be between 0 and \" + MAX_VISIBILITY_TIMEOUT);\n        }\n        receiveAttributes.put(Constants.VISIBILITY_TIMEOUT, \"\" + request.getVisibilityTimeout());\n      }\n\n      if (request.getWaitTimeSeconds() != null) {\n        if (request.getWaitTimeSeconds() < 0 || request.getWaitTimeSeconds() > MAX_RECEIVE_MESSAGE_WAIT_TIME_SECONDS) {\n          throw new InvalidParameterValueException(\"WaitTimeSeconds must be between 0 and \" + MAX_RECEIVE_MESSAGE_WAIT_TIME_SECONDS);\n        }\n        receiveAttributes.put(Constants.WAIT_TIME_SECONDS, \"\" + request.getWaitTimeSeconds());\n      }\n\n      int maxNumberOfMessages = 1;\n      if (request.getMaxNumberOfMessages() != null) {\n        if (request.getMaxNumberOfMessages() < 1 || request.getMaxNumberOfMessages() > MAX_RECEIVE_MESSAGE_MAX_NUMBER_OF_MESSAGES) {\n          throw new InvalidParameterValueException(\"WaitTimeSeconds must be between 1 and \" + MAX_RECEIVE_MESSAGE_MAX_NUMBER_OF_MESSAGES);\n        }\n        maxNumberOfMessages = request.getMaxNumberOfMessages();\n      }\n      receiveAttributes.put(Constants.MAX_NUMBER_OF_MESSAGES, \"\" + maxNumberOfMessages);\n\n\n      Collection<Message> messages = PersistenceFactory.getMessagePersistence().receiveMessages(queue, receiveAttributes);\n      if (messages != null) {\n        for (Message message: messages) {\n          filterReceiveAttributes(message, request.getAttributeName());\n          filterReceiveMessageAttributes(message, request.getMessageAttributeName());\n        }\n        reply.getReceiveMessageResult().getMessage().addAll(messages);\n      }\n    } catch (Exception ex) {\n      handleException(ex);\n    }\n    return reply;\n  }","id":76435,"modified_method":"public ReceiveMessageResponseType receiveMessage(ReceiveMessageType request) throws EucalyptusCloudException {\n    ReceiveMessageResponseType reply = request.getReply();\n    // TODO: IAM rather than own account for now\n    try {\n      final Context ctx = Contexts.lookup();\n      final String accountId = ctx.getAccountNumber();\n      QueueUrlParts queueUrlParts = getQueueUrlParts(request.getQueueUrl());\n      if (!queueUrlParts.getAccountId().equals(accountId)) {\n        throw new AccessDeniedException(\"Access to the resource \" + request.getQueueUrl() + \" is denied.\");\n      }\n      String queueName = queueUrlParts.getQueueName();\n\n      Queue queue = PersistenceFactory.getQueuePersistence().lookupQueue(accountId, queueName);\n      if (queue == null) {\n        throw new QueueDoesNotExistException(\"The specified queue does not exist.\");\n      }\n      Map<String, String> receiveAttributes = Maps.newHashMap();\n      if (request.getVisibilityTimeout() != null) {\n        if (request.getVisibilityTimeout() < 0 || request.getVisibilityTimeout() > MAX_VISIBILITY_TIMEOUT) {\n          throw new InvalidParameterValueException(\"VisibilityTimeout must be between 0 and \" + MAX_VISIBILITY_TIMEOUT);\n        }\n        receiveAttributes.put(Constants.VISIBILITY_TIMEOUT, \"\" + request.getVisibilityTimeout());\n      }\n\n      if (request.getWaitTimeSeconds() != null) {\n        if (request.getWaitTimeSeconds() < 0 || request.getWaitTimeSeconds() > MAX_RECEIVE_MESSAGE_WAIT_TIME_SECONDS) {\n          throw new InvalidParameterValueException(\"WaitTimeSeconds must be between 0 and \" + MAX_RECEIVE_MESSAGE_WAIT_TIME_SECONDS);\n        }\n        receiveAttributes.put(Constants.WAIT_TIME_SECONDS, \"\" + request.getWaitTimeSeconds());\n      }\n\n      int maxNumberOfMessages = 1;\n      if (request.getMaxNumberOfMessages() != null) {\n        if (request.getMaxNumberOfMessages() < 1 || request.getMaxNumberOfMessages() > MAX_RECEIVE_MESSAGE_MAX_NUMBER_OF_MESSAGES) {\n          throw new InvalidParameterValueException(\"WaitTimeSeconds must be between 1 and \" + MAX_RECEIVE_MESSAGE_MAX_NUMBER_OF_MESSAGES);\n        }\n        maxNumberOfMessages = request.getMaxNumberOfMessages();\n      }\n      receiveAttributes.put(Constants.MAX_NUMBER_OF_MESSAGES, \"\" + maxNumberOfMessages);\n\n\n      Collection<MessagePersistence.MessageWithReceiveCounts> messagesWithReceiveCounts = PersistenceFactory.getMessagePersistence().receiveMessages(queue, receiveAttributes);\n\n      boolean hasActiveLegalRedrivePolicy = false;\n      Queue deadLetterQueue = null;\n      int maxReceiveCount = 0;\n      try {\n        if (queue.getRedrivePolicy() != null && queue.getRedrivePolicy().isObject()) {\n          Ern deadLetterQueueArn = Ern.parse(queue.getRedrivePolicy().get(Constants.DEAD_LETTER_TARGET_ARN).textValue());\n          maxReceiveCount = queue.getRedrivePolicy().get(Constants.MAX_RECEIVE_COUNT).asInt();\n          deadLetterQueue = PersistenceFactory.getQueuePersistence().lookupQueue(deadLetterQueueArn.getAccount(), deadLetterQueueArn.getResourceName());\n          hasActiveLegalRedrivePolicy = (deadLetterQueue != null && maxReceiveCount > 0);\n        }\n      } catch (Exception ignore) {\n        // malformed or nonexistent redrive policy, just leave the message where it is?\n      }\n      if (messagesWithReceiveCounts != null) {\n        for (MessagePersistence.MessageWithReceiveCounts messageWithReceiveCounts: messagesWithReceiveCounts) {\n          Message message = messageWithReceiveCounts.getMessage();\n          if (hasActiveLegalRedrivePolicy && messageWithReceiveCounts.getLocalReceiveCount() > maxReceiveCount) {\n            PersistenceFactory.getMessagePersistence().moveMessageToDeadLetterQueue(queue, message, deadLetterQueue);\n          } else {\n            filterReceiveAttributes(message, request.getAttributeName());\n            filterReceiveMessageAttributes(message, request.getMessageAttributeName());\n            reply.getReceiveMessageResult().getMessage().add(message);\n          }\n        }\n      }\n    } catch (Exception ex) {\n      handleException(ex);\n    }\n    return reply;\n  }","commit_id":"6ba5173e7958fa1a277db5435cd4e9588179c314","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Nullable\n  protected PsiVariable getVariable() {\n    final PsiDeclarationStatement declarationStatement = myPointer.getElement();\n    return declarationStatement != null ? (PsiVariable)declarationStatement.getDeclaredElements()[0] : null;\n  }","id":76436,"modified_method":"@Nullable\n  protected PsiVariable getVariable() {\n    final PsiDeclarationStatement declarationStatement = myPointer.getElement();\n    if (declarationStatement != null) {\n      PsiElement[] declaredElements = declarationStatement.getDeclaredElements();\n      return declaredElements.length == 0 ? null : (PsiVariable)declaredElements[0];\n    }\n    return null;\n  }","commit_id":"9df040a6979fc3a3eb41bef5a97c805ba948a480","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethod(@NotNull PsiMethod aMethod) {\n      // no call to super, so it doesn't drill down into inner classes\n      final String methodName = aMethod.getName();\n      if (!HardcodedMethodConstants.MAIN.equals(methodName)) {\n        return;\n      }\n      if (!aMethod.hasModifierProperty(PsiModifier.PUBLIC)) {\n        registerMethodError(aMethod);\n        return;\n      }\n      if (!aMethod.hasModifierProperty(PsiModifier.STATIC)) {\n        registerMethodError(aMethod);\n        return;\n      }\n      final PsiType returnType = aMethod.getReturnType();\n\n      if (!TypeUtils.typeEquals(HardcodedMethodConstants.VOID, returnType)) {\n        registerMethodError(aMethod);\n        return;\n      }\n\n      final PsiParameterList paramList = aMethod.getParameterList();\n      if (paramList == null) {\n        return;\n      }\n      final PsiParameter[] parameters = paramList.getParameters();\n      if (parameters.length != 1) {\n        registerMethodError(aMethod);\n        return;\n      }\n      final PsiType paramType = parameters[0].getType();\n      if (!TypeUtils.typeEquals(\"java.lang.String\" + \"[]\", paramType)) {\n        registerMethodError(aMethod);\n      }\n    }","id":76437,"modified_method":"public void visitMethod(@NotNull PsiMethod aMethod) {\n            // no call to super, so it doesn't drill down into inner classes\n            final String methodName = aMethod.getName();\n            if (!HardcodedMethodConstants.MAIN.equals(methodName)) {\n                return;\n            }\n            if (!aMethod.hasModifierProperty(PsiModifier.PUBLIC)) {\n                registerMethodError(aMethod);\n                return;\n            }\n            if (!aMethod.hasModifierProperty(PsiModifier.STATIC)) {\n                registerMethodError(aMethod);\n                return;\n            }\n            final PsiType returnType = aMethod.getReturnType();\n\n            if (!TypeUtils.typeEquals(PsiKeyword.VOID, returnType)) {\n                registerMethodError(aMethod);\n                return;\n            }\n            final PsiParameterList paramList = aMethod.getParameterList();\n            final PsiParameter[] parameters = paramList.getParameters();\n            if (parameters.length != 1) {\n                registerMethodError(aMethod);\n                return;\n            }\n            final PsiType paramType = parameters[0].getType();\n            if (!TypeUtils.typeEquals(\"java.lang.String\" + \"[]\", paramType)) {\n                registerMethodError(aMethod);\n            }\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isIteratorAssigned() {\n      return iteratorAssigned;\n    }","id":76438,"modified_method":"public boolean isIteratorAssigned() {\n            return iteratorAssigned;\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {\n      super.visitMethodCallExpression(expression);\n      final PsiReferenceExpression methodExpression =\n        expression.getMethodExpression();\n      @NonNls final String name = methodExpression.getReferenceName();\n      if (!\"hasNext\".equals(name)) {\n        return;\n      }\n      final PsiExpression qualifier =\n        methodExpression.getQualifierExpression();\n      if (qualifier != null) {\n        final String qualifierText = qualifier.getText();\n        if (iteratorName.equals(qualifierText)) {\n          hasNextCalled = true;\n        }\n      }\n    }","id":76439,"modified_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            @NonNls final String name = methodExpression.getReferenceName();\n            if (!HardcodedMethodConstants.HAS_NEXT.equals(name)) {\n                return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (qualifier != null) {\n                final String qualifierText = qualifier.getText();\n                if (iteratorName.equals(qualifierText)) {\n                    hasNextCalled = true;\n                }\n            }\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String createCollectionIterationText(PsiWhileStatement whileStatement,\n                                                 Project project)\n      throws IncorrectOperationException {\n      final int length = whileStatement.getText().length();\n      @NonNls final StringBuffer out = new StringBuffer(length);\n      final PsiStatement body = whileStatement.getBody();\n      final PsiStatement firstStatement = getFirstStatement(body);\n      final PsiStatement initialization =\n        getPreviousStatement(whileStatement);\n      final PsiDeclarationStatement declaration =\n        (PsiDeclarationStatement)initialization;\n      assert declaration != null;\n      final PsiLocalVariable iterator =\n        (PsiLocalVariable)declaration.getDeclaredElements()[0];\n\n      final PsiMethodCallExpression initializer =\n        (PsiMethodCallExpression)iterator.getInitializer();\n      final PsiExpression collection =\n        initializer.getMethodExpression().getQualifierExpression();\n      final PsiClassType type = (PsiClassType)collection.getType();\n      final PsiType[] parameters = type.getParameters();\n      final String contentTypeString;\n      if (parameters.length == 1) {\n        final PsiType parameterType = parameters[0];\n        if (parameterType instanceof PsiWildcardType) {\n          final PsiWildcardType wildcardType = (PsiWildcardType)parameterType;\n          final PsiType bound = wildcardType.getBound();\n          if (bound == null) {\n            contentTypeString = \"java.lang.Object\";\n          }\n          else {\n            contentTypeString = bound.getCanonicalText();\n          }\n        }\n        else if (parameterType != null) {\n          contentTypeString = parameterType.getCanonicalText();\n        }\n        else {\n          contentTypeString = \"java.lang.Object\";\n        }\n      }\n      else {\n        contentTypeString = \"java.lang.Object\";\n      }\n      final PsiManager psiManager = PsiManager.getInstance(project);\n      final PsiElementFactory elementFactory =\n        psiManager.getElementFactory();\n      final PsiType contentType = elementFactory.createTypeFromText(contentTypeString,\n                                                                    whileStatement);\n      final String iteratorName = iterator.getName();\n      final boolean isDeclaration =\n        isIteratorNextDeclaration(firstStatement, iteratorName, contentTypeString);\n      final PsiStatement statementToSkip;\n      @NonNls final String finalString;\n      final String contentVariableName;\n      if (isDeclaration) {\n        final PsiDeclarationStatement decl =\n          (PsiDeclarationStatement)firstStatement;\n        assert decl != null;\n        final PsiElement[] declaredElements =\n          decl.getDeclaredElements();\n        final PsiLocalVariable localVar =\n          (PsiLocalVariable)declaredElements[0];\n        contentVariableName = localVar.getName();\n        statementToSkip = decl;\n        if (localVar.hasModifierProperty(PsiModifier.FINAL)) {\n          finalString = \"final \";\n        }\n        else {\n          finalString = \"\";\n        }\n      }\n      else {\n        if (collection instanceof PsiReferenceExpression) {\n          final String collectionName =\n            ((PsiReferenceExpression)collection).getReferenceName();\n          contentVariableName = createNewVarName(project,\n                                                 whileStatement,\n                                                 contentType,\n                                                 collectionName);\n        }\n        else {\n          contentVariableName = createNewVarName(project,\n                                                 whileStatement,\n                                                 contentType, null);\n        }\n        if (CodeStyleSettingsManager.getSettings(project).GENERATE_FINAL_LOCALS) {\n          finalString = \"final \";\n        }\n        else {\n          finalString = \"\";\n        }\n        statementToSkip = null;\n      }\n      out.append(\"for(\" + finalString + contentTypeString + ' ' +\n                 contentVariableName + \": \" + collection.getText() + ')');\n      replaceIteratorNext(body, contentVariableName, iteratorName,\n                          statementToSkip, out, contentTypeString);\n      return out.toString();\n    }","id":76440,"modified_method":"@Nullable\n        private static String createCollectionIterationText(\n                @NotNull PsiWhileStatement whileStatement)\n                throws IncorrectOperationException {\n            System.out.println(\"createCollectionIterationText()\");\n            final String text = whileStatement.getText();\n            final int length = text.length();\n            @NonNls final StringBuffer out = new StringBuffer(length);\n            final PsiStatement body = whileStatement.getBody();\n            if (body == null) {\n                return null;\n            }\n            final PsiStatement firstStatement = getFirstStatement(body);\n            final PsiStatement initialization =\n                    getPreviousStatement(whileStatement);\n            final PsiDeclarationStatement declaration =\n                    (PsiDeclarationStatement)initialization;\n            if (declaration == null) {\n                return null;\n            }\n            final PsiElement element = declaration.getDeclaredElements()[0];\n            if(!(element instanceof PsiLocalVariable)){\n                return null;\n            }\n            final PsiLocalVariable iterator =\n                    (PsiLocalVariable) element;\n            final PsiMethodCallExpression initializer =\n                    (PsiMethodCallExpression)iterator.getInitializer();\n            if (initializer == null) {\n                return null;\n            }\n            final PsiReferenceExpression methodExpression =\n                    initializer.getMethodExpression();\n            final PsiExpression collection =\n                    methodExpression.getQualifierExpression();\n            if (collection == null) {\n                return null;\n            }\n            final PsiClassType type = (PsiClassType)collection.getType();\n            if (type == null) {\n                return null;\n            }\n            final PsiType[] parameters = type.getParameters();\n            final String contentTypeString;\n            if (parameters.length == 1) {\n                final PsiType parameterType = parameters[0];\n                if (parameterType instanceof PsiWildcardType) {\n                    final PsiWildcardType wildcardType =\n                            (PsiWildcardType)parameterType;\n                    final PsiType bound = wildcardType.getBound();\n                    if (bound == null) {\n                        contentTypeString = \"java.lang.Object\";\n                    } else {\n                        contentTypeString = bound.getCanonicalText();\n                    }\n                } else if (parameterType != null) {\n                    contentTypeString = parameterType.getCanonicalText();\n                } else {\n                    contentTypeString = \"java.lang.Object\";\n                }\n            } else {\n                contentTypeString = \"java.lang.Object\";\n            }\n            final Project project = whileStatement.getProject();\n            final PsiManager psiManager = PsiManager.getInstance(project);\n            final PsiElementFactory elementFactory =\n                    psiManager.getElementFactory();\n            final PsiType contentType =\n                    elementFactory.createTypeFromText(contentTypeString,\n                            whileStatement);\n            final String iteratorName = iterator.getName();\n            final boolean isDeclaration =\n                    isIteratorNextDeclaration(firstStatement, iteratorName,\n                            contentTypeString);\n            final PsiStatement statementToSkip;\n            @NonNls final String finalString;\n            final String contentVariableName;\n            if (isDeclaration) {\n                final PsiDeclarationStatement declarationStatement =\n                        (PsiDeclarationStatement)firstStatement;\n                if (declarationStatement == null) {\n                    return null;\n                }\n                final PsiElement[] declaredElements =\n                        declarationStatement.getDeclaredElements();\n                final PsiLocalVariable localVar =\n                        (PsiLocalVariable)declaredElements[0];\n                contentVariableName = localVar.getName();\n                statementToSkip = declarationStatement;\n                if (localVar.hasModifierProperty(PsiModifier.FINAL)) {\n                    finalString = \"final \";\n                } else {\n                    finalString = \"\";\n                }\n            } else {\n                if (collection instanceof PsiReferenceExpression) {\n                    final PsiJavaCodeReferenceElement referenceElement\n                            = (PsiJavaCodeReferenceElement) collection;\n                    final String collectionName =\n                            referenceElement.getReferenceName();\n                    contentVariableName = createNewVarName(\n                            whileStatement,\n                            contentType,\n                            collectionName);\n                } else {\n                    contentVariableName = createNewVarName(\n                            whileStatement,\n                            contentType, null);\n                }\n                final CodeStyleSettings codeStyleSettings =\n                        CodeStyleSettingsManager.getSettings(project);\n                if(codeStyleSettings.GENERATE_FINAL_LOCALS) {\n                    finalString = \"final \";\n                } else {\n                    finalString = \"\";\n                }\n                statementToSkip = null;\n            }\n            out.append(\"for(\");\n            out.append(finalString);\n            out.append(contentTypeString);\n            out.append(' ');\n            out.append(contentVariableName);\n            out.append(\": \");\n            out.append(collection.getText());\n            out.append(')');\n            replaceIteratorNext(body, contentVariableName, iteratorName,\n                    statementToSkip, out, contentTypeString);\n            return out.toString();\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getNumCallsToIteratorNext() {\n      return numCallsToIteratorNext;\n    }","id":76441,"modified_method":"public int getNumCallsToIteratorNext() {\n            return numCallsToIteratorNext;\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isIteratorNext(PsiElement element,\n                                   String iteratorName, String contentType) {\n      if (element == null) {\n        return false;\n      }\n      if (element instanceof PsiTypeCastExpression) {\n\n        final PsiTypeCastExpression castExpression = (PsiTypeCastExpression)element;\n        final PsiType type = castExpression.getType();\n        if (type == null) {\n          return false;\n        }\n        if (!type.getPresentableText().equals(contentType)) {\n          return false;\n        }\n        final PsiExpression operand =\n          castExpression.getOperand();\n        return isIteratorNext(operand, iteratorName, contentType);\n      }\n      if (!(element instanceof PsiMethodCallExpression)) {\n        return false;\n      }\n      final PsiMethodCallExpression callExpression =\n        (PsiMethodCallExpression)element;\n      final PsiExpressionList argumentList =\n        callExpression.getArgumentList();\n      if (argumentList == null) {\n        return false;\n      }\n      final PsiExpression[] args = argumentList.getExpressions();\n      if (args.length != 0) {\n        return false;\n      }\n      final PsiReferenceExpression reference =\n        callExpression.getMethodExpression();\n      if (reference == null) {\n        return false;\n      }\n      final PsiExpression qualifier = reference.getQualifierExpression();\n      if (qualifier == null) {\n        return false;\n      }\n      if (!iteratorName.equals(qualifier.getText())) {\n        return false;\n      }\n      @NonNls final String referenceName = reference.getReferenceName();\n      return \"next\".equals(referenceName);\n    }","id":76442,"modified_method":"private static boolean isIteratorNext(\n                PsiElement element, String iteratorName, String contentType){\n            if (element == null) {\n                return false;\n            }\n            if (element instanceof PsiTypeCastExpression) {\n                final PsiTypeCastExpression castExpression =\n                        (PsiTypeCastExpression)element;\n                final PsiType type = castExpression.getType();\n                if (type == null) {\n                    return false;\n                }\n                final String presentableText = type.getPresentableText();\n                if(!presentableText.equals(contentType)){\n                    return false;\n                }\n                final PsiExpression operand =\n                        castExpression.getOperand();\n                return isIteratorNext(operand, iteratorName, contentType);\n            }\n            if (!(element instanceof PsiMethodCallExpression)) {\n                return false;\n            }\n            final PsiMethodCallExpression callExpression =\n                    (PsiMethodCallExpression)element;\n            final PsiExpressionList argumentList =\n                    callExpression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            if (args.length != 0) {\n                return false;\n            }\n            final PsiReferenceExpression reference =\n                    callExpression.getMethodExpression();\n            final PsiExpression qualifier = reference.getQualifierExpression();\n            if (qualifier == null) {\n                return false;\n            }\n            if (!iteratorName.equals(qualifier.getText())) {\n                return false;\n            }\n            @NonNls final String referenceName = reference.getReferenceName();\n            return \"next\".equals(referenceName);\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(@NotNull PsiMethodCallExpression callExpression) {\n      super.visitMethodCallExpression(callExpression);\n      final PsiReferenceExpression methodExpression =\n        callExpression.getMethodExpression();\n      if (methodExpression == null) {\n        return;\n      }\n      @NonNls final String methodName = methodExpression.getReferenceName();\n      if (!\"next\".equals(methodName)) {\n        return;\n      }\n\n      final PsiExpression qualifier =\n        methodExpression.getQualifierExpression();\n      if (qualifier == null) {\n        return;\n      }\n      final String qualifierText = qualifier.getText();\n      if (!iteratorName.equals(qualifierText)) {\n        return;\n      }\n      numCallsToIteratorNext++;\n    }","id":76443,"modified_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression callExpression) {\n            super.visitMethodCallExpression(callExpression);\n            final PsiReferenceExpression methodExpression =\n                    callExpression.getMethodExpression();\n            @NonNls final String methodName =\n                    methodExpression.getReferenceName();\n            if (!\"next\".equals(methodName)) {\n                return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (qualifier == null) {\n                return;\n            }\n            final String qualifierText = qualifier.getText();\n            if (!iteratorName.equals(qualifierText)) {\n                return;\n            }\n            numCallsToIteratorNext++;\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n      throws IncorrectOperationException {\n      final PsiElement whileElement = descriptor.getPsiElement();\n      final PsiWhileStatement whileStatement =\n        (PsiWhileStatement)whileElement.getParent();\n      final String newExpression =\n        createCollectionIterationText(whileStatement, project);\n      final PsiStatement statement = getPreviousStatement(whileStatement);\n      assert statement != null;\n      deleteElement(statement);\n      replaceStatementAndShortenClassNames(whileStatement, newExpression);\n    }","id":76444,"modified_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiElement whileElement = descriptor.getPsiElement();\n            final PsiWhileStatement whileStatement =\n                    (PsiWhileStatement)whileElement.getParent();\n            final String newExpression =\n                    createCollectionIterationText(whileStatement);\n            if(newExpression == null){\n                return;\n            }\n            final PsiStatement statement = getPreviousStatement(whileStatement);\n            if (statement == null) {\n                return;\n            }\n            deleteElement(statement);\n            replaceStatementAndShortenClassNames(whileStatement, newExpression);\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BaseInspectionVisitor buildVisitor() {\n    return new WhileBeForeachVisitor();\n  }","id":76445,"modified_method":"public BaseInspectionVisitor buildVisitor() {\n        return new WhileCanBeForeachVisitor();\n    }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isRemoveCalled() {\n      return removeCalled;\n    }","id":76446,"modified_method":"public boolean isRemoveCalled() {\n            return removeCalled;\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String createNewVarName(Project project, PsiWhileStatement scope,\n                                    PsiType type, String containerName) {\n      final CodeStyleManager codeStyleManager =\n        CodeStyleManager.getInstance(project);\n      @NonNls String baseName;\n      if (containerName != null) {\n        baseName = StringUtils.createSingularFromName(containerName);\n      }\n      else {\n\n        final SuggestedNameInfo suggestions =\n          codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE,\n                                               null, null, type);\n        final String[] names = suggestions.names;\n        if (names != null && names.length > 0) {\n          baseName = names[0];\n        }\n        else {\n          baseName = \"value\";\n        }\n      }\n      if (baseName == null || baseName.length() == 0) {\n        baseName = \"value\";\n      }\n      return codeStyleManager.suggestUniqueVariableName(baseName, scope,\n                                                        true);\n    }","id":76447,"modified_method":"private static String createNewVarName(\n                @NotNull PsiWhileStatement scope, PsiType type,\n                String containerName) {\n            final Project project = scope.getProject();\n            final CodeStyleManager codeStyleManager =\n                    CodeStyleManager.getInstance(project);\n            @NonNls String baseName;\n            if (containerName != null) {\n                baseName = StringUtils.createSingularFromName(containerName);\n            } else {\n                final SuggestedNameInfo suggestions =\n                        codeStyleManager.suggestVariableName(\n                                VariableKind.LOCAL_VARIABLE, null, null, type);\n                final String[] names = suggestions.names;\n                if (names != null && names.length > 0) {\n                    baseName = names[0];\n                } else {\n                    baseName = \"value\";\n                }\n            }\n            if (baseName == null || baseName.length() == 0) {\n                baseName = \"value\";\n            }\n            return codeStyleManager.suggestUniqueVariableName(baseName, scope,\n                    true);\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isHasNextCalled() {\n      return hasNextCalled;\n    }","id":76448,"modified_method":"public boolean isHasNextCalled() {\n            return hasNextCalled;\n        }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiStatement getPreviousStatement(PsiWhileStatement statement) {\n    final PsiElement prevStatement =\n      PsiTreeUtil.skipSiblingsBackward(statement,\n                                       new Class[]{PsiWhiteSpace.class});\n    if (prevStatement == null || !(prevStatement instanceof PsiStatement)) {\n      return null;\n    }\n    return (PsiStatement)prevStatement;\n  }","id":76449,"modified_method":"@Nullable\n    public static PsiStatement getPreviousStatement(\n            PsiWhileStatement statement) {\n        final PsiElement prevStatement =\n                PsiTreeUtil.skipSiblingsBackward(statement,\n                        new Class[]{PsiWhiteSpace.class, PsiComment.class});\n        if (prevStatement == null || !(prevStatement instanceof PsiStatement)) {\n            return null;\n        }\n        return (PsiStatement)prevStatement;\n    }","commit_id":"9b988832984f0e624cea3998a4bc58a17a3426e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    LOG.assertTrue(myOutOfScopeVariable != null);\n    PsiManager manager = file.getManager();\n    myOutOfScopeVariable.normalizeDeclaration();\n    PsiUtil.setModifierProperty(myOutOfScopeVariable, PsiModifier.FINAL, false);\n    PsiElement commonParent = PsiTreeUtil.findCommonParent(myOutOfScopeVariable, myUnresolvedReference);\n    LOG.assertTrue(commonParent != null);\n    PsiElement child = myOutOfScopeVariable.getTextRange().getStartOffset() < myUnresolvedReference.getTextRange().getStartOffset() ? myOutOfScopeVariable\n                       : myUnresolvedReference;\n\n    while(child.getParent() != commonParent) child = child.getParent();\n    PsiDeclarationStatement newDeclaration = (PsiDeclarationStatement)JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createStatementFromText(\"int i = 0\", null);\n    PsiVariable variable = (PsiVariable)newDeclaration.getDeclaredElements()[0].replace(myOutOfScopeVariable);\n    if (variable.getInitializer() != null) {\n      variable.getInitializer().delete();\n    }\n\n    while(!(child instanceof PsiStatement) || !(child.getParent() instanceof PsiCodeBlock)) {\n      child = child.getParent();\n      commonParent = commonParent.getParent();\n    }\n    LOG.assertTrue(commonParent != null);\n    PsiDeclarationStatement added = (PsiDeclarationStatement)commonParent.addBefore(newDeclaration, child);\n    PsiLocalVariable addedVar = (PsiLocalVariable)added.getDeclaredElements()[0];\n    CodeStyleManager.getInstance(manager.getProject()).reformat(commonParent);\n\n    //Leave initializer assignment\n    PsiExpression initializer = myOutOfScopeVariable.getInitializer();\n    if (initializer != null) {\n      PsiExpressionStatement assignment = (PsiExpressionStatement)JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createStatementFromText(myOutOfScopeVariable\n        .getName() + \"= e;\", null);\n      ((PsiAssignmentExpression)assignment.getExpression()).getRExpression().replace(initializer);\n      assignment = (PsiExpressionStatement)CodeStyleManager.getInstance(manager.getProject()).reformat(assignment);\n      PsiDeclarationStatement declStatement = PsiTreeUtil.getParentOfType(myOutOfScopeVariable, PsiDeclarationStatement.class);\n      LOG.assertTrue(declStatement != null);\n      PsiElement parent = declStatement.getParent();\n      if (parent instanceof PsiForStatement) {\n        declStatement.replace(assignment);\n      }\n      else {\n        parent.addAfter(assignment, declStatement);\n      }\n    }\n\n    if (myOutOfScopeVariable.isValid()) {\n      myOutOfScopeVariable.delete();\n    }\n\n    if (HighlightControlFlowUtil.checkVariableInitializedBeforeUsage(myUnresolvedReference, addedVar, new THashMap<PsiElement, Collection<PsiReferenceExpression>>(),file) != null) {\n      initialize(addedVar);\n    }\n\n    DaemonCodeAnalyzer.getInstance(project).updateVisibleHighlighters(editor);\n  }","id":76450,"modified_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    LOG.assertTrue(myOutOfScopeVariable != null);\n    PsiManager manager = file.getManager();\n    myOutOfScopeVariable.normalizeDeclaration();\n    PsiUtil.setModifierProperty(myOutOfScopeVariable, PsiModifier.FINAL, false);\n    PsiElement commonParent = PsiTreeUtil.findCommonParent(myOutOfScopeVariable, myUnresolvedReference);\n    LOG.assertTrue(commonParent != null);\n    PsiElement child = myOutOfScopeVariable.getTextRange().getStartOffset() < myUnresolvedReference.getTextRange().getStartOffset() ? myOutOfScopeVariable\n                       : myUnresolvedReference;\n\n    while(child.getParent() != commonParent) child = child.getParent();\n    PsiDeclarationStatement newDeclaration = (PsiDeclarationStatement)JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createStatementFromText(\"int i = 0\", null);\n    PsiVariable variable = (PsiVariable)newDeclaration.getDeclaredElements()[0].replace(myOutOfScopeVariable);\n    if (variable.getInitializer() != null) {\n      variable.getInitializer().delete();\n    }\n\n    while(!(child instanceof PsiStatement) || !(child.getParent() instanceof PsiCodeBlock)) {\n      child = child.getParent();\n      commonParent = commonParent.getParent();\n    }\n    LOG.assertTrue(commonParent != null);\n    PsiDeclarationStatement added = (PsiDeclarationStatement)commonParent.addBefore(newDeclaration, child);\n    final PsiElement[] declaredElements = added.getDeclaredElements();\n    LOG.assertTrue(declaredElements.length > 0, added.getText());\n    PsiLocalVariable addedVar = (PsiLocalVariable)declaredElements[0];\n    CodeStyleManager.getInstance(manager.getProject()).reformat(commonParent);\n\n    //Leave initializer assignment\n    PsiExpression initializer = myOutOfScopeVariable.getInitializer();\n    if (initializer != null) {\n      PsiExpressionStatement assignment = (PsiExpressionStatement)JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createStatementFromText(myOutOfScopeVariable\n        .getName() + \"= e;\", null);\n      ((PsiAssignmentExpression)assignment.getExpression()).getRExpression().replace(initializer);\n      assignment = (PsiExpressionStatement)CodeStyleManager.getInstance(manager.getProject()).reformat(assignment);\n      PsiDeclarationStatement declStatement = PsiTreeUtil.getParentOfType(myOutOfScopeVariable, PsiDeclarationStatement.class);\n      LOG.assertTrue(declStatement != null);\n      PsiElement parent = declStatement.getParent();\n      if (parent instanceof PsiForStatement) {\n        declStatement.replace(assignment);\n      }\n      else {\n        parent.addAfter(assignment, declStatement);\n      }\n    }\n\n    if (myOutOfScopeVariable.isValid()) {\n      myOutOfScopeVariable.delete();\n    }\n\n    if (HighlightControlFlowUtil.checkVariableInitializedBeforeUsage(myUnresolvedReference, addedVar, new THashMap<PsiElement, Collection<PsiReferenceExpression>>(),file) != null) {\n      initialize(addedVar);\n    }\n\n    DaemonCodeAnalyzer.getInstance(project).updateVisibleHighlighters(editor);\n  }","commit_id":"606d8ea0c5beb27b2947adfabc124694430b0579","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * \n     */\n    private void processTargets(Target[] targets, List<NotificationTask> targetSiblings, NoticeQueue noticeQueue, long startTime, Map<String, String> params, int noticeId) throws IOException, MarshalException, ValidationException {\n        for (int i = 0; i < targets.length; i++) {\n            String interval = (targets[i].getInterval() == null ? \"0s\" : targets[i].getInterval());\n\n            String targetName = targets[i].getName();\n            String autoNotify = targets[i].getAutoNotify();\n            if(autoNotify != null) {\n                if(autoNotify.equalsIgnoreCase(\"on\")) {\n                    autoNotify = \"Y\";\n                } else if(autoNotify.equalsIgnoreCase(\"off\")) {\n                    autoNotify = \"N\";\n                } else {\n                    autoNotify = \"C\";\n                }\n            } else {\n                autoNotify = \"C\";\n            }\n            if (log().isDebugEnabled()) {\n                log().debug(\"Processing target \" + targetName + \":\" + interval);\n            }\n            \n            NotificationTask[] tasks = null;\n            \n            if (getGroupManager().hasGroup((targetName))) {\n                tasks = makeGroupTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasRole(targetName)) {\n                tasks = makeRoleTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasUser(targetName)) {\n                NotificationTask[] userTasks = { makeUserTask(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify) };\n                tasks = userTasks;\n            } else if (targetName.indexOf(\"@\") > -1) {\n            \t// Bug 2027 -- get the command name from the Notifd config instead of using default of \"email\"\n            \tString[] emailCommands = { getNotifdConfigManager().getConfiguration().getEmailAddressCommand() };\n                NotificationTask[] emailTasks = { makeEmailTask(startTime, params, noticeId, targetName, emailCommands, targetSiblings, autoNotify) };\n                tasks = emailTasks;\n            }\n             \n            if (tasks != null) {\n                for (int index = 0; index < tasks.length; index++) {\n                    NotificationTask task = tasks[index];\n                    if (task != null) {\n                        noticeQueue.putItem(task.getSendTime(), task);\n                        targetSiblings.add(task);\n                    }\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","id":76451,"modified_method":"/**\n     * \n     */\n    private void processTargets(Target[] targets, List<NotificationTask> targetSiblings, NoticeQueue noticeQueue, long startTime, Map<String, String> params, int noticeId) throws IOException, MarshalException, ValidationException {\n        for (int i = 0; i < targets.length; i++) {\n            String interval = (targets[i].getInterval() == null ? \"0s\" : targets[i].getInterval());\n\n            String targetName = targets[i].getName();\n            String autoNotify = targets[i].getAutoNotify();\n            if(autoNotify != null) {\n                if(autoNotify.equalsIgnoreCase(\"on\")) {\n                    autoNotify = \"Y\";\n                } else if(autoNotify.equalsIgnoreCase(\"off\")) {\n                    autoNotify = \"N\";\n                } else {\n                    autoNotify = \"C\";\n                }\n            } else {\n                autoNotify = \"C\";\n            }\n            if (log().isDebugEnabled()) {\n                log().debug(\"Processing target \" + targetName + \":\" + interval);\n            }\n            \n            NotificationTask[] tasks = null;\n            \n            if (getGroupManager().hasGroup((targetName))) {\n                tasks = makeGroupTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasRole(targetName)) {\n                tasks = makeRoleTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasUser(targetName)) {\n                NotificationTask[] userTasks = { makeUserTask(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify) };\n                tasks = userTasks;\n            } else if (targetName.indexOf(\"@\") > -1) {\n            \t// Bug 2027 -- get the command name from the Notifd config instead of using default of \"email\"\n            \tString[] emailCommands = { getNotifdConfigManager().getConfiguration().getEmailAddressCommand() };\n                NotificationTask[] emailTasks = { makeEmailTask(startTime, params, noticeId, targetName, emailCommands, targetSiblings, autoNotify) };\n                tasks = emailTasks;\n            }\n             \n            if (tasks != null) {\n                for (int index = 0; index < tasks.length; index++) {\n                    NotificationTask task = tasks[index];\n                    if (task != null) {\n                        synchronized(noticeQueue) {\n                            noticeQueue.putItem(task.getSendTime(), task);\n                        }\n                        targetSiblings.add(task);\n                    }\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","commit_id":"6c98f26fc0597c9753d691da78e19484e7c137cd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, NoticeQueue> getNoticeQueues() {\n        synchronized(m_noticeQueues) {\n            return m_noticeQueues;\n        }\n    }","id":76452,"modified_method":"public synchronized Map<String, NoticeQueue> getNoticeQueues() {\n        return m_noticeQueues;\n    }","commit_id":"6c98f26fc0597c9753d691da78e19484e7c137cd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void sendResolvedNotificationsToUser(String queueID, String targetName, String[] commands, Map<String, String> params) throws Exception {\n        int noticeId = -1;\n        synchronized(m_noticeQueues) {\n            NoticeQueue noticeQueue = m_noticeQueues.get(queueID);\n            long now = System.currentTimeMillis();\n    \n            if (getUserManager().hasUser(targetName)) {\n                NotificationTask newTask = makeUserTask(now, params, noticeId, targetName, commands, null, null);\n    \n                if (newTask != null) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            } else if (targetName.indexOf(\"@\") > -1) {\n                NotificationTask newTask = makeEmailTask(now, params, noticeId, targetName, commands, null, null);\n    \n                if (newTask != null) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","id":76453,"modified_method":"protected void sendResolvedNotificationsToUser(String queueID, String targetName, String[] commands, Map<String, String> params) throws Exception {\n        int noticeId = -1;\n        NoticeQueue noticeQueue = null;\n        if (m_noticeQueues != null) {\n            synchronized (m_noticeQueues) {\n                noticeQueue = m_noticeQueues.get(queueID);\n            }\n        }\n        long now = System.currentTimeMillis();\n\n        if (getUserManager().hasUser(targetName)) {\n            NotificationTask newTask = makeUserTask(now, params, noticeId, targetName, commands, null, null);\n\n            if (newTask != null) {\n                noticeQueue.putItem(now, newTask);\n            }\n        } else if (targetName.indexOf(\"@\") > -1) {\n            NotificationTask newTask = makeEmailTask(now, params, noticeId, targetName, commands, null, null);\n\n            if (newTask != null) {\n                synchronized (noticeQueue) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            }\n        } else {\n            log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n        }\n    }","commit_id":"6c98f26fc0597c9753d691da78e19484e7c137cd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setNoticeQueues(Map<String, NoticeQueue> noticeQueues) {\n        synchronized(m_noticeQueues) {\n            m_noticeQueues = noticeQueues;\n        }\n    }","id":76454,"modified_method":"public void setNoticeQueues(Map<String, NoticeQueue> noticeQueues) {\n        m_noticeQueues = noticeQueues;\n    }","commit_id":"6c98f26fc0597c9753d691da78e19484e7c137cd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void processQueue() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        synchronized(m_noticeQueue) {\n            try {\n                Long now = new Long(System.currentTimeMillis());\n                SortedMap<Long, List<NotificationTask>> readyNotices = m_noticeQueue.headMap(now);\n    \n                for (List<NotificationTask> list : readyNotices.values()) {\n                    for (NotificationTask task : list) {\n                        startTask(task);\n                    }\n                }\n                readyNotices.clear();\n    \n                log.debug(\"current state of tree: \");\n                log.debug(\"\\n\" + m_noticeQueue);\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n                \n            }\n        }\n    }","id":76455,"modified_method":"/**\n     * \n     */\n    public void processQueue() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_noticeQueue != null) {\n            synchronized(m_noticeQueue) {\n                try {\n                    Long now = new Long(System.currentTimeMillis());\n                    SortedMap<Long, List<NotificationTask>> readyNotices = m_noticeQueue.headMap(now);\n        \n                    for (List<NotificationTask> list : readyNotices.values()) {\n                        for (NotificationTask task : list) {\n                            startTask(task);\n                        }\n                    }\n                    readyNotices.clear();\n        \n                    log.debug(\"current state of tree: \");\n                    log.debug(\"\\n\" + m_noticeQueue);\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                    \n                }\n            }\n        }\n    }","commit_id":"6c98f26fc0597c9753d691da78e19484e7c137cd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void setNoticeQueue(NoticeQueue noticeQueue) {\n        synchronized (m_noticeQueue) {\n            m_noticeQueue = noticeQueue;\n        }\n    }","id":76456,"modified_method":"/**\n     * \n     */\n    public synchronized void setNoticeQueue(NoticeQueue noticeQueue) {\n        m_noticeQueue = noticeQueue;\n    }","commit_id":"6c98f26fc0597c9753d691da78e19484e7c137cd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, NoticeQueue> getNoticeQueues() {\n        synchronized(m_noticeQueues) {\n            return m_noticeQueues;\n        }\n    }","id":76457,"modified_method":"public synchronized Map<String, NoticeQueue> getNoticeQueues() {\n        return m_noticeQueues;\n    }","commit_id":"e76d2b02da51793d4c9bb49da48e5884f2574348","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void sendResolvedNotificationsToUser(String queueID, String targetName, String[] commands, Map<String, String> params) throws Exception {\n        int noticeId = -1;\n        synchronized(m_noticeQueues) {\n            NoticeQueue noticeQueue = m_noticeQueues.get(queueID);\n            long now = System.currentTimeMillis();\n    \n            if (getUserManager().hasUser(targetName)) {\n                NotificationTask newTask = makeUserTask(now, params, noticeId, targetName, commands, null, null);\n    \n                if (newTask != null) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            } else if (targetName.indexOf(\"@\") > -1) {\n                NotificationTask newTask = makeEmailTask(now, params, noticeId, targetName, commands, null, null);\n    \n                if (newTask != null) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","id":76458,"modified_method":"protected void sendResolvedNotificationsToUser(String queueID, String targetName, String[] commands, Map<String, String> params) throws Exception {\n        int noticeId = -1;\n        NoticeQueue noticeQueue = null;\n        if (m_noticeQueues != null) {\n            synchronized (m_noticeQueues) {\n                noticeQueue = m_noticeQueues.get(queueID);\n            }\n        }\n        long now = System.currentTimeMillis();\n\n        if (getUserManager().hasUser(targetName)) {\n            NotificationTask newTask = makeUserTask(now, params, noticeId, targetName, commands, null, null);\n\n            if (newTask != null) {\n                noticeQueue.putItem(now, newTask);\n            }\n        } else if (targetName.indexOf(\"@\") > -1) {\n            NotificationTask newTask = makeEmailTask(now, params, noticeId, targetName, commands, null, null);\n\n            if (newTask != null) {\n                synchronized (noticeQueue) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            }\n        } else {\n            log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n        }\n    }","commit_id":"e76d2b02da51793d4c9bb49da48e5884f2574348","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setNoticeQueues(Map<String, NoticeQueue> noticeQueues) {\n        synchronized(m_noticeQueues) {\n            m_noticeQueues = noticeQueues;\n        }\n    }","id":76459,"modified_method":"public void setNoticeQueues(Map<String, NoticeQueue> noticeQueues) {\n        m_noticeQueues = noticeQueues;\n    }","commit_id":"e76d2b02da51793d4c9bb49da48e5884f2574348","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private void processTargets(Target[] targets, List<NotificationTask> targetSiblings, NoticeQueue noticeQueue, long startTime, Map<String, String> params, int noticeId) throws IOException, MarshalException, ValidationException {\n        for (int i = 0; i < targets.length; i++) {\n            String interval = (targets[i].getInterval() == null ? \"0s\" : targets[i].getInterval());\n\n            String targetName = targets[i].getName();\n            String autoNotify = targets[i].getAutoNotify();\n            if(autoNotify != null) {\n                if(autoNotify.equalsIgnoreCase(\"on\")) {\n                    autoNotify = \"Y\";\n                } else if(autoNotify.equalsIgnoreCase(\"off\")) {\n                    autoNotify = \"N\";\n                } else {\n                    autoNotify = \"C\";\n                }\n            } else {\n                autoNotify = \"C\";\n            }\n            if (log().isDebugEnabled()) {\n                log().debug(\"Processing target \" + targetName + \":\" + interval);\n            }\n            \n            NotificationTask[] tasks = null;\n            \n            if (getGroupManager().hasGroup((targetName))) {\n                tasks = makeGroupTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasRole(targetName)) {\n                tasks = makeRoleTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasUser(targetName)) {\n                NotificationTask[] userTasks = { makeUserTask(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify) };\n                tasks = userTasks;\n            } else if (targetName.indexOf(\"@\") > -1) {\n            \t// Bug 2027 -- get the command name from the Notifd config instead of using default of \"email\"\n            \tString[] emailCommands = { getNotifdConfigManager().getConfiguration().getEmailAddressCommand() };\n                NotificationTask[] emailTasks = { makeEmailTask(startTime, params, noticeId, targetName, emailCommands, targetSiblings, autoNotify) };\n                tasks = emailTasks;\n            }\n             \n            if (tasks != null) {\n                for (int index = 0; index < tasks.length; index++) {\n                    NotificationTask task = tasks[index];\n                    if (task != null) {\n                        noticeQueue.putItem(task.getSendTime(), task);\n                        targetSiblings.add(task);\n                    }\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","id":76460,"modified_method":"/**\n     * \n     */\n    private void processTargets(Target[] targets, List<NotificationTask> targetSiblings, NoticeQueue noticeQueue, long startTime, Map<String, String> params, int noticeId) throws IOException, MarshalException, ValidationException {\n        for (int i = 0; i < targets.length; i++) {\n            String interval = (targets[i].getInterval() == null ? \"0s\" : targets[i].getInterval());\n\n            String targetName = targets[i].getName();\n            String autoNotify = targets[i].getAutoNotify();\n            if(autoNotify != null) {\n                if(autoNotify.equalsIgnoreCase(\"on\")) {\n                    autoNotify = \"Y\";\n                } else if(autoNotify.equalsIgnoreCase(\"off\")) {\n                    autoNotify = \"N\";\n                } else {\n                    autoNotify = \"C\";\n                }\n            } else {\n                autoNotify = \"C\";\n            }\n            if (log().isDebugEnabled()) {\n                log().debug(\"Processing target \" + targetName + \":\" + interval);\n            }\n            \n            NotificationTask[] tasks = null;\n            \n            if (getGroupManager().hasGroup((targetName))) {\n                tasks = makeGroupTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasRole(targetName)) {\n                tasks = makeRoleTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasUser(targetName)) {\n                NotificationTask[] userTasks = { makeUserTask(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify) };\n                tasks = userTasks;\n            } else if (targetName.indexOf(\"@\") > -1) {\n            \t// Bug 2027 -- get the command name from the Notifd config instead of using default of \"email\"\n            \tString[] emailCommands = { getNotifdConfigManager().getConfiguration().getEmailAddressCommand() };\n                NotificationTask[] emailTasks = { makeEmailTask(startTime, params, noticeId, targetName, emailCommands, targetSiblings, autoNotify) };\n                tasks = emailTasks;\n            }\n             \n            if (tasks != null) {\n                for (int index = 0; index < tasks.length; index++) {\n                    NotificationTask task = tasks[index];\n                    if (task != null) {\n                        synchronized(noticeQueue) {\n                            noticeQueue.putItem(task.getSendTime(), task);\n                        }\n                        targetSiblings.add(task);\n                    }\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","commit_id":"e76d2b02da51793d4c9bb49da48e5884f2574348","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void setNoticeQueue(NoticeQueue noticeQueue) {\n        synchronized (m_noticeQueue) {\n            m_noticeQueue = noticeQueue;\n        }\n    }","id":76461,"modified_method":"/**\n     * \n     */\n    public synchronized void setNoticeQueue(NoticeQueue noticeQueue) {\n        m_noticeQueue = noticeQueue;\n    }","commit_id":"e76d2b02da51793d4c9bb49da48e5884f2574348","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void processQueue() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        synchronized(m_noticeQueue) {\n            try {\n                Long now = new Long(System.currentTimeMillis());\n                SortedMap<Long, List<NotificationTask>> readyNotices = m_noticeQueue.headMap(now);\n    \n                for (List<NotificationTask> list : readyNotices.values()) {\n                    for (NotificationTask task : list) {\n                        startTask(task);\n                    }\n                }\n                readyNotices.clear();\n    \n                log.debug(\"current state of tree: \");\n                log.debug(\"\\n\" + m_noticeQueue);\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n                \n            }\n        }\n    }","id":76462,"modified_method":"/**\n     * \n     */\n    public void processQueue() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_noticeQueue != null) {\n            synchronized(m_noticeQueue) {\n                try {\n                    Long now = new Long(System.currentTimeMillis());\n                    SortedMap<Long, List<NotificationTask>> readyNotices = m_noticeQueue.headMap(now);\n        \n                    for (List<NotificationTask> list : readyNotices.values()) {\n                        for (NotificationTask task : list) {\n                            startTask(task);\n                        }\n                    }\n                    readyNotices.clear();\n        \n                    log.debug(\"current state of tree: \");\n                    log.debug(\"\\n\" + m_noticeQueue);\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                    \n                }\n            }\n        }\n    }","commit_id":"e76d2b02da51793d4c9bb49da48e5884f2574348","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Map<String, NoticeQueue> getNoticeQueues() {\n        synchronized(m_noticeQueues) {\n            return m_noticeQueues;\n        }\n    }","id":76463,"modified_method":"public synchronized Map<String, NoticeQueue> getNoticeQueues() {\n        return m_noticeQueues;\n    }","commit_id":"9081b32296c65092fcf997427cbff7639f4dc72c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setNoticeQueues(Map<String, NoticeQueue> noticeQueues) {\n        synchronized(m_noticeQueues) {\n            m_noticeQueues = noticeQueues;\n        }\n    }","id":76464,"modified_method":"public void setNoticeQueues(Map<String, NoticeQueue> noticeQueues) {\n        m_noticeQueues = noticeQueues;\n    }","commit_id":"9081b32296c65092fcf997427cbff7639f4dc72c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void sendResolvedNotificationsToUser(String queueID, String targetName, String[] commands, Map<String, String> params) throws Exception {\n        int noticeId = -1;\n        synchronized(m_noticeQueues) {\n            NoticeQueue noticeQueue = m_noticeQueues.get(queueID);\n            long now = System.currentTimeMillis();\n    \n            if (getUserManager().hasUser(targetName)) {\n                NotificationTask newTask = makeUserTask(now, params, noticeId, targetName, commands, null, null);\n    \n                if (newTask != null) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            } else if (targetName.indexOf(\"@\") > -1) {\n                NotificationTask newTask = makeEmailTask(now, params, noticeId, targetName, commands, null, null);\n    \n                if (newTask != null) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","id":76465,"modified_method":"protected void sendResolvedNotificationsToUser(String queueID, String targetName, String[] commands, Map<String, String> params) throws Exception {\n        int noticeId = -1;\n        NoticeQueue noticeQueue = null;\n        if (m_noticeQueues != null) {\n            synchronized (m_noticeQueues) {\n                noticeQueue = m_noticeQueues.get(queueID);\n            }\n        }\n        long now = System.currentTimeMillis();\n\n        if (getUserManager().hasUser(targetName)) {\n            NotificationTask newTask = makeUserTask(now, params, noticeId, targetName, commands, null, null);\n\n            if (newTask != null) {\n                noticeQueue.putItem(now, newTask);\n            }\n        } else if (targetName.indexOf(\"@\") > -1) {\n            NotificationTask newTask = makeEmailTask(now, params, noticeId, targetName, commands, null, null);\n\n            if (newTask != null) {\n                synchronized (noticeQueue) {\n                    noticeQueue.putItem(now, newTask);\n                }\n            }\n        } else {\n            log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n        }\n    }","commit_id":"9081b32296c65092fcf997427cbff7639f4dc72c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    private void processTargets(Target[] targets, List<NotificationTask> targetSiblings, NoticeQueue noticeQueue, long startTime, Map<String, String> params, int noticeId) throws IOException, MarshalException, ValidationException {\n        for (int i = 0; i < targets.length; i++) {\n            String interval = (targets[i].getInterval() == null ? \"0s\" : targets[i].getInterval());\n\n            String targetName = targets[i].getName();\n            String autoNotify = targets[i].getAutoNotify();\n            if(autoNotify != null) {\n                if(autoNotify.equalsIgnoreCase(\"on\")) {\n                    autoNotify = \"Y\";\n                } else if(autoNotify.equalsIgnoreCase(\"off\")) {\n                    autoNotify = \"N\";\n                } else {\n                    autoNotify = \"C\";\n                }\n            } else {\n                autoNotify = \"C\";\n            }\n            if (log().isDebugEnabled()) {\n                log().debug(\"Processing target \" + targetName + \":\" + interval);\n            }\n            \n            NotificationTask[] tasks = null;\n            \n            if (getGroupManager().hasGroup((targetName))) {\n                tasks = makeGroupTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasRole(targetName)) {\n                tasks = makeRoleTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasUser(targetName)) {\n                NotificationTask[] userTasks = { makeUserTask(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify) };\n                tasks = userTasks;\n            } else if (targetName.indexOf(\"@\") > -1) {\n            \t// Bug 2027 -- get the command name from the Notifd config instead of using default of \"email\"\n            \tString[] emailCommands = { getNotifdConfigManager().getConfiguration().getEmailAddressCommand() };\n                NotificationTask[] emailTasks = { makeEmailTask(startTime, params, noticeId, targetName, emailCommands, targetSiblings, autoNotify) };\n                tasks = emailTasks;\n            }\n             \n            if (tasks != null) {\n                for (int index = 0; index < tasks.length; index++) {\n                    NotificationTask task = tasks[index];\n                    if (task != null) {\n                        noticeQueue.putItem(task.getSendTime(), task);\n                        targetSiblings.add(task);\n                    }\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","id":76466,"modified_method":"/**\n     * \n     */\n    private void processTargets(Target[] targets, List<NotificationTask> targetSiblings, NoticeQueue noticeQueue, long startTime, Map<String, String> params, int noticeId) throws IOException, MarshalException, ValidationException {\n        for (int i = 0; i < targets.length; i++) {\n            String interval = (targets[i].getInterval() == null ? \"0s\" : targets[i].getInterval());\n\n            String targetName = targets[i].getName();\n            String autoNotify = targets[i].getAutoNotify();\n            if(autoNotify != null) {\n                if(autoNotify.equalsIgnoreCase(\"on\")) {\n                    autoNotify = \"Y\";\n                } else if(autoNotify.equalsIgnoreCase(\"off\")) {\n                    autoNotify = \"N\";\n                } else {\n                    autoNotify = \"C\";\n                }\n            } else {\n                autoNotify = \"C\";\n            }\n            if (log().isDebugEnabled()) {\n                log().debug(\"Processing target \" + targetName + \":\" + interval);\n            }\n            \n            NotificationTask[] tasks = null;\n            \n            if (getGroupManager().hasGroup((targetName))) {\n                tasks = makeGroupTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasRole(targetName)) {\n                tasks = makeRoleTasks(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify, TimeConverter.convertToMillis(interval));\n            } else if (getUserManager().hasUser(targetName)) {\n                NotificationTask[] userTasks = { makeUserTask(startTime, params, noticeId, targetName, targets[i].getCommand(), targetSiblings, autoNotify) };\n                tasks = userTasks;\n            } else if (targetName.indexOf(\"@\") > -1) {\n            \t// Bug 2027 -- get the command name from the Notifd config instead of using default of \"email\"\n            \tString[] emailCommands = { getNotifdConfigManager().getConfiguration().getEmailAddressCommand() };\n                NotificationTask[] emailTasks = { makeEmailTask(startTime, params, noticeId, targetName, emailCommands, targetSiblings, autoNotify) };\n                tasks = emailTasks;\n            }\n             \n            if (tasks != null) {\n                for (int index = 0; index < tasks.length; index++) {\n                    NotificationTask task = tasks[index];\n                    if (task != null) {\n                        synchronized(noticeQueue) {\n                            noticeQueue.putItem(task.getSendTime(), task);\n                        }\n                        targetSiblings.add(task);\n                    }\n                }\n            } else {\n                log().warn(\"Unrecognized target '\" + targetName + \"' contained in destinationPaths.xml. Please check the configuration.\");\n            }\n        }\n    }","commit_id":"9081b32296c65092fcf997427cbff7639f4dc72c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void setNoticeQueue(NoticeQueue noticeQueue) {\n        synchronized (m_noticeQueue) {\n            m_noticeQueue = noticeQueue;\n        }\n    }","id":76467,"modified_method":"/**\n     * \n     */\n    public synchronized void setNoticeQueue(NoticeQueue noticeQueue) {\n        m_noticeQueue = noticeQueue;\n    }","commit_id":"9081b32296c65092fcf997427cbff7639f4dc72c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void processQueue() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        synchronized(m_noticeQueue) {\n            try {\n                Long now = new Long(System.currentTimeMillis());\n                SortedMap<Long, List<NotificationTask>> readyNotices = m_noticeQueue.headMap(now);\n    \n                for (List<NotificationTask> list : readyNotices.values()) {\n                    for (NotificationTask task : list) {\n                        startTask(task);\n                    }\n                }\n                readyNotices.clear();\n    \n                log.debug(\"current state of tree: \");\n                log.debug(\"\\n\" + m_noticeQueue);\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n                \n            }\n        }\n    }","id":76468,"modified_method":"/**\n     * \n     */\n    public void processQueue() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (m_noticeQueue != null) {\n            synchronized(m_noticeQueue) {\n                try {\n                    Long now = new Long(System.currentTimeMillis());\n                    SortedMap<Long, List<NotificationTask>> readyNotices = m_noticeQueue.headMap(now);\n        \n                    for (List<NotificationTask> list : readyNotices.values()) {\n                        for (NotificationTask task : list) {\n                            startTask(task);\n                        }\n                    }\n                    readyNotices.clear();\n        \n                    log.debug(\"current state of tree: \");\n                    log.debug(\"\\n\" + m_noticeQueue);\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                    \n                }\n            }\n        }\n    }","commit_id":"9081b32296c65092fcf997427cbff7639f4dc72c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void synchronize() {\n      super.synchronizeViewWithModel();\n      myPropertyCell_nwl53h_a0a.synchronize();\n      myPropertyCell_nwl53h_a1a.synchronize();\n      myPropertyCell_nwl53h_a2a.synchronize();\n      syncPortObjects(Component_Behavior.call_retrieveInPorts_9095678365530118263(getSNode()), myInputPorts.listIterator(), new HashSet<SNode>(myInputPorts));\n      syncPortObjects(Component_Behavior.call_retrieveOutPorts_9095678365530123411(getSNode()), myOutputPorts.listIterator(), new HashSet<SNode>(myOutputPorts));\n    }","id":76469,"modified_method":"public void synchronize() {\n      super.synchronizeViewWithModel();\n      myPropertyCell_nwl53h_a0a.synchronize();\n      myPropertyCell_nwl53h_a1a.synchronize();\n      myPropertyCell_nwl53h_a2a.synchronize();\n      syncPortObjects(SLinkOperations.getTargets(getSNode(), \"in\", true), myInputPorts.listIterator(), new HashSet<SNode>(myInputPorts));\n      syncPortObjects(SLinkOperations.getTargets(getSNode(), \"out\", true), myOutputPorts.listIterator(), new HashSet<SNode>(myOutputPorts));\n    }","commit_id":"536a92ecd3abd67af7aac486e9fd16328ea5af52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void synchronize() {\n      myInputPort.set(MultiTuple.<SNode>from(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(getSNode()), \"jetbrains.mps.samples.componentDependencies.structure.Component\"), \"out\", true)));\n      myOutputPort.set(MultiTuple.<SNode>from(SLinkOperations.getTarget(SLinkOperations.getTarget(getSNode(), \"to\", false), \"in\", true)));\n    }","id":76470,"modified_method":"public void synchronize() {\n      myInputPort.set(MultiTuple.<SNode>from(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(SNodeOperations.getParent(getSNode()), \"jetbrains.mps.samples.componentDependencies.structure.Component\"), \"out\", true)).first()));\n      myOutputPort.set(MultiTuple.<SNode>from(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(getSNode(), \"to\", false), \"in\", true)).first()));\n    }","commit_id":"536a92ecd3abd67af7aac486e9fd16328ea5af52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b, conceptFqName)) {\n      case 0:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.Component\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\").properties(\"x\", \"y\").children(new String[]{\"dep\", \"in\", \"out\"}, new boolean[]{true, false, false}).create();\n      case 1:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.ComponentSet\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\").properties(\"query\").children(new String[]{\"component\", \"dependency\"}, new boolean[]{true, true}).create();\n      case 2:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.Dependency\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\").references(\"to\").alias(\"depends on\", \"\").create();\n      case 3:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.InPort\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\").create();\n      case 4:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.OutPort\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\").create();\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","id":76471,"modified_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b, conceptFqName)) {\n      case 0:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.Component\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\").properties(\"x\", \"y\").children(new String[]{\"dep\", \"in\", \"out\"}, new boolean[]{true, true, true}).create();\n      case 1:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.ComponentSet\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\").properties(\"query\").children(new String[]{\"component\"}, new boolean[]{true}).create();\n      case 2:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.Dependency\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\").references(\"to\").alias(\"depends on\", \"\").create();\n      case 3:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.InPort\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\").create();\n      case 4:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.componentDependencies.structure.OutPort\").super_(\"jetbrains.mps.lang.core.structure.BaseConcept\").parents(\"jetbrains.mps.lang.core.structure.BaseConcept\").create();\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","commit_id":"536a92ecd3abd67af7aac486e9fd16328ea5af52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Element toXml() {\n    return new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element simpleElement_49w4x6_a0a0d = new Element(\"address\");\n        Text text_49w4x6_a0a0a0d = new Text(Address.this.getAddressString());\n        simpleElement_49w4x6_a0a0d.addContent(text_49w4x6_a0a0a0d);\n        return simpleElement_49w4x6_a0a0d;\n      }\n    }.invoke();\n  }","id":76472,"modified_method":"public Element toXml() {\n    return new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element simpleElement_49w4x6_a0a0d = new Element(\"address\");\n        Text text_49w4x6_a0a0a3 = new Text(Address.this.getAddressString());\n        simpleElement_49w4x6_a0a0d.addContent(text_49w4x6_a0a0a3);\n        return simpleElement_49w4x6_a0a0d;\n      }\n    }.invoke();\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Element toXml() {\n    return new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element simpleElement_jqm3zu_a0a0k = new Element(\"person\");\n        Element simpleElement_jqm3zu_a0a0a0k = new Element(\"name\");\n        Text text_jqm3zu_a0a0a0a0k = new Text(Person.this.getName());\n        simpleElement_jqm3zu_a0a0a0k.addContent(text_jqm3zu_a0a0a0a0k);\n        Element simpleElement_jqm3zu_b0a0a0k = new Element(\"lastName\");\n        Text text_jqm3zu_a0b0a0a0k = new Text(Person.this.getLastName());\n        simpleElement_jqm3zu_b0a0a0k.addContent(text_jqm3zu_a0b0a0a0k);\n        Element simpleElement_jqm3zu_c0a0a0k = new Element(\"address\");\n        Element elementMacro_jqm3zu_a0c0a0a0k = Person.this.getAddress().toXml();\n        simpleElement_jqm3zu_c0a0a0k.addContent(elementMacro_jqm3zu_a0c0a0a0k);\n        simpleElement_jqm3zu_a0a0a0k.addContent(simpleElement_jqm3zu_a0a0a0k);\n        simpleElement_jqm3zu_b0a0a0k.addContent(simpleElement_jqm3zu_b0a0a0k);\n        simpleElement_jqm3zu_c0a0a0k.addContent(simpleElement_jqm3zu_c0a0a0k);\n        return simpleElement_jqm3zu_a0a0k;\n      }\n    }.invoke();\n  }","id":76473,"modified_method":"public Element toXml() {\n    return new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element simpleElement_jqm3zu_a0a0k = new Element(\"person\");\n        Element simpleElement_jqm3zu_a0a0a01 = new Element(\"name\");\n        Text text_jqm3zu_a0a0a0k = new Text(Person.this.getName());\n        simpleElement_jqm3zu_a0a0a01.addContent(text_jqm3zu_a0a0a0k);\n        Element simpleElement_jqm3zu_b0a0a01 = new Element(\"lastName\");\n        Text text_jqm3zu_a1a0a0k = new Text(Person.this.getLastName());\n        simpleElement_jqm3zu_b0a0a01.addContent(text_jqm3zu_a1a0a0k);\n        Element simpleElement_jqm3zu_c0a0a01 = new Element(\"address\");\n        Element elementMacro_jqm3zu_a2a0a0k = Person.this.getAddress().toXml();\n        simpleElement_jqm3zu_c0a0a01.addContent(elementMacro_jqm3zu_a2a0a0k);\n        simpleElement_jqm3zu_a0a0k.addContent(simpleElement_jqm3zu_a0a0a01);\n        simpleElement_jqm3zu_a0a0k.addContent(simpleElement_jqm3zu_b0a0a01);\n        simpleElement_jqm3zu_a0a0k.addContent(simpleElement_jqm3zu_c0a0a01);\n        return simpleElement_jqm3zu_a0a0k;\n      }\n    }.invoke();\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_7946777123643247113(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), \"text\");\n  }","id":76474,"modified_method":"public static Object propertyMacro_GetPropertyValue_7946777123643247113(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), \"value\");\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6512904248380125038(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"contentToVariable\");\n  }","id":76475,"modified_method":"public static Object referenceMacro_GetReferent_258516944916638126(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"contentToVariable\");\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_7417816926334662396(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), \"jetbrains.mps.xmlInternal.structure.SimpleElement\"), \"elementName\", true);\n  }","id":76476,"modified_method":"public static SNode sourceNodeQuery_5081393330032716823(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SNodeOperations.getNextSibling(_context.getNode());\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_7417816926334692616(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), \"attributeDeclaration\", false), \"name\");\n  }","id":76477,"modified_method":"public static Object propertyMacro_GetPropertyValue_7417816926334692616(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), \"attrName\");\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_7946777123643247149(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return ListSequence.fromList(SLinkOperations.getTargets(_context.getNode(), \"text\", true)).first();\n  }","id":76478,"modified_method":"public static SNode sourceNodeQuery_5081393330032805846(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SNodeOperations.getNextSibling(_context.getNode());\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_7417816926334692632(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"value\", true);\n  }","id":76479,"modified_method":"public static SNode sourceNodeQuery_7417816926334692632(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return ListSequence.fromList(SLinkOperations.getTargets(_context.getNode(), \"value\", true)).first();\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean ifMacro_Condition_7417816926334662357(final IOperationContext operationContext, final IfMacroContext _context) {\n    return SNodeOperations.isInstanceOf(_context.getNode(), \"jetbrains.mps.xmlInternal.structure.SimpleElement\");\n  }","id":76480,"modified_method":"public static boolean ifMacro_Condition_5081393330032741683(final IOperationContext operationContext, final IfMacroContext _context) {\n    return (SNodeOperations.getNextSibling(_context.getNode()) == null);\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_7417816926334599975(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SNodeOperations.getNextSibling(_context.getNode());\n  }","id":76481,"modified_method":"public static SNode sourceNodeQuery_5081393330032735285(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SNodeOperations.getNextSibling(_context.getNode());\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_7417816926334662377(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), \"jetbrains.mps.xml.structure.Element\"), \"elementDeclaration\", false), \"name\");\n  }","id":76482,"modified_method":"public static Object propertyMacro_GetPropertyValue_5081393330032691231(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), \"text\");\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_7417816926334825640(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    return SLinkOperations.getTargets(SLinkOperations.getTarget(_context.getNode(), \"contentList\", true), \"content\", true);\n  }","id":76483,"modified_method":"public static Iterable sourceNodesQuery_258516944916661196(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    return SLinkOperations.getTargets(_context.getNode(), \"content\", true);\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object propertyMacro_GetPropertyValue_7417816926334692680(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), \"attributeName\");\n  }","id":76484,"modified_method":"public static Object propertyMacro_GetPropertyValue_5081393330032741712(final IOperationContext operationContext, final PropertyMacroContext _context) {\n    return SPropertyOperations.getString(_context.getNode(), \"entityName\");\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_7417816926334692038(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    return SLinkOperations.getTargets(_context.getNode(), \"attribute\", true);\n  }","id":76485,"modified_method":"public static Iterable sourceNodesQuery_7417816926334692038(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    return SLinkOperations.getTargets(_context.getNode(), \"attributes\", true);\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_6512904248380125046(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    return SLinkOperations.getTargets(SLinkOperations.getTarget(_context.getNode(), \"contentList\", true), \"content\", true);\n  }","id":76486,"modified_method":"public static Iterable sourceNodesQuery_6512904248380125046(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    return SLinkOperations.getTargets(_context.getNode(), \"content\", true);\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_7417816926334692701(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"value\", true);\n  }","id":76487,"modified_method":"public static SNode sourceNodeQuery_5081393330032741695(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SNodeOperations.getNextSibling(_context.getNode());\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b, conceptFqName)) {\n      case 0:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.xmlLiterals.structure.ElementMacro\").super_(\"jetbrains.mps.xml.structure.Content\").parents(\"jetbrains.mps.xml.structure.Content\").children(new String[]{\"expression\"}, new boolean[]{false}).alias(\"$${\", \"element macro\").create();\n      case 1:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.xmlLiterals.structure.TextMacro\").super_(\"jetbrains.mps.xml.structure.BaseText\").parents(\"jetbrains.mps.xml.structure.BaseText\").children(new String[]{\"expression\"}, new boolean[]{false}).alias(\"${\", \"\").create();\n      case 2:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.xmlLiterals.structure.XmlLiteral\").super_(\"jetbrains.mps.baseLanguage.structure.Expression\").parents(\"jetbrains.mps.baseLanguage.structure.Expression\").children(new String[]{\"element\"}, new boolean[]{false}).alias(\"xml literal\", \"\").staticScope(StaticScope.NONE).create();\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","id":76488,"modified_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b, conceptFqName)) {\n      case 0:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.xmlLiterals.structure.ElementMacro\").super_(\"jetbrains.mps.core.xml.structure.XmlContent\").parents(\"jetbrains.mps.core.xml.structure.XmlContent\").children(new String[]{\"expression\"}, new boolean[]{false}).alias(\"$${\", \"element macro\").create();\n      case 1:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.xmlLiterals.structure.TextMacro\").super_(\"jetbrains.mps.core.xml.structure.XmlText\").parents(\"jetbrains.mps.core.xml.structure.XmlText\").children(new String[]{\"expression\"}, new boolean[]{false}).alias(\"${\", \"\").create();\n      case 2:\n        return new ConceptDescriptorBuilder(\"jetbrains.mps.samples.xmlLiterals.structure.XmlLiteral\").super_(\"jetbrains.mps.baseLanguage.structure.Expression\").parents(\"jetbrains.mps.baseLanguage.structure.Expression\").children(new String[]{\"element\"}, new boolean[]{false}).alias(\"xml literal\", \"\").staticScope(StaticScope.NONE).create();\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","commit_id":"58ea232930292157bfbfea00cca4931549c3d556","url":"https://github.com/JetBrains/MPS"},{"original_method":"public JCVariableDecl build() {\n        if (built) {\n            throw new IllegalStateException();\n        }\n        built = true;\n        List<JCAnnotation> annots = List.nil();\n        if (!noAnnotations && !ignored) {\n            annots = annots.appendList(gen.makeAtName(name));\n            if (sequenced) {\n                annots = annots.appendList(gen.makeAtSequenced());\n            }\n            if (defaulted) {\n                annots = annots.appendList(gen.makeAtDefaulted());\n            }\n            if (typeAnnos != null) {\n                annots = annots.appendList(typeAnnos);\n            }\n            if (annos != null) {\n                annots = annots.appendList(gen.makeAtAnnotations(annos));\n            }\n        }else if(ignored){\n            annots = annots.appendList(gen.makeAtIgnore());\n        }\n        Name name = gen.names().fromString(aliasedName != null ? aliasedName : this.name);\n        return gen.make().VarDef(gen.make().Modifiers(modifiers | Flags.PARAMETER, annots), \n                name, type, null);   \n    }","id":76489,"modified_method":"public JCVariableDecl build() {\n        if (built) {\n            throw new IllegalStateException();\n        }\n        built = true;\n        ListBuffer<JCAnnotation> annots = ListBuffer.lb();\n        if (!noAnnotations && !ignored) {\n            annots.appendList(gen.makeAtName(name));\n            if (sequenced) {\n                annots.appendList(gen.makeAtSequenced());\n            }\n            if (defaulted) {\n                annots.appendList(gen.makeAtDefaulted());\n            }\n            if (typeAnnos != null) {\n                annots.appendList(typeAnnos);\n            }\n            if (annotations != null) {\n                annots.appendList(annotations.toList());\n            }\n            if (modelAnnotations != null) {\n                annots.appendList(modelAnnotations.toList());\n            }\n        }else if(ignored){\n            annots = annots.appendList(gen.makeAtIgnore());\n        }\n        Name name = gen.names().fromString(aliasedName != null ? aliasedName : this.name);\n        return gen.make().VarDef(gen.make().Modifiers(modifiers | Flags.PARAMETER, annots.toList()), \n                name, type, null);   \n    }","commit_id":"e7f46d1e8bece38b722cdfc9141643c71bef2f0c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public ParameterDefinitionBuilder modelAnnotations(java.util.List<Annotation> annos) {\n        this.annos = annos;\n        return this;\n    }","id":76490,"modified_method":"public ParameterDefinitionBuilder modelAnnotations(java.util.List<Annotation> annos) {\n        if (annos != null) {\n            if (this.modelAnnotations == null) {\n                this.modelAnnotations = ListBuffer.lb();\n            }\n            this.modelAnnotations.appendList(gen.makeAtAnnotations(annos));\n        }\n        return this;\n    }","commit_id":"e7f46d1e8bece38b722cdfc9141643c71bef2f0c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        public void flush() throws IOException {\n            if (closed) {\n                throw new IllegalStateException(\n                        sm.getString(\"wsRemoteEndpoint.closedOutputStream\"));\n            }\n\n            doWrite(false);\n        }","id":76491,"modified_method":"@Override\n        public void flush() throws IOException {\n            if (closed) {\n                throw new IllegalStateException(\n                        sm.getString(\"wsRemoteEndpoint.closedOutputStream\"));\n            }\n\n            if (buffer.position() > 0) {\n                doWrite(false);\n            }\n        }","commit_id":"80b1aedd642c06b741953cf7219578bd0a9ffbec","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public void flush() throws IOException {\n            if (closed) {\n                throw new IllegalStateException(\n                        sm.getString(\"wsRemoteEndpoint.closedWriter\"));\n            }\n\n            doWrite(false);\n        }","id":76492,"modified_method":"@Override\n        public void flush() throws IOException {\n            if (closed) {\n                throw new IllegalStateException(\n                        sm.getString(\"wsRemoteEndpoint.closedWriter\"));\n            }\n\n            if (buffer.position() > 0) {\n                doWrite(false);\n            }\n        }","commit_id":"80b1aedd642c06b741953cf7219578bd0a9ffbec","url":"https://github.com/apache/tomcat"},{"original_method":"public void write() {\n            // Write the header\n            while (headerBuffer.hasRemaining() && outputBuffer.hasRemaining()) {\n                outputBuffer.put(headerBuffer.get());\n            }\n            if (headerBuffer.hasRemaining()) {\n                // Still more headers to write, need to flush\n                flushRequired = true;\n                outputBuffer.flip();\n                endpoint.doWrite(this, outputBuffer);\n                return;\n            }\n\n            // Write the payload\n            while (payload.hasRemaining() && outputBuffer.hasRemaining()) {\n                outputBuffer.put(\n                        (byte) (payload.get() ^ (mask[maskIndex++] & 0xFF)));\n                if (maskIndex > 3) {\n                    maskIndex = 0;\n                }\n            }\n            if (payload.hasRemaining()) {\n                // Still more headers to write, need to flush\n                flushRequired = true;\n                outputBuffer.flip();\n                endpoint.doWrite(this, outputBuffer);\n                return;\n            }\n\n            if (flushRequired) {\n                outputBuffer.flip();\n                endpoint.doWrite(this, outputBuffer);\n                flushRequired = false;\n                return;\n            } else {\n                handler.onResult(new SendResult());\n            }\n        }","id":76493,"modified_method":"public void write() {\n            // Write the header\n            while (headerBuffer.hasRemaining() && outputBuffer.hasRemaining()) {\n                outputBuffer.put(headerBuffer.get());\n            }\n            if (headerBuffer.hasRemaining()) {\n                // Still more headers to write, need to flush\n                flushRequired = true;\n                outputBuffer.flip();\n                endpoint.doWrite(this, outputBuffer);\n                return;\n            }\n\n            // Write the payload\n            while (payload.hasRemaining() && outputBuffer.hasRemaining()) {\n                outputBuffer.put(\n                        (byte) (payload.get() ^ (mask[maskIndex++] & 0xFF)));\n                if (maskIndex > 3) {\n                    maskIndex = 0;\n                }\n            }\n            if (payload.hasRemaining()) {\n                // Still more headers to write, need to flush\n                flushRequired = true;\n                outputBuffer.flip();\n                endpoint.doWrite(this, outputBuffer);\n                return;\n            }\n\n            if (flushRequired) {\n                flushRequired = false;\n                outputBuffer.flip();\n                if (outputBuffer.remaining() == 0) {\n                    handler.onResult(new SendResult());\n                } else {\n                    endpoint.doWrite(this, outputBuffer);\n                }\n            } else {\n                handler.onResult(new SendResult());\n            }\n        }","commit_id":"ddcc3a38b0fe03d3d3ac51b3e1f403d11efd4b01","url":"https://github.com/apache/tomcat"},{"original_method":"private static String identifyCPU()\n    {\n        // http://en.wikipedia.org/wiki/Cpuid\n        String modelString = null;\n        int family = CPUID.getCPUFamily();\n        int model = CPUID.getCPUModel();\n        if (family == 15) {\n            family += CPUID.getCPUExtendedFamily();\n            model += CPUID.getCPUExtendedModel() << 4;\n        }\n\n        switch (family) {\n        //i486 class (Am486, 5x86) \n          case 4: {\n            switch (model) {\n                case 3:\n                    modelString = \"486 DX/2\";\n                    break;\n                case 7:\n                    modelString = \"486 DX/2-WB\";\n                    break;\n                case 8:\n                    modelString = \"486 DX/4\";\n                    break;\n                case 9:\n                    modelString = \"486 DX/4-WB\";\n                    break;\n                case 14:\n                    modelString = \"Am5x86-WT\";\n                    break;\n                case 15:\n                    modelString = \"Am5x86-WB\";\n                    break;\n                default:\n                    modelString = \"AMD 486/586 model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //i586 class (K5/K6/K6-2/K6-III) \n        // ref: http://support.amd.com/TechDocs/20734.pdf\n          case 5: {\n            isK6Compatible = true;\n            switch (model) {\n                case 0:\n                    modelString = \"K5/SSA5\";\n                    break;\n                case 1:\n                case 2:\n                case 3:\n                    modelString = \"K5\";\n                    break;\n                case 4:\n                    isK6Compatible = false;\n                    isGeodeCompatible = true;\n                    modelString = \"Geode GX1/GXLV/GXm\";\n                    break;\n                case 5:\n                    isK6Compatible = false;\n                    isGeodeCompatible = true;\n                    modelString = \"Geode GX2/LX\";\n                    break;\n                case 6:\n                case 7:\n                    modelString = \"K6\";\n                    break;\n                case 8:\n                    isK6_2_Compatible = true;\n                    modelString = \"K6-2\";\n                    break;\n                case 9:\n                    isK6_2_Compatible = true;\n                    isK6_3_Compatible = true;\n                    modelString = \"K6-3\";\n                    break;\n                case 13:\n                    isK6_2_Compatible = true;\n                    modelString = \"K6-2+ or K6-III+\";\n                    break;\n                default:\n                    modelString = \"AMD K5/K6 model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //i686 class (Athlon/Athlon XP/Duron/K7 Sempron) \n        // ref: http://support.amd.com/TechDocs/20734.pdf\n          case 6: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            switch (model) {\n                case 0:\n                case 1:\n                    modelString = \"Athlon (250 nm)\";\n                    break;\n                case 2:\n                    modelString = \"Athlon (180 nm)\";\n                    break;\n                case 3:\n                    modelString = \"Duron\";\n                    break;\n                case 4:\n                    modelString = \"Athlon (Thunderbird)\";\n                    break;\n                case 6:\n                    modelString = \"Athlon (Palamino)\";\n                    break;\n                case 7:\n                    modelString = \"Duron (Morgan)\";\n                    break;\n                case 8:\n                    modelString = \"Athlon (Thoroughbred)\";\n                    break;\n                case 10:\n                    modelString = \"Athlon (Barton)\";\n                    break;\n                default:\n                    modelString = \"AMD Athlon/Duron model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //AMD64 class (A64/Opteron/A64 X2/K8 Sempron/Turion/Second-Generation Opteron/Athlon Neo) \n        // ref: http://support.amd.com/TechDocs/33610.PDF\n          case 15: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isX64 = true;\n            switch (model) {\n                case 4:\n                    modelString = \"Athlon 64/Mobile XP-M\";\n                    break;\n                case 5:\n                    modelString = \"Athlon 64 FX Opteron\";\n                    break;\n                case 7:\n                    modelString = \"Athlon 64 FX (Sledgehammer S939, 130 nm)\";\n                    break;\n                case 8:\n                    modelString = \"Mobile A64/Sempron/XP-M\";\n                    break;\n                case 11:\n                    modelString = \"Athlon 64 (Clawhammer S939, 130 nm)\";\n                    break;\n                case 12:\n                case 14:\n                    modelString = \"Athlon 64/Sempron (Newcastle S754, 130 nm)\";\n                    break;\n                case 15:\n                    modelString = \"Athlon 64/Sempron (Clawhammer S939, 130 nm)\";\n                    break;                    \n                // everything below here was broken prior to 0.9.16\n                case 18:\n                    modelString = \"Sempron (Palermo, 90 nm)\";\n                    break;\n                case 20:\n                    modelString = \"Athlon 64 (Winchester S754, 90 nm)\";\n                    break;\n                case 23:\n                    modelString = \"Athlon 64 (Winchester S939, 90 nm)\";\n                    break;\n                case 24:\n                    modelString = \"Mobile A64/Sempron/XP-M (Winchester S754, 90 nm)\";\n                    break;\n                case 26:\n                    modelString = \"Athlon 64 (Winchester S939, 90 nm)\";\n                    break;\n                case 27:\n                    modelString = \"Athlon 64/Sempron (Winchester/Palermo 90 nm)\";\n                    break;\n                case 28:\n                    modelString = \"Sempron (Palermo, 90 nm)\";\n                    break;\n                case 31:\n                    modelString = \"Athlon 64/Sempron (Winchester/Palermo, 90 nm)\";\n                    break;\n                case 33:\n                    modelString = \"Dual-Core Opteron (Italy-Egypt S940, 90 nm)\";\n                    break;\n                case 35:\n                    modelString = \"Athlon 64 X2/A64 FX/Opteron (Toledo/Denmark S939, 90 nm)\";\n                    break;\n                case 36:\n                    modelString = \"Mobile A64/Turion (Lancaster/Richmond/Newark, 90 nm)\";\n                    break;\n                case 37:\n                    modelString = \"Opteron (Troy/Athens S940, 90 nm)\";\n                    break;\n                case 39:\n                    modelString = \"Athlon 64 (San Diego, 90 nm)\";\n                    break;\n                case 43:\n                    modelString = \"Athlon 64 X2 (Manchester, 90 nm)\";\n                    break;\n                case 44:\n                    modelString = \"Sempron/mobile Sempron (Palermo/Albany/Roma S754, 90 nm)\";\n                    break;\n                case 47:\n                    modelString = \"Athlon 64/Sempron (Venice/Palermo S939, 90 nm)\";\n                    break;\n                case 65:\n                    modelString = \"Second-Generaton Opteron (Santa Rosa S1207, 90 nm)\";\n                    break;\n                case 67:\n                    modelString = \"Athlon 64 X2/2nd-gen Opteron (Windsor/Santa Rosa, 90 nm)\";\n                    break;\n                case 72:\n                    modelString = \"Athlon 64 X2/Turion 64 X2 (Windsor/Taylor/Trinidad, 90 nm)\";\n                    break;\n                case 75:\n                    modelString = \"Athlon 64 X2 (Windsor, 90 nm)\";\n                    break;\n                case 76:\n                    modelString = \"Mobile A64/mobile Sempron/Turion (Keene/Trinidad/Taylor, 90 nm)\";\n                    break;\n                case 79:\n                    modelString = \"Athlon 64/Sempron (Orleans/Manila AM2, 90 nm)\";\n                    break;\n                case 93:\n                    modelString = \"Opteron Gen 2 (Santa Rosa, 90 nm)\";\n                    break;\n                case 95:\n                    modelString = \"A64/Sempron/mobile Sempron (Orleans/Manila/Keene, 90 nm)\";\n                    break;\n                case 104:\n                    modelString = \"Turion 64 X2 (Tyler S1, 65 nm)\";\n                    break;\n                case 107:\n                    modelString = \"Athlon 64 X2/Sempron X2/Athlon Neo X2 (Brisbane/Huron, 65 nm)\";\n                    break;\n                case 108:\n                    modelString = \"A64/Athlon Neo/Sempron/Mobile Sempron (Lima/Huron/Sparta/Sherman, 65 nm)\";\n                    break;\n                case 111:\n                    modelString = \"Neo/Sempron/mobile Sempron (Huron/Sparta/Sherman, 65 nm)\";\n                    break;\n                case 124:\n                    modelString = \"Athlon/Sempron/mobile Sempron (Lima/Sparta/Sherman, 65 nm)\";\n                    break;\n                case 127:\n                    modelString = \"A64/Athlon Neo/Sempron/mobile Sempron (Lima/Huron/Sparta/Sherman, 65 nm)\";\n                    break;\n                case 193:\n                    modelString = \"Athlon 64 FX (Windsor S1207 90 nm)\";\n                    break;\n                default:\n                    modelString = \"AMD Athlon/Duron/Sempron model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //Stars (Phenom II/Athlon II/Third-Generation Opteron/Opteron 4100 & 6100/Sempron 1xx) \n          case 16: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isX64 = true;\n            switch (model) {\n                case 2:\n                    modelString = \"Phenom / Athlon / Opteron Gen 3 (Barcelona/Agena/Toliman/Kuma, 65 nm)\";\n                    break;\n                case 4:\n                    modelString = \"Phenom II / Opteron Gen 3 (Shanghai/Deneb/Heka/Callisto, 45 nm)\";\n                    break;\n                case 5:\n                    modelString = \"Athlon II X2/X3/X4 (Regor/Rana/Propus AM3, 45 nm)\";\n                    break;\n                case 6:\n                    modelString = \"Mobile Athlon II/Turion II/Phenom II/Sempron/V-series (Regor/Caspian/Champlain, 45 nm)\";\n                    break;\n                case 8:\n                    modelString = \"Six-Core Opteron/Opteron 4100 series (Istanbul/Lisbon, 45 nm)\";\n                    break;\n                case 9:\n                    modelString = \"Opteron 6100 series (Magny-Cours G34, 45 nm)\";\n                    break;\n                case 10:\n                    modelString = \"Phenom II X4/X6 (Zosma/Thuban AM3, 45 nm)\";\n                    break;\n                default:\n                    modelString = \"AMD Athlon/Opteron model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //K8 mobile+HT3 (Turion X2/Athlon X2/Sempron) \n          case 17: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isX64 = true;\n            switch (model) {\n                case 3:\n                    modelString = \"AMD Turion X2/Athlon X2/Sempron (Lion/Sable, 65 nm)\";\n                    break;\n                default:\n                    modelString = \"AMD Athlon/Turion/Sempron model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        // APUs\n        // http://en.wikipedia.org/wiki/List_of_AMD_Accelerated_Processing_Unit_microprocessors\n          case 18: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isX64 = true;\n            modelString = \"AMD Llano/Trinity/Brazos model \" + model;\n          }\n          break;\n\n        //Bobcat\n          case 20: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isBobcatCompatible = true;\n            isX64 = true;\n            switch (model) {\n                case 1:                    \n                // Case 3 is uncertain but most likely a Bobcat APU\n                case 3:\n                    modelString = \"Bobcat APU\";\n                    break;\n                default:\n                    modelString = \"AMD Bobcat model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //Bulldozer\n          case 21: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isBobcatCompatible = true;\n            isBulldozerCompatible = true;\n            isX64 = true;\n            switch (model) {\n                case 1:                    \n                    modelString = \"Bulldozer FX-6000/8000\";\n                    break;\n                default:\n                    modelString = \"AMD Bulldozer model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //Jaguar\n          case 22: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isBobcatCompatible = true;\n            isX64 = true;\n            modelString = \"AMD Jaguar model \" + model;\n          }\n          break;\n        }\n        return modelString;\n    }","id":76494,"modified_method":"private static String identifyCPU()\n    {\n        // http://en.wikipedia.org/wiki/Cpuid\n        String modelString = null;\n        int family = CPUID.getCPUFamily();\n        int model = CPUID.getCPUModel();\n        if (family == 15) {\n            family += CPUID.getCPUExtendedFamily();\n            model += CPUID.getCPUExtendedModel() << 4;\n        }\n\n        switch (family) {\n        //i486 class (Am486, 5x86) \n          case 4: {\n            switch (model) {\n                case 3:\n                    modelString = \"486 DX/2\";\n                    break;\n                case 7:\n                    modelString = \"486 DX/2-WB\";\n                    break;\n                case 8:\n                    modelString = \"486 DX/4\";\n                    break;\n                case 9:\n                    modelString = \"486 DX/4-WB\";\n                    break;\n                case 14:\n                    modelString = \"Am5x86-WT\";\n                    break;\n                case 15:\n                    modelString = \"Am5x86-WB\";\n                    break;\n                default:\n                    modelString = \"AMD 486/586 model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //i586 class (K5/K6/K6-2/K6-III) \n        // ref: http://support.amd.com/TechDocs/20734.pdf\n          case 5: {\n            isK6Compatible = true;\n            switch (model) {\n                case 0:\n                    modelString = \"K5/SSA5\";\n                    break;\n                case 1:\n                case 2:\n                case 3:\n                    modelString = \"K5\";\n                    break;\n                case 4:\n                    isK6Compatible = false;\n                    isGeodeCompatible = true;\n                    modelString = \"Geode GX1/GXLV/GXm\";\n                    break;\n                case 5:\n                    isK6Compatible = false;\n                    isGeodeCompatible = true;\n                    modelString = \"Geode GX2/LX\";\n                    break;\n                case 6:\n                case 7:\n                    modelString = \"K6\";\n                    break;\n                case 8:\n                    isK6_2_Compatible = true;\n                    modelString = \"K6-2\";\n                    break;\n                case 9:\n                    isK6_2_Compatible = true;\n                    isK6_3_Compatible = true;\n                    modelString = \"K6-3\";\n                    break;\n                case 13:\n                    isK6_2_Compatible = true;\n                    modelString = \"K6-2+ or K6-III+\";\n                    break;\n                default:\n                    modelString = \"AMD K5/K6 model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //i686 class (Athlon/Athlon XP/Duron/K7 Sempron) \n        // ref: http://support.amd.com/TechDocs/20734.pdf\n          case 6: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            switch (model) {\n                case 0:\n                case 1:\n                    modelString = \"Athlon (250 nm)\";\n                    break;\n                case 2:\n                    modelString = \"Athlon (180 nm)\";\n                    break;\n                case 3:\n                    modelString = \"Duron\";\n                    break;\n                case 4:\n                    modelString = \"Athlon (Thunderbird)\";\n                    break;\n                case 6:\n                    modelString = \"Athlon (Palamino)\";\n                    break;\n                case 7:\n                    modelString = \"Duron (Morgan)\";\n                    break;\n                case 8:\n                    modelString = \"Athlon (Thoroughbred)\";\n                    break;\n                case 10:\n                    modelString = \"Athlon (Barton)\";\n                    break;\n                default:\n                    modelString = \"AMD Athlon/Duron model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //AMD64 class (A64/Opteron/A64 X2/K8 Sempron/Turion/Second-Generation Opteron/Athlon Neo) \n        // ref: http://support.amd.com/TechDocs/33610.PDF\n          case 15: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isX64 = true;\n            switch (model) {\n                case 4:\n                    modelString = \"Athlon 64/Mobile XP-M\";\n                    break;\n                case 5:\n                    modelString = \"Athlon 64 FX Opteron\";\n                    break;\n                case 7:\n                    modelString = \"Athlon 64 FX (Sledgehammer S939, 130 nm)\";\n                    break;\n                case 8:\n                    modelString = \"Mobile A64/Sempron/XP-M\";\n                    break;\n                case 11:\n                    modelString = \"Athlon 64 (Clawhammer S939, 130 nm)\";\n                    break;\n                case 12:\n                case 14:\n                    modelString = \"Athlon 64/Sempron (Newcastle S754, 130 nm)\";\n                    break;\n                case 15:\n                    modelString = \"Athlon 64/Sempron (Clawhammer S939, 130 nm)\";\n                    break;                    \n                // everything below here was broken prior to 0.9.16\n                case 18:\n                    modelString = \"Sempron (Palermo, 90 nm)\";\n                    break;\n                case 20:\n                    modelString = \"Athlon 64 (Winchester S754, 90 nm)\";\n                    break;\n                case 23:\n                    modelString = \"Athlon 64 (Winchester S939, 90 nm)\";\n                    break;\n                case 24:\n                    modelString = \"Mobile A64/Sempron/XP-M (Winchester S754, 90 nm)\";\n                    break;\n                case 26:\n                    modelString = \"Athlon 64 (Winchester S939, 90 nm)\";\n                    break;\n                case 27:\n                    modelString = \"Athlon 64/Sempron (Winchester/Palermo 90 nm)\";\n                    break;\n                case 28:\n                    modelString = \"Sempron (Palermo, 90 nm)\";\n                    break;\n                case 31:\n                    modelString = \"Athlon 64/Sempron (Winchester/Palermo, 90 nm)\";\n                    break;\n                case 33:\n                    modelString = \"Dual-Core Opteron (Italy-Egypt S940, 90 nm)\";\n                    break;\n                case 35:\n                    modelString = \"Athlon 64 X2/A64 FX/Opteron (Toledo/Denmark S939, 90 nm)\";\n                    break;\n                case 36:\n                    modelString = \"Mobile A64/Turion (Lancaster/Richmond/Newark, 90 nm)\";\n                    break;\n                case 37:\n                    modelString = \"Opteron (Troy/Athens S940, 90 nm)\";\n                    break;\n                case 39:\n                    modelString = \"Athlon 64 (San Diego, 90 nm)\";\n                    break;\n                case 43:\n                    modelString = \"Athlon 64 X2 (Manchester, 90 nm)\";\n                    break;\n                case 44:\n                    modelString = \"Sempron/mobile Sempron (Palermo/Albany/Roma S754, 90 nm)\";\n                    break;\n                case 47:\n                    modelString = \"Athlon 64/Sempron (Venice/Palermo S939, 90 nm)\";\n                    break;\n                case 65:\n                    modelString = \"Second-Generaton Opteron (Santa Rosa S1207, 90 nm)\";\n                    break;\n                case 67:\n                    modelString = \"Athlon 64 X2/2nd-gen Opteron (Windsor/Santa Rosa, 90 nm)\";\n                    break;\n                case 72:\n                    modelString = \"Athlon 64 X2/Turion 64 X2 (Windsor/Taylor/Trinidad, 90 nm)\";\n                    break;\n                case 75:\n                    modelString = \"Athlon 64 X2 (Windsor, 90 nm)\";\n                    break;\n                case 76:\n                    modelString = \"Mobile A64/mobile Sempron/Turion (Keene/Trinidad/Taylor, 90 nm)\";\n                    break;\n                case 79:\n                    modelString = \"Athlon 64/Sempron (Orleans/Manila AM2, 90 nm)\";\n                    break;\n                case 93:\n                    modelString = \"Opteron Gen 2 (Santa Rosa, 90 nm)\";\n                    break;\n                case 95:\n                    modelString = \"A64/Sempron/mobile Sempron (Orleans/Manila/Keene, 90 nm)\";\n                    break;\n                case 104:\n                    modelString = \"Turion 64 X2 (Tyler S1, 65 nm)\";\n                    break;\n                case 107:\n                    modelString = \"Athlon 64 X2/Sempron X2/Athlon Neo X2 (Brisbane/Huron, 65 nm)\";\n                    break;\n                case 108:\n                    modelString = \"A64/Athlon Neo/Sempron/Mobile Sempron (Lima/Huron/Sparta/Sherman, 65 nm)\";\n                    break;\n                case 111:\n                    modelString = \"Neo/Sempron/mobile Sempron (Huron/Sparta/Sherman, 65 nm)\";\n                    break;\n                case 124:\n                    modelString = \"Athlon/Sempron/mobile Sempron (Lima/Sparta/Sherman, 65 nm)\";\n                    break;\n                case 127:\n                    modelString = \"A64/Athlon Neo/Sempron/mobile Sempron (Lima/Huron/Sparta/Sherman, 65 nm)\";\n                    break;\n                case 193:\n                    modelString = \"Athlon 64 FX (Windsor S1207 90 nm)\";\n                    break;\n                default:\n                    modelString = \"AMD Athlon/Duron/Sempron model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //Stars (Phenom II/Athlon II/Third-Generation Opteron/Opteron 4100 & 6100/Sempron 1xx) \n          case 16: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isX64 = true;\n            switch (model) {\n                case 2:\n                    modelString = \"Phenom / Athlon / Opteron Gen 3 (Barcelona/Agena/Toliman/Kuma, 65 nm)\";\n                    break;\n                case 4:\n                    modelString = \"Phenom II / Opteron Gen 3 (Shanghai/Deneb/Heka/Callisto, 45 nm)\";\n                    break;\n                case 5:\n                    modelString = \"Athlon II X2/X3/X4 (Regor/Rana/Propus AM3, 45 nm)\";\n                    break;\n                case 6:\n                    modelString = \"Mobile Athlon II/Turion II/Phenom II/Sempron/V-series (Regor/Caspian/Champlain, 45 nm)\";\n                    break;\n                case 8:\n                    modelString = \"Six-Core Opteron/Opteron 4100 series (Istanbul/Lisbon, 45 nm)\";\n                    break;\n                case 9:\n                    modelString = \"Opteron 6100 series (Magny-Cours G34, 45 nm)\";\n                    break;\n                case 10:\n                    modelString = \"Phenom II X4/X6 (Zosma/Thuban AM3, 45 nm)\";\n                    break;\n                default:\n                    modelString = \"AMD Athlon/Opteron model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //K8 mobile+HT3 (Turion X2/Athlon X2/Sempron) \n          case 17: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isX64 = true;\n            switch (model) {\n                case 3:\n                    modelString = \"AMD Turion X2/Athlon X2/Sempron (Lion/Sable, 65 nm)\";\n                    break;\n                default:\n                    modelString = \"AMD Athlon/Turion/Sempron model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        // APUs\n        // http://en.wikipedia.org/wiki/List_of_AMD_Accelerated_Processing_Unit_microprocessors\n        // 1st gen Llano high perf / Brazos low power\n        // 2nd gen Trinity high perf / Brazos 2 low power\n        // 3rd gen Kaveri high perf / Kabini/Temash low power\n          case 18: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isX64 = true;\n            modelString = \"AMD APU model \" + model;\n          }\n          break;\n\n        //Bobcat\n          case 20: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isBobcatCompatible = true;\n            isX64 = true;\n            switch (model) {\n                case 1:                    \n                // Case 3 is uncertain but most likely a Bobcat APU\n                case 3:\n                    modelString = \"AMD Bobcat APU\";\n                    break;\n                default:\n                    modelString = \"AMD Bobcat APU model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //Bulldozer\n          case 21: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isBobcatCompatible = true;\n            isBulldozerCompatible = true;\n            isX64 = true;\n            switch (model) {\n                // 32 nm\n                case 1:                    \n                    modelString = \"Bulldozer FX-6100/8100\";\n                    break;\n                // 32 nm\n                case 2:                    \n                    modelString = \"Bulldozer FX-6300/8300\";\n                    break;\n                // 28 nm ?\n                case 3:                    \n                    modelString = \"Bulldozer FX-6500/8500\";\n                    break;\n                default:\n                    modelString = \"AMD Bulldozer model \" + model;\n                    break;\n            }\n          }\n          break;\n\n        //Jaguar\n          case 22: {\n            isK6Compatible = true;\n            isK6_2_Compatible = true;\n            isK6_3_Compatible = true;\n            isAthlonCompatible = true;\n            isAthlon64Compatible = true;\n            isBobcatCompatible = true;\n            isX64 = true;\n            switch (model) {\n                case 0:                    \n                    modelString = \"Athlon 5350 APU\";\n                    break;\n                default:\n                    modelString = \"AMD Jaguar APU model \" + model;\n                    break;\n            }\n          }\n          break;\n        }\n        return modelString;\n    }","commit_id":"a21e3cd8425b71aa0f0c2c00b9a9a7cd6c73270a","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public static void main(String args[])\n    {\n        _doLog = true;\n        if(!_nativeOk){\n            System.out.println(\"**Failed to retrieve CPUInfo. Please verify the existence of jcpuid dll/so**\");\n        }\n        System.out.println(\" **CPUInfo**\");\n        System.out.println(\"CPU Vendor: \" + getCPUVendorID());\n        System.out.println(\"CPU Family: \" + getCPUFamily());\n        System.out.println(\"CPU Model: \" + getCPUModel());\n        System.out.println(\"CPU Stepping: \" + getCPUStepping());\n        System.out.println(\"CPU Flags: 0x\" + Integer.toHexString(getEDXCPUFlags()));\n\n        CPUInfo c = getInfo();\n        System.out.println(\"\\n **More CPUInfo**\");\n        System.out.println(\"CPU model string: \" + c.getCPUModelString());\n        System.out.println(\"CPU has MMX: \" + c.hasMMX());\n        System.out.println(\"CPU has SSE: \" + c.hasSSE());\n        System.out.println(\"CPU has SSE2: \" + c.hasSSE2());\n        System.out.println(\"CPU has SSE3: \" + c.hasSSE3());\n        System.out.println(\"CPU has SSE4.1: \" + c.hasSSE41());\n        System.out.println(\"CPU has SSE4.2: \" + c.hasSSE42());\n        System.out.println(\"CPU has SSE4A: \" + c.hasSSE4A());\n        if(c instanceof IntelCPUInfo){\n            System.out.println(\"\\n **Intel-info**\");\n            System.out.println(\"Is PII-compatible: \"+((IntelCPUInfo)c).IsPentium2Compatible());\n            System.out.println(\"Is PIII-compatible: \"+((IntelCPUInfo)c).IsPentium3Compatible());\n            System.out.println(\"Is PIV-compatible: \"+((IntelCPUInfo)c).IsPentium4Compatible());\n            System.out.println(\"Is Atom-compatible: \"+((IntelCPUInfo)c).IsAtomCompatible());\n            System.out.println(\"Is Pentium M compatible: \"+((IntelCPUInfo)c).IsPentiumMCompatible());\n            System.out.println(\"Is Core2-compatible: \"+((IntelCPUInfo)c).IsCore2Compatible());\n            System.out.println(\"Is Corei-compatible: \"+((IntelCPUInfo)c).IsCoreiCompatible());\n        }\n        if(c instanceof AMDCPUInfo){\n            System.out.println(\"\\n **AMD-info**\");\n            System.out.println(\"Is K6-compatible: \"+((AMDCPUInfo)c).IsK6Compatible());\n            System.out.println(\"Is K6_2-compatible: \"+((AMDCPUInfo)c).IsK6_2_Compatible());\n            System.out.println(\"Is K6_3-compatible: \"+((AMDCPUInfo)c).IsK6_3_Compatible());\n            System.out.println(\"Is K6-compatible: \"+((AMDCPUInfo)c).IsGeodeCompatible());\n            System.out.println(\"Is Athlon-compatible: \"+((AMDCPUInfo)c).IsAthlonCompatible());\n            System.out.println(\"Is Athlon64-compatible: \"+((AMDCPUInfo)c).IsAthlon64Compatible());\n            System.out.println(\"Is Bobcat-compatible: \"+((AMDCPUInfo)c).IsBobcatCompatible());\n        }\n    }","id":76495,"modified_method":"public static void main(String args[])\n    {\n        _doLog = true;\n        if(!_nativeOk){\n            System.out.println(\"**Failed to retrieve CPUInfo. Please verify the existence of jcpuid dll/so**\");\n        }\n        System.out.println(\" **CPUInfo**\");\n        String mname = getCPUModelName();\n        if (mname != null)\n            System.out.println(\"CPU Model Name: \" + mname);\n        System.out.println(\"CPU Vendor: \" + getCPUVendorID());\n        // http://en.wikipedia.org/wiki/Cpuid\n        int family = getCPUFamily();\n        int model = getCPUModel();\n        if (family == 15) {\n            family += getCPUExtendedFamily();\n            model += getCPUExtendedModel() << 4;\n        }\n        System.out.println(\"CPU Family: \" + family);\n        System.out.println(\"CPU Model: \" + model);\n        System.out.println(\"CPU Stepping: \" + getCPUStepping());\n        System.out.println(\"CPU Flags: 0x\" + Integer.toHexString(getEDXCPUFlags()));\n\n        CPUInfo c = getInfo();\n        System.out.println(\"\\n **More CPUInfo**\");\n        System.out.println(\"CPU model string: \" + c.getCPUModelString());\n        System.out.println(\"CPU has MMX: \" + c.hasMMX());\n        System.out.println(\"CPU has SSE: \" + c.hasSSE());\n        System.out.println(\"CPU has SSE2: \" + c.hasSSE2());\n        System.out.println(\"CPU has SSE3: \" + c.hasSSE3());\n        System.out.println(\"CPU has SSE4.1: \" + c.hasSSE41());\n        System.out.println(\"CPU has SSE4.2: \" + c.hasSSE42());\n        System.out.println(\"CPU has SSE4A: \" + c.hasSSE4A());\n        System.out.println(\"CPU has AES-NI: \" + c.hasAES());\n        if(c instanceof IntelCPUInfo){\n            System.out.println(\"\\n **Intel-info**\");\n            System.out.println(\"Is PII-compatible: \"+((IntelCPUInfo)c).IsPentium2Compatible());\n            System.out.println(\"Is PIII-compatible: \"+((IntelCPUInfo)c).IsPentium3Compatible());\n            System.out.println(\"Is PIV-compatible: \"+((IntelCPUInfo)c).IsPentium4Compatible());\n            System.out.println(\"Is Atom-compatible: \"+((IntelCPUInfo)c).IsAtomCompatible());\n            System.out.println(\"Is Pentium M compatible: \"+((IntelCPUInfo)c).IsPentiumMCompatible());\n            System.out.println(\"Is Core2-compatible: \"+((IntelCPUInfo)c).IsCore2Compatible());\n            System.out.println(\"Is Corei-compatible: \"+((IntelCPUInfo)c).IsCoreiCompatible());\n        }\n        if(c instanceof AMDCPUInfo){\n            System.out.println(\"\\n **AMD-info**\");\n            System.out.println(\"Is K6-compatible: \"+((AMDCPUInfo)c).IsK6Compatible());\n            System.out.println(\"Is K6_2-compatible: \"+((AMDCPUInfo)c).IsK6_2_Compatible());\n            System.out.println(\"Is K6_3-compatible: \"+((AMDCPUInfo)c).IsK6_3_Compatible());\n            System.out.println(\"Is K6-compatible: \"+((AMDCPUInfo)c).IsGeodeCompatible());\n            System.out.println(\"Is Athlon-compatible: \"+((AMDCPUInfo)c).IsAthlonCompatible());\n            System.out.println(\"Is Athlon64-compatible: \"+((AMDCPUInfo)c).IsAthlon64Compatible());\n            System.out.println(\"Is Bobcat-compatible: \"+((AMDCPUInfo)c).IsBobcatCompatible());\n        }\n    }","commit_id":"a21e3cd8425b71aa0f0c2c00b9a9a7cd6c73270a","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS = \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned = false;\n      boolean userApproved = \n        (userApprovedParamS != null && Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled = isSecurityEnabled();\n      final String remoteUser = req.getRemoteUser();\n      final String pathInfo = req.getPathInfo();\n\n      String parts[] = pathInfo.split(\"/\", 3);\n      if(parts.length < 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId = parts[1];\n      String rest = parts.length > 2 ? parts[2] : \"\";\n      ApplicationId id = Apps.toAppID(appId);\n      if(id == null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName = getCheckCookieName(id); \n        for(Cookie c: req.getCookies()) {\n          if(cookieName.equals(c.getName())) {\n            userWasWarned = true;\n            userApproved = userApproved || Boolean.valueOf(c.getValue());\n            break;\n          }\n        }\n      }\n      \n      boolean checkUser = securityEnabled && (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport = getApplicationReport(id);\n      if(applicationReport == null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch =\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch != null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri = ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n        String message;\n        switch(applicationReport.getFinalApplicationStatus()) {\n          case FAILED:\n          case KILLED:\n          case SUCCEEDED:\n            message =\n              \"The requested application exited before setting a tracking URL.\";\n            break;\n          case UNDEFINED:\n            message = \"The requested application does not appear to be running \"\n              +\"yet, and has not set a tracking URL.\";\n            break;\n          default:\n            //This should never happen, but just to be safe\n            message = \"The requested application has not set a tracking URL.\";\n            break;\n        }\n        notFound(resp, message);\n        return;\n      }\n\n      String runningUser = applicationReport.getUser();\n      if(checkUser && !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch = new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c = null;\n      if(userWasWarned && userApproved) {\n        c = makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }","id":76496,"modified_method":"@Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS = \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned = false;\n      boolean userApproved = \n        (userApprovedParamS != null && Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled = isSecurityEnabled();\n      final String remoteUser = req.getRemoteUser();\n      final String pathInfo = req.getPathInfo();\n\n      String parts[] = pathInfo.split(\"/\", 3);\n      if(parts.length < 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId = parts[1];\n      String rest = parts.length > 2 ? parts[2] : \"\";\n      ApplicationId id = Apps.toAppID(appId);\n      if(id == null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName = getCheckCookieName(id); \n        Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned = true;\n              userApproved = userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser = securityEnabled && (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport = getApplicationReport(id);\n      if(applicationReport == null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch =\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch != null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      URI trackingUri = ProxyUriUtils.getUriFromAMUrl(\n          applicationReport.getOriginalTrackingUrl());\n      if(applicationReport.getOriginalTrackingUrl().equals(\"N/A\")) {\n        String message;\n        switch(applicationReport.getFinalApplicationStatus()) {\n          case FAILED:\n          case KILLED:\n          case SUCCEEDED:\n            message =\n              \"The requested application exited before setting a tracking URL.\";\n            break;\n          case UNDEFINED:\n            message = \"The requested application does not appear to be running \"\n              +\"yet, and has not set a tracking URL.\";\n            break;\n          default:\n            //This should never happen, but just to be safe\n            message = \"The requested application has not set a tracking URL.\";\n            break;\n        }\n        notFound(resp, message);\n        return;\n      }\n\n      String runningUser = applicationReport.getUser();\n      if(checkUser && !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      \n      URI toFetch = new URI(req.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c = null;\n      if(userWasWarned && userApproved) {\n        c = makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    }\n  }","commit_id":"4b9f0443cb0e35747e0c4ec5f416175b42164a60","url":"https://github.com/apache/hadoop"},{"original_method":"public ServletWebSocketRequest(HttpServletRequest request)\n    {\n        super(request.getRequestURI());\n        this.req = request;\n\n        // Copy Request Line Details\n        setMethod(request.getMethod());\n        setHttpVersion(request.getProtocol());\n\n        // Copy parameters\n        super.setParameterMap(request.getParameterMap());\n\n        // Copy Cookies\n        List<HttpCookie> cookies = new ArrayList<>();\n        for (Cookie rcookie : request.getCookies())\n        {\n            HttpCookie hcookie = new HttpCookie(rcookie.getName(),rcookie.getValue());\n            // no point handling domain/path/expires/secure/httponly on client request cookies\n            cookies.add(hcookie);\n        }\n        super.setCookies(cookies);\n\n        // Copy Headers\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements())\n        {\n            String name = headerNames.nextElement();\n            Enumeration<String> valuesEnum = request.getHeaders(name);\n            List<String> values = new ArrayList<>();\n            while (valuesEnum.hasMoreElements())\n            {\n                values.add(valuesEnum.nextElement());\n            }\n            setHeader(name,values);\n        }\n\n        // Parse Sub Protocols\n        Enumeration<String> protocols = request.getHeaders(\"Sec-WebSocket-Protocol\");\n        List<String> subProtocols = new ArrayList<>();\n        String protocol = null;\n        while ((protocol == null) && (protocols != null) && protocols.hasMoreElements())\n        {\n            String candidate = protocols.nextElement();\n            for (String p : parseProtocols(candidate))\n            {\n                subProtocols.add(p);\n            }\n        }\n        setSubProtocols(subProtocols);\n\n        // Parse Extension Configurations\n        Enumeration<String> e = request.getHeaders(\"Sec-WebSocket-Extensions\");\n        while (e.hasMoreElements())\n        {\n            Iterator<String> extTokenIter = QuoteUtil.splitAt(e.nextElement(),\",\");\n            while (extTokenIter.hasNext())\n            {\n                String extToken = extTokenIter.next();\n                ExtensionConfig config = ExtensionConfig.parse(extToken);\n                addExtensions(config);\n            }\n        }\n    }","id":76497,"modified_method":"public ServletWebSocketRequest(HttpServletRequest request)\n    {\n        super(request.getRequestURI());\n        this.req = request;\n\n        // Copy Request Line Details\n        setMethod(request.getMethod());\n        setHttpVersion(request.getProtocol());\n\n        // Copy parameters\n        super.setParameterMap(request.getParameterMap());\n\n        // Copy Cookies\n        Cookie rcookies[] = request.getCookies();\n        if (rcookies != null)\n        {\n            List<HttpCookie> cookies = new ArrayList<>();\n            for (Cookie rcookie : rcookies)\n            {\n                HttpCookie hcookie = new HttpCookie(rcookie.getName(),rcookie.getValue());\n                // no point handling domain/path/expires/secure/httponly on client request cookies\n                cookies.add(hcookie);\n            }\n            super.setCookies(cookies);\n        }\n\n        // Copy Headers\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements())\n        {\n            String name = headerNames.nextElement();\n            Enumeration<String> valuesEnum = request.getHeaders(name);\n            List<String> values = new ArrayList<>();\n            while (valuesEnum.hasMoreElements())\n            {\n                values.add(valuesEnum.nextElement());\n            }\n            setHeader(name,values);\n        }\n\n        // Parse Sub Protocols\n        Enumeration<String> protocols = request.getHeaders(\"Sec-WebSocket-Protocol\");\n        List<String> subProtocols = new ArrayList<>();\n        String protocol = null;\n        while ((protocol == null) && (protocols != null) && protocols.hasMoreElements())\n        {\n            String candidate = protocols.nextElement();\n            for (String p : parseProtocols(candidate))\n            {\n                subProtocols.add(p);\n            }\n        }\n        setSubProtocols(subProtocols);\n\n        // Parse Extension Configurations\n        Enumeration<String> e = request.getHeaders(\"Sec-WebSocket-Extensions\");\n        while (e.hasMoreElements())\n        {\n            Iterator<String> extTokenIter = QuoteUtil.splitAt(e.nextElement(),\",\");\n            while (extTokenIter.hasNext())\n            {\n                String extToken = extTokenIter.next();\n                ExtensionConfig config = ExtensionConfig.parse(extToken);\n                addExtensions(config);\n            }\n        }\n    }","commit_id":"dd3a918136ecd20ce7bcdcbc9e3794ef4a7edbdd","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static String toString(Cookie cookie) {\n\t\tStringBundler sb = new StringBundler(17);\n\n\t\tsb.append(\"{comment=\");\n\t\tsb.append(cookie.getComment());\n\t\tsb.append(\", domain=\");\n\t\tsb.append(cookie.getDomain());\n\t\tsb.append(\", maxAge=\");\n\t\tsb.append(cookie.getMaxAge());\n\t\tsb.append(\", name=\");\n\t\tsb.append(cookie.getName());\n\t\tsb.append(\", path=\");\n\t\tsb.append(cookie.getPath());\n\t\tsb.append(\", secure=\");\n\t\tsb.append(cookie.getSecure());\n\t\tsb.append(\", value=\");\n\t\tsb.append(cookie.getValue());\n\t\tsb.append(\", version=\");\n\t\tsb.append(cookie.getVersion());\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","id":76498,"modified_method":"public static String toString(Cookie cookie) {\n\t\tStringBundler sb = new StringBundler(19);\n\n\t\tsb.append(\"{comment=\");\n\t\tsb.append(cookie.getComment());\n\t\tsb.append(\", domain=\");\n\t\tsb.append(cookie.getDomain());\n\t\tsb.append(\", httpOnly=\");\n\t\tsb.append(cookie.isHttpOnly());\n\t\tsb.append(\", maxAge=\");\n\t\tsb.append(cookie.getMaxAge());\n\t\tsb.append(\", name=\");\n\t\tsb.append(cookie.getName());\n\t\tsb.append(\", path=\");\n\t\tsb.append(cookie.getPath());\n\t\tsb.append(\", secure=\");\n\t\tsb.append(cookie.getSecure());\n\t\tsb.append(\", value=\");\n\t\tsb.append(cookie.getValue());\n\t\tsb.append(\", version=\");\n\t\tsb.append(cookie.getVersion());\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"af9169fdd5c790a3e8e6df20e2989e105b5d81a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic Cookie[] getCookies() {\n\t\t\treturn cookies;\n\t\t}","id":76499,"modified_method":"@Override\n\t\tpublic Cookie[] getCookies() {\n\t\t\tif (cookiesData == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tCookie[] cookies = new Cookie[cookiesData.length];\n\n\t\t\tfor (int i = 0; i < cookies.length; i++) {\n\t\t\t\tcookies[i] = CookieUtil.deserialize(cookiesData[i]);\n\t\t\t}\n\n\t\t\treturn cookies;\n\t\t}","commit_id":"af9169fdd5c790a3e8e6df20e2989e105b5d81a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SPIAgentRequest(HttpServletRequest request) throws IOException {\n\t\tsuper(\n\t\t\t((Portlet)request.getAttribute(\n\t\t\t\tWebKeys.SPI_AGENT_PORTLET)).getContextName());\n\n\t\tcookies = request.getCookies();\n\t\tdistributedRequestAttributes = extractDistributedRequestAttributes(\n\t\t\trequest, Direction.REQUEST);\n\t\theaderMap = extractRequestHeaders(request);\n\t\tparameterMap = request.getParameterMap();\n\t\tremoteAddr = request.getRemoteAddr();\n\t\tremoteHost = request.getRemoteHost();\n\t\tremotePort = request.getRemotePort();\n\t\tremoteUser = request.getRemoteUser();\n\t\tserverName = request.getServerName();\n\t\tserverPort = request.getServerPort();\n\n\t\tString contentType = request.getContentType();\n\n\t\tif ((contentType != null) &&\n\t\t\tcontentType.startsWith(ContentTypes.MULTIPART)) {\n\n\t\t\tHttpServletRequest currentRequest = request;\n\n\t\t\tUploadServletRequest uploadServletRequest = null;\n\n\t\t\twhile (currentRequest instanceof HttpServletRequestWrapper) {\n\t\t\t\tif (currentRequest instanceof UploadServletRequest) {\n\t\t\t\t\tuploadServletRequest = (UploadServletRequest)currentRequest;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tHttpServletRequestWrapper httpServletRequestWrapper =\n\t\t\t\t\t(HttpServletRequestWrapper)currentRequest;\n\n\t\t\t\tcurrentRequest =\n\t\t\t\t\t(HttpServletRequest)httpServletRequestWrapper.getRequest();\n\t\t\t}\n\n\t\t\tif (uploadServletRequest == null) {\n\t\t\t\tthis.contentType = contentType;\n\n\t\t\t\trequestBodyFile = FileUtil.createTempFile();\n\n\t\t\t\tFileOutputStream fileOutputStream = new FileOutputStream(\n\t\t\t\t\trequestBodyFile);\n\n\t\t\t\ttry {\n\t\t\t\t\tStreamUtil.transfer(\n\t\t\t\t\t\tcurrentRequest.getInputStream(), fileOutputStream,\n\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tfileOutputStream.close();\n\t\t\t\t}\n\n\t\t\t\tuploadServletRequest = new UploadServletRequestImpl(\n\t\t\t\t\tnew AgentHttpServletRequestWrapper(currentRequest));\n\t\t\t}\n\n\t\t\tMap<String, FileItem[]> multipartParameterMap =\n\t\t\t\tuploadServletRequest.getMultipartParameterMap();\n\t\t\tMap<String, List<String>> regularParameterMap =\n\t\t\t\tuploadServletRequest.getRegularParameterMap();\n\n\t\t\tif (!multipartParameterMap.isEmpty()) {\n\t\t\t\tthis.multipartParameterMap = multipartParameterMap;\n\t\t\t}\n\n\t\t\tif (!regularParameterMap.isEmpty()) {\n\t\t\t\tthis.regularParameterMap = regularParameterMap;\n\t\t\t}\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif ((themeDisplay != null) && themeDisplay.isAjax()) {\n\t\t\tparameterMap = new HashMap<String, String[]>(parameterMap);\n\n\t\t\tparameterMap.put(\n\t\t\t\t\"portalResiliencyPortletShowFooter\",\n\t\t\t\tnew String[] {StringPool.FALSE});\n\t\t}\n\n\t\toriginalSessionAttributes = extractSessionAttributes(request);\n\n\t\tcaptureThreadLocals();\n\t}","id":76500,"modified_method":"public SPIAgentRequest(HttpServletRequest request) throws IOException {\n\t\tsuper(\n\t\t\t((Portlet)request.getAttribute(\n\t\t\t\tWebKeys.SPI_AGENT_PORTLET)).getContextName());\n\n\t\tCookie[] cookies = request.getCookies();\n\n\t\tif (cookies != null) {\n\t\t\tcookiesData = new byte[cookies.length][];\n\n\t\t\tfor (int i = 0; i < cookies.length; i++) {\n\t\t\t\tcookiesData[i] = CookieUtil.serialize(cookies[i]);\n\t\t\t}\n\t\t}\n\n\t\tdistributedRequestAttributes = extractDistributedRequestAttributes(\n\t\t\trequest, Direction.REQUEST);\n\t\theaderMap = extractRequestHeaders(request);\n\t\tparameterMap = request.getParameterMap();\n\t\tremoteAddr = request.getRemoteAddr();\n\t\tremoteHost = request.getRemoteHost();\n\t\tremotePort = request.getRemotePort();\n\t\tremoteUser = request.getRemoteUser();\n\t\tserverName = request.getServerName();\n\t\tserverPort = request.getServerPort();\n\n\t\tString contentType = request.getContentType();\n\n\t\tif ((contentType != null) &&\n\t\t\tcontentType.startsWith(ContentTypes.MULTIPART)) {\n\n\t\t\tHttpServletRequest currentRequest = request;\n\n\t\t\tUploadServletRequest uploadServletRequest = null;\n\n\t\t\twhile (currentRequest instanceof HttpServletRequestWrapper) {\n\t\t\t\tif (currentRequest instanceof UploadServletRequest) {\n\t\t\t\t\tuploadServletRequest = (UploadServletRequest)currentRequest;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tHttpServletRequestWrapper httpServletRequestWrapper =\n\t\t\t\t\t(HttpServletRequestWrapper)currentRequest;\n\n\t\t\t\tcurrentRequest =\n\t\t\t\t\t(HttpServletRequest)httpServletRequestWrapper.getRequest();\n\t\t\t}\n\n\t\t\tif (uploadServletRequest == null) {\n\t\t\t\tthis.contentType = contentType;\n\n\t\t\t\trequestBodyFile = FileUtil.createTempFile();\n\n\t\t\t\tFileOutputStream fileOutputStream = new FileOutputStream(\n\t\t\t\t\trequestBodyFile);\n\n\t\t\t\ttry {\n\t\t\t\t\tStreamUtil.transfer(\n\t\t\t\t\t\tcurrentRequest.getInputStream(), fileOutputStream,\n\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tfileOutputStream.close();\n\t\t\t\t}\n\n\t\t\t\tuploadServletRequest = new UploadServletRequestImpl(\n\t\t\t\t\tnew AgentHttpServletRequestWrapper(currentRequest));\n\t\t\t}\n\n\t\t\tMap<String, FileItem[]> multipartParameterMap =\n\t\t\t\tuploadServletRequest.getMultipartParameterMap();\n\t\t\tMap<String, List<String>> regularParameterMap =\n\t\t\t\tuploadServletRequest.getRegularParameterMap();\n\n\t\t\tif (!multipartParameterMap.isEmpty()) {\n\t\t\t\tthis.multipartParameterMap = multipartParameterMap;\n\t\t\t}\n\n\t\t\tif (!regularParameterMap.isEmpty()) {\n\t\t\t\tthis.regularParameterMap = regularParameterMap;\n\t\t\t}\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif ((themeDisplay != null) && themeDisplay.isAjax()) {\n\t\t\tparameterMap = new HashMap<String, String[]>(parameterMap);\n\n\t\t\tparameterMap.put(\n\t\t\t\t\"portalResiliencyPortletShowFooter\",\n\t\t\t\tnew String[] {StringPool.FALSE});\n\t\t}\n\n\t\toriginalSessionAttributes = extractSessionAttributes(request);\n\n\t\tcaptureThreadLocals();\n\t}","commit_id":"af9169fdd5c790a3e8e6df20e2989e105b5d81a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tint length = 20 + parameterMap.size() * 4;\n\n\t\tif (cookies != null) {\n\t\t\tlength += cookies.length * 2 - 1;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(length);\n\n\t\tsb.append(\"{contentType=\");\n\t\tsb.append(contentType);\n\t\tsb.append(\", cookies=[\");\n\n\t\tif (cookies != null) {\n\t\t\tfor (Cookie cookie : cookies) {\n\t\t\t\tsb.append(CookieUtil.toString(cookie));\n\t\t\t\tsb.append(\", \");\n\t\t\t}\n\n\t\t\tsb.setIndex(sb.index() - 1);\n\t\t}\n\n\t\tsb.append(\"], distributedRequestAttributes=\");\n\t\tsb.append(distributedRequestAttributes);\n\t\tsb.append(\", headerMap=\");\n\t\tsb.append(headerMap);\n\t\tsb.append(\", multipartParameterMap=\");\n\t\tsb.append(multipartParameterMap);\n\t\tsb.append(\", originalSessionAttributes=\");\n\t\tsb.append(originalSessionAttributes);\n\t\tsb.append(\", parameterMap={\");\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tsb.append(entry.getKey());\n\t\t\tsb.append(\"=\");\n\t\t\tsb.append(Arrays.toString(entry.getValue()));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(\"}, regularParameterMap=\");\n\t\tsb.append(regularParameterMap);\n\t\tsb.append(\", requestBodyFile=\");\n\t\tsb.append(requestBodyFile);\n\t\tsb.append(\", serverName=\");\n\t\tsb.append(serverName);\n\t\tsb.append(\", serverPort=\");\n\t\tsb.append(serverPort);\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","id":76501,"modified_method":"@Override\n\tpublic String toString() {\n\t\tint length = 20 + parameterMap.size() * 4;\n\n\t\tif (cookiesData != null) {\n\t\t\tlength += cookiesData.length * 2 - 1;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(length);\n\n\t\tsb.append(\"{contentType=\");\n\t\tsb.append(contentType);\n\t\tsb.append(\", cookies=[\");\n\n\t\tif (cookiesData != null) {\n\t\t\tfor (byte[] cookieData : cookiesData) {\n\t\t\t\tCookie cookie = CookieUtil.deserialize(cookieData);\n\n\t\t\t\tsb.append(CookieUtil.toString(cookie));\n\t\t\t\tsb.append(\", \");\n\t\t\t}\n\n\t\t\tsb.setIndex(sb.index() - 1);\n\t\t}\n\n\t\tsb.append(\"], distributedRequestAttributes=\");\n\t\tsb.append(distributedRequestAttributes);\n\t\tsb.append(\", headerMap=\");\n\t\tsb.append(headerMap);\n\t\tsb.append(\", multipartParameterMap=\");\n\t\tsb.append(multipartParameterMap);\n\t\tsb.append(\", originalSessionAttributes=\");\n\t\tsb.append(originalSessionAttributes);\n\t\tsb.append(\", parameterMap={\");\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tsb.append(entry.getKey());\n\t\t\tsb.append(\"=\");\n\t\t\tsb.append(Arrays.toString(entry.getValue()));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(\"}, regularParameterMap=\");\n\t\tsb.append(regularParameterMap);\n\t\tsb.append(\", requestBodyFile=\");\n\t\tsb.append(requestBodyFile);\n\t\tsb.append(\", serverName=\");\n\t\tsb.append(serverName);\n\t\tsb.append(\", serverPort=\");\n\t\tsb.append(serverPort);\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"af9169fdd5c790a3e8e6df20e2989e105b5d81a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testContentTypeIsNull() throws Exception {\n\n\t\t// Captured session attributes\n\n\t\tString threadLocalValue = \"threadLocalValue\";\n\n\t\t_threadLocal.set(threadLocalValue);\n\n\t\tSPIAgentRequest spiAgentRequest = new SPIAgentRequest(\n\t\t\t_mockHttpServletRequest);\n\n\t\t_threadLocal.remove();\n\n\t\tMap<String, Serializable> originalSessionAttributes =\n\t\t\tspiAgentRequest.getOriginalSessionAttributes();\n\n\t\tAssert.assertEquals(2, originalSessionAttributes.size());\n\t\tAssert.assertEquals(\n\t\t\t_SESSION_ATTRIBUTE_VALUE_1,\n\t\t\toriginalSessionAttributes.get(_SESSION_ATTRIBUTE_NAME_1));\n\t\tAssert.assertEquals(\n\t\t\t_SESSION_ATTRIBUTE_VALUE_2,\n\t\t\toriginalSessionAttributes.get(_SESSION_ATTRIBUTE_NAME_2));\n\n\t\t// Cookies\n\n\t\tHttpServletRequest populatedHttpServletRequest =\n\t\t\tspiAgentRequest.populateRequest(new MockHttpServletRequest());\n\n\t\tCookie[] cookies = populatedHttpServletRequest.getCookies();\n\n\t\tAssert.assertEquals(2, cookies.length);\n\t\tAssert.assertSame(_cookie1, cookies[0]);\n\t\tAssert.assertSame(_cookie2, cookies[1]);\n\n\t\t// Headers\n\n\t\tAssert.assertEquals(\n\t\t\t_HEADER_VALUE_1,\n\t\t\tpopulatedHttpServletRequest.getHeader(_HEADER_NAME_1));\n\t\tAssert.assertEquals(\n\t\t\t_HEADER_VALUE_3,\n\t\t\tpopulatedHttpServletRequest.getHeader(_HEADER_NAME_2));\n\t\tAssert.assertNull(\n\t\t\tpopulatedHttpServletRequest.getHeader(_HEADER_NAME_3));\n\t\tAssert.assertNull(\n\t\t\tpopulatedHttpServletRequest.getHeader(_HEADER_NAME_4));\n\n\t\tList<String> headerNames = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaderNames());\n\n\t\tAssert.assertEquals(3, headerNames.size());\n\t\tAssert.assertTrue(\n\t\t\theaderNames.contains(StringUtil.toLowerCase(_HEADER_NAME_1)));\n\t\tAssert.assertTrue(\n\t\t\theaderNames.contains(StringUtil.toLowerCase(_HEADER_NAME_2)));\n\t\tAssert.assertTrue(\n\t\t\theaderNames.contains(StringUtil.toLowerCase(_HEADER_NAME_3)));\n\n\t\tList<String> headers = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaders(_HEADER_NAME_1));\n\n\t\tAssert.assertEquals(2, headers.size());\n\t\tAssert.assertEquals(_HEADER_VALUE_1, headers.get(0));\n\t\tAssert.assertEquals(_HEADER_VALUE_2, headers.get(1));\n\n\t\theaders = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaders(_HEADER_NAME_2));\n\n\t\tAssert.assertEquals(2, headers.size());\n\t\tAssert.assertEquals(_HEADER_VALUE_3, headers.get(0));\n\t\tAssert.assertEquals(_HEADER_VALUE_4, headers.get(1));\n\n\t\theaders = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaders(_HEADER_NAME_3));\n\n\t\tAssert.assertTrue(headers.isEmpty());\n\n\t\theaders = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaders(_HEADER_NAME_4));\n\n\t\tAssert.assertTrue(headers.isEmpty());\n\n\t\t// Parameters\n\n\t\tMap<String, String[]> parameterMap =\n\t\t\tpopulatedHttpServletRequest.getParameterMap();\n\n\t\tAssert.assertEquals(3, parameterMap.size());\n\n\t\tString[] parameter1 = parameterMap.get(_PARAMETER_NAME_1);\n\n\t\tAssert.assertEquals(2, parameter1.length);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_1, parameter1[0]);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_2, parameter1[1]);\n\n\t\tString[] parameter2 = parameterMap.get(_PARAMETER_NAME_2);\n\n\t\tAssert.assertEquals(2, parameter2.length);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_3, parameter2[0]);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_4, parameter2[1]);\n\n\t\tString[] parameter3 = parameterMap.get(_PARAMETER_NAME_3);\n\n\t\tAssert.assertEquals(0, parameter3.length);\n\t\tAssert.assertEquals(\n\t\t\t_PARAMETER_VALUE_1,\n\t\t\tpopulatedHttpServletRequest.getParameter(_PARAMETER_NAME_1));\n\t\tAssert.assertEquals(\n\t\t\t_PARAMETER_VALUE_3,\n\t\t\tpopulatedHttpServletRequest.getParameter(_PARAMETER_NAME_2));\n\t\tAssert.assertNull(\n\t\t\tpopulatedHttpServletRequest.getParameter(_PARAMETER_NAME_3));\n\t\tAssert.assertNull(\n\t\t\tpopulatedHttpServletRequest.getParameter(_PARAMETER_NAME_4));\n\n\t\tList<String> parameterNames = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getParameterNames());\n\n\t\tAssert.assertEquals(3, parameterNames.size());\n\t\tAssert.assertEquals(_PARAMETER_NAME_1, parameterNames.get(0));\n\t\tAssert.assertEquals(_PARAMETER_NAME_2, parameterNames.get(1));\n\t\tAssert.assertEquals(_PARAMETER_NAME_3, parameterNames.get(2));\n\n\t\tparameter1 = populatedHttpServletRequest.getParameterValues(\n\t\t\t_PARAMETER_NAME_1);\n\n\t\tAssert.assertEquals(2, parameter1.length);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_1, parameter1[0]);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_2, parameter1[1]);\n\n\t\tparameter2 = populatedHttpServletRequest.getParameterValues(\n\t\t\t_PARAMETER_NAME_2);\n\n\t\tAssert.assertEquals(2, parameter2.length);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_3, parameter2[0]);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_4, parameter2[1]);\n\n\t\tparameter3 = populatedHttpServletRequest.getParameterValues(\n\t\t\t_PARAMETER_NAME_3);\n\n\t\tAssert.assertEquals(0, parameter3.length);\n\n\t\t// Remote address, host, port, and user\n\n\t\tAssert.assertEquals(\n\t\t\t_REMOTE_ADDR, populatedHttpServletRequest.getRemoteAddr());\n\n\t\tAssert.assertEquals(\n\t\t\t_REMOTE_HOST, populatedHttpServletRequest.getRemoteHost());\n\n\t\tAssert.assertEquals(\n\t\t\t_REMOTE_PORT, populatedHttpServletRequest.getRemotePort());\n\n\t\tAssert.assertEquals(\n\t\t\t_REMOTE_USER, populatedHttpServletRequest.getRemoteUser());\n\n\t\t// Server name\n\n\t\tAssert.assertEquals(\n\t\t\t_SERVER_NAME, populatedHttpServletRequest.getServerName());\n\n\t\t// Server port\n\n\t\tAssert.assertEquals(\n\t\t\t_SERVER_PORT, populatedHttpServletRequest.getServerPort());\n\n\t\tAssert.assertEquals(threadLocalValue, _threadLocal.get());\n\n\t\t// Populated session attributes\n\n\t\tMockHttpSession mockHttpSession = new MockHttpSession();\n\n\t\tspiAgentRequest.populateSessionAttributes(mockHttpSession);\n\n\t\tList<String> attributeNames = ListUtil.fromEnumeration(\n\t\t\tmockHttpSession.getAttributeNames());\n\n\t\tAssert.assertEquals(2, attributeNames.size());\n\t\tAssert.assertTrue(attributeNames.contains(_SESSION_ATTRIBUTE_NAME_1));\n\t\tAssert.assertTrue(attributeNames.contains(_SESSION_ATTRIBUTE_NAME_2));\n\n\t\tAssert.assertEquals(\n\t\t\t_SESSION_ATTRIBUTE_VALUE_1,\n\t\t\tmockHttpSession.getAttribute(_SESSION_ATTRIBUTE_NAME_1));\n\t\tAssert.assertEquals(\n\t\t\t_SESSION_ATTRIBUTE_VALUE_2,\n\t\t\tmockHttpSession.getAttribute(_SESSION_ATTRIBUTE_NAME_2));\n\n\t\t// To string\n\n\t\tStringBundler sb = new StringBundler(\n\t\t\t13 + cookies.length * 2 + parameterMap.size() * 4);\n\n\t\tsb.append(\"{contentType=null, cookies=[\");\n\n\t\tfor (Cookie cookie : cookies) {\n\t\t\tsb.append(CookieUtil.toString(cookie));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(\"], distributedRequestAttributes=\");\n\t\tsb.append(spiAgentRequest.distributedRequestAttributes);\n\t\tsb.append(\", headerMap=\");\n\t\tsb.append(spiAgentRequest.headerMap);\n\t\tsb.append(\", multipartParameterMap=null\");\n\t\tsb.append(\", originalSessionAttributes=\");\n\t\tsb.append(spiAgentRequest.getOriginalSessionAttributes());\n\t\tsb.append(\", parameterMap={\");\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tsb.append(entry.getKey());\n\t\t\tsb.append(\"=\");\n\t\t\tsb.append(Arrays.toString(entry.getValue()));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(\"}, regularParameterMap=null, requestBodyFile=null\");\n\t\tsb.append(\", serverName=\");\n\t\tsb.append(_SERVER_NAME);\n\t\tsb.append(\", serverPort=\");\n\t\tsb.append(_SERVER_PORT);\n\t\tsb.append(\"}\");\n\n\t\tAssert.assertEquals(sb.toString(), spiAgentRequest.toString());\n\n\t\t_mockHttpServletRequest.setCookies((Cookie[])null);\n\n\t\tspiAgentRequest = new SPIAgentRequest(_mockHttpServletRequest);\n\n\t\tsb = new StringBundler(13 + parameterMap.size() * 4);\n\n\t\tsb.append(\n\t\t\t\"{contentType=null, cookies=[], distributedRequestAttributes=\");\n\t\tsb.append(spiAgentRequest.distributedRequestAttributes);\n\t\tsb.append(\", headerMap=\");\n\t\tsb.append(spiAgentRequest.headerMap);\n\t\tsb.append(\", multipartParameterMap=null\");\n\t\tsb.append(\", originalSessionAttributes=\");\n\t\tsb.append(spiAgentRequest.getOriginalSessionAttributes());\n\t\tsb.append(\", parameterMap={\");\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tsb.append(entry.getKey());\n\t\t\tsb.append(\"=\");\n\t\t\tsb.append(Arrays.toString(entry.getValue()));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(\"}, regularParameterMap=null, requestBodyFile=null\");\n\t\tsb.append(\", serverName=\");\n\t\tsb.append(_SERVER_NAME);\n\t\tsb.append(\", serverPort=\");\n\t\tsb.append(_SERVER_PORT);\n\t\tsb.append(\"}\");\n\n\t\tAssert.assertEquals(sb.toString(), spiAgentRequest.toString());\n\t}","id":76502,"modified_method":"@Test\n\tpublic void testContentTypeIsNull() throws Exception {\n\n\t\t// Captured session attributes\n\n\t\tString threadLocalValue = \"threadLocalValue\";\n\n\t\t_threadLocal.set(threadLocalValue);\n\n\t\tSPIAgentRequest spiAgentRequest = new SPIAgentRequest(\n\t\t\t_mockHttpServletRequest);\n\n\t\t_threadLocal.remove();\n\n\t\tMap<String, Serializable> originalSessionAttributes =\n\t\t\tspiAgentRequest.getOriginalSessionAttributes();\n\n\t\tAssert.assertEquals(2, originalSessionAttributes.size());\n\t\tAssert.assertEquals(\n\t\t\t_SESSION_ATTRIBUTE_VALUE_1,\n\t\t\toriginalSessionAttributes.get(_SESSION_ATTRIBUTE_NAME_1));\n\t\tAssert.assertEquals(\n\t\t\t_SESSION_ATTRIBUTE_VALUE_2,\n\t\t\toriginalSessionAttributes.get(_SESSION_ATTRIBUTE_NAME_2));\n\n\t\t// Cookies\n\n\t\tHttpServletRequest populatedHttpServletRequest =\n\t\t\tspiAgentRequest.populateRequest(new MockHttpServletRequest());\n\n\t\tAssert.assertNull(populatedHttpServletRequest.getCookies());\n\n\t\t_mockHttpServletRequest.setCookies(_cookie1, _cookie2);\n\n\t\tspiAgentRequest = new SPIAgentRequest(_mockHttpServletRequest);\n\n\t\tpopulatedHttpServletRequest = spiAgentRequest.populateRequest(\n\t\t\tnew MockHttpServletRequest());\n\n\t\tCookie[] cookies = populatedHttpServletRequest.getCookies();\n\n\t\tAssert.assertEquals(2, cookies.length);\n\t\tAssert.assertTrue(CookieUtil.equals(_cookie1, cookies[0]));\n\t\tAssert.assertTrue(CookieUtil.equals(_cookie2, cookies[1]));\n\n\t\t// Headers\n\n\t\tAssert.assertEquals(\n\t\t\t_HEADER_VALUE_1,\n\t\t\tpopulatedHttpServletRequest.getHeader(_HEADER_NAME_1));\n\t\tAssert.assertEquals(\n\t\t\t_HEADER_VALUE_3,\n\t\t\tpopulatedHttpServletRequest.getHeader(_HEADER_NAME_2));\n\t\tAssert.assertNull(\n\t\t\tpopulatedHttpServletRequest.getHeader(_HEADER_NAME_3));\n\t\tAssert.assertNull(\n\t\t\tpopulatedHttpServletRequest.getHeader(_HEADER_NAME_4));\n\n\t\tList<String> headerNames = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaderNames());\n\n\t\tAssert.assertEquals(3, headerNames.size());\n\t\tAssert.assertTrue(\n\t\t\theaderNames.contains(StringUtil.toLowerCase(_HEADER_NAME_1)));\n\t\tAssert.assertTrue(\n\t\t\theaderNames.contains(StringUtil.toLowerCase(_HEADER_NAME_2)));\n\t\tAssert.assertTrue(\n\t\t\theaderNames.contains(StringUtil.toLowerCase(_HEADER_NAME_3)));\n\n\t\tList<String> headers = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaders(_HEADER_NAME_1));\n\n\t\tAssert.assertEquals(2, headers.size());\n\t\tAssert.assertEquals(_HEADER_VALUE_1, headers.get(0));\n\t\tAssert.assertEquals(_HEADER_VALUE_2, headers.get(1));\n\n\t\theaders = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaders(_HEADER_NAME_2));\n\n\t\tAssert.assertEquals(2, headers.size());\n\t\tAssert.assertEquals(_HEADER_VALUE_3, headers.get(0));\n\t\tAssert.assertEquals(_HEADER_VALUE_4, headers.get(1));\n\n\t\theaders = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaders(_HEADER_NAME_3));\n\n\t\tAssert.assertTrue(headers.isEmpty());\n\n\t\theaders = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getHeaders(_HEADER_NAME_4));\n\n\t\tAssert.assertTrue(headers.isEmpty());\n\n\t\t// Parameters\n\n\t\tMap<String, String[]> parameterMap =\n\t\t\tpopulatedHttpServletRequest.getParameterMap();\n\n\t\tAssert.assertEquals(3, parameterMap.size());\n\n\t\tString[] parameter1 = parameterMap.get(_PARAMETER_NAME_1);\n\n\t\tAssert.assertEquals(2, parameter1.length);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_1, parameter1[0]);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_2, parameter1[1]);\n\n\t\tString[] parameter2 = parameterMap.get(_PARAMETER_NAME_2);\n\n\t\tAssert.assertEquals(2, parameter2.length);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_3, parameter2[0]);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_4, parameter2[1]);\n\n\t\tString[] parameter3 = parameterMap.get(_PARAMETER_NAME_3);\n\n\t\tAssert.assertEquals(0, parameter3.length);\n\t\tAssert.assertEquals(\n\t\t\t_PARAMETER_VALUE_1,\n\t\t\tpopulatedHttpServletRequest.getParameter(_PARAMETER_NAME_1));\n\t\tAssert.assertEquals(\n\t\t\t_PARAMETER_VALUE_3,\n\t\t\tpopulatedHttpServletRequest.getParameter(_PARAMETER_NAME_2));\n\t\tAssert.assertNull(\n\t\t\tpopulatedHttpServletRequest.getParameter(_PARAMETER_NAME_3));\n\t\tAssert.assertNull(\n\t\t\tpopulatedHttpServletRequest.getParameter(_PARAMETER_NAME_4));\n\n\t\tList<String> parameterNames = ListUtil.fromEnumeration(\n\t\t\tpopulatedHttpServletRequest.getParameterNames());\n\n\t\tAssert.assertEquals(3, parameterNames.size());\n\t\tAssert.assertEquals(_PARAMETER_NAME_1, parameterNames.get(0));\n\t\tAssert.assertEquals(_PARAMETER_NAME_2, parameterNames.get(1));\n\t\tAssert.assertEquals(_PARAMETER_NAME_3, parameterNames.get(2));\n\n\t\tparameter1 = populatedHttpServletRequest.getParameterValues(\n\t\t\t_PARAMETER_NAME_1);\n\n\t\tAssert.assertEquals(2, parameter1.length);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_1, parameter1[0]);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_2, parameter1[1]);\n\n\t\tparameter2 = populatedHttpServletRequest.getParameterValues(\n\t\t\t_PARAMETER_NAME_2);\n\n\t\tAssert.assertEquals(2, parameter2.length);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_3, parameter2[0]);\n\t\tAssert.assertEquals(_PARAMETER_VALUE_4, parameter2[1]);\n\n\t\tparameter3 = populatedHttpServletRequest.getParameterValues(\n\t\t\t_PARAMETER_NAME_3);\n\n\t\tAssert.assertEquals(0, parameter3.length);\n\n\t\t// Remote address, host, port, and user\n\n\t\tAssert.assertEquals(\n\t\t\t_REMOTE_ADDR, populatedHttpServletRequest.getRemoteAddr());\n\n\t\tAssert.assertEquals(\n\t\t\t_REMOTE_HOST, populatedHttpServletRequest.getRemoteHost());\n\n\t\tAssert.assertEquals(\n\t\t\t_REMOTE_PORT, populatedHttpServletRequest.getRemotePort());\n\n\t\tAssert.assertEquals(\n\t\t\t_REMOTE_USER, populatedHttpServletRequest.getRemoteUser());\n\n\t\t// Server name\n\n\t\tAssert.assertEquals(\n\t\t\t_SERVER_NAME, populatedHttpServletRequest.getServerName());\n\n\t\t// Server port\n\n\t\tAssert.assertEquals(\n\t\t\t_SERVER_PORT, populatedHttpServletRequest.getServerPort());\n\n\t\tAssert.assertEquals(threadLocalValue, _threadLocal.get());\n\n\t\t// Populated session attributes\n\n\t\tMockHttpSession mockHttpSession = new MockHttpSession();\n\n\t\tspiAgentRequest.populateSessionAttributes(mockHttpSession);\n\n\t\tList<String> attributeNames = ListUtil.fromEnumeration(\n\t\t\tmockHttpSession.getAttributeNames());\n\n\t\tAssert.assertEquals(2, attributeNames.size());\n\t\tAssert.assertTrue(attributeNames.contains(_SESSION_ATTRIBUTE_NAME_1));\n\t\tAssert.assertTrue(attributeNames.contains(_SESSION_ATTRIBUTE_NAME_2));\n\n\t\tAssert.assertEquals(\n\t\t\t_SESSION_ATTRIBUTE_VALUE_1,\n\t\t\tmockHttpSession.getAttribute(_SESSION_ATTRIBUTE_NAME_1));\n\t\tAssert.assertEquals(\n\t\t\t_SESSION_ATTRIBUTE_VALUE_2,\n\t\t\tmockHttpSession.getAttribute(_SESSION_ATTRIBUTE_NAME_2));\n\n\t\t// To string\n\n\t\tStringBundler sb = new StringBundler(\n\t\t\t13 + cookies.length * 2 + parameterMap.size() * 4);\n\n\t\tsb.append(\"{contentType=null, cookies=[\");\n\n\t\tfor (Cookie cookie : cookies) {\n\t\t\tsb.append(CookieUtil.toString(cookie));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(\"], distributedRequestAttributes=\");\n\t\tsb.append(spiAgentRequest.distributedRequestAttributes);\n\t\tsb.append(\", headerMap=\");\n\t\tsb.append(spiAgentRequest.headerMap);\n\t\tsb.append(\", multipartParameterMap=null\");\n\t\tsb.append(\", originalSessionAttributes=\");\n\t\tsb.append(spiAgentRequest.getOriginalSessionAttributes());\n\t\tsb.append(\", parameterMap={\");\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tsb.append(entry.getKey());\n\t\t\tsb.append(\"=\");\n\t\t\tsb.append(Arrays.toString(entry.getValue()));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(\"}, regularParameterMap=null, requestBodyFile=null\");\n\t\tsb.append(\", serverName=\");\n\t\tsb.append(_SERVER_NAME);\n\t\tsb.append(\", serverPort=\");\n\t\tsb.append(_SERVER_PORT);\n\t\tsb.append(\"}\");\n\n\t\tAssert.assertEquals(sb.toString(), spiAgentRequest.toString());\n\n\t\t_mockHttpServletRequest.setCookies((Cookie[])null);\n\n\t\tspiAgentRequest = new SPIAgentRequest(_mockHttpServletRequest);\n\n\t\tsb = new StringBundler(13 + parameterMap.size() * 4);\n\n\t\tsb.append(\n\t\t\t\"{contentType=null, cookies=[], distributedRequestAttributes=\");\n\t\tsb.append(spiAgentRequest.distributedRequestAttributes);\n\t\tsb.append(\", headerMap=\");\n\t\tsb.append(spiAgentRequest.headerMap);\n\t\tsb.append(\", multipartParameterMap=null\");\n\t\tsb.append(\", originalSessionAttributes=\");\n\t\tsb.append(spiAgentRequest.getOriginalSessionAttributes());\n\t\tsb.append(\", parameterMap={\");\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tsb.append(entry.getKey());\n\t\t\tsb.append(\"=\");\n\t\t\tsb.append(Arrays.toString(entry.getValue()));\n\t\t\tsb.append(\", \");\n\t\t}\n\n\t\tsb.setIndex(sb.index() - 1);\n\n\t\tsb.append(\"}, regularParameterMap=null, requestBodyFile=null\");\n\t\tsb.append(\", serverName=\");\n\t\tsb.append(_SERVER_NAME);\n\t\tsb.append(\", serverPort=\");\n\t\tsb.append(_SERVER_PORT);\n\t\tsb.append(\"}\");\n\n\t\tAssert.assertEquals(sb.toString(), spiAgentRequest.toString());\n\t}","commit_id":"af9169fdd5c790a3e8e6df20e2989e105b5d81a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tFileUtil fileUtil = new FileUtil();\n\n\t\tfileUtil.setFile(\n\t\t\tnew FileImpl() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic File createTempFile() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn File.createTempFile(\n\t\t\t\t\t\t\tSPIAgentRequestTest.class.getName(), null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tthrow new RuntimeException(ioe);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t);\n\n\t\tMemoryPortalCacheManager<Serializable, Serializable>\n\t\t\tmemoryPortalCacheManager =\n\t\t\t\tnew MemoryPortalCacheManager<Serializable, Serializable>();\n\n\t\tmemoryPortalCacheManager.afterPropertiesSet();\n\n\t\tMultiVMPoolImpl multiVMPoolImpl = new MultiVMPoolImpl();\n\n\t\tmultiVMPoolImpl.setPortalCacheManager(memoryPortalCacheManager);\n\n\t\tMultiVMPoolUtil multiVMPoolUtil = new MultiVMPoolUtil();\n\n\t\tmultiVMPoolUtil.setMultiVMPool(multiVMPoolImpl);\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\tthreadLocalDistributor.setThreadLocalSources(\n\t\t\tArrays.asList(\n\t\t\t\tnew KeyValuePair(\n\t\t\t\t\tSPIAgentRequestTest.class.getName(), \"_threadLocal\")));\n\n\t\tthreadLocalDistributor.afterPropertiesSet();\n\n\t\t_mockHttpServletRequest = new MockHttpServletRequest() {\n\n\t\t\t@Override\n\t\t\tpublic Enumeration<String> getHeaderNames() {\n\t\t\t\tEnumeration<String> headerNameEnumeration =\n\t\t\t\t\tsuper.getHeaderNames();\n\n\t\t\t\tList<String> headerNames = ListUtil.fromEnumeration(\n\t\t\t\t\theaderNameEnumeration);\n\n\t\t\t\t// Header with no value\n\n\t\t\t\theaderNames.add(_HEADER_NAME_3);\n\n\t\t\t\treturn Collections.enumeration(headerNames);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Map<String, String[]> getParameterMap() {\n\t\t\t\tMap<String, String[]> parameterMap =\n\t\t\t\t\tnew LinkedHashMap<String, String[]>(\n\t\t\t\t\t\tsuper.getParameterMap());\n\n\t\t\t\t// Parameter with no value\n\n\t\t\t\tparameterMap.put(_PARAMETER_NAME_3, new String[0]);\n\n\t\t\t\treturn parameterMap;\n\t\t\t}\n\n\t\t};\n\n\t\t_mockHttpServletRequest.addHeader(_HEADER_NAME_1, _HEADER_VALUE_1);\n\t\t_mockHttpServletRequest.addHeader(_HEADER_NAME_1, _HEADER_VALUE_2);\n\t\t_mockHttpServletRequest.addHeader(_HEADER_NAME_2, _HEADER_VALUE_3);\n\t\t_mockHttpServletRequest.addHeader(_HEADER_NAME_2, _HEADER_VALUE_4);\n\t\t_mockHttpServletRequest.addParameter(\n\t\t\t_PARAMETER_NAME_1, _PARAMETER_VALUE_1);\n\t\t_mockHttpServletRequest.addParameter(\n\t\t\t_PARAMETER_NAME_1, _PARAMETER_VALUE_2);\n\t\t_mockHttpServletRequest.addParameter(\n\t\t\t_PARAMETER_NAME_2, _PARAMETER_VALUE_3);\n\t\t_mockHttpServletRequest.addParameter(\n\t\t\t_PARAMETER_NAME_2, _PARAMETER_VALUE_4);\n\t\t_mockHttpServletRequest.setCookies(_cookie1, _cookie2);\n\t\t_mockHttpServletRequest.setRemoteAddr(_REMOTE_ADDR);\n\t\t_mockHttpServletRequest.setRemoteHost(_REMOTE_HOST);\n\t\t_mockHttpServletRequest.setRemotePort(_REMOTE_PORT);\n\t\t_mockHttpServletRequest.setRemoteUser(_REMOTE_USER);\n\t\t_mockHttpServletRequest.setServerName(_SERVER_NAME);\n\t\t_mockHttpServletRequest.setServerPort(_SERVER_PORT);\n\n\t\tPortlet portlet = new PortletImpl() {\n\n\t\t\t@Override\n\t\t\tpublic String getContextName() {\n\t\t\t\treturn \"SERVLET_CONTEXT_NAME\";\n\t\t\t}\n\n\t\t};\n\n\t\t_mockHttpServletRequest.setAttribute(\n\t\t\tWebKeys.SPI_AGENT_PORTLET, portlet);\n\n\t\tRequestAttributes.setRequestAttributes(_mockHttpServletRequest);\n\n\t\tHttpSession session = _mockHttpServletRequest.getSession();\n\n\t\tsession.setAttribute(\n\t\t\t_SESSION_ATTRIBUTE_NAME_1, _SESSION_ATTRIBUTE_VALUE_1);\n\t\tsession.setAttribute(\n\t\t\t_SESSION_ATTRIBUTE_NAME_2, _SESSION_ATTRIBUTE_VALUE_2);\n\t\tsession.setAttribute(\n\t\t\t_SESSION_ATTRIBUTE_NAME_3, _SESSION_ATTRIBUTE_VALUE_3);\n\t}","id":76503,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tFileUtil fileUtil = new FileUtil();\n\n\t\tfileUtil.setFile(\n\t\t\tnew FileImpl() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic File createTempFile() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn File.createTempFile(\n\t\t\t\t\t\t\tSPIAgentRequestTest.class.getName(), null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tthrow new RuntimeException(ioe);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t);\n\n\t\tMemoryPortalCacheManager<Serializable, Serializable>\n\t\t\tmemoryPortalCacheManager =\n\t\t\t\tnew MemoryPortalCacheManager<Serializable, Serializable>();\n\n\t\tmemoryPortalCacheManager.afterPropertiesSet();\n\n\t\tMultiVMPoolImpl multiVMPoolImpl = new MultiVMPoolImpl();\n\n\t\tmultiVMPoolImpl.setPortalCacheManager(memoryPortalCacheManager);\n\n\t\tMultiVMPoolUtil multiVMPoolUtil = new MultiVMPoolUtil();\n\n\t\tmultiVMPoolUtil.setMultiVMPool(multiVMPoolImpl);\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\tthreadLocalDistributor.setThreadLocalSources(\n\t\t\tArrays.asList(\n\t\t\t\tnew KeyValuePair(\n\t\t\t\t\tSPIAgentRequestTest.class.getName(), \"_threadLocal\")));\n\n\t\tthreadLocalDistributor.afterPropertiesSet();\n\n\t\t_mockHttpServletRequest = new MockHttpServletRequest() {\n\n\t\t\t@Override\n\t\t\tpublic Enumeration<String> getHeaderNames() {\n\t\t\t\tEnumeration<String> headerNameEnumeration =\n\t\t\t\t\tsuper.getHeaderNames();\n\n\t\t\t\tList<String> headerNames = ListUtil.fromEnumeration(\n\t\t\t\t\theaderNameEnumeration);\n\n\t\t\t\t// Header with no value\n\n\t\t\t\theaderNames.add(_HEADER_NAME_3);\n\n\t\t\t\treturn Collections.enumeration(headerNames);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Map<String, String[]> getParameterMap() {\n\t\t\t\tMap<String, String[]> parameterMap =\n\t\t\t\t\tnew LinkedHashMap<String, String[]>(\n\t\t\t\t\t\tsuper.getParameterMap());\n\n\t\t\t\t// Parameter with no value\n\n\t\t\t\tparameterMap.put(_PARAMETER_NAME_3, new String[0]);\n\n\t\t\t\treturn parameterMap;\n\t\t\t}\n\n\t\t};\n\n\t\t_mockHttpServletRequest.addHeader(_HEADER_NAME_1, _HEADER_VALUE_1);\n\t\t_mockHttpServletRequest.addHeader(_HEADER_NAME_1, _HEADER_VALUE_2);\n\t\t_mockHttpServletRequest.addHeader(_HEADER_NAME_2, _HEADER_VALUE_3);\n\t\t_mockHttpServletRequest.addHeader(_HEADER_NAME_2, _HEADER_VALUE_4);\n\t\t_mockHttpServletRequest.addParameter(\n\t\t\t_PARAMETER_NAME_1, _PARAMETER_VALUE_1);\n\t\t_mockHttpServletRequest.addParameter(\n\t\t\t_PARAMETER_NAME_1, _PARAMETER_VALUE_2);\n\t\t_mockHttpServletRequest.addParameter(\n\t\t\t_PARAMETER_NAME_2, _PARAMETER_VALUE_3);\n\t\t_mockHttpServletRequest.addParameter(\n\t\t\t_PARAMETER_NAME_2, _PARAMETER_VALUE_4);\n\t\t_mockHttpServletRequest.setRemoteAddr(_REMOTE_ADDR);\n\t\t_mockHttpServletRequest.setRemoteHost(_REMOTE_HOST);\n\t\t_mockHttpServletRequest.setRemotePort(_REMOTE_PORT);\n\t\t_mockHttpServletRequest.setRemoteUser(_REMOTE_USER);\n\t\t_mockHttpServletRequest.setServerName(_SERVER_NAME);\n\t\t_mockHttpServletRequest.setServerPort(_SERVER_PORT);\n\n\t\tPortlet portlet = new PortletImpl() {\n\n\t\t\t@Override\n\t\t\tpublic String getContextName() {\n\t\t\t\treturn \"SERVLET_CONTEXT_NAME\";\n\t\t\t}\n\n\t\t};\n\n\t\t_mockHttpServletRequest.setAttribute(\n\t\t\tWebKeys.SPI_AGENT_PORTLET, portlet);\n\n\t\tRequestAttributes.setRequestAttributes(_mockHttpServletRequest);\n\n\t\tHttpSession session = _mockHttpServletRequest.getSession();\n\n\t\tsession.setAttribute(\n\t\t\t_SESSION_ATTRIBUTE_NAME_1, _SESSION_ATTRIBUTE_VALUE_1);\n\t\tsession.setAttribute(\n\t\t\t_SESSION_ATTRIBUTE_NAME_2, _SESSION_ATTRIBUTE_VALUE_2);\n\t\tsession.setAttribute(\n\t\t\t_SESSION_ATTRIBUTE_NAME_3, _SESSION_ATTRIBUTE_VALUE_3);\n\t}","commit_id":"af9169fdd5c790a3e8e6df20e2989e105b5d81a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private synchronized ProviderFirewallSupport getDelegate() {\n        if (this.delegate == null) {\n            this.delegate = new Ec2SupportDelegate();\n        }\n        return delegate;\n    }","id":76504,"modified_method":"private synchronized ApiFirewallSupport getDelegate() {\n        if (this.delegate == null) {\n            this.delegate = new Ec2SupportDelegate();\n        }\n        return delegate;\n    }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Revokes access to the specified ports of the node, from the specified source.\n     *\n     * @param service\n     * @param node\n     * @param source\n     * @param ports\n     */\n    @Override\n    public void revoke(ComputeService service, NodeMetadata node, String source, int... ports) {\n        try {\n            getDelegate().revoke(service, node, source, ports);\n        } catch (NoClassDefFoundError ex) {\n            ex.printStackTrace(System.out);\n            //ignore\n        }\n    }","id":76505,"modified_method":"/**\n     * Revokes access to the specified ports of the node, from the specified source.\n     *\n     * @param service\n     * @param node\n     * @param source\n     * @param ports\n     */\n    @Override\n    public void revoke(ComputeService service, NodeMetadata node, String source, int... ports) {\n        try {\n            getDelegate().revoke(service, node, source, ports);\n        } catch (NoClassDefFoundError ex) {\n            //ignore\n        }\n    }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n         * Removes all rules.\n         */\n        @Override\n        public void flush(ComputeService service, NodeMetadata node) {\n            String region = AWSUtils.parseHandle(node.getId())[0];\n            EC2Client ec2Client = EC2Client.class.cast(service.getContext().unwrap().getProviderMetadata().getApiMetadata());\n            String groupName = \"jclouds#\" + node.getGroup() + \"#\" + region;\n            Set<SecurityGroup> matchedSecurityGroups = ec2Client.getSecurityGroupServices().describeSecurityGroupsInRegion(region, groupName);\n            for (SecurityGroup securityGroup : matchedSecurityGroups) {\n                for (IpPermission ipPermission : securityGroup) {\n                    for (String cdr : ipPermission.getIpRanges()) {\n                        ec2Client.getSecurityGroupServices().revokeSecurityGroupIngressInRegion(region, groupName,\n                                IpProtocol.TCP, ipPermission.getFromPort(), ipPermission.getToPort(),\n                                cdr\n                        );\n                    }\n                }\n            }\n            //We want at least ssh access from everywhere.\n            authorize(service, node, \"0.0.0.0/0\", 22);\n        }","id":76506,"modified_method":"/**\n         * Removes all rules.\n         */\n        @Override\n        public void flush(ComputeService service, NodeMetadata node) {\n            String region = AWSUtils.parseHandle(node.getId())[0];\n            EC2Client ec2Client = service.getContext().unwrap(EC2ApiMetadata.CONTEXT_TOKEN).getApi();\n            String groupName = \"jclouds#\" + node.getGroup() + \"#\" + region;\n            Set<SecurityGroup> matchedSecurityGroups = ec2Client.getSecurityGroupServices().describeSecurityGroupsInRegion(region, groupName);\n            for (SecurityGroup securityGroup : matchedSecurityGroups) {\n                for (IpPermission ipPermission : securityGroup) {\n                    for (String cdr : ipPermission.getIpRanges()) {\n                        ec2Client.getSecurityGroupServices().revokeSecurityGroupIngressInRegion(region, groupName,\n                                IpProtocol.TCP, ipPermission.getFromPort(), ipPermission.getToPort(),\n                                cdr\n                        );\n                    }\n                }\n            }\n            //We want at least ssh access from everywhere.\n            authorize(service, node, \"0.0.0.0/0\", 22);\n        }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n         * Revokes access to the specified ports of the node, from the specified source.\n         *\n         * @param service\n         * @param node\n         * @param source\n         * @param ports\n         */\n        @Override\n        public void revoke(ComputeService service, NodeMetadata node, String source, int... ports) {\n            String region = AWSUtils.parseHandle(node.getId())[0];\n            EC2Client ec2Client = EC2Client.class.cast(service.getContext().unwrap().getProviderMetadata().getApiMetadata());\n            String groupName = \"jclouds#\" + node.getGroup() + \"#\" + region;\n            for (int port : ports) {\n                try {\n                    ec2Client.getSecurityGroupServices()\n                            .revokeSecurityGroupIngressInRegion(region, groupName,\n                                    IpProtocol.TCP, port, port, source);\n                } catch (IllegalStateException e) {\n                    //noop\n                }\n            }\n        }","id":76507,"modified_method":"/**\n         * Revokes access to the specified ports of the node, from the specified source.\n         *\n         * @param service\n         * @param node\n         * @param source\n         * @param ports\n         */\n        @Override\n        public void revoke(ComputeService service, NodeMetadata node, String source, int... ports) {\n            String region = AWSUtils.parseHandle(node.getId())[0];\n            EC2Client ec2Client = service.getContext().unwrap(EC2ApiMetadata.CONTEXT_TOKEN).getApi();\n            String groupName = \"jclouds#\" + node.getGroup() + \"#\" + region;\n            for (int port : ports) {\n                try {\n                    ec2Client.getSecurityGroupServices()\n                            .revokeSecurityGroupIngressInRegion(region, groupName,\n                                    IpProtocol.TCP, port, port, source);\n                } catch (IllegalStateException e) {\n                    //noop\n                }\n            }\n        }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n         * Authorizes access to the specified ports of the node, from the specified source.\n         *\n         * @param service\n         * @param node\n         * @param source\n         * @param ports\n         */\n        @Override\n        public void authorize(ComputeService service, NodeMetadata node, String source, int... ports) {\n            String region = AWSUtils.parseHandle(node.getId())[0];\n            EC2Client ec2Client = EC2Client.class.cast(service.getContext().unwrap().getProviderMetadata().getApiMetadata());\n            String groupName = \"jclouds#\" + node.getGroup();\n            for (int port : ports) {\n                try {\n                    ec2Client.getSecurityGroupServices()\n                            .authorizeSecurityGroupIngressInRegion(region, groupName,\n                                    IpProtocol.TCP, port, port, source);\n                } catch (IllegalStateException e) {\n                    //noop\n                }\n            }\n        }","id":76508,"modified_method":"/**\n         * Authorizes access to the specified ports of the node, from the specified source.\n         *\n         * @param service\n         * @param node\n         * @param source\n         * @param ports\n         */\n        @Override\n        public void authorize(ComputeService service, NodeMetadata node, String source, int... ports) {\n            String region = AWSUtils.parseHandle(node.getId())[0];\n            EC2Client ec2Client = service.getContext().unwrap(EC2ApiMetadata.CONTEXT_TOKEN).getApi();\n            String groupName = \"jclouds#\" + node.getGroup();\n            for (int port : ports) {\n                try {\n                    ec2Client.getSecurityGroupServices()\n                            .authorizeSecurityGroupIngressInRegion(region, groupName,\n                                    IpProtocol.TCP, port, port, source);\n                } catch (IllegalStateException e) {\n                    //noop\n                }\n            }\n        }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Authorizes access to the specified ports of the node, from the specified source.\n     *\n     * @param service\n     * @param node\n     * @param source\n     * @param ports\n     */\n    @Override\n    public void authorize(ComputeService service, NodeMetadata node, String source, int... ports) {\n        try {\n            getDelegate().authorize(service, node, source, ports);\n        } catch (NoClassDefFoundError ex) {\n            ex.printStackTrace(System.out);\n            //ignore\n        }\n    }","id":76509,"modified_method":"/**\n     * Authorizes access to the specified ports of the node, from the specified source.\n     *\n     * @param service\n     * @param node\n     * @param source\n     * @param ports\n     */\n    @Override\n    public void authorize(ComputeService service, NodeMetadata node, String source, int... ports) {\n        try {\n            getDelegate().authorize(service, node, source, ports);\n        } catch (NoClassDefFoundError ex) {\n            //ignore\n        }\n    }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Constructor\n     *\n     * @param computeService\n     * @param firewallSupport\n     */\n    public FirewallManager(ComputeService computeService, ProviderFirewallSupport firewallSupport) {\n        this.computeService = computeService;\n        this.firewallSupport = firewallSupport;\n    }","id":76510,"modified_method":"/**\n     * Constructor\n     *\n     * @param computeService\n     * @param firewallSupport\n     */\n    public FirewallManager(ComputeService computeService, ApiFirewallSupport firewallSupport) {\n        this.computeService = computeService;\n        this.firewallSupport = firewallSupport;\n    }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Returns a {@link org.fusesource.fabric.service.jclouds.firewall.FirewallManager} for the specified {@link org.jclouds.compute.ComputeService}.\n     *\n     * @param computeService\n     * @return\n     */\n    @Override\n    public synchronized FirewallManager getFirewallManager(ComputeService computeService) throws FirewallNotSupportedOnProviderException {\n        FirewallManager firewallManager = null;\n        String provider = computeService.getContext().unwrap().getId();\n\n        firewallManager = managers.get(provider);\n\n        if (firewallManager == null) {\n            ProviderFirewallSupport firewallSupport = support.get(provider);\n            if (firewallSupport == null) {\n                throw new FirewallNotSupportedOnProviderException(\"Provider \"+ provider+ \" is currently not supported for firewall operations\");\n            }\n            firewallManager = new FirewallManager(computeService, firewallSupport);\n            managers.put(provider, firewallManager);\n        }\n        return firewallManager;\n    }","id":76511,"modified_method":"/**\n     * Returns a {@link org.fusesource.fabric.service.jclouds.firewall.FirewallManager} for the specified {@link org.jclouds.compute.ComputeService}.\n     *\n     * @param computeService\n     * @return\n     */\n    @Override\n    public synchronized FirewallManager getFirewallManager(ComputeService computeService) throws FirewallNotSupportedOnProviderException {\n            ApiFirewallSupport firewallSupport = findApiFirewallSupport(computeService);\n            if (firewallSupport == null) {\n                throw new FirewallNotSupportedOnProviderException(\"Service is currently not supported for firewall operations\");\n            }\n            FirewallManager firewallManager = new FirewallManager(computeService, firewallSupport);\n            return firewallManager;\n    }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void unbind(ProviderFirewallSupport providerSupport) {\n        if (providerSupport != null && providerSupport.getProviders() != null) {\n            for (String provider : providerSupport.getProviders()) {\n                support.remove(provider);\n            }\n        }\n    }","id":76512,"modified_method":"public void unbind(ApiFirewallSupport providerSupport) {\n        firewallSupportModules.remove(providerSupport);\n    }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void bind(ProviderFirewallSupport providerSupport) {\n        if (providerSupport != null && providerSupport.getProviders() != null) {\n            for (String provider : providerSupport.getProviders()) {\n                support.put(provider, providerSupport);\n            }\n        }\n    }","id":76513,"modified_method":"public void bind(ApiFirewallSupport providerSupport) {\n        firewallSupportModules.add(providerSupport);\n    }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void init() {\n        firewallSupportModuleTracker = new ServiceTracker(bundleContext,ProviderFirewallSupport.class.getName(), null) {\n\n            @Override\n            public Object addingService(ServiceReference reference) {\n                ProviderFirewallSupport support = (ProviderFirewallSupport) bundleContext.getService(reference);\n                bind(support);\n                return support;\n            }\n\n\n            @Override\n            public void removedService(ServiceReference reference, Object service) {\n                ProviderFirewallSupport support = (ProviderFirewallSupport) service;\n                unbind(support);\n                super.removedService(reference, service);\n            }\n\n            @Override\n            public void modifiedService(ServiceReference reference, Object service) {\n                ProviderFirewallSupport support = (ProviderFirewallSupport) service;\n                bind(support);\n                super.modifiedService(reference, service);\n            }\n        };\n        firewallSupportModuleTracker.open();\n    }","id":76514,"modified_method":"public void init() {\n        firewallSupportModuleTracker = new ServiceTracker(bundleContext,ApiFirewallSupport.class.getName(), null) {\n\n            @Override\n            public Object addingService(ServiceReference reference) {\n                ApiFirewallSupport support = (ApiFirewallSupport) bundleContext.getService(reference);\n                bind(support);\n                return support;\n            }\n\n\n            @Override\n            public void removedService(ServiceReference reference, Object service) {\n                ApiFirewallSupport support = (ApiFirewallSupport) service;\n                unbind(support);\n                super.removedService(reference, service);\n            }\n\n            @Override\n            public void modifiedService(ServiceReference reference, Object service) {\n                ApiFirewallSupport support = (ApiFirewallSupport) service;\n                bind(support);\n                super.modifiedService(reference, service);\n            }\n        };\n        firewallSupportModuleTracker.open();\n    }","commit_id":"45746e3b192a7a1bb5931c149e8e09184302a829","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static ArrayList<DividerPolygon> createVisiblePolygons(EditingSides sides, FragmentSide left, int diffDividerPolygonsOffset) {\n    Editor editor1 = sides.getEditor(left);\n    Editor editor2 = sides.getEditor(left.otherSide());\n    LineBlocks lineBlocks = sides.getLineBlocks();\n    Trapezium visibleArea = new Trapezium(getVisibleInterval(editor1),\n                                          getVisibleInterval(editor2));\n    Interval indices = lineBlocks.getVisibleIndices(visibleArea);\n    Transformation[] transformations = new Transformation[]{getTransformation(editor1),\n      getTransformation(editor2)};\n    ArrayList<DividerPolygon> polygons = new ArrayList<DividerPolygon>();\n    for (int i = indices.getStart(); i < indices.getEnd(); i++) {\n      Trapezium trapezium = lineBlocks.getTrapezium(i);\n      final TextDiffType type = lineBlocks.getType(i);\n      Color color = type.getPolygonColor(editor1);\n      polygons.add(createPolygon(transformations, trapezium, color, left, diffDividerPolygonsOffset));\n    }\n    return polygons;\n  }","id":76515,"modified_method":"public static ArrayList<DividerPolygon> createVisiblePolygons(EditingSides sides, FragmentSide left, int diffDividerPolygonsOffset) {\n    Editor editor1 = sides.getEditor(left);\n    Editor editor2 = sides.getEditor(left.otherSide());\n    LineBlocks lineBlocks = sides.getLineBlocks();\n    Trapezium visibleArea = new Trapezium(getVisibleInterval(editor1),\n                                          getVisibleInterval(editor2));\n    Interval indices = lineBlocks.getVisibleIndices(visibleArea);\n    Transformation[] transformations = new Transformation[]{getTransformation(editor1),\n      getTransformation(editor2)};\n    ArrayList<DividerPolygon> polygons = new ArrayList<DividerPolygon>();\n    for (int i = indices.getStart(); i < indices.getEnd(); i++) {\n      Trapezium trapezium = lineBlocks.getTrapezium(i);\n      final TextDiffType type = lineBlocks.getType(i);\n      Color color = type.getPolygonColor(editor1);\n      polygons.add(createPolygon(transformations, trapezium, color, left, diffDividerPolygonsOffset, type.isApplied()));\n    }\n    return polygons;\n  }","commit_id":"51a8f15e9e1616e1dd44dbf4ebcd28c2184bba99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paint(Graphics2D g, int width) {\n    g.setColor(myColor);\n    g.fill(new Polygon(new int[]{0, 0, width, width}, new int[]{myStart1, myEnd1, myEnd2, myStart2}, 4));\n    g.setColor(FRAMING_LINE_COLOR);\n    UIUtil.drawLine(g, 0, myStart1, width, myStart2);\n    UIUtil.drawLine(g, 0, myEnd1, width, myEnd2);\n  }","id":76516,"modified_method":"private void paint(Graphics2D g, int width) {\n    if (!myApplied) {\n      g.setColor(myColor);\n      g.fill(new Polygon(new int[]{0, 0, width, width}, new int[]{myStart1, myEnd1, myEnd2, myStart2}, 4));\n      g.setColor(FRAMING_LINE_COLOR);\n      UIUtil.drawLine(g, 0, myStart1, width, myStart2);\n      UIUtil.drawLine(g, 0, myEnd1, width, myEnd2);\n    }\n    else {\n      g.setColor(myColor);\n      UIUtil.drawLine(g, 0, myStart1 + 1, width, myStart2 + 1);\n      UIUtil.drawLine(g, 0, myEnd1 + 1, width, myEnd2 + 1);\n    }\n  }","commit_id":"51a8f15e9e1616e1dd44dbf4ebcd28c2184bba99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static DividerPolygon createPolygon(Transformation[] transformations, Trapezium trapezium, Color color, FragmentSide left,\n                                              int diffDividerPolygonsOffset) {\n    Interval base1 = trapezium.getBase(left);\n    Interval base2 = trapezium.getBase(left.otherSide());\n    Transformation leftTransform = transformations[left.getIndex()];\n    Transformation rightTransform = transformations[left.otherSide().getIndex()];\n    int start1 = leftTransform.transform(base1.getStart());\n    int end1 = leftTransform.transform(base1.getEnd());\n    int start2 = rightTransform.transform(base2.getStart());\n    int end2 = rightTransform.transform(base2.getEnd());\n    return new DividerPolygon(start1 - diffDividerPolygonsOffset, start2 - diffDividerPolygonsOffset,\n                              end1 - diffDividerPolygonsOffset, end2 - diffDividerPolygonsOffset,\n                              ColorUtil.toAlpha(color, TRANSPARENCY));\n  }","id":76517,"modified_method":"private static DividerPolygon createPolygon(Transformation[] transformations, Trapezium trapezium, Color color, FragmentSide left,\n                                              int diffDividerPolygonsOffset, boolean applied) {\n    Interval base1 = trapezium.getBase(left);\n    Interval base2 = trapezium.getBase(left.otherSide());\n    Transformation leftTransform = transformations[left.getIndex()];\n    Transformation rightTransform = transformations[left.otherSide().getIndex()];\n    int start1 = leftTransform.transform(base1.getStart());\n    int end1 = leftTransform.transform(base1.getEnd());\n    int start2 = rightTransform.transform(base2.getStart());\n    int end2 = rightTransform.transform(base2.getEnd());\n    return new DividerPolygon(start1 - diffDividerPolygonsOffset, start2 - diffDividerPolygonsOffset,\n                              end1 - diffDividerPolygonsOffset, end2 - diffDividerPolygonsOffset,\n                              applied ? color : ColorUtil.toAlpha(color, TRANSPARENCY), applied);\n  }","commit_id":"51a8f15e9e1616e1dd44dbf4ebcd28c2184bba99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DividerPolygon(int start1, int start2, int end1, int end2, Color color) {\n    myStart1 = advance(start1);\n    myStart2 = advance(start2);\n    myEnd1 = advance(end1);\n    myEnd2 = advance(end2);\n    myColor = color;\n  }","id":76518,"modified_method":"public DividerPolygon(int start1, int start2, int end1, int end2, Color color, boolean applied) {\n    myApplied = applied;\n    myStart1 = advance(start1);\n    myStart2 = advance(start2);\n    myEnd1 = advance(end1);\n    myEnd2 = advance(end2);\n    myColor = color;\n  }","commit_id":"51a8f15e9e1616e1dd44dbf4ebcd28c2184bba99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void drawAbove(boolean gutter, Graphics2D g2, ArrayList<DividerPolygon> polygons, boolean takeLeftSideOfPolygon) {\n    for (DividerPolygon polygon : polygons) {\n      int startY = takeLeftSideOfPolygon ? polygon.getTopLeftY() :polygon.getTopRightY();\n      int endY = takeLeftSideOfPolygon ? polygon.getBottomLeftY() : polygon.getBottomRightY();\n      int height = endY - startY;\n\n      if (height == 0) { // draw at least a one-pixel line (e.g. for insertion or deletion), as it is done in highlighters\n        height = 1;\n      }\n\n      if (gutter) {\n        drawAboveGutter(g2, startY, height, polygon.getColor());\n      }\n      else {\n        drawAboveScrollBar(g2, startY, height, polygon.getColor());\n      }\n    }\n  }","id":76519,"modified_method":"private void drawAbove(boolean gutter, Graphics2D g2, ArrayList<DividerPolygon> polygons, boolean takeLeftSideOfPolygon) {\n    for (DividerPolygon polygon : polygons) {\n      int startY = takeLeftSideOfPolygon ? polygon.getTopLeftY() :polygon.getTopRightY();\n      int endY = takeLeftSideOfPolygon ? polygon.getBottomLeftY() : polygon.getBottomRightY();\n      int height = endY - startY;\n\n      if (height == 0) { // draw at least a one-pixel line (e.g. for insertion or deletion), as it is done in highlighters\n        height = 1;\n      }\n\n      if (gutter) {\n        drawAboveGutter(g2, startY, height, polygon.getColor(), polygon.isApplied());\n      }\n      else {\n        drawAboveScrollBar(g2, startY, height, polygon.getColor(), polygon.isApplied());\n      }\n    }\n  }","commit_id":"51a8f15e9e1616e1dd44dbf4ebcd28c2184bba99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void drawAboveScrollBar(@NotNull Graphics2D g, int startY, int height, @NotNull Color color) {\n    // painting only above the central scrollbar, because painting on edge scrollbars is not needed, and there are error stripes\n    if (myColumn == MergePanelColumn.BASE) {\n      g.setColor(color);\n      JScrollBar scrollBar = ((EditorEx)myEditor).getScrollPane().getVerticalScrollBar();\n      int startX = scrollBar.getX();\n      g.fillRect(startX, startY, scrollBar.getWidth(), height);\n\n      drawFramingLines(g, startX, startY, startX + scrollBar.getWidth(), startY + height);\n    }\n  }","id":76520,"modified_method":"private void drawAboveScrollBar(@NotNull Graphics2D g, int startY, int height, @NotNull Color color, boolean applied) {\n    // painting only above the central scrollbar, because painting on edge scrollbars is not needed, and there are error stripes\n    if (myColumn == MergePanelColumn.BASE) {\n      g.setColor(color);\n      JScrollBar scrollBar = ((EditorEx)myEditor).getScrollPane().getVerticalScrollBar();\n      int startX = scrollBar.getX();\n      int endX = startX + scrollBar.getWidth();\n      if (!applied) {\n        g.fillRect(startX, startY, scrollBar.getWidth(), height);\n        drawFramingLines(g, startX, startY, endX, startY + height);\n      }\n      else {\n        drawBoldDottedFramingLines(g, startX, endX, startY, height, color);\n      }\n    }\n  }","commit_id":"51a8f15e9e1616e1dd44dbf4ebcd28c2184bba99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void drawAboveGutter(@NotNull Graphics2D g, int startY, int height, @NotNull Color color) {\n    EditorGutterComponentEx gutter = ((EditorEx)myEditor).getGutterComponentEx();\n    g.setColor(color);\n    if (((EditorEx)myEditor).getVerticalScrollbarOrientation() == EditorEx.VERTICAL_SCROLLBAR_RIGHT) {\n      // scrollbar is at the right => the gutter is at the left (central editor case)\n      int startX = gutter.getX();\n      g.fillRect(startX, startY, gutter.getWidth() + 1, height);\n\n      drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height);\n    }\n    else {\n      JComponent editorComponent = myEditor.getComponent();\n      int startX = editorComponent.getX() + editorComponent.getWidth() - gutter.getWidth() - 1;\n      g.fillRect(startX, startY, gutter.getWidth() + 1, height);\n\n      drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height);\n    }\n  }","id":76521,"modified_method":"private void drawAboveGutter(@NotNull Graphics2D g, int startY, int height, @NotNull Color color, boolean applied) {\n    EditorGutterComponentEx gutter = ((EditorEx)myEditor).getGutterComponentEx();\n    g.setColor(color);\n    if (((EditorEx)myEditor).getVerticalScrollbarOrientation() == EditorEx.VERTICAL_SCROLLBAR_RIGHT) {\n      // scrollbar is at the right => the gutter is at the left (central editor case)\n      int startX = gutter.getX();\n      if (!applied) {\n        g.fillRect(startX, startY, gutter.getWidth() + 1, height);\n        drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height);\n      }\n      else {\n        drawBoldDottedFramingLines(g, startX, gutter.getWidth() + 1, startY, height, color);\n      }\n    }\n    else {\n      JComponent editorComponent = myEditor.getComponent();\n      int startX = editorComponent.getX() + editorComponent.getWidth() - gutter.getWidth() - 1;\n      if (!applied) {\n        g.fillRect(startX, startY, gutter.getWidth() + 1, height);\n        drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height);\n      }\n      else {\n        int endX = startX + gutter.getWidth() + 1;\n        drawBoldDottedFramingLines(g, startX, endX, startY, height, color);\n      }\n    }\n  }","commit_id":"51a8f15e9e1616e1dd44dbf4ebcd28c2184bba99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void drawAboveGutter(@NotNull Graphics2D g, int startY, int height, @NotNull Color color, boolean applied) {\n    EditorGutterComponentEx gutter = ((EditorEx)myEditor).getGutterComponentEx();\n    g.setColor(color);\n    if (((EditorEx)myEditor).getVerticalScrollbarOrientation() == EditorEx.VERTICAL_SCROLLBAR_RIGHT) {\n      // scrollbar is at the right => the gutter is at the left (central editor case)\n      int startX = gutter.getX();\n      if (!applied) {\n        g.fillRect(startX, startY, gutter.getWidth() + 1, height);\n        drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height);\n      }\n      else {\n        drawBoldDottedFramingLines(g, startX, gutter.getWidth() + 1, startY, height, color);\n      }\n    }\n    else {\n      JComponent editorComponent = myEditor.getComponent();\n      int startX = editorComponent.getX() + editorComponent.getWidth() - gutter.getWidth() - 1;\n      if (!applied) {\n        g.fillRect(startX, startY, gutter.getWidth() + 1, height);\n        drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height);\n      }\n      else {\n        int endX = startX + gutter.getWidth() + 1;\n        drawBoldDottedFramingLines(g, startX, endX, startY, height, color);\n      }\n    }\n  }","id":76522,"modified_method":"private void drawAboveGutter(@NotNull Graphics2D g, int startY, int height, @NotNull Color color, boolean applied) {\n    EditorGutterComponentEx gutter = ((EditorEx)myEditor).getGutterComponentEx();\n    g.setColor(color);\n    if (((EditorEx)myEditor).getVerticalScrollbarOrientation() == EditorEx.VERTICAL_SCROLLBAR_RIGHT) {\n      // scrollbar is at the right => the gutter is at the left (central editor case)\n      int startX = gutter.getX();\n      if (!applied) {\n        if (height > 2) {\n          g.fillRect(startX, startY, gutter.getWidth() + 1, height);\n          drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height, DividerPolygon.FRAMING_LINE_COLOR);\n        }\n        else {\n          drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height, color);\n        }\n      }\n      else {\n        drawBoldDottedFramingLines(g, startX, gutter.getWidth() + 1, startY, height, color);\n      }\n    }\n    else {\n      JComponent editorComponent = myEditor.getComponent();\n      int startX = editorComponent.getX() + editorComponent.getWidth() - gutter.getWidth() - 1;\n      if (!applied) {\n        g.fillRect(startX, startY, gutter.getWidth() + 1, height);\n        drawFramingLines(g, startX, startY, startX + gutter.getWidth(), startY + height, DividerPolygon.FRAMING_LINE_COLOR);\n      }\n      else {\n        int endX = startX + gutter.getWidth() + 1;\n        drawBoldDottedFramingLines(g, startX, endX, startY, height, color);\n      }\n    }\n  }","commit_id":"36574f915ec62a07615434f9d9691368fb416a84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void drawAboveScrollBar(@NotNull Graphics2D g, int startY, int height, @NotNull Color color, boolean applied) {\n    // painting only above the central scrollbar, because painting on edge scrollbars is not needed, and there are error stripes\n    if (myColumn == MergePanelColumn.BASE) {\n      g.setColor(color);\n      JScrollBar scrollBar = ((EditorEx)myEditor).getScrollPane().getVerticalScrollBar();\n      int startX = scrollBar.getX();\n      int endX = startX + scrollBar.getWidth();\n      if (!applied) {\n        g.fillRect(startX, startY, scrollBar.getWidth(), height);\n        drawFramingLines(g, startX, startY, endX, startY + height);\n      }\n      else {\n        drawBoldDottedFramingLines(g, startX, endX, startY, height, color);\n      }\n    }\n  }","id":76523,"modified_method":"private void drawAboveScrollBar(@NotNull Graphics2D g, int startY, int height, @NotNull Color color, boolean applied) {\n    // painting only above the central scrollbar, because painting on edge scrollbars is not needed, and there are error stripes\n    if (myColumn == MergePanelColumn.BASE) {\n      g.setColor(color);\n      JScrollBar scrollBar = ((EditorEx)myEditor).getScrollPane().getVerticalScrollBar();\n      int startX = scrollBar.getX();\n      int endX = startX + scrollBar.getWidth();\n      if (!applied) {\n        if (height > 2) {\n          g.fillRect(startX, startY, scrollBar.getWidth(), height);\n          drawFramingLines(g, startX, startY, endX, startY + height, DividerPolygon.FRAMING_LINE_COLOR);\n        }\n        else {\n          drawFramingLines(g, startX, startY, endX, startY + height, color);\n        }\n      }\n      else {\n        drawBoldDottedFramingLines(g, startX, endX, startY, height, color);\n      }\n    }\n  }","commit_id":"36574f915ec62a07615434f9d9691368fb416a84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void drawFramingLines(@NotNull Graphics2D g, int startX, int topY, int endX, int bottomY) {\n    UIUtil.drawLine(g, startX, topY, endX, topY, null, DividerPolygon.FRAMING_LINE_COLOR);\n    UIUtil.drawLine(g, startX, bottomY, endX, bottomY, null, DividerPolygon.FRAMING_LINE_COLOR);\n  }","id":76524,"modified_method":"private static void drawFramingLines(@NotNull Graphics2D g, int startX, int topY, int endX, int bottomY, @NotNull Color color) {\n    UIUtil.drawLine(g, startX, topY, endX, topY, null, color);\n    UIUtil.drawLine(g, startX, bottomY, endX, bottomY, null, color);\n  }","commit_id":"36574f915ec62a07615434f9d9691368fb416a84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @see QJournalProtocol#prepareRecovery(RequestInfo, long)\n   */\n  public synchronized PrepareRecoveryResponseProto prepareRecovery(\n      RequestInfo reqInfo, long segmentTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n    \n    abortCurSegment();\n    \n    PrepareRecoveryResponseProto.Builder builder =\n        PrepareRecoveryResponseProto.newBuilder();\n\n    SegmentStateProto segInfo = getSegmentInfo(segmentTxId);\n    boolean hasFinalizedSegment = segInfo != null && !segInfo.getIsInProgress();\n    \n    PersistedRecoveryPaxosData previouslyAccepted = getPersistedPaxosData(segmentTxId);\n\n    if (previouslyAccepted != null && !hasFinalizedSegment) {\n      SegmentStateProto acceptedState = previouslyAccepted.getSegmentState();\n      assert acceptedState.getEndTxId() == segInfo.getEndTxId() &&\n             acceptedState.getMd5Sum().equals(segInfo.getMd5Sum()) :\n            \"prev accepted: \" + TextFormat.shortDebugString(previouslyAccepted)+ \"\\n\" +\n            \"on disk:       \" + TextFormat.shortDebugString(segInfo);\n            \n      builder.setAcceptedInEpoch(previouslyAccepted.getAcceptedInEpoch())\n        .setSegmentState(previouslyAccepted.getSegmentState());\n    } else {\n      if (segInfo != null) {\n        builder.setSegmentState(segInfo);\n      }\n    }\n    \n    builder.setLastWriterEpoch(lastWriterEpoch.get());\n    if (committedTxnId.get() != HdfsConstants.INVALID_TXID) {\n      builder.setLastCommittedTxId(committedTxnId.get());\n    }\n    \n    PrepareRecoveryResponseProto resp = builder.build();\n    LOG.info(\"Prepared recovery for segment \" + segmentTxId + \": \" +\n        TextFormat.shortDebugString(resp));\n    return resp;\n  }","id":76525,"modified_method":"/**\n   * @see QJournalProtocol#prepareRecovery(RequestInfo, long)\n   */\n  public synchronized PrepareRecoveryResponseProto prepareRecovery(\n      RequestInfo reqInfo, long segmentTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n    \n    abortCurSegment();\n    \n    PrepareRecoveryResponseProto.Builder builder =\n        PrepareRecoveryResponseProto.newBuilder();\n\n    SegmentStateProto segInfo = getSegmentInfo(segmentTxId);\n    boolean hasFinalizedSegment = segInfo != null && !segInfo.getIsInProgress();\n    \n    PersistedRecoveryPaxosData previouslyAccepted = getPersistedPaxosData(segmentTxId);\n\n    if (previouslyAccepted != null && !hasFinalizedSegment) {\n      SegmentStateProto acceptedState = previouslyAccepted.getSegmentState();\n      assert acceptedState.getEndTxId() == segInfo.getEndTxId() :\n            \"prev accepted: \" + TextFormat.shortDebugString(previouslyAccepted)+ \"\\n\" +\n            \"on disk:       \" + TextFormat.shortDebugString(segInfo);\n            \n      builder.setAcceptedInEpoch(previouslyAccepted.getAcceptedInEpoch())\n        .setSegmentState(previouslyAccepted.getSegmentState());\n    } else {\n      if (segInfo != null) {\n        builder.setSegmentState(segInfo);\n      }\n    }\n    \n    builder.setLastWriterEpoch(lastWriterEpoch.get());\n    if (committedTxnId.get() != HdfsConstants.INVALID_TXID) {\n      builder.setLastCommittedTxId(committedTxnId.get());\n    }\n    \n    PrepareRecoveryResponseProto resp = builder.build();\n    LOG.info(\"Prepared recovery for segment \" + segmentTxId + \": \" +\n        TextFormat.shortDebugString(resp));\n    return resp;\n  }","commit_id":"83c14fbd24353b5e882f065faec81e58449afed3","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * @return the current state of the given segment, or null if the\n   * segment does not exist.\n   */\n  private SegmentStateProto getSegmentInfo(long segmentTxId)\n      throws IOException {\n    EditLogFile elf = fjm.getLogFile(segmentTxId);\n    if (elf == null) {\n      return null;\n    }\n    if (elf.isInProgress()) {\n      elf.validateLog();\n    }\n    if (elf.getLastTxId() == HdfsConstants.INVALID_TXID) {\n      LOG.info(\"Edit log file \" + elf + \" appears to be empty. \" +\n          \"Moving it aside...\");\n      elf.moveAsideEmptyFile();\n      return null;\n    }\n    SegmentStateProto ret = SegmentStateProto.newBuilder()\n        .setStartTxId(segmentTxId)\n        .setEndTxId(elf.getLastTxId())\n        .setIsInProgress(elf.isInProgress())\n        .setMd5Sum(ByteString.EMPTY) // TODO\n        .build();\n    LOG.info(\"getSegmentInfo(\" + segmentTxId + \"): \" + elf + \" -> \" +\n        TextFormat.shortDebugString(ret));\n    return ret;\n  }","id":76526,"modified_method":"/**\n   * @return the current state of the given segment, or null if the\n   * segment does not exist.\n   */\n  private SegmentStateProto getSegmentInfo(long segmentTxId)\n      throws IOException {\n    EditLogFile elf = fjm.getLogFile(segmentTxId);\n    if (elf == null) {\n      return null;\n    }\n    if (elf.isInProgress()) {\n      elf.validateLog();\n    }\n    if (elf.getLastTxId() == HdfsConstants.INVALID_TXID) {\n      LOG.info(\"Edit log file \" + elf + \" appears to be empty. \" +\n          \"Moving it aside...\");\n      elf.moveAsideEmptyFile();\n      return null;\n    }\n    SegmentStateProto ret = SegmentStateProto.newBuilder()\n        .setStartTxId(segmentTxId)\n        .setEndTxId(elf.getLastTxId())\n        .setIsInProgress(elf.isInProgress())\n        .build();\n    LOG.info(\"getSegmentInfo(\" + segmentTxId + \"): \" + elf + \" -> \" +\n        TextFormat.shortDebugString(ret));\n    return ret;\n  }","commit_id":"83c14fbd24353b5e882f065faec81e58449afed3","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public int compare(\n      Entry<AsyncLogger, PrepareRecoveryResponseProto> a,\n      Entry<AsyncLogger, PrepareRecoveryResponseProto> b) {\n    \n    PrepareRecoveryResponseProto r1 = a.getValue();\n    PrepareRecoveryResponseProto r2 = b.getValue();\n    \n    // A response that has data for a segment is always better than one\n    // that doesn't.\n    if (r1.hasSegmentState() != r2.hasSegmentState()) {\n      return Booleans.compare(r1.hasSegmentState(), r2.hasSegmentState());\n    }\n    \n    if (!r1.hasSegmentState()) {\n      // Neither has a segment, so neither can be used for recover.\n      // Call them equal.\n      return 0;\n    }\n    \n    // They both have a segment.\n    SegmentStateProto r1Seg = r1.getSegmentState();\n    SegmentStateProto r2Seg = r2.getSegmentState();\n    \n    Preconditions.checkArgument(r1Seg.getStartTxId() == r2Seg.getStartTxId(),\n        \"Should only be called with responses for corresponding segments: \" +\n        \"%s and %s do not have the same start txid.\", r1, r2);\n\n    // If one is in-progress but the other is finalized,\n    // the finalized one is greater.\n    if (r1Seg.getIsInProgress() != r2Seg.getIsInProgress()) {\n      return Booleans.compare(!r1Seg.getIsInProgress(), !r2Seg.getIsInProgress());\n    }\n    \n    if (!r1Seg.getIsInProgress()) {\n      // If both are finalized, they should match lengths, and be considered\n      // equal\n      if (r1Seg.getEndTxId() != r2Seg.getEndTxId()  ||\n          !r1Seg.getMd5Sum().equals(r2Seg.getMd5Sum())) {\n        throw new AssertionError(\"finalized segs with different lengths: \" + \n            r1 + \", \" + r2);\n      }\n      return 0;\n    }\n    \n    // Both are in-progress.\n    long r1SeenEpoch = Math.max(r1.getAcceptedInEpoch(), r1.getLastWriterEpoch());\n    long r2SeenEpoch = Math.max(r2.getAcceptedInEpoch(), r2.getLastWriterEpoch());\n    \n    return ComparisonChain.start()\n        .compare(r1SeenEpoch, r2SeenEpoch)\n        .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n        .result();\n  }","id":76527,"modified_method":"@Override\n  public int compare(\n      Entry<AsyncLogger, PrepareRecoveryResponseProto> a,\n      Entry<AsyncLogger, PrepareRecoveryResponseProto> b) {\n    \n    PrepareRecoveryResponseProto r1 = a.getValue();\n    PrepareRecoveryResponseProto r2 = b.getValue();\n    \n    // A response that has data for a segment is always better than one\n    // that doesn't.\n    if (r1.hasSegmentState() != r2.hasSegmentState()) {\n      return Booleans.compare(r1.hasSegmentState(), r2.hasSegmentState());\n    }\n    \n    if (!r1.hasSegmentState()) {\n      // Neither has a segment, so neither can be used for recover.\n      // Call them equal.\n      return 0;\n    }\n    \n    // They both have a segment.\n    SegmentStateProto r1Seg = r1.getSegmentState();\n    SegmentStateProto r2Seg = r2.getSegmentState();\n    \n    Preconditions.checkArgument(r1Seg.getStartTxId() == r2Seg.getStartTxId(),\n        \"Should only be called with responses for corresponding segments: \" +\n        \"%s and %s do not have the same start txid.\", r1, r2);\n\n    // If one is in-progress but the other is finalized,\n    // the finalized one is greater.\n    if (r1Seg.getIsInProgress() != r2Seg.getIsInProgress()) {\n      return Booleans.compare(!r1Seg.getIsInProgress(), !r2Seg.getIsInProgress());\n    }\n    \n    if (!r1Seg.getIsInProgress()) {\n      // If both are finalized, they should match lengths\n      if (r1Seg.getEndTxId() != r2Seg.getEndTxId()) {\n        throw new AssertionError(\"finalized segs with different lengths: \" + \n            r1 + \", \" + r2);\n      }\n      return 0;\n    }\n    \n    // Both are in-progress.\n    long r1SeenEpoch = Math.max(r1.getAcceptedInEpoch(), r1.getLastWriterEpoch());\n    long r2SeenEpoch = Math.max(r2.getAcceptedInEpoch(), r2.getLastWriterEpoch());\n    \n    return ComparisonChain.start()\n        .compare(r1SeenEpoch, r2SeenEpoch)\n        .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n        .result();\n  }","commit_id":"83c14fbd24353b5e882f065faec81e58449afed3","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testComparisons() {\n    Entry<AsyncLogger, PrepareRecoveryResponseProto> INPROGRESS_1_3 =\n        makeEntry(PrepareRecoveryResponseProto.newBuilder()\n          .setSegmentState(SegmentStateProto.newBuilder()\n              .setStartTxId(1L)\n              .setEndTxId(3L)\n              .setMd5Sum(ByteString.EMPTY)\n              .setIsInProgress(true))\n          .setLastWriterEpoch(0L)\n          .build());\n    Entry<AsyncLogger, PrepareRecoveryResponseProto> INPROGRESS_1_4 =\n        makeEntry(PrepareRecoveryResponseProto.newBuilder()\n          .setSegmentState(SegmentStateProto.newBuilder()\n              .setStartTxId(1L)\n              .setEndTxId(4L)\n              .setMd5Sum(ByteString.EMPTY)\n              .setIsInProgress(true))\n          .setLastWriterEpoch(0L)\n          .build());\n    Entry<AsyncLogger, PrepareRecoveryResponseProto> INPROGRESS_1_4_ACCEPTED =\n        makeEntry(PrepareRecoveryResponseProto.newBuilder()\n          .setSegmentState(SegmentStateProto.newBuilder()\n              .setStartTxId(1L)\n              .setEndTxId(4L)\n              .setMd5Sum(ByteString.EMPTY)\n              .setIsInProgress(true))\n          .setLastWriterEpoch(0L)\n          .setAcceptedInEpoch(1L)\n          .build());\n\n    Entry<AsyncLogger, PrepareRecoveryResponseProto> FINALIZED_1_3 =\n        makeEntry(PrepareRecoveryResponseProto.newBuilder()\n          .setSegmentState(SegmentStateProto.newBuilder()\n              .setStartTxId(1L)\n              .setEndTxId(3L)\n              .setMd5Sum(ByteString.EMPTY)\n              .setIsInProgress(false))\n          .setLastWriterEpoch(0L)\n          .build());\n\n    // Should compare equal to itself\n    assertEquals(0, INSTANCE.compare(INPROGRESS_1_3, INPROGRESS_1_3));\n    \n    // Longer log wins.\n    assertEquals(-1, INSTANCE.compare(INPROGRESS_1_3, INPROGRESS_1_4));\n    assertEquals(1, INSTANCE.compare(INPROGRESS_1_4, INPROGRESS_1_3));\n    \n    // Finalized log wins even over a longer in-progress\n    assertEquals(-1, INSTANCE.compare(INPROGRESS_1_4, FINALIZED_1_3));\n    assertEquals(1, INSTANCE.compare(FINALIZED_1_3, INPROGRESS_1_4));\n\n    // Finalized log wins even if the in-progress one has an accepted\n    // recovery proposal.\n    assertEquals(-1, INSTANCE.compare(INPROGRESS_1_4_ACCEPTED, FINALIZED_1_3));\n    assertEquals(1, INSTANCE.compare(FINALIZED_1_3, INPROGRESS_1_4_ACCEPTED));\n  }","id":76528,"modified_method":"@Test\n  public void testComparisons() {\n    Entry<AsyncLogger, PrepareRecoveryResponseProto> INPROGRESS_1_3 =\n        makeEntry(PrepareRecoveryResponseProto.newBuilder()\n          .setSegmentState(SegmentStateProto.newBuilder()\n              .setStartTxId(1L)\n              .setEndTxId(3L)\n              .setIsInProgress(true))\n          .setLastWriterEpoch(0L)\n          .build());\n    Entry<AsyncLogger, PrepareRecoveryResponseProto> INPROGRESS_1_4 =\n        makeEntry(PrepareRecoveryResponseProto.newBuilder()\n          .setSegmentState(SegmentStateProto.newBuilder()\n              .setStartTxId(1L)\n              .setEndTxId(4L)\n              .setIsInProgress(true))\n          .setLastWriterEpoch(0L)\n          .build());\n    Entry<AsyncLogger, PrepareRecoveryResponseProto> INPROGRESS_1_4_ACCEPTED =\n        makeEntry(PrepareRecoveryResponseProto.newBuilder()\n          .setSegmentState(SegmentStateProto.newBuilder()\n              .setStartTxId(1L)\n              .setEndTxId(4L)\n              .setIsInProgress(true))\n          .setLastWriterEpoch(0L)\n          .setAcceptedInEpoch(1L)\n          .build());\n\n    Entry<AsyncLogger, PrepareRecoveryResponseProto> FINALIZED_1_3 =\n        makeEntry(PrepareRecoveryResponseProto.newBuilder()\n          .setSegmentState(SegmentStateProto.newBuilder()\n              .setStartTxId(1L)\n              .setEndTxId(3L)\n              .setIsInProgress(false))\n          .setLastWriterEpoch(0L)\n          .build());\n\n    // Should compare equal to itself\n    assertEquals(0, INSTANCE.compare(INPROGRESS_1_3, INPROGRESS_1_3));\n    \n    // Longer log wins.\n    assertEquals(-1, INSTANCE.compare(INPROGRESS_1_3, INPROGRESS_1_4));\n    assertEquals(1, INSTANCE.compare(INPROGRESS_1_4, INPROGRESS_1_3));\n    \n    // Finalized log wins even over a longer in-progress\n    assertEquals(-1, INSTANCE.compare(INPROGRESS_1_4, FINALIZED_1_3));\n    assertEquals(1, INSTANCE.compare(FINALIZED_1_3, INPROGRESS_1_4));\n\n    // Finalized log wins even if the in-progress one has an accepted\n    // recovery proposal.\n    assertEquals(-1, INSTANCE.compare(INPROGRESS_1_4_ACCEPTED, FINALIZED_1_3));\n    assertEquals(1, INSTANCE.compare(FINALIZED_1_3, INPROGRESS_1_4_ACCEPTED));\n  }","commit_id":"83c14fbd24353b5e882f065faec81e58449afed3","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected void doSynchronizeRoots() {\n    if (!myStartupActivityPerformed) return;\n\n    if (myDoLogCachesUpdate) LOG.debug(new Throwable(\"sync roots\"));\n    else LOG.info(\"project roots have changed\");\n\n    DumbServiceImpl dumbService = DumbServiceImpl.getInstance(myProject);\n    if (FileBasedIndex.getInstance() instanceof FileBasedIndexImpl) {\n      dumbService.queueTask(new UnindexedFilesUpdater(myProject, false));\n    }\n  }","id":76529,"modified_method":"@Override\n  protected void doSynchronizeRoots() {\n    if (!myStartupActivityPerformed) return;\n\n    if (myDoLogCachesUpdate) LOG.debug(new Throwable(\"sync roots\"));\n    else if (!ApplicationManager.getApplication().isUnitTestMode()) LOG.info(\"project roots have changed\");\n\n    DumbServiceImpl dumbService = DumbServiceImpl.getInstance(myProject);\n    if (FileBasedIndex.getInstance() instanceof FileBasedIndexImpl) {\n      dumbService.queueTask(new UnindexedFilesUpdater(myProject, false));\n    }\n  }","commit_id":"4d81d4e2c42cb86ca6b1a3ff397b373706dc5d7f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateUnindexedFiles(ProgressIndicator indicator) {\n    PerformanceWatcher.Snapshot snapshot = PerformanceWatcher.takeSnapshot();\n    PushedFilePropertiesUpdater.getInstance(myProject).pushAllPropertiesNow();\n    snapshot.logResponsivenessSinceCreation(\"Pushing properties\");\n\n    indicator.setIndeterminate(true);\n    indicator.setText(IdeBundle.message(\"progress.indexing.scanning\"));\n\n    CollectingContentIterator finder = myIndex.createContentIterator(indicator);\n    snapshot = PerformanceWatcher.takeSnapshot();\n\n    myIndex.iterateIndexableFilesConcurrently(finder, myProject, indicator);\n\n    myIndex.filesUpdateEnumerationFinished();\n\n    snapshot.logResponsivenessSinceCreation(\"Indexable file iteration\");\n\n    List<VirtualFile> files = finder.getFiles();\n\n    if (myOnStartup && !ApplicationManager.getApplication().isUnitTestMode()) {\n      // full VFS refresh makes sense only after it's loaded, i.e. after scanning files to index is finished\n      ((StartupManagerImpl)StartupManager.getInstance(myProject)).scheduleInitialVfsRefresh();\n    }\n\n    if (files.isEmpty()) {\n      return;\n    }\n\n    snapshot = PerformanceWatcher.takeSnapshot();\n\n    LOG.info(\"Unindexed files update started: \" + files.size() + \" files to update\");\n\n    indicator.setIndeterminate(false);\n    indicator.setText(IdeBundle.message(\"progress.indexing.updating\"));\n\n    indexFiles(indicator, files);\n\n    snapshot.logResponsivenessSinceCreation(\"Unindexed files update\");\n  }","id":76530,"modified_method":"private void updateUnindexedFiles(ProgressIndicator indicator) {\n    PerformanceWatcher.Snapshot snapshot = PerformanceWatcher.takeSnapshot();\n    PushedFilePropertiesUpdater.getInstance(myProject).pushAllPropertiesNow();\n    boolean trackResponsiveness = !ApplicationManager.getApplication().isUnitTestMode();\n\n    if (trackResponsiveness) snapshot.logResponsivenessSinceCreation(\"Pushing properties\");\n\n    indicator.setIndeterminate(true);\n    indicator.setText(IdeBundle.message(\"progress.indexing.scanning\"));\n\n    CollectingContentIterator finder = myIndex.createContentIterator(indicator);\n    snapshot = PerformanceWatcher.takeSnapshot();\n\n    myIndex.iterateIndexableFilesConcurrently(finder, myProject, indicator);\n\n    myIndex.filesUpdateEnumerationFinished();\n\n    if (trackResponsiveness) snapshot.logResponsivenessSinceCreation(\"Indexable file iteration\");\n\n    List<VirtualFile> files = finder.getFiles();\n\n    if (myOnStartup && !ApplicationManager.getApplication().isUnitTestMode()) {\n      // full VFS refresh makes sense only after it's loaded, i.e. after scanning files to index is finished\n      ((StartupManagerImpl)StartupManager.getInstance(myProject)).scheduleInitialVfsRefresh();\n    }\n\n    if (files.isEmpty()) {\n      return;\n    }\n\n    snapshot = PerformanceWatcher.takeSnapshot();\n\n    if (trackResponsiveness) LOG.info(\"Unindexed files update started: \" + files.size() + \" files to update\");\n\n    indicator.setIndeterminate(false);\n    indicator.setText(IdeBundle.message(\"progress.indexing.updating\"));\n\n    indexFiles(indicator, files);\n\n    if (trackResponsiveness) snapshot.logResponsivenessSinceCreation(\"Unindexed files update\");\n  }","commit_id":"4d81d4e2c42cb86ca6b1a3ff397b373706dc5d7f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Returns all the hash lookups related artifact/attributes and groups them\n     * based on hashset name\n     *\n     * @return String table is a string of an html table\n     *\n     */\n    public String getGroupedEmailHit() {\n        StringBuilder table = new StringBuilder();\n        HashMap<BlackboardArtifact, ArrayList<BlackboardAttribute>> reportMap = new HashMap<BlackboardArtifact, ArrayList<BlackboardAttribute>>();\n        Case currentCase = Case.getCurrentCase(); // get the most updated case\n        SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n        try {\n            tempDb.copyCaseDB(currentCase.getTempDirectory() + File.separator + \"autopsy-copy.db\");\n            dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\", \"jdbc:sqlite:\" + currentCase.getTempDirectory() + File.separator + \"autopsy-copy.db\");\n             tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_from;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_to;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_content;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_cc;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_name;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report;\");\n            String temp1 = \"CREATE TABLE report_path AS SELECT value_text as path,blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_FROM.getTypeID() + \";\";\n            String temp2 = \"CREATE TABLE report_to AS SELECT value_text as to, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_TO.getTypeID() + \";\";\n            String temp3 = \"CREATE TABLE report_content AS SELECT value_text as content, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_PLAIN.getTypeID() + \";\";\n            String temp4 = \"CREATE TABLE report_cc AS SELECT value_text as cc, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_CC.getTypeID() + \";\";\n            String temp7 = \"CREATE TABLE report_bcc AS SELECT value_text as bcc, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_BCC.getTypeID() + \";\";\n            String temp8 = \"CREATE TABLE report_from AS SELECT value_text as path, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID() + \";\";\n            String temp6 = \"CREATE TABLE report_subject AS SELECT value_text as subject, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SUBJECT.getTypeID() + \";\";\n            String temp5 = \"CREATE TABLE report_name AS SELECT name, report_from.artifact_id from tsk_files,blackboard_artifacts, report_from WHERE blackboard_artifacts.artifact_id = report_from.artifact_id AND blackboard_artifacts.obj_id = tsk_files.obj_id;\";\n            String temp9 = \"CREATE TABLE report AS SELECT path,to,content,cc,bcc,subject,name,author from report_path INNER JOIN report_to ON report_path.artifact_id=report_to.artifact_id INNER JOIN report_content ON report_to.artifact_id=report_content.artifact_id INNER JOIN report_cc ON report_content.artifact_id=report_cc.artifact_id INNER JOIN report_name ON report_cc.artifact_id=report_name.artifact_id;\";\n            tempdbconnect.executeStmt(temp1);\n            tempdbconnect.executeStmt(temp2);\n            tempdbconnect.executeStmt(temp3);\n            tempdbconnect.executeStmt(temp4);\n            tempdbconnect.executeStmt(temp5);\n            tempdbconnect.executeStmt(temp6);\n            tempdbconnect.executeStmt(temp7);\n            tempdbconnect.executeStmt(temp8);\n            tempdbconnect.executeStmt(temp9);\n            ResultSet uniqueresults = tempdbconnect.executeQry(\"SELECT path,to,content,cc,bcc,subject,name,author FROM report ORDER BY path ASC\");\n            String keyword = \"\";\n            while (uniqueresults.next()) {\n                if (uniqueresults.getString(\"path\") == null ? keyword == null : uniqueresults.getString(\"path\").equals(keyword)) {\n                } else {\n                    table.append(\"<\/tbody><\/table><br /><br />\");\n                    keyword = uniqueresults.getString(\"path\");\n                    table.append(\"<strong>\").append(keyword).append(\"<\/strong>\");\n                    table.append(\"<table><thead><tr><th>\").append(\"Account\").append(\"<\/th><th>Preview<\/th><th>Email Messages<\/th><\/tr><tbody>\");\n                }\n                table.append(\"<tr><td>\").append(uniqueresults.getString(\"name\")).append(\"<\/td>\");\n                table.append(\"<td>\").append(uniqueresults.getString(\"preview\")).append(\"<\/td>\").append(\"<td>\").append(uniqueresults.getString(\"list\")).append(\"<br />(\").append(uniqueresults.getString(\"exp\")).append(\")\").append(\"<\/td>\").append(\"<\/tr>\");\n\n            }\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_keyword;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_preview;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_exp;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_name;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_list;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report;\");\n            tempdbconnect.closeConnection();\n\n            File f1 = new File(currentCase.getTempDirectory() + File.separator + \"autopsy-copy.db\");\n            boolean success = f1.delete();\n\n        } catch (Exception e) {\n            Logger.getLogger(Report.class.getName()).log(Level.WARNING, \"Exception occurred\", e);\n        }\n\n        return table.toString();\n    }","id":76531,"modified_method":"/**\n     * Returns all the hash lookups related artifact/attributes and groups them\n     * based on hashset name\n     *\n     * @return String table is a string of an html table\n     *\n     */\n    public String getGroupedEmailHit() {\n        StringBuilder table = new StringBuilder();\n        HashMap<BlackboardArtifact, ArrayList<BlackboardAttribute>> reportMap = new HashMap<BlackboardArtifact, ArrayList<BlackboardAttribute>>();\n        Case currentCase = Case.getCurrentCase(); // get the most updated case\n        SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n        try {\n            tempDb.copyCaseDB(currentCase.getTempDirectory() + File.separator + \"autopsy-copy.db\");\n            dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\", \"jdbc:sqlite:\" + currentCase.getTempDirectory() + File.separator + \"autopsy-copy.db\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_path;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_from;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_bcc;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_subject;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_to;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_content;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_cc;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report_name;\");\n            tempdbconnect.executeStmt(\"DROP TABLE IF EXISTS report;\");\n            String temp1 = \"CREATE TABLE report_path AS SELECT value_text as path,blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID() + \";\";\n            String temp0 = \"CREATE TABLE report_date AS SELECT value_int64 as date, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_RCVD.getTypeID() + \";\";\n\n            String temp2 = \"CREATE TABLE report_to AS SELECT value_text as receiver, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_TO.getTypeID() + \";\";\n            String temp3 = \"CREATE TABLE report_content AS SELECT value_text as content, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_PLAIN.getTypeID() + \";\";\n            String temp4 = \"CREATE TABLE report_cc AS SELECT value_text as cc, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_CC.getTypeID() + \";\";\n            String temp7 = \"CREATE TABLE report_bcc AS SELECT value_text as bcc, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_BCC.getTypeID() + \";\";\n            String temp8 = \"CREATE TABLE report_author AS SELECT value_text as author, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_FROM.getTypeID() + \";\";\n            String temp6 = \"CREATE TABLE report_subject AS SELECT value_text as subject, blackboard_attributes.attribute_type_id, blackboard_attributes.artifact_id FROM blackboard_attributes WHERE attribute_type_id = \" + BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SUBJECT.getTypeID() + \";\";\n            String temp5 = \"CREATE TABLE report_name AS SELECT name, report_path.artifact_id from tsk_files,blackboard_artifacts, report_path WHERE blackboard_artifacts.artifact_id = report_path.artifact_id AND blackboard_artifacts.obj_id = tsk_files.obj_id;\";\n            String temp9 = \"CREATE TABLE report AS SELECT path,receiver,content,cc,bcc,subject,name,author,date from report_path INNER JOIN report_to ON report_path.artifact_id=report_to.artifact_id INNER JOIN report_content ON report_to.artifact_id=report_content.artifact_id INNER JOIN report_cc ON report_content.artifact_id=report_cc.artifact_id INNER JOIN report_name ON report_cc.artifact_id=report_name.artifact_id INNER JOIN report_bcc ON report_name.artifact_id=report_bcc.artifact_id INNER JOIN report_subject ON report_bcc.artifact_id=report_subject.artifact_id INNER JOIN report_author ON report_subject.artifact_id=report_author.artifact_id INNER JOIN report_date ON report_author.artifact_id=report_date.artifact_id\";\n            tempdbconnect.executeStmt(temp1);\n            tempdbconnect.executeStmt(temp0);\n            tempdbconnect.executeStmt(temp2);\n            tempdbconnect.executeStmt(temp3);\n            tempdbconnect.executeStmt(temp4);\n            tempdbconnect.executeStmt(temp5);\n            tempdbconnect.executeStmt(temp6);\n            tempdbconnect.executeStmt(temp7);\n            tempdbconnect.executeStmt(temp8);\n            tempdbconnect.executeStmt(temp9);\n            ResultSet uniqueresults = tempdbconnect.executeQry(\"SELECT path,receiver,content,cc,bcc,subject,name,author,date FROM report ORDER BY path ASC\");\n            String keyword = \"\";\n            while (uniqueresults.next()) {\n                if (uniqueresults.getString(\"path\") == null ? keyword == null : uniqueresults.getString(\"path\").equals(keyword)) {\n                } else {\n                    table.append(\"<\/tbody><\/table><br /><br />\");\n                    keyword = uniqueresults.getString(\"path\");\n                    table.append(\"<strong>\").append(keyword).append(\"<\/strong>\");\n                    table.append(\"<table><thead><tr><th>\").append(\"Folder\").append(\"<\/th><th>From<\/th><th>To<\/th><th>Subject<\/th><th>Date/Time<\/th><th>Content<\/th><th>CC<\/th><th>BCC<\/th><th>Path<\/th><\/tr><tbody>\");\n                }\n                table.append(\"<tr><td>\").append(uniqueresults.getString(\"name\")).append(\"<\/td>\");\n                table.append(\"<td>\").append(uniqueresults.getString(\"receiver\")).append(\"<\/td>\").append(\"<td>\").append(uniqueresults.getString(\"author\")).append(\"<br />(\").append(uniqueresults.getString(\"subject\")).append(\")\").append(\"<\/td>\");\n                SimpleDateFormat sdf = new java.text.SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n                String value = sdf.format(new java.util.Date(uniqueresults.getLong(\"date\") * 1000));\n                table.append(\"<td>\").append(value).append(\"<\/td>\");\n                table.append(\"<td>\").append(uniqueresults.getString(\"content\")).append(\"<\/td>\");\n                table.append(\"<td>\").append(uniqueresults.getString(\"cc\")).append(\"<\/td>\");\n                table.append(\"<td>\").append(uniqueresults.getString(\"bcc\")).append(\"<\/td>\");\n                table.append(\"<td>\").append(uniqueresults.getString(\"path\")).append(\"<\/td>\");\n                table.append(\"<\/tr>\");\n            }\n            tempdbconnect.closeConnection();\n\n            File f1 = new File(currentCase.getTempDirectory() + File.separator + \"autopsy-copy.db\");\n            boolean success = f1.delete();\n\n        } catch (Exception e) {\n            Logger.getLogger(Report.class.getName()).log(Level.WARNING, \"Exception occurred\", e);\n        }\n\n        return table.toString();\n    }","commit_id":"fd1cc38fc9a1446b4b7db59ac17da0cefe5829f2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public String generateReport(ReportConfiguration reportconfig) throws ReportModuleException {\n        config = reportconfig;\n        ReportGen reportobj = new ReportGen();\n        reportobj.populateReport(reportconfig);\n        HashMap<BlackboardArtifact, ArrayList<BlackboardAttribute>> report = reportobj.Results;\n        //This is literally a terrible way to count up all the types of artifacts, and doesn't include any added ones. \n        //Unlike the XML Report, which is dynamic, this is formatted and needs to be redone later instead of being hardcoded.\n        //Also, clearing variables to generate new Report.\n        formatted_Report.setLength(0);\n        unformatted_header.setLength(0);\n        formatted_header.setLength(0);\n\n        int countGen = 0;\n        int countWebBookmark = 0;\n        int countWebCookie = 0;\n        int countWebHistory = 0;\n        int countWebDownload = 0;\n        int countRecentObjects = 0;\n        int countTrackPoint = 0;\n        int countInstalled = 0;\n        int countKeyword = 0;\n        int countHash = 0;\n        int countDevice = 0;\n        int countEmail = 0;\n        for (Entry<BlackboardArtifact, ArrayList<BlackboardAttribute>> entry : report.entrySet()) {\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID()) {\n                countGen++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID()) {\n                countWebBookmark++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()) {\n\n                countWebCookie++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()) {\n\n                countWebHistory++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID()) {\n                countWebDownload++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID()) {\n                countRecentObjects++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getTypeID()) {\n                countTrackPoint++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID()) {\n                countInstalled++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                countKeyword++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n                countHash++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID()) {\n                countDevice++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID()) {\n                countEmail++;\n            }\n        }\n\n\n        String ingestwarning = \"<h2 style=\\\"color: red;\\\">Warning, this report was run before ingest services completed!<\/h2>\";\n\n        String caseName = currentCase.getName();\n        Integer imagecount = currentCase.getImageIDs().length;\n        Integer totalfiles = 0;\n        Integer totaldirs = 0;\n        try {\n            totaldirs = skCase.countFsContentType(TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR);\n            totalfiles = skCase.countFsContentType(TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG);\n        } catch (TskException ex) {\n            Logger.getLogger(ReportHTML.class.getName()).log(Level.WARNING, \"Could not get FsContentType counts from TSK \", ex);\n        }\n\n\n\n        int reportsize = report.size();\n        Integer filesystemcount = currentCase.getRootObjectsCount();\n        DateFormat datetimeFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n        DateFormat dateFormat = new SimpleDateFormat(\"MM-dd-yyyy\");\n        Date date = new Date();\n        String datetime = datetimeFormat.format(date);\n        String datenotime = dateFormat.format(date);\n        String CSS = \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=utf-8\\\"><style>\"\n                + \"body {padding: 30px; margin: 0; background: #FFFFFF; font: 13px/20px Arial, Helvetica, sans-serif; color: #535353;} \"\n                + \"h1 {font-size: 26px; color: #005577; margin: 0 0 20px 0;} \"\n                + \"h2 {font-size: 20px; font-weight: normal; color: #0077aa; margin: 40px 0 10px 0; padding: 0 0 10px 0; border-bottom: 1px solid #dddddd;} \"\n                + \"h3 {font-size: 16px;color: #0077aa; margin: 40px 0 10px 0;} \"\n                + \"p {margin: 0 0 20px 0;} table {width: 100%; padding: 0; margin: 0; border-collapse: collapse; border-bottom: 1px solid #e5e5e5;} \"\n                + \"table thead th {display: table-cell; text-align: left; padding: 8px 16px; background: #e5e5e5; color: #777;font-size: 11px;text-shadow: #e9f9fd 0 1px 0; border-top: 1px solid #dedede; border-bottom: 2px solid #dedede;} \"\n                + \"table tr th:nth-child(1) {text-align: center; width: 60px;} \"\n                + \"table td {display: table-cell; padding: 8px 16px; font: 13px/20px Arial, Helvetica, sans-serif;} \"\n                + \"table tr:nth-child(even) td {background: #f3f3f3;} \"\n                + \"table tr td:nth-child(1) {text-align: left; width: 60px; background: #f3f3f3;} \"\n                + \"table tr:nth-child(even) td:nth-child(1) {background: #eaeaea;}\"\n                + \"<\/style>\";\n        //Add additional header information\n        String header = \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\"><html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\"><head><title>Autopsy Report for Case: \" + caseName + \"<\/title>\";\n        formatted_header.append(header);\n        formatted_header.append(CSS);\n\n        //do for unformatted\n        String simpleCSS = \"<style>\"\n                + \"body {padding: 30px; margin: 0; background: #FFFFFF; color: #535353;} \"\n                + \"h1 {font-size: 26px; color: #005577; margin: 0 0 20px 0;} \"\n                + \"h2 {font-size: 20px; font-weight: normal; color: #0077aa; margin: 40px 0 10px 0; padding: 0 0 10px 0; border-bottom: 1px solid #dddddd;} \"\n                + \"h3 {font-size: 16px;color: #0077aa; margin: 40px 0 10px 0;} \"\n                + \"p {margin: 0 0 20px 0;} table {width: 100%; padding: 0; margin: 0; border-collapse: collapse; border-bottom: 1px solid #e5e5e5;} \"\n                + \"table thead th {display: table-cell; text-align: left; padding: 4px 8px; background: #e5e5e5; color: #777;font-size: 11px; width: 80px; border-top: 1px solid #dedede; border-bottom: 2px solid #dedede;} \"\n                + \"table tr th {text-align: left; width: 80px;} \"\n                + \"table td {width: 100px; font-size: 8px; display: table-cell; padding: 4px 8px;} \"\n                + \"table tr {text-align: left; width: 60px; background: #f3f3f3;} \"\n                + \"tr.alt td{ background-color: #FFFFFF;}\"\n                + \"<\/style>\";\n        unformatted_header.append(header);\n        unformatted_header.append(simpleCSS);\n        //formatted_Report.append(\"<link rel=\\\"stylesheet\\\" href=\\\"\" + rrpath + \"Report.css\\\" type=\\\"text/css\\\" />\");\n        formatted_Report.append(\"<\/head><body><div id=\\\"main\\\"><div id=\\\"content\\\">\");\n        // Add summary information now\n\n        formatted_Report.append(\"<h1>Report for Case: \").append(caseName).append(\"<\/h1>\");\n        if (IngestManager.getDefault().isIngestRunning()) {\n            formatted_Report.append(ingestwarning);\n        }\n        formatted_Report.append(\"<h2>Case Summary<\/h2><p>HTML Report Generated by <strong>Autopsy 3<\/strong> on \").append(datetime).append(\"<ul>\");\n        formatted_Report.append(\"<li># of Images: \").append(imagecount).append(\"<\/li>\");\n        formatted_Report.append(\"<li>FileSystems: \").append(filesystemcount).append(\"<\/li>\");\n        formatted_Report.append(\"<li># of Files: \").append(totalfiles.toString()).append(\"<\/li>\");\n        formatted_Report.append(\"<li># of Dirs: \").append(totaldirs.toString()).append(\"<\/li>\");\n        formatted_Report.append(\"<li># of Artifacts: \").append(reportsize).append(\"<\/li><\/ul>\");\n\n        formatted_Report.append(\"<br /><table><thead><tr><th>Section<\/th><th>Count<\/th><\/tr><\/thead><tbody>\");\n        if (countWebBookmark > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#bookmark\\\">Web Bookmarks<\/a><\/td><td>\").append(countWebBookmark).append(\"<\/td><\/tr>\");\n        }\n        if (countWebCookie > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#cookie\\\">Web Cookies<\/a><\/td><td>\").append(countWebCookie).append(\"<\/td><\/tr>\");\n        }\n        if (countWebHistory > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#history\\\">Web History<\/a><\/td><td>\").append(countWebHistory).append(\"<\/td><\/tr>\");\n        }\n        if (countWebDownload > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#download\\\">Web Downloads<\/a><\/td><td>\").append(countWebDownload).append(\"<\/td><\/tr>\");\n        }\n        if (countRecentObjects > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#recent\\\">Recent Documents<\/a><\/td><td>\").append(countRecentObjects).append(\"<\/td><\/tr>\");\n        }\n        if (countInstalled > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#installed\\\">Installed Programs<\/a><\/td><td>\").append(countInstalled).append(\"<\/td><\/tr>\");\n        }\n        if (countKeyword > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#keyword\\\">Keyword Hits<\/a><\/td><td>\").append(countKeyword).append(\"<\/td><\/tr>\");\n        }\n        if (countHash > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#hash\\\">Hash Hits<\/a><\/td><td>\").append(countHash).append(\"<\/td><\/tr>\");\n        }\n        if (countDevice > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#device\\\">Attached Devices<\/a><\/td><td>\").append(countDevice).append(\"<\/td><\/tr>\");\n        }\n        if (countDevice > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#email\\\">Email Messages<\/a><\/td><td>\").append(countEmail).append(\"<\/td><\/tr>\");\n        }\n        formatted_Report.append(\"<\/tbody><\/table><br />\");\n        String tableHeader = \"<table><thead><tr>\";\n        StringBuilder nodeGen = new StringBuilder(\"<h3>General Information (\").append(countGen).append(\")<\/h3>\").append(tableHeader).append(\"<th>Attribute<\/th><th>Value<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeWebBookmark = new StringBuilder(\"<h3><a name=\\\"bookmark\\\">Web Bookmarks (\").append(countWebBookmark).append(\")<\/h3>\").append(tableHeader).append(\"<th>URL<\/th><th>Title<\/th><th>Program<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeWebCookie = new StringBuilder(\"<h3><a name=\\\"cookie\\\">Web Cookies (\").append(countWebCookie).append(\")<\/h3>\").append(tableHeader).append(\"<th>URL<\/th><th>Date<\/th><th>Name<\/th><th>Value<\/th><th>Program<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeWebHistory = new StringBuilder(\"<h3><a name=\\\"history\\\">Web History (\").append(countWebHistory).append(\")<\/h3>\").append(tableHeader).append(\"<th>URL<\/th><th>Date<\/th><th>Referrer<\/th><th>Title<\/th><th>Program<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeWebDownload = new StringBuilder(\"<h3><a name=\\\"download\\\">Web Downloads (\").append(countWebDownload).append(\")<\/h3>\").append(tableHeader).append(\"<th>File<\/th><th>Source<\/th><th>Time<\/th><th>Program<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeRecentObjects = new StringBuilder(\"<h3><a name=\\\"recent\\\">Recent Documents (\").append(countRecentObjects).append(\")<\/h3>\").append(tableHeader).append(\"<th>Name<\/th><th>Path<\/th><th>Related Shortcut<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeTrackPoint = new StringBuilder(\"<h3><a name=\\\"track\\\">Track Points (\").append(countTrackPoint).append(\")<\/h3>\").append(tableHeader).append(\"<th>Artifact ID<\/th><th>Name<\/th><th>Size<\/th><th>Attribute<\/th><th>Value<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeInstalled = new StringBuilder(\"<h3><a name=\\\"installed\\\">Installed Programs (\").append(countInstalled).append(\")<\/h3>\").append(tableHeader).append(\"<th>Program Name<\/th><th>Install Date/Time<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeKeyword = new StringBuilder(\"<h3><a name=\\\"keyword\\\">Keyword Search Hits (\").append(countKeyword).append(\")<\/h3>\");\n        StringBuilder nodeHash = new StringBuilder(\"<h3><a name=\\\"hash\\\">Hashset Hit (\").append(countHash).append(\")<\/h3>\");\n        StringBuilder nodeDevice = new StringBuilder(\"<h3><a name=\\\"device\\\">Attached Devices (\").append(countHash).append(\")<\/h3>\").append(tableHeader).append(\"<th>Name<\/th><th>Serial #<\/th><th>Time<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeEmail = new StringBuilder(\"<h3><a name=\\\"email\\\">Email Messages (\").append(countHash).append(\")<\/h3>\");\n\n        int alt = 0;\n        String altRow = \"\";\n        for (Entry<BlackboardArtifact, ArrayList<BlackboardAttribute>> entry : report.entrySet()) {\n            if (ReportFilter.cancel == true) {\n                break;\n            }\n\n            if (alt > 0) {\n                altRow = \" class=\\\"alt\\\"\";\n                alt = 0;\n            } else {\n                altRow = \"\";\n                alt++;\n            }\n            StringBuilder artifact = new StringBuilder(\"\");\n            Long objId = entry.getKey().getObjectID();\n            //Content file = skCase.getContentById(objId);\n            AbstractFile file = null;\n            try {\n                file = skCase.getAbstractFileById(objId);\n            } catch (TskException ex) {\n                Logger.getLogger(ReportHTML.class.getName()).log(Level.WARNING, \"Could not get AbstractFile from TSK \", ex);\n            }\n\n            Long filesize = file.getSize();\n\n\n            TreeMap<Integer, String> attributes = new TreeMap<Integer, String>();\n            // Get all the attributes, line them up to be added. Place empty string placeholders for each attribute type\n            int n;\n            for (n = 1; n <= 35; n++) {\n                attributes.put(n, \"\");\n\n            }\n            for (BlackboardAttribute tempatt : entry.getValue()) {\n                if (ReportFilter.cancel == true) {\n                    break;\n                }\n                String value = \"\";\n                Integer type = tempatt.getAttributeTypeID();\n                if (type.equals(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()) || type.equals(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID())) {\n\n                    SimpleDateFormat sdf = new java.text.SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n                    value = sdf.format(new java.util.Date((tempatt.getValueLong() * 1000)));\n\n                } else {\n                    value = tempatt.getValueString();\n                }\n                if (value == null || value.isEmpty()) {\n                    value = \"\";\n                }\n                value = ReportUtils.insertPeriodically(value, \"<br>\", 30);\n                attributes.put(type, StringEscapeUtils.escapeHtml(value));\n\n            }\n\n\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID()) {\n\n                artifact.append(\"<\/tr>\");\n                nodeGen.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeWebBookmark.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeWebCookie.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeWebHistory.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeWebDownload.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID()) {\n                //artifact.append(\"<tr><td>\").append(objId.toString());\n                artifact.append(\"<tr\").append(altRow).append(\"><td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(file.getName()).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeRecentObjects.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(objId.toString());\n                artifact.append(\"<\/td><td><strong>\").append(file.getName().toString()).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(filesize.toString()).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeTrackPoint.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeInstalled.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                //  artifact.append(\"<table><thead><tr><th>Artifact ID<\/th><th>Name<\/th><th>Size<\/th>\");\n                //    artifact.append(\"<\/tr><\/table>\");\n                //    nodeKeyword.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n                // artifact.append(\"<tr><td>\").append(objId.toString());\n                artifact.append(\"<tr\").append(altRow).append(\"><td><strong>\").append(file.getName().toString()).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(filesize.toString()).append(\"<\/td>\");\n                //artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_INTERESTING_FILE.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeHash.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID())).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeDevice.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID()) {\n            }\n        }\n        //Add them back in order\n        //formatted_Report.append(nodeGen);\n        // formatted_Report.append(\"<\/tbody><\/table>\");\n\n        if (countWebBookmark > 0) {\n            formatted_Report.append(nodeWebBookmark);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countWebCookie > 0) {\n            formatted_Report.append(nodeWebCookie);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countWebHistory > 0) {\n            formatted_Report.append(nodeWebHistory);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countWebDownload > 0) {\n            formatted_Report.append(nodeWebDownload);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countRecentObjects > 0) {\n            formatted_Report.append(nodeRecentObjects);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        // formatted_Report.append(nodeTrackPoint);\n        //formatted_Report.append(\"<\/tbody><\/table>\");\n        if (countInstalled > 0) {\n            formatted_Report.append(nodeInstalled);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countKeyword > 0) {\n            formatted_Report.append(nodeKeyword);\n            Report keywords = new Report();\n            formatted_Report.append(keywords.getGroupedKeywordHit());\n            // \"<table><thead><tr><th>Artifact ID<\/th><th>Name<\/th><th>Size<\/th>\n            // formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countHash > 0) {\n            formatted_Report.append(nodeHash);\n            Report hashset = new Report();\n            formatted_Report.append(hashset.getGroupedHashsetHit());\n        }\n\n        if (countDevice > 0) {\n            formatted_Report.append(nodeDevice);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        //end of master loop\n        if (countEmail > 0) {\n            formatted_Report.append(nodeEmail);\n            Report email = new Report();\n            formatted_Report.append(email.getGroupedEmailHit());\n        }\n        formatted_Report.append(\"<\/div><\/div><\/body><\/html>\");\n        formatted_header.append(formatted_Report);\n        // unformatted_header.append(formatted_Report);\n        try {\n            htmlPath = currentCase.getCaseDirectory() + \"/Reports/\" + caseName + \"-\" + datenotime + \".html\";\n            this.save(htmlPath);\n\n        } catch (Exception e) {\n\n            Logger.getLogger(ReportHTML.class.getName()).log(Level.WARNING, \"Could not write out HTML report! \", e);\n        }\n        return htmlPath;\n    }","id":76532,"modified_method":"@Override\n    public String generateReport(ReportConfiguration reportconfig) throws ReportModuleException {\n        config = reportconfig;\n        ReportGen reportobj = new ReportGen();\n        reportobj.populateReport(reportconfig);\n        HashMap<BlackboardArtifact, ArrayList<BlackboardAttribute>> report = reportobj.Results;\n        //This is literally a terrible way to count up all the types of artifacts, and doesn't include any added ones. \n        //Unlike the XML Report, which is dynamic, this is formatted and needs to be redone later instead of being hardcoded.\n        //Also, clearing variables to generate new Report.\n        formatted_Report.setLength(0);\n        unformatted_header.setLength(0);\n        formatted_header.setLength(0);\n\n        int countGen = 0;\n        int countWebBookmark = 0;\n        int countWebCookie = 0;\n        int countWebHistory = 0;\n        int countWebDownload = 0;\n        int countRecentObjects = 0;\n        int countTrackPoint = 0;\n        int countInstalled = 0;\n        int countKeyword = 0;\n        int countHash = 0;\n        int countDevice = 0;\n        int countEmail = 0;\n        for (Entry<BlackboardArtifact, ArrayList<BlackboardAttribute>> entry : report.entrySet()) {\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID()) {\n                countGen++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID()) {\n                countWebBookmark++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()) {\n\n                countWebCookie++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()) {\n\n                countWebHistory++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID()) {\n                countWebDownload++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID()) {\n                countRecentObjects++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getTypeID()) {\n                countTrackPoint++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID()) {\n                countInstalled++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                countKeyword++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n                countHash++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID()) {\n                countDevice++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID()) {\n                countEmail++;\n            }\n        }\n\n\n        String ingestwarning = \"<h2 style=\\\"color: red;\\\">Warning, this report was run before ingest services completed!<\/h2>\";\n\n        String caseName = currentCase.getName();\n        Integer imagecount = currentCase.getImageIDs().length;\n        Integer totalfiles = 0;\n        Integer totaldirs = 0;\n        try {\n            totaldirs = skCase.countFsContentType(TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR);\n            totalfiles = skCase.countFsContentType(TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG);\n        } catch (TskException ex) {\n            Logger.getLogger(ReportHTML.class.getName()).log(Level.WARNING, \"Could not get FsContentType counts from TSK \", ex);\n        }\n\n\n\n        int reportsize = report.size();\n        Integer filesystemcount = currentCase.getRootObjectsCount();\n        DateFormat datetimeFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n        DateFormat dateFormat = new SimpleDateFormat(\"MM-dd-yyyy\");\n        Date date = new Date();\n        String datetime = datetimeFormat.format(date);\n        String datenotime = dateFormat.format(date);\n        String CSS = \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=utf-8\\\"><style>\"\n                + \"body {padding: 30px; margin: 0; background: #FFFFFF; font: 13px/20px Arial, Helvetica, sans-serif; color: #535353;} \"\n                + \"h1 {font-size: 26px; color: #005577; margin: 0 0 20px 0;} \"\n                + \"h2 {font-size: 20px; font-weight: normal; color: #0077aa; margin: 40px 0 10px 0; padding: 0 0 10px 0; border-bottom: 1px solid #dddddd;} \"\n                + \"h3 {font-size: 16px;color: #0077aa; margin: 40px 0 10px 0;} \"\n                + \"p {margin: 0 0 20px 0;} table {width: 100%; padding: 0; margin: 0; border-collapse: collapse; border-bottom: 1px solid #e5e5e5;} \"\n                + \"table thead th {display: table-cell; text-align: left; padding: 8px 16px; background: #e5e5e5; color: #777;font-size: 11px;text-shadow: #e9f9fd 0 1px 0; border-top: 1px solid #dedede; border-bottom: 2px solid #dedede;} \"\n                + \"table tr th:nth-child(1) {text-align: center; width: 60px;} \"\n                + \"table td {display: table-cell; padding: 8px 16px; font: 13px/20px Arial, Helvetica, sans-serif;} \"\n                + \"table tr:nth-child(even) td {background: #f3f3f3;} \"\n                + \"table tr td:nth-child(1) {text-align: left; width: 60px; background: #f3f3f3;} \"\n                + \"table tr:nth-child(even) td:nth-child(1) {background: #eaeaea;}\"\n                + \"<\/style>\";\n        //Add additional header information\n        String header = \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\"><html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\"><head><title>Autopsy Report for Case: \" + caseName + \"<\/title>\";\n        formatted_header.append(header);\n        formatted_header.append(CSS);\n\n        //do for unformatted\n        String simpleCSS = \"<style>\"\n                + \"body {padding: 30px; margin: 0; background: #FFFFFF; color: #535353;} \"\n                + \"h1 {font-size: 26px; color: #005577; margin: 0 0 20px 0;} \"\n                + \"h2 {font-size: 20px; font-weight: normal; color: #0077aa; margin: 40px 0 10px 0; padding: 0 0 10px 0; border-bottom: 1px solid #dddddd;} \"\n                + \"h3 {font-size: 16px;color: #0077aa; margin: 40px 0 10px 0;} \"\n                + \"p {margin: 0 0 20px 0;} table {width: 100%; padding: 0; margin: 0; border-collapse: collapse; border-bottom: 1px solid #e5e5e5;} \"\n                + \"table thead th {display: table-cell; text-align: left; padding: 4px 8px; background: #e5e5e5; color: #777;font-size: 11px; width: 80px; border-top: 1px solid #dedede; border-bottom: 2px solid #dedede;} \"\n                + \"table tr th {text-align: left; width: 80px;} \"\n                + \"table td {width: 100px; font-size: 8px; display: table-cell; padding: 4px 8px;} \"\n                + \"table tr {text-align: left; width: 60px; background: #f3f3f3;} \"\n                + \"tr.alt td{ background-color: #FFFFFF;}\"\n                + \"<\/style>\";\n        unformatted_header.append(header);\n        unformatted_header.append(simpleCSS);\n        //formatted_Report.append(\"<link rel=\\\"stylesheet\\\" href=\\\"\" + rrpath + \"Report.css\\\" type=\\\"text/css\\\" />\");\n        formatted_Report.append(\"<\/head><body><div id=\\\"main\\\"><div id=\\\"content\\\">\");\n        // Add summary information now\n\n        formatted_Report.append(\"<h1>Report for Case: \").append(caseName).append(\"<\/h1>\");\n        if (IngestManager.getDefault().isIngestRunning()) {\n            formatted_Report.append(ingestwarning);\n        }\n        formatted_Report.append(\"<h2>Case Summary<\/h2><p>HTML Report Generated by <strong>Autopsy 3<\/strong> on \").append(datetime).append(\"<ul>\");\n        formatted_Report.append(\"<li># of Images: \").append(imagecount).append(\"<\/li>\");\n        formatted_Report.append(\"<li>FileSystems: \").append(filesystemcount).append(\"<\/li>\");\n        formatted_Report.append(\"<li># of Files: \").append(totalfiles.toString()).append(\"<\/li>\");\n        formatted_Report.append(\"<li># of Dirs: \").append(totaldirs.toString()).append(\"<\/li>\");\n        formatted_Report.append(\"<li># of Artifacts: \").append(reportsize).append(\"<\/li><\/ul>\");\n\n        formatted_Report.append(\"<br /><table><thead><tr><th>Section<\/th><th>Count<\/th><\/tr><\/thead><tbody>\");\n        if (countWebBookmark > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#bookmark\\\">Web Bookmarks<\/a><\/td><td>\").append(countWebBookmark).append(\"<\/td><\/tr>\");\n        }\n        if (countWebCookie > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#cookie\\\">Web Cookies<\/a><\/td><td>\").append(countWebCookie).append(\"<\/td><\/tr>\");\n        }\n        if (countWebHistory > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#history\\\">Web History<\/a><\/td><td>\").append(countWebHistory).append(\"<\/td><\/tr>\");\n        }\n        if (countWebDownload > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#download\\\">Web Downloads<\/a><\/td><td>\").append(countWebDownload).append(\"<\/td><\/tr>\");\n        }\n        if (countRecentObjects > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#recent\\\">Recent Documents<\/a><\/td><td>\").append(countRecentObjects).append(\"<\/td><\/tr>\");\n        }\n        if (countInstalled > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#installed\\\">Installed Programs<\/a><\/td><td>\").append(countInstalled).append(\"<\/td><\/tr>\");\n        }\n        if (countKeyword > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#keyword\\\">Keyword Hits<\/a><\/td><td>\").append(countKeyword).append(\"<\/td><\/tr>\");\n        }\n        if (countHash > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#hash\\\">Hash Hits<\/a><\/td><td>\").append(countHash).append(\"<\/td><\/tr>\");\n        }\n        if (countDevice > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#device\\\">Attached Devices<\/a><\/td><td>\").append(countDevice).append(\"<\/td><\/tr>\");\n        }\n        if (countEmail > 0) {\n            formatted_Report.append(\"<tr><td><a href=\\\"#email\\\">Email Messages<\/a><\/td><td>\").append(countEmail).append(\"<\/td><\/tr>\");\n        }\n        formatted_Report.append(\"<\/tbody><\/table><br />\");\n        String tableHeader = \"<table><thead><tr>\";\n        StringBuilder nodeGen = new StringBuilder(\"<h3>General Information (\").append(countGen).append(\")<\/h3>\").append(tableHeader).append(\"<th>Attribute<\/th><th>Value<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeWebBookmark = new StringBuilder(\"<h3><a name=\\\"bookmark\\\">Web Bookmarks (\").append(countWebBookmark).append(\")<\/h3>\").append(tableHeader).append(\"<th>URL<\/th><th>Title<\/th><th>Program<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeWebCookie = new StringBuilder(\"<h3><a name=\\\"cookie\\\">Web Cookies (\").append(countWebCookie).append(\")<\/h3>\").append(tableHeader).append(\"<th>URL<\/th><th>Date<\/th><th>Name<\/th><th>Value<\/th><th>Program<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeWebHistory = new StringBuilder(\"<h3><a name=\\\"history\\\">Web History (\").append(countWebHistory).append(\")<\/h3>\").append(tableHeader).append(\"<th>URL<\/th><th>Date<\/th><th>Referrer<\/th><th>Title<\/th><th>Program<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeWebDownload = new StringBuilder(\"<h3><a name=\\\"download\\\">Web Downloads (\").append(countWebDownload).append(\")<\/h3>\").append(tableHeader).append(\"<th>File<\/th><th>Source<\/th><th>Time<\/th><th>Program<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeRecentObjects = new StringBuilder(\"<h3><a name=\\\"recent\\\">Recent Documents (\").append(countRecentObjects).append(\")<\/h3>\").append(tableHeader).append(\"<th>Name<\/th><th>Path<\/th><th>Related Shortcut<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeTrackPoint = new StringBuilder(\"<h3><a name=\\\"track\\\">Track Points (\").append(countTrackPoint).append(\")<\/h3>\").append(tableHeader).append(\"<th>Artifact ID<\/th><th>Name<\/th><th>Size<\/th><th>Attribute<\/th><th>Value<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeInstalled = new StringBuilder(\"<h3><a name=\\\"installed\\\">Installed Programs (\").append(countInstalled).append(\")<\/h3>\").append(tableHeader).append(\"<th>Program Name<\/th><th>Install Date/Time<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeKeyword = new StringBuilder(\"<h3><a name=\\\"keyword\\\">Keyword Search Hits (\").append(countKeyword).append(\")<\/h3>\");\n        StringBuilder nodeHash = new StringBuilder(\"<h3><a name=\\\"hash\\\">Hashset Hit (\").append(countHash).append(\")<\/h3>\");\n        StringBuilder nodeDevice = new StringBuilder(\"<h3><a name=\\\"device\\\">Attached Devices (\").append(countHash).append(\")<\/h3>\").append(tableHeader).append(\"<th>Name<\/th><th>Serial #<\/th><th>Time<\/th><\/tr><\/thead><tbody>\");\n        StringBuilder nodeEmail = new StringBuilder(\"<h3><a name=\\\"email\\\">Email Messages (\").append(countHash).append(\")<\/h3>\");\n\n        int alt = 0;\n        String altRow = \"\";\n        for (Entry<BlackboardArtifact, ArrayList<BlackboardAttribute>> entry : report.entrySet()) {\n            if (ReportFilter.cancel == true) {\n                break;\n            }\n\n            if (alt > 0) {\n                altRow = \" class=\\\"alt\\\"\";\n                alt = 0;\n            } else {\n                altRow = \"\";\n                alt++;\n            }\n            StringBuilder artifact = new StringBuilder(\"\");\n            Long objId = entry.getKey().getObjectID();\n            //Content file = skCase.getContentById(objId);\n            AbstractFile file = null;\n            try {\n                file = skCase.getAbstractFileById(objId);\n            } catch (TskException ex) {\n                Logger.getLogger(ReportHTML.class.getName()).log(Level.WARNING, \"Could not get AbstractFile from TSK \", ex);\n            }\n\n            Long filesize = file.getSize();\n\n\n            TreeMap<Integer, String> attributes = new TreeMap<Integer, String>();\n            // Get all the attributes, line them up to be added. Place empty string placeholders for each attribute type\n            int n;\n            for (n = 1; n <= 35; n++) {\n                attributes.put(n, \"\");\n\n            }\n            for (BlackboardAttribute tempatt : entry.getValue()) {\n                if (ReportFilter.cancel == true) {\n                    break;\n                }\n                String value = \"\";\n                Integer type = tempatt.getAttributeTypeID();\n                if (type.equals(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()) || type.equals(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID())) {\n\n                    SimpleDateFormat sdf = new java.text.SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n                    value = sdf.format(new java.util.Date((tempatt.getValueLong() * 1000)));\n\n                } else {\n                    value = tempatt.getValueString();\n                }\n                if (value == null || value.isEmpty()) {\n                    value = \"\";\n                }\n                value = ReportUtils.insertPeriodically(value, \"<br>\", 30);\n                attributes.put(type, StringEscapeUtils.escapeHtml(value));\n\n            }\n\n\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID()) {\n\n                artifact.append(\"<\/tr>\");\n                nodeGen.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeWebBookmark.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeWebCookie.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeWebHistory.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeWebDownload.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID()) {\n                //artifact.append(\"<tr><td>\").append(objId.toString());\n                artifact.append(\"<tr\").append(altRow).append(\"><td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(file.getName()).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeRecentObjects.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td>\").append(objId.toString());\n                artifact.append(\"<\/td><td><strong>\").append(file.getName().toString()).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(filesize.toString()).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeTrackPoint.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeInstalled.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                //  artifact.append(\"<table><thead><tr><th>Artifact ID<\/th><th>Name<\/th><th>Size<\/th>\");\n                //    artifact.append(\"<\/tr><\/table>\");\n                //    nodeKeyword.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n                // artifact.append(\"<tr><td>\").append(objId.toString());\n               // artifact.append(\"<tr\").append(altRow).append(\"><td><strong>\").append(file.getName().toString()).append(\"<\/strong><\/td>\");\n               // artifact.append(\"<td>\").append(filesize.toString()).append(\"<\/td>\");\n                //artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_INTERESTING_FILE.getTypeID())).append(\"<\/td>\");\n               // artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID())).append(\"<\/td>\");\n              //  artifact.append(\"<\/tr>\");\n               // nodeHash.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID()) {\n                artifact.append(\"<tr\").append(altRow).append(\"><td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID())).append(\"<\/strong><\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\");\n                artifact.append(\"<\/tr>\");\n                nodeDevice.append(artifact);\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID()) {\n            }\n        }\n        //Add them back in order\n        //formatted_Report.append(nodeGen);\n        // formatted_Report.append(\"<\/tbody><\/table>\");\n\n        if (countWebBookmark > 0) {\n            formatted_Report.append(nodeWebBookmark);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countWebCookie > 0) {\n            formatted_Report.append(nodeWebCookie);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countWebHistory > 0) {\n            formatted_Report.append(nodeWebHistory);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countWebDownload > 0) {\n            formatted_Report.append(nodeWebDownload);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countRecentObjects > 0) {\n            formatted_Report.append(nodeRecentObjects);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        // formatted_Report.append(nodeTrackPoint);\n        //formatted_Report.append(\"<\/tbody><\/table>\");\n        if (countInstalled > 0) {\n            formatted_Report.append(nodeInstalled);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countKeyword > 0) {\n            formatted_Report.append(nodeKeyword);\n            Report keywords = new Report();\n            formatted_Report.append(keywords.getGroupedKeywordHit());\n            // \"<table><thead><tr><th>Artifact ID<\/th><th>Name<\/th><th>Size<\/th>\n            // formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n        if (countHash > 0) {\n            formatted_Report.append(nodeHash);\n            Report hashset = new Report();\n            formatted_Report.append(hashset.getGroupedHashsetHit());\n        }\n\n        if (countDevice > 0) {\n            formatted_Report.append(nodeDevice);\n            formatted_Report.append(\"<\/tbody><\/table>\");\n        }\n       \n        if (countEmail > 0) {\n            formatted_Report.append(nodeEmail);\n            Report email = new Report();\n            formatted_Report.append(email.getGroupedEmailHit());\n        }\n        //end of master loop\n        formatted_Report.append(\"<\/div><\/div><\/body><\/html>\");\n        formatted_header.append(formatted_Report);\n        // unformatted_header.append(formatted_Report); \n        try {\n            htmlPath = currentCase.getCaseDirectory() + \"/Reports/\" + caseName + \"-\" + datenotime + \".html\";\n            this.save(htmlPath);\n\n        } catch (Exception e) {\n\n            Logger.getLogger(ReportHTML.class.getName()).log(Level.WARNING, \"Could not write out HTML report! \", e);\n        }\n        return htmlPath;\n    }","commit_id":"fd1cc38fc9a1446b4b7db59ac17da0cefe5829f2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public String generateReport(ReportConfiguration reportconfig) throws ReportModuleException {\n        config = reportconfig;\n        ReportGen reportobj = new ReportGen();\n        reportobj.populateReport(reportconfig);\n        HashMap<BlackboardArtifact, ArrayList<BlackboardAttribute>> report = reportobj.Results;\n        Workbook wbtemp = new XSSFWorkbook();\n        int countGen = 0;\n        int countBookmark = 0;\n        int countCookie = 0;\n        int countHistory = 0;\n        int countDownload = 0;\n        int countRecentObjects = 0;\n        int countTrackPoint = 0;\n        int countInstalled = 0;\n        int countKeyword = 0;\n        int countHash = 0;\n        int countDevice = 0;\n        int countEmail = 0;\n        for (Entry<BlackboardArtifact, ArrayList<BlackboardAttribute>> entry : report.entrySet()) {\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID()) {\n                countGen++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID()) {\n                countBookmark++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()) {\n\n                countCookie++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()) {\n\n                countHistory++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID()) {\n                countDownload++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID()) {\n                countRecentObjects++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getTypeID()) {\n                countTrackPoint++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID()) {\n                countInstalled++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                countKeyword++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n                countHash++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID()) {\n                countDevice++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID()) {\n                countEmail++;\n            }\n        }\n\n        try {\n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase skCase = currentCase.getSleuthkitCase();\n            String caseName = currentCase.getName();\n            Integer imagecount = currentCase.getImageIDs().length;\n            Integer filesystemcount = currentCase.getRootObjectsCount();\n            Integer totalfiles = skCase.countFsContentType(TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG);\n            Integer totaldirs = skCase.countFsContentType(TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR);\n            DateFormat datetimeFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n            DateFormat dateFormat = new SimpleDateFormat(\"MM-dd-yyyy-HH-mm-ss\");\n            Date date = new Date();\n            String datetime = datetimeFormat.format(date);\n            String datenotime = dateFormat.format(date);\n\n            //The first summary report page\n            Sheet sheetSummary = wbtemp.createSheet(\"Summary\");\n\n            //Generate a sheet per artifact type\n            //  Sheet sheetGen = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getDisplayName()); \n            Sheet sheetHash = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getDisplayName());\n            Sheet sheetDevice = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getDisplayName());\n            Sheet sheetInstalled = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getDisplayName());\n            Sheet sheetKeyword = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getDisplayName());\n            //  Sheet sheetTrackpoint = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getDisplayName()); \n            Sheet sheetRecent = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getDisplayName());\n            Sheet sheetCookie = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getDisplayName());\n            Sheet sheetBookmark = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getDisplayName());\n            Sheet sheetDownload = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getDisplayName());\n            Sheet sheetHistory = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getDisplayName());\n            Sheet sheetEmail = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getDisplayName());\n\n            //Bold/underline cell style for the top header rows\n            CellStyle style = wbtemp.createCellStyle();\n            style.setBorderBottom((short) 2);\n            Font font = wbtemp.createFont();\n            font.setFontHeightInPoints((short) 14);\n            font.setFontName(\"Arial\");\n            font.setBoldweight((short) 2);\n            style.setFont(font);\n\n            //create 'default' style\n            CellStyle defaultstyle = wbtemp.createCellStyle();\n            defaultstyle.setBorderBottom((short) 2);\n            Font defaultfont = wbtemp.createFont();\n            defaultfont.setFontHeightInPoints((short) 14);\n            defaultfont.setFontName(\"Arial\");\n            defaultfont.setBoldweight((short) 2);\n            defaultstyle.setFont(defaultfont);\n            //create the rows in the worksheet for our records\n            //Create first row and header\n            //  sheetGen.createRow(0);\n            //   sheetGen.getRow(0).createCell(0).setCellValue(\"Name\");\n            //   sheetGen.getRow(0).createCell(1).setCellValue(\"Value\");\n            //  sheetGen.getRow(0).createCell(2).setCellValue(\"Date/Time\");\n            sheetSummary.setDefaultColumnStyle(1, defaultstyle);\n            sheetSummary.createRow(0).setRowStyle(style);\n            sheetSummary.getRow(0).createCell(0).setCellValue(\"Summary Information\");\n            sheetSummary.getRow(0).createCell(1).setCellValue(caseName);\n            //add some basic information\n            sheetSummary.createRow(1).setRowStyle(defaultstyle);\n            sheetSummary.getRow(1).createCell(0).setCellValue(\"# of Images\");\n            sheetSummary.getRow(1).createCell(1).setCellValue(imagecount);\n            sheetSummary.createRow(2);\n            sheetSummary.getRow(2).createCell(0).setCellValue(\"Filesystems found\");\n            sheetSummary.getRow(2).createCell(1).setCellValue(imagecount);\n            sheetSummary.createRow(3);\n            sheetSummary.getRow(3).createCell(0).setCellValue(\"# of Files\");\n            sheetSummary.getRow(3).createCell(1).setCellValue(totalfiles);\n            sheetSummary.createRow(4);\n            sheetSummary.getRow(4).createCell(0).setCellValue(\"# of Directories\");\n            sheetSummary.getRow(4).createCell(1).setCellValue(totaldirs);\n            sheetSummary.createRow(5);\n            sheetSummary.getRow(5).createCell(0).setCellValue(\"Date/Time\");\n            sheetSummary.getRow(5).createCell(1).setCellValue(datetime);\n\n\n            sheetHash.setDefaultColumnStyle(1, defaultstyle);\n            sheetHash.createRow(0).setRowStyle(style);\n            sheetHash.getRow(0).createCell(0).setCellValue(\"Name\");\n            sheetHash.getRow(0).createCell(1).setCellValue(\"Size\");\n            sheetHash.getRow(0).createCell(2).setCellValue(\"Hashset Name\");\n\n            sheetDevice.setDefaultColumnStyle(1, defaultstyle);\n            sheetDevice.createRow(0).setRowStyle(style);\n            sheetDevice.getRow(0).createCell(0).setCellValue(\"Name\");\n            sheetDevice.getRow(0).createCell(1).setCellValue(\"Serial #\");\n            sheetDevice.getRow(0).createCell(2).setCellValue(\"Time\");\n\n            sheetInstalled.setDefaultColumnStyle(1, defaultstyle);\n            sheetInstalled.createRow(0).setRowStyle(style);\n            sheetInstalled.getRow(0).createCell(0).setCellValue(\"Program Name\");\n            sheetInstalled.getRow(0).createCell(1).setCellValue(\"Install Date/Time\");\n\n            sheetKeyword.setDefaultColumnStyle(1, defaultstyle);\n            sheetKeyword.createRow(0).setRowStyle(style);\n            sheetKeyword.getRow(0).createCell(0).setCellValue(\"Keyword\");\n            sheetKeyword.getRow(0).createCell(1).setCellValue(\"File Name\");\n            sheetKeyword.getRow(0).createCell(2).setCellValue(\"Preview\");\n            sheetKeyword.getRow(0).createCell(3).setCellValue(\"Keyword List\");\n\n            sheetRecent.setDefaultColumnStyle(1, defaultstyle);\n            sheetRecent.createRow(0).setRowStyle(style);\n            sheetRecent.getRow(0).createCell(0).setCellValue(\"Name\");\n            sheetRecent.getRow(0).createCell(1).setCellValue(\"Path\");\n            sheetRecent.getRow(0).createCell(2).setCellValue(\"Related Shortcut\");\n\n            sheetCookie.setDefaultColumnStyle(1, defaultstyle);\n            sheetCookie.createRow(0).setRowStyle(style);\n            sheetCookie.getRow(0).createCell(0).setCellValue(\"URL\");\n            sheetCookie.getRow(0).createCell(1).setCellValue(\"Date\");\n            sheetCookie.getRow(0).createCell(2).setCellValue(\"Name\");\n            sheetCookie.getRow(0).createCell(3).setCellValue(\"Value\");\n            sheetCookie.getRow(0).createCell(4).setCellValue(\"Program\");\n\n            sheetBookmark.setDefaultColumnStyle(1, defaultstyle);\n            sheetBookmark.createRow(0).setRowStyle(style);\n            sheetBookmark.getRow(0).createCell(0).setCellValue(\"URL\");\n            sheetBookmark.getRow(0).createCell(1).setCellValue(\"Title\");\n            sheetBookmark.getRow(0).createCell(2).setCellValue(\"Program\");\n\n            sheetDownload.setDefaultColumnStyle(1, defaultstyle);\n            sheetDownload.createRow(0).setRowStyle(style);\n            sheetDownload.getRow(0).createCell(0).setCellValue(\"File\");\n            sheetDownload.getRow(0).createCell(1).setCellValue(\"Source\");\n            sheetDownload.getRow(0).createCell(2).setCellValue(\"Time\");\n            sheetDownload.getRow(0).createCell(3).setCellValue(\"Program\");\n\n            sheetHistory.setDefaultColumnStyle(1, defaultstyle);\n            sheetHistory.createRow(0).setRowStyle(style);\n            sheetHistory.getRow(0).createCell(0).setCellValue(\"URL\");\n            sheetHistory.getRow(0).createCell(1).setCellValue(\"Date\");\n            sheetHistory.getRow(0).createCell(2).setCellValue(\"Referrer\");\n            sheetHistory.getRow(0).createCell(3).setCellValue(\"Title\");\n            sheetHistory.getRow(0).createCell(4).setCellValue(\"Program\");\n\n            sheetEmail.setDefaultColumnStyle(1, defaultstyle);\n            sheetEmail.createRow(0).setRowStyle(style);\n            sheetEmail.getRow(0).createCell(0).setCellValue(\"From\");\n            sheetEmail.getRow(0).createCell(1).setCellValue(\"To\");\n            sheetEmail.getRow(0).createCell(2).setCellValue(\"Subject\");\n            sheetEmail.getRow(0).createCell(3).setCellValue(\"Content\");\n            sheetEmail.getRow(0).createCell(4).setCellValue(\"CC\");\n            sheetEmail.getRow(0).createCell(4).setCellValue(\"BCC\");\n            sheetEmail.getRow(0).createCell(4).setCellValue(\"Path\");\n\n            for (int i = 0; i < wbtemp.getNumberOfSheets(); i++) {\n                Sheet tempsheet = wbtemp.getSheetAt(i);\n                tempsheet.setAutobreaks(true);\n\n                for (Row temprow : tempsheet) {\n                    for (Cell cell : temprow) {\n                        cell.setCellStyle(style);\n                        tempsheet.autoSizeColumn(cell.getColumnIndex());\n                    }\n                }\n            }\n\n            int countedGen = 0;\n            int countedBookmark = 0;\n            int countedCookie = 0;\n            int countedHistory = 0;\n            int countedDownload = 0;\n            int countedRecentObjects = 0;\n            int countedTrackPoint = 0;\n            int countedInstalled = 0;\n            int countedKeyword = 0;\n            int countedHash = 0;\n            int countedDevice = 0;\n\n            //start populating the sheets in the workbook\n            for (Entry<BlackboardArtifact, ArrayList<BlackboardAttribute>> entry : report.entrySet()) {\n                if (ReportFilter.cancel == true) {\n                    break;\n                }\n                int cc = 0;\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = skCase.getAbstractFileById(objId);\n                String filename = file.getName();\n                Long filesize = file.getSize();\n                TreeMap<Integer, String> attributes = new TreeMap<Integer, String>();\n                // Get all the attributes, line them up to be added. Place empty string placeholders for each attribute type\n                int n;\n                for (n = 1; n <= 36; n++) {\n                    attributes.put(n, \"\");\n\n                }\n                for (BlackboardAttribute tempatt : entry.getValue()) {\n                    if (ReportFilter.cancel == true) {\n                        break;\n                    }\n                    String value = \"\";\n                    int type = tempatt.getAttributeTypeID();\n                    if (tempatt.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID() || tempatt.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID()) {\n                        value = new java.text.SimpleDateFormat(\"MM/dd/yyyy HH:mm:ss\").format(new java.util.Date((tempatt.getValueLong()) * 1000)).toString();\n                    } else {\n                        value = tempatt.getValueString();\n                    }\n\n                    attributes.put(type, StringEscapeUtils.escapeXml(value));\n                    cc++;\n                }\n\n\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID()) {\n                    countedGen++;\n                    //  Row temp = sheetGen.getRow(countedGen);\n\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID()) {\n                    countedBookmark++;\n                    Row temp = sheetBookmark.createRow(countedBookmark);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()) {\n                    countedCookie++;\n                    Row temp = sheetCookie.createRow(countedCookie);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID()));\n                    temp.createCell(4).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()) {\n                    countedHistory++;\n                    Row temp = sheetHistory.createRow(countedHistory);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()));\n                    temp.createCell(4).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID()) {\n                    countedDownload++;\n                    Row temp = sheetDownload.createRow(countedDownload);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID()) {\n                    countedRecentObjects++;\n                    Row temp = sheetRecent.createRow(countedRecentObjects);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID()));\n                    temp.createCell(2).setCellValue(file.getName());\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getTypeID()) {\n                    // sheetTrackpoint.addContent(artifact);\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID()) {\n                    countedInstalled++;\n                    Row temp = sheetInstalled.createRow(countedInstalled);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                    countedKeyword++;\n                    Row temp = sheetKeyword.createRow(countedKeyword);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD.getTypeID()));\n                    temp.createCell(1).setCellValue(filename);\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n                    countedHash++;\n                    Row temp = sheetHash.createRow(countedHash);\n                    temp.createCell(0).setCellValue(file.getName().toString());\n                    temp.createCell(1).setCellValue(filesize.toString());\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID()) {\n                    countedDevice++;\n                    Row temp = sheetDevice.createRow(countedDevice);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()));\n                }\n            }\n\n\n            //write out the report to the reports folder, set the wbtemp to the primary wb object\n            wb = wbtemp;\n            xlsPath = currentCase.getCaseDirectory() + File.separator + \"Reports\" + File.separator + caseName + \"-\" + datenotime + \".xlsx\";\n            this.save(xlsPath);\n\n        } catch (Exception E) {\n            String test = E.toString();\n        }\n\n        return xlsPath;\n    }","id":76533,"modified_method":"@Override\n    public String generateReport(ReportConfiguration reportconfig) throws ReportModuleException {\n        config = reportconfig;\n        ReportGen reportobj = new ReportGen();\n        reportobj.populateReport(reportconfig);\n        HashMap<BlackboardArtifact, ArrayList<BlackboardAttribute>> report = reportobj.Results;\n        Workbook wbtemp = new XSSFWorkbook();\n        int countGen = 0;\n        int countBookmark = 0;\n        int countCookie = 0;\n        int countHistory = 0;\n        int countDownload = 0;\n        int countRecentObjects = 0;\n        int countTrackPoint = 0;\n        int countInstalled = 0;\n        int countKeyword = 0;\n        int countHash = 0;\n        int countDevice = 0;\n        int countEmail = 0;\n        for (Entry<BlackboardArtifact, ArrayList<BlackboardAttribute>> entry : report.entrySet()) {\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID()) {\n                countGen++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID()) {\n                countBookmark++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()) {\n\n                countCookie++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()) {\n\n                countHistory++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID()) {\n                countDownload++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID()) {\n                countRecentObjects++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getTypeID()) {\n                countTrackPoint++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID()) {\n                countInstalled++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                countKeyword++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n                countHash++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID()) {\n                countDevice++;\n            }\n            if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID()) {\n                countEmail++;\n            }\n        }\n\n        try {\n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase skCase = currentCase.getSleuthkitCase();\n            String caseName = currentCase.getName();\n            Integer imagecount = currentCase.getImageIDs().length;\n            Integer filesystemcount = currentCase.getRootObjectsCount();\n            Integer totalfiles = skCase.countFsContentType(TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_REG);\n            Integer totaldirs = skCase.countFsContentType(TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR);\n            DateFormat datetimeFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n            DateFormat dateFormat = new SimpleDateFormat(\"MM-dd-yyyy-HH-mm-ss\");\n            Date date = new Date();\n            String datetime = datetimeFormat.format(date);\n            String datenotime = dateFormat.format(date);\n\n            //The first summary report page\n            Sheet sheetSummary = wbtemp.createSheet(\"Summary\");\n\n            //Generate a sheet per artifact type\n            //  Sheet sheetGen = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getDisplayName()); \n            Sheet sheetHash = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getDisplayName());\n            Sheet sheetDevice = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getDisplayName());\n            Sheet sheetInstalled = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getDisplayName());\n            Sheet sheetKeyword = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getDisplayName());\n            //  Sheet sheetTrackpoint = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getDisplayName()); \n            Sheet sheetRecent = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getDisplayName());\n            Sheet sheetCookie = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getDisplayName());\n            Sheet sheetBookmark = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getDisplayName());\n            Sheet sheetDownload = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getDisplayName());\n            Sheet sheetHistory = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getDisplayName());\n            Sheet sheetEmail = wbtemp.createSheet(BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getDisplayName());\n\n            //Bold/underline cell style for the top header rows\n            CellStyle style = wbtemp.createCellStyle();\n            style.setBorderBottom((short) 2);\n            Font font = wbtemp.createFont();\n            font.setFontHeightInPoints((short) 14);\n            font.setFontName(\"Arial\");\n            font.setBoldweight((short) 2);\n            style.setFont(font);\n\n            //create 'default' style\n            CellStyle defaultstyle = wbtemp.createCellStyle();\n            defaultstyle.setBorderBottom((short) 2);\n            Font defaultfont = wbtemp.createFont();\n            defaultfont.setFontHeightInPoints((short) 14);\n            defaultfont.setFontName(\"Arial\");\n            defaultfont.setBoldweight((short) 2);\n            defaultstyle.setFont(defaultfont);\n            //create the rows in the worksheet for our records\n            //Create first row and header\n            //  sheetGen.createRow(0);\n            //   sheetGen.getRow(0).createCell(0).setCellValue(\"Name\");\n            //   sheetGen.getRow(0).createCell(1).setCellValue(\"Value\");\n            //  sheetGen.getRow(0).createCell(2).setCellValue(\"Date/Time\");\n            sheetSummary.setDefaultColumnStyle(1, defaultstyle);\n            sheetSummary.createRow(0).setRowStyle(style);\n            sheetSummary.getRow(0).createCell(0).setCellValue(\"Summary Information\");\n            sheetSummary.getRow(0).createCell(1).setCellValue(caseName);\n            //add some basic information\n            sheetSummary.createRow(1).setRowStyle(defaultstyle);\n            sheetSummary.getRow(1).createCell(0).setCellValue(\"# of Images\");\n            sheetSummary.getRow(1).createCell(1).setCellValue(imagecount);\n            sheetSummary.createRow(2);\n            sheetSummary.getRow(2).createCell(0).setCellValue(\"Filesystems found\");\n            sheetSummary.getRow(2).createCell(1).setCellValue(imagecount);\n            sheetSummary.createRow(3);\n            sheetSummary.getRow(3).createCell(0).setCellValue(\"# of Files\");\n            sheetSummary.getRow(3).createCell(1).setCellValue(totalfiles);\n            sheetSummary.createRow(4);\n            sheetSummary.getRow(4).createCell(0).setCellValue(\"# of Directories\");\n            sheetSummary.getRow(4).createCell(1).setCellValue(totaldirs);\n            sheetSummary.createRow(5);\n            sheetSummary.getRow(5).createCell(0).setCellValue(\"Date/Time\");\n            sheetSummary.getRow(5).createCell(1).setCellValue(datetime);\n\n\n            sheetHash.setDefaultColumnStyle(1, defaultstyle);\n            sheetHash.createRow(0).setRowStyle(style);\n            sheetHash.getRow(0).createCell(0).setCellValue(\"Name\");\n            sheetHash.getRow(0).createCell(1).setCellValue(\"Size\");\n            sheetHash.getRow(0).createCell(2).setCellValue(\"Hashset Name\");\n\n            sheetDevice.setDefaultColumnStyle(1, defaultstyle);\n            sheetDevice.createRow(0).setRowStyle(style);\n            sheetDevice.getRow(0).createCell(0).setCellValue(\"Name\");\n            sheetDevice.getRow(0).createCell(1).setCellValue(\"Serial #\");\n            sheetDevice.getRow(0).createCell(2).setCellValue(\"Time\");\n\n            sheetInstalled.setDefaultColumnStyle(1, defaultstyle);\n            sheetInstalled.createRow(0).setRowStyle(style);\n            sheetInstalled.getRow(0).createCell(0).setCellValue(\"Program Name\");\n            sheetInstalled.getRow(0).createCell(1).setCellValue(\"Install Date/Time\");\n\n            sheetKeyword.setDefaultColumnStyle(1, defaultstyle);\n            sheetKeyword.createRow(0).setRowStyle(style);\n            sheetKeyword.getRow(0).createCell(0).setCellValue(\"Keyword\");\n            sheetKeyword.getRow(0).createCell(1).setCellValue(\"File Name\");\n            sheetKeyword.getRow(0).createCell(2).setCellValue(\"Preview\");\n            sheetKeyword.getRow(0).createCell(3).setCellValue(\"Keyword List\");\n\n            sheetRecent.setDefaultColumnStyle(1, defaultstyle);\n            sheetRecent.createRow(0).setRowStyle(style);\n            sheetRecent.getRow(0).createCell(0).setCellValue(\"Name\");\n            sheetRecent.getRow(0).createCell(1).setCellValue(\"Path\");\n            sheetRecent.getRow(0).createCell(2).setCellValue(\"Related Shortcut\");\n\n            sheetCookie.setDefaultColumnStyle(1, defaultstyle);\n            sheetCookie.createRow(0).setRowStyle(style);\n            sheetCookie.getRow(0).createCell(0).setCellValue(\"URL\");\n            sheetCookie.getRow(0).createCell(1).setCellValue(\"Date\");\n            sheetCookie.getRow(0).createCell(2).setCellValue(\"Name\");\n            sheetCookie.getRow(0).createCell(3).setCellValue(\"Value\");\n            sheetCookie.getRow(0).createCell(4).setCellValue(\"Program\");\n\n            sheetBookmark.setDefaultColumnStyle(1, defaultstyle);\n            sheetBookmark.createRow(0).setRowStyle(style);\n            sheetBookmark.getRow(0).createCell(0).setCellValue(\"URL\");\n            sheetBookmark.getRow(0).createCell(1).setCellValue(\"Title\");\n            sheetBookmark.getRow(0).createCell(2).setCellValue(\"Program\");\n\n            sheetDownload.setDefaultColumnStyle(1, defaultstyle);\n            sheetDownload.createRow(0).setRowStyle(style);\n            sheetDownload.getRow(0).createCell(0).setCellValue(\"File\");\n            sheetDownload.getRow(0).createCell(1).setCellValue(\"Source\");\n            sheetDownload.getRow(0).createCell(2).setCellValue(\"Time\");\n            sheetDownload.getRow(0).createCell(3).setCellValue(\"Program\");\n\n            sheetHistory.setDefaultColumnStyle(1, defaultstyle);\n            sheetHistory.createRow(0).setRowStyle(style);\n            sheetHistory.getRow(0).createCell(0).setCellValue(\"URL\");\n            sheetHistory.getRow(0).createCell(1).setCellValue(\"Date\");\n            sheetHistory.getRow(0).createCell(2).setCellValue(\"Referrer\");\n            sheetHistory.getRow(0).createCell(3).setCellValue(\"Title\");\n            sheetHistory.getRow(0).createCell(4).setCellValue(\"Program\");\n\n            sheetEmail.setDefaultColumnStyle(1, defaultstyle);\n            sheetEmail.createRow(0).setRowStyle(style);\n            sheetEmail.getRow(0).createCell(0).setCellValue(\"From\");\n            sheetEmail.getRow(0).createCell(1).setCellValue(\"To\");\n            sheetEmail.getRow(0).createCell(2).setCellValue(\"Subject\");\n            sheetEmail.getRow(0).createCell(3).setCellValue(\"Date/Time\");\n            sheetEmail.getRow(0).createCell(4).setCellValue(\"Content\");\n            sheetEmail.getRow(0).createCell(5).setCellValue(\"CC\");\n            sheetEmail.getRow(0).createCell(6).setCellValue(\"BCC\");\n            sheetEmail.getRow(0).createCell(7).setCellValue(\"Path\");\n\n            for (int i = 0; i < wbtemp.getNumberOfSheets(); i++) {\n                Sheet tempsheet = wbtemp.getSheetAt(i);\n                tempsheet.setAutobreaks(true);\n\n                for (Row temprow : tempsheet) {\n                    for (Cell cell : temprow) {\n                        cell.setCellStyle(style);\n                        tempsheet.autoSizeColumn(cell.getColumnIndex());\n                    }\n                }\n            }\n\n            int countedGen = 0;\n            int countedBookmark = 0;\n            int countedCookie = 0;\n            int countedHistory = 0;\n            int countedDownload = 0;\n            int countedRecentObjects = 0;\n            int countedTrackPoint = 0;\n            int countedInstalled = 0;\n            int countedKeyword = 0;\n            int countedHash = 0;\n            int countedDevice = 0;\n            int countedEmail = 0;\n\n            //start populating the sheets in the workbook\n            for (Entry<BlackboardArtifact, ArrayList<BlackboardAttribute>> entry : report.entrySet()) {\n                if (ReportFilter.cancel == true) {\n                    break;\n                }\n                int cc = 0;\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = skCase.getAbstractFileById(objId);\n                String filename = file.getName();\n                Long filesize = file.getSize();\n                TreeMap<Integer, String> attributes = new TreeMap<Integer, String>();\n                // Get all the attributes, line them up to be added. Place empty string placeholders for each attribute type\n                int n;\n                for (n = 1; n <= 36; n++) {\n                    attributes.put(n, \"\");\n\n                }\n                for (BlackboardAttribute tempatt : entry.getValue()) {\n                    if (ReportFilter.cancel == true) {\n                        break;\n                    }\n                    String value = \"\";\n                    int type = tempatt.getAttributeTypeID();\n                    if (tempatt.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_RCVD.getTypeID() || tempatt.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID() || tempatt.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID()) {\n                        value = new java.text.SimpleDateFormat(\"MM/dd/yyyy HH:mm:ss\").format(new java.util.Date((tempatt.getValueLong()) * 1000)).toString();\n                    } else {\n                        value = tempatt.getValueString();\n                    }\n\n                    attributes.put(type, StringEscapeUtils.escapeXml(value));\n                    cc++;\n                }\n\n\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_GEN_INFO.getTypeID()) {\n                    countedGen++;\n                    //  Row temp = sheetGen.getRow(countedGen);\n\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID()) {\n                    countedBookmark++;\n                    Row temp = sheetBookmark.createRow(countedBookmark);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()) {\n                    countedCookie++;\n                    Row temp = sheetCookie.createRow(countedCookie);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID()));\n                    temp.createCell(4).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()) {\n                    countedHistory++;\n                    Row temp = sheetHistory.createRow(countedHistory);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()));\n                    temp.createCell(4).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD.getTypeID()) {\n                    countedDownload++;\n                    Row temp = sheetDownload.createRow(countedDownload);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_RECENT_OBJECT.getTypeID()) {\n                    countedRecentObjects++;\n                    Row temp = sheetRecent.createRow(countedRecentObjects);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID()));\n                    temp.createCell(2).setCellValue(file.getName());\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_TRACKPOINT.getTypeID()) {\n                    // sheetTrackpoint.addContent(artifact);\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_INSTALLED_PROG.getTypeID()) {\n                    countedInstalled++;\n                    Row temp = sheetInstalled.createRow(countedInstalled);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                    countedKeyword++;\n                    Row temp = sheetKeyword.createRow(countedKeyword);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD.getTypeID()));\n                    temp.createCell(1).setCellValue(filename);\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()) {\n                    countedHash++;\n                    Row temp = sheetHash.createRow(countedHash);\n                    temp.createCell(0).setCellValue(file.getName().toString());\n                    temp.createCell(1).setCellValue(filesize.toString());\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID()));\n                }\n                if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_DEVICE_ATTACHED.getTypeID()) {\n                    countedDevice++;\n                    Row temp = sheetDevice.createRow(countedDevice);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()));\n                }\n                \n                 if (entry.getKey().getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_EMAIL_MSG.getTypeID()) {\n                    countedEmail++;\n                    Row temp = sheetEmail.createRow(countedEmail);\n                    temp.createCell(0).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_FROM.getTypeID()));\n                    temp.createCell(1).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_TO.getTypeID()));\n                    temp.createCell(2).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SUBJECT.getTypeID()));\n                    temp.createCell(3).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_RCVD.getTypeID()));\n                    temp.createCell(4).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_CONTENT_PLAIN.getTypeID()));\n                    temp.createCell(5).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_CC.getTypeID()));\n                    temp.createCell(6).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL_BCC.getTypeID()));\n                    temp.createCell(7).setCellValue(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID()));\n                }\n            }\n\n\n            //write out the report to the reports folder, set the wbtemp to the primary wb object\n            wb = wbtemp;\n            xlsPath = currentCase.getCaseDirectory() + File.separator + \"Reports\" + File.separator + caseName + \"-\" + datenotime + \".xlsx\";\n            this.save(xlsPath);\n\n        } catch (Exception E) {\n            String test = E.toString();\n        }\n\n        return xlsPath;\n    }","commit_id":"fd1cc38fc9a1446b4b7db59ac17da0cefe5829f2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Test\n    public void testFollowsProtoChange() throws Exception {\n        try {\n            utils.getResourceFromUrl(baseUrl + \"/secure\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Connection to https://0.0.0.0 refused\"));\n        }\n    }","id":76534,"modified_method":"@Test(expectedExceptions = RuntimeException.class)\n    public void testFollowsProtoChange() throws Exception {\n        utils.getResourceFromUrl(baseUrl + \"/secure\");\n    }","commit_id":"3fb4d9ae89894f15eab0f9df867f8f2e67e2b6bc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@BeforeClass(alwaysRun=true)\n    public void setUp() throws Exception {\n        utils = ResourceUtils.create(this, \"mycontext\");\n\n        BasicHttpProcessor httpProcessor = new BasicHttpProcessor();\n        httpProcessor.addInterceptor(new ResponseServer());\n        httpProcessor.addInterceptor(new ResponseContent());\n        httpProcessor.addInterceptor(new ResponseConnControl());\n        httpProcessor.addInterceptor(new RequestBasicAuth());\n        httpProcessor.addInterceptor(new ResponseBasicUnauthorized());\n\n        server = new LocalTestServer(httpProcessor, null);\n        server.register(\"/simple\", new SimpleResponseHandler(\"OK\"));\n        server.register(\"/empty\", new SimpleResponseHandler(HttpStatus.SC_NO_CONTENT, \"\"));\n        server.register(\"/missing\", new SimpleResponseHandler(HttpStatus.SC_NOT_FOUND, \"Missing\"));\n        server.register(\"/redirect\", new SimpleResponseHandler(HttpStatus.SC_MOVED_TEMPORARILY, \"Redirect\", new BasicHeader(\"Location\", \"/simple\")));\n        server.register(\"/cycle\", new SimpleResponseHandler(HttpStatus.SC_MOVED_TEMPORARILY, \"Redirect\", new BasicHeader(\"Location\", \"/cycle\")));\n        server.register(\"/secure\", new SimpleResponseHandler(HttpStatus.SC_MOVED_TEMPORARILY, \"Redirect\", new BasicHeader(\"Location\", \"https://0.0.0.0/\")));\n        server.register(\"/auth\", new AuthHandler(\"test\", \"test\", \"OK\"));\n        server.register(\"/auth_escape\", new AuthHandler(\"test@me:/\", \"test\", \"OK\"));\n        server.register(\"/auth_escape2\", new AuthHandler(\"test@me:test\", \"\", \"OK\"));\n        server.register(\"/no_credentials\", new CheckNoCredentials());\n        server.start();\n\n        InetSocketAddress addr = server.getServiceAddress();\n        baseUrl = \"http://\" + addr.getHostName() + \":\" + addr.getPort();\n    }","id":76535,"modified_method":"@BeforeClass(alwaysRun=true)\n    public void setUp() throws Exception {\n        utils = ResourceUtils.create(this, \"mycontext\");\n\n        BasicHttpProcessor httpProcessor = new BasicHttpProcessor();\n        httpProcessor.addInterceptor(new ResponseServer());\n        httpProcessor.addInterceptor(new ResponseContent());\n        httpProcessor.addInterceptor(new ResponseConnControl());\n        httpProcessor.addInterceptor(new RequestBasicAuth());\n        httpProcessor.addInterceptor(new ResponseBasicUnauthorized());\n\n        server = ServerBootstrap.bootstrap()\n                .setListenerPort(8080)\n                .setHttpProcessor(httpProcessor)\n                .registerHandler(\"/simple\", new SimpleResponseHandler(\"OK\"))\n                .registerHandler(\"/empty\", new SimpleResponseHandler(HttpStatus.SC_NO_CONTENT, \"\"))\n                .registerHandler(\"/missing\", new SimpleResponseHandler(HttpStatus.SC_NOT_FOUND, \"Missing\"))\n                .registerHandler(\"/redirect\", new SimpleResponseHandler(HttpStatus.SC_MOVED_TEMPORARILY, \"Redirect\", new BasicHeader(\"Location\", \"/simple\")))\n                .registerHandler(\"/cycle\", new SimpleResponseHandler(HttpStatus.SC_MOVED_TEMPORARILY, \"Redirect\", new BasicHeader(\"Location\", \"/cycle\")))\n                .registerHandler(\"/secure\", new SimpleResponseHandler(HttpStatus.SC_MOVED_TEMPORARILY, \"Redirect\", new BasicHeader(\"Location\", \"https://0.0.0.0/\")))\n                .registerHandler(\"/auth\", new AuthHandler(\"test\", \"test\", \"OK\"))\n                .registerHandler(\"/auth_escape\", new AuthHandler(\"test@me:/\", \"test\", \"OK\"))\n                .registerHandler(\"/auth_escape2\", new AuthHandler(\"test@me:test\", \"\", \"OK\"))\n                .registerHandler(\"/no_credentials\", new CheckNoCredentials())\n                .create();\n        server.start();\n        baseUrl = \"http://\" + server.getInetAddress().getHostName() + \":\" + server.getLocalPort();\n    }","commit_id":"3fb4d9ae89894f15eab0f9df867f8f2e67e2b6bc","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private Connection lookForLiveConnection(final int attemptsLimit,\n                                             final int reconnectionTimeout) throws IOException {\n        lookingForLiveConnection = true;\n        try {\n            boolean restored = false;\n            int attempt = 0;\n            while (currentConnection == null && running && !Thread.interrupted()) {\n                final long next = Clock.currentTimeMillis() + reconnectionTimeout;\n                synchronized (this) {\n                    if (currentConnection == null) {\n                        final Connection connection = searchForAvailableConnection();\n                        restored = connection != null;\n                        if (restored) {\n                            try {\n                                ClientConfig clientConfig = client.getClientConfig();\n                                SocketInterceptor socketInterceptor = clientConfig.getSocketInterceptor();\n                                if (socketInterceptor != null) {\n                                    socketInterceptor.onConnect(connection.getSocket());\n                                }\n                                bindConnection(connection);\n                                currentConnection = connection;\n                            } catch (Throwable e) {\n                                closeConnection(connection);\n                                logger.log(Level.WARNING, \"got an exception on getConnection:\" + e.getMessage(), e);\n                                restored = false;\n                            }\n                        }\n                    }\n                }\n                if (currentConnection != null) {\n                    logger.log(Level.FINE, \"Client is connecting to \" + currentConnection);\n                    lookingForLiveConnection = false;\n                    break;\n                }\n                if (attempt >= attemptsLimit) {\n                    break;\n                }\n                attempt++;\n                final long t = next - Clock.currentTimeMillis();\n                logger.log(Level.INFO, format(\"Unable to get alive cluster connection,\" +\n                                              \" try in {0} ms later, attempt {1} of {2}.\",\n                                              Math.max(0, t), attempt, attemptsLimit));\n                if (t > 0) {\n                    try {\n                        Thread.sleep(t);\n                    } catch (InterruptedException e) {\n                        break;\n                    }\n                }\n            }\n            if (restored) {\n                notifyConnectionIsRestored();\n            }\n        } finally {\n            lookingForLiveConnection = false;\n        }\n        return currentConnection;\n    }","id":76536,"modified_method":"private Connection lookForLiveConnection(final int attemptsLimit,\n                                             final int reconnectionTimeout) throws IOException {\n        lookingForLiveConnection = true;\n        try {\n            boolean restored = false;\n            int attempt = 0;\n            while (currentConnection == null && running && !Thread.interrupted()) {\n                final long next = Clock.currentTimeMillis() + reconnectionTimeout;\n                synchronized (this) {\n                    if (currentConnection == null) {\n                        final Connection connection = searchForAvailableConnection();\n                        restored = connection != null;\n                        if (restored) {\n                            try {\n                                ClientConfig clientConfig = client.getClientConfig();\n                                if (clientConfig != null) {\n                                    SocketInterceptor socketInterceptor = clientConfig.getSocketInterceptor();\n                                    if (socketInterceptor != null) {\n                                        socketInterceptor.onConnect(connection.getSocket());\n                                    }\n                                }\n                                bindConnection(connection);\n                                currentConnection = connection;\n                            } catch (Throwable e) {\n                                closeConnection(connection);\n                                logger.log(Level.WARNING, \"got an exception on getConnection:\" + e.getMessage(), e);\n                                restored = false;\n                            }\n                        }\n                    }\n                }\n                if (currentConnection != null) {\n                    logger.log(Level.FINE, \"Client is connecting to \" + currentConnection);\n                    lookingForLiveConnection = false;\n                    break;\n                }\n                if (attempt >= attemptsLimit) {\n                    break;\n                }\n                attempt++;\n                final long t = next - Clock.currentTimeMillis();\n                logger.log(Level.INFO, format(\"Unable to get alive cluster connection,\" +\n                                              \" try in {0} ms later, attempt {1} of {2}.\",\n                                              Math.max(0, t), attempt, attemptsLimit));\n                if (t > 0) {\n                    try {\n                        Thread.sleep(t);\n                    } catch (InterruptedException e) {\n                        break;\n                    }\n                }\n            }\n            if (restored) {\n                notifyConnectionIsRestored();\n            }\n        } finally {\n            lookingForLiveConnection = false;\n        }\n        return currentConnection;\n    }","commit_id":"ebe735fe6f1c4c54feec91f4ed586c2b69855baa","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public InstanceListenerManager(HazelcastClient client) {\n        this.client = client;\n        for (Object listener : client.getClientConfig().getListeners()) {\n            if (listener instanceof InstanceListener) {\n                registerListener((InstanceListener) listener);\n            }\n        }\n    }","id":76537,"modified_method":"public InstanceListenerManager(HazelcastClient client) {\n        this.client = client;\n        final ClientConfig clientConfig = client.getClientConfig();\n        if (clientConfig != null) {\n            for (Object listener : clientConfig.getListeners()) {\n                if (listener instanceof InstanceListener) {\n                    registerListener((InstanceListener) listener);\n                }\n            }\n        }\n    }","commit_id":"ebe735fe6f1c4c54feec91f4ed586c2b69855baa","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MembershipListenerManager(HazelcastClient client) {\n        this.client = client;\n        for (Object listener : client.getClientConfig().getListeners()) {\n            if (listener instanceof MembershipListener) {\n                registerListener((MembershipListener) listener);\n            }\n        }\n    }","id":76538,"modified_method":"public MembershipListenerManager(HazelcastClient client) {\n        this.client = client;\n        final ClientConfig clientConfig = client.getClientConfig();\n        if (clientConfig != null) {\n            for (Object listener : clientConfig.getListeners()) {\n                if (listener instanceof MembershipListener) {\n                    registerListener((MembershipListener) listener);\n                }\n            }\n        }\n    }","commit_id":"ebe735fe6f1c4c54feec91f4ed586c2b69855baa","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Connection lookForLiveConnection(final int attemptsLimit,\n                                             final int reconnectionTimeout) throws IOException {\n        lookingForLiveConnection = true;\n        try {\n            boolean restored = false;\n            int attempt = 0;\n            while (currentConnection == null && running && !Thread.interrupted()) {\n                final long next = Clock.currentTimeMillis() + reconnectionTimeout;\n                synchronized (this) {\n                    if (currentConnection == null) {\n                        final Connection connection = searchForAvailableConnection();\n                        restored = connection != null;\n                        if (restored) {\n                            try {\n                                ClientConfig clientConfig = client.getClientConfig();\n                                SocketInterceptor socketInterceptor = clientConfig.getSocketInterceptor();\n                                if (socketInterceptor != null) {\n                                    socketInterceptor.onConnect(connection.getSocket());\n                                }\n                                bindConnection(connection);\n                                currentConnection = connection;\n                            } catch (Throwable e) {\n                                closeConnection(connection);\n                                logger.log(Level.WARNING, \"got an exception on getConnection:\" + e.getMessage(), e);\n                                restored = false;\n                            }\n                        }\n                    }\n                }\n                if (currentConnection != null) {\n                    logger.log(Level.FINE, \"Client is connecting to \" + currentConnection);\n                    lookingForLiveConnection = false;\n                    break;\n                }\n                if (attempt >= attemptsLimit) {\n                    break;\n                }\n                attempt++;\n                final long t = next - Clock.currentTimeMillis();\n                logger.log(Level.INFO, format(\"Unable to get alive cluster connection,\" +\n                                              \" try in {0} ms later, attempt {1} of {2}.\",\n                                              Math.max(0, t), attempt, attemptsLimit));\n                if (t > 0) {\n                    try {\n                        Thread.sleep(t);\n                    } catch (InterruptedException e) {\n                        break;\n                    }\n                }\n            }\n            if (restored) {\n                notifyConnectionIsRestored();\n            }\n        } finally {\n            lookingForLiveConnection = false;\n        }\n        return currentConnection;\n    }","id":76539,"modified_method":"private Connection lookForLiveConnection(final int attemptsLimit,\n                                             final int reconnectionTimeout) throws IOException {\n        lookingForLiveConnection = true;\n        try {\n            boolean restored = false;\n            int attempt = 0;\n            while (currentConnection == null && running && !Thread.interrupted()) {\n                final long next = Clock.currentTimeMillis() + reconnectionTimeout;\n                synchronized (this) {\n                    if (currentConnection == null) {\n                        final Connection connection = searchForAvailableConnection();\n                        restored = connection != null;\n                        if (restored) {\n                            try {\n                                ClientConfig clientConfig = client.getClientConfig();\n                                if (clientConfig != null) {\n                                    SocketInterceptor socketInterceptor = clientConfig.getSocketInterceptor();\n                                    if (socketInterceptor != null) {\n                                        socketInterceptor.onConnect(connection.getSocket());\n                                    }\n                                }\n                                bindConnection(connection);\n                                currentConnection = connection;\n                            } catch (Throwable e) {\n                                closeConnection(connection);\n                                logger.log(Level.WARNING, \"got an exception on getConnection:\" + e.getMessage(), e);\n                                restored = false;\n                            }\n                        }\n                    }\n                }\n                if (currentConnection != null) {\n                    logger.log(Level.FINE, \"Client is connecting to \" + currentConnection);\n                    lookingForLiveConnection = false;\n                    break;\n                }\n                if (attempt >= attemptsLimit) {\n                    break;\n                }\n                attempt++;\n                final long t = next - Clock.currentTimeMillis();\n                logger.log(Level.INFO, format(\"Unable to get alive cluster connection,\" +\n                                              \" try in {0} ms later, attempt {1} of {2}.\",\n                                              Math.max(0, t), attempt, attemptsLimit));\n                if (t > 0) {\n                    try {\n                        Thread.sleep(t);\n                    } catch (InterruptedException e) {\n                        break;\n                    }\n                }\n            }\n            if (restored) {\n                notifyConnectionIsRestored();\n            }\n        } finally {\n            lookingForLiveConnection = false;\n        }\n        return currentConnection;\n    }","commit_id":"3bc329bcd8233fd71a4cd24c261fd0eb2ba6f4ee","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public InstanceListenerManager(HazelcastClient client) {\n        this.client = client;\n        for (Object listener : client.getClientConfig().getListeners()) {\n            if (listener instanceof InstanceListener) {\n                registerListener((InstanceListener) listener);\n            }\n        }\n    }","id":76540,"modified_method":"public InstanceListenerManager(HazelcastClient client) {\n        this.client = client;\n        final ClientConfig clientConfig = client.getClientConfig();\n        if (clientConfig != null) {\n            for (Object listener : clientConfig.getListeners()) {\n                if (listener instanceof InstanceListener) {\n                    registerListener((InstanceListener) listener);\n                }\n            }\n        }\n    }","commit_id":"3bc329bcd8233fd71a4cd24c261fd0eb2ba6f4ee","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MembershipListenerManager(HazelcastClient client) {\n        this.client = client;\n        for (Object listener : client.getClientConfig().getListeners()) {\n            if (listener instanceof MembershipListener) {\n                registerListener((MembershipListener) listener);\n            }\n        }\n    }","id":76541,"modified_method":"public MembershipListenerManager(HazelcastClient client) {\n        this.client = client;\n        final ClientConfig clientConfig = client.getClientConfig();\n        if (clientConfig != null) {\n            for (Object listener : clientConfig.getListeners()) {\n                if (listener instanceof MembershipListener) {\n                    registerListener((MembershipListener) listener);\n                }\n            }\n        }\n    }","commit_id":"3bc329bcd8233fd71a4cd24c261fd0eb2ba6f4ee","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * {@code CompileEnvironment#compileBunchOfSources} wrapper.\n     *\n     * @param src       compilation source (directory or file)\n     * @param output    compilation destination directory\n     * @param stdlib    \"kotlin-runtime.jar\" path\n     * @param classpath compilation classpath, can be <code>null<\/code> or empty\n     */\n    public void sourcesToDir ( @NotNull String src, @NotNull String output, @Nullable String stdlib, @Nullable String[] classpath ) {\n        try {\n            boolean success = env( stdlib, classpath ).compileBunchOfSources( src, null, output, true /* Last arg is ignored anyway */ );\n            if ( ! success ) {\n                throw new CompileEnvironmentException( errorMessage( src, false ));\n            }\n        }\n        catch ( Exception e ) {\n            throw new CompileEnvironmentException( errorMessage( src, true ), e );\n        }\n    }","id":76542,"modified_method":"/**\n     * {@code CompileEnvironment#compileBunchOfSources} wrapper.\n     *\n     * @param src       compilation source (directory or file)\n     * @param output    compilation destination directory\n     * @param stdlib    \"kotlin-runtime.jar\" path\n     * @param classpath compilation classpath, can be <code>null<\/code> or empty\n     */\n    public void sourcesToDir ( @NotNull String src, @NotNull String output, @Nullable String stdlib, @Nullable String[] classpath ) {\n        try {\n            boolean success = KotlinToJVMBytecodeCompiler.compileBunchOfSources(env(stdlib, classpath), src, null, output, true\n                                                                                /* Last arg is ignored anyway */);\n            if ( ! success ) {\n                throw new CompileEnvironmentException( errorMessage( src, false ));\n            }\n        }\n        catch ( Exception e ) {\n            throw new CompileEnvironmentException( errorMessage( src, true ), e );\n        }\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * {@code CompileEnvironment#compileBunchOfSources} wrapper.\n     *\n     * @param src            compilation source (directory or file)\n     * @param jar            compilation destination jar\n     * @param includeRuntime whether Kotlin runtime library is included in destination jar\n     * @param stdlib         \"kotlin-runtime.jar\" path\n     * @param classpath      compilation classpath, can be <code>null<\/code> or empty\n     */\n    public void sourcesToJar ( @NotNull String src, @NotNull String jar, boolean includeRuntime, @Nullable String stdlib, @Nullable String[] classpath ) {\n        try {\n            boolean success = env( stdlib, classpath ).compileBunchOfSources( src, jar, null, includeRuntime );\n            if ( ! success ) {\n                throw new CompileEnvironmentException( errorMessage( src, false ));\n            }\n        }\n        catch ( Exception e ) {\n            throw new CompileEnvironmentException( errorMessage( src, true ), e );\n        }\n    }","id":76543,"modified_method":"/**\n     * {@code CompileEnvironment#compileBunchOfSources} wrapper.\n     *\n     * @param src            compilation source (directory or file)\n     * @param jar            compilation destination jar\n     * @param includeRuntime whether Kotlin runtime library is included in destination jar\n     * @param stdlib         \"kotlin-runtime.jar\" path\n     * @param classpath      compilation classpath, can be <code>null<\/code> or empty\n     */\n    public void sourcesToJar ( @NotNull String src, @NotNull String jar, boolean includeRuntime, @Nullable String stdlib, @Nullable String[] classpath ) {\n        try {\n            boolean success = KotlinToJVMBytecodeCompiler.compileBunchOfSources(env(stdlib, classpath), src, jar, null, includeRuntime);\n            if ( ! success ) {\n                throw new CompileEnvironmentException( errorMessage( src, false ));\n            }\n        }\n        catch ( Exception e ) {\n            throw new CompileEnvironmentException( errorMessage( src, true ), e );\n        }\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * {@code CompileEnvironment#compileModuleScript} wrapper.\n     *\n     * @param module         compilation module file\n     * @param jar            compilation destination jar\n     * @param includeRuntime whether Kotlin runtime library is included in destination jar\n     * @param stdlib         \"kotlin-runtime.jar\" path\n     * @param classpath      compilation classpath, can be <code>null<\/code> or empty\n     */\n    public void moduleToJar ( @NotNull String module, @NotNull String jar, boolean includeRuntime, @Nullable String stdlib, @Nullable String[] classpath ) {\n        try {\n            boolean success = env( stdlib, classpath ).compileModuleScript( module, jar, null, includeRuntime);\n            if ( ! success ) {\n                throw new CompileEnvironmentException( errorMessage( module, false ));\n            }\n        }\n        catch ( Exception e ) {\n            throw new CompileEnvironmentException( errorMessage( module, true ), e );\n        }\n    }","id":76544,"modified_method":"/**\n     * {@code CompileEnvironment#compileModuleScript} wrapper.\n     *\n     * @param module         compilation module file\n     * @param jar            compilation destination jar\n     * @param includeRuntime whether Kotlin runtime library is included in destination jar\n     * @param stdlib         \"kotlin-runtime.jar\" path\n     * @param classpath      compilation classpath, can be <code>null<\/code> or empty\n     */\n    public void moduleToJar ( @NotNull String module, @NotNull String jar, boolean includeRuntime, @Nullable String stdlib, @Nullable String[] classpath ) {\n        try {\n            CompileEnvironmentConfiguration env = env(stdlib, classpath);\n            boolean success = KotlinToJVMBytecodeCompiler.compileModuleScript(env, module, jar, null, includeRuntime);\n            if ( ! success ) {\n                throw new CompileEnvironmentException( errorMessage( module, false ));\n            }\n        }\n        catch ( Exception e ) {\n            throw new CompileEnvironmentException( errorMessage( module, true ), e );\n        }\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Creates new instance of {@link CompileEnvironment} instance using the arguments specified.\n     *\n     * @param stdlib    path to \"kotlin-runtime.jar\", only used if not null and not empty\n     * @param classpath compilation classpath, only used if not null and not empty\n     *\n     * @return compile environment instance\n     */\n    private CompileEnvironment env( String stdlib, String[] classpath ) {\n        CompileEnvironment env = new CompileEnvironment(MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR));\n\n        if (( stdlib != null ) && ( stdlib.trim().length() > 0 )) {\n            env.setStdlib( stdlib );\n        }\n\n        if (( classpath != null ) && ( classpath.length > 0 )) {\n            env.addToClasspath( classpath );\n        }\n\n        // lets register any compiler plugins\n        env.getEnvironment().getCompilerPlugins().addAll(getCompilerPlugins());\n\n        return env;\n    }","id":76545,"modified_method":"/**\n     * Creates new instance of {@link org.jetbrains.jet.compiler.CompileEnvironmentConfiguration} instance using the arguments specified.\n     *\n     * @param stdlib    path to \"kotlin-runtime.jar\", only used if not null and not empty\n     * @param classpath compilation classpath, only used if not null and not empty\n     *\n     * @return compile environment instance\n     */\n    private CompileEnvironmentConfiguration env( String stdlib, String[] classpath ) {\n        CompilerDependencies dependencies = CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR);\n        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);\n        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);\n\n        if (( stdlib != null ) && ( stdlib.trim().length() > 0 )) {\n            File file = new File(stdlib);\n            CompileEnvironmentUtil.addToClasspath(env.getEnvironment(), file);\n        }\n\n        if (( classpath != null ) && ( classpath.length > 0 )) {\n            CompileEnvironmentUtil.addToClasspath(env.getEnvironment(), classpath);\n        }\n\n        // lets register any compiler plugins\n        env.getEnvironment().getCompilerPlugins().addAll(getCompilerPlugins());\n\n        return env;\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static List<Module> runDefineModules(CompilerDependencies compilerDependencies, String moduleFile, ClassFileFactory factory) {\n        File stdlibJar = compilerDependencies.getRuntimeJar();\n        GeneratedClassLoader loader;\n        if (stdlibJar != null) {\n            try {\n                loader = new GeneratedClassLoader(factory, new URLClassLoader(new URL[]{stdlibJar.toURI().toURL()}, AllModules.class.getClassLoader()));\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        else {\n            loader = new GeneratedClassLoader(factory, CompileEnvironment.class.getClassLoader());\n        }\n        try {\n            Class namespaceClass = loader.loadClass(JvmAbi.PACKAGE_CLASS);\n            final Method method = namespaceClass.getDeclaredMethod(\"project\");\n            if (method == null) {\n                throw new CompileEnvironmentException(\"Module script \" + moduleFile + \" must define project() function\");\n            }\n\n            method.setAccessible(true);\n            method.invoke(null);\n\n            ArrayList<Module> answer = new ArrayList<Module>(AllModules.modules.get());\n            AllModules.modules.get().clear();\n            return answer;\n        }\n        catch (Exception e) {\n            throw new ModuleExecutionException(e);\n        }\n        finally {\n            loader.dispose();\n        }\n    }","id":76546,"modified_method":"private static List<Module> runDefineModules(CompilerDependencies compilerDependencies, String moduleFile, ClassFileFactory factory) {\n        File stdlibJar = compilerDependencies.getRuntimeJar();\n        GeneratedClassLoader loader;\n        if (stdlibJar != null) {\n            try {\n                loader = new GeneratedClassLoader(factory, new URLClassLoader(new URL[]{stdlibJar.toURI().toURL()}, AllModules.class.getClassLoader()));\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        else {\n            loader = new GeneratedClassLoader(factory, CompileEnvironmentConfiguration.class.getClassLoader());\n        }\n        try {\n            Class namespaceClass = loader.loadClass(JvmAbi.PACKAGE_CLASS);\n            final Method method = namespaceClass.getDeclaredMethod(\"project\");\n            if (method == null) {\n                throw new CompileEnvironmentException(\"Module script \" + moduleFile + \" must define project() function\");\n            }\n\n            method.setAccessible(true);\n            method.invoke(null);\n\n            ArrayList<Module> answer = new ArrayList<Module>(AllModules.modules.get());\n            AllModules.modules.get().clear();\n            return answer;\n        }\n        catch (Exception e) {\n            throw new ModuleExecutionException(e);\n        }\n        finally {\n            loader.dispose();\n        }\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static File getUnpackedRuntimePath() {\n        URL url = CompileEnvironment.class.getClassLoader().getResource(\"jet/JetObject.class\");\n        if (url != null && url.getProtocol().equals(\"file\")) {\n            return new File(url.getPath()).getParentFile().getParentFile();\n        }\n        return null;\n    }","id":76547,"modified_method":"@Nullable\n    public static File getUnpackedRuntimePath() {\n        URL url = CompileEnvironmentConfiguration.class.getClassLoader().getResource(\"jet/JetObject.class\");\n        if (url != null && url.getProtocol().equals(\"file\")) {\n            return new File(url.getPath()).getParentFile().getParentFile();\n        }\n        return null;\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static File getRuntimeJarPath() {\n        URL url = CompileEnvironment.class.getClassLoader().getResource(\"jet/JetObject.class\");\n        if (url != null && url.getProtocol().equals(\"jar\")) {\n            String path = url.getPath();\n            return new File(path.substring(path.indexOf(\":\") + 1, path.indexOf(\"!/\")));\n        }\n        return null;\n    }","id":76548,"modified_method":"@Nullable\n    public static File getRuntimeJarPath() {\n        URL url = CompileEnvironmentConfiguration.class.getClassLoader().getResource(\"jet/JetObject.class\");\n        if (url != null && url.getProtocol().equals(\"jar\")) {\n            String path = url.getPath();\n            return new File(path.substring(path.indexOf(\":\") + 1, path.indexOf(\"!/\")));\n        }\n        return null;\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testMe() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        String text = \"import org.jetbrains.jet.codegen.CompileTextTest; fun x() = CompileTextTest()\";\n        CompileEnvironment compileEnvironment = new CompileEnvironment(MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR, CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR));\n        compileEnvironment.getEnvironment().addToClasspathFromClassLoader(getClass().getClassLoader());\n        ClassLoader classLoader = compileEnvironment.compileText(text);\n        Class<?> namespace = classLoader.loadClass(\"namespace\");\n        Method x = namespace.getDeclaredMethod(\"x\");\n        Object invoke = x.invoke(null);\n        assertTrue(invoke instanceof CompileTextTest);\n    }","id":76549,"modified_method":"public void testMe() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        String text = \"import org.jetbrains.jet.codegen.CompileTextTest; fun x() = CompileTextTest()\";\n        CompilerDependencies dependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR);\n        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);\n        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);\n        configuration.getEnvironment().addToClasspathFromClassLoader(getClass().getClassLoader());\n        ClassLoader classLoader = KotlinToJVMBytecodeCompiler.compileText(configuration, text);\n        Class<?> namespace = classLoader.loadClass(\"namespace\");\n        Method x = namespace.getDeclaredMethod(\"x\");\n        Object invoke = x.invoke(null);\n        assertTrue(invoke instanceof CompileTextTest);\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Strategy method to configure the environment, allowing compiler\n     * based tools to customise their own plugins\n     */\n    protected void configureEnvironment(CompileEnvironment environment, CompilerArguments arguments) {\n        // install any compiler plugins\n        List<CompilerPlugin> plugins = arguments.getCompilerPlugins();\n        if (plugins != null) {\n            environment.getEnvironment().getCompilerPlugins().addAll(plugins);\n        }\n\n        if (environment.getCompilerDependencies().getRuntimeJar() != null) {\n            environment.addToClasspath(environment.getCompilerDependencies().getRuntimeJar());\n        }\n\n        if (arguments.classpath != null) {\n            final Iterable<String> classpath = Splitter.on(File.pathSeparatorChar).split(arguments.classpath);\n            environment.addToClasspath(Iterables.toArray(classpath, String.class));\n        }\n    }","id":76550,"modified_method":"/**\n     * Strategy method to configure the environment, allowing compiler\n     * based tools to customise their own plugins\n     */\n    protected void configureEnvironment(CompileEnvironmentConfiguration configuration, CompilerArguments arguments) {\n        // install any compiler plugins\n        List<CompilerPlugin> plugins = arguments.getCompilerPlugins();\n        if (plugins != null) {\n            configuration.getEnvironment().getCompilerPlugins().addAll(plugins);\n        }\n\n        if (configuration.getCompilerDependencies().getRuntimeJar() != null) {\n            CompileEnvironmentUtil.addToClasspath(configuration.getEnvironment(), configuration.getCompilerDependencies().getRuntimeJar());\n        }\n\n        if (arguments.classpath != null) {\n            final Iterable<String> classpath = Splitter.on(File.pathSeparatorChar).split(arguments.classpath);\n            CompileEnvironmentUtil.addToClasspath(configuration.getEnvironment(), Iterables.toArray(classpath, String.class));\n        }\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Executes the compiler on the parsed arguments\n     */\n    public ExitCode exec(final PrintStream errStream, CompilerArguments arguments) {\n        if (arguments.help) {\n            usage(errStream);\n            return OK;\n        }\n        System.setProperty(\"java.awt.headless\", \"true\");\n\n        final MessageRenderer messageRenderer = arguments.tags ? MessageRenderer.TAGS : MessageRenderer.PLAIN;\n\n        if (arguments.version) {\n            errStream.println(messageRenderer.render(CompilerMessageSeverity.INFO, \"Kotlin Compiler version \" + CompilerVersion.VERSION, CompilerMessageLocation.NO_LOCATION));\n        }\n\n        CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);\n\n        File jdkHeadersJar;\n        if (mode.includeJdkHeaders()) {\n            if (arguments.jdkHeaders != null) {\n                jdkHeadersJar = new File(arguments.jdkHeaders);\n            }\n            else {\n                jdkHeadersJar = PathUtil.getAltHeadersPath();\n            }\n        }\n        else {\n            jdkHeadersJar = null;\n        }\n        File runtimeJar;\n\n        if (mode.includeKotlinRuntime()) {\n            if (arguments.stdlib != null) {\n                runtimeJar = new File(arguments.stdlib);\n            }\n            else {\n                runtimeJar = PathUtil.getDefaultRuntimePath();\n            }\n        }\n        else {\n            runtimeJar = null;\n        }\n\n        CompilerDependencies dependencies = new CompilerDependencies(mode, jdkHeadersJar,runtimeJar);\n        PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);\n        CompileEnvironment environment = new CompileEnvironment(messageCollector, dependencies);\n        try {\n            configureEnvironment(environment, arguments);\n\n            boolean noErrors;\n            if (arguments.module != null) {\n                noErrors = environment.compileModuleScript(arguments.module, arguments.jar, arguments.outputDir, arguments.includeRuntime);\n            }\n            else {\n                // TODO ideally we'd unify to just having a single field that supports multiple files/dirs\n                if (arguments.getSourceDirs() != null) {\n                    noErrors = environment.compileBunchOfSourceDirectories(arguments.getSourceDirs(), arguments.jar, arguments.outputDir, arguments.includeRuntime);\n                }\n                else {\n                    noErrors = environment.compileBunchOfSources(arguments.src, arguments.jar, arguments.outputDir, arguments.includeRuntime);\n                }\n            }\n            return noErrors ? OK : COMPILATION_ERROR;\n        }\n        catch (Throwable t) {\n            errStream.println(messageRenderer.renderException(t));\n            return INTERNAL_ERROR;\n        }\n        finally {\n            environment.dispose();\n            messageCollector.printToErrStream();\n        }\n    }","id":76551,"modified_method":"/**\n     * Executes the compiler on the parsed arguments\n     */\n    public ExitCode exec(final PrintStream errStream, CompilerArguments arguments) {\n        if (arguments.help) {\n            usage(errStream);\n            return OK;\n        }\n        System.setProperty(\"java.awt.headless\", \"true\");\n\n        final MessageRenderer messageRenderer = arguments.tags ? MessageRenderer.TAGS : MessageRenderer.PLAIN;\n\n        if (arguments.version) {\n            errStream.println(messageRenderer.render(CompilerMessageSeverity.INFO, \"Kotlin Compiler version \" + CompilerVersion.VERSION, CompilerMessageLocation.NO_LOCATION));\n        }\n\n        CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);\n\n        File jdkHeadersJar;\n        if (mode.includeJdkHeaders()) {\n            if (arguments.jdkHeaders != null) {\n                jdkHeadersJar = new File(arguments.jdkHeaders);\n            }\n            else {\n                jdkHeadersJar = PathUtil.getAltHeadersPath();\n            }\n        }\n        else {\n            jdkHeadersJar = null;\n        }\n        File runtimeJar;\n\n        if (mode.includeKotlinRuntime()) {\n            if (arguments.stdlib != null) {\n                runtimeJar = new File(arguments.stdlib);\n            }\n            else {\n                runtimeJar = PathUtil.getDefaultRuntimePath();\n            }\n        }\n        else {\n            runtimeJar = null;\n        }\n\n        CompilerDependencies dependencies = new CompilerDependencies(mode, jdkHeadersJar, runtimeJar);\n        PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);\n        Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();\n\n        JetCoreEnvironment environment = new JetCoreEnvironment(rootDisposable, dependencies);\n        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, messageCollector);\n        try {\n            configureEnvironment(configuration, arguments);\n\n            boolean noErrors;\n            if (arguments.module != null) {\n                noErrors = KotlinToJVMBytecodeCompiler.compileModuleScript(configuration,\n                                                                           arguments.module, arguments.jar, arguments.outputDir,\n                                                                           arguments.includeRuntime);\n            }\n            else {\n                // TODO ideally we'd unify to just having a single field that supports multiple files/dirs\n                if (arguments.getSourceDirs() != null) {\n                    noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,\n                                                                                           arguments.getSourceDirs(), arguments.jar, arguments.outputDir, arguments.includeRuntime);\n                }\n                else {\n                    noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,\n                                                                 arguments.src, arguments.jar, arguments.outputDir, arguments.includeRuntime);\n                }\n            }\n            return noErrors ? OK : COMPILATION_ERROR;\n        }\n        catch (Throwable t) {\n            errStream.println(messageRenderer.renderException(t));\n            return INTERNAL_ERROR;\n        }\n        finally {\n            Disposer.dispose(rootDisposable);\n            messageCollector.printToErrStream();\n        }\n    }","commit_id":"4da91ee3d62a02b97aa842a80e5a12601f856f64","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static JetCoreEnvironment createEnvironmentWithFullJdk(Disposable disposable) {\n        return new JetCoreEnvironment(disposable,\n                CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false));\n    }","id":76552,"modified_method":"public static JetCoreEnvironment createEnvironmentWithFullJdk(Disposable disposable) {\n        return JetCoreEnvironment.getCoreEnvironmentForJVM(disposable,\n                CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false));\n    }","commit_id":"330532661bea4cf0613aa9b0799b9423dbd1370a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void testLibraryFile(@Nullable File jar, @NotNull String libDescription) throws IOException {\n        System.out.println(\"Testing library \" + libDescription + \"...\");\n        if (jar != null) {\n            System.out.println(\"Using file \" + jar);\n        }\n        else {\n            System.out.println(\"Using rt.jar\");\n        }\n\n        long start = System.currentTimeMillis();\n\n        Disposable junk = new Disposable() {\n            @Override\n            public void dispose() { }\n        };\n\n        JetCoreEnvironment jetCoreEnvironment;\n        if (jar != null) {\n            jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdk(junk);\n            jetCoreEnvironment.addToClasspath(jar);\n        }\n        else {\n            CompilerDependencies compilerDependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false);\n            jetCoreEnvironment = new JetCoreEnvironment(junk, compilerDependencies);\n            jar = compilerDependencies.getJdkJar();\n        }\n\n\n        InjectorForJavaSemanticServices injector = new InjectorForJavaSemanticServices(compilerDependencies, jetCoreEnvironment.getProject());\n\n        FileInputStream is = new FileInputStream(jar);\n        try {\n            ZipInputStream zip = new ZipInputStream(is);\n            for (;;) {\n                ZipEntry entry = zip.getNextEntry();\n                if (entry == null) {\n                    break;\n                }\n                String entryName = entry.getName();\n                if (!entryName.endsWith(\".class\")) {\n                    continue;\n                }\n                if (entryName.matches(\"(.*/|)package-info\\\\.class\")) {\n                    continue;\n                }\n                if (entryName.contains(\"$\")) {\n                    continue;\n                }\n                String className = entryName.substring(0, entryName.length() - \".class\".length()).replace(\"/\", \".\");\n                ClassDescriptor clazz = injector.getJavaDescriptorResolver().resolveClass(new FqName(className), DescriptorSearchRule.ERROR_IF_FOUND_IN_KOTLIN);\n                if (clazz == null) {\n                    throw new IllegalStateException(\"class not found by name \" + className + \" in \" + libDescription);\n                }\n                clazz.getDefaultType().getMemberScope().getAllDescriptors();\n            }\n\n        } finally {\n            try {\n                is.close();\n            }\n            catch (Throwable e) {}\n\n            Disposer.dispose(junk);\n        }\n\n        System.out.println(\"Testing library \" + libDescription + \" done in \" + TimeUtils.millisecondsToSecondsString(System.currentTimeMillis() - start) + \"s\");\n    }","id":76553,"modified_method":"private void testLibraryFile(@Nullable File jar, @NotNull String libDescription) throws IOException {\n        System.out.println(\"Testing library \" + libDescription + \"...\");\n        if (jar != null) {\n            System.out.println(\"Using file \" + jar);\n        }\n        else {\n            System.out.println(\"Using rt.jar\");\n        }\n\n        long start = System.currentTimeMillis();\n\n        Disposable junk = new Disposable() {\n            @Override\n            public void dispose() { }\n        };\n\n        JetCoreEnvironment jetCoreEnvironment;\n        if (jar != null) {\n            jetCoreEnvironment = JetTestUtils.createEnvironmentWithMockJdk(junk);\n            jetCoreEnvironment.addToClasspath(jar);\n        }\n        else {\n            CompilerDependencies compilerDependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false);\n            jetCoreEnvironment = JetCoreEnvironment.getCoreEnvironmentForJVM(junk, compilerDependencies);\n            jar = compilerDependencies.getJdkJar();\n        }\n\n\n        InjectorForJavaSemanticServices injector = new InjectorForJavaSemanticServices(compilerDependencies, jetCoreEnvironment.getProject());\n\n        FileInputStream is = new FileInputStream(jar);\n        try {\n            ZipInputStream zip = new ZipInputStream(is);\n            for (;;) {\n                ZipEntry entry = zip.getNextEntry();\n                if (entry == null) {\n                    break;\n                }\n                String entryName = entry.getName();\n                if (!entryName.endsWith(\".class\")) {\n                    continue;\n                }\n                if (entryName.matches(\"(.*/|)package-info\\\\.class\")) {\n                    continue;\n                }\n                if (entryName.contains(\"$\")) {\n                    continue;\n                }\n                String className = entryName.substring(0, entryName.length() - \".class\".length()).replace(\"/\", \".\");\n                ClassDescriptor clazz = injector.getJavaDescriptorResolver().resolveClass(new FqName(className), DescriptorSearchRule.ERROR_IF_FOUND_IN_KOTLIN);\n                if (clazz == null) {\n                    throw new IllegalStateException(\"class not found by name \" + className + \" in \" + libDescription);\n                }\n                clazz.getDefaultType().getMemberScope().getAllDescriptors();\n            }\n\n        } finally {\n            try {\n                is.close();\n            }\n            catch (Throwable e) {}\n\n            Disposer.dispose(junk);\n        }\n\n        System.out.println(\"Testing library \" + libDescription + \" done in \" + TimeUtils.millisecondsToSecondsString(System.currentTimeMillis() - start) + \"s\");\n    }","commit_id":"330532661bea4cf0613aa9b0799b9423dbd1370a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tif (isSynthetic(method) || !prescreen(classContext, method))\n\t\t\treturn;\n\t\t\n\t\t\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tIsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n\t\tSet<ValueNumber> paramValueNumberSet = null;\n\t\t\n\t\tValueNumberDataflow vnaDataflow = null;\n\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tString methodName = methodGen.getClassName() + \".\"\n\t\t\t\t+ methodGen.getName();\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Checking \" + methodName);\n\t\t}\n\n\t\tSet<SourceLineAnnotation> haveInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveCast = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleCast = new HashSet<SourceLineAnnotation>();\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\tif (ins instanceof CHECKCAST) {\n\t\t\t\tif (!haveCast.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleCast.add(sourceLineAnnotation);\n\t\t\t} else {\n\t\t\t\tif (!haveInstanceOf.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleInstanceOf.add(sourceLineAnnotation);\n\t\t\t}\n\t\t}\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tint pc = handle.getPosition();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\t\t\tif (handle.getNext() == null) continue;\n\t\t\tInstruction nextIns = handle.getNext().getInstruction();\n\n\t\t\tboolean isCast = ins instanceof CHECKCAST;\n\t\t\tString kind = isCast ? \"checkedCast\" : \"instanceof\";\n\t\t\tint occurrences = cfg.getLocationsContainingInstructionWithOffset(\n\t\t\t\t\tpc).size();\n\t\t\tboolean split = occurrences > 1;\n\t\t\tIsNullValueFrame nullFrame = isNullDataflow.getFactAtLocation(location);\n\t\t\tIsNullValue operandNullness = nullFrame.getTopValue();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out\n\t\t\t\t\t\t.println(kind + \" at pc: \" + pc + \" in \" + methodName);\n\t\t\t\tSystem.out.println(\" occurrences: \" + occurrences);\n\t\t\t\tSystem.out.println(\"XXX: \" + operandNullness);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (split && !isCast) {\n\t\t\t\t// don't report this case; it might be infeasible due to inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tType operandType = frame.getTopValue();\n\t\t\tif (operandType.equals(TopType.instance())) {\n\t\t\t\t// unreachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tType castType = ((TypedInstruction) ins).getType(cpg);\n\n\t\t\tif (!(castType instanceof ReferenceType)) {\n\t\t\t\t// This shouldn't happen either\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castSig = castType.getSignature();\n\t\t\t\n\t\t\tif (operandType.equals(NullType.instance()) || operandNullness.isDefinitelyNull()) {\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\t\tif (!isCast) bugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_NULL_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation)\n\t\t\t\t\t\t);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\tif (!(operandType instanceof ReferenceType)) {\n\t\t\t\t// Shouldn't happen - illegal bytecode\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tReferenceType refType = (ReferenceType) operandType;\n\n\t\t\n\t\t\tif (refType.equals(castType)) {\n\t\t\t\t// System.out.println(\"self-cast to \" + castType.getSignature());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tString refSig = refType.getSignature();\n\t\t\tString castSig2 = castSig;\n\t\t\tString refSig2 = refSig;\n\t\t\twhile (castSig2.charAt(0) == '[' && refSig2.charAt(0) == '[') {\n\t\t\t\tcastSig2 = castSig2.substring(1);\n\t\t\t\trefSig2 = refSig2.substring(1);\n\t\t\t}\n\n\t\t\tif (refSig2.equals(\"Ljava/lang/Object;\") && !(nextIns instanceof InvokeInstruction)) {\n\t\t\t\t// System.out.println(\"cast of object value to \" + castType.getSignature());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (refSig2.charAt(0) != 'L' || castSig2.charAt(0) != 'L') {\n\t\t\t\t// cast involving primative arrays\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\n\t\t\tif (isCast && haveMultipleCast.contains(sourceLineAnnotation)\n\t\t\t\t\t|| !isCast\n\t\t\t\t\t&& haveMultipleInstanceOf.contains(sourceLineAnnotation)) {\n\t\t\t\t// skip; might be due to JSR inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castName = castSig2.substring(1, castSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\t\t\tString refName = refSig2.substring(1, refSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\n\t\t\tif (vnaDataflow == null)\n\t\t\t\tvnaDataflow = classContext\n\t\t\t\t.getValueNumberDataflow(method);\n\t\t\tValueNumberFrame vFrame = vnaDataflow.getFactAtLocation(location);\n\t\t\tif (paramValueNumberSet == null) \n\t\t\t\tparamValueNumberSet = getParameterValueNumbers(classContext, method, cfg);\n\t\t\tboolean isParameter = paramValueNumberSet.contains(vFrame\n\t\t\t\t\t.getTopValue());\n\t\t\ttry {\n\t\t\t\tJavaClass castJavaClass = Repository.lookupClass(castName);\n\t\t\t\tJavaClass refJavaClass = Repository.lookupClass(refName);\n\t\t\t\tboolean upcast = Repository.instanceOf(refJavaClass,\n\t\t\t\t\t\tcastJavaClass);\n\t\t\t\tif (upcast) {\n\t\t\t\t\tif (!isCast)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\t\t\"BC_VACUOUS_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation).addClass(\n\t\t\t\t\t\t\t\t\t\trefName.replace('/', '.')).addClass(\n\t\t\t\t\t\t\t\t\t\tcastName.replace('/', '.')));\n\t\t\t\t} else {\n\t\t\t\t\tboolean downcast = Repository.instanceOf(castJavaClass,\n\t\t\t\t\t\t\trefJavaClass);\n\t\t\t\t\tif (false && downcast && refName.equals(\"java.lang.Object\") && nextIns instanceof InvokeInstruction) {\n\t\t\t\t\t\tInvokeInstruction nextInvokeIns =  (InvokeInstruction) nextIns;\n\t\t\t\t\t\tType []  argTypes = nextInvokeIns.getArgumentTypes(cpg);\n\t\t\t\t\t\tString mName =  nextInvokeIns.getMethodName(cpg);\n\t\t\t\t\t\tif (argTypes.length > 0 && !mName.equals(\"add\")) {\n\t\t\t\t\t\t\tType lastArg = argTypes[argTypes.length - 1];\n\t\t\t\t\t\t\tif (lastArg instanceof ObjectType) {\n\t\t\t\t\t\t\t\tString name = ((ObjectType)lastArg).getClassName();\n\t\t\t\t\t\t\t\tif (refName.equals(name))\n\t\t\t\t\t\t\t\tSystem.out.println(\"Cast from \" + refName + \" to \" + castName + \" for argument of type \" + name\n\t+ \" of \" + mName\n\t\t\t\t\t\t\t\t\t\t+ \" in \" + sourceFile + \" : \" + methodName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (refName.equals(\"java.lang.Object\")) continue;\n\t\t\t\t\tdouble rank = Analyze.deepInstanceOf(refJavaClass,\n\t\t\t\t\t\t\tcastJavaClass);\n\t\t\t\t\tboolean castToConcreteCollection = concreteCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t\t&& abstractCollectionClasses.contains(refName);\n\t\t\t\t\tboolean castToAbstractCollection = \n\t\t\t\t\t\t\tabstractCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName);\n\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t&& rank > 0.6)\n\t\t\t\t\t  rank = (rank + 0.6) /2;\n\t\t\t\t\telse if (castToAbstractCollection\n\t\t\t\t\t\t&& rank > 0.3)\n\t\t\t\t\t  rank = (rank + 0.3) /2;\n\t\t\t\t\t\t\n\t\t\t\t\tif (false)\n\t\t\t\t\t\tSystem.out.println(\"Rank:\\t\" + rank + \"\\t\" + refName\n\t\t\t\t\t\t\t\t+ \"\\t\" + castName);\n\t\t\t\t\tboolean completeInformation = (!castJavaClass.isInterface() && !refJavaClass\n\t\t\t\t\t\t\t.isInterface())\n\t\t\t\t\t\t\t|| refJavaClass.isFinal()\n\t\t\t\t\t\t\t|| castJavaClass.isFinal();\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"cast from \" + refName + \" to \"\n\t\t\t\t\t\t\t\t+ castName);\n\t\t\t\t\t\tSystem.out.println(\"  is downcast: \" + downcast);\n\t\t\t\t\t\tSystem.out.println(\"  complete information: \"\n\t\t\t\t\t\t\t\t+ completeInformation);\n\t\t\t\t\t\tSystem.out.println(\"  isParameter: \"\n\t\t\t\t\t\t\t\t+ vFrame.getTopValue());\n\t\t\t\t\t\tSystem.out.println(\"  score: \" + rank);\n\t\t\t\t\t}\n\t\t\t\t\tif (!downcast && completeInformation)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\t\tisCast ? \"BC_IMPOSSIBLE_CAST\"\n\t\t\t\t\t\t\t\t\t\t: \"BC_IMPOSSIBLE_INSTANCEOF\",\n\t\t\t\t\t\t\t\tisCast ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation).addClass(\n\t\t\t\t\t\t\t\t\t\trefName.replace('/', '.')).addClass(\n\t\t\t\t\t\t\t\t\t\tcastName.replace('/', '.')));\n\t\t\t\t\telse if (isCast && rank < 0.9) {\n\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\n\t\t\t\t\t\tif (rank > 0.75)\n\t\t\t\t\t\t\tpriority += 2;\n\t\t\t\t\t\telse if (rank > 0.5)\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\telse if (rank > 0.25)\n\t\t\t\t\t\t\tpriority += 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpriority--;\n\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority a: \" + priority);\n\t\t\t\t\t\tif (methodGen.getClassName().startsWith(refName)\n\t\t\t\t\t\t\t\t|| methodGen.getClassName().startsWith(castName))\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority b: \" + priority);\n\t\t\t\t\t\tif (castJavaClass.isInterface() && !castToAbstractCollection)\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority c: \" + priority);\n\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName))\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority d: \" + priority);\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY \n\t\t\t\t\t\t\t\t&& !castToAbstractCollection\n\t\t\t\t\t\t\t\t&& !castToConcreteCollection\n\t\t\t\t\t\t\t\t&& (refJavaClass.isInterface() || refJavaClass\n\t\t\t\t\t\t\t\t\t\t.isAbstract()))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority e: \" + priority);\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" ref name: \" + refName);\n\t\t\t\t\t\tif (methodGen.getName().equals(\"compareTo\"))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\telse if (methodGen.isPublic() && isParameter)\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority h: \" + priority);\n\t\t\t\t\t\tif (priority < HIGH_PRIORITY)\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY) {\n\t\t\t\t\t\t\tString bug = \"BC_UNCONFIRMED_CAST\";\n\t\t\t\t\t\t\tif (castToConcreteCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_CONCRETE_COLLECTION\";\n\t\t\t\t\t\t\telse if (castToAbstractCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_ABSTRACT_COLLECTION\";\n\n\t\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, bug,\n\t\t\t\t\t\t\t\t\tpriority).addClassAndMethod(methodGen,\n\t\t\t\t\t\t\t\t\tsourceFile).addSourceLine(\n\t\t\t\t\t\t\t\t\tsourceLineAnnotation).addClass(\n\t\t\t\t\t\t\t\t\trefName.replace('/', '.')).addClass(\n\t\t\t\t\t\t\t\t\tcastName.replace('/', '.')));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t}\n\t\t}\n\t}","id":76554,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tif (isSynthetic(method) || !prescreen(classContext, method))\n\t\t\treturn;\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\t\n\t\t\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tIsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n\t\tSet<ValueNumber> paramValueNumberSet = null;\n\t\t\n\t\tValueNumberDataflow vnaDataflow = null;\n\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tString methodName = methodGen.getClassName() + \".\"\n\t\t\t\t+ methodGen.getName();\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Checking \" + methodName);\n\t\t}\n\n\t\tSet<SourceLineAnnotation> haveInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveCast = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleCast = new HashSet<SourceLineAnnotation>();\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\tif (ins instanceof CHECKCAST) {\n\t\t\t\tif (!haveCast.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleCast.add(sourceLineAnnotation);\n\t\t\t} else {\n\t\t\t\tif (!haveInstanceOf.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleInstanceOf.add(sourceLineAnnotation);\n\t\t\t}\n\t\t}\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tint pc = handle.getPosition();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\t\t\tif (handle.getNext() == null) continue;\n\t\t\tInstruction nextIns = handle.getNext().getInstruction();\n\n\t\t\tboolean isCast = ins instanceof CHECKCAST;\n\t\t\tString kind = isCast ? \"checkedCast\" : \"instanceof\";\n\t\t\tint occurrences = cfg.getLocationsContainingInstructionWithOffset(\n\t\t\t\t\tpc).size();\n\t\t\tboolean split = occurrences > 1;\n\t\t\tIsNullValueFrame nullFrame = isNullDataflow.getFactAtLocation(location);\n\t\t\tIsNullValue operandNullness = nullFrame.getTopValue();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out\n\t\t\t\t\t\t.println(kind + \" at pc: \" + pc + \" in \" + methodName);\n\t\t\t\tSystem.out.println(\" occurrences: \" + occurrences);\n\t\t\t\tSystem.out.println(\"XXX: \" + operandNullness);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (split && !isCast) {\n\t\t\t\t// don't report this case; it might be infeasible due to inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tType operandType = frame.getTopValue();\n\t\t\tif (operandType.equals(TopType.instance())) {\n\t\t\t\t// unreachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tType castType = ((TypedInstruction) ins).getType(cpg);\n\n\t\t\tif (!(castType instanceof ReferenceType)) {\n\t\t\t\t// This shouldn't happen either\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castSig = castType.getSignature();\n\t\t\t\n\t\t\tif (operandType.equals(NullType.instance()) || operandNullness.isDefinitelyNull()) {\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\t\tString castName = castSig.substring(1, castSig.length() - 1)\n\t\t\t\t.replace('/', '.');\n\t\t\t\tif (!isCast) accumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_NULL_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addClass(castName), sourceLineAnnotation);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\tif (!(operandType instanceof ReferenceType)) {\n\t\t\t\t// Shouldn't happen - illegal bytecode\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tReferenceType refType = (ReferenceType) operandType;\n\n\t\t\n\t\t\tif (refType.equals(castType)) {\n\t\t\t\t// System.out.println(\"self-cast to \" + castType.getSignature());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tString refSig = refType.getSignature();\n\t\t\tString castSig2 = castSig;\n\t\t\tString refSig2 = refSig;\n\t\t\twhile (castSig2.charAt(0) == '[' && refSig2.charAt(0) == '[') {\n\t\t\t\tcastSig2 = castSig2.substring(1);\n\t\t\t\trefSig2 = refSig2.substring(1);\n\t\t\t}\n\n\t\t\tif (refSig2.equals(\"Ljava/lang/Object;\") && !(nextIns instanceof InvokeInstruction)) {\n\t\t\t\t// System.out.println(\"cast of object value to \" + castType.getSignature());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (refSig2.charAt(0) != 'L' || castSig2.charAt(0) != 'L') {\n\t\t\t\t// cast involving primative arrays\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\n\t\t\tif (isCast && haveMultipleCast.contains(sourceLineAnnotation)\n\t\t\t\t\t|| !isCast\n\t\t\t\t\t&& haveMultipleInstanceOf.contains(sourceLineAnnotation)) {\n\t\t\t\t// skip; might be due to JSR inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castName = castSig2.substring(1, castSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\t\t\tString refName = refSig2.substring(1, refSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\n\t\t\tif (vnaDataflow == null)\n\t\t\t\tvnaDataflow = classContext\n\t\t\t\t.getValueNumberDataflow(method);\n\t\t\tValueNumberFrame vFrame = vnaDataflow.getFactAtLocation(location);\n\t\t\tif (paramValueNumberSet == null) \n\t\t\t\tparamValueNumberSet = getParameterValueNumbers(classContext, method, cfg);\n\t\t\tboolean isParameter = paramValueNumberSet.contains(vFrame\n\t\t\t\t\t.getTopValue());\n\t\t\ttry {\n\t\t\t\tJavaClass castJavaClass = Repository.lookupClass(castName);\n\t\t\t\tJavaClass refJavaClass = Repository.lookupClass(refName);\n\t\t\t\tboolean upcast = Repository.instanceOf(refJavaClass,\n\t\t\t\t\t\tcastJavaClass);\n\t\t\t\tif (upcast) {\n\t\t\t\t\tif (!isCast)\n\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\t\t\"BC_VACUOUS_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addClass(refName.replace('/', '.'))\n\t\t\t\t\t\t\t\t.addClass(castName.replace('/', '.'))\n\t\t\t\t\t\t\t\t,sourceLineAnnotation);\n\t\t\t\t} else {\n\t\t\t\t\tboolean downcast = Repository.instanceOf(castJavaClass,\n\t\t\t\t\t\t\trefJavaClass);\n\t\t\t\t\tif (false && downcast && refName.equals(\"java.lang.Object\") && nextIns instanceof InvokeInstruction) {\n\t\t\t\t\t\tInvokeInstruction nextInvokeIns =  (InvokeInstruction) nextIns;\n\t\t\t\t\t\tType []  argTypes = nextInvokeIns.getArgumentTypes(cpg);\n\t\t\t\t\t\tString mName =  nextInvokeIns.getMethodName(cpg);\n\t\t\t\t\t\tif (argTypes.length > 0 && !mName.equals(\"add\")) {\n\t\t\t\t\t\t\tType lastArg = argTypes[argTypes.length - 1];\n\t\t\t\t\t\t\tif (lastArg instanceof ObjectType) {\n\t\t\t\t\t\t\t\tString name = ((ObjectType)lastArg).getClassName();\n\t\t\t\t\t\t\t\tif (refName.equals(name))\n\t\t\t\t\t\t\t\tSystem.out.println(\"Cast from \" + refName + \" to \" + castName + \" for argument of type \" + name\n\t+ \" of \" + mName\n\t\t\t\t\t\t\t\t\t\t+ \" in \" + sourceFile + \" : \" + methodName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (refName.equals(\"java.lang.Object\")) continue;\n\t\t\t\t\tdouble rank = Analyze.deepInstanceOf(refJavaClass,\n\t\t\t\t\t\t\tcastJavaClass);\n\t\t\t\t\tboolean castToConcreteCollection = concreteCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t\t&& abstractCollectionClasses.contains(refName);\n\t\t\t\t\tboolean castToAbstractCollection = \n\t\t\t\t\t\t\tabstractCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName);\n\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t&& rank > 0.6)\n\t\t\t\t\t  rank = (rank + 0.6) /2;\n\t\t\t\t\telse if (castToAbstractCollection\n\t\t\t\t\t\t&& rank > 0.3)\n\t\t\t\t\t  rank = (rank + 0.3) /2;\n\t\t\t\t\t\t\n\t\t\t\t\tif (false)\n\t\t\t\t\t\tSystem.out.println(\"Rank:\\t\" + rank + \"\\t\" + refName\n\t\t\t\t\t\t\t\t+ \"\\t\" + castName);\n\t\t\t\t\tboolean completeInformation = (!castJavaClass.isInterface() && !refJavaClass\n\t\t\t\t\t\t\t.isInterface())\n\t\t\t\t\t\t\t|| refJavaClass.isFinal()\n\t\t\t\t\t\t\t|| castJavaClass.isFinal();\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"cast from \" + refName + \" to \"\n\t\t\t\t\t\t\t\t+ castName);\n\t\t\t\t\t\tSystem.out.println(\"  is downcast: \" + downcast);\n\t\t\t\t\t\tSystem.out.println(\"  complete information: \"\n\t\t\t\t\t\t\t\t+ completeInformation);\n\t\t\t\t\t\tSystem.out.println(\"  isParameter: \"\n\t\t\t\t\t\t\t\t+ vFrame.getTopValue());\n\t\t\t\t\t\tSystem.out.println(\"  score: \" + rank);\n\t\t\t\t\t}\n\t\t\t\t\tif (!downcast && completeInformation)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\t\tisCast ? \"BC_IMPOSSIBLE_CAST\"\n\t\t\t\t\t\t\t\t\t\t: \"BC_IMPOSSIBLE_INSTANCEOF\",\n\t\t\t\t\t\t\t\tisCast ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addClass(refName.replace('/', '.'))\n\t\t\t\t\t\t\t\t.addClass(castName.replace('/', '.'))\n\t\t\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\t\telse if (isCast && rank < 0.9) {\n\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\n\t\t\t\t\t\tif (rank > 0.75)\n\t\t\t\t\t\t\tpriority += 2;\n\t\t\t\t\t\telse if (rank > 0.5)\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\telse if (rank > 0.25)\n\t\t\t\t\t\t\tpriority += 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpriority--;\n\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority a: \" + priority);\n\t\t\t\t\t\tif (methodGen.getClassName().startsWith(refName)\n\t\t\t\t\t\t\t\t|| methodGen.getClassName().startsWith(castName))\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority b: \" + priority);\n\t\t\t\t\t\tif (castJavaClass.isInterface() && !castToAbstractCollection)\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority c: \" + priority);\n\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName))\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority d: \" + priority);\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY \n\t\t\t\t\t\t\t\t&& !castToAbstractCollection\n\t\t\t\t\t\t\t\t&& !castToConcreteCollection\n\t\t\t\t\t\t\t\t&& (refJavaClass.isInterface() || refJavaClass\n\t\t\t\t\t\t\t\t\t\t.isAbstract()))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority e: \" + priority);\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" ref name: \" + refName);\n\t\t\t\t\t\tif (methodGen.getName().equals(\"compareTo\"))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\telse if (methodGen.isPublic() && isParameter)\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority h: \" + priority);\n\t\t\t\t\t\tif (priority < HIGH_PRIORITY)\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY) {\n\t\t\t\t\t\t\tString bug = \"BC_UNCONFIRMED_CAST\";\n\t\t\t\t\t\t\tif (castToConcreteCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_CONCRETE_COLLECTION\";\n\t\t\t\t\t\t\telse if (castToAbstractCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_ABSTRACT_COLLECTION\";\n\n\t\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this, bug, priority)\n\t\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\t.addClass(refName.replace('/', '.'))\n\t\t\t\t\t\t\t\t\t.addClass(castName.replace('/', '.')),\n\t\t\t\t\t\t\t\t\tsourceLineAnnotation\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t}\n\t\t}\n\t\taccumulator.reportAccumulatedBugs();\n\t}","commit_id":"54a366ffa8a819ffa73ab6e6e5135a1186f2a078","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\t\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"    Analyzing method \" + method.toString());\n\t\t}\n\t\t\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\t\n\t\tDataflow<BitSet, LiveLocalStoreAnalysis> llsaDataflow =\n\t\t\tclassContext.getLiveLocalStoreDataflow(method);\n\t\t\n\t\tint numLocals = method.getCode().getMaxLocals();\n\t\tint [] localStoreCount = new int[numLocals];\n\t\tint [] localLoadCount = new int[numLocals];\n\t\tint [] localIncrementCount = new int[numLocals];\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tBitSet liveStoreSetAtEntry = llsaDataflow.getAnalysis().getResultFact(cfg.getEntry());\n\t\tBitSet complainedAbout = new BitSet();\n\t\t\n\t\t// Get number of locals that are parameters.\n\t\tint localsThatAreParameters = PreorderVisitor.getNumberArguments(method.getSignature());\n\t\tif (!method.isStatic()) localsThatAreParameters++;\n\t\t\n\t\t// Scan method to determine number of loads, stores, and increments\n\t\t// of local variables.\n\t\tcountLocalStoresLoadsAndIncrements(\n\t\t\t\tlocalStoreCount, localLoadCount, localIncrementCount, cfg);\n\t\t\n\t\t// Scan method for\n\t\t// - dead stores\n\t\t// - stores to parameters that are dead upon entry to the method\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tWarningPropertySet propertySet = new WarningPropertySet();\n\t\t\t// Skip any instruction which is not a store\n\t\t\tif (!isStore(location))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// Heuristic: exception handler blocks often contain\n\t\t\t// dead stores generated by the compiler.\n\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.EXCEPTION_HANDLER);\n\t\t\t\n\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\t\t\tint local = ins.getIndex();\n\t\t\tint position = location.getHandle().getPosition()+1;\n\t\t\t// Heuristic: name of local variable.\n\t\t\tLocalVariableTable localVariableTable = method.getLocalVariableTable();\n\t\t\tString localName = \"?\";\n\t\t\tif (localVariableTable != null) {\n\n\t\t\t\tLocalVariable lv1 = localVariableTable.getLocalVariable(local, position);\n\t\t\t\t// System.out.println(\"Local variable \" + local + \" at \" +  position + \" = \" + lv1);\n\t\t\t\tif (lv1 != null) {\n\t\t\t\t\tlocalName = lv1.getName();\n\t\t\t\t\tif (EXCLUDED_LOCALS.contains(localName)) continue;\n\t\t\t\t\tpropertySet.setProperty(DeadLocalStoreProperty.LOCAL_NAME, localName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Is this a store to a parameter which was dead on entry to the method?\n\t\t\tboolean parameterThatIsDeadAtEntry = local < localsThatAreParameters\n\t\t\t\t&& !llsaDataflow.getAnalysis().isStoreAlive(liveStoreSetAtEntry, local);\n\t\t\tif (parameterThatIsDeadAtEntry && !complainedAbout.get(local)) {\n\t\t\t\t\n\t\t\t\tLocalVariableAnnotation lvAnnotation =\n\t\t\t\t\tnew LocalVariableAnnotation(localName, local, position);\n\t\t\t\tlvAnnotation.setDescription(\n\t\t\t\t\t\tlocalName.equals(\"?\") ? \"LOCAL_VARIABLE_UNKNOWN\" : \"LOCAL_VARIABLE_NAMED\");\n\t\t\t\t\n\t\t\t\t// TODO: add warning properties?\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, \"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.add(lvAnnotation)\n\t\t\t\t\t.addSourceLine(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t\tcomplainedAbout.set(local);\n\t\t\t}\n\t\t\t\n\t\t\tInstructionHandle prevInsHandle = location.getHandle().getPrev();\n\t\t\tif (prevInsHandle != null) {\n\t\t\t\tInstruction prevIns = prevInsHandle.getInstruction();\n\t\t\t\tif (prevIns instanceof LDC || prevIns instanceof ConstantPushInstruction || prevIns instanceof ACONST_NULL) \n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// Get live stores at this instruction.\n\t\t\t// Note that the analysis also computes which stores were\n\t\t\t// killed by a subsequent unconditional store.\n\t\t\tBitSet liveStoreSet = llsaDataflow.getAnalysis().getFactAtLocation(location);\n\t\t\t\n\t\t\t// Is store alive?\n\t\t\tif (llsaDataflow.getAnalysis().isStoreAlive(liveStoreSet, local))\n\t\t\t\tcontinue;\n\t\t\t// Store is dead\n\t\t\t\n\t\t\t// Ignore assignments that were killed by a subsequent assignment.\n\t\t\tboolean killedBySubsequentStore = llsaDataflow.getAnalysis().killedByStore(liveStoreSet, local);\n\t\t\tif (killedBySubsequentStore)\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.KILLED_BY_SUBSEQUENT_STORE);\n\t\t\t\n\t\t\t// Ignore dead assignments of null and 0.\n\t\t\t// These often indicate defensive programming.\n\t\t\tInstructionHandle prev = location.getBasicBlock().getPredecessorOf(location.getHandle());\n\t\t\tint prevOpCode = -1;\n\n\t\t\tif (prev != null\n\t\t\t\t\t&& defensiveConstantValueOpcodes.get(prev.getInstruction().getOpcode())) {\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEFENSIVE_CONSTANT_OPCODE);\n\t\t\t\tprevOpCode = prev.getInstruction().getOpcode();\n\t\t\t\t}\n\n                        InstructionHandle prev2 = prev == null ? null : prev.getPrev();\n\n\t\t\tif (prev2 != null\n                                && prev2.getInstruction() instanceof ALOAD\n                                && prev.getInstruction() instanceof GETFIELD)\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.CACHING_VALUE);\n\n\n\t\t\t\n\t\t\tif (ins instanceof IINC) {\n\t\t\t\t// special handling of IINC\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_INCREMENT);\n\t\t\t\tif (localIncrementCount[local] == 1) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_DEAD_INCREMENT);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if (ins instanceof ASTORE && prev != null) { \n\t\t\t\t// Look for objects created but never used\n\t\t\t\t\n\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\tif ((prevIns instanceof INVOKESPECIAL &&\n\t\t\t\t\t\t((INVOKESPECIAL)prevIns).getMethodName(methodGen.getConstantPool()).equals(\"<init>\"))\n\t\t\t\t\t\t|| prevIns instanceof ANEWARRAY\n\t\t\t\t\t\t|| prevIns instanceof NEWARRAY\n\t\t\t\t\t\t|| prevIns instanceof MULTIANEWARRAY) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_OBJECT_STORE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if (!killedBySubsequentStore\n\t\t\t\t    && localStoreCount[local] == 2 && localLoadCount[local] > 0) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.TWO_STORES_MULTIPLE_LOADS);\n\t\t\t\t\n\t\t\t} else if (!parameterThatIsDeadAtEntry && localStoreCount[local] == 1) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_STORE);\n\t\t\t\t\n\t\t\t} else if (!parameterThatIsDeadAtEntry && localLoadCount[local] == 0) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.NO_LOADS);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif (parameterThatIsDeadAtEntry) {\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.PARAM_DEAD_ON_ENTRY);\n\t\t\t}\n\n\t\t\tif (localStoreCount[local] > 3) \n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.MANY_STORES);\n\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tif (priority <= Detector.EXP_PRIORITY) {\t\n\t\t\t\t\n\t\t\t\tLocalVariableAnnotation lvAnnotation =\n\t\t\t\t\tnew LocalVariableAnnotation(localName, local, position);\n\t\t\t\tlvAnnotation.setDescription(\n\t\t\t\t\t\tlocalName.equals(\"?\") ? \"LOCAL_VARIABLE_UNKNOWN\" : \"LOCAL_VARIABLE_NAMED\");\n\t\t\t\t\n\t\t\t\t// Report the warning\t\t\t\t\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, \"DLS_DEAD_LOCAL_STORE\", priority)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.add(lvAnnotation)\n\t\t\t\t\t.addSourceLine(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle());\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\n\t\t\t\t\tjavaClass.getSourceFileName() + \" : \" +\n\t\t\t\t\t\tmethodGen.getName());\n\t\t\t\tSystem.out.println(\"priority: \" + priority);\n\t\t\t\tSystem.out.println(\"Reporting \" + bugInstance);\n\t\t\t\tSystem.out.println(propertySet);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If in relaxed reporting mode, encode heuristic information.\n\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\t// Add general-purpose warning properties\n\t\t\t\t\tWarningPropertyUtil.addPropertiesForLocation(\n\t\t\t\t\t\t\tpropertySet,\n\t\t\t\t\t\t\tclassContext,\n\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\tlocation);\n\t\t\t\t\t\n\t\t\t\t\t// Turn all warning properties into BugProperties\n\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t}\n\t\t}\n\t}","id":76555,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\t\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"    Analyzing method \" + method.toString());\n\t\t}\n\t\t\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\t\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\tDataflow<BitSet, LiveLocalStoreAnalysis> llsaDataflow =\n\t\t\tclassContext.getLiveLocalStoreDataflow(method);\n\t\t\n\t\tint numLocals = method.getCode().getMaxLocals();\n\t\tint [] localStoreCount = new int[numLocals];\n\t\tint [] localLoadCount = new int[numLocals];\n\t\tint [] localIncrementCount = new int[numLocals];\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tBitSet liveStoreSetAtEntry = llsaDataflow.getAnalysis().getResultFact(cfg.getEntry());\n\t\tBitSet complainedAbout = new BitSet();\n\t\t\n\t\t// Get number of locals that are parameters.\n\t\tint localsThatAreParameters = PreorderVisitor.getNumberArguments(method.getSignature());\n\t\tif (!method.isStatic()) localsThatAreParameters++;\n\t\t\n\t\t// Scan method to determine number of loads, stores, and increments\n\t\t// of local variables.\n\t\tcountLocalStoresLoadsAndIncrements(\n\t\t\t\tlocalStoreCount, localLoadCount, localIncrementCount, cfg);\n\t\t\n\t\t// Scan method for\n\t\t// - dead stores\n\t\t// - stores to parameters that are dead upon entry to the method\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tWarningPropertySet propertySet = new WarningPropertySet();\n\t\t\t// Skip any instruction which is not a store\n\t\t\tif (!isStore(location))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// Heuristic: exception handler blocks often contain\n\t\t\t// dead stores generated by the compiler.\n\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.EXCEPTION_HANDLER);\n\t\t\t\n\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\t\t\tint local = ins.getIndex();\n\t\t\tint position = location.getHandle().getPosition()+1;\n\t\t\t// Heuristic: name of local variable.\n\t\t\tLocalVariableTable localVariableTable = method.getLocalVariableTable();\n\t\t\tString localName = \"?\";\n\t\t\tif (localVariableTable != null) {\n\n\t\t\t\tLocalVariable lv1 = localVariableTable.getLocalVariable(local, position);\n\t\t\t\t// System.out.println(\"Local variable \" + local + \" at \" +  position + \" = \" + lv1);\n\t\t\t\tif (lv1 != null) {\n\t\t\t\t\tlocalName = lv1.getName();\n\t\t\t\t\tif (EXCLUDED_LOCALS.contains(localName)) continue;\n\t\t\t\t\tpropertySet.setProperty(DeadLocalStoreProperty.LOCAL_NAME, localName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Is this a store to a parameter which was dead on entry to the method?\n\t\t\tboolean parameterThatIsDeadAtEntry = local < localsThatAreParameters\n\t\t\t\t&& !llsaDataflow.getAnalysis().isStoreAlive(liveStoreSetAtEntry, local);\n\t\t\tif (parameterThatIsDeadAtEntry && !complainedAbout.get(local)) {\n\t\t\t\t\n\t\t\t\tLocalVariableAnnotation lvAnnotation =\n\t\t\t\t\tnew LocalVariableAnnotation(localName, local, position);\n\t\t\t\tlvAnnotation.setDescription(\n\t\t\t\t\t\tlocalName.equals(\"?\") ? \"LOCAL_VARIABLE_UNKNOWN\" : \"LOCAL_VARIABLE_NAMED\");\n\t\t\t\t\n\t\t\t\t// TODO: add warning properties?\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, \"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.add(lvAnnotation)\n\t\t\t\t\t.addSourceLine(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t\tcomplainedAbout.set(local);\n\t\t\t}\n\t\t\t\n\t\t\tInstructionHandle prevInsHandle = location.getHandle().getPrev();\n\t\t\tif (prevInsHandle != null) {\n\t\t\t\tInstruction prevIns = prevInsHandle.getInstruction();\n\t\t\t\tif (prevIns instanceof LDC || prevIns instanceof ConstantPushInstruction || prevIns instanceof ACONST_NULL) \n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// Get live stores at this instruction.\n\t\t\t// Note that the analysis also computes which stores were\n\t\t\t// killed by a subsequent unconditional store.\n\t\t\tBitSet liveStoreSet = llsaDataflow.getAnalysis().getFactAtLocation(location);\n\t\t\t\n\t\t\t// Is store alive?\n\t\t\tif (llsaDataflow.getAnalysis().isStoreAlive(liveStoreSet, local))\n\t\t\t\tcontinue;\n\t\t\t// Store is dead\n\t\t\t\n\t\t\t// Ignore assignments that were killed by a subsequent assignment.\n\t\t\tboolean killedBySubsequentStore = llsaDataflow.getAnalysis().killedByStore(liveStoreSet, local);\n\t\t\tif (killedBySubsequentStore)\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.KILLED_BY_SUBSEQUENT_STORE);\n\t\t\t\n\t\t\t// Ignore dead assignments of null and 0.\n\t\t\t// These often indicate defensive programming.\n\t\t\tInstructionHandle prev = location.getBasicBlock().getPredecessorOf(location.getHandle());\n\t\t\tint prevOpCode = -1;\n\n\t\t\tif (prev != null\n\t\t\t\t\t&& defensiveConstantValueOpcodes.get(prev.getInstruction().getOpcode())) {\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEFENSIVE_CONSTANT_OPCODE);\n\t\t\t\tprevOpCode = prev.getInstruction().getOpcode();\n\t\t\t\t}\n\n                        InstructionHandle prev2 = prev == null ? null : prev.getPrev();\n\n\t\t\tif (prev2 != null\n                                && prev2.getInstruction() instanceof ALOAD\n                                && prev.getInstruction() instanceof GETFIELD)\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.CACHING_VALUE);\n\n\n\t\t\t\n\t\t\tif (ins instanceof IINC) {\n\t\t\t\t// special handling of IINC\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_INCREMENT);\n\t\t\t\tif (localIncrementCount[local] == 1) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_DEAD_INCREMENT);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if (ins instanceof ASTORE && prev != null) { \n\t\t\t\t// Look for objects created but never used\n\t\t\t\t\n\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\tif ((prevIns instanceof INVOKESPECIAL &&\n\t\t\t\t\t\t((INVOKESPECIAL)prevIns).getMethodName(methodGen.getConstantPool()).equals(\"<init>\"))\n\t\t\t\t\t\t|| prevIns instanceof ANEWARRAY\n\t\t\t\t\t\t|| prevIns instanceof NEWARRAY\n\t\t\t\t\t\t|| prevIns instanceof MULTIANEWARRAY) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_OBJECT_STORE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if (!killedBySubsequentStore\n\t\t\t\t    && localStoreCount[local] == 2 && localLoadCount[local] > 0) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.TWO_STORES_MULTIPLE_LOADS);\n\t\t\t\t\n\t\t\t} else if (!parameterThatIsDeadAtEntry && localStoreCount[local] == 1) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_STORE);\n\t\t\t\t\n\t\t\t} else if (!parameterThatIsDeadAtEntry && localLoadCount[local] == 0) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.NO_LOADS);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif (parameterThatIsDeadAtEntry) {\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.PARAM_DEAD_ON_ENTRY);\n\t\t\t}\n\n\t\t\tif (localStoreCount[local] > 3) \n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.MANY_STORES);\n\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tif (priority <= Detector.EXP_PRIORITY) {\t\n\t\t\t\t\n\t\t\t\tLocalVariableAnnotation lvAnnotation =\n\t\t\t\t\tnew LocalVariableAnnotation(localName, local, position);\n\t\t\t\tlvAnnotation.setDescription(\n\t\t\t\t\t\tlocalName.equals(\"?\") ? \"LOCAL_VARIABLE_UNKNOWN\" : \"LOCAL_VARIABLE_NAMED\");\n\t\t\t\t\n\t\t\t\t// Report the warning\t\t\t\t\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, \"DLS_DEAD_LOCAL_STORE\", priority)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.add(lvAnnotation);\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\t// If in relaxed reporting mode, encode heuristic information.\n\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\t// Add general-purpose warning properties\n\t\t\t\t\tWarningPropertyUtil.addPropertiesForLocation(\n\t\t\t\t\t\t\tpropertySet,\n\t\t\t\t\t\t\tclassContext,\n\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\tlocation);\n\t\t\t\t\t\n\t\t\t\t\t// Turn all warning properties into BugProperties\n\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t}\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation =\n\t\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(classContext, methodGen, javaClass.getSourceFileName(), \n\t\t\t\t\t\t\tlocation.getHandle());\n\t\t\t\t\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\n\t\t\t\t\tjavaClass.getSourceFileName() + \" : \" +\n\t\t\t\t\t\tmethodGen.getName());\n\t\t\t\tSystem.out.println(\"priority: \" + priority);\n\t\t\t\tSystem.out.println(\"Reporting \" + bugInstance);\n\t\t\t\tSystem.out.println(propertySet);\n\t\t\t\t}\n\t\t\t\taccumulator.accumulateBug(bugInstance, sourceLineAnnotation);\n\t\t\t}\n\t\t}\n\t\taccumulator.reportAccumulatedBugs();\n\t}","commit_id":"54a366ffa8a819ffa73ab6e6e5135a1186f2a078","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void visit(Code code) {\n\t\tString s = getMethodSig();\n\t\tSignatureParser sp = new SignatureParser(s);\n\t\t//Check to see if the method has Boolean return type\n\t\tboolean interesting = \"Ljava/lang/Boolean;\".equals(sp.getReturnTypeSignature());\n\t\tif (interesting)  {\n\t\t\tsuper.visit(code); // make callbacks to sawOpcode for all opcodes\n\t\t}\n\t}","id":76556,"modified_method":"@Override\n\tpublic void visit(Code code) {\n\t\tString s = getMethodSig();\n\t\tSignatureParser sp = new SignatureParser(s);\n\t\t//Check to see if the method has Boolean return type\n\t\tboolean interesting = \"Ljava/lang/Boolean;\".equals(sp.getReturnTypeSignature());\n\t\tif (interesting)  {\n\t\t\tsuper.visit(code); // make callbacks to sawOpcode for all opcodes\n\t\t\tbugAccumulator.reportAccumulatedBugs();\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public BooleanReturnNull(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t}","id":76557,"modified_method":"public BooleanReturnNull(BugReporter bugReporter) {\n\t\tthis.bugAccumulator = new BugAccumulator(bugReporter);\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\tif (seen == ARETURN && getPrevOpcode(1) == ACONST_NULL)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"NP_BOOLEAN_RETURN_NULL\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this)\n\t\t\t.addSourceLine(this));\n\n\n\t}","id":76558,"modified_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\tif (seen == ARETURN && getPrevOpcode(1) == ACONST_NULL)\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"NP_BOOLEAN_RETURN_NULL\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\n\n\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void visitJavaClass(JavaClass obj) {\n\t\thasThisDollarZero = false;\n\t\t// totally skip methods not defined in inner classes\n\t\tif (obj.getClassName().indexOf('$') >= 0) super.visitJavaClass(obj);\n\n\t}","id":76559,"modified_method":"@Override\n\t\t public void visitJavaClass(JavaClass obj) {\n\t\thasThisDollarZero = false;\n\t\t// totally skip methods not defined in inner classes\n\t\tif (obj.getClassName().indexOf('$') >= 0) {\n\t\t\tsuper.visitJavaClass(obj);\n\t\t\tbugAccumulator.reportAccumulatedBugs();\n\t\t}\n\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public ConfusionBetweenInheritedAndOuterMethod(BugReporter bugReporter) {\n\t\tthis.bugReporter =  bugReporter;\n\t}","id":76560,"modified_method":"public ConfusionBetweenInheritedAndOuterMethod(BugReporter bugReporter) {\n\t\tthis.bugReporter =  bugReporter;\n\t\tthis.bugAccumulator = new BugAccumulator(bugReporter);\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\t if (seen != INVOKEVIRTUAL) return;\n\t\t if (!getClassName().equals(getClassConstantOperand())) return;\n\t\t XMethod invokedMethod = XFactory.createXMethod(getDottedClassConstantOperand(), getNameConstantOperand(), getSigConstantOperand(), false);\n\t\t if (invokedMethod.isResolved() && invokedMethod.getClassName().equals(getDottedClassConstantOperand())) {\n\t\t\t // method is not inherited\n\t\t\t return;\n\t\t }\n\t\t // method is inherited\n\t\t String possibleTargetClass = getDottedClassName();\n\t\t String superClassName = getDottedSuperclassName();\n\t\t while(true) {\n\t\t\t int i = possibleTargetClass.lastIndexOf('$');\n\t\t\tif (i <= 0) break;\n\t\t\tpossibleTargetClass = possibleTargetClass.substring(0,i);\n\t\t\tif (possibleTargetClass.equals(superClassName)) break;\n\t\t\t XMethod alternativeMethod = XFactory.createXMethod(possibleTargetClass, getNameConstantOperand(), getSigConstantOperand(), false);\n\t\t\t if (alternativeMethod.isResolved() && alternativeMethod.getClassName().equals(possibleTargetClass)) \t{\n\t\t\t\t String targetPackage = invokedMethod.getPackageName();\n\t\t\t\t String alternativePackage = alternativeMethod.getPackageName();\n\t\t\t\t int priority = HIGH_PRIORITY;\n\t\t\t\t if (targetPackage.equals(alternativePackage)) priority++;\n\t\t\t\t if (targetPackage.startsWith(\"javax.swing\") || targetPackage.startsWith(\"java.awt\"))\n\t\t\t\t\t priority+=2;\n\t\t\t\t if (invokedMethod.getName().equals(getMethodName())) priority++;\n\n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD\", priority)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t  .addMethod(invokedMethod).describe(\"METHOD_INHERITED\")\n\t\t\t\t\t\t.addMethod(alternativeMethod).describe(\"METHOD_ALTERNATIVE_TARGET\")\n\t\t\t\t\t\t.addSourceLine(this, getPC()));\n\t\t\t\t break;\n\t\t\t }\n\t\t }\n\n\n\t\t\n\t}","id":76561,"modified_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\t if (seen != INVOKEVIRTUAL) return;\n\t\t if (!getClassName().equals(getClassConstantOperand())) return;\n\t\t XMethod invokedMethod = XFactory.createXMethod(getDottedClassConstantOperand(), getNameConstantOperand(), getSigConstantOperand(), false);\n\t\t if (invokedMethod.isResolved() && invokedMethod.getClassName().equals(getDottedClassConstantOperand())) {\n\t\t\t // method is not inherited\n\t\t\t return;\n\t\t }\n\t\t // method is inherited\n\t\t String possibleTargetClass = getDottedClassName();\n\t\t String superClassName = getDottedSuperclassName();\n\t\t while(true) {\n\t\t\t int i = possibleTargetClass.lastIndexOf('$');\n\t\t\tif (i <= 0) break;\n\t\t\tpossibleTargetClass = possibleTargetClass.substring(0,i);\n\t\t\tif (possibleTargetClass.equals(superClassName)) break;\n\t\t\t XMethod alternativeMethod = XFactory.createXMethod(possibleTargetClass, getNameConstantOperand(), getSigConstantOperand(), false);\n\t\t\t if (alternativeMethod.isResolved() && alternativeMethod.getClassName().equals(possibleTargetClass)) \t{\n\t\t\t\t String targetPackage = invokedMethod.getPackageName();\n\t\t\t\t String alternativePackage = alternativeMethod.getPackageName();\n\t\t\t\t int priority = HIGH_PRIORITY;\n\t\t\t\t if (targetPackage.equals(alternativePackage)) priority++;\n\t\t\t\t if (targetPackage.startsWith(\"javax.swing\") || targetPackage.startsWith(\"java.awt\"))\n\t\t\t\t\t priority+=2;\n\t\t\t\t if (invokedMethod.getName().equals(getMethodName())) priority++;\n\n\t\t\t\t bugAccumulator.accumulateBug(new BugInstance(this, \"IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD\", priority)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t  .addMethod(invokedMethod).describe(\"METHOD_INHERITED\")\n\t\t\t\t\t\t.addMethod(alternativeMethod).describe(\"METHOD_ALTERNATIVE_TARGET\"), this);\n\t\t\t\t break;\n\t\t\t }\n\t\t }\n\n\n\t\t\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tMethod[] methodList = classContext.getJavaClass().getMethods();\n\n\t\tfor (Method method : methodList) {\n\t\t\tif (method.getCode() == null)\n\t\t\t\tcontinue;\n\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"Detector \" + this.getClass().getName()\n\t\t\t\t\t\t+ \" caught exception\", e);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\t// bugReporter.logError(\"Detector \" + this.getClass().getName() + \" caught exception\", e);\n\t\t\t}\n\t\t}\n\t}","id":76562,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tMethod[] methodList = classContext.getJavaClass().getMethods();\n\n\t\tfor (Method method : methodList) {\n\t\t\tif (method.getCode() == null)\n\t\t\t\tcontinue;\n\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"Detector \" + this.getClass().getName()\n\t\t\t\t\t\t+ \" caught exception\", e);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\t// bugReporter.logError(\"Detector \" + this.getClass().getName() + \" caught exception\", e);\n\t\t\t}\n\t\t\tbugAccumulator.reportAccumulatedBugs();\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public FindNonSerializableStoreIntoSession(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t}","id":76563,"modified_method":"public FindNonSerializableStoreIntoSession(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t\tthis.bugAccumulator = new BugAccumulator(bugReporter);\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null)\n\t\t\treturn;\n\t\tBitSet bytecodeSet = classContext.getBytecodeSet(method);\n\t\tif (bytecodeSet == null) return;\n\t\t// We don't adequately model instanceof interfaces yet\n\t\tif (bytecodeSet.get(Constants.INSTANCEOF) || bytecodeSet.get(Constants.CHECKCAST))\n\t\t\treturn;\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\tif (DEBUG) {\n\t\t\tString methodName = methodGen.getClassName() + \".\"\n\t\t\t\t\t+ methodGen.getName();\n\t\t\tSystem.out.println(\"Checking \" + methodName);\n\t\t}\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (!(ins instanceof INVOKEINTERFACE))\n\t\t\t\tcontinue;\n\n\t\t\tINVOKEINTERFACE invoke = (INVOKEINTERFACE) ins;\n\t\t\tString mName = invoke.getMethodName(cpg);\n\t\t\tif (!mName.equals(\"setAttribute\"))\n\t\t\t\tcontinue;\n\t\t\tString cName = invoke.getClassName(cpg);\n\t\t\tif (!cName.equals(\"javax.servlet.http.HttpSession\"))\n\t\t\t\tcontinue;\n\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tType operandType = frame.getTopValue();\n\n\t\t\tif (operandType.equals(TopType.instance())) {\n\t\t\t\t// unreachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(operandType instanceof ReferenceType)) {\n\t\t\t\t// Shouldn't happen - illegal bytecode\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tReferenceType refType = (ReferenceType) operandType;\n\n\t\t\tif (refType.equals(NullType.instance())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString refSig = refType.getSignature();\n\n\t\t\ttry {\n\n\t\t\t\tdouble isSerializable = DeepSubtypeAnalysis.isDeepSerializable(refSig);\n\n\t\t\t\tif (isSerializable < 0.9) {\n\t\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen,\n\t\t\t\t\t\t\t\t\tsourceFile, handle);\n\n\t\t\t\t\tbugReporter\n\t\t\t\t\t\t\t.reportBug(new BugInstance(\n\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\"J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION\",\n\t\t\t\t\t\t\t\t\tisSerializable < 0.15 ? HIGH_PRIORITY\n\t\t\t\t\t\t\t\t\t\t\t: isSerializable > 0.5 ? LOW_PRIORITY\n\t\t\t\t\t\t\t\t\t\t\t\t\t: NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\t.addClass(DeepSubtypeAnalysis.getComponentClass(refSig))\n\t\t\t\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t}","id":76564,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null)\n\t\t\treturn;\n\t\tBitSet bytecodeSet = classContext.getBytecodeSet(method);\n\t\tif (bytecodeSet == null) return;\n\t\t// We don't adequately model instanceof interfaces yet\n\t\tif (bytecodeSet.get(Constants.INSTANCEOF) || bytecodeSet.get(Constants.CHECKCAST))\n\t\t\treturn;\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\tif (DEBUG) {\n\t\t\tString methodName = methodGen.getClassName() + \".\"\n\t\t\t\t\t+ methodGen.getName();\n\t\t\tSystem.out.println(\"Checking \" + methodName);\n\t\t}\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (!(ins instanceof INVOKEINTERFACE))\n\t\t\t\tcontinue;\n\n\t\t\tINVOKEINTERFACE invoke = (INVOKEINTERFACE) ins;\n\t\t\tString mName = invoke.getMethodName(cpg);\n\t\t\tif (!mName.equals(\"setAttribute\"))\n\t\t\t\tcontinue;\n\t\t\tString cName = invoke.getClassName(cpg);\n\t\t\tif (!cName.equals(\"javax.servlet.http.HttpSession\"))\n\t\t\t\tcontinue;\n\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tType operandType = frame.getTopValue();\n\n\t\t\tif (operandType.equals(TopType.instance())) {\n\t\t\t\t// unreachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(operandType instanceof ReferenceType)) {\n\t\t\t\t// Shouldn't happen - illegal bytecode\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tReferenceType refType = (ReferenceType) operandType;\n\n\t\t\tif (refType.equals(NullType.instance())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString refSig = refType.getSignature();\n\n\t\t\ttry {\n\n\t\t\t\tdouble isSerializable = DeepSubtypeAnalysis.isDeepSerializable(refSig);\n\n\t\t\t\tif (isSerializable < 0.9) {\n\t\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen,\n\t\t\t\t\t\t\t\t\tsourceFile, handle);\n\n\t\t\t\t\tbugAccumulator\n\t\t\t\t\t\t\t.accumulateBug(new BugInstance(\n\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\"J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION\",\n\t\t\t\t\t\t\t\t\tisSerializable < 0.15 ? HIGH_PRIORITY\n\t\t\t\t\t\t\t\t\t\t\t: isSerializable > 0.5 ? LOW_PRIORITY\n\t\t\t\t\t\t\t\t\t\t\t\t\t: NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\t.addClass(DeepSubtypeAnalysis.getComponentClass(refSig)), sourceLineAnnotation);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void foundGuaranteedNullDeref(\n\t\t\t@NonNull Set<Location> assignedNullLocationSet, \n\t\t\t@NonNull Set<Location> derefLocationSet, \n\t\t\tSortedSet<Location> doomedLocations,\n\t\t\tValueNumberDataflow vna, ValueNumber refValue,\n\t\t\t@CheckForNull BugAnnotation variableAnnotation, NullValueUnconditionalDeref deref,\n\t\t\tboolean npeIfStatementCovered) {\n\t\tif (refValue.hasFlag(ValueNumber.CONSTANT_CLASS_OBJECT))\n\t\t\treturn;\n\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Found guaranteed null deref in \"\n\t\t\t\t\t+ method.getName());\n\t\t\tfor (Location loc : doomedLocations)\n\t\t\t\tSystem.out.println(\"Doomed at \" + loc);\n\t\t}\n\n\t\tString bugType = \"NP_GUARANTEED_DEREF\";\n\t\tint priority = NORMAL_PRIORITY;\n\n\t\tif (deref.isMethodReturnValue())\n\t\t\tbugType = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\";\n\t\telse {\n\t\t\tif (deref.isAlwaysOnExceptionPath())\n\t\t\t\tbugType += \"_ON_EXCEPTION_PATH\";\n\t\t\telse priority = HIGH_PRIORITY;\n\t\t\tif (!npeIfStatementCovered)\n\t\t\t\tpriority++;\n\t\t}\n\n\t\t// Add Locations in the set of locations at least one of which\n\t\t// is guaranteed to be dereferenced\n\n\t\tSortedSet<Location> sourceLocations;\n\t\tif (doomedLocations.isEmpty() || doomedLocations.size() > 3\n\t\t\t\t&& doomedLocations.size() > assignedNullLocationSet.size())\n\t\t\tsourceLocations = new TreeSet<Location>(assignedNullLocationSet);\n\t\telse\n\t\t\tsourceLocations = doomedLocations;\n\n\t\tif (doomedLocations.isEmpty() || derefLocationSet.isEmpty())\n\t\t\treturn;\n\t\tboolean derefOutsideCatchBlock = false;\n\t\tfor (Location loc : derefLocationSet)\n\t\t\tif (!inCatchNullBlock(loc)) {\n\t\t\t\tderefOutsideCatchBlock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tboolean uniqueDereferenceLocations = false;\n\t\tLineNumberTable table = method.getLineNumberTable();\n\t\tif (table == null)\n\t\t\tuniqueDereferenceLocations = true;\n\t\telse {\n\t\t\tBitSet linesMentionedMultipleTimes = ClassContext.linesMentionedMultipleTimes(method);\n\t\t\tfor(Location loc : derefLocationSet) {\n\t\t\t  int lineNumber = table.getSourceLine(loc.getHandle().getPosition());\n\t\t\t  if (!linesMentionedMultipleTimes.get(lineNumber)) uniqueDereferenceLocations = true;\n\t\t\t}\n\t\t}\n\n\n\t\tif (!derefOutsideCatchBlock) {\n\t\t\tif (!uniqueDereferenceLocations || skipIfInsideCatchNull())\n\t\t\t\treturn;\n\t\t\tpriority++;\n\t\t}\n\t\tif (!uniqueDereferenceLocations)\n\t\t\tpriority++;\n\n\t\t// Create BugInstance\n\n\t\tBitSet knownNull = new BitSet();\n\n\t\tSortedSet<SourceLineAnnotation> knownNullLocations = new TreeSet<SourceLineAnnotation>();\n\t\tfor (Location loc : sourceLocations) {\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, method, loc);\n\t\t\tif (sourceLineAnnotation == null)\n\t\t\t\tcontinue;\n\t\t\tint startLine = sourceLineAnnotation.getStartLine();\n\t\t\tif (startLine == -1)\n\t\t\t\tknownNullLocations.add(sourceLineAnnotation);\n\t\t\telse if (!knownNull.get(startLine)) {\n\t\t\t\tknownNull.set(startLine);\n\t\t\t\tknownNullLocations.add(sourceLineAnnotation);\n\t\t\t}\n\t\t}\n\n\t\tFieldAnnotation storedField = null;\n\t\tMethodAnnotation invokedMethod = null;\n\t\tXMethod invokedXMethod = null;\n\t\tint parameterNumber = -1;\n\t\tif (derefLocationSet.size() == 1) {\n\t\t\tLocation loc = derefLocationSet.iterator().next();\n\n\t\t\tPointerUsageRequiringNonNullValue pu = null;\n\t\t\ttry {\n\t\t\t\tUsagesRequiringNonNullValues usages = classContext.getUsagesRequiringNonNullValues(method);\n\t\t\t\tpu = usages.get(loc, refValue, vnaDataflow);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t   AnalysisContext.logError(\"Error getting UsagesRequiringNonNullValues for \" + method, e);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tAnalysisContext.logError(\"Error getting UsagesRequiringNonNullValues for \" + method, e);\n\t\t\t}\n\n\n\t\t\tif (pu != null) {\n\n\n\t\t\tif (pu.getReturnFromNonNullMethod()) {\n\t\t\t\tbugType = \"NP_NONNULL_RETURN_VIOLATION\";\n\t\t\t\tString methodName = method.getName();\n\t\t\t\tString methodSig = method.getSignature();\n\t\t\t\tif (methodName.equals(\"clone\") && methodSig.equals(\"()Ljava/lang/Object;\")) {\n\t\t\t\t\tbugType = \"NP_CLONE_COULD_RETURN_NULL\";\n\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t} else if (methodName.equals(\"toString\") && methodSig.equals(\"()Ljava/lang/String;\")) {\n\t\t\t\t\tbugType = \"NP_TOSTRING_COULD_RETURN_NULL\";\n\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tXField nonNullField = pu.getNonNullField();\n\t\t\t\tif (nonNullField != null) {\n\t\t\t\t\tstoredField =  FieldAnnotation.fromXField( nonNullField );\n\t\t\t\t\tbugType = \"NP_STORE_INTO_NONNULL_FIELD\";\n\t\t\t\t} else {\n\t\t\t\t\tXMethodParameter nonNullParameter = pu.getNonNullParameter();\n\t\t\t\t\tif (nonNullParameter != null) {\n\t\t\t\t\t\tXMethodParameter mp = nonNullParameter ;\n\t\t\t\t\t\tinvokedXMethod = mp.getMethod();\n\t\t\t\t\t\tinvokedMethod =  MethodAnnotation.fromXMethod(mp.getMethod());\n\t\t\t\t\t\tparameterNumber = mp.getParameterNumber();\n\t\t\t\t\t\tbugType = \"NP_NULL_PARAM_DEREF\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t} else  if (!deref.isAlwaysOnExceptionPath())\n\t\t\t\tbugType = \"NP_NULL_ON_SOME_PATH\";\n\t\t\telse\n\t\t\t\tbugType = \"NP_NULL_ON_SOME_PATH_EXCEPTION\";\n\n\t\t\tif (deref.isMethodReturnValue())\n\t\t\t\tbugType = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\";\n\n\t\t}\n\n\n\t\tXMethod xMethod = XFactory.createXMethod(classContext.getJavaClass(), method);\n\t\tboolean uncallable = !AnalysisContext.currentXFactory().isCalledDirectlyOrIndirectly(xMethod) \n\t\t\t\t&& xMethod.isPrivate();\n\t\tif (invokedXMethod != null) for (Location derefLoc : derefLocationSet) \n\t\t\tif (safeCallToPrimateParseMethod(invokedXMethod, derefLoc)) return;\n\t\tboolean hasManyNullTests = true;\n\t\tfor (SourceLineAnnotation sourceLineAnnotation : knownNullLocations) {\n\t\t\tif (!hasManyPreceedingNullTests(sourceLineAnnotation.getStartBytecode()))\n\t\t\t\t\thasManyNullTests = false;\n\t\t}\n\t\tif (hasManyNullTests) {\n\t\t\tif (bugType.equals(\"NP_NULL_ON_SOME_PATH\"))\n\t\t\t\t\tbugType = \"NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE\";\n\t\t\telse priority++;\n\t\t}\n\t\t\t\n\t\tBugInstance bugInstance = new BugInstance(this, bugType, priority)\n\t\t\t\t.addClassAndMethod(classContext.getJavaClass(), method);\n\t\tif (invokedMethod != null)\n\t\t\tbugInstance.addMethod(invokedMethod).describe(\"METHOD_CALLED\")\n\t\t\t.addInt(parameterNumber+1).describe(\"INT_MAYBE_NULL_ARG\");\n\t\tif (storedField!= null)\n\t\t\tbugInstance.addField(storedField).describe(\"FIELD_STORED\");\n\t\tbugInstance.addOptionalAnnotation(variableAnnotation);\n\t\tif (variableAnnotation instanceof FieldAnnotation)\n\t\t\tbugInstance.describe(\"FIELD_CONTAINS_VALUE\");\n\t\tfor (Location loc : derefLocationSet)\n\t\t\tbugInstance.addSourceLine(classContext, method, loc).describe(getDescription(loc, refValue));\n\n\t\tfor (SourceLineAnnotation sourceLineAnnotation : knownNullLocations) {\n\t\t\tbugInstance.add(sourceLineAnnotation).describe(\n\t\t\t\"SOURCE_LINE_KNOWN_NULL\");\n\t\t}\n\n\n\t\t// If all deref locations are doomed\n\t\t// (i.e., locations where a normal return is not possible),\n\t\t// add a warning property indicating such.\n\n\t\t// Are all derefs at doomed locations?\n\t\tboolean allDerefsAtDoomedLocations = true;\n\t\tfor (Location derefLoc : derefLocationSet) {\n\t\t\tif (!isDoomed(derefLoc)) {\n\t\t\t\tallDerefsAtDoomedLocations = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tWarningPropertySet<WarningProperty> propertySet = new WarningPropertySet<WarningProperty>();\n\n\t\tif (allDerefsAtDoomedLocations) {\n\t\t\t// Add a WarningProperty\n\t\t\tpropertySet.addProperty(DoomedCodeWarningProperty.DOOMED_CODE);\n\t\t}\n\t\tif (uncallable)\n\t\t\tpropertySet.addProperty(GeneralWarningProperty.IN_UNCALLABLE_METHOD);\n\t\tpropertySet.decorateBugInstance(bugInstance);\n\n\n\t\t// Report it\n\t\tbugReporter.reportBug(bugInstance);\n\t}","id":76565,"modified_method":"public void foundGuaranteedNullDeref(\n\t\t\t@NonNull Set<Location> assignedNullLocationSet, \n\t\t\t@NonNull Set<Location> derefLocationSet, \n\t\t\tSortedSet<Location> doomedLocations,\n\t\t\tValueNumberDataflow vna, ValueNumber refValue,\n\t\t\t@CheckForNull BugAnnotation variableAnnotation, NullValueUnconditionalDeref deref,\n\t\t\tboolean npeIfStatementCovered) {\n\t\tif (refValue.hasFlag(ValueNumber.CONSTANT_CLASS_OBJECT))\n\t\t\treturn;\n\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Found guaranteed null deref in \"\n\t\t\t\t\t+ method.getName());\n\t\t\tfor (Location loc : doomedLocations)\n\t\t\t\tSystem.out.println(\"Doomed at \" + loc);\n\t\t}\n\n\t\tString bugType = \"NP_GUARANTEED_DEREF\";\n\t\tint priority = NORMAL_PRIORITY;\n\n\t\tif (deref.isMethodReturnValue())\n\t\t\tbugType = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\";\n\t\telse {\n\t\t\tif (deref.isAlwaysOnExceptionPath())\n\t\t\t\tbugType += \"_ON_EXCEPTION_PATH\";\n\t\t\telse priority = HIGH_PRIORITY;\n\t\t\tif (!npeIfStatementCovered)\n\t\t\t\tpriority++;\n\t\t}\n\n\t\t// Add Locations in the set of locations at least one of which\n\t\t// is guaranteed to be dereferenced\n\n\t\tSortedSet<Location> sourceLocations;\n\t\tif (doomedLocations.isEmpty() || doomedLocations.size() > 3\n\t\t\t\t&& doomedLocations.size() > assignedNullLocationSet.size())\n\t\t\tsourceLocations = new TreeSet<Location>(assignedNullLocationSet);\n\t\telse\n\t\t\tsourceLocations = doomedLocations;\n\n\t\tif (doomedLocations.isEmpty() || derefLocationSet.isEmpty())\n\t\t\treturn;\n\t\tboolean derefOutsideCatchBlock = false;\n\t\tfor (Location loc : derefLocationSet)\n\t\t\tif (!inCatchNullBlock(loc)) {\n\t\t\t\tderefOutsideCatchBlock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tboolean uniqueDereferenceLocations = false;\n\t\tLineNumberTable table = method.getLineNumberTable();\n\t\tif (table == null)\n\t\t\tuniqueDereferenceLocations = true;\n\t\telse {\n\t\t\tBitSet linesMentionedMultipleTimes = ClassContext.linesMentionedMultipleTimes(method);\n\t\t\tfor(Location loc : derefLocationSet) {\n\t\t\t  int lineNumber = table.getSourceLine(loc.getHandle().getPosition());\n\t\t\t  if (!linesMentionedMultipleTimes.get(lineNumber)) uniqueDereferenceLocations = true;\n\t\t\t}\n\t\t}\n\n\n\t\tif (!derefOutsideCatchBlock) {\n\t\t\tif (!uniqueDereferenceLocations || skipIfInsideCatchNull())\n\t\t\t\treturn;\n\t\t\tpriority++;\n\t\t}\n\t\tif (!uniqueDereferenceLocations)\n\t\t\tpriority++;\n\n\t\t// Create BugInstance\n\n\t\tBitSet knownNull = new BitSet();\n\n\t\tSortedSet<SourceLineAnnotation> knownNullLocations = new TreeSet<SourceLineAnnotation>();\n\t\tfor (Location loc : sourceLocations) {\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, method, loc);\n\t\t\tif (sourceLineAnnotation == null)\n\t\t\t\tcontinue;\n\t\t\tint startLine = sourceLineAnnotation.getStartLine();\n\t\t\tif (startLine == -1)\n\t\t\t\tknownNullLocations.add(sourceLineAnnotation);\n\t\t\telse if (!knownNull.get(startLine)) {\n\t\t\t\tknownNull.set(startLine);\n\t\t\t\tknownNullLocations.add(sourceLineAnnotation);\n\t\t\t}\n\t\t}\n\n\t\tFieldAnnotation storedField = null;\n\t\tMethodAnnotation invokedMethod = null;\n\t\tXMethod invokedXMethod = null;\n\t\tint parameterNumber = -1;\n\t\tif (derefLocationSet.size() == 1) {\n\t\t\tLocation loc = derefLocationSet.iterator().next();\n\n\t\t\tPointerUsageRequiringNonNullValue pu = null;\n\t\t\ttry {\n\t\t\t\tUsagesRequiringNonNullValues usages = classContext.getUsagesRequiringNonNullValues(method);\n\t\t\t\tpu = usages.get(loc, refValue, vnaDataflow);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t   AnalysisContext.logError(\"Error getting UsagesRequiringNonNullValues for \" + method, e);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tAnalysisContext.logError(\"Error getting UsagesRequiringNonNullValues for \" + method, e);\n\t\t\t}\n\n\n\t\t\tif (pu != null) {\n\n\n\t\t\tif (pu.getReturnFromNonNullMethod()) {\n\t\t\t\tbugType = \"NP_NONNULL_RETURN_VIOLATION\";\n\t\t\t\tString methodName = method.getName();\n\t\t\t\tString methodSig = method.getSignature();\n\t\t\t\tif (methodName.equals(\"clone\") && methodSig.equals(\"()Ljava/lang/Object;\")) {\n\t\t\t\t\tbugType = \"NP_CLONE_COULD_RETURN_NULL\";\n\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t} else if (methodName.equals(\"toString\") && methodSig.equals(\"()Ljava/lang/String;\")) {\n\t\t\t\t\tbugType = \"NP_TOSTRING_COULD_RETURN_NULL\";\n\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tXField nonNullField = pu.getNonNullField();\n\t\t\t\tif (nonNullField != null) {\n\t\t\t\t\tstoredField =  FieldAnnotation.fromXField( nonNullField );\n\t\t\t\t\tbugType = \"NP_STORE_INTO_NONNULL_FIELD\";\n\t\t\t\t} else {\n\t\t\t\t\tXMethodParameter nonNullParameter = pu.getNonNullParameter();\n\t\t\t\t\tif (nonNullParameter != null) {\n\t\t\t\t\t\tXMethodParameter mp = nonNullParameter ;\n\t\t\t\t\t\tinvokedXMethod = mp.getMethod();\n\t\t\t\t\t\tinvokedMethod =  MethodAnnotation.fromXMethod(mp.getMethod());\n\t\t\t\t\t\tparameterNumber = mp.getParameterNumber();\n\t\t\t\t\t\tbugType = \"NP_NULL_PARAM_DEREF\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t} else  if (!deref.isAlwaysOnExceptionPath())\n\t\t\t\tbugType = \"NP_NULL_ON_SOME_PATH\";\n\t\t\telse\n\t\t\t\tbugType = \"NP_NULL_ON_SOME_PATH_EXCEPTION\";\n\n\t\t\tif (deref.isReadlineValue())\n\t\t\t\tbugType = \"NP_DEREFERENCE_OF_READLINE_VALUE\";\n\t\t\telse if (deref.isMethodReturnValue())\n\t\t\t\tbugType = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\";\n\n\t\t}\n\n\n\t\tXMethod xMethod = XFactory.createXMethod(classContext.getJavaClass(), method);\n\t\tboolean uncallable = !AnalysisContext.currentXFactory().isCalledDirectlyOrIndirectly(xMethod) \n\t\t\t\t&& xMethod.isPrivate();\n\t\tif (invokedXMethod != null) for (Location derefLoc : derefLocationSet) \n\t\t\tif (safeCallToPrimateParseMethod(invokedXMethod, derefLoc)) return;\n\t\tboolean hasManyNullTests = true;\n\t\tfor (SourceLineAnnotation sourceLineAnnotation : knownNullLocations) {\n\t\t\tif (!hasManyPreceedingNullTests(sourceLineAnnotation.getStartBytecode()))\n\t\t\t\t\thasManyNullTests = false;\n\t\t}\n\t\tif (hasManyNullTests) {\n\t\t\tif (bugType.equals(\"NP_NULL_ON_SOME_PATH\"))\n\t\t\t\t\tbugType = \"NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE\";\n\t\t\telse priority++;\n\t\t}\n\t\t\t\n\t\tBugInstance bugInstance = new BugInstance(this, bugType, priority)\n\t\t\t\t.addClassAndMethod(classContext.getJavaClass(), method);\n\t\tif (invokedMethod != null)\n\t\t\tbugInstance.addMethod(invokedMethod).describe(\"METHOD_CALLED\")\n\t\t\t.addInt(parameterNumber+1).describe(\"INT_MAYBE_NULL_ARG\");\n\t\tif (storedField!= null)\n\t\t\tbugInstance.addField(storedField).describe(\"FIELD_STORED\");\n\t\tbugInstance.addOptionalAnnotation(variableAnnotation);\n\t\tif (variableAnnotation instanceof FieldAnnotation)\n\t\t\tbugInstance.describe(\"FIELD_CONTAINS_VALUE\");\n\t\t\n\t\t// If all deref locations are doomed\n\t\t// (i.e., locations where a normal return is not possible),\n\t\t// add a warning property indicating such.\n\n\t\t// Are all derefs at doomed locations?\n\t\tboolean allDerefsAtDoomedLocations = true;\n\t\tfor (Location derefLoc : derefLocationSet) {\n\t\t\tif (!isDoomed(derefLoc)) {\n\t\t\t\tallDerefsAtDoomedLocations = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tWarningPropertySet<WarningProperty> propertySet = new WarningPropertySet<WarningProperty>();\n\n\t\tif (allDerefsAtDoomedLocations) {\n\t\t\t// Add a WarningProperty\n\t\t\tpropertySet.addProperty(DoomedCodeWarningProperty.DOOMED_CODE);\n\t\t}\n\t\tif (uncallable)\n\t\t\tpropertySet.addProperty(GeneralWarningProperty.IN_UNCALLABLE_METHOD);\n\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\n\t\tif (bugType.equals(\"NP_DEREFERENCE_OF_READLINE_VALUE\")) {\n\n\t\t\tint source = -9999;\n\t\t\tif (knownNullLocations.size() == 1)\n\t\t\t\tsource = knownNullLocations.iterator().next().getEndBytecode();\n\t\t\tfor (Location loc : derefLocationSet) {\n\t\t\t\tint pos = loc.getHandle().getPosition();\n\t\t\t\tif (pos != source+3) // immediate dereferences are handled by another detector\n\t\t\t\t\tbugAccumulator.accumulateBug(bugInstance, SourceLineAnnotation.fromVisitedInstruction(classContext, method, loc));\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (Location loc : derefLocationSet)\n\t\t\t\tbugInstance.addSourceLine(classContext, method, loc).describe(getDescription(loc, refValue));\n\n\t\t\tfor (SourceLineAnnotation sourceLineAnnotation : knownNullLocations) {\n\t\t\t\tbugInstance.add(sourceLineAnnotation).describe(\n\t\t\t\t\"SOURCE_LINE_KNOWN_NULL\");\n\t\t\t}\n\n\t\t\t// Report it\n\t\t\tbugReporter.reportBug(bugInstance);\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public FindNullDeref(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t}","id":76566,"modified_method":"public FindNullDeref(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t\tthis.bugAccumulator = new BugAccumulator(bugReporter);\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void examineReturnInstruction(Location location)\n\t\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\tif (DEBUG_NULLRETURN) {\n\t\t\tSystem.out.println(\"Checking null return at \" + location);\n\t\t}\n\n\t\tIsNullValueDataflow invDataflow = classContext\n\t\t\t\t.getIsNullValueDataflow(method);\n\t\tIsNullValueFrame frame = invDataflow.getFactAtLocation(location);\n\t\tValueNumberFrame  vnaFrame = classContext.getValueNumberDataflow(method).getFactAtLocation(location);\n\t\tif (!vnaFrame.isValid()) return;\n\t\tValueNumber valueNumber = vnaFrame.getTopValue();\n\t\tif (!frame.isValid())\n\t\t\treturn;\n\t\tIsNullValue tos = frame.getTopValue();\n\t\tif (tos.isDefinitelyNull()) {\n\t\t\tBugAnnotation variable = ValueNumberSourceInfo.findAnnotationFromValueNumber(method,\n\t\t\t\t\tlocation, valueNumber, vnaFrame);\n\n\t\t\tString bugPattern = \"NP_NONNULL_RETURN_VIOLATION\";\n\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\tif (tos.isDefinitelyNull() && !tos.isException())\n\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\tString methodName = method.getName();\n\t\t\tif (methodName.equals(\"clone\")) {\n\t\t\t\tbugPattern = \"NP_CLONE_COULD_RETURN_NULL\";\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t} else if (methodName.equals(\"toString\")) {\n\t\t\t\tbugPattern = \"NP_TOSTRING_COULD_RETURN_NULL\";\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t}\n\t\t\tBugInstance warning = new BugInstance(this, bugPattern, priority)\n\t\t\t\t\t.addClassAndMethod(classContext.getJavaClass(), method).addOptionalAnnotation(variable).addSourceLine(\n\t\t\t\t\t\t\tclassContext, method,\n\t\t\t\t\t\t\tlocation);\n\n\t\t\tbugReporter.reportBug(warning);\n\t\t}\n\t}","id":76567,"modified_method":"private void examineReturnInstruction(Location location)\n\t\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\tif (DEBUG_NULLRETURN) {\n\t\t\tSystem.out.println(\"Checking null return at \" + location);\n\t\t}\n\n\t\tIsNullValueDataflow invDataflow = classContext\n\t\t\t\t.getIsNullValueDataflow(method);\n\t\tIsNullValueFrame frame = invDataflow.getFactAtLocation(location);\n\t\tValueNumberFrame  vnaFrame = classContext.getValueNumberDataflow(method).getFactAtLocation(location);\n\t\tif (!vnaFrame.isValid()) return;\n\t\tValueNumber valueNumber = vnaFrame.getTopValue();\n\t\tif (!frame.isValid())\n\t\t\treturn;\n\t\tIsNullValue tos = frame.getTopValue();\n\t\tif (tos.isDefinitelyNull()) {\n\t\t\tBugAnnotation variable = ValueNumberSourceInfo.findAnnotationFromValueNumber(method,\n\t\t\t\t\tlocation, valueNumber, vnaFrame);\n\n\t\t\tString bugPattern = \"NP_NONNULL_RETURN_VIOLATION\";\n\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\tif (tos.isDefinitelyNull() && !tos.isException())\n\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\tString methodName = method.getName();\n\t\t\tif (methodName.equals(\"clone\")) {\n\t\t\t\tbugPattern = \"NP_CLONE_COULD_RETURN_NULL\";\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t} else if (methodName.equals(\"toString\")) {\n\t\t\t\tbugPattern = \"NP_TOSTRING_COULD_RETURN_NULL\";\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t}\n\t\t\tBugInstance warning = new BugInstance(this, bugPattern, priority)\n\t\t\t\t\t.addClassAndMethod(classContext.getJavaClass(), method).addOptionalAnnotation(variable);\n\t\t\tbugAccumulator.accumulateBug(warning, SourceLineAnnotation.fromVisitedInstruction(classContext, method,\n\t\t\t\t\t\t\tlocation));\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void foundRedundantNullCheck(Location location,\n\t\t\tRedundantBranch redundantBranch) {\n\n\t\tboolean isChecked = redundantBranch.firstValue.isChecked();\n\t\tboolean wouldHaveBeenAKaboom = redundantBranch.firstValue\n\t\t\t\t.wouldHaveBeenAKaboom();\n\t\tLocation locationOfKaBoom = redundantBranch.firstValue\n\t\t\t\t.getLocationOfKaBoom();\n\n\t\tboolean createdDeadCode = false;\n\t\tboolean infeasibleEdgeSimplyThrowsException = false;\n\t\tEdge infeasibleEdge = redundantBranch.infeasibleEdge;\n\t\tif (infeasibleEdge != null) {\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Check if \" + redundantBranch\n\t\t\t\t\t\t+ \" creates dead code\");\n\t\t\tBasicBlock target = infeasibleEdge.getTarget();\n\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Target block is  \"\n\t\t\t\t\t\t+ (target.isExceptionThrower() ? \" exception thrower\"\n\t\t\t\t\t\t\t\t: \" not exception thrower\"));\n\t\t\t// If the block is empty, it probably doesn't matter that it was\n\t\t\t// killed.\n\t\t\t// FIXME: really, we should crawl the immediately reachable blocks\n\t\t\t// starting at the target block to see if any of them are dead and\n\t\t\t// nonempty.\n\t\t\tboolean empty = !target.isExceptionThrower()\n\t\t\t\t\t&& (target.isEmpty() || isGoto(target.getFirstInstruction()\n\t\t\t\t\t\t\t.getInstruction()));\n\t\t\tif (!empty) {\n\t\t\t\ttry {\n\t\t\t\t\tif (classContext.getCFG(method).getNumIncomingEdges(target) > 1) {\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out\n\t\t\t\t\t\t\t\t\t.println(\"Target of infeasible edge has multiple incoming edges\");\n\t\t\t\t\t\tempty = true;\n\t\t\t\t\t}\n\t\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\t\tassert true; // ignore it\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Target block is  \"\n\t\t\t\t\t\t+ (empty ? \"empty\" : \"not empty\"));\n\n\t\t\tif (!empty) {\n\t\t\t\tif (isThrower(target))\n\t\t\t\t\tinfeasibleEdgeSimplyThrowsException = true;\n\n\t\t\t}\n\t\t\tif (!empty && !previouslyDeadBlocks.get(target.getLabel())) {\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tSystem.out.println(\"target was alive previously\");\n\t\t\t\t// Block was not dead before the null pointer analysis.\n\t\t\t\t// See if it is dead now by inspecting the null value frame.\n\t\t\t\t// If it's TOP, then the block became dead.\n\t\t\t\tIsNullValueFrame invFrame = invDataflow.getStartFact(target);\n\t\t\t\tcreatedDeadCode = invFrame.isTop();\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tSystem.out.println(\"target is now \"\n\t\t\t\t\t\t\t+ (createdDeadCode ? \"dead\" : \"alive\"));\n\n\t\t\t}\n\t\t}\n\n\t\tint priority;\n\t\tboolean valueIsNull = true;\n\t\tString warning;\n\t\tif (redundantBranch.secondValue == null) {\n\t\t\tif (redundantBranch.firstValue.isDefinitelyNull()) {\n\t\t\t\twarning = \"RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE\";\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t} else {\n\t\t\t\twarning = \"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\";\n\t\t\t\tvalueIsNull = false;\n\t\t\t\tpriority = isChecked ? NORMAL_PRIORITY : LOW_PRIORITY;\n\t\t\t}\n\n\t\t} else {\n\t\t\tboolean bothNull = redundantBranch.firstValue.isDefinitelyNull()\n\t\t\t\t\t&& redundantBranch.secondValue.isDefinitelyNull();\n\t\t\tif (redundantBranch.secondValue.isChecked())\n\t\t\t\tisChecked = true;\n\t\t\tif (redundantBranch.secondValue.wouldHaveBeenAKaboom()) {\n\t\t\t\twouldHaveBeenAKaboom = true;\n\t\t\t\tlocationOfKaBoom = redundantBranch.secondValue\n\t\t\t\t\t\t.getLocationOfKaBoom();\n\t\t\t}\n\t\t\tif (bothNull) {\n\t\t\t\twarning = \"RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES\";\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t} else {\n\t\t\t\twarning = \"RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE\";\n\t\t\t\tpriority = isChecked ? NORMAL_PRIORITY : LOW_PRIORITY;\n\t\t\t}\n\n\t\t}\n\n\t\tif (wouldHaveBeenAKaboom) {\n\t\t\tpriority = HIGH_PRIORITY;\n\t\t\twarning = \"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\";\n\t\t\tif (locationOfKaBoom == null)\n\t\t\t\tthrow new NullPointerException(\"location of KaBoom is null\");\n\t\t}\n\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(createdDeadCode + \" \"\n\t\t\t\t\t+ infeasibleEdgeSimplyThrowsException + \" \" + valueIsNull\n\t\t\t\t\t+ \" \" + priority);\n\t\tif (createdDeadCode && !infeasibleEdgeSimplyThrowsException) {\n\t\t\tpriority += 0;\n\t\t} else if (createdDeadCode && infeasibleEdgeSimplyThrowsException) {\n\t\t\t// throw clause\n\t\t\tif (valueIsNull)\n\t\t\t\tpriority += 0;\n\t\t\telse\n\t\t\t\tpriority += 1;\n\t\t} else {\n\t\t\t// didn't create any dead code\n\t\t\tpriority += 1;\n\t\t}\n\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"RCN\" + priority + \" \"\n\t\t\t\t\t+ redundantBranch.firstValue + \" =? \"\n\t\t\t\t\t+ redundantBranch.secondValue + \" : \" + warning);\n\n\t\t\tif (isChecked)\n\t\t\t\tSystem.out.println(\"isChecked\");\n\t\t\tif (wouldHaveBeenAKaboom)\n\t\t\t\tSystem.out.println(\"wouldHaveBeenAKaboom\");\n\t\t\tif (createdDeadCode)\n\t\t\t\tSystem.out.println(\"createdDeadCode\");\n\t\t}\n\t\tif (priority > LOW_PRIORITY) return;\n\t\tBugAnnotation variableAnnotation = null;\n\t\ttry {\n\t\t\t// Get the value number\n\t\t\tValueNumberFrame vnaFrame = classContext.getValueNumberDataflow(\n\t\t\t\t\tmethod).getFactAtLocation(location);\n\t\t\tif (vnaFrame.isValid()) {\n\t\t\t\tInstruction ins = location.getHandle().getInstruction();\n\n\t\t\t\tValueNumber valueNumber = vnaFrame.getInstance(ins,\n\t\t\t\t\t\tclassContext.getConstantPoolGen());\n\t\t\t\tif (valueNumber.hasFlag(ValueNumber.CONSTANT_CLASS_OBJECT))\n\t\t\t\t\treturn;\n\t\t\t\tvariableAnnotation = ValueNumberSourceInfo.findAnnotationFromValueNumber(method,\n\t\t\t\t\t\tlocation, valueNumber, vnaFrame);\n\n\t\t\t}\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\t// ignore\n\t\t} catch (CFGBuilderException e) {\n\t\t\t// ignore\n\t\t}\n\n\t\tBugInstance bugInstance = new BugInstance(this, warning, priority)\n\t\t\t\t.addClassAndMethod(classContext.getJavaClass(), method);\n\t\tif (variableAnnotation != null)\n\t\t\tbugInstance.add(variableAnnotation);\n\t\telse\n\t\t\tbugInstance.add(new LocalVariableAnnotation(\"?\", -1, -1));\n\t\tif (wouldHaveBeenAKaboom)\n\t\t\tbugInstance.addSourceLine(classContext, method,\n\t\t\t\t\tlocationOfKaBoom);\n\t\tbugInstance.addSourceLine(classContext, method,\n\t\t\t\tlocation).describe(\"SOURCE_REDUNDANT_NULL_CHECK\");\n\n\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\tWarningPropertySet<WarningProperty> propertySet = new WarningPropertySet<WarningProperty>();\n\t\t\tWarningPropertyUtil.addPropertiesForLocation(propertySet,\n\t\t\t\t\tclassContext, method, location);\n\t\t\tif (isChecked)\n\t\t\t\tpropertySet.addProperty(NullDerefProperty.CHECKED_VALUE);\n\t\t\tif (wouldHaveBeenAKaboom)\n\t\t\t\tpropertySet\n\t\t\t\t\t\t.addProperty(NullDerefProperty.WOULD_HAVE_BEEN_A_KABOOM);\n\t\t\tif (createdDeadCode)\n\t\t\t\tpropertySet.addProperty(NullDerefProperty.CREATED_DEAD_CODE);\n\n\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\n\t\t\tpriority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tbugInstance.setPriority(priority);\n\t\t}\n\n\t\tbugReporter.reportBug(bugInstance);\n\t}","id":76568,"modified_method":"public void foundRedundantNullCheck(Location location,\n\t\t\tRedundantBranch redundantBranch) {\n\n\t\tboolean isChecked = redundantBranch.firstValue.isChecked();\n\t\tboolean wouldHaveBeenAKaboom = redundantBranch.firstValue\n\t\t\t\t.wouldHaveBeenAKaboom();\n\t\tLocation locationOfKaBoom = redundantBranch.firstValue\n\t\t\t\t.getLocationOfKaBoom();\n\n\t\tboolean createdDeadCode = false;\n\t\tboolean infeasibleEdgeSimplyThrowsException = false;\n\t\tEdge infeasibleEdge = redundantBranch.infeasibleEdge;\n\t\tif (infeasibleEdge != null) {\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Check if \" + redundantBranch\n\t\t\t\t\t\t+ \" creates dead code\");\n\t\t\tBasicBlock target = infeasibleEdge.getTarget();\n\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Target block is  \"\n\t\t\t\t\t\t+ (target.isExceptionThrower() ? \" exception thrower\"\n\t\t\t\t\t\t\t\t: \" not exception thrower\"));\n\t\t\t// If the block is empty, it probably doesn't matter that it was\n\t\t\t// killed.\n\t\t\t// FIXME: really, we should crawl the immediately reachable blocks\n\t\t\t// starting at the target block to see if any of them are dead and\n\t\t\t// nonempty.\n\t\t\tboolean empty = !target.isExceptionThrower()\n\t\t\t\t\t&& (target.isEmpty() || isGoto(target.getFirstInstruction()\n\t\t\t\t\t\t\t.getInstruction()));\n\t\t\tif (!empty) {\n\t\t\t\ttry {\n\t\t\t\t\tif (classContext.getCFG(method).getNumIncomingEdges(target) > 1) {\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out\n\t\t\t\t\t\t\t\t\t.println(\"Target of infeasible edge has multiple incoming edges\");\n\t\t\t\t\t\tempty = true;\n\t\t\t\t\t}\n\t\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\t\tassert true; // ignore it\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Target block is  \"\n\t\t\t\t\t\t+ (empty ? \"empty\" : \"not empty\"));\n\n\t\t\tif (!empty) {\n\t\t\t\tif (isThrower(target))\n\t\t\t\t\tinfeasibleEdgeSimplyThrowsException = true;\n\n\t\t\t}\n\t\t\tif (!empty && !previouslyDeadBlocks.get(target.getLabel())) {\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tSystem.out.println(\"target was alive previously\");\n\t\t\t\t// Block was not dead before the null pointer analysis.\n\t\t\t\t// See if it is dead now by inspecting the null value frame.\n\t\t\t\t// If it's TOP, then the block became dead.\n\t\t\t\tIsNullValueFrame invFrame = invDataflow.getStartFact(target);\n\t\t\t\tcreatedDeadCode = invFrame.isTop();\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tSystem.out.println(\"target is now \"\n\t\t\t\t\t\t\t+ (createdDeadCode ? \"dead\" : \"alive\"));\n\n\t\t\t}\n\t\t}\n\n\t\tint priority;\n\t\tboolean valueIsNull = true;\n\t\tString warning;\n\t\tif (redundantBranch.secondValue == null) {\n\t\t\tif (redundantBranch.firstValue.isDefinitelyNull()) {\n\t\t\t\twarning = \"RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE\";\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t} else {\n\t\t\t\twarning = \"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\";\n\t\t\t\tvalueIsNull = false;\n\t\t\t\tpriority = isChecked ? NORMAL_PRIORITY : LOW_PRIORITY;\n\t\t\t}\n\n\t\t} else {\n\t\t\tboolean bothNull = redundantBranch.firstValue.isDefinitelyNull()\n\t\t\t\t\t&& redundantBranch.secondValue.isDefinitelyNull();\n\t\t\tif (redundantBranch.secondValue.isChecked())\n\t\t\t\tisChecked = true;\n\t\t\tif (redundantBranch.secondValue.wouldHaveBeenAKaboom()) {\n\t\t\t\twouldHaveBeenAKaboom = true;\n\t\t\t\tlocationOfKaBoom = redundantBranch.secondValue\n\t\t\t\t\t\t.getLocationOfKaBoom();\n\t\t\t}\n\t\t\tif (bothNull) {\n\t\t\t\twarning = \"RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES\";\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t} else {\n\t\t\t\twarning = \"RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE\";\n\t\t\t\tpriority = isChecked ? NORMAL_PRIORITY : LOW_PRIORITY;\n\t\t\t}\n\n\t\t}\n\n\t\tif (wouldHaveBeenAKaboom) {\n\t\t\tpriority = HIGH_PRIORITY;\n\t\t\twarning = \"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\";\n\t\t\tif (locationOfKaBoom == null)\n\t\t\t\tthrow new NullPointerException(\"location of KaBoom is null\");\n\t\t}\n\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(createdDeadCode + \" \"\n\t\t\t\t\t+ infeasibleEdgeSimplyThrowsException + \" \" + valueIsNull\n\t\t\t\t\t+ \" \" + priority);\n\t\tif (createdDeadCode && !infeasibleEdgeSimplyThrowsException) {\n\t\t\tpriority += 0;\n\t\t} else if (createdDeadCode && infeasibleEdgeSimplyThrowsException) {\n\t\t\t// throw clause\n\t\t\tif (valueIsNull)\n\t\t\t\tpriority += 0;\n\t\t\telse\n\t\t\t\tpriority += 1;\n\t\t} else {\n\t\t\t// didn't create any dead code\n\t\t\tpriority += 1;\n\t\t}\n\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"RCN\" + priority + \" \"\n\t\t\t\t\t+ redundantBranch.firstValue + \" =? \"\n\t\t\t\t\t+ redundantBranch.secondValue + \" : \" + warning);\n\n\t\t\tif (isChecked)\n\t\t\t\tSystem.out.println(\"isChecked\");\n\t\t\tif (wouldHaveBeenAKaboom)\n\t\t\t\tSystem.out.println(\"wouldHaveBeenAKaboom\");\n\t\t\tif (createdDeadCode)\n\t\t\t\tSystem.out.println(\"createdDeadCode\");\n\t\t}\n\t\tif (priority > LOW_PRIORITY) return;\n\t\tBugAnnotation variableAnnotation = null;\n\t\ttry {\n\t\t\t// Get the value number\n\t\t\tValueNumberFrame vnaFrame = classContext.getValueNumberDataflow(\n\t\t\t\t\tmethod).getFactAtLocation(location);\n\t\t\tif (vnaFrame.isValid()) {\n\t\t\t\tInstruction ins = location.getHandle().getInstruction();\n\n\t\t\t\tValueNumber valueNumber = vnaFrame.getInstance(ins,\n\t\t\t\t\t\tclassContext.getConstantPoolGen());\n\t\t\t\tif (valueNumber.hasFlag(ValueNumber.CONSTANT_CLASS_OBJECT))\n\t\t\t\t\treturn;\n\t\t\t\tvariableAnnotation = ValueNumberSourceInfo.findAnnotationFromValueNumber(method,\n\t\t\t\t\t\tlocation, valueNumber, vnaFrame);\n\n\t\t\t}\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\t// ignore\n\t\t} catch (CFGBuilderException e) {\n\t\t\t// ignore\n\t\t}\n\n\t\tBugInstance bugInstance = new BugInstance(this, warning, priority)\n\t\t\t\t.addClassAndMethod(classContext.getJavaClass(), method);\n\t\tif (variableAnnotation != null)\n\t\t\tbugInstance.add(variableAnnotation);\n\t\telse\n\t\t\tbugInstance.add(new LocalVariableAnnotation(\"?\", -1, -1));\n\t\tif (wouldHaveBeenAKaboom)\n\t\t\tbugInstance.addSourceLine(classContext, method,\n\t\t\t\t\tlocationOfKaBoom);\n\t\t\n\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\tWarningPropertySet<WarningProperty> propertySet = new WarningPropertySet<WarningProperty>();\n\t\t\tWarningPropertyUtil.addPropertiesForLocation(propertySet,\n\t\t\t\t\tclassContext, method, location);\n\t\t\tif (isChecked)\n\t\t\t\tpropertySet.addProperty(NullDerefProperty.CHECKED_VALUE);\n\t\t\tif (wouldHaveBeenAKaboom)\n\t\t\t\tpropertySet\n\t\t\t\t\t\t.addProperty(NullDerefProperty.WOULD_HAVE_BEEN_A_KABOOM);\n\t\t\tif (createdDeadCode)\n\t\t\t\tpropertySet.addProperty(NullDerefProperty.CREATED_DEAD_CODE);\n\n\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\n\t\t\tpriority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tbugInstance.setPriority(priority);\n\t\t}\n\t\t\n\t\tSourceLineAnnotation sourceLine = SourceLineAnnotation.fromVisitedInstruction(classContext, method,\n\t\t\t\tlocation);\n\t\tsourceLine.setDescription(\"SOURCE_REDUNDANT_NULL_CHECK\");\n\t\tbugAccumulator.accumulateBug(bugInstance, sourceLine);\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tthis.classContext = classContext;\n\n\t\tString currentMethod = null;\n\n\t\tJavaClass jclass = classContext.getJavaClass();\n\t\tString className = jclass.getClassName();\n\t\tif (CLASS != null && !className.equals(CLASS))\n\t\t\treturn;\n\t\tMethod[] methodList = jclass.getMethods();\n\t\tfor (Method method : methodList) {\n\t\t\ttry {\n\t\t\t\tif (method.isAbstract() || method.isNative()\n\t\t\t\t\t\t|| method.getCode() == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcurrentMethod = SignatureConverter.convertMethodSignature(jclass, method);\n\n\t\t\t\tif (METHOD != null && !method.getName().equals(METHOD))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DEBUG || DEBUG_NULLARG)\n\t\t\t\t\tSystem.out.println(\"Checking for NP in \" + currentMethod);\n\t\t\t\tanalyzeMethod(classContext, method);\n\t\t\t} catch (MissingClassException e) {\n\t\t\t\tbugReporter.reportMissingClass(e.getClassNotFoundException());\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\"While analyzing \" + currentMethod\n\t\t\t\t\t\t+ \": FindNullDeref caught dae exception\", e);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"While analyzing \" + currentMethod\n\t\t\t\t\t\t+ \": FindNullDeref caught cfgb exception\", e);\n\t\t\t}\n\n\t\t}\n\t}","id":76569,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tthis.classContext = classContext;\n\n\t\tString currentMethod = null;\n\n\t\tJavaClass jclass = classContext.getJavaClass();\n\t\tString className = jclass.getClassName();\n\t\tif (CLASS != null && !className.equals(CLASS))\n\t\t\treturn;\n\t\tMethod[] methodList = jclass.getMethods();\n\t\tfor (Method method : methodList) {\n\t\t\ttry {\n\t\t\t\tif (method.isAbstract() || method.isNative()\n\t\t\t\t\t\t|| method.getCode() == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcurrentMethod = SignatureConverter.convertMethodSignature(jclass, method);\n\n\t\t\t\tif (METHOD != null && !method.getName().equals(METHOD))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DEBUG || DEBUG_NULLARG)\n\t\t\t\t\tSystem.out.println(\"Checking for NP in \" + currentMethod);\n\t\t\t\tanalyzeMethod(classContext, method);\n\t\t\t} catch (MissingClassException e) {\n\t\t\t\tbugReporter.reportMissingClass(e.getClassNotFoundException());\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\"While analyzing \" + currentMethod\n\t\t\t\t\t\t+ \": FindNullDeref caught dae exception\", e);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"While analyzing \" + currentMethod\n\t\t\t\t\t\t+ \": FindNullDeref caught cfgb exception\", e);\n\t\t\t}\n\t\t\tbugAccumulator.reportAccumulatedBugs();\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void analyzeMethod(ClassContext classContext, Method method,\n\t\t\t\t\t\t\t  StreamResourceTracker resourceTracker,\n\t\t\t\t\t\t\t  ResourceCollection<Stream> resourceCollection)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tif (isMainMethod(method)) return;\n\n\t\tpotentialOpenStreamList.clear();\n\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tCFG cfg = classContext.getCFG(method);\n\n\t\t// Add Streams passed into the method as parameters.\n\t\t// These are uninteresting, and should poison\n\t\t// any streams which wrap them.\n\t\ttry {\n\t\t\tType[] parameterTypeList = Type.getArgumentTypes(methodGen.getSignature());\n\t\t\tLocation firstLocation = new Location(cfg.getEntry().getFirstInstruction(), cfg.getEntry());\n\n\t\t\tint local = methodGen.isStatic() ? 0 : 1;\n\n\t\t\tfor (Type type : parameterTypeList) {\n\t\t\t\tif (type instanceof ObjectType) {\n\t\t\t\t\tObjectType objectType = (ObjectType) type;\n\t\t\t\t\tfor (ObjectType streamBase : streamBaseList) {\n\t\t\t\t\t\tif (Hierarchy.isSubtype(objectType, streamBase)) {\n\t\t\t\t\t\t\t// OK, found a parameter that is a resource.\n\t\t\t\t\t\t\t// Create a Stream object to represent it.\n\t\t\t\t\t\t\t// The Stream will be uninteresting, so it will\n\t\t\t\t\t\t\t// inhibit reporting for any stream that wraps it.\n\n\t\t\t\t\t\t\tStream paramStream =\n\t\t\t\t\t\t\t\t\tnew Stream(firstLocation, objectType.getClassName(), streamBase.getClassName());\n\t\t\t\t\t\t\tparamStream.setIsOpenOnCreation(true);\n\t\t\t\t\t\t\tparamStream.setOpenLocation(firstLocation);\n\t\t\t\t\t\t\tparamStream.setInstanceParam(local);\n\t\t\t\t\t\t\tresourceCollection.addPreexistingResource(paramStream);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch (type.getType()) {\n\t\t\t\tcase Constants.T_LONG:\n\t\t\t\tcase Constants.T_DOUBLE:\n\t\t\t\t\tlocal += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlocal += 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\n\t\t// Set precomputed map of Locations to Stream creation points.\n\t\t// That way, the StreamResourceTracker won't have to\n\t\t// repeatedly try to figure out where Streams are created.\n\t\tresourceTracker.setResourceCollection(resourceCollection);\n\n\t\tsuper.analyzeMethod(classContext, method, resourceTracker, resourceCollection);\n\n\t\t// Compute streams that escape into other streams:\n\t\t// this takes wrapper streams into account.\n\t\t// This will also compute equivalence classes of streams,\n\t\t// so that if one stream in a class is closed,\n\t\t// they are all considered closed.\n\t\t// (FIXME: this is too simplistic, especially if buffering\n\t\t// is involved.  Sometime we should really think harder\n\t\t// about how this should work.)\n\t\tresourceTracker.markTransitiveUninterestingStreamEscapes();\n\n\t\t// For each stream closed on all paths, mark its equivalence\n\t\t// class as being closed.\n\t\tfor (Iterator<Stream> i = resourceCollection.resourceIterator(); i.hasNext();) {\n\t\t\tStream stream = i.next();\n\t\t\tStreamEquivalenceClass equivalenceClass = resourceTracker.getStreamEquivalenceClass(stream);\n\t\t\tif (stream.isClosed())\n\t\t\t\tequivalenceClass.setClosed();\n\t\t}\n\n\t\t// Iterate through potential open streams, reporting warnings\n\t\t// for the \"interesting\" streams that haven't been closed\n\t\t// (and aren't in an equivalence class with another stream\n\t\t// that was closed).\n\t\tfor (PotentialOpenStream pos : potentialOpenStreamList) {\n\t\t\tStream stream = pos.stream;\n\t\t\tif (stream.isClosed())\n\t\t\t\t// Stream was in an equivalence class with another\n\t\t\t\t// stream that was properly closed.\n\t\t\t\tcontinue;\n\n\t\t\tif (stream.isUninteresting())\n\t\t\t\tcontinue;\n\n\t\t\tLocation openLocation = stream.getOpenLocation();\n\t\t\tif (openLocation == null)\n\t\t\t\tcontinue;\n\n\t\t\tif (IGNORE_WRAPPED_UNINTERESTING_STREAMS\n\t\t\t\t\t&& resourceTracker.isUninterestingStreamEscape(stream))\n\t\t\t\tcontinue;\n\n\t\t\tString sourceFile = javaClass.getSourceFileName();\n\t\t\tbugReporter.reportBug(new BugInstance(this, pos.bugType, pos.priority)\n\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t.addTypeOfNamedClass(stream.getStreamBase()).describe(TypeAnnotation.CLOSEIT_ROLE)\n\t\t\t\t\t.addSourceLine(classContext, methodGen, sourceFile, stream.getLocation().getHandle()));\n\t\t}\n\t}","id":76570,"modified_method":"@Override\n\t\t public void analyzeMethod(ClassContext classContext, Method method,\n\t\t\t\t\t\t\t  StreamResourceTracker resourceTracker,\n\t\t\t\t\t\t\t  ResourceCollection<Stream> resourceCollection)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tif (isMainMethod(method)) return;\n\n\t\tpotentialOpenStreamList.clear();\n\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tCFG cfg = classContext.getCFG(method);\n\n\t\t// Add Streams passed into the method as parameters.\n\t\t// These are uninteresting, and should poison\n\t\t// any streams which wrap them.\n\t\ttry {\n\t\t\tType[] parameterTypeList = Type.getArgumentTypes(methodGen.getSignature());\n\t\t\tLocation firstLocation = new Location(cfg.getEntry().getFirstInstruction(), cfg.getEntry());\n\n\t\t\tint local = methodGen.isStatic() ? 0 : 1;\n\n\t\t\tfor (Type type : parameterTypeList) {\n\t\t\t\tif (type instanceof ObjectType) {\n\t\t\t\t\tObjectType objectType = (ObjectType) type;\n\t\t\t\t\tfor (ObjectType streamBase : streamBaseList) {\n\t\t\t\t\t\tif (Hierarchy.isSubtype(objectType, streamBase)) {\n\t\t\t\t\t\t\t// OK, found a parameter that is a resource.\n\t\t\t\t\t\t\t// Create a Stream object to represent it.\n\t\t\t\t\t\t\t// The Stream will be uninteresting, so it will\n\t\t\t\t\t\t\t// inhibit reporting for any stream that wraps it.\n\n\t\t\t\t\t\t\tStream paramStream =\n\t\t\t\t\t\t\t\t\tnew Stream(firstLocation, objectType.getClassName(), streamBase.getClassName());\n\t\t\t\t\t\t\tparamStream.setIsOpenOnCreation(true);\n\t\t\t\t\t\t\tparamStream.setOpenLocation(firstLocation);\n\t\t\t\t\t\t\tparamStream.setInstanceParam(local);\n\t\t\t\t\t\t\tresourceCollection.addPreexistingResource(paramStream);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch (type.getType()) {\n\t\t\t\tcase Constants.T_LONG:\n\t\t\t\tcase Constants.T_DOUBLE:\n\t\t\t\t\tlocal += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlocal += 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\n\t\t// Set precomputed map of Locations to Stream creation points.\n\t\t// That way, the StreamResourceTracker won't have to\n\t\t// repeatedly try to figure out where Streams are created.\n\t\tresourceTracker.setResourceCollection(resourceCollection);\n\n\t\tsuper.analyzeMethod(classContext, method, resourceTracker, resourceCollection);\n\n\t\t// Compute streams that escape into other streams:\n\t\t// this takes wrapper streams into account.\n\t\t// This will also compute equivalence classes of streams,\n\t\t// so that if one stream in a class is closed,\n\t\t// they are all considered closed.\n\t\t// (FIXME: this is too simplistic, especially if buffering\n\t\t// is involved.  Sometime we should really think harder\n\t\t// about how this should work.)\n\t\tresourceTracker.markTransitiveUninterestingStreamEscapes();\n\n\t\t// For each stream closed on all paths, mark its equivalence\n\t\t// class as being closed.\n\t\tfor (Iterator<Stream> i = resourceCollection.resourceIterator(); i.hasNext();) {\n\t\t\tStream stream = i.next();\n\t\t\tStreamEquivalenceClass equivalenceClass = resourceTracker.getStreamEquivalenceClass(stream);\n\t\t\tif (stream.isClosed())\n\t\t\t\tequivalenceClass.setClosed();\n\t\t}\n\n\t\t// Iterate through potential open streams, reporting warnings\n\t\t// for the \"interesting\" streams that haven't been closed\n\t\t// (and aren't in an equivalence class with another stream\n\t\t// that was closed).\n\t\tfor (PotentialOpenStream pos : potentialOpenStreamList) {\n\t\t\tStream stream = pos.stream;\n\t\t\tif (stream.isClosed())\n\t\t\t\t// Stream was in an equivalence class with another\n\t\t\t\t// stream that was properly closed.\n\t\t\t\tcontinue;\n\n\t\t\tif (stream.isUninteresting())\n\t\t\t\tcontinue;\n\n\t\t\tLocation openLocation = stream.getOpenLocation();\n\t\t\tif (openLocation == null)\n\t\t\t\tcontinue;\n\n\t\t\tif (IGNORE_WRAPPED_UNINTERESTING_STREAMS\n\t\t\t\t\t&& resourceTracker.isUninterestingStreamEscape(stream))\n\t\t\t\tcontinue;\n\n\t\t\tString sourceFile = javaClass.getSourceFileName();\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, pos.bugType, pos.priority)\n\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t.addTypeOfNamedClass(stream.getStreamBase()).describe(TypeAnnotation.CLOSEIT_ROLE), \n\t\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(classContext, methodGen, sourceFile, stream.getLocation().getHandle()));\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public FindSqlInjection(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t}","id":76571,"modified_method":"public FindSqlInjection(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t\tthis.bugAccumulator = new BugAccumulator(bugReporter);\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method) throws DataflowAnalysisException,\n\t\t\tCFGBuilderException {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tthis.method = method;\n\t\tthis.classContext = classContext;\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null)\n\t\t\treturn;\n\n\t\tConstantPoolGen cpg = methodGen.getConstantPool();\n\t\tCFG cfg = classContext.getCFG(method);\n\n\t\tStringAppendState stringAppendState = getStringAppendState(cfg, cpg);\n\n\t\tConstantDataflow dataflow = classContext.getConstantDataflow(method);\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\tif (isDatabaseSink(ins, cpg)) {\n\t\t\t\tConstantFrame frame = dataflow.getFactAtLocation(location);\n\t\t\t\tConstant value = frame.getStackValue(0);\n\n\t\t\t\tif (!value.isConstantString()) {\n\t\t\t\t\t// TODO: verify it's the same string represented by\n\t\t\t\t\t// stringAppendState\n\t\t\t\t\t// FIXME: will false positive on const/static strings\n\t\t\t\t\t// returns by methods\n\t\t\t\t\tLocation prev = getPreviousLocation(cfg, location, true);\n\t\t\t\t\tif (prev == null || !isSafeValue(prev, cpg)) {\n\t\t\t\t\t\tBugInstance bug = generateBugInstance(javaClass, methodGen, location.getHandle(),\n\t\t\t\t\t\t\t\tstringAppendState);\n\t\t\t\t\t\tbug.addSourceLine(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":76572,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method) throws DataflowAnalysisException,\n\t\t\tCFGBuilderException {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tthis.method = method;\n\t\tthis.classContext = classContext;\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null)\n\t\t\treturn;\n\n\t\tConstantPoolGen cpg = methodGen.getConstantPool();\n\t\tCFG cfg = classContext.getCFG(method);\n\n\t\tStringAppendState stringAppendState = getStringAppendState(cfg, cpg);\n\n\t\tConstantDataflow dataflow = classContext.getConstantDataflow(method);\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\tif (isDatabaseSink(ins, cpg)) {\n\t\t\t\tConstantFrame frame = dataflow.getFactAtLocation(location);\n\t\t\t\tConstant value = frame.getStackValue(0);\n\n\t\t\t\tif (!value.isConstantString()) {\n\t\t\t\t\t// TODO: verify it's the same string represented by\n\t\t\t\t\t// stringAppendState\n\t\t\t\t\t// FIXME: will false positive on const/static strings\n\t\t\t\t\t// returns by methods\n\t\t\t\t\tLocation prev = getPreviousLocation(cfg, location, true);\n\t\t\t\t\tif (prev == null || !isSafeValue(prev, cpg)) {\n\t\t\t\t\t\tBugInstance bug = generateBugInstance(javaClass, methodGen, location.getHandle(),\n\t\t\t\t\t\t\t\tstringAppendState);\n\t\t\t\t\t\tbugAccumulator.accumulateBug(bug, SourceLineAnnotation.fromVisitedInstruction(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbugAccumulator.reportAccumulatedBugs();\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public FindUselessControlFlow(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t}","id":76573,"modified_method":"public FindUselessControlFlow(BugReporter bugReporter) {\n\t\tthis.bugAccumulator = new BugAccumulator(bugReporter);\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\tif (ifInstructionSet.get(seen)) {\n\t\t\tif (getBranchTarget() == getBranchFallThrough()) {\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\n\t\t\t\tLineNumberTable lineNumbers = getCode().getLineNumberTable();\n\t\t\t\tif (lineNumbers != null) {\n\t\t\t\t\tint branchLineNumber = lineNumbers.getSourceLine(getPC());\n\t\t\t\t\tint targetLineNumber = lineNumbers.getSourceLine(getBranchFallThrough());\n\t\t\t\t\tint nextLine = getNextSourceLine(lineNumbers, branchLineNumber);\n\t\t\t\t\t\n\t\t\t\t\tif (branchLineNumber +1 == targetLineNumber || branchLineNumber  == targetLineNumber && nextLine == branchLineNumber+1) priority = HIGH_PRIORITY;\n\t\t\t\t\telse if (branchLineNumber +2 < Math.max(targetLineNumber, nextLine)) priority = LOW_PRIORITY;\n\t\t\t\t} else priority = LOW_PRIORITY;\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, priority == HIGH_PRIORITY ? \"UCF_USELESS_CONTROL_FLOW_NEXT_LINE\" : \"UCF_USELESS_CONTROL_FLOW\", priority)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addSourceLine(this));\n\t\t\t}\n\t\t}\n\t}","id":76574,"modified_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\tif (ifInstructionSet.get(seen)) {\n\t\t\tif (getBranchTarget() == getBranchFallThrough()) {\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\n\t\t\t\tLineNumberTable lineNumbers = getCode().getLineNumberTable();\n\t\t\t\tif (lineNumbers != null) {\n\t\t\t\t\tint branchLineNumber = lineNumbers.getSourceLine(getPC());\n\t\t\t\t\tint targetLineNumber = lineNumbers.getSourceLine(getBranchFallThrough());\n\t\t\t\t\tint nextLine = getNextSourceLine(lineNumbers, branchLineNumber);\n\t\t\t\t\t\n\t\t\t\t\tif (branchLineNumber +1 == targetLineNumber || branchLineNumber  == targetLineNumber && nextLine == branchLineNumber+1) priority = HIGH_PRIORITY;\n\t\t\t\t\telse if (branchLineNumber +2 < Math.max(targetLineNumber, nextLine)) priority = LOW_PRIORITY;\n\t\t\t\t} else priority = LOW_PRIORITY;\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, priority == HIGH_PRIORITY ? \"UCF_USELESS_CONTROL_FLOW_NEXT_LINE\" : \"UCF_USELESS_CONTROL_FLOW\", priority)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\tif (!isFinal && seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"start\")\n\t\t\t\t&& getSigConstantOperand().equals(\"()V\")) {\n\t\t\ttry {\n\t\t\t\tif (Hierarchy.isSubtype(getDottedClassConstantOperand(), \"java.lang.Thread\")) {\n\t\t\t\t\tBugInstance bug = new BugInstance(this, \"SC_START_IN_CTOR\", Priorities.NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this);\n\t\t\t\t\t Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();\n\t\t             Set<ClassDescriptor> directSubtypes = subtypes2.getDirectSubtypes(getClassDescriptor());\n\t\t             if (!directSubtypes.isEmpty()) {\n\t\t\t\t\t\t\tfor(ClassDescriptor sub : directSubtypes) \n\t\t                \t\tbug.addClass(sub).describe(ClassAnnotation.SUBCLASS_ROLE);\n\t\t                \tbug.setPriority(Priorities.HIGH_PRIORITY);\n\t\t                }\n\t\t\t\t\tbugReporter.reportBug(bug.addSourceLine(this));\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","id":76575,"modified_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\tif (!isFinal && seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"start\")\n\t\t\t\t&& getSigConstantOperand().equals(\"()V\")) {\n\t\t\ttry {\n\t\t\t\tif (Hierarchy.isSubtype(getDottedClassConstantOperand(), \"java.lang.Thread\")) {\n\t\t\t\t\tBugInstance bug = new BugInstance(this, \"SC_START_IN_CTOR\", Priorities.NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this);\n\t\t\t\t\t Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();\n\t\t             Set<ClassDescriptor> directSubtypes = subtypes2.getDirectSubtypes(getClassDescriptor());\n\t\t             if (!directSubtypes.isEmpty()) {\n\t\t\t\t\t\t\tfor(ClassDescriptor sub : directSubtypes) \n\t\t                \t\tbug.addClass(sub).describe(ClassAnnotation.SUBCLASS_ROLE);\n\t\t                \tbug.setPriority(Priorities.HIGH_PRIORITY);\n\t\t                }\n\t\t\t\t\tbugAccumulator.accumulateBug(bug, this);\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void visit(Code obj) {\n\t\tif (getMethodName().equals(\"<init>\")) super.visit(obj);\n\t}","id":76576,"modified_method":"@Override\n\t\t public void visit(Code obj) {\n\t\tif (getMethodName().equals(\"<init>\")) {\n\t\t\tsuper.visit(obj);\n\t\t\tbugAccumulator.reportAccumulatedBugs();\n\t\t}\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public StartInConstructor(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t}","id":76577,"modified_method":"public StartInConstructor(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t\tthis.bugAccumulator = new BugAccumulator(bugReporter);\n\t}","commit_id":"8b6e858991007216a80412a05f21f15b14fe61b6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Test\n    public void testOnTheFlyIndexing1() throws IOException {\n        Index indexFromInputFile = IndexFactory.createIndex(inputFile, new VCFCodec());\n        if ( outputFileIndex.exists() ) {\n            System.err.println(\"Deleting \" + outputFileIndex);\n            outputFileIndex.delete();\n        }\n\n        for ( int maxRecords : Arrays.asList(0, 1, 10, 100, 1000, -1)) {\n            BasicFeatureSource<VariantContext> source = new BasicFeatureSource<VariantContext>(inputFile.getAbsolutePath(), indexFromInputFile, new VCFCodec());\n\n            int counter = 0;\n            VCFWriter writer = new StandardVCFWriter(outputFile, dict);\n            writer.writeHeader((VCFHeader)source.getHeader());\n            CloseableTribbleIterator<VariantContext> it = source.iterator();\n            while (it.hasNext() && (counter++ < maxRecords || maxRecords == -1) ) {\n                VariantContext vc = it.next();\n                writer.add(vc);\n            }\n            writer.close();\n\n            // test that the input index is the same as the one created from the identical input file\n            // test that the dynamic index is the same as the output index, which is equal to the input index\n            WalkerTest.assertOnDiskIndexEqualToNewlyCreatedIndex(outputFileIndex, \"unittest\", outputFile);\n        }\n    }","id":76578,"modified_method":"@Test\n    public void testOnTheFlyIndexing1() throws IOException {\n        Index indexFromInputFile = IndexFactory.createDynamicIndex(inputFile, new VCFCodec());\n        if ( outputFileIndex.exists() ) {\n            System.err.println(\"Deleting \" + outputFileIndex);\n            outputFileIndex.delete();\n        }\n\n        for ( int maxRecords : Arrays.asList(0, 1, 10, 100, 1000, -1)) {\n            AbstractFeatureReader<VariantContext> source = AbstractFeatureReader.getFeatureReader(inputFile.getAbsolutePath(), new VCFCodec(), indexFromInputFile);\n\n            int counter = 0;\n            VCFWriter writer = new StandardVCFWriter(outputFile, dict);\n            writer.writeHeader((VCFHeader)source.getHeader());\n            CloseableTribbleIterator<VariantContext> it = source.iterator();\n            while (it.hasNext() && (counter++ < maxRecords || maxRecords == -1) ) {\n                VariantContext vc = it.next();\n                writer.add(vc);\n            }\n            writer.close();\n\n            // test that the input index is the same as the one created from the identical input file\n            // test that the dynamic index is the same as the output index, which is equal to the input index\n            //WalkerTest.assertOnDiskIndexEqualToNewlyCreatedIndex(outputFileIndex, \"unittest\", outputFile);\n        }\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public CloseableIterator<GATKFeature> query(GenomeLoc interval) throws IOException {\n        CloseableTribbleIterator<Feature> iter = reader.query(interval.getContig(),interval.getStart(),interval.getStop());\n        if ( RMDTrackBuilder.MEASURE_TRIBBLE_QUERY_PERFORMANCE )\n            logger.warn(\"Query \" + getName() + \":\" + ((PerformanceLoggingFeatureSource)reader).getPerformanceLog());\n        return new FeatureToGATKFeatureIterator(genomeLocParser, iter, this.getName());\n    }","id":76579,"modified_method":"public CloseableIterator<GATKFeature> query(GenomeLoc interval) throws IOException {\n        CloseableTribbleIterator<Feature> iter = reader.query(interval.getContig(),interval.getStart(),interval.getStop());\n        return new FeatureToGATKFeatureIterator(genomeLocParser, iter, this.getName());\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a track\n     *\n     * @param type the type of track, used for track lookup\n     * @param name the name of this specific track\n     * @param file the associated file, for reference or recreating the reader\n     * @param reader the feature reader to use as the underlying data source\n     * @param dict the sam sequence dictionary\n     * @param codec the feature codec we use to decode this type\n     */\n    public RMDTrack(Class type, String name, File file, FeatureSource reader, SAMSequenceDictionary dict, GenomeLocParser genomeLocParser, FeatureCodec codec) {\n        this.type = type;\n        this.name = name;\n        this.file = file;\n        this.reader = reader;\n        this.dictionary = dict;\n        this.genomeLocParser = genomeLocParser;\n        this.codec = codec;\n    }","id":76580,"modified_method":"/**\n     * Create a track\n     *\n     * @param type the type of track, used for track lookup\n     * @param name the name of this specific track\n     * @param file the associated file, for reference or recreating the reader\n     * @param reader the feature reader to use as the underlying data source\n     * @param dict the sam sequence dictionary\n     * @param codec the feature codec we use to decode this type\n     */\n    public RMDTrack(Class type, String name, File file, AbstractFeatureReader reader, SAMSequenceDictionary dict, GenomeLocParser genomeLocParser, FeatureCodec codec) {\n        this.type = type;\n        this.name = name;\n        this.file = file;\n        this.reader = reader;\n        this.dictionary = dict;\n        this.genomeLocParser = genomeLocParser;\n        this.codec = codec;\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create the index in memory, given the input file and feature codec\n     * @param inputFile the input file\n     * @param codec the codec\n     * @return a LinearIndex, given the file location\n     * @throws IOException when unable to create the index in memory\n     */\n    private Index createIndexInMemory(File inputFile, FeatureCodec codec) {\n        // this can take a while, let them know what we're doing\n        logger.info(\"Creating Tribble index in memory for file \" + inputFile);\n        Index idx = IndexFactory.createIndex(inputFile, codec, IndexFactory.IndexBalanceApproach.FOR_SEEK_TIME);\n        validateAndUpdateIndexSequenceDictionary(inputFile, idx, dict);\n        return idx;\n    }","id":76581,"modified_method":"/**\n     * create the index in memory, given the input file and feature codec\n     * @param inputFile the input file\n     * @param codec the codec\n     * @return a LinearIndex, given the file location\n     * @throws IOException when unable to create the index in memory\n     */\n    private Index createIndexInMemory(File inputFile, FeatureCodec codec) {\n        // this can take a while, let them know what we're doing\n        logger.info(\"Creating Tribble index in memory for file \" + inputFile);\n        Index idx = IndexFactory.createDynamicIndex(inputFile, codec, IndexFactory.IndexBalanceApproach.FOR_SEEK_TIME);\n        validateAndUpdateIndexSequenceDictionary(inputFile, idx, dict);\n        return idx;\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create a RMDTrack of the specified type\n     *\n     * @param fileDescriptor a description of the type of track to build.\n     *\n     * @return an instance of the track\n     */\n    public RMDTrack createInstanceOfTrack(RMDTriplet fileDescriptor) {\n        String name = fileDescriptor.getName();\n        File inputFile = new File(fileDescriptor.getFile());\n\n        FeatureManager.FeatureDescriptor descriptor = getFeatureManager().getByTriplet(fileDescriptor);\n        if (descriptor == null)\n            throw new UserException.BadArgumentValue(\"-B\",fileDescriptor.getType());\n\n        // return a feature reader track\n        Pair<FeatureSource, SAMSequenceDictionary> pair;\n        if (inputFile.getAbsolutePath().endsWith(\".gz\"))\n            pair = createTabixIndexedFeatureSource(descriptor, name, inputFile);\n        else\n            pair = getFeatureSource(descriptor, name, inputFile, fileDescriptor.getStorageType());\n        if (pair == null) throw new UserException.CouldNotReadInputFile(inputFile, \"Unable to make the feature reader for input file\");\n        return new RMDTrack(descriptor.getCodecClass(), name, inputFile, pair.first, pair.second, genomeLocParser, createCodec(descriptor, name));\n    }","id":76582,"modified_method":"/**\n     * create a RMDTrack of the specified type\n     *\n     * @param fileDescriptor a description of the type of track to build.\n     *\n     * @return an instance of the track\n     */\n    public RMDTrack createInstanceOfTrack(RMDTriplet fileDescriptor) {\n        String name = fileDescriptor.getName();\n        File inputFile = new File(fileDescriptor.getFile());\n\n        FeatureManager.FeatureDescriptor descriptor = getFeatureManager().getByTriplet(fileDescriptor);\n        if (descriptor == null)\n            throw new UserException.BadArgumentValue(\"-B\",fileDescriptor.getType());\n\n        // return a feature reader track\n        Pair<AbstractFeatureReader, SAMSequenceDictionary> pair;\n        if (inputFile.getAbsolutePath().endsWith(\".gz\"))\n            pair = createTabixIndexedFeatureSource(descriptor, name, inputFile);\n        else\n            pair = getFeatureSource(descriptor, name, inputFile, fileDescriptor.getStorageType());\n        if (pair == null) throw new UserException.CouldNotReadInputFile(inputFile, \"Unable to make the feature reader for input file\");\n        return new RMDTrack(descriptor.getCodecClass(), name, inputFile, pair.first, pair.second, genomeLocParser, createCodec(descriptor, name));\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create a feature source object given:\n     * @param descriptor the FeatureDescriptor describing the FeatureCodec we want to create\n     * @param name the name of the codec\n     * @param inputFile the tribble file to parse\n     * @param storageType How the RMD is streamed into the input file.\n     * @return the input file as a FeatureReader\n     */\n    private Pair<FeatureSource, SAMSequenceDictionary> getFeatureSource(FeatureManager.FeatureDescriptor descriptor,\n                                                                        String name,\n                                                                        File inputFile,\n                                                                        RMDStorageType storageType) {\n        // Feature source and sequence dictionary to use as the ultimate reference\n        FeatureSource featureSource = null;\n        SAMSequenceDictionary sequenceDictionary = null;\n\n        // Detect whether or not this source should be indexed.\n        boolean canBeIndexed = (storageType == RMDStorageType.FILE);\n\n        if(canBeIndexed) {\n            try {\n                Index index = loadIndex(inputFile, createCodec(descriptor, name));\n                try { logger.info(String.format(\"  Index for %s has size in bytes %d\", inputFile, Sizeof.getObjectGraphSize(index))); }\n                catch (ReviewedStingException e) { }\n\n                sequenceDictionary = IndexDictionaryUtils.getSequenceDictionaryFromProperties(index);\n\n                // if we don't have a dictionary in the Tribble file, and we've set a dictionary for this builder, set it in the file if they match\n                if (sequenceDictionary.size() == 0 && dict != null) {\n                    File indexFile = Tribble.indexFile(inputFile);\n                    validateAndUpdateIndexSequenceDictionary(inputFile, index, dict);\n                    try { // re-write the index\n                        writeIndexToDisk(index,indexFile,new FSLockWithShared(indexFile));\n                    } catch (IOException e) {\n                        logger.warn(\"Unable to update index with the sequence dictionary for file \" + indexFile + \"; this will not effect your run of the GATK\");\n                    }\n\n                    sequenceDictionary = IndexDictionaryUtils.getSequenceDictionaryFromProperties(index);\n                }\n\n                if ( MEASURE_TRIBBLE_QUERY_PERFORMANCE )\n                    featureSource = new PerformanceLoggingFeatureSource(inputFile.getAbsolutePath(), index, createCodec(descriptor, name));\n                else\n                    featureSource = new BasicFeatureSource(inputFile.getAbsolutePath(), index, createCodec(descriptor, name));\n            }\n            catch (TribbleException e) {\n                throw new UserException(e.getMessage());\n            }\n            catch (IOException e) {\n                throw new UserException.CouldNotCreateOutputFile(inputFile, \"unable to write Tribble index\", e);\n            }\n        }\n        else {\n            featureSource = BasicFeatureSource.getFeatureSource(inputFile.getAbsolutePath(),createCodec(descriptor, name),false);\n        }\n\n        return new Pair<FeatureSource,SAMSequenceDictionary>(featureSource,sequenceDictionary);\n    }","id":76583,"modified_method":"/**\n     * create a feature source object given:\n     * @param descriptor the FeatureDescriptor describing the FeatureCodec we want to create\n     * @param name the name of the codec\n     * @param inputFile the tribble file to parse\n     * @param storageType How the RMD is streamed into the input file.\n     * @return the input file as a FeatureReader\n     */\n    private Pair<AbstractFeatureReader, SAMSequenceDictionary> getFeatureSource(FeatureManager.FeatureDescriptor descriptor,\n                                                                        String name,\n                                                                        File inputFile,\n                                                                        RMDStorageType storageType) {\n        // Feature source and sequence dictionary to use as the ultimate reference\n        AbstractFeatureReader featureSource = null;\n        SAMSequenceDictionary sequenceDictionary = null;\n\n        // Detect whether or not this source should be indexed.\n        boolean canBeIndexed = (storageType == RMDStorageType.FILE);\n\n        if(canBeIndexed) {\n            try {\n                Index index = loadIndex(inputFile, createCodec(descriptor, name));\n                try { logger.info(String.format(\"  Index for %s has size in bytes %d\", inputFile, Sizeof.getObjectGraphSize(index))); }\n                catch (ReviewedStingException e) { }\n\n                sequenceDictionary = IndexDictionaryUtils.getSequenceDictionaryFromProperties(index);\n\n                // if we don't have a dictionary in the Tribble file, and we've set a dictionary for this builder, set it in the file if they match\n                if (sequenceDictionary.size() == 0 && dict != null) {\n                    File indexFile = Tribble.indexFile(inputFile);\n                    validateAndUpdateIndexSequenceDictionary(inputFile, index, dict);\n                    try { // re-write the index\n                        writeIndexToDisk(index,indexFile,new FSLockWithShared(indexFile));\n                    } catch (IOException e) {\n                        logger.warn(\"Unable to update index with the sequence dictionary for file \" + indexFile + \"; this will not effect your run of the GATK\");\n                    }\n\n                    sequenceDictionary = IndexDictionaryUtils.getSequenceDictionaryFromProperties(index);\n                }\n\n                featureSource = AbstractFeatureReader.getFeatureReader(inputFile.getAbsolutePath(), createCodec(descriptor, name), index);\n            }\n            catch (TribbleException e) {\n                throw new UserException(e.getMessage());\n            }\n            catch (IOException e) {\n                throw new UserException.CouldNotCreateOutputFile(inputFile, \"unable to write Tribble index\", e);\n            }\n        }\n        else {\n            featureSource = AbstractFeatureReader.getFeatureReader(inputFile.getAbsolutePath(), createCodec(descriptor, name), false);\n        }\n\n        return new Pair<AbstractFeatureReader,SAMSequenceDictionary>(featureSource,sequenceDictionary);\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create a feature reader, without assuming there exists an index.  This code assumes the feature\n     * reader of the appropriate type will figure out what the right index type is, and determine if it\n     * exists.\n     *\n     * @param descriptor the FeatureDescriptor describing the FeatureCodec we want to create\n     * @param name the name of the track\n     * @param inputFile the file to load\n     * @return a feature reader implementation\n     */\n    private Pair<FeatureSource, SAMSequenceDictionary> createTabixIndexedFeatureSource(FeatureManager.FeatureDescriptor descriptor, String name, File inputFile) {\n        // we might not know the index type, try loading with the default reader constructor\n        logger.info(\"Attempting to blindly load \" + inputFile + \" as a tabix indexed file\");\n        try {\n            return new Pair<FeatureSource, SAMSequenceDictionary>(BasicFeatureSource.getFeatureSource(inputFile.getAbsolutePath(), createCodec(descriptor, name)),null);\n        } catch (TribbleException e) {\n            throw new UserException(e.getMessage(), e);\n        }\n    }","id":76584,"modified_method":"/**\n     * create a feature reader, without assuming there exists an index.  This code assumes the feature\n     * reader of the appropriate type will figure out what the right index type is, and determine if it\n     * exists.\n     *\n     * @param descriptor the FeatureDescriptor describing the FeatureCodec we want to create\n     * @param name the name of the track\n     * @param inputFile the file to load\n     * @return a feature reader implementation\n     */\n    private Pair<AbstractFeatureReader, SAMSequenceDictionary> createTabixIndexedFeatureSource(FeatureManager.FeatureDescriptor descriptor, String name, File inputFile) {\n        // we might not know the index type, try loading with the default reader constructor\n        logger.info(\"Attempting to blindly load \" + inputFile + \" as a tabix indexed file\");\n        try {\n            return new Pair<AbstractFeatureReader, SAMSequenceDictionary>(AbstractFeatureReader.getFeatureReader(inputFile.getAbsolutePath(), createCodec(descriptor, name)),null);\n        } catch (TribbleException e) {\n            throw new UserException(e.getMessage(), e);\n        }\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void mergeInto(VCFWriterStorage target) {\n        try {\n            String sourceFilePath = file.getAbsolutePath();\n            String targetFilePath = target.file != null ? target.file.getAbsolutePath() : \"/dev/stdin\";\n            logger.debug(String.format(\"Merging %s into %s\",sourceFilePath,targetFilePath));\n            BasicFeatureSource<VariantContext> source = BasicFeatureSource.getFeatureSource(file.getAbsolutePath(), new VCFCodec(), false);\n            \n            for ( VariantContext vc : source.iterator() ) {\n                target.writer.add(vc);\n            }\n\n            source.close();\n        } catch (IOException e) {\n            throw new UserException.CouldNotReadInputFile(file, \"Error reading file in VCFWriterStorage: \", e);\n        }\n    }","id":76585,"modified_method":"public void mergeInto(VCFWriterStorage target) {\n        try {\n            String sourceFilePath = file.getAbsolutePath();\n            String targetFilePath = target.file != null ? target.file.getAbsolutePath() : \"/dev/stdin\";\n            logger.debug(String.format(\"Merging %s into %s\",sourceFilePath,targetFilePath));\n            AbstractFeatureReader<VariantContext> source = AbstractFeatureReader.getFeatureReader(file.getAbsolutePath(), new VCFCodec(), false);\n            \n            for ( VariantContext vc : source.iterator() ) {\n                target.writer.add(vc);\n            }\n\n            source.close();\n        } catch (IOException e) {\n            throw new UserException.CouldNotReadInputFile(file, \"Error reading file in VCFWriterStorage: \", e);\n        }\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static void assertOnDiskIndexEqualToNewlyCreatedIndex(final File indexFile, final String name, final File resultFile) {\n        System.out.println(\"Verifying on-the-fly index \" + indexFile + \" for test \" + name + \" using file \" + resultFile);\n        Index indexFromOutputFile = IndexFactory.createIndex(resultFile, new VCFCodec());\n        Index dynamicIndex = IndexFactory.loadIndex(indexFile.getAbsolutePath());\n\n        if ( ! indexFromOutputFile.equalsIgnoreProperties(dynamicIndex) ) {\n            Assert.fail(String.format(\"Index on disk from indexing on the fly not equal to the index created after the run completed.  FileIndex %s vs. on-the-fly %s%n\",\n                    indexFromOutputFile.getProperties(),\n                    dynamicIndex.getProperties()));\n        }\n    }","id":76586,"modified_method":"public static void assertOnDiskIndexEqualToNewlyCreatedIndex(final File indexFile, final String name, final File resultFile) {\n        System.out.println(\"Verifying on-the-fly index \" + indexFile + \" for test \" + name + \" using file \" + resultFile);\n        Index indexFromOutputFile = IndexFactory.createDynamicIndex(resultFile, new VCFCodec());\n        Index dynamicIndex = IndexFactory.loadIndex(indexFile.getAbsolutePath());\n\n        if ( ! indexFromOutputFile.equalsIgnoreProperties(dynamicIndex) ) {\n            Assert.fail(String.format(\"Index on disk from indexing on the fly not equal to the index created after the run completed.  FileIndex %s vs. on-the-fly %s%n\",\n                    indexFromOutputFile.getProperties(),\n                    dynamicIndex.getProperties()));\n        }\n    }","commit_id":"58c470a6c5a23d626b582d89dc83724a42d4d2c1","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create a feature reader, without assuming there exists an index.  This code assumes the feature\n     * reader of the appropriate type will figure out what the right index type is, and determine if it\n     * exists.\n     *\n     * @param targetClass the codec class type\n     * @param name the name of the track\n     * @param inputFile the file to load\n     * @return a feature reader implementation\n     */\n    private Pair<BasicFeatureSource, SAMSequenceDictionary> createBasicFeatureSourceNoAssumedIndex(Class targetClass, String name, File inputFile) {\n        // we might not know the index type, try loading with the default reader constructor\n        logger.info(\"Attempting to blindly load \" + inputFile + \" as a tabix indexed file\");\n        try {\n            return new Pair<BasicFeatureSource, SAMSequenceDictionary>(new BasicFeatureSource(inputFile.getAbsolutePath(), createCodec(targetClass, name)),null);\n        } catch (IOException e) {\n            throw new StingException(\"Unable to create feature reader from file \" + inputFile);\n        }\n    }","id":76587,"modified_method":"/**\n     * create a feature reader, without assuming there exists an index.  This code assumes the feature\n     * reader of the appropriate type will figure out what the right index type is, and determine if it\n     * exists.\n     *\n     * @param targetClass the codec class type\n     * @param name the name of the track\n     * @param inputFile the file to load\n     * @return a feature reader implementation\n     */\n    private Pair<BasicFeatureSource, SAMSequenceDictionary> createBasicFeatureSourceNoAssumedIndex(Class targetClass, String name, File inputFile) {\n        // we might not know the index type, try loading with the default reader constructor\n        logger.info(\"Attempting to blindly load \" + inputFile + \" as a tabix indexed file\");\n        try {\n            return new Pair<BasicFeatureSource, SAMSequenceDictionary>(BasicFeatureSource.getFeatureSource(inputFile.getAbsolutePath(), createCodec(targetClass, name)),null);\n        } catch (IOException e) {\n            throw new StingException(\"Unable to create feature reader from file \" + inputFile);\n        }\n    }","commit_id":"69d92fab4fd6a428b1c30bee2f00524640db8be7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String process(final CrawlEntry entry, final String parserMode) {\r\n        // load a resource, store it to htcache and push queue entry to switchboard queue\r\n        // returns null if everything went fine, a fail reason string if a problem occurred\r\n        indexDocumentMetadata h;\r\n        try {\r\n            entry.setStatus(\"loading\", serverProcessorJob.STATUS_RUNNING);\r\n            h = load(entry, parserMode);\r\n            assert h != null;\r\n            entry.setStatus(\"loaded\", serverProcessorJob.STATUS_RUNNING);\r\n            final boolean stored = sb.htEntryStoreProcess(h);\r\n            entry.setStatus(\"stored-\" + ((stored) ? \"ok\" : \"fail\"), serverProcessorJob.STATUS_FINISHED);\r\n            return (stored) ? null : \"not stored\";\r\n        } catch (IOException e) {\r\n            entry.setStatus(\"error\", serverProcessorJob.STATUS_FINISHED);\r\n            log.logWarning(\"problem loading \" + entry.url().toString() + \": \" + e.getMessage());\r\n            return \"load error - \" + e.getMessage();\r\n        }\r\n    }","id":76588,"modified_method":"public String process(final CrawlEntry entry, final String parserMode) {\r\n        // load a resource, store it to htcache and push queue entry to switchboard queue\r\n        // returns null if everything went fine, a fail reason string if a problem occurred\r\n        indexDocumentMetadata h;\r\n        try {\r\n            entry.setStatus(\"loading\", serverProcessorJob.STATUS_RUNNING);\r\n            h = load(entry, parserMode);\r\n            assert h != null;\r\n            entry.setStatus(\"loaded\", serverProcessorJob.STATUS_RUNNING);\r\n            final boolean stored = sb.htEntryStoreProcess(h);\r\n            entry.setStatus(\"stored-\" + ((stored) ? \"ok\" : \"fail\"), serverProcessorJob.STATUS_FINISHED);\r\n            return (stored) ? null : \"not stored\";\r\n        } catch (IOException e) {\r\n            entry.setStatus(\"error\", serverProcessorJob.STATUS_FINISHED);\r\n            if (log.isFine()) log.logFine(\"problem loading \" + entry.url().toString() + \": \" + e.getMessage());\r\n            return \"load error - \" + e.getMessage();\r\n        }\r\n    }","commit_id":"91af1053734e515f8a8e961568e15009eec4a2a9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static long[] queryRWICount(final Seed target, final String wordHash) {\r\n        if (target == null) return new long[] {-1, -1};\r\n        \r\n        // prepare request\r\n        final String salt = crypt.randomSalt();\r\n\r\n        // send request\r\n        try {\r\n            final Map<String, ContentBody> parts = basicRequestParts(Switchboard.getSwitchboard(), target.hash, salt);\r\n            parts.put(\"object\", UTF8.StringBody(\"rwicount\"));\r\n            parts.put(\"ttl\", UTF8.StringBody(\"0\"));\r\n            parts.put(\"env\", UTF8.StringBody(wordHash));\r\n            final byte[] content = postToFile(target, \"query.html\", parts, 6000);\r\n            final Map<String, String> result = FileUtils.table(content);\r\n            if (result == null || result.isEmpty()) return new long[] {-1, -1};\r\n            final String resp = result.get(\"response\");\r\n            if (resp == null) return new long[] {-1, -1};\r\n            String magic = result.get(\"magic\");\r\n            if (magic == null) magic = \"0\";\r\n            try {\r\n                return new long[] {Long.parseLong(resp), Long.parseLong(magic)};\r\n            } catch ( final NumberFormatException e ) {\r\n                return new long[] {-1, -1};\r\n            }\r\n        } catch ( final Exception e ) {\r\n            Network.log.logWarning(\"yacyClient.queryRWICount error:\" + e.getMessage());\r\n            return new long[] {-1, -1};\r\n        }\r\n    }","id":76589,"modified_method":"public static long[] queryRWICount(final Seed target, final String wordHash) {\r\n        if (target == null) return new long[] {-1, -1};\r\n        \r\n        // prepare request\r\n        final String salt = crypt.randomSalt();\r\n\r\n        // send request\r\n        try {\r\n            final Map<String, ContentBody> parts = basicRequestParts(Switchboard.getSwitchboard(), target.hash, salt);\r\n            parts.put(\"object\", UTF8.StringBody(\"rwicount\"));\r\n            parts.put(\"ttl\", UTF8.StringBody(\"0\"));\r\n            parts.put(\"env\", UTF8.StringBody(wordHash));\r\n            final byte[] content = postToFile(target, \"query.html\", parts, 6000);\r\n            final Map<String, String> result = FileUtils.table(content);\r\n            if (result == null || result.isEmpty()) return new long[] {-1, -1};\r\n            final String resp = result.get(\"response\");\r\n            if (resp == null) return new long[] {-1, -1};\r\n            String magic = result.get(\"magic\");\r\n            if (magic == null) magic = \"0\";\r\n            try {\r\n                return new long[] {Long.parseLong(resp), Long.parseLong(magic)};\r\n            } catch ( final NumberFormatException e ) {\r\n                return new long[] {-1, -1};\r\n            }\r\n        } catch ( final Exception e ) {\r\n            if (Network.log.isFine()) Network.log.logFine(\"yacyClient.queryRWICount error:\" + e.getMessage());\r\n            return new long[] {-1, -1};\r\n        }\r\n    }","commit_id":"1eb9626ccaa16f2407f01139e9cf6399dbf9f08d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) throws FileNotFoundException, IOException {\n\n        // return variable that accumulates replacements\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        final File langPath = new File(sb.getAppPath(\"locale.source\", \"locales\").getAbsolutePath());\n        String lang = env.getConfig(\"locale.language\", \"default\");\n\n        final int authentication = sb.adminAuthenticated(header);\n        if (authentication < 2) {\n            // must authenticate\n        \tprop.authenticationRequired();\n            return prop;\n        }\n\n        // store this call as api call\n        if (post != null && post.containsKey(\"set\")) {\n            sb.tables.recordAPICall(post, \"ConfigBasic.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"basic settings\");\n        }\n\n        //boolean doPeerPing = false;\n        if ((sb.peers.mySeed().isVirgin()) || (sb.peers.mySeed().isJunior())) {\n            InstantBusyThread.oneTimeJob(sb.yc, \"peerPing\", 0);\n            //doPeerPing = true;\n        }\n\n        // language settings\n        if (post != null && post.containsKey(\"language\")  && !lang.equals(post.get(\"language\", \"default\")) &&\n                (Translator.changeLang(env, langPath, post.get(\"language\", \"default\") + \".lng\"))) {\n            prop.put(\"changedLanguage\", \"1\");\n        }\n\n        // peer name settings\n        final String peerName = (post == null) ? sb.peers.mySeed().getName() : post.get(\"peername\", \"\");\n\n        // port settings\n        final long port;\n        if (post != null && post.getInt(\"port\", 0) > 1023) {\n            port = post.getLong(\"port\", 8090);\n        } else {\n            port = env.getConfigLong(\"port\", 8090); //this allows a low port, but it will only get one, if the user edits the config himself.\n        }\n\n        // check if peer name already exists\n        final Seed oldSeed = sb.peers.lookupByName(peerName);\n        if (oldSeed == null &&\n            !peerName.equals(sb.peers.mySeed().getName()) &&\n            Pattern.compile(\"[A-Za-z0-9\\\\-_]{3,80}\").matcher(peerName).matches()) {\n            sb.peers.setMyName(peerName);\n            sb.peers.saveMySeed();\n        }\n\n        // UPnP config\n        final boolean upnp;\n        if (post != null && post.containsKey(\"port\")) { // hack to allow checkbox\n            upnp = post.containsKey(\"enableUpnp\");\n            if (upnp && !sb.getConfigBool(SwitchboardConstants.UPNP_ENABLED, false)) {\n                UPnP.addPortMapping();\n            }\n            sb.setConfig(SwitchboardConstants.UPNP_ENABLED, upnp);\n            if (!upnp) {\n                UPnP.deletePortMapping();\n            }\n        } else {\n            upnp = false;\n        }\n\n        // check port\n        final boolean reconnect;\n        if (!(env.getConfigLong(\"port\", port) == port)) {\n            // validate port\n            final serverCore theServerCore = (serverCore) env.getThread(\"10_httpd\");\n            env.setConfig(\"port\", port);\n\n            // redirect the browser to the new port\n            reconnect = true;\n\n            // renew upnp port mapping\n            if (upnp) {\n                UPnP.addPortMapping();\n            }\n\n            String host = null;\n            if (header.containsKey(HeaderFramework.HOST)) {\n                host = header.get(HeaderFramework.HOST);\n                final int idx = host.indexOf(':',0);\n                if (idx != -1) host = host.substring(0,idx);\n            } else {\n                host = Domains.myPublicLocalIP().getHostAddress();\n            }\n\n            prop.put(\"reconnect\", \"1\");\n            prop.put(\"reconnect_host\", host);\n            prop.put(\"nextStep_host\", host);\n            prop.put(\"reconnect_port\", port);\n            prop.put(\"nextStep_port\", port);\n            prop.put(\"reconnect_sslSupport\", theServerCore.withSSL() ? \"1\" : \"0\");\n            prop.put(\"nextStep_sslSupport\", theServerCore.withSSL() ? \"1\" : \"0\");\n\n            // generate new shortcut (used for Windows)\n            //yacyAccessible.setNewPortBat(Integer.parseInt(port));\n            //yacyAccessible.setNewPortLink(Integer.parseInt(port));\n\n            // force reconnection in 7 seconds\n            theServerCore.reconnect(7000);\n        } else {\n            reconnect = false;\n            prop.put(\"reconnect\", \"0\");\n        }\n\n        // set a use case\n        String networkName = sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\n        if (post != null && post.containsKey(\"usecase\")) {\n            if (\"freeworld\".equals(post.get(\"usecase\", \"\")) && !\"freeworld\".equals(networkName)) {\n                // switch to freeworld network\n                sb.switchNetwork(\"defaults/yacy.network.freeworld.unit\");\n                // switch to p2p mode\n                sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, true);\n                sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true);\n                // set default behavior for search verification\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY, \"iffresh\"); // nocache,iffresh,ifexist,cacheonly,false\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY_DELETE, \"true\");\n            }\n            if (\"portal\".equals(post.get(\"usecase\", \"\")) && !\"webportal\".equals(networkName)) {\n                // switch to webportal network\n                sb.switchNetwork(\"defaults/yacy.network.webportal.unit\");\n                // switch to robinson mode\n                sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, false);\n                sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false);\n                // set default behavior for search verification\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY, \"ifexist\"); // nocache,iffresh,ifexist,cacheonly,false\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY_DELETE, \"false\");\n            }\n            if (\"intranet\".equals(post.get(\"usecase\", \"\")) && !\"intranet\".equals(networkName)) {\n                // switch to intranet network\n                sb.switchNetwork(\"defaults/yacy.network.intranet.unit\");\n                // switch to p2p mode: enable ad-hoc networks between intranet users\n                sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, false);\n                sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false);\n                // set default behavior for search verification\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY, \"cacheonly\"); // nocache,iffresh,ifexist,cacheonly,false\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY_DELETE, \"false\");\n            }\n            if (\"intranet\".equals(post.get(\"usecase\", \"\"))) {\n                final String repositoryPath = post.get(\"repositoryPath\", \"/DATA/HTROOT/repository\");\n                final File repository = ((repositoryPath.length() > 0 && repositoryPath.charAt(0) == '/') || (repositoryPath.length() > 1 && repositoryPath.charAt(1) == ':')) ? new File(repositoryPath) : new File(sb.getDataPath(), repositoryPath);\n                if (repository.exists() && repository.isDirectory()) {\n                \tsb.setConfig(\"repositoryPath\", repositoryPath);\n                }\n            }\n        }\n\n        networkName = sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\n        if (\"freeworld\".equals(networkName)) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_freeworldChecked\", 1);\n        } else if (\"webportal\".equals(networkName)) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_portalChecked\", 1);\n        } else if (\"intranet\".equals(networkName)) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_intranetChecked\", 1);\n        } else {\n            prop.put(\"setUseCase\", 0);\n        }\n        prop.put(\"setUseCase_port\", port);\n        prop.put(\"setUseCase_repositoryPath\", sb.getConfig(\"repositoryPath\", \"/DATA/HTROOT/repository\"));\n\n        // check if values are proper\n        final boolean properPassword = (sb.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0) || sb.getConfigBool(\"adminAccountForLocalhost\", false);\n        final boolean properName = (sb.peers.mySeed().getName().length() >= 3) && (!(Seed.isDefaultPeerName(sb.peers.mySeed().getName())));\n        final boolean properPort = (sb.peers.mySeed().isSenior()) || (sb.peers.mySeed().isPrincipal());\n\n        if ((env.getConfig(SwitchboardConstants.BROWSER_DEFAULT, \"\").startsWith(\"ConfigBasic.html,\"))) {\n            env.setConfig(SwitchboardConstants.BROWSER_DEFAULT, env.getConfig(SwitchboardConstants.BROWSER_DEFAULT, \"\").substring(17));\n            env.setConfig(\"browserPopUpPage\", \"Status.html\");\n            HTTPDFileHandler.initDefaultPath();\n        }\n\n        prop.put(\"statusName\", properName ? \"1\" : \"0\");\n        prop.put(\"statusPort\", properPort ? \"1\" : \"0\");\n        if (reconnect) {\n            prop.put(\"nextStep\", NEXTSTEP_RECONNECT);\n        } else if (!properName) {\n            prop.put(\"nextStep\", NEXTSTEP_PEERNAME);\n        } else if (!properPassword) {\n            prop.put(\"nextStep\", NEXTSTEP_PWD);\n        } else if (!properPort) {\n            prop.put(\"nextStep\", NEXTSTEP_PEERPORT);\n        } else {\n            prop.put(\"nextStep\", NEXTSTEP_FINISHED);\n        }\n\n        final boolean upnp_enabled = env.getConfigBool(SwitchboardConstants.UPNP_ENABLED, false);\n        prop.put(\"upnp\", \"1\");\n        prop.put(\"upnp_enabled\", upnp_enabled ? \"1\" : \"0\");\n        if (upnp_enabled) {\n            prop.put(\"upnp_success\", (UPnP.getMappedPort() > 0) ? \"2\" : \"1\");\n        }\n        else {\n            prop.put(\"upnp_success\", \"0\");\n        }\n\n        // set default values\n        prop.putHTML(\"defaultName\", sb.peers.mySeed().getName());\n        prop.putHTML(\"defaultPort\", env.getConfig(\"port\", \"8090\"));\n        lang = env.getConfig(\"locale.language\", \"default\"); // re-assign lang, may have changed\n        prop.put(\"lang_de\", \"0\");\n        prop.put(\"lang_fr\", \"0\");\n        prop.put(\"lang_cn\", \"0\");\n        prop.put(\"lang_ru\", \"0\");\n        prop.put(\"lang_uk\", \"0\");\n        prop.put(\"lang_en\", \"0\");\n        if (\"default\".equals(lang)) {\n            prop.put(\"lang_en\", \"1\");\n        } else {\n            prop.put(\"lang_\" + lang, \"1\");\n        }\n        return prop;\n    }","id":76590,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) throws FileNotFoundException, IOException {\n\n        // return variable that accumulates replacements\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        final File langPath = new File(sb.getAppPath(\"locale.source\", \"locales\").getAbsolutePath());\n        String lang = env.getConfig(\"locale.language\", \"default\");\n\n        final int authentication = sb.adminAuthenticated(header);\n        if (authentication < 2) {\n            // must authenticate\n        \tprop.authenticationRequired();\n            return prop;\n        }\n\n        // store this call as api call\n        if (post != null && post.containsKey(\"set\")) {\n            sb.tables.recordAPICall(post, \"ConfigBasic.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"basic settings\");\n        }\n\n        //boolean doPeerPing = false;\n        if ((sb.peers.mySeed().isVirgin()) || (sb.peers.mySeed().isJunior())) {\n            InstantBusyThread.oneTimeJob(sb.yc, \"peerPing\", 0);\n            //doPeerPing = true;\n        }\n\n        // language settings\n        if (post != null && post.containsKey(\"language\")  && !lang.equals(post.get(\"language\", \"default\")) &&\n                (Translator.changeLang(env, langPath, post.get(\"language\", \"default\") + \".lng\"))) {\n            prop.put(\"changedLanguage\", \"1\");\n        }\n\n        // peer name settings\n        String peerName = (post == null) ? sb.peers.mySeed().getName() : post.get(\"peername\", \"\");\n        if (peerName != null) peerName = peerName.replace(' ', '-');\n        \n        // port settings\n        final long port;\n        if (post != null && post.getInt(\"port\", 0) > 1023) {\n            port = post.getLong(\"port\", 8090);\n        } else {\n            port = env.getConfigLong(\"port\", 8090); //this allows a low port, but it will only get one, if the user edits the config himself.\n        }\n\n        // check if peer name already exists\n        final Seed oldSeed = sb.peers.lookupByName(peerName);\n        if (oldSeed == null &&\n            !peerName.equals(sb.peers.mySeed().getName()) &&\n            Pattern.compile(\"[A-Za-z0-9\\\\-_]{3,80}\").matcher(peerName).matches()) {\n            sb.peers.setMyName(peerName);\n            sb.peers.saveMySeed();\n        }\n\n        // UPnP config\n        final boolean upnp;\n        if (post != null && post.containsKey(\"port\")) { // hack to allow checkbox\n            upnp = post.containsKey(\"enableUpnp\");\n            if (upnp && !sb.getConfigBool(SwitchboardConstants.UPNP_ENABLED, false)) {\n                UPnP.addPortMapping();\n            }\n            sb.setConfig(SwitchboardConstants.UPNP_ENABLED, upnp);\n            if (!upnp) {\n                UPnP.deletePortMapping();\n            }\n        } else {\n            upnp = false;\n        }\n\n        // check port\n        final boolean reconnect;\n        if (!(env.getConfigLong(\"port\", port) == port)) {\n            // validate port\n            final serverCore theServerCore = (serverCore) env.getThread(\"10_httpd\");\n            env.setConfig(\"port\", port);\n\n            // redirect the browser to the new port\n            reconnect = true;\n\n            // renew upnp port mapping\n            if (upnp) {\n                UPnP.addPortMapping();\n            }\n\n            String host = null;\n            if (header.containsKey(HeaderFramework.HOST)) {\n                host = header.get(HeaderFramework.HOST);\n                final int idx = host.indexOf(':',0);\n                if (idx != -1) host = host.substring(0,idx);\n            } else {\n                host = Domains.myPublicLocalIP().getHostAddress();\n            }\n\n            prop.put(\"reconnect\", \"1\");\n            prop.put(\"reconnect_host\", host);\n            prop.put(\"nextStep_host\", host);\n            prop.put(\"reconnect_port\", port);\n            prop.put(\"nextStep_port\", port);\n            prop.put(\"reconnect_sslSupport\", theServerCore.withSSL() ? \"1\" : \"0\");\n            prop.put(\"nextStep_sslSupport\", theServerCore.withSSL() ? \"1\" : \"0\");\n\n            // generate new shortcut (used for Windows)\n            //yacyAccessible.setNewPortBat(Integer.parseInt(port));\n            //yacyAccessible.setNewPortLink(Integer.parseInt(port));\n\n            // force reconnection in 7 seconds\n            theServerCore.reconnect(7000);\n        } else {\n            reconnect = false;\n            prop.put(\"reconnect\", \"0\");\n        }\n\n        // set a use case\n        String networkName = sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\n        if (post != null && post.containsKey(\"usecase\")) {\n            if (\"freeworld\".equals(post.get(\"usecase\", \"\")) && !\"freeworld\".equals(networkName)) {\n                // switch to freeworld network\n                sb.switchNetwork(\"defaults/yacy.network.freeworld.unit\");\n                // switch to p2p mode\n                sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, true);\n                sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true);\n                // set default behavior for search verification\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY, \"iffresh\"); // nocache,iffresh,ifexist,cacheonly,false\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY_DELETE, \"true\");\n            }\n            if (\"portal\".equals(post.get(\"usecase\", \"\")) && !\"webportal\".equals(networkName)) {\n                // switch to webportal network\n                sb.switchNetwork(\"defaults/yacy.network.webportal.unit\");\n                // switch to robinson mode\n                sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, false);\n                sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false);\n                // set default behavior for search verification\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY, \"ifexist\"); // nocache,iffresh,ifexist,cacheonly,false\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY_DELETE, \"false\");\n            }\n            if (\"intranet\".equals(post.get(\"usecase\", \"\")) && !\"intranet\".equals(networkName)) {\n                // switch to intranet network\n                sb.switchNetwork(\"defaults/yacy.network.intranet.unit\");\n                // switch to p2p mode: enable ad-hoc networks between intranet users\n                sb.setConfig(SwitchboardConstants.INDEX_DIST_ALLOW, false);\n                sb.setConfig(SwitchboardConstants.INDEX_RECEIVE_ALLOW, false);\n                // set default behavior for search verification\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY, \"cacheonly\"); // nocache,iffresh,ifexist,cacheonly,false\n                sb.setConfig(SwitchboardConstants.SEARCH_VERIFY_DELETE, \"false\");\n            }\n            if (\"intranet\".equals(post.get(\"usecase\", \"\"))) {\n                final String repositoryPath = post.get(\"repositoryPath\", \"/DATA/HTROOT/repository\");\n                final File repository = ((repositoryPath.length() > 0 && repositoryPath.charAt(0) == '/') || (repositoryPath.length() > 1 && repositoryPath.charAt(1) == ':')) ? new File(repositoryPath) : new File(sb.getDataPath(), repositoryPath);\n                if (repository.exists() && repository.isDirectory()) {\n                \tsb.setConfig(\"repositoryPath\", repositoryPath);\n                }\n            }\n        }\n\n        networkName = sb.getConfig(SwitchboardConstants.NETWORK_NAME, \"\");\n        if (\"freeworld\".equals(networkName)) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_freeworldChecked\", 1);\n        } else if (\"webportal\".equals(networkName)) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_portalChecked\", 1);\n        } else if (\"intranet\".equals(networkName)) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_intranetChecked\", 1);\n        } else {\n            prop.put(\"setUseCase\", 0);\n        }\n        prop.put(\"setUseCase_port\", port);\n        prop.put(\"setUseCase_repositoryPath\", sb.getConfig(\"repositoryPath\", \"/DATA/HTROOT/repository\"));\n\n        // check if values are proper\n        final boolean properPassword = (sb.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0) || sb.getConfigBool(\"adminAccountForLocalhost\", false);\n        final boolean properName = (sb.peers.mySeed().getName().length() >= 3) && (!(Seed.isDefaultPeerName(sb.peers.mySeed().getName())));\n        final boolean properPort = (sb.peers.mySeed().isSenior()) || (sb.peers.mySeed().isPrincipal());\n\n        if ((env.getConfig(SwitchboardConstants.BROWSER_DEFAULT, \"\").startsWith(\"ConfigBasic.html,\"))) {\n            env.setConfig(SwitchboardConstants.BROWSER_DEFAULT, env.getConfig(SwitchboardConstants.BROWSER_DEFAULT, \"\").substring(17));\n            env.setConfig(\"browserPopUpPage\", \"Status.html\");\n            HTTPDFileHandler.initDefaultPath();\n        }\n\n        prop.put(\"statusName\", properName ? \"1\" : \"0\");\n        prop.put(\"statusPort\", properPort ? \"1\" : \"0\");\n        if (reconnect) {\n            prop.put(\"nextStep\", NEXTSTEP_RECONNECT);\n        } else if (!properName) {\n            prop.put(\"nextStep\", NEXTSTEP_PEERNAME);\n        } else if (!properPassword) {\n            prop.put(\"nextStep\", NEXTSTEP_PWD);\n        } else if (!properPort) {\n            prop.put(\"nextStep\", NEXTSTEP_PEERPORT);\n        } else {\n            prop.put(\"nextStep\", NEXTSTEP_FINISHED);\n        }\n\n        final boolean upnp_enabled = env.getConfigBool(SwitchboardConstants.UPNP_ENABLED, false);\n        prop.put(\"upnp\", \"1\");\n        prop.put(\"upnp_enabled\", upnp_enabled ? \"1\" : \"0\");\n        if (upnp_enabled) {\n            prop.put(\"upnp_success\", (UPnP.getMappedPort() > 0) ? \"2\" : \"1\");\n        }\n        else {\n            prop.put(\"upnp_success\", \"0\");\n        }\n\n        // set default values\n        prop.putHTML(\"defaultName\", sb.peers.mySeed().getName());\n        prop.putHTML(\"defaultPort\", env.getConfig(\"port\", \"8090\"));\n        lang = env.getConfig(\"locale.language\", \"default\"); // re-assign lang, may have changed\n        prop.put(\"lang_de\", \"0\");\n        prop.put(\"lang_fr\", \"0\");\n        prop.put(\"lang_cn\", \"0\");\n        prop.put(\"lang_ru\", \"0\");\n        prop.put(\"lang_uk\", \"0\");\n        prop.put(\"lang_en\", \"0\");\n        if (\"default\".equals(lang)) {\n            prop.put(\"lang_en\", \"1\");\n        } else {\n            prop.put(\"lang_\" + lang, \"1\");\n        }\n        return prop;\n    }","commit_id":"67f2866cd0cb95b2c72d46bad9ccdb7ab7a0b873","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Make some checks if crawl is valid and start it\r\n     *\r\n     * @param urlEntry\r\n     * @param profileHandle\r\n     * @param stats String for log prefixing\r\n     * @return\r\n     */\r\n    private void load(final Request urlEntry, final String stats, final String profileHandle) {\r\n        final CrawlProfile profile = this.sb.crawler.getActive(UTF8.getBytes(profileHandle));\r\n        if (profile != null) {\r\n\r\n            // check if the protocol is supported\r\n            final DigestURI url = urlEntry.url();\r\n            final String urlProtocol = url.getProtocol();\r\n            if (this.sb.loader.isSupportedProtocol(urlProtocol)) {\r\n                if (this.log.isFine()) {\r\n                    this.log.logFine(stats + \": URL=\" + urlEntry.url()\r\n                            + \", initiator=\" + ((urlEntry.initiator() == null) ? \"\" : ASCII.String(urlEntry.initiator()))\r\n                            + \", crawlOrder=\" + ((profile.remoteIndexing()) ? \"true\" : \"false\")\r\n                            + \", depth=\" + urlEntry.depth()\r\n                            + \", crawlDepth=\" + profile.depth()\r\n                            + \", must-match=\" + profile.urlMustMatchPattern().toString()\r\n                            + \", must-not-match=\" + profile.urlMustNotMatchPattern().toString()\r\n                            + \", permission=\" + ((this.sb.peers == null) ? \"undefined\" : (((this.sb.peers.mySeed().isSenior()) || (this.sb.peers.mySeed().isPrincipal())) ? \"true\" : \"false\")));\r\n                }\r\n\r\n                // work off one Crawl stack entry\r\n                if (urlEntry == null || urlEntry.url() == null) {\r\n                    this.log.logInfo(stats + \": urlEntry = null\");\r\n                } else {\r\n                \tnew Loader(urlEntry);\r\n                }\r\n\r\n            } else {\r\n                this.log.logSevere(\"Unsupported protocol in URL '\" + url.toString());\r\n            }\r\n        } else {\r\n            this.log.logWarning(stats + \": LOST PROFILE HANDLE '\" + urlEntry.profileHandle() + \"' for URL \" + urlEntry.url());\r\n        }\r\n    }","id":76591,"modified_method":"/**\r\n     * Make some checks if crawl is valid and start it\r\n     *\r\n     * @param urlEntry\r\n     * @param profileHandle\r\n     * @param stats String for log prefixing\r\n     * @return\r\n     */\r\n    private void load(final Request urlEntry, final String stats, final String profileHandle) {\r\n        final CrawlProfile profile = this.sb.crawler.getActive(UTF8.getBytes(profileHandle));\r\n        if (profile != null) {\r\n\r\n            // check if the protocol is supported\r\n            final DigestURI url = urlEntry.url();\r\n            final String urlProtocol = url.getProtocol();\r\n            if (this.sb.loader.isSupportedProtocol(urlProtocol)) {\r\n                if (this.log.isFine()) {\r\n                    this.log.logFine(stats + \": URL=\" + urlEntry.url()\r\n                            + \", initiator=\" + ((urlEntry.initiator() == null) ? \"\" : ASCII.String(urlEntry.initiator()))\r\n                            + \", crawlOrder=\" + ((profile.remoteIndexing()) ? \"true\" : \"false\")\r\n                            + \", depth=\" + urlEntry.depth()\r\n                            + \", crawlDepth=\" + profile.depth()\r\n                            + \", must-match=\" + profile.urlMustMatchPattern().toString()\r\n                            + \", must-not-match=\" + profile.urlMustNotMatchPattern().toString()\r\n                            + \", permission=\" + ((this.sb.peers == null) ? \"undefined\" : (((this.sb.peers.mySeed().isSenior()) || (this.sb.peers.mySeed().isPrincipal())) ? \"true\" : \"false\")));\r\n                }\r\n\r\n                // work off one Crawl stack entry\r\n                if (urlEntry == null || urlEntry.url() == null) {\r\n                    this.log.logInfo(stats + \": urlEntry = null\");\r\n                } else {\r\n                \tnew Loader(urlEntry);\r\n                }\r\n\r\n            } else {\r\n                this.log.logSevere(\"Unsupported protocol in URL '\" + url.toString());\r\n            }\r\n        } else {\r\n            if (this.log.isFine()) this.log.logFine(stats + \": LOST PROFILE HANDLE '\" + urlEntry.profileHandle() + \"' for URL \" + urlEntry.url());\r\n        }\r\n    }","commit_id":"67f2866cd0cb95b2c72d46bad9ccdb7ab7a0b873","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    public Document[] parse(final DigestURI location, final String mimeType,\n            final String charset, final InputStream source)\n            throws Parser.Failure, InterruptedException\n    {\n\n        try {\n            final SWF2HTML swf2html = new SWF2HTML();\n            String contents = \"\";\n            try {\n            \tcontents = swf2html.convertSWFToHTML(source);\n            } catch (final NegativeArraySizeException e) {\n                throw new Parser.Failure(e.getMessage(), location);\n            } catch (final IOException e) {\n                throw new Parser.Failure(e.getMessage(), location);\n            } catch (final Exception e) {\n                throw new Parser.Failure(e.getMessage(), location);\n            }\n            String url = null;\n            String urlnr = null;\n            final String linebreak = System.getProperty(\"line.separator\");\n            final String[] sections =  null;\n            final String abstrct = null;\n            //TreeSet images = null;\n            final Map<MultiProtocolURI, Properties> anchors = new HashMap<MultiProtocolURI, Properties>();\n            int urls = 0;\n            int urlStart = -1;\n            int urlEnd = 0;\n            int p0 = 0;\n\n            //getting rid of HTML-Tags\n            p0 = contents.indexOf(\"<html><body>\",0);\n            contents = contents.substring(p0+12);\n            p0 = contents.indexOf(\"<\/body><\/html>\",0);\n            contents = contents.substring(0,p0);\n\n            //extracting urls\n            while ((urlStart = contents.indexOf(\"http://\",urlEnd)) >= 0){\n                urlEnd = contents.indexOf(linebreak,urlStart);\n                url = contents.substring(urlStart,urlEnd);\n                urlnr = Integer.toString(++urls).toString();\n                final Properties p = new Properties();\n                p.put(\"name\", urlnr);\n                anchors.put(new MultiProtocolURI(url), p);\n                contents = contents.substring(0,urlStart)+contents.substring(urlEnd);\n            }\n\n           // As the result of parsing this function must return a plasmaParserDocument object\n            return new Document[]{new Document(\n                    location,     // url of the source document\n                    mimeType,     // the documents mime type\n                    \"UTF-8\",      // charset of the document text\n                    this,\n                    null,\n                    null,          //keywords\n                      ((contents.length() > 80)? contents.substring(0, 80):contents.trim()).\n                          replaceAll(\"\\r\\n\",\" \").\n                          replaceAll(\"\\n\",\" \").\n                          replaceAll(\"\\r\",\" \").\n                          replaceAll(\"\\t\",\" \"), // title\n                    \"\", // TODO: AUTHOR\n                    \"\",\n                    sections,     // an array of section headlines\n                    abstrct,     // an abstract\n                    0.0f, 0.0f,\n                    contents,     // the parsed document text\n                    anchors,      // a map of extracted anchors\n                    null,\n                    null,\n                    false)};      // a treeset of image URLs\n        } catch (final Exception e) {\n            if (e instanceof InterruptedException) throw (InterruptedException) e;\n\n            // if an unexpected error occures just log the error and raise a new Parser.Failure\n            final String errorMsg = \"Unable to parse the swf document '\" + location + \"':\" + e.getMessage();\n            AbstractParser.log.logSevere(errorMsg);\n            throw new Parser.Failure(errorMsg, location);\n        }\n    }","id":76592,"modified_method":"@Override\n    public Document[] parse(final DigestURI location, final String mimeType,\n            final String charset, final InputStream source)\n            throws Parser.Failure, InterruptedException\n    {\n\n        try {\n            final SWF2HTML swf2html = new SWF2HTML();\n            String contents = \"\";\n            try {\n            \tcontents = swf2html.convertSWFToHTML(source);\n            } catch (final NegativeArraySizeException e) {\n                throw new Parser.Failure(e.getMessage(), location);\n            } catch (final IOException e) {\n                throw new Parser.Failure(e.getMessage(), location);\n            } catch (final Exception e) {\n                throw new Parser.Failure(e.getMessage(), location);\n            }\n            String url = null;\n            String urlnr = null;\n            final String linebreak = System.getProperty(\"line.separator\");\n            final String[] sections =  null;\n            final String abstrct = null;\n            //TreeSet images = null;\n            final Map<MultiProtocolURI, Properties> anchors = new HashMap<MultiProtocolURI, Properties>();\n            int urls = 0;\n            int urlStart = -1;\n            int urlEnd = 0;\n            int p0 = 0;\n\n            //getting rid of HTML-Tags\n            p0 = contents.indexOf(\"<html><body>\",0);\n            contents = contents.substring(p0+12);\n            p0 = contents.indexOf(\"<\/body><\/html>\",0);\n            contents = contents.substring(0,p0);\n\n            //extracting urls\n            while ((urlStart = contents.indexOf(\"http://\",urlEnd)) >= 0){\n                urlEnd = contents.indexOf(linebreak,urlStart);\n                url = contents.substring(urlStart,urlEnd);\n                urlnr = Integer.toString(++urls).toString();\n                final Properties p = new Properties();\n                p.put(\"name\", urlnr);\n                anchors.put(new MultiProtocolURI(url), p);\n                contents = contents.substring(0,urlStart)+contents.substring(urlEnd);\n            }\n\n           // As the result of parsing this function must return a plasmaParserDocument object\n            return new Document[]{new Document(\n                    location,     // url of the source document\n                    mimeType,     // the documents mime type\n                    \"UTF-8\",      // charset of the document text\n                    this,\n                    null,\n                    null,          //keywords\n                      ((contents.length() > 80)? contents.substring(0, 80):contents.trim()).\n                          replaceAll(\"\\r\\n\",\" \").\n                          replaceAll(\"\\n\",\" \").\n                          replaceAll(\"\\r\",\" \").\n                          replaceAll(\"\\t\",\" \"), // title\n                    \"\", // TODO: AUTHOR\n                    \"\",\n                    sections,     // an array of section headlines\n                    abstrct,     // an abstract\n                    0.0f, 0.0f,\n                    contents,     // the parsed document text\n                    anchors,      // a map of extracted anchors\n                    null,\n                    null,\n                    false)};      // a treeset of image URLs\n        } catch (final Exception e) {\n            if (e instanceof InterruptedException) throw (InterruptedException) e;\n\n            // if an unexpected error occures just log the error and raise a new Parser.Failure\n            final String errorMsg = \"Unable to parse the swf document '\" + location + \"':\" + e.getMessage();\n            //AbstractParser.log.logSevere(errorMsg);\n            throw new Parser.Failure(errorMsg, location);\n        }\n    }","commit_id":"67f2866cd0cb95b2c72d46bad9ccdb7ab7a0b873","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private MultivaluedMap<String, Object> handleForm(MultivaluedMap<ParameterType, Parameter> map, \n                                                      Object[] params) {\n        \n        MultivaluedMap<String, Object> form = new MetadataMap<String, Object>();\n        \n        List<Parameter> fm = getParameters(map, ParameterType.FORM);\n        for (Parameter p : fm) {\n            if (params[p.getIndex()] != null) {\n                FormUtils.addPropertyToForm(form, p.getName(), params[p.getIndex()]);\n            }\n        }\n        \n        return form;\n    }","id":76593,"modified_method":"private MultivaluedMap<String, String> handleForm(MultivaluedMap<ParameterType, Parameter> map, \n                                                      Object[] params) {\n        \n        MultivaluedMap<String, String> form = new MetadataMap<String, String>();\n        \n        List<Parameter> fm = getParameters(map, ParameterType.FORM);\n        for (Parameter p : fm) {\n            if (params[p.getIndex()] != null) {\n                FormUtils.addPropertyToForm(form, p.getName(), params[p.getIndex()]);\n            }\n        }\n        \n        return form;\n    }","commit_id":"1eaf4e84fa27b220a8588e348af657969f3b42f3","url":"https://github.com/apache/cxf"},{"original_method":"public MultivaluedMap<String, Object> getData() {\n        return new MetadataMap<String, Object>(map);\n    }","id":76594,"modified_method":"public MultivaluedMap<String, String> getData() {\n        return map;\n    }","commit_id":"1eaf4e84fa27b220a8588e348af657969f3b42f3","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void writeTo(Object obj, Class<?> c, Type t, Annotation[] anns, \n                        MediaType mt, MultivaluedMap<String, Object> headers, OutputStream os) \n        throws IOException, WebApplicationException {\n        \n        if (mt.isCompatible(MediaType.MULTIPART_FORM_DATA_TYPE)) {\n            Object body = obj;\n            if (obj.getClass() == File.class) {\n                File f = (File)obj;\n                ContentDisposition cd = new ContentDisposition(\"attachment;filename=\" + f.getName());\n                body = new Attachment(AttachmentUtil.BODY_ATTACHMENT_ID, new FileInputStream(f), cd);\n            }\n            MultipartProvider provider = new MultipartProvider();\n            provider.setMessageContext(mc);\n            provider.writeTo(body, body.getClass(), body.getClass(), anns, mt, headers, os);\n        } else {\n            MultivaluedMap<String, String> map = (MultivaluedMap<String, String>)obj;\n            boolean encoded = AnnotationUtils.getAnnotation(anns, Encoded.class) != null;\n            \n            String encoding = HttpUtils.getSetEncoding(mt, headers, \"UTF-8\");\n            \n            for (Iterator<Map.Entry<String, List<String>>> it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry<String, List<String>> entry = it.next();\n                for (Iterator<String> entryIterator = entry.getValue().iterator(); entryIterator.hasNext();) {\n                    String value = entryIterator.next();\n                    os.write(entry.getKey().getBytes(encoding));\n                    os.write('=');\n                    String data = encoded ? value : HttpUtils.urlEncode(value);\n                    os.write(data.getBytes(encoding));\n                    if (entryIterator.hasNext() || it.hasNext()) {\n                        os.write('&');\n                    }\n                }\n    \n            }\n        }\n    }","id":76595,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void writeTo(Object obj, Class<?> c, Type t, Annotation[] anns, \n                        MediaType mt, MultivaluedMap<String, Object> headers, OutputStream os) \n        throws IOException, WebApplicationException {\n        \n        if (mt.isCompatible(MediaType.MULTIPART_FORM_DATA_TYPE)) {\n            Object body = obj;\n            if (obj.getClass() == File.class) {\n                File f = (File)obj;\n                ContentDisposition cd = new ContentDisposition(\"attachment;filename=\" + f.getName());\n                body = new Attachment(AttachmentUtil.BODY_ATTACHMENT_ID, new FileInputStream(f), cd);\n            }\n            MultipartProvider provider = new MultipartProvider();\n            provider.setMessageContext(mc);\n            provider.writeTo(body, body.getClass(), body.getClass(), anns, mt, headers, os);\n        } else {\n            MultivaluedMap<String, String> map = \n                (MultivaluedMap<String, String>)(obj instanceof Form ? ((Form)obj).getData() : obj);\n            boolean encoded = AnnotationUtils.getAnnotation(anns, Encoded.class) != null;\n            \n            String encoding = HttpUtils.getSetEncoding(mt, headers, \"UTF-8\");\n            \n            for (Iterator<Map.Entry<String, List<String>>> it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry<String, List<String>> entry = it.next();\n                for (Iterator<String> entryIterator = entry.getValue().iterator(); entryIterator.hasNext();) {\n                    String value = entryIterator.next();\n                    os.write(entry.getKey().getBytes(encoding));\n                    os.write('=');\n                    String data = encoded ? value : HttpUtils.urlEncode(value);\n                    os.write(data.getBytes(encoding));\n                    if (entryIterator.hasNext() || it.hasNext()) {\n                        os.write('&');\n                    }\n                }\n    \n            }\n        }\n    }","commit_id":"1eaf4e84fa27b220a8588e348af657969f3b42f3","url":"https://github.com/apache/cxf"},{"original_method":"public Object readFrom(\n        Class<Object> clazz, Type genericType, Annotation[] annotations, MediaType mt, \n        MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        try {\n            if (mt.isCompatible(MediaType.MULTIPART_FORM_DATA_TYPE)) {\n                MultipartBody body = AttachmentUtils.getMultipartBody(mc);\n                if (MultipartBody.class.isAssignableFrom(clazz)) {\n                    return body;\n                } else if (Attachment.class.isAssignableFrom(clazz)) {\n                    return body.getRootAttachment();\n                }  \n            }\n            \n            MultivaluedMap<String, String> params = createMap(clazz);\n            populateMap(params, is, mt,\n                        AnnotationUtils.getAnnotation(annotations, Encoded.class) == null);\n            validateMap(params);\n            \n            persistParamsOnMessage(params);\n            \n            return params;\n        } catch (WebApplicationException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new WebApplicationException(e);\n        }\n    }","id":76596,"modified_method":"public Object readFrom(\n        Class<Object> clazz, Type genericType, Annotation[] annotations, MediaType mt, \n        MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        try {\n            if (mt.isCompatible(MediaType.MULTIPART_FORM_DATA_TYPE)) {\n                MultipartBody body = AttachmentUtils.getMultipartBody(mc);\n                if (MultipartBody.class.isAssignableFrom(clazz)) {\n                    return body;\n                } else if (Attachment.class.isAssignableFrom(clazz)) {\n                    return body.getRootAttachment();\n                }  \n            }\n            \n            MultivaluedMap<String, String> params = createMap(clazz);\n            populateMap(params, is, mt,\n                        AnnotationUtils.getAnnotation(annotations, Encoded.class) == null);\n            validateMap(params);\n            \n            persistParamsOnMessage(params);\n            \n            return getFormObject(clazz, params);\n        } catch (WebApplicationException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new WebApplicationException(e);\n        }\n    }","commit_id":"1eaf4e84fa27b220a8588e348af657969f3b42f3","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected MultivaluedMap<String, String> createMap(Class<?> clazz) throws Exception {\n        if (clazz == MultivaluedMap.class) {\n            return new MetadataMap<String, String>();\n        }\n        return (MultivaluedMap<String, String>)clazz.newInstance();\n    }","id":76597,"modified_method":"@SuppressWarnings(\"unchecked\")\n    protected MultivaluedMap<String, String> createMap(Class<?> clazz) throws Exception {\n        if (clazz == MultivaluedMap.class || clazz == Form.class) {\n            return new MetadataMap<String, String>();\n        }\n        return (MultivaluedMap<String, String>)clazz.newInstance();\n    }","commit_id":"1eaf4e84fa27b220a8588e348af657969f3b42f3","url":"https://github.com/apache/cxf"},{"original_method":"private boolean isSupported(Class<?> type, Type genericType, Annotation[] annotations, \n                                MediaType mt) {\n        return MultivaluedMap.class.isAssignableFrom(type)\n            || mt.getType().equalsIgnoreCase(\"multipart\") \n            && mt.isCompatible(MediaType.MULTIPART_FORM_DATA_TYPE)\n            && (MultipartBody.class.isAssignableFrom(type) || Attachment.class.isAssignableFrom(type));\n    }","id":76598,"modified_method":"private boolean isSupported(Class<?> type, Type genericType, Annotation[] annotations, \n                                MediaType mt) {\n        return (MultivaluedMap.class.isAssignableFrom(type) || Form.class.isAssignableFrom(type)) \n            || (mt.getType().equalsIgnoreCase(\"multipart\") \n            && mt.isCompatible(MediaType.MULTIPART_FORM_DATA_TYPE)\n            && (MultipartBody.class.isAssignableFrom(type) || Attachment.class.isAssignableFrom(type)));\n    }","commit_id":"1eaf4e84fa27b220a8588e348af657969f3b42f3","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testReadable() {\n        assertTrue(ferp.isReadable(MultivaluedMap.class, null, null, null));\n    }","id":76599,"modified_method":"@Test\n    public void testReadableMap() {\n        assertTrue(ferp.isReadable(MultivaluedMap.class, null, null, null));\n    }","commit_id":"1eaf4e84fa27b220a8588e348af657969f3b42f3","url":"https://github.com/apache/cxf"},{"original_method":"public static void addPropertyToForm(MultivaluedMap<String, Object> map, String name, Object value) {\n        if (!\"\".equals(name)) {\n            map.add(name, value.toString());\n        } else {\n            MultivaluedMap<String, Object> values = \n                InjectionUtils.extractValuesFromBean(value, \"\");\n            for (Map.Entry<String, List<Object>> entry : values.entrySet()) {\n                for (Object v : entry.getValue()) {\n                    map.add(entry.getKey(), v.toString());\n                }\n            }\n        }\n    }","id":76600,"modified_method":"public static void addPropertyToForm(MultivaluedMap<String, String> map, String name, Object value) {\n        if (!\"\".equals(name)) {\n            map.add(name, value.toString());\n        } else {\n            MultivaluedMap<String, Object> values = \n                InjectionUtils.extractValuesFromBean(value, \"\");\n            for (Map.Entry<String, List<Object>> entry : values.entrySet()) {\n                for (Object v : entry.getValue()) {\n                    map.add(entry.getKey(), v.toString());\n                }\n            }\n        }\n    }","commit_id":"1eaf4e84fa27b220a8588e348af657969f3b42f3","url":"https://github.com/apache/cxf"},{"original_method":"private Query createRangeQuery(Class<?> cls, String name, Object value, ConditionType type) {\n        \n        boolean minInclusive = type == ConditionType.GREATER_OR_EQUALS || type == ConditionType.EQUALS;\n        boolean maxInclusive = type == ConditionType.LESS_OR_EQUALS || type == ConditionType.EQUALS;\n        \n        if (String.class.isAssignableFrom(cls) || Number.class.isAssignableFrom(cls)) {\n            // If needed, long and double can be supported too\n            // Also, perhaps Strings may optionally be compared with string comparators \n            Integer intValue = Integer.valueOf(value.toString());\n            Integer min = type == ConditionType.LESS_THAN || type == ConditionType.LESS_OR_EQUALS ? null : intValue;\n            Integer max = type == ConditionType.GREATER_THAN || type == ConditionType.GREATER_OR_EQUALS \n                ? null : intValue;\n            Query query = NumericRangeQuery.newIntRange(name, min, max, \n                                                        minInclusive, maxInclusive);\n            return query;\n        } else if (Date.class.isAssignableFrom(cls)) {\n            // This code has not been tested - most likely needs to be fixed  \n            // Resolution should be configurable ?\n            final Date date = SearchUtils.timestampFromString(value.toString());           \n            final String luceneDateValue = (date != null) \n                ? DateTools.dateToString(date, Resolution.MILLISECOND) : value.toString();\n                \n            if (type == ConditionType.LESS_THAN || type == ConditionType.LESS_OR_EQUALS) {\n                return TermRangeQuery.newStringRange(name, \"\", luceneDateValue, minInclusive, maxInclusive);\n            } else {\n                return TermRangeQuery.newStringRange(name, luceneDateValue, \n                    DateTools.dateToString(new Date(), Resolution.MILLISECOND), minInclusive, maxInclusive);\n            }\n        } else {\n            return null;\n        }\n    }","id":76601,"modified_method":"private Query createRangeQuery(Class<?> cls, String name, Object value, ConditionType type) {\n        \n        boolean minInclusive = type == ConditionType.GREATER_OR_EQUALS || type == ConditionType.EQUALS;\n        boolean maxInclusive = type == ConditionType.LESS_OR_EQUALS || type == ConditionType.EQUALS;\n        \n        if (String.class.isAssignableFrom(cls) || Number.class.isAssignableFrom(cls)) {\n            // If needed, long and double can be supported too\n            // Also, perhaps Strings may optionally be compared with string comparators \n            Query query = null;\n            \n            if (Double.class.isAssignableFrom(cls)) {\n                query = createDoubleRangeQuery(name, value, type, minInclusive, maxInclusive);\n            } else if (Float.class.isAssignableFrom(cls)) {\n                query = createFloatRangeQuery(name, value, type, minInclusive, maxInclusive);\n            } else if (Long.class.isAssignableFrom(cls)) {\n                query = createLongRangeQuery(name, value, type, minInclusive, maxInclusive);\n            } else {\n                query = createIntRangeQuery(name, value, type, minInclusive, maxInclusive);\n            }\n        \n            return query;\n        } else if (Date.class.isAssignableFrom(cls)) {\n            // This code has not been tested - most likely needs to be fixed  \n            // Resolution should be configurable ?\n            final Date date = SearchUtils.timestampFromString(value.toString());           \n            final String luceneDateValue = (date != null) \n                ? DateTools.dateToString(date, Resolution.MILLISECOND) : value.toString();\n                \n            if (type == ConditionType.LESS_THAN || type == ConditionType.LESS_OR_EQUALS) {\n                return TermRangeQuery.newStringRange(name, \"\", luceneDateValue, minInclusive, maxInclusive);\n            } else {\n                return TermRangeQuery.newStringRange(name, luceneDateValue, \n                    DateTools.dateToString(new Date(), Resolution.MILLISECOND), minInclusive, maxInclusive);\n            }\n        } else {\n            return null;\n        }\n    }","commit_id":"84cbdf6ac5b7b242c77ea70937aae7ab1cb5e306","url":"https://github.com/apache/cxf"},{"original_method":"private static Field getField(final LuceneDocumentMetadata documentMetadata, \n                                  final String name, final String value) { \n        final Class< ? > type = documentMetadata.getFieldType(name);\n        \n        if (type != null) {\n            if (Number.class.isAssignableFrom(type)) {\n                if (Double.class.isAssignableFrom(type)) {\n                    return new DoubleField(name, Double.valueOf(value), Store.YES);\n                } else if (Float.class.isAssignableFrom(type)) {\n                    return new FloatField(name, Float.valueOf(value), Store.YES);\n                } else if (Long.class.isAssignableFrom(type)) {\n                    return new LongField(name, Long.valueOf(value), Store.YES);\n                } else if (Integer.class.isAssignableFrom(type)) {\n                    return new IntField(name, Integer.valueOf(value), Store.YES);\n                }\n            } else if (Date.class.isAssignableFrom(type)) {\n                final Date date = SearchUtils.timestampFromString(value);                \n                Field field = null;\n                \n                if (date != null) {\n                    field = new StringField(name, DateTools.dateToString(date, Resolution.MILLISECOND), \n                        Store.YES);\n                } else {\n                    field = new StringField(name, value, Store.YES); \n                }\n                \n                return field;\n            }                \n        }\n        \n        return new StringField(name, value, Store.YES);\n    }","id":76602,"modified_method":"private static Field getField(final LuceneDocumentMetadata documentMetadata, \n                                  final String name, final String value) { \n        final Class< ? > type = documentMetadata.getFieldType(name);\n        \n        if (type != null) {\n            if (Number.class.isAssignableFrom(type)) {\n                if (Double.class.isAssignableFrom(type)) {\n                    return new DoubleField(name, Double.valueOf(value), Store.YES);\n                } else if (Float.class.isAssignableFrom(type)) {\n                    return new FloatField(name, Float.valueOf(value), Store.YES);\n                } else if (Long.class.isAssignableFrom(type)) {\n                    return new LongField(name, Long.valueOf(value), Store.YES);\n                } else if (Integer.class.isAssignableFrom(type) || Byte.class.isAssignableFrom(type)) {\n                    return new IntField(name, Integer.valueOf(value), Store.YES);\n                }\n            } else if (Date.class.isAssignableFrom(type)) {\n                final Date date = SearchUtils.timestampFromString(value);                \n                Field field = null;\n                \n                if (date != null) {\n                    field = new StringField(name, DateTools.dateToString(date, Resolution.MILLISECOND), \n                        Store.YES);\n                } else {\n                    field = new StringField(name, value, Store.YES); \n                }\n                \n                return field;\n            }                \n        }\n        \n        return new StringField(name, value, Store.YES);\n    }","commit_id":"84cbdf6ac5b7b242c77ea70937aae7ab1cb5e306","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Processes an access token request\n     * @param params the form parameters representing the access token grant \n     * @return Access Token or the error \n     */\n    @POST\n    @Consumes(\"application/x-www-form-urlencoded\")\n    @Produces(\"application/json\")\n    public Response handleTokenRequest(MultivaluedMap<String, String> params) {\n        \n        // Make sure the client is authenticated\n        Client client = authenticateClientIfNeeded(params);\n        \n        // Find the grant handler\n        AccessTokenGrantHandler handler = findGrantHandler(params);\n        if (handler == null) {\n            return createErrorResponse(params, OAuthConstants.UNSUPPORTED_GRANT_TYPE);\n        }\n        \n        // Create the access token\n        ServerAccessToken serverToken = null;\n        try {\n            serverToken = handler.createAccessToken(client, params);\n        } catch (OAuthServiceException ex) {\n            // the error response is to be returned next\n        }\n        if (serverToken == null) {\n            return createErrorResponse(params, OAuthConstants.INVALID_GRANT);\n        }\n        \n        // Extract the information to be of use for the client\n        ClientAccessToken clientToken = new ClientAccessToken(serverToken.getTokenType(),\n                                                              serverToken.getTokenKey());\n        clientToken.setParameters(serverToken.getParameters());\n        \n        \n        // Return it to the client\n        return Response.ok(clientToken)\n                       .header(HttpHeaders.CACHE_CONTROL, \"no-store\")\n                       .header(\"Pragma\", \"no-cache\")\n                        .build();\n    }","id":76603,"modified_method":"/**\n     * Processes an access token request\n     * @param params the form parameters representing the access token grant \n     * @return Access Token or the error \n     */\n    @POST\n    @Consumes(\"application/x-www-form-urlencoded\")\n    @Produces(\"application/json\")\n    public Response handleTokenRequest(MultivaluedMap<String, String> params) {\n        \n        // Make sure the client is authenticated\n        Client client = authenticateClientIfNeeded(params);\n        \n        // Find the grant handler\n        AccessTokenGrantHandler handler = findGrantHandler(params);\n        if (handler == null) {\n            return createErrorResponse(params, OAuthConstants.UNSUPPORTED_GRANT_TYPE);\n        }\n        \n        // Create the access token\n        ServerAccessToken serverToken = null;\n        try {\n            serverToken = handler.createAccessToken(client, params);\n        } catch (OAuthServiceException ex) {\n            // the error response is to be returned next\n        }\n        if (serverToken == null) {\n            return createErrorResponse(params, OAuthConstants.INVALID_GRANT);\n        }\n        \n        // Extract the information to be of use for the client\n        ClientAccessToken clientToken = new ClientAccessToken(serverToken.getTokenType(),\n                                                              serverToken.getTokenKey());\n        if (writeOptionalParameters) {\n            clientToken.setExpiresIn(serverToken.getLifetime());\n            List<OAuthPermission> perms = serverToken.getScopes();\n            if (!perms.isEmpty()) {\n                clientToken.setApprovedScope(OAuthUtils.convertPermissionsToScope(perms));    \n            }\n            clientToken.setParameters(serverToken.getParameters());\n        }\n        \n        //TODO: also set a refresh token if any\n        \n        // Return it to the client\n        return Response.ok(clientToken)\n                       .header(HttpHeaders.CACHE_CONTROL, \"no-store\")\n                       .header(\"Pragma\", \"no-cache\")\n                        .build();\n    }","commit_id":"577235e62a3358dce8c9f142285858c49c19fbde","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Obtains the access token from OAuth AccessToken Service \n     * using the initialized web client \n     * @param accessTokenService the AccessToken client\n     * @param consumer {@link Consumer} representing the registered client.\n     * @param grant {@link AccessTokenGrant} grant\n     * @param setAuthorizationHeader if set to true then HTTP Basic scheme\n     *           will be used to pass client id and secret, otherwise they will\n     *           be passed in the form payload  \n     * @return {@link ClientAccessToken} access token\n     * @throws OAuthServiceException\n     */\n    public static ClientAccessToken getAccessToken(WebClient accessTokenService,\n                                                   Consumer consumer,\n                                                   AccessTokenGrant grant,\n                                                   boolean setAuthorizationHeader) \n        throws OAuthServiceException {\n        \n        Form form = new Form(grant.toMap());\n    \n        if (consumer != null) {\n            if (setAuthorizationHeader) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(\"Basic \");\n                try {\n                    String data = consumer.getKey() + \":\" + consumer.getSecret();\n                    sb.append(Base64Utility.encode(data.getBytes(\"UTF-8\")));\n                } catch (Exception ex) {\n                    throw new ClientWebApplicationException(ex);\n                }\n                accessTokenService.header(\"Authorization\", sb.toString());\n            } else {\n                form.set(OAuthConstants.CLIENT_ID, consumer.getKey());\n                form.set(OAuthConstants.CLIENT_SECRET, consumer.getSecret());\n            }\n        } else {\n            // in this case the AccessToken service is expected to find a mapping between\n            // the authenticated credentials and the client registration id\n        }\n        Response response = accessTokenService.form(form);\n        Map<String, String> map = null;\n        try {\n            map = new OAuthJSONProvider().readJSONResponse((InputStream)response.getEntity());\n        } catch (IOException ex) {\n            throw new ClientWebApplicationException(ex);\n        }\n        if (200 == response.getStatus()) {\n            if (map.containsKey(OAuthConstants.ACCESS_TOKEN)\n                && map.containsKey(OAuthConstants.ACCESS_TOKEN_TYPE)) {\n                String tokenType = map.get(OAuthConstants.ACCESS_TOKEN_TYPE);\n                \n                ClientAccessToken token = new ClientAccessToken(\n                                              tokenType,\n                                              map.get(OAuthConstants.ACCESS_TOKEN));\n                return token;\n            } else {\n                throw new OAuthServiceException(OAuthConstants.SERVER_ERROR);\n            }\n        } else if (400 == response.getStatus() && map.containsValue(OAuthConstants.ERROR_KEY)) {\n            OAuthError error = new OAuthError(map.get(OAuthConstants.ERROR_KEY),\n                                              map.get(OAuthConstants.ERROR_DESCRIPTION_KEY));\n            throw new OAuthServiceException(error);\n        } \n        throw new OAuthServiceException(OAuthConstants.SERVER_ERROR);\n    }","id":76604,"modified_method":"/**\n     * Obtains the access token from OAuth AccessToken Service \n     * using the initialized web client \n     * @param accessTokenService the AccessToken client\n     * @param consumer {@link Consumer} representing the registered client.\n     * @param grant {@link AccessTokenGrant} grant\n     * @param setAuthorizationHeader if set to true then HTTP Basic scheme\n     *           will be used to pass client id and secret, otherwise they will\n     *           be passed in the form payload  \n     * @return {@link ClientAccessToken} access token\n     * @throws OAuthServiceException\n     */\n    public static ClientAccessToken getAccessToken(WebClient accessTokenService,\n                                                   Consumer consumer,\n                                                   AccessTokenGrant grant,\n                                                   boolean setAuthorizationHeader) \n        throws OAuthServiceException {\n        \n        Form form = new Form(grant.toMap());\n    \n        if (consumer != null) {\n            if (setAuthorizationHeader) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(\"Basic \");\n                try {\n                    String data = consumer.getKey() + \":\" + consumer.getSecret();\n                    sb.append(Base64Utility.encode(data.getBytes(\"UTF-8\")));\n                } catch (Exception ex) {\n                    throw new ClientWebApplicationException(ex);\n                }\n                accessTokenService.header(\"Authorization\", sb.toString());\n            } else {\n                form.set(OAuthConstants.CLIENT_ID, consumer.getKey());\n                form.set(OAuthConstants.CLIENT_SECRET, consumer.getSecret());\n            }\n        } else {\n            // in this case the AccessToken service is expected to find a mapping between\n            // the authenticated credentials and the client registration id\n        }\n        Response response = accessTokenService.form(form);\n        Map<String, String> map = null;\n        try {\n            map = new OAuthJSONProvider().readJSONResponse((InputStream)response.getEntity());\n        } catch (IOException ex) {\n            throw new ClientWebApplicationException(ex);\n        }\n        if (200 == response.getStatus()) {\n            ClientAccessToken token = fromMapToClientToken(map);\n            if (token == null) {\n                throw new OAuthServiceException(OAuthConstants.SERVER_ERROR);\n            } else {\n                return token;\n            }\n        } else if (400 == response.getStatus() && map.containsValue(OAuthConstants.ERROR_KEY)) {\n            OAuthError error = new OAuthError(map.get(OAuthConstants.ERROR_KEY),\n                                              map.get(OAuthConstants.ERROR_DESCRIPTION_KEY));\n            error.setErrorUri(map.get(OAuthConstants.ERROR_URI_KEY));\n            throw new OAuthServiceException(error);\n        } \n        throw new OAuthServiceException(OAuthConstants.SERVER_ERROR);\n    }","commit_id":"577235e62a3358dce8c9f142285858c49c19fbde","url":"https://github.com/apache/cxf"},{"original_method":"private void appendJsonPair(StringBuilder sb, String key, String value) {\n        sb.append(\"\\\"\").append(key).append(\"\\\"\");\n        sb.append(\":\");\n        sb.append(\"\\\"\").append(value).append(\"\\\"\");\n    }","id":76605,"modified_method":"private void appendJsonPair(StringBuilder sb, String key, Object value) {\n        appendJsonPair(sb, key, value, true);\n    }","commit_id":"577235e62a3358dce8c9f142285858c49c19fbde","url":"https://github.com/apache/cxf"},{"original_method":"private void writeOAuthError(OAuthError obj, OutputStream os) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        appendJsonPair(sb, OAuthConstants.ERROR_KEY, obj.getError());\n        if (obj.getErrorDescription() != null) {\n            sb.append(\",\");\n            appendJsonPair(sb, OAuthConstants.ERROR_DESCRIPTION_KEY, obj.getErrorDescription());\n        }\n        // etc\n        sb.append(\"}\");\n        String result = sb.toString();\n        os.write(result.getBytes(\"UTF-8\"));\n        os.flush();\n    }","id":76606,"modified_method":"private void writeOAuthError(OAuthError obj, OutputStream os) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        appendJsonPair(sb, OAuthConstants.ERROR_KEY, obj.getError());\n        if (obj.getErrorDescription() != null) {\n            sb.append(\",\");\n            appendJsonPair(sb, OAuthConstants.ERROR_DESCRIPTION_KEY, obj.getErrorDescription());\n        }\n        if (obj.getErrorUri() != null) {\n            sb.append(\",\");\n            appendJsonPair(sb, OAuthConstants.ERROR_URI_KEY, obj.getErrorUri());\n        }\n        \n        sb.append(\"}\");\n        String result = sb.toString();\n        os.write(result.getBytes(\"UTF-8\"));\n        os.flush();\n    }","commit_id":"577235e62a3358dce8c9f142285858c49c19fbde","url":"https://github.com/apache/cxf"},{"original_method":"public Map<String, String> readFrom(Class<Map<String, String>> cls, Type t, Annotation[] anns, \n                                        MediaType mt, MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException, WebApplicationException {\n        return readJSONResponse(is);\n    }","id":76607,"modified_method":"public Object readFrom(Class<Object> cls, Type t, Annotation[] anns, \n                           MediaType mt, MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException, WebApplicationException {\n        Map<String, String> params = readJSONResponse(is);\n        if (Map.class.isAssignableFrom(cls)) {\n            return params;\n        }\n        ClientAccessToken token = OAuthClientUtils.fromMapToClientToken(params);\n        if (token == null) {\n            throw new WebApplicationException(500);\n        } else {\n            return token;\n        }\n        \n    }","commit_id":"577235e62a3358dce8c9f142285858c49c19fbde","url":"https://github.com/apache/cxf"},{"original_method":"public boolean isReadable(Class<?> cls, Type t, Annotation[] anns, MediaType mt) {\n        return Map.class.isAssignableFrom(cls);\n    }","id":76608,"modified_method":"public boolean isReadable(Class<?> cls, Type t, Annotation[] anns, MediaType mt) {\n        return Map.class.isAssignableFrom(cls) || ClientAccessToken.class.isAssignableFrom(cls);\n    }","commit_id":"577235e62a3358dce8c9f142285858c49c19fbde","url":"https://github.com/apache/cxf"},{"original_method":"private void writeAccessToken(ClientAccessToken obj, OutputStream os) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        appendJsonPair(sb, OAuthConstants.ACCESS_TOKEN, obj.getTokenKey());\n        sb.append(\",\");\n        appendJsonPair(sb, OAuthConstants.ACCESS_TOKEN_TYPE, obj.getTokenType().toString());\n        // etc\n        sb.append(\"}\");\n        String result = sb.toString();\n        os.write(result.getBytes(\"UTF-8\"));\n        os.flush();\n    }","id":76609,"modified_method":"private void writeAccessToken(ClientAccessToken obj, OutputStream os) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        appendJsonPair(sb, OAuthConstants.ACCESS_TOKEN, obj.getTokenKey());\n        sb.append(\",\");\n        appendJsonPair(sb, OAuthConstants.ACCESS_TOKEN_TYPE, obj.getTokenType());\n        if (obj.getExpiresIn() != -1) {\n            sb.append(\",\");\n            appendJsonPair(sb, OAuthConstants.ACCESS_TOKEN_EXPIRES_IN, obj.getExpiresIn(), false);\n        }\n        if (obj.getApprovedScope() != null) {\n            sb.append(\",\");\n            appendJsonPair(sb, OAuthConstants.SCOPE, obj.getApprovedScope());\n        }\n        if (obj.getRefreshToken() != null) {\n            sb.append(\",\");\n            appendJsonPair(sb, OAuthConstants.REFRESH_TOKEN, obj.getRefreshToken());\n        }\n        Map<String, String> parameters = obj.getParameters();\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            sb.append(\",\");\n            appendJsonPair(sb, entry.getKey(), entry.getValue());\n        }\n        sb.append(\"}\");\n        String result = sb.toString();\n        os.write(result.getBytes(\"UTF-8\"));\n        os.flush();\n    }","commit_id":"577235e62a3358dce8c9f142285858c49c19fbde","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create the authorization challenge data \n     */\n    protected OAuthAuthorizationData createAuthorizationData(\n        Client client, MultivaluedMap<String, String> params, List<OAuthPermission> perms) {\n        \n        OAuthAuthorizationData secData = new OAuthAuthorizationData();\n        \n        addAuthenticityTokenToSession(secData);\n                \n        secData.setPermissions(perms);\n        \n        StringBuilder sb = new StringBuilder();\n        for (OAuthPermission perm : perms) {\n            if (sb.length() > 0) {\n                sb.append(\" \");\n            }\n            sb.append(perm.getPermission());\n        }\n        secData.setProposedScope(sb.toString());\n        \n        secData.setClientId(client.getClientId());\n        secData.setRedirectUri(params.getFirst(OAuthConstants.REDIRECT_URI));\n        secData.setState(params.getFirst(OAuthConstants.STATE));\n        \n        secData.setApplicationName(client.getApplicationName()); \n        secData.setApplicationWebUri(client.getApplicationWebUri());\n        secData.setApplicationDescription(client.getApplicationDescription());\n        secData.setApplicationLogoUri(client.getApplicationLogoUri());\n        \n        String replyTo = getMessageContext().getUriInfo()\n            .getAbsolutePathBuilder().path(\"decision\").build().toString();\n        secData.setReplyTo(replyTo);\n        \n        return secData;\n    }","id":76610,"modified_method":"/**\n     * Create the authorization challenge data \n     */\n    protected OAuthAuthorizationData createAuthorizationData(\n        Client client, MultivaluedMap<String, String> params, List<OAuthPermission> perms) {\n        \n        OAuthAuthorizationData secData = new OAuthAuthorizationData();\n        \n        addAuthenticityTokenToSession(secData);\n                \n        secData.setPermissions(perms);\n        secData.setProposedScope(OAuthUtils.convertPermissionsToScope(perms));\n        secData.setClientId(client.getClientId());\n        secData.setRedirectUri(params.getFirst(OAuthConstants.REDIRECT_URI));\n        secData.setState(params.getFirst(OAuthConstants.STATE));\n        \n        secData.setApplicationName(client.getApplicationName()); \n        secData.setApplicationWebUri(client.getApplicationWebUri());\n        secData.setApplicationDescription(client.getApplicationDescription());\n        secData.setApplicationLogoUri(client.getApplicationLogoUri());\n        \n        String replyTo = getMessageContext().getUriInfo()\n            .getAbsolutePathBuilder().path(\"decision\").build().toString();\n        secData.setReplyTo(replyTo);\n        \n        return secData;\n    }","commit_id":"577235e62a3358dce8c9f142285858c49c19fbde","url":"https://github.com/apache/cxf"},{"original_method":"public Object getShadow(final Object fact) throws RuntimeDroolsException {\r\n            ShadowProxy proxy = null;\r\n            if ( isShadowEnabled() ) {\r\n                try {\r\n                    if( Collection.class.isAssignableFrom( this.shadowClass ) ) {\r\n                        // if it is a collection, try to instantiate using constructor\r\n                        try {\r\n                            proxy = (ShadowProxy) this.shadowClass.getConstructor( new Class[] { cls } ).newInstance( new Object[] { fact } );\r\n                        } catch ( Exception e ) {\r\n                            // not possible to instantiate using constructor\r\n                        }\r\n                    }\r\n                    if( proxy == null ) {\r\n                        if ( this.instantiator == null ) {\r\n                            this.setInstantiator();\r\n                        }\r\n                        proxy = (ShadowProxy) this.instantiator.newInstance();\r\n                    }\r\n                    proxy.setShadowedObject( fact );\r\n                } catch ( final Exception e ) {\r\n                    throw new RuntimeDroolsException( \"Error creating shadow fact for object: \" + fact,\r\n                                                      e );\r\n                }\r\n            }\r\n            return proxy;\r\n        }","id":76611,"modified_method":"public Object getShadow(final Object fact) throws RuntimeDroolsException {\r\n            ShadowProxy proxy = null;\r\n            if ( isShadowEnabled() ) {\r\n                try {\r\n                    if( Collection.class.isAssignableFrom( this.shadowClass ) ||\r\n                        Map.class.isAssignableFrom( this.shadowClass ) ) {\r\n                        // if it is a collection, try to instantiate using constructor\r\n                        try {\r\n                            proxy = (ShadowProxy) this.shadowClass.getConstructor( new Class[] { cls } ).newInstance( new Object[] { fact } );\r\n                        } catch ( Exception e ) {\r\n                            // not possible to instantiate using constructor\r\n                        }\r\n                    }\r\n                    if( proxy == null ) {\r\n                        if ( this.instantiator == null ) {\r\n                            this.setInstantiator();\r\n                        }\r\n                        proxy = (ShadowProxy) this.instantiator.newInstance();\r\n                    }\r\n                    proxy.setShadowedObject( fact );\r\n                } catch ( final Exception e ) {\r\n                    throw new RuntimeDroolsException( \"Error creating shadow fact for object: \" + fact,\r\n                                                      e );\r\n                }\r\n            }\r\n            return proxy;\r\n        }","commit_id":"5f09866b5cbe5f28c8fb11aa5a00f9c4aa9beae5","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected static void buildSetShadowedObject(final Class clazz,\n                                                 final String className,\n                                                 final Method setShadowed,\n                                                 final ClassWriter cw) {\n        final MethodVisitor mv = cw.visitMethod( Opcodes.ACC_PUBLIC,\n                                                 setShadowed.getName(),\n                                                 Type.getMethodDescriptor( setShadowed ),\n                                                 null,\n                                                 null );\n        mv.visitCode();\n        Label l0 = new Label();\n        mv.visitLabel( l0 );\n        // this.delegate = (<clazz>) object;\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         0 );\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         1 );\n        mv.visitTypeInsn( Opcodes.CHECKCAST,\n                          Type.getInternalName( clazz ) );\n        mv.visitFieldInsn( Opcodes.PUTFIELD,\n                           className,\n                           DELEGATE_FIELD_NAME,\n                           Type.getDescriptor( clazz ) );\n        if ( Collection.class.isAssignableFrom( clazz ) ) {\n            Label l1 = new Label();\n            mv.visitLabel( l1 );\n            mv.visitVarInsn( Opcodes.ALOAD,\n                             0 );\n            mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL,\n                                className,\n                                UPDATE_PROXY,\n                                Type.getMethodDescriptor( Type.VOID_TYPE,\n                                                          new Type[0] ) );\n        }\n        Label l2 = new Label();\n        mv.visitLabel( l2 );\n        mv.visitInsn( Opcodes.RETURN );\n        Label l3 = new Label();\n        mv.visitLabel( l3 );\n        mv.visitLocalVariable( \"this\",\n                               \"L\" + className + \";\",\n                               null,\n                               l0,\n                               l3,\n                               0 );\n        mv.visitLocalVariable( \"object\",\n                               Type.getDescriptor( Object.class ),\n                               null,\n                               l0,\n                               l3,\n                               1 );\n        mv.visitMaxs( 0,\n                      0 );\n        mv.visitEnd();\n    }","id":76612,"modified_method":"protected static void buildSetShadowedObject(final Class clazz,\n                                                 final String className,\n                                                 final Method setShadowed,\n                                                 final ClassWriter cw) {\n        final MethodVisitor mv = cw.visitMethod( Opcodes.ACC_PUBLIC,\n                                                 setShadowed.getName(),\n                                                 Type.getMethodDescriptor( setShadowed ),\n                                                 null,\n                                                 null );\n        mv.visitCode();\n        Label l0 = new Label();\n        mv.visitLabel( l0 );\n        // this.delegate = (<clazz>) object;\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         0 );\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         1 );\n        mv.visitTypeInsn( Opcodes.CHECKCAST,\n                          Type.getInternalName( clazz ) );\n        mv.visitFieldInsn( Opcodes.PUTFIELD,\n                           className,\n                           DELEGATE_FIELD_NAME,\n                           Type.getDescriptor( clazz ) );\n        if ( Collection.class.isAssignableFrom( clazz ) ||\n             Map.class.isAssignableFrom( clazz ) ) {\n            Label l1 = new Label();\n            mv.visitLabel( l1 );\n            mv.visitVarInsn( Opcodes.ALOAD,\n                             0 );\n            mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL,\n                                className,\n                                UPDATE_PROXY,\n                                Type.getMethodDescriptor( Type.VOID_TYPE,\n                                                          new Type[0] ) );\n        }\n        Label l2 = new Label();\n        mv.visitLabel( l2 );\n        mv.visitInsn( Opcodes.RETURN );\n        Label l3 = new Label();\n        mv.visitLabel( l3 );\n        mv.visitLocalVariable( \"this\",\n                               \"L\" + className + \";\",\n                               null,\n                               l0,\n                               l3,\n                               0 );\n        mv.visitLocalVariable( \"object\",\n                               Type.getDescriptor( Object.class ),\n                               null,\n                               l0,\n                               l3,\n                               1 );\n        mv.visitMaxs( 0,\n                      0 );\n        mv.visitEnd();\n    }","commit_id":"5f09866b5cbe5f28c8fb11aa5a00f9c4aa9beae5","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private static void buildCollectionClass(final Class clazz,\n                                             final String className,\n                                             final ClassWriter cw) {\n\n        buildConstructor( clazz,\n                          className,\n                          cw );\n\n        buildCollectionUpdateProxyMethod( clazz,\n                                          className,\n                                          cw );\n\n    }","id":76613,"modified_method":"private static void buildCollectionClass(final Class clazz,\n                                             final String className,\n                                             final ClassWriter cw) {\n\n        buildCollectionUpdateProxyMethod( clazz,\n                                          className,\n                                          cw );\n\n    }","commit_id":"5f09866b5cbe5f28c8fb11aa5a00f9c4aa9beae5","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private static void buildRegularClass(final Class clazz,\n                                          final String className,\n                                          final ClassWriter cw) {\n        final Map fieldTypes = new HashMap();\n        final Method[] methods = getMethods( clazz );\n        for ( int i = 0; i < methods.length; i++ ) {\n            if ( (!Modifier.isFinal( methods[i].getModifiers() )) && Modifier.isPublic( methods[i].getModifiers() ) && (!Modifier.isStatic( methods[i].getModifiers() )) ) {\n                if ( (!methods[i].getReturnType().equals( Void.TYPE )) && (methods[i].getParameterTypes().length == 0) && (!methods[i].getName().equals( \"hashCode\" )) && (!methods[i].getName().equals( \"toString\" )) ) {\n\n                    final String fieldName = methods[i].getName();\n\n                    buildField( fieldName,\n                                Type.getDescriptor( methods[i].getReturnType() ),\n                                cw );\n                    fieldTypes.put( fieldName,\n                                    methods[i] );\n\n                    buildField( fieldName + ShadowProxyFactory.FIELD_SET_FLAG,\n                                Type.BOOLEAN_TYPE.getDescriptor(),\n                                cw );\n                    buildGetMethod( fieldName,\n                                    methods[i].getReturnType(),\n                                    fieldName + ShadowProxyFactory.FIELD_SET_FLAG,\n                                    methods[i],\n                                    className,\n                                    clazz,\n                                    cw );\n                } else if ( (!methods[i].getName().equals( \"hashCode\" )) && (!methods[i].getName().equals( \"equals\" )) ) {\n                    buildDelegateMethod( methods[i],\n                                         clazz,\n                                         className,\n                                         cw );\n                }\n            }\n        }\n\n        buildConstructor( clazz,\n                          className,\n                          cw );\n\n        buildUpdateProxyMethod( fieldTypes,\n                                className,\n                                cw );\n\n        buildEquals( cw,\n                     className,\n                     clazz,\n                     fieldTypes );\n\n        buildField( ShadowProxyFactory.HASHCACHE_FIELD_NAME,\n                    Type.getDescriptor( int.class ),\n                    cw );\n\n        buildHashCode( cw,\n                       className,\n                       clazz,\n                       fieldTypes );\n    }","id":76614,"modified_method":"private static void buildRegularClass(final Class clazz,\n                                          final String className,\n                                          final ClassWriter cw) {\n        final Map fieldTypes = new HashMap();\n        final Method[] methods = getMethods( clazz );\n        for ( int i = 0; i < methods.length; i++ ) {\n            if ( (!Modifier.isFinal( methods[i].getModifiers() )) && Modifier.isPublic( methods[i].getModifiers() ) && (!Modifier.isStatic( methods[i].getModifiers() )) ) {\n                if ( (!methods[i].getReturnType().equals( Void.TYPE )) && (methods[i].getParameterTypes().length == 0) && (!methods[i].getName().equals( \"hashCode\" )) && (!methods[i].getName().equals( \"toString\" )) ) {\n\n                    final String fieldName = methods[i].getName();\n\n                    buildField( fieldName,\n                                Type.getDescriptor( methods[i].getReturnType() ),\n                                cw );\n                    fieldTypes.put( fieldName,\n                                    methods[i] );\n\n                    buildField( fieldName + ShadowProxyFactory.FIELD_SET_FLAG,\n                                Type.BOOLEAN_TYPE.getDescriptor(),\n                                cw );\n                    buildGetMethod( fieldName,\n                                    methods[i].getReturnType(),\n                                    fieldName + ShadowProxyFactory.FIELD_SET_FLAG,\n                                    methods[i],\n                                    className,\n                                    clazz,\n                                    cw );\n                } else if ( (!methods[i].getName().equals( \"hashCode\" )) && (!methods[i].getName().equals( \"equals\" )) ) {\n                    buildDelegateMethod( methods[i],\n                                         clazz,\n                                         className,\n                                         cw );\n                }\n            }\n        }\n\n        buildUpdateProxyMethod( fieldTypes,\n                                className,\n                                cw );\n\n        buildEquals( cw,\n                     className,\n                     clazz,\n                     fieldTypes );\n\n        buildField( ShadowProxyFactory.HASHCACHE_FIELD_NAME,\n                    Type.getDescriptor( int.class ),\n                    cw );\n\n        buildHashCode( cw,\n                       className,\n                       clazz,\n                       fieldTypes );\n    }","commit_id":"5f09866b5cbe5f28c8fb11aa5a00f9c4aa9beae5","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected static byte[] dump(final Class clazz,\n                                 final String className) throws Exception {\n\n        final ClassWriter cw = new ClassWriter( true );\n\n        buildClassHeader( clazz,\n                          className,\n                          cw );\n\n        buildField( ShadowProxyFactory.DELEGATE_FIELD_NAME,\n                    Type.getDescriptor( clazz ),\n                    cw );\n\n        final Method getShadowed = ShadowProxy.class.getDeclaredMethod( GET_SHADOWED_OBJECT,\n                                                                        new Class[]{} );\n        final Method setShadowed = ShadowProxy.class.getDeclaredMethod( SET_SHADOWED_OBJECT,\n                                                                        new Class[]{Object.class} );\n        buildSimpleGetMethod( ShadowProxyFactory.DELEGATE_FIELD_NAME,\n                              clazz,\n                              getShadowed,\n                              className,\n                              clazz,\n                              cw );\n\n        buildSetShadowedObject( clazz,\n                                className,\n                                setShadowed,\n                                cw );\n\n        if ( Collection.class.isAssignableFrom( clazz ) ) {\n            buildCollectionClass( clazz,\n                                  className,\n                                  cw );\n        } else {\n            buildRegularClass( clazz,\n                               className,\n                               cw );\n        }\n\n        return cw.toByteArray();\n    }","id":76615,"modified_method":"protected static byte[] dump(final Class clazz,\n                                 final String className) throws Exception {\n\n        final ClassWriter cw = new ClassWriter( true );\n\n        buildClassHeader( clazz,\n                          className,\n                          cw );\n\n        buildConstructor( clazz,\n                          className,\n                          cw );\n\n        buildField( ShadowProxyFactory.DELEGATE_FIELD_NAME,\n                    Type.getDescriptor( clazz ),\n                    cw );\n\n        final Method getShadowed = ShadowProxy.class.getDeclaredMethod( GET_SHADOWED_OBJECT,\n                                                                        new Class[]{} );\n        final Method setShadowed = ShadowProxy.class.getDeclaredMethod( SET_SHADOWED_OBJECT,\n                                                                        new Class[]{Object.class} );\n        buildSimpleGetMethod( ShadowProxyFactory.DELEGATE_FIELD_NAME,\n                              clazz,\n                              getShadowed,\n                              className,\n                              clazz,\n                              cw );\n\n        buildSetShadowedObject( clazz,\n                                className,\n                                setShadowed,\n                                cw );\n\n        if ( Collection.class.isAssignableFrom( clazz ) ) {\n            buildCollectionClass( clazz,\n                                  className,\n                                  cw );\n        } else if ( Map.class.isAssignableFrom( clazz ) ) {\n            buildMapClass( clazz,\n                           className,\n                           cw );\n        } else {\n            buildRegularClass( clazz,\n                               className,\n                               cw );\n        }\n\n        return cw.toByteArray();\n    }","commit_id":"5f09866b5cbe5f28c8fb11aa5a00f9c4aa9beae5","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected static void buildCollectionUpdateProxyMethod(final Class clazz,\n                                                           final String className,\n                                                           final ClassWriter cw) {\n        final MethodVisitor mv = cw.visitMethod( Opcodes.ACC_PUBLIC,\n                                                 ShadowProxyFactory.UPDATE_PROXY,\n                                                 Type.getMethodDescriptor( Type.VOID_TYPE,\n                                                                           new Type[]{} ),\n                                                 null,\n                                                 null );\n        mv.visitCode();\n        final Label l0 = new Label();\n        mv.visitLabel( l0 );\n        // this.clear();\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         0 );\n        mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL,\n                            className,\n                            \"clear\",\n                            Type.getMethodDescriptor( Type.VOID_TYPE,\n                                                      new Type[0] ) );\n        Label l1 = new Label();\n        mv.visitLabel( l1 );\n        // this.addAll( this.delegate );\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         0 );\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         0 );\n        mv.visitFieldInsn( Opcodes.GETFIELD,\n                           className,\n                           DELEGATE_FIELD_NAME,\n                           Type.getDescriptor( clazz ) );\n        mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL,\n                            className,\n                            \"addAll\",\n                            Type.getMethodDescriptor( Type.BOOLEAN_TYPE,\n                                                      new Type[]{Type.getType( Collection.class )} ) );\n        mv.visitInsn( Opcodes.POP );\n        Label l2 = new Label();\n        mv.visitLabel( l2 );\n        mv.visitInsn( Opcodes.RETURN );\n        Label l3 = new Label();\n        mv.visitLabel( l3 );\n        mv.visitLocalVariable( \"this\",\n                               \"L\" + className + \";\",\n                               null,\n                               l0,\n                               l3,\n                               0 );\n        mv.visitMaxs( 0,\n                      0 );\n        mv.visitEnd();\n    }","id":76616,"modified_method":"/**\n     * Creates an update proxy method for Map classes\n     * \n     * public void updateProxy() {\n     *     this.clear();\n     *     this.addAll( this.delegate );\n     * }\n     * \n     * @param clazz\n     * @param className\n     * @param cw\n     */\n    protected static void buildCollectionUpdateProxyMethod(final Class clazz,\n                                                           final String className,\n                                                           final ClassWriter cw) {\n        final MethodVisitor mv = cw.visitMethod( Opcodes.ACC_PUBLIC,\n                                                 ShadowProxyFactory.UPDATE_PROXY,\n                                                 Type.getMethodDescriptor( Type.VOID_TYPE,\n                                                                           new Type[]{} ),\n                                                 null,\n                                                 null );\n        mv.visitCode();\n        final Label l0 = new Label();\n        mv.visitLabel( l0 );\n        // this.clear();\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         0 );\n        mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL,\n                            className,\n                            \"clear\",\n                            Type.getMethodDescriptor( Type.VOID_TYPE,\n                                                      new Type[0] ) );\n        Label l1 = new Label();\n        mv.visitLabel( l1 );\n        // this.addAll( this.delegate );\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         0 );\n        mv.visitVarInsn( Opcodes.ALOAD,\n                         0 );\n        mv.visitFieldInsn( Opcodes.GETFIELD,\n                           className,\n                           DELEGATE_FIELD_NAME,\n                           Type.getDescriptor( clazz ) );\n        mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL,\n                            className,\n                            \"addAll\",\n                            Type.getMethodDescriptor( Type.BOOLEAN_TYPE,\n                                                      new Type[]{Type.getType( Collection.class )} ) );\n        mv.visitInsn( Opcodes.POP );\n        Label l2 = new Label();\n        mv.visitLabel( l2 );\n        mv.visitInsn( Opcodes.RETURN );\n        Label l3 = new Label();\n        mv.visitLabel( l3 );\n        mv.visitLocalVariable( \"this\",\n                               \"L\" + className + \";\",\n                               null,\n                               l0,\n                               l3,\n                               0 );\n        mv.visitMaxs( 0,\n                      0 );\n        mv.visitEnd();\n    }","commit_id":"5f09866b5cbe5f28c8fb11aa5a00f9c4aa9beae5","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected AbstractSpringServer(String path, String cPath, int portNumber) {\n        resourcePath = path;\n        contextPath = \"/\";\n        port = portNumber;\n    }","id":76617,"modified_method":"protected AbstractSpringServer(String path, String cPath, int portNumber) {\n        resourcePath = path;\n        contextPath = cPath;\n        port = portNumber;\n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"public static String getPathToMatch(String path, String address, boolean addSlash) {\n        \n        int ind = path.indexOf(address);\n        if (ind == 0) {\n            path = path.substring(ind + address.length());\n        }\n        if (addSlash && !path.startsWith(\"/\")) {\n            path = \"/\" + path;\n        }\n        \n        return path;\n    }","id":76618,"modified_method":"public static String getPathToMatch(String path, String address, boolean addSlash) {\n        \n        int ind = path.indexOf(address);\n        if (ind == -1 && address.equals(path + \"/\")) {\n            path += \"/\";\n            ind = 0;\n        }\n        if (ind == 0) {\n            path = path.substring(ind + address.length());\n        }\n        if (addSlash && !path.startsWith(\"/\")) {\n            path = \"/\" + path;\n        }\n        \n        return path;\n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPathToMatch() {\n        assertEquals(\"/\", HttpUtils.getPathToMatch(\"/\", \"/\", true));\n        assertEquals(\"/\", HttpUtils.getPathToMatch(\"/\", \"/bar\", true));\n        assertEquals(\"/bar\", HttpUtils.getPathToMatch(\"/bar\", \"/\", true));\n        \n        assertEquals(\"/\", HttpUtils.getPathToMatch(\"/bar\", \"/bar\", true));\n        assertEquals(\"/bar\", HttpUtils.getPathToMatch(\"/baz/bar\", \"/baz\", true));\n        assertEquals(\"/baz/bar/foo/\", HttpUtils.getPathToMatch(\"/baz/bar/foo/\", \"/bar\", true));\n        \n    }","id":76619,"modified_method":"@Test\n    public void testPathToMatch() {\n        assertEquals(\"/\", HttpUtils.getPathToMatch(\"/\", \"/\", true));\n        assertEquals(\"/\", HttpUtils.getPathToMatch(\"/\", \"/bar\", true));\n        assertEquals(\"/\", HttpUtils.getPathToMatch(\"/bar\", \"/bar/\", true));\n        assertEquals(\"/bar\", HttpUtils.getPathToMatch(\"/bar\", \"/\", true));\n        \n        assertEquals(\"/\", HttpUtils.getPathToMatch(\"/bar\", \"/bar\", true));\n        assertEquals(\"/bar\", HttpUtils.getPathToMatch(\"/baz/bar\", \"/baz\", true));\n        assertEquals(\"/baz/bar/foo/\", HttpUtils.getPathToMatch(\"/baz/bar/foo/\", \"/bar\", true));\n        \n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"private synchronized void updateDests(HttpServletRequest request) {\n        if (disableAddressUpdates) {\n            return;\n        }\n        String base = forcedBaseAddress == null ? getBaseURL(request) : forcedBaseAddress;\n\n        //if (base.equals(lastBase)) {\n        //    return;\n        //}\n        Set<String> paths = servlet.getTransport().getDestinationsPaths();\n        for (String path : paths) {\n            OsgiDestination d2 = servlet.getTransport().getDestinationForPath(path);\n            String ad = d2.getEndpointInfo().getAddress();\n            if (ad.equals(path)\n                || ad.equals(lastBase + path)) {\n                d2.getEndpointInfo().setAddress(base + path);\n                if (d2.getEndpointInfo().getExtensor(AddressType.class) != null) {\n                    d2.getEndpointInfo().getExtensor(AddressType.class).setLocation(base + path);\n                }\n            }\n        }\n        lastBase = base;\n    }","id":76620,"modified_method":"private synchronized void updateDests(HttpServletRequest request) {\n        if (disableAddressUpdates) {\n            return;\n        }\n        String base = forcedBaseAddress == null ? getBaseURL(request) : forcedBaseAddress;\n\n        if (base.equals(lastBase)) {\n            return;\n        }\n        \n        Set<String> paths = servlet.getTransport().getDestinationsPaths();\n        for (String path : paths) {\n            OsgiDestination d2 = servlet.getTransport().getDestinationForPath(path);\n            String ad = d2.getEndpointInfo().getAddress();\n            if (ad.equals(path)\n                || ad.equals(lastBase + path)) {\n                d2.getEndpointInfo().setAddress(base + path);\n                if (d2.getEndpointInfo().getExtensor(AddressType.class) != null) {\n                    d2.getEndpointInfo().getExtensor(AddressType.class).setLocation(base + path);\n                }\n            }\n        }\n        lastBase = base;\n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"public void invoke(HttpServletRequest request, HttpServletResponse res) throws ServletException {\n        try {\n            EndpointInfo ei = new EndpointInfo();\n            String address = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n\n            ei.setAddress(address);\n            OsgiDestination d = \n                (OsgiDestination)servlet.getTransport().getDestinationForPath(ei.getAddress());\n\n            if (d == null) {\n                if (!isHideServiceList && (request.getRequestURI().endsWith(serviceListRelativePath)\n                    || request.getRequestURI().endsWith(serviceListRelativePath + \"/\"))\n                    || StringUtils.isEmpty(request.getPathInfo())\n                    || \"/\".equals(request.getPathInfo())) {\n                    updateDests(request);\n                    generateServiceList(request, res);\n                } else {\n                    d = checkRestfulRequest(request);\n                    if (d == null || d.getMessageObserver() == null) {\n                        LOG.warning(\"Can't find the the request for \"\n                                    + request.getRequestURL() + \"'s Observer \");\n                        generateNotFound(request, res);\n                    }  else { // the request should be a restful service request\n                        updateDests(request);\n                        invokeDestination(request, res, d);\n                    }\n                }\n            } else {\n                ei = d.getEndpointInfo();\n                Bus bus = d.getBus();\n                if (null != request.getQueryString()\n                    && request.getQueryString().length() > 0\n                    && bus.getExtension(QueryHandlerRegistry.class) != null) {\n\n                    String ctxUri = request.getPathInfo();\n                    String baseUri = request.getRequestURL().toString()\n                        + \"?\" + request.getQueryString();\n                    // update the EndPoint Address with request url\n                    if (\"GET\".equals(request.getMethod())) {\n                        updateDests(request);\n                    }\n\n                    for (QueryHandler qh : bus.getExtension(QueryHandlerRegistry.class).getHandlers()) {\n                        if (qh.isRecognizedQuery(baseUri, ctxUri, ei)) {\n\n                            res.setContentType(qh.getResponseContentType(baseUri, ctxUri));\n                            OutputStream out = res.getOutputStream();\n                            try {\n                                qh.writeResponse(baseUri, ctxUri, ei, out);\n                                out.flush();\n                                return;\n                            } catch (Exception e) {\n                                LOG.warning(qh.getClass().getName()\n                                    + \" Exception caught writing response: \"\n                                    + e.getMessage());\n                                throw new ServletException(e);\n                            }\n                        }\n                    }\n                } \n                invokeDestination(request, res, d);\n                \n            }\n        } catch (IOException e) {\n            throw new ServletException(e);\n        }\n    }","id":76621,"modified_method":"public void invoke(HttpServletRequest request, HttpServletResponse res) throws ServletException {\n        try {\n            EndpointInfo ei = new EndpointInfo();\n            String address = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n\n            ei.setAddress(address);\n            OsgiDestination d = \n                (OsgiDestination)servlet.getTransport().getDestinationForPath(ei.getAddress());\n\n            if (d == null) {\n                if (!isHideServiceList && (request.getRequestURI().endsWith(serviceListRelativePath)\n                    || request.getRequestURI().endsWith(serviceListRelativePath + \"/\"))\n                    || StringUtils.isEmpty(request.getPathInfo())\n                    || \"/\".equals(request.getPathInfo())) {\n                    updateDests(request);\n                    generateServiceList(request, res);\n                } else {\n                    d = checkRestfulRequest(request);\n                    if (d == null || d.getMessageObserver() == null) {\n                        LOG.warning(\"Can't find the the request for \"\n                                    + request.getRequestURL() + \"'s Observer \");\n                        generateNotFound(request, res);\n                    }  else { // the request should be a restful service request\n                        updateDests(request);\n                        invokeDestination(request, res, d);\n                    }\n                }\n            } else {\n                ei = d.getEndpointInfo();\n                Bus bus = d.getBus();\n                if (null != request.getQueryString()\n                    && request.getQueryString().length() > 0\n                    && bus.getExtension(QueryHandlerRegistry.class) != null) {\n\n                    String ctxUri = request.getPathInfo();\n                    String baseUri = request.getRequestURL().toString()\n                        + \"?\" + request.getQueryString();\n                    // update the EndPoint Address with request url\n                    if (\"GET\".equals(request.getMethod())) {\n                        updateDests(request);\n                    }\n\n                    for (QueryHandler qh : bus.getExtension(QueryHandlerRegistry.class).getHandlers()) {\n                        if (qh.isRecognizedQuery(baseUri, ctxUri, ei)) {\n\n                            res.setContentType(qh.getResponseContentType(baseUri, ctxUri));\n                            OutputStream out = res.getOutputStream();\n                            try {\n                                qh.writeResponse(baseUri, ctxUri, ei, out);\n                                out.flush();\n                                return;\n                            } catch (Exception e) {\n                                LOG.warning(qh.getClass().getName()\n                                    + \" Exception caught writing response: \"\n                                    + e.getMessage());\n                                throw new ServletException(e);\n                            }\n                        }\n                    }\n                } else if (\"/\".equals(address) || address.length() == 0) {\n                    updateDests(request);\n                }\n                invokeDestination(request, res, d);\n                \n            }\n        } catch (IOException e) {\n            throw new ServletException(e);\n        }\n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"public void invoke(HttpServletRequest request, HttpServletResponse res) throws ServletException {\n        try {\n            EndpointInfo ei = new EndpointInfo();\n            \n            String address = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n            ei.setAddress(address);\n            \n            ServletDestination d = getDestination(ei.getAddress());\n            if (d == null) {\n                if (!isHideServiceList && (request.getRequestURI().endsWith(serviceListRelativePath)\n                    || request.getRequestURI().endsWith(serviceListRelativePath + \"/\")\n                    || StringUtils.isEmpty(request.getPathInfo())\n                    || \"/\".equals(request.getPathInfo()))) {\n                    updateDests(request);\n                    \n                    if (request.getParameter(\"stylesheet\") != null) {\n                        renderStyleSheet(request, res);\n                    } else if (\"false\".equals(request.getParameter(\"formatted\"))) {\n                        generateUnformattedServiceList(request, res);\n                    } else {\n                        generateServiceList(request, res);\n                    }\n                } else {\n                    d = checkRestfulRequest(request);\n                    if (d == null || d.getMessageObserver() == null) {                        \n                        LOG.warning(\"Can't find the request for \" \n                                    + request.getRequestURL() + \"'s Observer \");\n                        generateNotFound(request, res);\n                    }  else { // the request should be a restful service request\n                        updateDests(request);\n                        invokeDestination(request, res, d);\n                    }\n                }\n            } else {\n                ei = d.getEndpointInfo();\n                if (null != request.getQueryString() \n                    && request.getQueryString().length() > 0\n                    && bus.getExtension(QueryHandlerRegistry.class) != null) {                    \n                    \n                    String ctxUri = request.getPathInfo();\n                    String baseUri = request.getRequestURL().toString() \n                        + \"?\" + request.getQueryString();\n                    // update the EndPoint Address with request url\n                    if (\"GET\".equals(request.getMethod())) {\n                        updateDests(request);\n                    }\n\n                    for (QueryHandler qh : bus.getExtension(QueryHandlerRegistry.class).getHandlers()) {\n                        if (qh.isRecognizedQuery(baseUri, ctxUri, ei)) {\n                            \n                            res.setContentType(qh.getResponseContentType(baseUri, ctxUri));\n                            OutputStream out = res.getOutputStream();\n                            try {\n                                qh.writeResponse(baseUri, ctxUri, ei, out);\n                            } catch (Exception e) {\n                                LogUtils.log(LOG, Level.WARNING,\n                                             qh.getClass().getName() \n                                             + \" Exception caught writing response.\",\n                                             e);\n                                throw new ServletException(e);                                \n                            }\n                            out.flush();\n                            return;\n                        }   \n                    }\n                }\n                \n                invokeDestination(request, res, d);\n            }\n        } catch (Fault ex) {\n            if (ex.getCause() instanceof RuntimeException) {\n                throw (RuntimeException)ex.getCause(); \n            } else {\n                throw new ServletException(ex.getCause());\n            }\n        } catch (IOException e) {\n            throw new ServletException(e);\n        } \n    }","id":76622,"modified_method":"public void invoke(HttpServletRequest request, HttpServletResponse res) throws ServletException {\n        try {\n            EndpointInfo ei = new EndpointInfo();\n            \n            String address = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n            ei.setAddress(address);\n            \n            ServletDestination d = getDestination(ei.getAddress());\n            if (d == null) {\n                if (!isHideServiceList && (request.getRequestURI().endsWith(serviceListRelativePath)\n                    || request.getRequestURI().endsWith(serviceListRelativePath + \"/\")\n                    || StringUtils.isEmpty(request.getPathInfo())\n                    || \"/\".equals(request.getPathInfo()))) {\n                    updateDests(request);\n                    \n                    if (request.getParameter(\"stylesheet\") != null) {\n                        renderStyleSheet(request, res);\n                    } else if (\"false\".equals(request.getParameter(\"formatted\"))) {\n                        generateUnformattedServiceList(request, res);\n                    } else {\n                        generateServiceList(request, res);\n                    }\n                } else {\n                    d = checkRestfulRequest(request);\n                    if (d == null || d.getMessageObserver() == null) {                        \n                        LOG.warning(\"Can't find the request for \" \n                                    + request.getRequestURL() + \"'s Observer \");\n                        generateNotFound(request, res);\n                    }  else { // the request should be a restful service request\n                        updateDests(request);\n                        invokeDestination(request, res, d);\n                    }\n                }\n            } else {\n                ei = d.getEndpointInfo();\n                \n                if (\"GET\".equals(request.getMethod())\n                    && null != request.getQueryString() \n                    && request.getQueryString().length() > 0\n                    && bus.getExtension(QueryHandlerRegistry.class) != null) {                    \n                    \n                    String ctxUri = request.getPathInfo();\n                    String baseUri = request.getRequestURL().toString() \n                        + \"?\" + request.getQueryString();\n                    // update the EndPoint Address with request url\n                    updateDests(request);\n                    \n                    for (QueryHandler qh : bus.getExtension(QueryHandlerRegistry.class).getHandlers()) {\n                        if (qh.isRecognizedQuery(baseUri, ctxUri, ei)) {\n                            \n                            res.setContentType(qh.getResponseContentType(baseUri, ctxUri));\n                            OutputStream out = res.getOutputStream();\n                            try {\n                                qh.writeResponse(baseUri, ctxUri, ei, out);\n                            } catch (Exception e) {\n                                LogUtils.log(LOG, Level.WARNING,\n                                             qh.getClass().getName() \n                                             + \" Exception caught writing response.\",\n                                             e);\n                                throw new ServletException(e);                                \n                            }\n                            out.flush();\n                            return;\n                        }   \n                    }\n                } else if (\"/\".equals(address) || address.length() == 0) {\n                    updateDests(request);\n                }\n                \n                invokeDestination(request, res, d);\n            }\n        } catch (Fault ex) {\n            if (ex.getCause() instanceof RuntimeException) {\n                throw (RuntimeException)ex.getCause(); \n            } else {\n                throw new ServletException(ex.getCause());\n            }\n        } catch (IOException e) {\n            throw new ServletException(e);\n        } \n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mt) {\n        return Source.class.isAssignableFrom(type) || XMLSource.class.isAssignableFrom(type);\n    }","id":76623,"modified_method":"public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mt) {\n        return Source.class.isAssignableFrom(type) \n               || XMLSource.class.isAssignableFrom(type)\n               || Document.class.isAssignableFrom(type);\n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"public Object readFrom(Class<Object> source, Type genericType, Annotation[] annotations, MediaType m,  \n        MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        if (DOMSource.class.isAssignableFrom(source)) {\n            Document doc = null;\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder;\n            try {\n                builder = factory.newDocumentBuilder();\n                doc = builder.parse(is);\n            } catch (Exception e) {\n                IOException ioex = new IOException(\"Problem creating a Source object\");\n                ioex.setStackTrace(e.getStackTrace());\n                throw ioex;\n            }\n    \n            return new DOMSource(doc);\n        } else if (StreamSource.class.isAssignableFrom(source)\n                   || Source.class.isAssignableFrom(source)) {\n            return new StreamSource(is);\n        } else if (XMLSource.class.isAssignableFrom(source)) {\n            return new XMLSource(is);\n        }\n        \n        throw new IOException(\"Unrecognized source\");\n    }","id":76624,"modified_method":"public Object readFrom(Class<Object> source, Type genericType, Annotation[] annotations, MediaType m,  \n        MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        if (DOMSource.class.isAssignableFrom(source) || Document.class.isAssignableFrom(source)) {\n            \n            boolean docRequired = Document.class.isAssignableFrom(source);\n            \n            Document doc = null;\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder;\n            try {\n                builder = factory.newDocumentBuilder();\n                doc = builder.parse(is);\n            } catch (Exception e) {\n                IOException ioex = new IOException(\"Problem creating a Source object\");\n                ioex.setStackTrace(e.getStackTrace());\n                throw ioex;\n            }\n    \n            return docRequired ? doc : new DOMSource(doc);\n        } else if (StreamSource.class.isAssignableFrom(source)\n                   || Source.class.isAssignableFrom(source)) {\n            return new StreamSource(is);\n        } else if (XMLSource.class.isAssignableFrom(source)) {\n            return new XMLSource(is);\n        }\n        \n        throw new IOException(\"Unrecognized source\");\n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testReadFrom() throws Exception {\n        SourceProvider p = new SourceProvider();\n        assertSame(StreamSource.class, verifyRead(p, StreamSource.class).getClass());\n        assertSame(StreamSource.class, verifyRead(p, Source.class).getClass());\n        assertSame(DOMSource.class, verifyRead(p, DOMSource.class).getClass());\n    }","id":76625,"modified_method":"@Test\n    public void testReadFrom() throws Exception {\n        SourceProvider p = new SourceProvider();\n        assertSame(StreamSource.class, verifyRead(p, StreamSource.class).getClass());\n        assertSame(StreamSource.class, verifyRead(p, Source.class).getClass());\n        assertSame(DOMSource.class, verifyRead(p, DOMSource.class).getClass());\n        assertTrue(Document.class.isAssignableFrom(verifyRead(p, Document.class).getClass()));\n    }","commit_id":"d2307599c75cf53c31a42546b69436e528c9a480","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public Object doConvertTo(final Class type, final Exchange exchange, final Object value) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Converting \" + (value == null ? \"null\" : value.getClass().getCanonicalName())\n                + \" -> \" + type.getCanonicalName() + \" with value: \" + value);\n        }\n\n        if (value == null) {\n            // lets avoid NullPointerException when converting to boolean for null values\n            if (boolean.class.isAssignableFrom(type)) {\n                return Boolean.FALSE;\n            }\n            return null;\n        }\n\n        // same instance type\n        if (type.isInstance(value)) {\n            return type.cast(value);\n        }\n\n        // check if we have tried it before and if its a miss\n        TypeMapping key = new TypeMapping(type, value.getClass());\n        if (misses.containsKey(key)) {\n            // we have tried before but we cannot convert this one\n            return Void.TYPE;\n        }\n\n        // make sure we have loaded the converters\n        checkLoaded();\n\n        // try to find a suitable type converter\n        TypeConverter converter = getOrFindTypeConverter(type, value);\n        if (converter != null) {\n            Object rc = converter.convertTo(type, exchange, value);\n            if (rc != null) {\n                return rc;\n            }\n        }\n\n        // fallback converters\n        for (TypeConverter fallback : fallbackConverters) {\n            Object rc = fallback.convertTo(type, exchange, value);\n\n            if (Void.TYPE.equals(rc)) {\n                // it cannot be converted so give up\n                return Void.TYPE;\n            }\n\n            if (rc != null) {\n                // add it as a known type converter since we found a fallback that could do it\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Adding fallback type converter as a known type converter to convert from: \"\n                        + type.getCanonicalName() + \" to: \" + value.getClass().getCanonicalName());\n                }\n                addTypeConverter(type, value.getClass(), fallback);\n                return rc;\n            }\n        }\n\n        // primitives\n        if (type.isPrimitive()) {\n            Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(type);\n            if (primitiveType != type) {\n                return convertTo(primitiveType, exchange, value);\n            }\n        }\n\n        // Could not find suitable conversion, so remember it\n        synchronized (misses) {\n            misses.put(key, key);\n        }\n\n        // Could not find suitable conversion, so return Void to indicate not found\n        return Void.TYPE;\n    }","id":76626,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public Object doConvertTo(final Class type, final Exchange exchange, final Object value) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Converting \" + (value == null ? \"null\" : value.getClass().getCanonicalName())\n                + \" -> \" + type.getCanonicalName() + \" with value: \" + value);\n        }\n\n        if (value == null) {\n            // lets avoid NullPointerException when converting to boolean for null values\n            if (boolean.class.isAssignableFrom(type) || Boolean.class.isAssignableFrom(type)) {\n                return Boolean.FALSE;\n            }\n            return null;\n        }\n\n        // same instance type\n        if (type.isInstance(value)) {\n            return type.cast(value);\n        }\n\n        // check if we have tried it before and if its a miss\n        TypeMapping key = new TypeMapping(type, value.getClass());\n        if (misses.containsKey(key)) {\n            // we have tried before but we cannot convert this one\n            return Void.TYPE;\n        }\n\n        // make sure we have loaded the converters\n        checkLoaded();\n\n        // try to find a suitable type converter\n        TypeConverter converter = getOrFindTypeConverter(type, value);\n        if (converter != null) {\n            Object rc = converter.convertTo(type, exchange, value);\n            if (rc != null) {\n                return rc;\n            }\n        }\n\n        // fallback converters\n        for (TypeConverter fallback : fallbackConverters) {\n            Object rc = fallback.convertTo(type, exchange, value);\n\n            if (Void.TYPE.equals(rc)) {\n                // it cannot be converted so give up\n                return Void.TYPE;\n            }\n\n            if (rc != null) {\n                // add it as a known type converter since we found a fallback that could do it\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Adding fallback type converter as a known type converter to convert from: \"\n                        + type.getCanonicalName() + \" to: \" + value.getClass().getCanonicalName());\n                }\n                addTypeConverter(type, value.getClass(), fallback);\n                return rc;\n            }\n        }\n\n        // primitives\n        if (type.isPrimitive()) {\n            Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(type);\n            if (primitiveType != type) {\n                return convertTo(primitiveType, exchange, value);\n            }\n        }\n\n        // Could not find suitable conversion, so remember it\n        synchronized (misses) {\n            misses.put(key, key);\n        }\n\n        // Could not find suitable conversion, so return Void to indicate not found\n        return Void.TYPE;\n    }","commit_id":"93061f36271e16a5d60200f2db5c12ae95f76b5b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.codehaus.plexus.lifecycle.phase.AbstractPhase#execute(java.lang.Object,\n     *      org.codehaus.plexus.component.manager.ComponentManager, org.codehaus.plexus.classworlds.realm.ClassRealm)\n     */\n    @Override\n    public void execute(Object object, ComponentManager componentManager, ClassRealm classRealm)\n        throws PhaseExecutionException\n    {\n        if (object instanceof Composable) {\n            org.xwiki.component.manager.ComponentManager xwikiManager =\n                new PlexusComponentManager(componentManager.getContainer());\n            ((Composable) object).compose(xwikiManager);\n        }\n    }","id":76627,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.codehaus.plexus.lifecycle.phase.AbstractPhase#execute(java.lang.Object,\n     *      org.codehaus.plexus.component.manager.ComponentManager, org.codehaus.plexus.classworlds.realm.ClassRealm)\n     */\n    @Override\n    public void execute(Object object, ComponentManager componentManager, ClassRealm classRealm)\n        throws PhaseExecutionException\n    {\n        // Only support Composable for classes implementing ComponentManager since for all other components\n        // they should have ComponentManager injected.\n        if (ComponentManager.class.isAssignableFrom(object.getClass()) \n            && Composable.class.isAssignableFrom(object.getClass()))\n        {\n            org.xwiki.component.manager.ComponentManager xwikiManager =\n                new PlexusComponentManager(componentManager.getContainer());\n            ((Composable) object).compose(xwikiManager);\n        }\n    }","commit_id":"17aa6cb39573e0db5bbf25e1e631e5b55f27dbc8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private <T> T getInstance(RoleHint<T> roleHint) throws Exception\n    {\n        T instance = null;\n\n        // Instantiate component\n        ComponentDescriptor<T> descriptor = (ComponentDescriptor<T>) this.descriptors.get(roleHint);\n        if (descriptor != null) {\n            Class<T> componentClass = (Class<T>) this.classLoader.loadClass(descriptor.getImplementation());\n            instance = componentClass.newInstance();\n            \n            // Set each dependency\n            for (ComponentDependency<?> dependency : descriptor.getComponentDependencies()) {\n            \n                // TODO: Handle dependency cycles\n\n                // Handle different field types\n                Object fieldValue;\n                if ((dependency.getMappingType() != null)\n                    && List.class.isAssignableFrom(dependency.getMappingType()))\n                {\n                    fieldValue = lookupList(dependency.getRole());\n                } else if ((dependency.getMappingType() != null)\n                    && Map.class.isAssignableFrom(dependency.getMappingType()))\n                {\n                    fieldValue = lookupMap(dependency.getRole());\n                } else {\n                    fieldValue = lookup(dependency.getRole(), dependency.getRoleHint());\n                }\n                \n                // Set the field by introspection\n                if (fieldValue != null) {\n                    ReflectionUtils.setFieldValue(instance, dependency.getName(), fieldValue);\n                }\n            }\n\n            // Call Lifecycle\n\n            // LogEnabled\n            if (LogEnabled.class.isAssignableFrom(componentClass)) {\n                // TODO: Use a proper logger\n                ((LogEnabled) instance).enableLogging(new VoidLogger());\n            }\n            \n            // Composable\n            if (Composable.class.isAssignableFrom(componentClass)) {\n                ((Composable) instance).compose(this);\n            }\n            \n            // Initializable\n            if (Initializable.class.isAssignableFrom(componentClass)) {\n                ((Initializable) instance).initialize();\n            }\n        }\n        return instance;\n    }","id":76628,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private <T> T getInstance(RoleHint<T> roleHint) throws Exception\n    {\n        T instance = null;\n\n        // Instantiate component\n        ComponentDescriptor<T> descriptor = (ComponentDescriptor<T>) this.descriptors.get(roleHint);\n        if (descriptor != null) {\n            Class<T> componentClass = (Class<T>) this.classLoader.loadClass(descriptor.getImplementation());\n            instance = componentClass.newInstance();\n            \n            // Set each dependency\n            for (ComponentDependency<?> dependency : descriptor.getComponentDependencies()) {\n            \n                // TODO: Handle dependency cycles\n\n                // Handle different field types\n                Object fieldValue;\n                if ((dependency.getMappingType() != null)\n                    && List.class.isAssignableFrom(dependency.getMappingType()))\n                {\n                    fieldValue = lookupList(dependency.getRole());\n                } else if ((dependency.getMappingType() != null)\n                    && Map.class.isAssignableFrom(dependency.getMappingType()))\n                {\n                    fieldValue = lookupMap(dependency.getRole());\n                } else {\n                    fieldValue = lookup(dependency.getRole(), dependency.getRoleHint());\n                }\n                \n                // Set the field by introspection\n                if (fieldValue != null) {\n                    ReflectionUtils.setFieldValue(instance, dependency.getName(), fieldValue);\n                }\n            }\n\n            // Call Lifecycle\n\n            // LogEnabled\n            if (LogEnabled.class.isAssignableFrom(componentClass)) {\n                // TODO: Use a proper logger\n                ((LogEnabled) instance).enableLogging(new VoidLogger());\n            }\n            \n            // Composable\n            // Only support Composable for classes implementing ComponentManager since for all other components\n            // they should have ComponentManager injected.\n            if (ComponentManager.class.isAssignableFrom(componentClass) \n                && Composable.class.isAssignableFrom(componentClass))\n            {\n                ((Composable) instance).compose(this);\n            }\n            \n            // Initializable\n            if (Initializable.class.isAssignableFrom(componentClass)) {\n                ((Initializable) instance).initialize();\n            }\n        }\n        return instance;\n    }","commit_id":"17aa6cb39573e0db5bbf25e1e631e5b55f27dbc8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n\t * Return the list of return value handlers to use including built-in and\n\t * custom handlers provided via {@link #setReturnValueHandlers}.\n\t */\n\tprivate List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {\n\t\tList<HandlerMethodReturnValueHandler> handlers = new ArrayList<HandlerMethodReturnValueHandler>();\n\n\t\t// Single-purpose return value types\n\t\thandlers.add(new ModelAndViewMethodReturnValueHandler());\n\t\thandlers.add(new ModelMethodProcessor());\n\t\thandlers.add(new ViewMethodReturnValueHandler());\n\t\thandlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters()));\n\t\thandlers.add(new HttpEntityMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice));\n\t\thandlers.add(new HttpHeadersReturnValueHandler());\n\t\thandlers.add(new CallableMethodReturnValueHandler());\n\t\thandlers.add(new DeferredResultMethodReturnValueHandler());\n\t\thandlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory));\n\t\thandlers.add(new ListenableFutureReturnValueHandler());\n\n\t\t// Annotation-based return value types\n\t\thandlers.add(new ModelAttributeMethodProcessor(false));\n\t\thandlers.add(new RequestResponseBodyMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice));\n\n\t\t// Multi-purpose return value types\n\t\thandlers.add(new ViewNameMethodReturnValueHandler());\n\t\thandlers.add(new MapMethodProcessor());\n\n\t\t// Custom return value types\n\t\tif (getCustomReturnValueHandlers() != null) {\n\t\t\thandlers.addAll(getCustomReturnValueHandlers());\n\t\t}\n\n\t\t// Catch-all\n\t\tif (!CollectionUtils.isEmpty(getModelAndViewResolvers())) {\n\t\t\thandlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));\n\t\t}\n\t\telse {\n\t\t\thandlers.add(new ModelAttributeMethodProcessor(true));\n\t\t}\n\n\t\treturn handlers;\n\t}","id":76629,"modified_method":"/**\n\t * Return the list of return value handlers to use including built-in and\n\t * custom handlers provided via {@link #setReturnValueHandlers}.\n\t */\n\tprivate List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {\n\t\tList<HandlerMethodReturnValueHandler> handlers = new ArrayList<HandlerMethodReturnValueHandler>();\n\n\t\t// Single-purpose return value types\n\t\thandlers.add(new ModelAndViewMethodReturnValueHandler());\n\t\thandlers.add(new ModelMethodProcessor());\n\t\thandlers.add(new ViewMethodReturnValueHandler());\n\t\thandlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters()));\n\t\thandlers.add(new StreamingResponseBodyReturnValueHandler());\n\t\thandlers.add(new HttpEntityMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice));\n\t\thandlers.add(new HttpHeadersReturnValueHandler());\n\t\thandlers.add(new CallableMethodReturnValueHandler());\n\t\thandlers.add(new DeferredResultMethodReturnValueHandler());\n\t\thandlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory));\n\t\thandlers.add(new ListenableFutureReturnValueHandler());\n\n\t\t// Annotation-based return value types\n\t\thandlers.add(new ModelAttributeMethodProcessor(false));\n\t\thandlers.add(new RequestResponseBodyMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice));\n\n\t\t// Multi-purpose return value types\n\t\thandlers.add(new ViewNameMethodReturnValueHandler());\n\t\thandlers.add(new MapMethodProcessor());\n\n\t\t// Custom return value types\n\t\tif (getCustomReturnValueHandlers() != null) {\n\t\t\thandlers.addAll(getCustomReturnValueHandlers());\n\t\t}\n\n\t\t// Catch-all\n\t\tif (!CollectionUtils.isEmpty(getModelAndViewResolvers())) {\n\t\t\thandlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));\n\t\t}\n\t\telse {\n\t\t\thandlers.add(new ModelAttributeMethodProcessor(true));\n\t\t}\n\n\t\treturn handlers;\n\t}","commit_id":"95f6e4cc9bda491e20da26ba05eb7ba3f3c15bbe","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tpublic Class<?> getParameterType() {\n\t\t\tif (this.returnValue != null) {\n\t\t\t\treturn this.returnValue.getClass();\n\t\t\t}\n\t\t\tClass<?> parameterType = super.getParameterType();\n\t\t\tif (ResponseBodyEmitter.class.isAssignableFrom(parameterType)) {\n\t\t\t\treturn parameterType;\n\t\t\t}\n\t\t\tAssert.isTrue(!ResolvableType.NONE.equals(this.returnType), \"Expected one of\" +\n\t\t\t\t\t\"Callable, DeferredResult, or ListenableFuture: \" + super.getParameterType());\n\t\t\treturn this.returnType.getRawClass();\n\t\t}","id":76630,"modified_method":"@Override\n\t\tpublic Class<?> getParameterType() {\n\t\t\tif (this.returnValue != null) {\n\t\t\t\treturn this.returnValue.getClass();\n\t\t\t}\n\t\t\tClass<?> parameterType = super.getParameterType();\n\t\t\tif (ResponseBodyEmitter.class.isAssignableFrom(parameterType) ||\n\t\t\t\t\tStreamingResponseBody.class.isAssignableFrom(parameterType)) {\n\t\t\t\treturn parameterType;\n\t\t\t}\n\t\t\tAssert.isTrue(!ResolvableType.NONE.equals(this.returnType), \"Expected one of\" +\n\t\t\t\t\t\"Callable, DeferredResult, or ListenableFuture: \" + super.getParameterType());\n\t\t\treturn this.returnType.getRawClass();\n\t\t}","commit_id":"95f6e4cc9bda491e20da26ba05eb7ba3f3c15bbe","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\r\n\t * @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(java.lang.Class,\r\n\t *      java.lang.String, java.util.Locale, java.lang.String, java.lang.String)\r\n\t */\r\n\t@Override\r\n\tpublic String loadStringResource(Class<?> clazz, final String key, final Locale locale,\r\n\t\tfinal String style, final String variation)\r\n\t{\r\n\t\t// only care about IValidator subclasses\r\n\t\tif (clazz == null || !IValidator.class.isAssignableFrom(clazz))\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn super.loadStringResource(clazz, key, locale, style, variation);\r\n\t}","id":76631,"modified_method":"/**\r\n\t * @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(java.lang.Class,\r\n\t *      java.lang.String, java.util.Locale, java.lang.String, java.lang.String)\r\n\t */\r\n\t@Override\r\n\tpublic String loadStringResource(Class<?> clazz, final String key, final Locale locale,\r\n\t\tfinal String style, final String variation)\r\n\t{\r\n\t\t// only care about IValidator/IFormValidator subclasses\r\n\t\tif (\r\n\t\t\t\tclazz == null ||\r\n\t\t\t\t!(IValidator.class.isAssignableFrom(clazz) || IFormValidator.class.isAssignableFrom(clazz)))\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn super.loadStringResource(clazz, key, locale, style, variation);\r\n\t}","commit_id":"843fcf6287534f8ee481d2e4da63bfd52d76f2b0","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(org.apache.wicket.Component,\r\n\t *      java.lang.String, java.util.Locale, java.lang.String, java.lang.String)\r\n\t */\r\n\t@Override\r\n\tpublic String loadStringResource(final Component component, final String key,\r\n\t\tfinal Locale locale, final String style, final String variation)\r\n\t{\r\n\t\tif (component == null || !(component instanceof FormComponent))\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tFormComponent<?> fc = (FormComponent<?>)component;\r\n\t\tfor (IValidator<?> validator : fc.getValidators())\r\n\t\t{\r\n\t\t\tClass<?> scope = getScope(validator);\r\n\t\t\tString resource = loadStringResource(scope, key, locale, style,\r\n\t\t\t\tvariation);\r\n\t\t\tif (resource != null)\r\n\t\t\t{\r\n\t\t\t\treturn resource;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// not found\r\n\t\treturn null;\r\n\t}","id":76632,"modified_method":"/**\r\n\t * @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(org.apache.wicket.Component,\r\n\t *      java.lang.String, java.util.Locale, java.lang.String, java.lang.String)\r\n\t */\r\n\t@Override\r\n\tpublic String loadStringResource(final Component component, final String key,\r\n\t\tfinal Locale locale, final String style, final String variation)\r\n\t{\r\n\r\n\t\tfinal String resource;\r\n\t\tif (component instanceof FormComponent)\r\n\t\t{\r\n\t\t\tresource = loadStringResource((FormComponent) component, key, locale, style, variation);\r\n\t\t}\r\n\t\telse if (component instanceof Form)\r\n\t\t{\r\n\t\t\tresource = loadStringResource((Form) component, key, locale, style, variation);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tresource = null;\r\n\t\t}\r\n\r\n\t\treturn resource;\r\n\t}","commit_id":"843fcf6287534f8ee481d2e4da63bfd52d76f2b0","url":"https://github.com/apache/wicket"},{"original_method":"/** For a given Class generate a client-friendly type name (e.g., int[][] or Frame). */\n    public static String consType(Schema schema, Class clz, String field_name, API annotation) {\n      boolean is_enum = isEnum(clz, null) || isFakeEnum(clz, annotation);\n      boolean is_array = clz.isArray();\n\n      // built-in Java types:\n      if (is_enum)\n        return \"enum\";\n\n      if (String.class.isAssignableFrom(clz))\n        return \"string\"; // lower-case, to be less Java-centric\n\n      if (clz.equals(Boolean.TYPE) || clz.equals(Byte.TYPE) || clz.equals(Short.TYPE) || clz.equals(Integer.TYPE) || clz.equals(Long.TYPE) || clz.equals(Float.TYPE) || clz.equals(Double.TYPE))\n        return clz.toString();\n\n      if (is_array)\n        return consType(schema, clz.getComponentType(), field_name, annotation) + \"[]\";\n\n      if (Map.class.isAssignableFrom(clz)) {\n        if (IcedHashMapGeneric.class.isAssignableFrom(clz)) {\n          String type0 = ReflectionUtils.findActualClassParameter(clz, 0).getSimpleName();\n          String type1 = ReflectionUtils.findActualClassParameter(clz, 1).getSimpleName();\n          if (\"String\".equals(type0)) type0 = \"string\";\n          if (\"String\".equals(type1)) type1 = \"string\";\n          return \"Map<\" + type0 + \",\" + type1 + \">\";\n        } else {\n          Log.warn(\"Schema Map field isn't a subclass of IcedHashMap, so its metadata won't have type parameters: \" + schema.getClass().getSimpleName() + \".\" + field_name);\n          return \"Map\";\n        }\n      }\n\n\n      if (List.class.isAssignableFrom(clz))\n        return \"List\";\n\n      // H2O-specific types:\n      // TODO: NOTE, this is a mix of Schema types and Iced types; that's not right. . .\n      // Should ONLY have schema types.\n      // Also, this mapping could/should be moved to Schema.\n      if (water.Key.class.isAssignableFrom(clz)) {\n        Log.warn(\"Raw Key (not KeySchema) in Schema: \" + schema.getClass() + \" field: \" + field_name);\n        return \"Key\";\n      }\n\n      if (KeyV3.class.isAssignableFrom(clz)) {\n        return \"Key<\" + KeyV3.getKeyedClassType((Class<? extends KeyV3>) clz) + \">\";\n      }\n\n      if (Schema.class.isAssignableFrom(clz)) {\n        return Schema.getImplClass((Class<Schema>)clz).getSimpleName();  // same as Schema.schema_type\n      }\n\n      if (Iced.class.isAssignableFrom(clz)) {\n        if (clz == SchemaV3.Meta.class) {\n          // Special case where we allow an Iced in a Schema so we don't get infinite meta-regress:\n          return \"Schema.Meta\";\n        } else {\n          // Special cases: polymorphic metadata fields that can contain scalars, Schemas (any Iced, actually), or arrays of these:\n          if (schema instanceof ModelParameterSchemaV3 && (\"default_value\".equals(field_name) || \"actual_value\".equals(field_name)))\n            return \"Polymorphic\";\n\n          if ((schema instanceof FieldMetadataV3) && \"value\".equals(field_name))\n            return \"Polymorphic\";\n\n          if (((schema instanceof TwoDimTableV3) && \"data\".equals(field_name))) // IcedWrapper\n            return \"Polymorphic\";\n\n          Log.warn(\"WARNING: found non-Schema Iced field: \" + clz.toString() + \" in Schema: \" + schema.getClass() + \" field: \" + field_name);\n          return clz.getSimpleName();\n        }\n      }\n\n      String msg = \"Don't know how to generate a client-friendly type name for class: \" + clz.toString() + \" in Schema: \" + schema.getClass() + \" field: \" + field_name;\n      Log.warn(msg);\n      throw H2O.fail(msg);\n    }","id":76633,"modified_method":"/** For a given Class generate a client-friendly type name (e.g., int[][] or Frame). */\n    public static String consType(Schema schema, Class clz, String field_name, API annotation) {\n      boolean is_enum = isEnum(clz, null) || isFakeEnum(clz, annotation);\n      boolean is_array = clz.isArray();\n\n      // built-in Java types:\n      if (is_enum)\n        return \"enum\";\n\n      if (String.class.isAssignableFrom(clz))\n        return \"string\"; // lower-case, to be less Java-centric\n\n      if (clz.equals(Boolean.TYPE) || clz.equals(Byte.TYPE) || clz.equals(Short.TYPE) || clz.equals(Integer.TYPE) || clz.equals(Long.TYPE) || clz.equals(Float.TYPE) || clz.equals(Double.TYPE))\n        return clz.toString();\n\n      if (is_array)\n        return consType(schema, clz.getComponentType(), field_name, annotation) + \"[]\";\n\n      if (Map.class.isAssignableFrom(clz)) {\n        if (IcedHashMapGeneric.class.isAssignableFrom(clz) || IcedHashMapBase.class.isAssignableFrom(clz)) {\n          String type0 = ReflectionUtils.findActualClassParameter(clz, 0).getSimpleName();\n          String type1 = ReflectionUtils.findActualClassParameter(clz, 1).getSimpleName();\n          if (\"String\".equals(type0)) type0 = \"string\";\n          if (\"String\".equals(type1)) type1 = \"string\";\n          return \"Map<\" + type0 + \",\" + type1 + \">\";\n        } else {\n          Log.warn(\"Schema Map field isn't a subclass of IcedHashMap, so its metadata won't have type parameters: \" + schema.getClass().getSimpleName() + \".\" + field_name);\n          return \"Map\";\n        }\n      }\n\n\n      if (List.class.isAssignableFrom(clz))\n        return \"List\";\n\n      // H2O-specific types:\n      // TODO: NOTE, this is a mix of Schema types and Iced types; that's not right. . .\n      // Should ONLY have schema types.\n      // Also, this mapping could/should be moved to Schema.\n      if (water.Key.class.isAssignableFrom(clz)) {\n        Log.warn(\"Raw Key (not KeySchema) in Schema: \" + schema.getClass() + \" field: \" + field_name);\n        return \"Key\";\n      }\n\n      if (KeyV3.class.isAssignableFrom(clz)) {\n        return \"Key<\" + KeyV3.getKeyedClassType((Class<? extends KeyV3>) clz) + \">\";\n      }\n\n      if (Schema.class.isAssignableFrom(clz)) {\n        return Schema.getImplClass((Class<Schema>)clz).getSimpleName();  // same as Schema.schema_type\n      }\n\n      if (Iced.class.isAssignableFrom(clz)) {\n        if (clz == SchemaV3.Meta.class) {\n          // Special case where we allow an Iced in a Schema so we don't get infinite meta-regress:\n          return \"Schema.Meta\";\n        } else {\n          // Special cases: polymorphic metadata fields that can contain scalars, Schemas (any Iced, actually), or arrays of these:\n          if (schema instanceof ModelParameterSchemaV3 && (\"default_value\".equals(field_name) || \"actual_value\".equals(field_name)))\n            return \"Polymorphic\";\n\n          if ((schema instanceof FieldMetadataV3) && \"value\".equals(field_name))\n            return \"Polymorphic\";\n\n          if (((schema instanceof TwoDimTableV3) && \"data\".equals(field_name))) // IcedWrapper\n            return \"Polymorphic\";\n\n          Log.warn(\"WARNING: found non-Schema Iced field: \" + clz.toString() + \" in Schema: \" + schema.getClass() + \" field: \" + field_name);\n          return clz.getSimpleName();\n        }\n      }\n\n      String msg = \"Don't know how to generate a client-friendly type name for class: \" + clz.toString() + \" in Schema: \" + schema.getClass() + \" field: \" + field_name;\n      Log.warn(msg);\n      throw H2O.fail(msg);\n    }","commit_id":"05a8db833abba04605553a65024f1048b5751555","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n     * @param path File path.\n     * @param prefixLen Prefix length.\n     * @throws Exception In case of error.\n     */\n    private void processClassFile(String path, int prefixLen)\n        throws Exception {\n        String clsName = path.substring(prefixLen, path.length() - 6).replace(File.separatorChar, '.');\n\n        boolean included = false;\n\n        for (String pkg : packages) {\n            if (clsName.startsWith(pkg)) {\n                included = true;\n\n                break;\n            }\n        }\n\n        if (included) {\n            Class<?> cls = Class.forName(clsName, false, ldr);\n\n            if (Serializable.class.isAssignableFrom(cls)) {\n                if (!cls.isInterface() && !Modifier.isAbstract(cls.getModifiers()) && !cls.isEnum() &&\n                    !cls.getSimpleName().isEmpty() && cls.getName().startsWith(\"org.apache.ignite\")) {\n                    try {\n                        Field field = cls.getDeclaredField(\"serialVersionUID\");\n\n                        if (!field.getType().equals(long.class))\n                            errs.add(\"serialVersionUID field is not long in class: \" + cls.getName());\n\n                        int mod = field.getModifiers();\n\n                        if (!Modifier.isStatic(mod))\n                            errs.add(\"serialVersionUID field is not static in class: \" + cls.getName());\n\n                        if (!Modifier.isFinal(mod))\n                            errs.add(\"serialVersionUID field is not final in class: \" + cls.getName());\n                    }\n                    catch (NoSuchFieldException ignored) {\n                        errs.add(\"No serialVersionUID field in class: \" + cls.getName());\n                    }\n                }\n\n                classes.add((Class)cls);\n            }\n        }\n    }","id":76634,"modified_method":"/**\n     * @param path File path.\n     * @param prefixLen Prefix length.\n     * @throws Exception In case of error.\n     */\n    private void processClassFile(String path, int prefixLen)\n        throws Exception {\n        String clsName = path.substring(prefixLen, path.length() - 6).replace(File.separatorChar, '.');\n\n        boolean included = false;\n\n        for (String pkg : packages) {\n            if (clsName.startsWith(pkg)) {\n                included = true;\n\n                break;\n            }\n        }\n\n        if (included) {\n            Class<?> cls = Class.forName(clsName, false, ldr);\n\n            if (Serializable.class.isAssignableFrom(cls) && !IgniteFuture.class.isAssignableFrom(cls) &&\n                !IgniteInternalFuture.class.isAssignableFrom(cls) && !GridClientFuture.class.isAssignableFrom(cls)) {\n                if (!cls.isInterface() && !Modifier.isAbstract(cls.getModifiers()) && !cls.isEnum() &&\n                    !cls.getSimpleName().isEmpty() && cls.getName().startsWith(\"org.apache.ignite\")) {\n                    try {\n                        Field field = cls.getDeclaredField(\"serialVersionUID\");\n\n                        if (!field.getType().equals(long.class))\n                            errs.add(\"serialVersionUID field is not long in class: \" + cls.getName());\n\n                        int mod = field.getModifiers();\n\n                        if (!Modifier.isStatic(mod))\n                            errs.add(\"serialVersionUID field is not static in class: \" + cls.getName());\n\n                        if (!Modifier.isFinal(mod))\n                            errs.add(\"serialVersionUID field is not final in class: \" + cls.getName());\n                    }\n                    catch (NoSuchFieldException ignored) {\n                        errs.add(\"No serialVersionUID field in class: \" + cls.getName());\n                    }\n                }\n\n                classes.add((Class)cls);\n            }\n        }\n    }","commit_id":"9d740c693a4ede29885ca9cf3977d0f5c01d6008","url":"https://github.com/apache/ignite"},{"original_method":"@Override\n\tpublic int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag<R> searchContainerRowTag =\n\t\t\t\t(SearchContainerRowTag<R>)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow resultRow = searchContainerRowTag.getRow();\n\n\t\t\tif (index <= -1) {\n\t\t\t\tList<SearchEntry> searchEntries = resultRow.getEntries();\n\n\t\t\t\tindex = searchEntries.size();\n\t\t\t}\n\n\t\t\tButtonSearchEntry buttonSearchEntry = new ButtonSearchEntry();\n\n\t\t\tbuttonSearchEntry.setAlign(getAlign());\n\t\t\tbuttonSearchEntry.setColspan(getColspan());\n\t\t\tbuttonSearchEntry.setCssClass(getCssClass());\n\t\t\tbuttonSearchEntry.setHref((String)getHref());\n\t\t\tbuttonSearchEntry.setName(LanguageUtil.get(request, getName()));\n\t\t\tbuttonSearchEntry.setValign(getValign());\n\n\t\t\tresultRow.addSearchEntry(index, buttonSearchEntry);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\tindex = -1;\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\talign = SearchEntry.DEFAULT_ALIGN;\n\t\t\t\tcolspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t\tcssClass = SearchEntry.DEFAULT_CSS_CLASS;\n\t\t\t\t_href = null;\n\t\t\t\tname = StringPool.BLANK;\n\t\t\t\tvalign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t}\n\t\t}\n\t}","id":76635,"modified_method":"@Override\n\tpublic int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag<R> searchContainerRowTag =\n\t\t\t\t(SearchContainerRowTag<R>)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow resultRow = searchContainerRowTag.getRow();\n\n\t\t\tif (index <= -1) {\n\t\t\t\tList<SearchEntry> searchEntries = resultRow.getEntries();\n\n\t\t\t\tindex = searchEntries.size();\n\t\t\t}\n\n\t\t\tButtonSearchEntry buttonSearchEntry = new ButtonSearchEntry();\n\n\t\t\tbuttonSearchEntry.setAlign(getAlign());\n\t\t\tbuttonSearchEntry.setColspan(getColspan());\n\t\t\tbuttonSearchEntry.setCssClass(getCssClass());\n\t\t\tbuttonSearchEntry.setHref(String.valueOf(getHref()));\n\t\t\tbuttonSearchEntry.setName(LanguageUtil.get(request, getName()));\n\t\t\tbuttonSearchEntry.setValign(getValign());\n\n\t\t\tresultRow.addSearchEntry(index, buttonSearchEntry);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\tindex = -1;\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\talign = SearchEntry.DEFAULT_ALIGN;\n\t\t\t\tcolspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t\tcssClass = SearchEntry.DEFAULT_CSS_CLASS;\n\t\t\t\t_href = null;\n\t\t\t\tname = StringPool.BLANK;\n\t\t\t\tvalign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t}\n\t\t}\n\t}","commit_id":"ee8c6a372c0a446fd6e024295ca3fb81585408ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag<R> searchContainerRowTag =\n\t\t\t\t(SearchContainerRowTag<R>)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow resultRow = searchContainerRowTag.getRow();\n\n\t\t\tif (Validator.isNotNull(_property)) {\n\t\t\t\t_value = (Date)BeanPropertiesUtil.getObject(\n\t\t\t\t\tresultRow.getObject(), _property);\n\t\t\t}\n\n\t\t\tif (index <= -1) {\n\t\t\t\tList<SearchEntry> searchEntries = resultRow.getEntries();\n\n\t\t\t\tindex = searchEntries.size();\n\t\t\t}\n\n\t\t\tif (resultRow.isRestricted()) {\n\t\t\t\t_href = null;\n\t\t\t}\n\n\t\t\tDateSearchEntry dateSearchEntry = new DateSearchEntry();\n\n\t\t\tdateSearchEntry.setAlign(getAlign());\n\t\t\tdateSearchEntry.setColspan(getColspan());\n\t\t\tdateSearchEntry.setCssClass(getCssClass());\n\t\t\tdateSearchEntry.setDate(_value);\n\t\t\tdateSearchEntry.setHref((String)getHref());\n\t\t\tdateSearchEntry.setValign(getValign());\n\n\t\t\tresultRow.addSearchEntry(index, dateSearchEntry);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\tindex = -1;\n\t\t\t_value = null;\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\talign = SearchEntry.DEFAULT_ALIGN;\n\t\t\t\tcolspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t\tcssClass = SearchEntry.DEFAULT_CSS_CLASS;\n\t\t\t\t_href = null;\n\t\t\t\tname = null;\n\t\t\t\t_orderable = false;\n\t\t\t\t_orderableProperty = null;\n\t\t\t\t_property = null;\n\t\t\t\tvalign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t}\n\t\t}\n\t}","id":76636,"modified_method":"@Override\n\tpublic int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag<R> searchContainerRowTag =\n\t\t\t\t(SearchContainerRowTag<R>)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow resultRow = searchContainerRowTag.getRow();\n\n\t\t\tif (Validator.isNotNull(_property)) {\n\t\t\t\t_value = (Date)BeanPropertiesUtil.getObject(\n\t\t\t\t\tresultRow.getObject(), _property);\n\t\t\t}\n\n\t\t\tif (index <= -1) {\n\t\t\t\tList<SearchEntry> searchEntries = resultRow.getEntries();\n\n\t\t\t\tindex = searchEntries.size();\n\t\t\t}\n\n\t\t\tif (resultRow.isRestricted()) {\n\t\t\t\t_href = null;\n\t\t\t}\n\n\t\t\tDateSearchEntry dateSearchEntry = new DateSearchEntry();\n\n\t\t\tdateSearchEntry.setAlign(getAlign());\n\t\t\tdateSearchEntry.setColspan(getColspan());\n\t\t\tdateSearchEntry.setCssClass(getCssClass());\n\t\t\tdateSearchEntry.setDate(_value);\n\t\t\tdateSearchEntry.setHref(String.valueOf(getHref()));\n\t\t\tdateSearchEntry.setValign(getValign());\n\n\t\t\tresultRow.addSearchEntry(index, dateSearchEntry);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\tindex = -1;\n\t\t\t_value = null;\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\talign = SearchEntry.DEFAULT_ALIGN;\n\t\t\t\tcolspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t\tcssClass = SearchEntry.DEFAULT_CSS_CLASS;\n\t\t\t\t_href = null;\n\t\t\t\tname = null;\n\t\t\t\t_orderable = false;\n\t\t\t\t_orderableProperty = null;\n\t\t\t\t_property = null;\n\t\t\t\tvalign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t}\n\t\t}\n\t}","commit_id":"ee8c6a372c0a446fd6e024295ca3fb81585408ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag<R> searchContainerRowTag =\n\t\t\t\t(SearchContainerRowTag<R>)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow resultRow = searchContainerRowTag.getRow();\n\n\t\t\tif (index <= -1) {\n\t\t\t\tList<SearchEntry> searchEntries = resultRow.getEntries();\n\n\t\t\t\tindex = searchEntries.size();\n\t\t\t}\n\n\t\t\tJSPSearchEntry jspSearchEntry = new JSPSearchEntry();\n\n\t\t\tjspSearchEntry.setAlign(getAlign());\n\t\t\tjspSearchEntry.setColspan(getColspan());\n\t\t\tjspSearchEntry.setCssClass(getCssClass());\n\t\t\tjspSearchEntry.setHref((String)getHref());\n\t\t\tjspSearchEntry.setPath(getPath());\n\t\t\tjspSearchEntry.setRequest(\n\t\t\t\t(HttpServletRequest)pageContext.getRequest());\n\t\t\tjspSearchEntry.setResponse(\n\t\t\t\t(HttpServletResponse)pageContext.getResponse());\n\t\t\tjspSearchEntry.setServletContext(pageContext.getServletContext());\n\t\t\tjspSearchEntry.setTruncate(getTruncate());\n\t\t\tjspSearchEntry.setValign(getValign());\n\n\t\t\tresultRow.addSearchEntry(index, jspSearchEntry);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\tindex = -1;\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\talign = SearchEntry.DEFAULT_ALIGN;\n\t\t\t\tcolspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t\tcssClass = SearchEntry.DEFAULT_CSS_CLASS;\n\t\t\t\tname = StringPool.BLANK;\n\t\t\t\t_path = null;\n\t\t\t\tvalign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t}\n\t\t}\n\t}","id":76637,"modified_method":"@Override\n\tpublic int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag<R> searchContainerRowTag =\n\t\t\t\t(SearchContainerRowTag<R>)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow resultRow = searchContainerRowTag.getRow();\n\n\t\t\tif (index <= -1) {\n\t\t\t\tList<SearchEntry> searchEntries = resultRow.getEntries();\n\n\t\t\t\tindex = searchEntries.size();\n\t\t\t}\n\n\t\t\tJSPSearchEntry jspSearchEntry = new JSPSearchEntry();\n\n\t\t\tjspSearchEntry.setAlign(getAlign());\n\t\t\tjspSearchEntry.setColspan(getColspan());\n\t\t\tjspSearchEntry.setCssClass(getCssClass());\n\t\t\tjspSearchEntry.setHref(String.valueOf(getHref()));\n\t\t\tjspSearchEntry.setPath(getPath());\n\t\t\tjspSearchEntry.setRequest(\n\t\t\t\t(HttpServletRequest)pageContext.getRequest());\n\t\t\tjspSearchEntry.setResponse(\n\t\t\t\t(HttpServletResponse)pageContext.getResponse());\n\t\t\tjspSearchEntry.setServletContext(pageContext.getServletContext());\n\t\t\tjspSearchEntry.setTruncate(getTruncate());\n\t\t\tjspSearchEntry.setValign(getValign());\n\n\t\t\tresultRow.addSearchEntry(index, jspSearchEntry);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\tindex = -1;\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\talign = SearchEntry.DEFAULT_ALIGN;\n\t\t\t\tcolspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t\tcssClass = SearchEntry.DEFAULT_CSS_CLASS;\n\t\t\t\tname = StringPool.BLANK;\n\t\t\t\t_path = null;\n\t\t\t\tvalign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t}\n\t\t}\n\t}","commit_id":"ee8c6a372c0a446fd6e024295ca3fb81585408ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag<R> searchContainerRowTag =\n\t\t\t\t(SearchContainerRowTag<R>)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow resultRow = searchContainerRowTag.getRow();\n\n\t\t\tif (Validator.isNotNull(_property)) {\n\t\t\t\t_value = String.valueOf(\n\t\t\t\t\tBeanPropertiesUtil.getObject(\n\t\t\t\t\t\tresultRow.getObject(), _property));\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(_buffer)) {\n\t\t\t\t_value = _sb.toString();\n\t\t\t}\n\t\t\telse if (_value == null) {\n\t\t\t\tBodyContent bodyContent = getBodyContent();\n\n\t\t\t\tif (bodyContent != null) {\n\t\t\t\t\t_value = bodyContent.getString();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject object = BeanPropertiesUtil.getObject(\n\t\t\t\t\t\tresultRow.getObject(), getName());\n\n\t\t\t\t\t_value = String.valueOf(object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_translate) {\n\t\t\t\t_value = LanguageUtil.get(request, _value);\n\t\t\t}\n\n\t\t\tif (index <= -1) {\n\t\t\t\tList<SearchEntry> searchEntries = resultRow.getEntries();\n\n\t\t\t\tindex = searchEntries.size();\n\t\t\t}\n\n\t\t\tif (resultRow.isRestricted()) {\n\t\t\t\t_href = null;\n\t\t\t}\n\n\t\t\tTextSearchEntry textSearchEntry = new TextSearchEntry();\n\n\t\t\ttextSearchEntry.setAlign(getAlign());\n\t\t\ttextSearchEntry.setColspan(getColspan());\n\t\t\ttextSearchEntry.setCssClass(getCssClass());\n\t\t\ttextSearchEntry.setHref((String)getHref());\n\t\t\ttextSearchEntry.setName(getValue());\n\t\t\ttextSearchEntry.setTarget(getTarget());\n\t\t\ttextSearchEntry.setTitle(getTitle());\n\t\t\ttextSearchEntry.setTruncate(getTruncate());\n\t\t\ttextSearchEntry.setValign(getValign());\n\n\t\t\tresultRow.addSearchEntry(index, textSearchEntry);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\tindex = -1;\n\t\t\t_value = null;\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\talign = SearchEntry.DEFAULT_ALIGN;\n\t\t\t\t_buffer = null;\n\t\t\t\tcolspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t\tcssClass = SearchEntry.DEFAULT_CSS_CLASS;\n\t\t\t\t_href = null;\n\t\t\t\tname = null;\n\t\t\t\t_orderable = false;\n\t\t\t\t_orderableProperty = null;\n\t\t\t\t_property = null;\n\t\t\t\t_sb = null;\n\t\t\t\t_target = null;\n\t\t\t\t_title = null;\n\t\t\t\t_translate = false;\n\t\t\t\tvalign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t}\n\t\t}\n\t}","id":76638,"modified_method":"@Override\n\tpublic int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag<R> searchContainerRowTag =\n\t\t\t\t(SearchContainerRowTag<R>)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow resultRow = searchContainerRowTag.getRow();\n\n\t\t\tif (Validator.isNotNull(_property)) {\n\t\t\t\t_value = String.valueOf(\n\t\t\t\t\tBeanPropertiesUtil.getObject(\n\t\t\t\t\t\tresultRow.getObject(), _property));\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(_buffer)) {\n\t\t\t\t_value = _sb.toString();\n\t\t\t}\n\t\t\telse if (_value == null) {\n\t\t\t\tBodyContent bodyContent = getBodyContent();\n\n\t\t\t\tif (bodyContent != null) {\n\t\t\t\t\t_value = bodyContent.getString();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject object = BeanPropertiesUtil.getObject(\n\t\t\t\t\t\tresultRow.getObject(), getName());\n\n\t\t\t\t\t_value = String.valueOf(object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_translate) {\n\t\t\t\t_value = LanguageUtil.get(request, _value);\n\t\t\t}\n\n\t\t\tif (index <= -1) {\n\t\t\t\tList<SearchEntry> searchEntries = resultRow.getEntries();\n\n\t\t\t\tindex = searchEntries.size();\n\t\t\t}\n\n\t\t\tif (resultRow.isRestricted()) {\n\t\t\t\t_href = null;\n\t\t\t}\n\n\t\t\tTextSearchEntry textSearchEntry = new TextSearchEntry();\n\n\t\t\ttextSearchEntry.setAlign(getAlign());\n\t\t\ttextSearchEntry.setColspan(getColspan());\n\t\t\ttextSearchEntry.setCssClass(getCssClass());\n\t\t\ttextSearchEntry.setHref(String.valueOf(getHref()));\n\t\t\ttextSearchEntry.setName(getValue());\n\t\t\ttextSearchEntry.setTarget(getTarget());\n\t\t\ttextSearchEntry.setTitle(getTitle());\n\t\t\ttextSearchEntry.setTruncate(getTruncate());\n\t\t\ttextSearchEntry.setValign(getValign());\n\n\t\t\tresultRow.addSearchEntry(index, textSearchEntry);\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\tindex = -1;\n\t\t\t_value = null;\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\talign = SearchEntry.DEFAULT_ALIGN;\n\t\t\t\t_buffer = null;\n\t\t\t\tcolspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t\tcssClass = SearchEntry.DEFAULT_CSS_CLASS;\n\t\t\t\t_href = null;\n\t\t\t\tname = null;\n\t\t\t\t_orderable = false;\n\t\t\t\t_orderableProperty = null;\n\t\t\t\t_property = null;\n\t\t\t\t_sb = null;\n\t\t\t\t_target = null;\n\t\t\t\t_title = null;\n\t\t\t\t_translate = false;\n\t\t\t\tvalign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t}\n\t\t}\n\t}","commit_id":"ee8c6a372c0a446fd6e024295ca3fb81585408ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void setup(boolean addShutdownHook, Settings settings, Environment environment) throws Exception {\n        setupSecurity(settings, environment);\n        if (settings.getAsBoolean(\"bootstrap.mlockall\", false)) {\n            Natives.tryMlockall();\n        }\n\n        NodeBuilder nodeBuilder = NodeBuilder.nodeBuilder().settings(settings).loadConfigSettings(false);\n        node = nodeBuilder.build();\n        if (addShutdownHook) {\n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                @Override\n                public void run() {\n                    node.close();\n                }\n            });\n        }\n\n        if (settings.getAsBoolean(\"bootstrap.ctrlhandler\", true)) {\n            Natives.addConsoleCtrlHandler(new ConsoleCtrlHandler() {\n                @Override\n                public boolean handle(int code) {\n                    if (CTRL_CLOSE_EVENT == code) {\n                        ESLogger logger = Loggers.getLogger(Bootstrap.class);\n                        logger.info(\"running graceful exit on windows\");\n\n                        System.exit(0);\n                        return true;\n                    }\n                    return false;\n                }\n            });\n        }\n    }","id":76639,"modified_method":"private void setup(boolean addShutdownHook, Settings settings, Environment environment) throws Exception {\n        if (settings.getAsBoolean(\"bootstrap.mlockall\", false)) {\n            Natives.tryMlockall();\n        }\n\n        NodeBuilder nodeBuilder = NodeBuilder.nodeBuilder().settings(settings).loadConfigSettings(false);\n        node = nodeBuilder.build();\n        if (addShutdownHook) {\n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                @Override\n                public void run() {\n                    node.close();\n                }\n            });\n        }\n\n        if (settings.getAsBoolean(\"bootstrap.ctrlhandler\", true)) {\n            Natives.addConsoleCtrlHandler(new ConsoleCtrlHandler() {\n                @Override\n                public boolean handle(int code) {\n                    if (CTRL_CLOSE_EVENT == code) {\n                        ESLogger logger = Loggers.getLogger(Bootstrap.class);\n                        logger.info(\"running graceful exit on windows\");\n\n                        System.exit(0);\n                        return true;\n                    }\n                    return false;\n                }\n            });\n        }\n        // install SM after natives, JNA can require strange permissions\n        setupSecurity(settings, environment);\n    }","commit_id":"f599c237bdee7624bd5a67cf26828ccac32dbcc7","url":"https://github.com/elastic/elasticsearch"},{"original_method":"static Path processTemplate(InputStream template, Environment environment) throws IOException {\n        Path processed = Files.createTempFile(null, null);\n        try (OutputStream output = new BufferedOutputStream(Files.newOutputStream(processed))) {\n            // copy the template as-is.\n            try (InputStream in = new BufferedInputStream(template)) {\n                ByteStreams.copy(in, output);\n            }\n            \n            // add permissions for all configured paths.\n            Set<Path> paths = new HashSet<>();\n            paths.add(environment.homeFile());\n            paths.add(environment.configFile());\n            paths.add(environment.logsFile());\n            paths.add(environment.pluginsFile());\n            for (Path path : environment.dataFiles()) {\n                paths.add(path);\n            }\n            for (Path path : environment.dataWithClusterFiles()) {\n                paths.add(path);\n            }\n            output.write(createPermissions(paths));\n        }\n        return processed;\n    }","id":76640,"modified_method":"static Path processTemplate(InputStream template, Environment environment) throws IOException {\n        Path processed = Files.createTempFile(null, null);\n        try (OutputStream output = new BufferedOutputStream(Files.newOutputStream(processed))) {\n            // copy the template as-is.\n            try (InputStream in = new BufferedInputStream(template)) {\n                ByteStreams.copy(in, output);\n            }\n\n            //  all policy files are UTF-8:\n            //  https://docs.oracle.com/javase/7/docs/technotes/guides/security/PolicyFiles.html\n            try (Writer writer = new OutputStreamWriter(output, StandardCharsets.UTF_8)) {\n                writer.write(System.lineSeparator());\n                writer.write(\"grant {\");\n                writer.write(System.lineSeparator());\n\n                // add permissions for all configured paths.\n                // TODO: improve test infra so we can reduce permissions where read/write\n                // is not really needed...\n                addPath(writer, environment.homeFile(), \"read,readlink,write,delete\");\n                addPath(writer, environment.configFile(), \"read,readlink,write,delete\");\n                addPath(writer, environment.logsFile(), \"read,readlink,write,delete\");\n                addPath(writer, environment.pluginsFile(), \"read,readlink,write,delete\");\n                for (Path path : environment.dataFiles()) {\n                    addPath(writer, path, \"read,readlink,write,delete\");\n                }\n                for (Path path : environment.dataWithClusterFiles()) {\n                    addPath(writer, path, \"read,readlink,write,delete\");\n                }\n\n                writer.write(\"};\");\n                writer.write(System.lineSeparator());\n            }\n        }\n        return processed;\n    }","commit_id":"f599c237bdee7624bd5a67cf26828ccac32dbcc7","url":"https://github.com/elastic/elasticsearch"},{"original_method":"static void addPath(Writer writer, String path, String permissions) throws IOException {\n        writer.write(\"permission java.io.FilePermission \\\"\" + path + \"\\\", \\\"\" + permissions + \"\\\";\");\n        writer.write(System.lineSeparator());\n    }","id":76641,"modified_method":"static void addPath(Writer writer, Path path, String permissions) throws IOException {\n        // paths may not exist yet\n        Files.createDirectories(path);\n        // add each path twice: once for itself, again for files underneath it\n        writer.write(\"permission java.io.FilePermission \\\"\" + encode(path) + \"\\\", \\\"\" + permissions + \"\\\";\");\n        writer.write(System.lineSeparator());\n        writer.write(\"permission java.io.FilePermission \\\"\" + encode(path) + \"${/}-\\\", \\\"\" + permissions + \"\\\";\");\n        writer.write(System.lineSeparator());\n    }","commit_id":"f599c237bdee7624bd5a67cf26828ccac32dbcc7","url":"https://github.com/elastic/elasticsearch"},{"original_method":"static String encode(Path path) {\n        return encode(path.toString());\n    }","id":76642,"modified_method":"static String encode(Path path) {\n        return path.toString().replace(\"\\\\\", \"\\\\\\\\\");\n    }","commit_id":"f599c237bdee7624bd5a67cf26828ccac32dbcc7","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public JComponent createComponent() {\n    for (UnnamedConfigurable provider : getConfigurables()) {\n      myAddonPanel.add(provider.createComponent(), new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0, 0, GridBagConstraints.NORTHWEST,\n                                                                            GridBagConstraints.NONE, new Insets(0,0,15,0), 0,0));\n    }\n    return myRootPanel;\n  }","id":76643,"modified_method":"@Override\n  public JComponent createComponent() {\n    for (UnnamedConfigurable provider : getConfigurables()) {\n      JComponent component = provider.createComponent();\n      if (component != null) {\n        myAddonPanel.add(component, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 0, 0, GridBagConstraints.NORTHWEST,\n                                                           GridBagConstraints.NONE, new Insets(0, 0, 15, 0), 0, 0));\n      }\n    }\n    return myRootPanel;\n  }","commit_id":"18ece6efa7ec7212151fe51d94b1a10734578d19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void updateSelection(@Nullable NamedConfigurable configurable) {\n    myDetails.setText(configurable != null ? configurable.getBannerSlogan() : null);\n\n    myCurrentConfigurable = configurable;\n\n    if (configurable != null) {\n      myDetails.setContent(configurable.createComponent());\n      if (!isInitialized(configurable)) {\n        configurable.reset();\n        initializeConfigurable(configurable);\n      }\n       myHistory.pushPlaceForElement(TREE_OBJECT, configurable.getEditableObject());\n    } else {\n      myDetails.setContent(null);\n      myDetails.setEmptyContentText(getEmptySelectionString());\n    }\n  }","id":76644,"modified_method":"protected void updateSelection(@Nullable NamedConfigurable configurable) {\n    myDetails.setText(configurable != null ? configurable.getBannerSlogan() : null);\n\n    myCurrentConfigurable = configurable;\n\n    if (configurable != null) {\n      final JComponent comp = configurable.createComponent();\n      if (comp == null) {\n        setEmpty();\n        LOG.error(\"createComponent() returned null. configurable=\" + configurable);\n      } else {\n        myDetails.setContent(comp);\n        if (!isInitialized(configurable)) {\n          configurable.reset();\n          initializeConfigurable(configurable);\n        }\n         myHistory.pushPlaceForElement(TREE_OBJECT, configurable.getEditableObject());\n      }\n    } else {\n      setEmpty();\n    }\n  }","commit_id":"bbd01b9341e72f8759976583a01e159d74967b3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GeneralCodeStylePanel(CodeStyleSettings settings) {\n    super(settings);\n\n    myLineSeparatorCombo.addItem(SYSTEM_DEPENDANT_STRING);\n    myLineSeparatorCombo.addItem(UNIX_STRING);\n    myLineSeparatorCombo.addItem(WINDOWS_STRING);\n    myLineSeparatorCombo.addItem(MACINTOSH_STRING);\n    addPanelToWatch(myPanel);\n\n    myRightMarginSpinner.setModel(new SpinnerNumberModel(settings.getDefaultRightMargin(), 1, 1000000, 1));\n\n    myEnableFormatterTags.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        boolean tagsEnabled = myEnableFormatterTags.isSelected();\n        setFormatterTagControlsEnabled(tagsEnabled);\n      }\n    });\n\n    myAutodetectIndentsBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        boolean isDetectIndent = myAutodetectIndentsBox.isSelected();\n        myShowDetectedIndentNotification.setEnabled(isDetectIndent);\n      }\n    });\n\n    myDefaultOptionsPanel\n      .setBorder(IdeBorderFactory.createTitledBorder(ApplicationBundle.message(\"settings.code.style.general.default.options\")));\n    myIndentsDetectionPanel\n      .setBorder(IdeBorderFactory.createTitledBorder(ApplicationBundle.message(\"settings.code.style.general.indents.detection\")));\n\n    myMarkersPanel.setBorder(IdeBorderFactory.createTitledBorder(\n      ApplicationBundle.message(\"settings.code.style.general.formatter.marker.title\"), true));\n    myMarkerOptionsPanel.setBorder(\n      IdeBorderFactory.createTitledBorder(ApplicationBundle.message(\"settings.code.style.general.formatter.marker.options.title\"), true));\n    myPanel.setBorder(JBUI.Borders.empty(10, 10));\n    myScrollPane = ScrollPaneFactory.createScrollPane(null, true);\n    myScrollPane.setViewport(new GradientViewport(myPanel, JBUI.insetsTop(5), true));\n    myScrollPane.getVerticalScrollBar().setUnitIncrement(JBUI.scale(10));\n\n    myAdditionalSettingsPanel.setLayout(new VerticalFlowLayout(true, true));\n    myAdditionalSettingsPanel.removeAll();\n    myAdditionalOptions = ConfigurableWrapper.createConfigurables(GeneralCodeStyleOptionsProviderEP.EP_NAME);\n    for (GeneralCodeStyleOptionsProvider provider : myAdditionalOptions) {\n      myAdditionalSettingsPanel.add(provider.createComponent());\n    }\n  }","id":76645,"modified_method":"public GeneralCodeStylePanel(CodeStyleSettings settings) {\n    super(settings);\n\n    //noinspection unchecked\n    myLineSeparatorCombo.addItem(SYSTEM_DEPENDANT_STRING);\n    //noinspection unchecked\n    myLineSeparatorCombo.addItem(UNIX_STRING);\n    //noinspection unchecked\n    myLineSeparatorCombo.addItem(WINDOWS_STRING);\n    //noinspection unchecked\n    myLineSeparatorCombo.addItem(MACINTOSH_STRING);\n    addPanelToWatch(myPanel);\n\n    myRightMarginSpinner.setModel(new SpinnerNumberModel(settings.getDefaultRightMargin(), 1, 1000000, 1));\n\n    myEnableFormatterTags.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        boolean tagsEnabled = myEnableFormatterTags.isSelected();\n        setFormatterTagControlsEnabled(tagsEnabled);\n      }\n    });\n\n    myAutodetectIndentsBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        boolean isDetectIndent = myAutodetectIndentsBox.isSelected();\n        myShowDetectedIndentNotification.setEnabled(isDetectIndent);\n      }\n    });\n\n    myDefaultOptionsPanel\n      .setBorder(IdeBorderFactory.createTitledBorder(ApplicationBundle.message(\"settings.code.style.general.default.options\")));\n    myIndentsDetectionPanel\n      .setBorder(IdeBorderFactory.createTitledBorder(ApplicationBundle.message(\"settings.code.style.general.indents.detection\")));\n\n    myMarkersPanel.setBorder(IdeBorderFactory.createTitledBorder(\n      ApplicationBundle.message(\"settings.code.style.general.formatter.marker.title\"), true));\n    myMarkerOptionsPanel.setBorder(\n      IdeBorderFactory.createTitledBorder(ApplicationBundle.message(\"settings.code.style.general.formatter.marker.options.title\"), true));\n    myPanel.setBorder(JBUI.Borders.empty(10, 10));\n    myScrollPane = ScrollPaneFactory.createScrollPane(null, true);\n    myScrollPane.setViewport(new GradientViewport(myPanel, JBUI.insetsTop(5), true));\n    myScrollPane.getVerticalScrollBar().setUnitIncrement(JBUI.scale(10));\n\n    myAdditionalSettingsPanel.setLayout(new VerticalFlowLayout(true, true));\n    myAdditionalSettingsPanel.removeAll();\n    myAdditionalOptions = ConfigurableWrapper.createConfigurables(GeneralCodeStyleOptionsProviderEP.EP_NAME);\n    for (GeneralCodeStyleOptionsProvider provider : myAdditionalOptions) {\n      JComponent generalSettingsComponent = provider.createComponent();\n      if (generalSettingsComponent != null) {\n        myAdditionalSettingsPanel.add(generalSettingsComponent);\n      }\n    }\n  }","commit_id":"7a24b505626657602f55cc8a43bf503dd2d0bf18","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Query the index. Returns a node set containing all matching nodes. Each node\n     * in the node set has a {@link org.exist.indexing.lucene.LuceneIndexWorker.LuceneMatch}\n     * element attached, which stores the score and a link to the query which generated it.\n     *\n     * @param context current XQuery context\n     * @param contextId current context id, identify to track the position inside nested XPath predicates\n     * @param docs query will be restricted to documents in this set\n     * @param contextSet if specified, returned nodes will be descendants of the nodes in this set\n     * @param qnames query will be restricted to nodes with the qualified names given here\n     * @param queryRoot an XML representation of the query, see {@link XMLToQuery}.\n     * @param axis which node is returned: the node in which a match was found or the corresponding ancestor\n     *  from the contextSet\n     * @return node set containing all matching nodes\n     *\n     * @throws IOException\n     * @throws ParseException\n     */\n    public NodeSet query(XQueryContext context, int contextId, DocumentSet docs, NodeSet contextSet,\n                         List qnames, Element queryRoot, int axis, Properties options)\n            throws IOException, ParseException, XPathException {\n        if (qnames == null || qnames.isEmpty())\n            qnames = getDefinedIndexes();\n        NodeSet resultSet = new NewArrayNodeSet();\n        boolean returnAncestor = axis == NodeSet.ANCESTOR;\n        IndexSearcher searcher = null;\n        try {\n            searcher = index.getSearcher();\n            for (int i = 0; i < qnames.size(); i++) {\n                QName qname = (QName) qnames.get(i);\n                String field = encodeQName(qname);\n                analyzer = getAnalyzer(qname, context.getBroker(), docs);\n                Query query = queryTranslator.parse(field, queryRoot, analyzer, options);\n                LuceneHitCollector collector = new LuceneHitCollector();\n                searcher.search(query, collector);\n                processHits(collector.getDocs(), searcher, contextId, docs, contextSet, resultSet, returnAncestor, query);\n            }\n        } finally {\n            index.releaseSearcher(searcher);\n        }\n        return resultSet;\n    }","id":76646,"modified_method":"/**\n     * Query the index. Returns a node set containing all matching nodes. Each node\n     * in the node set has a {@link org.exist.indexing.lucene.LuceneIndexWorker.LuceneMatch}\n     * element attached, which stores the score and a link to the query which generated it.\n     *\n     * @param context current XQuery context\n     * @param contextId current context id, identify to track the position inside nested XPath predicates\n     * @param docs query will be restricted to documents in this set\n     * @param contextSet if specified, returned nodes will be descendants of the nodes in this set\n     * @param qnames query will be restricted to nodes with the qualified names given here\n     * @param queryRoot an XML representation of the query, see {@link XMLToQuery}.\n     * @param axis which node is returned: the node in which a match was found or the corresponding ancestor\n     *  from the contextSet\n     * @return node set containing all matching nodes\n     *\n     * @throws IOException\n     * @throws ParseException\n     */\n    public NodeSet query(XQueryContext context, int contextId, DocumentSet docs, NodeSet contextSet,\n                         List qnames, Element queryRoot, int axis, Properties options)\n            throws IOException, ParseException, XPathException {\n        if (qnames == null || qnames.isEmpty())\n            qnames = getDefinedIndexes();\n        NodeSet resultSet = new NewArrayNodeSet();\n        boolean returnAncestor = axis == NodeSet.ANCESTOR;\n        IndexSearcher searcher = null;\n        try {\n            searcher = index.getSearcher();\n            for (int i = 0; i < qnames.size(); i++) {\n                QName qname = (QName) qnames.get(i);\n                String field = encodeQName(qname);\n                analyzer = getAnalyzer(qname, context.getBroker(), docs);\n                Query query = queryTranslator.parse(field, queryRoot, analyzer, options);\n                if (query != null) {\n\t                LuceneHitCollector collector = new LuceneHitCollector();\n\t                searcher.search(query, collector);\n\t                processHits(collector.getDocs(), searcher, contextId, docs, contextSet, resultSet, returnAncestor, query);\n                }\n            }\n        } finally {\n            index.releaseSearcher(searcher);\n        }\n        return resultSet;\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"private SpanQuery[] parseSpanChildren(String field, Element node, Analyzer analyzer) throws XPathException {\n        List<SpanQuery> list = new ArrayList<SpanQuery>(8);\n        Node child = node.getFirstChild();\n        while (child != null) {\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                if (\"term\".equals(child.getLocalName()))\n                    list.add(getSpanTerm(field, (Element) child));\n                else if (\"near\".equals(child.getLocalName()))\n                    list.add(nearQuery(field, (Element) child, analyzer));\n                else if (\"first\".equals(child.getLocalName()))\n                    list.add(getSpanFirst(field, (Element) child, analyzer));\n                else\n                    throw new XPathException(\"Unknown query element: \" + child.getNodeName());\n            }\n            child = child.getNextSibling();\n        }\n        return list.toArray(new SpanQuery[list.size()]);\n    }","id":76647,"modified_method":"private SpanQuery[] parseSpanChildren(String field, Element node, Analyzer analyzer) throws XPathException {\n        List<SpanQuery> list = new ArrayList<SpanQuery>(8);\n        Node child = node.getFirstChild();\n        while (child != null) {\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                if (\"term\".equals(child.getLocalName()))\n                    getSpanTerm(list, field, (Element) child, analyzer);\n                else if (\"near\".equals(child.getLocalName()))\n                    list.add(nearQuery(field, (Element) child, analyzer));\n                else if (\"first\".equals(child.getLocalName()))\n                    list.add(getSpanFirst(field, (Element) child, analyzer));\n                else\n                    throw new XPathException(\"Unknown query element: \" + child.getNodeName());\n            }\n            child = child.getNextSibling();\n        }\n        return list.toArray(new SpanQuery[list.size()]);\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"private Query termQuery(String field, Element node) {\n        return new TermQuery(new Term(field, getText(node)));\n    }","id":76648,"modified_method":"private Query termQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n    \tString termStr = getTerm(field, getText(node), analyzer);\n    \treturn termStr == null ? null : new TermQuery(new Term(field, termStr));\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"private SpanQuery nearQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n        int slop = getSlop(node);\n        if (slop < 0)\n            slop = 0;\n        boolean inOrder = true;\n        if (node.hasAttribute(\"ordered\"))\n            inOrder = node.getAttribute(\"ordered\").equals(\"yes\");\n\n        if (!hasElementContent(node)) {\n            String qstr = getText(node);\n            TokenStream stream = analyzer.tokenStream(field, new StringReader(qstr));\n            List<SpanTermQuery> list = new ArrayList<SpanTermQuery>(8);\n            Token token = new Token();\n            try {\n                while ((token = stream.next(token)) != null) {\n                    String str = new String(token.termBuffer(), 0, token.termLength());\n                    list.add(new SpanTermQuery(new Term(field, str)));\n                }\n            } catch (IOException e) {\n                throw new XPathException(\"Error while parsing phrase query: \" + qstr);\n            }\n\n            return new SpanNearQuery(list.toArray(new SpanTermQuery[list.size()]), slop, inOrder);\n        } else {\n            SpanQuery[] children = parseSpanChildren(field, node, analyzer);\n            return new SpanNearQuery(children, slop, inOrder);\n        }\n    }","id":76649,"modified_method":"private SpanQuery nearQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n        int slop = getSlop(node);\n        if (slop < 0)\n            slop = 0;\n        boolean inOrder = true;\n        if (node.hasAttribute(\"ordered\"))\n            inOrder = node.getAttribute(\"ordered\").equals(\"yes\");\n\n        if (!hasElementContent(node)) {\n            String qstr = getText(node);\n            TokenStream stream = analyzer.tokenStream(field, new StringReader(qstr));\n            TermAttribute termAttr = (TermAttribute) stream.addAttribute(TermAttribute.class);\n            List<SpanTermQuery> list = new ArrayList<SpanTermQuery>(8);\n            try {\n            \tstream.reset();\n                while (stream.incrementToken()) {\n                    list.add(new SpanTermQuery(new Term(field, termAttr.term())));\n                }\n                stream.end();\n                stream.close();\n            } catch (IOException e) {\n                throw new XPathException(\"Error while parsing phrase query: \" + qstr);\n            }\n\n            return new SpanNearQuery(list.toArray(new SpanTermQuery[list.size()]), slop, inOrder);\n        } else {\n            SpanQuery[] children = parseSpanChildren(field, node, analyzer);\n            return new SpanNearQuery(children, slop, inOrder);\n        }\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"public Query parse(String field, Element root, Analyzer analyzer, Properties options) throws XPathException {\n        Query query;\n        String localName = root.getLocalName();\n        if (\"query\".equals(localName))\n            query = parseChildren(field, root, analyzer, options);\n        else if (\"term\".equals(localName))\n            query = termQuery(field, root);\n        else if (\"wildcard\".equals(localName))\n            query = wildcardQuery(field, root, options);\n        else if (\"prefix\".equals(localName))\n            query = prefixQuery(field, root, options);\n        else if (\"fuzzy\".equals(localName))\n            query = fuzzyQuery(field, root);\n        else if (\"bool\".equals(localName))\n            query = booleanQuery(field, root, analyzer, options);\n        else if (\"phrase\".equals(localName))\n            query = phraseQuery(field, root, analyzer);\n        else if (\"near\".equals(localName))\n            query = nearQuery(field, root, analyzer);\n        else if (\"first\".equals(localName))\n            query = getSpanFirst(field, root, analyzer);\n        else if (\"regex\".equals(localName))\n            query = regexQuery(field, root, options);\n        else\n            throw new XPathException(\"Unknown element in lucene query expression: \" + localName);\n        setBoost(root, query);\n        return query;\n    }","id":76650,"modified_method":"public Query parse(String field, Element root, Analyzer analyzer, Properties options) throws XPathException {\n        Query query;\n        String localName = root.getLocalName();\n        if (\"query\".equals(localName))\n            query = parseChildren(field, root, analyzer, options);\n        else if (\"term\".equals(localName))\n            query = termQuery(field, root, analyzer);\n        else if (\"wildcard\".equals(localName))\n            query = wildcardQuery(field, root, options);\n        else if (\"prefix\".equals(localName))\n            query = prefixQuery(field, root, options);\n        else if (\"fuzzy\".equals(localName))\n            query = fuzzyQuery(field, root);\n        else if (\"bool\".equals(localName))\n            query = booleanQuery(field, root, analyzer, options);\n        else if (\"phrase\".equals(localName))\n            query = phraseQuery(field, root, analyzer);\n        else if (\"near\".equals(localName))\n            query = nearQuery(field, root, analyzer);\n        else if (\"first\".equals(localName))\n            query = getSpanFirst(field, root, analyzer);\n        else if (\"regex\".equals(localName))\n            query = regexQuery(field, root, options);\n        else\n            throw new XPathException(\"Unknown element in lucene query expression: \" + localName);\n        if (query != null)\n        \tsetBoost(root, query);\n        return query;\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"private Query phraseQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n        NodeList termList = node.getElementsByTagName(\"term\");\n        if (termList.getLength() == 0) {\n            PhraseQuery query = new PhraseQuery();\n            String qstr = getText(node);\n            TokenStream stream = analyzer.tokenStream(field, new StringReader(qstr));\n            Token token = new Token();\n            try {\n                while ((token = stream.next(token)) != null) {\n                    String str = new String(token.termBuffer(), 0, token.termLength());\n                    query.add(new Term(field, str));\n                }\n            } catch (IOException e) {\n                throw new XPathException(\"Error while parsing phrase query: \" + qstr);\n            }\n            int slop = getSlop(node);\n            if (slop > -1)\n                query.setSlop(slop);\n            return query;\n        } else {\n            MultiPhraseQuery query = new MultiPhraseQuery();\n            for (int i = 0; i < termList.getLength(); i++) {\n                Element elem = (Element) termList.item(i);\n                String text = getText(elem);\n                if (text.indexOf('?') > -1 || text.indexOf('*') > 0) {\n                    Term[] expanded = expandTerms(field, text);\n                    if (expanded.length > 0)\n                        query.add(expanded);\n                } else\n                    query.add(new Term(field, text));\n            }\n            int slop = getSlop(node);\n            if (slop > -1)\n                query.setSlop(slop);\n            return query;\n        }\n    }","id":76651,"modified_method":"private Query phraseQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n        NodeList termList = node.getElementsByTagName(\"term\");\n        if (termList.getLength() == 0) {\n            PhraseQuery query = new PhraseQuery();\n            String qstr = getText(node);\n            TokenStream stream = analyzer.tokenStream(field, new StringReader(qstr));\n            TermAttribute termAttr = (TermAttribute) stream.addAttribute(TermAttribute.class);\n            try {\n            \tstream.reset();\n                while (stream.incrementToken()) {\n                    query.add(new Term(field, termAttr.term()));\n                }\n                stream.end();\n                stream.close();\n            } catch (IOException e) {\n                throw new XPathException(\"Error while parsing phrase query: \" + qstr);\n            }\n            int slop = getSlop(node);\n            if (slop > -1)\n                query.setSlop(slop);\n            return query;\n        } else {\n            MultiPhraseQuery query = new MultiPhraseQuery();\n            for (int i = 0; i < termList.getLength(); i++) {\n                Element elem = (Element) termList.item(i);\n                String text = getText(elem);\n                if (text.indexOf('?') > -1 || text.indexOf('*') > 0) {\n                    Term[] expanded = expandTerms(field, text);\n                    if (expanded.length > 0)\n                        query.add(expanded);\n                } else {\n                \tString termStr = getTerm(field, text, analyzer);\n                \tif (termStr != null)\n                \t\tquery.add(new Term(field, text));\n                }\n            }\n            int slop = getSlop(node);\n            if (slop > -1)\n                query.setSlop(slop);\n            return query;\n        }\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"private SpanQuery getSpanFirst(String field, Element node, Analyzer analyzer) throws XPathException {\n        SpanQuery query;\n        if (hasElementContent(node)) {\n            SpanQuery[] children = parseSpanChildren(field, node, analyzer);\n            if (children.length != 1)\n                throw new XPathException(\"Query element 'first' expects exactly one child element\");\n            query = children[0];\n        } else {\n            query = new SpanTermQuery(new Term(field, getText(node)));\n        }\n        int end = 0;\n        if (node.hasAttribute(\"end\")) {\n            try {\n                end = Integer.parseInt(node.getAttribute(\"end\"));\n            } catch (NumberFormatException e) {\n                throw new XPathException(\"Attribute 'end' to query element 'first' should be a \" +\n                        \"valid integer. Got: \" + node.getAttribute(\"end\"));\n            }\n        }\n        return new SpanFirstQuery(query, end);\n    }","id":76652,"modified_method":"private SpanQuery getSpanFirst(String field, Element node, Analyzer analyzer) throws XPathException {\n    \tint slop = getSlop(node);\n        if (slop < 0)\n            slop = 0;\n        boolean inOrder = true;\n        if (node.hasAttribute(\"ordered\"))\n            inOrder = node.getAttribute(\"ordered\").equals(\"yes\");\n        SpanQuery query = null;\n        if (hasElementContent(node)) {\n            SpanQuery[] children = parseSpanChildren(field, node, analyzer);\n            query = new SpanNearQuery(children, slop, inOrder);\n        } else {\n        \tString termStr = getTerm(field, getText(node), analyzer);\n        \tif (termStr != null)\n        \t\tquery = new SpanTermQuery(new Term(field, termStr));\n        }\n        int end = 0;\n        if (node.hasAttribute(\"end\")) {\n            try {\n                end = Integer.parseInt(node.getAttribute(\"end\"));\n            } catch (NumberFormatException e) {\n                throw new XPathException(\"Attribute 'end' to query element 'first' should be a \" +\n                        \"valid integer. Got: \" + node.getAttribute(\"end\"));\n            }\n        }\n        return query != null ? new SpanFirstQuery(query, end) : null;\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"private SpanQuery getSpanTerm(String field, Element node) {\n        return new SpanTermQuery(new Term(field, getText(node)));\n    }","id":76653,"modified_method":"private void getSpanTerm(List<SpanQuery> list, String field, Element node, Analyzer analyzer) throws XPathException {\n    \tString termStr = getTerm(field, getText(node), analyzer);\n    \tif (termStr != null)\n    \t\tlist.add(new SpanTermQuery(new Term(field, termStr)));\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"private Query booleanQuery(String field, Element node, Analyzer analyzer, Properties options) throws XPathException {\n        BooleanQuery query = new BooleanQuery();\n        Node child = node.getFirstChild();\n        while (child != null) {\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                Element elem = (Element) child;\n                Query childQuery = parse(field, elem, analyzer, options);\n                BooleanClause.Occur occur = getOccur(elem);\n                query.add(childQuery, occur);\n            }\n            child = child.getNextSibling();\n        }\n        return query;\n    }","id":76654,"modified_method":"private Query booleanQuery(String field, Element node, Analyzer analyzer, Properties options) throws XPathException {\n        BooleanQuery query = new BooleanQuery();\n        Node child = node.getFirstChild();\n        while (child != null) {\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                Element elem = (Element) child;\n                Query childQuery = parse(field, elem, analyzer, options);\n                if (childQuery != null) {\n\t                BooleanClause.Occur occur = getOccur(elem);\n\t                query.add(childQuery, occur);\n                }\n            }\n            child = child.getNextSibling();\n        }\n        return query;\n    }","commit_id":"e584474cd16ade1ce1d8220409ecf847a63c1641","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Query the index. Returns a node set containing all matching nodes. Each node\n     * in the node set has a {@link org.exist.indexing.lucene.LuceneIndexWorker.LuceneMatch}\n     * element attached, which stores the score and a link to the query which generated it.\n     *\n     * @param context current XQuery context\n     * @param contextId current context id, identify to track the position inside nested XPath predicates\n     * @param docs query will be restricted to documents in this set\n     * @param contextSet if specified, returned nodes will be descendants of the nodes in this set\n     * @param qnames query will be restricted to nodes with the qualified names given here\n     * @param queryRoot an XML representation of the query, see {@link XMLToQuery}.\n     * @param axis which node is returned: the node in which a match was found or the corresponding ancestor\n     *  from the contextSet\n     * @return node set containing all matching nodes\n     *\n     * @throws IOException\n     * @throws ParseException\n     */\n    public NodeSet query(XQueryContext context, int contextId, DocumentSet docs, NodeSet contextSet,\n                         List<QName> qnames, Element queryRoot, int axis, Properties options)\n            throws IOException, ParseException, XPathException {\n        if (qnames == null || qnames.isEmpty())\n            qnames = getDefinedIndexes();\n        NodeSet resultSet = new NewArrayNodeSet();\n        boolean returnAncestor = axis == NodeSet.ANCESTOR;\n        IndexSearcher searcher = null;\n        try {\n            searcher = index.getSearcher();\n            for (QName qname : qnames) {\n                String field = encodeQName(qname);\n                analyzer = getAnalyzer(qname, context.getBroker(), docs);\n                Query query = queryTranslator.parse(field, queryRoot, analyzer, options);\n                LuceneHitCollector collector = new LuceneHitCollector();\n                searcher.search(query, collector);\n                processHits(collector.getDocs(), searcher, contextId, docs, contextSet, resultSet, returnAncestor, query);\n            }\n        } finally {\n            index.releaseSearcher(searcher);\n        }\n        return resultSet;\n    }","id":76655,"modified_method":"/**\n     * Query the index. Returns a node set containing all matching nodes. Each node\n     * in the node set has a {@link org.exist.indexing.lucene.LuceneIndexWorker.LuceneMatch}\n     * element attached, which stores the score and a link to the query which generated it.\n     *\n     * @param context current XQuery context\n     * @param contextId current context id, identify to track the position inside nested XPath predicates\n     * @param docs query will be restricted to documents in this set\n     * @param contextSet if specified, returned nodes will be descendants of the nodes in this set\n     * @param qnames query will be restricted to nodes with the qualified names given here\n     * @param queryRoot an XML representation of the query, see {@link XMLToQuery}.\n     * @param axis which node is returned: the node in which a match was found or the corresponding ancestor\n     *  from the contextSet\n     * @return node set containing all matching nodes\n     *\n     * @throws IOException\n     * @throws ParseException\n     */\n    public NodeSet query(XQueryContext context, int contextId, DocumentSet docs, NodeSet contextSet,\n                         List<QName> qnames, Element queryRoot, int axis, Properties options)\n            throws IOException, ParseException, XPathException {\n        if (qnames == null || qnames.isEmpty())\n            qnames = getDefinedIndexes();\n        NodeSet resultSet = new NewArrayNodeSet();\n        boolean returnAncestor = axis == NodeSet.ANCESTOR;\n        IndexSearcher searcher = null;\n        try {\n            searcher = index.getSearcher();\n            for (QName qname : qnames) {\n                String field = encodeQName(qname);\n                analyzer = getAnalyzer(qname, context.getBroker(), docs);\n                Query query = queryTranslator.parse(field, queryRoot, analyzer, options);\n                if (query != null) {\n\t                LuceneHitCollector collector = new LuceneHitCollector();\n\t                searcher.search(query, collector);\n\t                processHits(collector.getDocs(), searcher, contextId, docs, contextSet, resultSet, returnAncestor, query);\n                }\n            }\n        } finally {\n            index.releaseSearcher(searcher);\n        }\n        return resultSet;\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"private Query phraseQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n        NodeList termList = node.getElementsByTagName(\"term\");\n        if (termList.getLength() == 0) {\n            PhraseQuery query = new PhraseQuery();\n            String qstr = getText(node);\n            TokenStream stream = analyzer.tokenStream(field, new StringReader(qstr));\n            Token token = new Token();\n            try {\n                while ((token = stream.next(token)) != null) {\n                    String str = new String(token.termBuffer(), 0, token.termLength());\n                    query.add(new Term(field, str));\n                }\n            } catch (IOException e) {\n                throw new XPathException(\"Error while parsing phrase query: \" + qstr);\n            }\n            int slop = getSlop(node);\n            if (slop > -1)\n                query.setSlop(slop);\n            return query;\n        } else {\n            MultiPhraseQuery query = new MultiPhraseQuery();\n            for (int i = 0; i < termList.getLength(); i++) {\n                Element elem = (Element) termList.item(i);\n                String text = getText(elem);\n                if (text.indexOf('?') > -1 || text.indexOf('*') > 0) {\n                    Term[] expanded = expandTerms(field, text);\n                    if (expanded.length > 0)\n                        query.add(expanded);\n                } else\n                    query.add(new Term(field, text));\n            }\n            int slop = getSlop(node);\n            if (slop > -1)\n                query.setSlop(slop);\n            return query;\n        }\n    }","id":76656,"modified_method":"private Query phraseQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n        NodeList termList = node.getElementsByTagName(\"term\");\n        if (termList.getLength() == 0) {\n            PhraseQuery query = new PhraseQuery();\n            String qstr = getText(node);\n            TokenStream stream = analyzer.tokenStream(field, new StringReader(qstr));\n            TermAttribute termAttr = (TermAttribute) stream.addAttribute(TermAttribute.class);\n            try {\n            \tstream.reset();\n                while (stream.incrementToken()) {\n                    query.add(new Term(field, termAttr.term()));\n                }\n                stream.end();\n                stream.close();\n            } catch (IOException e) {\n                throw new XPathException(\"Error while parsing phrase query: \" + qstr);\n            }\n            int slop = getSlop(node);\n            if (slop > -1)\n                query.setSlop(slop);\n            return query;\n        } else {\n            MultiPhraseQuery query = new MultiPhraseQuery();\n            for (int i = 0; i < termList.getLength(); i++) {\n                Element elem = (Element) termList.item(i);\n                String text = getText(elem);\n                if (text.indexOf('?') > -1 || text.indexOf('*') > 0) {\n                    Term[] expanded = expandTerms(field, text);\n                    if (expanded.length > 0)\n                        query.add(expanded);\n                } else {\n                \tString termStr = getTerm(field, text, analyzer);\n                \tif (termStr != null)\n                \t\tquery.add(new Term(field, text));\n                }\n            }\n            int slop = getSlop(node);\n            if (slop > -1)\n                query.setSlop(slop);\n            return query;\n        }\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"private SpanQuery[] parseSpanChildren(String field, Element node, Analyzer analyzer) throws XPathException {\n        List<SpanQuery> list = new ArrayList<SpanQuery>(8);\n        Node child = node.getFirstChild();\n        while (child != null) {\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                if (\"term\".equals(child.getLocalName()))\n                    list.add(getSpanTerm(field, (Element) child));\n                else if (\"near\".equals(child.getLocalName()))\n                    list.add(nearQuery(field, (Element) child, analyzer));\n                else if (\"first\".equals(child.getLocalName()))\n                    list.add(getSpanFirst(field, (Element) child, analyzer));\n                else\n                    throw new XPathException(\"Unknown query element: \" + child.getNodeName());\n            }\n            child = child.getNextSibling();\n        }\n        return list.toArray(new SpanQuery[list.size()]);\n    }","id":76657,"modified_method":"private SpanQuery[] parseSpanChildren(String field, Element node, Analyzer analyzer) throws XPathException {\n        List<SpanQuery> list = new ArrayList<SpanQuery>(8);\n        Node child = node.getFirstChild();\n        while (child != null) {\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                if (\"term\".equals(child.getLocalName()))\n                    getSpanTerm(list, field, (Element) child, analyzer);\n                else if (\"near\".equals(child.getLocalName()))\n                    list.add(nearQuery(field, (Element) child, analyzer));\n                else if (\"first\".equals(child.getLocalName()))\n                    list.add(getSpanFirst(field, (Element) child, analyzer));\n                else\n                    throw new XPathException(\"Unknown query element: \" + child.getNodeName());\n            }\n            child = child.getNextSibling();\n        }\n        return list.toArray(new SpanQuery[list.size()]);\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"private SpanQuery getSpanFirst(String field, Element node, Analyzer analyzer) throws XPathException {\n        SpanQuery query;\n        if (hasElementContent(node)) {\n            SpanQuery[] children = parseSpanChildren(field, node, analyzer);\n            if (children.length != 1)\n                throw new XPathException(\"Query element 'first' expects exactly one child element\");\n            query = children[0];\n        } else {\n            query = new SpanTermQuery(new Term(field, getText(node)));\n        }\n        int end = 0;\n        if (node.hasAttribute(\"end\")) {\n            try {\n                end = Integer.parseInt(node.getAttribute(\"end\"));\n            } catch (NumberFormatException e) {\n                throw new XPathException(\"Attribute 'end' to query element 'first' should be a \" +\n                        \"valid integer. Got: \" + node.getAttribute(\"end\"));\n            }\n        }\n        return new SpanFirstQuery(query, end);\n    }","id":76658,"modified_method":"private SpanQuery getSpanFirst(String field, Element node, Analyzer analyzer) throws XPathException {\n    \tint slop = getSlop(node);\n        if (slop < 0)\n            slop = 0;\n        boolean inOrder = true;\n        if (node.hasAttribute(\"ordered\"))\n            inOrder = node.getAttribute(\"ordered\").equals(\"yes\");\n        SpanQuery query = null;\n        if (hasElementContent(node)) {\n            SpanQuery[] children = parseSpanChildren(field, node, analyzer);\n            query = new SpanNearQuery(children, slop, inOrder);\n        } else {\n        \tString termStr = getTerm(field, getText(node), analyzer);\n        \tif (termStr != null)\n        \t\tquery = new SpanTermQuery(new Term(field, termStr));\n        }\n        int end = 0;\n        if (node.hasAttribute(\"end\")) {\n            try {\n                end = Integer.parseInt(node.getAttribute(\"end\"));\n            } catch (NumberFormatException e) {\n                throw new XPathException(\"Attribute 'end' to query element 'first' should be a \" +\n                        \"valid integer. Got: \" + node.getAttribute(\"end\"));\n            }\n        }\n        return query != null ? new SpanFirstQuery(query, end) : null;\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"private SpanQuery getSpanTerm(String field, Element node) {\n        return new SpanTermQuery(new Term(field, getText(node)));\n    }","id":76659,"modified_method":"private void getSpanTerm(List<SpanQuery> list, String field, Element node, Analyzer analyzer) throws XPathException {\n    \tString termStr = getTerm(field, getText(node), analyzer);\n    \tif (termStr != null)\n    \t\tlist.add(new SpanTermQuery(new Term(field, termStr)));\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"public Query parse(String field, Element root, Analyzer analyzer, Properties options) throws XPathException {\n        Query query;\n        String localName = root.getLocalName();\n        if (\"query\".equals(localName))\n            query = parseChildren(field, root, analyzer, options);\n        else if (\"term\".equals(localName))\n            query = termQuery(field, root);\n        else if (\"wildcard\".equals(localName))\n            query = wildcardQuery(field, root, options);\n        else if (\"prefix\".equals(localName))\n            query = prefixQuery(field, root, options);\n        else if (\"fuzzy\".equals(localName))\n            query = fuzzyQuery(field, root);\n        else if (\"bool\".equals(localName))\n            query = booleanQuery(field, root, analyzer, options);\n        else if (\"phrase\".equals(localName))\n            query = phraseQuery(field, root, analyzer);\n        else if (\"near\".equals(localName))\n            query = nearQuery(field, root, analyzer);\n        else if (\"first\".equals(localName))\n            query = getSpanFirst(field, root, analyzer);\n        else if (\"regex\".equals(localName))\n            query = regexQuery(field, root, options);\n        else\n            throw new XPathException(\"Unknown element in lucene query expression: \" + localName);\n        setBoost(root, query);\n        return query;\n    }","id":76660,"modified_method":"public Query parse(String field, Element root, Analyzer analyzer, Properties options) throws XPathException {\n        Query query;\n        String localName = root.getLocalName();\n        if (\"query\".equals(localName))\n            query = parseChildren(field, root, analyzer, options);\n        else if (\"term\".equals(localName))\n            query = termQuery(field, root, analyzer);\n        else if (\"wildcard\".equals(localName))\n            query = wildcardQuery(field, root, options);\n        else if (\"prefix\".equals(localName))\n            query = prefixQuery(field, root, options);\n        else if (\"fuzzy\".equals(localName))\n            query = fuzzyQuery(field, root);\n        else if (\"bool\".equals(localName))\n            query = booleanQuery(field, root, analyzer, options);\n        else if (\"phrase\".equals(localName))\n            query = phraseQuery(field, root, analyzer);\n        else if (\"near\".equals(localName))\n            query = nearQuery(field, root, analyzer);\n        else if (\"first\".equals(localName))\n            query = getSpanFirst(field, root, analyzer);\n        else if (\"regex\".equals(localName))\n            query = regexQuery(field, root, options);\n        else\n            throw new XPathException(\"Unknown element in lucene query expression: \" + localName);\n        if (query != null)\n        \tsetBoost(root, query);\n        return query;\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"private Query termQuery(String field, Element node) {\n        return new TermQuery(new Term(field, getText(node)));\n    }","id":76661,"modified_method":"private Query termQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n    \tString termStr = getTerm(field, getText(node), analyzer);\n    \treturn termStr == null ? null : new TermQuery(new Term(field, termStr));\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"private SpanQuery nearQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n        int slop = getSlop(node);\n        if (slop < 0)\n            slop = 0;\n        boolean inOrder = true;\n        if (node.hasAttribute(\"ordered\"))\n            inOrder = node.getAttribute(\"ordered\").equals(\"yes\");\n\n        if (!hasElementContent(node)) {\n            String qstr = getText(node);\n            TokenStream stream = analyzer.tokenStream(field, new StringReader(qstr));\n            List<SpanTermQuery> list = new ArrayList<SpanTermQuery>(8);\n            Token token = new Token();\n            try {\n                while ((token = stream.next(token)) != null) {\n                    String str = new String(token.termBuffer(), 0, token.termLength());\n                    list.add(new SpanTermQuery(new Term(field, str)));\n                }\n            } catch (IOException e) {\n                throw new XPathException(\"Error while parsing phrase query: \" + qstr);\n            }\n\n            return new SpanNearQuery(list.toArray(new SpanTermQuery[list.size()]), slop, inOrder);\n        } else {\n            SpanQuery[] children = parseSpanChildren(field, node, analyzer);\n            return new SpanNearQuery(children, slop, inOrder);\n        }\n    }","id":76662,"modified_method":"private SpanQuery nearQuery(String field, Element node, Analyzer analyzer) throws XPathException {\n        int slop = getSlop(node);\n        if (slop < 0)\n            slop = 0;\n        boolean inOrder = true;\n        if (node.hasAttribute(\"ordered\"))\n            inOrder = node.getAttribute(\"ordered\").equals(\"yes\");\n\n        if (!hasElementContent(node)) {\n            String qstr = getText(node);\n            TokenStream stream = analyzer.tokenStream(field, new StringReader(qstr));\n            TermAttribute termAttr = (TermAttribute) stream.addAttribute(TermAttribute.class);\n            List<SpanTermQuery> list = new ArrayList<SpanTermQuery>(8);\n            try {\n            \tstream.reset();\n                while (stream.incrementToken()) {\n                    list.add(new SpanTermQuery(new Term(field, termAttr.term())));\n                }\n                stream.end();\n                stream.close();\n            } catch (IOException e) {\n                throw new XPathException(\"Error while parsing phrase query: \" + qstr);\n            }\n\n            return new SpanNearQuery(list.toArray(new SpanTermQuery[list.size()]), slop, inOrder);\n        } else {\n            SpanQuery[] children = parseSpanChildren(field, node, analyzer);\n            return new SpanNearQuery(children, slop, inOrder);\n        }\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"private Query booleanQuery(String field, Element node, Analyzer analyzer, Properties options) throws XPathException {\n        BooleanQuery query = new BooleanQuery();\n        Node child = node.getFirstChild();\n        while (child != null) {\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                Element elem = (Element) child;\n                Query childQuery = parse(field, elem, analyzer, options);\n                BooleanClause.Occur occur = getOccur(elem);\n                query.add(childQuery, occur);\n            }\n            child = child.getNextSibling();\n        }\n        return query;\n    }","id":76663,"modified_method":"private Query booleanQuery(String field, Element node, Analyzer analyzer, Properties options) throws XPathException {\n        BooleanQuery query = new BooleanQuery();\n        Node child = node.getFirstChild();\n        while (child != null) {\n            if (child.getNodeType() == Node.ELEMENT_NODE) {\n                Element elem = (Element) child;\n                Query childQuery = parse(field, elem, analyzer, options);\n                if (childQuery != null) {\n\t                BooleanClause.Occur occur = getOccur(elem);\n\t                query.add(childQuery, occur);\n                }\n            }\n            child = child.getNextSibling();\n        }\n        return query;\n    }","commit_id":"ac3f4d8e1d5666732f1db8d7d6cebc1c364279b9","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(SimpleQueryStringParser.NAME);\n\n        builder.field(\"query\", queryText);\n\n        if (fields.size() > 0) {\n            builder.startArray(\"fields\");\n            for (Map.Entry<String, Float> entry : fields.entrySet()) {\n                String field = entry.getKey();\n                Float boost = entry.getValue();\n                if (boost != null) {\n                    builder.value(field + \"^\" + boost);\n                } else {\n                    builder.value(field);\n                }\n            }\n            builder.endArray();\n        }\n\n        if (flags != -1) {\n            builder.field(\"flags\", flags);\n        }\n\n        if (analyzer != null) {\n            builder.field(\"analyzer\", analyzer);\n        }\n\n        if (operator != null) {\n            builder.field(\"default_operator\", operator.name().toLowerCase(Locale.ROOT));\n        }\n\n        if (lowercaseExpandedTerms != null) {\n            builder.field(\"lowercase_expanded_terms\", lowercaseExpandedTerms);\n        }\n\n        if (lenient != null) {\n            builder.field(\"lenient\", lenient);\n        }\n\n        if (analyzeWildcard != null) {\n            builder.field(\"analyze_wildcard\", analyzeWildcard);\n        }\n\n        if (locale != null) {\n            builder.field(\"locale\", locale.toString());\n        }\n\n        if (queryName != null) {\n            builder.field(\"_name\", queryName);\n        }\n\n        if (minimumShouldMatch != null) {\n            builder.field(\"minimum_should_match\", minimumShouldMatch);\n        }\n        \n        if (boost != 1.0f) {\n            builder.field(\"boost\", boost);\n        }\n\n        builder.endObject();\n    }","id":76664,"modified_method":"@Override\n    public void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(SimpleQueryStringParser.NAME);\n\n        builder.field(\"query\", queryText);\n\n        if (fields.size() > 0) {\n            builder.startArray(\"fields\");\n            for (Map.Entry<String, Float> entry : fields.entrySet()) {\n                String field = entry.getKey();\n                Float boost = entry.getValue();\n                if (boost != null) {\n                    builder.value(field + \"^\" + boost);\n                } else {\n                    builder.value(field);\n                }\n            }\n            builder.endArray();\n        }\n\n        if (flags != -1) {\n            builder.field(\"flags\", flags);\n        }\n\n        if (analyzer != null) {\n            builder.field(\"analyzer\", analyzer);\n        }\n\n        if (operator != null) {\n            builder.field(\"default_operator\", operator.name().toLowerCase(Locale.ROOT));\n        }\n\n        if (lowercaseExpandedTerms != null) {\n            builder.field(\"lowercase_expanded_terms\", lowercaseExpandedTerms);\n        }\n\n        if (lenient != null) {\n            builder.field(\"lenient\", lenient);\n        }\n\n        if (analyzeWildcard != null) {\n            builder.field(\"analyze_wildcard\", analyzeWildcard);\n        }\n\n        if (locale != null) {\n            builder.field(\"locale\", locale.toString());\n        }\n\n        if (queryName != null) {\n            builder.field(\"_name\", queryName);\n        }\n\n        if (minimumShouldMatch != null) {\n            builder.field(\"minimum_should_match\", minimumShouldMatch);\n        }\n        \n        if (boost != -1.0f) {\n            builder.field(\"boost\", boost);\n        }\n\n        builder.endObject();\n    }","commit_id":"5e9106ae5e7ed7ad0648fab640471aa48a4bd135","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        String currentFieldName = null;\n        String queryBody = null;\n        float boost = 1.0f; \n        String queryName = null;\n        String field = null;\n        String minimumShouldMatch = null;\n        Map<String, Float> fieldsAndWeights = null;\n        BooleanClause.Occur defaultOperator = null;\n        Analyzer analyzer = null;\n        int flags = -1;\n        SimpleQueryParser.Settings sqsSettings = new SimpleQueryParser.Settings();\n\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                if (\"fields\".equals(currentFieldName)) {\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        String fField = null;\n                        float fBoost = 1;\n                        char[] text = parser.textCharacters();\n                        int end = parser.textOffset() + parser.textLength();\n                        for (int i = parser.textOffset(); i < end; i++) {\n                            if (text[i] == '^') {\n                                int relativeLocation = i - parser.textOffset();\n                                fField = new String(text, parser.textOffset(), relativeLocation);\n                                fBoost = Float.parseFloat(new String(text, i + 1, parser.textLength() - relativeLocation - 1));\n                                break;\n                            }\n                        }\n                        if (fField == null) {\n                            fField = parser.text();\n                        }\n\n                        if (fieldsAndWeights == null) {\n                            fieldsAndWeights = new HashMap<>();\n                        }\n\n                        if (Regex.isSimpleMatchPattern(fField)) {\n                            for (String fieldName : parseContext.mapperService().simpleMatchToIndexNames(fField)) {\n                                fieldsAndWeights.put(fieldName, fBoost);\n                            }\n                        } else {\n                            MappedFieldType fieldType = parseContext.fieldMapper(fField);\n                            if (fieldType != null) {\n                                fieldsAndWeights.put(fieldType.names().indexName(), fBoost);\n                            } else {\n                                fieldsAndWeights.put(fField, fBoost);\n                            }\n                        }\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext,\n \"[\" + NAME + \"] query does not support [\" + currentFieldName\n + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"query\".equals(currentFieldName)) {\n                    queryBody = parser.text();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = parser.floatValue();\n                } else if (\"analyzer\".equals(currentFieldName)) {\n                    analyzer = parseContext.analysisService().analyzer(parser.text());\n                    if (analyzer == null) {\n                        throw new QueryParsingException(parseContext, \"[\" + NAME + \"] analyzer [\" + parser.text() + \"] not found\");\n                    }\n                } else if (\"field\".equals(currentFieldName)) {\n                    field = parser.text();\n                } else if (\"default_operator\".equals(currentFieldName) || \"defaultOperator\".equals(currentFieldName)) {\n                    String op = parser.text();\n                    if (\"or\".equalsIgnoreCase(op)) {\n                        defaultOperator = BooleanClause.Occur.SHOULD;\n                    } else if (\"and\".equalsIgnoreCase(op)) {\n                        defaultOperator = BooleanClause.Occur.MUST;\n                    } else {\n                        throw new QueryParsingException(parseContext, \"[\" + NAME + \"] default operator [\" + op + \"] is not allowed\");\n                    }\n                } else if (\"flags\".equals(currentFieldName)) {\n                    if (parser.currentToken() != XContentParser.Token.VALUE_NUMBER) {\n                        // Possible options are:\n                        // ALL, NONE, AND, OR, PREFIX, PHRASE, PRECEDENCE, ESCAPE, WHITESPACE, FUZZY, NEAR, SLOP\n                        flags = SimpleQueryStringFlag.resolveFlags(parser.text());\n                    } else {\n                        flags = parser.intValue();\n                        if (flags < 0) {\n                            flags = SimpleQueryStringFlag.ALL.value();\n                        }\n                    }\n                } else if (\"locale\".equals(currentFieldName)) {\n                    String localeStr = parser.text();\n                    Locale locale = LocaleUtils.parse(localeStr);\n                    sqsSettings.locale(locale);\n                } else if (\"lowercase_expanded_terms\".equals(currentFieldName)) {\n                    sqsSettings.lowercaseExpandedTerms(parser.booleanValue());\n                } else if (\"lenient\".equals(currentFieldName)) {\n                    sqsSettings.lenient(parser.booleanValue());\n                } else if (\"analyze_wildcard\".equals(currentFieldName)) {\n                    sqsSettings.analyzeWildcard(parser.booleanValue());\n                } else if (\"_name\".equals(currentFieldName)) {\n                    queryName = parser.text();\n                } else if (\"minimum_should_match\".equals(currentFieldName)) {\n                    minimumShouldMatch = parser.textOrNull();\n                } else {\n                    throw new QueryParsingException(parseContext, \"[\" + NAME + \"] unsupported field [\" + parser.currentName() + \"]\");\n                }\n            }\n        }\n\n        // Query text is required\n        if (queryBody == null) {\n            throw new QueryParsingException(parseContext, \"[\" + NAME + \"] query text missing\");\n        }\n        \n        // Support specifying only a field instead of a map\n        if (field == null) {\n            field = currentFieldName;\n        }\n\n        // Use the default field (_all) if no fields specified\n        if (fieldsAndWeights == null) {\n            field = parseContext.defaultField();\n        }\n\n        // Use standard analyzer by default\n        if (analyzer == null) {\n            analyzer = parseContext.mapperService().searchAnalyzer();\n        }\n\n        if (fieldsAndWeights == null) {\n            fieldsAndWeights = Collections.singletonMap(field, 1.0F);\n        }\n        SimpleQueryParser sqp = new SimpleQueryParser(analyzer, fieldsAndWeights, flags, sqsSettings);\n\n        if (defaultOperator != null) {\n            sqp.setDefaultOperator(defaultOperator);\n        }\n\n        Query query = sqp.parse(queryBody);\n        if (queryName != null) {\n            parseContext.addNamedQuery(queryName, query);\n        }\n\n        if (minimumShouldMatch != null && query instanceof BooleanQuery) {\n            Queries.applyMinimumShouldMatch((BooleanQuery) query, minimumShouldMatch);\n        }\n        \n        query.setBoost(boost);\n        return query;\n    }","id":76665,"modified_method":"@Override\n    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        String currentFieldName = null;\n        String queryBody = null;\n        float boost = 1.0f; \n        String queryName = null;\n        String field = null;\n        String minimumShouldMatch = null;\n        Map<String, Float> fieldsAndWeights = null;\n        BooleanClause.Occur defaultOperator = null;\n        Analyzer analyzer = null;\n        int flags = -1;\n        SimpleQueryParser.Settings sqsSettings = new SimpleQueryParser.Settings();\n\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                if (\"fields\".equals(currentFieldName)) {\n                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                        String fField = null;\n                        float fBoost = 1;\n                        char[] text = parser.textCharacters();\n                        int end = parser.textOffset() + parser.textLength();\n                        for (int i = parser.textOffset(); i < end; i++) {\n                            if (text[i] == '^') {\n                                int relativeLocation = i - parser.textOffset();\n                                fField = new String(text, parser.textOffset(), relativeLocation);\n                                fBoost = Float.parseFloat(new String(text, i + 1, parser.textLength() - relativeLocation - 1));\n                                break;\n                            }\n                        }\n                        if (fField == null) {\n                            fField = parser.text();\n                        }\n\n                        if (fieldsAndWeights == null) {\n                            fieldsAndWeights = new HashMap<>();\n                        }\n\n                        if (Regex.isSimpleMatchPattern(fField)) {\n                            for (String fieldName : parseContext.mapperService().simpleMatchToIndexNames(fField)) {\n                                fieldsAndWeights.put(fieldName, fBoost);\n                            }\n                        } else {\n                            MappedFieldType fieldType = parseContext.fieldMapper(fField);\n                            if (fieldType != null) {\n                                fieldsAndWeights.put(fieldType.names().indexName(), fBoost);\n                            } else {\n                                fieldsAndWeights.put(fField, fBoost);\n                            }\n                        }\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext,\n \"[\" + NAME + \"] query does not support [\" + currentFieldName\n + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"query\".equals(currentFieldName)) {\n                    queryBody = parser.text();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = parser.floatValue();\n                } else if (\"analyzer\".equals(currentFieldName)) {\n                    analyzer = parseContext.analysisService().analyzer(parser.text());\n                    if (analyzer == null) {\n                        throw new QueryParsingException(parseContext, \"[\" + NAME + \"] analyzer [\" + parser.text() + \"] not found\");\n                    }\n                } else if (\"field\".equals(currentFieldName)) {\n                    field = parser.text();\n                } else if (\"default_operator\".equals(currentFieldName) || \"defaultOperator\".equals(currentFieldName)) {\n                    String op = parser.text();\n                    if (\"or\".equalsIgnoreCase(op)) {\n                        defaultOperator = BooleanClause.Occur.SHOULD;\n                    } else if (\"and\".equalsIgnoreCase(op)) {\n                        defaultOperator = BooleanClause.Occur.MUST;\n                    } else {\n                        throw new QueryParsingException(parseContext, \"[\" + NAME + \"] default operator [\" + op + \"] is not allowed\");\n                    }\n                } else if (\"flags\".equals(currentFieldName)) {\n                    if (parser.currentToken() != XContentParser.Token.VALUE_NUMBER) {\n                        // Possible options are:\n                        // ALL, NONE, AND, OR, PREFIX, PHRASE, PRECEDENCE, ESCAPE, WHITESPACE, FUZZY, NEAR, SLOP\n                        flags = SimpleQueryStringFlag.resolveFlags(parser.text());\n                    } else {\n                        flags = parser.intValue();\n                        if (flags < 0) {\n                            flags = SimpleQueryStringFlag.ALL.value();\n                        }\n                    }\n                } else if (\"locale\".equals(currentFieldName)) {\n                    String localeStr = parser.text();\n                    Locale locale = LocaleUtils.parse(localeStr);\n                    sqsSettings.locale(locale);\n                } else if (\"lowercase_expanded_terms\".equals(currentFieldName)) {\n                    sqsSettings.lowercaseExpandedTerms(parser.booleanValue());\n                } else if (\"lenient\".equals(currentFieldName)) {\n                    sqsSettings.lenient(parser.booleanValue());\n                } else if (\"analyze_wildcard\".equals(currentFieldName)) {\n                    sqsSettings.analyzeWildcard(parser.booleanValue());\n                } else if (\"_name\".equals(currentFieldName)) {\n                    queryName = parser.text();\n                } else if (\"minimum_should_match\".equals(currentFieldName)) {\n                    minimumShouldMatch = parser.textOrNull();\n                } else {\n                    throw new QueryParsingException(parseContext, \"[\" + NAME + \"] unsupported field [\" + parser.currentName() + \"]\");\n                }\n            }\n        }\n\n        // Query text is required\n        if (queryBody == null) {\n            throw new QueryParsingException(parseContext, \"[\" + NAME + \"] query text missing\");\n        }\n        \n        // Support specifying only a field instead of a map\n        if (field == null) {\n            field = currentFieldName;\n        }\n\n        // Use the default field (_all) if no fields specified\n        if (fieldsAndWeights == null) {\n            field = parseContext.defaultField();\n        }\n\n        // Use standard analyzer by default\n        if (analyzer == null) {\n            analyzer = parseContext.mapperService().searchAnalyzer();\n        }\n\n        if (fieldsAndWeights == null) {\n            fieldsAndWeights = Collections.singletonMap(field, 1.0F);\n        }\n        SimpleQueryParser sqp = new SimpleQueryParser(analyzer, fieldsAndWeights, flags, sqsSettings);\n\n        if (defaultOperator != null) {\n            sqp.setDefaultOperator(defaultOperator);\n        }\n\n        Query query = sqp.parse(queryBody);\n        if (queryName != null) {\n            parseContext.addNamedQuery(queryName, query);\n        }\n\n        if (minimumShouldMatch != null && query instanceof BooleanQuery) {\n            Queries.applyMinimumShouldMatch((BooleanQuery) query, minimumShouldMatch);\n        }\n\n        if (query != null) {\n            query.setBoost(boost);\n        }\n\n        return query;\n    }","commit_id":"5e9106ae5e7ed7ad0648fab640471aa48a4bd135","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleQueryString() throws ExecutionException, InterruptedException {\n        createIndex(\"test\");\n        indexRandom(true, false,\n                client().prepareIndex(\"test\", \"type1\", \"1\").setSource(\"body\", \"foo\"),\n                client().prepareIndex(\"test\", \"type1\", \"2\").setSource(\"body\", \"bar\"),\n                client().prepareIndex(\"test\", \"type1\", \"3\").setSource(\"body\", \"foo bar\"),\n                client().prepareIndex(\"test\", \"type1\", \"4\").setSource(\"body\", \"quux baz eggplant\"),\n                client().prepareIndex(\"test\", \"type1\", \"5\").setSource(\"body\", \"quux baz spaghetti\"),\n                client().prepareIndex(\"test\", \"type1\", \"6\").setSource(\"otherbody\", \"spaghetti\"));\n\n        SearchResponse searchResponse = client().prepareSearch().setQuery(simpleQueryStringQuery(\"foo bar\")).get();\n        assertHitCount(searchResponse, 3l);\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\");\n\n        searchResponse = client().prepareSearch().setQuery(\n                boolQuery()\n                    .should(simpleQueryStringQuery(\"foo\").boost(-10.0f))\n                    .should(termQuery(\"body\", \"eggplant\"))).get();\n        assertHitCount(searchResponse, 3l);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n\n        searchResponse = client().prepareSearch().setQuery(\n                simpleQueryStringQuery(\"foo bar\").defaultOperator(SimpleQueryStringBuilder.Operator.AND)).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"3\"));\n\n        searchResponse = client().prepareSearch().setQuery(simpleQueryStringQuery(\"\\\"quux baz\\\" +(eggplant | spaghetti)\")).get();\n        assertHitCount(searchResponse, 2l);\n        assertSearchHits(searchResponse, \"4\", \"5\");\n\n        searchResponse = client().prepareSearch().setQuery(\n                simpleQueryStringQuery(\"eggplants\").analyzer(\"snowball\")).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n\n        searchResponse = client().prepareSearch().setQuery(\n                simpleQueryStringQuery(\"spaghetti\").field(\"body\", 1000.0f).field(\"otherbody\", 2.0f).queryName(\"myquery\")).get();\n        assertHitCount(searchResponse, 2l);\n        assertFirstHit(searchResponse, hasId(\"5\"));\n        assertSearchHits(searchResponse, \"5\", \"6\");\n        assertThat(searchResponse.getHits().getAt(0).getMatchedQueries()[0], equalTo(\"myquery\"));\n\n        searchResponse = client().prepareSearch().setQuery(simpleQueryStringQuery(\"spaghetti\").field(\"*body\")).get();\n        assertHitCount(searchResponse, 2l);\n        assertSearchHits(searchResponse, \"5\", \"6\");\n\n        // Have to bypass the builder here because the builder always uses \"fields\" instead of \"field\"\n        searchResponse = client().prepareSearch().setQuery(\"{\\\"simple_query_string\\\": {\\\"query\\\": \\\"spaghetti\\\", \\\"field\\\": \\\"_all\\\"}}\").get();\n        assertHitCount(searchResponse, 2l);\n        assertSearchHits(searchResponse, \"5\", \"6\");\n    }","id":76666,"modified_method":"@Test\n    public void testSimpleQueryString() throws ExecutionException, InterruptedException {\n        createIndex(\"test\");\n        indexRandom(true, false,\n                client().prepareIndex(\"test\", \"type1\", \"1\").setSource(\"body\", \"foo\"),\n                client().prepareIndex(\"test\", \"type1\", \"2\").setSource(\"body\", \"bar\"),\n                client().prepareIndex(\"test\", \"type1\", \"3\").setSource(\"body\", \"foo bar\"),\n                client().prepareIndex(\"test\", \"type1\", \"4\").setSource(\"body\", \"quux baz eggplant\"),\n                client().prepareIndex(\"test\", \"type1\", \"5\").setSource(\"body\", \"quux baz spaghetti\"),\n                client().prepareIndex(\"test\", \"type1\", \"6\").setSource(\"otherbody\", \"spaghetti\"));\n\n        SearchResponse searchResponse = client().prepareSearch().setQuery(simpleQueryStringQuery(\"foo bar\")).get();\n        assertHitCount(searchResponse, 3l);\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\");\n\n        // Tests boost value setting. In this case doc 1 should always be ranked above the other\n        // two matches.\n        searchResponse = client().prepareSearch().setQuery(\n                boolQuery()\n                    .should(simpleQueryStringQuery(\"\\\"foo bar\\\"\").boost(10.0f))\n                    .should(termQuery(\"body\", \"eggplant\"))).get();\n        assertHitCount(searchResponse, 2l);\n        assertFirstHit(searchResponse, hasId(\"3\"));\n\n        searchResponse = client().prepareSearch().setQuery(\n                simpleQueryStringQuery(\"foo bar\").defaultOperator(SimpleQueryStringBuilder.Operator.AND)).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"3\"));\n\n        searchResponse = client().prepareSearch().setQuery(simpleQueryStringQuery(\"\\\"quux baz\\\" +(eggplant | spaghetti)\")).get();\n        assertHitCount(searchResponse, 2l);\n        assertSearchHits(searchResponse, \"4\", \"5\");\n\n        searchResponse = client().prepareSearch().setQuery(\n                simpleQueryStringQuery(\"eggplants\").analyzer(\"snowball\")).get();\n        assertHitCount(searchResponse, 1l);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n\n        searchResponse = client().prepareSearch().setQuery(\n                simpleQueryStringQuery(\"spaghetti\").field(\"body\", 1000.0f).field(\"otherbody\", 2.0f).queryName(\"myquery\")).get();\n        assertHitCount(searchResponse, 2l);\n        assertFirstHit(searchResponse, hasId(\"5\"));\n        assertSearchHits(searchResponse, \"5\", \"6\");\n        assertThat(searchResponse.getHits().getAt(0).getMatchedQueries()[0], equalTo(\"myquery\"));\n\n        searchResponse = client().prepareSearch().setQuery(simpleQueryStringQuery(\"spaghetti\").field(\"*body\")).get();\n        assertHitCount(searchResponse, 2l);\n        assertSearchHits(searchResponse, \"5\", \"6\");\n\n        // Have to bypass the builder here because the builder always uses \"fields\" instead of \"field\"\n        searchResponse = client().prepareSearch().setQuery(\"{\\\"simple_query_string\\\": {\\\"query\\\": \\\"spaghetti\\\", \\\"field\\\": \\\"_all\\\"}}\").get();\n        assertHitCount(searchResponse, 2l);\n        assertSearchHits(searchResponse, \"5\", \"6\");\n    }","commit_id":"5e9106ae5e7ed7ad0648fab640471aa48a4bd135","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public void writeResult(Object iResult, final String iFormat, final String accept) throws InterruptedException, IOException {\r\n    if (iResult == null)\r\n      send(OHttpUtils.STATUS_OK_NOCONTENT_CODE, \"\", OHttpUtils.CONTENT_TEXT_PLAIN, null, null, true);\r\n    else {\r\n      final Object newResult;\r\n      if (isJSObject(iResult)) {\r\n        newResult = Collections.singleton(new ODocument().field(\"value\", iResult)).iterator();\r\n      } else if (iResult instanceof Map<?, ?>) {\r\n        newResult = ((Map<?, ?>) iResult).entrySet().iterator();\r\n      } else if (OMultiValue.isMultiValue(iResult)\r\n          && (OMultiValue.getSize(iResult) > 0 && !(OMultiValue.getFirstValue(iResult) instanceof OIdentifiable))) {\r\n        newResult = Collections.singleton(new ODocument().field(\"value\", iResult)).iterator();\r\n      } else if (iResult instanceof OIdentifiable) {\r\n        // CONVERT SIGLE VALUE IN A COLLECTION\r\n        newResult = Collections.singleton(iResult).iterator();\r\n      } else if (iResult instanceof Iterable<?>)\r\n        newResult = ((Iterable<OIdentifiable>) iResult).iterator();\r\n      else if (OMultiValue.isMultiValue(iResult))\r\n        newResult = OMultiValue.getMultiValueIterator(iResult);\r\n      else {\r\n        newResult = Collections.singleton(new ODocument().field(\"value\", iResult)).iterator();\r\n      }\r\n\r\n      if (newResult == null)\r\n        send(OHttpUtils.STATUS_OK_NOCONTENT_CODE, \"\", OHttpUtils.CONTENT_TEXT_PLAIN, null, null, true);\r\n      else\r\n        writeRecords(newResult, null, iFormat, accept);\r\n    }\r\n  }","id":76667,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  public void writeResult(Object iResult, final String iFormat, final String accept) throws InterruptedException, IOException {\r\n    if (iResult == null)\r\n      send(OHttpUtils.STATUS_OK_NOCONTENT_CODE, \"\", OHttpUtils.CONTENT_TEXT_PLAIN, null, null, true);\r\n    else {\r\n      if (iResult instanceof Map<?, ?>) {\r\n        iResult = ((Map<?, ?>) iResult).entrySet().iterator();\r\n      } else if (OMultiValue.isMultiValue(iResult)\r\n          && (OMultiValue.getSize(iResult) > 0 && !(OMultiValue.getFirstValue(iResult) instanceof OIdentifiable))) {\r\n        final List<OIdentifiable> resultSet = new ArrayList<OIdentifiable>();\r\n        resultSet.add(new ODocument().field(\"value\", iResult));\r\n        iResult = resultSet.iterator();\r\n\r\n      } else if (iResult instanceof OIdentifiable) {\r\n        // CONVERT SIGLE VALUE IN A COLLECTION\r\n        final List<OIdentifiable> resultSet = new ArrayList<OIdentifiable>();\r\n        resultSet.add((OIdentifiable) iResult);\r\n        iResult = resultSet.iterator();\r\n      } else if (iResult instanceof Iterable<?>)\r\n        iResult = ((Iterable<OIdentifiable>) iResult).iterator();\r\n      else if (OMultiValue.isMultiValue(iResult))\r\n        iResult = OMultiValue.getMultiValueIterator(iResult);\r\n      else {\r\n        final List<OIdentifiable> resultSet = new ArrayList<OIdentifiable>();\r\n        resultSet.add(new ODocument().field(\"value\", iResult));\r\n        iResult = resultSet.iterator();\r\n      }\r\n\r\n      if (iResult == null)\r\n        send(OHttpUtils.STATUS_OK_NOCONTENT_CODE, \"\", OHttpUtils.CONTENT_TEXT_PLAIN, null, null, true);\r\n      else if (iResult instanceof Iterator<?>)\r\n        writeRecords(iResult, null, iFormat, accept);\r\n    }\r\n  }","commit_id":"3a1082d72003dfda2c6ee56b7ca6580795b5dd67","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInitializerFromClasspath() throws IOException {\n        URL url = new URL(\"file://test\");\n        loader = EasyMock.createMockBuilder(WebappServiceLoader.class)\n                .addMockedMethod(\"parseConfigFile\", Set.class, URL.class)\n                .withConstructor(context).createMock(control);\n        EasyMock.expect(context.getAttribute(ServletContext.ORDERED_LIBS))\n                .andReturn(null);\n        EasyMock.expect(cl.getResources(CONFIG_FILE))\n                .andReturn(Collections.enumeration(Collections.singleton(url)));\n        loader.parseConfigFile(EasyMock.isA(Set.class), EasyMock.same(url));\n        control.replay();\n        Assert.assertTrue(loader.load(ServletContainerInitializer.class).isEmpty());\n        control.verify();\n    }","id":76668,"modified_method":"@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInitializerFromClasspath() throws IOException {\n        URL url = new URL(\"file://test\");\n        loader = EasyMock.createMockBuilder(WebappServiceLoader.class)\n                .addMockedMethod(\"parseConfigFile\", LinkedHashSet.class, URL.class)\n                .withConstructor(context).createMock(control);\n        EasyMock.expect(context.getAttribute(ServletContext.ORDERED_LIBS))\n                .andReturn(null);\n        EasyMock.expect(cl.getResources(CONFIG_FILE))\n                .andReturn(Collections.enumeration(Collections.singleton(url)));\n        loader.parseConfigFile(EasyMock.isA(LinkedHashSet.class), EasyMock.same(url));\n        control.replay();\n        Assert.assertTrue(loader.load(ServletContainerInitializer.class).isEmpty());\n        control.verify();\n    }","commit_id":"f5b5f624c4dfca276caa1462991ee0af452282cf","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testWithOrdering() throws IOException {\n        URL url1 = new URL(\"file://jar1.jar\");\n        URL sci1 = new URL(\"jar:file://jar1.jar!/\" + CONFIG_FILE);\n        URL url2 = new URL(\"file://dir/\");\n        URL sci2 = new URL(\"file://dir/\" + CONFIG_FILE);\n        loader = EasyMock.createMockBuilder(WebappServiceLoader.class)\n                .addMockedMethod(\"parseConfigFile\", Set.class, URL.class)\n                .withConstructor(context).createMock(control);\n        List<String> jars = Arrays.asList(\"jar1.jar\", \"dir/\");\n        EasyMock.expect(context.getAttribute(ServletContext.ORDERED_LIBS))\n                .andReturn(jars);\n        EasyMock.expect(context.getResource(\"/WEB-INF/lib/jar1.jar\"))\n                .andReturn(url1);\n        loader.parseConfigFile(EasyMock.isA(Set.class), EasyMock.eq(sci1));\n        EasyMock.expect(context.getResource(\"/WEB-INF/lib/dir/\"))\n                .andReturn(url2);\n        loader.parseConfigFile(EasyMock.isA(Set.class), EasyMock.eq(sci2));\n        EasyMock.expect(parent.getResources(CONFIG_FILE))\n                .andReturn(Collections.<URL>emptyEnumeration());\n\n        control.replay();\n        Assert.assertTrue(loader.load(ServletContainerInitializer.class).isEmpty());\n        control.verify();\n    }","id":76669,"modified_method":"@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testWithOrdering() throws IOException {\n        URL url1 = new URL(\"file://jar1.jar\");\n        URL sci1 = new URL(\"jar:file://jar1.jar!/\" + CONFIG_FILE);\n        URL url2 = new URL(\"file://dir/\");\n        URL sci2 = new URL(\"file://dir/\" + CONFIG_FILE);\n        loader = EasyMock.createMockBuilder(WebappServiceLoader.class)\n                .addMockedMethod(\"parseConfigFile\", LinkedHashSet.class, URL.class)\n                .withConstructor(context).createMock(control);\n        List<String> jars = Arrays.asList(\"jar1.jar\", \"dir/\");\n        EasyMock.expect(context.getAttribute(ServletContext.ORDERED_LIBS))\n                .andReturn(jars);\n        EasyMock.expect(context.getResource(\"/WEB-INF/lib/jar1.jar\"))\n                .andReturn(url1);\n        loader.parseConfigFile(EasyMock.isA(LinkedHashSet.class), EasyMock.eq(sci1));\n        EasyMock.expect(context.getResource(\"/WEB-INF/lib/dir/\"))\n                .andReturn(url2);\n        loader.parseConfigFile(EasyMock.isA(LinkedHashSet.class), EasyMock.eq(sci2));\n        EasyMock.expect(parent.getResources(CONFIG_FILE))\n                .andReturn(Collections.<URL>emptyEnumeration());\n\n        control.replay();\n        Assert.assertTrue(loader.load(ServletContainerInitializer.class).isEmpty());\n        control.verify();\n    }","commit_id":"f5b5f624c4dfca276caa1462991ee0af452282cf","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testParseConfigFile() throws IOException {\n        Set<String> found = new HashSet<>();\n        loader = new WebappServiceLoader<>(context);\n        loader.parseConfigFile(found, getClass().getResource(\"service-config.txt\"));\n        Assert.assertEquals(Collections.singleton(\"provider1\"), found);\n    }","id":76670,"modified_method":"@Test\n    public void testParseConfigFile() throws IOException {\n        LinkedHashSet<String> found = new LinkedHashSet<>();\n        loader = new WebappServiceLoader<>(context);\n        loader.parseConfigFile(found, getClass().getResource(\"service-config.txt\"));\n        Assert.assertEquals(Collections.singleton(\"provider1\"), found);\n    }","commit_id":"f5b5f624c4dfca276caa1462991ee0af452282cf","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testServiceCannotBeConstructed() throws Exception {\n        Class<?> sci = Integer.class;\n        loader = new WebappServiceLoader<>(context);\n        cl.loadClass(sci.getName());\n        EasyMock.expectLastCall()\n                .andReturn(sci);\n        Set<String> names = Collections.singleton(sci.getName());\n        control.replay();\n        try {\n            loader.loadServices(ServletContainerInitializer.class, names);\n        } catch (IOException e) {\n            Assert.assertTrue(e.getCause() instanceof InstantiationException);\n        } finally {\n            control.verify();\n        }\n    }","id":76671,"modified_method":"@Test\n    public void testServiceCannotBeConstructed() throws Exception {\n        Class<?> sci = Integer.class;\n        loader = new WebappServiceLoader<>(context);\n        cl.loadClass(sci.getName());\n        EasyMock.expectLastCall()\n                .andReturn(sci);\n        LinkedHashSet<String> names = new LinkedHashSet<>();\n        names.add(sci.getName());\n        control.replay();\n        try {\n            loader.loadServices(ServletContainerInitializer.class, names);\n        } catch (IOException e) {\n            Assert.assertTrue(e.getCause() instanceof InstantiationException);\n        } finally {\n            control.verify();\n        }\n    }","commit_id":"f5b5f624c4dfca276caa1462991ee0af452282cf","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testLoadServices() throws Exception {\n        Class<?> sci = TesterServletContainerInitializer1.class;\n        loader = new WebappServiceLoader<>(context);\n        cl.loadClass(sci.getName());\n        EasyMock.expectLastCall()\n                .andReturn(sci);\n        Set<String> names = Collections.singleton(sci.getName());\n        control.replay();\n        Collection<ServletContainerInitializer> initializers =\n                loader.loadServices(ServletContainerInitializer.class, names);\n        Assert.assertEquals(1, initializers.size());\n        Assert.assertTrue(sci.isInstance(initializers.iterator().next()));\n        control.verify();\n    }","id":76672,"modified_method":"@Test\n    public void testLoadServices() throws Exception {\n        Class<?> sci = TesterServletContainerInitializer1.class;\n        loader = new WebappServiceLoader<>(context);\n        cl.loadClass(sci.getName());\n        EasyMock.expectLastCall()\n                .andReturn(sci);\n        LinkedHashSet<String> names = new LinkedHashSet<>();\n        names.add(sci.getName());\n        control.replay();\n        Collection<ServletContainerInitializer> initializers =\n                loader.loadServices(ServletContainerInitializer.class, names);\n        Assert.assertEquals(1, initializers.size());\n        Assert.assertTrue(sci.isInstance(initializers.iterator().next()));\n        control.verify();\n    }","commit_id":"f5b5f624c4dfca276caa1462991ee0af452282cf","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testServiceIsNotExpectedType() throws Exception {\n        Class<?> sci = Object.class;\n        loader = new WebappServiceLoader<>(context);\n        cl.loadClass(sci.getName());\n        EasyMock.expectLastCall()\n                .andReturn(sci);\n        Set<String> names = Collections.singleton(sci.getName());\n        control.replay();\n        try {\n            loader.loadServices(ServletContainerInitializer.class, names);\n        } catch (IOException e) {\n            Assert.assertTrue(e.getCause() instanceof ClassCastException);\n        } finally {\n            control.verify();\n        }\n    }","id":76673,"modified_method":"@Test\n    public void testServiceIsNotExpectedType() throws Exception {\n        Class<?> sci = Object.class;\n        loader = new WebappServiceLoader<>(context);\n        cl.loadClass(sci.getName());\n        EasyMock.expectLastCall()\n                .andReturn(sci);\n        LinkedHashSet<String> names = new LinkedHashSet<>();\n        names.add(sci.getName());\n        control.replay();\n        try {\n            loader.loadServices(ServletContainerInitializer.class, names);\n        } catch (IOException e) {\n            Assert.assertTrue(e.getCause() instanceof ClassCastException);\n        } finally {\n            control.verify();\n        }\n    }","commit_id":"f5b5f624c4dfca276caa1462991ee0af452282cf","url":"https://github.com/apache/tomcat"},{"original_method":"public static Collection<String> getBootstrapPaths() {\n    List<String> paths;\n    File lib = new File(getHomePath() + File.separator + \"lib\");\n    if (lib.exists() && lib.isDirectory()) {\n      paths = new ArrayList<String>();\n      for (File jar : lib.listFiles(MPS_JARS)) {\n        paths.add(jar.getAbsolutePath()+ MODULES_PREFIX);\n      }\n      if (paths.size() > 0) {\n        return Collections.unmodifiableCollection(paths);\n      }\n    }\n    return Collections.singleton(getHomePath() + File.separator + \"core\");\n  }","id":76674,"modified_method":"public static Collection<String> getBootstrapPaths() {\n    List<String> paths;\n    File lib = new File(getHomePath() + File.separator + \"lib\");\n    if (lib.exists() && lib.isDirectory()) {\n      paths = new ArrayList<String>();\n      for (File jar : lib.listFiles(MPS_JARS)) {\n        paths.add(jar.getAbsolutePath()+ MODULES_PREFIX);\n      }\n      if (paths.size() > 0) {\n        return Collections.unmodifiableCollection(paths);\n      }\n    }\n    paths = new ArrayList<String>(2);\n    paths.add(getHomePath() + File.separator + \"core\");\n    paths.add(getHomePath() + File.separator + \"editor\");\n    return Collections.unmodifiableCollection(paths);\n  }","commit_id":"6b9a5cb53bda18f7faf8e922c130c084f9451b5a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public static String prepareClassText(PyClass superClass, PyElement[] elements, boolean up, boolean ignoreNoChanges, final String preparedClassName) {\n    PsiElement sibling = elements[0].getPrevSibling();\n    sibling = sibling == null ? elements[0].getParent().getPrevSibling() : sibling;\n    final String white = sibling.getText();\n    final StringBuilder builder = new StringBuilder(\"class \");\n    builder.append(preparedClassName).append(\":\\n\");\n    boolean hasChanges = false;\n    for (PyElement element : elements) {\n      final String name = element.getName();\n      if (name != null && (up || superClass.findMethodByName(name, false) == null)) {\n        builder.append(white).append(element.getText()).append(\"\\n\\n\");\n        hasChanges = true;\n      }\n    }\n    return ignoreNoChanges || hasChanges ? builder.toString() : null;\n  }","id":76675,"modified_method":"@Nullable\n  public static String prepareClassText(PyClass superClass, PyElement[] elements, boolean up, boolean ignoreNoChanges, final String preparedClassName) {\n    PsiElement sibling = elements[0].getPrevSibling();\n    sibling = sibling == null ? elements[0].getParent().getPrevSibling() : sibling;\n    final String white = sibling.getText();\n    final StringBuilder builder = new StringBuilder(\"class \");\n    builder.append(preparedClassName).append(\":\\n\");\n    boolean hasChanges = false;\n    for (PyElement element : elements) {\n      final String name = element.getName();\n      if (name != null && (up || superClass.findMethodByName(name, false) == null)) {\n        builder.append(white).append(element.getText()).append(\"\\n\");\n        hasChanges = true;\n      }\n    }\n    return ignoreNoChanges || hasChanges ? builder.toString() : null;\n  }","commit_id":"77bafe85df490f2dacdc4bab7dd0343bdf0a5cb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addMethods(final PyClass superClass, final PyElement[] elements, final boolean up) {\n    if (elements.length == 0) return;\n    final Project project = superClass.getProject();\n    final String text = prepareClassText(superClass, elements, up, false, \"Foo\");\n\n    if (text == null) return;\n\n    final PyClass newClass = PythonLanguage.getInstance().getElementGenerator().createFromText(project, PyClass.class, text);\n    if (superClass.getMethods().length != 0) {\n      final PyFunction previousLastMethod = superClass.getMethods()[0];\n      PyPsiUtils.addBeforeInParent(previousLastMethod, newClass.getLastChild().getChildren());\n      PyPsiUtils.addBeforeInParent(previousLastMethod, newClass.getLastChild().getPrevSibling());\n      PyPsiUtils.addBeforeInParent(previousLastMethod, newClass.getLastChild());      \n    } else {\n      PyPsiUtils.addToEnd(superClass, newClass.getLastChild());\n    }\n  }","id":76676,"modified_method":"public static void addMethods(final PyClass superClass, final PyElement[] elements, final boolean up) {\n    if (elements.length == 0) return;\n    final Project project = superClass.getProject();\n    final String text = prepareClassText(superClass, elements, up, false, \"Foo\");\n\n    if (text == null) return;\n\n    final PyClass newClass = PythonLanguage.getInstance().getElementGenerator().createFromText(project, PyClass.class, text);\n    if (superClass.getMethods().length != 0) {\n      final PyFunction previousLastMethod = superClass.getMethods()[0];\n      final ASTNode node = newClass.getLastChild().getNode();\n      for (ASTNode child : node.getChildren(null)) {\n        PyPsiUtils.addBeforeInParent(previousLastMethod, child.getPsi());\n      }\n      PyPsiUtils.addBeforeInParent(previousLastMethod, newClass.getLastChild().getPrevSibling());\n      PyPsiUtils.addBeforeInParent(previousLastMethod, newClass.getLastChild());      \n    } else {\n      PyPsiUtils.addToEnd(superClass, newClass.getLastChild());\n    }\n  }","commit_id":"77bafe85df490f2dacdc4bab7dd0343bdf0a5cb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testExistingmethod() throws Exception {\n    doProcessorTest(\"Foo\", \".foo\", \"function <b><code>foo<\/code><\/b> is already overridden in class <b><code>Boo<\/code><\/b>. Method will not be pushed down to that class.\");\n  }","id":76677,"modified_method":"public void testExistingmethod() throws Exception {\n    doProcessorTest(\"Foo\", \"function <b><code>foo<\/code><\/b> is already overridden in class <b><code>Boo<\/code><\/b>. Method will not be pushed down to that class.\", \".foo\");\n  }","commit_id":"77bafe85df490f2dacdc4bab7dd0343bdf0a5cb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSimple() throws Exception {\n    doProcessorTest(\"Foo\", \".foo\", null);\n  }","id":76678,"modified_method":"public void testSimple() throws Exception {\n    doProcessorTest(\"Foo\", null, \".foo\");\n  }","commit_id":"77bafe85df490f2dacdc4bab7dd0343bdf0a5cb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMultiple() throws Exception {\n    doProcessorTest(\"Foo\", \".foo\", null);\n  }","id":76679,"modified_method":"public void testMultiple() throws Exception {\n    doProcessorTest(\"Foo\", null, \".foo\");\n  }","commit_id":"77bafe85df490f2dacdc4bab7dd0343bdf0a5cb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSuperclass() throws Exception {\n    doProcessorTest(\"Zope\", \"Foo\", null);\n  }","id":76680,"modified_method":"public void testSuperclass() throws Exception {\n    doProcessorTest(\"Zope\", null, \"Foo\");\n  }","commit_id":"77bafe85df490f2dacdc4bab7dd0343bdf0a5cb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doProcessorTest(final String className, final String memberName, final String expectedError) throws Exception {\n    try {\n    String baseName = \"/refactoring/pushdown/\" + getTestName(true);\n    myFixture.configureByFile(baseName + \".before.py\");\n    final PyClass clazz = findClass(className);\n    final PyElement member = findMember(className, memberName);\n    final PyPushDownProcessor processor = new PyPushDownProcessor(myFixture.getProject(), clazz, Collections.singleton(new PyMemberInfo(member)));\n    new WriteCommandAction.Simple(myFixture.getProject()) {\n      @Override\n      protected void run() throws Throwable {\n        processor.run();\n      }\n    }.execute();\n    myFixture.checkResultByFile(baseName + \".after.py\");\n    } catch (Exception e) {\n      if (expectedError == null) throw e;\n      assertEquals(expectedError, e.getMessage());\n    }\n  }","id":76681,"modified_method":"private void doProcessorTest(final String className, final String expectedError, final String... membersName) throws Exception {\n    try {\n    String baseName = \"/refactoring/pushdown/\" + getTestName(true);\n    myFixture.configureByFile(baseName + \".before.py\");\n    final PyClass clazz = findClass(className);\n    final List<PyMemberInfo> members = new ArrayList<PyMemberInfo>();\n    for (String memberName : membersName) {\n      final PyElement member = findMember(className, memberName);\n      assertNotNull(member);\n      members.add(new PyMemberInfo(member));\n    }\n\n    final PyPushDownProcessor processor = new PyPushDownProcessor(myFixture.getProject(), clazz, members);\n    new WriteCommandAction.Simple(myFixture.getProject()) {\n      @Override\n      protected void run() throws Throwable {\n        processor.run();\n      }\n    }.execute();\n    myFixture.checkResultByFile(baseName + \".after.py\");\n    } catch (Exception e) {\n      if (expectedError == null) throw e;\n      assertEquals(expectedError, e.getMessage());\n    }\n  }","commit_id":"77bafe85df490f2dacdc4bab7dd0343bdf0a5cb9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Checks that rule assertions are met for the given set of TagChecks.\n     * @param schecks The TagChecks for which assertions have to be checked\n     * @return A set of error messages, empty if all assertions are met\n     * @since 7356\n     */\n    public Set<String> checkAsserts(final Collection<TagCheck> schecks) {\n        Set<String> assertionErrors = new LinkedHashSet<>();\n        final DataSet ds = new DataSet();\n        for (final TagCheck check : schecks) {\n            if (Main.isDebugEnabled()) {\n                Main.debug(\"Check: \"+check);\n            }\n            for (final Map.Entry<String, Boolean> i : check.assertions.entrySet()) {\n                if (Main.isDebugEnabled()) {\n                    Main.debug(\"- Assertion: \"+i);\n                }\n                final OsmPrimitive p = OsmUtils.createPrimitive(i.getKey());\n                // Add primitive to dataset to avoid DataIntegrityProblemException when evaluating selectors\n                ds.addPrimitive(p);\n                final Collection<TestError> pErrors = getErrorsForPrimitive(p, true,\n                        Collections.singleton(Collections.singleton(check)));\n                if (Main.isDebugEnabled()) {\n                    Main.debug(\"- Errors: \"+pErrors);\n                }\n                final boolean isError = Utils.exists(pErrors, new Predicate<TestError>() {\n                    @Override\n                    public boolean evaluate(TestError e) {\n                        //noinspection EqualsBetweenInconvertibleTypes\n                        return e.getTester().equals(check.rule);\n                    }\n                });\n                if (isError != i.getValue()) {\n                    final String error = MessageFormat.format(\"Expecting test ''{0}'' (i.e., {1}) to {2} {3} (i.e., {4})\",\n                            check.getMessage(p), check.rule.selectors, i.getValue() ? \"match\" : \"not match\", i.getKey(), p.getKeys());\n                    assertionErrors.add(error);\n                }\n                ds.removePrimitive(p);\n            }\n        }\n        return assertionErrors;\n    }","id":76682,"modified_method":"/**\n     * Checks that rule assertions are met for the given set of TagChecks.\n     * @param schecks The TagChecks for which assertions have to be checked\n     * @return A set of error messages, empty if all assertions are met\n     * @since 7356\n     */\n    public Set<String> checkAsserts(final Collection<TagCheck> schecks) {\n        Set<String> assertionErrors = new LinkedHashSet<>();\n        final DataSet ds = new DataSet();\n        for (final TagCheck check : schecks) {\n            if (Main.isDebugEnabled()) {\n                Main.debug(\"Check: \"+check);\n            }\n            for (final Map.Entry<String, Boolean> i : check.assertions.entrySet()) {\n                if (Main.isDebugEnabled()) {\n                    Main.debug(\"- Assertion: \"+i);\n                }\n                final OsmPrimitive p = OsmUtils.createPrimitive(i.getKey());\n                // Build minimal ordered list of checks to run to test the assertion\n                List<Set<TagCheck>> checksToRun = new ArrayList<Set<TagCheck>>();\n                Set<TagCheck> checkDependencies = check.getTagCheckDependencies(schecks);\n                if (!checkDependencies.isEmpty()) {\n                    checksToRun.add(checkDependencies);\n                }\n                checksToRun.add(Collections.singleton(check));\n                // Add primitive to dataset to avoid DataIntegrityProblemException when evaluating selectors\n                ds.addPrimitive(p);\n                final Collection<TestError> pErrors = getErrorsForPrimitive(p, true, checksToRun);\n                if (Main.isDebugEnabled()) {\n                    Main.debug(\"- Errors: \"+pErrors);\n                }\n                final boolean isError = Utils.exists(pErrors, new Predicate<TestError>() {\n                    @Override\n                    public boolean evaluate(TestError e) {\n                        //noinspection EqualsBetweenInconvertibleTypes\n                        return e.getTester().equals(check.rule);\n                    }\n                });\n                if (isError != i.getValue()) {\n                    final String error = MessageFormat.format(\"Expecting test ''{0}'' (i.e., {1}) to {2} {3} (i.e., {4})\",\n                            check.getMessage(p), check.rule.selectors, i.getValue() ? \"match\" : \"not match\", i.getKey(), p.getKeys());\n                    assertionErrors.add(error);\n                }\n                ds.removePrimitive(p);\n            }\n        }\n        return assertionErrors;\n    }","commit_id":"fcc731ecd15a245fc97c0b0266ee60cc4c187cdf","url":"https://github.com/openstreetmap/josm"},{"original_method":"static TagCheck ofMapCSSRule(final GroupedMapCSSRule rule) throws IllegalDataException {\n            final TagCheck check = new TagCheck(rule);\n            boolean containsSetClassExpression = false;\n            for (Instruction i : rule.declaration.instructions) {\n                if (i instanceof Instruction.AssignmentInstruction) {\n                    final Instruction.AssignmentInstruction ai = (Instruction.AssignmentInstruction) i;\n                    if (ai.isSetInstruction) {\n                        containsSetClassExpression = true;\n                        continue;\n                    }\n                    final String val = ai.val instanceof Expression\n                            ? (String) ((Expression) ai.val).evaluate(new Environment())\n                            : ai.val instanceof String\n                            ? (String) ai.val\n                            : ai.val instanceof Keyword\n                            ? ((Keyword) ai.val).val\n                            : null;\n                    if (ai.key.startsWith(\"throw\")) {\n                        try {\n                            final Severity severity = Severity.valueOf(ai.key.substring(\"throw\".length()).toUpperCase());\n                            check.errors.put(ai, severity);\n                        } catch (IllegalArgumentException e) {\n                            Main.warn(\"Unsupported \"+ai.key+\" instruction. Allowed instructions are \"+POSSIBLE_THROWS);\n                        }\n                    } else if (\"fixAdd\".equals(ai.key)) {\n                        final PrimitiveToTag toTag = PrimitiveToTag.ofMapCSSObject(ai.val, false);\n                        if (toTag != null) {\n                            check.change.add(toTag);\n                        } else {\n                            Main.warn(\"Invalid value for \"+ai.key+\": \"+ai.val);\n                        }\n                    } else if (\"fixRemove\".equals(ai.key)) {\n                        CheckParameterUtil.ensureThat(!(ai.val instanceof String) || !(val != null && val.contains(\"=\")),\n                                \"Unexpected '='. Please only specify the key to remove!\");\n                        final PrimitiveToTag toTag = PrimitiveToTag.ofMapCSSObject(ai.val, true);\n                        if (toTag != null) {\n                            check.change.add(toTag);\n                        } else {\n                            Main.warn(\"Invalid value for \"+ai.key+\": \"+ai.val);\n                        }\n                    } else if (\"fixChangeKey\".equals(ai.key) && val != null) {\n                        CheckParameterUtil.ensureThat(val.contains(\"=>\"), \"Separate old from new key by '=>'!\");\n                        final String[] x = val.split(\"=>\", 2);\n                        check.keyChange.put(Tag.removeWhiteSpaces(x[0]), Tag.removeWhiteSpaces(x[1]));\n                    } else if (\"fixDeleteObject\".equals(ai.key) && val != null) {\n                        CheckParameterUtil.ensureThat(val.equals(\"this\"), \"fixDeleteObject must be followed by 'this'\");\n                        check.deletion = true;\n                    } else if (\"suggestAlternative\".equals(ai.key) && val != null) {\n                        check.alternatives.add(val);\n                    } else if (\"assertMatch\".equals(ai.key) && val != null) {\n                        check.assertions.put(val, true);\n                    } else if (\"assertNoMatch\".equals(ai.key) && val != null) {\n                        check.assertions.put(val, false);\n                    } else {\n                        throw new IllegalDataException(\"Cannot add instruction \" + ai.key + \": \" + ai.val + \"!\");\n                    }\n                }\n            }\n            if (check.errors.isEmpty() && !containsSetClassExpression) {\n                throw new IllegalDataException(\"No \"+POSSIBLE_THROWS+\" given! You should specify a validation error message for \" + rule.selectors);\n            } else if (check.errors.size() > 1) {\n                throw new IllegalDataException(\"More than one \"+POSSIBLE_THROWS+\" given! You should specify a single validation error message for \" + rule.selectors);\n            }\n            return check;\n        }","id":76683,"modified_method":"static TagCheck ofMapCSSRule(final GroupedMapCSSRule rule) throws IllegalDataException {\n            final TagCheck check = new TagCheck(rule);\n            for (Instruction i : rule.declaration.instructions) {\n                if (i instanceof Instruction.AssignmentInstruction) {\n                    final Instruction.AssignmentInstruction ai = (Instruction.AssignmentInstruction) i;\n                    if (ai.isSetInstruction) {\n                        check.setClassExpressions.add(ai.key);\n                        continue;\n                    }\n                    final String val = ai.val instanceof Expression\n                            ? (String) ((Expression) ai.val).evaluate(new Environment())\n                            : ai.val instanceof String\n                            ? (String) ai.val\n                            : ai.val instanceof Keyword\n                            ? ((Keyword) ai.val).val\n                            : null;\n                    if (ai.key.startsWith(\"throw\")) {\n                        try {\n                            final Severity severity = Severity.valueOf(ai.key.substring(\"throw\".length()).toUpperCase());\n                            check.errors.put(ai, severity);\n                        } catch (IllegalArgumentException e) {\n                            Main.warn(\"Unsupported \"+ai.key+\" instruction. Allowed instructions are \"+POSSIBLE_THROWS);\n                        }\n                    } else if (\"fixAdd\".equals(ai.key)) {\n                        final PrimitiveToTag toTag = PrimitiveToTag.ofMapCSSObject(ai.val, false);\n                        if (toTag != null) {\n                            check.change.add(toTag);\n                        } else {\n                            Main.warn(\"Invalid value for \"+ai.key+\": \"+ai.val);\n                        }\n                    } else if (\"fixRemove\".equals(ai.key)) {\n                        CheckParameterUtil.ensureThat(!(ai.val instanceof String) || !(val != null && val.contains(\"=\")),\n                                \"Unexpected '='. Please only specify the key to remove!\");\n                        final PrimitiveToTag toTag = PrimitiveToTag.ofMapCSSObject(ai.val, true);\n                        if (toTag != null) {\n                            check.change.add(toTag);\n                        } else {\n                            Main.warn(\"Invalid value for \"+ai.key+\": \"+ai.val);\n                        }\n                    } else if (\"fixChangeKey\".equals(ai.key) && val != null) {\n                        CheckParameterUtil.ensureThat(val.contains(\"=>\"), \"Separate old from new key by '=>'!\");\n                        final String[] x = val.split(\"=>\", 2);\n                        check.keyChange.put(Tag.removeWhiteSpaces(x[0]), Tag.removeWhiteSpaces(x[1]));\n                    } else if (\"fixDeleteObject\".equals(ai.key) && val != null) {\n                        CheckParameterUtil.ensureThat(val.equals(\"this\"), \"fixDeleteObject must be followed by 'this'\");\n                        check.deletion = true;\n                    } else if (\"suggestAlternative\".equals(ai.key) && val != null) {\n                        check.alternatives.add(val);\n                    } else if (\"assertMatch\".equals(ai.key) && val != null) {\n                        check.assertions.put(val, true);\n                    } else if (\"assertNoMatch\".equals(ai.key) && val != null) {\n                        check.assertions.put(val, false);\n                    } else {\n                        throw new IllegalDataException(\"Cannot add instruction \" + ai.key + \": \" + ai.val + \"!\");\n                    }\n                }\n            }\n            if (check.errors.isEmpty() && check.setClassExpressions.isEmpty()) {\n                throw new IllegalDataException(\n                        \"No \"+POSSIBLE_THROWS+\" given! You should specify a validation error message for \" + rule.selectors);\n            } else if (check.errors.size() > 1) {\n                throw new IllegalDataException(\n                        \"More than one \"+POSSIBLE_THROWS+\" given! You should specify a single validation error message for \"\n                                + rule.selectors);\n            }\n            return check;\n        }","commit_id":"fcc731ecd15a245fc97c0b0266ee60cc4c187cdf","url":"https://github.com/openstreetmap/josm"},{"original_method":"private RandomGrabArrayItem removeRandomLimited(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tint excluded = 0;\n\t\tboolean changedMe = false;\n\t\twhile(true) {\n\t\tint i = context.fastWeakRandom.nextInt(index);\n\t\tint blockNo = i / BLOCK_SIZE;\n\t\tint lastActiveBlock = -1;\n\t\tRandomGrabArrayItem ret, oret;\n\t\tif(persistent && blockNo != lastActiveBlock) {\n\t\t\tif(lastActiveBlock != -1)\n\t\t\t\tcontainer.deactivate(blocks[lastActiveBlock], 1);\n\t\t\tlastActiveBlock = blockNo;\n\t\t\tcontainer.activate(blocks[blockNo], 1);\n\t\t}\n\t\tret = blocks[blockNo].reqs[i % BLOCK_SIZE];\n\t\tif(ret == null) {\n\t\t\tLogger.error(this, \"reqs[\"+i+\"] = null\");\n\t\t\tremove(blockNo, i, container);\n\t\t\tchangedMe = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(excluding.excludeSummarily(ret, this, container, persistent, now)) {\n\t\t\texcluded++;\n\t\t\tif(excluded > MAX_EXCLUDED) {\n\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.activate(ret, 1);\n\t\toret = ret;\n\t\tboolean broken = false;\n\t\tbroken = persistent && ret.isStorageBroken(container);\n\t\tif(broken) {\n\t\t\tLogger.error(this, \"Storage broken on \"+ret);\n\t\t\ttry {\n\t\t\t\tret.removeFrom(container, context);\n\t\t\t} catch (Throwable t) {\n\t\t\t\t// Ignore\n\t\t\t\tcontainer.delete(ret);\n\t\t\t}\n\t\t}\n\t\tlong itemWakeTime = ret.getCooldownTime(container, context, now);\n\t\tif(broken || itemWakeTime == -1) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not returning because cancelled: \"+ret);\n\t\t\tret = null;\n\t\t\t// Will be removed in the do{} loop\n\t\t\t// Tell it that it's been removed first.\n\t\t\toret.setParentGrabArray(null, container);\n\t\t}\n\t\tif(ret != null && (itemWakeTime > 0 || excluding.exclude(ret, container, context))) {\n\t\t\texcluded++;\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(ret, 1);\n\t\t\tif(excluded > MAX_EXCLUDED) {\n\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(ret != null) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Returning (cannot remove): \"+ret+\" of \"+index);\n\t\t\tif(persistent && changedMe)\n\t\t\t\tcontainer.store(this);\n\t\t\treturn ret;\n\t\t}\n\t\t// Remove an element.\n\t\tdo {\n\t\t\tchangedMe = true;\n\t\t\tremove(blockNo, i, container);\n\t\t\tif(persistent && oret != null && ret == null) // if ret != null we will return it\n\t\t\t\tcontainer.deactivate(oret, 1);\n\t\t\toret = blocks[blockNo].reqs[i % BLOCK_SIZE];\n\t\t\t// Check for nulls, but don't check for cancelled, since we'd have to activate.\n\t\t} while (index > i && oret == null);\n\t\t// Shrink array\n\t\tif(blocks.length == 1 && index < blocks[0].reqs.length / 4) {\n\t\t\tchangedMe = true;\n\t\t\t// Shrink array\n\t\t\tint newSize = Math.max(index * 2, MIN_SIZE);\n\t\t\tRandomGrabArrayItem[] r = new RandomGrabArrayItem[newSize];\n\t\t\tSystem.arraycopy(blocks[0].reqs, 0, r, 0, r.length);\n\t\t\tblocks[0].reqs = r;\n\t\t\tif(persistent)\n\t\t\t\tcontainer.store(this);\n\t\t} else if(blocks.length > 1 &&\n\t\t\t\t(((index + (BLOCK_SIZE/2)) / BLOCK_SIZE) + 1) < \n\t\t\t\tblocks.length) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Shrinking blocks on \"+this);\n\t\t\tBlock[] newBlocks = new Block[((index + (BLOCK_SIZE/2)) / BLOCK_SIZE) + 1];\n\t\t\tSystem.arraycopy(blocks, 0, newBlocks, 0, newBlocks.length);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.store(this);\n\t\t\t\tfor(int x=newBlocks.length;x<blocks.length;x++)\n\t\t\t\t\tcontainer.delete(blocks[x]);\n\t\t\t}\n\t\t\tblocks = newBlocks;\n\t\t}\n\t\treturn ret;\n\t\t}\n\t}","id":76684,"modified_method":"private RandomGrabArrayItem removeRandomLimited(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tint excluded = 0;\n\t\tboolean changedMe = false;\n\t\twhile(true) {\n\t\tint i = context.fastWeakRandom.nextInt(index);\n\t\tint blockNo = i / BLOCK_SIZE;\n\t\tint lastActiveBlock = -1;\n\t\tRandomGrabArrayItem ret, oret;\n\t\tif(persistent && blockNo != lastActiveBlock) {\n\t\t\tif(lastActiveBlock != -1)\n\t\t\t\tcontainer.deactivate(blocks[lastActiveBlock], 1);\n\t\t\tlastActiveBlock = blockNo;\n\t\t\tcontainer.activate(blocks[blockNo], 1);\n\t\t}\n\t\tret = blocks[blockNo].reqs[i % BLOCK_SIZE];\n\t\tif(ret == null) {\n\t\t\tLogger.error(this, \"reqs[\"+i+\"] = null\");\n\t\t\tremove(blockNo, i, container);\n\t\t\tchangedMe = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(excluding.excludeSummarily(ret, this, container, persistent, now) > 0) {\n\t\t\texcluded++;\n\t\t\tif(excluded > MAX_EXCLUDED) {\n\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.activate(ret, 1);\n\t\toret = ret;\n\t\tboolean broken = false;\n\t\tbroken = persistent && ret.isStorageBroken(container);\n\t\tif(broken) {\n\t\t\tLogger.error(this, \"Storage broken on \"+ret);\n\t\t\ttry {\n\t\t\t\tret.removeFrom(container, context);\n\t\t\t} catch (Throwable t) {\n\t\t\t\t// Ignore\n\t\t\t\tcontainer.delete(ret);\n\t\t\t}\n\t\t}\n\t\tlong itemWakeTime = ret.getCooldownTime(container, context, now);\n\t\tif(broken || itemWakeTime == -1) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not returning because cancelled: \"+ret);\n\t\t\tret = null;\n\t\t\t// Will be removed in the do{} loop\n\t\t\t// Tell it that it's been removed first.\n\t\t\toret.setParentGrabArray(null, container);\n\t\t}\n\t\tif(ret != null && (itemWakeTime > 0 || excluding.exclude(ret, container, context))) {\n\t\t\texcluded++;\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(ret, 1);\n\t\t\tif(excluded > MAX_EXCLUDED) {\n\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(ret != null) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Returning (cannot remove): \"+ret+\" of \"+index);\n\t\t\tif(persistent && changedMe)\n\t\t\t\tcontainer.store(this);\n\t\t\treturn ret;\n\t\t}\n\t\t// Remove an element.\n\t\tdo {\n\t\t\tchangedMe = true;\n\t\t\tremove(blockNo, i, container);\n\t\t\tif(persistent && oret != null && ret == null) // if ret != null we will return it\n\t\t\t\tcontainer.deactivate(oret, 1);\n\t\t\toret = blocks[blockNo].reqs[i % BLOCK_SIZE];\n\t\t\t// Check for nulls, but don't check for cancelled, since we'd have to activate.\n\t\t} while (index > i && oret == null);\n\t\t// Shrink array\n\t\tif(blocks.length == 1 && index < blocks[0].reqs.length / 4) {\n\t\t\tchangedMe = true;\n\t\t\t// Shrink array\n\t\t\tint newSize = Math.max(index * 2, MIN_SIZE);\n\t\t\tRandomGrabArrayItem[] r = new RandomGrabArrayItem[newSize];\n\t\t\tSystem.arraycopy(blocks[0].reqs, 0, r, 0, r.length);\n\t\t\tblocks[0].reqs = r;\n\t\t\tif(persistent)\n\t\t\t\tcontainer.store(this);\n\t\t} else if(blocks.length > 1 &&\n\t\t\t\t(((index + (BLOCK_SIZE/2)) / BLOCK_SIZE) + 1) < \n\t\t\t\tblocks.length) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Shrinking blocks on \"+this);\n\t\t\tBlock[] newBlocks = new Block[((index + (BLOCK_SIZE/2)) / BLOCK_SIZE) + 1];\n\t\t\tSystem.arraycopy(blocks, 0, newBlocks, 0, newBlocks.length);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.store(this);\n\t\t\t\tfor(int x=newBlocks.length;x<blocks.length;x++)\n\t\t\t\t\tcontainer.delete(blocks[x]);\n\t\t\t}\n\t\t\tblocks = newBlocks;\n\t\t}\n\t\treturn ret;\n\t\t}\n\t}","commit_id":"d080d921a28b0a83ee32c9c5d5375a945cbd8eca","url":"https://github.com/freenet/fred"},{"original_method":"private RemoveRandomReturn removeRandomExhaustiveSearch(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tboolean changedMe = false;\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\tRandomGrabArrayItem ret = null;\n\t\tint random = -1;\n\t\tif(persistent) container.activate(blocks[0], 1);\n\t\tRandomGrabArrayItem[] reqsReading = blocks[0].reqs;\n\t\tRandomGrabArrayItem[] reqsWriting = blocks[0].reqs;\n\t\tint blockNumReading = 0;\n\t\tint blockNumWriting = 0;\n\t\tint offset = -1;\n\t\tint writeOffset = -1;\n\t\twhile(true) {\n\t\t\tint exclude = 0;\n\t\t\tint valid = 0;\n\t\t\tint validIndex = -1;\n\t\t\tint target = 0;\n\t\t\tint chosenIndex = -1;\n\t\t\tRandomGrabArrayItem chosenItem = null;\n\t\t\tRandomGrabArrayItem validItem = null;\n\t\t\tfor(int i=0;i<index;i++) {\n\t\t\t\toffset++;\n\t\t\t\t// Compact the array.\n\t\t\t\tRandomGrabArrayItem item;\n\t\t\t\tif(offset == BLOCK_SIZE) {\n\t\t\t\t\toffset = -1;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumReading], 1);\n\t\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumReading]);\n\t\t\t\t\tblockNumReading++;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.activate(blocks[blockNumReading], 1);\n\t\t\t\t\treqsReading = blocks[blockNumReading].reqs;\n\t\t\t\t}\n\t\t\t\titem = reqsReading[offset];\n\t\t\t\tif(item == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tboolean excludeItem = false;\n\t\t\t\tboolean activated = false;\n\t\t\t\tif(excluding.excludeSummarily(item, this, container, persistent, now)) {\n\t\t\t\t\t// In cooldown, will be wanted later.\n\t\t\t\t\texcludeItem = true;\n\t\t\t\t} else {\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(item, 1);\n\t\t\t\t\tactivated = true;\n\t\t\t\t\tboolean broken = false;\n\t\t\t\t\tbroken = persistent && item.isStorageBroken(container);\n\t\t\t\t\tif(broken) {\n\t\t\t\t\t\tLogger.error(this, \"Storage broken on \"+item);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\titem.removeFrom(container, context);\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\tcontainer.delete(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlong itemWakeTime = item.getCooldownTime(container, context, now);\n\t\t\t\t\tif(itemWakeTime == -1 || broken) {\n\t\t\t\t\t\tchangedMe = true;\n\t\t\t\t\t\t// We are doing compaction here. We don't need to swap with the end; we write valid ones to the target location.\n\t\t\t\t\t\treqsReading[offset] = null;\n\t\t\t\t\t\titem.setParentGrabArray(null, container);\n\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\tcontainer.deactivate(item, 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if(itemWakeTime > 0) {\n\t\t\t\t\t\tif(itemWakeTime < wakeupTime) wakeupTime = itemWakeTime;\n\t\t\t\t\t\texcludeItem = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(!excludeItem)\n\t\t\t\t\t\texcludeItem = excluding.exclude(item, container, context);\n\t\t\t\t}\n\t\t\t\twriteOffset++;\n\t\t\t\tif(writeOffset == BLOCK_SIZE) {\n\t\t\t\t\twriteOffset = 0;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumWriting], 1);\n\t\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumWriting]);\n\t\t\t\t\tblockNumWriting++;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.activate(blocks[blockNumWriting], 1);\n\t\t\t\t\treqsWriting = blocks[blockNumWriting].reqs;\n\t\t\t\t}\n\t\t\t\tif(i != target) {\n\t\t\t\t\tchangedMe = true;\n\t\t\t\t\treqsReading[offset] = null;\n\t\t\t\t\treqsWriting[writeOffset] = item;\n\t\t\t\t} // else the request can happily stay where it is\n\t\t\t\ttarget++;\n\t\t\t\tif(excludeItem) {\n\t\t\t\t\texclude++;\n\t\t\t\t} else {\n\t\t\t\t\tif(valid == random) { // Picked on previous round\n\t\t\t\t\t\tchosenIndex = target-1;\n\t\t\t\t\t\tchosenItem = item;\n\t\t\t\t\t}\n\t\t\t\t\tif(validIndex == -1) {\n\t\t\t\t\t\t// Take the first valid item\n\t\t\t\t\t\tvalidIndex = target-1;\n\t\t\t\t\t\tvalidItem = item;\n\t\t\t\t\t}\n\t\t\t\t\tvalid++;\n\t\t\t\t}\n\t\t\t\tif(persistent && activated && item != chosenItem && item != validItem) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Deactivating \"+item);\n\t\t\t\t\tcontainer.deactivate(item, 1);\n\t\t\t\t\tif(container.ext().isActive(item))\n\t\t\t\t\t\tLogger.error(this, \"Still active after deactivation: \"+item);\n\t\t\t\t\telse if(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Deactivated: \"+item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(index != target) {\n\t\t\t\tchangedMe = true;\n\t\t\t\tindex = target;\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.deactivate(blocks[blockNumReading], 1);\n\t\t\t\t\tif(blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumWriting], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// We reach this point if 1) the random number we picked last round is invalid because an item became cancelled or excluded\n\t\t\t// or 2) we are on the first round anyway.\n\t\t\tif(chosenItem != null) {\n\t\t\t\tif(persistent && validItem != null && validItem != chosenItem)\n\t\t\t\t\tcontainer.deactivate(validItem, 1);\n\t\t\t\tchangedMe = true;\n\t\t\t\tret = chosenItem;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Chosen random item \"+ret+\" out of \"+valid+\" total \"+index);\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn new RemoveRandomReturn(ret);\n\t\t\t}\n\t\t\tif(valid == 0 && exclude == 0) {\n\t\t\t\tindex = 0;\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid or excluded items total \"+index);\n\t\t\t\treturn null; // Caller should remove the whole RGA\n\t\t\t} else if(valid == 0) {\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid items, \"+exclude+\" excluded items total \"+index);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t} else if(valid == 1) {\n\t\t\t\tret = validItem;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid or excluded items apart from \"+ret+\" total \"+index);\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn new RemoveRandomReturn(ret);\n\t\t\t} else {\n\t\t\t\trandom = context.fastWeakRandom.nextInt(valid);\n\t\t\t}\n\t\t}\n\t}","id":76685,"modified_method":"private RemoveRandomReturn removeRandomExhaustiveSearch(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tboolean changedMe = false;\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\tRandomGrabArrayItem ret = null;\n\t\tint random = -1;\n\t\tif(persistent) container.activate(blocks[0], 1);\n\t\tRandomGrabArrayItem[] reqsReading = blocks[0].reqs;\n\t\tRandomGrabArrayItem[] reqsWriting = blocks[0].reqs;\n\t\tint blockNumReading = 0;\n\t\tint blockNumWriting = 0;\n\t\tint offset = -1;\n\t\tint writeOffset = -1;\n\t\twhile(true) {\n\t\t\tint exclude = 0;\n\t\t\tint valid = 0;\n\t\t\tint validIndex = -1;\n\t\t\tint target = 0;\n\t\t\tint chosenIndex = -1;\n\t\t\tRandomGrabArrayItem chosenItem = null;\n\t\t\tRandomGrabArrayItem validItem = null;\n\t\t\tfor(int i=0;i<index;i++) {\n\t\t\t\toffset++;\n\t\t\t\t// Compact the array.\n\t\t\t\tRandomGrabArrayItem item;\n\t\t\t\tif(offset == BLOCK_SIZE) {\n\t\t\t\t\toffset = -1;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumReading], 1);\n\t\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumReading]);\n\t\t\t\t\tblockNumReading++;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.activate(blocks[blockNumReading], 1);\n\t\t\t\t\treqsReading = blocks[blockNumReading].reqs;\n\t\t\t\t}\n\t\t\t\titem = reqsReading[offset];\n\t\t\t\tif(item == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tboolean excludeItem = false;\n\t\t\t\tboolean activated = false;\n\t\t\t\tlong excludeTime = excluding.excludeSummarily(item, this, container, persistent, now);\n\t\t\t\tif(excludeTime > 0) {\n\t\t\t\t\t// In cooldown, will be wanted later.\n\t\t\t\t\texcludeItem = true;\n\t\t\t\t\tif(wakeupTime > excludeTime) wakeupTime = excludeTime;\n\t\t\t\t} else {\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(item, 1);\n\t\t\t\t\tactivated = true;\n\t\t\t\t\tboolean broken = false;\n\t\t\t\t\tbroken = persistent && item.isStorageBroken(container);\n\t\t\t\t\tif(broken) {\n\t\t\t\t\t\tLogger.error(this, \"Storage broken on \"+item);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\titem.removeFrom(container, context);\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\tcontainer.delete(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlong itemWakeTime = item.getCooldownTime(container, context, now);\n\t\t\t\t\tif(itemWakeTime == -1 || broken) {\n\t\t\t\t\t\tchangedMe = true;\n\t\t\t\t\t\t// We are doing compaction here. We don't need to swap with the end; we write valid ones to the target location.\n\t\t\t\t\t\treqsReading[offset] = null;\n\t\t\t\t\t\titem.setParentGrabArray(null, container);\n\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\tcontainer.deactivate(item, 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if(itemWakeTime > 0) {\n\t\t\t\t\t\tif(itemWakeTime < wakeupTime) wakeupTime = itemWakeTime;\n\t\t\t\t\t\texcludeItem = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(!excludeItem)\n\t\t\t\t\t\texcludeItem = excluding.exclude(item, container, context);\n\t\t\t\t}\n\t\t\t\twriteOffset++;\n\t\t\t\tif(writeOffset == BLOCK_SIZE) {\n\t\t\t\t\twriteOffset = 0;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumWriting], 1);\n\t\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumWriting]);\n\t\t\t\t\tblockNumWriting++;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.activate(blocks[blockNumWriting], 1);\n\t\t\t\t\treqsWriting = blocks[blockNumWriting].reqs;\n\t\t\t\t}\n\t\t\t\tif(i != target) {\n\t\t\t\t\tchangedMe = true;\n\t\t\t\t\treqsReading[offset] = null;\n\t\t\t\t\treqsWriting[writeOffset] = item;\n\t\t\t\t} // else the request can happily stay where it is\n\t\t\t\ttarget++;\n\t\t\t\tif(excludeItem) {\n\t\t\t\t\texclude++;\n\t\t\t\t} else {\n\t\t\t\t\tif(valid == random) { // Picked on previous round\n\t\t\t\t\t\tchosenIndex = target-1;\n\t\t\t\t\t\tchosenItem = item;\n\t\t\t\t\t}\n\t\t\t\t\tif(validIndex == -1) {\n\t\t\t\t\t\t// Take the first valid item\n\t\t\t\t\t\tvalidIndex = target-1;\n\t\t\t\t\t\tvalidItem = item;\n\t\t\t\t\t}\n\t\t\t\t\tvalid++;\n\t\t\t\t}\n\t\t\t\tif(persistent && activated && item != chosenItem && item != validItem) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Deactivating \"+item);\n\t\t\t\t\tcontainer.deactivate(item, 1);\n\t\t\t\t\tif(container.ext().isActive(item))\n\t\t\t\t\t\tLogger.error(this, \"Still active after deactivation: \"+item);\n\t\t\t\t\telse if(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Deactivated: \"+item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(index != target) {\n\t\t\t\tchangedMe = true;\n\t\t\t\tindex = target;\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.deactivate(blocks[blockNumReading], 1);\n\t\t\t\t\tif(blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumWriting], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// We reach this point if 1) the random number we picked last round is invalid because an item became cancelled or excluded\n\t\t\t// or 2) we are on the first round anyway.\n\t\t\tif(chosenItem != null) {\n\t\t\t\tif(persistent && validItem != null && validItem != chosenItem)\n\t\t\t\t\tcontainer.deactivate(validItem, 1);\n\t\t\t\tchangedMe = true;\n\t\t\t\tret = chosenItem;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Chosen random item \"+ret+\" out of \"+valid+\" total \"+index);\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn new RemoveRandomReturn(ret);\n\t\t\t}\n\t\t\tif(valid == 0 && exclude == 0) {\n\t\t\t\tindex = 0;\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid or excluded items total \"+index);\n\t\t\t\treturn null; // Caller should remove the whole RGA\n\t\t\t} else if(valid == 0) {\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid items, \"+exclude+\" excluded items total \"+index);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t} else if(valid == 1) {\n\t\t\t\tret = validItem;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid or excluded items apart from \"+ret+\" total \"+index);\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn new RemoveRandomReturn(ret);\n\t\t\t} else {\n\t\t\t\trandom = context.fastWeakRandom.nextInt(valid);\n\t\t\t}\n\t\t}\n\t}","commit_id":"d080d921a28b0a83ee32c9c5d5375a945cbd8eca","url":"https://github.com/freenet/fred"},{"original_method":"public boolean excludeSummarily(HasCooldownCacheItem item,\n\t\t\tHasCooldownCacheItem parent, ObjectContainer container, boolean persistent, long now) {\n\t\treturn core.clientContext.cooldownTracker.getCachedWakeup(item, persistent, container, now) != -1;\n\t}","id":76686,"modified_method":"public long excludeSummarily(HasCooldownCacheItem item,\n\t\t\tHasCooldownCacheItem parent, ObjectContainer container, boolean persistent, long now) {\n\t\treturn core.clientContext.cooldownTracker.getCachedWakeup(item, persistent, container, now);\n\t}","commit_id":"d080d921a28b0a83ee32c9c5d5375a945cbd8eca","url":"https://github.com/freenet/fred"},{"original_method":"private RemoveRandomReturn removeRandomTwoOnly(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t// Another simple common case\n\t\tint x = context.fastWeakRandom.nextBoolean() ? 1 : 0;\n\t\tRemoveRandomWithObject rga = grabArrays[x];\n\t\tRemoveRandomWithObject firstRGA = rga;\n\t\tif(rga == null) {\n\t\t\tLogger.error(this, \"rga = null on \"+this);\n\t\t\tif(container != null && !container.ext().isActive(this))\n\t\t\t\tLogger.error(this, \"NOT ACTIVE!!\");\n\t\t\tif(grabArrays[1-x] == null) {\n\t\t\t\tLogger.error(this, \"other rga is also null on \"+this);\n\t\t\t} else {\n\t\t\t\tRemoveRandomWithObject valid = grabArrays[1-x];\n\t\t\t\tLogger.error(this, \"grabArrays[\"+(1-x)+\"] is valid but [\"+x+\"] is null, correcting...\");\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { grabArrays[1-x] };\n\t\t\t\tgrabClients = new Object[] { grabClients[1-x] };\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tRandomGrabArrayItem item = null;\n\t\tRemoveRandomReturn val = null;\n\t\tif(!excluding.excludeSummarily(rga, this, container, persistent, now)) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rga, 1);\n\t\t\tval = rga.removeRandom(excluding, container, context, now);\n\t\t\tif(val != null) {\n\t\t\t\tif(val.item != null)\n\t\t\t\t\titem = val.item;\n\t\t\t\telse {\n\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(item == null) {\n\t\t\tx = 1-x;\n\t\t\trga = grabArrays[x];\n\t\t\tif(rga == null) {\n\t\t\t\tLogger.error(this, \"Other RGA is null later on on \"+this);\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { grabArrays[1-x] };\n\t\t\t\tgrabClients = new Object[] { grabClients[1-x] };\n\t\t\t\tif(persistent) container.store(this);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t}\n\t\t\tif(!excluding.excludeSummarily(rga, this, container, persistent, now)) {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(rga, 1);\n\t\t\t\tval = rga.removeRandom(excluding, container, context, now);\n\t\t\t\tif(val != null) {\n\t\t\t\t\tif(val.item != null)\n\t\t\t\t\t\titem = val.item;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(firstRGA.isEmpty() && rga.isEmpty()) {\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[0];\n\t\t\t\tgrabClients = new Object[0];\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\tfirstRGA.removeFrom(container);\n\t\t\t\t\trga.removeFrom(container);\n\t\t\t\t}\n\t\t\t} else if(firstRGA.isEmpty()) {\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.activate(firstRGA, 1);\n\t\t\t\t}\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { rga };\n\t\t\t\tgrabClients = new Object[] { grabClients[x] };\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\tfirstRGA.removeFrom(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t\tcontainer.deactivate(firstRGA, 1);\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Returning (two items only) \"+item+\" for \"+rga);\n\t\t\tif(item == null) {\n\t\t\t\tif(grabArrays.length == 0)\n\t\t\t\t\treturn null; // Remove this as well\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t} else return new RemoveRandomReturn(item);\n\t\t} else {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Returning (two items only) \"+item+\" for \"+rga);\n\t\t\treturn new RemoveRandomReturn(item);\n\t\t}\n\t}","id":76687,"modified_method":"private RemoveRandomReturn removeRandomTwoOnly(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\t// Another simple common case\n\t\tint x = context.fastWeakRandom.nextBoolean() ? 1 : 0;\n\t\tRemoveRandomWithObject rga = grabArrays[x];\n\t\tRemoveRandomWithObject firstRGA = rga;\n\t\tif(rga == null) {\n\t\t\tLogger.error(this, \"rga = null on \"+this);\n\t\t\tif(container != null && !container.ext().isActive(this))\n\t\t\t\tLogger.error(this, \"NOT ACTIVE!!\");\n\t\t\tif(grabArrays[1-x] == null) {\n\t\t\t\tLogger.error(this, \"other rga is also null on \"+this);\n\t\t\t} else {\n\t\t\t\tRemoveRandomWithObject valid = grabArrays[1-x];\n\t\t\t\tLogger.error(this, \"grabArrays[\"+(1-x)+\"] is valid but [\"+x+\"] is null, correcting...\");\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { grabArrays[1-x] };\n\t\t\t\tgrabClients = new Object[] { grabClients[1-x] };\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tRandomGrabArrayItem item = null;\n\t\tRemoveRandomReturn val = null;\n\t\tlong excludeTime = excluding.excludeSummarily(rga, this, container, persistent, now);\n\t\tif(excludeTime > 0) {\n\t\t\twakeupTime = excludeTime;\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rga, 1);\n\t\t\tval = rga.removeRandom(excluding, container, context, now);\n\t\t\tif(val != null) {\n\t\t\t\tif(val.item != null)\n\t\t\t\t\titem = val.item;\n\t\t\t\telse {\n\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(item == null) {\n\t\t\tx = 1-x;\n\t\t\trga = grabArrays[x];\n\t\t\tif(rga == null) {\n\t\t\t\tLogger.error(this, \"Other RGA is null later on on \"+this);\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { grabArrays[1-x] };\n\t\t\t\tgrabClients = new Object[] { grabClients[1-x] };\n\t\t\t\tif(persistent) container.store(this);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t}\n\t\t\texcludeTime = excluding.excludeSummarily(rga, this, container, persistent, now);\n\t\t\tif(excludeTime > 0) {\n\t\t\t\tif(wakeupTime < excludeTime) wakeupTime = excludeTime;\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(rga, 1);\n\t\t\t\tval = rga.removeRandom(excluding, container, context, now);\n\t\t\t\tif(val != null) {\n\t\t\t\t\tif(val.item != null)\n\t\t\t\t\t\titem = val.item;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(firstRGA.isEmpty() && rga.isEmpty()) {\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[0];\n\t\t\t\tgrabClients = new Object[0];\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\tfirstRGA.removeFrom(container);\n\t\t\t\t\trga.removeFrom(container);\n\t\t\t\t}\n\t\t\t} else if(firstRGA.isEmpty()) {\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.activate(firstRGA, 1);\n\t\t\t\t}\n\t\t\t\tgrabArrays = new RemoveRandomWithObject[] { rga };\n\t\t\t\tgrabClients = new Object[] { grabClients[x] };\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\tfirstRGA.removeFrom(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t\tcontainer.deactivate(firstRGA, 1);\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Returning (two items only) \"+item+\" for \"+rga);\n\t\t\tif(item == null) {\n\t\t\t\tif(grabArrays.length == 0)\n\t\t\t\t\treturn null; // Remove this as well\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t} else return new RemoveRandomReturn(item);\n\t\t} else {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Returning (two items only) \"+item+\" for \"+rga);\n\t\t\treturn new RemoveRandomReturn(item);\n\t\t}\n\t}","commit_id":"d080d921a28b0a83ee32c9c5d5375a945cbd8eca","url":"https://github.com/freenet/fred"},{"original_method":"private RandomGrabArrayItem removeRandomLimited(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\t/** Count of arrays that have items but didn't return anything because of exclusions */\n\t\tfinal int MAX_EXCLUDED = 10;\n\t\tint excluded = 0;\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\twhile(true) {\n\t\t\tint x = context.fastWeakRandom.nextInt(grabArrays.length);\n\t\t\tRemoveRandomWithObject rga = grabArrays[x];\n\t\t\tif(excluding.excludeSummarily(rga, this, container, persistent, now)) {\n\t\t\t\texcluded++;\n\t\t\t\tif(excluded > MAX_EXCLUDED) {\n\t\t\t\t\tLogger.normal(this, \"Too many sub-arrays are entirely excluded on \"+this+\" length = \"+grabArrays.length, new Exception(\"error\"));\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rga, 1);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Picked \"+x+\" of \"+grabArrays.length+\" : \"+rga+\" on \"+this);\n\t\t\t\n\t\t\tRandomGrabArrayItem item = null;\n\t\t\tRemoveRandomReturn val = rga.removeRandom(excluding, container, context, now);\n\t\t\tif(val != null) {\n\t\t\t\tif(val.item != null)\n\t\t\t\t\titem = val.item;\n\t\t\t\telse {\n\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"RGA has picked \"+x+\"/\"+grabArrays.length+\": \"+item+\n\t\t\t\t\t\t\" rga.isEmpty=\"+rga.isEmpty());\n\t\t\t// Just because the item is cancelled does not necessarily mean the whole client is.\n\t\t\t// E.g. a segment may return cancelled because it is decoding, that doesn't mean\n\t\t\t// other segments are cancelled. So just go around the loop in that case.\n\t\t\tif(rga.isEmpty()) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Removing grab array \"+x+\" : \"+rga+\" (is empty)\");\n\t\t\t\tremoveElement(x);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\trga.removeFrom(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(item == null) {\n\t\t\t\tif(!rga.isEmpty()) {\n\t\t\t\t\t// Hmmm...\n\t\t\t\t\texcluded++;\n\t\t\t\t\tif(excluded > MAX_EXCLUDED) {\n\t\t\t\t\t\tLogger.normal(this, \"Too many sub-arrays are entirely excluded on \"+this+\" length = \"+grabArrays.length, new Exception(\"error\"));\n\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t// No point calling getCooldownTime() again.\n\t\t\treturn item;\n\t\t}\n\t}","id":76688,"modified_method":"private RandomGrabArrayItem removeRandomLimited(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\t/** Count of arrays that have items but didn't return anything because of exclusions */\n\t\tfinal int MAX_EXCLUDED = 10;\n\t\tint excluded = 0;\n\t\twhile(true) {\n\t\t\tint x = context.fastWeakRandom.nextInt(grabArrays.length);\n\t\t\tRemoveRandomWithObject rga = grabArrays[x];\n\t\t\tlong excludeTime = excluding.excludeSummarily(rga, this, container, persistent, now);\n\t\t\tif(excludeTime > 0) {\n\t\t\t\texcluded++;\n\t\t\t\tif(excluded > MAX_EXCLUDED) {\n\t\t\t\t\tLogger.normal(this, \"Too many sub-arrays are entirely excluded on \"+this+\" length = \"+grabArrays.length, new Exception(\"error\"));\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rga, 1);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Picked \"+x+\" of \"+grabArrays.length+\" : \"+rga+\" on \"+this);\n\t\t\t\n\t\t\tRandomGrabArrayItem item = null;\n\t\t\tRemoveRandomReturn val = rga.removeRandom(excluding, container, context, now);\n\t\t\tif(val != null) {\n\t\t\t\tif(val.item != null)\n\t\t\t\t\titem = val.item;\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"RGA has picked \"+x+\"/\"+grabArrays.length+\": \"+item+\n\t\t\t\t\t\t\" rga.isEmpty=\"+rga.isEmpty());\n\t\t\t// Just because the item is cancelled does not necessarily mean the whole client is.\n\t\t\t// E.g. a segment may return cancelled because it is decoding, that doesn't mean\n\t\t\t// other segments are cancelled. So just go around the loop in that case.\n\t\t\tif(rga.isEmpty()) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Removing grab array \"+x+\" : \"+rga+\" (is empty)\");\n\t\t\t\tremoveElement(x);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\trga.removeFrom(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(item == null) {\n\t\t\t\tif(!rga.isEmpty()) {\n\t\t\t\t\t// Hmmm...\n\t\t\t\t\texcluded++;\n\t\t\t\t\tif(excluded > MAX_EXCLUDED) {\n\t\t\t\t\t\tLogger.normal(this, \"Too many sub-arrays are entirely excluded on \"+this+\" length = \"+grabArrays.length, new Exception(\"error\"));\n\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\t// No point calling getCooldownTime() again.\n\t\t\treturn item;\n\t\t}\n\t}","commit_id":"d080d921a28b0a83ee32c9c5d5375a945cbd8eca","url":"https://github.com/freenet/fred"},{"original_method":"private RemoveRandomReturn removeRandomExhaustive(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\tint x = context.fastWeakRandom.nextInt(grabArrays.length);\n\t\tfor(int i=0;i<grabArrays.length;i++) {\n\t\t\tx++;\n\t\t\tif(x >= grabArrays.length) x = 0;\n\t\t\tRemoveRandomWithObject rga = grabArrays[x];\n\t\t\tif(excluding.excludeSummarily(rga, this, container, persistent, now))\n\t\t\t\tcontinue;\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rga, 1);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Picked \"+x+\" of \"+grabArrays.length+\" : \"+rga+\" on \"+this);\n\t\t\t\n\t\t\tRandomGrabArrayItem item = null;\n\t\t\tRemoveRandomReturn val = rga.removeRandom(excluding, container, context, now);\n\t\t\tif(val != null) {\n\t\t\t\tif(val.item != null)\n\t\t\t\t\titem = val.item;\n\t\t\t\telse {\n\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"RGA has picked \"+x+\"/\"+grabArrays.length+\": \"+item+\n\t\t\t\t\t\t\" rga.isEmpty=\"+rga.isEmpty());\n\t\t\t// Just because the item is cancelled does not necessarily mean the whole client is.\n\t\t\t// E.g. a segment may return cancelled because it is decoding, that doesn't mean\n\t\t\t// other segments are cancelled. So just go around the loop in that case.\n\t\t\tif(rga.isEmpty()) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Removing grab array \"+x+\" : \"+rga+\" (is empty)\");\n\t\t\t\tremoveElement(x);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\trga.removeFrom(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\tif(item == null) continue;\n\t\t\t// No point calling getCooldownTime() again.\n\t\t\treturn new RemoveRandomReturn(item);\n\n\t\t}\n\t\treturn new RemoveRandomReturn(wakeupTime);\n\t}","id":76689,"modified_method":"private RemoveRandomReturn removeRandomExhaustive(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\tint x = context.fastWeakRandom.nextInt(grabArrays.length);\n\t\tfor(int i=0;i<grabArrays.length;i++) {\n\t\t\tx++;\n\t\t\tif(x >= grabArrays.length) x = 0;\n\t\t\tRemoveRandomWithObject rga = grabArrays[x];\n\t\t\tlong excludeTime = excluding.excludeSummarily(rga, this, container, persistent, now);\n\t\t\tif(excludeTime > 0) {\n\t\t\t\tif(wakeupTime > excludeTime) wakeupTime = excludeTime;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(rga, 1);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Picked \"+x+\" of \"+grabArrays.length+\" : \"+rga+\" on \"+this);\n\t\t\t\n\t\t\tRandomGrabArrayItem item = null;\n\t\t\tRemoveRandomReturn val = rga.removeRandom(excluding, container, context, now);\n\t\t\tif(val != null) {\n\t\t\t\tif(val.item != null)\n\t\t\t\t\titem = val.item;\n\t\t\t\telse {\n\t\t\t\t\tif(wakeupTime > val.wakeupTime) wakeupTime = val.wakeupTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"RGA has picked \"+x+\"/\"+grabArrays.length+\": \"+item+\n\t\t\t\t\t\t\" rga.isEmpty=\"+rga.isEmpty());\n\t\t\t// Just because the item is cancelled does not necessarily mean the whole client is.\n\t\t\t// E.g. a segment may return cancelled because it is decoding, that doesn't mean\n\t\t\t// other segments are cancelled. So just go around the loop in that case.\n\t\t\tif(rga.isEmpty()) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Removing grab array \"+x+\" : \"+rga+\" (is empty)\");\n\t\t\t\tremoveElement(x);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t\trga.removeFrom(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(rga, 1);\n\t\t\tif(item == null) continue;\n\t\t\t// No point calling getCooldownTime() again.\n\t\t\treturn new RemoveRandomReturn(item);\n\n\t\t}\n\t\treturn new RemoveRandomReturn(wakeupTime);\n\t}","commit_id":"d080d921a28b0a83ee32c9c5d5375a945cbd8eca","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * <p>onInit<\/p>\n     *\n     * @throws java.lang.IllegalStateException if any.\n     */\n    @Override\n    protected void onInit() throws IllegalStateException {\n\n        Assert.state(m_eventForwarder != null, \"must set the eventForwarder property\");\n        \n        try {\n            initializeConfiguration();\n            EventIpcManagerFactory.init();\n        } catch (Throwable e) {\n            LOG.debug(\"onInit: initialization failed\", e);\n            throw new IllegalStateException(\"Could not initialize discovery configuration.\", e);\n        }\n    }","id":76690,"modified_method":"/**\n     * <p>onInit<\/p>\n     *\n     * @throws java.lang.IllegalStateException if any.\n     */\n    @Override\n    protected void onInit() throws IllegalStateException {\n\n        Assert.state(m_eventForwarder != null, \"must set the eventForwarder property\");\n        \n        //Wiring doesn't seem to be working.\n        Assert.state(m_discoveryFactory != null, \"must set the Discovery Factory propertly\");\n        cb.setDiscoveryFactory(m_discoveryFactory);\n        \n        try {\n        \tLOG.debug(\"Initializing configuration...\");\n            initializeConfiguration();\n        \tLOG.debug(\"Configuration initialized.  Init the factory...\");\n            EventIpcManagerFactory.init();\n        \tLOG.debug(\"Factory init'd.\");\n        } catch (Throwable e) {\n            LOG.debug(\"onInit: initialization failed\", e);\n            throw new IllegalStateException(\"Could not initialize discovery configuration.\", e);\n        }\n    }","commit_id":"b956936b41349e4bd854bb958279d87a678d96e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void ping(IPPollAddress pollAddress) {\n        InetAddress address = pollAddress.getAddress();\n        if (address != null) {\n            if (!isAlreadyDiscovered(address)) {\n                try {\n                    m_pinger.ping(address, pollAddress.getTimeout(), pollAddress.getRetries(), (short) 1, cb);\n                } catch (Throwable e) {\n                    LOG.debug(\"error pinging {}\", address.getAddress(), e);\n                }\n            }\n        }\n    }","id":76691,"modified_method":"private void ping(IPPollAddress pollAddress) {\n        InetAddress address = pollAddress.getAddress();\n        if (address != null) {\n            if (!isAlreadyDiscovered(address)) {\n                try {\n                    m_pinger.ping(address, pollAddress.getTimeout(), pollAddress.getRetries(), (short) 1, cb);\n                } catch (Throwable e) {\n                    LOG.debug(\"error pinging {}\", address.getAddress(), e);\n                }\n            } else {\n            \tLOG.debug(\"{} already discovered.\", address.toString());\n            }\n        }\n    }","commit_id":"b956936b41349e4bd854bb958279d87a678d96e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void doPings() {\n        LOG.info(\"starting ping sweep\");\n        \n        try {\n            initializeConfiguration();\n        } catch (Throwable e) {\n            LOG.error(\"doPings: could not re-init configuration, continuing with in memory configuration.\", e);\n        }\n\n\n        m_xstatus = PING_RUNNING;\n\n        getDiscoveryFactory().getReadLock().lock();\n        try {\n            for (IPPollAddress pollAddress : getDiscoveryFactory().getConfiguredAddresses()) {\n                if (m_xstatus == PING_FINISHING || m_timer == null) {\n                    m_xstatus = PING_IDLE;\n                    return;\n                }\n                ping(pollAddress);\n                try {\n                    Thread.sleep(getDiscoveryFactory().getIntraPacketDelay());\n                } catch (InterruptedException e) {\n                    LOG.info(\"interrupting discovery sweep\");\n                    break;\n                }\n            }\n        } finally {\n            getDiscoveryFactory().getReadLock().unlock();\n        }\n\n        LOG.info(\"finished discovery sweep\");\n        m_xstatus = PING_IDLE;\n    }","id":76692,"modified_method":"private void doPings() {\n        LOG.info(\"starting ping sweep\");\n        \n        try {\n            initializeConfiguration();\n        } catch (Throwable e) {\n            LOG.error(\"doPings: could not re-init configuration, continuing with in memory configuration.\", e);\n        }\n\n\n        m_xstatus = PING_RUNNING;\n\n        getDiscoveryFactory().getReadLock().lock();\n        try {\n            for (IPPollAddress pollAddress : getDiscoveryFactory().getConfiguredAddresses()) {\n                if (m_xstatus == PING_FINISHING || m_timer == null) {\n                    m_xstatus = PING_IDLE;\n                    return;\n                }\n                LOG.debug(\"Pinging: {} of foreign source {}\", pollAddress.getAddress().toString(), m_discoveryFactory.getForeignSource(pollAddress.getAddress()));\n                ping(pollAddress);\n                try {\n                    Thread.sleep(getDiscoveryFactory().getIntraPacketDelay());\n                } catch (InterruptedException e) {\n                    LOG.info(\"interrupting discovery sweep\");\n                    break;\n                }\n            }\n        } finally {\n            getDiscoveryFactory().getReadLock().unlock();\n        }\n\n        LOG.info(\"finished discovery sweep\");\n        m_xstatus = PING_IDLE;\n    }","commit_id":"b956936b41349e4bd854bb958279d87a678d96e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getForeignSource(InetAddress address) {\n    \tgetReadLock().lock();\n    \t\n        final byte[] laddr = address.getAddress();\n\n    \tList<Specific> specificCollection = getConfiguration().getSpecificCollection();\n    \tfor (Specific specific : specificCollection) {\n\t\t\tString ipAddr = specific.getContent();\n\t\t\tif (ipAddr.equals(InetAddressUtils.str(address))) {\n\t\t\t\treturn specific.getForeignSource();\n\t\t\t}\n\t\t}\n    \t\n    \tList<IncludeRange> includeRangeCollection = getConfiguration().getIncludeRangeCollection();\n    \tfor (IncludeRange range : includeRangeCollection) {\n            if (InetAddressUtils.isInetAddressInRange(laddr, range.getBegin(), range.getEnd())) {\n    \t\t\trange.getForeignSource();\n            }\n\t\t}\n    \t\n    \tList<IncludeUrl> includeUrlCollection = getConfiguration().getIncludeUrlCollection();\n    \tfor (IncludeUrl includeUrl : includeUrlCollection) {\n    \t\tString ipAddr = includeUrl.getContent();\n\t\t\tif (ipAddr.equals(InetAddressUtils.str(address))) {\n\t\t\t\treturn includeUrl.getForeignSource();\n\t\t\t}\n\t\t}\n    \t\n    \treturn getConfiguration().getForeignSource();\n    }","id":76693,"modified_method":"public String getForeignSource(InetAddress address) {\n    \tgetReadLock().lock();\n    \t\n    \tLOG.debug(\"Looking for matching foreign source specific IP or IP range with address: {}...\", address);\n    \t\n    \tList<Specific> specificCollection = getConfiguration().getSpecificCollection();\n    \tfor (Specific specific : specificCollection) {\n\t\t\tString ipAddr = specific.getContent();\n\t    \t\n\t\t\tif (ipAddr.equals(InetAddressUtils.str(address))) {\n\t\t\t\t\n\t\t    \tString foreignSource = specific.getForeignSource();\n\t\t\t\tLOG.debug(\"Matched foreign source {} matching address: {} against specific {}.\", foreignSource, address, ipAddr);\n\t\t    \tgetReadLock().unlock();\n\t\t\t\treturn foreignSource;\n\t\t\t}\n\t\t}\n    \t\n        final byte[] laddr = address.getAddress();\n        \n    \tList<IncludeRange> includeRangeCollection = getConfiguration().getIncludeRangeCollection();\n    \tfor (IncludeRange range : includeRangeCollection) {\n    \t\t\n            if (InetAddressUtils.isInetAddressInRange(laddr, range.getBegin(), range.getEnd())) {\n            \t\n            \tString foreignSource = range.getForeignSource();\n\t\t\t\tLOG.debug(\"Found foreign source {} with address {} in the range begin: {} and end: {}.\", foreignSource, address, range.getBegin(), range.getEnd());\n\t\t    \tgetReadLock().unlock();\n    \t\t\treturn foreignSource;\n            }\n\t\t}\n    \t\n    \tList<IncludeUrl> includeUrlCollection = getConfiguration().getIncludeUrlCollection();\n    \tfor (IncludeUrl includeUrl : includeUrlCollection) {\n    \t\tString ipAddr = includeUrl.getContent();\n\t\t\tif (ipAddr.equals(InetAddressUtils.str(address))) {\n\t\t\t\t\n\t\t    \tString foreignSource = includeUrl.getForeignSource();\n\t\t\t\tLOG.debug(\"Matched foreign source {} matching address: {} in specified URL.\", foreignSource, address);\n\t\t    \tgetReadLock().unlock();\n\t\t\t\treturn foreignSource;\n\t\t\t}\n\t\t}\n    \t\n    \tString foreignSource = getConfiguration().getForeignSource();\n    \tgetReadLock().unlock();\n\t\treturn foreignSource;\n    }","commit_id":"b956936b41349e4bd854bb958279d87a678d96e5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        // if all are defaults, no sense to write it at all\n        if (fieldType.stored() == Defaults.FIELD_TYPE.stored() &&\n                fieldType.indexed() == Defaults.FIELD_TYPE.indexed() && path == Defaults.PATH) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n            builder.field(\"index\", fieldType.indexed());\n        }\n        if (path != Defaults.PATH) {\n            builder.field(\"path\", path);\n        }\n        builder.endObject();\n        return builder;\n    }","id":76694,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        // if all are defaults, no sense to write it at all\n        if (fieldType.stored() == Defaults.FIELD_TYPE.stored() &&\n                fieldType.indexed() == Defaults.FIELD_TYPE.indexed() && path == Defaults.PATH) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n            builder.field(\"index\", indexTokenizeOptionToString(fieldType.indexed(), fieldType.tokenized()));\n        }\n        if (path != Defaults.PATH) {\n            builder.field(\"path\", path);\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"2655c2aa58df53e055d59d383ccfa8241274741a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n\n        // all are defaults, don't write it at all\n        if (!includeDefaults && name().equals(Defaults.NAME) && nullValue == null &&\n                fieldType.indexed() == Defaults.FIELD_TYPE.indexed() &&\n                fieldType.stored() == Defaults.FIELD_TYPE.stored() &&\n                customFieldDataSettings == null) {\n            return builder;\n        }\n        builder.startObject(contentType());\n        if (includeDefaults || !name().equals(Defaults.NAME)) {\n            builder.field(\"name\", name());\n        }\n        if (includeDefaults || nullValue != null) {\n            builder.field(\"null_value\", nullValue);\n        }\n        if (includeDefaults || fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n            builder.field(\"index\", fieldType.indexed());\n        }\n        if (includeDefaults || fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (customFieldDataSettings != null) {\n            builder.field(\"fielddata\", (Map) customFieldDataSettings.getAsMap());\n        } else if (includeDefaults) {\n            builder.field(\"fielddata\", (Map) fieldDataType.getSettings().getAsMap());\n\n        }\n        builder.endObject();\n        return builder;\n    }","id":76695,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n\n        // all are defaults, don't write it at all\n        if (!includeDefaults && name().equals(Defaults.NAME) && nullValue == null &&\n                fieldType.indexed() == Defaults.FIELD_TYPE.indexed() &&\n                fieldType.stored() == Defaults.FIELD_TYPE.stored() &&\n                customFieldDataSettings == null) {\n            return builder;\n        }\n        builder.startObject(contentType());\n        if (includeDefaults || !name().equals(Defaults.NAME)) {\n            builder.field(\"name\", name());\n        }\n        if (includeDefaults || nullValue != null) {\n            builder.field(\"null_value\", nullValue);\n        }\n        if (includeDefaults || fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n            builder.field(\"index\", indexTokenizeOptionToString(fieldType.indexed(), fieldType.tokenized()));\n        }\n        if (includeDefaults || fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (customFieldDataSettings != null) {\n            builder.field(\"fielddata\", (Map) customFieldDataSettings.getAsMap());\n        } else if (includeDefaults) {\n            builder.field(\"fielddata\", (Map) fieldDataType.getSettings().getAsMap());\n\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"59ecfd67e89688467998b6e54139f0ff150efbe7","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSetValues() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_boost\")\n                .field(\"store\", \"yes\").field(\"index\", \"not_analyzed\")\n                .endObject()\n                .endObject().endObject().string();\n        DocumentMapper docMapper = createIndex(\"test\").mapperService().documentMapperParser().parse(mapping);\n        assertThat(docMapper.boostFieldMapper().fieldType().stored(), equalTo(true));\n        assertThat(docMapper.boostFieldMapper().fieldType().indexed(), equalTo(true));\n    }","id":76696,"modified_method":"@Test\n    public void testSetValues() throws Exception {\n        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"_boost\")\n                .field(\"store\", \"yes\").field(\"index\", \"not_analyzed\")\n                .endObject()\n                .endObject().endObject().string();\n        IndexService indexServices = createIndex(\"test\");\n        DocumentMapper docMapper = indexServices.mapperService().documentMapperParser().parse(\"type\", mapping);\n        assertThat(docMapper.boostFieldMapper().fieldType().stored(), equalTo(true));\n        assertThat(docMapper.boostFieldMapper().fieldType().indexed(), equalTo(true));\n        docMapper.refreshSource();\n        docMapper = indexServices.mapperService().documentMapperParser().parse(\"type\", docMapper.mappingSource().string());\n        assertThat(docMapper.boostFieldMapper().fieldType().stored(), equalTo(true));\n        assertThat(docMapper.boostFieldMapper().fieldType().indexed(), equalTo(true));\n    }","commit_id":"59ecfd67e89688467998b6e54139f0ff150efbe7","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        // if all are defaults, no sense to write it at all\n        if (fieldType.indexed() == Defaults.FIELD_TYPE.indexed() &&\n                fieldType.stored() == Defaults.FIELD_TYPE.stored() && required == Defaults.REQUIRED && path == Defaults.PATH) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n            builder.field(\"index\", fieldType.indexed());\n        }\n        if (fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (required != Defaults.REQUIRED) {\n            builder.field(\"required\", required);\n        }\n        if (path != Defaults.PATH) {\n            builder.field(\"path\", path);\n        }\n        builder.endObject();\n        return builder;\n    }","id":76697,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        // if all are defaults, no sense to write it at all\n        if (fieldType.indexed() == Defaults.FIELD_TYPE.indexed() &&\n                fieldType.stored() == Defaults.FIELD_TYPE.stored() && required == Defaults.REQUIRED && path == Defaults.PATH) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n            builder.field(\"index\", indexTokenizeOptionToString(fieldType.indexed(), fieldType.tokenized()));\n        }\n        if (fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (required != Defaults.REQUIRED) {\n            builder.field(\"required\", required);\n        }\n        if (path != Defaults.PATH) {\n            builder.field(\"path\", path);\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"28b9e250536f8a554abb26b49d6a80a0d4fb4f03","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        // if all are defaults, no sense to write it at all\n        if (fieldType.indexed() == Defaults.FIELD_TYPE.indexed() &&\n                fieldType.stored() == Defaults.FIELD_TYPE.stored() && enabledState == Defaults.ENABLED && path == Defaults.PATH\n                && dateTimeFormatter.format().equals(Defaults.DATE_TIME_FORMATTER.format())) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (enabledState != Defaults.ENABLED) {\n            builder.field(\"enabled\", enabledState.enabled);\n        }\n        if (enabledState.enabled) {\n            if (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n                builder.field(\"index\", fieldType.indexed());\n            }\n            if (fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n                builder.field(\"store\", fieldType.stored());\n            }\n            if (path != Defaults.PATH) {\n                builder.field(\"path\", path);\n            }\n            if (!dateTimeFormatter.format().equals(Defaults.DATE_TIME_FORMATTER.format())) {\n                builder.field(\"format\", dateTimeFormatter.format());\n            }\n        }\n        builder.endObject();\n        return builder;\n    }","id":76698,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        // if all are defaults, no sense to write it at all\n        if (fieldType.indexed() == Defaults.FIELD_TYPE.indexed() &&\n                fieldType.stored() == Defaults.FIELD_TYPE.stored() && enabledState == Defaults.ENABLED && path == Defaults.PATH\n                && dateTimeFormatter.format().equals(Defaults.DATE_TIME_FORMATTER.format())) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (enabledState != Defaults.ENABLED) {\n            builder.field(\"enabled\", enabledState.enabled);\n        }\n        if (enabledState.enabled) {\n            if (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n                builder.field(\"index\", indexTokenizeOptionToString(fieldType.indexed(), fieldType.tokenized()));\n            }\n            if (fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n                builder.field(\"store\", fieldType.stored());\n            }\n            if (path != Defaults.PATH) {\n                builder.field(\"path\", path);\n            }\n            if (!dateTimeFormatter.format().equals(Defaults.DATE_TIME_FORMATTER.format())) {\n                builder.field(\"format\", dateTimeFormatter.format());\n            }\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"28b9e250536f8a554abb26b49d6a80a0d4fb4f03","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        // if all are defaults, no sense to write it at all\n        if (fieldType.stored() == Defaults.FIELD_TYPE.stored() && fieldType.indexed() == Defaults.FIELD_TYPE.indexed()) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n            builder.field(\"index\", fieldType.indexed());\n        }\n        builder.endObject();\n        return builder;\n    }","id":76699,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        // if all are defaults, no sense to write it at all\n        if (fieldType.stored() == Defaults.FIELD_TYPE.stored() && fieldType.indexed() == Defaults.FIELD_TYPE.indexed()) {\n            return builder;\n        }\n        builder.startObject(CONTENT_TYPE);\n        if (fieldType.stored() != Defaults.FIELD_TYPE.stored()) {\n            builder.field(\"store\", fieldType.stored());\n        }\n        if (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) {\n            builder.field(\"index\", indexTokenizeOptionToString(fieldType.indexed(), fieldType.tokenized()));\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"1e937fd5d1ee6265782c311593a8711b0e537003","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private Map getAttributesAsMap(HttpServletRequest request) {\n        Map attrMap = FastMap.newInstance();\n        Enumeration en = request.getAttributeNames();\n        while (en.hasMoreElements()) {\n            String name = (String) en.nextElement();\n            Object val = request.getAttribute(name);\n            if (val instanceof String || val instanceof Number || val instanceof Map || val instanceof List) {\n                Debug.log(\"Adding attribute to JSON output: \" + name, module);\n                attrMap.put(name, val);\n            }\n        }\n\n        return attrMap;\n    }","id":76700,"modified_method":"private Map getAttributesAsMap(HttpServletRequest request) {\n        Map attrMap = FastMap.newInstance();\n        Enumeration en = request.getAttributeNames();\n        while (en.hasMoreElements()) {\n            String name = (String) en.nextElement();\n            Object val = request.getAttribute(name);\n            if (val instanceof String || val instanceof Number || val instanceof Map || val instanceof List) {\n                if (Debug.verboseOn()) Debug.logVerbose(\"Adding attribute to JSON output: \" + name, module);\n                attrMap.put(name, val);\n            }\n        }\n\n        return attrMap;\n    }","commit_id":"8d28c89ef0577f78c1cb53f1fe577a99df1c62d0","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * @see javax.transaction.xa.XAResource#commit(javax.transaction.xa.Xid xid, boolean onePhase)\n     */\n    public void commit(Xid xid, boolean onePhase) throws XAException {\n        Debug.log(\"ServiceXaWrapper#commit() : \" + onePhase + \" / \" + xid.toString(), module);\n        // the commit listener\n        if (this.active) {\n            Debug.logWarning(\"commit() called without end()\", module);\n        }\n        if (this.xid == null || !this.xid.equals(xid)) {\n            throw new XAException(XAException.XAER_NOTA);\n        }\n\n        final String service = commitService;\n        final Map context = commitContext;\n        final boolean persist = commitAsyncPersist;\n        final boolean async = commitAsync;\n\n        Thread thread = new Thread() {\n            public void run() {\n                try {\n                    runService(service, context, persist, (async ? MODE_ASYNC : MODE_SYNC), TYPE_COMMIT);\n                } catch (XAException e) {\n                    Debug.logError(e, module);\n                }\n            }\n        };\n        thread.start();\n\n        this.xid = null;\n        this.active = false;\n    }","id":76701,"modified_method":"/**\n     * @see javax.transaction.xa.XAResource#commit(javax.transaction.xa.Xid xid, boolean onePhase)\n     */\n    public void commit(Xid xid, boolean onePhase) throws XAException {\n        if (Debug.verboseOn()) Debug.logVerbose(\"ServiceXaWrapper#commit() : \" + onePhase + \" / \" + xid.toString(), module);\n        // the commit listener\n        if (this.active) {\n            Debug.logWarning(\"commit() called without end()\", module);\n        }\n        if (this.xid == null || !this.xid.equals(xid)) {\n            throw new XAException(XAException.XAER_NOTA);\n        }\n\n        final String service = commitService;\n        final Map context = commitContext;\n        final boolean persist = commitAsyncPersist;\n        final boolean async = commitAsync;\n\n        Thread thread = new Thread() {\n            public void run() {\n                try {\n                    runService(service, context, persist, (async ? MODE_ASYNC : MODE_SYNC), TYPE_COMMIT);\n                } catch (XAException e) {\n                    Debug.logError(e, module);\n                }\n            }\n        };\n        thread.start();\n\n        this.xid = null;\n        this.active = false;\n    }","commit_id":"8d28c89ef0577f78c1cb53f1fe577a99df1c62d0","url":"https://github.com/apache/ofbiz"},{"original_method":"public int prepare(Xid xid) throws XAException {\n        // overriding to log two phase commits\n        Debug.log(\"ServiceXaWrapper#prepare() : \" + xid.toString(), module);\n        int rtn;\n        try {\n            rtn = super.prepare(xid);\n        } catch (XAException e) {\n            Debug.logError(e, module);\n            throw e;\n        }\n        Debug.log(\"ServiceXaWrapper#prepare() : \" + rtn + \" / \" + (rtn == XA_OK) , module);\n        return rtn;\n    }","id":76702,"modified_method":"public int prepare(Xid xid) throws XAException {\n        // overriding to log two phase commits\n        if (Debug.verboseOn()) Debug.logVerbose(\"ServiceXaWrapper#prepare() : \" + xid.toString(), module);\n        int rtn;\n        try {\n            rtn = super.prepare(xid);\n        } catch (XAException e) {\n            Debug.logError(e, module);\n            throw e;\n        }\n        if (Debug.verboseOn()) Debug.logVerbose(\"ServiceXaWrapper#prepare() : \" + rtn + \" / \" + (rtn == XA_OK) , module);\n        return rtn;\n    }","commit_id":"8d28c89ef0577f78c1cb53f1fe577a99df1c62d0","url":"https://github.com/apache/ofbiz"},{"original_method":"protected final void runService(String service, Map context, boolean persist, int mode, int type) throws XAException {\n        // set the logging prefix\n        String msgPrefix = \"[XaWrapper] \";\n        switch (type) {\n            case TYPE_ROLLBACK:\n                msgPrefix = \"[Rollback] \";\n                break;\n            case TYPE_COMMIT:\n                msgPrefix = \"[Commit] \";\n                break;\n        }\n\n        // if a service exists; run it\n        if (UtilValidate.isNotEmpty(service)) {\n\n            // suspend this transaction\n            Transaction parentTx = null;\n            boolean beganTx;\n\n            try {\n                int currentTxStatus = Status.STATUS_UNKNOWN;\n                try {\n                    currentTxStatus = TransactionUtil.getStatus();\n                } catch (GenericTransactionException e) {\n                    Debug.logWarning(e, module);\n                }\n\n                // suspend the parent tx\n                if (currentTxStatus != Status.STATUS_NO_TRANSACTION) {\n                    parentTx = TransactionUtil.suspend();\n                }\n\n                // begin the new tx\n                beganTx = TransactionUtil.begin();\n\n                // configure and run the service\n                try {\n                    // obtain the model and get the valid context\n                    ModelService model = dctx.getModelService(service);\n                    Map thisContext = context;\n                    if (model.validate) {\n                        thisContext = model.makeValid(context, ModelService.IN_PARAM);\n                    }\n\n                    // set the userLogin object\n                    thisContext.put(\"userLogin\", ServiceUtil.getUserLogin(dctx, thisContext, runAsUser));\n\n                    // invoke based on mode\n                    switch (mode) {\n                        case MODE_ASYNC:\n                            Debug.log(msgPrefix + \"Invoking [\" + service + \"] via runAsync\", module);\n                            dctx.getDispatcher().runAsync(service, thisContext, persist);\n                            break;\n\n                        case MODE_SYNC:\n                            Debug.log(msgPrefix + \"Invoking [\" + service + \"] via runSyncIgnore\", module);\n                            dctx.getDispatcher().runSyncIgnore(service, thisContext);\n                            break;\n                    }\n                } catch (Throwable t) {\n                    Debug.logError(t, \"Problem calling \" + msgPrefix + \"service : \" + service + \" / \" + context, module);\n                    try {\n                        TransactionUtil.rollback(beganTx, t.getMessage(), t);\n                    } catch (GenericTransactionException e) {\n                        Debug.logError(e, module);\n                    }\n\n                    // async calls are assumed to not effect this TX\n                    if (mode != MODE_ASYNC) {\n                        throw new XAException(XAException.XA_RBOTHER);\n                    }\n                } finally {\n                    // commit the transaction\n                    try {\n                        TransactionUtil.commit(beganTx);\n                    } catch (GenericTransactionException e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            } catch (GenericTransactionException e) {\n                Debug.logError(e, module);\n            } finally {\n                // resume the transaction\n                if (parentTx != null) {\n                    try {\n                        TransactionUtil.resume(parentTx);\n                    } catch (Exception e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            }\n        } else {\n            Debug.log(\"No \" + msgPrefix + \"service defined; nothing to do\", module);\n        }\n\n        this.xid = null;\n        this.active = false;\n    }","id":76703,"modified_method":"protected final void runService(String service, Map context, boolean persist, int mode, int type) throws XAException {\n        // set the logging prefix\n        String msgPrefix = \"[XaWrapper] \";\n        switch (type) {\n            case TYPE_ROLLBACK:\n                msgPrefix = \"[Rollback] \";\n                break;\n            case TYPE_COMMIT:\n                msgPrefix = \"[Commit] \";\n                break;\n        }\n\n        // if a service exists; run it\n        if (UtilValidate.isNotEmpty(service)) {\n\n            // suspend this transaction\n            Transaction parentTx = null;\n            boolean beganTx;\n\n            try {\n                int currentTxStatus = Status.STATUS_UNKNOWN;\n                try {\n                    currentTxStatus = TransactionUtil.getStatus();\n                } catch (GenericTransactionException e) {\n                    Debug.logWarning(e, module);\n                }\n\n                // suspend the parent tx\n                if (currentTxStatus != Status.STATUS_NO_TRANSACTION) {\n                    parentTx = TransactionUtil.suspend();\n                }\n\n                // begin the new tx\n                beganTx = TransactionUtil.begin();\n\n                // configure and run the service\n                try {\n                    // obtain the model and get the valid context\n                    ModelService model = dctx.getModelService(service);\n                    Map thisContext = context;\n                    if (model.validate) {\n                        thisContext = model.makeValid(context, ModelService.IN_PARAM);\n                    }\n\n                    // set the userLogin object\n                    thisContext.put(\"userLogin\", ServiceUtil.getUserLogin(dctx, thisContext, runAsUser));\n\n                    // invoke based on mode\n                    switch (mode) {\n                        case MODE_ASYNC:\n                            if (Debug.infoOn()) Debug.logInfo(msgPrefix + \"Invoking [\" + service + \"] via runAsync\", module);\n                            dctx.getDispatcher().runAsync(service, thisContext, persist);\n                            break;\n\n                        case MODE_SYNC:\n                            if (Debug.infoOn()) Debug.logInfo(msgPrefix + \"Invoking [\" + service + \"] via runSyncIgnore\", module);\n                            dctx.getDispatcher().runSyncIgnore(service, thisContext);\n                            break;\n                    }\n                } catch (Throwable t) {\n                    Debug.logError(t, \"Problem calling \" + msgPrefix + \"service : \" + service + \" / \" + context, module);\n                    try {\n                        TransactionUtil.rollback(beganTx, t.getMessage(), t);\n                    } catch (GenericTransactionException e) {\n                        Debug.logError(e, module);\n                    }\n\n                    // async calls are assumed to not effect this TX\n                    if (mode != MODE_ASYNC) {\n                        throw new XAException(XAException.XA_RBOTHER);\n                    }\n                } finally {\n                    // commit the transaction\n                    try {\n                        TransactionUtil.commit(beganTx);\n                    } catch (GenericTransactionException e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            } catch (GenericTransactionException e) {\n                Debug.logError(e, module);\n            } finally {\n                // resume the transaction\n                if (parentTx != null) {\n                    try {\n                        TransactionUtil.resume(parentTx);\n                    } catch (Exception e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            }\n        } else {\n            if (Debug.infoOn()) Debug.logInfo(\"No \" + msgPrefix + \"service defined; nothing to do\", module);\n        }\n\n        this.xid = null;\n        this.active = false;\n    }","commit_id":"8d28c89ef0577f78c1cb53f1fe577a99df1c62d0","url":"https://github.com/apache/ofbiz"},{"original_method":"public void enlist() throws XAException {\n        super.enlist();\n        Debug.log(\"Enlisted in transaction : \" + this.toString(), module);\n    }","id":76704,"modified_method":"public void enlist() throws XAException {\n        super.enlist();\n        if (Debug.verboseOn()) Debug.logVerbose(\"Enlisted in transaction : \" + this.toString(), module);\n    }","commit_id":"8d28c89ef0577f78c1cb53f1fe577a99df1c62d0","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * @see javax.transaction.xa.XAResource#rollback(javax.transaction.xa.Xid xid)\n     */\n    public void rollback(Xid xid) throws XAException {\n        Debug.log(\"ServiceXaWrapper#rollback() : \" + xid.toString(), module);\n        // the rollback listener\n        if (this.active) {\n            Debug.logWarning(\"rollback() called without end()\", module);\n        }\n        if (this.xid == null || !this.xid.equals(xid)) {\n            throw new XAException(XAException.XAER_NOTA);\n        }\n\n        final String service = rollbackService;\n        final Map context = rollbackContext;\n        final boolean persist = rollbackAsyncPersist;\n        final boolean async = rollbackAsync;\n\n        Thread thread = new Thread() {\n            public void run() {\n                try {\n                    runService(service, context, persist, (async ? MODE_ASYNC : MODE_SYNC), TYPE_ROLLBACK);\n                } catch (XAException e) {\n                    Debug.logError(e, module);\n                }\n            }\n        };\n        thread.start();\n\n        this.xid = null;\n        this.active = false;\n    }","id":76705,"modified_method":"/**\n     * @see javax.transaction.xa.XAResource#rollback(javax.transaction.xa.Xid xid)\n     */\n    public void rollback(Xid xid) throws XAException {\n        if (Debug.verboseOn()) Debug.logVerbose(\"ServiceXaWrapper#rollback() : \" + xid.toString(), module);\n        // the rollback listener\n        if (this.active) {\n            Debug.logWarning(\"rollback() called without end()\", module);\n        }\n        if (this.xid == null || !this.xid.equals(xid)) {\n            throw new XAException(XAException.XAER_NOTA);\n        }\n\n        final String service = rollbackService;\n        final Map context = rollbackContext;\n        final boolean persist = rollbackAsyncPersist;\n        final boolean async = rollbackAsync;\n\n        Thread thread = new Thread() {\n            public void run() {\n                try {\n                    runService(service, context, persist, (async ? MODE_ASYNC : MODE_SYNC), TYPE_ROLLBACK);\n                } catch (XAException e) {\n                    Debug.logError(e, module);\n                }\n            }\n        };\n        thread.start();\n\n        this.xid = null;\n        this.active = false;\n    }","commit_id":"8d28c89ef0577f78c1cb53f1fe577a99df1c62d0","url":"https://github.com/apache/ofbiz"},{"original_method":"public boolean submitPortalData(PortalRegistrationData portalRegistrationData) {\n        final HttpClient client = new HttpClient();\n        final HttpClientParams httpClientParams = client.getParams();\n        httpClientParams.setSoTimeout(5000);\n        \n        String postUrl = this.submitUrl;\n        for (int redirectCounter = 0; redirectCounter < 10; redirectCounter++) {\n            final PostMethod post = new PostMethod(postUrl);\n            \n            //Add static parameters\n            final String deployerAddress = portalRegistrationData.getDeployerAddress();\n            if (deployerAddress != null) {\n                post.addParameter(\"deployerAddress\", deployerAddress);\n            }\n            \n            final String deployerName = portalRegistrationData.getDeployerName();\n            if (deployerName != null) {\n                post.addParameter(\"deployerName\", deployerName);\n            }\n            \n            final String institutionName = portalRegistrationData.getInstitutionName();\n            if (institutionName != null) {\n                post.addParameter(\"institutionName\", institutionName);\n            }\n            \n            final String portalName = portalRegistrationData.getPortalName();\n            if (portalName != null) {\n                post.addParameter(\"portalName\", portalName);\n            }\n            \n            final String portalUrl = portalRegistrationData.getPortalUrl();\n            if (portalUrl != null) {\n                post.addParameter(\"portalUrl\", portalUrl);\n            }\n            \n            post.addParameter(\"shareInfo\", Boolean.toString(portalRegistrationData.isShareInfo()));\n            \n            //Add gathered data\n            final Map<String, Map<String, String>> collectedData = portalRegistrationData.getCollectedData();\n            for (final Map.Entry<String, Map<String, String>> collectedDataEntry : collectedData.entrySet()) {\n                final String dataKey = collectedDataEntry.getKey();\n                \n                for (final Map.Entry<String, String> dataValueEntry : collectedDataEntry.getValue().entrySet()) {\n                    final String valueKey = dataValueEntry.getKey();\n                    final String value = dataValueEntry.getValue();\n                    if (value != null) {\n                        post.addParameter(dataKey + \"_\" + valueKey, value);\n                    }\n                }\n            }\n            \n            Integer result = null;\n            try {\n                result = client.executeMethod(post);\n                \n                if (result == 200) {\n                    this.logger.info(\"Portal registration data successfully submitted to \" + this.submitUrl);\n                    return true;\n                }\n                else if (result >= 300 && result <= 399) {\n                    final Header newLocation = post.getResponseHeader(\"location\");\n                    postUrl = newLocation.getValue();\n                    this.logger.info(\"Handling redirect to \" + postUrl);\n                    continue;\n                }\n            }\n            catch (HttpException e) {\n                this.logger.warn(\"Portal registration data failed to submit due to a HTTP exception\", e);\n                return false;\n            }\n            catch (IOException e) {\n                this.logger.warn(\"Portal registration data failed to submit due to an IO exception\", e);\n                return false;\n            }\n            \n            this.logger.warn(\"Portal registration data failed to submit with return code \" + result);\n            return false;\n        }\n        \n        this.logger.warn(\"Portal registration data failed to submit due to too many redirects\");\n        return false;\n    }","id":76706,"modified_method":"public boolean submitPortalData(PortalRegistrationData portalRegistrationData) {\n        final HttpClient client = new HttpClient();\n        final HttpClientParams httpClientParams = client.getParams();\n        httpClientParams.setSoTimeout(5000);\n        \n        String postUrl = this.submitUrl;\n        for (int redirectCounter = 0; redirectCounter < 10; redirectCounter++) {\n            final PostMethod post = new PostMethod(postUrl);\n            try {\n                this.addParameters(portalRegistrationData, post);\n                \n                Integer result = null;\n                try {\n                    result = client.executeMethod(post);\n                    \n                    if (result == 200) {\n                        this.logger.info(\"Portal registration data successfully submitted to \" + this.submitUrl);\n                        return true;\n                    }\n                    else if (result >= 300 && result <= 399) {\n                        final Header newLocation = post.getResponseHeader(\"location\");\n                        postUrl = newLocation.getValue();\n                        this.logger.info(\"Handling redirect to \" + postUrl);\n                        continue;\n                    }\n                }\n                catch (HttpException e) {\n                    this.logger.warn(\"Portal registration data failed to submit due to a HTTP exception\", e);\n                    return false;\n                }\n                catch (IOException e) {\n                    this.logger.warn(\"Portal registration data failed to submit due to an IO exception\", e);\n                    return false;\n                }\n                \n                this.logger.warn(\"Portal registration data failed to submit with return code \" + result);\n                return false;\n            }\n            finally {\n                post.releaseConnection();\n            }\n        }\n        \n        this.logger.warn(\"Portal registration data failed to submit due to too many redirects\");\n        return false;\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n        .append(\"dataToSubmit\", this.collectedData)\n        .append(\"deployerAddress\", this.deployerAddress)\n        .append(\"portalName\", this.portalName)\n        .append(\"deployerName\", this.deployerName)\n        .append(\"institutionName\", this.institutionName)\n        .append(\"portalUrl\", this.portalUrl)\n        .append(\"shareInfo\", this.shareInfo)\n        .toString();\n    }","id":76707,"modified_method":"/**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n            .appendSuper(super.toString())\n            .append(\"collectedData\", this.collectedData)\n            .toString();\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#equals(Object)\n     */\n    @Override\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof PortalRegistrationData)) {\n            return false;\n        }\n        PortalRegistrationData rhs = (PortalRegistrationData) object;\n        return new EqualsBuilder()\n            .append(this.collectedData, rhs.collectedData)\n            .append(this.deployerAddress, rhs.deployerAddress)\n            .append(this.portalName, rhs.portalName)\n            .append(this.deployerName, rhs.deployerName)\n            .append(this.institutionName, rhs.institutionName)\n            .append(this.portalUrl, rhs.portalUrl)\n            .append(this.shareInfo, rhs.shareInfo)\n            .isEquals();\n    }","id":76708,"modified_method":"/**\n     * @see java.lang.Object#equals(Object)\n     */\n    @Override\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof PortalRegistrationData)) {\n            return false;\n        }\n        PortalRegistrationData rhs = (PortalRegistrationData) object;\n        return new EqualsBuilder()\n            .appendSuper(super.equals(object))\n            .append(this.collectedData, rhs.collectedData)\n            .isEquals();\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @return the collectedData\n     */\n    public Map<String, Map<String, String>> getCollectedData() {\n        return this.collectedData;\n    }","id":76709,"modified_method":"/**\n     * @return the collectedData\n     */\n    public Map<String, Map<String, String>> getCollectedData() {\n        return collectedData;\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(554822571, 313513477)\n        .append(this.collectedData)\n        .append(this.deployerAddress)\n        .append(this.portalName)\n        .append(this.deployerName)\n        .append(this.institutionName)\n        .append(this.portalUrl)\n        .append(this.shareInfo)\n        .toHashCode();\n    }","id":76710,"modified_method":"/**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(229556677, 2120134195)\n            .appendSuper(super.hashCode())\n            .append(this.collectedData)\n            .toHashCode();\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Gathers portal data for the registration request\n     * \n     * @param registrationRequest Registration request containing the user's preferences\n     * @return Registration data collected based on the registration request \n     */\n    public PortalRegistrationData getRegistrationData(PortalRegistrationRequest registrationRequest) {\n        this.logger.debug(registrationRequest);\n        \n        final PortalRegistrationData registrationData = new PortalRegistrationData();\n        registrationData.setDeployerAddress(registrationRequest.getDeployerAddress());\n        registrationData.setDeployerName(registrationRequest.getDeployerName());\n        registrationData.setInstitutionName(registrationRequest.getInstitutionName());\n        registrationData.setPortalName(registrationRequest.getPortalName());\n        registrationData.setPortalUrl(registrationRequest.getPortalUrl());\n        registrationData.setShareInfo(registrationRequest.isShareInfo());\n        \n        final Set<String> dataToCollect = new LinkedHashSet<String>();\n        final Map<String, String> dataToSubmit = registrationRequest.getDataToSubmit();\n        for (final Map.Entry<String, String> dataToSubmitEntry : dataToSubmit.entrySet()) {\n            if (Boolean.parseBoolean(dataToSubmitEntry.getValue())) {\n                dataToCollect.add(dataToSubmitEntry.getKey());\n            }\n        }\n        \n        final Map<String, Map<String, String>> collectedData = this.portalDataCollator.getCollectedData(dataToCollect);\n        registrationData.setCollectedData(collectedData);\n        \n        return registrationData;\n    }","id":76711,"modified_method":"/**\n     * Gathers portal data for the registration request\n     * \n     * @param registrationRequest Registration request containing the user's preferences\n     * @return Registration data collected based on the registration request \n     */\n    public PortalRegistrationData getRegistrationData(PortalRegistrationRequest registrationRequest) {\n        this.logger.debug(registrationRequest);\n        \n        final PortalRegistrationData registrationData = new PortalRegistrationData(registrationRequest);\n        \n        final Set<String> dataToCollect = new LinkedHashSet<String>();\n        final Map<String, String> dataToSubmit = registrationRequest.getDataToSubmit();\n        for (final Map.Entry<String, String> dataToSubmitEntry : dataToSubmit.entrySet()) {\n            if (Boolean.parseBoolean(dataToSubmitEntry.getValue())) {\n                dataToCollect.add(dataToSubmitEntry.getKey());\n            }\n        }\n        \n        final Map<String, Map<String, String>> collectedData = this.portalDataCollator.getCollectedData(dataToCollect);\n        registrationData.setCollectedData(collectedData);\n        \n        return registrationData;\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#equals(Object)\n     */\n    @Override\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof PortalRegistrationRequest)) {\n            return false;\n        }\n        PortalRegistrationRequest rhs = (PortalRegistrationRequest) object;\n        return new EqualsBuilder()\n            .append(this.dataToSubmit, rhs.dataToSubmit)\n            .append(this.deployerAddress, rhs.deployerAddress)\n            .append(this.portalName, rhs.portalName)\n            .append(this.deployerName, rhs.deployerName)\n            .append(this.institutionName, rhs.institutionName)\n            .append(this.portalUrl, rhs.portalUrl)\n            .append(this.shareInfo, rhs.shareInfo)\n            .isEquals();\n    }","id":76712,"modified_method":"/**\n     * @see java.lang.Object#equals(Object)\n     */\n    @Override\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof PortalRegistrationRequest)) {\n            return false;\n        }\n        PortalRegistrationRequest rhs = (PortalRegistrationRequest) object;\n        return new EqualsBuilder()\n            .append(this.dataToSubmit, rhs.dataToSubmit)\n            .append(this.deployerAddress, rhs.deployerAddress)\n            .append(this.portalName, rhs.portalName)\n            .append(this.deployerName, rhs.deployerName)\n            .append(this.institutionName, rhs.institutionName)\n            .append(this.portalUrl, rhs.portalUrl)\n            .append(this.shareInfo, rhs.shareInfo)\n            .append(this.demoUrl, rhs.demoUrl)\n            .append(this.numberOfUsers, rhs.numberOfUsers)\n            .append(this.audience, rhs.audience)\n            .append(this.authnSystem, rhs.authnSystem)\n            .append(this.notes, rhs.notes)\n            .isEquals();\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n        .append(\"dataToSubmit\", this.dataToSubmit)\n        .append(\"deployerAddress\", this.deployerAddress)\n        .append(\"portalName\", this.portalName)\n        .append(\"deployerName\", this.deployerName)\n        .append(\"institutionName\", this.institutionName)\n        .append(\"portalUrl\", this.portalUrl)\n        .append(\"shareInfo\", this.shareInfo)\n        .toString();\n    }","id":76713,"modified_method":"/**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n        .append(\"dataToSubmit\", this.dataToSubmit)\n        .append(\"deployerAddress\", this.deployerAddress)\n        .append(\"portalName\", this.portalName)\n        .append(\"deployerName\", this.deployerName)\n        .append(\"institutionName\", this.institutionName)\n        .append(\"portalUrl\", this.portalUrl)\n        .append(\"shareInfo\", this.shareInfo)\n        .append(\"demoUrl\", this.demoUrl)\n        .append(\"numberOfUsers\", this.numberOfUsers)\n        .append(\"audience\", this.audience)\n        .append(\"authnSystem\", this.authnSystem)\n        .append(\"notes\", this.notes)\n        .toString();\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(554822571, 313513477)\n        .append(this.dataToSubmit)\n        .append(this.deployerAddress)\n        .append(this.portalName)\n        .append(this.deployerName)\n        .append(this.institutionName)\n        .append(this.portalUrl)\n        .append(this.shareInfo)\n        .toHashCode();\n    }","id":76714,"modified_method":"/**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(554822571, 313513477)\n        .append(this.dataToSubmit)\n        .append(this.deployerAddress)\n        .append(this.portalName)\n        .append(this.deployerName)\n        .append(this.institutionName)\n        .append(this.portalUrl)\n        .append(this.shareInfo)\n        .append(this.demoUrl)\n        .append(this.numberOfUsers)\n        .append(this.audience)\n        .append(this.authnSystem)\n        .append(this.notes)\n        .toHashCode();\n    }","commit_id":"050f3394659a4f0df40dab42b8ca03aad37c1d82","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Returns a baseActionURL - parameters of a request coming in on the baseActionURL\n     * will be placed into the ChannelRuntimeData object for channel's use.\n     *\n     * @param idempotent a <code>boolean<\/code> value specifying if a given URL should be idepotent.\n     * @return a value of URL to which parameter sequences should be appended.\n     */\n    public String getBaseActionURL(boolean idempotent) {\n        // If the base action URL was explicitly set, use it\n        // peterk: we should probably introduce idepotent version of this one as well, at some point\n        if (baseActionURL != null) {\n          return baseActionURL;\n        }\n\n        String url=null;\n        try {\n            if(idempotent) {\n                UPFileSpec upfs=new UPFileSpec(channelUPFile);\n                upfs.setTagId(PortalSessionManager.IDEMPOTENT_URL_TAG);\n                url=upfs.getUPFile();\n            } else {\n                url=channelUPFile.getUPFile();\n            }\n        } catch (Exception e) {\n            log.error(\"ChannelRuntimeData::getBaseActionURL() : unable to construct a base action URL!\");\n        }\n        return url;\n    }","id":76715,"modified_method":"/**\n     * Returns a baseActionURL - parameters of a request coming in on the baseActionURL\n     * will be placed into the ChannelRuntimeData object for channel's use.\n     *\n     * @param idempotent a <code>boolean<\/code> value specifying if a given URL should be idepotent.\n     * @return a value of URL to which parameter sequences should be appended.\n     */\n    public String getBaseActionURL(boolean idempotent) {\n        // If the base action URL was explicitly set, use it\n        // peterk: we should probably introduce idepotent version of this one as well, at some point\n        if (baseActionURL != null) {\n          return baseActionURL;\n        }\n\n        String url=null;\n        try {\n            if(idempotent) {\n                UPFileSpec upfs=new UPFileSpec(channelUPFile);\n                upfs.setTagId(PortalSessionManager.IDEMPOTENT_URL_TAG);\n                url=upfs.getUPFile();\n            } else {\n                url=channelUPFile.getUPFile();\n            }\n        } catch (Exception e) {\n            log.error(\"Unable to construct a base action URL!\", e);\n        }\n        return url;\n    }","commit_id":"aa5134529dbb4771b22403dd97c2f9b7eb71281f","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#equals(Object)\n     */\n    @Override\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof PortletUrl)) {\n            return false;\n        }\n        PortletUrl rhs = (PortletUrl) object;\n        return new EqualsBuilder()\n            .append(this.secure, rhs.secure)\n            .append(this.requestType, rhs.requestType)\n            .append(this.windowState, rhs.windowState)\n            .append(this.parameters, rhs.parameters)\n            .append(this.portletMode, rhs.portletMode)\n            .isEquals();\n    }","id":76716,"modified_method":"/**\n     * @see java.lang.Object#equals(Object)\n     */\n    @Override\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof PortletUrl)) {\n            return false;\n        }\n        PortletUrl rhs = (PortletUrl) object;\n        if (new EqualsBuilder()\n            .append(this.secure, rhs.secure)\n            .append(this.requestType, rhs.requestType)\n            .append(this.windowState, rhs.windowState)\n            .append(this.portletMode, rhs.portletMode)\n            .isEquals()) {\n            \n            //Nasty logic for doing equality checking on the parameters Map that has String[] values\n            if (this.parameters == rhs.parameters || (this.parameters != null && this.parameters.equals(rhs.parameters))) {\n                return true;\n            }\n            else if ((this.parameters != rhs.parameters && (this.parameters == null || rhs.parameters == null)) || this.parameters.size() != rhs.parameters.size()) {\n                return false;\n            }\n            else {\n                for (final Map.Entry<String, String[]> paramEntry : this.parameters.entrySet()) {\n                    final String key = paramEntry.getKey();\n                    \n                    if (!Arrays.equals(paramEntry.getValue(), rhs.parameters.get(key))) {\n                        return false;\n                    }\n                }\n                \n                return true;\n            }\n        }\n        \n        return false;\n    }","commit_id":"aa5134529dbb4771b22403dd97c2f9b7eb71281f","url":"https://github.com/Jasig/uPortal"},{"original_method":"public String generatePortletUrl(HttpServletRequest request, IPortletWindow portletWindow, PortletUrl portletUrl) {\n        Validate.notNull(request, \"request can not be null\");\n        Validate.notNull(portletWindow, \"portletWindow can not be null\");\n        Validate.notNull(portletUrl, \"portletUrl can not be null\");\n        \n        //Get the channel runtime data from the request attributes, it should have been set there by the portlet adapter\n        final ChannelRuntimeData channelRuntimeData = (ChannelRuntimeData)request.getAttribute(IPortletAdaptor.ATTRIBUTE_RUNTIME_DATA);\n        if (channelRuntimeData == null) {\n            throw new IllegalStateException(\"No ChannelRuntimeData was found as a request attribute for key '\" + IPortletAdaptor.ATTRIBUTE_RUNTIME_DATA + \"' on request '\" + request + \"'\");\n        }\n\n        //Get the encoding to use for the URL\n        final String encoding = this.getEncoding(request);\n        \n        //Get the string version of the portlet ID (local variable to avoid needless toString() calls)\n        final String portletWindowIdString = portletWindow.getPortletWindowId().toString();\n        \n        // TODO Need to decide how to deal with 'secure' URL requests\n        // Determine the base path for the URL\n        // If the next state is EXCLUSIVE or there is no state change and the current state is EXCLUSIVE use the worker URL base\n        final String urlBase;\n        final WindowState windowState = portletUrl.getWindowState();\n        if (IPortletAdaptor.EXCLUSIVE.equals(windowState) || (windowState == null && IPortletAdaptor.EXCLUSIVE.equals(portletWindow.getWindowState()))) {\n            urlBase = channelRuntimeData.getBaseWorkerURL(UPFileSpec.FILE_DOWNLOAD_WORKER);\n\n            if (this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Using worker url base '\" + urlBase + \"'\");\n            }\n        }\n        else {\n            urlBase = channelRuntimeData.getBaseActionURL();\n            \n            if (this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Using default url base '\" + urlBase + \"'\");\n            }\n        }\n\n        final StringBuilder url = new StringBuilder(this.bufferLength);\n        url.append(urlBase);\n        \n        //Set the request type\n        final RequestType requestType = portletUrl.getRequestType();\n        final String requestTypeString = requestType != null ? requestType.toString() : RequestType.RENDER.toString();\n        this.encodeAndAppend(url.append(\"?\"), encoding, PARAM_REQUEST_TYPE + portletWindowIdString, requestTypeString);\n        \n        // If set add the window state\n        if (windowState != null) {\n            this.encodeAndAppend(url.append(\"&\"), encoding, PARAM_WINDOW_STATE + portletWindowIdString, windowState.toString());\n        }\n        \n        //If set add the portlet mode\n        final PortletMode portletMode = portletUrl.getPortletMode();\n        if (portletMode != null) {\n            this.encodeAndAppend(url.append(\"&\"), encoding, PARAM_PORTLET_MODE + portletWindowIdString, portletMode.toString());\n        }\n        \n        //Add the parameters to the URL\n        final Map<String, String[]> parameters = portletUrl.getParameters();\n        if (parameters != null) {\n            for (final Map.Entry<String, String[]> parameterEntry : parameters.entrySet()) {\n                final String name = parameterEntry.getKey();\n                final String[] values = parameterEntry.getValue();\n                \n                this.encodeAndAppend(url.append(\"&\"), encoding, PORTLET_PARAM_PREFIX + portletWindowIdString + SEPERATOR + name, values);\n            }\n        }\n        \n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Generated portlet URL '\" + url + \"' for IPortletWindow='\" + portletWindow + \"' and PortletUrl='\" + portletUrl + \"'. StringBuilder started with length \" + this.bufferLength + \" and ended with length '\" + url.capacity() + \"'.\");\n        }\n        \n        return url.toString();\n    }","id":76717,"modified_method":"public String generatePortletUrl(HttpServletRequest request, IPortletWindow portletWindow, PortletUrl portletUrl) {\n        Validate.notNull(request, \"request can not be null\");\n        Validate.notNull(portletWindow, \"portletWindow can not be null\");\n        Validate.notNull(portletUrl, \"portletUrl can not be null\");\n        \n        //Get the channel runtime data from the request attributes, it should have been set there by the portlet adapter\n        final ChannelRuntimeData channelRuntimeData = (ChannelRuntimeData)request.getAttribute(IPortletAdaptor.ATTRIBUTE_RUNTIME_DATA);\n        if (channelRuntimeData == null) {\n            throw new IllegalStateException(\"No ChannelRuntimeData was found as a request attribute for key '\" + IPortletAdaptor.ATTRIBUTE_RUNTIME_DATA + \"' on request '\" + request + \"'\");\n        }\n\n        //Get the encoding to use for the URL\n        final String encoding = this.getEncoding(request);\n        \n        //Get the string version of the portlet ID (local variable to avoid needless getStringId() calls)\n        final String portletWindowIdString = portletWindow.getPortletWindowId().getStringId();\n        \n        // TODO Need to decide how to deal with 'secure' URL requests\n        // Determine the base path for the URL\n        // If the next state is EXCLUSIVE or there is no state change and the current state is EXCLUSIVE use the worker URL base\n        final String urlBase;\n        final WindowState windowState = portletUrl.getWindowState();\n        if (IPortletAdaptor.EXCLUSIVE.equals(windowState) || (windowState == null && IPortletAdaptor.EXCLUSIVE.equals(portletWindow.getWindowState()))) {\n            urlBase = channelRuntimeData.getBaseWorkerURL(UPFileSpec.FILE_DOWNLOAD_WORKER);\n\n            if (this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Using worker url base '\" + urlBase + \"'\");\n            }\n        }\n        else {\n            urlBase = channelRuntimeData.getBaseActionURL();\n            \n            if (this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Using default url base '\" + urlBase + \"'\");\n            }\n        }\n\n        final StringBuilder url = new StringBuilder(this.bufferLength);\n        url.append(urlBase);\n        \n        //Set the request type\n        final RequestType requestType = portletUrl.getRequestType();\n        final String requestTypeString = requestType != null ? requestType.toString() : RequestType.RENDER.toString();\n        this.encodeAndAppend(url.append(\"?\"), encoding, PARAM_REQUEST_TYPE + portletWindowIdString, requestTypeString);\n        \n        // If set add the window state\n        if (windowState != null) {\n            this.encodeAndAppend(url.append(\"&\"), encoding, PARAM_WINDOW_STATE + portletWindowIdString, windowState.toString());\n        }\n        \n        //If set add the portlet mode\n        final PortletMode portletMode = portletUrl.getPortletMode();\n        if (portletMode != null) {\n            this.encodeAndAppend(url.append(\"&\"), encoding, PARAM_PORTLET_MODE + portletWindowIdString, portletMode.toString());\n        }\n        \n        //Add the parameters to the URL\n        final Map<String, String[]> parameters = portletUrl.getParameters();\n        if (parameters != null) {\n            for (final Map.Entry<String, String[]> parameterEntry : parameters.entrySet()) {\n                final String name = parameterEntry.getKey();\n                final String[] values = parameterEntry.getValue();\n                \n                this.encodeAndAppend(url.append(\"&\"), encoding, PORTLET_PARAM_PREFIX + portletWindowIdString + SEPERATOR + name, values);\n            }\n        }\n        \n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Generated portlet URL '\" + url + \"' for IPortletWindow='\" + portletWindow + \"' and PortletUrl='\" + portletUrl + \"'. StringBuilder started with length \" + this.bufferLength + \" and ended with length \" + url.capacity() + \".\");\n        }\n        \n        return url.toString();\n    }","commit_id":"aa5134529dbb4771b22403dd97c2f9b7eb71281f","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Encodes parameter name and value(s) on to the url using the specified encoding. The option to pass more than one\n     * value is provided to avoid encoding the same name multiple times.  \n     * \n     * @param url The URL StringBuilder to append the parameters to\n     * @param encoding The encoding to use.\n     * @param name The name of the parameter\n     * @param values The values for the parameter, a & will be appeneded between each name/value pair added when multiple values are passed.\n     */\n    protected void encodeAndAppend(StringBuilder url, String encoding, String name, String... values) {\n        try {\n            name = URLEncoder.encode(name, encoding);\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"Failed to encode portlet URL parameter name '\" + name + \"' for encoding '\" + encoding + \"'\");\n        }\n        \n        for (int index = 0; index < values.length; index++) {\n            String value = values[index];\n            \n            try {\n                value = URLEncoder.encode(value, encoding);\n            }\n            catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(\"Failed to encode portlet URL parameter value '\" + value + \"' for encoding '\" + encoding + \"'\");\n            }\n            \n            if (index > 0) {\n                url.append(\"&\");\n            }\n            \n            url.append(name).append(\"=\").append(value);\n        }\n    }","id":76718,"modified_method":"/**\n     * Encodes parameter name and value(s) on to the url using the specified encoding. The option to pass more than one\n     * value is provided to avoid encoding the same name multiple times.  \n     * \n     * @param url The URL StringBuilder to append the parameters to\n     * @param encoding The encoding to use.\n     * @param name The name of the parameter\n     * @param values The values for the parameter, a & will be appeneded between each name/value pair added when multiple values are passed.\n     */\n    protected void encodeAndAppend(StringBuilder url, String encoding, String name, String... values) {\n        try {\n            name = URLEncoder.encode(name, encoding);\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"Failed to encode portlet URL parameter name '\" + name + \"' for encoding '\" + encoding + \"'\");\n        }\n        \n        if (values.length == 0) {\n            url.append(name).append(\"=\");\n        }\n        else {\n            for (int index = 0; index < values.length; index++) {\n                String value = values[index];\n                \n                try {\n                    value = URLEncoder.encode(value, encoding);\n                }\n                catch (UnsupportedEncodingException e) {\n                    throw new RuntimeException(\"Failed to encode portlet URL parameter value '\" + value + \"' for encoding '\" + encoding + \"'\");\n                }\n                \n                if (index > 0) {\n                    url.append(\"&\");\n                }\n                \n                url.append(name).append(\"=\").append(value);\n            }\n        }\n    }","commit_id":"aa5134529dbb4771b22403dd97c2f9b7eb71281f","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected Tuple<String, String> parseParameterName(String parameterName) {\n        final int firstIndex = parameterName.indexOf(SEPERATOR);\n        if (firstIndex < 0) {\n            this.logger.warn(\"Portlet parameter name '\" + parameterName + \"' cannot be parsed. The index of the first seperator character '\" + SEPERATOR + \"' returned \" + firstIndex + \". The parameter will be ignored.\");\n            return null;\n        }\n        \n        final int secondIndex = parameterName.indexOf(SEPERATOR, firstIndex + SEPERATOR.length());\n        if (secondIndex < 0) {\n            this.logger.warn(\"Portlet parameter name '\" + parameterName + \"' cannot be parsed. The index of the second seperator character '\" + SEPERATOR + \"' returned \" + secondIndex + \". The parameter will be ignored.\");\n            return null;\n        }\n        \n        final String firstPart = parameterName.substring(firstIndex + SEPERATOR.length(), secondIndex);\n        final String secondPart = parameterName.substring(secondIndex + SEPERATOR.length());\n\n        return new Tuple<String, String>(firstPart, secondPart);\n    }","id":76719,"modified_method":"/**\n     * Parses a parameter name into a Tuple that contains the second and third parts. The parsing\n     * is done based on the {@link #SEPERATOR} string.\n     * \n     * @param parameterName Name of parameter to parse\n     * @return A Tuple with the second/third parse of the parameter name, null if the parameter name can not be parsed.\n     */\n    protected Tuple<String, String> parseParameterName(String parameterName) {\n        final int firstIndex = parameterName.indexOf(SEPERATOR);\n        if (firstIndex < 0) {\n            this.logger.warn(\"Portlet parameter name '\" + parameterName + \"' cannot be parsed. The index of the first seperator character '\" + SEPERATOR + \"' returned \" + firstIndex + \". The parameter will be ignored.\");\n            return null;\n        }\n        \n        final int secondIndex = parameterName.indexOf(SEPERATOR, firstIndex + SEPERATOR.length());\n        if (secondIndex < 0) {\n            this.logger.warn(\"Portlet parameter name '\" + parameterName + \"' cannot be parsed. The index of the second seperator character '\" + SEPERATOR + \"' returned \" + secondIndex + \". The parameter will be ignored.\");\n            return null;\n        }\n        \n        final String firstPart = parameterName.substring(firstIndex + SEPERATOR.length(), secondIndex);\n        final String secondPart = parameterName.substring(secondIndex + SEPERATOR.length());\n\n        return new Tuple<String, String>(firstPart, secondPart);\n    }","commit_id":"aa5134529dbb4771b22403dd97c2f9b7eb71281f","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected PortletUrl getPortletUrl(IPortletWindowId portletWindowId, Map<IPortletWindowId, PortletUrl> parsedUrls) {\n        PortletUrl portletUrl = parsedUrls.get(portletWindowId);\n        \n        if (portletUrl == null) {\n            portletUrl = new PortletUrl();\n            parsedUrls.put(portletWindowId, portletUrl);\n        }\n        \n        return portletUrl;\n    }","id":76720,"modified_method":"/**\n     * Gets/Creates PortletUrl to parse parameters into from the parsedUrls Map\n     * \n     * @param portletWindowId ID to get ParsedUrl for\n     * @param parsedUrls Map of existing ParsedUrl objects\n     * @return The PortletUrl to parse parameters into for the IPortletWindowId\n     */\n    protected PortletUrl getPortletUrl(IPortletWindowId portletWindowId, Map<IPortletWindowId, PortletUrl> parsedUrls) {\n        PortletUrl portletUrl = parsedUrls.get(portletWindowId);\n        \n        if (portletUrl == null) {\n            portletUrl = new PortletUrl();\n            parsedUrls.put(portletWindowId, portletUrl);\n        }\n        \n        return portletUrl;\n    }","commit_id":"aa5134529dbb4771b22403dd97c2f9b7eb71281f","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n            .append(\"id\", this.portletWindowId)\n            .toString();\n    }","id":76721,"modified_method":"/**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return this.getStringId();\n    }","commit_id":"aa5134529dbb4771b22403dd97c2f9b7eb71281f","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n        protected int doHash(Method method) {\n            return new HashCodeBuilder()\n                    .append(method.getName())\n                    .append(method.getGenericReturnType())\n                    .append(method.getGenericParameterTypes())\n                    .toHashCode();\n        }","id":76722,"modified_method":"@Override\n        protected int doHash(Method method) {\n            return new HashCodeBuilder()\n                    .append(method.getName())\n                    .append(method.getGenericParameterTypes())\n                    .toHashCode();\n        }","commit_id":"25a06f134b14fd84d52a20fff32998561787065b","url":"https://github.com/gradle/gradle"},{"original_method":"public <R> ModelSchemaExtractionResult<R> extract(final ModelSchemaExtractionContext<R> extractionContext, final ModelSchemaCache cache) {\n        ModelType<R> type = extractionContext.getType();\n        Class<? super R> clazz = type.getRawClass();\n        if (clazz.isAnnotationPresent(Managed.class)) {\n            validateType(type, extractionContext);\n\n            ImmutableListMultimap<String, Method> methodsByName = Multimaps.index(Arrays.asList(clazz.getMethods()), new Function<Method, String>() {\n                public String apply(Method method) {\n                    return method.getName();\n                }\n            });\n\n            ensureNoOverloadedMethods(extractionContext, methodsByName);\n\n            List<ModelProperty<?>> properties = Lists.newLinkedList();\n            List<Method> handled = Lists.newArrayListWithCapacity(clazz.getMethods().length);\n\n            for (String methodName : methodsByName.keySet()) {\n                if (methodName.startsWith(\"get\") && !methodName.equals(\"get\")) {\n                    ImmutableList<Method> getterMethods = methodsByName.get(methodName);\n\n                    // The overload check earlier verified that all methods for are equivalent for our purposes\n                    // So, taking the first one is fine.\n                    Method sampleMethod = getterMethods.get(0);\n\n                    if (sampleMethod.getParameterTypes().length != 0) {\n                        throw invalidMethod(extractionContext, \"getter methods cannot take parameters\", sampleMethod);\n                    }\n\n                    Character getterPropertyNameFirstChar = methodName.charAt(3);\n                    if (!Character.isUpperCase(getterPropertyNameFirstChar)) {\n                        throw invalidMethod(extractionContext, \"the 4th character of the getter method name must be an uppercase character\", sampleMethod);\n                    }\n\n                    ModelType<?> returnType = ModelType.of(sampleMethod.getGenericReturnType());\n\n                    String propertyNameCapitalized = methodName.substring(3);\n                    String propertyName = StringUtils.uncapitalize(propertyNameCapitalized);\n                    String setterName = \"set\" + propertyNameCapitalized;\n                    ImmutableList<Method> setterMethods = methodsByName.get(setterName);\n\n                    boolean isWritable = !setterMethods.isEmpty();\n                    if (isWritable) {\n                        validateSetter(extractionContext, returnType, setterMethods.get(0));\n                        handled.addAll(setterMethods);\n                    }\n\n                    ImmutableSet<ModelType<?>> declaringClasses = ImmutableSet.copyOf(Iterables.transform(getterMethods, new Function<Method, ModelType<?>>() {\n                        public ModelType<?> apply(Method input) {\n                            return ModelType.of(input.getDeclaringClass());\n                        }\n                    }));\n\n                    properties.add(ModelProperty.of(returnType, propertyName, isWritable, declaringClasses));\n                    handled.addAll(getterMethods);\n                }\n            }\n\n            Iterable<Method> notHandled = Iterables.filter(methodsByName.values(), Predicates.not(Predicates.in(handled)));\n\n            // TODO - should call out valid getters without setters\n            if (!Iterables.isEmpty(notHandled)) {\n                throw invalidMethods(extractionContext, \"only paired getter/setter methods are supported\", notHandled);\n            }\n\n            ModelSchema<R> schema = ModelSchema.struct(type, properties);\n            Iterable<ModelSchemaExtractionContext<?>> propertyDependencies = Iterables.transform(properties, new Function<ModelProperty<?>, ModelSchemaExtractionContext<?>>() {\n                public ModelSchemaExtractionContext<?> apply(final ModelProperty<?> property) {\n                    return toPropertyExtractionContext(extractionContext, property, cache);\n                }\n            });\n\n            return new ModelSchemaExtractionResult<R>(schema, propertyDependencies);\n        } else {\n            return null;\n        }\n    }","id":76723,"modified_method":"public <R> ModelSchemaExtractionResult<R> extract(final ModelSchemaExtractionContext<R> extractionContext, final ModelSchemaCache cache) {\n        ModelType<R> type = extractionContext.getType();\n        Class<? super R> clazz = type.getRawClass();\n        if (clazz.isAnnotationPresent(Managed.class)) {\n            validateType(type, extractionContext);\n\n            ImmutableListMultimap<String, Method> methodsByName = Multimaps.index(Arrays.asList(clazz.getMethods()), new Function<Method, String>() {\n                public String apply(Method method) {\n                    return method.getName();\n                }\n            });\n\n            ensureNoOverloadedMethods(extractionContext, methodsByName);\n\n            List<ModelProperty<?>> properties = Lists.newLinkedList();\n            List<Method> handled = Lists.newArrayListWithCapacity(clazz.getMethods().length);\n            ReturnTypeSpecializationOrdering returnTypeSpecializationOrdering = new ReturnTypeSpecializationOrdering();\n\n            for (String methodName : methodsByName.keySet()) {\n                if (methodName.startsWith(\"get\") && !methodName.equals(\"get\")) {\n                    ImmutableList<Method> getterMethods = methodsByName.get(methodName);\n\n                    // The overload check earlier verified that all methods for are equivalent for our purposes\n                    // So, taking the first one with the most specialized return type is fine.\n                    Method sampleMethod = returnTypeSpecializationOrdering.max(getterMethods);\n\n                    if (sampleMethod.getParameterTypes().length != 0) {\n                        throw invalidMethod(extractionContext, \"getter methods cannot take parameters\", sampleMethod);\n                    }\n\n                    Character getterPropertyNameFirstChar = methodName.charAt(3);\n                    if (!Character.isUpperCase(getterPropertyNameFirstChar)) {\n                        throw invalidMethod(extractionContext, \"the 4th character of the getter method name must be an uppercase character\", sampleMethod);\n                    }\n\n                    ModelType<?> returnType = ModelType.of(sampleMethod.getGenericReturnType());\n\n                    String propertyNameCapitalized = methodName.substring(3);\n                    String propertyName = StringUtils.uncapitalize(propertyNameCapitalized);\n                    String setterName = \"set\" + propertyNameCapitalized;\n                    ImmutableList<Method> setterMethods = methodsByName.get(setterName);\n\n                    boolean isWritable = !setterMethods.isEmpty();\n                    if (isWritable) {\n                        validateSetter(extractionContext, returnType, setterMethods.get(0));\n                        handled.addAll(setterMethods);\n                    }\n\n                    ImmutableSet<ModelType<?>> declaringClasses = ImmutableSet.copyOf(Iterables.transform(getterMethods, new Function<Method, ModelType<?>>() {\n                        public ModelType<?> apply(Method input) {\n                            return ModelType.of(input.getDeclaringClass());\n                        }\n                    }));\n\n                    properties.add(ModelProperty.of(returnType, propertyName, isWritable, declaringClasses));\n                    handled.addAll(getterMethods);\n                }\n            }\n\n            Iterable<Method> notHandled = Iterables.filter(methodsByName.values(), Predicates.not(Predicates.in(handled)));\n\n            // TODO - should call out valid getters without setters\n            if (!Iterables.isEmpty(notHandled)) {\n                throw invalidMethods(extractionContext, \"only paired getter/setter methods are supported\", notHandled);\n            }\n\n            ModelSchema<R> schema = ModelSchema.struct(type, properties);\n            Iterable<ModelSchemaExtractionContext<?>> propertyDependencies = Iterables.transform(properties, new Function<ModelProperty<?>, ModelSchemaExtractionContext<?>>() {\n                public ModelSchemaExtractionContext<?> apply(final ModelProperty<?> property) {\n                    return toPropertyExtractionContext(extractionContext, property, cache);\n                }\n            });\n\n            return new ModelSchemaExtractionResult<R>(schema, propertyDependencies);\n        } else {\n            return null;\n        }\n    }","commit_id":"25a06f134b14fd84d52a20fff32998561787065b","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected boolean doEquivalent(Method a, Method b) {\n            return new EqualsBuilder()\n                    .append(a.getName(), b.getName())\n                    .append(a.getGenericReturnType(), b.getGenericReturnType())\n                    .append(a.getGenericParameterTypes(), b.getGenericParameterTypes())\n                    .isEquals();\n        }","id":76724,"modified_method":"@Override\n        protected boolean doEquivalent(Method a, Method b) {\n            boolean equals = new EqualsBuilder()\n                    .append(a.getName(), b.getName())\n                    .append(a.getGenericParameterTypes(), b.getGenericParameterTypes())\n                    .isEquals();\n            if (equals) {\n                equals = a.getReturnType().equals(b.getReturnType())\n                        || a.getReturnType().isAssignableFrom(b.getReturnType())\n                        || b.getReturnType().isAssignableFrom(a.getReturnType());\n            }\n            return equals;\n        }","commit_id":"25a06f134b14fd84d52a20fff32998561787065b","url":"https://github.com/gradle/gradle"},{"original_method":"/**\r\n     * my and their way have no ids, neither do the nodes they refer to. but\r\n     * my and  their way are semantically equal. so technical attributes of\r\n     * their way can be merged on my way. No conflict.\r\n     *\r\n     */\r\n    @Test\r\n    public void waySimple_twoWaysWithNoId_NodesWithoutId() {\r\n\r\n        DataSet my = new DataSet();\r\n        my.version = \"0.6\";\r\n\r\n        Node n1 = new Node(new LatLon(0,0));\r\n        my.addPrimitive(n1);\r\n\r\n        Node n2 = new Node(new LatLon(1,1));\r\n        my.addPrimitive(n2);\r\n\r\n        Way myWay = new Way();\r\n        myWay.addNode(n1);\r\n        myWay.addNode(n2);\r\n        my.addPrimitive(myWay);\r\n\r\n        DataSet their = new DataSet();\r\n        their.version = \"0.6\";\r\n\r\n        Node n3 = new Node(new LatLon(0,0));\r\n        their.addPrimitive(n3);\r\n\r\n        Node n4 = new Node(new LatLon(1,1));\r\n        their.addPrimitive(n4);\r\n\r\n        Way theirWay = new Way();\r\n        theirWay.addNode(n3);\r\n        theirWay.addNode(n4);\r\n        theirWay.user = User.createOsmUser(1111, \"their\");\r\n        theirWay.setTimestamp(new Date());\r\n        their.addPrimitive(theirWay);\r\n\r\n        MergeVisitor visitor = new MergeVisitor(my,their);\r\n        visitor.merge();\r\n\r\n        assertEquals(0,visitor.getConflicts().size());\r\n        assertEquals(\"their\", myWay.user.getName());\r\n        assertEquals(1111, myWay.user.getId());\r\n        assertEquals(1111, myWay.user.getId());\r\n        assertEquals(theirWay.getTimestamp(), myWay.getTimestamp());\r\n    }","id":76725,"modified_method":"/**\r\n     * my and their way have no ids, neither do the nodes they refer to. but\r\n     * my and  their way are semantically equal. so technical attributes of\r\n     * their way can be merged on my way. No conflict.\r\n     *\r\n     */\r\n    @Test\r\n    public void waySimple_twoWaysWithNoId_NodesWithoutId() {\r\n\r\n        DataSet my = new DataSet();\r\n        my.version = \"0.6\";\r\n\r\n        Node n1 = new Node(new LatLon(0,0));\r\n        my.addPrimitive(n1);\r\n\r\n        Node n2 = new Node(new LatLon(1,1));\r\n        my.addPrimitive(n2);\r\n\r\n        Way myWay = new Way();\r\n        myWay.addNode(n1);\r\n        myWay.addNode(n2);\r\n        my.addPrimitive(myWay);\r\n\r\n        DataSet their = new DataSet();\r\n        their.version = \"0.6\";\r\n\r\n        Node n3 = new Node(new LatLon(0,0));\r\n        their.addPrimitive(n3);\r\n\r\n        Node n4 = new Node(new LatLon(1,1));\r\n        their.addPrimitive(n4);\r\n\r\n        Way theirWay = new Way();\r\n        theirWay.addNode(n3);\r\n        theirWay.addNode(n4);\r\n        theirWay.setUser(User.createOsmUser(1111, \"their\"));\r\n        theirWay.setTimestamp(new Date());\r\n        their.addPrimitive(theirWay);\r\n\r\n        MergeVisitor visitor = new MergeVisitor(my,their);\r\n        visitor.merge();\r\n\r\n        assertEquals(0,visitor.getConflicts().size());\r\n        assertEquals(\"their\", myWay.getUser().getName());\r\n        assertEquals(1111, myWay.getUser().getId());\r\n        assertEquals(1111, myWay.getUser().getId());\r\n        assertEquals(theirWay.getTimestamp(), myWay.getTimestamp());\r\n    }","commit_id":"b565a976d5bb07191bc39a4c917874a090e6d514","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\r\n     * my and their way have no ids,  nodes they refer to have an id. but\r\n     * my and  their way are semantically equal. so technical attributes of\r\n     * their way can be merged on my way. No conflict.\r\n     *\r\n     *\r\n     *\r\n     */\r\n    @Test\r\n    public void waySimple_twoWaysWithNoId_NodesWithId() {\r\n\r\n        DataSet my = new DataSet();\r\n        my.version = \"0.6\";\r\n\r\n        Node n1 = new Node(new LatLon(0,0));\r\n        n1.setOsmId(1,1);\r\n        my.addPrimitive(n1);\r\n\r\n        Node n2 = new Node(new LatLon(1,1));\r\n        n2.setOsmId(2,1);\r\n        my.addPrimitive(n2);\r\n\r\n        Way myWay = new Way();\r\n        myWay.addNode(n1);\r\n        myWay.addNode(n2);\r\n        my.addPrimitive(myWay);\r\n\r\n        DataSet their = new DataSet();\r\n        their.version = \"0.6\";\r\n\r\n        Node n3 = new Node(new LatLon(0,0));\r\n        n3.setOsmId(1,1);\r\n        their.addPrimitive(n3);\r\n\r\n        Node n4 = new Node(new LatLon(1,1));\r\n        n4.setOsmId(2,1);\r\n        their.addPrimitive(n4);\r\n\r\n        Way theirWay = new Way();\r\n        theirWay.addNode(n3);\r\n        theirWay.addNode(n4);\r\n        theirWay.user = User.createOsmUser(1111, \"their\");\r\n        theirWay.setTimestamp(new Date());\r\n        their.addPrimitive(theirWay);\r\n\r\n        MergeVisitor visitor = new MergeVisitor(my,their);\r\n        visitor.merge();\r\n\r\n        assertEquals(0,visitor.getConflicts().size());\r\n        assertEquals(\"their\", myWay.user.getName());\r\n        assertEquals(1111, myWay.user.getId());\r\n        assertEquals(1111, myWay.user.getId());\r\n        assertEquals(theirWay.getTimestamp(), myWay.getTimestamp());\r\n    }","id":76726,"modified_method":"/**\r\n     * my and their way have no ids,  nodes they refer to have an id. but\r\n     * my and  their way are semantically equal. so technical attributes of\r\n     * their way can be merged on my way. No conflict.\r\n     *\r\n     *\r\n     *\r\n     */\r\n    @Test\r\n    public void waySimple_twoWaysWithNoId_NodesWithId() {\r\n\r\n        DataSet my = new DataSet();\r\n        my.version = \"0.6\";\r\n\r\n        Node n1 = new Node(new LatLon(0,0));\r\n        n1.setOsmId(1,1);\r\n        my.addPrimitive(n1);\r\n\r\n        Node n2 = new Node(new LatLon(1,1));\r\n        n2.setOsmId(2,1);\r\n        my.addPrimitive(n2);\r\n\r\n        Way myWay = new Way();\r\n        myWay.addNode(n1);\r\n        myWay.addNode(n2);\r\n        my.addPrimitive(myWay);\r\n\r\n        DataSet their = new DataSet();\r\n        their.version = \"0.6\";\r\n\r\n        Node n3 = new Node(new LatLon(0,0));\r\n        n3.setOsmId(1,1);\r\n        their.addPrimitive(n3);\r\n\r\n        Node n4 = new Node(new LatLon(1,1));\r\n        n4.setOsmId(2,1);\r\n        their.addPrimitive(n4);\r\n\r\n        Way theirWay = new Way();\r\n        theirWay.addNode(n3);\r\n        theirWay.addNode(n4);\r\n        theirWay.setUser(User.createOsmUser(1111, \"their\"));\r\n        theirWay.setTimestamp(new Date());\r\n        their.addPrimitive(theirWay);\r\n\r\n        MergeVisitor visitor = new MergeVisitor(my,their);\r\n        visitor.merge();\r\n\r\n        assertEquals(0,visitor.getConflicts().size());\r\n        assertEquals(\"their\", myWay.getUser().getName());\r\n        assertEquals(1111, myWay.getUser().getId());\r\n        assertEquals(1111, myWay.getUser().getId());\r\n        assertEquals(theirWay.getTimestamp(), myWay.getTimestamp());\r\n    }","commit_id":"b565a976d5bb07191bc39a4c917874a090e6d514","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\r\n     * My dataset includes a deleted node.\r\n     * Their dataset includes a way with three nodes, the first one being my node.\r\n     *\r\n     * => the merged way should include two nodes only. the deleted node should still be\r\n     * in the data set\r\n     *\r\n     */\r\n    @Test\r\n    public void wayComplex_mergingADeletedNode() {\r\n\r\n        DataSet my = new DataSet();\r\n        my.version = \"0.6\";\r\n\r\n        Node n1 = new Node(new LatLon(0,0));\r\n        n1.setOsmId(1,1);\r\n        n1.setDeleted(true);\r\n        my.addPrimitive(n1);\r\n\r\n        DataSet their = new DataSet();\r\n        their.version = \"0.6\";\r\n\r\n        Node n3 = new Node(new LatLon(0,0));\r\n        n3.setOsmId(1,1);\r\n        their.addPrimitive(n3);\r\n\r\n        Node n4 = new Node(new LatLon(1,1));\r\n        n4.setOsmId(2,1);\r\n        their.addPrimitive(n4);\r\n\r\n        Node n5 = new Node(new LatLon(2,2));\r\n        n5.setOsmId(3,1);\r\n        their.addPrimitive(n5);\r\n\r\n\r\n        Way theirWay = new Way();\r\n        theirWay.setOsmId(4,1);\r\n        theirWay.addNode(n3);\r\n        theirWay.addNode(n4);\r\n        theirWay.addNode(n5);\r\n        theirWay.user = User.createOsmUser(1111, \"their\");\r\n        theirWay.setTimestamp(new Date());\r\n        their.addPrimitive(theirWay);\r\n\r\n        MergeVisitor visitor = new MergeVisitor(my,their);\r\n        visitor.merge();\r\n\r\n        assertEquals(0,visitor.getConflicts().size());\r\n\r\n        Way myWay = (Way)my.getPrimitiveById(4,OsmPrimitiveType.WAY);\r\n        assertEquals(2, myWay.getNodesCount());\r\n\r\n        Node n = (Node)my.getPrimitiveById(1,OsmPrimitiveType.NODE);\r\n        assertTrue(n != null);\r\n    }","id":76727,"modified_method":"/**\r\n     * My dataset includes a deleted node.\r\n     * Their dataset includes a way with three nodes, the first one being my node.\r\n     *\r\n     * => the merged way should include two nodes only. the deleted node should still be\r\n     * in the data set\r\n     *\r\n     */\r\n    @Test\r\n    public void wayComplex_mergingADeletedNode() {\r\n\r\n        DataSet my = new DataSet();\r\n        my.version = \"0.6\";\r\n\r\n        Node n1 = new Node(new LatLon(0,0));\r\n        n1.setOsmId(1,1);\r\n        n1.setDeleted(true);\r\n        my.addPrimitive(n1);\r\n\r\n        DataSet their = new DataSet();\r\n        their.version = \"0.6\";\r\n\r\n        Node n3 = new Node(new LatLon(0,0));\r\n        n3.setOsmId(1,1);\r\n        their.addPrimitive(n3);\r\n\r\n        Node n4 = new Node(new LatLon(1,1));\r\n        n4.setOsmId(2,1);\r\n        their.addPrimitive(n4);\r\n\r\n        Node n5 = new Node(new LatLon(2,2));\r\n        n5.setOsmId(3,1);\r\n        their.addPrimitive(n5);\r\n\r\n\r\n        Way theirWay = new Way();\r\n        theirWay.setOsmId(4,1);\r\n        theirWay.addNode(n3);\r\n        theirWay.addNode(n4);\r\n        theirWay.addNode(n5);\r\n        theirWay.setUser(User.createOsmUser(1111, \"their\"));\r\n        theirWay.setTimestamp(new Date());\r\n        their.addPrimitive(theirWay);\r\n\r\n        MergeVisitor visitor = new MergeVisitor(my,their);\r\n        visitor.merge();\r\n\r\n        assertEquals(0,visitor.getConflicts().size());\r\n\r\n        Way myWay = (Way)my.getPrimitiveById(4,OsmPrimitiveType.WAY);\r\n        assertEquals(2, myWay.getNodesCount());\r\n\r\n        Node n = (Node)my.getPrimitiveById(1,OsmPrimitiveType.NODE);\r\n        assertTrue(n != null);\r\n    }","commit_id":"b565a976d5bb07191bc39a4c917874a090e6d514","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\r\n     * their node has no assigned id (id == 0) and is semantically equal to one of my\r\n     * nodes with id == 0\r\n     *\r\n     * => merge it onto my node.\r\n     *\r\n     */\r\n    @Test\r\n    public void nodeSimple_NoIdSemanticallyEqual() {\r\n\r\n        Calendar cal = GregorianCalendar.getInstance();\r\n        User myUser = User.createOsmUser(1111, \"my\");\r\n\r\n        User theirUser = User.createOsmUser(222, \"their\");\r\n\r\n        DataSet my = new DataSet();\r\n        my.version = \"0.6\";\r\n        Node n = new Node();\r\n        n.setCoor(new LatLon(0,0));\r\n        n.put(\"key1\", \"value1\");\r\n        n.user = myUser;\r\n        n.setTimestamp(cal.getTime());\r\n\r\n        my.addPrimitive(n);\r\n\r\n        DataSet their = new DataSet();\r\n        their.version = \"0.6\";\r\n        Node n1 = new Node();\r\n        n1.setCoor(new LatLon(0,0));\r\n        n1.put(\"key1\", \"value1\");\r\n        cal.add(Calendar.HOUR, 1);\r\n        Date timestamp = cal.getTime();\r\n        n1.setTimestamp(timestamp);\r\n        n1.user = theirUser;\r\n        their.addPrimitive(n1);\r\n\r\n\r\n        MergeVisitor visitor = new MergeVisitor(my,their);\r\n        visitor.merge();\r\n\r\n        Node n2 = my.nodes.iterator().next();\r\n        assertEquals(0,visitor.getConflicts().size());\r\n        assertEquals(\"value1\",n2.get(\"key1\"));\r\n        assertEquals(true, n1.getTimestamp().equals(n2.getTimestamp()));\r\n        assertEquals(theirUser,n2.user);\r\n    }","id":76728,"modified_method":"/**\r\n     * their node has no assigned id (id == 0) and is semantically equal to one of my\r\n     * nodes with id == 0\r\n     *\r\n     * => merge it onto my node.\r\n     *\r\n     */\r\n    @Test\r\n    public void nodeSimple_NoIdSemanticallyEqual() {\r\n\r\n        Calendar cal = GregorianCalendar.getInstance();\r\n        User myUser = User.createOsmUser(1111, \"my\");\r\n\r\n        User theirUser = User.createOsmUser(222, \"their\");\r\n\r\n        DataSet my = new DataSet();\r\n        my.version = \"0.6\";\r\n        Node n = new Node();\r\n        n.setCoor(new LatLon(0,0));\r\n        n.put(\"key1\", \"value1\");\r\n        n.setUser(myUser);\r\n        n.setTimestamp(cal.getTime());\r\n\r\n        my.addPrimitive(n);\r\n\r\n        DataSet their = new DataSet();\r\n        their.version = \"0.6\";\r\n        Node n1 = new Node();\r\n        n1.setCoor(new LatLon(0,0));\r\n        n1.put(\"key1\", \"value1\");\r\n        cal.add(Calendar.HOUR, 1);\r\n        Date timestamp = cal.getTime();\r\n        n1.setTimestamp(timestamp);\r\n        n1.setUser(theirUser);\r\n        their.addPrimitive(n1);\r\n\r\n\r\n        MergeVisitor visitor = new MergeVisitor(my,their);\r\n        visitor.merge();\r\n\r\n        Node n2 = my.nodes.iterator().next();\r\n        assertEquals(0,visitor.getConflicts().size());\r\n        assertEquals(\"value1\",n2.get(\"key1\"));\r\n        assertEquals(true, n1.getTimestamp().equals(n2.getTimestamp()));\r\n        assertEquals(theirUser,n2.getUser());\r\n    }","commit_id":"b565a976d5bb07191bc39a4c917874a090e6d514","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected WebResource connect(final ResourceCli resourceCli, final String resource) {\n        // Initialize the REST client\n        final DefaultApacheHttpClientConfig defaultApacheHttpClientConfig = new DefaultApacheHttpClientConfig();\n        defaultApacheHttpClientConfig.getFeatures().put(JSONConfiguration.FEATURE_POJO_MAPPING, Boolean.TRUE);\n        defaultApacheHttpClientConfig.getProperties().put(defaultApacheHttpClientConfig.PROPERTY_PREEMPTIVE_AUTHENTICATION, Boolean.TRUE);\n        defaultApacheHttpClientConfig.getState().setCredentials(null, null, -1, resourceCli.getUsername(), resourceCli.getPassword());\n        final ApacheHttpClient apacheHttpClient = ApacheHttpClient.create(defaultApacheHttpClientConfig);\n\n        // Build the request URL\n        final StringBuilder url = new StringBuilder();\n        url.append(resourceCli.getBaseUrl());\n        url.append(\"/rest/resources\");\n        if (! Strings.isNullOrEmpty(resource)) {\n            url.append(\"/\");\n            url.append(UrlEscapers.urlPathSegmentEscaper().escape(resource));\n        }\n\n        // Build the web resource\n        return apacheHttpClient\n                .resource(url.toString());\n    }","id":76729,"modified_method":"protected Invocation.Builder connect(final ResourceCli resourceCli, final String resource) {\n        // Initialize the REST client\n        final Client client = ClientBuilder.newClient();\n\n        // Build the request URL\n        final StringBuilder url = new StringBuilder();\n        url.append(resourceCli.getBaseUrl());\n        url.append(\"/rest/resources\");\n        if (! Strings.isNullOrEmpty(resource)) {\n            url.append(\"/\");\n            url.append(UrlEscapers.urlPathSegmentEscaper().escape(resource));\n        }\n        WebTarget target = client.target(url.toString());\n\n        String authorizationHeader = \"Basic \" + Base64Utility.encode((resourceCli.getUsername() + \":\" + resourceCli.getPassword()).getBytes());\n        return target.request().header(\"Authorization\", authorizationHeader);\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected WebResource connect(final ResourceCli resourceCli) {\n        return this.connect(resourceCli, null);\n    }","id":76730,"modified_method":"protected Invocation.Builder connect(final ResourceCli resourceCli) {\n        return connect(resourceCli, null);\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getDisplayName(String reportId) {\n        reportId = reportId.substring(reportId.indexOf('_') + 1);\n        String result = \"\";\n        if (isConfigOk()) {\n            m_webResource = m_client.resource(m_remoteRepositoryDefintion.getURI() + \"displayName/\" + reportId);\n            try {\n                result = m_webResource.get(String.class);\n            } catch (Exception e) {\n                logger.error(\"Error requesting display name by report id. Error message: '{}' URI was: '{}'\", e.getMessage(), m_webResource.getURI());\n                e.printStackTrace();\n            }\n            \n            logger.debug(\"getDisplayName for id / result: '{}' URI was: '{}' \", reportId + \" / \" + result, m_webResource.getURI());\n            \n        }\n        return result;\n    }","id":76731,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getDisplayName(String reportId) {\n        reportId = reportId.substring(reportId.indexOf('_') + 1);\n        String result = \"\";\n        if (isConfigOk()) {\n            WebTarget target = getTarget(m_remoteRepositoryDefintion.getURI() + \"displayName/\" + reportId);\n            try {\n                result = getBuilder(target).get(String.class);\n            } catch (Exception e) {\n                logger.error(\"Error requesting display name by report id. Error message: '{}' URI was: '{}'\", e.getMessage(), target.getUri());\n                e.printStackTrace();\n            }\n            \n            logger.debug(\"getDisplayName for id / result: '{}' URI was: '{}' \", reportId + \" / \" + result, target.getUri());\n            \n        }\n        return result;\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Default constructor to initialize the ReST HTTP client\n     *\n     * @param remoteRepositoryDefinition a {@link org.opennms.features.reporting.model.remoterepository.RemoteRepositoryDefinition} object\n     * @param jasperReportsVersion       a {@link java.lang.String} object\n     */\n    public DefaultRemoteRepository(\n            RemoteRepositoryDefinition remoteRepositoryDefinition,\n            String jasperReportsVersion) {\n        this.m_remoteRepositoryDefintion = remoteRepositoryDefinition;\n        this.m_jasperReportsVersion = jasperReportsVersion;\n        ApacheHttpClientConfig clientConfig = new DefaultApacheHttpClientConfig();\n        clientConfig.getState().setCredentials(null,\n                m_remoteRepositoryDefintion.getURI().getHost(),\n                m_remoteRepositoryDefintion.getURI().getPort(),\n                m_remoteRepositoryDefintion.getLoginUser(),\n                m_remoteRepositoryDefintion.getLoginRepoPassword());\n        m_client = ApacheHttpClient.create(clientConfig);\n    }","id":76732,"modified_method":"/**\n     * Default constructor to initialize the ReST HTTP client\n     *\n     * @param remoteRepositoryDefinition a {@link org.opennms.features.reporting.model.remoterepository.RemoteRepositoryDefinition} object\n     * @param jasperReportsVersion       a {@link java.lang.String} object\n     */\n    public DefaultRemoteRepository(\n            RemoteRepositoryDefinition remoteRepositoryDefinition,\n            String jasperReportsVersion) {\n        this.m_remoteRepositoryDefintion = remoteRepositoryDefinition;\n        this.m_jasperReportsVersion = jasperReportsVersion;\n        m_authorizationHeader = \"Basic \" + Base64Utility.encode((m_remoteRepositoryDefintion.getLoginUser() + \":\" + m_remoteRepositoryDefintion.getLoginRepoPassword()).getBytes());\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public InputStream getTemplateStream(String reportId) {\n        reportId = reportId.substring(reportId.indexOf('_') + 1);\n        InputStream templateStreamResult = null;\n        if (isConfigOk()) {\n            m_webResource = m_client.resource(m_remoteRepositoryDefintion.getURI() + \"templateStream/\" + reportId);\n            try {\n                templateStreamResult = m_webResource.get(InputStream.class);\n            } catch (Exception e) {\n                logger.error(\"Error requesting template stream by id. Error message: '{}' URI was: '{}'\", e.getMessage(), m_webResource.getURI());\n                e.printStackTrace();\n            }\n            \n            logger.debug(\"getTemplateStream for id / inputstream: '{}' URI was: '{}' \", reportId + \" / \" + templateStreamResult, m_webResource.getURI());\n            \n        }\n        return templateStreamResult;\n    }","id":76733,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public InputStream getTemplateStream(String reportId) {\n        reportId = reportId.substring(reportId.indexOf('_') + 1);\n        InputStream templateStreamResult = null;\n        if (isConfigOk()) {\n            WebTarget target = getTarget(m_remoteRepositoryDefintion.getURI() + \"templateStream/\" + reportId);\n            try {\n                templateStreamResult = getBuilder(target).get(InputStream.class);\n            } catch (Exception e) {\n                logger.error(\"Error requesting template stream by id. Error message: '{}' URI was: '{}'\", e.getMessage(), target.getUri());\n                e.printStackTrace();\n            }\n            \n            logger.debug(\"getTemplateStream for id / inputstream: '{}' URI was: '{}' \", reportId + \" / \" + templateStreamResult, target.getUri());\n            \n        }\n        return templateStreamResult;\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getEngine(String reportId) {\n        reportId = reportId.substring(reportId.indexOf('_') + 1);\n        String result = \"\";\n        if (isConfigOk()) {\n            m_webResource = m_client.resource(m_remoteRepositoryDefintion.getURI() + \"engine/\" + reportId);\n            try {\n                result = m_webResource.get(String.class);\n            } catch (Exception e) {\n                logger.error(\"Error requesting engine by id. Error message: '{}' URI was: '{}'\", e.getMessage(), m_webResource.getURI());\n                e.printStackTrace();\n            }\n            \n            logger.debug(\"getEngine for id / result: '{}' URI was: '{}' \", reportId + \" / \" + result, m_webResource.getURI());\n            \n        }\n        return result;\n    }","id":76734,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getEngine(String reportId) {\n        reportId = reportId.substring(reportId.indexOf('_') + 1);\n        String result = \"\";\n        if (isConfigOk()) {\n            WebTarget target = getTarget(m_remoteRepositoryDefintion.getURI() + \"engine/\" + reportId);\n            try {\n                result = getBuilder(target).get(String.class);\n            } catch (Exception e) {\n                logger.error(\"Error requesting engine by id. Error message: '{}' URI was: '{}'\", e.getMessage(), target.getUri());\n                e.printStackTrace();\n            }\n            \n            logger.debug(\"getEngine for id / result: '{}' URI was: '{}' \", reportId + \" / \" + result, target.getUri());\n            \n        }\n        return result;\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<BasicReportDefinition> getReports() {\n        List<BasicReportDefinition> resultReports = new ArrayList<BasicReportDefinition>();\n        if (isConfigOk()) {\n            m_webResource = m_client.resource(m_remoteRepositoryDefintion.getURI() + \"reports\" + \"/\" + m_jasperReportsVersion);\n            List<RemoteReportSDO> webCallResult = new ArrayList<RemoteReportSDO>();\n            try {\n                webCallResult = m_webResource.get(new GenericType<List<RemoteReportSDO>>() {\n                });\n            } catch (Exception e) {\n                logger.error(\"Error requesting report template from repository. Error message: '{}' Uri was: '{}'\", e.getMessage(), m_webResource.getURI());\n                e.printStackTrace();\n            }\n\n            logger.debug(\"getReports got '{}' RemoteReportSDOs from uri '{}'\", webCallResult.size(), m_webResource.getURI());\n\n            resultReports = this.mapSDOListToBasicReportList(webCallResult);\n\n        }\n        return resultReports;\n    }","id":76735,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<BasicReportDefinition> getReports() {\n        List<BasicReportDefinition> resultReports = new ArrayList<BasicReportDefinition>();\n        if (isConfigOk()) {\n            WebTarget target = getTarget(m_remoteRepositoryDefintion.getURI() + \"reports\" + \"/\" + m_jasperReportsVersion);\n\n            List<RemoteReportSDO> webCallResult = new ArrayList<RemoteReportSDO>();\n            try {\n                webCallResult = getBuilder(target).get(new GenericType<List<RemoteReportSDO>>() {});\n            } catch (Exception e) {\n                logger.error(\"Error requesting report template from repository. Error message: '{}' Uri was: '{}'\", e.getMessage(), target.getUri());\n                e.printStackTrace();\n            }\n\n            logger.debug(\"getReports got '{}' RemoteReportSDOs from uri '{}'\", webCallResult.size(), target.getUri());\n\n            resultReports = this.mapSDOListToBasicReportList(webCallResult);\n\n        }\n        return resultReports;\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<BasicReportDefinition> getOnlineReports() {\n        List<BasicReportDefinition> resultReports = new ArrayList<BasicReportDefinition>();\n        List<RemoteReportSDO> webCallResult = new ArrayList<RemoteReportSDO>();\n        if (isConfigOk()) {\n            m_webResource = m_client.resource(m_remoteRepositoryDefintion.getURI() + \"onlineReports\" + \"/\" + m_jasperReportsVersion);\n            try {\n                webCallResult = m_webResource.get(new GenericType<List<RemoteReportSDO>>() {\n                });\n            } catch (Exception e) {\n                logger.error(\"Error requesting online reports. Error message: '{}' URI was: '{}'\", e.getMessage(), m_webResource.getURI());\n                e.printStackTrace();\n            }\n            \n            logger.debug(\"getOnlineReports got '{}' RemoteReportSDOs from uri '{}'\", webCallResult.size(), m_webResource.getURI());\n            \n            resultReports = this.mapSDOListToBasicReportList(webCallResult);\n        }\n        return resultReports;\n    }","id":76736,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<BasicReportDefinition> getOnlineReports() {\n        List<BasicReportDefinition> resultReports = new ArrayList<BasicReportDefinition>();\n        List<RemoteReportSDO> webCallResult = new ArrayList<RemoteReportSDO>();\n        if (isConfigOk()) {\n            WebTarget target = getTarget(m_remoteRepositoryDefintion.getURI() + \"onlineReports\" + \"/\" + m_jasperReportsVersion);\n            try {\n                webCallResult = getBuilder(target).get(new GenericType<List<RemoteReportSDO>>() {});\n            } catch (Exception e) {\n                logger.error(\"Error requesting online reports. Error message: '{}' URI was: '{}'\", e.getMessage(), target.getUri());\n                e.printStackTrace();\n            }\n            \n            logger.debug(\"getOnlineReports got '{}' RemoteReportSDOs from uri '{}'\", webCallResult.size(), target.getUri());\n            \n            resultReports = this.mapSDOListToBasicReportList(webCallResult);\n        }\n        return resultReports;\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getReportService(String reportId) {\n        reportId = reportId.substring(reportId.indexOf('_') + 1);\n        String result = \"\";\n        if (isConfigOk()) {\n            m_webResource = m_client.resource(m_remoteRepositoryDefintion.getURI() + \"reportService/\" + reportId);\n            try {\n                result = m_webResource.get(String.class);\n            } catch (Exception e) {\n                logger.error(\"Error requesting report service by report id. Error message: '{}' URI was: '{}'\", e.getMessage(), m_webResource.getURI());\n                e.printStackTrace();\n            }\n            logger.debug(\"getReportService for id / result: '{}' URI was: '{}' \", reportId + \" / \" + result, m_webResource.getURI());\n        }\n        return result;\n    }","id":76737,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public String getReportService(String reportId) {\n        reportId = reportId.substring(reportId.indexOf('_') + 1);\n        String result = \"\";\n        if (isConfigOk()) {\n            WebTarget target = getTarget(m_remoteRepositoryDefintion.getURI() + \"reportService/\" + reportId);\n            try {\n                result = getBuilder(target).get(String.class);\n            } catch (Exception e) {\n                logger.error(\"Error requesting report service by report id. Error message: '{}' URI was: '{}'\", e.getMessage(), target.getUri());\n                e.printStackTrace();\n            }\n            logger.debug(\"getReportService for id / result: '{}' URI was: '{}' \", reportId + \" / \" + result, target.getUri());\n        }\n        return result;\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String nodeIdString = request.getParameter(\"node\");\n        String labelType = request.getParameter(\"labeltype\");\n        String userLabel = request.getParameter(\"userlabel\");\n\n        if (nodeIdString == null) {\n            throw new MissingParameterException(\"node\", new String[] { \"node\", \"labeltype\", \"userlabel\" });\n        }\n        if (labelType == null) {\n            throw new MissingParameterException(\"labeltype\", new String[] { \"node\", \"labeltype\", \"userlabel\" });\n        }\n        if (userLabel == null) {\n            throw new MissingParameterException(\"userlabel\", new String[] { \"node\", \"labeltype\", \"userlabel\" });\n        }\n\n        try {\n            final int nodeId = WebSecurityUtils.safeParseInt(nodeIdString);\n            final OnmsNode node = NetworkElementFactory.getInstance(getServletContext()).getNode(nodeId);\n            NodeLabel nodeLabel = BeanUtils.getBean(\"daoContext\", \"nodeLabel\", NodeLabel.class);\n            NodeLabel oldLabel = new NodeLabelDaoImpl(node.getLabel(), node.getLabelSource());\n            NodeLabel newLabel = null;\n\n            if (labelType.equals(\"auto\")) {\n                newLabel = nodeLabel.computeLabel(nodeId);\n            } else if (labelType.equals(\"user\")) {\n                newLabel = new NodeLabelDaoImpl(userLabel, NodeLabelSource.USER);\n            } else {\n                throw new ServletException(\"Unexpected labeltype value: \" + labelType);\n            }\n\n            final String newNodeLabel = newLabel.getLabel();\n            boolean managedByProvisiond = node.getForeignSource() != null && node.getForeignId() != null;\n            if (managedByProvisiond) {\n                WebApplicationContext beanFactory = WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n                final TransactionTemplate transactionTemplate = beanFactory.getBean(TransactionTemplate.class);\n                final RequisitionAccessService requisitionService = beanFactory.getBean(RequisitionAccessService.class);\n                transactionTemplate.execute(new TransactionCallback<RequisitionNode>() {\n                    @Override\n                    public RequisitionNode doInTransaction(TransactionStatus status) {\n                        MultivaluedMapImpl params = new MultivaluedMapImpl();\n                        params.putSingle(\"node-label\", newNodeLabel);\n                        requisitionService.updateNode(node.getForeignSource(), node.getForeignId(), params);\n                        return requisitionService.getNode(node.getForeignSource(), node.getForeignId());\n                    }\n                });\n            }\n\n            this.sendLabelChangeEvent(nodeId, oldLabel, newLabel);\n\n            if (managedByProvisiond) {\n                response.sendRedirect(Util.calculateUrlBase(request, \"admin/nodelabelProvisioned.jsp?node=\" + nodeIdString + \"&foreignSource=\" + node.getForeignSource()));\n            } else {\n                final WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n                final TransactionTemplate transactionTemplate = context.getBean(TransactionTemplate.class);\n                final NodeLabel newLabelFinal = newLabel;\n                transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n                    @Override\n                    protected void doInTransactionWithoutResult(TransactionStatus status) {\n                        try {\n                            nodeLabel.assignLabel(nodeId, newLabelFinal);\n                        } catch (SQLException e) {\n                            LOG.error(\"Failed to change label on node with id: {} to: {}\", nodeId, newLabelFinal, e);\n                            throw Throwables.propagate(e);\n                        }\n                    }\n                });\n                response.sendRedirect(Util.calculateUrlBase(request, \"element/node.jsp?node=\" + nodeIdString));\n            }\n        } catch (SQLException e) {\n            throw new ServletException(\"Database exception\", e);\n        } catch (Throwable e) {\n            throw new ServletException(\"Exception sending node label change event\", e);\n        }\n    }","id":76738,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String nodeIdString = request.getParameter(\"node\");\n        String labelType = request.getParameter(\"labeltype\");\n        String userLabel = request.getParameter(\"userlabel\");\n\n        if (nodeIdString == null) {\n            throw new MissingParameterException(\"node\", new String[] { \"node\", \"labeltype\", \"userlabel\" });\n        }\n        if (labelType == null) {\n            throw new MissingParameterException(\"labeltype\", new String[] { \"node\", \"labeltype\", \"userlabel\" });\n        }\n        if (userLabel == null) {\n            throw new MissingParameterException(\"userlabel\", new String[] { \"node\", \"labeltype\", \"userlabel\" });\n        }\n\n        try {\n            final int nodeId = WebSecurityUtils.safeParseInt(nodeIdString);\n            final OnmsNode node = NetworkElementFactory.getInstance(getServletContext()).getNode(nodeId);\n            NodeLabel nodeLabel = BeanUtils.getBean(\"daoContext\", \"nodeLabel\", NodeLabel.class);\n            NodeLabel oldLabel = new NodeLabelDaoImpl(node.getLabel(), node.getLabelSource());\n            NodeLabel newLabel = null;\n\n            if (labelType.equals(\"auto\")) {\n                newLabel = nodeLabel.computeLabel(nodeId);\n            } else if (labelType.equals(\"user\")) {\n                newLabel = new NodeLabelDaoImpl(userLabel, NodeLabelSource.USER);\n            } else {\n                throw new ServletException(\"Unexpected labeltype value: \" + labelType);\n            }\n\n            final String newNodeLabel = newLabel.getLabel();\n            boolean managedByProvisiond = node.getForeignSource() != null && node.getForeignId() != null;\n            if (managedByProvisiond) {\n                WebApplicationContext beanFactory = WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n                final TransactionTemplate transactionTemplate = beanFactory.getBean(TransactionTemplate.class);\n                final RequisitionAccessService requisitionService = beanFactory.getBean(RequisitionAccessService.class);\n                transactionTemplate.execute(new TransactionCallback<RequisitionNode>() {\n                    @Override\n                    public RequisitionNode doInTransaction(TransactionStatus status) {\n                        MultivaluedMap<String, String> params = new MultivaluedHashMap<String, String>();\n                        params.putSingle(\"node-label\", newNodeLabel);\n                        requisitionService.updateNode(node.getForeignSource(), node.getForeignId(), params);\n                        return requisitionService.getNode(node.getForeignSource(), node.getForeignId());\n                    }\n                });\n            }\n\n            this.sendLabelChangeEvent(nodeId, oldLabel, newLabel);\n\n            if (managedByProvisiond) {\n                response.sendRedirect(Util.calculateUrlBase(request, \"admin/nodelabelProvisioned.jsp?node=\" + nodeIdString + \"&foreignSource=\" + node.getForeignSource()));\n            } else {\n                final WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n                final TransactionTemplate transactionTemplate = context.getBean(TransactionTemplate.class);\n                final NodeLabel newLabelFinal = newLabel;\n                transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n                    @Override\n                    protected void doInTransactionWithoutResult(TransactionStatus status) {\n                        try {\n                            nodeLabel.assignLabel(nodeId, newLabelFinal);\n                        } catch (SQLException e) {\n                            LOG.error(\"Failed to change label on node with id: {} to: {}\", nodeId, newLabelFinal, e);\n                            throw Throwables.propagate(e);\n                        }\n                    }\n                });\n                response.sendRedirect(Util.calculateUrlBase(request, \"element/node.jsp?node=\" + nodeIdString));\n            }\n        } catch (SQLException e) {\n            throw new ServletException(\"Database exception\", e);\n        } catch (Throwable e) {\n            throw new ServletException(\"Exception sending node label change event\", e);\n        }\n    }","commit_id":"a5600c8dc85da65cd12aa3ec3198f29e03f9ba1e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Determines the {@link MediaType} for the given filename.\n\t * <p>The default implementation will check the {@linkplain #setMediaTypes(Map) media types}\n\t * property first for a defined mapping. If not present, and if the Java Activation Framework\n\t * can be found on the classpath, it will call {@link FileTypeMap#getContentType(String)}\n\t * <p>This method can be overridden to provide a different algorithm.\n\t * @param filename the current request file name (i.e. {@code hotels.html})\n\t * @return the media type, if any\n\t */\n\tprotected MediaType getMediaTypeFromFilename(String filename) {\n\t\tString extension = StringUtils.getFilenameExtension(filename);\n\t\tif (!StringUtils.hasText(extension)) {\n\t\t\treturn null;\n\t\t}\n\t\textension = extension.toLowerCase(Locale.ENGLISH);\n\t\tMediaType mediaType = this.mediaTypes.get(extension);\n\t\tif (mediaType == null) {\n\t\t\tString mimeType = getServletContext().getMimeType(filename);\n\t\t\tif (StringUtils.hasText(mimeType)) {\n\t\t\t\tmediaType = new MediaType(mimeType);\n\t\t\t}\n\t\t\telse if (this.useJaf && jafPresent) {\n\t\t\t\tmediaType = ActivationMediaTypeFactory.getMediaType(filename);\n\t\t\t}\n\t\t\tif (mediaType != null) {\n\t\t\t\tthis.mediaTypes.putIfAbsent(extension, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mediaType;\n\t}","id":76739,"modified_method":"/**\n\t * Determines the {@link MediaType} for the given filename.\n\t * <p>The default implementation will check the {@linkplain #setMediaTypes(Map) media types}\n\t * property first for a defined mapping. If not present, and if the Java Activation Framework\n\t * can be found on the classpath, it will call {@link FileTypeMap#getContentType(String)}\n\t * <p>This method can be overridden to provide a different algorithm.\n\t * @param filename the current request file name (i.e. {@code hotels.html})\n\t * @return the media type, if any\n\t */\n\tprotected MediaType getMediaTypeFromFilename(String filename) {\n\t\tString extension = StringUtils.getFilenameExtension(filename);\n\t\tif (!StringUtils.hasText(extension)) {\n\t\t\treturn null;\n\t\t}\n\t\textension = extension.toLowerCase(Locale.ENGLISH);\n\t\tMediaType mediaType = this.mediaTypes.get(extension);\n\t\tif (mediaType == null) {\n\t\t\tString mimeType = getServletContext().getMimeType(filename);\n\t\t\tif (StringUtils.hasText(mimeType)) {\n\t\t\t\tmediaType = MediaType.parseMediaType(mimeType);\n\t\t\t}\n\t\t\tif (this.useJaf && (mediaType == null || MediaType.APPLICATION_OCTET_STREAM.equals(mediaType))) {\n\t\t\t\tMediaType jafMediaType = ActivationMediaTypeFactory.getMediaType(filename);\n\t\t\t\tif (jafMediaType != null && !MediaType.APPLICATION_OCTET_STREAM.equals(jafMediaType)) {\n\t\t\t\t\tmediaType = jafMediaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mediaType != null) {\n\t\t\t\tthis.mediaTypes.putIfAbsent(extension, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mediaType;\n\t}","commit_id":"83c83d4d152ff6d8bffe79e9eece31ea0fc89c0e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void getMediaTypeFromFilenameJaf() {\n\t\tassertEquals(\"Invalid content type\", new MediaType(\"text\", \"html\"),\n\t\t\t\tviewResolver.getMediaTypeFromFilename(\"test.html\"));\n\t}","id":76740,"modified_method":"@Test\n\tpublic void getMediaTypeFromFilenameJaf() {\n\t\tassertEquals(\"Invalid content type\", new MediaType(\"application\", \"vnd.ms-excel\"),\n\t\t\t\tviewResolver.getMediaTypeFromFilename(\"test.xls\"));\n\t}","commit_id":"83c83d4d152ff6d8bffe79e9eece31ea0fc89c0e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void createViewResolver() {\n\t\tviewResolver = new ContentNegotiatingViewResolver();\n\t\trequest = new MockHttpServletRequest(\"GET\", \"/test\");\n\t\tRequestContextHolder.setRequestAttributes(new ServletRequestAttributes(request));\n\t}","id":76741,"modified_method":"@Before\n\tpublic void createViewResolver() {\n\t\tStaticWebApplicationContext wac = new StaticWebApplicationContext();\n\t\twac.setServletContext(new MockServletContext());\n\t\twac.refresh();\n\t\tviewResolver = new ContentNegotiatingViewResolver();\n\t\tviewResolver.setApplicationContext(wac);\n\t\trequest = new MockHttpServletRequest(\"GET\", \"/test\");\n\t\tRequestContextHolder.setRequestAttributes(new ServletRequestAttributes(request));\n\t}","commit_id":"83c83d4d152ff6d8bffe79e9eece31ea0fc89c0e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void getMediaTypeFromFilenameNoJaf() {\n\t\tviewResolver.setUseJaf(false);\n\t\tassertNull(\"Invalid content type\", viewResolver.getMediaTypeFromFilename(\"test.html\"));\n\t}","id":76742,"modified_method":"@Test\n\tpublic void getMediaTypeFromFilenameNoJaf() {\n\t\tviewResolver.setUseJaf(false);\n\t\tassertEquals(\"Invalid content type\", MediaType.APPLICATION_OCTET_STREAM,\n\t\t\t\tviewResolver.getMediaTypeFromFilename(\"test.xls\"));\n\t}","commit_id":"83c83d4d152ff6d8bffe79e9eece31ea0fc89c0e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Determine an appropriate media type for the given resource.\n\t * @param resource the resource to check\n\t * @return the corresponding media type, or <code>null<\/code> if none found\n\t */\n\tprotected MediaType getMediaType(Resource resource) {\n\t\tString mimeType = getServletContext().getMimeType(resource.getFilename());\n\t\tif (StringUtils.hasText(mimeType)) {\n\t\t\treturn new MediaType(mimeType);\n\t\t}\n\t\telse if (jafPresent) {\n\t\t\treturn ActivationMediaTypeFactory.getMediaType(resource.getFilename());\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":76743,"modified_method":"/**\n\t * Determine an appropriate media type for the given resource.\n\t * @param resource the resource to check\n\t * @return the corresponding media type, or <code>null<\/code> if none found\n\t */\n\tprotected MediaType getMediaType(Resource resource) {\n\t\tMediaType mediaType = null;\n\t\tString mimeType = getServletContext().getMimeType(resource.getFilename());\n\t\tif (StringUtils.hasText(mimeType)) {\n\t\t\tmediaType = MediaType.parseMediaType(mimeType);\n\t\t}\n\t\tif (jafPresent && (mediaType == null || MediaType.APPLICATION_OCTET_STREAM.equals(mediaType))) {\n\t\t\tMediaType jafMediaType = ActivationMediaTypeFactory.getMediaType(resource.getFilename());\n\t\t\tif (jafMediaType != null && !MediaType.APPLICATION_OCTET_STREAM.equals(jafMediaType)) {\n\t\t\t\tmediaType = jafMediaType;\n\t\t\t}\n\t\t}\n\t\treturn mediaType;\n\t}","commit_id":"83c83d4d152ff6d8bffe79e9eece31ea0fc89c0e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Method called back in the RemoteListener to notify\n     * listener of all RTP Remote Events.RemoteEvents are one of\n     * ReceiverReportEvent, SenderReportEvent or RemoteCollisionEvent\n     *\n     * @param remoteEvent the event\n     */\n    public void update(RemoteEvent remoteEvent)\n    {\n        if(!logger.isInfoEnabled())\n            return;\n\n        if(remoteEvent instanceof SenderReportEvent)\n        {\n            numberOfReceivedSenderReports++;\n\n            SenderReport report =\n                    ((SenderReportEvent)remoteEvent).getReport();\n\n            if(report.getFeedbackReports().size() > 0)\n            {\n                Feedback feedback =\n                            (Feedback)report.getFeedbackReports().get(0);\n\n                long remoteJitter = feedback.getJitter();\n\n                if(remoteJitter < minRemoteInterArrivalJitter\n                    ||minRemoteInterArrivalJitter == -1)\n                    minRemoteInterArrivalJitter = remoteJitter;\n\n                if(maxRemoteInterArrivalJitter < remoteJitter)\n                    maxRemoteInterArrivalJitter = remoteJitter;\n\n                // As sender reports are received on every 5 seconds\n                // print every 4th packet, on every 20 seconds\n                if(numberOfReceivedSenderReports%4 != 1)\n                    return;\n\n                StringBuilder buff =\n                        new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);\n\n                buff.append(\"Received a report for \")\n                    .append(getFormat().getMediaType().toString())\n                    .append(\" stream SSRC:\")\n                    .append(getLocalSourceID())\n                    .append(\" [packet count:\")\n                    .append(report.getSenderPacketCount())\n                    .append(\", bytes:\").append(report.getSenderByteCount())\n                    .append(\", interarrival jitter:\")\n                            .append(remoteJitter)\n                    .append(\", lost packets:\").append(feedback.getNumLost())\n                    .append(\", time since previous report:\")\n                            .append((int)(feedback.getDLSR()/65.536))\n                            .append(\"ms ]\");\n                logger.info(buff);\n            }\n        }\n    }","id":76744,"modified_method":"/**\n     * Method called back in the RemoteListener to notify\n     * listener of all RTP Remote Events.RemoteEvents are one of\n     * ReceiverReportEvent, SenderReportEvent or RemoteCollisionEvent\n     *\n     * @param remoteEvent the event\n     */\n    public void update(RemoteEvent remoteEvent)\n    {\n        if(!logger.isInfoEnabled())\n            return;\n\n        if(remoteEvent instanceof SenderReportEvent)\n        {\n            numberOfReceivedSenderReports++;\n\n            SenderReport report =\n                    ((SenderReportEvent)remoteEvent).getReport();\n\n            if(report.getFeedbackReports().size() > 0)\n            {\n                Feedback feedback =\n                            (Feedback)report.getFeedbackReports().get(0);\n\n                long remoteJitter = feedback.getJitter();\n\n                if(remoteJitter < minRemoteInterArrivalJitter\n                    ||minRemoteInterArrivalJitter == -1)\n                    minRemoteInterArrivalJitter = remoteJitter;\n\n                if(maxRemoteInterArrivalJitter < remoteJitter)\n                    maxRemoteInterArrivalJitter = remoteJitter;\n\n                // As sender reports are received on every 5 seconds\n                // print every 4th packet, on every 20 seconds\n                if(numberOfReceivedSenderReports%4 != 1)\n                    return;\n\n                StringBuilder buff =\n                        new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);\n\n                buff.append(\"Received a report for \")\n                    .append(getFormat() != null ? getFormat().getMediaType().toString() : \"\")\n                    .append(\" stream SSRC:\")\n                    .append(getLocalSourceID())\n                    .append(\" [packet count:\")\n                    .append(report.getSenderPacketCount())\n                    .append(\", bytes:\").append(report.getSenderByteCount())\n                    .append(\", interarrival jitter:\")\n                            .append(remoteJitter)\n                    .append(\", lost packets:\").append(feedback.getNumLost())\n                    .append(\", time since previous report:\")\n                            .append((int)(feedback.getDLSR()/65.536))\n                            .append(\"ms ]\");\n                logger.info(buff);\n            }\n        }\n    }","commit_id":"72023383399b099d710c4f384b465ebd9f13f825","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Prints all statistics available for rtpManager.\n     *\n     * @param rtpManager the RTP manager that we'd like to print statistics for.\n     */\n    private void printFlowStatistics(RTPManager rtpManager)\n    {\n        try\n        {\n            //print flow statistics.\n            GlobalTransmissionStats s = rtpManager.getGlobalTransmissionStats();\n\n            StringBuilder buff =\n                    new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);\n\n            buff.append(\"call stats for outgoing \")\n                .append(getFormat().getMediaType())\n                .append(\" stream SSRC:\")\n                .append(getLocalSourceID())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"bytes sent: \").append(s.getBytesSent())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"RTP sent: \").append(s.getRTPSent())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"remote reported min interarrival jitter : \")\n                        .append(minRemoteInterArrivalJitter)\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"remote reported max interarrival jitter : \")\n                        .append(maxRemoteInterArrivalJitter)\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"local collisions: \").append(s.getLocalColls())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"remote collisions: \").append(s.getRemoteColls())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"RTCP sent: \").append(s.getRTCPSent())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"transmit failed: \").append(s.getTransmitFailed());\n\n            logger.info(buff);\n\n            GlobalReceptionStats rs = rtpManager.getGlobalReceptionStats();\n\n            buff = new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);\n\n            buff.append(\"call stats for incoming \")\n                .append(getFormat().getMediaType()).append(\" stream SSRC:\")\n                .append(getRemoteSourceID())\n                .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"packets received: \").append(rs.getPacketsRecd())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"bytes received: \").append(rs.getBytesRecd())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"packets lost: \").append(statisticsEngine.getLost())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"min interarrival jitter : \")\n                    .append(statisticsEngine.getMinInterArrivalJitter())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"max interarrival jitter : \")\n                    .append(statisticsEngine.getMaxInterArrivalJitter())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"RTCPs received: \").append(rs.getRTCPRecd())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"bad RTCP packets: \").append(rs.getBadRTCPPkts())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"bad RTP packets: \").append(rs.getBadRTPkts())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"local collisions: \").append(rs.getLocalColls())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"malformed BYEs: \").append(rs.getMalformedBye())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"malformed RRs: \").append(rs.getMalformedRR())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"malformed SDESs: \").append(rs.getMalformedSDES())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"malformed SRs: \").append(rs.getMalformedSR())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"packets looped: \").append(rs.getPacketsLooped())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"remote collisions: \").append(rs.getRemoteColls())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"SRRs received: \").append(rs.getSRRecd())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"transmit failed: \").append(rs.getTransmitFailed())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"unknown types: \").append(rs.getUnknownTypes());\n\n            logger.info(buff);\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error writing statistics\", t);\n        }\n    }","id":76745,"modified_method":"/**\n     * Prints all statistics available for rtpManager.\n     *\n     * @param rtpManager the RTP manager that we'd like to print statistics for.\n     */\n    private void printFlowStatistics(RTPManager rtpManager)\n    {\n        try\n        {\n            //print flow statistics.\n            GlobalTransmissionStats s = rtpManager.getGlobalTransmissionStats();\n\n            StringBuilder buff =\n                    new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);\n\n            buff.append(\"call stats for outgoing \")\n                .append(getFormat() != null ? getFormat().getMediaType() : \"\")\n                .append(\" stream SSRC:\")\n                .append(getLocalSourceID())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"bytes sent: \").append(s.getBytesSent())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"RTP sent: \").append(s.getRTPSent())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"remote reported min interarrival jitter : \")\n                        .append(minRemoteInterArrivalJitter)\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"remote reported max interarrival jitter : \")\n                        .append(maxRemoteInterArrivalJitter)\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"local collisions: \").append(s.getLocalColls())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"remote collisions: \").append(s.getRemoteColls())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"RTCP sent: \").append(s.getRTCPSent())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"transmit failed: \").append(s.getTransmitFailed());\n\n            logger.info(buff);\n\n            GlobalReceptionStats rs = rtpManager.getGlobalReceptionStats();\n\n            buff = new StringBuilder(StatisticsEngine.RTP_STAT_PREFIX);\n\n            buff.append(\"call stats for incoming \")\n                .append(getFormat().getMediaType()).append(\" stream SSRC:\")\n                .append(getRemoteSourceID())\n                .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"packets received: \").append(rs.getPacketsRecd())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"bytes received: \").append(rs.getBytesRecd())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"packets lost: \").append(statisticsEngine.getLost())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"min interarrival jitter : \")\n                    .append(statisticsEngine.getMinInterArrivalJitter())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"max interarrival jitter : \")\n                    .append(statisticsEngine.getMaxInterArrivalJitter())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"RTCPs received: \").append(rs.getRTCPRecd())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"bad RTCP packets: \").append(rs.getBadRTCPPkts())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"bad RTP packets: \").append(rs.getBadRTPkts())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"local collisions: \").append(rs.getLocalColls())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"malformed BYEs: \").append(rs.getMalformedBye())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"malformed RRs: \").append(rs.getMalformedRR())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"malformed SDESs: \").append(rs.getMalformedSDES())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"malformed SRs: \").append(rs.getMalformedSR())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"packets looped: \").append(rs.getPacketsLooped())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"remote collisions: \").append(rs.getRemoteColls())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"SRRs received: \").append(rs.getSRRecd())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"transmit failed: \").append(rs.getTransmitFailed())\n                    .append(\"\\n\").append(StatisticsEngine.RTP_STAT_PREFIX)\n                .append(\"unknown types: \").append(rs.getUnknownTypes());\n\n            logger.info(buff);\n        }\n        catch(Throwable t)\n        {\n            logger.error(\"Error writing statistics\", t);\n        }\n    }","commit_id":"72023383399b099d710c4f384b465ebd9f13f825","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call,\n     * boolean). Modifies the local media setup to reflect the requested setting\n     * for the streaming of the local video and then re-invites all\n     * CallPeers to re-negotiate the modified media setup.\n     *\n     * @param call the call where we'd like to allow sending local video.\n     * @param allowed <tt>true<\/tt> if local video transmission is allowed and\n     * <tt>false<\/tt> otherwise.\n     *\n     *  @throws OperationFailedException if video initialization fails.\n     */\n    @Override\n    public void setLocalVideoAllowed(Call call, boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallJabberImpl)call).setLocalVideoAllowed(allowed,\n                MediaUseCase.DESKTOP);\n        MediaDevice device = ((CallJabberImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        ((CallJabberImpl)call).modifyVideoContent(allowed);\n        origin = getOriginForMediaDevice(device);\n    }","id":76746,"modified_method":"/**\n     * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call,\n     * boolean). Modifies the local media setup to reflect the requested setting\n     * for the streaming of the local video and then re-invites all\n     * CallPeers to re-negotiate the modified media setup.\n     *\n     * @param call the call where we'd like to allow sending local video.\n     * @param allowed <tt>true<\/tt> if local video transmission is allowed and\n     * <tt>false<\/tt> otherwise.\n     *\n     *  @throws OperationFailedException if video initialization fails.\n     */\n    @Override\n    public void setLocalVideoAllowed(Call call, boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallJabberImpl)call).setLocalVideoAllowed(allowed,\n                MediaUseCase.DESKTOP);\n        ((CallJabberImpl)call).setVideoDevice(null);\n        MediaDevice device = ((CallJabberImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        ((CallJabberImpl)call).modifyVideoContent(allowed);\n        origin = getOriginForMediaDevice(device);\n    }","commit_id":"72023383399b099d710c4f384b465ebd9f13f825","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call,\n     * boolean). Modifies the local media setup to reflect the requested setting\n     * for the streaming of the local video and then re-invites all\n     * CallPeers to re-negotiate the modified media setup.\n     *\n     * @param call the call where we'd like to allow sending local video.\n     * @param allowed <tt>true<\/tt> if local video transmission is allowed and\n     * <tt>false<\/tt> otherwise.\n     *\n     *  @throws OperationFailedException if video initialization fails.\n     */\n    @Override\n    public void setLocalVideoAllowed(Call call, boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallSipImpl)call).setLocalVideoAllowed(allowed, MediaUseCase.DESKTOP);\n\n        MediaDevice device = ((CallSipImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n\n        /* reinvite all peers */\n        ((CallSipImpl)call).reInvite();\n    }","id":76747,"modified_method":"/**\n     * Implements OperationSetVideoTelephony#setLocalVideoAllowed(Call,\n     * boolean). Modifies the local media setup to reflect the requested setting\n     * for the streaming of the local video and then re-invites all\n     * CallPeers to re-negotiate the modified media setup.\n     *\n     * @param call the call where we'd like to allow sending local video.\n     * @param allowed <tt>true<\/tt> if local video transmission is allowed and\n     * <tt>false<\/tt> otherwise.\n     *\n     *  @throws OperationFailedException if video initialization fails.\n     */\n    @Override\n    public void setLocalVideoAllowed(Call call, boolean allowed)\n        throws OperationFailedException\n    {\n        ((CallSipImpl)call).setLocalVideoAllowed(allowed, MediaUseCase.DESKTOP);\n        ((CallSipImpl)call).setVideoDevice(null);\n        MediaDevice device = ((CallSipImpl)call).getDefaultDevice(\n                MediaType.VIDEO);\n        size = (((VideoMediaFormat)device.getFormat()).getSize());\n        origin = getOriginForMediaDevice(device);\n\n        /* reinvite all peers */\n        ((CallSipImpl)call).reInvite();\n    }","commit_id":"72023383399b099d710c4f384b465ebd9f13f825","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Invoke the servlet we are managing, respecting the rules regarding\n     * servlet lifecycle and SingleThreadModel support.\n     *\n     * @param request Request to be processed\n     * @param response Response to be produced\n     * @param valveContext Valve context used to forward to the next Valve\n     *\n     * @exception IOException if an input/output error occurred\n     * @exception ServletException if a servlet error occurred\n     */\n    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n        //check filters to see if we support async or not.\n        request.setAsyncSupported(filterChain.isAsyncSupported());\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }","id":76748,"modified_method":"/**\n     * Invoke the servlet we are managing, respecting the rules regarding\n     * servlet lifecycle and SingleThreadModel support.\n     *\n     * @param request Request to be processed\n     * @param response Response to be produced\n     * @param valveContext Valve context used to forward to the next Valve\n     *\n     * @exception IOException if an input/output error occurred\n     * @exception ServletException if a servlet error occurred\n     */\n    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n        //check filters to see if we support async or not.\n        if (filterChain != null) {\n            request.setAsyncSupported(filterChain.isAsyncSupported());\n        }\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }","commit_id":"7c21d1fd8909169effd019a0d00ce662b3e8454a","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void contextInitialized(ServletContextEvent sce)\n    {\t\n        // System.err.println(\"contextInitialized \"+sce);\n        _called.put(\"contextInitialized\",new Throwable());\n\n        //configure programmatic security\n        ServletRegistration.Dynamic rego = sce.getServletContext().addServlet(\"RegoTest\", RegTest.class.getName());\n        rego.addMapping(\"/rego/*\");\n        HttpConstraintElement constraintElement = new HttpConstraintElement(ServletSecurity.EmptyRoleSemantic.PERMIT, \n            ServletSecurity.TransportGuarantee.NONE, new String[]{\"admin\"});\n        ServletSecurityElement securityElement = new ServletSecurityElement(constraintElement, null);\n        Set<String> unchanged = rego.setServletSecurity(securityElement);\n        //// System.err.println(\"Security constraints registered: \"+unchanged.isEmpty());\n\n        //Test that a security constraint from web.xml can't be overridden programmatically\n        ServletRegistration.Dynamic rego2 = sce.getServletContext().addServlet(\"RegoTest2\", RegTest.class.getName());\n        rego2.addMapping(\"/rego2/*\");\n        securityElement = new ServletSecurityElement(constraintElement, null);\n        unchanged = rego2.setServletSecurity(securityElement);\n        //// System.err.println(\"Overridding web.xml constraints not possible:\" +!unchanged.isEmpty());\n\n        /* For servlet 3.0 */\n        FilterRegistration.Dynamic registration = sce.getServletContext().addFilter(\"TestFilter\",TestFilter.class.getName());\n        registration.setInitParameter(\"remote\", \"false\");\n        registration.setAsyncSupported(true);\n        registration.addMappingForUrlPatterns(\n            EnumSet.of(DispatcherType.ERROR,DispatcherType.ASYNC,DispatcherType.FORWARD,DispatcherType.INCLUDE,DispatcherType.REQUEST),\n            true, \n            new String[]{\"/*\"});\n    }","id":76749,"modified_method":"@Override\n    public void contextInitialized(ServletContextEvent sce)\n    {\t\n        // System.err.println(\"contextInitialized \"+sce);\n        _called.put(\"contextInitialized\",new Throwable());\n\n        //configure programmatic security\n        ServletRegistration.Dynamic rego = sce.getServletContext().addServlet(\"RegoTest\", RegTest.class.getName());\n        rego.addMapping(\"/rego/*\");\n        HttpConstraintElement constraintElement = new HttpConstraintElement(ServletSecurity.EmptyRoleSemantic.PERMIT, \n            ServletSecurity.TransportGuarantee.NONE, new String[]{\"admin\"});\n        ServletSecurityElement securityElement = new ServletSecurityElement(constraintElement, null);\n        Set<String> unchanged = rego.setServletSecurity(securityElement);\n        //// System.err.println(\"Security constraints registered: \"+unchanged.isEmpty());\n\n        //Test that a security constraint from web.xml can't be overridden programmatically\n        ServletRegistration.Dynamic rego2 = sce.getServletContext().addServlet(\"RegoTest2\", RegTest.class.getName());\n        rego2.addMapping(\"/rego2/*\");\n        securityElement = new ServletSecurityElement(constraintElement, null);\n        unchanged = rego2.setServletSecurity(securityElement);\n        //// System.err.println(\"Overridding web.xml constraints not possible:\" +!unchanged.isEmpty());\n\n        /* For servlet 3.0 */\n        FilterRegistration.Dynamic registration = sce.getServletContext().addFilter(\"TestFilter\",TestFilter.class.getName());\n        if (registration != null) //otherwise defined in web.xml\n        {\n            registration.setInitParameter(\"remote\", \"false\");\n            registration.setAsyncSupported(true);\n            registration.addMappingForUrlPatterns(\n                                                  EnumSet.of(DispatcherType.ERROR,DispatcherType.ASYNC,DispatcherType.FORWARD,DispatcherType.INCLUDE,DispatcherType.REQUEST),\n                                                  true, \n                                                  new String[]{\"/*\"});\n        }\n    }","commit_id":"fc2682ab02a52fa0988ce5d621cb39e278476e05","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void contextInitialized(ServletContextEvent sce)\n    {\t\n        //configure programmatic security\n        ServletRegistration.Dynamic rego = sce.getServletContext().addServlet(\"RegoTest\", RegTest.class.getName());\n        rego.addMapping(\"/rego/*\");\n        HttpConstraintElement constraintElement = new HttpConstraintElement(ServletSecurity.EmptyRoleSemantic.PERMIT, \n                                                                            ServletSecurity.TransportGuarantee.NONE, new String[]{\"admin\"});\n        ServletSecurityElement securityElement = new ServletSecurityElement(constraintElement, null);\n        Set<String> unchanged = rego.setServletSecurity(securityElement);\n        //System.err.println(\"Security constraints registered: \"+unchanged.isEmpty());\n\n        //Test that a security constraint from web.xml can't be overridden programmatically\n        ServletRegistration.Dynamic rego2 = sce.getServletContext().addServlet(\"RegoTest2\", RegTest.class.getName());\n        rego2.addMapping(\"/rego2/*\");\n        securityElement = new ServletSecurityElement(constraintElement, null);\n        unchanged = rego2.setServletSecurity(securityElement);\n        //System.err.println(\"Overridding web.xml constraints not possible:\" +!unchanged.isEmpty());\n\n    \t/* For servlet 3.0 */\n    \tFilterRegistration.Dynamic registration = sce.getServletContext().addFilter(\"TestFilter\",TestFilter.class.getName());\n    \tregistration.setInitParameter(\"remote\", \"false\");\n    \tregistration.setAsyncSupported(true);\n    \tregistration.addMappingForUrlPatterns(\n    \t        EnumSet.of(DispatcherType.ERROR,DispatcherType.ASYNC,DispatcherType.FORWARD,DispatcherType.INCLUDE,DispatcherType.REQUEST),\n    \t        true, \n    \t        new String[]{\"/*\"});\n    }","id":76750,"modified_method":"public void contextInitialized(ServletContextEvent sce)\n    {\t\n        //configure programmatic security\n        ServletRegistration.Dynamic rego = sce.getServletContext().addServlet(\"RegoTest\", RegTest.class.getName());\n        rego.addMapping(\"/rego/*\");\n        HttpConstraintElement constraintElement = new HttpConstraintElement(ServletSecurity.EmptyRoleSemantic.PERMIT, \n                                                                            ServletSecurity.TransportGuarantee.NONE, new String[]{\"admin\"});\n        ServletSecurityElement securityElement = new ServletSecurityElement(constraintElement, null);\n        Set<String> unchanged = rego.setServletSecurity(securityElement);\n        //System.err.println(\"Security constraints registered: \"+unchanged.isEmpty());\n\n        //Test that a security constraint from web.xml can't be overridden programmatically\n        ServletRegistration.Dynamic rego2 = sce.getServletContext().addServlet(\"RegoTest2\", RegTest.class.getName());\n        rego2.addMapping(\"/rego2/*\");\n        securityElement = new ServletSecurityElement(constraintElement, null);\n        unchanged = rego2.setServletSecurity(securityElement);\n        //System.err.println(\"Overridding web.xml constraints not possible:\" +!unchanged.isEmpty());\n\n    \t/* For servlet 3.0 */\n    \tFilterRegistration.Dynamic registration = sce.getServletContext().addFilter(\"TestFilter\",TestFilter.class.getName());\n        if (registration != null) //otherwise it was configured in web.xml\n        {\n    \t    registration.setInitParameter(\"remote\", \"false\");\n    \t    registration.setAsyncSupported(true);\n    \t    registration.addMappingForUrlPatterns(\n    \t        EnumSet.of(DispatcherType.ERROR,DispatcherType.ASYNC,DispatcherType.FORWARD,DispatcherType.INCLUDE,DispatcherType.REQUEST),\n    \t        true, \n    \t        new String[]{\"/*\"});\n        }\n    }","commit_id":"976d6e2203d10c38a50fba8eb6ae5dde2476da35","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testDatagramDetectorWiring() {\n        DnsDetector bean = (DnsDetector)m_applicationContext.getBean(\"dnsDetector\");\n        assertNotNull(bean);\n    }","id":76751,"modified_method":"@Test\n    public void testDatagramDetectorWiring() {\n        testWiredDetector(DnsDetector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDhcpDetectorWiring() {\n        DhcpDetector bean = (DhcpDetector) m_applicationContext.getBean(\"dhcpDetector\");\n        assertNotNull(bean);\n    }","id":76752,"modified_method":"@Test\n    public void testDhcpDetectorWiring() {\n        testWiredDetector(DhcpDetector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testJdbcDetectorWiring() {\n        JdbcDetector bean = (JdbcDetector) m_applicationContext.getBean(\"jdbcDetector\");\n        assertNotNull(bean);\n    }","id":76753,"modified_method":"@Test\n    public void testJdbcDetectorWiring() {\n        testWiredDetector(JdbcDetector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testJsr160DetectorWiring() {\n       Jsr160Detector bean = (Jsr160Detector) m_applicationContext.getBean(\"jsr160Detector\");\n       assertNotNull(bean);\n    }","id":76754,"modified_method":"@Test\n    public void testJsr160DetectorWiring() {\n        testWiredDetector(Jsr160Detector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRadiusDetectorWiring() {\n        RadiusAuthDetector bean = (RadiusAuthDetector) m_applicationContext.getBean(\"radiusAuthDetector\");\n        assertNotNull(bean);\n    }","id":76755,"modified_method":"@Test\n    public void testRadiusDetectorWiring() {\n        testWiredDetector(RadiusAuthDetector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSnmpDetectorWiring() {\n        SnmpDetector bean = (SnmpDetector) m_applicationContext.getBean(SnmpDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76756,"modified_method":"@Test\n    public void testSnmpDetectorWiring() {\n        testWiredDetector(SnmpDetector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testIcmpDetectorWiring(){\n        IcmpDetector bean = (IcmpDetector) m_applicationContext.getBean(IcmpDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76757,"modified_method":"@Test\n    public void testIcmpDetectorWiring(){\n        testWiredDetector(IcmpDetector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSmbDetectorWiring() {\n        SmbDetector bean = (SmbDetector) m_applicationContext.getBean(SmbDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76758,"modified_method":"@Test\n    public void testSmbDetectorWiring() {\n        testWiredDetector(SmbDetector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSshDetectorWiring() {\n        SshDetector bean = (SshDetector) m_applicationContext.getBean(\"sshDetector\");\n        assertNotNull(bean);\n    }","id":76759,"modified_method":"@Test\n    public void testSshDetectorWiring() {\n        testWiredDetector(SshDetector.class);\n    }","commit_id":"e4c0d786a61e52075580f6c01350d1e1407a5880","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDatagramDetectorWiring() {\n        DnsDetector bean = (DnsDetector)m_applicationContext.getBean(\"dnsDetector\");\n        assertNotNull(bean);\n    }","id":76760,"modified_method":"@Test\n    public void testDatagramDetectorWiring() {\n        testWiredDetector(DnsDetector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDhcpDetectorWiring() {\n        DhcpDetector bean = (DhcpDetector) m_applicationContext.getBean(\"dhcpDetector\");\n        assertNotNull(bean);\n    }","id":76761,"modified_method":"@Test\n    public void testDhcpDetectorWiring() {\n        testWiredDetector(DhcpDetector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testJdbcDetectorWiring() {\n        JdbcDetector bean = (JdbcDetector) m_applicationContext.getBean(\"jdbcDetector\");\n        assertNotNull(bean);\n    }","id":76762,"modified_method":"@Test\n    public void testJdbcDetectorWiring() {\n        testWiredDetector(JdbcDetector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testJsr160DetectorWiring() {\n       Jsr160Detector bean = (Jsr160Detector) m_applicationContext.getBean(\"jsr160Detector\");\n       assertNotNull(bean);\n    }","id":76763,"modified_method":"@Test\n    public void testJsr160DetectorWiring() {\n        testWiredDetector(Jsr160Detector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRadiusDetectorWiring() {\n        RadiusAuthDetector bean = (RadiusAuthDetector) m_applicationContext.getBean(\"radiusAuthDetector\");\n        assertNotNull(bean);\n    }","id":76764,"modified_method":"@Test\n    public void testRadiusDetectorWiring() {\n        testWiredDetector(RadiusAuthDetector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testIcmpDetectorWiring(){\n        IcmpDetector bean = (IcmpDetector) m_applicationContext.getBean(IcmpDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76765,"modified_method":"@Test\n    public void testIcmpDetectorWiring(){\n        testWiredDetector(IcmpDetector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSmbDetectorWiring() {\n        SmbDetector bean = (SmbDetector) m_applicationContext.getBean(SmbDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76766,"modified_method":"@Test\n    public void testSmbDetectorWiring() {\n        testWiredDetector(SmbDetector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSnmpDetectorWiring() {\n        SnmpDetector bean = (SnmpDetector) m_applicationContext.getBean(SnmpDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76767,"modified_method":"@Test\n    public void testSnmpDetectorWiring() {\n        testWiredDetector(SnmpDetector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSshDetectorWiring() {\n        SshDetector bean = (SshDetector) m_applicationContext.getBean(\"sshDetector\");\n        assertNotNull(bean);\n    }","id":76768,"modified_method":"@Test\n    public void testSshDetectorWiring() {\n        testWiredDetector(SshDetector.class);\n    }","commit_id":"c658e1e915055d65b11a4d35ae3f2b3b5149dec8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDatagramDetectorWiring() {\n        DnsDetector bean = (DnsDetector)m_applicationContext.getBean(\"dnsDetector\");\n        assertNotNull(bean);\n    }","id":76769,"modified_method":"@Test\n    public void testDatagramDetectorWiring() {\n        testWiredDetector(DnsDetector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDhcpDetectorWiring() {\n        DhcpDetector bean = (DhcpDetector) m_applicationContext.getBean(\"dhcpDetector\");\n        assertNotNull(bean);\n    }","id":76770,"modified_method":"@Test\n    public void testDhcpDetectorWiring() {\n        testWiredDetector(DhcpDetector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testJdbcDetectorWiring() {\n        JdbcDetector bean = (JdbcDetector) m_applicationContext.getBean(\"jdbcDetector\");\n        assertNotNull(bean);\n    }","id":76771,"modified_method":"@Test\n    public void testJdbcDetectorWiring() {\n        testWiredDetector(JdbcDetector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testJsr160DetectorWiring() {\n       Jsr160Detector bean = (Jsr160Detector) m_applicationContext.getBean(\"jsr160Detector\");\n       assertNotNull(bean);\n    }","id":76772,"modified_method":"@Test\n    public void testJsr160DetectorWiring() {\n        testWiredDetector(Jsr160Detector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRadiusDetectorWiring() {\n        RadiusAuthDetector bean = (RadiusAuthDetector) m_applicationContext.getBean(\"radiusAuthDetector\");\n        assertNotNull(bean);\n    }","id":76773,"modified_method":"@Test\n    public void testRadiusDetectorWiring() {\n        testWiredDetector(RadiusAuthDetector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testIcmpDetectorWiring(){\n        IcmpDetector bean = (IcmpDetector) m_applicationContext.getBean(IcmpDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76774,"modified_method":"@Test\n    public void testIcmpDetectorWiring(){\n        testWiredDetector(IcmpDetector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSnmpDetectorWiring() {\n        SnmpDetector bean = (SnmpDetector) m_applicationContext.getBean(SnmpDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76775,"modified_method":"@Test\n    public void testSnmpDetectorWiring() {\n        testWiredDetector(SnmpDetector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSmbDetectorWiring() {\n        SmbDetector bean = (SmbDetector) m_applicationContext.getBean(SmbDetector.class.getName());\n        assertNotNull(bean);\n    }","id":76776,"modified_method":"@Test\n    public void testSmbDetectorWiring() {\n        testWiredDetector(SmbDetector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSshDetectorWiring() {\n        SshDetector bean = (SshDetector) m_applicationContext.getBean(\"sshDetector\");\n        assertNotNull(bean);\n    }","id":76777,"modified_method":"@Test\n    public void testSshDetectorWiring() {\n        testWiredDetector(SshDetector.class);\n    }","commit_id":"0124b260cd14edfaeb7aeb6e450e990fdbf915e2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * {@inheritDoc #handleException(Throwable)}\n   * \n   * @return\n   * @throws Throwable\n   */\n  public boolean init( ) throws Throwable {\n    ExpandoMetaClass.enableGlobally( );\n    Logs.init( );\n    Thread.setDefaultUncaughtExceptionHandler( new UncaughtExceptionHandler( ) {\n      \n      @Override\n      public void uncaughtException( Thread t, Throwable e ) {\n        try {\n          String stack = Joiner.on( \"\\t\\n\" ).join( Thread.currentThread( ).getStackTrace( ) );\n          LOG.error( stack );\n          LOG.error( e, e );\n        } catch ( Exception ex ) {\n          try {\n            System.out.println( Joiner.on( \"\\t\\n\" ).join( Thread.currentThread( ).getStackTrace( ) ) );\n            e.printStackTrace( );\n            ex.printStackTrace( );\n          } catch ( Exception ex1 ) {\n            System.out.println( \"Failed because of badness in uncaught exception path.\" );\n            System.out.println( \"Thread:      \" + t.toString( ) );\n            System.out.println( \"Exception:   \" + e.getClass( ) );\n            System.out.println( \"Message:     \" + e.getMessage( ) );\n            System.out.println( \"All threads:\\n\" );\n            for ( Map.Entry<Thread, StackTraceElement[]> ent : Thread.getAllStackTraces( ).entrySet( ) ) {\n\n            }\n          }\n        }\n      }\n    } );\n    OrderedShutdown.initialize( );\n    BootstrapArgs.init( );\n    Security.addProvider( new BouncyCastleProvider( ) );\n    try {//GRZE:HACK: need to remove the nss add-on in deb based distros as it breaks ssl.\n      Groovyness.eval( \"import sun.security.jca.*; Providers.setProviderList( ProviderList.remove( Providers.@providerList,\\\"SunPKCS11-NSS\\\") );\" );\n    } catch ( Exception ex ) {\n      LOG.error( ex , ex );\n    }\n    try {\n      if ( !BootstrapArgs.isInitializeSystem( ) ) {\n        Bootstrap.init( );\n        Bootstrap.Stage stage = Bootstrap.transition( );\n        stage.load( );\n      }\n      return true;\n    } catch ( Throwable t ) {\n      SystemBootstrapper.handleException( t );\n      return false;\n    }\n  }","id":76778,"modified_method":"/**\n   * {@inheritDoc #handleException(Throwable)}\n   * \n   * @return\n   * @throws Throwable\n   */\n  public boolean init( ) throws Throwable {\n    ExpandoMetaClass.enableGlobally( );\n    Logs.init( );\n    Thread.setDefaultUncaughtExceptionHandler( new UncaughtExceptionHandler( ) {\n      \n      @Override\n      public void uncaughtException( Thread t, Throwable e ) {\n        try {\n          String stack = Joiner.on( \"\\t\\n\" ).join( Thread.currentThread( ).getStackTrace( ) );\n          LOG.error( stack );\n          LOG.error( e, e );\n        } catch ( Exception ex ) {\n          try {\n            System.out.println( Joiner.on( \"\\t\\n\" ).join( Thread.currentThread( ).getStackTrace( ) ) );\n            e.printStackTrace( );\n            ex.printStackTrace( );\n          } catch ( Exception ex1 ) {\n            System.out.println( \"Failed because of badness in uncaught exception path.\" );\n            System.out.println( \"Thread:      \" + t.toString( ) );\n            System.out.println( \"Exception:   \" + e.getClass( ) );\n            System.out.println( \"Message:     \" + e.getMessage( ) );\n            System.out.println( \"All threads:\\n\" );\n            for ( Map.Entry<Thread, StackTraceElement[]> ent : Thread.getAllStackTraces( ).entrySet( ) ) {\n\n            }\n          }\n        }\n      }\n    } );\n    OrderedShutdown.initialize( );\n    BootstrapArgs.init( );\n    if ( Security.getProvider( BouncyCastleProvider.PROVIDER_NAME ) == null ) {\n      if ( Security.getProviders().length > 4 ) {\n        Security.insertProviderAt( new BouncyCastleProvider( ), 4 ); // EUCA-5833\n      } else {\n        Security.addProvider( new BouncyCastleProvider( ) );\n      }\n    }\n    try {//GRZE:HACK: need to remove the nss add-on in deb based distros as it breaks ssl.\n      Groovyness.eval( \"import sun.security.jca.*; Providers.setProviderList( ProviderList.remove( Providers.@providerList,\\\"SunPKCS11-NSS\\\") );\" );\n    } catch ( Exception ex ) {\n      LOG.error( ex , ex );\n    }\n    try {\n      if ( !BootstrapArgs.isInitializeSystem( ) ) {\n        Bootstrap.init( );\n        Bootstrap.Stage stage = Bootstrap.transition( );\n        stage.load( );\n      }\n      return true;\n    } catch ( Throwable t ) {\n      SystemBootstrapper.handleException( t );\n      return false;\n    }\n  }","commit_id":"63a5b11351174bf7d3585aa190f0bed1005a8bbb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n\t * Load the BouncyCastle and other necessary providers, should be called once for initialization. \n\t * Currently this is done by CCNHandle.\n\t */\r\n\tpublic static void initializeProvider() {\r\n\t\tsynchronized(KeyManager.class) {\r\n\t\t\tif (null == BC_PROVIDER) {\n\t\t\t\tProvider bc = new BouncyCastleProvider();\r\n\t\t\t\tSecurity.addProvider(bc);\n\t\t\t\tBC_PROVIDER = bc;\n\t\t\t\tif (null != BC_PROVIDER)\n\t\t\t\t\tLog.info(\"KeyManager: Successfully initialized BouncyCastle provider.\");\n\t\t\t\telse\n\t\t\t\t\tLog.severe(\"ERROR: NULL default provider! Cannot load BouncyCastle!\");\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":76779,"modified_method":"/**\n\t * Load the BouncyCastle and other necessary providers, should be called once for initialization. \n\t * Currently this is done by CCNHandle.\n\t */\r\n\tpublic static void initializeProvider() {\r\n\t\tsynchronized(KeyManager.class) {\r\n\t\t\tif (null == BC_PROVIDER) {\n\t\t\t\tBC_PROVIDER = Security.getProvider(\"BC\");\n\t\t\t\tif (null == BC_PROVIDER) {\n\t\t\t\t\tProvider bc = new BouncyCastleProvider();\r\n\t\t\t\t\tint result = Security.addProvider(bc);\n\t\t\t\t\tBC_PROVIDER = bc;\n\t\t\t\t\tif (null != BC_PROVIDER) {\n\t\t\t\t\t\tif (result > 0) {\n\t\t\t\t\t\t\tLog.info(\"KeyManager: Successfully initialized BouncyCastle provider at position \" + result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLog.info(\"KeyManager: BouncyCastle provider already installed.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.severe(\"ERROR: NULL default provider! Cannot load BouncyCastle! Result of addProvider: \" + result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLog.info(\"KeyManager: BouncyCastle provider installed by default.\");\n\t\t\t\t}\n\t\t\t\tProvider checkProvider = Security.getProvider(\"BC\");\n\t\t\t\tif (null == checkProvider) {\n\t\t\t\t\tLog.severe(\"Could not load BouncyCastle provider back in!\");\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"fe6f65af12c3e7345227088b68854a39881462ab","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static boolean checkDefaultProvider() {\n\t\treturn ((null != BC_PROVIDER) && (Security.getProvider(\"BC\") != null));\n\t}","id":76780,"modified_method":"public static boolean checkDefaultProvider() {\n\t\tboolean test = true;\n\t\tif (null == BC_PROVIDER) {\n\t\t\ttest = false;\n\t\t\tLog.warning(\"checkDefaultProvider: initialization of BouncyCastle provider did not proceed properly, no BC_PROVIDER.\");\n\t\t}\n\t\tif (null == Security.getProvider(\"BC\")) {\n\t\t\ttest = false;\n\t\t\tLog.warning(\"checkDefaultProvider: cannot load BouncyCastle provider!\");\n\t\t}\n\t\treturn test;\n\t}","commit_id":"fe6f65af12c3e7345227088b68854a39881462ab","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Retrieve our default BouncyCastle provider.\n\t * @return the BouncyCastle provider instance\n\t */\r\n\tpublic static Provider getDefaultProvider() {\r\n\t\tif (null == BC_PROVIDER) {\r\n\t\t\tinitializeProvider();\r\n\t\t}\n\t\tif (null == BC_PROVIDER) {\n\t\t\tLog.severe(\"ERROR: NULL default provider! Cannot load BouncyCastle!\");\n\t\t}\r\n\t\treturn BC_PROVIDER;\r\n\t}","id":76781,"modified_method":"/**\n\t * Retrieve our default BouncyCastle provider.\n\t * @return the BouncyCastle provider instance\n\t */\r\n\tpublic static Provider getDefaultProvider() {\r\n\t\tif (null == BC_PROVIDER) {\r\n\t\t\tinitializeProvider();\r\n\t\t}\n\t\treturn BC_PROVIDER;\r\n\t}","commit_id":"60471c870920162b49a3f696facc6098ce25f13e","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Load the BouncyCastle and other necessary providers, should be called once for initialization. \n\t * Currently this is done by CCNHandle.\n\t */\r\n\tpublic static void initializeProvider() {\r\n\t\tsynchronized(KeyManager.class) {\r\n\t\t\tif (null == BC_PROVIDER) {\n\t\t\t\tBC_PROVIDER = Security.getProvider(\"BC\");\n\t\t\t\tif (null == BC_PROVIDER) {\n\t\t\t\t\tProvider bc = new BouncyCastleProvider();\r\n\t\t\t\t\tint result = Security.addProvider(bc);\n\t\t\t\t\tBC_PROVIDER = bc;\n\t\t\t\t\tif (null != BC_PROVIDER) {\n\t\t\t\t\t\tif (result > 0) {\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.INFO)) { \n\t\t\t\t\t\t\t\tLog.info(Log.FAC_KEYS, \"KeyManager: Successfully initialized BouncyCastle provider at position \" + result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.INFO)) { \n\t\t\t\t\t\t\t\tLog.info(Log.FAC_KEYS, \"KeyManager: BouncyCastle provider already installed.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.severe(\"ERROR: NULL default provider! Cannot load BouncyCastle! Result of addProvider: \" + result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.INFO)) { \n\t\t\t\t\t\tLog.info(Log.FAC_KEYS, \"KeyManager: BouncyCastle provider installed by default.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tProvider checkProvider = Security.getProvider(\"BC\");\n\t\t\t\tif (null == checkProvider) {\n\t\t\t\t\tLog.severe(\"Could not load BouncyCastle provider back in!\");\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":76782,"modified_method":"/**\n\t * Load the BouncyCastle and other necessary providers, should be called once for initialization. \n\t * Currently this is done by CCNHandle.\n\t */\r\n\tpublic static synchronized void initializeProvider() {\r\n\t\tif (BC_PROVIDER == null) {\n\t\t\t// first try and get it, in case some other code has already created it.\n\t\t\tBC_PROVIDER = Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);\n\t\t\t\n\t\t\t// it's not yet known to the Security class, so create it.\n\t\t\tif (BC_PROVIDER == null) {\n\t\t\t\tBC_PROVIDER = new BouncyCastleProvider();\r\n\t\t\t\tSecurity.addProvider(BC_PROVIDER);\n\t\t\t}\n\t\t}\r\n\t}","commit_id":"60471c870920162b49a3f696facc6098ce25f13e","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Unwraps an encrypted key, and decodes it into a Key of an algorithm type\n\t * specified by wrappedKeyAlgorithm.\n\t * @param unwrapKey the key to use to decrypt this wrapped key.\n\t * @param wrappedKeyAlgorithm the algorithm of the wrapped key, used in decoding it.\n\t * @return the decrypted key if successful.\n\t * @throws InvalidKeyException if we encounter an error using the unwrapKey to decrypt.\n\t * @throws NoSuchAlgorithmException if we do not recognize the wrappedKeyAlgorithm.\n\t **/\n\tpublic Key unwrapKey(Key unwrapKey, String wrappedKeyAlgorithm) \n\t\t\tthrows InvalidKeyException, NoSuchAlgorithmException {\n\n\t\tKey unwrappedKey = null;\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"wrap algorithm: \" + wrapAlgorithm() + \" wa for key \" +\n\t\t\t\t\twrapAlgorithmForKey(unwrapKey.getAlgorithm()));\n\t\t\tLog.info(\"unwrapKey: unwrapping {0} with {1}\", this, DataUtils.printHexBytes(wrappingKeyIdentifier(unwrapKey)));\n\t\t\tLog.info(\"Is BC provider OK? \" + KeyManager.checkDefaultProvider());\n\t\t}\n\t\tif (((null != wrapAlgorithm()) && (wrapAlgorithm().equalsIgnoreCase(\"AESWrapWithPad\"))) || \n\t\t\t\t\t\t\twrapAlgorithmForKey(unwrapKey.getAlgorithm()).equalsIgnoreCase(\"AESWrapWithPad\")) {\n\t\t\tunwrappedKey = AESUnwrapWithPad(unwrapKey, wrappedKeyAlgorithm, encryptedKey(), 0, encryptedKey().length);\n\t\t} else {\n\t\t\tCipher unwrapCipher = null;\n\t\t\ttry {\n\t\t\t\tif (null != wrapAlgorithm()) {\n\t\t\t\t\tunwrapCipher = Cipher.getInstance(wrapAlgorithm());\n\t\t\t\t} else {\n\t\t\t\t\tunwrapCipher = Cipher.getInstance(wrapAlgorithmForKey(unwrapKey.getAlgorithm()));\n\t\t\t\t}\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tLog.warning(\"Unexpected NoSuchAlgorithmException attempting to instantiate wrapping algorithm.\");\n\t\t\t\tthrow new InvalidKeyException(\"Unexpected NoSuchAlgorithmException attempting to instantiate wrapping algorithm.\");\n\t\t\t} catch (NoSuchPaddingException e) {\n\t\t\t\tLog.warning(\"Unexpected NoSuchPaddingException attempting to instantiate wrapping algorithm.\");\n\t\t\t\tthrow new InvalidKeyException(\"Unexpected NoSuchPaddingException attempting to instantiate wrapping algorithm\");\n\t\t\t}\n\n\t\t\tunwrapCipher.init(Cipher.UNWRAP_MODE, unwrapKey);\n\t\t\tint keyType = getCipherType(wrappedKeyAlgorithm);\n\n\t\t\tif (null != encryptedNonceKey()) {\n\t\t\t\ttry {\n\t\t\t\t\tKey nonceKey = null;\n\t\t\t\t\t\n\t\t\t\t\t// Cope with GC memory corruption\n\t\t\t\t\tSignatureLocks.unwrapLock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnonceKey = unwrapCipher.unwrap(encryptedNonceKey(), NONCE_KEY_ALGORITHM, Cipher.SECRET_KEY);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tSignatureLocks.unwrapUnock();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Cipher nonceKeyCipher = Cipher.getInstance(wrapAlgorithmForKey(NONCE_KEY_ALGORITHM));\n\t\t\t\t\t//nonceKeyCipher.init(Cipher.UNWRAP_MODE, nonceKey);\n\t\t\t\t\t//unwrappedKey = nonceKeyCipher.unwrap(encryptedKey(), wrappedKeyAlgorithm, keyType);\n\t\t\t\t\tunwrappedKey = AESUnwrapWithPad(nonceKey, wrappedKeyAlgorithm, encryptedKey(), 0, encryptedKey().length);\n\n\t\t\t\t} catch(NoSuchAlgorithmException nsex) {\n\t\t\t\t\tLog.warning(\"Configuration error: Unknown default nonce key algorithm: \" + NONCE_KEY_ALGORITHM);\n\t\t\t\t\tLog.warningStackTrace(nsex);\n\t\t\t\t\tthrow new RuntimeException(\"Configuration error: Unknown default nonce key algorithm: \" + NONCE_KEY_ALGORITHM);\t    \t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Cope with GC memory corruption\n\t\t\t\tSignatureLocks.unwrapLock();\n\t\t\t\ttry {\n\t\t\t\t\tunwrappedKey = unwrapCipher.unwrap(encryptedKey(), wrappedKeyAlgorithm, keyType);\n\t\t\t\t} finally {\n\t\t\t\t\tSignatureLocks.unwrapUnock();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t    return unwrappedKey;\n\t}","id":76783,"modified_method":"/**\n\t * Unwraps an encrypted key, and decodes it into a Key of an algorithm type\n\t * specified by wrappedKeyAlgorithm.\n\t * @param unwrapKey the key to use to decrypt this wrapped key.\n\t * @param wrappedKeyAlgorithm the algorithm of the wrapped key, used in decoding it.\n\t * @return the decrypted key if successful.\n\t * @throws InvalidKeyException if we encounter an error using the unwrapKey to decrypt.\n\t * @throws NoSuchAlgorithmException if we do not recognize the wrappedKeyAlgorithm.\n\t **/\n\tpublic Key unwrapKey(Key unwrapKey, String wrappedKeyAlgorithm) \n\t\t\tthrows InvalidKeyException, NoSuchAlgorithmException {\n\n\t\tKey unwrappedKey = null;\n\t\tif (Log.isLoggable(Level.INFO)) {\n\t\t\tLog.info(\"wrap algorithm: \" + wrapAlgorithm() + \" wa for key \" +\n\t\t\t\t\twrapAlgorithmForKey(unwrapKey.getAlgorithm()));\n\t\t\tLog.info(\"unwrapKey: unwrapping {0} with {1}\", this, DataUtils.printHexBytes(wrappingKeyIdentifier(unwrapKey)));\n\t\t}\n\t\tif (((null != wrapAlgorithm()) && (wrapAlgorithm().equalsIgnoreCase(\"AESWrapWithPad\"))) || \n\t\t\t\t\t\t\twrapAlgorithmForKey(unwrapKey.getAlgorithm()).equalsIgnoreCase(\"AESWrapWithPad\")) {\n\t\t\tunwrappedKey = AESUnwrapWithPad(unwrapKey, wrappedKeyAlgorithm, encryptedKey(), 0, encryptedKey().length);\n\t\t} else {\n\t\t\tCipher unwrapCipher = null;\n\t\t\ttry {\n\t\t\t\tif (null != wrapAlgorithm()) {\n\t\t\t\t\tunwrapCipher = Cipher.getInstance(wrapAlgorithm());\n\t\t\t\t} else {\n\t\t\t\t\tunwrapCipher = Cipher.getInstance(wrapAlgorithmForKey(unwrapKey.getAlgorithm()));\n\t\t\t\t}\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tLog.warning(\"Unexpected NoSuchAlgorithmException attempting to instantiate wrapping algorithm.\");\n\t\t\t\tthrow new InvalidKeyException(\"Unexpected NoSuchAlgorithmException attempting to instantiate wrapping algorithm.\");\n\t\t\t} catch (NoSuchPaddingException e) {\n\t\t\t\tLog.warning(\"Unexpected NoSuchPaddingException attempting to instantiate wrapping algorithm.\");\n\t\t\t\tthrow new InvalidKeyException(\"Unexpected NoSuchPaddingException attempting to instantiate wrapping algorithm\");\n\t\t\t}\n\n\t\t\tunwrapCipher.init(Cipher.UNWRAP_MODE, unwrapKey);\n\t\t\tint keyType = getCipherType(wrappedKeyAlgorithm);\n\n\t\t\tif (null != encryptedNonceKey()) {\n\t\t\t\ttry {\n\t\t\t\t\tKey nonceKey = null;\n\t\t\t\t\t\n\t\t\t\t\t// Cope with GC memory corruption\n\t\t\t\t\tSignatureLocks.unwrapLock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnonceKey = unwrapCipher.unwrap(encryptedNonceKey(), NONCE_KEY_ALGORITHM, Cipher.SECRET_KEY);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tSignatureLocks.unwrapUnock();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Cipher nonceKeyCipher = Cipher.getInstance(wrapAlgorithmForKey(NONCE_KEY_ALGORITHM));\n\t\t\t\t\t//nonceKeyCipher.init(Cipher.UNWRAP_MODE, nonceKey);\n\t\t\t\t\t//unwrappedKey = nonceKeyCipher.unwrap(encryptedKey(), wrappedKeyAlgorithm, keyType);\n\t\t\t\t\tunwrappedKey = AESUnwrapWithPad(nonceKey, wrappedKeyAlgorithm, encryptedKey(), 0, encryptedKey().length);\n\n\t\t\t\t} catch(NoSuchAlgorithmException nsex) {\n\t\t\t\t\tLog.warning(\"Configuration error: Unknown default nonce key algorithm: \" + NONCE_KEY_ALGORITHM);\n\t\t\t\t\tLog.warningStackTrace(nsex);\n\t\t\t\t\tthrow new RuntimeException(\"Configuration error: Unknown default nonce key algorithm: \" + NONCE_KEY_ALGORITHM);\t    \t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Cope with GC memory corruption\n\t\t\t\tSignatureLocks.unwrapLock();\n\t\t\t\ttry {\n\t\t\t\t\tunwrappedKey = unwrapCipher.unwrap(encryptedKey(), wrappedKeyAlgorithm, keyType);\n\t\t\t\t} finally {\n\t\t\t\t\tSignatureLocks.unwrapUnock();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t    return unwrappedKey;\n\t}","commit_id":"60471c870920162b49a3f696facc6098ce25f13e","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n  public PsiReference findReferenceAt(int offset) {\n    PsiReference mirrorRef = getMirror().findReferenceAt(offset);\n    if (mirrorRef == null) return null;\n    PsiElement mirrorElement = mirrorRef.getElement();\n    PsiElement element = mirrorToElement(mirrorElement);\n    if (element == null) return null;\n    return element.getReference();\n  }","id":76784,"modified_method":"@Override\n  public PsiReference findReferenceAt(int offset) {\n    PsiElement mirror = getMirror();\n    if (mirror == null) return null;\n    PsiReference mirrorRef = mirror.findReferenceAt(offset);\n    if (mirrorRef == null) return null;\n    PsiElement mirrorElement = mirrorRef.getElement();\n    PsiElement element = mirrorToElement(mirrorElement);\n    if (element == null) return null;\n    return element.getReference();\n  }","commit_id":"a1f59ee4061f2f8a585fff46feebb0da35654f9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public char[] textToCharArray() {\n    return getMirror().textToCharArray();\n  }","id":76785,"modified_method":"@Override\n  @NotNull\n  public char[] textToCharArray() {\n    PsiElement mirror = getMirror();\n    return mirror != null ? mirror.textToCharArray() : ArrayUtil.EMPTY_CHAR_ARRAY;\n  }","commit_id":"a1f59ee4061f2f8a585fff46feebb0da35654f9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement findElementAt(int offset) {\n    PsiElement mirrorAt = getMirror().findElementAt(offset);\n    while (true) {\n      if (mirrorAt == null) return null;\n      PsiElement elementAt = mirrorToElement(mirrorAt);\n      if (elementAt != null) return elementAt;\n      mirrorAt = mirrorAt.getParent();\n    }\n  }","id":76786,"modified_method":"@Override\n  public PsiElement findElementAt(int offset) {\n    PsiElement mirror = getMirror();\n    if (mirror == null) return null;\n    PsiElement mirrorAt = mirror.findElementAt(offset);\n    while (true) {\n      if (mirrorAt == null) return null;\n      PsiElement elementAt = mirrorToElement(mirrorAt);\n      if (elementAt != null) return elementAt;\n      mirrorAt = mirrorAt.getParent();\n    }\n  }","commit_id":"a1f59ee4061f2f8a585fff46feebb0da35654f9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"DetailsPanel(@NotNull VcsLogDataHolder logDataHolder, @NotNull VcsLogGraphTable graphTable, @NotNull VcsLogColorManager colorManager,\n               @NotNull VisiblePack initialDataPack) {\n    myLogDataHolder = logDataHolder;\n    myGraphTable = graphTable;\n    myDataPack = initialDataPack;\n\n    myRefsPanel = new RefsPanel(colorManager);\n\n    final JScrollPane scrollPane = new JBScrollPane() {\n      @Override\n      public Border getBorder() {\n        return getVerticalScrollBar().isVisible() ? super.getBorder() : null;\n      }\n    };\n    myMessageDataPanel = new DataPanel(logDataHolder.getProject()) {\n      @Override\n      public Dimension getPreferredSize() {\n        Dimension size = super.getPreferredSize();\n        size.width = scrollPane.getViewport().getWidth() - 5;\n        return size;\n      }\n    };\n    scrollPane.setOpaque(false);\n    scrollPane.getViewport().setOpaque(false);\n    scrollPane.setViewportView(myMessageDataPanel);\n\n    myContainingBranchesPanel = new ContainingBranchesPanel();\n    myMessageLabel = new JLabel();\n    myMessageLabel.setForeground(UIUtil.getInactiveTextColor());\n    myMessageLabel.setHorizontalAlignment(SwingConstants.CENTER);\n    myMessageLabel.setVerticalAlignment(SwingConstants.CENTER);\n\n    myLoadingPanel = new JBLoadingPanel(new BorderLayout(), logDataHolder, ProgressWindow.DEFAULT_PROGRESS_DIALOG_POSTPONE_TIME_MILLIS);\n    myLoadingPanel.add(myRefsPanel, BorderLayout.NORTH);\n    myLoadingPanel.add(scrollPane, BorderLayout.CENTER);\n    myLoadingPanel.add(myContainingBranchesPanel, BorderLayout.SOUTH);\n    myLoadingPanel.setOpaque(false);\n\n    setLayout(new CardLayout());\n    add(myLoadingPanel, STANDARD_LAYER);\n    add(myMessageLabel, MESSAGE_LAYER);\n\n    setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));\n    showMessage(\"No commits selected\");\n  }","id":76787,"modified_method":"DetailsPanel(@NotNull VcsLogDataHolder logDataHolder,\n               @NotNull VcsLogGraphTable graphTable,\n               @NotNull VcsLogColorManager colorManager,\n               @NotNull VisiblePack initialDataPack) {\n    myLogDataHolder = logDataHolder;\n    myGraphTable = graphTable;\n    myDataPack = initialDataPack;\n\n    myRefsPanel = new RefsPanel(colorManager);\n    myCommitDetailsPanel = new DataPanel(logDataHolder.getProject());\n\n    final JScrollPane scrollPane =\n      ScrollPaneFactory.createScrollPane(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    JPanel content = new JPanel(new MigLayout(\"flowy, ins 0, hidemode 3, gapy 0\")) {\n      @Override\n      public Dimension getPreferredSize() {\n        Dimension size = super.getPreferredSize();\n        size.width = scrollPane.getViewport().getWidth() - 5;\n        return size;\n      }\n    };\n    content.setOpaque(false);\n    scrollPane.setOpaque(false);\n    scrollPane.getViewport().setOpaque(false);\n    scrollPane.setViewportView(content);\n    content.add(myRefsPanel, \"\");\n    content.add(myCommitDetailsPanel, \"\");\n\n    myLoadingPanel = new JBLoadingPanel(new BorderLayout(), logDataHolder, ProgressWindow.DEFAULT_PROGRESS_DIALOG_POSTPONE_TIME_MILLIS);\n    myLoadingPanel.add(scrollPane);\n\n    myMessagePanel = new MessagePanel();\n    setBackground(UIUtil.getTableBackground());\n\n    setLayout(new CardLayout());\n    add(myLoadingPanel, STANDARD_LAYER);\n    add(myMessagePanel, MESSAGE_LAYER);\n\n    showMessage(\"No commits selected\");\n  }","commit_id":"f7c31b74b6f7893457eb2e423489317208a299bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Color getBackground() {\n    return UIUtil.getTableBackground();\n  }","id":76788,"modified_method":"@Override\n  public Color getBackground() {\n    return getDetailsBackground();\n  }","commit_id":"f7c31b74b6f7893457eb2e423489317208a299bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Dimension getPreferredSize() {\n      Dimension size = super.getPreferredSize();\n      size.height = Math.max(size.height, 7 * getFontMetrics(getFont()).getHeight());\n      return size;\n    }","id":76789,"modified_method":"@Override\n    public Dimension getPreferredSize() {\n      Dimension size = super.getPreferredSize();\n      size.height = Math.max(size.height, 4 * getFontMetrics(getFont()).getHeight());\n      return size;\n    }","commit_id":"f7c31b74b6f7893457eb2e423489317208a299bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showMessage(String text) {\n    myLoadingPanel.stopLoading();\n    ((CardLayout)getLayout()).show(this, MESSAGE_LAYER);\n    myMessageLabel.setText(text);\n  }","id":76790,"modified_method":"private void showMessage(String text) {\n    myLoadingPanel.stopLoading();\n    ((CardLayout)getLayout()).show(this, MESSAGE_LAYER);\n    myMessagePanel.setText(text);\n  }","commit_id":"f7c31b74b6f7893457eb2e423489317208a299bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void valueChanged(@Nullable ListSelectionEvent notUsed) {\n    int[] rows = myGraphTable.getSelectedRows();\n    if (rows.length < 1) {\n      showMessage(\"No commits selected\");\n    }\n    else if (rows.length > 1) {\n      showMessage(\"Several commits selected\");\n    }\n    else {\n      ((CardLayout)getLayout()).show(this, STANDARD_LAYER);\n      int row = rows[0];\n      GraphTableModel tableModel = (GraphTableModel)myGraphTable.getModel();\n      Hash hash = tableModel.getHashAtRow(row);\n      VcsFullCommitDetails commitData = myLogDataHolder.getCommitDetailsGetter().getCommitData(row, tableModel);\n      if (commitData == null || hash == null) {\n        showMessage(\"No commits selected\");\n        return;\n      }\n      if (commitData instanceof LoadingDetails) {\n        myLoadingPanel.startLoading();\n        myMessageDataPanel.setData(null);\n        myRefsPanel.setRefs(Collections.<VcsRef>emptyList());\n      }\n      else {\n        myLoadingPanel.stopLoading();\n        myMessageDataPanel.setData(commitData);\n        myRefsPanel.setRefs(sortRefs(hash, commitData.getRoot()));\n      }\n\n      List<String> branches = null;\n      if (!(commitData instanceof LoadingDetails)) {\n        branches = myLogDataHolder.getContainingBranchesGetter().requestContainingBranches(commitData.getRoot(), hash);\n      }\n      myContainingBranchesPanel.setBranches(branches);\n    }\n  }","id":76791,"modified_method":"@Override\n  public void valueChanged(@Nullable ListSelectionEvent notUsed) {\n    int[] rows = myGraphTable.getSelectedRows();\n    if (rows.length < 1) {\n      showMessage(\"No commits selected\");\n    }\n    else if (rows.length > 1) {\n      showMessage(\"Several commits selected\");\n    }\n    else {\n      ((CardLayout)getLayout()).show(this, STANDARD_LAYER);\n      int row = rows[0];\n      GraphTableModel tableModel = (GraphTableModel)myGraphTable.getModel();\n      Hash hash = tableModel.getHashAtRow(row);\n      VcsFullCommitDetails commitData = myLogDataHolder.getCommitDetailsGetter().getCommitData(row, tableModel);\n      if (commitData == null || hash == null) {\n        showMessage(\"No commits selected\");\n        return;\n      }\n      if (commitData instanceof LoadingDetails) {\n        myLoadingPanel.startLoading();\n        myCommitDetailsPanel.setData(null);\n        myRefsPanel.setRefs(Collections.<VcsRef>emptyList());\n      }\n      else {\n        myLoadingPanel.stopLoading();\n        myCommitDetailsPanel.setData(commitData);\n        myRefsPanel.setRefs(sortRefs(hash, commitData.getRoot()));\n      }\n\n      List<String> branches = null;\n      if (!(commitData instanceof LoadingDetails)) {\n        branches = myLogDataHolder.getContainingBranchesGetter().requestContainingBranches(commitData.getRoot(), hash);\n      }\n      myCommitDetailsPanel.setBranches(branches);\n    }\n  }","commit_id":"f7c31b74b6f7893457eb2e423489317208a299bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"RefsPanel(@NotNull VcsLogColorManager colorManager) {\n      myRefPainter = new RefPainter(colorManager, false);\n      myRefs = Collections.emptyList();\n      setPreferredSize(new Dimension(-1, PrintParameters.HEIGHT_CELL + UIUtil.DEFAULT_VGAP));\n      setOpaque(false);\n    }","id":76792,"modified_method":"RefsPanel(@NotNull VcsLogColorManager colorManager) {\n      super(new FlowLayout(FlowLayout.LEADING, 0, 2));\n      myRefPainter = new RefPainter(colorManager, false);\n      myRefs = Collections.emptyList();\n      setOpaque(false);\n    }","commit_id":"f7c31b74b6f7893457eb2e423489317208a299bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void setRefs(@NotNull List<VcsRef> refs) {\n      myRefs = refs;\n      setVisible(!myRefs.isEmpty());\n      repaint();\n    }","id":76793,"modified_method":"void setRefs(@NotNull List<VcsRef> refs) {\n      removeAll();\n      myRefs = refs;\n      for (VcsRef ref : refs) {\n        add(new SingleRefPanel(myRefPainter, ref));\n      }\n      setVisible(!myRefs.isEmpty());\n      revalidate();\n      repaint();\n    }","commit_id":"f7c31b74b6f7893457eb2e423489317208a299bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void setData(@Nullable VcsFullCommitDetails commit) {\n      if (commit == null) {\n        setText(\"\");\n      }\n      else {\n        String body = commit.getId().toShortString() + \" \" + getAuthorText(commit) + \"<br>\" + getMessageText(commit);\n        setText(\"<html><head>\" + UIUtil.getCssFontDeclaration(UIUtil.getLabelFont()) + \"<\/head><body>\" + body + \"<\/body><\/html>\");\n        setCaretPosition(0);\n      }\n      revalidate();\n      repaint();\n    }","id":76794,"modified_method":"void setData(@Nullable VcsFullCommitDetails commit) {\n      if (commit == null) {\n        myMainText = null;\n      }\n      else {\n        String body = getMessageText(commit);\n        String header = commit.getId().toShortString() + \" \" + getAuthorText(commit);\n        myMainText = header + \"<br/>\" + body;\n      }\n      update();\n    }","commit_id":"f7c31b74b6f7893457eb2e423489317208a299bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     *  @return Least recently pushed Object.\n     */\n\tpublic final synchronized T pop() {\n        if ( list.size() > 0 ) {\n\t\t\treturn (hash.remove(((QItem<T>) list.pop()).obj)).obj;\n        } else {\n            return null;\n        }\n    }","id":76795,"modified_method":"/**\n     *  @return Least recently pushed Object.\n     */\n\tpublic final synchronized T pop() {\n        if ( list.size() > 0 ) {\n\t\t\treturn hash.remove(list.pop().obj).obj;\n        } else {\n            return null;\n        }\n    }","commit_id":"91eacaf8b3063e35ce424dfeacf57bcd94924dff","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * @return Least recently pushed value.\n     */\n    public final synchronized Object popValue() {\n        if ( list.size() > 0 ) {\n            return (\thash.remove(((QItem) list.pop()).obj)).value;\n        } else {\n            return null;\n        }\n    }","id":76796,"modified_method":"/**\n     * @return Least recently pushed value.\n     */\n    public final synchronized Object popValue() {\n        if ( list.size() > 0 ) {\n\t\t\treturn hash.remove(list.pop().obj).value;\n        } else {\n            return null;\n        }\n    }","commit_id":"c35ede5f9d237f5afce6d2b84c36f99c1422d8c7","url":"https://github.com/freenet/fred"},{"original_method":"public Object nextElement() {\n            return ((QItem) source.nextElement()).obj;\n        }","id":76797,"modified_method":"public K nextElement() {\n\t\t\treturn source.nextElement().obj;\n        }","commit_id":"c35ede5f9d237f5afce6d2b84c36f99c1422d8c7","url":"https://github.com/freenet/fred"},{"original_method":"public final synchronized Object peekValue() {\n        if ( list.size() > 0 ) {\n            return (\thash.get(((QItem) list.tail()).obj)).value;\n        } else {\n            return null;\n        }\n\t}","id":76798,"modified_method":"public final synchronized Object peekValue() {\n        if ( list.size() > 0 ) {\n\t\t\treturn hash.get(list.tail().obj).value;\n        } else {\n            return null;\n        }\n\t}","commit_id":"c35ede5f9d237f5afce6d2b84c36f99c1422d8c7","url":"https://github.com/freenet/fred"},{"original_method":"public Object nextElement() {\n            return ((QItem) source.nextElement()).value;\n        }","id":76799,"modified_method":"public V nextElement() {\n\t\t\treturn source.nextElement().value;\n        }","commit_id":"c35ede5f9d237f5afce6d2b84c36f99c1422d8c7","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     *  @return Least recently pushed key.\n     */\n    public final synchronized Object popKey() {\n        if ( list.size() > 0 ) {\n            return (\thash.remove(((QItem) list.pop()).obj)).obj;\n        } else {\n            return null;\n        }\n    }","id":76800,"modified_method":"/**\n     *  @return Least recently pushed key.\n     */\n    public final synchronized Object popKey() {\n        if ( list.size() > 0 ) {\n\t\t\treturn hash.remove(list.pop().obj).obj;\n        } else {\n            return null;\n        }\n    }","commit_id":"c35ede5f9d237f5afce6d2b84c36f99c1422d8c7","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * push to bottom (least recently used position)\n     */\n\tpublic synchronized void pushLeast(Object obj) {\n        QItem insert = (QItem)hash.get(obj);        \n        if (insert == null) {\n            insert = new QItem(obj);\n            hash.put(obj,insert);\n        } else {\n            list.remove(insert);\n        }\n\n        list.push(insert);\n\t}","id":76801,"modified_method":"/**\n     * push to bottom (least recently used position)\n     */\n\tpublic synchronized void pushLeast(T obj) {\n\t\tQItem<T> insert = hash.get(obj);        \n        if (insert == null) {\n            insert = new QItem<T>(obj);\n            hash.put(obj,insert);\n        } else {\n            list.remove(insert);\n        }\n\n        list.push(insert);\n\t}","commit_id":"a9b314d4c38767b523b7b6fce89fd0913dc38f69","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Return the objects in the queue as an array in an arbitrary and meaningless\n     * order.\n\t * @param array The array to fill in. If it is too small a new array of the same type will be allocated.\n     */\n\tpublic synchronized Object[] toArray(Object[] array) {\n\t\treturn hash.keySet().toArray(array);\n\t}","id":76802,"modified_method":"/**\n     * Return the objects in the queue as an array in an arbitrary and meaningless\n     * order.\n\t * @param array The array to fill in. If it is too small a new array of the same type will be allocated.\n     */\n\tpublic synchronized <E> E[] toArray(E[] array) {\n\t\treturn hash.keySet().toArray(array);\n\t}","commit_id":"a9b314d4c38767b523b7b6fce89fd0913dc38f69","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Return the objects in the queue as an array. The <strong>least<\/strong>\n\t * recently used object is in <tt>[0]<\/tt>, the <strong>most<\/strong>\n\t * recently used object is in <tt>[array.length-1]<\/tt>.\n\t * \n\t * @param array\n\t *            The array to fill in. If it is too small a new array of the\n\t *            same type will be allocated.\n\t */\n\tpublic synchronized Object[] toArrayOrdered(Object[] array) {\n\t\tarray = toArray(array);\n\t\tint listSize = list.size();\n\t\tif(array.length != listSize)\n\t\t\tthrow new IllegalStateException(\"array.length=\"+array.length+\" but list.size=\"+listSize);\n\t\tint x = 0;\n\t\tfor(Enumeration e = list.reverseElements();e.hasMoreElements();) {\n\t\t\tarray[x++] = ((QItem)e.nextElement()).obj;\n\t\t}\n\t\treturn array;\n\t}","id":76803,"modified_method":"/**\n\t * Return the objects in the queue as an array. The <strong>least<\/strong>\n\t * recently used object is in <tt>[0]<\/tt>, the <strong>most<\/strong>\n\t * recently used object is in <tt>[array.length-1]<\/tt>.\n\t * \n\t * @param array\n\t *            The array to fill in. If it is too small a new array of the\n\t *            same type will be allocated.\n\t */\n\tpublic synchronized <E> E[] toArrayOrdered(E[] array) {\n\t\tarray = toArray(array);\n\t\tint listSize = list.size();\n\t\tif(array.length != listSize)\n\t\t\tthrow new IllegalStateException(\"array.length=\"+array.length+\" but list.size=\"+listSize);\n\t\tint x = 0;\n\t\tfor(Enumeration<QItem<T>> e = list.reverseElements();e.hasMoreElements();) {\n\t\t\tarray[x++] = (E) e.nextElement().obj;\n\t\t}\n\t\treturn array;\n\t}","commit_id":"a9b314d4c38767b523b7b6fce89fd0913dc38f69","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     *  @return Least recently pushed Object.\n     */\n    public final synchronized Object pop() {\n        if ( list.size() > 0 ) {\n            return ((QItem)hash.remove(((QItem)list.pop()).obj)).obj;\n        } else {\n            return null;\n        }\n    }","id":76804,"modified_method":"/**\n     *  @return Least recently pushed Object.\n     */\n    public final synchronized T pop() {\n        if ( list.size() > 0 ) {\n            return hash.remove(list.pop().obj).obj;\n        } else {\n            return null;\n        }\n    }","commit_id":"a9b314d4c38767b523b7b6fce89fd0913dc38f69","url":"https://github.com/freenet/fred"},{"original_method":"public Object nextElement() {\n            return ((QItem) source.nextElement()).obj;\n        }","id":76805,"modified_method":"public T nextElement() {\n\t\t\treturn source.nextElement().obj;\n        }","commit_id":"a9b314d4c38767b523b7b6fce89fd0913dc38f69","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Return the objects in the queue as an array. The <strong>least<\/strong>\n\t * recently used object is in <tt>[0]<\/tt>, the <strong>most<\/strong>\n\t * recently used object is in <tt>[array.length-1]<\/tt>.\n\t */\n\tpublic synchronized Object[] toArrayOrdered() {\n\t\tObject[] array = new Object[list.size()];\n\t\tint x = 0;\n\t\tfor(Enumeration e = list.reverseElements();e.hasMoreElements();) {\n\t\t\tarray[x++] = ((QItem)e.nextElement()).obj;\n\t\t}\n\t\treturn array;\n\t}","id":76806,"modified_method":"/**\n\t * Return the objects in the queue as an array. The <strong>least<\/strong>\n\t * recently used object is in <tt>[0]<\/tt>, the <strong>most<\/strong>\n\t * recently used object is in <tt>[array.length-1]<\/tt>.\n\t */\n\tpublic synchronized Object[] toArrayOrdered() {\n\t\tObject[] array = new Object[list.size()];\n\t\tint x = 0;\n\t\tfor(Enumeration<QItem<T>> e = list.reverseElements();e.hasMoreElements();) {\n\t\t\tarray[x++] = e.nextElement().obj;\n\t\t}\n\t\treturn array;\n\t}","commit_id":"a9b314d4c38767b523b7b6fce89fd0913dc38f69","url":"https://github.com/freenet/fred"},{"original_method":"protected DDMTemplate addTemplate(\n\t\t\tlong classNameId, long classPK, String templateKey, String name,\n\t\t\tString type, String mode, String language, String script)\n\t\tthrows Exception {\n\n\t\tlong userId = TestPropsValues.getUserId();\n\n\t\tlong groupId = TestPropsValues.getGroupId();\n\n\t\tMap<Locale, String> nameMap = getDefaultLocaleMap(name);\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\treturn DDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, classNameId, classPK, templateKey, nameMap, null,\n\t\t\ttype, mode, language, script, serviceContext);\n\t}","id":76807,"modified_method":"protected DDMTemplate addTemplate(\n\t\t\tlong classNameId, long classPK, String templateKey, String name,\n\t\t\tString type, String mode, String language, String script)\n\t\tthrows Exception {\n\n\t\treturn DDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tTestPropsValues.getUserId(), TestPropsValues.getGroupId(),\n\t\t\tclassNameId, classPK, templateKey, getDefaultLocaleMap(name), null,\n\t\t\ttype, mode, language, script, ServiceTestUtil.getServiceContext());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String readText(String filename) {\n\t\tClass<?> clazz = getClass();\n\n\t\tInputStream inputStream = clazz.getResourceAsStream(\n\t\t\t\"dependencies/\" + filename);\n\n\t\tString text = null;\n\t\ttry {\n\t\t\ttext = StringUtil.read(inputStream);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\ttext = StringPool.BLANK;\n\t\t}\n\n\t\treturn text;\n\t}","id":76808,"modified_method":"protected String readText(String fileName) throws Exception {\n\t\tClass<?> clazz = getClass();\n\n\t\tInputStream inputStream = clazz.getResourceAsStream(\n\t\t\t\"dependencies/\" + fileName);\n\n\t\treturn StringUtil.read(inputStream);\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMTemplate addListTemplate(long classPK, String name)\n\t\tthrows Exception {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(DDMStructure.class);\n\n\t\treturn addListTemplate(classNameId, classPK, name);\n\t}","id":76809,"modified_method":"protected DDMTemplate addListTemplate(long classPK, String name)\n\t\tthrows Exception {\n\n\t\treturn addListTemplate(\n\t\t\tPortalUtil.getClassNameId(DDMStructure.class), classPK, name);\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMStructure addStructure(long classNameId, String name)\n\t\tthrows Exception {\n\n\t\tString storageType = StorageType.XML.getValue();\n\n\t\tString xsd = getTestStructureXsd(storageType);\n\n\t\tint type =  DDMStructureConstants.TYPE_DEFAULT;\n\n\t\treturn addStructure(classNameId, null, name, xsd, storageType, type);\n\t}","id":76810,"modified_method":"protected DDMStructure addStructure(long classNameId, String name)\n\t\tthrows Exception {\n\n\t\tString storageType = StorageType.XML.getValue();\n\n\t\treturn addStructure(\n\t\t\tclassNameId, null, name, getTestStructureXsd(storageType),\n\t\t\tstorageType, DDMStructureConstants.TYPE_DEFAULT);\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMTemplate addDetailTemplate(long classPK, String name)\n\t\tthrows Exception {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(DDMStructure.class);\n\n\t\tString type = DDMTemplateConstants.TEMPLATE_TYPE_DETAIL;\n\n\t\tString mode = DDMTemplateConstants.TEMPLATE_MODE_CREATE;\n\n\t\tString language = \"xsd\";\n\n\t\tString script = getTestTemplateScript(language);\n\n\t\treturn addTemplate(\n\t\t\tclassNameId, classPK, name, type, mode, language, script);\n\t}","id":76811,"modified_method":"protected DDMTemplate addDetailTemplate(long classPK, String name)\n\t\tthrows Exception {\n\n\t\tString language = \"xsd\";\n\n\t\treturn addTemplate(\n\t\t\tPortalUtil.getClassNameId(DDMStructure.class), classPK, name,\n\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DETAIL,\n\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE, language,\n\t\t\tgetTestTemplateScript(language));\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMStructure addStructure(\n\t\t\tlong classNameId, String structureKey, String name, String xsd,\n\t\t\tString storageType, int type)\n\t\tthrows Exception {\n\n\t\tlong userId = TestPropsValues.getUserId();\n\n\t\tlong groupId = TestPropsValues.getGroupId();\n\n\t\tMap<Locale, String> nameMap = getDefaultLocaleMap(name);\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\treturn DDMStructureLocalServiceUtil.addStructure(\n\t\t\tuserId, groupId, classNameId, structureKey, nameMap, null, xsd,\n\t\t\tstorageType, type, serviceContext);\n\t}","id":76812,"modified_method":"protected DDMStructure addStructure(\n\t\t\tlong classNameId, String structureKey, String name, String xsd,\n\t\t\tString storageType, int type)\n\t\tthrows Exception {\n\n\t\treturn DDMStructureLocalServiceUtil.addStructure(\n\t\t\tTestPropsValues.getUserId(), TestPropsValues.getGroupId(),\n\t\t\tclassNameId, structureKey, getDefaultLocaleMap(name), null, xsd,\n\t\t\tstorageType, type, ServiceTestUtil.getServiceContext());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMTemplate addListTemplate(\n\t\t\tlong classNameId, long classPK, String name)\n\t\tthrows Exception {\n\n\t\tString type = DDMTemplateConstants.TEMPLATE_TYPE_LIST;\n\n\t\tString mode = StringPool.BLANK;\n\n\t\tString language = DDMTemplateConstants.LANG_TYPE_VM;\n\n\t\tString script = getTestTemplateScript(language);\n\n\t\treturn addTemplate(\n\t\t\tclassNameId, classPK, name, type, mode, language, script);\n\t}","id":76813,"modified_method":"protected DDMTemplate addListTemplate(\n\t\t\tlong classNameId, long classPK, String name)\n\t\tthrows Exception {\n\n\t\tString language = DDMTemplateConstants.LANG_TYPE_VM;\n\n\t\treturn addTemplate(\n\t\t\tclassNameId, classPK, name, DDMTemplateConstants.TEMPLATE_TYPE_LIST,\n\t\t\tStringPool.BLANK, language, getTestTemplateScript(language));\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDeleteStructureReferencedByTemplates() throws Exception {\n\t\tDDMStructure structure = addStructure(\n\t\t\t_testClassNameId, \"Test Structure\");\n\n\t\taddDetailTemplate(structure.getPrimaryKey(), \"Test List Template\");\n\t\taddListTemplate(structure.getPrimaryKey(), \"Test Detail Template\");\n\n\t\ttry {\n\t\t\tDDMStructureLocalServiceUtil.deleteStructure(\n\t\t\t\tstructure.getStructureId());\n\n\t\t\tAssert.fail(\n\t\t\t\t\"Should not be able to delete this structure because it is \" +\n\t\t\t\t\"referenced by templates\");\n\t\t}\n\t\tcatch (RequiredStructureException rse) {\n\t\t}\n\t}","id":76814,"modified_method":"@Test\n\tpublic void testDeleteStructureReferencedByTemplates() throws Exception {\n\t\tDDMStructure structure = addStructure(_classNameId, \"Test Structure\");\n\n\t\taddDetailTemplate(structure.getPrimaryKey(), \"Test List Template\");\n\t\taddListTemplate(structure.getPrimaryKey(), \"Test Detail Template\");\n\n\t\ttry {\n\t\t\tDDMStructureLocalServiceUtil.deleteStructure(\n\t\t\t\tstructure.getStructureId());\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (RequiredStructureException rse) {\n\t\t}\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddStructureWithoutXsd() throws Exception {\n\t\tString storageType = StorageType.XML.getValue();\n\t\tint type =  DDMStructureConstants.TYPE_DEFAULT;\n\n\t\ttry {\n\t\t\taddStructure(\n\t\t\t\t_testClassNameId, null, \"Test Structure\", StringPool.BLANK,\n\t\t\t\tstorageType, type);\n\n\t\t\tAssert.fail(\"Should not be able to add Structure because \" +\n\t\t\t\t\"xsd is empty\");\n\t\t}\n\t\tcatch (StructureXsdException sxe) {\n\t\t}\n\t}","id":76815,"modified_method":"@Test\n\tpublic void testAddStructureWithoutXsd() throws Exception {\n\t\ttry {\n\t\t\taddStructure(\n\t\t\t\t_classNameId, null, \"Test Structure\", StringPool.BLANK,\n\t\t\t\tStorageType.XML.getValue(), DDMStructureConstants.TYPE_DEFAULT);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (StructureXsdException sxe) {\n\t\t}\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearch() throws Exception {\n\t\tDDMStructure structure = addStructure(\n\t\t\t_testClassNameId, \"Test Structure 1\");\n\n\t\taddStructure(_testClassNameId, \"Test Structure 2\");\n\n\t\tlong[] groupIds = new long[] {structure.getGroupId()};\n\t\tlong[] classNameIds = new long[] {structure.getClassNameId()};\n\n\t\tList<DDMStructure> structures = DDMStructureLocalServiceUtil.search(\n\t\t\tstructure.getCompanyId(), groupIds, classNameIds, null, null,\n\t\t\tstructure.getStorageType(), structure.getType(), false, 0, 1, null);\n\n\t\tAssert.assertEquals(1, structures.size());\n\t}","id":76816,"modified_method":"@Test\n\tpublic void testSearch() throws Exception {\n\t\tDDMStructure structure = addStructure(_classNameId, \"Test Structure 1\");\n\n\t\taddStructure(_classNameId, \"Test Structure 2\");\n\n\t\tList<DDMStructure> structures = DDMStructureLocalServiceUtil.search(\n\t\t\tstructure.getCompanyId(), new long[] {structure.getGroupId()},\n\t\t\tnew long[] {structure.getClassNameId()}, null, null,\n\t\t\tstructure.getStorageType(), structure.getType(), false, 0, 1, null);\n\n\t\tAssert.assertEquals(1, structures.size());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMStructure updateStructure(DDMStructure structure)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\treturn DDMStructureLocalServiceUtil.updateStructure(\n\t\t\tstructure.getStructureId(), structure.getNameMap(),\n\t\t\tstructure.getDescriptionMap(), structure.getXsd(), serviceContext);\n\t}","id":76817,"modified_method":"protected DDMStructure updateStructure(DDMStructure structure)\n\t\tthrows Exception {\n\n\t\treturn DDMStructureLocalServiceUtil.updateStructure(\n\t\t\tstructure.getStructureId(), structure.getNameMap(),\n\t\t\tstructure.getDescriptionMap(), structure.getXsd(),\n\t\t\tServiceTestUtil.getServiceContext());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMStructure copyStructure(DDMStructure structure)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\treturn  DDMStructureLocalServiceUtil.copyStructure(\n\t\t\tstructure.getUserId(), structure.getStructureId(),\n\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\tserviceContext);\n\t}","id":76818,"modified_method":"protected DDMStructure copyStructure(DDMStructure structure)\n\t\tthrows Exception {\n\n\t\treturn DDMStructureLocalServiceUtil.copyStructure(\n\t\t\tstructure.getUserId(), structure.getStructureId(),\n\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\tServiceTestUtil.getServiceContext());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearchCount() throws Exception {\n\t\tlong companyId = TestPropsValues.getCompanyId();\n\t\tlong[] groupIds = new long[] {TestPropsValues.getGroupId()};\n\t\tlong[] classNameIds = new long[] {_testClassNameId};\n\t\tString name = \"Test Structure\";\n\t\tint type = DDMStructureConstants.TYPE_DEFAULT;\n\n\t\tint initCount = DDMStructureLocalServiceUtil.searchCount(\n\t\t\tcompanyId, groupIds, classNameIds, name, null, null, type, false);\n\t\t\n\t\taddStructure(_testClassNameId, name);\n\n\t\tint count = DDMStructureLocalServiceUtil.searchCount(\n\t\t\tcompanyId, groupIds, classNameIds, name, null, null, type, false);\n\n\t\tAssert.assertEquals(initCount + 1, count);\n\t}","id":76819,"modified_method":"@Test\n\tpublic void testSearchCount() throws Exception {\n\t\tint initialCount = DDMStructureLocalServiceUtil.searchCount(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tnew long[] {TestPropsValues.getGroupId()},\n\t\t\tnew long[] {_classNameId}, \"Test Structure\", null, null,\n\t\t\tDDMStructureConstants.TYPE_DEFAULT, false);\n\n\t\taddStructure(_classNameId, \"Test Structure\");\n\n\t\tint count = DDMStructureLocalServiceUtil.searchCount(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tnew long[] {TestPropsValues.getGroupId()},\n\t\t\tnew long[] {_classNameId}, \"Test Structure\", null, null,\n\t\t\tDDMStructureConstants.TYPE_DEFAULT, false);\n\n\t\tAssert.assertEquals(initialCount + 1, count);\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddStructureWithoutName() throws Exception {\n\t\tString storageType = StorageType.XML.getValue();\n\t\tString xsd = getTestStructureXsd(storageType);\n\t\tint type =  DDMStructureConstants.TYPE_DEFAULT;\n\n\t\ttry {\n\t\t\taddStructure(\n\t\t\t\t_testClassNameId, null, StringPool.BLANK, xsd, storageType,\n\t\t\t\ttype);\n\n\t\t\tAssert.fail(\"Should not be able to add Structure because \" +\n\t\t\t\t\"name is empty\");\n\t\t}\n\t\tcatch (StructureNameException sne) {\n\t\t}\n\t}","id":76820,"modified_method":"@Test\n\tpublic void testAddStructureWithoutName() throws Exception {\n\t\tString storageType = StorageType.XML.getValue();\n\n\t\ttry {\n\t\t\taddStructure(\n\t\t\t\t_classNameId, null, StringPool.BLANK,\n\t\t\t\tgetTestStructureXsd(storageType), storageType,\n\t\t\t\tDDMStructureConstants.TYPE_DEFAULT);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (StructureNameException sne) {\n\t\t}\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetTemplates() throws Exception {\n\t\tDDMStructure structure = addStructure(\n\t\t\t_testClassNameId, \"Test Structure\");\n\n\t\taddDetailTemplate(structure.getPrimaryKey(), \"Test List Template\");\n\t\taddListTemplate(structure.getPrimaryKey(), \"Test Detail Template\");\n\n\t\tList<DDMTemplate> templates = structure.getTemplates();\n\n\t\tAssert.assertEquals(2, templates.size());\n\t}","id":76821,"modified_method":"@Test\n\tpublic void testGetTemplates() throws Exception {\n\t\tDDMStructure structure = addStructure(_classNameId, \"Test Structure\");\n\n\t\taddDetailTemplate(structure.getStructureId(), \"Test List Template\");\n\t\taddListTemplate(structure.getStructureId(), \"Test Detail Template\");\n\n\t\tList<DDMTemplate> templates = structure.getTemplates();\n\n\t\tAssert.assertEquals(2, templates.size());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetStructures() throws Exception {\n\t\tDDMStructure structure = addStructure(\n\t\t\t_testClassNameId, \"Test Structure\");\n\n\t\tList<DDMStructure> structures =\n\t\t\tDDMStructureLocalServiceUtil.getStructures(structure.getGroupId());\n\n\t\tAssert.assertTrue(structures.contains(structure));\n\t}","id":76822,"modified_method":"@Test\n\tpublic void testGetStructures() throws Exception {\n\t\tDDMStructure structure = addStructure(_classNameId, \"Test Structure\");\n\n\t\tList<DDMStructure> structures =\n\t\t\tDDMStructureLocalServiceUtil.getStructures(structure.getGroupId());\n\n\t\tAssert.assertTrue(structures.contains(structure));\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearchByKeywords() throws Exception {\n\t\tDDMStructure structure = addStructure(\n\t\t\t_testClassNameId, \"Test Structure 1\");\n\n\t\taddStructure(_testClassNameId, \"Test Structure 2\");\n\n\t\tlong[] groupIds = new long[] {structure.getGroupId()};\n\t\tlong[] classNameIds = new long[] {structure.getClassNameId()};\n\n\t\tList<DDMStructure> structures = DDMStructureLocalServiceUtil.search(\n\t\t\tstructure.getCompanyId(), groupIds, classNameIds, null, 0, 1, null);\n\n\t\tAssert.assertEquals(1, structures.size());\n\t}","id":76823,"modified_method":"@Test\n\tpublic void testSearchByKeywords() throws Exception {\n\t\tDDMStructure structure = addStructure(_classNameId, \"Test Structure 1\");\n\n\t\taddStructure(_classNameId, \"Test Structure 2\");\n\n\t\tList<DDMStructure> structures = DDMStructureLocalServiceUtil.search(\n\t\t\tstructure.getCompanyId(), new long[] {structure.getGroupId()},\n\t\t\tnew long[] {structure.getClassNameId()}, null, 0, 1, null);\n\n\t\tAssert.assertEquals(1, structures.size());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearchCountByKeywords() throws Exception {\n\t\tlong companyId = TestPropsValues.getCompanyId();\n\t\tlong[] groupIds = new long[] {TestPropsValues.getGroupId()};\n\t\tlong[] classNameIds = new long[] {_testClassNameId};\n\n\t\tint initCount = DDMStructureLocalServiceUtil.searchCount(\n\t\t\tcompanyId, groupIds, classNameIds, null);\n\n\t\taddStructure(_testClassNameId, \"Test Structure\");\n\n\t\tint count = DDMStructureLocalServiceUtil.searchCount(\n\t\t\tcompanyId, groupIds, classNameIds, null);\n\n\t\tAssert.assertEquals(initCount + 1, count);\n\t}","id":76824,"modified_method":"@Test\n\tpublic void testSearchCountByKeywords() throws Exception {\n\t\tint initialCount = DDMStructureLocalServiceUtil.searchCount(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tnew long[] {TestPropsValues.getGroupId()},\n\t\t\tnew long[] {_classNameId}, null);\n\n\t\taddStructure(_classNameId, \"Test Structure\");\n\n\t\tint count = DDMStructureLocalServiceUtil.searchCount(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tnew long[] {TestPropsValues.getGroupId()},\n\t\t\tnew long[] {_classNameId}, null);\n\n\t\tAssert.assertEquals(initialCount + 1, count);\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testCopyStructure() throws Exception {\n\t\tDDMStructure structure = addStructure(\n\t\t\t_testClassNameId, \"Test Structure\");\n\n\t\tDDMStructure copyStructure = copyStructure(structure);\n\n\t\tAssert.assertEquals(structure.getGroupId(), copyStructure.getGroupId());\n\t\tAssert.assertEquals(structure.getXsd(), copyStructure.getXsd());\n\t\tAssert.assertEquals(\n\t\t\tstructure.getStorageType(), copyStructure.getStorageType());\n\t\tAssert.assertEquals(structure.getType(), copyStructure.getType());\n\t}","id":76825,"modified_method":"@Test\n\tpublic void testCopyStructure() throws Exception {\n\t\tDDMStructure structure = addStructure(_classNameId, \"Test Structure\");\n\n\t\tDDMStructure copyStructure = copyStructure(structure);\n\n\t\tAssert.assertEquals(structure.getGroupId(), copyStructure.getGroupId());\n\t\tAssert.assertEquals(structure.getXsd(), copyStructure.getXsd());\n\t\tAssert.assertEquals(\n\t\t\tstructure.getStorageType(), copyStructure.getStorageType());\n\t\tAssert.assertEquals(structure.getType(), copyStructure.getType());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDeleteStructure() throws Exception {\n\t\tDDMStructure structure = addStructure(\n\t\t\t_testClassNameId, \"Test Structure\");\n\n\t\tlong structureId = structure.getStructureId();\n\n\t\tDDMStructureLocalServiceUtil.deleteStructure(structureId);\n\n\t\tDDMStructure fetchStructure =\n\t\t\tDDMStructureLocalServiceUtil.fetchDDMStructure(structureId);\n\n\t\tAssert.assertNull(fetchStructure);\n\t}","id":76826,"modified_method":"@Test\n\tpublic void testDeleteStructure() throws Exception {\n\t\tDDMStructure structure = addStructure(_classNameId, \"Test Structure\");\n\n\t\tDDMStructureLocalServiceUtil.deleteStructure(\n\t\t\tstructure.getStructureId());\n\n\t\tAssert.assertNull(\n\t\t\tDDMStructureLocalServiceUtil.fetchDDMStructure(\n\t\t\t\tstructure.getStructureId()));\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFetchStructure() throws Exception {\n\t\tDDMStructure structure = addStructure(\n\t\t\t_testClassNameId, \"Test Structure\");\n\n\t\tDDMStructure fetchStructure =\n\t\t\tDDMStructureLocalServiceUtil.fetchStructure(\n\t\t\t\tstructure.getGroupId(), structure.getStructureKey());\n\n\t\tAssert.assertNotNull(fetchStructure);\n\t}","id":76827,"modified_method":"@Test\n\tpublic void testFetchStructure() throws Exception {\n\t\tDDMStructure structure = addStructure(_classNameId, \"Test Structure\");\n\n\t\tAssert.assertNotNull(\n\t\t\tDDMStructureLocalServiceUtil.fetchStructure(\n\t\t\t\tstructure.getGroupId(), structure.getStructureKey()));\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddStructureWithDuplicatedKey() throws Exception {\n\t\tString structureKey = ServiceTestUtil.randomString();\n\t\tString storageType = StorageType.XML.getValue();\n\t\tString xsd = getTestStructureXsd(storageType);\n\t\tint type =  DDMStructureConstants.TYPE_DEFAULT;\n\n\t\ttry {\n\t\t\taddStructure(\n\t\t\t\t_testClassNameId, structureKey, \"Test Structure 1\", xsd,\n\t\t\t\tstorageType, type);\n\n\t\t\taddStructure(\n\t\t\t\t_testClassNameId, structureKey, \"Test Structure 2\", xsd,\n\t\t\t\tstorageType, type);\n\n\t\t\tAssert.fail(\"Should not be able to add Structure because \" +\n\t\t\t\t\t\"structureKey is duplicated\");\n\t\t}\n\t\tcatch (StructureDuplicateStructureKeyException sdske) {\n\t\t}\n\t}","id":76828,"modified_method":"@Test\n\tpublic void testAddStructureWithDuplicateKey() throws Exception {\n\t\tString structureKey = ServiceTestUtil.randomString();\n\t\tString storageType = StorageType.XML.getValue();\n\n\t\ttry {\n\t\t\taddStructure(\n\t\t\t\t_classNameId, structureKey, \"Test Structure 1\",\n\t\t\t\tgetTestStructureXsd(storageType), storageType,\n\t\t\t\tDDMStructureConstants.TYPE_DEFAULT);\n\n\t\t\taddStructure(\n\t\t\t\t_classNameId, structureKey, \"Test Structure 2\",\n\t\t\t\tgetTestStructureXsd(storageType), storageType,\n\t\t\t\tDDMStructureConstants.TYPE_DEFAULT);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (StructureDuplicateStructureKeyException sdske) {\n\t\t}\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddTemplateWithDuplicatedKey() throws Exception {\n\t\tString templateKey = ServiceTestUtil.randomString();\n\n\t\tString language = DDMTemplateConstants.LANG_TYPE_VM;\n\t\tString script = getTestTemplateScript(language);\n\t\tString type = DDMTemplateConstants.TEMPLATE_TYPE_DETAIL;\n\t\tString mode = DDMTemplateConstants.TEMPLATE_MODE_CREATE;\n\n\t\ttry {\n\t\t\taddTemplate(\n\t\t\t\t_testClassNameId, 0, templateKey, \"Test Template 1\", type, mode,\n\t\t\t\tlanguage, script);\n\n\t\t\taddTemplate(\n\t\t\t\t_testClassNameId, 0, templateKey, \"Test Template 2\", type, mode,\n\t\t\t\tlanguage, script);\n\n\t\t\tAssert.fail(\"Should not be able to add Template because \" +\n\t\t\t\t\"templateKey is duplicated\");\n\t\t}\n\t\tcatch (TemplateDuplicateTemplateKeyException tdtke) {\n\t\t}\n\t}","id":76829,"modified_method":"@Test\n\tpublic void testAddTemplateWithDuplicateKey() throws Exception {\n\t\tString templateKey = ServiceTestUtil.randomString();\n\t\tString language = DDMTemplateConstants.LANG_TYPE_VM;\n\n\t\ttry {\n\t\t\taddTemplate(\n\t\t\t\t_classNameId, 0, templateKey, \"Test Template 1\",\n\t\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DETAIL,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE, language,\n\t\t\t\tgetTestTemplateScript(language));\n\t\t\taddTemplate(\n\t\t\t\t_classNameId, 0, templateKey, \"Test Template 2\",\n\t\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DETAIL,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE, language,\n\t\t\t\tgetTestTemplateScript(language));\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (TemplateDuplicateTemplateKeyException tdtke) {\n\t\t}\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddTemplateWithoutScript() throws Exception {\n\t\tString language = DDMTemplateConstants.LANG_TYPE_VM;\n\t\tString type = DDMTemplateConstants.TEMPLATE_TYPE_DETAIL;\n\t\tString mode = DDMTemplateConstants.TEMPLATE_MODE_CREATE;\n\n\t\ttry {\n\t\t\taddTemplate(\n\t\t\t\t_testClassNameId, 0, null, \"Test Template\", type, mode,\n\t\t\t\tlanguage, StringPool.BLANK);\n\n\t\t\tAssert.fail(\"Should not be able to add Template because \" +\n\t\t\t\t\"script is empty\");\n\t\t}\n\t\tcatch (TemplateScriptException tse) {\n\t\t}\n\t}","id":76830,"modified_method":"@Test\n\tpublic void testAddTemplateWithoutScript() throws Exception {\n\t\ttry {\n\t\t\taddTemplate(\n\t\t\t\t_classNameId, 0, null, \"Test Template\",\n\t\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DETAIL,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE,\n\t\t\t\tDDMTemplateConstants.LANG_TYPE_VM, StringPool.BLANK);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (TemplateScriptException tse) {\n\t\t}\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearchCount() throws Exception {\n\t\tlong companyId = TestPropsValues.getCompanyId();\n\t\tlong groupId = TestPropsValues.getGroupId();\n\t\tString name = \"Test Template\";\n\n\t\tint initCount = DDMTemplateLocalServiceUtil.searchCount(\n\t\t\tcompanyId, groupId, _testClassNameId, 0, name, null, null, null,\n\t\t\tnull, false);\n\n\t\taddListTemplate(_testClassNameId, 0, name);\n\n\t\tint count = DDMTemplateLocalServiceUtil.searchCount(\n\t\t\tcompanyId, groupId, _testClassNameId, 0, name, null, null, null,\n\t\t\tnull, false);\n\n\t\tAssert.assertEquals(initCount + 1, count);\n\t}","id":76831,"modified_method":"@Test\n\tpublic void testSearchCount() throws Exception {\n\t\tint initialCount = DDMTemplateLocalServiceUtil.searchCount(\n\t\t\tTestPropsValues.getCompanyId(), TestPropsValues.getGroupId(),\n\t\t\t_classNameId, 0, \"Test Template\", null, null, null, null, false);\n\n\t\taddListTemplate(_classNameId, 0, \"Test Template\");\n\n\t\tint count = DDMTemplateLocalServiceUtil.searchCount(\n\t\t\tTestPropsValues.getCompanyId(), TestPropsValues.getGroupId(),\n\t\t\t_classNameId, 0, \"Test Template\", null, null, null, null, false);\n\n\t\tAssert.assertEquals(initialCount + 1, count);\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMTemplate updateTemplate(DDMTemplate template)\n\t\t\tthrows Exception {\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\treturn DDMTemplateLocalServiceUtil.updateTemplate(\n\t\t\ttemplate.getTemplateId(), template.getNameMap(),\n\t\t\ttemplate.getDescriptionMap(), template.getType(),\n\t\t\ttemplate.getMode(), template.getLanguage(), template.getScript(),\n\t\t\tserviceContext);\n\t}","id":76832,"modified_method":"protected DDMTemplate updateTemplate(DDMTemplate template)\n\t\tthrows Exception {\n\n\t\treturn DDMTemplateLocalServiceUtil.updateTemplate(\n\t\t\ttemplate.getTemplateId(), template.getNameMap(),\n\t\t\ttemplate.getDescriptionMap(), template.getType(),\n\t\t\ttemplate.getMode(), template.getLanguage(), template.getScript(),\n\t\t\tServiceTestUtil.getServiceContext());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testCopyTemplates() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_testClassNameId, 0, \"Test Template\");\n\n\t\tList<DDMTemplate> templates = copyTemplate(template);\n\n\t\tAssert.assertTrue(templates.size() >= 1);\n\t}","id":76833,"modified_method":"@Test\n\tpublic void testCopyTemplates() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_classNameId, 0, \"Test Template\");\n\n\t\tList<DDMTemplate> templates = copyTemplate(template);\n\n\t\tAssert.assertTrue(templates.size() >= 1);\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAddTemplateWithoutName() throws Exception {\n\t\tString language = DDMTemplateConstants.LANG_TYPE_VM;\n\t\tString script = getTestTemplateScript(language);\n\t\tString type = DDMTemplateConstants.TEMPLATE_TYPE_DETAIL;\n\t\tString mode = DDMTemplateConstants.TEMPLATE_MODE_CREATE;\n\n\t\ttry {\n\t\t\taddTemplate(\n\t\t\t\t_testClassNameId, 0, null, StringPool.BLANK, type, mode,\n\t\t\t\tlanguage, script);\n\n\t\t\tAssert.fail(\"Should not be able to add Template because \" +\n\t\t\t\t\"name is empty\");\n\t\t}\n\t\tcatch (TemplateNameException tne) {\n\t\t}\n\t}","id":76834,"modified_method":"@Test\n\tpublic void testAddTemplateWithoutName() throws Exception {\n\t\tString language = DDMTemplateConstants.LANG_TYPE_VM;\n\n\t\ttry {\n\t\t\taddTemplate(\n\t\t\t\t_classNameId, 0, null, StringPool.BLANK,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_TYPE_DETAIL,\n\t\t\t\tDDMTemplateConstants.TEMPLATE_MODE_CREATE, language,\n\t\t\t\tgetTestTemplateScript(language));\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (TemplateNameException tne) {\n\t\t}\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<DDMTemplate> copyTemplate(DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tlong newClassPK = -1;\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\treturn DDMTemplateLocalServiceUtil.copyTemplates(\n\t\t\ttemplate.getUserId(), template.getClassNameId(),\n\t\t\ttemplate.getClassPK(), newClassPK, template.getType(),\n\t\t\tserviceContext);\n\t}","id":76835,"modified_method":"protected List<DDMTemplate> copyTemplate(DDMTemplate template)\n\t\tthrows Exception {\n\n\t\treturn DDMTemplateLocalServiceUtil.copyTemplates(\n\t\t\ttemplate.getUserId(), template.getClassNameId(),\n\t\t\ttemplate.getClassPK(), -1, template.getType(),\n\t\t\tServiceTestUtil.getServiceContext());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetTemplates() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_testClassNameId, 0, \"Test Template\");\n\n\t\tList<DDMTemplate> templates = DDMTemplateLocalServiceUtil.getTemplates(\n\t\t\ttemplate.getGroupId(), template.getClassNameId());\n\n\t\tAssert.assertTrue(templates.contains(template));\n\t}","id":76836,"modified_method":"@Test\n\tpublic void testGetTemplates() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_classNameId, 0, \"Test Template\");\n\n\t\tList<DDMTemplate> templates = DDMTemplateLocalServiceUtil.getTemplates(\n\t\t\ttemplate.getGroupId(), template.getClassNameId());\n\n\t\tAssert.assertTrue(templates.contains(template));\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearch() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_testClassNameId, 0, \"Test Template 1\");\n\n\t\taddListTemplate(_testClassNameId, 0, \"Test Template 2\");\n\n\t\tList<DDMTemplate> templates = DDMTemplateLocalServiceUtil.search(\n\t\t\ttemplate.getCompanyId(), template.getGroupId(),\n\t\t\ttemplate.getClassNameId(), template.getClassPK(),\n\t\t\ttemplate.getName(), template.getDescription(), template.getType(),\n\t\t\ttemplate.getMode(), template.getLanguage(), false, 0, 1, null);\n\n\t\tAssert.assertEquals(1, templates.size());\n\t}","id":76837,"modified_method":"@Test\n\tpublic void testSearch() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_classNameId, 0, \"Test Template 1\");\n\n\t\taddListTemplate(_classNameId, 0, \"Test Template 2\");\n\n\t\tList<DDMTemplate> templates = DDMTemplateLocalServiceUtil.search(\n\t\t\ttemplate.getCompanyId(), template.getGroupId(),\n\t\t\ttemplate.getClassNameId(), template.getClassPK(),\n\t\t\ttemplate.getName(), template.getDescription(), template.getType(),\n\t\t\ttemplate.getMode(), template.getLanguage(), false, 0, 1, null);\n\n\t\tAssert.assertEquals(1, templates.size());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearchCountByKeywords() throws Exception {\n\t\tlong companyId = TestPropsValues.getCompanyId();\n\t\tlong groupId = TestPropsValues.getGroupId();\n\n\t\tint initCount = DDMTemplateLocalServiceUtil.searchCount(\n\t\t\tcompanyId, groupId, _testClassNameId, 0, null, null, null);\n\n\t\taddListTemplate(_testClassNameId, 0, \"Test Template\");\n\n\t\tint count = DDMTemplateLocalServiceUtil.searchCount(\n\t\t\tcompanyId, groupId, _testClassNameId, 0, null, null, null);\n\n\t\tAssert.assertEquals(initCount + 1, count);\n\t}","id":76838,"modified_method":"@Test\n\tpublic void testSearchCountByKeywords() throws Exception {\n\t\tint initialCount = DDMTemplateLocalServiceUtil.searchCount(\n\t\t\tTestPropsValues.getCompanyId(), TestPropsValues.getGroupId(),\n\t\t\t_classNameId, 0, null, null, null);\n\n\t\taddListTemplate(_classNameId, 0, \"Test Template\");\n\n\t\tint count = DDMTemplateLocalServiceUtil.searchCount(\n\t\t\tTestPropsValues.getCompanyId(), TestPropsValues.getGroupId(),\n\t\t\t_classNameId, 0, null, null, null);\n\n\t\tAssert.assertEquals(initialCount + 1, count);\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDeleteTemplate() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_testClassNameId, 0, \"Test Template\");\n\n\t\tlong templateId = template.getTemplateId();\n\n\t\tDDMTemplateLocalServiceUtil.deleteTemplate(templateId);\n\n\t\tDDMTemplate fetchTemplate =\n\t\t\tDDMTemplateLocalServiceUtil.fetchDDMTemplate(templateId);\n\n\t\tAssert.assertNull(fetchTemplate);\n\t}","id":76839,"modified_method":"@Test\n\tpublic void testDeleteTemplate() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_classNameId, 0, \"Test Template\");\n\n\t\tDDMTemplateLocalServiceUtil.deleteTemplate(template.getTemplateId());\n\n\t\tAssert.assertNull(\n\t\t\tDDMTemplateLocalServiceUtil.fetchDDMTemplate(\n\t\t\t\ttemplate.getTemplateId()));\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearchByKeywords() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_testClassNameId, 0, \"Test Template 1\");\n\n\t\taddListTemplate(_testClassNameId, 0, \"Test Template 2\");\n\n\t\tList<DDMTemplate> templates = DDMTemplateLocalServiceUtil.search(\n\t\t\ttemplate.getCompanyId(), template.getGroupId(),\n\t\t\ttemplate.getClassNameId(), template.getClassPK(), null,\n\t\t\ttemplate.getType(), template.getMode(), 0, 1, null);\n\n\t\tAssert.assertEquals(1, templates.size());\n\t}","id":76840,"modified_method":"@Test\n\tpublic void testSearchByKeywords() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_classNameId, 0, \"Test Template 1\");\n\n\t\taddListTemplate(_classNameId, 0, \"Test Template 2\");\n\n\t\tList<DDMTemplate> templates = DDMTemplateLocalServiceUtil.search(\n\t\t\ttemplate.getCompanyId(), template.getGroupId(),\n\t\t\ttemplate.getClassNameId(), template.getClassPK(), null,\n\t\t\ttemplate.getType(), template.getMode(), 0, 1, null);\n\n\t\tAssert.assertEquals(1, templates.size());\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFetchTemplate() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_testClassNameId, 0, \"Test Template\");\n\n\t\tDDMTemplate fetchTemplate = DDMTemplateLocalServiceUtil.fetchTemplate(\n\t\t\ttemplate.getGroupId(), template.getTemplateKey());\n\n\t\tAssert.assertNotNull(fetchTemplate);\n\t}","id":76841,"modified_method":"@Test\n\tpublic void testFetchTemplate() throws Exception {\n\t\tDDMTemplate template = addListTemplate(\n\t\t\t_classNameId, 0, \"Test Template\");\n\n\t\tAssert.assertNotNull(\n\t\t\tDDMTemplateLocalServiceUtil.fetchTemplate(\n\t\t\t\ttemplate.getGroupId(), template.getTemplateKey()));\n\t}","commit_id":"c765c6a9b74125e961a511ee6f15349ae933dd1f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static StandaloneServer create(final ModuleLoader moduleLoader, final File jbossHomeDir, final Properties systemProps, final Map<String, String> systemEnv) {\n        try {\n            // Load the server Module and get its ClassLoader\n            final ModuleIdentifier serverModuleId = ModuleIdentifier.create(\"org.jboss.as.server\");\n            final Module serverModule = moduleLoader.loadModule(serverModuleId);\n            final ModuleClassLoader serverModuleClassLoader = serverModule.getClassLoader();\n\n            Class<?> embeddedStandAloneServerFactoryClass = serverModuleClassLoader.loadClass(\"org.jboss.as.server.EmbeddedStandAloneServerFactory\");\n            Method createMethod = embeddedStandAloneServerFactoryClass.getMethod(\"create\", File.class, ModuleLoader.class, Properties.class, Map.class);\n            final StandaloneServer standaloneServer = (StandaloneServer) createMethod.invoke(null, jbossHomeDir, moduleLoader, systemProps, systemEnv);\n            return standaloneServer;\n        } catch (ModuleLoadException e) {\n            throw MESSAGES.moduleLoaderError(e, e.getMessage(), moduleLoader);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":76842,"modified_method":"public static StandaloneServer create(final ModuleLoader moduleLoader, final File jbossHomeDir, final Properties systemProps, final Map<String, String> systemEnv) {\n        return EmbeddedStandAloneServerFactory.create(jbossHomeDir, moduleLoader, systemProps, systemEnv);\n    }","commit_id":"3f9cbf4b0906e2f6a1d63c87e25a82cb06d12757","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processModuleDependency(List<ModuleIdentifier> dependencies, ElementNode parentNode, ModuleDependency dep) throws IOException, XMLStreamException {\n        ModuleIdentifier moduleId = dep.getModuleId();\n        ElementNode moduleNode = new ElementNode(parentNode, \"module\");\n        moduleNode.addAttribute(\"name\", new AttributeValue(moduleId.toString()));\n        if (dep.isOptional()) {\n            moduleNode.addAttribute(\"optional\", new AttributeValue(\"true\"));\n        }\n        if (dependencies.contains(moduleId)) {\n            moduleNode.addAttribute(\"defined\", new AttributeValue(\"true\"));\n            parentNode.addChild(moduleNode);\n        } else {\n            parentNode.addChild(moduleNode);\n            if (!dep.isOptional()) {\n                dependencies.add(moduleId);\n\n                String path = moduleId.getName().replace('.', '/') + '/' + moduleId.getSlot();\n                File moduleFile = new File(resourcesDir + File.separator + \"modules\" + File.separator + path + File.separator + \"module.xml\");\n\n                ModuleParser moduleParser = new ModuleParser(moduleFile);\n                moduleParser.parse();\n\n                List<ModuleDependency> moduledeps = moduleParser.getDependencies();\n                for (ModuleDependency aux : moduledeps) {\n                    processModuleDependency(dependencies, moduleNode, aux);\n                }\n            }\n        }\n    }","id":76843,"modified_method":"private void processModuleDependency(List<ModuleIdentifier> dependencies, ElementNode parentNode, ModuleDependency dep) throws IOException, XMLStreamException {\n        ModuleIdentifier moduleId = dep.getModuleId();\n        if (dependencies.contains(moduleId)) {\n            log.debugf(\"Already defined: %s\", moduleId);\n            return;\n        }\n\n        ElementNode moduleNode = new ElementNode(parentNode, \"module\");\n        moduleNode.addAttribute(\"name\", new AttributeValue(moduleId.toString()));\n        parentNode.addChild(moduleNode);\n\n        if (!dep.isOptional()) {\n            dependencies.add(moduleId);\n\n            String path = moduleId.getName().replace('.', '/') + '/' + moduleId.getSlot();\n            File moduleFile = new File(resourcesDir + File.separator + \"modules\" + File.separator + path + File.separator + \"module.xml\");\n\n            ModuleParser moduleParser = new ModuleParser(moduleFile);\n            moduleParser.parse();\n\n            List<ModuleDependency> moduledeps = moduleParser.getDependencies();\n            for (ModuleDependency aux : moduledeps) {\n                processModuleDependency(dependencies, moduleNode, aux);\n            }\n        } else {\n            moduleNode.addAttribute(\"optional\", new AttributeValue(\"true\"));\n        }\n    }","commit_id":"3f9cbf4b0906e2f6a1d63c87e25a82cb06d12757","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, SUN_JDK, false, false, true, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, IBM_JDK, false, false, true, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAVAX_API, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JBOSS_LOGGING, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JBOSS_VFS, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, COMMONS_LOGGING, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, LOG4J, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, SLF4J, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JUL_TO_SLF4J, false, false, false, false));\n    }","id":76844,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        for (ModuleIdentifier moduleId : DEFAULT_MODULES) {\n            try {\n                moduleLoader.loadModule(moduleId);\n                boolean importServices = moduleId.getName().endsWith(\"jdk\");\n                moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleId, false, false, importServices, false));\n            } catch (ModuleLoadException ex) {\n                ServerLogger.ROOT_LOGGER.debugf(\"Module not found: %s\", moduleId);\n            }\n        }\n    }","commit_id":"3f9cbf4b0906e2f6a1d63c87e25a82cb06d12757","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Adds Java EE module as a dependency to any deployment unit which is a EJB deployment\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n\n        // get hold of the deployment unit\n        DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        //we always give them the EJB client\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_CLIENT, false, false, true, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_IIOP_CLIENT, false, false, false, false));\n\n        //we always have to add this, as even non-ejb deployments may still lookup IIOP ejb's\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_SUBSYSTEM, false, false, true, false));\n\n        if (JacORBDeploymentMarker.isJacORBDeployment(deploymentUnit)) {\n            //needed for dynamic IIOP stubs\n            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JACORB, false, false, false, false));\n        }\n\n        // fetch the EjbJarMetaData\n        //TODO: remove the app client bit after the next EJB release\n        if (!isEjbDeployment(deploymentUnit) && !DeploymentTypeMarker.isType(DeploymentType.APPLICATION_CLIENT, deploymentUnit)) {\n            // nothing to do\n            return;\n        }\n\n\n        // FIXME: still not the best way to do it\n        //this must be the first dep listed in the module\n        if (Boolean.getBoolean(\"org.jboss.as.ejb3.EMBEDDED\"))\n            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, ModuleIdentifier.CLASSPATH, false, false, false, false));\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAVAEE_MODULE_IDENTIFIER, false, false, false, false));\n\n    }","id":76845,"modified_method":"/**\n     * Adds Java EE module as a dependency to any deployment unit which is a EJB deployment\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n\n        // get hold of the deployment unit\n        DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        //we always give them the EJB client\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_CLIENT, false, false, true, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_IIOP_CLIENT, false, false, false, false));\n\n        //we always have to add this, as even non-ejb deployments may still lookup IIOP ejb's\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_SUBSYSTEM, false, false, true, false));\n\n        if (JacORBDeploymentMarker.isJacORBDeployment(deploymentUnit)) {\n            //needed for dynamic IIOP stubs\n            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JACORB, false, false, false, false));\n        }\n\n        // fetch the EjbJarMetaData\n        //TODO: remove the app client bit after the next EJB release\n        if (!isEjbDeployment(deploymentUnit) && !DeploymentTypeMarker.isType(DeploymentType.APPLICATION_CLIENT, deploymentUnit)) {\n            // nothing to do\n            return;\n        }\n\n\n        // FIXME: still not the best way to do it\n        //this must be the first dep listed in the module\n        if (Boolean.getBoolean(\"org.jboss.as.ejb3.EMBEDDED\"))\n            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, ModuleIdentifier.CLASSPATH, false, false, false, false));\n\n    }","commit_id":"9199cb9459c3e29d479bf0bfb7098864718f8c16","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Add dependencies for modules required for JPA deployments\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n        // all applications get the javax.persistence module added to their deplyoment by default\n        addDependency(moduleSpecification, moduleLoader, deploymentUnit, JAVAX_PERSISTENCE_API_ID);\n\n        if (!JPADeploymentMarker.isJPADeployment(deploymentUnit)) {\n            return; // Skip if there are no persistence use in the deployment\n        }\n        addDependency(moduleSpecification, moduleLoader, deploymentUnit, JAVAEE_API_ID, JBOSS_AS_JPA_ID, JBOSS_AS_JPA_SPI_ID, JAVASSIST_ID);\n        addPersistenceProviderModuleDependencies(phaseContext, moduleSpecification, moduleLoader);\n    }","id":76846,"modified_method":"/**\n     * Add dependencies for modules required for JPA deployments\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n        // all applications get the javax.persistence module added to their deplyoment by default\n        addDependency(moduleSpecification, moduleLoader, deploymentUnit, JAVAX_PERSISTENCE_API_ID);\n\n        if (!JPADeploymentMarker.isJPADeployment(deploymentUnit)) {\n            return; // Skip if there are no persistence use in the deployment\n        }\n        addDependency(moduleSpecification, moduleLoader, deploymentUnit, JBOSS_AS_JPA_ID, JBOSS_AS_JPA_SPI_ID, JAVASSIST_ID);\n        addPersistenceProviderModuleDependencies(phaseContext, moduleSpecification, moduleLoader);\n    }","commit_id":"9199cb9459c3e29d479bf0bfb7098864718f8c16","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Add the EE APIs as a dependency to all deployments\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAVAEE_API_ID, false, false, true, false));\n        // TODO: Post 7.0, we have to rethink this whole hibernate dependencies that we add to user deployments\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, HIBERNATE_VALIDATOR_ID, false, false, true, false));\n\n        //add jboss-invocation classes needed by the proxies\n        ModuleDependency invocation = new ModuleDependency(moduleLoader, JBOSS_INVOCATION_ID, false, false, false, false);\n        invocation.addImportFilter(PathFilters.is(\"org.jboss.invocation.proxy.classloading\"), true);\n        moduleSpecification.addSystemDependency(invocation);\n\n        ModuleDependency ee = new ModuleDependency(moduleLoader, JBOSS_AS_EE, false, false, false, false);\n        ee.addImportFilter(PathFilters.is(\"org.jboss.as.ee.component.serialization\"), true);\n        moduleSpecification.addSystemDependency(ee);\n    }","id":76847,"modified_method":"/**\n     * Add the EE APIs as a dependency to all deployments\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        // TODO: Post 7.0, we have to rethink this whole hibernate dependencies that we add to user deployments\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, HIBERNATE_VALIDATOR_ID, false, false, true, false));\n\n        //add jboss-invocation classes needed by the proxies\n        ModuleDependency invocation = new ModuleDependency(moduleLoader, JBOSS_INVOCATION_ID, false, false, false, false);\n        invocation.addImportFilter(PathFilters.is(\"org.jboss.invocation.proxy.classloading\"), true);\n        moduleSpecification.addSystemDependency(invocation);\n\n        ModuleDependency ee = new ModuleDependency(moduleLoader, JBOSS_AS_EE, false, false, false, false);\n        ee.addImportFilter(PathFilters.is(\"org.jboss.as.ee.component.serialization\"), true);\n        moduleSpecification.addSystemDependency(ee);\n\n\n        //we always add all Java EE API modules, as the platform spec requires them to always be available\n        //we do not just add the javaee.api module, as this breaks excludes\n\n        for (final ModuleIdentifier moduleIdentifier : JAVA_EE_API_MODULES) {\n            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, false, false, true, false));\n        }\n    }","commit_id":"9199cb9459c3e29d479bf0bfb7098864718f8c16","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n        // Add module dependencies on Java EE apis\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAVAX_EE_API, false, false, false, false));\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JSTL, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, UNDERTOW_CORE, false, false, true, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, UNDERTOW_SERVLET, false, false, true, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, UNDERTOW_WEBSOCKET, false, false, true, false));\n    }","id":76848,"modified_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JSTL, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, UNDERTOW_CORE, false, false, true, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, UNDERTOW_SERVLET, false, false, true, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, UNDERTOW_WEBSOCKET, false, false, true, false));\n    }","commit_id":"9199cb9459c3e29d479bf0bfb7098864718f8c16","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n        // Add module dependencies on Java EE apis\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAVAX_EE_API, false, false, false, false));\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JSTL, false, false, false, false));\n\n        // FIXME we need to revise the exports of the web module, so that we\n        // don't export our internals\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JBOSS_WEB, false, false, true, false));\n\n    }","id":76849,"modified_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JSTL, false, false, false, false));\n\n        // FIXME we need to revise the exports of the web module, so that we\n        // don't export our internals\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JBOSS_WEB, false, false, true, false));\n\n    }","commit_id":"9199cb9459c3e29d479bf0bfb7098864718f8c16","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Add dependencies for modules required for weld deployments, if managed weld configurations are attached to the deployment\n     *\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            return; // Skip if there are no beans.xml files in the deployment\n        }\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        addDependency(moduleSpecification, moduleLoader, JAVAX_PERSISTENCE_API_ID);\n        addDependency(moduleSpecification, moduleLoader, JAVAEE_API_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_CORE_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_API_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_SPI_ID);\n\n\n        ModuleDependency dep = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_ID, false, false, false, false);\n        dep.addImportFilter(PathFilters.getMetaInfFilter(), true);\n        dep.addExportFilter(PathFilters.getMetaInfFilter(), true);\n        moduleSpecification.addSystemDependency(dep);\n\n    }","id":76850,"modified_method":"/**\n     * Add dependencies for modules required for weld deployments, if managed weld configurations are attached to the deployment\n     *\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            return; // Skip if there are no beans.xml files in the deployment\n        }\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        addDependency(moduleSpecification, moduleLoader, JAVAX_PERSISTENCE_API_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_CORE_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_API_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_SPI_ID);\n\n\n        ModuleDependency dep = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_ID, false, false, false, false);\n        dep.addImportFilter(PathFilters.getMetaInfFilter(), true);\n        dep.addExportFilter(PathFilters.getMetaInfFilter(), true);\n        moduleSpecification.addSystemDependency(dep);\n    }","commit_id":"9199cb9459c3e29d479bf0bfb7098864718f8c16","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addHibernate3AdaptorToDeployment(final ModuleLoader moduleLoader, final DeploymentUnit deploymentUnit) {\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        try {\n            final Module module = moduleLoader.loadModule(HIBERNATE_3_PROVIDER);\n            //use a trick to get to the root of the class loader\n            final URL url = module.getClassLoader().getResource(HIBERNATE3_PROVIDER_ADAPTOR.replace('.', '/') + \".class\");\n\n            final URLConnection connection = url.openConnection();\n            if (!(connection instanceof JarURLConnection)) {\n                throw MESSAGES.invalidUrlConnection(\"hibernate 3\", connection);\n            }\n\n            final JarFile jarFile = ((JarURLConnection) connection).getJarFile();\n\n            moduleSpecification.addResourceLoader(ResourceLoaderSpec.createResourceLoaderSpec(ResourceLoaders.createJarResourceLoader(\"hibernate3integration\", jarFile)));\n\n            // hack in the dependencies which are part of hibernate3integration\n            // TODO:  do this automatically (adding dependencies found in HIBERNATE_3_PROVIDER).\n            addDependency(moduleSpecification, moduleLoader, JBOSS_AS_NAMING_ID);\n            addDependency(moduleSpecification, moduleLoader, JBOSS_JANDEX_ID);\n        } catch (ModuleLoadException e) {\n            throw MESSAGES.cannotLoadModule(e, HIBERNATE_3_PROVIDER, \"hibernate 3\");\n        } catch (MalformedURLException e) {\n            throw MESSAGES.cannotAddIntegration(e, \"hibernate 3\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":76851,"modified_method":"private void addHibernate3AdaptorToDeployment(final ModuleLoader moduleLoader, final DeploymentUnit deploymentUnit) {\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        try {\n            final Module module = moduleLoader.loadModule(HIBERNATE_3_PROVIDER);\n            //use a trick to get to the root of the class loader\n            final URL url = module.getClassLoader().getResource(HIBERNATE3_PROVIDER_ADAPTOR.replace('.', '/') + \".class\");\n\n            final URLConnection connection = url.openConnection();\n            if (!(connection instanceof JarURLConnection)) {\n                throw MESSAGES.invalidUrlConnection(\"hibernate 3\", connection);\n            }\n\n            final JarFile jarFile = ((JarURLConnection) connection).getJarFile();\n\n            moduleSpecification.addResourceLoader(ResourceLoaderSpec.createResourceLoaderSpec(ResourceLoaders.createJarResourceLoader(\"hibernate3integration\", jarFile)));\n\n            // hack in the dependencies which are part of hibernate3integration\n            // TODO:  do this automatically (adding dependencies found in HIBERNATE_3_PROVIDER).\n            addDependency(moduleSpecification, moduleLoader, deploymentUnit, JBOSS_AS_NAMING_ID, JBOSS_JANDEX_ID);\n        } catch (ModuleLoadException e) {\n            throw MESSAGES.cannotLoadModule(e, HIBERNATE_3_PROVIDER, \"hibernate 3\");\n        } catch (MalformedURLException e) {\n            throw MESSAGES.cannotAddIntegration(e, \"hibernate 3\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addPersistenceProviderModuleDependencies(DeploymentPhaseContext phaseContext, ModuleSpecification moduleSpecification, ModuleLoader moduleLoader) throws\n        DeploymentUnitProcessingException {\n\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        int defaultProviderCount = 0;\n        Set<String> moduleDependencies = new HashSet<String>();\n\n        // get the number of persistence units that use the default persistence provider module.\n        // Dependencies for other persistence provider will be added to the passed\n        // 'moduleDependencies' collection.  Each persistence provider module that is found, will be injected into the\n        // passed moduleSpecification (for the current deployment unit).\n        PersistenceUnitsInApplication persistenceUnitsInApplication = DeploymentUtils.getTopDeploymentUnit(deploymentUnit).getAttachment(PersistenceUnitsInApplication.PERSISTENCE_UNITS_IN_APPLICATION);\n        for (PersistenceUnitMetadataHolder holder: persistenceUnitsInApplication.getPersistenceUnitHolders()) {\n            defaultProviderCount += loadPersistenceUnits(moduleLoader, deploymentUnit, moduleDependencies, holder);\n        }\n\n        // add dependencies for the default persistence provider module\n        if (defaultProviderCount > 0) {\n            moduleDependencies.add(Configuration.PROVIDER_MODULE_DEFAULT);\n            ROOT_LOGGER.debugf(\"added (default provider) %s dependency to %s (since %d PU(s) didn't specify %s\",\n                Configuration.PROVIDER_MODULE_DEFAULT, deploymentUnit.getName(),defaultProviderCount, Configuration.PROVIDER_MODULE + \")\");\n            // only inject default envers for default Hibernate module\n            addDependency(moduleSpecification, moduleLoader, HIBERNATE_ENVERS_ID);\n        }\n\n        // add persistence provider dependency\n        for (String dependency : moduleDependencies) {\n\n            addDependency(moduleSpecification, moduleLoader, ModuleIdentifier.fromString(dependency));\n            ROOT_LOGGER.debugf(\"added %s dependency to application deployment\", dependency);\n        }\n    }","id":76852,"modified_method":"private void addPersistenceProviderModuleDependencies(DeploymentPhaseContext phaseContext, ModuleSpecification moduleSpecification, ModuleLoader moduleLoader) throws\n        DeploymentUnitProcessingException {\n\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        int defaultProviderCount = 0;\n        Set<String> moduleDependencies = new HashSet<String>();\n\n        // get the number of persistence units that use the default persistence provider module.\n        // Dependencies for other persistence provider will be added to the passed\n        // 'moduleDependencies' collection.  Each persistence provider module that is found, will be injected into the\n        // passed moduleSpecification (for the current deployment unit).\n        PersistenceUnitsInApplication persistenceUnitsInApplication = DeploymentUtils.getTopDeploymentUnit(deploymentUnit).getAttachment(PersistenceUnitsInApplication.PERSISTENCE_UNITS_IN_APPLICATION);\n        for (PersistenceUnitMetadataHolder holder: persistenceUnitsInApplication.getPersistenceUnitHolders()) {\n            defaultProviderCount += loadPersistenceUnits(moduleLoader, deploymentUnit, moduleDependencies, holder);\n        }\n\n        // add dependencies for the default persistence provider module\n        if (defaultProviderCount > 0) {\n            moduleDependencies.add(Configuration.PROVIDER_MODULE_DEFAULT);\n            ROOT_LOGGER.debugf(\"added (default provider) %s dependency to %s (since %d PU(s) didn't specify %s\",\n                Configuration.PROVIDER_MODULE_DEFAULT, deploymentUnit.getName(),defaultProviderCount, Configuration.PROVIDER_MODULE + \")\");\n            // only inject default envers for default Hibernate module\n            addDependency(moduleSpecification, moduleLoader, deploymentUnit, HIBERNATE_ENVERS_ID);\n        }\n\n        // add persistence provider dependency\n        for (String dependency : moduleDependencies) {\n\n            addDependency(moduleSpecification, moduleLoader, deploymentUnit, ModuleIdentifier.fromString(dependency));\n        }\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Add dependencies for modules required for JPA deployments\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        addDependency(moduleSpecification, moduleLoader, JAVAX_PERSISTENCE_API_ID);\n\n        if (!JPADeploymentMarker.isJPADeployment(deploymentUnit)) {\n            ROOT_LOGGER.debugf(\"added javax.persistence.api dependency to %s\", deploymentUnit.getName());\n            return; // Skip if there are no persistence use in the deployment\n        }\n        addDependency(moduleSpecification, moduleLoader, JAVAEE_API_ID);\n        addDependency(moduleSpecification, moduleLoader, JBOSS_AS_JPA_ID);\n        addDependency(moduleSpecification, moduleLoader, JBOSS_AS_JPA_SPI_ID);  // cover when adapter jar is in app\n        addDependency(moduleSpecification, moduleLoader, JAVASSIST_ID);\n        ROOT_LOGGER.debugf(\"added javax.persistence.api, javaee.api, org.jboss.as.jpa, org.javassist dependencies to %s\", deploymentUnit.getName());\n        addPersistenceProviderModuleDependencies(phaseContext, moduleSpecification, moduleLoader);\n    }","id":76853,"modified_method":"/**\n     * Add dependencies for modules required for JPA deployments\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n        // all applications get the javax.persistence module added to their deplyoment by default\n        addDependency(moduleSpecification, moduleLoader, deploymentUnit, JAVAX_PERSISTENCE_API_ID);\n\n        if (!JPADeploymentMarker.isJPADeployment(deploymentUnit)) {\n            return; // Skip if there are no persistence use in the deployment\n        }\n        addDependency(moduleSpecification, moduleLoader, deploymentUnit, JAVAEE_API_ID, JBOSS_AS_JPA_ID, JBOSS_AS_JPA_SPI_ID, JAVASSIST_ID);\n        addPersistenceProviderModuleDependencies(phaseContext, moduleSpecification, moduleLoader);\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addDependency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader,\n                               ModuleIdentifier moduleIdentifier) {\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, false, false, false, false));\n    }","id":76854,"modified_method":"private void addDependency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader,\n                               DeploymentUnit deploymentUnit, ModuleIdentifier... moduleIdentifiers) {\n        for ( ModuleIdentifier moduleIdentifier : moduleIdentifiers) {\n            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, false, false, false, false));\n            ROOT_LOGGER.debugf(\"added %s dependency to %s\", moduleIdentifier, deploymentUnit.getName());\n        }\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * return true if the {@link DeploymentUnit} is part of a JPA deployment\n     */\n    public static boolean isJPADeployment(DeploymentUnit unit) {\n        if (unit.getParent() == null) {\n            return unit.getAttachment(MARKER) != null;\n        } else {\n            return unit.getParent().getAttachment(MARKER) != null;\n        }\n    }","id":76855,"modified_method":"/**\n     * return true if the {@link DeploymentUnit} is part of a JPA deployment\n     */\n    public static boolean isJPADeployment(DeploymentUnit unit) {\n        unit = DeploymentUtils.getTopDeploymentUnit(unit);\n        return unit.getAttachment(MARKER) != null;\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Mark the top level deployment as being a JPA deployment. If the deployment is not a top level deployment the parent is\n     * marked instead\n     */\n    public static void mark(DeploymentUnit unit) {\n        if (unit.getParent() == null) {\n            unit.putAttachment(MARKER, Boolean.TRUE);\n        } else {\n            unit.getParent().putAttachment(MARKER, Boolean.TRUE);\n        }\n    }","id":76856,"modified_method":"/**\n     * Mark the top level deployment as being a JPA deployment. If the deployment is not a top level deployment the parent is\n     * marked instead\n     */\n    public static void mark(DeploymentUnit unit) {\n        unit = DeploymentUtils.getTopDeploymentUnit(unit);\n        unit.putAttachment(MARKER, Boolean.TRUE);\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n\n        final ServicesAttachment servicesAttachment = deploymentUnit.getAttachment(Attachments.SERVICES);\n        if (module != null && servicesAttachment != null) {\n            final ModuleClassLoader deploymentModuleClassLoader = module.getClassLoader();\n            List<PersistenceProvider> providerList = new ArrayList<PersistenceProvider>();\n            PersistenceProvider provider;\n\n            // collect list of persistence providers packaged with the application\n            final List<String> providerNames = servicesAttachment.getServiceImplementations(PersistenceProvider.class.getName());\n            for (String providerName : providerNames) {\n                try {\n                    final Class<? extends PersistenceProvider> providerClass = deploymentModuleClassLoader.loadClass(providerName).asSubclass(PersistenceProvider.class);\n                    final Constructor<? extends PersistenceProvider> constructor = providerClass.getConstructor();\n                    provider = constructor.newInstance();\n                    ROOT_LOGGER.debugf(\"Deployment has its own Persistence Provider %s \", providerClass);\n                    providerList.add(provider);\n                } catch (Exception e) {\n                    throw MESSAGES.cannotDeployApp(e, providerName);\n                }\n            }\n            if (providerList.size() > 0) {\n                final String adapterClass = deploymentUnit.getAttachment(JpaAttachments.ADAPTOR_CLASS_NAME);\n                PersistenceProviderAdaptor adaptor = null;\n                if (adapterClass != null) {\n                    try {\n                        adaptor = (PersistenceProviderAdaptor) deploymentModuleClassLoader.loadClass(adapterClass).newInstance();\n                        adaptor.injectJtaManager(JtaManagerImpl.getInstance());\n                        deploymentUnit.putAttachment(JpaAttachments.DEPLOYED_PERSISTENCE_PROVIDER, new PersistenceProviderDeploymentHolder(providerList, adaptor));\n                    } catch (InstantiationException e) {\n                        throw MESSAGES.cannotCreateAdapter(e, adapterClass);\n                    } catch (IllegalAccessException e) {\n                        throw MESSAGES.cannotCreateAdapter(e, adapterClass);\n                    } catch (ClassNotFoundException e) {\n                        throw MESSAGES.cannotCreateAdapter(e, adapterClass);\n                    }\n                }\n            }\n\n\n        }\n    }","id":76857,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n\n        final ServicesAttachment servicesAttachment = deploymentUnit.getAttachment(Attachments.SERVICES);\n        if (module != null && servicesAttachment != null) {\n            final ModuleClassLoader deploymentModuleClassLoader = module.getClassLoader();\n            PersistenceProvider provider;\n\n            // collect list of persistence providers packaged with the application\n            final List<String> providerNames = servicesAttachment.getServiceImplementations(PERSISTENCE_PROVIDER_CLASSNAME);\n            List<PersistenceProvider> providerList = new ArrayList<PersistenceProvider>();\n\n            for (String providerName : providerNames) {\n                try {\n                    final Class<? extends PersistenceProvider> providerClass = deploymentModuleClassLoader.loadClass(providerName).asSubclass(PersistenceProvider.class);\n                    final Constructor<? extends PersistenceProvider> constructor = providerClass.getConstructor();\n                    provider = constructor.newInstance();\n                    Set<ClassLoader> deploymentClassLoaders = allDeploymentModuleClassLoaders(deploymentUnit);\n                    ROOT_LOGGER.debugf(\"Deployment has its own persistence provider %s associated with classloaders %s\", providerClass, deploymentClassLoaders.toString());\n\n                    // register persistence provider so javax.persistence.Persistence.createEntityManagerFactory can find it\n                    PersistenceProviderResolverImpl.getInstance().addDeploymentSpecificPersistenceProvider(provider, deploymentClassLoaders);\n\n                    // TODO: instead of passing provider in via PersistenceProviderDeploymentHolder,\n                    // it should instead be looked up via PersistenceProviderResolverImpl (still need to pass adapter in\n                    // or add mechanism to deal with it on a per deployment basis).\n                    providerList.add(provider);\n\n                } catch (Exception e) {\n                    throw MESSAGES.cannotDeployApp(e, providerName);\n                }\n            }\n\n\n            if (providerList.size() > 0) {\n                final String adapterClass = deploymentUnit.getAttachment(JpaAttachments.ADAPTOR_CLASS_NAME);\n                PersistenceProviderAdaptor adaptor;\n                if (adapterClass != null) {\n                    try {\n                        adaptor = (PersistenceProviderAdaptor) deploymentModuleClassLoader.loadClass(adapterClass).newInstance();\n                        adaptor.injectJtaManager(JtaManagerImpl.getInstance());\n                        deploymentUnit.putAttachment(JpaAttachments.DEPLOYED_PERSISTENCE_PROVIDER, new PersistenceProviderDeploymentHolder(providerList, adaptor));\n                    } catch (InstantiationException e) {\n                        throw MESSAGES.cannotCreateAdapter(e, adapterClass);\n                    } catch (IllegalAccessException e) {\n                        throw MESSAGES.cannotCreateAdapter(e, adapterClass);\n                    } catch (ClassNotFoundException e) {\n                        throw MESSAGES.cannotCreateAdapter(e, adapterClass);\n                    }\n                }\n            }\n        }\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void undeploy(final DeploymentUnit context) {\n    }","id":76858,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void undeploy(final DeploymentUnit deploymentUnit) {\n        DeploymentUnit toplevelDeploymentUnit = DeploymentUtils.getTopDeploymentUnit(deploymentUnit);\n        final Module module = toplevelDeploymentUnit.getAttachment(Attachments.MODULE);\n        Set<ClassLoader> deploymentClassLoaders = allDeploymentModuleClassLoaders(deploymentUnit);\n\n        PersistenceProviderResolverImpl.getInstance().clearCachedDeploymentSpecificProviders(deploymentClassLoaders);\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Return a new instance of each persistence provider class\n     * @return\n     */\n    @Override\n    public List<PersistenceProvider> getPersistenceProviders() {\n         List<PersistenceProvider> providersCopy = new ArrayList<PersistenceProvider>(providers.size());\n        for (Class providerClass: providers) {\n            try {\n                providersCopy.add((PersistenceProvider) providerClass.newInstance());\n            } catch (InstantiationException e) {\n                throw JpaMessages.MESSAGES.couldNotCreateInstanceProvider(e, providerClass.getName());\n            } catch (IllegalAccessException e) {\n                throw JpaMessages.MESSAGES.couldNotCreateInstanceProvider(e, providerClass.getName());\n            }\n        }\n        return providersCopy;\n    }","id":76859,"modified_method":"/**\n     * Return a new instance of each persistence provider class\n     *\n     * @return\n     */\n    @Override\n    public List<PersistenceProvider> getPersistenceProviders() {\n        List<PersistenceProvider> providersCopy = new ArrayList<PersistenceProvider>(providers.size());\n\n        /**\n         * Add the application specified providers first so they are found before the global providers\n         */\n        synchronized(persistenceProviderPerClassLoader) {\n            if (persistenceProviderPerClassLoader.size() > 0) {\n                // get the deployment or subdeployment classloader\n                ClassLoader deploymentClassLoader = findParentModuleCl(SecurityActions.getContextClassLoader());\n\n                // collect persistence providers associated with deployment/each sub-deployment\n                List<Class> deploymentSpecificPersistenceProviders = persistenceProviderPerClassLoader.get(deploymentClassLoader);\n                if (deploymentSpecificPersistenceProviders != null) {\n\n                    for (Class providerClass : deploymentSpecificPersistenceProviders) {\n                        try {\n                            ROOT_LOGGER.tracef(\"application has its own Persistence Provider %s\", providerClass.getName());\n                            providersCopy.add((PersistenceProvider) providerClass.newInstance());\n                        } catch (InstantiationException e) {\n                            throw JpaMessages.MESSAGES.couldNotCreateInstanceProvider(e, providerClass.getName());\n                        } catch (IllegalAccessException e) {\n                            throw JpaMessages.MESSAGES.couldNotCreateInstanceProvider(e, providerClass.getName());\n                        }\n                    }\n                }\n            }\n        }\n\n        // add global persistence providers last (so application packaged providers have priority)\n        for (Class providerClass : providers) {\n            try {\n                providersCopy.add((PersistenceProvider) providerClass.newInstance());\n                ROOT_LOGGER.tracef(\"returning global (module) Persistence Provider %s\", providerClass.getName());\n            } catch (InstantiationException e) {\n                throw JpaMessages.MESSAGES.couldNotCreateInstanceProvider(e, providerClass.getName());\n            } catch (IllegalAccessException e) {\n                throw JpaMessages.MESSAGES.couldNotCreateInstanceProvider(e, providerClass.getName());\n            }\n        }\n        return providersCopy;\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Add one PU service per top level deployment that represents\n     *\n     * @param phaseContext\n     * @param puList\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    private void addPuService(DeploymentPhaseContext phaseContext, ArrayList<PersistenceUnitMetadataHolder> puList\n    )\n        throws DeploymentUnitProcessingException {\n\n        if (puList.size() > 0) {\n            final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n            final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n            final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n            final Collection<ComponentDescription> components = eeModuleDescription.getComponentDescriptions();\n            if (module == null)\n                throw MESSAGES.failedToGetModuleAttachment(phaseContext.getDeploymentUnit());\n\n            final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n            final ModuleClassLoader classLoader = module.getClassLoader();\n            PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = deploymentUnit.getAttachment(JpaAttachments.DEPLOYED_PERSISTENCE_PROVIDER);\n            if (persistenceProviderDeploymentHolder == null && deploymentUnit.getParent() != null) {\n                persistenceProviderDeploymentHolder = deploymentUnit.getParent().getAttachment(JpaAttachments.DEPLOYED_PERSISTENCE_PROVIDER);\n            }\n\n\n\n            for (PersistenceUnitMetadataHolder holder : puList) {\n                setAnnotationIndexes(holder, deploymentUnit);\n                for (PersistenceUnitMetadata pu : holder.getPersistenceUnits()) {\n\n                    pu.setClassLoader(classLoader);\n                    try {\n                        final HashMap properties = new HashMap();\n                        if (!ValidationMode.NONE.equals(pu.getValidationMode())) {\n                            ValidatorFactory validatorFactory = SerializableValidatorFactory.validatorFactory();\n                            properties.put(\"javax.persistence.validation.factory\", validatorFactory);\n                        }\n                        final PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor(pu, persistenceProviderDeploymentHolder, deploymentUnit);\n\n\n                        PersistenceProvider provider = null;\n                        if (persistenceProviderDeploymentHolder != null &&\n                            persistenceProviderDeploymentHolder.getProvider() != null) {\n\n                            List<PersistenceProvider> providerList = persistenceProviderDeploymentHolder.getProvider();\n                            for (PersistenceProvider persistenceProvider : providerList) {\n                                if (persistenceProvider.getClass().getName().equals(pu.getPersistenceProviderClassName())) {\n                                    provider = persistenceProvider;\n                                    break;\n                                }\n                            }\n                        }\n                        //  look provider up if we didn't use the providers packaged with the application\n                        if (provider == null) {\n                            provider = lookupProvider(pu);\n                        }\n\n                        final PersistenceUnitServiceImpl service = new PersistenceUnitServiceImpl(classLoader, pu, adaptor, provider);\n\n                        phaseContext.getDeploymentUnit().addToAttachmentList(REMOVAL_KEY, new PersistenceAdaptorRemoval(pu, adaptor));\n\n                        // add persistence provider specific properties\n                        adaptor.addProviderProperties(properties, pu);\n\n\n                        final ServiceName puServiceName = PersistenceUnitServiceImpl.getPUServiceName(pu);\n                        // add the PU service as a dependency to all EE components in this scope\n                        this.addPUServiceDependencyToComponents(components, puServiceName);\n\n                        deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, puServiceName);\n\n                        ServiceBuilder<PersistenceUnitServiceImpl> builder = serviceTarget.addService(puServiceName, service);\n                        boolean useDefaultDataSource = true;\n                        final String jtaDataSource = adjustJndi(pu.getJtaDataSourceName());\n                        final String nonJtaDataSource = adjustJndi(pu.getNonJtaDataSourceName());\n\n                        if (jtaDataSource != null && jtaDataSource.length() > 0) {\n                            if (jtaDataSource.startsWith(\"java:\")) {\n                                builder.addDependency(ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, jtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getJtaDataSourceInjector()));\n                                useDefaultDataSource = false;\n                            } else {\n                                builder.addDependency(AbstractDataSourceService.SERVICE_NAME_BASE.append(jtaDataSource), new CastingInjector<DataSource>(service.getJtaDataSourceInjector(), DataSource.class));\n                                useDefaultDataSource = false;\n                            }\n                        }\n                        if (nonJtaDataSource != null && nonJtaDataSource.length() > 0) {\n                            if (nonJtaDataSource.startsWith(\"java:\")) {\n                                builder.addDependency(ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, nonJtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getNonJtaDataSourceInjector()));\n                                useDefaultDataSource = false;\n                            } else {\n                                builder.addDependency(AbstractDataSourceService.SERVICE_NAME_BASE.append(nonJtaDataSource), new CastingInjector<DataSource>(service.getNonJtaDataSourceInjector(), DataSource.class));\n                                useDefaultDataSource = false;\n                            }\n                        }\n                        // JPA 2.0 8.2.1.5, container provides default JTA datasource\n                        if (useDefaultDataSource) {\n                            final String defaultJtaDataSource = adjustJndi(JPAService.getDefaultDataSourceName());\n                            if (defaultJtaDataSource != null &&\n                                defaultJtaDataSource.length() > 0) {\n                                builder.addDependency(AbstractDataSourceService.SERVICE_NAME_BASE.append(defaultJtaDataSource), new CastingInjector<DataSource>(service.getJtaDataSourceInjector(), DataSource.class));\n                                JPA_LOGGER.tracef(\"%s is using the default data source '%s'\", puServiceName, defaultJtaDataSource);\n                            }\n                        }\n\n                        adaptor.addProviderDependencies(phaseContext.getServiceRegistry(), serviceTarget, builder, pu);\n\n                        if (pu.getProperties().containsKey(JNDI_PROPERTY)) {\n                            String jndiName = pu.getProperties().get(JNDI_PROPERTY).toString();\n                            final ContextNames.BindInfo bindingInfo;\n                            if (jndiName.startsWith(\"java:\")) {\n                                bindingInfo =  ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, jndiName);\n                            }\n                            else {\n                                bindingInfo = ContextNames.bindInfoFor(jndiName);\n                            }\n                            JPA_LOGGER.tracef(\"binding the entity manager factory to jndi name '%s'\", bindingInfo.getAbsoluteJndiName());\n                            final BinderService binderService = new BinderService(bindingInfo.getBindName());\n                            serviceTarget.addService(bindingInfo.getBinderServiceName(), binderService)\n                                .addDependency(bindingInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())\n                                .addDependency(puServiceName, PersistenceUnitServiceImpl.class, new Injector<PersistenceUnitServiceImpl>() {\n                                    @Override\n                                    public void inject(final PersistenceUnitServiceImpl value) throws\n                                        InjectionException {\n                                        binderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value.getEntityManagerFactory())));\n                                    }\n\n                                    @Override\n                                    public void uninject() {\n                                        binderService.getNamingStoreInjector().uninject();\n                                    }\n                                }).install();\n                        }\n\n                        builder.setInitialMode(ServiceController.Mode.ACTIVE)\n                            .addInjection(service.getPropertiesInjector(), properties)\n                            .addInjection(persistenceUnitRegistry.getInjector())\n                            .install();\n\n                        JPA_LOGGER.tracef(\"added PersistenceUnitService for '%s'.  PU is ready for injector action.\", puServiceName);\n                        addManagementConsole(deploymentUnit, pu, service, adaptor);\n\n                    } catch (ServiceRegistryException e) {\n                        throw MESSAGES.failedToAddPersistenceUnit(e, pu.getPersistenceUnitName());\n                    }\n\n                }\n            }\n        }\n    }","id":76860,"modified_method":"/**\n     * Add one PU service per top level deployment that represents\n     *\n     * @param phaseContext\n     * @param puList\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    private void addPuService(DeploymentPhaseContext phaseContext, ArrayList<PersistenceUnitMetadataHolder> puList\n    )\n        throws DeploymentUnitProcessingException {\n\n        if (puList.size() > 0) {\n            final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n            final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n            final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n            final Collection<ComponentDescription> components = eeModuleDescription.getComponentDescriptions();\n            if (module == null)\n                throw MESSAGES.failedToGetModuleAttachment(phaseContext.getDeploymentUnit());\n\n            final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n            final ModuleClassLoader classLoader = module.getClassLoader();\n            PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = deploymentUnit.getAttachment(JpaAttachments.DEPLOYED_PERSISTENCE_PROVIDER);\n            if (persistenceProviderDeploymentHolder == null && deploymentUnit.getParent() != null) {\n                persistenceProviderDeploymentHolder = deploymentUnit.getParent().getAttachment(JpaAttachments.DEPLOYED_PERSISTENCE_PROVIDER);\n            }\n\n\n\n            for (PersistenceUnitMetadataHolder holder : puList) {\n                setAnnotationIndexes(holder, deploymentUnit);\n                for (PersistenceUnitMetadata pu : holder.getPersistenceUnits()) {\n\n                    pu.setClassLoader(classLoader);\n                    try {\n                        final HashMap properties = new HashMap();\n                        if (!ValidationMode.NONE.equals(pu.getValidationMode())) {\n                            ValidatorFactory validatorFactory = SerializableValidatorFactory.validatorFactory();\n                            properties.put(\"javax.persistence.validation.factory\", validatorFactory);\n                        }\n                        final PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor(pu, persistenceProviderDeploymentHolder, deploymentUnit);\n\n\n                        PersistenceProvider provider = null;\n                        if (persistenceProviderDeploymentHolder != null &&\n                            persistenceProviderDeploymentHolder.getProvider() != null) {\n\n                            List<PersistenceProvider> providerList = persistenceProviderDeploymentHolder.getProvider();\n                            for (PersistenceProvider persistenceProvider : providerList) {\n                                if (persistenceProvider.getClass().getName().equals(pu.getPersistenceProviderClassName())) {\n                                    provider = persistenceProvider;\n                                    JPA_LOGGER.tracef(\"deployment %s is using its own copy of %s\", deploymentUnit.getName(), pu.getPersistenceProviderClassName());\n                                    break;\n                                }\n                            }\n                        }\n                        //  look provider up if we didn't use the providers packaged with the application\n                        if (provider == null) {\n                            provider = lookupProvider(pu);\n                        }\n\n                        final PersistenceUnitServiceImpl service = new PersistenceUnitServiceImpl(classLoader, pu, adaptor, provider);\n\n                        phaseContext.getDeploymentUnit().addToAttachmentList(REMOVAL_KEY, new PersistenceAdaptorRemoval(pu, adaptor));\n\n                        // add persistence provider specific properties\n                        adaptor.addProviderProperties(properties, pu);\n\n\n                        final ServiceName puServiceName = PersistenceUnitServiceImpl.getPUServiceName(pu);\n                        // add the PU service as a dependency to all EE components in this scope\n                        this.addPUServiceDependencyToComponents(components, puServiceName);\n\n                        deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, puServiceName);\n\n                        ServiceBuilder<PersistenceUnitServiceImpl> builder = serviceTarget.addService(puServiceName, service);\n                        boolean useDefaultDataSource = true;\n                        final String jtaDataSource = adjustJndi(pu.getJtaDataSourceName());\n                        final String nonJtaDataSource = adjustJndi(pu.getNonJtaDataSourceName());\n\n                        if (jtaDataSource != null && jtaDataSource.length() > 0) {\n                            if (jtaDataSource.startsWith(\"java:\")) {\n                                builder.addDependency(ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, jtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getJtaDataSourceInjector()));\n                                useDefaultDataSource = false;\n                            } else {\n                                builder.addDependency(AbstractDataSourceService.SERVICE_NAME_BASE.append(jtaDataSource), new CastingInjector<DataSource>(service.getJtaDataSourceInjector(), DataSource.class));\n                                useDefaultDataSource = false;\n                            }\n                        }\n                        if (nonJtaDataSource != null && nonJtaDataSource.length() > 0) {\n                            if (nonJtaDataSource.startsWith(\"java:\")) {\n                                builder.addDependency(ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, nonJtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getNonJtaDataSourceInjector()));\n                                useDefaultDataSource = false;\n                            } else {\n                                builder.addDependency(AbstractDataSourceService.SERVICE_NAME_BASE.append(nonJtaDataSource), new CastingInjector<DataSource>(service.getNonJtaDataSourceInjector(), DataSource.class));\n                                useDefaultDataSource = false;\n                            }\n                        }\n                        // JPA 2.0 8.2.1.5, container provides default JTA datasource\n                        if (useDefaultDataSource) {\n                            final String defaultJtaDataSource = adjustJndi(JPAService.getDefaultDataSourceName());\n                            if (defaultJtaDataSource != null &&\n                                defaultJtaDataSource.length() > 0) {\n                                builder.addDependency(AbstractDataSourceService.SERVICE_NAME_BASE.append(defaultJtaDataSource), new CastingInjector<DataSource>(service.getJtaDataSourceInjector(), DataSource.class));\n                                JPA_LOGGER.tracef(\"%s is using the default data source '%s'\", puServiceName, defaultJtaDataSource);\n                            }\n                        }\n\n                        adaptor.addProviderDependencies(phaseContext.getServiceRegistry(), serviceTarget, builder, pu);\n\n                        if (pu.getProperties().containsKey(JNDI_PROPERTY)) {\n                            String jndiName = pu.getProperties().get(JNDI_PROPERTY).toString();\n                            final ContextNames.BindInfo bindingInfo;\n                            if (jndiName.startsWith(\"java:\")) {\n                                bindingInfo =  ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, jndiName);\n                            }\n                            else {\n                                bindingInfo = ContextNames.bindInfoFor(jndiName);\n                            }\n                            JPA_LOGGER.tracef(\"binding the entity manager factory to jndi name '%s'\", bindingInfo.getAbsoluteJndiName());\n                            final BinderService binderService = new BinderService(bindingInfo.getBindName());\n                            serviceTarget.addService(bindingInfo.getBinderServiceName(), binderService)\n                                .addDependency(bindingInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())\n                                .addDependency(puServiceName, PersistenceUnitServiceImpl.class, new Injector<PersistenceUnitServiceImpl>() {\n                                    @Override\n                                    public void inject(final PersistenceUnitServiceImpl value) throws\n                                        InjectionException {\n                                        binderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue<Object>(value.getEntityManagerFactory())));\n                                    }\n\n                                    @Override\n                                    public void uninject() {\n                                        binderService.getNamingStoreInjector().uninject();\n                                    }\n                                }).install();\n                        }\n\n                        builder.setInitialMode(ServiceController.Mode.ACTIVE)\n                            .addInjection(service.getPropertiesInjector(), properties)\n                            .addInjection(persistenceUnitRegistry.getInjector())\n                            .install();\n\n                        JPA_LOGGER.tracef(\"added PersistenceUnitService for '%s'.  PU is ready for injector action.\", puServiceName);\n                        addManagementConsole(deploymentUnit, pu, service, adaptor);\n\n                    } catch (ServiceRegistryException e) {\n                        throw MESSAGES.failedToAddPersistenceUnit(e, pu.getPersistenceUnitName());\n                    }\n\n                }\n            }\n        }\n    }","commit_id":"bd477b6176399af63cb492bb5f58ff8b4efbe14f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public boolean visitNodeCommand( Command.NodeCommand command ) throws IOException\n    {\n        if ( !command.getBefore().inUse() && command.getAfter().inUse() )\n        { // node added\n            nodesDelta++;\n        }\n        else if ( command.getBefore().inUse() && !command.getAfter().inUse() )\n        { // node deleted\n            nodesDelta--;\n        }\n        return true;\n    }","id":76861,"modified_method":"@Override\n    public boolean visitNodeCommand( Command.NodeCommand command ) throws IOException\n    {\n        NodeRecord before = command.getBefore(), after = command.getAfter();\n        if ( !before.inUse() && after.inUse() )\n        { // node added\n            nodesDelta++;\n        }\n        else if ( before.inUse() && !after.inUse() )\n        { // node deleted\n            nodesDelta--;\n        }\n        if ( before.getLabelField() != after.getLabelField() )\n        {\n            long[] labelsBefore = labels( before );\n            long[] labelsAfter = labels( after );\n            for ( PrimitiveLongIterator added = diff( labelsBefore, labelsAfter ); added.hasNext(); )\n            {\n                label( (int) added.next() ).increment();\n            }\n            for ( PrimitiveLongIterator removed = diff( labelsAfter, labelsBefore ); removed.hasNext(); )\n            {\n                label( (int) removed.next() ).decrement();\n            }\n        }\n        return true;\n    }","commit_id":"00b65e4adfcfca39b6500f7bf671e66d95ee3023","url":"https://github.com/neo4j/neo4j"},{"original_method":"public CountStoreApplier( CountsStore countsStore )\n    {\n        this.countsStore = countsStore;\n    }","id":76862,"modified_method":"public CountStoreApplier( CountsStore countsStore, NodeStore nodeStore )\n    {\n        this.countsStore = countsStore;\n        this.nodeStore = nodeStore;\n    }","commit_id":"00b65e4adfcfca39b6500f7bf671e66d95ee3023","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void apply()\n    {\n        countsStore.updateCountsForNode( ANY_LABEL, nodesDelta );\n    }","id":76863,"modified_method":"@Override\n    public void apply()\n    {\n        countsStore.updateCountsForNode( ANY_LABEL, nodesDelta );\n        for ( Map.Entry<Integer, IntCounter> label : labelDelta.entrySet() )\n        {\n            countsStore.updateCountsForNode( label.getKey(), label.getValue().value() );\n        }\n    }","commit_id":"00b65e4adfcfca39b6500f7bf671e66d95ee3023","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void apply( TransactionRepresentation representation, LockGroup locks,\n                       long transactionId, boolean applyRecovered )\n            throws IOException\n    {\n        NeoCommandHandler storeApplier = new NeoTransactionStoreApplier(\n                neoStore, indexingService, cacheAccess, lockService, locks, transactionId,\n                highIdTrackerFactory, applyRecovered );\n        NeoCommandHandler countStoreApplier = new CountStoreApplier( neoStore.getCountsStore() );\n        NeoCommandHandler indexApplier = new NeoTransactionIndexApplier( indexingService,\n                labelScanStore, neoStore.getNodeStore(), neoStore.getPropertyStore(), cacheAccess, propertyLoader );\n        NeoCommandHandler legacyIndexApplier = new LegacyIndexApplier( indexConfigStore,\n                legacyIndexProviderLookup, legacyIndexTransactionOrdering, transactionId, applyRecovered );\n\n        try ( CommandApplierFacade applier = new CommandApplierFacade(\n                storeApplier, countStoreApplier, indexApplier, legacyIndexApplier ) )\n        {\n            representation.accept( applier );\n        }\n    }","id":76864,"modified_method":"public void apply( TransactionRepresentation representation, LockGroup locks,\n                       long transactionId, boolean applyRecovered )\n            throws IOException\n    {\n        NeoCommandHandler storeApplier = new NeoTransactionStoreApplier(\n                neoStore, indexingService, cacheAccess, lockService, locks, transactionId,\n                highIdTrackerFactory, applyRecovered );\n        NeoCommandHandler countStoreApplier = new CountStoreApplier( neoStore.getCountsStore(), neoStore.getNodeStore() );\n        NeoCommandHandler indexApplier = new NeoTransactionIndexApplier( indexingService,\n                labelScanStore, neoStore.getNodeStore(), neoStore.getPropertyStore(), cacheAccess, propertyLoader );\n        NeoCommandHandler legacyIndexApplier = new LegacyIndexApplier( indexConfigStore,\n                legacyIndexProviderLookup, legacyIndexTransactionOrdering, transactionId, applyRecovered );\n\n        try ( CommandApplierFacade applier = new CommandApplierFacade(\n                storeApplier, countStoreApplier, indexApplier, legacyIndexApplier ) )\n        {\n            representation.accept( applier );\n        }\n    }","commit_id":"00b65e4adfcfca39b6500f7bf671e66d95ee3023","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean visitLabelTokenCommand( Command.LabelTokenCommand command ) throws IOException\n    {\n    \tif ( recovery )\n    \t{\n    \t\tneoStore.getLabelTokenStore().setHighId( command.getRecord().getId() );\n    \t}\n        neoStore.getLabelTokenStore().updateRecord( command.getRecord() );\n        if ( recovery )\n        {\n            addLabel( (int) command.getKey() );\n        }\n        invalidateCache( command );\n        return true;\n    }","id":76865,"modified_method":"@Override\n    public boolean visitLabelTokenCommand( Command.LabelTokenCommand command ) throws IOException\n    {\n    \tif ( recovery )\n    \t{\n    \t\tneoStore.getLabelTokenStore().setHighId( command.getRecord().getId() );\n    \t}\n        neoStore.getLabelTokenStore().updateRecord( command.getRecord() );\n        if ( recovery )\n        {\n            Token labelId = neoStore.getLabelTokenStore().getToken( (int) command.getKey() );\n            cacheAccess.addLabelToken( labelId );\n        }\n        invalidateCache( command );\n        return true;\n    }","commit_id":"14255c1b7ebacba32bdab8a139da8dc1ca6b9c4c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean nodeHasBeenUpgradedToDense( NodeCommand command )\n    {\n        return command.getBefore().inUse() && !command.getBefore().isDense() &&\n                command.getAfter().inUse() && command.getAfter().isDense();\n    }","id":76866,"modified_method":"private boolean nodeHasBeenUpgradedToDense( NodeCommand command )\n    {\n        final NodeRecord before = command.getBefore();\n        final NodeRecord after = command.getAfter();\n\n        return before.inUse() && !before.isDense() &&\n                after.inUse() && after.isDense();\n    }","commit_id":"14255c1b7ebacba32bdab8a139da8dc1ca6b9c4c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean visitNodeCommand( Command.NodeCommand command ) throws IOException\n    {\n        // acquire lock\n        lockGroup.add( lockService.acquireNodeLock( command.getKey(), LockService.LockType.WRITE_LOCK ) );\n\n        if ( recovery )\n        {\n        \tneoStore.getNodeStore().setHighId( command.getAfter().getId() );\n        }\n        // update store\n        neoStore.getNodeStore().updateRecord( command.getAfter() );\n\n        // Dynamic Label Records\n        Collection<DynamicRecord> toUpdate = new ArrayList<>( command.getAfter().getDynamicLabelRecords() );\n        // the dynamic label records that exist in before, but not in after should be deleted.\n        Set<Long> idsToRemove = new HashSet<>();\n        for ( DynamicRecord record : command.getBefore().getDynamicLabelRecords() )\n        {\n            idsToRemove.add( record.getId() );\n        }\n        for ( DynamicRecord record : command.getAfter().getDynamicLabelRecords() )\n        {\n            idsToRemove.remove( record.getId() );\n        }\n        for ( long id : idsToRemove )\n        {\n            toUpdate.add( new DynamicRecord( id ) );\n        }\n\n        if ( recovery )\n        {\n        \tfor ( DynamicRecord record : toUpdate )\n        \t{\n        \t\tneoStore.getNodeStore().getDynamicLabelStore().setHighId( record.getId() );\n        \t}\n        }\n        neoStore.getNodeStore().updateDynamicLabelRecords( toUpdate );\n\n        invalidateCache( command );\n        // Additional cache invalidation check for nodes that have just been upgraded to dense\n        if ( nodeHasBeenUpgradedToDense( command ) )\n        {\n            command.invalidateCache( cacheAccess );\n        }\n        return true;\n    }","id":76867,"modified_method":"@Override\n    public boolean visitNodeCommand( Command.NodeCommand command ) throws IOException\n    {\n        // acquire lock\n        lockGroup.add( lockService.acquireNodeLock( command.getKey(), LockService.LockType.WRITE_LOCK ) );\n\n        if ( recovery )\n        {\n        \tneoStore.getNodeStore().setHighId( command.getAfter().getId() );\n        }\n        // update store\n        neoStore.getNodeStore().updateRecord( command.getAfter() );\n\n        // Dynamic Label Records\n        Collection<DynamicRecord> toUpdate = new ArrayList<>( command.getAfter().getDynamicLabelRecords() );\n        // the dynamic label records that exist in before, but not in after should be deleted.\n        Set<Long> idsToRemove = new HashSet<>();\n        for ( DynamicRecord record : command.getBefore().getDynamicLabelRecords() )\n        {\n            idsToRemove.add( record.getId() );\n        }\n        for ( DynamicRecord record : command.getAfter().getDynamicLabelRecords() )\n        {\n            idsToRemove.remove( record.getId() );\n        }\n        for ( long id : idsToRemove )\n        {\n            toUpdate.add( new DynamicRecord( id ) );\n        }\n\n        if ( recovery )\n        {\n        \tfor ( DynamicRecord record : toUpdate )\n        \t{\n        \t\tneoStore.getNodeStore().getDynamicLabelStore().setHighId( record.getId() );\n        \t}\n        }\n        neoStore.getNodeStore().updateDynamicLabelRecords( toUpdate );\n\n        // Additional cache invalidation check for nodes that have just been upgraded to dense\n        invalidateCache( command, nodeHasBeenUpgradedToDense( command ) );\n        return true;\n    }","commit_id":"14255c1b7ebacba32bdab8a139da8dc1ca6b9c4c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void invalidateCache( Command command )\n    {\n        if ( recovery || command.getMode() == Mode.DELETE )\n        {\n            command.invalidateCache( cacheAccess );\n        }\n    }","id":76868,"modified_method":"private void invalidateCache( Command command ) {\n        invalidateCache( command, false );\n    }","commit_id":"14255c1b7ebacba32bdab8a139da8dc1ca6b9c4c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean visitRelationshipTypeTokenCommand( Command.RelationshipTypeTokenCommand command ) throws\n            IOException\n    {\n    \tif ( recovery )\n    \t{\n    \t\tneoStore.getRelationshipTypeTokenStore().setHighId(command.getRecord().getId() );\n    \t}\n        neoStore.getRelationshipTypeTokenStore().updateRecord( command.getRecord() );\n        if ( recovery )\n        {\n            addRelationshipType( (int) command.getKey() );\n        }\n        invalidateCache( command );\n        return true;\n    }","id":76869,"modified_method":"@Override\n    public boolean visitRelationshipTypeTokenCommand( Command.RelationshipTypeTokenCommand command ) throws IOException\n    {\n    \tif ( recovery )\n    \t{\n    \t\tneoStore.getRelationshipTypeTokenStore().setHighId( command.getRecord().getId() );\n    \t}\n        neoStore.getRelationshipTypeTokenStore().updateRecord( command.getRecord() );\n        if ( recovery )\n        {\n            Token type = neoStore.getRelationshipTypeTokenStore().getToken( (int) command.getKey() );\n            cacheAccess.addRelationshipTypeToken( type );\n        }\n        invalidateCache( command );\n        return true;\n    }","commit_id":"14255c1b7ebacba32bdab8a139da8dc1ca6b9c4c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean visitPropertyKeyTokenCommand( Command.PropertyKeyTokenCommand command ) throws IOException\n    {\n    \tif ( recovery )\n    \t{\n    \t\tneoStore.getPropertyKeyTokenStore().setHighId( command.getRecord().getId() );\n    \t}\n        neoStore.getPropertyStore().getPropertyKeyTokenStore().updateRecord( command.getRecord() );\n        if ( recovery )\n        {\n            addPropertyKey( (int) command.getKey() );\n        }\n        invalidateCache( command );\n        return true;\n    }","id":76870,"modified_method":"@Override\n    public boolean visitPropertyKeyTokenCommand( Command.PropertyKeyTokenCommand command ) throws IOException\n    {\n    \tif ( recovery )\n    \t{\n    \t\tneoStore.getPropertyKeyTokenStore().setHighId( command.getRecord().getId() );\n    \t}\n        neoStore.getPropertyKeyTokenStore().updateRecord( command.getRecord() );\n        if ( recovery )\n        {\n            Token index = neoStore.getPropertyKeyTokenStore().getToken( (int) command.getKey() );\n            cacheAccess.addPropertyKeyToken( index );\n        }\n        invalidateCache( command );\n        return true;\n    }","commit_id":"14255c1b7ebacba32bdab8a139da8dc1ca6b9c4c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public Set<Long> changedNodeIds()\n    {\n        Set<Long> nodeIds = new HashSet<>( nodeCommands.keySet() );\n        for ( List<PropertyCommand> propCmd : propCommands )\n        {\n            PropertyRecord record = propCmd.get( 0 ).getAfter();\n            if ( record.isNodeSet() )\n            {\n                nodeIds.add( record.getNodeId() );\n            }\n        }\n        return nodeIds;\n    }","id":76871,"modified_method":"@Override\n    public Set<Long> changedNodeIds()\n    {\n        Set<Long> nodeIds = new HashSet<>( nodeCommands.keySet() );\n        nodeIds.addAll( propCommands.keySet() );\n        return nodeIds;\n    }","commit_id":"8d778e8f2602bf8ce78a62b31a173e0ec2fa9657","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void gatherUpdatesFromPropertyCommands( Collection<NodePropertyUpdate> updates,\n                                                    Map<Pair<Long, Integer>, NodePropertyUpdate> propertyLookup )\n    {\n        for ( List<PropertyCommand> propertyCommands : propCommands )\n        {\n            // Let after state of first command here be representative of the whole group\n            PropertyRecord representative = propertyCommands.get( 0 ).getAfter();\n            if ( !representative.isNodeSet() )\n            {   // These changes wasn't for a node, skip them\n                continue;\n            }\n\n            long nodeId = representative.getNodeId();\n            long[] nodeLabelsBefore, nodeLabelsAfter;\n            NodeCommand nodeChanges = nodeCommands.get( nodeId );\n            if ( nodeChanges != null )\n            {\n                nodeLabelsBefore = parseLabelsField( nodeChanges.getBefore() ).get( nodeStore );\n                nodeLabelsAfter = parseLabelsField( nodeChanges.getAfter() ).get( nodeStore );\n            }\n            else\n            {\n                /* If the node doesn't exist here then we've most likely encountered this scenario:\n                 * - TX1: Node N exists and has property record P\n                 * - rotate log\n                 * - TX2: P gets changed\n                 * - TX3: N gets deleted (also P, but that's irrelevant for this scenario)\n                 * - N is persisted to disk for some reason\n                 * - crash\n                 * - recover\n                 * - TX2: P has changed and updates to indexes are gathered. As part of that it tries to read\n                 *        the labels of N (which does not exist a.t.m.).\n                 *\n                 * We can actually (if we disregard any potential inconsistencies) just assume that\n                 * if this happens and we're in recovery mode that the node in question will be deleted\n                 * in an upcoming transaction, so just skip this update.\n                 */\n                NodeRecord nodeRecord = nodeStore.getRecord( nodeId );\n                nodeLabelsBefore = nodeLabelsAfter = parseLabelsField( nodeRecord ).get( nodeStore );\n            }\n\n            propertyStore.toLogicalUpdates( updates,\n                    Iterables.<PropertyRecordChange, PropertyCommand>cast( propertyCommands ),\n                    nodeLabelsBefore, nodeLabelsAfter );\n        }\n\n        for ( NodePropertyUpdate update : updates )\n        {\n            if ( update.getUpdateMode() == UpdateMode.CHANGED )\n            {\n                propertyLookup.put( Pair.of( update.getNodeId(), update.getPropertyKeyId() ), update );\n            }\n        }\n    }","id":76872,"modified_method":"private void gatherUpdatesFromPropertyCommands( Collection<NodePropertyUpdate> updates,\n                                                    Map<Pair<Long, Integer>, NodePropertyUpdate> propertyLookup )\n    {\n        for ( List<PropertyCommand> propertyCommands : propCommands.values() )\n        {\n            // Let after state of first command here be representative of the whole group\n            PropertyRecord representative = propertyCommands.get( 0 ).getAfter();\n            if ( !representative.isNodeSet() )\n            {   // These changes wasn't for a node, skip them\n                continue;\n            }\n\n            long nodeId = representative.getNodeId();\n            long[] nodeLabelsBefore, nodeLabelsAfter;\n            NodeCommand nodeChanges = nodeCommands.get( nodeId );\n            if ( nodeChanges != null )\n            {\n                nodeLabelsBefore = parseLabelsField( nodeChanges.getBefore() ).get( nodeStore );\n                nodeLabelsAfter = parseLabelsField( nodeChanges.getAfter() ).get( nodeStore );\n            }\n            else\n            {\n                /* If the node doesn't exist here then we've most likely encountered this scenario:\n                 * - TX1: Node N exists and has property record P\n                 * - rotate log\n                 * - TX2: P gets changed\n                 * - TX3: N gets deleted (also P, but that's irrelevant for this scenario)\n                 * - N is persisted to disk for some reason\n                 * - crash\n                 * - recover\n                 * - TX2: P has changed and updates to indexes are gathered. As part of that it tries to read\n                 *        the labels of N (which does not exist a.t.m.).\n                 *\n                 * We can actually (if we disregard any potential inconsistencies) just assume that\n                 * if this happens and we're in recovery mode that the node in question will be deleted\n                 * in an upcoming transaction, so just skip this update.\n                 */\n                NodeRecord nodeRecord = nodeStore.getRecord( nodeId );\n                nodeLabelsBefore = nodeLabelsAfter = parseLabelsField( nodeRecord ).get( nodeStore );\n            }\n\n            propertyStore.toLogicalUpdates( updates,\n                    Iterables.<PropertyRecordChange, PropertyCommand>cast( propertyCommands ),\n                    nodeLabelsBefore, nodeLabelsAfter );\n        }\n\n        for ( NodePropertyUpdate update : updates )\n        {\n            if ( update.getUpdateMode() == UpdateMode.CHANGED )\n            {\n                propertyLookup.put( Pair.of( update.getNodeId(), update.getPropertyKeyId() ), update );\n            }\n        }\n    }","commit_id":"8d778e8f2602bf8ce78a62b31a173e0ec2fa9657","url":"https://github.com/neo4j/neo4j"},{"original_method":"public LazyIndexUpdates( NodeStore nodeStore, PropertyStore propertyStore,\n                             Collection<List<PropertyCommand>> propCommands,\n                             Map<Long, NodeCommand> nodeCommands, PropertyLoader propertyLoader )\n    {\n        this.nodeStore = nodeStore;\n        this.propertyStore = propertyStore;\n        this.propCommands = propCommands;\n        this.nodeCommands = nodeCommands;\n        this.propertyLoader = propertyLoader;\n    }","id":76873,"modified_method":"public LazyIndexUpdates( NodeStore nodeStore,\n                             PropertyStore propertyStore,\n                             Map<Long, List<PropertyCommand>> propCommands,\n                             Map<Long, NodeCommand> nodeCommands,\n                             PropertyLoader propertyLoader )\n    {\n        this.nodeStore = nodeStore;\n        this.propertyStore = propertyStore;\n        this.propCommands = propCommands;\n        this.nodeCommands = nodeCommands;\n        this.propertyLoader = propertyLoader;\n    }","commit_id":"8d778e8f2602bf8ce78a62b31a173e0ec2fa9657","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void close()\n    {\n        if ( !labelUpdates.isEmpty() )\n        {\n            updateLabelScanStore();\n            cacheAccess.applyLabelUpdates( labelUpdates );\n        }\n\n        if ( !nodeCommands.isEmpty() || !propertyCommands.isEmpty() )\n        {\n            indexingService.updateIndexes( new LazyIndexUpdates(\n                    nodeStore, propertyStore, propertyCommands.values(), nodeCommands, propertyLoader ) );\n        }\n    }","id":76874,"modified_method":"@Override\n    public void close()\n    {\n        if ( !labelUpdates.isEmpty() )\n        {\n            updateLabelScanStore();\n            cacheAccess.applyLabelUpdates( labelUpdates );\n        }\n\n        if ( !nodeCommands.isEmpty() || !propertyCommands.isEmpty() )\n        {\n            indexingService.updateIndexes( new LazyIndexUpdates(\n                    nodeStore, propertyStore, propertyCommands, nodeCommands, propertyLoader ) );\n        }\n    }","commit_id":"8d778e8f2602bf8ce78a62b31a173e0ec2fa9657","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean visitNodeCommand( NodeCommand command ) throws IOException\n    {\n        // for index updates\n        nodeCommands.put( command.getKey(), command );\n\n        // for label store updates\n        NodeLabels labelFieldBefore = parseLabelsField( command.getBefore() );\n        NodeLabels labelFieldAfter = parseLabelsField( command.getAfter() );\n        if ( !(labelFieldBefore.isInlined() && labelFieldAfter.isInlined()\n             && command.getBefore().getLabelField() == command.getAfter().getLabelField()) )\n        {\n            long[] labelsBefore = labelFieldBefore.getIfLoaded();\n            long[] labelsAfter = labelFieldAfter.getIfLoaded();\n            if ( labelsBefore != null && labelsAfter != null )\n            {\n                labelUpdates.add( NodeLabelUpdate.labelChanges( command.getKey(), labelsBefore, labelsAfter ) );\n            }\n        }\n\n        return true;\n    }","id":76875,"modified_method":"@Override\n    public boolean visitNodeCommand( NodeCommand command ) throws IOException\n    {\n        // for index updates\n        nodeCommands.put( command.getKey(), command );\n\n        NodeRecord before = command.getBefore();\n        NodeRecord after = command.getAfter();\n\n        // for label store updates\n        NodeLabels labelFieldBefore = parseLabelsField( before );\n        NodeLabels labelFieldAfter = parseLabelsField( after );\n        if ( !(labelFieldBefore.isInlined() && labelFieldAfter.isInlined()\n                && before.getLabelField() == after.getLabelField()) )\n        {\n            long[] labelsBefore = labelFieldBefore.getIfLoaded();\n            long[] labelsAfter = labelFieldAfter.getIfLoaded();\n            if ( labelsBefore != null && labelsAfter != null )\n            {\n                labelUpdates.add( NodeLabelUpdate.labelChanges( command.getKey(), labelsBefore, labelsAfter ) );\n            }\n        }\n\n        return true;\n    }","commit_id":"8d778e8f2602bf8ce78a62b31a173e0ec2fa9657","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String showMemory(final int memoryUsage) {\n    return myPrefix + Formatters.printFullKBMemory(memoryUsage);\n  }","id":76876,"modified_method":"private String showMemory(final long memoryUsage) {\n    return myPrefix + Formatters.printFullKBMemory(memoryUsage);\n  }","commit_id":"c5d85067d0ac7456355ff0d8e5be62228a298e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getMemoryUsage() {\n    return myMemoryUsage;\n  }","id":76877,"modified_method":"public long getMemoryUsage() {\n    return myMemoryUsage;\n  }","commit_id":"c5d85067d0ac7456355ff0d8e5be62228a298e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getAfterMemory() {\n    return myAfterMemory;\n  }","id":76878,"modified_method":"public long getAfterMemory() {\n    return myAfterMemory;\n  }","commit_id":"c5d85067d0ac7456355ff0d8e5be62228a298e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getBeforeMemory() {\n    return myBeforeMemory;\n  }","id":76879,"modified_method":"public long getBeforeMemory() {\n    return myBeforeMemory;\n  }","commit_id":"c5d85067d0ac7456355ff0d8e5be62228a298e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getMemoryUsage() {\n    return myAfterMemory - myBeforeMemory;\n  }","id":76880,"modified_method":"public long getMemoryUsage() {\n    return myAfterMemory - myBeforeMemory;\n  }","commit_id":"c5d85067d0ac7456355ff0d8e5be62228a298e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Statistics(final ObjectReader reader) {\n    myTime = reader.readInt();\n    myBeforeMemory = reader.readInt();\n    myAfterMemory = reader.readInt();\n  }","id":76881,"modified_method":"public Statistics(final ObjectReader reader) {\n    myTime = reader.readInt();\n    myBeforeMemory = reader.readLong();\n    myAfterMemory = reader.readLong();\n  }","commit_id":"c5d85067d0ac7456355ff0d8e5be62228a298e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final int compare(final Object o1, final Object o2) {\n      return getAspect(getTestStatistics(o2)) - getAspect(getTestStatistics(o1));\n    }","id":76882,"modified_method":"public final int compare(final Object o1, final Object o2) {\n      final long a2 = getAspect(getTestStatistics(o2));\n      final long a1 = getAspect(getTestStatistics(o1));\n      return a2 > a1 ? 1 : a1 > a2 ? -1 : 0;\n    }","commit_id":"c5d85067d0ac7456355ff0d8e5be62228a298e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract int getAspect(Statistics statistics);","id":76883,"modified_method":"protected abstract long getAspect(Statistics statistics);","commit_id":"c5d85067d0ac7456355ff0d8e5be62228a298e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ScriptBuilder createScriptBuilder() {\n    ScriptBuilder scb = new ScriptBuilder();\n    for (String ns : allUsedLangNamespaces()) {\n      LanguageRuntime lr = LanguageRegistry.getInstance().getLanguage(ns);\n      Iterable<IFacet> fcts = lr.getAspect(MakeAspectDescriptor.class).getManifest().facets();\n      scb.withFacetNames(Sequence.fromIterable(fcts).select(new ISelector<IFacet, IFacet.Name>() {\n        public IFacet.Name select(IFacet fct) {\n          return fct.getName();\n        }\n      }));\n      scb.withFacetNames(Sequence.fromIterable(FacetRegistry.getInstance().getFacetsForLanguage(ns)).select(new ISelector<IFacet, IFacet.Name>() {\n        public IFacet.Name select(IFacet fct) {\n          return fct.getName();\n        }\n      }));\n    }\n    return scb.withFinalTarget(new ITarget.Name(\"jetbrains.mps.make.facets.Make.make\"));\n  }","id":76884,"modified_method":"public ScriptBuilder createScriptBuilder() {\n    ScriptBuilder scb = new ScriptBuilder();\n    for (String ns : allUsedLangNamespaces()) {\n      LanguageRuntime lr = LanguageRegistry.getInstance().getLanguage(ns);\n      MakeAspectDescriptor aspect = (lr == null ? null : lr.getAspect(MakeAspectDescriptor.class));\n      Iterable<IFacet> fcts = (aspect == null ? Sequence.fromIterable(Collections.<IFacet>emptyList()) : aspect.getManifest().facets());\n      scb.withFacetNames(Sequence.fromIterable(fcts).select(new ISelector<IFacet, IFacet.Name>() {\n        public IFacet.Name select(IFacet fct) {\n          return fct.getName();\n        }\n      }));\n      scb.withFacetNames(Sequence.fromIterable(FacetRegistry.getInstance().getFacetsForLanguage(ns)).select(new ISelector<IFacet, IFacet.Name>() {\n        public IFacet.Name select(IFacet fct) {\n          return fct.getName();\n        }\n      }));\n    }\n    return scb.withFinalTarget(new ITarget.Name(\"jetbrains.mps.make.facets.Make.make\"));\n  }","commit_id":"76e7b48e8dcb22942f6b418538609aca386e1b49","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @see javax.servlet.http.HttpServlet#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        long requestStartTime = System.currentTimeMillis();\n        RequestHandler requestHandler = this.getRequestHandler(); \n        HttpSession session = request.getSession();\n\n        // setup DEFAULT chararcter encoding and content type, this will be overridden in the RequestHandler for view rendering\n        String charset = getServletContext().getInitParameter(\"charset\");\n        if (charset == null || charset.length() == 0) charset = request.getCharacterEncoding();\n        if (charset == null || charset.length() == 0) charset = \"UTF-8\";\n        Debug.logInfo(\"The character encoding of the request is: [\" + request.getCharacterEncoding() + \"]. The character encoding we will use for the request and response is: [\" + charset + \"]\", module);\n\n        if (!\"none\".equals(charset)) {\n            request.setCharacterEncoding(charset);\n        }\n\n        // setup content type\n        String contentType = \"text/html\";\n        if (charset.length() > 0 && !\"none\".equals(charset)) {\n            response.setContentType(contentType + \"; charset=\" + charset);\n            response.setCharacterEncoding(charset);\n        } else {\n            response.setContentType(contentType);\n        }\n\n        GenericValue userLogin = (GenericValue) session.getAttribute(\"userLogin\");\n        //Debug.log(\"Cert Chain: \" + request.getAttribute(\"javax.servlet.request.X509Certificate\"), module);\n\n        // workaraound if we are in the root webapp\n        String webappName = UtilHttp.getApplicationName(request);\n\n        String rname = \"\";\n        if (request.getPathInfo() != null) {\n            rname = request.getPathInfo().substring(1);\n        }\n        if (rname.indexOf('/') > 0) {\n            rname = rname.substring(0, rname.indexOf('/'));\n        }\n\n        UtilTimer timer = null;\n        if (Debug.timingOn()) {\n            timer = new UtilTimer();\n            timer.setLog(true);\n            timer.timerString(\"[\" + rname + \"] Servlet Starting, doing setup\", module);\n        }\n\n        // Setup the CONTROL_PATH for JSP dispatching.\n        String contextPath = request.getContextPath();\n        if (contextPath == null || \"/\".equals(contextPath)) {\n            contextPath = \"\";\n        }\n        request.setAttribute(\"_CONTROL_PATH_\", contextPath + request.getServletPath());\n        if (Debug.verboseOn())\n            Debug.logVerbose(\"Control Path: \" + request.getAttribute(\"_CONTROL_PATH_\"), module);\n\n        // for convenience, and necessity with event handlers, make security and delegator available in the request:\n        // try to get it from the session first so that we can have a delegator/dispatcher/security for a certain user if desired\n        GenericDelegator delegator = null;\n        String delegatorName = (String) session.getAttribute(\"delegatorName\");\n        if (UtilValidate.isNotEmpty(delegatorName)) {\n            delegator = GenericDelegator.getGenericDelegator(delegatorName);\n        }\n        if (delegator == null) {\n            delegator = (GenericDelegator) getServletContext().getAttribute(\"delegator\");\n        }\n        if (delegator == null) {\n            Debug.logError(\"[ControlServlet] ERROR: delegator not found in ServletContext\", module);\n        } else {\n            request.setAttribute(\"delegator\", delegator);\n            // always put this in the session too so that session events can use the delegator\n            session.setAttribute(\"delegatorName\", delegator.getDelegatorName());\n        }\n\n        LocalDispatcher dispatcher = (LocalDispatcher) session.getAttribute(\"dispatcher\");\n        if (dispatcher == null) {\n            dispatcher = (LocalDispatcher) getServletContext().getAttribute(\"dispatcher\");\n        }\n        if (dispatcher == null) {\n            Debug.logError(\"[ControlServlet] ERROR: dispatcher not found in ServletContext\", module);\n        }\n        request.setAttribute(\"dispatcher\", dispatcher);\n\n        Security security = (Security) session.getAttribute(\"security\");\n        if (security == null) {\n            security = (Security) getServletContext().getAttribute(\"security\");\n        }\n        if (security == null) {\n            Debug.logError(\"[ControlServlet] ERROR: security not found in ServletContext\", module);\n        }\n        request.setAttribute(\"security\", security);\n        \n        request.setAttribute(\"_REQUEST_HANDLER_\", requestHandler);\n\n        // setup some things that should always be there\n        UtilHttp.setInitialRequestInfo(request);\n        VisitHandler.getVisitor(request, response);\n\n        // display details on the servlet objects\n        if (Debug.verboseOn()) {\n            logRequestInfo(request);\n        }\n\n        if (Debug.timingOn()) timer.timerString(\"[\" + rname + \"] Setup done, doing Event(s) and View(s)\", module);\n\n        // some containers call filters on EVERY request, even forwarded ones, so let it know that it came from the control servlet\n        request.setAttribute(ContextFilter.FORWARDED_FROM_SERVLET, Boolean.TRUE);\n\n        String errorPage = null;\n        try {\n            // the ServerHitBin call for the event is done inside the doRequest method\n            requestHandler.doRequest(request, response, null, userLogin, delegator);\n        } catch (RequestHandlerException e) {\n            Throwable throwable = e.getNested() != null ? e.getNested() : e;\n            Debug.logError(throwable, \"Error in request handler: \", module);\n            request.setAttribute(\"_ERROR_MESSAGE_\", throwable.toString());\n            errorPage = requestHandler.getDefaultErrorPage(request);\n        } catch (Exception e) {\n            Debug.logError(e, \"Error in request handler: \", module);\n            request.setAttribute(\"_ERROR_MESSAGE_\", e.toString());\n            errorPage = requestHandler.getDefaultErrorPage(request);\n        }\n\n        // Forward to the JSP\n        // if (Debug.infoOn()) Debug.logInfo(\"[\" + rname + \"] Event done, rendering page: \" + nextPage, module);\n        // if (Debug.timingOn()) timer.timerString(\"[\" + rname + \"] Event done, rendering page: \" + nextPage, module);\n\n        if (errorPage != null) {\n            Debug.logError(\"An error occurred, going to the errorPage: \" + errorPage, module);\n\n            RequestDispatcher rd = request.getRequestDispatcher(errorPage);\n\n            // use this request parameter to avoid infinite looping on errors in the error page...\n            if (request.getAttribute(\"_ERROR_OCCURRED_\") == null && rd != null) {\n                request.setAttribute(\"_ERROR_OCCURRED_\", Boolean.TRUE);\n                Debug.logError(\"Including errorPage: \" + errorPage, module);\n                \n                // NOTE DEJ20070727 after having trouble with all of these, try to get the page out and as a last resort just send something back\n                try {\n                    rd.include(request, response);\n                } catch (Throwable t) {\n                    Debug.logWarning(\"Error while trying to send error page using rd.include (will try response.getOutputStream or response.getWriter): \" + t.toString(), module);\n\n                    String errorMessage = \"ERROR rendering error page [\" + errorPage + \"], but here is the error text: \" + request.getAttribute(\"_ERROR_MESSAGE_\");\n                    try {\n                        if (UtilJ2eeCompat.useOutputStreamNotWriter(getServletContext())) {\n                            response.getOutputStream().print(errorMessage);\n                        } else {\n                            response.getWriter().print(errorMessage);\n                        }\n                    } catch (Throwable t2) {\n                        try {\n                            int errorToSend = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n                            Debug.logWarning(\"Error while trying to write error message using response.getOutputStream or response.getWriter: \" + t.toString() + \"; sending error code [\" + errorToSend + \"], and message [\" + errorMessage + \"]\", module);\n                            response.sendError(errorToSend, errorMessage);\n                        } catch (Throwable t3) {\n                            // wow, still bad... just throw an IllegalStateException with the message and let the servlet container handle it\n                            throw new IllegalStateException(errorMessage);\n                        }\n                    }\n                }\n\n            } else {\n                if (rd == null) {\n                    Debug.logError(\"Could not get RequestDispatcher for errorPage: \" + errorPage, module);\n                }\n\n                String errorMessage = \"<html><body>ERROR in error page, (infinite loop or error page not found with name [\" + errorPage + \"]), but here is the text just in case it helps you: \" + request.getAttribute(\"_ERROR_MESSAGE_\") + \"<\/body><\/html>\";\n                if (UtilJ2eeCompat.useOutputStreamNotWriter(getServletContext())) {\n                    response.getOutputStream().print(errorMessage);\n                } else {\n                    response.getWriter().print(errorMessage);\n                }\n            }\n        }\n\n        // sanity check; make sure we don't have any transactions in place\n        try {\n            // roll back current TX first\n            if (TransactionUtil.isTransactionInPlace()) {\n                Debug.logWarning(\"*** NOTICE: ControlServlet finished w/ a transaction in place! Rolling back.\", module);\n                TransactionUtil.rollback();\n            }\n\n            // now resume/rollback any suspended txs\n            if (TransactionUtil.suspendedTransactionsHeld()) {\n                int suspended = TransactionUtil.cleanSuspendedTransactions();\n                Debug.logWarning(\"Resumed/Rolled Back [\" + suspended + \"] transactions.\", module);\n            }\n        } catch (GenericTransactionException e) {\n            Debug.logWarning(e, module);\n        }\n\n        // run these two again before the ServerHitBin.countRequest call because on a logout this will end up creating a new visit\n        if (response.isCommitted() && request.getSession(false) == null) {\n            // response committed and no session, and we can't get a new session, what to do!\n            // without a session we can't log the hit, etc; so just do nothing; this should NOT happen much!\n            Debug.logError(\"Error in ControlServlet output where response isCommitted and there is no session (probably because of a logout); not saving ServerHit/Bin information because there is no session and as the response isCommitted we can't get a new one. The output was successful, but we just can't save ServerHit/Bin info.\", module);\n        } else {\n            try {\n                UtilHttp.setInitialRequestInfo(request);\n                VisitHandler.getVisitor(request, response);\n                if (requestHandler.trackStats(request)) {\n                    ServerHitBin.countRequest(webappName + \".\" + rname, request, requestStartTime, System.currentTimeMillis() - requestStartTime, userLogin, delegator);\n                } else {\n                    Debug.log(\"Track status is disabled for this request\");\n                }\n            } catch (Throwable t) {\n                Debug.logError(t, \"Error in ControlServlet saving ServerHit/Bin information; the output was successful, but can't save this tracking information. The error was: \" + t.toString(), module);\n            }\n        }\n        if (Debug.timingOn()) timer.timerString(\"[\" + rname + \"] Done rendering page, Servlet Finished\", module);\n    }","id":76885,"modified_method":"/**\n     * @see javax.servlet.http.HttpServlet#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        long requestStartTime = System.currentTimeMillis();\n        RequestHandler requestHandler = this.getRequestHandler(); \n        HttpSession session = request.getSession();\n\n        // setup DEFAULT chararcter encoding and content type, this will be overridden in the RequestHandler for view rendering\n        String charset = getServletContext().getInitParameter(\"charset\");\n        if (charset == null || charset.length() == 0) charset = request.getCharacterEncoding();\n        if (charset == null || charset.length() == 0) charset = \"UTF-8\";\n        Debug.logInfo(\"The character encoding of the request is: [\" + request.getCharacterEncoding() + \"]. The character encoding we will use for the request and response is: [\" + charset + \"]\", module);\n\n        if (!\"none\".equals(charset)) {\n            request.setCharacterEncoding(charset);\n        }\n\n        // setup content type\n        String contentType = \"text/html\";\n        if (charset.length() > 0 && !\"none\".equals(charset)) {\n            response.setContentType(contentType + \"; charset=\" + charset);\n            response.setCharacterEncoding(charset);\n        } else {\n            response.setContentType(contentType);\n        }\n\n        GenericValue userLogin = (GenericValue) session.getAttribute(\"userLogin\");\n        //Debug.log(\"Cert Chain: \" + request.getAttribute(\"javax.servlet.request.X509Certificate\"), module);\n\n        // workaraound if we are in the root webapp\n        String webappName = UtilHttp.getApplicationName(request);\n\n        String rname = \"\";\n        if (request.getPathInfo() != null) {\n            rname = request.getPathInfo().substring(1);\n        }\n        if (rname.indexOf('/') > 0) {\n            rname = rname.substring(0, rname.indexOf('/'));\n        }\n\n        UtilTimer timer = null;\n        if (Debug.timingOn()) {\n            timer = new UtilTimer();\n            timer.setLog(true);\n            timer.timerString(\"[\" + rname + \"] Servlet Starting, doing setup\", module);\n        }\n\n        // Setup the CONTROL_PATH for JSP dispatching.\n        String contextPath = request.getContextPath();\n        if (contextPath == null || \"/\".equals(contextPath)) {\n            contextPath = \"\";\n        }\n        request.setAttribute(\"_CONTROL_PATH_\", contextPath + request.getServletPath());\n        if (Debug.verboseOn())\n            Debug.logVerbose(\"Control Path: \" + request.getAttribute(\"_CONTROL_PATH_\"), module);\n\n        // for convenience, and necessity with event handlers, make security and delegator available in the request:\n        // try to get it from the session first so that we can have a delegator/dispatcher/security for a certain user if desired\n        GenericDelegator delegator = null;\n        String delegatorName = (String) session.getAttribute(\"delegatorName\");\n        if (UtilValidate.isNotEmpty(delegatorName)) {\n            delegator = GenericDelegator.getGenericDelegator(delegatorName);\n        }\n        if (delegator == null) {\n            delegator = (GenericDelegator) getServletContext().getAttribute(\"delegator\");\n        }\n        if (delegator == null) {\n            Debug.logError(\"[ControlServlet] ERROR: delegator not found in ServletContext\", module);\n        } else {\n            request.setAttribute(\"delegator\", delegator);\n            // always put this in the session too so that session events can use the delegator\n            session.setAttribute(\"delegatorName\", delegator.getDelegatorName());\n        }\n\n        LocalDispatcher dispatcher = (LocalDispatcher) session.getAttribute(\"dispatcher\");\n        if (dispatcher == null) {\n            dispatcher = (LocalDispatcher) getServletContext().getAttribute(\"dispatcher\");\n        }\n        if (dispatcher == null) {\n            Debug.logError(\"[ControlServlet] ERROR: dispatcher not found in ServletContext\", module);\n        }\n        request.setAttribute(\"dispatcher\", dispatcher);\n\n        Security security = (Security) session.getAttribute(\"security\");\n        if (security == null) {\n            security = (Security) getServletContext().getAttribute(\"security\");\n        }\n        if (security == null) {\n            Debug.logError(\"[ControlServlet] ERROR: security not found in ServletContext\", module);\n        }\n        request.setAttribute(\"security\", security);\n        \n        request.setAttribute(\"_REQUEST_HANDLER_\", requestHandler);\n\n        // setup some things that should always be there\n        UtilHttp.setInitialRequestInfo(request);\n        VisitHandler.getVisitor(request, response);\n\n        // display details on the servlet objects\n        if (Debug.verboseOn()) {\n            logRequestInfo(request);\n        }\n\n        if (Debug.timingOn()) timer.timerString(\"[\" + rname + \"] Setup done, doing Event(s) and View(s)\", module);\n\n        // some containers call filters on EVERY request, even forwarded ones, so let it know that it came from the control servlet\n        request.setAttribute(ContextFilter.FORWARDED_FROM_SERVLET, Boolean.TRUE);\n\n        String errorPage = null;\n        try {\n            // the ServerHitBin call for the event is done inside the doRequest method\n            requestHandler.doRequest(request, response, null, userLogin, delegator);\n        } catch (RequestHandlerException e) {\n            Throwable throwable = e.getNested() != null ? e.getNested() : e;\n            Debug.logError(throwable, \"Error in request handler: \", module);\n            request.setAttribute(\"_ERROR_MESSAGE_\", throwable.toString());\n            errorPage = requestHandler.getDefaultErrorPage(request);\n        } catch (Exception e) {\n            Debug.logError(e, \"Error in request handler: \", module);\n            request.setAttribute(\"_ERROR_MESSAGE_\", e.toString());\n            errorPage = requestHandler.getDefaultErrorPage(request);\n        }\n\n        // Forward to the JSP\n        // if (Debug.infoOn()) Debug.logInfo(\"[\" + rname + \"] Event done, rendering page: \" + nextPage, module);\n        // if (Debug.timingOn()) timer.timerString(\"[\" + rname + \"] Event done, rendering page: \" + nextPage, module);\n\n        if (errorPage != null) {\n            Debug.logError(\"An error occurred, going to the errorPage: \" + errorPage, module);\n\n            RequestDispatcher rd = request.getRequestDispatcher(errorPage);\n\n            // use this request parameter to avoid infinite looping on errors in the error page...\n            if (request.getAttribute(\"_ERROR_OCCURRED_\") == null && rd != null) {\n                request.setAttribute(\"_ERROR_OCCURRED_\", Boolean.TRUE);\n                Debug.logError(\"Including errorPage: \" + errorPage, module);\n                \n                // NOTE DEJ20070727 after having trouble with all of these, try to get the page out and as a last resort just send something back\n                try {\n                    rd.include(request, response);\n                } catch (Throwable t) {\n                    Debug.logWarning(\"Error while trying to send error page using rd.include (will try response.getOutputStream or response.getWriter): \" + t.toString(), module);\n\n                    String errorMessage = \"ERROR rendering error page [\" + errorPage + \"], but here is the error text: \" + request.getAttribute(\"_ERROR_MESSAGE_\");\n                    try {\n                        if (UtilJ2eeCompat.useOutputStreamNotWriter(getServletContext())) {\n                            response.getOutputStream().print(errorMessage);\n                        } else {\n                            response.getWriter().print(errorMessage);\n                        }\n                    } catch (Throwable t2) {\n                        try {\n                            int errorToSend = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n                            Debug.logWarning(\"Error while trying to write error message using response.getOutputStream or response.getWriter: \" + t.toString() + \"; sending error code [\" + errorToSend + \"], and message [\" + errorMessage + \"]\", module);\n                            response.sendError(errorToSend, errorMessage);\n                        } catch (Throwable t3) {\n                            // wow, still bad... just throw an IllegalStateException with the message and let the servlet container handle it\n                            throw new IllegalStateException(errorMessage);\n                        }\n                    }\n                }\n\n            } else {\n                if (rd == null) {\n                    Debug.logError(\"Could not get RequestDispatcher for errorPage: \" + errorPage, module);\n                }\n\n                String errorMessage = \"<html><body>ERROR in error page, (infinite loop or error page not found with name [\" + errorPage + \"]), but here is the text just in case it helps you: \" + request.getAttribute(\"_ERROR_MESSAGE_\") + \"<\/body><\/html>\";\n                if (UtilJ2eeCompat.useOutputStreamNotWriter(getServletContext())) {\n                    response.getOutputStream().print(errorMessage);\n                } else {\n                    response.getWriter().print(errorMessage);\n                }\n            }\n        }\n\n        // sanity check; make sure we don't have any transactions in place\n        try {\n            // roll back current TX first\n            if (TransactionUtil.isTransactionInPlace()) {\n                Debug.logWarning(\"*** NOTICE: ControlServlet finished w/ a transaction in place! Rolling back.\", module);\n                TransactionUtil.rollback();\n            }\n\n            // now resume/rollback any suspended txs\n            if (TransactionUtil.suspendedTransactionsHeld()) {\n                int suspended = TransactionUtil.cleanSuspendedTransactions();\n                Debug.logWarning(\"Resumed/Rolled Back [\" + suspended + \"] transactions.\", module);\n            }\n        } catch (GenericTransactionException e) {\n            Debug.logWarning(e, module);\n        }\n\n        // run these two again before the ServerHitBin.countRequest call because on a logout this will end up creating a new visit\n        if (response.isCommitted() && request.getSession(false) == null) {\n            // response committed and no session, and we can't get a new session, what to do!\n            // without a session we can't log the hit, etc; so just do nothing; this should NOT happen much!\n            Debug.logError(\"Error in ControlServlet output where response isCommitted and there is no session (probably because of a logout); not saving ServerHit/Bin information because there is no session and as the response isCommitted we can't get a new one. The output was successful, but we just can't save ServerHit/Bin info.\", module);\n        } else {\n            try {\n                UtilHttp.setInitialRequestInfo(request);\n                VisitHandler.getVisitor(request, response);\n                if (requestHandler.trackStats(request)) {\n                    ServerHitBin.countRequest(webappName + \".\" + rname, request, requestStartTime, System.currentTimeMillis() - requestStartTime, userLogin, delegator);\n                }\n            } catch (Throwable t) {\n                Debug.logError(t, \"Error in ControlServlet saving ServerHit/Bin information; the output was successful, but can't save this tracking information. The error was: \" + t.toString(), module);\n            }\n        }\n        if (Debug.timingOn()) timer.timerString(\"[\" + rname + \"] Done rendering page, Servlet Finished\", module);\n    }","commit_id":"970e72b029e9541461b376370926db64fd75dec7","url":"https://github.com/apache/ofbiz"},{"original_method":"public void doRequest(HttpServletRequest request, HttpServletResponse response, String chain,\n            GenericValue userLogin, GenericDelegator delegator) throws RequestHandlerException {\n\n        HttpSession session = request.getSession();\n        String eventType;\n        String eventPath;\n        String eventMethod;\n\n        // workaraound if we are in the root webapp\n        String cname = UtilHttp.getApplicationName(request);\n\n        // Grab data from request object to process\n        String requestUri = RequestHandler.getRequestUri(request.getPathInfo());\n        String nextView = RequestHandler.getNextPageUri(request.getPathInfo());\n        if (request.getAttribute(\"targetRequestUri\") == null) {\n            if (request.getSession().getAttribute(\"_PREVIOUS_REQUEST_\") != null) {\n                request.setAttribute(\"targetRequestUri\", request.getSession().getAttribute(\"_PREVIOUS_REQUEST_\"));\n            } else {\n                request.setAttribute(\"targetRequestUri\", \"/\" + requestUri);\n            }\n        }\n\n        // Check for chained request.\n        if (chain != null) {\n            requestUri = RequestHandler.getRequestUri(chain);\n            if (request.getAttribute(\"_POST_CHAIN_VIEW_\") != null) {\n                nextView = (String) request.getAttribute(\"_POST_CHAIN_VIEW_\");\n            } else {\n                nextView = RequestHandler.getNextPageUri(chain);\n            }\n            if (Debug.infoOn()) Debug.logInfo(\"[RequestHandler]: Chain in place: requestUri=\" + requestUri + \" nextView=\" + nextView + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n        } else {\n            // Check to make sure we are allowed to access this request directly. (Also checks if this request is defined.)\n            // If the request cannot be called, or is not defined, check and see if there is a default-request we an process\n            if (!requestManager.allowDirectRequest(requestUri)) {\n                if (!requestManager.allowDirectRequest(requestManager.getDefaultRequest())) {\n                    throw new RequestHandlerException(\"Unknown request [\" + requestUri + \"]; this request does not exist or cannot be called directly.\");\n                } else {\n                    requestUri = requestManager.getDefaultRequest();\n                }\n            }\n\n            // Check if we SHOULD be secure and are not. If we are posting let it pass to not lose data. (too late now anyway)\n            if (!request.isSecure() && requestManager.requiresHttps(requestUri) && !request.getMethod().equalsIgnoreCase(\"POST\")) {\n                StringBuffer urlBuf = new StringBuffer();\n                urlBuf.append(request.getPathInfo());\n                if (request.getQueryString() != null) {\n                    urlBuf.append(\"?\").append(request.getQueryString());\n                }\n                String newUrl = RequestHandler.makeUrl(request, response, urlBuf.toString());\n                if (newUrl.toUpperCase().startsWith(\"HTTPS\")) {\n                    // if we are supposed to be secure, redirect secure.\n                    callRedirect(newUrl, response, request);\n                }\n            }\n\n            // Check if X509 is required and we are not secure; throw exception\n            if (!request.isSecure() && requestManager.requiresHttpsClientCert(requestUri)) {\n                throw new RequestHandlerException(\"Unknown request [\" + requestUri + \"]; this request does not exist or cannot be called directly.\");\n            }            \n\n            // Check for HTTPS client (x.509) security\n            if (request.isSecure() && requestManager.requiresHttpsClientCert(requestUri)) {            \n                X509Certificate[] clientCerts = (X509Certificate[]) request.getAttribute(\"javax.servlet.request.X509Certificate\"); // 2.2 spec\n                if (clientCerts == null) {\n                    clientCerts = (X509Certificate[]) request.getAttribute(\"javax.net.ssl.peer_certificates\"); // 2.1 spec\n                }\n                if (clientCerts == null) {\n                    Debug.logWarning(\"Received no client certificates from browser\", module);\n                }\n\n                // check if the client has a valid certificate (in our db store)\n                boolean foundTrustedCert = false;\n\n                if (clientCerts == null) {\n                    throw new RequestHandlerException(\"Unknown request [\" + requestUri + \"]; this request does not exist or cannot be called directly.\");\n                } else {\n                    for (int i = 0; i < clientCerts.length; i++) {\n                        Debug.logInfo(clientCerts[i].getSubjectX500Principal().getName(), module);\n                    }\n                   \n                    // check if this is a trusted cert\n                    if (SSLUtil.isClientTrusted(clientCerts, null)) {\n                        foundTrustedCert = true;\n                    }\n                }\n\n                if (!foundTrustedCert) {\n                    Debug.logWarning(\"No trusted certificate found for request [\" + requestUri + \"]\", module);\n                    throw new RequestHandlerException(\"Unknown request [\" + requestUri + \"]; this request does not exist or cannot be called directly.\");\n                }\n            }\n\n            // If its the first visit run the first visit events.\n            if (this.trackVisit(request) && session.getAttribute(\"visit\") == null) {\n                Debug.logInfo(\"This is the first request in this visit.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                // This isn't an event because it is required to run. We do not want to make it optional.\n                GenericValue visit = VisitHandler.getVisit(session);\n                Collection events = requestManager.getFirstVisitEvents();\n\n                if (visit != null && events != null) {\n                    Iterator i = events.iterator();\n\n                    while (i.hasNext()) {\n                        Map eventMap = (Map) i.next();\n                        String eType = (String) eventMap.get(ConfigXMLReader.EVENT_TYPE);\n                        String ePath = (String) eventMap.get(ConfigXMLReader.EVENT_PATH);\n                        String eMeth = (String) eventMap.get(ConfigXMLReader.EVENT_METHOD);\n\n                        try {\n                            String returnString = this.runEvent(request, response, eType, ePath, eMeth);\n                            if (returnString != null && !returnString.equalsIgnoreCase(\"success\")) {\n                                throw new EventHandlerException(\"First-Visit event did not return 'success'.\");\n                            } else if (returnString == null) {\n                                nextView = \"none:\";\n                            }\n                        } catch (EventHandlerException e) {\n                            Debug.logError(e, module);\n                        }\n                    }\n                }\n            } else {\n                Debug.log(\"Track visit is disabled for this request\");\n            }\n\n            // Invoke the pre-processor (but NOT in a chain)\n            Collection preProcEvents = requestManager.getPreProcessor();\n            if (preProcEvents != null) {\n                Iterator i = preProcEvents.iterator();\n\n                while (i.hasNext()) {\n                    Map eventMap = (Map) i.next();\n                    String eType = (String) eventMap.get(ConfigXMLReader.EVENT_TYPE);\n                    String ePath = (String) eventMap.get(ConfigXMLReader.EVENT_PATH);\n                    String eMeth = (String) eventMap.get(ConfigXMLReader.EVENT_METHOD);\n                    try {\n                        String returnString = this.runEvent(request, response, eType, ePath, eMeth);\n                        if (returnString != null && !returnString.equalsIgnoreCase(\"success\")) {\n                            throw new EventHandlerException(\"Pre-Processor event did not return 'success'.\");\n                        } else if (returnString == null) {\n                            nextView = \"none:\";\n                        }\n                    } catch (EventHandlerException e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            }\n        }\n\n        // Pre-Processor/First-Visit event(s) can interrupt the flow by returning null.\n        // Warning: this could cause problems if more then one event attempts to return a response.\n        if (\"none:\".equals(nextView)) {\n            if (Debug.infoOn()) Debug.logInfo(\"[Pre-Processor Interrupted Request, not running: \" + requestUri + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n            return;\n        }\n\n        if (Debug.infoOn()) Debug.logInfo(\"[Processing Request]: \" + requestUri + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n        request.setAttribute(\"thisRequestUri\", requestUri); // store the actual request URI\n        \n        String eventReturnString = null;\n\n        // Perform security check.\n        if (requestManager.requiresAuth(requestUri)) {\n            // Invoke the security handler\n            // catch exceptions and throw RequestHandlerException if failed.\n            Debug.logVerbose(\"[RequestHandler]: AuthRequired. Running security check.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n            String checkLoginType = requestManager.getEventType(\"checkLogin\");\n            String checkLoginPath = requestManager.getEventPath(\"checkLogin\");\n            String checkLoginMethod = requestManager.getEventMethod(\"checkLogin\");\n            String checkLoginReturnString;\n\n            try {\n                checkLoginReturnString = this.runEvent(request, response, checkLoginType,\n                        checkLoginPath, checkLoginMethod);\n            } catch (EventHandlerException e) {\n                throw new RequestHandlerException(e.getMessage(), e);\n            }\n            if (!\"success\".equalsIgnoreCase(checkLoginReturnString)) {\n                // previous URL already saved by event, so just do as the return says...\n                eventReturnString = checkLoginReturnString;\n                requestUri = \"checkLogin\";                            \n            }\n        }\n\n        // Invoke the defined event (unless login failed)\n        if (eventReturnString == null) {\n            eventType = requestManager.getEventType(requestUri);\n            eventPath = requestManager.getEventPath(requestUri);\n            eventMethod = requestManager.getEventMethod(requestUri);\n            if (eventType != null && eventPath != null && eventMethod != null) {\n                try {\n                    long eventStartTime = System.currentTimeMillis();\n\n                    // run the event\n                    eventReturnString = this.runEvent(request, response, eventType, eventPath, eventMethod);\n\n                    // save the server hit\n                    if (this.trackStats(request))\n                        ServerHitBin.countEvent(cname + \".\" + eventMethod, request, eventStartTime,\n                                System.currentTimeMillis() - eventStartTime, userLogin, delegator);\n\n                    // set the default event return\n                    if (eventReturnString == null) {\n                        nextView = \"none:\";\n                    }\n                } catch (EventHandlerException e) {\n                    // check to see if there is an \"error\" response, if so go there and make an request error message\n                    String tryErrorMsg = requestManager.getRequestAttribute(requestUri, \"error\");\n\n                    if (tryErrorMsg != null) {\n                        eventReturnString = \"error\";\n                        Locale locale = UtilHttp.getLocale(request);\n                        String errMsg = UtilProperties.getMessage(RequestHandler.err_resource, \"requestHandler.error_call_event\", locale);\n                        request.setAttribute(\"_ERROR_MESSAGE_\", errMsg + \": \" + e.toString());\n                    } else {\n                        throw new RequestHandlerException(\"Error calling event and no error repsonse was specified\", e);\n                    }\n                }\n            }\n        }\n\n         // If error, then display more error messages:\n         if (\"error\".equals(eventReturnString)) {\n             if (Debug.errorOn()) {\n                 String errorMessageHeader = \"Request \" + requestUri + \" caused an error with the following message: \";\n                 if (request.getAttribute(\"_ERROR_MESSAGE_\") != null) {\n                     Debug.logError(errorMessageHeader + request.getAttribute(\"_ERROR_MESSAGE_\"), module);\n                 }\n                 if (request.getAttribute(\"_ERROR_MESSAGE_LIST_\") != null) {\n                     Debug.logError(errorMessageHeader + request.getAttribute(\"_ERROR_MESSAGE_LIST_\"), module);\n                 }\n             }\n         }\n\n        // Process the eventReturn.\n        String eventReturn = requestManager.getRequestAttribute(requestUri, eventReturnString);\n        if (Debug.verboseOn()) Debug.logVerbose(\"[Response Qualified]: \" + eventReturn + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n\n        // Set the next view (don't use event return if success, default to nextView (which is set to eventReturn later if null); also even if success if it is a type \"none\" response ignore the nextView, ie use the eventReturn)\n        if (eventReturn != null && (!\"success\".equals(eventReturnString) || eventReturn.startsWith(\"none:\"))) nextView = eventReturn;\n        if (Debug.verboseOn()) Debug.logVerbose(\"[Event Response Mapping]: \" + nextView + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n\n        // get the previous request info\n        String previousRequest = (String) request.getSession().getAttribute(\"_PREVIOUS_REQUEST_\");\n        String loginPass = (String) request.getAttribute(\"_LOGIN_PASSED_\");\n\n        // restore previous redirected request's attribute, so redirected page can display previous request's error msg etc.\n        String preReqAttStr = (String) request.getSession().getAttribute(\"_REQ_ATTR_MAP_\");\n        if (preReqAttStr != null) {\n            request.getSession().removeAttribute(\"_REQ_ATTR_MAP_\");\n            byte[] reqAttrMapBytes = StringUtil.fromHexString(preReqAttStr);\n            Map preRequestMap = (Map) UtilObject.getObject(reqAttrMapBytes);\n            if (preRequestMap != null && preRequestMap.size() > 0) {\n                Iterator keys = preRequestMap.keySet().iterator();\n                while (keys.hasNext()){\n                    String key = (String) keys.next();\n                    if(\"_ERROR_MESSAGE_LIST_\".equals(key) || \"_ERROR_MESSAGE_MAP_\".equals(key) || \"_ERROR_MESSAGE_\".equals(key) ||\n                            \"_EVENT_MESSAGE_LIST_\".equals(key) || \"_EVENT_MESSAGE_\".equals(key)) {\n                        Object value = preRequestMap.get(key);\n                        request.setAttribute(key, value);\n                   }\n                }\n            }\n        }\n\n        if (Debug.verboseOn()) Debug.logVerbose(\"[RequestHandler]: previousRequest - \" + previousRequest + \" (\" + loginPass + \")\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n\n        // if previous request exists, and a login just succeeded, do that now.\n        if (previousRequest != null && loginPass != null && loginPass.equalsIgnoreCase(\"TRUE\")) {\n            request.getSession().removeAttribute(\"_PREVIOUS_REQUEST_\");\n            // special case to avoid login/logout looping: if request was \"logout\" before the login, change to null for default success view; do the same for \"login\" to avoid going back to the same page\n            if (\"logout\".equals(previousRequest) || \"/logout\".equals(previousRequest) || \"login\".equals(previousRequest) || \"/login\".equals(previousRequest) || \"checkLogin\".equals(previousRequest) || \"/checkLogin\".equals(previousRequest)) {\n                Debug.logWarning(\"Found special _PREVIOUS_REQUEST_ of [\" + previousRequest + \"], setting to null to avoid problems, not running request again\", module);\n            } else {\n                if (Debug.infoOn()) Debug.logInfo(\"[Doing Previous Request]: \" + previousRequest + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                doRequest(request, response, previousRequest, userLogin, delegator);\n                return; // this is needed or else we will run the view twice\n            }\n        }\n\n        String successView = requestManager.getViewName(requestUri);\n        if (\"success\".equals(eventReturnString) && successView.startsWith(\"request:\")) {\n            // chains will override any url defined views; but we will save the view for the very end\n            if (nextView != null) {\n                request.setAttribute(\"_POST_CHAIN_VIEW_\", nextView);\n            }\n            nextView = successView;\n        }\n\n        // Make sure we have some sort of response to go to\n        if (nextView == null) nextView = successView;\n        if (Debug.verboseOn()) Debug.logVerbose(\"[Current View]: \" + nextView + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n\n        // Handle the responses - chains/views\n        if (nextView != null && nextView.startsWith(\"request:\")) {\n            // chained request\n            Debug.logInfo(\"[RequestHandler.doRequest]: Response is a chained request.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n            nextView = nextView.substring(8);\n            doRequest(request, response, nextView, userLogin, delegator);\n        } else { // handle views\n            // first invoke the post-processor events.\n            Collection postProcEvents = requestManager.getPostProcessor();\n            if (chain == null && postProcEvents != null) { // don't run post-proc events on chained requests\n                Iterator i = postProcEvents.iterator();\n\n                while (i.hasNext()) {\n                    Map eventMap = (Map) i.next();\n                    String eType = (String) eventMap.get(ConfigXMLReader.EVENT_TYPE);\n                    String ePath = (String) eventMap.get(ConfigXMLReader.EVENT_PATH);\n                    String eMeth = (String) eventMap.get(ConfigXMLReader.EVENT_METHOD);\n                    try {\n                        String returnString = this.runEvent(request, response, eType, ePath, eMeth);\n                        if (returnString != null && !returnString.equalsIgnoreCase(\"success\"))\n                            throw new EventHandlerException(\"Post-Processor event did not return 'success'.\");\n                        else if (returnString == null)\n                            nextView = \"none:\";\n                    } catch (EventHandlerException e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            }\n\n            if (nextView != null && nextView.startsWith(\"url:\")) {\n                // check for a url for redirection\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a URL redirect.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                nextView = nextView.substring(4);\n                callRedirect(nextView, response, request);\n            } else if (nextView != null && nextView.startsWith(\"cross-redirect:\")) {\n                // check for a cross-application redirect\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a Cross-Application redirect.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                String url = nextView.startsWith(\"/\") ? nextView : \"/\" + nextView;\n                callRedirect(url + this.makeQueryString(request), response, request);\n            } else if (nextView != null && nextView.startsWith(\"request-redirect:\")) {\n                // check for a Request redirect\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a Request redirect.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                nextView = nextView.substring(17);\n                callRedirect(makeLinkWithQueryString(request, response, \"/\" + nextView), response, request);\n            } else if (nextView != null && nextView.startsWith(\"request-redirect-noparam:\")) {\n                // check for a Request redirect\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a Request redirect with no parameters.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                nextView = nextView.substring(25);\n                callRedirect(makeLink(request, response, nextView), response, request);\n            } else if (nextView != null && nextView.startsWith(\"view:\")) {\n                // check for a View\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a view.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                nextView = nextView.substring(5);\n                renderView(nextView, requestManager.allowExtView(requestUri), request, response);\n            } else if (nextView != null && nextView.startsWith(\"none:\")) {\n                // check for a no dispatch return (meaning the return was processed by the event\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is handled by the event.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n            } else if (nextView != null) {\n                // a page request\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a page [\" + nextView + \"]\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                renderView(nextView, requestManager.allowExtView(requestUri), request, response);\n            } else {\n                // unknown request\n                throw new RequestHandlerException(\"Illegal response; handler could not process [\" + eventReturnString + \"].\");\n            }\n        }\n    }","id":76886,"modified_method":"public void doRequest(HttpServletRequest request, HttpServletResponse response, String chain,\n            GenericValue userLogin, GenericDelegator delegator) throws RequestHandlerException {\n\n        HttpSession session = request.getSession();\n        String eventType;\n        String eventPath;\n        String eventMethod;\n\n        // workaraound if we are in the root webapp\n        String cname = UtilHttp.getApplicationName(request);\n\n        // Grab data from request object to process\n        String requestUri = RequestHandler.getRequestUri(request.getPathInfo());\n        String nextView = RequestHandler.getNextPageUri(request.getPathInfo());\n        if (request.getAttribute(\"targetRequestUri\") == null) {\n            if (request.getSession().getAttribute(\"_PREVIOUS_REQUEST_\") != null) {\n                request.setAttribute(\"targetRequestUri\", request.getSession().getAttribute(\"_PREVIOUS_REQUEST_\"));\n            } else {\n                request.setAttribute(\"targetRequestUri\", \"/\" + requestUri);\n            }\n        }\n\n        // Check for chained request.\n        if (chain != null) {\n            requestUri = RequestHandler.getRequestUri(chain);\n            if (request.getAttribute(\"_POST_CHAIN_VIEW_\") != null) {\n                nextView = (String) request.getAttribute(\"_POST_CHAIN_VIEW_\");\n            } else {\n                nextView = RequestHandler.getNextPageUri(chain);\n            }\n            if (Debug.infoOn()) Debug.logInfo(\"[RequestHandler]: Chain in place: requestUri=\" + requestUri + \" nextView=\" + nextView + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n        } else {\n            // Check to make sure we are allowed to access this request directly. (Also checks if this request is defined.)\n            // If the request cannot be called, or is not defined, check and see if there is a default-request we an process\n            if (!requestManager.allowDirectRequest(requestUri)) {\n                if (!requestManager.allowDirectRequest(requestManager.getDefaultRequest())) {\n                    throw new RequestHandlerException(\"Unknown request [\" + requestUri + \"]; this request does not exist or cannot be called directly.\");\n                } else {\n                    requestUri = requestManager.getDefaultRequest();\n                }\n            }\n\n            // Check if we SHOULD be secure and are not. If we are posting let it pass to not lose data. (too late now anyway)\n            if (!request.isSecure() && requestManager.requiresHttps(requestUri) && !request.getMethod().equalsIgnoreCase(\"POST\")) {\n                StringBuffer urlBuf = new StringBuffer();\n                urlBuf.append(request.getPathInfo());\n                if (request.getQueryString() != null) {\n                    urlBuf.append(\"?\").append(request.getQueryString());\n                }\n                String newUrl = RequestHandler.makeUrl(request, response, urlBuf.toString());\n                if (newUrl.toUpperCase().startsWith(\"HTTPS\")) {\n                    // if we are supposed to be secure, redirect secure.\n                    callRedirect(newUrl, response, request);\n                }\n            }\n\n            // Check if X509 is required and we are not secure; throw exception\n            if (!request.isSecure() && requestManager.requiresHttpsClientCert(requestUri)) {\n                throw new RequestHandlerException(\"Unknown request [\" + requestUri + \"]; this request does not exist or cannot be called directly.\");\n            }            \n\n            // Check for HTTPS client (x.509) security\n            if (request.isSecure() && requestManager.requiresHttpsClientCert(requestUri)) {            \n                X509Certificate[] clientCerts = (X509Certificate[]) request.getAttribute(\"javax.servlet.request.X509Certificate\"); // 2.2 spec\n                if (clientCerts == null) {\n                    clientCerts = (X509Certificate[]) request.getAttribute(\"javax.net.ssl.peer_certificates\"); // 2.1 spec\n                }\n                if (clientCerts == null) {\n                    Debug.logWarning(\"Received no client certificates from browser\", module);\n                }\n\n                // check if the client has a valid certificate (in our db store)\n                boolean foundTrustedCert = false;\n\n                if (clientCerts == null) {\n                    throw new RequestHandlerException(\"Unknown request [\" + requestUri + \"]; this request does not exist or cannot be called directly.\");\n                } else {\n                    if (Debug.infoOn()) {\n                        for (int i = 0; i < clientCerts.length; i++) {\n                            Debug.logInfo(clientCerts[i].getSubjectX500Principal().getName(), module);\n                        }\n                    }\n                   \n                    // check if this is a trusted cert\n                    if (SSLUtil.isClientTrusted(clientCerts, null)) {\n                        foundTrustedCert = true;\n                    }\n                }\n\n                if (!foundTrustedCert) {\n                    Debug.logWarning(\"No trusted certificate found for request [\" + requestUri + \"]\", module);\n                    throw new RequestHandlerException(\"Unknown request [\" + requestUri + \"]; this request does not exist or cannot be called directly.\");\n                }\n            }\n\n            // If its the first visit run the first visit events.\n            if (this.trackVisit(request) && session.getAttribute(\"visit\") == null) {\n                if (Debug.infoOn())\n                    Debug.logInfo(\"This is the first request in this visit.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                // This isn't an event because it is required to run. We do not want to make it optional.\n                GenericValue visit = VisitHandler.getVisit(session);\n                Collection events = requestManager.getFirstVisitEvents();\n\n                if (visit != null && events != null) {\n                    Iterator i = events.iterator();\n\n                    while (i.hasNext()) {\n                        Map eventMap = (Map) i.next();\n                        String eType = (String) eventMap.get(ConfigXMLReader.EVENT_TYPE);\n                        String ePath = (String) eventMap.get(ConfigXMLReader.EVENT_PATH);\n                        String eMeth = (String) eventMap.get(ConfigXMLReader.EVENT_METHOD);\n\n                        try {\n                            String returnString = this.runEvent(request, response, eType, ePath, eMeth);\n                            if (returnString != null && !returnString.equalsIgnoreCase(\"success\")) {\n                                throw new EventHandlerException(\"First-Visit event did not return 'success'.\");\n                            } else if (returnString == null) {\n                                nextView = \"none:\";\n                            }\n                        } catch (EventHandlerException e) {\n                            Debug.logError(e, module);\n                        }\n                    }\n                }\n            }\n\n            // Invoke the pre-processor (but NOT in a chain)\n            Collection preProcEvents = requestManager.getPreProcessor();\n            if (preProcEvents != null) {\n                Iterator i = preProcEvents.iterator();\n\n                while (i.hasNext()) {\n                    Map eventMap = (Map) i.next();\n                    String eType = (String) eventMap.get(ConfigXMLReader.EVENT_TYPE);\n                    String ePath = (String) eventMap.get(ConfigXMLReader.EVENT_PATH);\n                    String eMeth = (String) eventMap.get(ConfigXMLReader.EVENT_METHOD);\n                    try {\n                        String returnString = this.runEvent(request, response, eType, ePath, eMeth);\n                        if (returnString != null && !returnString.equalsIgnoreCase(\"success\")) {\n                            throw new EventHandlerException(\"Pre-Processor event did not return 'success'.\");\n                        } else if (returnString == null) {\n                            nextView = \"none:\";\n                        }\n                    } catch (EventHandlerException e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            }\n        }\n\n        // Pre-Processor/First-Visit event(s) can interrupt the flow by returning null.\n        // Warning: this could cause problems if more then one event attempts to return a response.\n        if (\"none:\".equals(nextView)) {\n            if (Debug.infoOn()) Debug.logInfo(\"[Pre-Processor Interrupted Request, not running: \" + requestUri + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n            return;\n        }\n\n        if (Debug.infoOn()) Debug.logInfo(\"[Processing Request]: \" + requestUri + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n        request.setAttribute(\"thisRequestUri\", requestUri); // store the actual request URI\n        \n        String eventReturnString = null;\n\n        // Perform security check.\n        if (requestManager.requiresAuth(requestUri)) {\n            // Invoke the security handler\n            // catch exceptions and throw RequestHandlerException if failed.\n            Debug.logVerbose(\"[RequestHandler]: AuthRequired. Running security check.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n            String checkLoginType = requestManager.getEventType(\"checkLogin\");\n            String checkLoginPath = requestManager.getEventPath(\"checkLogin\");\n            String checkLoginMethod = requestManager.getEventMethod(\"checkLogin\");\n            String checkLoginReturnString;\n\n            try {\n                checkLoginReturnString = this.runEvent(request, response, checkLoginType,\n                        checkLoginPath, checkLoginMethod);\n            } catch (EventHandlerException e) {\n                throw new RequestHandlerException(e.getMessage(), e);\n            }\n            if (!\"success\".equalsIgnoreCase(checkLoginReturnString)) {\n                // previous URL already saved by event, so just do as the return says...\n                eventReturnString = checkLoginReturnString;\n                requestUri = \"checkLogin\";                            \n            }\n        }\n\n        // Invoke the defined event (unless login failed)\n        if (eventReturnString == null) {\n            eventType = requestManager.getEventType(requestUri);\n            eventPath = requestManager.getEventPath(requestUri);\n            eventMethod = requestManager.getEventMethod(requestUri);\n            if (eventType != null && eventPath != null && eventMethod != null) {\n                try {\n                    long eventStartTime = System.currentTimeMillis();\n\n                    // run the event\n                    eventReturnString = this.runEvent(request, response, eventType, eventPath, eventMethod);\n\n                    // save the server hit\n                    if (this.trackStats(request)) {\n                        ServerHitBin.countEvent(cname + \".\" + eventMethod, request, eventStartTime,\n                                System.currentTimeMillis() - eventStartTime, userLogin, delegator);\n                    }\n\n                    // set the default event return\n                    if (eventReturnString == null) {\n                        nextView = \"none:\";\n                    }\n                } catch (EventHandlerException e) {\n                    // check to see if there is an \"error\" response, if so go there and make an request error message\n                    String tryErrorMsg = requestManager.getRequestAttribute(requestUri, \"error\");\n\n                    if (tryErrorMsg != null) {\n                        eventReturnString = \"error\";\n                        Locale locale = UtilHttp.getLocale(request);\n                        String errMsg = UtilProperties.getMessage(RequestHandler.err_resource, \"requestHandler.error_call_event\", locale);\n                        request.setAttribute(\"_ERROR_MESSAGE_\", errMsg + \": \" + e.toString());\n                    } else {\n                        throw new RequestHandlerException(\"Error calling event and no error repsonse was specified\", e);\n                    }\n                }\n            }\n        }\n\n         // If error, then display more error messages:\n         if (\"error\".equals(eventReturnString)) {\n             if (Debug.errorOn()) {\n                 String errorMessageHeader = \"Request \" + requestUri + \" caused an error with the following message: \";\n                 if (request.getAttribute(\"_ERROR_MESSAGE_\") != null) {\n                     Debug.logError(errorMessageHeader + request.getAttribute(\"_ERROR_MESSAGE_\"), module);\n                 }\n                 if (request.getAttribute(\"_ERROR_MESSAGE_LIST_\") != null) {\n                     Debug.logError(errorMessageHeader + request.getAttribute(\"_ERROR_MESSAGE_LIST_\"), module);\n                 }\n             }\n         }\n\n        // Process the eventReturn.\n        String eventReturn = requestManager.getRequestAttribute(requestUri, eventReturnString);\n        if (Debug.verboseOn()) Debug.logVerbose(\"[Response Qualified]: \" + eventReturn + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n\n        // Set the next view (don't use event return if success, default to nextView (which is set to eventReturn later if null); also even if success if it is a type \"none\" response ignore the nextView, ie use the eventReturn)\n        if (eventReturn != null && (!\"success\".equals(eventReturnString) || eventReturn.startsWith(\"none:\"))) nextView = eventReturn;\n        if (Debug.verboseOn()) Debug.logVerbose(\"[Event Response Mapping]: \" + nextView + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n\n        // get the previous request info\n        String previousRequest = (String) request.getSession().getAttribute(\"_PREVIOUS_REQUEST_\");\n        String loginPass = (String) request.getAttribute(\"_LOGIN_PASSED_\");\n\n        // restore previous redirected request's attribute, so redirected page can display previous request's error msg etc.\n        String preReqAttStr = (String) request.getSession().getAttribute(\"_REQ_ATTR_MAP_\");\n        if (preReqAttStr != null) {\n            request.getSession().removeAttribute(\"_REQ_ATTR_MAP_\");\n            byte[] reqAttrMapBytes = StringUtil.fromHexString(preReqAttStr);\n            Map preRequestMap = (Map) UtilObject.getObject(reqAttrMapBytes);\n            if (preRequestMap != null && preRequestMap.size() > 0) {\n                Iterator keys = preRequestMap.keySet().iterator();\n                while (keys.hasNext()){\n                    String key = (String) keys.next();\n                    if(\"_ERROR_MESSAGE_LIST_\".equals(key) || \"_ERROR_MESSAGE_MAP_\".equals(key) || \"_ERROR_MESSAGE_\".equals(key) ||\n                            \"_EVENT_MESSAGE_LIST_\".equals(key) || \"_EVENT_MESSAGE_\".equals(key)) {\n                        Object value = preRequestMap.get(key);\n                        request.setAttribute(key, value);\n                   }\n                }\n            }\n        }\n\n        if (Debug.verboseOn()) Debug.logVerbose(\"[RequestHandler]: previousRequest - \" + previousRequest + \" (\" + loginPass + \")\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n\n        // if previous request exists, and a login just succeeded, do that now.\n        if (previousRequest != null && loginPass != null && loginPass.equalsIgnoreCase(\"TRUE\")) {\n            request.getSession().removeAttribute(\"_PREVIOUS_REQUEST_\");\n            // special case to avoid login/logout looping: if request was \"logout\" before the login, change to null for default success view; do the same for \"login\" to avoid going back to the same page\n            if (\"logout\".equals(previousRequest) || \"/logout\".equals(previousRequest) || \"login\".equals(previousRequest) || \"/login\".equals(previousRequest) || \"checkLogin\".equals(previousRequest) || \"/checkLogin\".equals(previousRequest)) {\n                Debug.logWarning(\"Found special _PREVIOUS_REQUEST_ of [\" + previousRequest + \"], setting to null to avoid problems, not running request again\", module);\n            } else {\n                if (Debug.infoOn()) Debug.logInfo(\"[Doing Previous Request]: \" + previousRequest + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                doRequest(request, response, previousRequest, userLogin, delegator);\n                return; // this is needed or else we will run the view twice\n            }\n        }\n\n        String successView = requestManager.getViewName(requestUri);\n        if (\"success\".equals(eventReturnString) && successView.startsWith(\"request:\")) {\n            // chains will override any url defined views; but we will save the view for the very end\n            if (nextView != null) {\n                request.setAttribute(\"_POST_CHAIN_VIEW_\", nextView);\n            }\n            nextView = successView;\n        }\n\n        // Make sure we have some sort of response to go to\n        if (nextView == null) nextView = successView;\n        if (Debug.verboseOn()) Debug.logVerbose(\"[Current View]: \" + nextView + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n\n        // Handle the responses - chains/views\n        if (nextView != null && nextView.startsWith(\"request:\")) {\n            // chained request\n            Debug.logInfo(\"[RequestHandler.doRequest]: Response is a chained request.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n            nextView = nextView.substring(8);\n            doRequest(request, response, nextView, userLogin, delegator);\n        } else { // handle views\n            // first invoke the post-processor events.\n            Collection postProcEvents = requestManager.getPostProcessor();\n            if (chain == null && postProcEvents != null) { // don't run post-proc events on chained requests\n                Iterator i = postProcEvents.iterator();\n\n                while (i.hasNext()) {\n                    Map eventMap = (Map) i.next();\n                    String eType = (String) eventMap.get(ConfigXMLReader.EVENT_TYPE);\n                    String ePath = (String) eventMap.get(ConfigXMLReader.EVENT_PATH);\n                    String eMeth = (String) eventMap.get(ConfigXMLReader.EVENT_METHOD);\n                    try {\n                        String returnString = this.runEvent(request, response, eType, ePath, eMeth);\n                        if (returnString != null && !returnString.equalsIgnoreCase(\"success\"))\n                            throw new EventHandlerException(\"Post-Processor event did not return 'success'.\");\n                        else if (returnString == null)\n                            nextView = \"none:\";\n                    } catch (EventHandlerException e) {\n                        Debug.logError(e, module);\n                    }\n                }\n            }\n\n            if (nextView != null && nextView.startsWith(\"url:\")) {\n                // check for a url for redirection\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a URL redirect.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                nextView = nextView.substring(4);\n                callRedirect(nextView, response, request);\n            } else if (nextView != null && nextView.startsWith(\"cross-redirect:\")) {\n                // check for a cross-application redirect\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a Cross-Application redirect.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                String url = nextView.startsWith(\"/\") ? nextView : \"/\" + nextView;\n                callRedirect(url + this.makeQueryString(request), response, request);\n            } else if (nextView != null && nextView.startsWith(\"request-redirect:\")) {\n                // check for a Request redirect\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a Request redirect.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                nextView = nextView.substring(17);\n                callRedirect(makeLinkWithQueryString(request, response, \"/\" + nextView), response, request);\n            } else if (nextView != null && nextView.startsWith(\"request-redirect-noparam:\")) {\n                // check for a Request redirect\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a Request redirect with no parameters.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                nextView = nextView.substring(25);\n                callRedirect(makeLink(request, response, nextView), response, request);\n            } else if (nextView != null && nextView.startsWith(\"view:\")) {\n                // check for a View\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a view.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                nextView = nextView.substring(5);\n                renderView(nextView, requestManager.allowExtView(requestUri), request, response);\n            } else if (nextView != null && nextView.startsWith(\"none:\")) {\n                // check for a no dispatch return (meaning the return was processed by the event\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is handled by the event.\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n            } else if (nextView != null) {\n                // a page request\n                Debug.logInfo(\"[RequestHandler.doRequest]: Response is a page [\" + nextView + \"]\" + \" sessionId=\" + UtilHttp.getSessionId(request), module);\n                renderView(nextView, requestManager.allowExtView(requestUri), request, response);\n            } else {\n                // unknown request\n                throw new RequestHandlerException(\"Illegal response; handler could not process [\" + eventReturnString + \"].\");\n            }\n        }\n    }","commit_id":"970e72b029e9541461b376370926db64fd75dec7","url":"https://github.com/apache/ofbiz"},{"original_method":"public String invoke(String eventPath, String eventMethod, HttpServletRequest request, HttpServletResponse response) throws EventHandlerException {        \n        InputStream in;\n        try {\n            in = request.getInputStream();\n        } catch (IOException e) {\n            throw new EventHandlerException(e.getMessage(), e);\n        }\n        OutputStream out;\n        try {\n            out = response.getOutputStream();\n        } catch (IOException e) {\n            throw new EventHandlerException(e.getMessage(), e);\n        }\n\n        Map context = FastMap.newInstance();\n        context.put(\"inputStream\", in);\n        context.put(\"outputStream\", out);\n\n        Debug.log(\"Running service with context: \" + context, module);\n        Map resp;\n        try {\n            resp = dispatcher.runSync(eventMethod, context);\n        } catch (GenericServiceException e) {\n            throw new EventHandlerException(e.getMessage(), e);\n        }\n        Debug.log(\"Received respone: \" + resp, module);\n        if (ServiceUtil.isError(resp)) {\n            throw new EventHandlerException(ServiceUtil.getErrorMessage(resp));\n        }\n        String contentType = (String) resp.get(\"contentType\");\n        if (contentType != null) {\n            response.setContentType(contentType);\n        }\n\n        if (out != null) {\n            try {\n                out.close();\n            } catch (IOException e) {\n                throw new EventHandlerException(ServiceUtil.getErrorMessage(resp));\n            }\n        }\n        \n        return null;\n    }","id":76887,"modified_method":"public String invoke(String eventPath, String eventMethod, HttpServletRequest request, HttpServletResponse response) throws EventHandlerException {        \n        InputStream in;\n        try {\n            in = request.getInputStream();\n        } catch (IOException e) {\n            throw new EventHandlerException(e.getMessage(), e);\n        }\n        OutputStream out;\n        try {\n            out = response.getOutputStream();\n        } catch (IOException e) {\n            throw new EventHandlerException(e.getMessage(), e);\n        }\n\n        Map context = FastMap.newInstance();\n        context.put(\"inputStream\", in);\n        context.put(\"outputStream\", out);\n\n        if (Debug.infoOn()) Debug.logInfo(\"Running service with context: \" + context, module);\n        \n        Map resp;\n        try {\n            resp = dispatcher.runSync(eventMethod, context);\n        } catch (GenericServiceException e) {\n            outputError(out, e, \"Exception thrown in runSync()\");\n            throw new EventHandlerException(e.getMessage(), e);\n        }\n        Debug.log(\"Received respone: \" + resp, module);\n        if (ServiceUtil.isError(resp)) {\n            outputError(out, null, ServiceUtil.getErrorMessage(resp));\n            throw new EventHandlerException(ServiceUtil.getErrorMessage(resp));\n        }\n        String contentType = (String) resp.get(\"contentType\");\n        if (contentType != null) {\n            response.setContentType(contentType);\n        }\n\n        if (out != null) {\n            try {\n                out.close();\n            } catch (IOException e) {\n                throw new EventHandlerException(ServiceUtil.getErrorMessage(resp));\n            }\n        }\n        \n        return null;\n    }","commit_id":"970e72b029e9541461b376370926db64fd75dec7","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Called after a traversal to print out information about the traversal process\n     *\n     * @param type String describing this type of traversal (\"loci\", \"read\")\n     * @param sum  The reduce result of the traversal\n     * @param <T>  ReduceType of the traversal\n     */\n    protected <T> void printOnTraversalDone(final String type, T sum) {\n        printProgress(true, type, null);\n        System.out.println(\"Traversal reduce result is \" + sum);\n        System.out.printf(\"Traversal skipped %d reads out of %d total (%.2f%%)%n\", nSkippedReads, nReads, (nSkippedReads * 100.0) / nReads);\n        System.out.printf(\"  -> %d unmapped reads%n\", nUnmappedReads);\n        System.out.printf(\"  -> %d non-primary reads%n\", nNotPrimary);\n        System.out.printf(\"  -> %d reads with bad alignments%n\", nBadAlignments);\n        System.out.printf(\"  -> %d reads with indels%n\", nSkippedIndels);\n    }","id":76888,"modified_method":"/**\n     * Called after a traversal to print out information about the traversal process\n     *\n     * @param type String describing this type of traversal (\"loci\", \"read\")\n     * @param sum  The reduce result of the traversal\n     * @param <T>  ReduceType of the traversal\n     */\n    protected <T> void printOnTraversalDone(final String type, T sum) {\n        printProgress(true, type, null);\n        logger.info(String.format(\"Traversal reduce result is \" + sum));\n        logger.info(String.format(\"Traversal skipped %d reads out of %d total (%.2f%%)\", nSkippedReads, nReads, (nSkippedReads * 100.0) / nReads));\n        logger.info(String.format(\"  -> %d unmapped reads\", nUnmappedReads));\n        logger.info(String.format(\"  -> %d non-primary reads\", nNotPrimary));\n        logger.info(String.format(\"  -> %d reads with bad alignments\", nBadAlignments));\n        logger.info(String.format(\"  -> %d reads with indels\", nSkippedIndels));\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Traverse by loci -- the key driver of linearly ordered traversal of loci.  Provides reads, RODs, and\n     * the reference base for each locus in the reference to the LocusWalker walker.  Supports all of the\n     * interaction contract implied by the locus walker\n     *\n     * @param walker A locus walker object\n     * @param <M>    MapType -- the result of calling map() on walker\n     * @param <T>    ReduceType -- the result of calling reduce() on the walker\n     * @return 0 on success\n     */\n    protected <M, T> int traverseByLoci(LocusWalker<M, T> walker) {\n        verifySortOrder(true);\n\n        // prepare the read filtering read iterator and provide it to a new locus iterator\n        FilteringIterator filterIter = new FilteringIterator(samReadIter, new locusStreamFilterFunc());\n        //LocusIterator iter = new SingleLocusIterator(filterIter);\n        LocusIterator iter = new LocusIteratorByHanger(filterIter);\n\n        // initialize the walker object\n        walker.initialize();\n        // Initialize the T sum using the walker\n        T sum = walker.reduceInit();\n        boolean done = false;\n        GenomeLoc prevLoc = null;\n\n        int current_interval_index = -1;\n        int current_interval_offset = -1;\n\n        while (iter.hasNext() && !done) {\n            this.nRecords++;\n\n            // actually get the read and hand it to the walker\n            LocusContext locus = iter.next();\n\n            // Poor man's version of index LOL\n            // HALP! I HAZ 10K INTERVALS 2 INDX\n            if (((this.locs != null) && (this.locs.length != 0)) && ((current_interval_index == -1) || (!locus.getLocation().overlapsP(this.locs[current_interval_index])))) {\n                // Advance to the next locus.\n                current_interval_index += 1;\n                current_interval_offset = 0;\n\n                if (this.locs.length <= current_interval_index) {\n                    done = true;\n                    break;\n                }\n\n                //System.out.format(\"DEBUG Seeking from %s to %s\\n\", locus.getLocation().toString(), this.locs[current_interval_index].toString());\n\n                while ((this.locs.length > current_interval_index) && (!locus.getLocation().overlapsP(this.locs[current_interval_index])) && (iter.hasNext())) {\n                    switch (locus.getLocation().compareTo(this.locs[current_interval_index])) {\n                        case -1:\n                            locus = iter.next();\n                            //System.out.format(\"DEBUG at %s\\n\", locus.getLocation().toString());\n                            break;\n                        case 0:\n                            break;\n                        case 1:\n                            current_interval_index += 1;\n                            current_interval_offset = 0;\n                            if (this.locs.length <= current_interval_index) {\n                                done = true;\n                                break;\n                            }\n                            //System.out.format(\"DEBUG Giving up on old locus, Seeking from %s to %s\\n\", locus.getLocation().toString(), this.locs[current_interval_index].toString());\n                            break;\n                    }\n                }\n                if (this.locs.length <= current_interval_index) {\n                    done = true;\n                    break;\n                }\n\n                //System.out.format(\"DEBUG Got there.\\n\");\n            } else {\n                current_interval_offset += 1;\n            }\n\n            {\n                //System.out.format(\"Working at %s\\n\", locus.getLocation().toString());\n\n                // Jump forward in the reference to this locus location\n                final ReferenceIterator refSite;\n                refSite = refIter.seekForward(locus.getLocation());\n                final char refBase = refSite.getBaseAsChar();\n                locus.setReferenceContig(refSite.getCurrentContig());\n\n                // Iterate forward to get all reference ordered data covering this locus\n                final List<ReferenceOrderedDatum> rodData = getReferenceOrderedDataAtLocus(rodIters, locus.getLocation());\n\n                if (DEBUGGING)\n                    System.out.printf(\"  Reference: %s:%d %c%n\", refSite.getCurrentContig().getName(), refSite.getPosition(), refBase);\n\n                //\n                // Execute our contract with the walker.  Call filter, map, and reduce\n                //\n                final boolean keepMeP = walker.filter(rodData, refBase, locus);\n                if (keepMeP) {\n                    M x = walker.map(rodData, refBase, locus);\n                    sum = walker.reduce(x, sum);\n                }\n\n                if (this.maxReads > 0 && this.nRecords > this.maxReads) {\n                    System.out.println(\"Maximum number of reads encountered, terminating traversal \" + this.nRecords);\n                    done = true;\n                }\n\n\n            }\n\n            printProgress(\"loci\", locus.getLocation());\n            if (pastFinalLocation(locus.getLocation()))\n                done = true;\n        }\n\n        printOnTraversalDone(\"loci\", sum);\n        walker.onTraversalDone();\n        return 0;\n    }","id":76889,"modified_method":"/**\n     * Traverse by loci -- the key driver of linearly ordered traversal of loci.  Provides reads, RODs, and\n     * the reference base for each locus in the reference to the LocusWalker walker.  Supports all of the\n     * interaction contract implied by the locus walker\n     *\n     * @param walker A locus walker object\n     * @param <M>    MapType -- the result of calling map() on walker\n     * @param <T>    ReduceType -- the result of calling reduce() on the walker\n     * @return 0 on success\n     */\n    protected <M, T> int traverseByLoci(LocusWalker<M, T> walker) {\n        verifySortOrder(true);\n\n        // prepare the read filtering read iterator and provide it to a new locus iterator\n        FilteringIterator filterIter = new FilteringIterator(samReadIter, new locusStreamFilterFunc());\n        //LocusIterator iter = new SingleLocusIterator(filterIter);\n        LocusIterator iter = new LocusIteratorByHanger(filterIter);\n\n        // initialize the walker object\n        walker.initialize();\n        // Initialize the T sum using the walker\n        T sum = walker.reduceInit();\n        boolean done = false;\n        GenomeLoc prevLoc = null;\n\n        int current_interval_index = -1;\n        int current_interval_offset = -1;\n\n        while (iter.hasNext() && !done) {\n            this.nRecords++;\n\n            // actually get the read and hand it to the walker\n            LocusContext locus = iter.next();\n\n            // Poor man's version of index LOL\n            // HALP! I HAZ 10K INTERVALS 2 INDX\n            if (((this.locs != null) && (this.locs.length != 0)) && ((current_interval_index == -1) || (!locus.getLocation().overlapsP(this.locs[current_interval_index])))) {\n                // Advance to the next locus.\n                current_interval_index += 1;\n                current_interval_offset = 0;\n\n                if (this.locs.length <= current_interval_index) {\n                    done = true;\n                    break;\n                }\n\n                //System.out.format(\"DEBUG Seeking from %s to %s\\n\", locus.getLocation().toString(), this.locs[current_interval_index].toString());\n\n                while ((this.locs.length > current_interval_index) && (!locus.getLocation().overlapsP(this.locs[current_interval_index])) && (iter.hasNext())) {\n                    switch (locus.getLocation().compareTo(this.locs[current_interval_index])) {\n                        case -1:\n                            locus = iter.next();\n                            //System.out.format(\"DEBUG at %s\\n\", locus.getLocation().toString());\n                            break;\n                        case 0:\n                            break;\n                        case 1:\n                            current_interval_index += 1;\n                            current_interval_offset = 0;\n                            if (this.locs.length <= current_interval_index) {\n                                done = true;\n                                break;\n                            }\n                            //System.out.format(\"DEBUG Giving up on old locus, Seeking from %s to %s\\n\", locus.getLocation().toString(), this.locs[current_interval_index].toString());\n                            break;\n                    }\n                }\n                if (this.locs.length <= current_interval_index) {\n                    done = true;\n                    break;\n                }\n\n                //System.out.format(\"DEBUG Got there.\\n\");\n            } else {\n                current_interval_offset += 1;\n            }\n\n            {\n                //System.out.format(\"Working at %s\\n\", locus.getLocation().toString());\n\n                // Jump forward in the reference to this locus location\n                final ReferenceIterator refSite;\n                refSite = refIter.seekForward(locus.getLocation());\n                final char refBase = refSite.getBaseAsChar();\n                locus.setReferenceContig(refSite.getCurrentContig());\n\n                // Iterate forward to get all reference ordered data covering this locus\n                final List<ReferenceOrderedDatum> rodData = getReferenceOrderedDataAtLocus(rodIters, locus.getLocation());\n\n\n                    logger.debug(String.format(\"  Reference: %s:%d %c\", refSite.getCurrentContig().getName(), refSite.getPosition(), refBase));\n\n                //\n                // Execute our contract with the walker.  Call filter, map, and reduce\n                //\n                final boolean keepMeP = walker.filter(rodData, refBase, locus);\n                if (keepMeP) {\n                    M x = walker.map(rodData, refBase, locus);\n                    sum = walker.reduce(x, sum);\n                }\n\n                if (this.maxReads > 0 && this.nRecords > this.maxReads) {\n                    logger.warn(String.format(\"Maximum number of reads encountered, terminating traversal \" + this.nRecords));\n                    done = true;\n                }\n\n\n            }\n\n            printProgress(\"loci\", locus.getLocation());\n            if (pastFinalLocation(locus.getLocation()))\n                done = true;\n        }\n\n        printOnTraversalDone(\"loci\", sum);\n        walker.onTraversalDone();\n        return 0;\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Utility routine that prints out process information (including timing) every N records or\n     * every M seconds, for N and M set in global variables.\n     *\n     * @param mustPrint If true, will print out info, regardless of nRecords or time interval\n     * @param type      String to print out describing our atomic traversal type (\"read\", \"locus\", etc)\n     * @param loc       Current location\n     */\n    public void printProgress(boolean mustPrint, final String type, GenomeLoc loc) {\n        final long nRecords = this.nRecords;\n        final long curTime = System.currentTimeMillis();\n        final double elapsed = (curTime - startTime) / 1000.0;\n        //System.out.printf(\"Cur = %d, last print = %d%n\", curTime, lastProgressPrintTime);\n\n        if (mustPrint || nRecords % N_RECORDS_TO_PRINT == 0 || maxElapsedIntervalForPrinting(curTime)) {\n            this.lastProgressPrintTime = curTime;\n            final double secsPer1MReads = (elapsed * 1000000.0) / nRecords;\n            if (loc != null)\n                System.out.printf(\"[PROGRESS] Traversed to %s, processing %,d %s in %.2f secs (%.2f secs per 1M %s)%n\", loc, nRecords, type, elapsed, secsPer1MReads, type);\n            else\n                System.out.printf(\"[PROGRESS] Traversed %,d %s in %.2f secs (%.2f secs per 1M %s)%n\", nRecords, type, elapsed, secsPer1MReads, type);\n\n            // Currently samReadingTracker will print misleading info if we're not processing the whole file\n\n            // If an index is enabled, file read progress is meaningless because a linear\n            // traversal is not being performed.  For now, don't bother printing progress.\n            // TODO: Create a sam indexed read tracker that tracks based on percentage through the query.\n            if (samReadingTracker != null && this.locs == null)\n                System.out.printf(\"[PROGRESS]   -> %s%n\", samReadingTracker.progressMeter());\n        }\n    }","id":76890,"modified_method":"/**\n     * Utility routine that prints out process information (including timing) every N records or\n     * every M seconds, for N and M set in global variables.\n     *\n     * @param mustPrint If true, will print out info, regardless of nRecords or time interval\n     * @param type      String to print out describing our atomic traversal type (\"read\", \"locus\", etc)\n     * @param loc       Current location\n     */\n    public void printProgress(boolean mustPrint, final String type, GenomeLoc loc) {\n        final long nRecords = this.nRecords;\n        final long curTime = System.currentTimeMillis();\n        final double elapsed = (curTime - startTime) / 1000.0;\n        //System.out.printf(\"Cur = %d, last print = %d%n\", curTime, lastProgressPrintTime);\n\n        if (mustPrint || nRecords % N_RECORDS_TO_PRINT == 0 || maxElapsedIntervalForPrinting(curTime)) {\n            this.lastProgressPrintTime = curTime;\n            final double secsPer1MReads = (elapsed * 1000000.0) / nRecords;\n            if (loc != null)\n                logger.info(String.format(\"[PROGRESS] Traversed to %s, processing %,d %s in %.2f secs (%.2f secs per 1M %s)\", loc, nRecords, type, elapsed, secsPer1MReads, type));\n            else\n                logger.info(String.format(\"[PROGRESS] Traversed %,d %s in %.2f secs (%.2f secs per 1M %s)\", nRecords, type, elapsed, secsPer1MReads, type));\n\n            // Currently samReadingTracker will print misleading info if we're not processing the whole file\n\n            // If an index is enabled, file read progress is meaningless because a linear\n            // traversal is not being performed.  For now, don't bother printing progress.\n            // TODO: Create a sam indexed read tracker that tracks based on percentage through the query.\n            if (samReadingTracker != null && this.locs == null)\n                logger.info(String.format(\"[PROGRESS]   -> %s\", samReadingTracker.progressMeter()));\n        }\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void initializeReads(final boolean THREADED_IO) {\n\n        Iterator<SAMRecord> samIterator;\n        try {\n            samReadIter = loadSAMFile(readsFile, THREADED_IO);\n        }\n        catch (IOException ex) {\n            // TODO: IOException should be a checked exception in this case.\n            throw new RuntimeIOException(ex);\n        }\n\n        if (SORT_ON_FLY)\n            samReadIter = new SortSamIterator(samReadIter, MAX_ON_FLY_SORTS);\n        if (beSafeP)\n            samReadIter = new VerifyingSamIterator(samReadIter);\n\n        if (THREADED_IO) {\n            System.out.printf(\"Enabling threaded I/O with buffer of %d reads%n\", THREADED_IO_BUFFER_SIZE);\n            samReadIter = new ThreadedIterator<SAMRecord>(samReadIter, THREADED_IO_BUFFER_SIZE);\n        }\n    }","id":76891,"modified_method":"private void initializeReads(final boolean THREADED_IO) {\n\n        Iterator<SAMRecord> samIterator;\n        try {\n            samReadIter = loadSAMFile(readsFile, THREADED_IO);\n        }\n        catch (IOException ex) {\n            // TODO: IOException should be a checked exception in this case.\n            throw new RuntimeIOException(ex);\n        }\n\n        if (SORT_ON_FLY)\n            samReadIter = new SortSamIterator(samReadIter, MAX_ON_FLY_SORTS);\n        if (beSafeP)\n            samReadIter = new VerifyingSamIterator(samReadIter);\n\n        if (THREADED_IO) {\n            logger.info(String.format(\"Enabling threaded I/O with buffer of %d reads\", THREADED_IO_BUFFER_SIZE));\n            samReadIter = new ThreadedIterator<SAMRecord>(samReadIter, THREADED_IO_BUFFER_SIZE);\n        }\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * An inappropriately placed testing of reading the reference\n     */\n    protected void testReference() {\n        while (true) {\n            ReferenceSequence ref = refFile.nextSequence();\n            System.out.printf(\"%s %d %d%n\", ref.getName(), ref.length(), System.currentTimeMillis());\n            printProgress(true, \"loci\", new GenomeLoc(\"foo\", 1));\n        }\n    }","id":76892,"modified_method":"/**\n     * An inappropriately placed testing of reading the reference\n     */\n    protected void testReference() {\n        while (true) {\n            ReferenceSequence ref = refFile.nextSequence();\n            logger.debug(String.format(\"%s %d %d\", ref.getName(), ref.length(), System.currentTimeMillis()));\n            printProgress(true, \"loci\", new GenomeLoc(\"foo\", 1));\n        }\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Useful utility function that parses a location string into a coordinate-order sorted\n     * array of GenomeLoc objects\n     *\n     * @param str\n     * @return Array of GenomeLoc objects corresponding to the locations in the string, sorted by coordinate order\n     */\n    public static GenomeLoc[] parseGenomeLocs(final String str) {\n        // Of the form: loc1;loc2;...\n        // Where each locN can be:\n        // �chr2�, �chr2:1000000� or �chr2:1,000,000-2,000,000�\n        StdReflect reflect = new JdkStdReflect();\n        FunctionN<GenomeLoc> parseOne = reflect.staticFunction(GenomeLoc.class, \"parseGenomeLoc\", String.class);\n        Function1<GenomeLoc, String> f1 = parseOne.f1();\n        try {\n            Collection<GenomeLoc> result = Functions.map(f1, Arrays.asList(str.split(\";\")));\n            GenomeLoc[] locs = (GenomeLoc[]) result.toArray(new GenomeLoc[0]);\n            Arrays.sort(locs);\n            System.out.printf(\"  Locations are: %s%n\", Utils.join(\"\\n\", Functions.map(Operators.toString, Arrays.asList(locs))));\n            return locs;\n        } catch (Exception e) {\n            logger.fatal(String.format(\"Invalid locations string: %s, format is loc1;loc2; where each locN can be 'chr2', 'chr2:1000000' or 'chr2:1,000,000-2,000,000'\", str));\n            throw new IllegalArgumentException(\"Invalid locations string: \" + str + \", format is loc1;loc2; where each locN can be 'chr2', 'chr2:1000000' or 'chr2:1,000,000-2,000,000'\");\n        }\n    }","id":76893,"modified_method":"/**\n     * Useful utility function that parses a location string into a coordinate-order sorted\n     * array of GenomeLoc objects\n     *\n     * @param str\n     * @return Array of GenomeLoc objects corresponding to the locations in the string, sorted by coordinate order\n     */\n    public static GenomeLoc[] parseGenomeLocs(final String str) {\n        // Of the form: loc1;loc2;...\n        // Where each locN can be:\n        // �chr2�, �chr2:1000000� or �chr2:1,000,000-2,000,000�\n        StdReflect reflect = new JdkStdReflect();\n        FunctionN<GenomeLoc> parseOne = reflect.staticFunction(GenomeLoc.class, \"parseGenomeLoc\", String.class);\n        Function1<GenomeLoc, String> f1 = parseOne.f1();\n        try {\n            Collection<GenomeLoc> result = Functions.map(f1, Arrays.asList(str.split(\";\")));\n            GenomeLoc[] locs = (GenomeLoc[]) result.toArray(new GenomeLoc[0]);\n            Arrays.sort(locs);\n            logger.debug(\"  Locations are: \" + Utils.join(\"\\n\", Functions.map(Operators.toString, Arrays.asList(locs))));\n            return locs;\n        } catch (Exception e) {\n            logger.fatal(String.format(\"Invalid locations string: %s, format is loc1;loc2; where each locN can be 'chr2', 'chr2:1000000' or 'chr2:1,000,000-2,000,000'\", str));\n            throw new IllegalArgumentException(\"Invalid locations string: \" + str + \", format is loc1;loc2; where each locN can be 'chr2', 'chr2:1000000' or 'chr2:1,000,000-2,000,000'\");\n        }\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void setSafetyChecking(final boolean beSafeP) {\n        if (!beSafeP)\n            System.out.printf(\"*** Turning off safety checking, I hope you know what you are doing.  Errors will result in debugging assert failures and other inscrutable messages...%n\");\n        this.beSafeP = beSafeP;\n    }","id":76894,"modified_method":"public void setSafetyChecking(final boolean beSafeP) {\n        if (!beSafeP)\n            logger.warn(\"*** Turning off safety checking, I hope you know what you are doing.  Errors will result in debugging assert failures and other inscrutable messages...\");\n        this.beSafeP = beSafeP;\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Read a file of genome locations to process.\n     * regions specified by the location string.  The string is of the form:\n     * Of the form: loc1;loc2;...\n     * Where each locN can be:\n     * �chr2�, �chr2:1000000� or �chr2:1,000,000-2,000,000�\n     *\n     * @param file_name\n     */\n    public void setLocationFromFile(final String file_name) {\n        String locStr = \"\";\n\n        Scanner scanner = null;\n        try {\n            scanner = new Scanner(new File(file_name));\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                line.replaceAll(\"\\n\", \"\");\n                locStr += line;\n                if (scanner.hasNextLine()) {\n                    locStr += \";\";\n                }\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n        finally {\n            //ensure the underlying stream is always closed\n            scanner.close();\n        }\n\n        System.out.format(\"DEBUG: locStr: %s\\n\", locStr);\n\n        this.locs = parseGenomeLocs(locStr);\n    }","id":76895,"modified_method":"/**\n     * Read a file of genome locations to process.\n     * regions specified by the location string.  The string is of the form:\n     * Of the form: loc1;loc2;...\n     * Where each locN can be:\n     * �chr2�, �chr2:1000000� or �chr2:1,000,000-2,000,000�\n     *\n     * @param file_name\n     */\n    public void setLocationFromFile(final String file_name) {\n        String locStr = \"\";\n\n        Scanner scanner = null;\n        try {\n            scanner = new Scanner(new File(file_name));\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                line.replaceAll(\"\\n\", \"\");\n                locStr += line;\n                if (scanner.hasNextLine()) {\n                    locStr += \";\";\n                }\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n        finally {\n            //ensure the underlying stream is always closed\n            scanner.close();\n        }\n\n        logger.debug(\"DEBUG: locStr: \" + locStr);\n\n        this.locs = parseGenomeLocs(locStr);\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected Iterator<SAMRecord> loadSAMFile(final File samFile, final boolean threadedIO)\n            throws IOException {\n        Iterator<SAMRecord> iterator = null;\n\n        samReader = new SAMFileReader(readsFile, true);\n        samReader.setValidationStringency(strictness);\n\n        final SAMFileHeader header = samReader.getFileHeader();\n        System.err.println(\"Sort order is: \" + header.getSortOrder());\n\n        // If the file has an index, querying functions are available.  Use them if possible...\n        if (samReader.hasIndex()) {\n            iterator = new SamQueryIterator(samReader, locs);\n        } else {\n            // Ugh.  Close and reopen the file so that the file progress decorator can be assigned to the input stream.\n            samReader.close();\n\n            final FileInputStream samFileStream = new FileInputStream(readsFile);\n            final InputStream bufferedStream = new BufferedInputStream(samFileStream);\n            samReader = new SAMFileReader(readsFile, true);\n            samReader.setValidationStringency(strictness);\n\n            samReadingTracker = new FileProgressTracker<SAMRecord>(readsFile, samReader.iterator(), samFileStream.getChannel(), 1000);\n            iterator = samReadingTracker;\n        }\n\n        return iterator;\n    }","id":76896,"modified_method":"protected Iterator<SAMRecord> loadSAMFile(final File samFile, final boolean threadedIO)\n            throws IOException {\n        Iterator<SAMRecord> iterator = null;\n\n        samReader = new SAMFileReader(readsFile, true);\n        samReader.setValidationStringency(strictness);\n\n        final SAMFileHeader header = samReader.getFileHeader();\n        logger.info(String.format(\"Sort order is: \" + header.getSortOrder()));\n\n        // If the file has an index, querying functions are available.  Use them if possible...\n        if (samReader.hasIndex()) {\n            iterator = new SamQueryIterator(samReader, locs);\n        } else {\n            // Ugh.  Close and reopen the file so that the file progress decorator can be assigned to the input stream.\n            samReader.close();\n\n            final FileInputStream samFileStream = new FileInputStream(readsFile);\n            final InputStream bufferedStream = new BufferedInputStream(samFileStream);\n            samReader = new SAMFileReader(readsFile, true);\n            samReader.setValidationStringency(strictness);\n\n            samReadingTracker = new FileProgressTracker<SAMRecord>(readsFile, samReader.iterator(), samFileStream.getChannel(), 1000);\n            iterator = samReadingTracker;\n        }\n\n        return iterator;\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Traverse by read -- the key driver of linearly ordered traversal of reads.  Provides a single read to\n     * the walker object, in coordinate order.  Supports all of the\n     * interaction contract implied by the read walker\n     * sor\n     *\n     * @param walker A read walker object\n     * @param <M>    MapType -- the result of calling map() on walker\n     * @param <R>    ReduceType -- the result of calling reduce() on the walker\n     * @return 0 on success\n     */\n    protected <M, R> int traverseByRead(ReadWalker<M, R> walker) {\n        if (refFileName == null && !walker.requiresOrderedReads() && verifyingSamReadIter != null) {\n            System.out.println(\"STATUS: No reference file provided and unordered reads are tolerated, enabling out of order read processing.\");\n            if (verifyingSamReadIter != null)\n                verifyingSamReadIter.setCheckOrderP(false);\n        }\n\n        verifySortOrder(refFileName != null || walker.requiresOrderedReads());\n\n        // Initialize the walker\n        walker.initialize();\n\n        // Initialize the sum\n        R sum = walker.reduceInit();\n        List<Integer> offsets = Arrays.asList(0);   // Offset of a single read is always 0\n\n        boolean done = false;\n        while (samReadIter.hasNext() && !done) {\n            this.nRecords++;\n\n            // get the next read\n            final SAMRecord read = samReadIter.next();\n            final List<SAMRecord> reads = Arrays.asList(read);\n            GenomeLoc loc = Utils.genomicLocationOf(read);\n\n            // Jump forward in the reference to this locus location\n            LocusContext locus = new LocusContext(loc, reads, offsets);\n            if (!loc.isUnmapped() && refIter != null) {\n                final ReferenceIterator refSite = refIter.seekForward(loc);\n                locus.setReferenceContig(refSite.getCurrentContig());\n            }\n\n            if (inLocations(loc)) {\n\n                //\n                // execute the walker contact\n                //\n                final boolean keepMeP = walker.filter(locus, read);\n                if (keepMeP) {\n                    M x = walker.map(locus, read);\n                    sum = walker.reduce(x, sum);\n                }\n\n                if (this.maxReads > 0 && this.nRecords > this.maxReads) {\n                    System.out.println(\"Maximum number of reads encountered, terminating traversal \" + this.nRecords);\n                    done = true;\n                }\n            }\n            printProgress(\"reads\", loc);\n\n            if (pastFinalLocation(loc))\n                done = true;\n            //System.out.printf(\"Done? %b%n\", done);\n        }\n\n        printOnTraversalDone(\"reads\", sum);\n        walker.onTraversalDone();\n        return 0;\n    }","id":76897,"modified_method":"/**\n     * Traverse by read -- the key driver of linearly ordered traversal of reads.  Provides a single read to\n     * the walker object, in coordinate order.  Supports all of the\n     * interaction contract implied by the read walker\n     * sor\n     *\n     * @param walker A read walker object\n     * @param <M>    MapType -- the result of calling map() on walker\n     * @param <R>    ReduceType -- the result of calling reduce() on the walker\n     * @return 0 on success\n     */\n    protected <M, R> int traverseByRead(ReadWalker<M, R> walker) {\n        if (refFileName == null && !walker.requiresOrderedReads() && verifyingSamReadIter != null) {\n            logger.warn(String.format(\"STATUS: No reference file provided and unordered reads are tolerated, enabling out of order read processing.\"));\n            if (verifyingSamReadIter != null)\n                verifyingSamReadIter.setCheckOrderP(false);\n        }\n\n        verifySortOrder(refFileName != null || walker.requiresOrderedReads());\n\n        // Initialize the walker\n        walker.initialize();\n\n        // Initialize the sum\n        R sum = walker.reduceInit();\n        List<Integer> offsets = Arrays.asList(0);   // Offset of a single read is always 0\n\n        boolean done = false;\n        while (samReadIter.hasNext() && !done) {\n            this.nRecords++;\n\n            // get the next read\n            final SAMRecord read = samReadIter.next();\n            final List<SAMRecord> reads = Arrays.asList(read);\n            GenomeLoc loc = Utils.genomicLocationOf(read);\n\n            // Jump forward in the reference to this locus location\n            LocusContext locus = new LocusContext(loc, reads, offsets);\n            if (!loc.isUnmapped() && refIter != null) {\n                final ReferenceIterator refSite = refIter.seekForward(loc);\n                locus.setReferenceContig(refSite.getCurrentContig());\n            }\n\n            if (inLocations(loc)) {\n\n                //\n                // execute the walker contact\n                //\n                final boolean keepMeP = walker.filter(locus, read);\n                if (keepMeP) {\n                    M x = walker.map(locus, read);\n                    sum = walker.reduce(x, sum);\n                }\n\n                if (this.maxReads > 0 && this.nRecords > this.maxReads) {\n                    logger.warn(String.format((\"Maximum number of reads encountered, terminating traversal \" + this.nRecords)));\n                    done = true;\n                }\n            }\n            printProgress(\"reads\", loc);\n\n            if (pastFinalLocation(loc))\n                done = true;\n            //System.out.printf(\"Done? %b%n\", done);\n        }\n\n        printOnTraversalDone(\"reads\", sum);\n        walker.onTraversalDone();\n        return 0;\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void setSortOnFly(final boolean SORT_ON_FLY) {\n        if (SORT_ON_FLY)\n            System.out.println(\"Sorting read file on the fly: max reads allowed is \" + MAX_ON_FLY_SORTS);\n        this.SORT_ON_FLY = SORT_ON_FLY;\n    }","id":76898,"modified_method":"public void setSortOnFly(final boolean SORT_ON_FLY) {\n        if (SORT_ON_FLY)\n            logger.info(\"Sorting read file on the fly: max reads allowed is \" + MAX_ON_FLY_SORTS);\n        this.SORT_ON_FLY = SORT_ON_FLY;\n    }","commit_id":"b56a73538d60ae3aa241b230d89b8b1ad74da5bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Basic Editor panel has two blocks: a tag table at the top and a membership list below\n     * @param selectedMembers\n     * @return a JPanel with the described layout\n     */\n    private JPanel setupBasicLayout(Collection<RelationMember> selectedMembers) {\n        // setting up the properties table\n        propertyData.setColumnIdentifiers(new String[]{tr(\"Key\"),tr(\"Value\")});\n        propertyTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        propertyData.addTableModelListener(new TableModelListener() {\n            public void tableChanged(TableModelEvent tme) {\n                if (tme.getType() == TableModelEvent.UPDATE) {\n                    int row = tme.getFirstRow();\n\n                    if (!(tme.getColumn() == 0 && row == propertyData.getRowCount() -1)) {\n                        clone.entrySet().clear();\n                        for (int i = 0; i < propertyData.getRowCount(); i++) {\n                            String key = propertyData.getValueAt(i, 0).toString();\n                            String value = propertyData.getValueAt(i, 1).toString();\n                            if (key.length() > 0 && value.length() > 0) {\n                                clone.put(key, value);\n                            }\n                        }\n                        refreshTables();\n                    }\n                }\n            }\n        });\n        propertyTable.putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n\n        // setting up the member table\n\n        memberData.setColumnIdentifiers(new String[]{tr(\"Role\"),tr(\"Occupied By\"), tr(\"linked\")});\n        memberTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n        memberTable.getColumnModel().getColumn(1).setCellRenderer(new OsmPrimitivRenderer());\n        memberData.addTableModelListener(new TableModelListener() {\n            public void tableChanged(TableModelEvent tme) {\n                if (tme.getType() == TableModelEvent.UPDATE && tme.getColumn() == 0) {\n                    int row = tme.getFirstRow();\n                    clone.members.get(row).role = memberData.getValueAt(row, 0).toString();\n                }\n            }\n        });\n        ListSelectionModel lsm = memberTable.getSelectionModel();\n        lsm.addListSelectionListener(new ListSelectionListener() {\n            public void valueChanged(ListSelectionEvent e) {\n                ArrayList<OsmPrimitive> sel;\n                int cnt = memberTable.getSelectedRowCount();\n                if(cnt > 0)\n                {\n                    sel = new ArrayList<OsmPrimitive>(cnt);\n                    for (int i : memberTable.getSelectedRows()) {\n                        sel.add((OsmPrimitive)memberTable.getValueAt(i, 1));\n                    }\n                }\n                else\n                {\n                    cnt = memberTable.getRowCount();\n                    sel = new ArrayList<OsmPrimitive>(cnt);\n                    for (int i = 0; i < cnt; ++i) {\n                        sel.add((OsmPrimitive)memberTable.getValueAt(i, 1));\n                    }\n                }\n                Main.ds.setSelected(sel);\n            }\n        });\n        memberTable.putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n\n        // combine both tables and wrap them in a scrollPane\n        JPanel bothTables = new JPanel();\n        bothTables.setLayout(new GridBagLayout());\n        bothTables.add(new JLabel(tr(\"Tags (empty value deletes tag)\")), GBC.eol().fill(GBC.HORIZONTAL));\n        bothTables.add(new JScrollPane(propertyTable), GBC.eop().fill(GBC.BOTH));\n        bothTables.add(status = new JLabel(tr(\"Members\")), GBC.eol().fill(GBC.HORIZONTAL));\n        // this is not exactly pretty but the four buttons simply don't fit in one line.\n        // we should have smaller buttons for situations like this.\n        JPanel buttonPanel = setupBasicButtons();\n\n        bothTables.add(new JScrollPane(memberTable), GBC.eol().fill(GBC.BOTH));\n        bothTables.add(buttonPanel, GBC.eop().fill(GBC.HORIZONTAL));\n        refreshTables();\n\n        if (selectedMembers != null) {\n            boolean scrolled = false;\n            for (int i = 0; i < memberData.getRowCount(); i++) {\n                for (RelationMember m : selectedMembers) {\n                    if (m.member == memberData.getValueAt(i, 1)\n                            && m.role.equals(memberData.getValueAt(i, 0))) {\n                        memberTable.addRowSelectionInterval(i, i);\n                        if (!scrolled) {\n                            // Ensure that the first member is visible\n                            memberTable.scrollRectToVisible(memberTable.getCellRect(i, 0, true));\n                            scrolled = true;\n                        }\n                        break;\n                    }\n                }\n\n            }\n        }\n        return bothTables;\n    }","id":76899,"modified_method":"/**\n     * Basic Editor panel has two blocks: a tag table at the top and a membership list below\n     * @param selectedMembers\n     * @return a JPanel with the described layout\n     */\n    private JPanel setupBasicLayout(Collection<RelationMember> selectedMembers) {\n        // setting up the tag table\n        //\n        tagEditorModel = new TagEditorModel();\n        tagTable = new TagTable(tagEditorModel);\n        acCache.initFromJOSMDataset();\n        TagCellEditor editor = ((TagCellEditor)tagTable.getColumnModel().getColumn(0).getCellEditor());\n        editor.setAutoCompletionCache(acCache);\n        editor.setAutoCompletionList(acList);\n        editor = ((TagCellEditor)tagTable.getColumnModel().getColumn(1).getCellEditor());\n        editor.setAutoCompletionCache(acCache);\n        editor.setAutoCompletionList(acList);\n\n\n        // setting up the member table\n\n        memberData.setColumnIdentifiers(new String[]{tr(\"Role\"),tr(\"Occupied By\"), tr(\"linked\")});\n        memberTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n        memberTable.getColumnModel().getColumn(1).setCellRenderer(new OsmPrimitivRenderer());\n        memberData.addTableModelListener(new TableModelListener() {\n            public void tableChanged(TableModelEvent tme) {\n                if (tme.getType() == TableModelEvent.UPDATE && tme.getColumn() == 0) {\n                    int row = tme.getFirstRow();\n                    getClone().members.get(row).role = memberData.getValueAt(row, 0).toString();\n                }\n            }\n        });\n        ListSelectionModel lsm = memberTable.getSelectionModel();\n        lsm.addListSelectionListener(new ListSelectionListener() {\n            public void valueChanged(ListSelectionEvent e) {\n                ArrayList<OsmPrimitive> sel;\n                int cnt = memberTable.getSelectedRowCount();\n                if(cnt > 0)\n                {\n                    sel = new ArrayList<OsmPrimitive>(cnt);\n                    for (int i : memberTable.getSelectedRows()) {\n                        sel.add((OsmPrimitive)memberTable.getValueAt(i, 1));\n                    }\n                }\n                else\n                {\n                    cnt = memberTable.getRowCount();\n                    sel = new ArrayList<OsmPrimitive>(cnt);\n                    for (int i = 0; i < cnt; ++i) {\n                        sel.add((OsmPrimitive)memberTable.getValueAt(i, 1));\n                    }\n                }\n                Main.ds.setSelected(sel);\n            }\n        });\n        memberTable.putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n\n        // combine both tables and wrap them in a scrollPane\n        JPanel bothTables = new JPanel();\n        bothTables.setLayout(new GridBagLayout());\n        bothTables.add(new JLabel(tr(\"Tags\")), GBC.eol().fill(GBC.HORIZONTAL));\n        final JScrollPane scrollPane = new JScrollPane(tagTable);\n\n        // this adapters ensures that the width of the tag table columns is adjusted\n        // to the width of the scroll pane viewport. Also tried to overwrite\n        // getPreferredViewportSize() in JTable, but did not work.\n        //\n        scrollPane.addComponentListener(\n                new ComponentAdapter() {\n                    @Override public void componentResized(ComponentEvent e) {\n                        super.componentResized(e);\n                        Dimension d = scrollPane.getViewport().getExtentSize();\n                        tagTable.adjustColumnWidth(d.width);\n                    }\n                }\n        );\n        bothTables.add(scrollPane, GBC.eop().fill(GBC.BOTH));\n        bothTables.add(status = new JLabel(tr(\"Members\")), GBC.eol().fill(GBC.HORIZONTAL));\n        // this is not exactly pretty but the four buttons simply don't fit in one line.\n        // we should have smaller buttons for situations like this.\n        JPanel buttonPanel = setupBasicButtons();\n\n        bothTables.add(new JScrollPane(memberTable), GBC.eol().fill(GBC.BOTH));\n        bothTables.add(buttonPanel, GBC.eop().fill(GBC.HORIZONTAL));\n        refreshTables();\n\n        if (selectedMembers != null) {\n            boolean scrolled = false;\n            for (int i = 0; i < memberData.getRowCount(); i++) {\n                for (RelationMember m : selectedMembers) {\n                    if (m.member == memberData.getValueAt(i, 1)\n                            && m.role.equals(memberData.getValueAt(i, 0))) {\n                        memberTable.addRowSelectionInterval(i, i);\n                        if (!scrolled) {\n                            // Ensure that the first member is visible\n                            memberTable.scrollRectToVisible(memberTable.getCellRect(i, 0, true));\n                            scrolled = true;\n                        }\n                        break;\n                    }\n                }\n\n            }\n        }\n        return bothTables;\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void downloadRelationMembers() {\n        boolean download = false;\n        for (RelationMember member : clone.members) {\n            if (member.member.incomplete) {\n                download = true;\n                break;\n            }\n        }\n        if (download) {\n            OsmServerObjectReader reader = new OsmServerObjectReader(clone.id, OsmPrimitiveType.RELATION, true);\n            try {\n                DataSet dataSet = reader.parseOsm();\n                if (dataSet != null) {\n                    final MergeVisitor visitor = new MergeVisitor(Main.main.map.mapView.getEditLayer()\n                            .data, dataSet);\n                    visitor.merge();\n\n                    // copy the merged layer's data source info\n                    for (DataSource src : dataSet.dataSources) {\n                        Main.main.map.mapView.getEditLayer().data.dataSources.add(src);\n                    }\n                    Main.main.map.mapView.getEditLayer().fireDataChange();\n\n                    if (visitor.getConflicts().isEmpty())\n                        return;\n                    final ConflictDialog dlg = Main.map.conflictDialog;\n                    dlg.getConflicts().add(visitor.getConflicts());\n                    JOptionPane.showMessageDialog(Main.parent,\n                            tr(\"There were conflicts during import.\"));\n                    if (!dlg.isVisible()) {\n                        dlg.action\n                        .actionPerformed(new ActionEvent(this, 0, \"\"));\n                    }\n                }\n            } catch(OsmTransferException e) {\n                e.printStackTrace();\n                if (e.getCause() != null) {\n                    if (e.getCause() instanceof SAXException) {\n                        JOptionPane.showMessageDialog(this,tr(\"Error parsing server response.\")+\": \"+e.getCause().getMessage(),\n                                tr(\"Error\"), JOptionPane.ERROR_MESSAGE);\n                    } else if(e.getCause() instanceof IOException) {\n                        JOptionPane.showMessageDialog(this,tr(\"Cannot connect to server.\")+\": \"+e.getCause().getMessage(),\n                                tr(\"Error\"), JOptionPane.ERROR_MESSAGE);\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this,tr(\"Error when communicating with server.\")+\": \"+e.getMessage(),\n                            tr(\"Error\"), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n        }\n    }","id":76900,"modified_method":"private void downloadRelationMembers() {\n        boolean download = false;\n        for (RelationMember member : getClone().members) {\n            if (member.member.incomplete) {\n                download = true;\n                break;\n            }\n        }\n        if (download) {\n            OsmServerObjectReader reader = new OsmServerObjectReader(getClone().id, OsmPrimitiveType.RELATION, true);\n            try {\n                DataSet dataSet = reader.parseOsm();\n                if (dataSet != null) {\n                    final MergeVisitor visitor = new MergeVisitor(Main.main.map.mapView.getEditLayer()\n                            .data, dataSet);\n                    visitor.merge();\n\n                    // copy the merged layer's data source info\n                    for (DataSource src : dataSet.dataSources) {\n                        Main.main.map.mapView.getEditLayer().data.dataSources.add(src);\n                    }\n                    Main.main.map.mapView.getEditLayer().fireDataChange();\n\n                    if (visitor.getConflicts().isEmpty())\n                        return;\n                    final ConflictDialog dlg = Main.map.conflictDialog;\n                    dlg.getConflicts().add(visitor.getConflicts());\n                    JOptionPane.showMessageDialog(Main.parent,\n                            tr(\"There were conflicts during import.\"));\n                    if (!dlg.isVisible()) {\n                        dlg.action\n                        .actionPerformed(new ActionEvent(this, 0, \"\"));\n                    }\n                }\n            } catch(OsmTransferException e) {\n                e.printStackTrace();\n                if (e.getCause() != null) {\n                    if (e.getCause() instanceof SAXException) {\n                        JOptionPane.showMessageDialog(this,tr(\"Error parsing server response.\")+\": \"+e.getCause().getMessage(),\n                                tr(\"Error\"), JOptionPane.ERROR_MESSAGE);\n                    } else if(e.getCause() instanceof IOException) {\n                        JOptionPane.showMessageDialog(this,tr(\"Cannot connect to server.\")+\": \"+e.getCause().getMessage(),\n                                tr(\"Error\"), JOptionPane.ERROR_MESSAGE);\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this,tr(\"Error when communicating with server.\")+\": \"+e.getMessage(),\n                            tr(\"Error\"), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n        }\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void refreshTables() {\n        // re-load property data\n        int numLinked = 0;\n\n        propertyData.setRowCount(0);\n        for (Entry<String, String> e : clone.entrySet()) {\n            propertyData.addRow(new Object[]{e.getKey(), e.getValue()});\n        }\n        propertyData.addRow(new Object[]{\"\", \"\"});\n\n        // re-load membership data\n\n        memberData.setRowCount(0);\n        for (int i=0; i<clone.members.size(); i++) {\n\n            // this whole section is aimed at finding out whether the\n            // relation member is \"linked\" with the next, i.e. whether\n            // (if both are ways) these ways are connected. It should\n            // really produce a much more beautiful output (with a linkage\n            // symbol somehow places between the two member lines!), and\n            // it should cache results, so... FIXME ;-)\n\n            RelationMember em = clone.members.get(i);\n            WayConnectionType link = WayConnectionType.none;\n            RelationMember m = em;\n            RelationMember way1 = null;\n            RelationMember way2 = null;\n            int depth = 0;\n\n            while (m != null && depth < 10) {\n                if (m.member instanceof Way) {\n                    way1 = m;\n                    break;\n                } else if (m.member instanceof Relation) {\n                    if (m.member == this.relation) {\n                        break;\n                    }\n                    m = ((Relation)m.member).lastMember();\n                    depth++;\n                } else {\n                    break;\n                }\n            }\n            if (way1 != null) {\n                int next = (i+1) % clone.members.size();\n                while (next != i) {\n                    m = clone.members.get(next);\n                    next = (next + 1) % clone.members.size();\n                    depth = 0;\n                    while (m != null && depth < 10) {\n                        if (m.member instanceof Way) {\n                            way2 = m;\n                            break;\n                        } else if (m.member instanceof Relation) {\n                            if (m.member == this.relation) {\n                                break;\n                            }\n                            m = ((Relation)(m.member)).firstMember();\n                            depth++;\n                        } else {\n                            break;\n                        }\n                    }\n                    if (way2 != null) {\n                        break;\n                    }\n                }\n            }\n            if (way2 != null) {\n                Node way1first = ((Way)(way1.member)).firstNode();\n                Node way1last = ((Way)(way1.member)).lastNode();\n                Node way2first = ((Way)(way2.member)).firstNode();\n                Node way2last = ((Way)(way2.member)).lastNode();\n                if (way1.role.equals(\"forward\")) {\n                    way1first = null;\n                } else if (way1.role.equals(\"backward\")) {\n                    way1last = null;\n                }\n                if (way2.role.equals(\"forward\")) {\n                    way2last = null;\n                } else if (way2.role.equals(\"backward\")) {\n                    way2first = null;\n                }\n\n                if (way1first != null && way2first != null && way1first.equals(way2first)) {\n                    link = WayConnectionType.tail_to_tail;\n                } else if (way1first != null && way2last != null && way1first.equals(way2last)) {\n                    link = WayConnectionType.tail_to_head;\n                } else if (way1last != null && way2first != null && way1last.equals(way2first)) {\n                    link = WayConnectionType.head_to_tail;\n                } else if (way1last != null && way2last != null && way1last.equals(way2last)) {\n                    link = WayConnectionType.head_to_head;\n                }\n\n                // end of section to determine linkedness.\n                if (link != WayConnectionType.none)\n                {\n                    ++numLinked;\n                }\n\n            }\n            memberData.addRow(new Object[]{em.role, em.member, link});\n        }\n        status.setText(tr(\"Members: {0} (linked: {1})\", clone.members.size(), numLinked));\n    }","id":76901,"modified_method":"private void refreshTables() {\n        // re-load property data\n        int numLinked = 0;\n\n        // re-load membership data\n\n        memberData.setRowCount(0);\n        for (int i=0; i<getClone().members.size(); i++) {\n\n            // this whole section is aimed at finding out whether the\n            // relation member is \"linked\" with the next, i.e. whether\n            // (if both are ways) these ways are connected. It should\n            // really produce a much more beautiful output (with a linkage\n            // symbol somehow places between the two member lines!), and\n            // it should cache results, so... FIXME ;-)\n\n            RelationMember em = getClone().members.get(i);\n            WayConnectionType link = WayConnectionType.none;\n            RelationMember m = em;\n            RelationMember way1 = null;\n            RelationMember way2 = null;\n            int depth = 0;\n\n            while (m != null && depth < 10) {\n                if (m.member instanceof Way) {\n                    way1 = m;\n                    break;\n                } else if (m.member instanceof Relation) {\n                    if (m.member == this.getRelation()) {\n                        break;\n                    }\n                    m = ((Relation)m.member).lastMember();\n                    depth++;\n                } else {\n                    break;\n                }\n            }\n            if (way1 != null) {\n                int next = (i+1) % getClone().members.size();\n                while (next != i) {\n                    m = getClone().members.get(next);\n                    next = (next + 1) % getClone().members.size();\n                    depth = 0;\n                    while (m != null && depth < 10) {\n                        if (m.member instanceof Way) {\n                            way2 = m;\n                            break;\n                        } else if (m.member instanceof Relation) {\n                            if (m.member == this.getRelation()) {\n                                break;\n                            }\n                            m = ((Relation)(m.member)).firstMember();\n                            depth++;\n                        } else {\n                            break;\n                        }\n                    }\n                    if (way2 != null) {\n                        break;\n                    }\n                }\n            }\n            if (way2 != null) {\n                Node way1first = ((Way)(way1.member)).firstNode();\n                Node way1last = ((Way)(way1.member)).lastNode();\n                Node way2first = ((Way)(way2.member)).firstNode();\n                Node way2last = ((Way)(way2.member)).lastNode();\n                if (way1.role.equals(\"forward\")) {\n                    way1first = null;\n                } else if (way1.role.equals(\"backward\")) {\n                    way1last = null;\n                }\n                if (way2.role.equals(\"forward\")) {\n                    way2last = null;\n                } else if (way2.role.equals(\"backward\")) {\n                    way2first = null;\n                }\n\n                if (way1first != null && way2first != null && way1first.equals(way2first)) {\n                    link = WayConnectionType.tail_to_tail;\n                } else if (way1first != null && way2last != null && way1first.equals(way2last)) {\n                    link = WayConnectionType.tail_to_head;\n                } else if (way1last != null && way2first != null && way1last.equals(way2first)) {\n                    link = WayConnectionType.head_to_tail;\n                } else if (way1last != null && way2last != null && way1last.equals(way2last)) {\n                    link = WayConnectionType.head_to_head;\n                }\n\n                // end of section to determine linkedness.\n                if (link != WayConnectionType.none)\n                {\n                    ++numLinked;\n                }\n\n            }\n            memberData.addRow(new Object[]{em.role, em.member, link});\n        }\n        status.setText(tr(\"Members: {0} (linked: {1})\", getClone().members.size(), numLinked));\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates a new relation editor for the given relation. The relation\n     * will be saved if the user selects \"ok\" in the editor.\n     *\n     * If no relation is given, will create an editor for a new relation.\n     *\n     * @param relation relation to edit, or null to create a new one.\n     */\n    public GenericRelationEditor(Relation relation, Collection<RelationMember> selectedMembers )\n    {\n        // Initalizes ExtendedDialog\n        super(relation, selectedMembers);\n\n        JPanel bothTables = setupBasicLayout(selectedMembers);\n\n        JTabbedPane tabPane = new JTabbedPane();\n        tabPane.add(bothTables, tr(\"Basic\"));\n\n        // This sets the minimum size before scrollbars appear on the dialog\n        tabPane.setPreferredSize(new Dimension(100, 100));\n        contentConstraints = GBC.eol().fill().insets(5,10,5,0);\n        setupDialog(tabPane, new String[] { \"ok.png\", \"cancel.png\" });\n        // FIXME: Make it remember last screen position\n        setSize(findMaxDialogSize());\n\n        try { setAlwaysOnTop(true); } catch (SecurityException sx) {}\n        setVisible(true);\n    }","id":76902,"modified_method":"/**\n     * Creates a new relation editor for the given relation. The relation\n     * will be saved if the user selects \"ok\" in the editor.\n     *\n     * If no relation is given, will create an editor for a new relation.\n     *\n     * @param relation relation to edit, or null to create a new one.\n     */\n    public GenericRelationEditor(Relation relation, Collection<RelationMember> selectedMembers )\n    {\n        // Initalizes ExtendedDialog\n        super(relation, selectedMembers);\n        acCache = AutoCompletionCache.getCacheForLayer(Main.map.mapView.getEditLayer());\n        acList = new AutoCompletionList();\n\n        JPanel bothTables = setupBasicLayout(selectedMembers);\n        if (relation != null) {\n            this.tagEditorModel.initFromPrimitive(relation);\n        } else {\n            tagEditorModel.clear();\n        }\n        tagEditorModel.ensureOneTag();\n        addWindowListener(\n                new WindowAdapter() {\n                    protected void requestFocusInTopLeftCell() {\n                        SwingUtilities.invokeLater(new Runnable(){\n                            public void run()\n                            {\n                                tagEditorModel.ensureOneTag();\n                                tagTable.requestFocusInCell(0, 0);\n                            }\n                        });\n                    }\n                    @Override public void windowGainedFocus(WindowEvent e) {\n                        requestFocusInTopLeftCell();\n                    }\n                    @Override\n                    public void windowActivated(WindowEvent e) {\n                        requestFocusInTopLeftCell();\n                    }\n                    @Override\n                    public void windowDeiconified(WindowEvent e) {\n                        requestFocusInTopLeftCell();\n                    }\n                    @Override\n                    public void windowOpened(WindowEvent e) {\n                        requestFocusInTopLeftCell();\n                    }\n                }\n        );\n\n        JTabbedPane tabPane = new JTabbedPane();\n        tabPane.add(bothTables, tr(\"Basic\"));\n\n        // This sets the minimum size before scrollbars appear on the dialog\n        tabPane.setPreferredSize(new Dimension(100, 100));\n        contentConstraints = GBC.eol().fill().insets(5,10,5,0);\n        setupDialog(tabPane, new String[] { \"ok.png\", \"cancel.png\" });\n        // FIXME: Make it remember last screen position\n        setSize(findMaxDialogSize());\n\n        try { setAlwaysOnTop(true); } catch (SecurityException sx) {}\n        setVisible(true);\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates the buttons for the basic editing layout\n     * @return JPanel with basic buttons\n     */\n    private JPanel setupBasicButtons() {\n        JPanel buttonPanel = new JPanel(new GridLayout(2, 4));\n\n        buttonPanel.add(createButton(marktr(\"Move Up\"), \"moveup\", tr(\"Move the currently selected members up\"), KeyEvent.VK_N, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                moveMembers(-1);\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Add Selected\"),\"addselected\",\n                tr(\"Add all currently selected objects as members\"), KeyEvent.VK_D, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                addSelected();\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Remove Selected\"),\"removeselected\",\n                tr(\"Remove all currently selected objects from relation\"), KeyEvent.VK_S, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                deleteSelected();\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Sort\"), \"sort\",\n                tr(\"Sort the selected relation members or the whole list\"), KeyEvent.VK_O, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                sort();\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Move Down\"), \"movedown\", tr(\"Move the currently selected members down\"), KeyEvent.VK_J, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                moveMembers(1);\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Remove\"),\"remove\",\n                tr(\"Remove the member in the current table row from this relation\"), KeyEvent.VK_X, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                int[] rows = memberTable.getSelectedRows();\n                RelationMember mem = new RelationMember();\n                for (int row : rows) {\n                    mem.role = memberTable.getValueAt(row, 0).toString();\n                    mem.member = (OsmPrimitive) memberTable.getValueAt(row, 1);\n                    clone.members.remove(mem);\n                }\n                refreshTables();\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Download Members\"),\"downloadincomplete\",\n                tr(\"Download all incomplete ways and nodes in relation\"), KeyEvent.VK_K, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                downloadRelationMembers();\n                refreshTables();\n            }\n        }));\n\n        return buttonPanel;\n    }","id":76903,"modified_method":"/**\n     * Creates the buttons for the basic editing layout\n     * @return JPanel with basic buttons\n     */\n    private JPanel setupBasicButtons() {\n        JPanel buttonPanel = new JPanel(new GridLayout(2, 4));\n\n        buttonPanel.add(createButton(marktr(\"Move Up\"), \"moveup\", tr(\"Move the currently selected members up\"), KeyEvent.VK_N, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                moveMembers(-1);\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Add Selected\"),\"addselected\",\n                tr(\"Add all currently selected objects as members\"), KeyEvent.VK_D, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                addSelected();\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Remove Selected\"),\"removeselected\",\n                tr(\"Remove all currently selected objects from relation\"), KeyEvent.VK_S, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                deleteSelected();\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Sort\"), \"sort\",\n                tr(\"Sort the selected relation members or the whole list\"), KeyEvent.VK_O, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                sort();\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Move Down\"), \"movedown\", tr(\"Move the currently selected members down\"), KeyEvent.VK_J, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                moveMembers(1);\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Remove\"),\"remove\",\n                tr(\"Remove the member in the current table row from this relation\"), KeyEvent.VK_X, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                int[] rows = memberTable.getSelectedRows();\n                RelationMember mem = new RelationMember();\n                for (int row : rows) {\n                    mem.role = memberTable.getValueAt(row, 0).toString();\n                    mem.member = (OsmPrimitive) memberTable.getValueAt(row, 1);\n                    getClone().members.remove(mem);\n                }\n                refreshTables();\n            }\n        }));\n\n        buttonPanel.add(createButton(marktr(\"Download Members\"),\"downloadincomplete\",\n                tr(\"Download all incomplete ways and nodes in relation\"), KeyEvent.VK_K, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                downloadRelationMembers();\n                refreshTables();\n            }\n        }));\n\n        return buttonPanel;\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void deleteSelected() {\n        for (OsmPrimitive p : Main.ds.getSelected()) {\n            Relation c = new Relation(clone);\n            for (RelationMember rm : c.members) {\n                if (rm.member == p)\n                {\n                    RelationMember mem = new RelationMember();\n                    mem.role = rm.role;\n                    mem.member = rm.member;\n                    clone.members.remove(mem);\n                }\n            }\n        }\n        refreshTables();\n    }","id":76904,"modified_method":"private void deleteSelected() {\n        for (OsmPrimitive p : Main.ds.getSelected()) {\n            Relation c = new Relation(getClone());\n            for (RelationMember rm : c.members) {\n                if (rm.member == p)\n                {\n                    RelationMember mem = new RelationMember();\n                    mem.role = rm.role;\n                    mem.member = rm.member;\n                    getClone().members.remove(mem);\n                }\n            }\n        }\n        refreshTables();\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void moveMembers(int direction) {\n        int[] rows = memberTable.getSelectedRows();\n        if (rows.length == 0) return;\n\n        // check if user attempted to move anything beyond the boundary of the list\n        if (rows[0] + direction < 0) return;\n        if (rows[rows.length-1] + direction >= clone.members.size()) return;\n\n        RelationMember m[] = new RelationMember[clone.members.size()];\n\n        // first move all selected rows from the member list into a new array,\n        // displaced by the move amount\n        for (Integer i: rows) {\n            m[i+direction] = clone.members.get(i);\n            clone.members.set(i, null);\n        }\n\n        // now fill the empty spots in the destination array with the remaining\n        // elements.\n        int i = 0;\n        for (RelationMember rm : clone.members) {\n            if (rm != null) {\n                while (m[i] != null) {\n                    i++;\n                }\n                m[i++] = rm;\n            }\n        }\n\n        // and write the array back into the member list.\n        clone.members.clear();\n        clone.members.addAll(Arrays.asList(m));\n        refreshTables();\n        ListSelectionModel lsm = memberTable.getSelectionModel();\n        lsm.setValueIsAdjusting(true);\n        for (Integer j: rows) {\n            lsm.addSelectionInterval(j + direction, j + direction);\n        }\n        lsm.setValueIsAdjusting(false);\n    }","id":76905,"modified_method":"private void moveMembers(int direction) {\n        int[] rows = memberTable.getSelectedRows();\n        if (rows.length == 0) return;\n\n        // check if user attempted to move anything beyond the boundary of the list\n        if (rows[0] + direction < 0) return;\n        if (rows[rows.length-1] + direction >= getClone().members.size()) return;\n\n        RelationMember m[] = new RelationMember[getClone().members.size()];\n\n        // first move all selected rows from the member list into a new array,\n        // displaced by the move amount\n        for (Integer i: rows) {\n            m[i+direction] = getClone().members.get(i);\n            getClone().members.set(i, null);\n        }\n\n        // now fill the empty spots in the destination array with the remaining\n        // elements.\n        int i = 0;\n        for (RelationMember rm : getClone().members) {\n            if (rm != null) {\n                while (m[i] != null) {\n                    i++;\n                }\n                m[i++] = rm;\n            }\n        }\n\n        // and write the array back into the member list.\n        getClone().members.clear();\n        getClone().members.addAll(Arrays.asList(m));\n        refreshTables();\n        ListSelectionModel lsm = memberTable.getSelectionModel();\n        lsm.setValueIsAdjusting(true);\n        for (Integer j: rows) {\n            lsm.addSelectionInterval(j + direction, j + direction);\n        }\n        lsm.setValueIsAdjusting(false);\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * This function saves the user's changes. Must be invoked manually.\n     */\n    private void applyChanges() {\n        if (GenericRelationEditor.this.relation == null) {\n            // If the user wanted to create a new relation, but hasn't added any members or\n            // tags, don't add an empty relation\n            if(clone.members.size() == 0 && !clone.isTagged())\n                return;\n            Main.main.undoRedo.add(new AddCommand(clone));\n            DataSet.fireSelectionChanged(Main.ds.getSelected());\n        } else if (!GenericRelationEditor.this.relation.realEqual(clone, true)) {\n            Main.main.undoRedo.add(new ChangeCommand(GenericRelationEditor.this.relation, clone));\n            DataSet.fireSelectionChanged(Main.ds.getSelected());\n        }\n    }","id":76906,"modified_method":"/**\n     * This function saves the user's changes. Must be invoked manually.\n     */\n    private void applyChanges() {\n        if (getRelation()== null) {\n            // If the user wanted to create a new relation, but hasn't added any members or\n            // tags, don't add an empty relation\n            if(getClone().members.size() == 0 && tagEditorModel.getKeys().isEmpty())\n                return;\n            tagEditorModel.applyToPrimitive(getClone());\n            Main.main.undoRedo.add(new AddCommand(getClone()));\n            DataSet.fireSelectionChanged(Main.ds.getSelected());\n        } else if (getRelation().hasEqualSemanticAttributes(getClone())) {\n            tagEditorModel.applyToPrimitive(getClone());\n            Main.main.undoRedo.add(new ChangeCommand(getRelation(), getClone()));\n            DataSet.fireSelectionChanged(Main.ds.getSelected());\n        }\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void sort() {\n        java.util.HashMap<Node, java.util.TreeSet<Integer>>   points =\n            new java.util.HashMap<Node, java.util.TreeSet<Integer>>();\n        java.util.HashMap<Node, Integer>   nodes =\n            new java.util.HashMap<Node, Integer>();\n        int                                i;\n        boolean                            lastWayStartUsed = true;\n\n        // TODO: sort only selected rows\n\n        for (i = 1; i < clone.members.size(); ++i)\n        {\n            RelationMember  m = clone.members.get(i);\n            if (m.member.incomplete)\n                // TODO: emit some message that sorting failed\n                return;\n            try\n            {\n                Way w = (Way)m.member;\n                if (!points.containsKey(w.firstNode()))\n                {\n                    points.put(w.firstNode(), new java.util.TreeSet<Integer>());\n                }\n                points.get(w.firstNode()).add(Integer.valueOf(i));\n\n                if (!points.containsKey(w.lastNode()))\n                {\n                    points.put(w.lastNode(), new java.util.TreeSet<Integer>());\n                }\n                points.get(w.lastNode()).add(Integer.valueOf(i));\n            }\n            catch(ClassCastException e1)\n            {\n                try\n                {\n                    Node        n = (Node)m.member;\n                    nodes.put(n, Integer.valueOf(i));\n                }\n                catch(ClassCastException e2)\n                {\n                    System.err.println(\"relation member sort: member \" + i + \" is not a way or node\");\n                    return;\n                }\n            }\n        }\n\n        for (i = 0; i < clone.members.size(); ++i)\n        {\n            RelationMember  m = clone.members.get(i);\n            Integer         m2 = null;\n            Node            searchNode = null;\n            try\n            {\n                Way             w = (Way)m.member;\n\n                if (lastWayStartUsed || ((i == 0) && !m.role.equals(\"backward\")))\n                {\n                    // try end node\n                    searchNode = w.lastNode();\n                }\n                else /* if ((m2 == null) && (!lastWayStartUsed || (i == 0))) */\n                {\n                    searchNode = w.firstNode();\n                }\n            }\n            catch(ClassCastException e1)\n            {\n                try\n                {\n                    Node n = (Node)m.member;\n                    searchNode = n;\n                }\n                catch(ClassCastException e2)\n                {\n                    // impossible\n                }\n            }\n\n            try {\n                m2 = nodes.get(searchNode);\n                if (m2 == null)\n                {\n                    m2 = points.get(searchNode).first();\n                    if (m.member == clone.members.get(m2).member)\n                    {\n                        m2 = points.get(searchNode).last();\n                    }\n                }\n            } catch(NullPointerException f) {}\n            catch(java.util.NoSuchElementException e) {}\n\n            if ((m2 == null) && ((i+1) < clone.members.size()))\n            {\n                // TODO: emit some message that sorting failed\n                System.err.println(\"relation member sort: could not find linked way or node for member \" + i);\n                break;\n            }\n\n            if (m2 != null)\n            {\n                try\n                {\n                    Way next = (Way)clone.members.get(m2).member;\n                    lastWayStartUsed = searchNode.equals(next.firstNode());\n                }\n                catch(ClassCastException e)\n                {\n                }\n\n                if ((m2 < clone.members.size()) && ((i+1) < clone.members.size()))\n                {\n                    RelationMember  a = clone.members.get(i+1);\n                    RelationMember  b = clone.members.get(m2);\n\n                    if (m2 != (i+1))\n                    {\n                        clone.members.set(i+1, b);\n                        clone.members.set(m2, a);\n\n                        try\n                        {\n                            if (!points.get(((Way)b.member).firstNode()).remove(m2))\n                            {\n                                System.err.println(\"relation member sort: could not remove start mapping for \" + m2);\n                            }\n                            if (!points.get(((Way)b.member).lastNode()).remove(m2))\n                            {\n                                System.err.println(\"relation member sort: could not remove end mapping for \" + m2);\n                            }\n                        }\n                        catch(ClassCastException e1)\n                        {\n                            nodes.remove(b.member);\n                        }\n\n                        try\n                        {\n                            points.get(((Way)a.member).firstNode()).add(m2);\n                            points.get(((Way)a.member).lastNode()).add(m2);\n                        }\n                        catch(ClassCastException e1)\n                        {\n                            nodes.put((Node)a.member, m2);\n                        }\n                    }\n                    try\n                    {\n                        if (!points.get(((Way)a.member).firstNode()).remove(i+1))\n                        {\n                            System.err.println(\"relation member sort: could not remove start mapping for \" + (i+1));\n                        }\n                        if (!points.get(((Way)a.member).lastNode()).remove(i+1))\n                        {\n                            System.err.println(\"relation member sort: could not remove end mapping for \" + (i+1));\n                        }\n                    }\n                    catch(ClassCastException e1)\n                    {\n                        nodes.remove(a.member);\n                    }\n                }\n            }\n        }\n\n        refreshTables();\n    }","id":76907,"modified_method":"private void sort() {\n        java.util.HashMap<Node, java.util.TreeSet<Integer>>   points =\n            new java.util.HashMap<Node, java.util.TreeSet<Integer>>();\n        java.util.HashMap<Node, Integer>   nodes =\n            new java.util.HashMap<Node, Integer>();\n        int                                i;\n        boolean                            lastWayStartUsed = true;\n\n        // TODO: sort only selected rows\n\n        for (i = 1; i < getClone().members.size(); ++i)\n        {\n            RelationMember  m = getClone().members.get(i);\n            if (m.member.incomplete)\n                // TODO: emit some message that sorting failed\n                return;\n            try\n            {\n                Way w = (Way)m.member;\n                if (!points.containsKey(w.firstNode()))\n                {\n                    points.put(w.firstNode(), new java.util.TreeSet<Integer>());\n                }\n                points.get(w.firstNode()).add(Integer.valueOf(i));\n\n                if (!points.containsKey(w.lastNode()))\n                {\n                    points.put(w.lastNode(), new java.util.TreeSet<Integer>());\n                }\n                points.get(w.lastNode()).add(Integer.valueOf(i));\n            }\n            catch(ClassCastException e1)\n            {\n                try\n                {\n                    Node        n = (Node)m.member;\n                    nodes.put(n, Integer.valueOf(i));\n                }\n                catch(ClassCastException e2)\n                {\n                    System.err.println(\"relation member sort: member \" + i + \" is not a way or node\");\n                    return;\n                }\n            }\n        }\n\n        for (i = 0; i < getClone().members.size(); ++i)\n        {\n            RelationMember  m = getClone().members.get(i);\n            Integer         m2 = null;\n            Node            searchNode = null;\n            try\n            {\n                Way             w = (Way)m.member;\n\n                if (lastWayStartUsed || ((i == 0) && !m.role.equals(\"backward\")))\n                {\n                    // try end node\n                    searchNode = w.lastNode();\n                }\n                else /* if ((m2 == null) && (!lastWayStartUsed || (i == 0))) */\n                {\n                    searchNode = w.firstNode();\n                }\n            }\n            catch(ClassCastException e1)\n            {\n                try\n                {\n                    Node n = (Node)m.member;\n                    searchNode = n;\n                }\n                catch(ClassCastException e2)\n                {\n                    // impossible\n                }\n            }\n\n            try {\n                m2 = nodes.get(searchNode);\n                if (m2 == null)\n                {\n                    m2 = points.get(searchNode).first();\n                    if (m.member == getClone().members.get(m2).member)\n                    {\n                        m2 = points.get(searchNode).last();\n                    }\n                }\n            } catch(NullPointerException f) {}\n            catch(java.util.NoSuchElementException e) {}\n\n            if ((m2 == null) && ((i+1) < getClone().members.size()))\n            {\n                // TODO: emit some message that sorting failed\n                System.err.println(\"relation member sort: could not find linked way or node for member \" + i);\n                break;\n            }\n\n            if (m2 != null)\n            {\n                try\n                {\n                    Way next = (Way)getClone().members.get(m2).member;\n                    lastWayStartUsed = searchNode.equals(next.firstNode());\n                }\n                catch(ClassCastException e)\n                {\n                }\n\n                if ((m2 < getClone().members.size()) && ((i+1) < getClone().members.size()))\n                {\n                    RelationMember  a = getClone().members.get(i+1);\n                    RelationMember  b = getClone().members.get(m2);\n\n                    if (m2 != (i+1))\n                    {\n                        getClone().members.set(i+1, b);\n                        getClone().members.set(m2, a);\n\n                        try\n                        {\n                            if (!points.get(((Way)b.member).firstNode()).remove(m2))\n                            {\n                                System.err.println(\"relation member sort: could not remove start mapping for \" + m2);\n                            }\n                            if (!points.get(((Way)b.member).lastNode()).remove(m2))\n                            {\n                                System.err.println(\"relation member sort: could not remove end mapping for \" + m2);\n                            }\n                        }\n                        catch(ClassCastException e1)\n                        {\n                            nodes.remove(b.member);\n                        }\n\n                        try\n                        {\n                            points.get(((Way)a.member).firstNode()).add(m2);\n                            points.get(((Way)a.member).lastNode()).add(m2);\n                        }\n                        catch(ClassCastException e1)\n                        {\n                            nodes.put((Node)a.member, m2);\n                        }\n                    }\n                    try\n                    {\n                        if (!points.get(((Way)a.member).firstNode()).remove(i+1))\n                        {\n                            System.err.println(\"relation member sort: could not remove start mapping for \" + (i+1));\n                        }\n                        if (!points.get(((Way)a.member).lastNode()).remove(i+1))\n                        {\n                            System.err.println(\"relation member sort: could not remove end mapping for \" + (i+1));\n                        }\n                    }\n                    catch(ClassCastException e1)\n                    {\n                        nodes.remove(a.member);\n                    }\n                }\n            }\n        }\n\n        refreshTables();\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void addSelected() {\n        for (OsmPrimitive p : Main.ds.getSelected()) {\n            // ordered relations may have the same member multiple times.\n            // TODO: visual indication of the fact that one is there more than once?\n            RelationMember em = new RelationMember();\n            em.member = p;\n            em.role = \"\";\n            // when working with ordered relations, we make an effort to\n            // add the element before the first selected member.\n            int[] rows = memberTable.getSelectedRows();\n            if (rows.length > 0) {\n                clone.members.add(rows[0], em);\n            } else {\n                clone.members.add(em);\n            }\n        }\n        refreshTables();\n    }","id":76908,"modified_method":"private void addSelected() {\n        for (OsmPrimitive p : Main.ds.getSelected()) {\n            // ordered relations may have the same member multiple times.\n            // TODO: visual indication of the fact that one is there more than once?\n            RelationMember em = new RelationMember();\n            em.member = p;\n            em.role = \"\";\n            // when working with ordered relations, we make an effort to\n            // add the element before the first selected member.\n            int[] rows = memberTable.getSelectedRows();\n            if (rows.length > 0) {\n                getClone().members.add(rows[0], em);\n            } else {\n                getClone().members.add(em);\n            }\n        }\n        refreshTables();\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * This is a factory method that creates an appropriate RelationEditor\n     * instance suitable for editing the relation that was passed in as an\n     * argument.\n     *\n     * This method is guaranteed to return a working RelationEditor. If no\n     * specific editor has been registered for the type of relation, then\n     * a generic editor will be returned.\n     * \n     * Editors can be registered by adding their class to the static list \"editors\"\n     * in the RelationEditor class. When it comes to editing a relation, all\n     * registered editors are queried via their static \"canEdit\" method whether they\n     * feel responsible for that kind of relation, and if they return true\n     * then an instance of that class will be used.\n     *\n     * @param r the relation to be edited\n     * @return an instance of RelationEditor suitable for editing that kind of relation\n     */\n    public static RelationEditor getEditor(Relation r, Collection<RelationMember> selectedMembers) {\n        for (Class<RelationEditor> e : editors) {\n            try {\n                Method m = e.getMethod(\"canEdit\", Relation.class);\n                Boolean canEdit = (Boolean) m.invoke(null, r);\n                if (canEdit) {\n                    Constructor<RelationEditor> con = e.getConstructor(Relation.class, Collection.class);\n                    RelationEditor editor = con.newInstance(r, selectedMembers);\n                    return editor;\n                }\n            } catch (Exception ex) {\n                // plod on\n            }\n        }\n        return new GenericRelationEditor(r, selectedMembers);\n    }","id":76909,"modified_method":"/**\n     * This is a factory method that creates an appropriate RelationEditor\n     * instance suitable for editing the relation that was passed in as an\n     * argument.\n     *\n     * This method is guaranteed to return a working RelationEditor. If no\n     * specific editor has been registered for the type of relation, then\n     * a generic editor will be returned.\n     * \n     * Editors can be registered by adding their class to the static list \"editors\"\n     * in the RelationEditor class. When it comes to editing a relation, all\n     * registered editors are queried via their static \"canEdit\" method whether they\n     * feel responsible for that kind of relation, and if they return true\n     * then an instance of that class will be used.\n     *\n     * @param r the relation to be edited\n     * @return an instance of RelationEditor suitable for editing that kind of relation\n     */\n    public static RelationEditor getEditor(Relation r, Collection<RelationMember> selectedMembers) {\n        for (Class<RelationEditor> e : editors) {\n            try {\n                Method m = e.getMethod(\"canEdit\", Relation.class);\n                Boolean canEdit = (Boolean) m.invoke(null, r);\n                if (canEdit) {\n                    Constructor<RelationEditor> con = e.getConstructor(Relation.class, Collection.class);\n                    RelationEditor editor = con.newInstance(r, selectedMembers);\n                    return editor;\n                }\n            } catch (Exception ex) {\n                // plod on\n            }\n        }\n        if (getRelationDialogManager().isOpenInEditor(r))\n            return getRelationDialogManager().getEditorForRelation(r);\n        else {\n            RelationEditor editor = new GenericRelationEditor(r, selectedMembers);\n            getRelationDialogManager().register(r, editor);\n            return editor;\n        }\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public Collection<Command> execute(Way oldway, Way way) throws UserCancelException {\n        Map<OsmPrimitive, List<TagCorrection>> tagCorrectionsMap =\n                new HashMap<OsmPrimitive, List<TagCorrection>>();\n\n        ArrayList<OsmPrimitive> primitives = new ArrayList<OsmPrimitive>();\n        primitives.add(way);\n        primitives.addAll(way.nodes);\n\n        for (OsmPrimitive primitive : primitives) {\n            tagCorrectionsMap.put(primitive, new ArrayList<TagCorrection>());\n\n            for (String key : primitive.keySet()) {\n                String newKey = key;\n                String value = primitive.get(key);\n                String newValue = value;\n\n                if (key.equals(\"oneway\")) {\n                    if (value.equals(\"-1\"))\n                        newValue = OsmUtils.trueval;\n                    else {\n                        Boolean boolValue = OsmUtils.getOsmBoolean(value);\n                        if (boolValue != null && boolValue.booleanValue()) {\n                            newValue = \"-1\";\n                        }\n                    }\n                } else {\n                    for (PrefixSuffixSwitcher prefixSuffixSwitcher : prefixSuffixSwitchers) {\n                        newKey = prefixSuffixSwitcher.apply(key);\n                        if (!key.equals(newKey))\n                            break;\n                    }\n                }\n\n                if (!key.equals(newKey) || !value.equals(newValue))\n                    tagCorrectionsMap.get(primitive).add(\n                            new TagCorrection(key, value, newKey, newValue));\n            }\n        }\n\n        Map<OsmPrimitive, List<RoleCorrection>> roleCorrectionMap =\n                new HashMap<OsmPrimitive, List<RoleCorrection>>();\n        roleCorrectionMap.put(way, new ArrayList<RoleCorrection>());\n\n        for (Relation relation : Main.ds.relations) {\n            int position = 0;\n            for (RelationMember member : relation.members) {\n                if (!member.member.realEqual(oldway, true)\n                        || member.role.length() == 0) {\n                    position++;\n                    continue;\n                }\n\n                boolean found = false;\n                String newRole = null;\n                for (PrefixSuffixSwitcher prefixSuffixSwitcher : prefixSuffixSwitchers) {\n                    newRole = prefixSuffixSwitcher.apply(member.role);\n                    if (!newRole.equals(member.role)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (found)\n                    roleCorrectionMap.get(way).add(\n                            new RoleCorrection(relation, position, member, newRole));\n\n                position++;\n            }\n        }\n\n        return applyCorrections(tagCorrectionsMap, roleCorrectionMap,\n                tr(\"When reversing this way, the following changes to properties \"\n                        + \"of the way and its nodes are suggested in order \"\n                        + \"to maintain data consistency.\"));\n    }","id":76910,"modified_method":"@Override\n    public Collection<Command> execute(Way oldway, Way way) throws UserCancelException {\n        Map<OsmPrimitive, List<TagCorrection>> tagCorrectionsMap =\n            new HashMap<OsmPrimitive, List<TagCorrection>>();\n\n        ArrayList<OsmPrimitive> primitives = new ArrayList<OsmPrimitive>();\n        primitives.add(way);\n        primitives.addAll(way.nodes);\n\n        for (OsmPrimitive primitive : primitives) {\n            tagCorrectionsMap.put(primitive, new ArrayList<TagCorrection>());\n\n            for (String key : primitive.keySet()) {\n                String newKey = key;\n                String value = primitive.get(key);\n                String newValue = value;\n\n                if (key.equals(\"oneway\")) {\n                    if (value.equals(\"-1\")) {\n                        newValue = OsmUtils.trueval;\n                    } else {\n                        Boolean boolValue = OsmUtils.getOsmBoolean(value);\n                        if (boolValue != null && boolValue.booleanValue()) {\n                            newValue = \"-1\";\n                        }\n                    }\n                } else {\n                    for (PrefixSuffixSwitcher prefixSuffixSwitcher : prefixSuffixSwitchers) {\n                        newKey = prefixSuffixSwitcher.apply(key);\n                        if (!key.equals(newKey)) {\n                            break;\n                        }\n                    }\n                }\n\n                if (!key.equals(newKey) || !value.equals(newValue)) {\n                    tagCorrectionsMap.get(primitive).add(\n                            new TagCorrection(key, value, newKey, newValue));\n                }\n            }\n        }\n\n        Map<OsmPrimitive, List<RoleCorrection>> roleCorrectionMap =\n            new HashMap<OsmPrimitive, List<RoleCorrection>>();\n        roleCorrectionMap.put(way, new ArrayList<RoleCorrection>());\n\n        for (Relation relation : Main.ds.relations) {\n            int position = 0;\n            for (RelationMember member : relation.members) {\n                if (!member.member.hasEqualSemanticAttributes(oldway)\n                        || member.role.length() == 0) {\n                    position++;\n                    continue;\n                }\n\n                boolean found = false;\n                String newRole = null;\n                for (PrefixSuffixSwitcher prefixSuffixSwitcher : prefixSuffixSwitchers) {\n                    newRole = prefixSuffixSwitcher.apply(member.role);\n                    if (!newRole.equals(member.role)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    roleCorrectionMap.get(way).add(\n                            new RoleCorrection(relation, position, member, newRole));\n                }\n\n                position++;\n            }\n        }\n\n        return applyCorrections(tagCorrectionsMap, roleCorrectionMap,\n                tr(\"When reversing this way, the following changes to properties \"\n                        + \"of the way and its nodes are suggested in order \"\n                        + \"to maintain data consistency.\"));\n    }","commit_id":"6c3dc3586eee37a3f719600fd6311e27900def65","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n\tpublic void selectVertexRefs(Collection<? extends VertexRef> vertexRefs) {\n\t\tfor(VertexRef vertexRef : vertexRefs) {\n\t\t\tsetVertexRefSelected(vertexRef, true);\n\t\t}\n\t\t\n\t\tfireSelectionChanged();\n\t}","id":76911,"modified_method":"@Override\n\tpublic void selectVertexRefs(Collection<? extends VertexRef> vertexRefs) {\n\t    int selectionSize = getSelectedVertexRefs().size();\n\t    for(VertexRef vertexRef : vertexRefs) {\n\t\t\tsetVertexRefSelected(vertexRef, true);\n\t\t}\n\t    int selectionSizeAfterRemoval = getSelectedVertexRefs().size();\n\t    \n\t    if(selectionSize != selectionSizeAfterRemoval) {\n            fireSelectionChanged();\n        }\n\t}","commit_id":"7699e48f448172ef2efa58f4eed9a7267347a6b1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic void deselectVertexRefs(Collection<? extends VertexRef> vertexRefs) {\n\t\tfor(VertexRef vertexRef : vertexRefs) {\n\t\t\tsetVertexRefSelected(vertexRef, false);\n\t\t}\n\t\t\n\t\tfireSelectionChanged();\n\t}","id":76912,"modified_method":"@Override\n\tpublic void deselectVertexRefs(Collection<? extends VertexRef> vertexRefs) {\n\t\tint selectionSize = getSelectedVertexRefs().size();\n\t    for(VertexRef vertexRef : vertexRefs) {\n\t\t\tsetVertexRefSelected(vertexRef, false);\n\t\t}\n\t\tint selectionSizeAfterRemoval = getSelectedVertexRefs().size();\n\t\t\n\t\tif(selectionSize != selectionSizeAfterRemoval) {\n\t\t    fireSelectionChanged();\n\t\t}\n\t}","commit_id":"7699e48f448172ef2efa58f4eed9a7267347a6b1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private BoundingBox getBoundingBox() {\n        m_scale.setValue(m_viewManager.getScale());\n        return m_viewManager.getCurrentBoundingBox();\n    }","id":76913,"modified_method":"private BoundingBox getBoundingBox() {\n        double scale = m_viewManager.getScale();\n        m_scale.setValue(scale);\n        \n        return m_viewManager.getCurrentBoundingBox();\n    }","commit_id":"7699e48f448172ef2efa58f4eed9a7267347a6b1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Main vaadin method for receiving communication from the Front End\n     * \n     */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n    public void changeVariables(Object source, Map<String, Object> variables) {\n        if(variables.containsKey(\"graph\")) {\n            String graph = (String) variables.get(\"graph\");\n            getApplication().getMainWindow().showNotification(\"\" + graph);\n            \n        }\n        \n        if(variables.containsKey(\"clickedEdge\")) {\n            String edgeId = (String) variables.get(\"clickedEdge\");\n            selectEdge(edgeId);\n        }\n        \n        if(variables.containsKey(\"clickedBackground\")) {\n            getSelectionManager().deselectAll();\n        }\n        \n        if(variables.containsKey(\"clickedVertex\")) {\n            String vertexKey = (String) variables.get(\"clickedVertex\");\n            if((variables.containsKey(\"shiftKeyPressed\") && (Boolean) variables.get(\"shiftKeyPressed\") == true) \n                    || variables.containsKey(\"metaKeyPressed\") && (Boolean) variables.get(\"metaKeyPressed\") == true\n                    || (variables.containsKey(\"ctrlKeyPressed\") && (Boolean) variables.get(\"ctrlKeyPressed\") == true  && !(((String)variables.get(\"platform\")).indexOf(\"Mac\") > 0)  )) {\n        \t    addVerticesToSelection(vertexKey);\n        \t}else {\n        \t    selectVertices(vertexKey);\n        \t}\n            \n        }\n        \n        if(variables.containsKey(\"marqueeSelection\")) {\n            String[] vertexKeys = (String[]) variables.get(\"marqueeSelection\");\n            if(variables.containsKey(\"shiftKeyPressed\") && (Boolean) variables.get(\"shiftKeyPressed\") == true) {\n            \taddVerticesToSelection(vertexKeys);\n            } else {\n            \tselectVertices(vertexKeys);\n            }\n            \n        }\n        \n        if(variables.containsKey(\"updateVertices\")) {\n            String[] vertices = (String[]) variables.get(\"updateVertices\");\n            for(String vUpdate : vertices) {\n                updateVertex(vUpdate);\n            }\n            if(vertices.length > 0) {\n                requestRepaint();\n            }\n            \n        }\n        \n        if(variables.containsKey(\"mapScale\")) {\n            double newScale = (Double)variables.get(\"mapScale\");\n            setScaleUpdateFromUI(true);\n            setScale(newScale);\n        }\n        \n        if(variables.containsKey(\"scrollWheel\")) {\n            Map<String, Object> props = (Map<String, Object>) variables.get(\"scrollWheel\");\n            int x = (Integer) props.get(\"x\");\n            int y = (Integer) props.get(\"y\");\n            double scrollVal = (Double) props.get(\"scrollVal\");\n            m_viewManager.zoomToPoint(m_viewManager.getScale() + scrollVal, new Point(x, y));\n        }\n        \n        if(variables.containsKey(\"clientCenterPoint\")) {\n            Map<String, Object> props = (Map<String, Object>) variables.get(\"clientCenterPoint\");\n            int x = (Integer) props.get(\"x\");\n            int y = (Integer) props.get(\"y\"); \n            m_viewManager.setCenter(new Point(x, y));\n            \n        }\n        \n        if(variables.containsKey(\"clientX\")) {\n            int clientX = (Integer) variables.get(\"clientX\");\n            m_mapManager.setClientX(clientX);\n        }\n        \n        if(variables.containsKey(\"clientY\")) {\n            int clientY = (Integer) variables.get(\"clientY\");\n            m_mapManager.setClientY(clientY);\n        }\n        \n        if(variables.containsKey(\"contextMenu\")) {\n            Map<String, Object> props = (Map<String, Object>) variables.get(\"contextMenu\");\n            \n            \n            int x = (Integer) props.get(\"x\");\n            int y = (Integer) props.get(\"y\");\n            \n            String type = (String) props.get(\"type\");\n\n            Object target = null;\n            if (type.toLowerCase().equals(\"vertex\")) {\n            \tString targetKey = (String)props.get(\"target\");\n            \ttarget = getGraph().getVertexByKey(targetKey);\n            \tgetSelectionManager().setSelectedVertexRefs(Arrays.asList((Vertex) target));\n            } else if (type.toLowerCase().equals(\"edge\")) {\n            \tString targetKey = (String)props.get(\"target\");\n            \ttarget = getGraph().getEdgeByKey(targetKey);\n            }\n\n            getContextMenuHandler().show(target, x, y);\n        }\n        \n        if(variables.containsKey(\"mapPhysicalBounds\")) {\n            Map<String, Object> bounds = (Map<String, Object>) variables.get(\"mapPhysicalBounds\");\n            Integer width = (Integer)bounds.get(\"width\");\n            Integer height = (Integer)bounds.get(\"height\");\n            \n            m_mapManager.setClientWidth(width);\n            m_mapManager.setClientHeight(height);\n            m_viewManager.setViewPort(width, height);\n            \n        }\n        \n        if(variables.containsKey(\"doubleClick\")) {\n            Map<String, Object> props = (Map<String, Object>) variables.get(\"doubleClick\");\n            int x = (Integer) props.get(\"x\");\n            int y = (Integer) props.get(\"y\");\n            \n            double scale = m_viewManager.getScale() + 0.1;\n            System.out.println(\"double click: scale: \" + scale + \" x: \" + x + \" y: \" + y );\n            m_viewManager.zoomToPoint(scale, new Point(x, y));\n        }\n        \n        updateMenuItems();\n    }","id":76914,"modified_method":"/**\n     * Main vaadin method for receiving communication from the Front End\n     * \n     */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n    public void changeVariables(Object source, Map<String, Object> variables) {\n        if(variables.containsKey(\"graph\")) {\n            String graph = (String) variables.get(\"graph\");\n            getApplication().getMainWindow().showNotification(\"\" + graph);\n            \n        }\n        \n        if(variables.containsKey(\"clickedEdge\")) {\n            String edgeId = (String) variables.get(\"clickedEdge\");\n            selectEdge(edgeId);\n        }\n        \n        if(variables.containsKey(\"clickedBackground\")) {\n            getSelectionManager().deselectAll();\n        }\n        \n        if(variables.containsKey(\"clickedVertex\")) {\n            String vertexKey = (String) variables.get(\"clickedVertex\");\n            if((variables.containsKey(\"shiftKeyPressed\") && (Boolean) variables.get(\"shiftKeyPressed\") == true) \n                    || variables.containsKey(\"metaKeyPressed\") && (Boolean) variables.get(\"metaKeyPressed\") == true\n                    || (variables.containsKey(\"ctrlKeyPressed\") && (Boolean) variables.get(\"ctrlKeyPressed\") == true  && !(((String)variables.get(\"platform\")).indexOf(\"Mac\") > 0)  )) {\n        \t    addVerticesToSelection(vertexKey);\n        \t}else {\n        \t    selectVertices(vertexKey);\n        \t}\n            \n        }\n        \n        if(variables.containsKey(\"marqueeSelection\")) {\n            String[] vertexKeys = (String[]) variables.get(\"marqueeSelection\");\n            if(variables.containsKey(\"shiftKeyPressed\") && (Boolean) variables.get(\"shiftKeyPressed\") == true) {\n            \taddVerticesToSelection(vertexKeys);\n            } else {\n            \tselectVertices(vertexKeys);\n            }\n            \n        }\n        \n        if(variables.containsKey(\"updateVertices\")) {\n            String[] vertices = (String[]) variables.get(\"updateVertices\");\n            for(String vUpdate : vertices) {\n                updateVertex(vUpdate);\n            }\n            if(vertices.length > 0) {\n                requestRepaint();\n            }\n            \n        }\n        \n        if(variables.containsKey(\"scrollWheel\")) {\n            Map<String, Object> props = (Map<String, Object>) variables.get(\"scrollWheel\");\n            int x = (Integer) props.get(\"x\");\n            int y = (Integer) props.get(\"y\");\n            double scrollVal = (Double) props.get(\"scrollVal\");\n            m_viewManager.zoomToPoint(m_viewManager.getScale() + scrollVal, new Point(x, y));\n        }\n        \n        if(variables.containsKey(\"clientCenterPoint\")) {\n            Map<String, Object> props = (Map<String, Object>) variables.get(\"clientCenterPoint\");\n            int x = (Integer) props.get(\"x\");\n            int y = (Integer) props.get(\"y\"); \n            m_viewManager.setCenter(new Point(x, y));\n            \n        }\n        \n        if(variables.containsKey(\"contextMenu\")) {\n            Map<String, Object> props = (Map<String, Object>) variables.get(\"contextMenu\");\n            \n            \n            int x = (Integer) props.get(\"x\");\n            int y = (Integer) props.get(\"y\");\n            \n            String type = (String) props.get(\"type\");\n\n            Object target = null;\n            if (type.toLowerCase().equals(\"vertex\")) {\n            \tString targetKey = (String)props.get(\"target\");\n            \ttarget = getGraph().getVertexByKey(targetKey);\n            \tgetSelectionManager().setSelectedVertexRefs(Arrays.asList((Vertex) target));\n            } else if (type.toLowerCase().equals(\"edge\")) {\n            \tString targetKey = (String)props.get(\"target\");\n            \ttarget = getGraph().getEdgeByKey(targetKey);\n            }\n\n            getContextMenuHandler().show(target, x, y);\n        }\n        \n        if(variables.containsKey(\"mapPhysicalBounds\")) {\n            Map<String, Object> bounds = (Map<String, Object>) variables.get(\"mapPhysicalBounds\");\n            Integer width = (Integer)bounds.get(\"width\");\n            Integer height = (Integer)bounds.get(\"height\");\n            \n            m_mapManager.setClientWidth(width);\n            m_mapManager.setClientHeight(height);\n            m_viewManager.setViewPort(width, height);\n            \n        }\n        \n        if(variables.containsKey(\"doubleClick\")) {\n            Map<String, Object> props = (Map<String, Object>) variables.get(\"doubleClick\");\n            int x = (Integer) props.get(\"x\");\n            int y = (Integer) props.get(\"y\");\n            \n            double scale = m_viewManager.getScale() + 0.1;\n            m_viewManager.zoomToPoint(scale, new Point(x, y));\n        }\n        \n        updateMenuItems();\n    }","commit_id":"7699e48f448172ef2efa58f4eed9a7267347a6b1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setScale(double scale){\n\t    setScaleUpdateFromUI(true);\n\t    m_scale.setValue(scale);\n    }","id":76915,"modified_method":"protected void setScale(double scale){\n\t    m_scale.setValue(scale);\n    }","commit_id":"7699e48f448172ef2efa58f4eed9a7267347a6b1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        validateContainersName(container);\n        if (isPartOfEnsemble(container) && !force) {\n            System.out.println(\"Container is part of the ensemble. If you still want to delete it, please use -f option.\");\n            return null;\n        }\n\n        Container found = getContainer(container);\n        applyUpdatedCredentials(found);\n        if (recursive) {\n            for (Container child : found.getChildren()) {\n                child.stop(force);\n                child.destroy(force);\n            }\n        }\n        found.stop(force);\n        found.destroy(force);\n        return null;\n    }","id":76916,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        validateContainersName(container);\n        if (isPartOfEnsemble(container) && !force) {\n            System.out.println(\"Container is part of the ensemble. If you still want to delete it, please use -f option.\");\n            return null;\n        }\n\n        Container found = getContainer(container);\n        applyUpdatedCredentials(found);\n        if (recursive) {\n            for (Container child : found.getChildren()) {\n                child.destroy(force);\n            }\n        }\n        found.destroy(force);\n        return null;\n    }","commit_id":"dafa3476ed7f6ecc401848f412be766b1e6a44c1","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void destroyContainer(Container container, boolean force) {\n        assertValid();\n        String containerId = container.getId();\n        LOGGER.info(\"Destroying container {}\", containerId);\n        ContainerProvider provider = getProvider(container);\n        provider.destroy(container);\n        try {\n            portService.get().unregisterPort(container);\n            getDataStore().deleteContainer(container.getId());\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to cleanup container {} entries due to: {}. This will be ignored.\", containerId, e.getMessage());\n        }\n    }","id":76917,"modified_method":"public void destroyContainer(Container container, boolean force) {\n        assertValid();\n        String containerId = container.getId();\n        LOGGER.info(\"Destroying container {}\", containerId);\n        ContainerProvider provider = getProvider(container, true);\n        if (provider == null && !force) {\n            // Should throw an exception\n            getProvider(container);\n        }\n        if (provider != null) {\n            provider.stop(container);\n            provider.destroy(container);\n        }\n        try {\n            portService.get().unregisterPort(container);\n            getDataStore().deleteContainer(container.getId());\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to cleanup container {} entries due to: {}. This will be ignored.\", containerId, e.getMessage());\n        }\n    }","commit_id":"dafa3476ed7f6ecc401848f412be766b1e6a44c1","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private ContainerProvider getProvider(Container container) {\n        CreateContainerMetadata metadata = container.getMetadata();\n        String type = metadata != null ? metadata.getCreateOptions().getProviderType() : null;\n        if (type == null) {\n            throw new UnsupportedOperationException(\"Container \" + container.getId() + \" has not been created using Fabric\");\n        }\n        ContainerProvider provider = getProvider(type);\n        if (provider == null) {\n            throw new UnsupportedOperationException(\"Container provider \" + type + \" not supported\");\n        }\n        return provider;\n    }","id":76918,"modified_method":"private ContainerProvider getProvider(Container container) {\n        return getProvider(container, false);\n    }","commit_id":"dafa3476ed7f6ecc401848f412be766b1e6a44c1","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\tif(settings.MAP_SCREEN_ORIENTATION.get() != getRequestedOrientation()){\n\t\t\tsetRequestedOrientation(settings.MAP_SCREEN_ORIENTATION.get());\n\t\t\t// can't return from this method we are not sure if activity will be recreated or not\n\t\t}\n\t\tmapLayers.getNavigationLayer().setPointToNavigate(settings.getPointToNavigate());\n\t\t\n\t\tcurrentScreenOrientation = getWindow().getWindowManager().getDefaultDisplay().getOrientation();\n\t\t\n\t\t// for voice navigation\n\t\tif(settings.AUDIO_STREAM_GUIDANCE.get() != null){\n\t\t\tsetVolumeControlStream(settings.AUDIO_STREAM_GUIDANCE.get());\n\t\t} else {\n\t\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t\t}\n\t\t\n\t\tmapLayers.updateMapSource(mapView, null);\n\t\tupdateApplicationModeSettings();\n\t\t\n\t\tmapLayers.getPoiMapLayer().setFilter(settings.getPoiFilterForMap((OsmandApplication) getApplication()));\n\t\t\n\t\tbackToLocation.setVisibility(View.INVISIBLE);\n\t\tisMapLinkedToLocation = false;\n\t\tif(routingHelper.isFollowingMode()){\n\t\t\t// by default turn off causing unexpected movements due to network establishing\n\t\t\t// best to show previous location\n\t\t\tisMapLinkedToLocation = true;\n\t\t}\n\t\t\n\t\troutingHelper.setUiActivity(this);\n\t\troutingHelper.getVoiceRouter().onActivityInit(this);\n\t\tif(routingHelper.isFollowingMode() && !Algoritms.objectEquals(settings.getPointToNavigate(), routingHelper.getFinalLocation())){\n\t\t\troutingHelper.setFinalAndCurrentLocation(settings.getPointToNavigate(), routingHelper.getCurrentLocation());\n\t\t}\n\t\t\n\t\tLocationManager service = (LocationManager) getSystemService(LOCATION_SERVICE);\n\t\ttry {\n\t\t\tservice.requestLocationUpdates(LocationManager.GPS_PROVIDER, GPS_TIMEOUT_REQUEST, GPS_DIST_REQUEST, gpsListener);\n\t\t\tcurrentLocationProvider = LocationManager.GPS_PROVIDER;\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tLog.d(LogUtil.TAG, \"GPS location provider not available\"); //$NON-NLS-1$\n\t\t}\n\t\tif(!useOnlyGPS()){\n\t\t\t// try to always  ask for network provide : it is faster way to find location\n\t\t\ttry {\n\t\t\t\tservice.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, GPS_TIMEOUT_REQUEST, GPS_DIST_REQUEST, networkListener);\n\t\t\t\tcurrentLocationProvider = LocationManager.NETWORK_PROVIDER;\n\t\t\t} catch(IllegalArgumentException e) {\n\t\t\t\tLog.d(LogUtil.TAG, \"Network location provider not available\"); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\n\t\tLocationProvider  prov = service.getProvider(currentLocationProvider); \n\t\tproviderSupportsBearing = prov == null ? false : prov.supportsBearing() && !isRunningOnEmulator();\n\t\tproviderSupportsSpeed = prov == null ? false : prov.supportsSpeed() && !isRunningOnEmulator();\n\t\t\n\t\tif(settings != null && settings.isLastKnownMapLocation()){\n\t\t\tLatLon l = settings.getLastKnownMapLocation();\n\t\t\tmapView.setLatLon(l.getLatitude(), l.getLongitude());\n\t\t\tmapView.setZoom(settings.getLastKnownMapZoom());\n\t\t}\n\t\t\n\t\t\n\t\tif (wakeLock == null) {\n\t\t\tPowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n\t\t\twakeLock = powerManager.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, \"net.osmand.map\"); //$NON-NLS-1$\n\t\t\twakeLock.acquire();\n\t\t}\n\t\t\n\t\tsettings.MAP_ACTIVITY_ENABLED.set(true);\n\t\tcheckExternalStorage();\n\t\tshowAndHideMapPosition();\n\t\t\n\t\tLatLon cur = new LatLon(mapView.getLatitude(), mapView.getLongitude());\n\t\tLatLon latLon = settings.getAndClearMapLocationToShow();\n\t\tif (latLon != null && !latLon.equals(cur)) {\n\t\t\tmapView.getAnimatedDraggingThread().startMoving(latLon.getLatitude(),\n\t\t\t\t\tlatLon.getLongitude(), settings.getMapZoomToShow(),  true);\n\t\t}\n\t\t\n\t\t\n\t\tView progress = findViewById(R.id.ProgressBar);\n\t\tif(progress != null){\n\t\t\tgetMyApplication().getResourceManager().setBusyIndicator(new BusyIndicator(this, progress));\n\t\t}\n\t\t\n\t\tgetMyApplication().getDaynightHelper().onMapResume();\n\t}","id":76919,"modified_method":"@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\tif(settings.MAP_SCREEN_ORIENTATION.get() != getRequestedOrientation()){\n\t\t\tsetRequestedOrientation(settings.MAP_SCREEN_ORIENTATION.get());\n\t\t\t// can't return from this method we are not sure if activity will be recreated or not\n\t\t}\n\t\tmapLayers.getNavigationLayer().setPointToNavigate(settings.getPointToNavigate());\n\t\t\n\t\tcurrentScreenOrientation = getWindow().getWindowManager().getDefaultDisplay().getOrientation();\n\t\t\n\t\t// for voice navigation\n\t\tif(settings.AUDIO_STREAM_GUIDANCE.get() != null){\n\t\t\tsetVolumeControlStream(settings.AUDIO_STREAM_GUIDANCE.get());\n\t\t} else {\n\t\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t\t}\n\t\t\n\t\tmapLayers.updateMapSource(mapView, null);\n\t\tupdateApplicationModeSettings();\n\t\t\n\t\tmapLayers.getPoiMapLayer().setFilter(settings.getPoiFilterForMap((OsmandApplication) getApplication()));\n\t\t\n\t\tbackToLocation.setVisibility(View.INVISIBLE);\n\t\tisMapLinkedToLocation = false;\n\t\tif(routingHelper.isFollowingMode()){\n\t\t\t// by default turn off causing unexpected movements due to network establishing\n\t\t\t// best to show previous location\n\t\t\tisMapLinkedToLocation = true;\n\t\t}\n\t\t\n\t\troutingHelper.setUiActivity(this);\n\t\troutingHelper.getVoiceRouter().onActivityInit(this);\n\t\tif(routingHelper.isFollowingMode() && !Algoritms.objectEquals(settings.getPointToNavigate(), routingHelper.getFinalLocation())){\n\t\t\troutingHelper.setFinalAndCurrentLocation(settings.getPointToNavigate(), routingHelper.getCurrentLocation());\n\t\t}\n\t\t\n\t\tLocationManager service = (LocationManager) getSystemService(LOCATION_SERVICE);\n\t\ttry {\n\t\t\tservice.requestLocationUpdates(LocationManager.GPS_PROVIDER, GPS_TIMEOUT_REQUEST, GPS_DIST_REQUEST, gpsListener);\n\t\t\tcurrentLocationProvider = LocationManager.GPS_PROVIDER;\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tLog.d(LogUtil.TAG, \"GPS location provider not available\"); //$NON-NLS-1$\n\t\t}\n\t\tif(!useOnlyGPS()){\n\t\t\t// try to always  ask for network provide : it is faster way to find location\n\t\t\ttry {\n\t\t\t\tservice.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, GPS_TIMEOUT_REQUEST, GPS_DIST_REQUEST, networkListener);\n\t\t\t\tcurrentLocationProvider = LocationManager.NETWORK_PROVIDER;\n\t\t\t} catch(IllegalArgumentException e) {\n\t\t\t\tLog.d(LogUtil.TAG, \"Network location provider not available\"); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\n\t\tLocationProvider  prov = currentLocationProvider != null ? service.getProvider(currentLocationProvider) : null; \n\t\tproviderSupportsBearing = prov == null ? false : prov.supportsBearing() && !isRunningOnEmulator();\n\t\tproviderSupportsSpeed = prov == null ? false : prov.supportsSpeed() && !isRunningOnEmulator();\n\t\t\n\t\tif(settings != null && settings.isLastKnownMapLocation()){\n\t\t\tLatLon l = settings.getLastKnownMapLocation();\n\t\t\tmapView.setLatLon(l.getLatitude(), l.getLongitude());\n\t\t\tmapView.setZoom(settings.getLastKnownMapZoom());\n\t\t}\n\t\t\n\t\t\n\t\tif (wakeLock == null) {\n\t\t\tPowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n\t\t\twakeLock = powerManager.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, \"net.osmand.map\"); //$NON-NLS-1$\n\t\t\twakeLock.acquire();\n\t\t}\n\t\t\n\t\tsettings.MAP_ACTIVITY_ENABLED.set(true);\n\t\tcheckExternalStorage();\n\t\tshowAndHideMapPosition();\n\t\t\n\t\tLatLon cur = new LatLon(mapView.getLatitude(), mapView.getLongitude());\n\t\tLatLon latLon = settings.getAndClearMapLocationToShow();\n\t\tif (latLon != null && !latLon.equals(cur)) {\n\t\t\tmapView.getAnimatedDraggingThread().startMoving(latLon.getLatitude(),\n\t\t\t\t\tlatLon.getLongitude(), settings.getMapZoomToShow(),  true);\n\t\t}\n\t\t\n\t\t\n\t\tView progress = findViewById(R.id.ProgressBar);\n\t\tif(progress != null){\n\t\t\tgetMyApplication().getResourceManager().setBusyIndicator(new BusyIndicator(this, progress));\n\t\t}\n\t\t\n\t\tgetMyApplication().getDaynightHelper().onMapResume();\n\t}","commit_id":"860ce11670fad4dc04254fd83795ee14d61ea425","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private InstallationDetails createInstallationDetails(final Cloud cloud, final MachineDetails md)\n\t\t\tthrows FileNotFoundException {\n\t\t// TODO - move this to a util package - it is copied in bootstrap-cloud\n\t\tfinal InstallationDetails details = new InstallationDetails();\n\n\t\tdetails.setLocalDir(cloud.getProvider().getLocalDirectory());\n\t\tfinal String remoteDir = getRemoteDir();\n\t\tdetails.setRemoteDir(remoteDir);\n\t\tdetails.setManagementOnlyFiles(cloud.getProvider().getManagementOnlyFiles());\n\t\tfinal String[] zones = this.config.getGridServiceAgentZones();\n\t\tdetails.setZones(StringUtils.join(zones, \",\", 0, zones.length));\n\n\t\tif (org.apache.commons.lang.StringUtils.isNotBlank(cloud.getUser().getKeyFile())) {\n\t\t\tlogger.info(\"Key file has been specified in cloud configuration: \" + cloud.getUser().getKeyFile());\n\t\t\tfinal File keyFile = new File(cloud.getProvider().getLocalDirectory(), cloud.getUser().getKeyFile());\n\t\t\tif (keyFile.exists()) {\n\t\t\t\tdetails.setKeyFile(keyFile.getAbsolutePath());\n\t\t\t\tlogger.info(\"Using key file: \" + keyFile);\n\t\t\t} else {\n\t\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\t\"Could not find key file matching specified cloud configuration key file: \"\n\t\t\t\t\t\t\t\t+ cloud.getUser().getKeyFile() + \". Tried: \" + keyFile + \" but file does not exist\");\n\t\t\t}\n\n\t\t}\n\n\t\tdetails.setPrivateIp(md.getPrivateAddress());\n\t\tdetails.setPublicIp(md.getPublicAddress());\n\n\t\tdetails.setLocator(this.lookupLocatorsString);\n\t\tdetails.setLus(false);\n\t\tdetails.setCloudifyUrl(cloud.getProvider().getCloudifyUrl());\n\t\tdetails.setOverridesUrl(cloud.getProvider().getCloudifyOverridesUrl());\n\t\tdetails.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());\n\t\tdetails.setAdmin(this.admin);\n\n\t\tdetails.setUsername(md.getRemoteUsername());\n\t\tdetails.setPassword(md.getRemotePassword());\n\t\tdetails.setRemoteExecutionMode(md.getRemoteExecutionMode());\n\t\tdetails.setFileTransferMode(md.getFileTransferMode());\n\t\tlogger.info(\"Created new Installation Details: \" + details);\n\t\treturn details;\n\n\t}","id":76920,"modified_method":"private InstallationDetails createInstallationDetails(final Cloud cloud, final MachineDetails md)\n\t\t\tthrows FileNotFoundException {\n\t\tfinal CloudTemplate template = this.cloud.getTemplates().get(this.cloudTemplateName);\n\t\tfinal String[] zones = this.config.getGridServiceAgentZones();\n\t\tfinal InstallationDetails details =\n\t\t\t\tUtils.createInstallationDetails(md, cloud, template, zones, lookupLocatorsString, this.admin);\n\n\t\tlogger.info(\"Created new Installation Details: \" + details);\n\t\treturn details;\n\n\t}","commit_id":"7e78cecd7f4c859b16b2cd2ba05b876420ae1aa1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private GridServiceAgent waitForGsa(final String machineIp, final long end)\n\t\t\tthrows InterruptedException, TimeoutException {\n\n\t\twhile (Utils.millisUntil(end) > 0) {\n\t\t\tGridServiceAgent gsa = getGSAByIpOrHost(machineIp);\n\t\t\tif (gsa != null) {\n\t\t\t\treturn gsa;\n\t\t\t}\n\n\t\t\tThread.sleep(MILLISECONDS_IN_SECOND);\n\n\t\t}\n\t\treturn null;\n\n\t}","id":76921,"modified_method":"private GridServiceAgent waitForGsa(final String machineIp, final long end)\n\t\t\tthrows InterruptedException, TimeoutException {\n\n\t\twhile (Utils.millisUntil(end) > 0) {\n\t\t\tfinal GridServiceAgent gsa = getGSAByIpOrHost(machineIp);\n\t\t\tif (gsa != null) {\n\t\t\t\treturn gsa;\n\t\t\t}\n\n\t\t\tThread.sleep(MILLISECONDS_IN_SECOND);\n\n\t\t}\n\t\treturn null;\n\n\t}","commit_id":"7e78cecd7f4c859b16b2cd2ba05b876420ae1aa1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic GridServiceAgent startMachine(final long duration, final TimeUnit unit)\n\t\t\tthrows ElasticMachineProvisioningException, InterruptedException, TimeoutException {\n\n\t\tlogger.info(\"Cloudify Adapter is starting a new machine\");\n\t\t// calculate timeout\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(duration);\n\n\t\t// provision the machine\n\t\tlogger.info(\"Calling provisioning implementation for new machine\");\n\t\tMachineDetails machineDetails = null;\n\t\ttry {\n\t\t\tmachineDetails = provisionMachine(duration, unit);\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(Level.SEVERE, \"Failed to provisiong machine: \" + e.getMessage(), e);\n\t\t\tthrow new ElasticMachineProvisioningException(\"Failed to provisiong machine: \" + e.getMessage(), e);\n\t\t}\n\n\t\tlogger.info(\"Machine was provisioned by implementation. Machine is: \" + machineDetails);\n\n\t\ttry {\n\t\t\t// check for timeout\n\t\t\tcheckForProvisioningTimeout(end, machineDetails);\n\n\t\t\t// TODO - finish this section - support picking up existing\n\t\t\t// installations and agent. - i.e. machineDetails.cloudifyInstalled == true\n\n\t\t\t// install gigaspaces and start agent\n\t\t\tlogger.info(\"Cloudify Adapter is installing Cloudify on new machine\");\n\t\t\tinstallAndStartAgent(machineDetails, end);\n\n\t\t\t// check for timeout again - the installation step can also take a\n\t\t\t// while to complete.\n\t\t\tcheckForProvisioningTimeout(end, machineDetails);\n\n\t\t\t// which IP should be used in the cluster\n\t\t\tString machineIp = null;\n\t\t\tif (machineDetails.isUsePrivateAddress()) {\n\t\t\t\tmachineIp = machineDetails.getPrivateAddress();\n\t\t\t} else {\n\t\t\t\tmachineIp = machineDetails.getPublicAddress();\n\t\t\t}\n\n\t\t\tif (machineIp == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"The IP of the new machine is null! Machine Details are: \"\n\t\t\t\t\t\t+ machineDetails + \" .\");\n\t\t\t}\n\t\t\t// wait for GSA to become available\n\t\t\tlogger.info(\"Cloudify adapter is waiting for GSA to become available\");\n\t\t\tfinal GridServiceAgent gsa = waitForGsa(machineIp, end);\n\t\t\tif (gsa == null) {\n\t\t\t\t// GSA did not start correctly or on time - shutdown the machine\n\t\t\t\t// handleGSANotFound(machineIp);\n\t\t\t\tthrow new TimeoutException(\"New machine was provisioned and Cloudify was installed, \"\n\t\t\t\t\t\t+ \"but a GSA was not discovered on the new machine: \" + machineDetails);\n\t\t\t}\n\t\t\treturn gsa;\n\t\t} catch (final ElasticMachineProvisioningException e) {\n\t\t\tlogger.info(\"ElasticMachineProvisioningException occurred, \" + e.getMessage());\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\thandleExceptionAfterMachineCreated(machineDetails, end);\n\t\t\tthrow e;\n\t\t} catch (final TimeoutException e) {\n\t\t\tlogger.info(\"TimeoutException occurred, \" + e.getMessage());\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\thandleExceptionAfterMachineCreated(machineDetails, end);\n\t\t\tthrow e;\n\t\t} catch (final InterruptedException e) {\n\t\t\tlogger.info(\"InterruptedException occurred, \" + e.getMessage());\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\thandleExceptionAfterMachineCreated(machineDetails, end);\n\t\t\tthrow e;\n\t\t}\n\n\t}","id":76922,"modified_method":"@Override\n\tpublic GridServiceAgent startMachine(final long duration, final TimeUnit unit)\n\t\t\tthrows ElasticMachineProvisioningException, InterruptedException, TimeoutException {\n\n\t\tlogger.info(\"Cloudify Adapter is starting a new machine\");\n\t\t// calculate timeout\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(duration);\n\n\t\t// provision the machine\n\t\tlogger.info(\"Calling provisioning implementation for new machine\");\n\t\tMachineDetails machineDetails = null;\n\t\ttry {\n\t\t\tmachineDetails = provisionMachine(duration, unit);\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(Level.SEVERE, \"Failed to provisiong machine: \" + e.getMessage(), e);\n\t\t\tthrow new ElasticMachineProvisioningException(\"Failed to provisiong machine: \" + e.getMessage(), e);\n\t\t}\n\n\t\tlogger.info(\"Machine was provisioned by implementation. Machine is: \" + machineDetails);\n\n\t\ttry {\n\t\t\t// check for timeout\n\t\t\tcheckForProvisioningTimeout(end, machineDetails);\n\n\t\t\tif (machineDetails.isAgentRunning()) {\n\t\t\t\tlogger.info(\"Machine provisioning provided a machine and indicated that an agent is already running\");\n\t\t\t} else {\n\t\t\t\t// install gigaspaces and start agent\n\t\t\t\tlogger.info(\"Cloudify Adapter is installing Cloudify on new machine\");\n\t\t\t\tinstallAndStartAgent(machineDetails, end);\n\t\t\t\t// check for timeout again - the installation step can also take a\n\t\t\t\t// while to complete.\n\t\t\t\tcheckForProvisioningTimeout(end, machineDetails);\n\n\t\t\t}\n\n\t\t\t// There is another case here, that we do not handle - where the started image\n\t\t\t// has the cloudify distro, but the agent is not running. This means we should\n\t\t\t// run a modified remote execution script. Not sure if we really need this, though,\n\t\t\t// as this scenario really does not offer a better experience. If required, handling will\n\t\t\t// be added here.\n\n\t\t\t// which IP should be used in the cluster\n\t\t\tString machineIp = null;\n\t\t\tif (machineDetails.isUsePrivateAddress()) {\n\t\t\t\tmachineIp = machineDetails.getPrivateAddress();\n\t\t\t} else {\n\t\t\t\tmachineIp = machineDetails.getPublicAddress();\n\t\t\t}\n\n\t\t\tif (machineIp == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"The IP of the new machine is null! Machine Details are: \"\n\t\t\t\t\t\t+ machineDetails + \" .\");\n\t\t\t}\n\t\t\t// wait for GSA to become available\n\t\t\tlogger.info(\"Cloudify adapter is waiting for GSA to become available\");\n\t\t\tfinal GridServiceAgent gsa = waitForGsa(machineIp, end);\n\t\t\tif (gsa == null) {\n\t\t\t\t// GSA did not start correctly or on time - shutdown the machine\n\t\t\t\t// handleGSANotFound(machineIp);\n\t\t\t\tthrow new TimeoutException(\"New machine was provisioned and Cloudify was installed, \"\n\t\t\t\t\t\t+ \"but a GSA was not discovered on the new machine: \" + machineDetails);\n\t\t\t}\n\t\t\treturn gsa;\n\t\t} catch (final ElasticMachineProvisioningException e) {\n\t\t\tlogger.info(\"ElasticMachineProvisioningException occurred, \" + e.getMessage());\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\thandleExceptionAfterMachineCreated(machineDetails, end);\n\t\t\tthrow e;\n\t\t} catch (final TimeoutException e) {\n\t\t\tlogger.info(\"TimeoutException occurred, \" + e.getMessage());\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\thandleExceptionAfterMachineCreated(machineDetails, end);\n\t\t\tthrow e;\n\t\t} catch (final InterruptedException e) {\n\t\t\tlogger.info(\"InterruptedException occurred, \" + e.getMessage());\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\thandleExceptionAfterMachineCreated(machineDetails, end);\n\t\t\tthrow e;\n\t\t}\n\n\t}","commit_id":"7e78cecd7f4c859b16b2cd2ba05b876420ae1aa1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void afterPropertiesSet()\n\t\t\tthrows Exception {\n\t\t\n\t\t logger = java.util.logging.Logger\n\t\t\t\t\t.getLogger(ElasticMachineProvisioningCloudifyAdapter.class.getName());\n\t\t\n\t\tfinal String cloudContents = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_CONFIGURATION);\n\t\tif (cloudContents == null) {\n\t\t\tthrow new IllegalArgumentException(\"Cloud configuration was not set!\");\n\t\t}\n\n\t\ttry {\n\t\t\tthis.cloud = ServiceReader.readCloud(cloudContents);\n\t\t\tthis.cloudTemplate = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_TEMPLATE_NAME);\n\n\t\t\tif (this.cloudTemplate == null) {\n\t\t\t\tthrow new BeanConfigurationException(\"Cloud template was not set!\");\n\t\t\t}\n\n\t\t\t// This code runs on the ESM in the remote machine,\n\t\t\t// so set the local directory to the value of the remote directory\n\t\t\t// TODO - change the condition to ServiceUtils.isWindows\n\t\t\tlogger.info(\"Remote Directory is: \" + cloud.getProvider().getRemoteDirectory());\n\t\t\tif (System.getProperty(\"os.name\").toLowerCase().indexOf(\"win\") >= 0) {\n\t\t\t\tlogger.info(\"Windows machine - modifying local directory location\");\n\t\t\t\tString localDirectoryName = cloud.getProvider().getRemoteDirectory();\n\t\t\t\tlocalDirectoryName = localDirectoryName.replace(\"$\", \"\");\n\t\t\t\tif (localDirectoryName.startsWith(\"/\")) {\n\t\t\t\t\tlocalDirectoryName = localDirectoryName.substring(1);\n\t\t\t\t}\n\t\t\t\tif (localDirectoryName.charAt(1) == '/') {\n\t\t\t\t\tlocalDirectoryName = localDirectoryName.substring(0, 1) + \":\" + localDirectoryName.substring(1);\n\t\t\t\t}\n\t\t\t\tlogger.info(\"Modified local dir name is: \" + localDirectoryName);\n\n\t\t\t\tcloud.getProvider().setLocalDirectory(localDirectoryName);\n\t\t\t} else {\n\t\t\t\tcloud.getProvider().setLocalDirectory(cloud.getProvider().getRemoteDirectory());\n\t\t\t}\n\n\t\t\t// load the provisioning class and set it up\n\t\t\ttry {\n\t\t\t\tthis.cloudifyProvisioning =\n\t\t\t\t\t\t(ProvisioningDriver) Class.forName(this.cloud.getConfiguration().getClassName()).newInstance();\n\n\t\t\t\tif (cloudifyProvisioning instanceof ProvisioningDriverClassContextAware) {\n\t\t\t\t\tfinal ProvisioningDriverClassContext provisioningDriverContext =\n\t\t\t\t\t\t\tlazyCreateProvisioningDriverClassContext(cloudifyProvisioning);\n\t\t\t\t\tfinal ProvisioningDriverClassContextAware contextAware =\n\t\t\t\t\t\t\t(ProvisioningDriverClassContextAware) cloudifyProvisioning;\n\t\t\t\t\tcontextAware.setProvisioningDriverClassContext(provisioningDriverContext);\n\t\t\t\t}\n\n\t\t\t\tthis.cloudifyProvisioning.setConfig(cloud, cloudTemplate, false);\n\n\t\t\t} catch (final ClassNotFoundException e) {\n\t\t\t\tthrow new BeanConfigurationException(\"Failed to load provisioning class for cloud: \"\n\t\t\t\t\t\t+ this.cloud.getName() + \". Class not found: \" + this.cloud.getConfiguration().getClassName(),\n\t\t\t\t\t\te);\n\t\t\t} catch (final Exception e) {\n\t\t\t\tthrow new BeanConfigurationException(\"Failed to load provisioning class for cloud: \"\n\t\t\t\t\t\t+ this.cloud.getName(), e);\n\t\t\t}\n\n\t\t\tthis.lookupLocatorsString = createLocatorsString();\n\n\t\t\tlogger.info(\"Locators string used for new instances will be: \" + this.lookupLocatorsString);\n\n\t\t} catch (final DSLException e) {\n\t\t\tlogger.severe(\"Could not parse the provided cloud configuration: \" + cloudContents + \": \" + e.getMessage());\n\t\t\tthrow new BeanConfigurationException(\"Could not parse the prvided cloud configuration: \" + cloudContents\n\t\t\t\t\t+ \": \" + e.getMessage());\n\t\t}\n\n\t}","id":76923,"modified_method":"@Override\n\tpublic void afterPropertiesSet()\n\t\t\tthrows Exception {\n\t\t\n\t\t logger = java.util.logging.Logger\n\t\t\t\t\t.getLogger(ElasticMachineProvisioningCloudifyAdapter.class.getName());\n\t\t\n\t\tfinal String cloudContents = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_CONFIGURATION);\n\t\tif (cloudContents == null) {\n\t\t\tthrow new IllegalArgumentException(\"Cloud configuration was not set!\");\n\t\t}\n\n\t\ttry {\n\t\t\tthis.cloud = ServiceReader.readCloud(cloudContents);\n\t\t\tthis.cloudTemplateName = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_TEMPLATE_NAME);\n\n\t\t\tif (this.cloudTemplateName == null) {\n\t\t\t\tthrow new BeanConfigurationException(\"Cloud template was not set!\");\n\t\t\t}\n\n\t\t\tfinal CloudTemplate cloudTemplate = this.cloud.getTemplates().get(this.cloudTemplateName);\n\t\t\tif (cloudTemplate == null) {\n\t\t\t\tthrow new BeanConfigurationException(\"The provided cloud template name: \" + this.cloudTemplateName\n\t\t\t\t\t\t+ \" was not found in the cloud configuration\");\n\t\t\t}\n\n\t\t\t// This code runs on the ESM in the remote machine,\n\t\t\t// so set the local directory to the value of the remote directory\n\t\t\tlogger.info(\"Remote Directory is: \" + cloudTemplate.getRemoteDirectory());\n\t\t\tif (ServiceUtils.isWindows()) {\n\t\t\t\tlogger.info(\"Windows machine - modifying local directory location\");\n\t\t\t\tString localDirectoryName = cloudTemplate.getRemoteDirectory();\n\t\t\t\tlocalDirectoryName = localDirectoryName.replace(\"$\", \"\");\n\t\t\t\tif (localDirectoryName.startsWith(\"/\")) {\n\t\t\t\t\tlocalDirectoryName = localDirectoryName.substring(1);\n\t\t\t\t}\n\t\t\t\tif (localDirectoryName.charAt(1) == '/') {\n\t\t\t\t\tlocalDirectoryName = localDirectoryName.substring(0, 1) + \":\" + localDirectoryName.substring(1);\n\t\t\t\t}\n\t\t\t\tlogger.info(\"Modified local dir name is: \" + localDirectoryName);\n\n\t\t\t\tcloud.getProvider().setLocalDirectory(localDirectoryName);\n\t\t\t} else {\n\t\t\t\tcloud.getProvider().setLocalDirectory(cloudTemplate.getRemoteDirectory());\n\t\t\t}\n\n\t\t\t// load the provisioning class and set it up\n\t\t\ttry {\n\t\t\t\tthis.cloudifyProvisioning =\n\t\t\t\t\t\t(ProvisioningDriver) Class.forName(this.cloud.getConfiguration().getClassName()).newInstance();\n\n\t\t\t\tif (cloudifyProvisioning instanceof ProvisioningDriverClassContextAware) {\n\t\t\t\t\tfinal ProvisioningDriverClassContext provisioningDriverContext =\n\t\t\t\t\t\t\tlazyCreateProvisioningDriverClassContext(cloudifyProvisioning);\n\t\t\t\t\tfinal ProvisioningDriverClassContextAware contextAware =\n\t\t\t\t\t\t\t(ProvisioningDriverClassContextAware) cloudifyProvisioning;\n\t\t\t\t\tcontextAware.setProvisioningDriverClassContext(provisioningDriverContext);\n\t\t\t\t}\n\n\t\t\t\tthis.cloudifyProvisioning.setConfig(cloud, cloudTemplateName, false);\n\n\t\t\t} catch (final ClassNotFoundException e) {\n\t\t\t\tthrow new BeanConfigurationException(\"Failed to load provisioning class for cloud: \"\n\t\t\t\t\t\t+ this.cloud.getName() + \". Class not found: \" + this.cloud.getConfiguration().getClassName(),\n\t\t\t\t\t\te);\n\t\t\t} catch (final Exception e) {\n\t\t\t\tthrow new BeanConfigurationException(\"Failed to load provisioning class for cloud: \"\n\t\t\t\t\t\t+ this.cloud.getName(), e);\n\t\t\t}\n\n\t\t\tthis.lookupLocatorsString = createLocatorsString();\n\n\t\t\tlogger.info(\"Locators string used for new instances will be: \" + this.lookupLocatorsString);\n\n\t\t} catch (final DSLException e) {\n\t\t\tlogger.severe(\"Could not parse the provided cloud configuration: \" + cloudContents + \": \" + e.getMessage());\n\t\t\tthrow new BeanConfigurationException(\"Could not parse the prvided cloud configuration: \" + cloudContents\n\t\t\t\t\t+ \": \" + e.getMessage());\n\t\t}\n\n\t}","commit_id":"7e78cecd7f4c859b16b2cd2ba05b876420ae1aa1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic boolean stopMachine(final GridServiceAgent agent, final long duration, final TimeUnit unit)\n\t\t\tthrows ElasticMachineProvisioningException, InterruptedException, TimeoutException {\n\n\t\t// TODO - move INFO printouts to FINE\n\t\tfinal String machineIp = agent.getMachine().getHostAddress();\n\t\tlogger.fine(\"Shutting down agent: \" + agent + \" on host: \" + machineIp);\n\t\ttry {\n\t\t\tagent.shutdown();\n\t\t\tlogger.fine(\"Agent on host: \" + machineIp + \" successfully shut down\");\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(Level.WARNING, \"Failed to shutdown agent on host: \" + machineIp\n\t\t\t\t\t+ \". Continuing with shutdown of machine.\", e);\n\t\t}\n\n\t\ttry {\n\t\t\tlogger.fine(\"Cloudify Adapter is shutting down machine with ip: \" + machineIp);\n\n\t\t\tfinal boolean shutdownResult = this.cloudifyProvisioning.stopMachine(machineIp, duration, unit);\n\t\t\tlogger.info(\"Shutdown result of machine: \" + machineIp + \" was: \" + shutdownResult);\n\n\t\t\treturn shutdownResult;\n\n\t\t} catch (final CloudProvisioningException e) {\n\t\t\tthrow new ElasticMachineProvisioningException(\"Attempt to shutdown machine with IP: \" + machineIp\n\t\t\t\t\t+ \" for agent with UID: \" + agent.getUid() + \" has failed with error: \" + e.getMessage(), e);\n\t\t} catch (final AdminException e) {\n\t\t\tthrow new ElasticMachineProvisioningException(\"Failed to shutdown agent \"\n\t\t\t\t\t+ agent.getMachine().getHostAddress(), e);\n\t\t}\n\t}","id":76924,"modified_method":"@Override\n\tpublic boolean stopMachine(final GridServiceAgent agent, final long duration, final TimeUnit unit)\n\t\t\tthrows ElasticMachineProvisioningException, InterruptedException, TimeoutException {\n\n\t\tfinal String machineIp = agent.getMachine().getHostAddress();\n\t\tlogger.fine(\"Shutting down agent: \" + agent + \" on host: \" + machineIp);\n\t\ttry {\n\t\t\tagent.shutdown();\n\t\t\tlogger.fine(\"Agent on host: \" + machineIp + \" successfully shut down\");\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(Level.WARNING, \"Failed to shutdown agent on host: \" + machineIp\n\t\t\t\t\t+ \". Continuing with shutdown of machine.\", e);\n\t\t}\n\n\t\ttry {\n\t\t\tlogger.fine(\"Cloudify Adapter is shutting down machine with ip: \" + machineIp);\n\n\t\t\tfinal boolean shutdownResult = this.cloudifyProvisioning.stopMachine(machineIp, duration, unit);\n\t\t\tlogger.fine(\"Shutdown result of machine: \" + machineIp + \" was: \" + shutdownResult);\n\n\t\t\treturn shutdownResult;\n\n\t\t} catch (final CloudProvisioningException e) {\n\t\t\tthrow new ElasticMachineProvisioningException(\"Attempt to shutdown machine with IP: \" + machineIp\n\t\t\t\t\t+ \" for agent with UID: \" + agent.getUid() + \" has failed with error: \" + e.getMessage(), e);\n\t\t} catch (final AdminException e) {\n\t\t\tthrow new ElasticMachineProvisioningException(\"Failed to shutdown agent \"\n\t\t\t\t\t+ agent.getMachine().getHostAddress(), e);\n\t\t}\n\t}","commit_id":"7e78cecd7f4c859b16b2cd2ba05b876420ae1aa1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic CapacityRequirements getCapacityOfSingleMachine() {\n\t\tfinal CloudTemplate template = cloud.getTemplates().get(this.cloudTemplate);\n\t\tfinal CapacityRequirements capacityRequirements =\n\t\t\t\tnew CapacityRequirements(new MemoryCapacityRequirement((long) template.getMachineMemoryMB()),\n\t\t\t\t\t\tnew CpuCapacityRequirement(template.getNumberOfCores()));\n\t\tlogger.info(\"Capacity requirements for a single machine are: \" + capacityRequirements);\n\t\treturn capacityRequirements;\n\n\t}","id":76925,"modified_method":"@Override\n\tpublic CapacityRequirements getCapacityOfSingleMachine() {\n\t\tfinal CloudTemplate template = cloud.getTemplates().get(this.cloudTemplateName);\n\t\tfinal CapacityRequirements capacityRequirements =\n\t\t\t\tnew CapacityRequirements(new MemoryCapacityRequirement((long) template.getMachineMemoryMB()),\n\t\t\t\t\t\tnew CpuCapacityRequirement(template.getNumberOfCores()));\n\t\tlogger.info(\"Capacity requirements for a single machine are: \" + capacityRequirements);\n\t\treturn capacityRequirements;\n\n\t}","commit_id":"7e78cecd7f4c859b16b2cd2ba05b876420ae1aa1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private synchronized void buildToolWindows(String pattern) {\n      final List<ActivateToolWindowAction> actions = new ArrayList<ActivateToolWindowAction>();\n      for (ActivateToolWindowAction action : ToolWindowsGroup.getToolWindowActions(project)) {\n        String text = action.getTemplatePresentation().getText();\n        if (text != null && StringUtil.startsWithIgnoreCase(text, pattern)) {\n          actions.add(action);\n\n          if (actions.size() == MAX_TOOL_WINDOWS) {\n            break;\n          }\n        }\n      }\n\n      check();\n\n      if (actions.isEmpty()) {\n        return;\n      }\n\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          myListModel.titleIndex.toolWindows = myListModel.size();\n          for (Object toolWindow : actions) {\n            myListModel.addElement(toolWindow);\n          }\n        }\n      });\n    }","id":76926,"modified_method":"private synchronized void buildToolWindows(String pattern) {\n      if (!Registry.is(\"search.everywhere.toolwindows\")) {\n        return;\n      }\n      final List<ActivateToolWindowAction> actions = new ArrayList<ActivateToolWindowAction>();\n      for (ActivateToolWindowAction action : ToolWindowsGroup.getToolWindowActions(project)) {\n        String text = action.getTemplatePresentation().getText();\n        if (text != null && StringUtil.startsWithIgnoreCase(text, pattern)) {\n          actions.add(action);\n\n          if (actions.size() == MAX_TOOL_WINDOWS) {\n            break;\n          }\n        }\n      }\n\n      check();\n\n      if (actions.isEmpty()) {\n        return;\n      }\n\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          myListModel.titleIndex.toolWindows = myListModel.size();\n          for (Object toolWindow : actions) {\n            myListModel.addElement(toolWindow);\n          }\n        }\n      });\n    }","commit_id":"4dd245ddc96be2847244a34ebf070043efc34053","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private SearchResult getFiles(final String pattern, final int max, ChooseByNamePopup chooseByNamePopup) {\n      final SearchResult files = new SearchResult();\n      if (chooseByNamePopup == null) {\n        return files;\n      }\n      final GlobalSearchScope scope = GlobalSearchScope.projectScope(project);\n      chooseByNamePopup.getProvider().filterElements(chooseByNamePopup, pattern, true,\n                                                      myProgressIndicator, new Processor<Object>() {\n          @Override\n          public boolean process(Object o) {\n            VirtualFile file = null;\n            if (o instanceof VirtualFile) {\n              file = (VirtualFile)o;\n            } else if (o instanceof PsiFile) {\n              file = ((PsiFile)o).getVirtualFile();\n            } else if (o instanceof PsiDirectory) {\n              file = ((PsiDirectory)o).getVirtualFile();\n            }\n            if (file != null\n                && !(pattern.indexOf(' ') != -1 && file.getName().indexOf(' ') == -1)\n                && (showAll.get() || scope.accept(file)\n                && !myListModel.contains(file)\n                && !myAlreadyAddedFiles.contains(file))\n                && !files.contains(file)) {\n              if (files.size() == max) {\n                files.needMore = true;\n                return false;\n              }\n              files.add(file);\n            }\n            return true;\n          }\n        });\n      return files;\n    }","id":76927,"modified_method":"private SearchResult getFiles(final String pattern, final int max, ChooseByNamePopup chooseByNamePopup) {\n      final SearchResult files = new SearchResult();\n      if (chooseByNamePopup == null || !Registry.is(\"search.everywhere.files\")) {\n        return files;\n      }\n      final GlobalSearchScope scope = GlobalSearchScope.projectScope(project);\n      chooseByNamePopup.getProvider().filterElements(chooseByNamePopup, pattern, true,\n                                                      myProgressIndicator, new Processor<Object>() {\n          @Override\n          public boolean process(Object o) {\n            VirtualFile file = null;\n            if (o instanceof VirtualFile) {\n              file = (VirtualFile)o;\n            } else if (o instanceof PsiFile) {\n              file = ((PsiFile)o).getVirtualFile();\n            } else if (o instanceof PsiDirectory) {\n              file = ((PsiDirectory)o).getVirtualFile();\n            }\n            if (file != null\n                && !(pattern.indexOf(' ') != -1 && file.getName().indexOf(' ') == -1)\n                && (showAll.get() || scope.accept(file)\n                && !myListModel.contains(file)\n                && !myAlreadyAddedFiles.contains(file))\n                && !files.contains(file)) {\n              if (files.size() == max) {\n                files.needMore = true;\n                return false;\n              }\n              files.add(file);\n            }\n            return true;\n          }\n        });\n      return files;\n    }","commit_id":"4dd245ddc96be2847244a34ebf070043efc34053","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private SearchResult getSymbols(String pattern, final int max, ChooseByNamePopup chooseByNamePopup) {\n      final SearchResult symbols = new SearchResult();\n      final GlobalSearchScope scope = GlobalSearchScope.projectScope(project);\n      chooseByNamePopup.getProvider().filterElements(chooseByNamePopup, pattern, false,\n                                                         myProgressIndicator, new Processor<Object>() {\n          @Override\n          public boolean process(Object o) {\n            if (o instanceof PsiElement) {\n              final PsiElement element = (PsiElement)o;\n              final PsiFile file = element.getContainingFile();\n              if (!myListModel.contains(o) &&\n                  //some elements are non-physical like DB columns\n                  (file == null || (file.getVirtualFile() != null && scope.accept(file.getVirtualFile())))) {\n                symbols.add(o);\n              }\n            }\n            symbols.needMore = symbols.size() == max;\n            return !symbols.needMore;\n          }\n        });\n      return symbols;\n    }","id":76928,"modified_method":"private SearchResult getSymbols(String pattern, final int max, ChooseByNamePopup chooseByNamePopup) {\n      final SearchResult symbols = new SearchResult();\n      if (!Registry.is(\"search.everywhere.symbols\")) {\n        return symbols;\n      }\n      final GlobalSearchScope scope = GlobalSearchScope.projectScope(project);\n      if (chooseByNamePopup == null) return symbols;\n      final ChooseByNameItemProvider provider = chooseByNamePopup.getProvider();\n      provider.filterElements(chooseByNamePopup, pattern, false,\n                              myProgressIndicator, new Processor<Object>() {\n          @Override\n          public boolean process(Object o) {\n            if (o instanceof PsiElement) {\n              final PsiElement element = (PsiElement)o;\n              final PsiFile file = element.getContainingFile();\n              if (!myListModel.contains(o) &&\n                  //some elements are non-physical like DB columns\n                  (file == null || (file.getVirtualFile() != null && scope.accept(file.getVirtualFile())))) {\n                symbols.add(o);\n              }\n            }\n            symbols.needMore = symbols.size() == max;\n            return !symbols.needMore;\n          }\n        });\n      return symbols;\n    }","commit_id":"4dd245ddc96be2847244a34ebf070043efc34053","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private SearchResult getActionsOrSettings(final String pattern, final int max, final boolean actions) {\n      final SearchResult result = new SearchResult();\n      final MinusculeMatcher matcher = new MinusculeMatcher(\"*\" +pattern, NameUtil.MatchingCaseSensitivity.NONE);\n      if (myActionProvider == null) {\n        myActionProvider = createActionProvider();\n      }\n\n      myActionProvider.filterElements(pattern, true, new Processor<GotoActionModel.MatchedValue>() {\n        @Override\n        public boolean process(GotoActionModel.MatchedValue matched) {\n          check();\n          Object object = matched.value;\n          if (myListModel.contains(object)) return true;\n\n          if (!actions && isSetting(object)) {\n            if (matcher.matches(getSettingText((OptionDescription)object))) {\n              result.add(object);\n            }\n          } else if (actions && !isToolWindowAction(object) && isActionValue(object)) {\n            result.add(object);\n          }\n          return result.size() <= max;\n        }\n      });\n\n      return result;\n    }","id":76929,"modified_method":"private SearchResult getActionsOrSettings(final String pattern, final int max, final boolean actions) {\n      final SearchResult result = new SearchResult();\n      if ((actions && !Registry.is(\"search.everywhere.actions\")) || (!actions && !Registry.is(\"search.everywhere.settings\"))) {\n        return result;\n      }\n      final MinusculeMatcher matcher = new MinusculeMatcher(\"*\" +pattern, NameUtil.MatchingCaseSensitivity.NONE);\n      if (myActionProvider == null) {\n        myActionProvider = createActionProvider();\n      }\n\n      myActionProvider.filterElements(pattern, true, new Processor<GotoActionModel.MatchedValue>() {\n        @Override\n        public boolean process(GotoActionModel.MatchedValue matched) {\n          check();\n          Object object = matched.value;\n          if (myListModel.contains(object)) return true;\n\n          if (!actions && isSetting(object)) {\n            if (matcher.matches(getSettingText((OptionDescription)object))) {\n              result.add(object);\n            }\n          } else if (actions && !isToolWindowAction(object) && isActionValue(object)) {\n            result.add(object);\n          }\n          return result.size() <= max;\n        }\n      });\n\n      return result;\n    }","commit_id":"4dd245ddc96be2847244a34ebf070043efc34053","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e, MouseEvent me) {\n    if (myBalloon != null && myBalloon.isVisible()) {\n      showAll.set(!showAll.get());\n      myNonProjectCheckBox.setSelected(showAll.get());\n//      myPopupField.getTextEditor().setBackground(showAll.get() ? new JBColor(new Color(0xffffe4), new Color(0x494539)) : UIUtil.getTextFieldBackground());\n      rebuildList(myPopupField.getText());\n      return;\n    }\n    myCurrentWorker = ActionCallback.DONE;\n    if (e != null) {\n      myEditor = e.getData(CommonDataKeys.EDITOR);\n      myFile = e.getData(CommonDataKeys.PSI_FILE);\n    }\n    if (e == null && myFocusOwner != null) {\n      e = new AnActionEvent(me, DataManager.getInstance().getDataContext(myFocusOwner), ActionPlaces.UNKNOWN, getTemplatePresentation(), ActionManager.getInstance(), 0);\n    }\n    if (e == null) return;\n\n    updateComponents();\n    myContextComponent = PlatformDataKeys.CONTEXT_COMPONENT.getData(e.getDataContext());\n    Window wnd = myContextComponent != null ? SwingUtilities.windowForComponent(myContextComponent)\n      : KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow();\n    if (wnd == null && myContextComponent instanceof Window) {\n      wnd = (Window)myContextComponent;\n    }\n    if (wnd == null || wnd.getParent() != null) return;\n    myActionEvent = e;\n    if (myPopupField != null) {\n      Disposer.dispose(myPopupField);\n    }\n    myPopupField = new MySearchTextField();\n    myPopupField.getTextEditor().addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyTyped(KeyEvent e) {\n        myHistoryIndex = 0;\n        myHistoryItem = null;\n      }\n\n      @Override\n      public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_SHIFT) {\n          myList.repaint();\n        }\n      }\n\n      @Override\n      public void keyReleased(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_SHIFT) {\n          myList.repaint();\n        }\n      }\n    });\n    initSearchField(myPopupField);\n    myPopupField.setOpaque(false);\n    final JTextField editor = myPopupField.getTextEditor();\n    editor.setColumns(SEARCH_FIELD_COLUMNS);\n    final JPanel panel = new JPanel(new BorderLayout()) {\n      @Override\n      protected void paintComponent(Graphics g) {\n        final Gradient gradient = getGradientColors();\n        ((Graphics2D)g).setPaint(new GradientPaint(0, 0, gradient.getStartColor(), 0, getHeight(), gradient.getEndColor()));\n        g.fillRect(0, 0, getWidth(), getHeight());\n      }\n\n      @Override\n      public Dimension getPreferredSize() {\n        return new Dimension(410, super.getPreferredSize().height);\n      }\n    };\n    final JLabel title = new JLabel(\" Search Everywhere:       \");\n    final JPanel topPanel = new NonOpaquePanel(new BorderLayout());\n    title.setForeground(new JBColor(Gray._240, Gray._200));\n    if (SystemInfo.isMac) {\n      title.setFont(title.getFont().deriveFont(Font.BOLD, title.getFont().getSize() - 1f));\n    } else {\n      title.setFont(title.getFont().deriveFont(Font.BOLD));\n    }\n    topPanel.add(title, BorderLayout.WEST);\n    myNonProjectCheckBox.setForeground(new JBColor(Gray._240, Gray._200));\n    myNonProjectCheckBox.setText(\"Include non-project items (\" + getShortcut() + \")\");\n    if (!NonProjectScopeDisablerEP.isSearchInNonProjectDisabled()) {\n      topPanel.add(myNonProjectCheckBox, BorderLayout.EAST);\n    }\n    panel.add(myPopupField, BorderLayout.CENTER);\n    panel.add(topPanel, BorderLayout.NORTH);\n    panel.setBorder(IdeBorderFactory.createEmptyBorder(3, 5, 4, 5));\n    DataManager.registerDataProvider(panel, this);\n    final ComponentPopupBuilder builder = JBPopupFactory.getInstance().createComponentPopupBuilder(panel, editor);\n    myBalloon = builder\n      .setCancelOnClickOutside(true)\n      .setModalContext(false)\n      .setRequestFocus(true)\n      .createPopup();\n    myBalloon.getContent().setBorder(new EmptyBorder(0,0,0,0));\n    final Window window = WindowManager.getInstance().suggestParentWindow(e.getProject());\n\n    //noinspection ConstantConditions\n    e.getProject().getMessageBus().connect(myBalloon).subscribe(DumbService.DUMB_MODE, new DumbService.DumbModeListener() {\n      @Override\n      public void enteredDumbMode() {\n      }\n\n      @Override\n      public void exitDumbMode() {\n        rebuildList(myPopupField.getText());\n      }\n    });\n\n    Component parent = UIUtil.findUltimateParent(window);\n    registerDataProvider(panel, e.getProject());\n    final RelativePoint showPoint;\n    if (me != null) {\n      final Component label = me.getComponent();\n      final Component button = label.getParent();\n      assert button != null;\n      showPoint = new RelativePoint(button, new Point(button.getWidth() - panel.getPreferredSize().width, button.getHeight()));\n    } else {\n      if (parent != null) {\n        int height = UISettings.getInstance().SHOW_MAIN_TOOLBAR ? 135 : 115;\n        if (parent instanceof IdeFrameImpl && ((IdeFrameImpl)parent).isInFullScreen()) {\n          height -= 20;\n        }\n        showPoint = new RelativePoint(parent, new Point((parent.getSize().width - panel.getPreferredSize().width)/ 2, height));\n      } else {\n        showPoint = JBPopupFactory.getInstance().guessBestPopupLocation(e.getDataContext());\n      }\n    }\n    myList.setFont(UIUtil.getListFont());\n    myBalloon.show(showPoint);\n    initSearchActions(myBalloon, myPopupField);\n    IdeFocusManager focusManager = IdeFocusManager.getInstance(e.getProject());\n    focusManager.requestFocus(editor, true);\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(IdeActions.ACTION_SEARCH_EVERYWHERE);\n  }","id":76930,"modified_method":"public void actionPerformed(AnActionEvent e, MouseEvent me) {\n    if (myBalloon != null && myBalloon.isVisible()) {\n      showAll.set(!showAll.get());\n      myNonProjectCheckBox.setSelected(showAll.get());\n//      myPopupField.getTextEditor().setBackground(showAll.get() ? new JBColor(new Color(0xffffe4), new Color(0x494539)) : UIUtil.getTextFieldBackground());\n      rebuildList(myPopupField.getText());\n      return;\n    }\n    myCurrentWorker = ActionCallback.DONE;\n    if (e != null) {\n      myEditor = e.getData(CommonDataKeys.EDITOR);\n      myFile = e.getData(CommonDataKeys.PSI_FILE);\n    }\n    if (e == null && myFocusOwner != null) {\n      e = new AnActionEvent(me, DataManager.getInstance().getDataContext(myFocusOwner), ActionPlaces.UNKNOWN, getTemplatePresentation(), ActionManager.getInstance(), 0);\n    }\n    if (e == null) return;\n\n    updateComponents();\n    myContextComponent = PlatformDataKeys.CONTEXT_COMPONENT.getData(e.getDataContext());\n    Window wnd = myContextComponent != null ? SwingUtilities.windowForComponent(myContextComponent)\n      : KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow();\n    if (wnd == null && myContextComponent instanceof Window) {\n      wnd = (Window)myContextComponent;\n    }\n    if (wnd == null || wnd.getParent() != null) return;\n    myActionEvent = e;\n    if (myPopupField != null) {\n      Disposer.dispose(myPopupField);\n    }\n    myPopupField = new MySearchTextField();\n    myPopupField.getTextEditor().addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyTyped(KeyEvent e) {\n        myHistoryIndex = 0;\n        myHistoryItem = null;\n      }\n\n      @Override\n      public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_SHIFT) {\n          myList.repaint();\n        }\n      }\n\n      @Override\n      public void keyReleased(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_SHIFT) {\n          myList.repaint();\n        }\n      }\n    });\n    initSearchField(myPopupField);\n    myPopupField.setOpaque(false);\n    final JTextField editor = myPopupField.getTextEditor();\n    editor.setColumns(SEARCH_FIELD_COLUMNS);\n    final JPanel panel = new JPanel(new BorderLayout()) {\n      @Override\n      protected void paintComponent(Graphics g) {\n        final Gradient gradient = getGradientColors();\n        ((Graphics2D)g).setPaint(new GradientPaint(0, 0, gradient.getStartColor(), 0, getHeight(), gradient.getEndColor()));\n        g.fillRect(0, 0, getWidth(), getHeight());\n      }\n\n      @Override\n      public Dimension getPreferredSize() {\n        return new Dimension(410, super.getPreferredSize().height);\n      }\n    };\n    final JLabel title = new JLabel(\" Search Everywhere:       \");\n    final JPanel topPanel = new NonOpaquePanel(new BorderLayout());\n    title.setForeground(new JBColor(Gray._240, Gray._200));\n    if (SystemInfo.isMac) {\n      title.setFont(title.getFont().deriveFont(Font.BOLD, title.getFont().getSize() - 1f));\n    } else {\n      title.setFont(title.getFont().deriveFont(Font.BOLD));\n    }\n    topPanel.add(title, BorderLayout.WEST);\n    final JPanel controls = new JPanel(new BorderLayout());\n    controls.setOpaque(false);\n    final JLabel settings = new JLabel(AllIcons.General.WebSettings);\n    new ClickListener(){\n      @Override\n      public boolean onClick(@NotNull MouseEvent event, int clickCount) {\n        showSettings();\n        return true;\n      }\n    }.installOn(settings);\n    controls.add(settings, BorderLayout.EAST);\n    myNonProjectCheckBox.setForeground(new JBColor(Gray._240, Gray._200));\n    myNonProjectCheckBox.setText(\"Include non-project items (\" + getShortcut() + \")  \");\n    if (!NonProjectScopeDisablerEP.isSearchInNonProjectDisabled()) {\n      controls.add(myNonProjectCheckBox, BorderLayout.WEST);\n    }\n    topPanel.add(controls, BorderLayout.EAST);\n    panel.add(myPopupField, BorderLayout.CENTER);\n    panel.add(topPanel, BorderLayout.NORTH);\n    panel.setBorder(IdeBorderFactory.createEmptyBorder(3, 5, 4, 5));\n    DataManager.registerDataProvider(panel, this);\n    final ComponentPopupBuilder builder = JBPopupFactory.getInstance().createComponentPopupBuilder(panel, editor);\n    myBalloon = builder\n      .setCancelOnClickOutside(true)\n      .setModalContext(false)\n      .setRequestFocus(true)\n      .createPopup();\n    myBalloon.getContent().setBorder(new EmptyBorder(0,0,0,0));\n    final Window window = WindowManager.getInstance().suggestParentWindow(e.getProject());\n\n    //noinspection ConstantConditions\n    e.getProject().getMessageBus().connect(myBalloon).subscribe(DumbService.DUMB_MODE, new DumbService.DumbModeListener() {\n      @Override\n      public void enteredDumbMode() {\n      }\n\n      @Override\n      public void exitDumbMode() {\n        rebuildList(myPopupField.getText());\n      }\n    });\n\n    Component parent = UIUtil.findUltimateParent(window);\n    registerDataProvider(panel, e.getProject());\n    final RelativePoint showPoint;\n    if (me != null) {\n      final Component label = me.getComponent();\n      final Component button = label.getParent();\n      assert button != null;\n      showPoint = new RelativePoint(button, new Point(button.getWidth() - panel.getPreferredSize().width, button.getHeight()));\n    } else {\n      if (parent != null) {\n        int height = UISettings.getInstance().SHOW_MAIN_TOOLBAR ? 135 : 115;\n        if (parent instanceof IdeFrameImpl && ((IdeFrameImpl)parent).isInFullScreen()) {\n          height -= 20;\n        }\n        showPoint = new RelativePoint(parent, new Point((parent.getSize().width - panel.getPreferredSize().width)/ 2, height));\n      } else {\n        showPoint = JBPopupFactory.getInstance().guessBestPopupLocation(e.getDataContext());\n      }\n    }\n    myList.setFont(UIUtil.getListFont());\n    myBalloon.show(showPoint);\n    initSearchActions(myBalloon, myPopupField);\n    IdeFocusManager focusManager = IdeFocusManager.getInstance(e.getProject());\n    focusManager.requestFocus(editor, true);\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(IdeActions.ACTION_SEARCH_EVERYWHERE);\n  }","commit_id":"4dd245ddc96be2847244a34ebf070043efc34053","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private SearchResult getConfigurations(String pattern, int max) {\n      SearchResult configurations = new SearchResult();\n      MinusculeMatcher matcher = new MinusculeMatcher(pattern, NameUtil.MatchingCaseSensitivity.NONE);\n      final ChooseRunConfigurationPopup.ItemWrapper[] wrappers =\n        ChooseRunConfigurationPopup.createSettingsList(project, new ExecutorProvider() {\n          @Override\n          public Executor getExecutor() {\n            return ExecutorRegistry.getInstance().getExecutorById(ToolWindowId.DEBUG);\n          }\n        }, false);\n      check();\n      for (ChooseRunConfigurationPopup.ItemWrapper wrapper : wrappers) {\n        if (matcher.matches(wrapper.getText()) && !myListModel.contains(wrapper)) {\n          if (configurations.size() == max) {\n            configurations.needMore = true;\n            break;\n          }\n          configurations.add(wrapper);\n        }\n        check();\n      }\n\n      return configurations;\n    }","id":76931,"modified_method":"private SearchResult getConfigurations(String pattern, int max) {\n      SearchResult configurations = new SearchResult();\n      if (!Registry.is(\"search.everywhere.configurations\")) {\n        return configurations;\n      }\n      MinusculeMatcher matcher = new MinusculeMatcher(pattern, NameUtil.MatchingCaseSensitivity.NONE);\n      final ChooseRunConfigurationPopup.ItemWrapper[] wrappers =\n        ChooseRunConfigurationPopup.createSettingsList(project, new ExecutorProvider() {\n          @Override\n          public Executor getExecutor() {\n            return ExecutorRegistry.getInstance().getExecutorById(ToolWindowId.DEBUG);\n          }\n        }, false);\n      check();\n      for (ChooseRunConfigurationPopup.ItemWrapper wrapper : wrappers) {\n        if (matcher.matches(wrapper.getText()) && !myListModel.contains(wrapper)) {\n          if (configurations.size() == max) {\n            configurations.needMore = true;\n            break;\n          }\n          configurations.add(wrapper);\n        }\n        check();\n      }\n\n      return configurations;\n    }","commit_id":"4dd245ddc96be2847244a34ebf070043efc34053","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DeleteDhcpOptionsResponseType deleteDhcpOptions( final DeleteDhcpOptionsType request ) throws EucalyptusCloudException {\n    final DeleteDhcpOptionsResponseType reply = request.getReply( );\n    delete( Identifier.dopt, request.getDhcpOptionsId(), new Function<Pair<AccountFullName,String>,DhcpOptionSet>( ) {\n      @Override\n      public DhcpOptionSet apply( final Pair<AccountFullName, String> accountAndId ) {\n        try {\n          final DhcpOptionSet dhcpOptionSet =\n              dhcpOptionSets.lookupByName( accountAndId.getLeft( ), accountAndId.getRight( ), Functions.<DhcpOptionSet>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( dhcpOptionSet ) ) {\n            dhcpOptionSets.delete( dhcpOptionSet );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete DHCP options\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","id":76932,"modified_method":"public DeleteDhcpOptionsResponseType deleteDhcpOptions( final DeleteDhcpOptionsType request ) throws EucalyptusCloudException {\n    final DeleteDhcpOptionsResponseType reply = request.getReply( );\n    delete( Identifier.dopt, request.getDhcpOptionsId(), new Function<Pair<Optional<AccountFullName>,String>,DhcpOptionSet>( ) {\n      @Override\n      public DhcpOptionSet apply( final Pair<Optional<AccountFullName>,String> accountAndId ) {\n        try {\n          final DhcpOptionSet dhcpOptionSet = dhcpOptionSets.lookupByName(\n              accountAndId.getLeft( ).orNull( ),\n              accountAndId.getRight( ),\n              Functions.<DhcpOptionSet>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( dhcpOptionSet ) ) {\n            dhcpOptionSets.delete( dhcpOptionSet );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete DHCP options\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteSubnetResponseType deleteSubnet( final DeleteSubnetType request ) throws EucalyptusCloudException {\n    final DeleteSubnetResponseType reply = request.getReply( );\n    delete( Identifier.subnet, request.getSubnetId( ), new Function<Pair<AccountFullName,String>,Subnet>( ) {\n      @Override\n      public Subnet apply( final Pair<AccountFullName, String> accountAndId ) {\n        try {\n          final Subnet subnet = subnets.lookupByName( accountAndId.getLeft( ), accountAndId.getRight( ), Functions.<Subnet>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( subnet ) ) {\n            subnets.delete( subnet );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete subnet\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","id":76933,"modified_method":"public DeleteSubnetResponseType deleteSubnet( final DeleteSubnetType request ) throws EucalyptusCloudException {\n    final DeleteSubnetResponseType reply = request.getReply( );\n    delete( Identifier.subnet, request.getSubnetId( ), new Function<Pair<Optional<AccountFullName>,String>,Subnet>( ) {\n      @Override\n      public Subnet apply( final Pair<Optional<AccountFullName>, String> accountAndId ) {\n        try {\n          final Subnet subnet = subnets.lookupByName(\n              accountAndId.getLeft( ).orNull( ),\n              accountAndId.getRight( ),\n              Functions.<Subnet>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( subnet ) ) {\n            subnets.delete( subnet );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete subnet\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteRouteResponseType deleteRoute( final DeleteRouteType request ) throws EucalyptusCloudException {\n    final DeleteRouteResponseType reply = request.getReply( );\n    final Context ctx = Contexts.lookup( );\n    final AccountFullName accountFullName = ctx.getUserFullName( ).asAccountFullName( );\n    final String routeTableId = Identifier.rtb.normalize( request.getRouteTableId( ) );\n    try {\n      routeTables.updateByExample(\n          RouteTable.exampleWithName( accountFullName, routeTableId ),\n          accountFullName,\n          request.getRouteTableId( ),\n          new Callback<RouteTable>() {\n            @Override\n            public void fire( final RouteTable routeTable ) {\n              try {\n                final Optional<Route> route = Iterables.tryFind(\n                    routeTable.getRoutes( ),\n                    CollectionUtils.propertyPredicate(\n                        request.getDestinationCidrBlock( ),\n                        RouteTables.RouteFilterStringFunctions.DESTINATION_CIDR ) );\n                if ( RestrictedTypes.filterPrivileged( ).apply( routeTable ) ) {\n                  if ( route.isPresent( ) ) {\n                    routeTable.getRoutes( ).remove( route.get( ) );\n                    routeTable.updateTimeStamps( ); // ensure version of table increments also\n                  } else {\n                    throw new ClientComputeException(\n                        \"InvalidRoute.NotFound\",\n                        \"Route not found for cidr: \" + request.getDestinationCidrBlock( ) );\n                  }\n                } else {\n                  throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete route\" ) );\n                }\n              } catch ( Exception e ) {\n                throw Exceptions.toUndeclared( e );\n              }\n            }\n          }) ;\n      invalidate( routeTableId );\n    } catch ( Exception e ) {\n      throw handleException( e );\n    }\n    return reply;\n  }","id":76934,"modified_method":"public DeleteRouteResponseType deleteRoute( final DeleteRouteType request ) throws EucalyptusCloudException {\n    final DeleteRouteResponseType reply = request.getReply( );\n    final Context ctx = Contexts.lookup( );\n    final AccountFullName accountFullName = ctx.isAdministrator( ) ? null : ctx.getUserFullName( ).asAccountFullName( );\n    final String routeTableId = Identifier.rtb.normalize( request.getRouteTableId( ) );\n    try {\n      routeTables.updateByExample(\n          RouteTable.exampleWithName( accountFullName, routeTableId ),\n          accountFullName,\n          request.getRouteTableId( ),\n          new Callback<RouteTable>() {\n            @Override\n            public void fire( final RouteTable routeTable ) {\n              try {\n                if ( RestrictedTypes.filterPrivileged( ).apply( routeTable ) ) {\n                  final Optional<Route> route = Iterables.tryFind(\n                      routeTable.getRoutes( ),\n                      CollectionUtils.propertyPredicate(\n                          request.getDestinationCidrBlock( ),\n                          RouteTables.RouteFilterStringFunctions.DESTINATION_CIDR ) );\n                  if ( route.isPresent( ) ) {\n                    routeTable.getRoutes( ).remove( route.get( ) );\n                    routeTable.updateTimeStamps( ); // ensure version of table increments also\n                  } else {\n                    throw new ClientComputeException(\n                        \"InvalidRoute.NotFound\",\n                        \"Route not found for cidr: \" + request.getDestinationCidrBlock( ) );\n                  }\n                } else {\n                  throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete route\" ) );\n                }\n              } catch ( Exception e ) {\n                throw Exceptions.toUndeclared( e );\n              }\n            }\n          }) ;\n      invalidate( routeTableId );\n    } catch ( Exception e ) {\n      throw handleException( e );\n    }\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteVpcResponseType deleteVpc( final DeleteVpcType request ) throws EucalyptusCloudException {\n    final DeleteVpcResponseType reply = request.getReply( );\n    delete( Identifier.vpc, request.getVpcId( ), new Function<Pair<AccountFullName,String>,Vpc>( ) {\n      @Override\n      public Vpc apply( final Pair<AccountFullName, String> accountAndId ) {\n        try {\n          final Vpc vpc = vpcs.lookupByName( accountAndId.getLeft( ), accountAndId.getRight( ), Functions.<Vpc>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( vpc ) ) {\n            if ( Boolean.TRUE.equals( vpc.getDefaultVpc( ) ) &&  Contexts.lookup( ).isAdministrator( ) ) try {\n              final InternetGateway internetGateway =\n                  internetGateways.lookupByVpc( null, vpc.getDisplayName( ), Functions.<InternetGateway>identity( ) );\n              internetGateways.delete( internetGateway );\n            } catch ( VpcMetadataNotFoundException e ) { /* so no need to delete */ }\n            networkAcls.delete( networkAcls.lookupDefault( vpc.getDisplayName(), Functions.<NetworkAcl>identity() ) );\n            routeTables.delete( routeTables.lookupMain( vpc.getDisplayName(), Functions.<RouteTable>identity() ) );\n            try {\n              securityGroups.delete( securityGroups.lookupDefault( vpc.getDisplayName(), Functions.<NetworkGroup>identity() ) );\n            } catch ( VpcMetadataNotFoundException e ) { /* so no need to delete */ }\n            vpcs.delete( vpc );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete vpc\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","id":76935,"modified_method":"public DeleteVpcResponseType deleteVpc( final DeleteVpcType request ) throws EucalyptusCloudException {\n    final DeleteVpcResponseType reply = request.getReply( );\n    delete( Identifier.vpc, request.getVpcId( ), new Function<Pair<Optional<AccountFullName>,String>,Vpc>( ) {\n      @Override\n      public Vpc apply( final Pair<Optional<AccountFullName>, String> accountAndId ) {\n        try {\n          final Vpc vpc = vpcs.lookupByName(\n              accountAndId.getLeft( ).orNull( ),\n              accountAndId.getRight( ),\n              Functions.<Vpc>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( vpc ) ) {\n            if ( Boolean.TRUE.equals( vpc.getDefaultVpc( ) ) &&  Contexts.lookup( ).isAdministrator( ) ) {\n              final List<Subnet> defaultSubnets = subnets.listByExample(\n                  Subnet.exampleDefault( AccountFullName.getInstance( vpc.getOwnerAccountNumber( ) ), null ),\n                  Predicates.alwaysTrue( ),\n                  Functions.<Subnet>identity( ) );\n              for ( final Subnet subnet : defaultSubnets ) {\n                subnets.delete( subnet );\n              }\n              try {\n                final InternetGateway internetGateway =\n                    internetGateways.lookupByVpc( null, vpc.getDisplayName( ), Functions.<InternetGateway>identity( ) );\n                internetGateways.delete( internetGateway );\n              } catch ( VpcMetadataNotFoundException e ) { /* so no need to delete */ }\n            }\n            try {\n              networkAcls.delete( networkAcls.lookupDefault( vpc.getDisplayName(), Functions.<NetworkAcl>identity() ) );\n            } catch ( VpcMetadataNotFoundException e ) { /* so no need to delete */ }\n            try {\n              routeTables.delete( routeTables.lookupMain( vpc.getDisplayName(), Functions.<RouteTable>identity() ) );\n            } catch ( VpcMetadataNotFoundException e ) { /* so no need to delete */ }\n            try {\n              securityGroups.delete( securityGroups.lookupDefault( vpc.getDisplayName(), Functions.<NetworkGroup>identity() ) );\n            } catch ( VpcMetadataNotFoundException e ) { /* so no need to delete */ }\n            vpcs.delete( vpc );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete vpc\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteNetworkAclEntryResponseType deleteNetworkAclEntry(final DeleteNetworkAclEntryType request) throws EucalyptusCloudException {\n    final DeleteNetworkAclEntryResponseType reply = request.getReply( );\n    final Context ctx = Contexts.lookup( );\n    final AccountFullName accountFullName = ctx.getUserFullName( ).asAccountFullName( );\n    final String networkAclId = Identifier.acl.normalize( request.getNetworkAclId() );\n    try {\n      networkAcls.updateByExample(\n          NetworkAcl.exampleWithName( accountFullName, networkAclId ),\n          accountFullName,\n          request.getNetworkAclId(),\n          new Callback<NetworkAcl>() {\n            @Override\n            public void fire( final NetworkAcl networkAcl ) {\n              try {\n                final Optional<NetworkAclEntry> entry = Iterables.tryFind(\n                    networkAcl.getEntries( ),\n                    entryPredicate( request.getEgress( ), request.getRuleNumber( ) ) );\n                if ( RestrictedTypes.filterPrivileged( ).apply( networkAcl ) ) {\n                  if ( entry.isPresent( ) ) {\n                    networkAcl.getEntries( ).remove( entry.get( ) );\n                    networkAcl.updateTimeStamps( ); // ensure version of table increments also\n                  } else {\n                    throw new ClientComputeException(\n                        \"InvalidNetworkAclEntry.NotFound\",\n                        \"Entry not found for number: \" + request.getRuleNumber( ) );\n                  }\n                } else {\n                  throw new ClientUnauthorizedComputeException( \"Not authorized to delete network ACL entry\" );\n                }\n              } catch ( Exception e ) {\n                throw Exceptions.toUndeclared( e );\n              }\n            }\n          }) ;\n      invalidate( networkAclId );\n    } catch ( Exception e ) {\n      throw handleException( e );\n    }\n    return reply;\n  }","id":76936,"modified_method":"public DeleteNetworkAclEntryResponseType deleteNetworkAclEntry(final DeleteNetworkAclEntryType request) throws EucalyptusCloudException {\n    final DeleteNetworkAclEntryResponseType reply = request.getReply( );\n    final Context ctx = Contexts.lookup( );\n    final AccountFullName accountFullName = ctx.isAdministrator( ) ? null : ctx.getUserFullName( ).asAccountFullName( );\n    final String networkAclId = Identifier.acl.normalize( request.getNetworkAclId() );\n    try {\n      networkAcls.updateByExample(\n          NetworkAcl.exampleWithName( accountFullName, networkAclId ),\n          accountFullName,\n          request.getNetworkAclId(),\n          new Callback<NetworkAcl>() {\n            @Override\n            public void fire( final NetworkAcl networkAcl ) {\n              try {\n                if ( RestrictedTypes.filterPrivileged( ).apply( networkAcl ) ) {\n                  final Optional<NetworkAclEntry> entry = Iterables.tryFind(\n                      networkAcl.getEntries( ),\n                      entryPredicate( request.getEgress( ), request.getRuleNumber( ) ) );\n                  if ( entry.isPresent( ) ) {\n                    networkAcl.getEntries( ).remove( entry.get( ) );\n                    networkAcl.updateTimeStamps( ); // ensure version of table increments also\n                  } else {\n                    throw new ClientComputeException(\n                        \"InvalidNetworkAclEntry.NotFound\",\n                        \"Entry not found for number: \" + request.getRuleNumber( ) );\n                  }\n                } else {\n                  throw new ClientUnauthorizedComputeException( \"Not authorized to delete network ACL entry\" );\n                }\n              } catch ( Exception e ) {\n                throw Exceptions.toUndeclared( e );\n              }\n            }\n          }) ;\n      invalidate( networkAclId );\n    } catch ( Exception e ) {\n      throw handleException( e );\n    }\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteNetworkInterfaceResponseType deleteNetworkInterface( final DeleteNetworkInterfaceType request ) throws EucalyptusCloudException {\n    final DeleteNetworkInterfaceResponseType reply = request.getReply( );\n    delete( Identifier.eni, request.getNetworkInterfaceId( ), new Function<Pair<AccountFullName,String>,NetworkInterface>( ) {\n      @Override\n      public NetworkInterface apply( final Pair<AccountFullName, String> accountAndId ) {\n        try {\n          final NetworkInterface networkInterface =\n              networkInterfaces.lookupByName( accountAndId.getLeft( ), accountAndId.getRight( ), Functions.<NetworkInterface>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( networkInterface ) ) {\n            if ( networkInterface.isAttached( ) ) {\n              throw new ClientComputeException( \"\" +\n                  \"InvalidNetworkInterface.InUse\",\n                  \"The network interface is in use '\"+request.getNetworkInterfaceId()+\"'\" );\n            }\n            NetworkInterfaceHelper.release( networkInterface );\n            networkInterfaces.delete( networkInterface );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete network interface\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","id":76937,"modified_method":"public DeleteNetworkInterfaceResponseType deleteNetworkInterface( final DeleteNetworkInterfaceType request ) throws EucalyptusCloudException {\n    final DeleteNetworkInterfaceResponseType reply = request.getReply( );\n    delete( Identifier.eni, request.getNetworkInterfaceId( ), new Function<Pair<Optional<AccountFullName>,String>,NetworkInterface>( ) {\n      @Override\n      public NetworkInterface apply( final Pair<Optional<AccountFullName>, String> accountAndId ) {\n        try {\n          final NetworkInterface networkInterface = networkInterfaces.lookupByName(\n              accountAndId.getLeft( ).orNull( ),\n              accountAndId.getRight( ),\n              Functions.<NetworkInterface>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( networkInterface ) ) {\n            if ( networkInterface.isAttached( ) ) {\n              throw new ClientComputeException( \"\" +\n                  \"InvalidNetworkInterface.InUse\",\n                  \"The network interface is in use '\"+request.getNetworkInterfaceId()+\"'\" );\n            }\n            NetworkInterfaceHelper.release( networkInterface );\n            networkInterfaces.delete( networkInterface );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete network interface\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private <E extends AbstractPersistent> void delete(\n      final Identifier identifier,\n      final String idParam,\n      final Function<Pair<AccountFullName,String>,E> deleter\n  ) throws EucalyptusCloudException {\n    final Context ctx = Contexts.lookup( );\n    final AccountFullName accountName = ctx.getUserFullName( ).asAccountFullName( );\n    final String id = identifier.normalize( idParam );\n    try {\n      transactional( deleter ).apply( Pair.pair( accountName, id ) );\n    } catch ( Exception e ) {\n      if ( Exceptions.isCausedBy( e, ConstraintViolationException.class ) ) {\n        throw new ClientComputeException( \"DependencyViolation\", \"Resource (\"+idParam+\") is in use\" );\n      }\n      if ( !Exceptions.isCausedBy( e, VpcMetadataNotFoundException.class ) ) {\n        throw handleException( e );\n      } // else ignore missing on delete?\n    }\n  }","id":76938,"modified_method":"private <E extends AbstractPersistent> void delete(\n      final Identifier identifier,\n      final String idParam,\n      final Function<Pair<Optional<AccountFullName>,String>,E> deleter\n  ) throws EucalyptusCloudException {\n    final Context ctx = Contexts.lookup( );\n    final AccountFullName accountName = ctx.isAdministrator( ) ? null : ctx.getUserFullName( ).asAccountFullName( );\n    final String id = identifier.normalize( idParam );\n    try {\n      transactional( deleter ).apply( Pair.lopair( accountName, id ) );\n    } catch ( Exception e ) {\n      if ( Exceptions.isCausedBy( e, ConstraintViolationException.class ) ) {\n        throw new ClientComputeException( \"DependencyViolation\", \"Resource (\"+idParam+\") is in use\" );\n      }\n      if ( !Exceptions.isCausedBy( e, VpcMetadataNotFoundException.class ) ) {\n        throw handleException( e );\n      } // else ignore missing on delete?\n    }\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteNetworkAclResponseType deleteNetworkAcl( final DeleteNetworkAclType request ) throws EucalyptusCloudException {\n    final DeleteNetworkAclResponseType reply = request.getReply( );\n    delete( Identifier.acl, request.getNetworkAclId( ), new Function<Pair<AccountFullName,String>,NetworkAcl>( ) {\n      @Override\n      public NetworkAcl apply( final Pair<AccountFullName, String> accountAndId ) {\n        try {\n          final NetworkAcl networkAcl =\n              networkAcls.lookupByName( accountAndId.getLeft( ), accountAndId.getRight( ), Functions.<NetworkAcl>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( networkAcl ) ) {\n            networkAcls.delete( networkAcl );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete network ACL\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","id":76939,"modified_method":"public DeleteNetworkAclResponseType deleteNetworkAcl( final DeleteNetworkAclType request ) throws EucalyptusCloudException {\n    final DeleteNetworkAclResponseType reply = request.getReply( );\n    delete( Identifier.acl, request.getNetworkAclId( ), new Function<Pair<Optional<AccountFullName>,String>,NetworkAcl>( ) {\n      @Override\n      public NetworkAcl apply( final Pair<Optional<AccountFullName>, String> accountAndId ) {\n        try {\n          final NetworkAcl networkAcl = networkAcls.lookupByName(\n              accountAndId.getLeft( ).orNull( ),\n              accountAndId.getRight( ),\n              Functions.<NetworkAcl>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( networkAcl ) ) {\n            networkAcls.delete( networkAcl );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete network ACL\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteInternetGatewayResponseType deleteInternetGateway( final DeleteInternetGatewayType request ) throws EucalyptusCloudException {\n    final DeleteInternetGatewayResponseType reply = request.getReply( );\n    delete( Identifier.igw, request.getInternetGatewayId( ), new Function<Pair<AccountFullName,String>,InternetGateway>( ) {\n      @Override\n      public InternetGateway apply( final Pair<AccountFullName, String> accountAndId ) {\n        try {\n          final InternetGateway internetGateway =\n              internetGateways.lookupByName( accountAndId.getLeft( ), accountAndId.getRight( ), Functions.<InternetGateway>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( internetGateway ) ) {\n            internetGateways.delete( internetGateway );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete internet gateway\" ) );\n          }\n        } catch ( VpcMetadataNotFoundException e ) {\n          // so nothing to delete, move along\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n        return null;\n      }\n    } );\n    return reply;\n  }","id":76940,"modified_method":"public DeleteInternetGatewayResponseType deleteInternetGateway( final DeleteInternetGatewayType request ) throws EucalyptusCloudException {\n    final DeleteInternetGatewayResponseType reply = request.getReply( );\n    delete( Identifier.igw, request.getInternetGatewayId( ), new Function<Pair<Optional<AccountFullName>,String>,InternetGateway>( ) {\n      @Override\n      public InternetGateway apply( final Pair<Optional<AccountFullName>, String> accountAndId ) {\n        try {\n          final InternetGateway internetGateway = internetGateways.lookupByName(\n              accountAndId.getLeft( ).orNull( ),\n              accountAndId.getRight( ),\n              Functions.<InternetGateway>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( internetGateway ) ) {\n            internetGateways.delete( internetGateway );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete internet gateway\" ) );\n          }\n        } catch ( VpcMetadataNotFoundException e ) {\n          // so nothing to delete, move along\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n        return null;\n      }\n    } );\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteRouteTableResponseType deleteRouteTable( final DeleteRouteTableType request ) throws EucalyptusCloudException {\n    final DeleteRouteTableResponseType reply = request.getReply( );\n    delete( Identifier.rtb, request.getRouteTableId( ), new Function<Pair<AccountFullName,String>,RouteTable>( ) {\n      @Override\n      public RouteTable apply( final Pair<AccountFullName, String> accountAndId ) {\n        try {\n          final RouteTable routeTable = routeTables.lookupByName( accountAndId.getLeft( ), accountAndId.getRight( ), Functions.<RouteTable>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( routeTable ) ) {\n            routeTables.delete( routeTable );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete route table\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","id":76941,"modified_method":"public DeleteRouteTableResponseType deleteRouteTable( final DeleteRouteTableType request ) throws EucalyptusCloudException {\n    final DeleteRouteTableResponseType reply = request.getReply( );\n    delete( Identifier.rtb, request.getRouteTableId( ), new Function<Pair<Optional<AccountFullName>,String>,RouteTable>( ) {\n      @Override\n      public RouteTable apply( final Pair<Optional<AccountFullName>, String> accountAndId ) {\n        try {\n          final RouteTable routeTable = routeTables.lookupByName(\n              accountAndId.getLeft( ).orNull( ),\n              accountAndId.getRight( ),\n              Functions.<RouteTable>identity( ) );\n          if ( RestrictedTypes.filterPrivileged( ).apply( routeTable ) ) {\n            routeTables.delete( routeTable );\n          } else {\n            throw Exceptions.toUndeclared( new ClientUnauthorizedComputeException( \"Not authorized to delete route table\" ) );\n          }\n          return null;\n        } catch ( Exception ex ) {\n          throw new RuntimeException( ex );\n        }\n      }\n    } );\n    return reply;\n  }","commit_id":"ee2ed01a36ef6007487ce78c73b21e985a675983","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ModifySnapshotAttributeResponseType modifySnapshotAttribute( final ModifySnapshotAttributeType request ) throws EucalyptusCloudException {\n        ModifySnapshotAttributeResponseType reply = request.getReply( );\n        final Context ctx = Contexts.lookup();\n        final String snapshotId = normalizeSnapshotIdentifier( request.getSnapshotId( ) );\n        Function<Snapshot, Boolean> modifySnapshotAttribute = Functions.forPredicate(new Predicate<Snapshot>( ) {\n\n            @Override\n            public boolean apply( Snapshot snap ) {\n                //Can only modify attributes of snapshots in 'creating' or 'available' state\n                if ( !State.EXTANT.equals( snap.getState( ) ) && !State.GENERATING.equals( snap.getState( ) ) ) {\n                    return false;\n                } else if ( !canModifySnapshot(snap)) {\n                    throw Exceptions.toUndeclared( new EucalyptusCloudException( \"Not authorized to modify attribute for snapshot \" + request.getSnapshotId( ) + \" by \" + ctx.getUser( ).getName( ) ) );\n                } else {\n                    switch ( request.snapshotAttribute() ) {\n                        case CreateVolumePermission:\n                            //do adds\n                            try {\n                                snap.addPermissions(verifyAccountIds(request.addUserIds()));\n                            } catch (EucalyptusCloudException e) {\n                                LOG.warn(\"Failed validating accountIds\", e);\n                                throw Exceptions.toUndeclared(e);\n                            }\n                            if (request.addGroupAll()) {\n                                snap.setSnapshotPublic(true);\n                            }\n\n\n                            //do removes\n                            snap.removePermissions(request.removeUserIds());\n                            if (request.removeGroupAll()) {\n                                snap.setSnapshotPublic(false);\n                            }\n                            break;\n                        case ProductCode:\n                            for ( String productCode : request.getProductCodes( ) ) {\n                                snap.addProductCode( productCode );\n                            }\n                            break;\n                    }\n                    return true;\n                }\n            }\n        });\n\n        boolean result = false;\n        try {\n            result = Transactions.one(Snapshot.named( ctx.getUserFullName( ).asAccountFullName( ), snapshotId ), modifySnapshotAttribute);\n        } catch ( NoSuchElementException ex2 ) {\n            throw new ClientComputeException( \"InvalidSnapshot.NotFound\", \"The snapshot '\"+request.getSnapshotId( )+\"' does not exist.\" );\n        } catch ( ExecutionException ex1 ) {\n            throw new EucalyptusCloudException( ex1.getCause( ) );\n        }\n        reply.set_return( result );\n        return reply;\n    }","id":76942,"modified_method":"public ModifySnapshotAttributeResponseType modifySnapshotAttribute( final ModifySnapshotAttributeType request ) throws EucalyptusCloudException {\n        ModifySnapshotAttributeResponseType reply = request.getReply( );\n        final Context ctx = Contexts.lookup();\n        final String snapshotId = normalizeSnapshotIdentifier( request.getSnapshotId( ) );\n        Function<Snapshot, Boolean> modifySnapshotAttribute = Functions.forPredicate(new Predicate<Snapshot>( ) {\n\n            @Override\n            public boolean apply( Snapshot snap ) {\n                //Can only modify attributes of snapshots in 'creating' or 'available' state\n                if ( !State.EXTANT.equals( snap.getState( ) ) && !State.GENERATING.equals( snap.getState( ) ) ) {\n                    return false;\n                } else if ( !canModifySnapshot(snap)) {\n                    throw Exceptions.toUndeclared( new EucalyptusCloudException( \"Not authorized to modify attribute for snapshot \" + request.getSnapshotId( ) + \" by \" + ctx.getUser( ).getName( ) ) );\n                } else {\n                    switch ( request.snapshotAttribute() ) {\n                        case CreateVolumePermission:\n                            //do adds\n                            try {\n                                snap.addPermissions(verifyAccountIds(request.addUserIds()));\n                            } catch (EucalyptusCloudException e) {\n                                LOG.warn(\"Failed validating accountIds\", e);\n                                throw Exceptions.toUndeclared(e);\n                            }\n                            if (request.addGroupAll()) {\n                                snap.setSnapshotPublic(true);\n                            }\n\n\n                            //do removes\n                            snap.removePermissions(request.removeUserIds());\n                            if (request.removeGroupAll()) {\n                                snap.setSnapshotPublic(false);\n                            }\n                            break;\n                        case ProductCode:\n                            for ( String productCode : request.getProductCodes( ) ) {\n                                snap.addProductCode( productCode );\n                            }\n                            break;\n                    }\n                    return true;\n                }\n            }\n        });\n\n        final boolean result;\n        try {\n            result = Transactions.one(\n                Snapshot.named(\n                    ctx.isAdministrator( ) ? null : ctx.getUserFullName( ).asAccountFullName( ),\n                    snapshotId ),\n                modifySnapshotAttribute );\n        } catch ( NoSuchElementException ex2 ) {\n            throw new ClientComputeException( \"InvalidSnapshot.NotFound\", \"The snapshot '\"+request.getSnapshotId( )+\"' does not exist.\" );\n        } catch ( ExecutionException ex1 ) {\n            throw new EucalyptusCloudException( ex1.getCause( ) );\n        }\n        reply.set_return( result );\n        return reply;\n    }","commit_id":"52b97f3d0bd647868e5247a38f27649400948ccf","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeSnapshotAttributeResponseType describeSnapshotAttribute( DescribeSnapshotAttributeType request ) throws EucalyptusCloudException {\n        DescribeSnapshotAttributeResponseType reply = request.getReply( );\n        reply.setSnapshotId(request.getSnapshotId());\n        final Context ctx = Contexts.lookup( );\n        final String snapshotId = normalizeSnapshotIdentifier( request.getSnapshotId( ) );\n        try (TransactionResource db = Entities.transactionFor(Snapshot.class)) {\n            Snapshot result = Entities.uniqueResult(Snapshot.named( ctx.getUserFullName( ).asAccountFullName( ), snapshotId));\n            if( !RestrictedTypes.filterPrivileged( ).apply( result ) ) {\n                throw new EucalyptusCloudException(\"Not authorized to describe attributes for snapshot \" + request.getSnapshotId());\n            }\n\n            ArrayList<CreateVolumePermissionItemType> permissions = Lists.newArrayList();\n            for(String id : result.getPermissions()) {\n                permissions.add(new CreateVolumePermissionItemType(id, null));\n            }\n            if(result.getSnapshotPublic()) {\n                permissions.add(new CreateVolumePermissionItemType(null, \"all\"));\n            }\n\n            if(result.getProductCodes() != null) {\n                reply.setProductCodes(new ArrayList<String>(result.getProductCodes()));\n            }\n            reply.setCreateVolumePermission(permissions);\n        } catch ( NoSuchElementException ex2 ) {\n            throw new ClientComputeException( \"InvalidSnapshot.NotFound\", \"The snapshot '\"+request.getSnapshotId( )+\"' does not exist.\" );\n        } catch ( ExecutionException ex1 ) {\n            throw new EucalyptusCloudException( ex1.getCause( ) );\n        }\n        return reply;\n    }","id":76943,"modified_method":"public DescribeSnapshotAttributeResponseType describeSnapshotAttribute( DescribeSnapshotAttributeType request ) throws EucalyptusCloudException {\n        DescribeSnapshotAttributeResponseType reply = request.getReply( );\n        reply.setSnapshotId(request.getSnapshotId());\n        final Context ctx = Contexts.lookup( );\n        final String snapshotId = normalizeSnapshotIdentifier( request.getSnapshotId( ) );\n        try (TransactionResource db = Entities.transactionFor(Snapshot.class)) {\n            Snapshot result = Entities.uniqueResult( Snapshot.named(\n                ctx.isAdministrator( ) ? null : ctx.getUserFullName( ).asAccountFullName( ),\n                snapshotId ) );\n            if( !RestrictedTypes.filterPrivileged( ).apply( result ) ) {\n                throw new EucalyptusCloudException(\"Not authorized to describe attributes for snapshot \" + request.getSnapshotId());\n            }\n\n            ArrayList<CreateVolumePermissionItemType> permissions = Lists.newArrayList();\n            for(String id : result.getPermissions()) {\n                permissions.add(new CreateVolumePermissionItemType(id, null));\n            }\n            if(result.getSnapshotPublic()) {\n                permissions.add(new CreateVolumePermissionItemType(null, \"all\"));\n            }\n\n            if(result.getProductCodes() != null) {\n                reply.setProductCodes(new ArrayList<String>(result.getProductCodes()));\n            }\n            reply.setCreateVolumePermission(permissions);\n        } catch ( NoSuchElementException ex2 ) {\n            throw new ClientComputeException( \"InvalidSnapshot.NotFound\", \"The snapshot '\"+request.getSnapshotId( )+\"' does not exist.\" );\n        } catch ( ExecutionException ex1 ) {\n            throw new EucalyptusCloudException( ex1.getCause( ) );\n        }\n        return reply;\n    }","commit_id":"52b97f3d0bd647868e5247a38f27649400948ccf","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static void showDiffWithBranch(@NotNull Project project, @NotNull VirtualFile file, @NotNull String head,\n                                           @NotNull String branchToCompare) throws VcsException {\n      final FilePath filePath = new FilePathImpl(file);\n      // we could use something like GitRepository#getCurrentRevision here,\n      // but this way we can easily identify if the file is available in the branch\n      final GitRevisionNumber currentRevisionNumber = (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, head);\n      final GitRevisionNumber compareRevisionNumber =\n        (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, branchToCompare);\n\n      if (compareRevisionNumber == null) {\n        fileDoesntExistInBranchError(project, file, branchToCompare);\n        return;\n      }\n      LOG.assertTrue(currentRevisionNumber != null,\n                     String.format(\"Current revision number is null for file [%s] and branch [%s]\", filePath, head));\n\n      // constructing the revision with human readable name (will work for files comparison however).\n      final VcsFileRevision compareRevision =\n        new GitFileRevision(project, filePath, new GitRevisionNumber(branchToCompare, compareRevisionNumber.getTimestamp()));\n      CurrentRevision currentRevision = new CurrentRevision(file, new GitRevisionNumber(head, currentRevisionNumber.getTimestamp()));\n      new GitDiffFromHistoryHandler(project).showDiffForTwo(new FilePathImpl(file), compareRevision, currentRevision);\n    }","id":76944,"modified_method":"private static void showDiffWithBranch(@NotNull Project project, @NotNull VirtualFile file, @NotNull String head,\n                                           @NotNull String branchToCompare) throws VcsException {\n      final FilePath filePath = new FilePathImpl(file);\n      // we could use something like GitRepository#getCurrentRevision here,\n      // but this way we can easily identify if the file is available in the branch\n      final GitRevisionNumber currentRevisionNumber = (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, head);\n      final GitRevisionNumber compareRevisionNumber =\n        (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, branchToCompare);\n\n      if (compareRevisionNumber == null) {\n        fileDoesntExistInBranchError(project, file, branchToCompare);\n        return;\n      }\n\n      if (currentRevisionNumber == null) {\n        LOG.error(String.format(\"Current revision number is null for file [%s] and branch [%s]\", filePath, head));\n        return;\n      }\n\n      // constructing the revision with human readable name (will work for files comparison however).\n      final VcsFileRevision compareRevision =\n        new GitFileRevision(project, filePath, new GitRevisionNumber(branchToCompare, compareRevisionNumber.getTimestamp()));\n      CurrentRevision currentRevision = new CurrentRevision(file, new GitRevisionNumber(head, currentRevisionNumber.getTimestamp()));\n      new GitDiffFromHistoryHandler(project).showDiffForTwo(new FilePathImpl(file), compareRevision, currentRevision);\n    }","commit_id":"5178a820a030ed05dea6e38ddb2ca351fa2f10de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected Project generateProject(Project project, NewDirectoryProjectDialog dlg) {\n    final DirectoryProjectGenerator generator = dlg.getProjectGenerator();\n    final File location = new File(dlg.getNewProjectLocation());\n    if (!location.exists() && !location.mkdirs()) {\n      Messages.showErrorDialog(project, \"Cannot create directory '\" + location + \"'\", \"Create Project\");\n      return null;\n    }\n\n    final VirtualFile baseDir = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n      public VirtualFile compute() {\n        return LocalFileSystem.getInstance().refreshAndFindFileByIoFile(location);\n      }\n    });\n    LOG.assertTrue(baseDir != null, \"Couldn't find '\" + location + \"' in VFS\");\n    baseDir.refresh(false, true);\n\n    if (baseDir.getChildren().length > 0) {\n      int rc = Messages.showYesNoDialog(project,\n                                        \"The directory '\" + location +\n                                        \"' is not empty. Would you like to create a project from existing sources instead?\",\n                                        \"Create New Project\", Messages.getQuestionIcon());\n      if (rc == Messages.YES) {\n        return PlatformProjectOpenProcessor.getInstance().doOpenProject(baseDir, null, false);\n      }\n    }\n\n    String generatorName = generator == null ? \"empty\" : ConvertUsagesUtil.ensureProperKey(generator.getName());\n    UsageTrigger.trigger(\"NewDirectoryProjectAction.\" + generatorName);\n    Object settings = null;\n    if (generator != null) {\n      try {\n        settings = showSettings(generator, baseDir);\n      }\n      catch (ProcessCanceledException e1) {\n        return null;\n      }\n    }\n    GeneralSettings.getInstance().setLastProjectCreationLocation(location.getParent());\n    final Object finalSettings = settings;\n    return PlatformProjectOpenProcessor.doOpenProject(baseDir, null, false, -1, new ProjectOpenedCallback() {\n      @Override\n      public void projectOpened(Project project, Module module) {\n        if (generator != null) {\n          generator.generateProject(project, baseDir, finalSettings, module);\n        }\n      }\n    }, false);\n  }","id":76945,"modified_method":"@Nullable\n  protected Project generateProject(Project project, NewDirectoryProjectDialog dlg) {\n    final File location = new File(dlg.getNewProjectLocation());\n    if (!location.exists() && !location.mkdirs()) {\n      String message = ActionsBundle.message(\"action.NewDirectoryProject.cannot.create.dir\", location);\n      Messages.showErrorDialog(project, message, ActionsBundle.message(\"action.NewDirectoryProject.title\"));\n      return null;\n    }\n\n    final VirtualFile baseDir = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n      public VirtualFile compute() {\n        return LocalFileSystem.getInstance().refreshAndFindFileByIoFile(location);\n      }\n    });\n    if (baseDir == null) {\n      LOG.error(\"Couldn't find '\" + location + \"' in VFS\");\n      return null;\n    }\n    baseDir.refresh(false, true);\n\n    if (baseDir.getChildren().length > 0) {\n      String message = ActionsBundle.message(\"action.NewDirectoryProject.not.empty\", location);\n      int rc = Messages.showYesNoDialog(project, message, ActionsBundle.message(\"action.NewDirectoryProject.title\"), Messages.getQuestionIcon());\n      if (rc == Messages.YES) {\n        return PlatformProjectOpenProcessor.getInstance().doOpenProject(baseDir, null, false);\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\") final DirectoryProjectGenerator<Object> generator = dlg.getProjectGenerator();\n\n    String generatorName = generator == null ? \"empty\" : ConvertUsagesUtil.ensureProperKey(generator.getName());\n    UsageTrigger.trigger(\"NewDirectoryProjectAction.\" + generatorName);\n\n    Object settings = null;\n    if (generator != null) {\n      try {\n        settings = showSettings(generator, baseDir);\n      }\n      catch (ProcessCanceledException e) {\n        return null;\n      }\n    }\n    GeneralSettings.getInstance().setLastProjectCreationLocation(location.getParent());\n    final Object finalSettings = settings;\n    return PlatformProjectOpenProcessor.doOpenProject(baseDir, null, false, -1, new ProjectOpenedCallback() {\n      @Override\n      public void projectOpened(Project project, Module module) {\n        if (generator != null) {\n          generator.generateProject(project, baseDir, finalSettings, module);\n        }\n      }\n    }, false);\n  }","commit_id":"8696ab04907194a4ac207c6f45d24d6b3dd4a5d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n    Project project = e.getData(CommonDataKeys.PROJECT);\n    NewDirectoryProjectDialog dlg = new NewDirectoryProjectDialog(project);\n    dlg.show();\n    if (dlg.getExitCode() != DialogWrapper.OK_EXIT_CODE) return;\n    generateProject(project, dlg);\n  }","id":76946,"modified_method":"public void actionPerformed(@NotNull AnActionEvent e) {\n    Project project = e.getProject();\n    NewDirectoryProjectDialog dlg = new NewDirectoryProjectDialog(project);\n    dlg.show();\n    if (dlg.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n      generateProject(project, dlg);\n    }\n  }","commit_id":"8696ab04907194a4ac207c6f45d24d6b3dd4a5d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OnBranchChooseRunnable(Project project, VirtualFile file, String head, JBList list) {\n      myProject = project;\n      myFile = file;\n      myHead = head;\n      myList = list;\n    }","id":76947,"modified_method":"OnBranchChooseRunnable(@NotNull Project project, @NotNull VirtualFile file, @NotNull String head, @NotNull JList list) {\n      myProject = project;\n      myFile = file;\n      myHead = head;\n      myList = list;\n    }","commit_id":"02ffec61082b2d5affc2a30ab57c62b77b637b8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<String> getBranchNamesExceptCurrent(GitRepository repository) {\n    List<GitBranch> localBranches = new ArrayList<GitBranch>(repository.getBranches().getLocalBranches());\n    Collections.sort(localBranches);\n    List<GitBranch> remoteBranches = new ArrayList<GitBranch>(repository.getBranches().getRemoteBranches());\n    Collections.sort(remoteBranches);\n    \n    if (repository.isOnBranch()) {\n      localBranches.remove(repository.getCurrentBranch());\n    }\n    \n    final List<String> branchNames = new ArrayList<String>();\n    for (GitBranch branch : localBranches) {\n      branchNames.add(branch.getName());\n    }\n    for (GitBranch branch : remoteBranches) {\n      branchNames.add(branch.getName());\n    }\n    return branchNames;\n  }","id":76948,"modified_method":"@NotNull\n  private static List<String> getBranchNamesExceptCurrent(@NotNull GitRepository repository) {\n    List<GitBranch> localBranches = new ArrayList<GitBranch>(repository.getBranches().getLocalBranches());\n    Collections.sort(localBranches);\n    List<GitBranch> remoteBranches = new ArrayList<GitBranch>(repository.getBranches().getRemoteBranches());\n    Collections.sort(remoteBranches);\n    \n    if (repository.isOnBranch()) {\n      localBranches.remove(repository.getCurrentBranch());\n    }\n    \n    List<String> branchNames = ContainerUtil.newArrayList();\n    for (GitBranch branch : localBranches) {\n      branchNames.add(branch.getName());\n    }\n    for (GitBranch branch : remoteBranches) {\n      branchNames.add(branch.getName());\n    }\n    return branchNames;\n  }","commit_id":"02ffec61082b2d5affc2a30ab57c62b77b637b8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void showDiffWithBranch(@NotNull Project project, @NotNull VirtualFile file, @NotNull String head,\n                                           @NotNull String branchToCompare) throws VcsException {\n      final FilePath filePath = new FilePathImpl(file);\n      // we could use something like GitRepository#getCurrentRevision here,\n      // but this way we can easily identify if the file is available in the branch\n      final GitRevisionNumber currentRevisionNumber = (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, head);\n      final GitRevisionNumber compareRevisionNumber =\n        (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, branchToCompare);\n\n      if (compareRevisionNumber == null) {\n        fileDoesntExistInBranchError(project, file, branchToCompare);\n        return;\n      }\n\n      if (currentRevisionNumber == null) {\n        LOG.error(String.format(\"Current revision number is null for file [%s] and branch [%s]\", filePath, head));\n        return;\n      }\n\n      // constructing the revision with human readable name (will work for files comparison however).\n      final VcsFileRevision compareRevision =\n        new GitFileRevision(project, filePath, new GitRevisionNumber(branchToCompare, compareRevisionNumber.getTimestamp()));\n      CurrentRevision currentRevision = new CurrentRevision(file, new GitRevisionNumber(head, currentRevisionNumber.getTimestamp()));\n      new GitDiffFromHistoryHandler(project).showDiffForTwo(new FilePathImpl(file), compareRevision, currentRevision);\n    }","id":76949,"modified_method":"private static void showDiffWithBranch(@NotNull Project project, @NotNull VirtualFile file, @NotNull String head,\n                                           @NotNull String branchToCompare) throws VcsException {\n      FilePath filePath = new FilePathImpl(file);\n      // we could use something like GitRepository#getCurrentRevision here,\n      // but this way we can easily identify if the file is available in the branch\n      GitRevisionNumber compareRevisionNumber = (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, branchToCompare);\n      if (compareRevisionNumber == null) {\n        fileDoesntExistInBranchError(project, file, branchToCompare);\n        return;\n      }\n\n      GitRevisionNumber currentRevisionNumber = (GitRevisionNumber)GitHistoryUtils.getCurrentRevision(project, filePath, head);\n      if (currentRevisionNumber == null) {\n        LOG.error(String.format(\"Current revision number is null for file [%s] and branch [%s]\", filePath, head));\n        return;\n      }\n\n      // constructing the revision with human readable name (will work for files comparison however).\n      VcsFileRevision compareRevision = new GitFileRevision(project, filePath,\n                                                            new GitRevisionNumber(branchToCompare, compareRevisionNumber.getTimestamp()));\n      CurrentRevision currentRevision = new CurrentRevision(file, new GitRevisionNumber(head, currentRevisionNumber.getTimestamp()));\n      new GitDiffFromHistoryHandler(project).showDiffForTwo(new FilePathImpl(file), compareRevision, currentRevision);\n    }","commit_id":"02ffec61082b2d5affc2a30ab57c62b77b637b8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent event) {\n    final Project project = event.getProject();\n    assert project != null;\n\n    final VirtualFile file = getAffectedFile(event);\n\n    GitRepositoryManager manager = GitUtil.getRepositoryManager(project);\n    GitRepository repository = manager.getRepositoryForFile(file);\n    assert repository != null;\n\n    GitBranch currentBranch = repository.getCurrentBranch();\n    final String head;\n    if (currentBranch == null) {\n      String currentRevision = repository.getCurrentRevision();\n      LOG.assertTrue(currentRevision != null,\n                     \"Current revision is null for \" + repository + \". Compare with branch shouldn't be available for fresh repository\");\n      head = DvcsUtil.getShortHash(currentRevision);\n    }\n    else {\n      head = currentBranch.getName();\n    }\n    final List<String> branchNames = getBranchNamesExceptCurrent(repository);\n\n    // prepare and invoke popup\n    final JBList list = new JBList(branchNames);\n\n    JBPopupFactory.getInstance()\n      .createListPopupBuilder(list)\n      .setTitle(\"Select branch to compare\")\n      .setItemChoosenCallback(new OnBranchChooseRunnable(project, file, head, list))\n      .setAutoselectOnMouseMove(true)\n      .createPopup()\n      .showInBestPositionFor(event.getDataContext());\n  }","id":76950,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent event) {\n    Project project = event.getRequiredData(CommonDataKeys.PROJECT);\n    VirtualFile file = getAffectedFile(event);\n    GitRepository repository = GitUtil.getRepositoryManager(project).getRepositoryForFile(file);\n    assert repository != null;\n\n    GitBranch currentBranch = repository.getCurrentBranch();\n    String head;\n    if (currentBranch == null) {\n      String currentRevision = repository.getCurrentRevision();\n      if (currentRevision == null) {\n        LOG.error(\"Current revision is null for \" + repository + \". Compare with branch shouldn't be available for fresh repository\");\n        return;\n      }\n      head = DvcsUtil.getShortHash(currentRevision);\n    }\n    else {\n      head = currentBranch.getName();\n    }\n    List<String> branchNames = getBranchNamesExceptCurrent(repository);\n\n    JBList list = new JBList(branchNames);\n    JBPopupFactory.getInstance()\n      .createListPopupBuilder(list)\n      .setTitle(\"Select branch to compare\")\n      .setItemChoosenCallback(new OnBranchChooseRunnable(project, file, head, list))\n      .setAutoselectOnMouseMove(true)\n      .createPopup()\n      .showInBestPositionFor(event.getDataContext());\n  }","commit_id":"02ffec61082b2d5affc2a30ab57c62b77b637b8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void run() {\n      String branchToCompare = myList.getSelectedValue().toString();\n      try {\n        showDiffWithBranch(myProject, myFile, myHead, branchToCompare);\n      }\n      catch (VcsException e) {\n        if (e.getMessage().contains(\"exists on disk, but not in\")) {\n          fileDoesntExistInBranchError(myProject, myFile, branchToCompare);\n        } else {\n          GitUIUtil.notifyError(myProject, \"Couldn't compare with branch\",\n                                String.format(\"Couldn't compare file [%s] with selected branch [%s]\", myFile, myList.getSelectedValue()),\n                                false, e);\n        }\n      }\n    }","id":76951,"modified_method":"@Override\n    public void run() {\n      Object selectedValue = myList.getSelectedValue();\n      if (selectedValue == null) {\n        LOG.error(\"Selected value is unexpectedly null\");\n        return;\n      }\n      String branchToCompare = selectedValue.toString();\n      try {\n        showDiffWithBranch(myProject, myFile, myHead, branchToCompare);\n      }\n      catch (VcsException e) {\n        if (e.getMessage().contains(\"exists on disk, but not in\")) {\n          fileDoesntExistInBranchError(myProject, myFile, branchToCompare);\n        } else {\n          GitUIUtil.notifyError(myProject, \"Couldn't compare with branch\",\n                                String.format(\"Couldn't compare file [%s] with selected branch [%s]\", myFile, selectedValue),\n                                false, e);\n        }\n      }\n    }","commit_id":"02ffec61082b2d5affc2a30ab57c62b77b637b8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void insertNode(final DefaultMutableTreeNode nodeToInsert, DefaultMutableTreeNode rootNode) {\n    final Enumeration enumeration = rootNode.children();\n    ArrayList children = Collections.list(enumeration);\n    final int index = Collections.binarySearch(children, nodeToInsert, new Comparator<DefaultMutableTreeNode>() {\n      public int compare(DefaultMutableTreeNode node1, DefaultMutableTreeNode node2) {\n        final Object o1 = node1.getUserObject();\n        final Object o2 = node2.getUserObject();\n        if (o1 instanceof Module && o2 instanceof Module) {\n          return ((Module)o1).getName().compareToIgnoreCase(((Module)o2).getName());\n        }\n        if (o1 instanceof ModuleGroup && o2 instanceof ModuleGroup){\n          return o1.toString().compareToIgnoreCase(o2.toString());\n        }\n        if (o1 instanceof ModuleGroup) return -1;\n        if (o1 instanceof DirectoryChooser.ItemWrapper && o2 instanceof DirectoryChooser.ItemWrapper) {\n          final VirtualFile virtualFile1 = ((DirectoryChooser.ItemWrapper)o1).getDirectory().getVirtualFile();\n          final VirtualFile virtualFile2 = ((DirectoryChooser.ItemWrapper)o2).getDirectory().getVirtualFile();\n          return Comparing.compare(virtualFile1.getPath(), virtualFile2.getPath());\n        }\n        return 1;\n      }\n    });\n    final int insertionPoint = -(index+1);\n    LOG.assertTrue(0 <= insertionPoint && insertionPoint <= rootNode.getChildCount(), \"insertionPoint = \"+insertionPoint+\"; children=\"+children+\"; node=\"+nodeToInsert);\n    rootNode.insert(nodeToInsert, insertionPoint);\n    ((DefaultTreeModel)myTree.getModel()).nodeStructureChanged(rootNode);\n  }","id":76952,"modified_method":"private void insertNode(final DefaultMutableTreeNode nodeToInsert, DefaultMutableTreeNode rootNode) {\n    final Enumeration enumeration = rootNode.children();\n    ArrayList children = Collections.list(enumeration);\n    final int index = Collections.binarySearch(children, nodeToInsert, new Comparator<DefaultMutableTreeNode>() {\n      public int compare(DefaultMutableTreeNode node1, DefaultMutableTreeNode node2) {\n        final Object o1 = node1.getUserObject();\n        final Object o2 = node2.getUserObject();\n        if (o1 instanceof Module && o2 instanceof Module) {\n          return ((Module)o1).getName().compareToIgnoreCase(((Module)o2).getName());\n        }\n        if (o1 instanceof ModuleGroup && o2 instanceof ModuleGroup){\n          return o1.toString().compareToIgnoreCase(o2.toString());\n        }\n        if (o1 instanceof ModuleGroup) return -1;\n        if (o1 instanceof DirectoryChooser.ItemWrapper && o2 instanceof DirectoryChooser.ItemWrapper) {\n          final VirtualFile virtualFile1 = ((DirectoryChooser.ItemWrapper)o1).getDirectory().getVirtualFile();\n          final VirtualFile virtualFile2 = ((DirectoryChooser.ItemWrapper)o2).getDirectory().getVirtualFile();\n          return Comparing.compare(virtualFile1.getPath(), virtualFile2.getPath());\n        }\n        return 1;\n      }\n    });\n    final int insertionPoint = -(index+1);\n    if (insertionPoint < 0 || insertionPoint > rootNode.getChildCount()) {\n      LOG.error(\"insertionPoint = \" + insertionPoint + \"; children=\" + children + \"; node=\" + nodeToInsert);\n      return;\n    }\n    rootNode.insert(nodeToInsert, insertionPoint);\n    ((DefaultTreeModel)myTree.getModel()).nodeStructureChanged(rootNode);\n  }","commit_id":"118757f6ed2a5312f632bf5630facc33f41b009e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JdkPopupAction() {\n    super(\"Show Quick list\", \"\", AllIcons.General.AddJdk);\n    if (/*SystemInfo.isWindows*/false) {\n      new SwingWorker() {\n        ArrayList<Pair<File, String>> myResult = new ArrayList<Pair<File, String>>();\n\n        @Override\n        public Object construct() {\n          Collection<String> homePaths = JavaSdk.getInstance().suggestHomePaths();\n          for (final String path : homePaths) {\n            try {\n              File file = new File(path);\n              File javaExe = new File(new File(file, \"bin\"), \"java.exe\");\n              ProcessOutput output = ExecUtil.execAndGetOutput(Arrays.asList(javaExe.getAbsolutePath(), \"-version\"), null);\n              List<String> lines = output.getStderrLines();\n              if (lines.isEmpty()) {\n                lines = output.getStdoutLines();\n              }\n              StringBuilder stringBuilder = new StringBuilder();\n              if (lines.size() == 3) {\n                stringBuilder.append(\"JDK \");\n                String line = lines.get(1);\n                int pos = line.indexOf(\"(build \");\n                if (pos != -1) {\n                  stringBuilder.append(line.substring(pos + 7, line.length() - 1));\n                }\n                line = lines.get(2);\n                pos = line.indexOf(\" (build\");\n                if (pos != -1) {\n                  String substring = line.substring(0, pos);\n                  stringBuilder.append(\" (\").append(substring).append(\")\");\n                }\n              }\n              else {\n                stringBuilder.append(file.getName());\n              }\n              myResult.add(Pair.create(file, stringBuilder.toString()));\n            }\n            catch (ExecutionException e) {\n              LOG.debug(e);\n            }\n          }\n          return myResult;\n        }\n\n        @Override\n        public void finished() {\n          myJDKHomes.addAll(myResult);\n        }\n      }.start();\n    }\n  }","id":76953,"modified_method":"public JdkPopupAction() {\n    super(\"Show Quick list\", \"\", AllIcons.General.AddJdk);\n  }","commit_id":"2cc0e2fa0999fd61685d56bdb618db983d015f56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    ActionPopupMenu menu =\n      ActionManager.getInstance().createActionPopupMenu(e.getPlace(), new ActionGroup() {\n        @NotNull\n        @Override\n        public AnAction[] getChildren(@Nullable AnActionEvent e) {\n          List<AnAction> result = new ArrayList<AnAction>();\n          for (final Pair<File, String> homes : myJDKHomes) {\n            result.add(new FileChooserAction(\"\", null, null) {\n              @Override\n              protected void update(FileSystemTree fileChooser, AnActionEvent e) {\n                e.getPresentation().setText(homes.getSecond(), false);\n                boolean selected = false;\n                VirtualFile selectedFile = fileChooser.getSelectedFile();\n                if (selectedFile != null) {\n                  selected = homes.getFirst().getAbsolutePath().equals(VfsUtilCore.virtualToIoFile(selectedFile).getAbsolutePath());\n                }\n                e.getPresentation().setIcon(selected ? AllIcons.Actions.Checked_small : null);\n              }\n\n              @Override\n              protected void actionPerformed(FileSystemTree fileChooser, AnActionEvent e) {\n                fileChooser.select(VfsUtil.findFileByIoFile(homes.getFirst(), true), null);\n              }\n            });\n          }\n          return result.toArray(new AnAction[result.size()]);\n        }\n      });\n    JPopupMenu menuComponent = menu.getComponent();\n\n    Object source = e.getInputEvent().getSource();\n    if (source instanceof Component) {\n      Component component = (Component)source;\n      menuComponent.show(component, 0, component.getHeight());\n    }\n    else {\n      Component component = e.getData(PlatformDataKeys.CONTEXT_COMPONENT);\n      if (component == null) {\n        return;\n      }\n      menuComponent\n        .show(component, (component.getWidth() - menuComponent.getWidth()) / 2, (component.getHeight() - menuComponent.getHeight()) / 2);\n    }\n  }","id":76954,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final JComponent component;\n    final boolean showInMiddle;\n    InputEvent inputEvent = e.getInputEvent();\n    Object source = inputEvent != null ? inputEvent.getSource() : null;\n    if (source instanceof JComponent) {\n      component = (JComponent)source;\n      showInMiddle = false;\n    }\n    else {\n      Component c = e.getData(PlatformDataKeys.CONTEXT_COMPONENT);\n      component = c instanceof JComponent? (JComponent)c : null;\n      showInMiddle = true;\n    }\n\n    if (!isEnabledInCurrentOS() || component == null) return;\n\n    ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n\n      @Override\n      public void run() {\n        final ArrayList<Pair<File, String>> jdkLocations = retrieveJDKLocations();\n\n        if (jdkLocations.isEmpty()) {\n          return;\n        }\n\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            showPopupMenu(e, jdkLocations, showInMiddle, component);\n          }\n        });\n      }\n    }, \"Looking for JDK locations...\", false, e.getProject(), component);\n  }","commit_id":"2cc0e2fa0999fd61685d56bdb618db983d015f56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    boolean enabled = SystemInfo.isWindows && !myJDKHomes.isEmpty();\n    if (enabled) {\n      FileSystemTree tree = FileSystemTree.DATA_KEY.getData(e.getDataContext());\n      if (tree instanceof FileSystemTreeImpl) {\n        FileSystemTreeImpl impl = (FileSystemTreeImpl)tree;\n        if (Boolean.TRUE != impl.getData(JavaSdkImpl.KEY)) {\n          enabled = false;\n        }\n      }\n      else {\n        enabled = false;\n      }\n    }\n    e.getPresentation().setEnabled(enabled);\n    e.getPresentation().setVisible(enabled);\n  }","id":76955,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    boolean enabled = isEnabledInCurrentOS();\n    if (enabled) {\n      FileSystemTree tree = FileSystemTree.DATA_KEY.getData(e.getDataContext());\n      if (tree == null || Boolean.TRUE != tree.getData(JavaSdkImpl.KEY)) {\n        enabled = false;\n      }\n    }\n    e.getPresentation().setEnabled(enabled);\n    e.getPresentation().setVisible(enabled);\n  }","commit_id":"2cc0e2fa0999fd61685d56bdb618db983d015f56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isEnabled(@NotNull final Project project, final AnActionEvent event) {\n      return myHandler.isEnabled(project) && (event == null || event.getInputEvent()== null || !event.getInputEvent().isAltDown());\n    }","id":76956,"modified_method":"public boolean isEnabled(@NotNull final Project project, final AnActionEvent event) {\n      Editor editor = event.getData(PlatformDataKeys.EDITOR);\n      MouseEvent mouseEvent = event.getInputEvent() instanceof MouseEvent ? (MouseEvent)event.getInputEvent(): null;\n      if (editor == null || mouseEvent == null || !(mouseEvent.isAltDown()))\n        return false;\n      Component deepestComponentAt = SwingUtilities.getDeepestComponentAt(mouseEvent.getComponent(), mouseEvent.getX(), mouseEvent.getY());\n      if (!SwingUtilities.isDescendingFrom(deepestComponentAt, editor.getComponent()))\n        return false;\n      EditorMouseEventArea area = editor.getMouseEventArea(SwingUtilities.convertMouseEvent(mouseEvent.getComponent(), mouseEvent, deepestComponentAt));\n      return myHandler.isEnabled(project) && area == EditorMouseEventArea.EDITING_AREA;\n    }","commit_id":"063545bb6e9be8106eb6a507fc560752490b3d04","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    Editor editor = PlatformDataKeys.EDITOR.getData(dataContext);\n\n    switch (myCompletionType) {\n      case BASIC: FeatureUsageTracker.getInstance().triggerFeatureUsed(CodeCompletionFeatures.EDITING_COMPLETION_BASIC);\n      case SMART: FeatureUsageTracker.getInstance().triggerFeatureUsed(CodeCompletionFeatures.EDITING_COMPLETION_SMARTTYPE_GENERAL);\n      case CLASS_NAME: FeatureUsageTracker.getInstance().triggerFeatureUsed(CodeCompletionFeatures.EDITING_COMPLETION_CLASSNAME);\n    }\n\n    new CodeCompletionHandlerBase(myCompletionType).invokeCompletion(project, editor, 1, e.getInputEvent().getModifiers() != 0);\n  }","id":76957,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    Editor editor = PlatformDataKeys.EDITOR.getData(dataContext);\n\n    switch (myCompletionType) {\n      case BASIC: FeatureUsageTracker.getInstance().triggerFeatureUsed(CodeCompletionFeatures.EDITING_COMPLETION_BASIC);\n      case SMART: FeatureUsageTracker.getInstance().triggerFeatureUsed(CodeCompletionFeatures.EDITING_COMPLETION_SMARTTYPE_GENERAL);\n      case CLASS_NAME: FeatureUsageTracker.getInstance().triggerFeatureUsed(CodeCompletionFeatures.EDITING_COMPLETION_CLASSNAME);\n    }\n\n    final InputEvent inputEvent = e.getInputEvent();\n    new CodeCompletionHandlerBase(myCompletionType).invokeCompletion(project, editor, 1, inputEvent != null && inputEvent.getModifiers() != 0);\n  }","commit_id":"83de4aac8c8b700955d6dd1a18a6bfee341280be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Lock refresh(String uuid, long expirationTime)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tList<Lock> locks = lockPersistence.findByUuid(uuid);\n\n\t\tLock lock = null;\n\n\t\tif (locks.size() > 0) {\n\t\t\tlock = locks.get(0);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchLockException();\n\t\t}\n\n\t\tlock.setCreateDate(now);\n\t\tlock.setExpirationDate(new Date(now.getTime() + expirationTime));\n\n\t\tlockPersistence.update(lock, false);\n\n\t\treturn lock;\n\t}","id":76958,"modified_method":"public Lock refresh(String uuid, long expirationTime)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tList<Lock> locks = lockPersistence.findByUuid(uuid);\n\n\t\tLock lock = null;\n\n\t\tif (locks.size() > 0) {\n\t\t\tlock = locks.get(0);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchLockException();\n\t\t}\n\n\t\tlock.setCreateDate(now);\n\n\t\tif (expirationTime == 0) {\n\t\t\tlock.setExpirationDate(new Date(Long.MAX_VALUE));\n\t\t}\n\t\telse {\n\t\t\tlock.setExpirationDate(new Date(now.getTime() + expirationTime));\n\t\t}\n\n\t\tlockPersistence.update(lock, false);\n\n\t\treturn lock;\n\t}","commit_id":"1eec914814193b988b76097e70df42ba2a03367d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Lock lock(\n\t\t\tlong userId, String className, String key, String owner,\n\t\t\tboolean inheritable, long expirationTime)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tLock lock = lockPersistence.fetchByC_K(className, key);\n\n\t\tif (lock != null) {\n\t\t\tif (lock.isExpired()) {\n\t\t\t\tunlock(className, key);\n\n\t\t\t\tlock = null;\n\t\t\t}\n\t\t\telse if (!lock.getOwner().equals(owner)) {\n\t\t\t\tthrow new DuplicateLockException(lock);\n\t\t\t}\n\t\t}\n\n\t\tif (lock == null) {\n\t\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\t\tlong lockId = counterLocalService.increment();\n\n\t\t\tlock = lockPersistence.create(lockId);\n\n\t\t\tlock.setCompanyId(user.getCompanyId());\n\t\t\tlock.setUserId(user.getUserId());\n\t\t\tlock.setUserName(user.getFullName());\n\t\t\tlock.setUserId(userId);\n\t\t\tlock.setClassName(className);\n\t\t\tlock.setKey(key);\n\t\t\tlock.setOwner(owner);\n\t\t\tlock.setInheritable(inheritable);\n\t\t}\n\n\t\tlock.setCreateDate(now);\n\t\tlock.setExpirationDate(new Date(now.getTime() + expirationTime));\n\n\t\tlockPersistence.update(lock, false);\n\n\t\treturn lock;\n\t}","id":76959,"modified_method":"public Lock lock(\n\t\t\tlong userId, String className, String key, String owner,\n\t\t\tboolean inheritable, long expirationTime)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tLock lock = lockPersistence.fetchByC_K(className, key);\n\n\t\tif (lock != null) {\n\t\t\tif (lock.isExpired()) {\n\t\t\t\tunlock(className, key);\n\n\t\t\t\tlock = null;\n\t\t\t}\n\t\t\telse if (!lock.getOwner().equals(owner)) {\n\t\t\t\tthrow new DuplicateLockException(lock);\n\t\t\t}\n\t\t}\n\n\t\tif (lock == null) {\n\t\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\t\tlong lockId = counterLocalService.increment();\n\n\t\t\tlock = lockPersistence.create(lockId);\n\n\t\t\tlock.setCompanyId(user.getCompanyId());\n\t\t\tlock.setUserId(user.getUserId());\n\t\t\tlock.setUserName(user.getFullName());\n\t\t\tlock.setUserId(userId);\n\t\t\tlock.setClassName(className);\n\t\t\tlock.setKey(key);\n\t\t\tlock.setOwner(owner);\n\t\t\tlock.setInheritable(inheritable);\n\t\t}\n\n\t\tlock.setCreateDate(now);\n\n\t\tif (expirationTime == 0) {\n\t\t\tlock.setExpirationDate(new Date(Long.MAX_VALUE));\n\t\t}\n\t\telse {\n\t\t\tlock.setExpirationDate(new Date(now.getTime() + expirationTime));\n\t\t}\n\n\t\tlockPersistence.update(lock, false);\n\n\t\treturn lock;\n\t}","commit_id":"1eec914814193b988b76097e70df42ba2a03367d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JournalArticle approveArticle(\n\t\t\tlong userId, long groupId, String articleId, double version,\n\t\t\tString articleURL, PortletPreferences prefs)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tJournalArticle article = journalArticlePersistence.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tarticle.setModifiedDate(now);\n\t\tarticle.setApproved(true);\n\t\tarticle.setApprovedByUserId(user.getUserId());\n\t\tarticle.setApprovedByUserName(user.getFullName());\n\t\tarticle.setApprovedDate(now);\n\t\tarticle.setExpired(false);\n\t\tarticle.setExpirationDate(null);\n\n\t\tjournalArticlePersistence.update(article, false);\n\n\t\t// Email\n\n\t\ttry {\n\t\t\tsendEmail(article, articleURL, prefs, \"granted\");\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isIndexable()) {\n\t\t\t\tString[] tagsEntries = tagsEntryLocalService.getEntryNames(\n\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\tarticle.getResourcePrimKey());\n\n\t\t\t\tIndexer.updateArticle(\n\t\t\t\t\tarticle.getCompanyId(), article.getGroupId(),\n\t\t\t\t\tarticle.getArticleId(), article.getVersion(),\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\tarticle.getDisplayDate(), tagsEntries);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Indexing \" + article.getId(), ioe);\n\t\t}\n\n\t\treturn article;\n\t}","id":76960,"modified_method":"public JournalArticle approveArticle(\n\t\t\tlong userId, long groupId, String articleId, double version,\n\t\t\tString articleURL, PortletPreferences prefs)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tJournalArticle article = journalArticlePersistence.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tarticle.setModifiedDate(now);\n\t\tarticle.setApproved(true);\n\t\tarticle.setApprovedByUserId(user.getUserId());\n\t\tarticle.setApprovedByUserName(user.getFullName());\n\t\tarticle.setApprovedDate(now);\n\t\tarticle.setExpired(false);\n\n\t\tif( ( article.getExpirationDate()!=null ) &&\n\t\t\t( article.getExpirationDate().before(now) )) {\n\t\t\tarticle.setExpirationDate(null);\n\t\t}\n\n\t\tjournalArticlePersistence.update(article, false);\n\n\t\t// Email\n\n\t\ttry {\n\t\t\tsendEmail(article, articleURL, prefs, \"granted\");\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isIndexable()) {\n\t\t\t\tString[] tagsEntries = tagsEntryLocalService.getEntryNames(\n\t\t\t\t\tJournalArticle.class.getName(),\n\t\t\t\t\tarticle.getResourcePrimKey());\n\n\t\t\t\tIndexer.updateArticle(\n\t\t\t\t\tarticle.getCompanyId(), article.getGroupId(),\n\t\t\t\t\tarticle.getArticleId(), article.getVersion(),\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\tarticle.getDisplayDate(), tagsEntries);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Indexing \" + article.getId(), ioe);\n\t\t}\n\n\t\treturn article;\n\t}","commit_id":"e752f41c6125c2829831ed2771b3f5533821b554","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private int getIfIndexByName(Connection dbConn,\r\n\t\t\tint nodeid, String ifName) throws SQLException {\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\r\n\t\tPreparedStatement stmt = null;\r\n\t\tstmt = dbConn.prepareStatement(SQL_GET_IFINDEX_SNMPINTERFACE_NAME);\r\n\t\tstmt.setInt(1, nodeid);\r\n\t\tstmt.setString(2, ifName);\r\n\t\tstmt.setString(3, ifName);\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getIfIndexByName: executing query\"\r\n\t\t\t\t\t+ stmt.toString() + \"nodeid =\" + nodeid + \"and ifName=\" + ifName);\r\n\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"getIfIndexByName: no entries found in snmpinterface\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// extract the values.\r\n\t\t//\r\n\t\tint ndx = 1;\r\n\r\n\t\tif (rs.wasNull()) {\r\n\t\t\t\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"getIfIndexByName: no entries found in snmpinterface\");\r\n\t\t\treturn -1;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tint ifindex = rs.getInt(ndx++);\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getIfIndexByName: found ifindex=\"\r\n\t\t\t\t\t+ ifindex);\r\n\r\n\t\tstmt.close();\r\n\r\n\t\treturn ifindex;\r\n\t}","id":76961,"modified_method":"private int getIfIndexByName(Connection dbConn,\r\n\t\t\tint nodeid, String ifName) throws SQLException {\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\r\n\t\tPreparedStatement stmt = null;\r\n\t\tstmt = dbConn.prepareStatement(SQL_GET_IFINDEX_SNMPINTERFACE_NAME);\r\n\t\tstmt.setInt(1, nodeid);\r\n\t\tstmt.setString(2, ifName);\r\n\t\tstmt.setString(3, ifName);\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getIfIndexByName: executing query\"\r\n\t\t\t\t\t+ SQL_GET_IFINDEX_SNMPINTERFACE_NAME + \"nodeid =\" + nodeid + \"and ifName=\" + ifName);\r\n\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"getIfIndexByName: no entries found in snmpinterface\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// extract the values.\r\n\t\t//\r\n\t\tint ndx = 1;\r\n\r\n\t\tif (rs.wasNull()) {\r\n\t\t\t\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"getIfIndexByName: no entries found in snmpinterface\");\r\n\t\t\treturn -1;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tint ifindex = rs.getInt(ndx++);\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getIfIndexByName: found ifindex=\"\r\n\t\t\t\t\t+ ifindex);\r\n\r\n\t\tstmt.close();\r\n\r\n\t\treturn ifindex;\r\n\t}","commit_id":"eb38aaa965946932df8e0e4c3c65b6acd80be751","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private AtInterface getNodeidIfindexFromIp(Connection dbConn, InetAddress ipaddr)\r\n\tthrows SQLException {\r\n\r\n\r\n\t\tif (ipaddr.isLoopbackAddress() || ipaddr.getHostAddress().equals(\"0.0.0.0\")) return null;\r\n\t\t\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\t\r\n\t\tint atnodeid = -1;\r\n\t\tint atifindex = -1;\r\n\t\t\r\n\t\tPreparedStatement stmt = dbConn.prepareStatement(SQL_GET_NODEID_IFINDEX_IPINT);\r\n\t\tstmt.setString(1, ipaddr.getHostAddress());\r\n\r\n\t\tif (log.isDebugEnabled()) \r\n\t\t\tlog.debug(\"getNodeidIfindexFromIp: executing SQL Statement \" + SQL_GET_NODEID_IFINDEX_IPINT + \" with ip address=\" + ipaddr.getHostAddress());\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tint ndx = 1;\r\n\t\tatnodeid = rs.getInt(ndx++);\r\n\t\tif (rs.wasNull()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t// save info for DiscoveryLink\r\n\t\tAtInterface ati = new AtInterface(atnodeid,ipaddr.getHostAddress());\r\n\r\n\t\t// get ifindex if exists\r\n\t\tatifindex = rs.getInt(ndx++);\r\n\t\tif (rs.wasNull()) {\r\n\t\t\tif (log.isInfoEnabled())\r\n\t\t\t\tlog.info(\"store: no ifindex (-1) found for ipaddress \"\r\n\t\t\t\t\t\t+ ipaddr + \".\");\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\tif (log.isInfoEnabled())\r\n\t\t\t\tlog.info(\"store: ifindex \" + atifindex + \" found for ipaddress \"\r\n\t\t\t\t\t\t+ ipaddr + \".\");\r\n\t\t\t\r\n\t\t\tati.setIfindex(atifindex);\r\n\t\t}\r\n\t\t\r\n\t\treturn ati;\r\n\t\t\r\n\t}","id":76962,"modified_method":"private AtInterface getNodeidIfindexFromIp(Connection dbConn, InetAddress ipaddr)\r\n\tthrows SQLException {\r\n\r\n\r\n\t\tif (ipaddr.isLoopbackAddress() || ipaddr.getHostAddress().equals(\"0.0.0.0\")) return null;\r\n\t\t\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\t\r\n\t\tint atnodeid = -1;\r\n\t\tint atifindex = -1;\r\n\t\t\r\n\t\tPreparedStatement stmt = dbConn.prepareStatement(SQL_GET_NODEID_IFINDEX_IPINT);\r\n\t\r\n\t\tstmt.setString(1, ipaddr.getHostAddress());\r\n\r\n\t\tif (log.isDebugEnabled()) \r\n\t\t\tlog.debug(\"getNodeidIfindexFromIp: executing SQL Statement \" + SQL_GET_NODEID_IFINDEX_IPINT + \" with ip address=\" + ipaddr.getHostAddress());\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tatnodeid = rs.getInt(\"nodeid\");\r\n\t\tif (rs.wasNull()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t// save info for DiscoveryLink\r\n\t\tAtInterface ati = new AtInterface(atnodeid,ipaddr.getHostAddress());\r\n\r\n\t\t// get ifindex if exists\r\n\t\tatifindex = rs.getInt(\"ifindex\");\r\n\t\tif (rs.wasNull()) {\r\n\t\t\tif (log.isInfoEnabled())\r\n\t\t\t\tlog.info(\"getNodeidIfindexFromIp: nodeid \"+ atnodeid +\" no ifindex (-1) found for ipaddress \"\r\n\t\t\t\t\t\t+ ipaddr + \".\");\r\n\t\t} else {\r\n\t\t\tif (log.isInfoEnabled())\r\n\t\t\t\tlog.info(\"getNodeidIfindexFromIp: nodeid \"+ atnodeid +\" ifindex \" + atifindex + \" found for ipaddress \"\r\n\t\t\t\t\t\t+ ipaddr + \".\");\r\n\t\t\tati.setIfindex(atifindex);\r\n\t\t}\r\n\t\t\r\n\t\treturn ati;\r\n\t\t\r\n\t}","commit_id":"eb38aaa965946932df8e0e4c3c65b6acd80be751","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private int getNodeidFromIp(Connection dbConn, InetAddress ipaddr)\r\n\t\t\tthrows SQLException {\r\n\r\n\r\n\t\tif (ipaddr.isLoopbackAddress() || ipaddr.getHostAddress().equals(\"0.0.0.0\")) return -1;\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\t\r\n\t\tint nodeid = -1;\r\n\t\t\r\n\t\tPreparedStatement stmt = null;\r\n\t\tstmt = dbConn.prepareStatement(SQL_GET_NODEID);\r\n\t\tstmt.setString(1, ipaddr.getHostAddress());\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getNodeidFromIp: executing query \" + stmt.toString() + \" with ip address=\" + ipaddr.getHostAddress());\r\n\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog.debug(\"getNodeidFromIp: no entries found in ipinterface\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t// extract the values.\r\n\t\t//\r\n\t\tint ndx = 1;\r\n\r\n\t\t// get the node id\r\n\t\t//\r\n\t\tnodeid = rs.getInt(ndx++);\r\n\t\tif (rs.wasNull())\r\n\t\t\tnodeid = -1;\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getNodeidFromIp: found nodeid \" + nodeid);\r\n\r\n\t\tstmt.close();\r\n\r\n\t\treturn nodeid;\r\n\r\n\t}","id":76963,"modified_method":"private int getNodeidFromIp(Connection dbConn, InetAddress ipaddr)\r\n\t\t\tthrows SQLException {\r\n\r\n\r\n\t\tif (ipaddr.isLoopbackAddress() || ipaddr.getHostAddress().equals(\"0.0.0.0\")) return -1;\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\t\r\n\t\tint nodeid = -1;\r\n\t\t\r\n\t\tPreparedStatement stmt = null;\r\n\t\tstmt = dbConn.prepareStatement(SQL_GET_NODEID);\r\n\t\tstmt.setString(1, ipaddr.getHostAddress());\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getNodeidFromIp: executing query \" + SQL_GET_NODEID + \" with ip address=\" + ipaddr.getHostAddress());\r\n\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog.debug(\"getNodeidFromIp: no entries found in ipinterface\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t// extract the values.\r\n\t\t//\r\n\t\tint ndx = 1;\r\n\r\n\t\t// get the node id\r\n\t\t//\r\n\t\tnodeid = rs.getInt(ndx++);\r\n\t\tif (rs.wasNull())\r\n\t\t\tnodeid = -1;\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getNodeidFromIp: found nodeid \" + nodeid);\r\n\r\n\t\tstmt.close();\r\n\r\n\t\treturn nodeid;\r\n\r\n\t}","commit_id":"eb38aaa965946932df8e0e4c3c65b6acd80be751","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\r\n\t * \r\n\t * @param dbConn\r\n\t * @param now\r\n\t * @throws SQLException\r\n\t */\r\n\tprivate void storeSnmpCollection(Connection dbConn, Timestamp now) throws SQLException,\r\n\t\t\tUnknownHostException {\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\tIterator ite = null;\r\n\r\n\t\tint nodeid = m_node.getNodeId();\r\n\r\n\t\tif (m_snmpcoll.hasIpNetToMediaTable()) {\r\n\t\t\tite = m_snmpcoll.getIpNetToMediaTable()\r\n\t\t\t\t\t.getEntries().iterator();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving IpNetToMediaTable to atinterface table in DB\");\r\n\t\t\t// the AtInterfaces used by LinkableNode where to save info\r\n\t\t\tjava.util.List<AtInterface> atInterfaces = new java.util.ArrayList<AtInterface>();\r\n\t\t\twhile (ite.hasNext()) {\r\n\r\n\t\t\t\tIpNetToMediaTableEntry ent = (IpNetToMediaTableEntry) ite\r\n\t\t\t\t\t\t.next();\r\n\t\t\t\t\r\n\t\t\t\tint ifindex = ent\r\n\t\t\t\t\t\t.getInt32(IpNetToMediaTableEntry.INTM_INDEX);\r\n\t\t\t\t\r\n\t\t\t\tInetAddress ipaddress = ent\r\n\t\t\t\t\t\t.getIPAddress(IpNetToMediaTableEntry.INTM_NETADDR);\r\n\r\n\t\t\t\tif (ipaddress.isLoopbackAddress() || ipaddress.getHostAddress().equals(\"0.0.0.0\")) {\r\n\t\t\t\t\tlog.warn(\"store: invalid ip \" + ipaddress.getHostAddress());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tString physAddr = ent\r\n\t\t\t\t\t\t.getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\r\n\t\t\t\t\r\n\t\t\t\tif (physAddr.equals(\"000000000000\") || physAddr.equalsIgnoreCase(\"ffffffffffff\")) {\r\n\t\t\t\t\tlog.warn(\"store: invalid mac address \" + physAddr\r\n\t\t\t\t\t\t\t+ \" for ip \" + ipaddress.getHostAddress());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\tlog.debug(\"store: trying save info for ipaddr \" + ipaddress.getHostName()\r\n\t\t\t\t\t\t\t+ \" mac address \" + physAddr + \" found on ifindex \"\r\n\t\t\t\t\t\t\t+ ifindex);\r\n\r\n\t\t\t\t// get an At interface but without setting mac address\r\n\t\t\t\tAtInterface at = getNodeidIfindexFromIp(dbConn, ipaddress);\r\n\t\t\t\tif (at == null) {\r\n\t\t\t\t\t\tlog.warn(\"getNodeidIfindexFromIp: no nodeid found for ipaddress \"\r\n\t\t\t\t\t\t\t\t+ ipaddress + \".\");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t\t//TODO here is a good place for autodiscovery\r\n\t\t\t\t}\r\n\t\t\t\t//set the mac address\r\n\t\t\t\tat.setMacAddress(physAddr);\r\n\t\t\t\t// add At Inteface to list of valid interfaces\r\n\t\t\t\tatInterfaces.add(at);\r\n\r\n\t\t\t\t// Save in DB\r\n\t\t\t\tDbAtInterfaceEntry atInterfaceEntry = DbAtInterfaceEntry.get(\r\n\t\t\t\t\t\tdbConn, at.getNodeId(), ipaddress.getHostAddress());\r\n\t\t\t\tif (atInterfaceEntry == null) {\r\n\t\t\t\t\tatInterfaceEntry = DbAtInterfaceEntry.create(at.getNodeId(),\r\n\t\t\t\t\t\t\tipaddress.getHostAddress());\r\n\t\t\t\t}\r\n\t\t\t\t// update object\r\n\r\n\t\t\t\tatInterfaceEntry.updateAtPhysAddr(physAddr);\r\n\r\n\t\t\t\tatInterfaceEntry.updateSourceNodeId(nodeid);\r\n\t\t\t\tatInterfaceEntry.updateIfIndex(ifindex);\r\n\t\t\t\tatInterfaceEntry.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);\r\n\t\t\t\tatInterfaceEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t// store object in database\r\n\t\t\t\tatInterfaceEntry.store(dbConn);\r\n\t\t\t}\r\n\t\t\t// set AtInterfaces in LinkableNode\r\n\t\t\tm_node.setAtInterfaces(atInterfaces);\r\n\t\t}\r\n\r\n\t\tif (m_snmpcoll.hasCdpCacheTable()) {\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving CdpCacheTable into SnmpLinkableNode\");\r\n\t\t\tjava.util.List<CdpInterface> cdpInterfaces = new java.util.ArrayList<CdpInterface>();\r\n\t\t\tite = m_snmpcoll.getCdpCacheTable()\r\n\t\t\t\t\t.getEntries().iterator();\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tCdpCacheTableEntry cdpEntry = (CdpCacheTableEntry) ite.next();\r\n\t\t\t\tint cdpAddrType = cdpEntry.getInt32(CdpCacheTableEntry.CDP_ADDRESS_TYPE);\r\n\r\n\t\t\t\tif (cdpAddrType != 1)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tString cdptargetipaddress = cdpEntry.getHexString(CdpCacheTableEntry.CDP_ADDRESS);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ip address octet string is \" + cdptargetipaddress);\r\n\r\n\t\t\t\tlong ipAddr = Long.parseLong(cdptargetipaddress, 16);\r\n\t\t\t\tbyte[] bytes = new byte[4];\r\n\t\t\t\tbytes[3] = (byte) (ipAddr & 0xff);\r\n\t\t\t\tbytes[2] = (byte) ((ipAddr >> 8) & 0xff);\r\n\t\t\t\tbytes[1] = (byte) ((ipAddr >> 16) & 0xff);\r\n\t\t\t\tbytes[0] = (byte) ((ipAddr >> 24) & 0xff);\r\n\t\t\t\t                         \r\n\t\t\t\tInetAddress cdpTargetIpAddr = InetAddress.getByAddress(bytes);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ip address after parsing is \" + cdpTargetIpAddr.getHostAddress());\r\n\t\t\t\t\r\n\t\t\t\tint cdpIfIndex = cdpEntry.getInt32(CdpCacheTableEntry.CDP_IFINDEX);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ifindex is \" + cdpIfIndex);\r\n\r\n\t\t\t\tString cdpTargetDevicePort = cdpEntry.getDisplayString(CdpCacheTableEntry.CDP_DEVICEPORT);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp Target device port name is \" + cdpTargetDevicePort);\r\n\r\n\r\n\t\t\t\tCdpInterface cdpIface = new CdpInterface(cdpIfIndex);\r\n\r\n\t\t\t\tint targetCdpNodeId = getNodeidFromIp(dbConn, cdpTargetIpAddr);\r\n\r\n\t\t\t\tcdpIface.setCdpTargetNodeId(targetCdpNodeId);\r\n\t\t\t\tcdpIface.setCdpTargetIpAddr(cdpTargetIpAddr);\r\n\t\t\t\t\r\n\t\t\t\tint cdpTargetIfindex = getIfIndexByName(\r\n\t\t\t\t\t\tdbConn, targetCdpNodeId, cdpTargetDevicePort);\r\n\r\n\t\t\t\tif (targetCdpNodeId == -1 || cdpTargetIfindex == -1) {\r\n\t\t\t\t\tlog.warn(\"No nodeid found: cdp interface not added to Linkable Snmp Node\");\r\n\t\t\t\t\t//TODO Good place for autodiscovery\r\n\t\t\t\t} else  {\r\n\r\n\t\t\t\t\tcdpIface.setCdpTargetIfIndex(cdpTargetIfindex);\r\n\t\t\t\t\tcdpInterfaces.add(cdpIface);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tm_node.setCdpInterfaces(cdpInterfaces);\r\n\t\t}\r\n\r\n\t\tif (m_snmpcoll.hasRouteTable()) {\r\n\t\t\tjava.util.List<RouterInterface> routeInterfaces = new java.util.ArrayList<RouterInterface>();\r\n\t\t\tite = m_snmpcoll.getIpRouteTable().getEntries()\r\n\t\t\t\t\t.iterator();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving ipRouteTable to iprouteinterface table in DB\");\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tIpRouteTableEntry ent = (IpRouteTableEntry) ite.next();\r\n                \r\n                log.debug(\"storeSnmpCollection: ent=\"+ent);\r\n\r\n\t\t\t\tInetAddress routedest = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_DEST);\r\n                log.debug(\"storeSnmpCollection: routedest is: \"+ (routedest == null ? \"null\" : routedest)+\"; IP_ROUTE_DEST: \"+IpRouteTableEntry.IP_ROUTE_DEST);\r\n                    \r\n\t\t\t\tInetAddress routemask = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_MASK);\r\n                log.debug(\"storeSnmpCollection: routemask is: \"+ (routemask == null ? \"null\" : routemask)+\"; IP_ROUTE_MASK: \"+IpRouteTableEntry.IP_ROUTE_MASK);\r\n                \r\n\t\t\t\tInetAddress nexthop = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_NXTHOP);\r\n                log.debug(\"storeSnmpCollection: nexthop is: \"+ (nexthop == null ? \"null\" : nexthop)+\"; IP_ROUTE_NXTHOP: \"+IpRouteTableEntry.IP_ROUTE_NXTHOP);\r\n                \r\n\t\t\t\tint ifindex = ent.getInt32(IpRouteTableEntry.IP_ROUTE_IFINDEX);\r\n                log.debug(\"storeSnmpCollection: ifindex is: \"+ (ifindex < 1 ? \"less than 1\" : ifindex)+\"; IP_ROUTE_IFINDEX: \"+IpRouteTableEntry.IP_ROUTE_IFINDEX);\r\n                \r\n\t\t\t\tint routemetric1 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC1);\r\n                log.debug(\"storeSnmpCollection: routemetric1 is: \"+ (routemetric1 < 1 ? \"less than 1\" : routemetric1)+\"; IP_ROUTE_METRIC1: \"+IpRouteTableEntry.IP_ROUTE_METRIC1);\r\n                \r\n                log.debug(\"storeSnmpCollection: ent=\"+ent);\r\n                log.debug(\"storeSnmpCollection: IP_ROUTE_METRIC2=\"+IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n\t\t\t\tint routemetric2 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n                log.debug(\"storeSnmpCollection: routemetric2 is: \"+ (routemetric2 < 1 ? \"less than 1\" : routemetric2)+\"; IP_ROUTE_METRIC2: \"+IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n                \r\n\t\t\t\tint routemetric3  =ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC3);\r\n                log.debug(\"storeSnmpCollection: routemetric3 is: \"+ (routemetric3 < 1 ? \"less than 1\" : routemetric3)+\"; IP_ROUTE_METRIC3: \"+IpRouteTableEntry.IP_ROUTE_METRIC3);\r\n                \r\n\t\t\t\tint routemetric4 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC4);\r\n                log.debug(\"storeSnmpCollection: routemetric4 is: \"+ (routemetric4 < 1 ? \"less than 1\" : routemetric4)+\"; IP_ROUTE_METRIC4: \"+IpRouteTableEntry.IP_ROUTE_METRIC4);\r\n                \r\n\t\t\t\tint routemetric5 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC5);\r\n                log.debug(\"storeSnmpCollection: routemetric5 is: \"+ (routemetric5 < 1 ? \"less than 1\" : routemetric5)+\"; IP_ROUTE_METRIC5: \"+IpRouteTableEntry.IP_ROUTE_METRIC5);\r\n                \r\n\t\t\t\tint routetype = ent.getInt32(IpRouteTableEntry.IP_ROUTE_TYPE);\r\n                log.debug(\"storeSnmpCollection: routetype is: \"+ (routetype < 1 ? \"less than 1\" : routetype)+\"; IP_ROUTE_TYPE: \"+IpRouteTableEntry.IP_ROUTE_TYPE);\r\n                \r\n\t\t\t\tint routeproto = ent.getInt32(IpRouteTableEntry.IP_ROUTE_PROTO);\r\n                log.debug(\"storeSnmpCollection: routeproto is: \"+ (routeproto < 1 ? \"less than 1\" : routeproto)+\"; IP_ROUTE_PROTO: \"+IpRouteTableEntry.IP_ROUTE_PROTO);\r\n                \r\n\r\n\t\t\t\t// info used for Discovery Link\r\n\t\t\t\tRouterInterface routeIface = new RouterInterface(ifindex);\r\n\t\t\t\trouteIface.setMetric(routemetric1);\r\n\t\t\t\trouteIface.setNextHop(nexthop);\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tint nodeParentId = getNodeidFromIp(dbConn,nexthop);\r\n\t\t\t\t\r\n\t\t\t\tif (nodeParentId == -1) {\r\n\t\t\t\t\t//TODO here is a good point for autodiscovery\r\n\t\t\t\t\tlog.warn(\"store: No nodeid found for next hop \" + nexthop \r\n\t\t\t\t\t\t\t+ \" Skipping ip route interface add to Linkable Snmp Node\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\trouteIface.setNodeparentid(nodeParentId);\r\n\t\t\t\t\trouteIface.setSnmpiftype(getSnmpIfType(dbConn, nodeid, ifindex));\r\n\t\t\t\t\t\r\n\t\t\t\t\trouteInterfaces.add(routeIface);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// save info to DB\r\n\t\t\t\tDbIpRouteInterfaceEntry iprouteInterfaceEntry = DbIpRouteInterfaceEntry\r\n\t\t\t\t\t\t.get(dbConn, nodeid, routedest.getHostAddress());\r\n\t\t\t\tif (iprouteInterfaceEntry == null) {\r\n\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\tiprouteInterfaceEntry = DbIpRouteInterfaceEntry.create(\r\n\t\t\t\t\t\t\tm_node.getNodeId(), routedest.getHostAddress());\r\n\t\t\t\t}\r\n\t\t\t\t// update object\r\n\t\t\t\tiprouteInterfaceEntry.updateRouteMask(routemask.getHostAddress());\r\n\t\t\t\tiprouteInterfaceEntry.updateRouteNextHop(nexthop.getHostAddress());\r\n\t\t\t\tiprouteInterfaceEntry.updateIfIndex(ifindex);\r\n\t\t\t\tif (routemetric1 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric1(routemetric1);\r\n\t\t\t\tif (routemetric2 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric2(routemetric2);\r\n\t\t\t\tif (routemetric3 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric3(routemetric3);\r\n\t\t\t\tif (routemetric4 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric4(routemetric4);\r\n\t\t\t\tif (routemetric5 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric5(routemetric5);\r\n\t\t\t\tif (routetype != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteType(routetype);\r\n\t\t\t\tif (routeproto != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteProto(routeproto);\r\n\t\t\t\tiprouteInterfaceEntry\r\n\t\t\t\t\t\t.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);\r\n\t\t\t\tiprouteInterfaceEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t// store object in database\r\n\t\t\t\tiprouteInterfaceEntry.store(dbConn);\r\n\t\t\t}\r\n\t\t\tm_node.setRouteInterfaces(routeInterfaces);\r\n\t\t}\r\n\t\t// STARTS loop on vlans\r\n\r\n\t\tif (m_snmpcoll.hasVlanTable()) {\r\n\t\t\t\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving SnmpVlanCollection in DB\");\r\n\t\t\tite = m_snmpcoll.getSnmpVlanCollections()\r\n\t\t\t\t\t.iterator();\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tSnmpVlanCollection snmpVlanColl = (SnmpVlanCollection) ite\r\n\t\t\t\t\t\t.next();\r\n\r\n\t\t\t\tString vlanindex = snmpVlanColl.getVlanIndex();\r\n\t\t\t\tint vlan = Integer.parseInt(vlanindex);\r\n\t\t\t\tString vlanname = snmpVlanColl.getVlanName();\r\n\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t.debug(\"store: parsing VLAN \"\r\n\t\t\t\t\t\t\t\t\t+ vlanindex + \" VLAN_NAME \" + vlanname);\r\n\r\n\t\t\t\tif (snmpVlanColl.hasDot1dBase()) {\r\n\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t.debug(\"store: saving Dot1dBaseGroup in stpnode table\");\r\n\r\n\t\t\t\t\tDot1dBaseGroup dod1db = (Dot1dBaseGroup) snmpVlanColl.getDot1dBase();\r\n\t\t\t\t\tString baseBridgeAddress = dod1db.getBridgeAddress();\r\n\t\t\t\t\tint basenumports = dod1db.getNumberOfPorts();\r\n\t\t\t\t\tint bridgetype = dod1db.getBridgeType();\r\n\t\t\t\t\t\r\n\r\n\t\t\t\t\tif (baseBridgeAddress == \"000000000000\") {\r\n\t\t\t\t\t\tlog.warn(\"store: base bridge address \" + baseBridgeAddress\r\n\t\t\t\t\t\t\t\t+ \" is invalid for ipaddress \" );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm_node.addBridgeIdentifier(baseBridgeAddress,vlanindex);\r\n\t\t\t\t\t\tDbStpNodeEntry dbStpNodeEntry = DbStpNodeEntry.get(dbConn,\r\n\t\t\t\t\t\t\tm_node.getNodeId(), vlan);\r\n\t\t\t\t\t\tif (dbStpNodeEntry == null) {\r\n\t\t\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\t\t\tdbStpNodeEntry = DbStpNodeEntry.create(m_node\r\n\t\t\t\t\t\t\t\t.getNodeId(), vlan);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// update object\r\n\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseBridgeAddress(baseBridgeAddress);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseNumPorts(basenumports);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseType(bridgetype);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseVlanName(vlanname);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dStp()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\"store: adding Dot1dStpGroup in stpnode table\");\r\n\r\n\t\t\t\t\t\t\tDot1dStpGroup dod1stp = (Dot1dStpGroup) snmpVlanColl\r\n\t\t\t\t\t\t\t\t.getDot1dStp();\r\n\t\t\t\t\t\t\tint protospec = dod1stp.getStpProtocolSpecification();\r\n\t\t\t\t\t\t\tint stppriority = dod1stp.getStpPriority();\r\n\t\t\t\t\t\t\tString stpDesignatedRoot = dod1stp.getStpDesignatedRoot();\r\n\t\t\t\t\t\t\tint stprootcost = dod1stp.getStpRootCost();\r\n\t\t\t\t\t\t\tint stprootport = dod1stp.getStpRootPort();\r\n\r\n\t\t\t\t\t\t\tif (stpDesignatedRoot != \"0000000000000000\") {\r\n\t\t\t\t\t\t\t\tm_node.setVlanStpRoot(vlanindex,stpDesignatedRoot);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpProtocolSpecification(protospec);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpPriority(stppriority);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpDesignatedRoot(stpDesignatedRoot);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpRootCost(stprootcost);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpRootPort(stprootport);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t// store object in database\r\n\t\t\t\t\t\tdbStpNodeEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\tdbStpNodeEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\tdbStpNodeEntry.store(dbConn);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dBasePortTable()) {\r\n\t\t\t\t\t\t\tIterator sub_ite = snmpVlanColl.getDot1dBasePortTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\"store: saving Dot1dBasePortTable in stpinterface table\");\r\n\t\t\t\t\t\t\twhile (sub_ite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dBasePortTableEntry dot1dbaseptentry = (Dot1dBasePortTableEntry) sub_ite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tint baseport = dot1dbaseptentry.getInt32(Dot1dBasePortTableEntry.BASE_PORT);\r\n\t\t\t\t\t\t\t\tint ifindex = dot1dbaseptentry.getInt32(Dot1dBasePortTableEntry.BASE_IFINDEX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tm_node.setIfIndexBridgePort(ifindex,baseport);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tDbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry\r\n\t\t\t\t\t\t\t\t\t.get(dbConn, m_node.getNodeId(),\r\n\t\t\t\t\t\t\t\t\t\t\tbaseport, vlan);\r\n\t\t\t\t\t\t\t\tif (dbStpIntEntry == null) {\r\n\t\t\t\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry = DbStpInterfaceEntry.create(\r\n\t\t\t\t\t\t\t\t\t\tm_node.getNodeId(), baseport, vlan);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.updateIfIndex(ifindex);\r\n\r\n\t\t\t\t\t\t\t\tdbStpIntEntry\r\n\t\t\t\t\t\t\t\t\t.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.store(dbConn);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dStpPortTable()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\" store: adding Dot1dStpPortTable in stpinterface table\");\r\n\t\t\t\t\t\t\tIterator sub_ite = snmpVlanColl.getDot1dStpPortTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\twhile (sub_ite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dStpPortTableEntry dot1dstpptentry = (Dot1dStpPortTableEntry) sub_ite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tint stpport = dot1dstpptentry.getInt32(Dot1dStpPortTableEntry.STP_PORT);\r\n\t\t\t\t\t\t\t\tDbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry\r\n\t\t\t\t\t\t\t\t\t.get(dbConn, m_node.getNodeId(),\r\n\t\t\t\t\t\t\t\t\t\t\tstpport, vlan);\r\n\t\t\t\t\t\t\t\tif (dbStpIntEntry == null) {\r\n\t\t\t\t\t\t\t\t// Cannot create the object becouse must exists the dot1dbase\r\n\t\t\t\t\t\t\t\t// object!!!!!\r\n\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.warn(\"store StpInterface: when storing STP info\"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for bridge node with nodeid \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ m_node.getNodeId()\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" bridgeport number \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ stpport\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" and vlan index \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ vlanindex\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" info not found in database, ERROR skipping.....\");\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tint stpportstate = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_STATE);\r\n\t\t\t\t\t\t\t\t\tint stpportpathcost = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_PATH_COST);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedBridge = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_BRIDGE);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedRoot = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_ROOT);\r\n\t\t\t\t\t\t\t\t\tint stpportdesignatedcost = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_COST);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedPort = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_PORT);\r\n\t\t\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\t\t\t\tif (stpPortDesignatedBridge.equals(\"0000000000000000\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog.warn(\"storeSnmpCollection: designated bridge is invalid not adding to discoveryLink\");\r\n\t\t\t\t\t\t\t\t\t} else if (stpPortDesignatedPort.equals(\"0000\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog.warn(\"storeSnmpCollection: designated port is invalid not adding to discoveryLink\");\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tBridgeStpInterface stpIface = new BridgeStpInterface(stpport,vlanindex);\r\n\t\t\t\t\t\t\t\t\t\tstpIface.setStpPortDesignatedBridge(stpPortDesignatedBridge);\r\n\t\t\t\t\t\t\t\t\t\tstpIface.setStpPortDesignatedPort(stpPortDesignatedPort);\r\n\t\t\t\t\t\t\t\t\t\tm_node.addStpInterface(stpIface);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortState(stpportstate);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortPathCost(stpportpathcost);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedBridge(stpPortDesignatedBridge);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedRoot(stpPortDesignatedRoot);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortDesignatedCost(stpportdesignatedcost);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedPort(stpPortDesignatedPort);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.store(dbConn);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dTpFdbTable()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t.debug(\"store: parsing Dot1dTpFdbTable\");\r\n\r\n\t\t\t\t\t\t\tIterator subite = snmpVlanColl.getDot1dFdbTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\twhile (subite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dTpFdbTableEntry dot1dfdbentry = (Dot1dTpFdbTableEntry) subite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tString curMacAddress = dot1dfdbentry\r\n\t\t\t\t\t\t\t\t\t.getHexString(Dot1dTpFdbTableEntry.FDB_ADDRESS);\r\n\r\n\t\t\t\t\t\t\t\tint fdbport = dot1dfdbentry.getInt32(Dot1dTpFdbTableEntry.FDB_PORT);\r\n\r\n\t\t\t\t\t\t\t\tif (fdbport == 0) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"populateBridge: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" learned on invalid port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tint curfdbstatus = dot1dfdbentry.getInt32(Dot1dTpFdbTableEntry.FDB_STATUS);\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_LEARNED) {\r\n\t\t\t\t\t\t\t\t\tm_node.addMacAddress(fdbport,\r\n\t\t\t\t\t\t\t\t\t\tcurMacAddress, vlanindex);\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.debug(\"storeSnmpCollection: found learned mac address \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" on bridge port \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ fdbport\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for VLAN \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ snmpVlanColl.getVlanIndex());\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_SELF) {\r\n\t\t\t\t\t\t\t\t\tm_node.addBridgeIdentifier(curMacAddress);\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.debug(\"storeSnmpCollection: found bridge identifier \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for VLAN \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ snmpVlanColl.getVlanIndex()\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" and bridge port \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ fdbport);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_INVALID) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has INVALID status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_MGMT) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has MGMT status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_OTHER) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has OTHER status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//now adding bridge identifier mac addresses of switch from snmpinterface\r\n\t\t\t\t\t\tsetBridgeIdentifierFromSnmpInterface(dbConn);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tupdate(dbConn, now);\r\n\t\t\r\n\t}","id":76964,"modified_method":"/**\r\n\t * \r\n\t * @param dbConn\r\n\t * @param now\r\n\t * @throws SQLException\r\n\t */\r\n\tprivate void storeSnmpCollection(Connection dbConn, Timestamp now) throws SQLException,\r\n\t\t\tUnknownHostException {\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\tIterator ite = null;\r\n\r\n\t\tint nodeid = m_node.getNodeId();\r\n\r\n\t\tif (m_snmpcoll.hasIpNetToMediaTable()) {\r\n\t\t\tite = m_snmpcoll.getIpNetToMediaTable()\r\n\t\t\t\t\t.getEntries().iterator();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving IpNetToMediaTable to atinterface table in DB\");\r\n\t\t\t// the AtInterfaces used by LinkableNode where to save info\r\n\t\t\tjava.util.List<AtInterface> atInterfaces = new java.util.ArrayList<AtInterface>();\r\n\t\t\twhile (ite.hasNext()) {\r\n\r\n\t\t\t\tIpNetToMediaTableEntry ent = (IpNetToMediaTableEntry) ite\r\n\t\t\t\t\t\t.next();\r\n\t\t\t\t\r\n\t\t\t\tint ifindex = ent\r\n\t\t\t\t\t\t.getInt32(IpNetToMediaTableEntry.INTM_INDEX);\r\n\t\t\t\t\r\n\t\t\t\tInetAddress ipaddress = ent\r\n\t\t\t\t\t\t.getIPAddress(IpNetToMediaTableEntry.INTM_NETADDR);\r\n\r\n\t\t\t\tif (ipaddress.isLoopbackAddress() || ipaddress.getHostAddress().equals(\"0.0.0.0\")) {\r\n\t\t\t\t\tlog.warn(\"store: invalid ip \" + ipaddress.getHostAddress());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tString physAddr = ent\r\n\t\t\t\t\t\t.getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\r\n\t\t\t\t\r\n\t\t\t\tif (physAddr.equals(\"000000000000\") || physAddr.equalsIgnoreCase(\"ffffffffffff\")) {\r\n\t\t\t\t\tlog.warn(\"store: invalid mac address \" + physAddr\r\n\t\t\t\t\t\t\t+ \" for ip \" + ipaddress.getHostAddress());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\tlog.debug(\"store: trying save info for ipaddr \" + ipaddress.getHostName()\r\n\t\t\t\t\t\t\t+ \" mac address \" + physAddr + \" found on ifindex \"\r\n\t\t\t\t\t\t\t+ ifindex);\r\n\r\n\t\t\t\t// get an At interface but without setting mac address\r\n\t\t\t\tAtInterface at = getNodeidIfindexFromIp(dbConn, ipaddress);\r\n\t\t\t\tif (at == null) {\r\n\t\t\t\t\t\tlog.warn(\"getNodeidIfindexFromIp: no nodeid found for ipaddress \"\r\n\t\t\t\t\t\t\t\t+ ipaddress + \".\");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t\t//TODO here is a good place for autodiscovery\r\n\t\t\t\t}\r\n\t\t\t\t//set the mac address\r\n\t\t\t\tat.setMacAddress(physAddr);\r\n\t\t\t\t// add At Inteface to list of valid interfaces\r\n\t\t\t\tatInterfaces.add(at);\r\n\r\n\t\t\t\t// Save in DB\r\n\t\t\t\tDbAtInterfaceEntry atInterfaceEntry = DbAtInterfaceEntry.get(\r\n\t\t\t\t\t\tdbConn, at.getNodeId(), ipaddress.getHostAddress());\r\n\t\t\t\tif (atInterfaceEntry == null) {\r\n\t\t\t\t\tatInterfaceEntry = DbAtInterfaceEntry.create(at.getNodeId(),\r\n\t\t\t\t\t\t\tipaddress.getHostAddress());\r\n\t\t\t\t}\r\n\t\t\t\t// update object\r\n\r\n\t\t\t\tatInterfaceEntry.updateAtPhysAddr(physAddr);\r\n\r\n\t\t\t\tatInterfaceEntry.updateSourceNodeId(nodeid);\r\n\t\t\t\tatInterfaceEntry.updateIfIndex(ifindex);\r\n\t\t\t\tatInterfaceEntry.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);\r\n\t\t\t\tatInterfaceEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t// store object in database\r\n\t\t\t\tatInterfaceEntry.store(dbConn);\r\n\t\t\t}\r\n\t\t\t// set AtInterfaces in LinkableNode\r\n\t\t\tm_node.setAtInterfaces(atInterfaces);\r\n\t\t}\r\n\r\n\t\tif (m_snmpcoll.hasCdpCacheTable()) {\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving CdpCacheTable into SnmpLinkableNode\");\r\n\t\t\tjava.util.List<CdpInterface> cdpInterfaces = new java.util.ArrayList<CdpInterface>();\r\n\t\t\tite = m_snmpcoll.getCdpCacheTable()\r\n\t\t\t\t\t.getEntries().iterator();\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tCdpCacheTableEntry cdpEntry = (CdpCacheTableEntry) ite.next();\r\n\t\t\t\tint cdpAddrType = cdpEntry.getInt32(CdpCacheTableEntry.CDP_ADDRESS_TYPE);\r\n\r\n\t\t\t\tif (cdpAddrType != 1)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tString cdptargetipaddress = cdpEntry.getHexString(CdpCacheTableEntry.CDP_ADDRESS);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ip address octet string is \" + cdptargetipaddress);\r\n\r\n\t\t\t\tlong ipAddr = Long.parseLong(cdptargetipaddress, 16);\r\n\t\t\t\tbyte[] bytes = new byte[4];\r\n\t\t\t\tbytes[3] = (byte) (ipAddr & 0xff);\r\n\t\t\t\tbytes[2] = (byte) ((ipAddr >> 8) & 0xff);\r\n\t\t\t\tbytes[1] = (byte) ((ipAddr >> 16) & 0xff);\r\n\t\t\t\tbytes[0] = (byte) ((ipAddr >> 24) & 0xff);\r\n\t\t\t\t                         \r\n\t\t\t\tInetAddress cdpTargetIpAddr = InetAddress.getByAddress(bytes);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ip address after parsing is \" + cdpTargetIpAddr.getHostAddress());\r\n\t\t\t\t\r\n\t\t\t\tint cdpIfIndex = cdpEntry.getInt32(CdpCacheTableEntry.CDP_IFINDEX);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ifindex is \" + cdpIfIndex);\r\n\r\n\t\t\t\tString cdpTargetDevicePort = cdpEntry.getDisplayString(CdpCacheTableEntry.CDP_DEVICEPORT);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp Target device port name is \" + cdpTargetDevicePort);\r\n\r\n\r\n\t\t\t\tCdpInterface cdpIface = new CdpInterface(cdpIfIndex);\r\n\r\n\t\t\t\tint targetCdpNodeId = getNodeidFromIp(dbConn, cdpTargetIpAddr);\r\n\r\n\t\t\t\tcdpIface.setCdpTargetNodeId(targetCdpNodeId);\r\n\t\t\t\tcdpIface.setCdpTargetIpAddr(cdpTargetIpAddr);\r\n\t\t\t\t\r\n\t\t\t\tint cdpTargetIfindex = getIfIndexByName(\r\n\t\t\t\t\t\tdbConn, targetCdpNodeId, cdpTargetDevicePort);\r\n\r\n\t\t\t\tif (targetCdpNodeId == -1 || cdpTargetIfindex == -1) {\r\n\t\t\t\t\tlog.warn(\"No nodeid found: cdp interface not added to Linkable Snmp Node\");\r\n\t\t\t\t\t//TODO Good place for autodiscovery\r\n\t\t\t\t} else  {\r\n\r\n\t\t\t\t\tcdpIface.setCdpTargetIfIndex(cdpTargetIfindex);\r\n\t\t\t\t\tcdpInterfaces.add(cdpIface);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tm_node.setCdpInterfaces(cdpInterfaces);\r\n\t\t}\r\n\r\n\t\tif (m_snmpcoll.hasRouteTable()) {\r\n\t\t\tjava.util.List<RouterInterface> routeInterfaces = new java.util.ArrayList<RouterInterface>();\r\n\t\t\t\r\n\t\t\tite = m_snmpcoll.getIpRouteTable().getEntries()\r\n\t\t\t\t\t.iterator();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving ipRouteTable to iprouteinterface table in DB\");\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tIpRouteTableEntry ent = (IpRouteTableEntry) ite.next();\r\n                \r\n                log.debug(\"storeSnmpCollection: ent=\"+ent);\r\n\r\n\t\t\t\tInetAddress routedest = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_DEST);\r\n                log.debug(\"storeSnmpCollection: routedest is: \"+ (routedest == null ? \"null\" : routedest)+\"; IP_ROUTE_DEST: \"+IpRouteTableEntry.IP_ROUTE_DEST);\r\n                    \r\n\t\t\t\tInetAddress routemask = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_MASK);\r\n                log.debug(\"storeSnmpCollection: routemask is: \"+ (routemask == null ? \"null\" : routemask)+\"; IP_ROUTE_MASK: \"+IpRouteTableEntry.IP_ROUTE_MASK);\r\n                \r\n\t\t\t\tInetAddress nexthop = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_NXTHOP);\r\n                log.debug(\"storeSnmpCollection: nexthop is: \"+ (nexthop == null ? \"null\" : nexthop)+\"; IP_ROUTE_NXTHOP: \"+IpRouteTableEntry.IP_ROUTE_NXTHOP);\r\n                \r\n\t\t\t\tint ifindex = ent.getInt32(IpRouteTableEntry.IP_ROUTE_IFINDEX);\r\n                log.debug(\"storeSnmpCollection: ifindex is: \"+ (ifindex < 1 ? \"less than 1\" : ifindex)+\"; IP_ROUTE_IFINDEX: \"+IpRouteTableEntry.IP_ROUTE_IFINDEX);\r\n\r\n                if (ifindex < 0) {\r\n\t\t\t\t\tlog.warn(\"store: NNot valid ifindex\" + ifindex \r\n\t\t\t\t\t\t\t+ \" Skipping...\");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n                \r\n\t\t\t\tint routemetric1 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC1);\r\n                log.debug(\"storeSnmpCollection: routemetric1 is: \"+ (routemetric1 < 1 ? \"less than 1\" : routemetric1)+\"; IP_ROUTE_METRIC1: \"+IpRouteTableEntry.IP_ROUTE_METRIC1);\r\n                \r\n                log.debug(\"storeSnmpCollection: ent=\"+ent);\r\n                log.debug(\"storeSnmpCollection: IP_ROUTE_METRIC2=\"+IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n\t\t\t\tint routemetric2 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n                log.debug(\"storeSnmpCollection: routemetric2 is: \"+ (routemetric2 < 1 ? \"less than 1\" : routemetric2)+\"; IP_ROUTE_METRIC2: \"+IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n                \r\n\t\t\t\tint routemetric3  =ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC3);\r\n                log.debug(\"storeSnmpCollection: routemetric3 is: \"+ (routemetric3 < 1 ? \"less than 1\" : routemetric3)+\"; IP_ROUTE_METRIC3: \"+IpRouteTableEntry.IP_ROUTE_METRIC3);\r\n                \r\n\t\t\t\tint routemetric4 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC4);\r\n                log.debug(\"storeSnmpCollection: routemetric4 is: \"+ (routemetric4 < 1 ? \"less than 1\" : routemetric4)+\"; IP_ROUTE_METRIC4: \"+IpRouteTableEntry.IP_ROUTE_METRIC4);\r\n                \r\n\t\t\t\tint routemetric5 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC5);\r\n                log.debug(\"storeSnmpCollection: routemetric5 is: \"+ (routemetric5 < 1 ? \"less than 1\" : routemetric5)+\"; IP_ROUTE_METRIC5: \"+IpRouteTableEntry.IP_ROUTE_METRIC5);\r\n                \r\n\t\t\t\tint routetype = ent.getInt32(IpRouteTableEntry.IP_ROUTE_TYPE);\r\n                log.debug(\"storeSnmpCollection: routetype is: \"+ (routetype < 1 ? \"less than 1\" : routetype)+\"; IP_ROUTE_TYPE: \"+IpRouteTableEntry.IP_ROUTE_TYPE);\r\n                \r\n\t\t\t\tint routeproto = ent.getInt32(IpRouteTableEntry.IP_ROUTE_PROTO);\r\n                log.debug(\"storeSnmpCollection: routeproto is: \"+ (routeproto < 1 ? \"less than 1\" : routeproto)+\"; IP_ROUTE_PROTO: \"+IpRouteTableEntry.IP_ROUTE_PROTO);\r\n                \r\n\r\n\t\t\t\t// info used for Discovery Link\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tRouterInterface routeIface = null;\r\n\t\t\t\trouteIface = getNodeidMaskFromIp(dbConn,nexthop);\r\n\r\n\t\t\t\t// if target node is not snmp node try to save info\r\n\t\t\t\tif (routeIface == null) {\r\n\t\t\t\t\trouteIface = getNodeFromIp(dbConn, nexthop);\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\tif (routeIface == null) {\r\n\t\t\t\t\t//TODO here is a good point for autodiscovery\r\n\t\t\t\t\tlog.warn(\"store: No nodeid found for next hop ip\" + nexthop \r\n\t\t\t\t\t\t\t+ \" Skipping ip route interface add to Linkable Snmp Node\");\r\n\t\t\t\t\t// try to find it in ipinterface\r\n\t\t\t\t} else {\r\n\t\t\t\t\tint snmpiftype = -2;\r\n\t\t\t\t\tif (ifindex > 0) snmpiftype = getSnmpIfType(dbConn, nodeid, ifindex);\r\n\r\n\t\t\t\t\t// no processing ethernet type\r\n\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\tlog.debug(\"store: interface has snmpiftype \"\r\n\t\t\t\t\t\t\t\t\t+ snmpiftype + \" . Adding to DiscoverLink \");\r\n\r\n\t\t\t\t\trouteIface.setSnmpiftype(snmpiftype);\r\n\t\t\t\t\trouteIface.setIfindex(ifindex);\r\n\t\t\t\t\trouteIface.setMetric(routemetric1);\r\n\t\t\t\t\trouteIface.setNextHop(nexthop);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\trouteInterfaces.add(routeIface);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// save info to DB\r\n\t\t\t\tDbIpRouteInterfaceEntry iprouteInterfaceEntry = DbIpRouteInterfaceEntry\r\n\t\t\t\t\t\t.get(dbConn, nodeid, routedest.getHostAddress());\r\n\t\t\t\tif (iprouteInterfaceEntry == null) {\r\n\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\tiprouteInterfaceEntry = DbIpRouteInterfaceEntry.create(\r\n\t\t\t\t\t\t\tm_node.getNodeId(), routedest.getHostAddress());\r\n\t\t\t\t}\r\n\t\t\t\t// update object\r\n\t\t\t\tiprouteInterfaceEntry.updateRouteMask(routemask.getHostAddress());\r\n\t\t\t\tiprouteInterfaceEntry.updateRouteNextHop(nexthop.getHostAddress());\r\n\t\t\t\tiprouteInterfaceEntry.updateIfIndex(ifindex);\r\n\t\t\t\tif (routemetric1 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric1(routemetric1);\r\n\t\t\t\tif (routemetric2 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric2(routemetric2);\r\n\t\t\t\tif (routemetric3 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric3(routemetric3);\r\n\t\t\t\tif (routemetric4 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric4(routemetric4);\r\n\t\t\t\tif (routemetric5 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric5(routemetric5);\r\n\t\t\t\tif (routetype != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteType(routetype);\r\n\t\t\t\tif (routeproto != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteProto(routeproto);\r\n\t\t\t\tiprouteInterfaceEntry\r\n\t\t\t\t\t\t.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);\r\n\t\t\t\tiprouteInterfaceEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t// store object in database\r\n\t\t\t\tiprouteInterfaceEntry.store(dbConn);\r\n\t\t\t}\r\n\t\t\tm_node.setRouteInterfaces(routeInterfaces);\r\n\t\t}\r\n\t\t// STARTS loop on vlans\r\n\r\n\t\tif (m_snmpcoll.hasVlanTable()) {\r\n\t\t\t\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving SnmpVlanCollection in DB\");\r\n\t\t\tite = m_snmpcoll.getSnmpVlanCollections()\r\n\t\t\t\t\t.iterator();\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tSnmpVlanCollection snmpVlanColl = (SnmpVlanCollection) ite\r\n\t\t\t\t\t\t.next();\r\n\r\n\t\t\t\tString vlanindex = snmpVlanColl.getVlanIndex();\r\n\t\t\t\tint vlan = Integer.parseInt(vlanindex);\r\n\t\t\t\tString vlanname = snmpVlanColl.getVlanName();\r\n\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t.debug(\"store: parsing VLAN \"\r\n\t\t\t\t\t\t\t\t\t+ vlanindex + \" VLAN_NAME \" + vlanname);\r\n\r\n\t\t\t\tif (snmpVlanColl.hasDot1dBase()) {\r\n\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t.debug(\"store: saving Dot1dBaseGroup in stpnode table\");\r\n\r\n\t\t\t\t\tDot1dBaseGroup dod1db = (Dot1dBaseGroup) snmpVlanColl.getDot1dBase();\r\n\t\t\t\t\tString baseBridgeAddress = dod1db.getBridgeAddress();\r\n\t\t\t\t\tint basenumports = dod1db.getNumberOfPorts();\r\n\t\t\t\t\tint bridgetype = dod1db.getBridgeType();\r\n\t\t\t\t\t\r\n\r\n\t\t\t\t\tif (baseBridgeAddress == \"000000000000\") {\r\n\t\t\t\t\t\tlog.warn(\"store: base bridge address \" + baseBridgeAddress\r\n\t\t\t\t\t\t\t\t+ \" is invalid for ipaddress \" );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm_node.addBridgeIdentifier(baseBridgeAddress,vlanindex);\r\n\t\t\t\t\t\tDbStpNodeEntry dbStpNodeEntry = DbStpNodeEntry.get(dbConn,\r\n\t\t\t\t\t\t\tm_node.getNodeId(), vlan);\r\n\t\t\t\t\t\tif (dbStpNodeEntry == null) {\r\n\t\t\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\t\t\tdbStpNodeEntry = DbStpNodeEntry.create(m_node\r\n\t\t\t\t\t\t\t\t.getNodeId(), vlan);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// update object\r\n\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseBridgeAddress(baseBridgeAddress);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseNumPorts(basenumports);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseType(bridgetype);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseVlanName(vlanname);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dStp()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\"store: adding Dot1dStpGroup in stpnode table\");\r\n\r\n\t\t\t\t\t\t\tDot1dStpGroup dod1stp = (Dot1dStpGroup) snmpVlanColl\r\n\t\t\t\t\t\t\t\t.getDot1dStp();\r\n\t\t\t\t\t\t\tint protospec = dod1stp.getStpProtocolSpecification();\r\n\t\t\t\t\t\t\tint stppriority = dod1stp.getStpPriority();\r\n\t\t\t\t\t\t\tString stpDesignatedRoot = dod1stp.getStpDesignatedRoot();\r\n\t\t\t\t\t\t\tint stprootcost = dod1stp.getStpRootCost();\r\n\t\t\t\t\t\t\tint stprootport = dod1stp.getStpRootPort();\r\n\r\n\t\t\t\t\t\t\tif (stpDesignatedRoot != \"0000000000000000\") {\r\n\t\t\t\t\t\t\t\tm_node.setVlanStpRoot(vlanindex,stpDesignatedRoot);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpProtocolSpecification(protospec);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpPriority(stppriority);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpDesignatedRoot(stpDesignatedRoot);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpRootCost(stprootcost);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpRootPort(stprootport);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t// store object in database\r\n\t\t\t\t\t\tdbStpNodeEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\tdbStpNodeEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\tdbStpNodeEntry.store(dbConn);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dBasePortTable()) {\r\n\t\t\t\t\t\t\tIterator sub_ite = snmpVlanColl.getDot1dBasePortTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\"store: saving Dot1dBasePortTable in stpinterface table\");\r\n\t\t\t\t\t\t\twhile (sub_ite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dBasePortTableEntry dot1dbaseptentry = (Dot1dBasePortTableEntry) sub_ite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tint baseport = dot1dbaseptentry.getInt32(Dot1dBasePortTableEntry.BASE_PORT);\r\n\t\t\t\t\t\t\t\tint ifindex = dot1dbaseptentry.getInt32(Dot1dBasePortTableEntry.BASE_IFINDEX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tm_node.setIfIndexBridgePort(ifindex,baseport);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tDbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry\r\n\t\t\t\t\t\t\t\t\t.get(dbConn, m_node.getNodeId(),\r\n\t\t\t\t\t\t\t\t\t\t\tbaseport, vlan);\r\n\t\t\t\t\t\t\t\tif (dbStpIntEntry == null) {\r\n\t\t\t\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry = DbStpInterfaceEntry.create(\r\n\t\t\t\t\t\t\t\t\t\tm_node.getNodeId(), baseport, vlan);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.updateIfIndex(ifindex);\r\n\r\n\t\t\t\t\t\t\t\tdbStpIntEntry\r\n\t\t\t\t\t\t\t\t\t.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.store(dbConn);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dStpPortTable()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\" store: adding Dot1dStpPortTable in stpinterface table\");\r\n\t\t\t\t\t\t\tIterator sub_ite = snmpVlanColl.getDot1dStpPortTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\twhile (sub_ite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dStpPortTableEntry dot1dstpptentry = (Dot1dStpPortTableEntry) sub_ite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tint stpport = dot1dstpptentry.getInt32(Dot1dStpPortTableEntry.STP_PORT);\r\n\t\t\t\t\t\t\t\tDbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry\r\n\t\t\t\t\t\t\t\t\t.get(dbConn, m_node.getNodeId(),\r\n\t\t\t\t\t\t\t\t\t\t\tstpport, vlan);\r\n\t\t\t\t\t\t\t\tif (dbStpIntEntry == null) {\r\n\t\t\t\t\t\t\t\t// Cannot create the object becouse must exists the dot1dbase\r\n\t\t\t\t\t\t\t\t// object!!!!!\r\n\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.warn(\"store StpInterface: when storing STP info\"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for bridge node with nodeid \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ m_node.getNodeId()\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" bridgeport number \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ stpport\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" and vlan index \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ vlanindex\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" info not found in database, ERROR skipping.....\");\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tint stpportstate = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_STATE);\r\n\t\t\t\t\t\t\t\t\tint stpportpathcost = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_PATH_COST);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedBridge = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_BRIDGE);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedRoot = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_ROOT);\r\n\t\t\t\t\t\t\t\t\tint stpportdesignatedcost = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_COST);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedPort = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_PORT);\r\n\t\t\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\t\t\t\tif (stpPortDesignatedBridge.equals(\"0000000000000000\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog.warn(\"storeSnmpCollection: designated bridge is invalid not adding to discoveryLink\");\r\n\t\t\t\t\t\t\t\t\t} else if (stpPortDesignatedPort.equals(\"0000\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog.warn(\"storeSnmpCollection: designated port is invalid not adding to discoveryLink\");\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tBridgeStpInterface stpIface = new BridgeStpInterface(stpport,vlanindex);\r\n\t\t\t\t\t\t\t\t\t\tstpIface.setStpPortDesignatedBridge(stpPortDesignatedBridge);\r\n\t\t\t\t\t\t\t\t\t\tstpIface.setStpPortDesignatedPort(stpPortDesignatedPort);\r\n\t\t\t\t\t\t\t\t\t\tm_node.addStpInterface(stpIface);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortState(stpportstate);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortPathCost(stpportpathcost);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedBridge(stpPortDesignatedBridge);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedRoot(stpPortDesignatedRoot);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortDesignatedCost(stpportdesignatedcost);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedPort(stpPortDesignatedPort);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.store(dbConn);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dTpFdbTable()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t.debug(\"store: parsing Dot1dTpFdbTable\");\r\n\r\n\t\t\t\t\t\t\tIterator subite = snmpVlanColl.getDot1dFdbTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\twhile (subite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dTpFdbTableEntry dot1dfdbentry = (Dot1dTpFdbTableEntry) subite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tString curMacAddress = dot1dfdbentry\r\n\t\t\t\t\t\t\t\t\t.getHexString(Dot1dTpFdbTableEntry.FDB_ADDRESS);\r\n\r\n\t\t\t\t\t\t\t\tint fdbport = dot1dfdbentry.getInt32(Dot1dTpFdbTableEntry.FDB_PORT);\r\n\r\n\t\t\t\t\t\t\t\tif (fdbport == 0) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"populateBridge: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" learned on invalid port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tint curfdbstatus = dot1dfdbentry.getInt32(Dot1dTpFdbTableEntry.FDB_STATUS);\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_LEARNED) {\r\n\t\t\t\t\t\t\t\t\tm_node.addMacAddress(fdbport,\r\n\t\t\t\t\t\t\t\t\t\tcurMacAddress, vlanindex);\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.debug(\"storeSnmpCollection: found learned mac address \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" on bridge port \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ fdbport\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for VLAN \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ snmpVlanColl.getVlanIndex());\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_SELF) {\r\n\t\t\t\t\t\t\t\t\tm_node.addBridgeIdentifier(curMacAddress);\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.debug(\"storeSnmpCollection: found bridge identifier \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for VLAN \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ snmpVlanColl.getVlanIndex()\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" and bridge port \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ fdbport);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_INVALID) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has INVALID status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_MGMT) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has MGMT status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_OTHER) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has OTHER status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//now adding bridge identifier mac addresses of switch from snmpinterface\r\n\t\t\t\t\t\tsetBridgeIdentifierFromSnmpInterface(dbConn);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tupdate(dbConn, now);\r\n\t\t\r\n\t}","commit_id":"eb38aaa965946932df8e0e4c3c65b6acd80be751","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * @param serviceName - the absolute name of the service\n\t * @param service - the service DSL or null if not exists\n\t * @param externalProcessMemoryInMB - MB memory allocated for the GSC plus the external service.\n\t * @return a @{link AutomaticCapacityScaleConfig} based on the specified service and memory.\n\t */\n\tprivate AutomaticCapacityScaleConfig createAutomaticCapacityScaleConfig(final String serviceName,\n\t\t\tfinal Service service, final int externalProcessMemoryInMB)\n\t\t\tthrows DSLException {\n\n\t\tScalingRuleDetails scalingRule = service.getScalingRules();\n\t\t\n\t\tif (service.getMinAllowedInstances() <= 0) {\n\t\t\tthrow new DSLException(\"Minimum number of instances (\" + service.getMinAllowedInstances()\n\t\t\t\t\t+ \") must be 1 or higher.\");\n\t\t}\n\n\t\tif (service.getMinAllowedInstances() > service.getMaxAllowedInstances()) {\n\t\t\tthrow new DSLException(\"maximum number of instances (\" + service.getMaxAllowedInstances()\n\t\t\t\t\t+ \") must be equal or greater than the minimum number of instances (\"\n\t\t\t\t\t+ service.getMinAllowedInstances() + \")\");\n\t\t}\n\n\t\tif (service.getMinAllowedInstances() > service.getNumInstances()) {\n\t\t\tthrow new DSLException(\"number of instances (\" + service.getNumInstances()\n\t\t\t\t\t+ \") must be equal or greater than the minimum number of instances (\"\n\t\t\t\t\t+ service.getMinAllowedInstances() + \")\");\n\t\t}\n\n\t\tif (service.getNumInstances() > service.getMaxAllowedInstances()) {\n\t\t\tthrow new DSLException(\"number of instances (\" + service.getNumInstances()\n\t\t\t\t\t+ \") must be equal or less than the maximum number of instances (\"\n\t\t\t\t\t+ service.getMaxAllowedInstances() + \")\");\n\t\t}\n\n\t\tMap<String, ServiceStatisticsDetails> serviceStatisticsByName = new HashMap<String, ServiceStatisticsDetails>();\n\t\tfor (AbstractStatisticsDetails calculatedStatistics : service.getServiceStatistics()) {\n\t\t\tif (calculatedStatistics instanceof ServiceStatisticsDetails) {\n\t\t\t\tserviceStatisticsByName.put(calculatedStatistics.getName(), (ServiceStatisticsDetails)calculatedStatistics);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (serviceStatisticsByName.isEmpty()) {\n\t\t\tthrow new DSLException(\"calculatedStatistics must define at least one serviceStatistics entry\");\n\t\t}\n\t\t\n\t\tString serviceStatisticsName = scalingRule.getStatistics();\n\t\tif (serviceStatisticsName == null) {\n\t\t\tthrow new DSLException(\"scalingRule must specify statistics (serviceStatistics name)\");\n\t\t}\n\t\t\n\t\tServiceStatisticsDetails serviceStatistics = serviceStatisticsByName.get(serviceStatisticsName);\n\t\t\n\t\tif (serviceStatistics == null) {\n\t\t\tthrow new DSLException(\"scalingRule must specify a valid statistics (serviceStatistics name). \" + serviceStatisticsName + \" is not recognized. Possible values are: \"+ serviceStatisticsByName.keySet());\n\t\t}\n\t\n\t\tProcessingUnitStatisticsId statisticsId = new ProcessingUnitStatisticsId();\n\t\tstatisticsId.setMonitor(CloudifyConstants.USM_MONITORS_SERVICE_ID);\n\t\tstatisticsId.setMetric(serviceStatistics.getMetric());\n\t\tstatisticsId.setInstancesStatistics(serviceStatistics.getInstancesStatistics().createInstancesStatistics());\n\n\t\tif (serviceStatistics.getMovingTimeRangeInSeconds() <= service.getSamplingPeriodInSeconds()) {\n\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\tlogger.fine(\"Deploying service \" + serviceName + \" with auto scaling that monitors the last sample of \"\n\t\t\t\t\t\t+ serviceStatistics.getMetric());\n\t\t\t}\n\t\t\tstatisticsId.setTimeWindowStatistics(new LastSampleTimeWindowStatisticsConfig());\n\t\t} else {\n\t\t\tstatisticsId.setTimeWindowStatistics(serviceStatistics.getTimeStatistics().createTimeWindowStatistics(\n\t\t\t\t\tserviceStatistics.getMovingTimeRangeInSeconds(), TimeUnit.SECONDS));\n\t\t}\n\n\t\tAutomaticCapacityScaleRuleConfig rule = new AutomaticCapacityScaleRuleConfig();\n\t\trule.setStatistics(statisticsId);\n\t\t\n\t\tif (scalingRule.getLowThreshold() == null){\n\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatisticsName +\" lowThreshold is undefined\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tComparable<?> threshold = scalingRule.getLowThreshold().getValue();\n\t\t\tif (threshold == null) {\n\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatisticsName +\" lowThreshold value is missing\");\n\t\t\t}\n\t\t\t\n\t\t\tint instancesDecrease = scalingRule.getLowThreshold().getInstancesDecrease ();\n\t\t\tif (instancesDecrease < 0) {\n\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatisticsName +\" lowThreshold instancesDecrease cannot be a negative number (\"+instancesDecrease+\")\");\n\t\t\t}\n\t\t\t\n\t\t\tif (instancesDecrease == 0) {\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatisticsName +\" lowThreshold instancesDecrease is 0\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trule.setLowThreshold(threshold);\n\t\t\t\trule.setLowThresholdBreachedDecrease(\n\t\t\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t\t\t.memoryCapacity(instancesDecrease * externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.create());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (scalingRule.getHighThreshold() == null) {\n\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatisticsName +\" highThreshold is undefined\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tComparable<?> threshold = scalingRule.getHighThreshold().getValue();\n\t\t\tif (threshold == null) {\n\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatisticsName +\" highThreshold value is missing\");\n\t\t\t}\n\t\t\t\n\t\t\tint instancesIncrease = scalingRule.getHighThreshold().getInstancesIncrease();\n\t\t\tif (instancesIncrease < 0) {\n\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatisticsName +\" highThreshold instancesIncrease cannot be a negative number (\"+instancesIncrease+\")\");\n\t\t\t}\n\t\t\t\n\t\t\tif (instancesIncrease == 0) {\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatisticsName +\" highThreshold instancesIncrease is 0\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trule.setHighThreshold(threshold);\n\t\t\t\trule.setHighThresholdBreachedIncrease(\n\t\t\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t\t\t.memoryCapacity(instancesIncrease * externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.create());\n\t\t\t}\n\t\t}\n\n\t\tCapacityRequirementsConfig minCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getMinAllowedInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.create();\n\n\t\tCapacityRequirementsConfig initialCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getNumInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.create();\n\n\n\t\tCapacityRequirementsConfig maxCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getMaxAllowedInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.create();\n\n\t\tAutomaticCapacityScaleConfig scaleConfig = \n\t\t\tnew AutomaticCapacityScaleConfigurer()\n\t\t\t.minCapacity(minCapacity)\n\t\t\t.initialCapacity(initialCapacity)\n\t\t\t.maxCapacity(maxCapacity)\n\t\t\t.statisticsPollingInterval(service.getSamplingPeriodInSeconds(), TimeUnit.SECONDS)\n\t\t\t.cooldownAfterScaleOut(service.getScaleOutCooldownInSeconds(),TimeUnit.SECONDS)\n\t\t\t.cooldownAfterScaleIn(service.getScaleInCooldownInSeconds(),TimeUnit.SECONDS)\n\t\t\t.addRule(rule)\n\t\t\t.create();\n\n\t\treturn scaleConfig;\n\t}","id":76965,"modified_method":"/**\n\t * @param serviceName - the absolute name of the service\n\t * @param service - the service DSL or null if not exists\n\t * @param externalProcessMemoryInMB - MB memory allocated for the GSC plus the external service.\n\t * @return a @{link AutomaticCapacityScaleConfig} based on the specified service and memory.\n\t */\n\tprivate AutomaticCapacityScaleConfig createAutomaticCapacityScaleConfig(final String serviceName,\n\t\t\tfinal Service service, final int externalProcessMemoryInMB)\n\t\t\tthrows DSLException {\n\n\t\tList<ScalingRuleDetails> scalingRules = service.getScalingRules();\n\t\tif (scalingRules.size() == 0) {\n\t\t\tthrow new DSLException(\"scalingRules cannot be empty\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() <= 0) {\n\t\t\tthrow new DSLException(\"Minimum number of instances (\" + service.getMinAllowedInstances()\n\t\t\t\t\t+ \") must be 1 or higher.\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() > service.getMaxAllowedInstances()) {\n\t\t\tthrow new DSLException(\"maximum number of instances (\" + service.getMaxAllowedInstances()\n\t\t\t\t\t+ \") must be equal or greater than the minimum number of instances (\"\n\t\t\t\t\t+ service.getMinAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() > service.getNumInstances()) {\n\t\t\tthrow new DSLException(\"number of instances (\" + service.getNumInstances()\n\t\t\t\t\t+ \") must be equal or greater than the minimum number of instances (\"\n\t\t\t\t\t+ service.getMinAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tif (service.getNumInstances() > service.getMaxAllowedInstances()) {\n\t\t\tthrow new DSLException(\"number of instances (\" + service.getNumInstances()\n\t\t\t\t\t+ \") must be equal or less than the maximum number of instances (\"\n\t\t\t\t\t+ service.getMaxAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tCapacityRequirementsConfig minCapacity = \n\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t.memoryCapacity((service.getMinAllowedInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t\t.create();\n\t\t\n\t\tCapacityRequirementsConfig initialCapacity = \n\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t.memoryCapacity((service.getNumInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t\t.create();\n\t\t\n\t\t\n\t\tCapacityRequirementsConfig maxCapacity = \n\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t.memoryCapacity((service.getMaxAllowedInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t\t.create();\n\t\t\n\t\tAutomaticCapacityScaleConfigurer scaleConfigurer = \n\t\t\t\tnew AutomaticCapacityScaleConfigurer()\n\t\t.minCapacity(minCapacity)\n\t\t.initialCapacity(initialCapacity)\n\t\t.maxCapacity(maxCapacity)\n\t\t.statisticsPollingInterval(service.getSamplingPeriodInSeconds(), TimeUnit.SECONDS)\n\t\t.cooldownAfterScaleOut(service.getScaleOutCooldownInSeconds(),TimeUnit.SECONDS)\n\t\t.cooldownAfterScaleIn(service.getScaleInCooldownInSeconds(),TimeUnit.SECONDS);\n\t\t\n\t\tMap<String, ServiceStatisticsDetails> serviceStatisticsByName = new HashMap<String, ServiceStatisticsDetails>();\n\t\tfor (AbstractStatisticsDetails calculatedStatistics : service.getServiceStatistics()) {\n\t\t\tif (calculatedStatistics instanceof ServiceStatisticsDetails) {\n\t\t\t\tserviceStatisticsByName.put(calculatedStatistics.getName(), (ServiceStatisticsDetails)calculatedStatistics);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (serviceStatisticsByName.isEmpty()) {\n\t\t\tthrow new DSLException(\"calculatedStatistics must define at least one serviceStatistics entry\");\n\t\t}\n\t\t\n\t\tfor (ScalingRuleDetails scalingRule : scalingRules) {\n\t\t\t\n\t\t\tString serviceStatisticsName = scalingRule.getStatistics();\n\t\t\tif (serviceStatisticsName == null) {\n\t\t\t\tthrow new DSLException(\"scalingRule must specify statistics (serviceStatistics name)\");\n\t\t\t}\n\t\t\t\n\t\t\tServiceStatisticsDetails serviceStatistics = serviceStatisticsByName.get(serviceStatisticsName);\n\t\t\t\n\t\t\tif (serviceStatistics == null) {\n\t\t\t\tthrow new DSLException(\"scalingRule must specify a valid statistics (serviceStatistics name). \" + serviceStatisticsName + \" is not recognized. Possible values are: \"+ serviceStatisticsByName.keySet());\n\t\t\t}\n\t\t\n\t\t\tProcessingUnitStatisticsId statisticsId = new ProcessingUnitStatisticsId();\n\t\t\tstatisticsId.setMonitor(CloudifyConstants.USM_MONITORS_SERVICE_ID);\n\t\t\tstatisticsId.setMetric(serviceStatistics.getMetric());\n\t\t\tstatisticsId.setInstancesStatistics(serviceStatistics.getInstancesStatistics().createInstancesStatistics());\n\t\n\t\t\tif (serviceStatistics.getMovingTimeRangeInSeconds() <= service.getSamplingPeriodInSeconds()) {\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(\"Deploying service \" + serviceName + \" with auto scaling that monitors the last sample of \"\n\t\t\t\t\t\t\t+ serviceStatistics.getMetric());\n\t\t\t\t}\n\t\t\t\tstatisticsId.setTimeWindowStatistics(new LastSampleTimeWindowStatisticsConfig());\n\t\t\t} else {\n\t\t\t\tstatisticsId.setTimeWindowStatistics(serviceStatistics.getTimeStatistics().createTimeWindowStatistics(\n\t\t\t\t\t\tserviceStatistics.getMovingTimeRangeInSeconds(), TimeUnit.SECONDS));\n\t\t\t}\n\t\n\t\t\tAutomaticCapacityScaleRuleConfig rule = new AutomaticCapacityScaleRuleConfig();\n\t\t\trule.setStatistics(statisticsId);\n\t\t\t\n\t\t\tif (scalingRule.getLowThreshold() == null){\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatisticsName +\" lowThreshold is undefined\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tComparable<?> threshold = scalingRule.getLowThreshold().getValue();\n\t\t\t\tif (threshold == null) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatisticsName +\" lowThreshold value is missing\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint instancesDecrease = scalingRule.getLowThreshold().getInstancesDecrease ();\n\t\t\t\tif (instancesDecrease < 0) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatisticsName +\" lowThreshold instancesDecrease cannot be a negative number (\"+instancesDecrease+\")\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (instancesDecrease == 0) {\n\t\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatisticsName +\" lowThreshold instancesDecrease is 0\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trule.setLowThreshold(threshold);\n\t\t\t\t\trule.setLowThresholdBreachedDecrease(\n\t\t\t\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t\t\t\t.memoryCapacity(instancesDecrease * externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t\t.create());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (scalingRule.getHighThreshold() == null) {\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatisticsName +\" highThreshold is undefined\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tComparable<?> threshold = scalingRule.getHighThreshold().getValue();\n\t\t\t\tif (threshold == null) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatisticsName +\" highThreshold value is missing\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint instancesIncrease = scalingRule.getHighThreshold().getInstancesIncrease();\n\t\t\t\tif (instancesIncrease < 0) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatisticsName +\" highThreshold instancesIncrease cannot be a negative number (\"+instancesIncrease+\")\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (instancesIncrease == 0) {\n\t\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatisticsName +\" highThreshold instancesIncrease is 0\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trule.setHighThreshold(threshold);\n\t\t\t\t\trule.setHighThresholdBreachedIncrease(\n\t\t\t\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t\t\t\t.memoryCapacity(instancesIncrease * externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t\t.create());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tscaleConfigurer.addRule(rule);\n\t\t}\n\t\t\n\t\treturn scaleConfigurer.create();\n\t}","commit_id":"6dc897d8b5e04335c6fd728dbf3263e3d0e5372c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private int getNodeidFromIp(Connection dbConn, InetAddress ipaddr)\r\n\t\t\tthrows SQLException {\r\n\r\n\r\n\t\tif (ipaddr.isLoopbackAddress() || ipaddr.getHostAddress().equals(\"0.0.0.0\")) return -1;\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\t\r\n\t\tint nodeid = -1;\r\n\t\t\r\n\t\tPreparedStatement stmt = null;\r\n\t\tstmt = dbConn.prepareStatement(SQL_GET_NODEID);\r\n\t\tstmt.setString(1, ipaddr.getHostAddress());\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getNodeidFromIp: executing query \" + stmt.toString() + \" with ip address=\" + ipaddr.getHostAddress());\r\n\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog.debug(\"getNodeidFromIp: no entries found in ipinterface\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t// extract the values.\r\n\t\t//\r\n\t\tint ndx = 1;\r\n\r\n\t\t// get the node id\r\n\t\t//\r\n\t\tnodeid = rs.getInt(ndx++);\r\n\t\tif (rs.wasNull())\r\n\t\t\tnodeid = -1;\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getNodeidFromIp: found nodeid \" + nodeid);\r\n\r\n\t\tstmt.close();\r\n\r\n\t\treturn nodeid;\r\n\r\n\t}","id":76966,"modified_method":"private int getNodeidFromIp(Connection dbConn, InetAddress ipaddr)\r\n\t\t\tthrows SQLException {\r\n\r\n\r\n\t\tif (ipaddr.isLoopbackAddress() || ipaddr.getHostAddress().equals(\"0.0.0.0\")) return -1;\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\t\r\n\t\tint nodeid = -1;\r\n\t\t\r\n\t\tPreparedStatement stmt = null;\r\n\t\tstmt = dbConn.prepareStatement(SQL_GET_NODEID);\r\n\t\tstmt.setString(1, ipaddr.getHostAddress());\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getNodeidFromIp: executing query \" + SQL_GET_NODEID + \" with ip address=\" + ipaddr.getHostAddress());\r\n\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog.debug(\"getNodeidFromIp: no entries found in ipinterface\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t// extract the values.\r\n\t\t//\r\n\t\tint ndx = 1;\r\n\r\n\t\t// get the node id\r\n\t\t//\r\n\t\tnodeid = rs.getInt(ndx++);\r\n\t\tif (rs.wasNull())\r\n\t\t\tnodeid = -1;\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getNodeidFromIp: found nodeid \" + nodeid);\r\n\r\n\t\tstmt.close();\r\n\r\n\t\treturn nodeid;\r\n\r\n\t}","commit_id":"48ba4871a75515fa56c88d0996231782339e9204","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private AtInterface getNodeidIfindexFromIp(Connection dbConn, InetAddress ipaddr)\r\n\tthrows SQLException {\r\n\r\n\r\n\t\tif (ipaddr.isLoopbackAddress() || ipaddr.getHostAddress().equals(\"0.0.0.0\")) return null;\r\n\t\t\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\t\r\n\t\tint atnodeid = -1;\r\n\t\tint atifindex = -1;\r\n\t\t\r\n\t\tPreparedStatement stmt = dbConn.prepareStatement(SQL_GET_NODEID_IFINDEX_IPINT);\r\n\t\tstmt.setString(1, ipaddr.getHostAddress());\r\n\r\n\t\tif (log.isDebugEnabled()) \r\n\t\t\tlog.debug(\"getNodeidIfindexFromIp: executing SQL Statement \" + SQL_GET_NODEID_IFINDEX_IPINT + \" with ip address=\" + ipaddr.getHostAddress());\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tint ndx = 1;\r\n\t\tatnodeid = rs.getInt(ndx++);\r\n\t\tif (rs.wasNull()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t// save info for DiscoveryLink\r\n\t\tAtInterface ati = new AtInterface(atnodeid,ipaddr.getHostAddress());\r\n\r\n\t\t// get ifindex if exists\r\n\t\tatifindex = rs.getInt(ndx++);\r\n\t\tif (rs.wasNull()) {\r\n\t\t\tif (log.isInfoEnabled())\r\n\t\t\t\tlog.info(\"store: no ifindex (-1) found for ipaddress \"\r\n\t\t\t\t\t\t+ ipaddr + \".\");\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\tif (log.isInfoEnabled())\r\n\t\t\t\tlog.info(\"store: ifindex \" + atifindex + \" found for ipaddress \"\r\n\t\t\t\t\t\t+ ipaddr + \".\");\r\n\t\t\t\r\n\t\t\tati.setIfindex(atifindex);\r\n\t\t}\r\n\t\t\r\n\t\treturn ati;\r\n\t\t\r\n\t}","id":76967,"modified_method":"private AtInterface getNodeidIfindexFromIp(Connection dbConn, InetAddress ipaddr)\r\n\tthrows SQLException {\r\n\r\n\r\n\t\tif (ipaddr.isLoopbackAddress() || ipaddr.getHostAddress().equals(\"0.0.0.0\")) return null;\r\n\t\t\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\t\r\n\t\tint atnodeid = -1;\r\n\t\tint atifindex = -1;\r\n\t\t\r\n\t\tPreparedStatement stmt = dbConn.prepareStatement(SQL_GET_NODEID_IFINDEX_IPINT);\r\n\t\r\n\t\tstmt.setString(1, ipaddr.getHostAddress());\r\n\r\n\t\tif (log.isDebugEnabled()) \r\n\t\t\tlog.debug(\"getNodeidIfindexFromIp: executing SQL Statement \" + SQL_GET_NODEID_IFINDEX_IPINT + \" with ip address=\" + ipaddr.getHostAddress());\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tatnodeid = rs.getInt(\"nodeid\");\r\n\t\tif (rs.wasNull()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t// save info for DiscoveryLink\r\n\t\tAtInterface ati = new AtInterface(atnodeid,ipaddr.getHostAddress());\r\n\r\n\t\t// get ifindex if exists\r\n\t\tatifindex = rs.getInt(\"ifindex\");\r\n\t\tif (rs.wasNull()) {\r\n\t\t\tif (log.isInfoEnabled())\r\n\t\t\t\tlog.info(\"getNodeidIfindexFromIp: nodeid \"+ atnodeid +\" no ifindex (-1) found for ipaddress \"\r\n\t\t\t\t\t\t+ ipaddr + \".\");\r\n\t\t} else {\r\n\t\t\tif (log.isInfoEnabled())\r\n\t\t\t\tlog.info(\"getNodeidIfindexFromIp: nodeid \"+ atnodeid +\" ifindex \" + atifindex + \" found for ipaddress \"\r\n\t\t\t\t\t\t+ ipaddr + \".\");\r\n\t\t\tati.setIfindex(atifindex);\r\n\t\t}\r\n\t\t\r\n\t\treturn ati;\r\n\t\t\r\n\t}","commit_id":"48ba4871a75515fa56c88d0996231782339e9204","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private int getIfIndexByName(Connection dbConn,\r\n\t\t\tint nodeid, String ifName) throws SQLException {\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\r\n\t\tPreparedStatement stmt = null;\r\n\t\tstmt = dbConn.prepareStatement(SQL_GET_IFINDEX_SNMPINTERFACE_NAME);\r\n\t\tstmt.setInt(1, nodeid);\r\n\t\tstmt.setString(2, ifName);\r\n\t\tstmt.setString(3, ifName);\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getIfIndexByName: executing query\"\r\n\t\t\t\t\t+ stmt.toString() + \"nodeid =\" + nodeid + \"and ifName=\" + ifName);\r\n\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"getIfIndexByName: no entries found in snmpinterface\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// extract the values.\r\n\t\t//\r\n\t\tint ndx = 1;\r\n\r\n\t\tif (rs.wasNull()) {\r\n\t\t\t\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"getIfIndexByName: no entries found in snmpinterface\");\r\n\t\t\treturn -1;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tint ifindex = rs.getInt(ndx++);\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getIfIndexByName: found ifindex=\"\r\n\t\t\t\t\t+ ifindex);\r\n\r\n\t\tstmt.close();\r\n\r\n\t\treturn ifindex;\r\n\t}","id":76968,"modified_method":"private int getIfIndexByName(Connection dbConn,\r\n\t\t\tint nodeid, String ifName) throws SQLException {\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\r\n\t\tPreparedStatement stmt = null;\r\n\t\tstmt = dbConn.prepareStatement(SQL_GET_IFINDEX_SNMPINTERFACE_NAME);\r\n\t\tstmt.setInt(1, nodeid);\r\n\t\tstmt.setString(2, ifName);\r\n\t\tstmt.setString(3, ifName);\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getIfIndexByName: executing query\"\r\n\t\t\t\t\t+ SQL_GET_IFINDEX_SNMPINTERFACE_NAME + \"nodeid =\" + nodeid + \"and ifName=\" + ifName);\r\n\r\n\t\tResultSet rs = stmt.executeQuery();\r\n\r\n\t\tif (!rs.next()) {\r\n\t\t\trs.close();\r\n\t\t\tstmt.close();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"getIfIndexByName: no entries found in snmpinterface\");\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// extract the values.\r\n\t\t//\r\n\t\tint ndx = 1;\r\n\r\n\t\tif (rs.wasNull()) {\r\n\t\t\t\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"getIfIndexByName: no entries found in snmpinterface\");\r\n\t\t\treturn -1;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tint ifindex = rs.getInt(ndx++);\r\n\r\n\t\tif (log.isDebugEnabled())\r\n\t\t\tlog.debug(\"getIfIndexByName: found ifindex=\"\r\n\t\t\t\t\t+ ifindex);\r\n\r\n\t\tstmt.close();\r\n\r\n\t\treturn ifindex;\r\n\t}","commit_id":"48ba4871a75515fa56c88d0996231782339e9204","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\r\n\t * \r\n\t * @param dbConn\r\n\t * @param now\r\n\t * @throws SQLException\r\n\t */\r\n\tprivate void storeSnmpCollection(Connection dbConn, Timestamp now) throws SQLException,\r\n\t\t\tUnknownHostException {\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\tIterator ite = null;\r\n\r\n\t\tint nodeid = m_node.getNodeId();\r\n\r\n\t\tif (m_snmpcoll.hasIpNetToMediaTable()) {\r\n\t\t\tite = m_snmpcoll.getIpNetToMediaTable()\r\n\t\t\t\t\t.getEntries().iterator();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving IpNetToMediaTable to atinterface table in DB\");\r\n\t\t\t// the AtInterfaces used by LinkableNode where to save info\r\n\t\t\tjava.util.List<AtInterface> atInterfaces = new java.util.ArrayList<AtInterface>();\r\n\t\t\twhile (ite.hasNext()) {\r\n\r\n\t\t\t\tIpNetToMediaTableEntry ent = (IpNetToMediaTableEntry) ite\r\n\t\t\t\t\t\t.next();\r\n\t\t\t\t\r\n\t\t\t\tint ifindex = ent\r\n\t\t\t\t\t\t.getInt32(IpNetToMediaTableEntry.INTM_INDEX);\r\n\t\t\t\t\r\n\t\t\t\tInetAddress ipaddress = ent\r\n\t\t\t\t\t\t.getIPAddress(IpNetToMediaTableEntry.INTM_NETADDR);\r\n\r\n\t\t\t\tif (ipaddress.isLoopbackAddress() || ipaddress.getHostAddress().equals(\"0.0.0.0\")) {\r\n\t\t\t\t\tlog.warn(\"store: invalid ip \" + ipaddress.getHostAddress());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tString physAddr = ent\r\n\t\t\t\t\t\t.getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\r\n\t\t\t\t\r\n\t\t\t\tif (physAddr.equals(\"000000000000\") || physAddr.equalsIgnoreCase(\"ffffffffffff\")) {\r\n\t\t\t\t\tlog.warn(\"store: invalid mac address \" + physAddr\r\n\t\t\t\t\t\t\t+ \" for ip \" + ipaddress.getHostAddress());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\tlog.debug(\"store: trying save info for ipaddr \" + ipaddress.getHostName()\r\n\t\t\t\t\t\t\t+ \" mac address \" + physAddr + \" found on ifindex \"\r\n\t\t\t\t\t\t\t+ ifindex);\r\n\r\n\t\t\t\t// get an At interface but without setting mac address\r\n\t\t\t\tAtInterface at = getNodeidIfindexFromIp(dbConn, ipaddress);\r\n\t\t\t\tif (at == null) {\r\n\t\t\t\t\t\tlog.warn(\"getNodeidIfindexFromIp: no nodeid found for ipaddress \"\r\n\t\t\t\t\t\t\t\t+ ipaddress + \".\");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t\t//TODO here is a good place for autodiscovery\r\n\t\t\t\t}\r\n\t\t\t\t//set the mac address\r\n\t\t\t\tat.setMacAddress(physAddr);\r\n\t\t\t\t// add At Inteface to list of valid interfaces\r\n\t\t\t\tatInterfaces.add(at);\r\n\r\n\t\t\t\t// Save in DB\r\n\t\t\t\tDbAtInterfaceEntry atInterfaceEntry = DbAtInterfaceEntry.get(\r\n\t\t\t\t\t\tdbConn, at.getNodeId(), ipaddress.getHostAddress());\r\n\t\t\t\tif (atInterfaceEntry == null) {\r\n\t\t\t\t\tatInterfaceEntry = DbAtInterfaceEntry.create(at.getNodeId(),\r\n\t\t\t\t\t\t\tipaddress.getHostAddress());\r\n\t\t\t\t}\r\n\t\t\t\t// update object\r\n\r\n\t\t\t\tatInterfaceEntry.updateAtPhysAddr(physAddr);\r\n\r\n\t\t\t\tatInterfaceEntry.updateSourceNodeId(nodeid);\r\n\t\t\t\tatInterfaceEntry.updateIfIndex(ifindex);\r\n\t\t\t\tatInterfaceEntry.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);\r\n\t\t\t\tatInterfaceEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t// store object in database\r\n\t\t\t\tatInterfaceEntry.store(dbConn);\r\n\t\t\t}\r\n\t\t\t// set AtInterfaces in LinkableNode\r\n\t\t\tm_node.setAtInterfaces(atInterfaces);\r\n\t\t}\r\n\r\n\t\tif (m_snmpcoll.hasCdpCacheTable()) {\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving CdpCacheTable into SnmpLinkableNode\");\r\n\t\t\tjava.util.List<CdpInterface> cdpInterfaces = new java.util.ArrayList<CdpInterface>();\r\n\t\t\tite = m_snmpcoll.getCdpCacheTable()\r\n\t\t\t\t\t.getEntries().iterator();\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tCdpCacheTableEntry cdpEntry = (CdpCacheTableEntry) ite.next();\r\n\t\t\t\tint cdpAddrType = cdpEntry.getInt32(CdpCacheTableEntry.CDP_ADDRESS_TYPE);\r\n\r\n\t\t\t\tif (cdpAddrType != 1)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tString cdptargetipaddress = cdpEntry.getHexString(CdpCacheTableEntry.CDP_ADDRESS);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ip address octet string is \" + cdptargetipaddress);\r\n\r\n\t\t\t\tlong ipAddr = Long.parseLong(cdptargetipaddress, 16);\r\n\t\t\t\tbyte[] bytes = new byte[4];\r\n\t\t\t\tbytes[3] = (byte) (ipAddr & 0xff);\r\n\t\t\t\tbytes[2] = (byte) ((ipAddr >> 8) & 0xff);\r\n\t\t\t\tbytes[1] = (byte) ((ipAddr >> 16) & 0xff);\r\n\t\t\t\tbytes[0] = (byte) ((ipAddr >> 24) & 0xff);\r\n\t\t\t\t                         \r\n\t\t\t\tInetAddress cdpTargetIpAddr = InetAddress.getByAddress(bytes);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ip address after parsing is \" + cdpTargetIpAddr.getHostAddress());\r\n\t\t\t\t\r\n\t\t\t\tint cdpIfIndex = cdpEntry.getInt32(CdpCacheTableEntry.CDP_IFINDEX);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ifindex is \" + cdpIfIndex);\r\n\r\n\t\t\t\tString cdpTargetDevicePort = cdpEntry.getDisplayString(CdpCacheTableEntry.CDP_DEVICEPORT);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp Target device port name is \" + cdpTargetDevicePort);\r\n\r\n\r\n\t\t\t\tCdpInterface cdpIface = new CdpInterface(cdpIfIndex);\r\n\r\n\t\t\t\tint targetCdpNodeId = getNodeidFromIp(dbConn, cdpTargetIpAddr);\r\n\r\n\t\t\t\tcdpIface.setCdpTargetNodeId(targetCdpNodeId);\r\n\t\t\t\tcdpIface.setCdpTargetIpAddr(cdpTargetIpAddr);\r\n\t\t\t\t\r\n\t\t\t\tint cdpTargetIfindex = getIfIndexByName(\r\n\t\t\t\t\t\tdbConn, targetCdpNodeId, cdpTargetDevicePort);\r\n\r\n\t\t\t\tif (targetCdpNodeId == -1 || cdpTargetIfindex == -1) {\r\n\t\t\t\t\tlog.warn(\"No nodeid found: cdp interface not added to Linkable Snmp Node\");\r\n\t\t\t\t\t//TODO Good place for autodiscovery\r\n\t\t\t\t} else  {\r\n\r\n\t\t\t\t\tcdpIface.setCdpTargetIfIndex(cdpTargetIfindex);\r\n\t\t\t\t\tcdpInterfaces.add(cdpIface);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tm_node.setCdpInterfaces(cdpInterfaces);\r\n\t\t}\r\n\r\n\t\tif (m_snmpcoll.hasRouteTable()) {\r\n\t\t\tjava.util.List<RouterInterface> routeInterfaces = new java.util.ArrayList<RouterInterface>();\r\n\t\t\tite = m_snmpcoll.getIpRouteTable().getEntries()\r\n\t\t\t\t\t.iterator();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving ipRouteTable to iprouteinterface table in DB\");\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tIpRouteTableEntry ent = (IpRouteTableEntry) ite.next();\r\n                \r\n                log.debug(\"storeSnmpCollection: ent=\"+ent);\r\n\r\n\t\t\t\tInetAddress routedest = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_DEST);\r\n                log.debug(\"storeSnmpCollection: routedest is: \"+ (routedest == null ? \"null\" : routedest)+\"; IP_ROUTE_DEST: \"+IpRouteTableEntry.IP_ROUTE_DEST);\r\n                    \r\n\t\t\t\tInetAddress routemask = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_MASK);\r\n                log.debug(\"storeSnmpCollection: routemask is: \"+ (routemask == null ? \"null\" : routemask)+\"; IP_ROUTE_MASK: \"+IpRouteTableEntry.IP_ROUTE_MASK);\r\n                \r\n\t\t\t\tInetAddress nexthop = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_NXTHOP);\r\n                log.debug(\"storeSnmpCollection: nexthop is: \"+ (nexthop == null ? \"null\" : nexthop)+\"; IP_ROUTE_NXTHOP: \"+IpRouteTableEntry.IP_ROUTE_NXTHOP);\r\n                \r\n\t\t\t\tint ifindex = ent.getInt32(IpRouteTableEntry.IP_ROUTE_IFINDEX);\r\n                log.debug(\"storeSnmpCollection: ifindex is: \"+ (ifindex < 1 ? \"less than 1\" : ifindex)+\"; IP_ROUTE_IFINDEX: \"+IpRouteTableEntry.IP_ROUTE_IFINDEX);\r\n                \r\n\t\t\t\tint routemetric1 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC1);\r\n                log.debug(\"storeSnmpCollection: routemetric1 is: \"+ (routemetric1 < 1 ? \"less than 1\" : routemetric1)+\"; IP_ROUTE_METRIC1: \"+IpRouteTableEntry.IP_ROUTE_METRIC1);\r\n                \r\n                log.debug(\"storeSnmpCollection: ent=\"+ent);\r\n                log.debug(\"storeSnmpCollection: IP_ROUTE_METRIC2=\"+IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n\t\t\t\tint routemetric2 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n                log.debug(\"storeSnmpCollection: routemetric2 is: \"+ (routemetric2 < 1 ? \"less than 1\" : routemetric2)+\"; IP_ROUTE_METRIC2: \"+IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n                \r\n\t\t\t\tint routemetric3  =ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC3);\r\n                log.debug(\"storeSnmpCollection: routemetric3 is: \"+ (routemetric3 < 1 ? \"less than 1\" : routemetric3)+\"; IP_ROUTE_METRIC3: \"+IpRouteTableEntry.IP_ROUTE_METRIC3);\r\n                \r\n\t\t\t\tint routemetric4 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC4);\r\n                log.debug(\"storeSnmpCollection: routemetric4 is: \"+ (routemetric4 < 1 ? \"less than 1\" : routemetric4)+\"; IP_ROUTE_METRIC4: \"+IpRouteTableEntry.IP_ROUTE_METRIC4);\r\n                \r\n\t\t\t\tint routemetric5 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC5);\r\n                log.debug(\"storeSnmpCollection: routemetric5 is: \"+ (routemetric5 < 1 ? \"less than 1\" : routemetric5)+\"; IP_ROUTE_METRIC5: \"+IpRouteTableEntry.IP_ROUTE_METRIC5);\r\n                \r\n\t\t\t\tint routetype = ent.getInt32(IpRouteTableEntry.IP_ROUTE_TYPE);\r\n                log.debug(\"storeSnmpCollection: routetype is: \"+ (routetype < 1 ? \"less than 1\" : routetype)+\"; IP_ROUTE_TYPE: \"+IpRouteTableEntry.IP_ROUTE_TYPE);\r\n                \r\n\t\t\t\tint routeproto = ent.getInt32(IpRouteTableEntry.IP_ROUTE_PROTO);\r\n                log.debug(\"storeSnmpCollection: routeproto is: \"+ (routeproto < 1 ? \"less than 1\" : routeproto)+\"; IP_ROUTE_PROTO: \"+IpRouteTableEntry.IP_ROUTE_PROTO);\r\n                \r\n\r\n\t\t\t\t// info used for Discovery Link\r\n\t\t\t\tRouterInterface routeIface = new RouterInterface(ifindex);\r\n\t\t\t\trouteIface.setMetric(routemetric1);\r\n\t\t\t\trouteIface.setNextHop(nexthop);\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tint nodeParentId = getNodeidFromIp(dbConn,nexthop);\r\n\t\t\t\t\r\n\t\t\t\tif (nodeParentId == -1) {\r\n\t\t\t\t\t//TODO here is a good point for autodiscovery\r\n\t\t\t\t\tlog.warn(\"store: No nodeid found for next hop \" + nexthop \r\n\t\t\t\t\t\t\t+ \" Skipping ip route interface add to Linkable Snmp Node\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\trouteIface.setNodeparentid(nodeParentId);\r\n\t\t\t\t\trouteIface.setSnmpiftype(getSnmpIfType(dbConn, nodeid, ifindex));\r\n\t\t\t\t\t\r\n\t\t\t\t\trouteInterfaces.add(routeIface);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// save info to DB\r\n\t\t\t\tDbIpRouteInterfaceEntry iprouteInterfaceEntry = DbIpRouteInterfaceEntry\r\n\t\t\t\t\t\t.get(dbConn, nodeid, routedest.getHostAddress());\r\n\t\t\t\tif (iprouteInterfaceEntry == null) {\r\n\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\tiprouteInterfaceEntry = DbIpRouteInterfaceEntry.create(\r\n\t\t\t\t\t\t\tm_node.getNodeId(), routedest.getHostAddress());\r\n\t\t\t\t}\r\n\t\t\t\t// update object\r\n\t\t\t\tiprouteInterfaceEntry.updateRouteMask(routemask.getHostAddress());\r\n\t\t\t\tiprouteInterfaceEntry.updateRouteNextHop(nexthop.getHostAddress());\r\n\t\t\t\tiprouteInterfaceEntry.updateIfIndex(ifindex);\r\n\t\t\t\tif (routemetric1 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric1(routemetric1);\r\n\t\t\t\tif (routemetric2 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric2(routemetric2);\r\n\t\t\t\tif (routemetric3 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric3(routemetric3);\r\n\t\t\t\tif (routemetric4 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric4(routemetric4);\r\n\t\t\t\tif (routemetric5 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric5(routemetric5);\r\n\t\t\t\tif (routetype != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteType(routetype);\r\n\t\t\t\tif (routeproto != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteProto(routeproto);\r\n\t\t\t\tiprouteInterfaceEntry\r\n\t\t\t\t\t\t.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);\r\n\t\t\t\tiprouteInterfaceEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t// store object in database\r\n\t\t\t\tiprouteInterfaceEntry.store(dbConn);\r\n\t\t\t}\r\n\t\t\tm_node.setRouteInterfaces(routeInterfaces);\r\n\t\t}\r\n\t\t// STARTS loop on vlans\r\n\r\n\t\tif (m_snmpcoll.hasVlanTable()) {\r\n\t\t\t\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving SnmpVlanCollection in DB\");\r\n\t\t\tite = m_snmpcoll.getSnmpVlanCollections()\r\n\t\t\t\t\t.iterator();\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tSnmpVlanCollection snmpVlanColl = (SnmpVlanCollection) ite\r\n\t\t\t\t\t\t.next();\r\n\r\n\t\t\t\tString vlanindex = snmpVlanColl.getVlanIndex();\r\n\t\t\t\tint vlan = Integer.parseInt(vlanindex);\r\n\t\t\t\tString vlanname = snmpVlanColl.getVlanName();\r\n\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t.debug(\"store: parsing VLAN \"\r\n\t\t\t\t\t\t\t\t\t+ vlanindex + \" VLAN_NAME \" + vlanname);\r\n\r\n\t\t\t\tif (snmpVlanColl.hasDot1dBase()) {\r\n\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t.debug(\"store: saving Dot1dBaseGroup in stpnode table\");\r\n\r\n\t\t\t\t\tDot1dBaseGroup dod1db = (Dot1dBaseGroup) snmpVlanColl.getDot1dBase();\r\n\t\t\t\t\tString baseBridgeAddress = dod1db.getBridgeAddress();\r\n\t\t\t\t\tint basenumports = dod1db.getNumberOfPorts();\r\n\t\t\t\t\tint bridgetype = dod1db.getBridgeType();\r\n\t\t\t\t\t\r\n\r\n\t\t\t\t\tif (baseBridgeAddress == \"000000000000\") {\r\n\t\t\t\t\t\tlog.warn(\"store: base bridge address \" + baseBridgeAddress\r\n\t\t\t\t\t\t\t\t+ \" is invalid for ipaddress \" );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm_node.addBridgeIdentifier(baseBridgeAddress,vlanindex);\r\n\t\t\t\t\t\tDbStpNodeEntry dbStpNodeEntry = DbStpNodeEntry.get(dbConn,\r\n\t\t\t\t\t\t\tm_node.getNodeId(), vlan);\r\n\t\t\t\t\t\tif (dbStpNodeEntry == null) {\r\n\t\t\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\t\t\tdbStpNodeEntry = DbStpNodeEntry.create(m_node\r\n\t\t\t\t\t\t\t\t.getNodeId(), vlan);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// update object\r\n\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseBridgeAddress(baseBridgeAddress);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseNumPorts(basenumports);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseType(bridgetype);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseVlanName(vlanname);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dStp()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\"store: adding Dot1dStpGroup in stpnode table\");\r\n\r\n\t\t\t\t\t\t\tDot1dStpGroup dod1stp = (Dot1dStpGroup) snmpVlanColl\r\n\t\t\t\t\t\t\t\t.getDot1dStp();\r\n\t\t\t\t\t\t\tint protospec = dod1stp.getStpProtocolSpecification();\r\n\t\t\t\t\t\t\tint stppriority = dod1stp.getStpPriority();\r\n\t\t\t\t\t\t\tString stpDesignatedRoot = dod1stp.getStpDesignatedRoot();\r\n\t\t\t\t\t\t\tint stprootcost = dod1stp.getStpRootCost();\r\n\t\t\t\t\t\t\tint stprootport = dod1stp.getStpRootPort();\r\n\r\n\t\t\t\t\t\t\tif (stpDesignatedRoot != \"0000000000000000\") {\r\n\t\t\t\t\t\t\t\tm_node.setVlanStpRoot(vlanindex,stpDesignatedRoot);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpProtocolSpecification(protospec);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpPriority(stppriority);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpDesignatedRoot(stpDesignatedRoot);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpRootCost(stprootcost);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpRootPort(stprootport);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t// store object in database\r\n\t\t\t\t\t\tdbStpNodeEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\tdbStpNodeEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\tdbStpNodeEntry.store(dbConn);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dBasePortTable()) {\r\n\t\t\t\t\t\t\tIterator sub_ite = snmpVlanColl.getDot1dBasePortTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\"store: saving Dot1dBasePortTable in stpinterface table\");\r\n\t\t\t\t\t\t\twhile (sub_ite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dBasePortTableEntry dot1dbaseptentry = (Dot1dBasePortTableEntry) sub_ite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tint baseport = dot1dbaseptentry.getInt32(Dot1dBasePortTableEntry.BASE_PORT);\r\n\t\t\t\t\t\t\t\tint ifindex = dot1dbaseptentry.getInt32(Dot1dBasePortTableEntry.BASE_IFINDEX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tm_node.setIfIndexBridgePort(ifindex,baseport);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tDbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry\r\n\t\t\t\t\t\t\t\t\t.get(dbConn, m_node.getNodeId(),\r\n\t\t\t\t\t\t\t\t\t\t\tbaseport, vlan);\r\n\t\t\t\t\t\t\t\tif (dbStpIntEntry == null) {\r\n\t\t\t\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry = DbStpInterfaceEntry.create(\r\n\t\t\t\t\t\t\t\t\t\tm_node.getNodeId(), baseport, vlan);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.updateIfIndex(ifindex);\r\n\r\n\t\t\t\t\t\t\t\tdbStpIntEntry\r\n\t\t\t\t\t\t\t\t\t.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.store(dbConn);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dStpPortTable()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\" store: adding Dot1dStpPortTable in stpinterface table\");\r\n\t\t\t\t\t\t\tIterator sub_ite = snmpVlanColl.getDot1dStpPortTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\twhile (sub_ite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dStpPortTableEntry dot1dstpptentry = (Dot1dStpPortTableEntry) sub_ite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tint stpport = dot1dstpptentry.getInt32(Dot1dStpPortTableEntry.STP_PORT);\r\n\t\t\t\t\t\t\t\tDbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry\r\n\t\t\t\t\t\t\t\t\t.get(dbConn, m_node.getNodeId(),\r\n\t\t\t\t\t\t\t\t\t\t\tstpport, vlan);\r\n\t\t\t\t\t\t\t\tif (dbStpIntEntry == null) {\r\n\t\t\t\t\t\t\t\t// Cannot create the object becouse must exists the dot1dbase\r\n\t\t\t\t\t\t\t\t// object!!!!!\r\n\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.warn(\"store StpInterface: when storing STP info\"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for bridge node with nodeid \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ m_node.getNodeId()\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" bridgeport number \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ stpport\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" and vlan index \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ vlanindex\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" info not found in database, ERROR skipping.....\");\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tint stpportstate = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_STATE);\r\n\t\t\t\t\t\t\t\t\tint stpportpathcost = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_PATH_COST);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedBridge = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_BRIDGE);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedRoot = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_ROOT);\r\n\t\t\t\t\t\t\t\t\tint stpportdesignatedcost = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_COST);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedPort = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_PORT);\r\n\t\t\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\t\t\t\tif (stpPortDesignatedBridge.equals(\"0000000000000000\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog.warn(\"storeSnmpCollection: designated bridge is invalid not adding to discoveryLink\");\r\n\t\t\t\t\t\t\t\t\t} else if (stpPortDesignatedPort.equals(\"0000\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog.warn(\"storeSnmpCollection: designated port is invalid not adding to discoveryLink\");\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tBridgeStpInterface stpIface = new BridgeStpInterface(stpport,vlanindex);\r\n\t\t\t\t\t\t\t\t\t\tstpIface.setStpPortDesignatedBridge(stpPortDesignatedBridge);\r\n\t\t\t\t\t\t\t\t\t\tstpIface.setStpPortDesignatedPort(stpPortDesignatedPort);\r\n\t\t\t\t\t\t\t\t\t\tm_node.addStpInterface(stpIface);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortState(stpportstate);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortPathCost(stpportpathcost);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedBridge(stpPortDesignatedBridge);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedRoot(stpPortDesignatedRoot);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortDesignatedCost(stpportdesignatedcost);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedPort(stpPortDesignatedPort);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.store(dbConn);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dTpFdbTable()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t.debug(\"store: parsing Dot1dTpFdbTable\");\r\n\r\n\t\t\t\t\t\t\tIterator subite = snmpVlanColl.getDot1dFdbTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\twhile (subite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dTpFdbTableEntry dot1dfdbentry = (Dot1dTpFdbTableEntry) subite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tString curMacAddress = dot1dfdbentry\r\n\t\t\t\t\t\t\t\t\t.getHexString(Dot1dTpFdbTableEntry.FDB_ADDRESS);\r\n\r\n\t\t\t\t\t\t\t\tint fdbport = dot1dfdbentry.getInt32(Dot1dTpFdbTableEntry.FDB_PORT);\r\n\r\n\t\t\t\t\t\t\t\tif (fdbport == 0) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"populateBridge: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" learned on invalid port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tint curfdbstatus = dot1dfdbentry.getInt32(Dot1dTpFdbTableEntry.FDB_STATUS);\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_LEARNED) {\r\n\t\t\t\t\t\t\t\t\tm_node.addMacAddress(fdbport,\r\n\t\t\t\t\t\t\t\t\t\tcurMacAddress, vlanindex);\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.debug(\"storeSnmpCollection: found learned mac address \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" on bridge port \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ fdbport\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for VLAN \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ snmpVlanColl.getVlanIndex());\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_SELF) {\r\n\t\t\t\t\t\t\t\t\tm_node.addBridgeIdentifier(curMacAddress);\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.debug(\"storeSnmpCollection: found bridge identifier \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for VLAN \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ snmpVlanColl.getVlanIndex()\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" and bridge port \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ fdbport);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_INVALID) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has INVALID status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_MGMT) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has MGMT status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_OTHER) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has OTHER status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//now adding bridge identifier mac addresses of switch from snmpinterface\r\n\t\t\t\t\t\tsetBridgeIdentifierFromSnmpInterface(dbConn);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tupdate(dbConn, now);\r\n\t\t\r\n\t}","id":76969,"modified_method":"/**\r\n\t * \r\n\t * @param dbConn\r\n\t * @param now\r\n\t * @throws SQLException\r\n\t */\r\n\tprivate void storeSnmpCollection(Connection dbConn, Timestamp now) throws SQLException,\r\n\t\t\tUnknownHostException {\r\n\r\n\t\tCategory log = ThreadCategory.getInstance(getClass());\r\n\t\tIterator ite = null;\r\n\r\n\t\tint nodeid = m_node.getNodeId();\r\n\r\n\t\tif (m_snmpcoll.hasIpNetToMediaTable()) {\r\n\t\t\tite = m_snmpcoll.getIpNetToMediaTable()\r\n\t\t\t\t\t.getEntries().iterator();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving IpNetToMediaTable to atinterface table in DB\");\r\n\t\t\t// the AtInterfaces used by LinkableNode where to save info\r\n\t\t\tjava.util.List<AtInterface> atInterfaces = new java.util.ArrayList<AtInterface>();\r\n\t\t\twhile (ite.hasNext()) {\r\n\r\n\t\t\t\tIpNetToMediaTableEntry ent = (IpNetToMediaTableEntry) ite\r\n\t\t\t\t\t\t.next();\r\n\t\t\t\t\r\n\t\t\t\tint ifindex = ent\r\n\t\t\t\t\t\t.getInt32(IpNetToMediaTableEntry.INTM_INDEX);\r\n\t\t\t\t\r\n\t\t\t\tInetAddress ipaddress = ent\r\n\t\t\t\t\t\t.getIPAddress(IpNetToMediaTableEntry.INTM_NETADDR);\r\n\r\n\t\t\t\tif (ipaddress.isLoopbackAddress() || ipaddress.getHostAddress().equals(\"0.0.0.0\")) {\r\n\t\t\t\t\tlog.warn(\"store: invalid ip \" + ipaddress.getHostAddress());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tString physAddr = ent\r\n\t\t\t\t\t\t.getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\r\n\t\t\t\t\r\n\t\t\t\tif (physAddr.equals(\"000000000000\") || physAddr.equalsIgnoreCase(\"ffffffffffff\")) {\r\n\t\t\t\t\tlog.warn(\"store: invalid mac address \" + physAddr\r\n\t\t\t\t\t\t\t+ \" for ip \" + ipaddress.getHostAddress());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\tlog.debug(\"store: trying save info for ipaddr \" + ipaddress.getHostName()\r\n\t\t\t\t\t\t\t+ \" mac address \" + physAddr + \" found on ifindex \"\r\n\t\t\t\t\t\t\t+ ifindex);\r\n\r\n\t\t\t\t// get an At interface but without setting mac address\r\n\t\t\t\tAtInterface at = getNodeidIfindexFromIp(dbConn, ipaddress);\r\n\t\t\t\tif (at == null) {\r\n\t\t\t\t\t\tlog.warn(\"getNodeidIfindexFromIp: no nodeid found for ipaddress \"\r\n\t\t\t\t\t\t\t\t+ ipaddress + \".\");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t\t//TODO here is a good place for autodiscovery\r\n\t\t\t\t}\r\n\t\t\t\t//set the mac address\r\n\t\t\t\tat.setMacAddress(physAddr);\r\n\t\t\t\t// add At Inteface to list of valid interfaces\r\n\t\t\t\tatInterfaces.add(at);\r\n\r\n\t\t\t\t// Save in DB\r\n\t\t\t\tDbAtInterfaceEntry atInterfaceEntry = DbAtInterfaceEntry.get(\r\n\t\t\t\t\t\tdbConn, at.getNodeId(), ipaddress.getHostAddress());\r\n\t\t\t\tif (atInterfaceEntry == null) {\r\n\t\t\t\t\tatInterfaceEntry = DbAtInterfaceEntry.create(at.getNodeId(),\r\n\t\t\t\t\t\t\tipaddress.getHostAddress());\r\n\t\t\t\t}\r\n\t\t\t\t// update object\r\n\r\n\t\t\t\tatInterfaceEntry.updateAtPhysAddr(physAddr);\r\n\r\n\t\t\t\tatInterfaceEntry.updateSourceNodeId(nodeid);\r\n\t\t\t\tatInterfaceEntry.updateIfIndex(ifindex);\r\n\t\t\t\tatInterfaceEntry.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);\r\n\t\t\t\tatInterfaceEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t// store object in database\r\n\t\t\t\tatInterfaceEntry.store(dbConn);\r\n\t\t\t}\r\n\t\t\t// set AtInterfaces in LinkableNode\r\n\t\t\tm_node.setAtInterfaces(atInterfaces);\r\n\t\t}\r\n\r\n\t\tif (m_snmpcoll.hasCdpCacheTable()) {\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving CdpCacheTable into SnmpLinkableNode\");\r\n\t\t\tjava.util.List<CdpInterface> cdpInterfaces = new java.util.ArrayList<CdpInterface>();\r\n\t\t\tite = m_snmpcoll.getCdpCacheTable()\r\n\t\t\t\t\t.getEntries().iterator();\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tCdpCacheTableEntry cdpEntry = (CdpCacheTableEntry) ite.next();\r\n\t\t\t\tint cdpAddrType = cdpEntry.getInt32(CdpCacheTableEntry.CDP_ADDRESS_TYPE);\r\n\r\n\t\t\t\tif (cdpAddrType != 1)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tString cdptargetipaddress = cdpEntry.getHexString(CdpCacheTableEntry.CDP_ADDRESS);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ip address octet string is \" + cdptargetipaddress);\r\n\r\n\t\t\t\tlong ipAddr = Long.parseLong(cdptargetipaddress, 16);\r\n\t\t\t\tbyte[] bytes = new byte[4];\r\n\t\t\t\tbytes[3] = (byte) (ipAddr & 0xff);\r\n\t\t\t\tbytes[2] = (byte) ((ipAddr >> 8) & 0xff);\r\n\t\t\t\tbytes[1] = (byte) ((ipAddr >> 16) & 0xff);\r\n\t\t\t\tbytes[0] = (byte) ((ipAddr >> 24) & 0xff);\r\n\t\t\t\t                         \r\n\t\t\t\tInetAddress cdpTargetIpAddr = InetAddress.getByAddress(bytes);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ip address after parsing is \" + cdpTargetIpAddr.getHostAddress());\r\n\t\t\t\t\r\n\t\t\t\tint cdpIfIndex = cdpEntry.getInt32(CdpCacheTableEntry.CDP_IFINDEX);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp ifindex is \" + cdpIfIndex);\r\n\r\n\t\t\t\tString cdpTargetDevicePort = cdpEntry.getDisplayString(CdpCacheTableEntry.CDP_DEVICEPORT);\r\n\t\t\t\tif (log.isDebugEnabled())\tlog.debug(\" cdp Target device port name is \" + cdpTargetDevicePort);\r\n\r\n\r\n\t\t\t\tCdpInterface cdpIface = new CdpInterface(cdpIfIndex);\r\n\r\n\t\t\t\tint targetCdpNodeId = getNodeidFromIp(dbConn, cdpTargetIpAddr);\r\n\r\n\t\t\t\tcdpIface.setCdpTargetNodeId(targetCdpNodeId);\r\n\t\t\t\tcdpIface.setCdpTargetIpAddr(cdpTargetIpAddr);\r\n\t\t\t\t\r\n\t\t\t\tint cdpTargetIfindex = getIfIndexByName(\r\n\t\t\t\t\t\tdbConn, targetCdpNodeId, cdpTargetDevicePort);\r\n\r\n\t\t\t\tif (targetCdpNodeId == -1 || cdpTargetIfindex == -1) {\r\n\t\t\t\t\tlog.warn(\"No nodeid found: cdp interface not added to Linkable Snmp Node\");\r\n\t\t\t\t\t//TODO Good place for autodiscovery\r\n\t\t\t\t} else  {\r\n\r\n\t\t\t\t\tcdpIface.setCdpTargetIfIndex(cdpTargetIfindex);\r\n\t\t\t\t\tcdpInterfaces.add(cdpIface);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tm_node.setCdpInterfaces(cdpInterfaces);\r\n\t\t}\r\n\r\n\t\tif (m_snmpcoll.hasRouteTable()) {\r\n\t\t\tjava.util.List<RouterInterface> routeInterfaces = new java.util.ArrayList<RouterInterface>();\r\n\t\t\t\r\n\t\t\tite = m_snmpcoll.getIpRouteTable().getEntries()\r\n\t\t\t\t\t.iterator();\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving ipRouteTable to iprouteinterface table in DB\");\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tIpRouteTableEntry ent = (IpRouteTableEntry) ite.next();\r\n                \r\n                log.debug(\"storeSnmpCollection: ent=\"+ent);\r\n\r\n\t\t\t\tInetAddress routedest = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_DEST);\r\n                log.debug(\"storeSnmpCollection: routedest is: \"+ (routedest == null ? \"null\" : routedest)+\"; IP_ROUTE_DEST: \"+IpRouteTableEntry.IP_ROUTE_DEST);\r\n                    \r\n\t\t\t\tInetAddress routemask = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_MASK);\r\n                log.debug(\"storeSnmpCollection: routemask is: \"+ (routemask == null ? \"null\" : routemask)+\"; IP_ROUTE_MASK: \"+IpRouteTableEntry.IP_ROUTE_MASK);\r\n                \r\n\t\t\t\tInetAddress nexthop = ent.getIPAddress(IpRouteTableEntry.IP_ROUTE_NXTHOP);\r\n                log.debug(\"storeSnmpCollection: nexthop is: \"+ (nexthop == null ? \"null\" : nexthop)+\"; IP_ROUTE_NXTHOP: \"+IpRouteTableEntry.IP_ROUTE_NXTHOP);\r\n                \r\n\t\t\t\tint ifindex = ent.getInt32(IpRouteTableEntry.IP_ROUTE_IFINDEX);\r\n                log.debug(\"storeSnmpCollection: ifindex is: \"+ (ifindex < 1 ? \"less than 1\" : ifindex)+\"; IP_ROUTE_IFINDEX: \"+IpRouteTableEntry.IP_ROUTE_IFINDEX);\r\n\r\n                if (ifindex < 0) {\r\n\t\t\t\t\tlog.warn(\"store: NNot valid ifindex\" + ifindex \r\n\t\t\t\t\t\t\t+ \" Skipping...\");\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n                \r\n\t\t\t\tint routemetric1 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC1);\r\n                log.debug(\"storeSnmpCollection: routemetric1 is: \"+ (routemetric1 < 1 ? \"less than 1\" : routemetric1)+\"; IP_ROUTE_METRIC1: \"+IpRouteTableEntry.IP_ROUTE_METRIC1);\r\n                \r\n                log.debug(\"storeSnmpCollection: ent=\"+ent);\r\n                log.debug(\"storeSnmpCollection: IP_ROUTE_METRIC2=\"+IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n\t\t\t\tint routemetric2 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n                log.debug(\"storeSnmpCollection: routemetric2 is: \"+ (routemetric2 < 1 ? \"less than 1\" : routemetric2)+\"; IP_ROUTE_METRIC2: \"+IpRouteTableEntry.IP_ROUTE_METRIC2);\r\n                \r\n\t\t\t\tint routemetric3  =ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC3);\r\n                log.debug(\"storeSnmpCollection: routemetric3 is: \"+ (routemetric3 < 1 ? \"less than 1\" : routemetric3)+\"; IP_ROUTE_METRIC3: \"+IpRouteTableEntry.IP_ROUTE_METRIC3);\r\n                \r\n\t\t\t\tint routemetric4 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC4);\r\n                log.debug(\"storeSnmpCollection: routemetric4 is: \"+ (routemetric4 < 1 ? \"less than 1\" : routemetric4)+\"; IP_ROUTE_METRIC4: \"+IpRouteTableEntry.IP_ROUTE_METRIC4);\r\n                \r\n\t\t\t\tint routemetric5 = ent.getInt32(IpRouteTableEntry.IP_ROUTE_METRIC5);\r\n                log.debug(\"storeSnmpCollection: routemetric5 is: \"+ (routemetric5 < 1 ? \"less than 1\" : routemetric5)+\"; IP_ROUTE_METRIC5: \"+IpRouteTableEntry.IP_ROUTE_METRIC5);\r\n                \r\n\t\t\t\tint routetype = ent.getInt32(IpRouteTableEntry.IP_ROUTE_TYPE);\r\n                log.debug(\"storeSnmpCollection: routetype is: \"+ (routetype < 1 ? \"less than 1\" : routetype)+\"; IP_ROUTE_TYPE: \"+IpRouteTableEntry.IP_ROUTE_TYPE);\r\n                \r\n\t\t\t\tint routeproto = ent.getInt32(IpRouteTableEntry.IP_ROUTE_PROTO);\r\n                log.debug(\"storeSnmpCollection: routeproto is: \"+ (routeproto < 1 ? \"less than 1\" : routeproto)+\"; IP_ROUTE_PROTO: \"+IpRouteTableEntry.IP_ROUTE_PROTO);\r\n                \r\n\r\n\t\t\t\t// info used for Discovery Link\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tRouterInterface routeIface = null;\r\n\t\t\t\trouteIface = getNodeidMaskFromIp(dbConn,nexthop);\r\n\r\n\t\t\t\t// if target node is not snmp node try to save info\r\n\t\t\t\tif (routeIface == null) {\r\n\t\t\t\t\trouteIface = getNodeFromIp(dbConn, nexthop);\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\tif (routeIface == null) {\r\n\t\t\t\t\t//TODO here is a good point for autodiscovery\r\n\t\t\t\t\tlog.warn(\"store: No nodeid found for next hop ip\" + nexthop \r\n\t\t\t\t\t\t\t+ \" Skipping ip route interface add to Linkable Snmp Node\");\r\n\t\t\t\t\t// try to find it in ipinterface\r\n\t\t\t\t} else {\r\n\t\t\t\t\tint snmpiftype = -2;\r\n\t\t\t\t\tif (ifindex > 0) snmpiftype = getSnmpIfType(dbConn, nodeid, ifindex);\r\n\r\n\t\t\t\t\t// no processing ethernet type\r\n\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\tlog.debug(\"store: interface has snmpiftype \"\r\n\t\t\t\t\t\t\t\t\t+ snmpiftype + \" . Adding to DiscoverLink \");\r\n\r\n\t\t\t\t\trouteIface.setSnmpiftype(snmpiftype);\r\n\t\t\t\t\trouteIface.setIfindex(ifindex);\r\n\t\t\t\t\trouteIface.setMetric(routemetric1);\r\n\t\t\t\t\trouteIface.setNextHop(nexthop);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\trouteInterfaces.add(routeIface);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// save info to DB\r\n\t\t\t\tDbIpRouteInterfaceEntry iprouteInterfaceEntry = DbIpRouteInterfaceEntry\r\n\t\t\t\t\t\t.get(dbConn, nodeid, routedest.getHostAddress());\r\n\t\t\t\tif (iprouteInterfaceEntry == null) {\r\n\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\tiprouteInterfaceEntry = DbIpRouteInterfaceEntry.create(\r\n\t\t\t\t\t\t\tm_node.getNodeId(), routedest.getHostAddress());\r\n\t\t\t\t}\r\n\t\t\t\t// update object\r\n\t\t\t\tiprouteInterfaceEntry.updateRouteMask(routemask.getHostAddress());\r\n\t\t\t\tiprouteInterfaceEntry.updateRouteNextHop(nexthop.getHostAddress());\r\n\t\t\t\tiprouteInterfaceEntry.updateIfIndex(ifindex);\r\n\t\t\t\tif (routemetric1 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric1(routemetric1);\r\n\t\t\t\tif (routemetric2 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric2(routemetric2);\r\n\t\t\t\tif (routemetric3 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric3(routemetric3);\r\n\t\t\t\tif (routemetric4 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric4(routemetric4);\r\n\t\t\t\tif (routemetric5 != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteMetric5(routemetric5);\r\n\t\t\t\tif (routetype != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteType(routetype);\r\n\t\t\t\tif (routeproto != -1)\r\n\t\t\t\t\tiprouteInterfaceEntry.updateRouteProto(routeproto);\r\n\t\t\t\tiprouteInterfaceEntry\r\n\t\t\t\t\t\t.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);\r\n\t\t\t\tiprouteInterfaceEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t// store object in database\r\n\t\t\t\tiprouteInterfaceEntry.store(dbConn);\r\n\t\t\t}\r\n\t\t\tm_node.setRouteInterfaces(routeInterfaces);\r\n\t\t}\r\n\t\t// STARTS loop on vlans\r\n\r\n\t\tif (m_snmpcoll.hasVlanTable()) {\r\n\t\t\t\r\n\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\tlog\r\n\t\t\t\t\t\t.debug(\"store: saving SnmpVlanCollection in DB\");\r\n\t\t\tite = m_snmpcoll.getSnmpVlanCollections()\r\n\t\t\t\t\t.iterator();\r\n\t\t\twhile (ite.hasNext()) {\r\n\t\t\t\tSnmpVlanCollection snmpVlanColl = (SnmpVlanCollection) ite\r\n\t\t\t\t\t\t.next();\r\n\r\n\t\t\t\tString vlanindex = snmpVlanColl.getVlanIndex();\r\n\t\t\t\tint vlan = Integer.parseInt(vlanindex);\r\n\t\t\t\tString vlanname = snmpVlanColl.getVlanName();\r\n\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t.debug(\"store: parsing VLAN \"\r\n\t\t\t\t\t\t\t\t\t+ vlanindex + \" VLAN_NAME \" + vlanname);\r\n\r\n\t\t\t\tif (snmpVlanColl.hasDot1dBase()) {\r\n\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t.debug(\"store: saving Dot1dBaseGroup in stpnode table\");\r\n\r\n\t\t\t\t\tDot1dBaseGroup dod1db = (Dot1dBaseGroup) snmpVlanColl.getDot1dBase();\r\n\t\t\t\t\tString baseBridgeAddress = dod1db.getBridgeAddress();\r\n\t\t\t\t\tint basenumports = dod1db.getNumberOfPorts();\r\n\t\t\t\t\tint bridgetype = dod1db.getBridgeType();\r\n\t\t\t\t\t\r\n\r\n\t\t\t\t\tif (baseBridgeAddress == \"000000000000\") {\r\n\t\t\t\t\t\tlog.warn(\"store: base bridge address \" + baseBridgeAddress\r\n\t\t\t\t\t\t\t\t+ \" is invalid for ipaddress \" );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm_node.addBridgeIdentifier(baseBridgeAddress,vlanindex);\r\n\t\t\t\t\t\tDbStpNodeEntry dbStpNodeEntry = DbStpNodeEntry.get(dbConn,\r\n\t\t\t\t\t\t\tm_node.getNodeId(), vlan);\r\n\t\t\t\t\t\tif (dbStpNodeEntry == null) {\r\n\t\t\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\t\t\tdbStpNodeEntry = DbStpNodeEntry.create(m_node\r\n\t\t\t\t\t\t\t\t.getNodeId(), vlan);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// update object\r\n\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseBridgeAddress(baseBridgeAddress);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseNumPorts(basenumports);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseType(bridgetype);\r\n\t\t\t\t\t\tdbStpNodeEntry.updateBaseVlanName(vlanname);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dStp()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\"store: adding Dot1dStpGroup in stpnode table\");\r\n\r\n\t\t\t\t\t\t\tDot1dStpGroup dod1stp = (Dot1dStpGroup) snmpVlanColl\r\n\t\t\t\t\t\t\t\t.getDot1dStp();\r\n\t\t\t\t\t\t\tint protospec = dod1stp.getStpProtocolSpecification();\r\n\t\t\t\t\t\t\tint stppriority = dod1stp.getStpPriority();\r\n\t\t\t\t\t\t\tString stpDesignatedRoot = dod1stp.getStpDesignatedRoot();\r\n\t\t\t\t\t\t\tint stprootcost = dod1stp.getStpRootCost();\r\n\t\t\t\t\t\t\tint stprootport = dod1stp.getStpRootPort();\r\n\r\n\t\t\t\t\t\t\tif (stpDesignatedRoot != \"0000000000000000\") {\r\n\t\t\t\t\t\t\t\tm_node.setVlanStpRoot(vlanindex,stpDesignatedRoot);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpProtocolSpecification(protospec);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpPriority(stppriority);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpDesignatedRoot(stpDesignatedRoot);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpRootCost(stprootcost);\r\n\t\t\t\t\t\t\tdbStpNodeEntry.updateStpRootPort(stprootport);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t// store object in database\r\n\t\t\t\t\t\tdbStpNodeEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\tdbStpNodeEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\tdbStpNodeEntry.store(dbConn);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dBasePortTable()) {\r\n\t\t\t\t\t\t\tIterator sub_ite = snmpVlanColl.getDot1dBasePortTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\"store: saving Dot1dBasePortTable in stpinterface table\");\r\n\t\t\t\t\t\t\twhile (sub_ite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dBasePortTableEntry dot1dbaseptentry = (Dot1dBasePortTableEntry) sub_ite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tint baseport = dot1dbaseptentry.getInt32(Dot1dBasePortTableEntry.BASE_PORT);\r\n\t\t\t\t\t\t\t\tint ifindex = dot1dbaseptentry.getInt32(Dot1dBasePortTableEntry.BASE_IFINDEX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tm_node.setIfIndexBridgePort(ifindex,baseport);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tDbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry\r\n\t\t\t\t\t\t\t\t\t.get(dbConn, m_node.getNodeId(),\r\n\t\t\t\t\t\t\t\t\t\t\tbaseport, vlan);\r\n\t\t\t\t\t\t\t\tif (dbStpIntEntry == null) {\r\n\t\t\t\t\t\t\t\t// Create a new entry\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry = DbStpInterfaceEntry.create(\r\n\t\t\t\t\t\t\t\t\t\tm_node.getNodeId(), baseport, vlan);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.updateIfIndex(ifindex);\r\n\r\n\t\t\t\t\t\t\t\tdbStpIntEntry\r\n\t\t\t\t\t\t\t\t\t.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\t\t\tdbStpIntEntry.store(dbConn);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dStpPortTable()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t.debug(\" store: adding Dot1dStpPortTable in stpinterface table\");\r\n\t\t\t\t\t\t\tIterator sub_ite = snmpVlanColl.getDot1dStpPortTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\twhile (sub_ite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dStpPortTableEntry dot1dstpptentry = (Dot1dStpPortTableEntry) sub_ite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tint stpport = dot1dstpptentry.getInt32(Dot1dStpPortTableEntry.STP_PORT);\r\n\t\t\t\t\t\t\t\tDbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry\r\n\t\t\t\t\t\t\t\t\t.get(dbConn, m_node.getNodeId(),\r\n\t\t\t\t\t\t\t\t\t\t\tstpport, vlan);\r\n\t\t\t\t\t\t\t\tif (dbStpIntEntry == null) {\r\n\t\t\t\t\t\t\t\t// Cannot create the object becouse must exists the dot1dbase\r\n\t\t\t\t\t\t\t\t// object!!!!!\r\n\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.warn(\"store StpInterface: when storing STP info\"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for bridge node with nodeid \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ m_node.getNodeId()\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" bridgeport number \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ stpport\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" and vlan index \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ vlanindex\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" info not found in database, ERROR skipping.....\");\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tint stpportstate = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_STATE);\r\n\t\t\t\t\t\t\t\t\tint stpportpathcost = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_PATH_COST);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedBridge = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_BRIDGE);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedRoot = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_ROOT);\r\n\t\t\t\t\t\t\t\t\tint stpportdesignatedcost = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getInt32(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_COST);\r\n\t\t\t\t\t\t\t\t\tString stpPortDesignatedPort = dot1dstpptentry\r\n\t\t\t\t\t\t\t\t\t\t.getHexString(Dot1dStpPortTableEntry.STP_PORT_DESIGNATED_PORT);\r\n\t\t\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\t\t\t\tif (stpPortDesignatedBridge.equals(\"0000000000000000\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog.warn(\"storeSnmpCollection: designated bridge is invalid not adding to discoveryLink\");\r\n\t\t\t\t\t\t\t\t\t} else if (stpPortDesignatedPort.equals(\"0000\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog.warn(\"storeSnmpCollection: designated port is invalid not adding to discoveryLink\");\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tBridgeStpInterface stpIface = new BridgeStpInterface(stpport,vlanindex);\r\n\t\t\t\t\t\t\t\t\t\tstpIface.setStpPortDesignatedBridge(stpPortDesignatedBridge);\r\n\t\t\t\t\t\t\t\t\t\tstpIface.setStpPortDesignatedPort(stpPortDesignatedPort);\r\n\t\t\t\t\t\t\t\t\t\tm_node.addStpInterface(stpIface);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortState(stpportstate);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortPathCost(stpportpathcost);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedBridge(stpPortDesignatedBridge);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedRoot(stpPortDesignatedRoot);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpPortDesignatedCost(stpportdesignatedcost);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStpportDesignatedPort(stpPortDesignatedPort);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.set_lastpolltime(now);\r\n\r\n\t\t\t\t\t\t\t\t\tdbStpIntEntry.store(dbConn);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (snmpVlanColl.hasDot1dTpFdbTable()) {\r\n\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t.debug(\"store: parsing Dot1dTpFdbTable\");\r\n\r\n\t\t\t\t\t\t\tIterator subite = snmpVlanColl.getDot1dFdbTable()\r\n\t\t\t\t\t\t\t\t.getEntries().iterator();\r\n\t\t\t\t\t\t\twhile (subite.hasNext()) {\r\n\t\t\t\t\t\t\t\tDot1dTpFdbTableEntry dot1dfdbentry = (Dot1dTpFdbTableEntry) subite\r\n\t\t\t\t\t\t\t\t\t.next();\r\n\t\t\t\t\t\t\t\tString curMacAddress = dot1dfdbentry\r\n\t\t\t\t\t\t\t\t\t.getHexString(Dot1dTpFdbTableEntry.FDB_ADDRESS);\r\n\r\n\t\t\t\t\t\t\t\tint fdbport = dot1dfdbentry.getInt32(Dot1dTpFdbTableEntry.FDB_PORT);\r\n\r\n\t\t\t\t\t\t\t\tif (fdbport == 0) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"populateBridge: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" learned on invalid port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tint curfdbstatus = dot1dfdbentry.getInt32(Dot1dTpFdbTableEntry.FDB_STATUS);\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_LEARNED) {\r\n\t\t\t\t\t\t\t\t\tm_node.addMacAddress(fdbport,\r\n\t\t\t\t\t\t\t\t\t\tcurMacAddress, vlanindex);\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.debug(\"storeSnmpCollection: found learned mac address \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" on bridge port \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ fdbport\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for VLAN \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ snmpVlanColl.getVlanIndex());\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_SELF) {\r\n\t\t\t\t\t\t\t\t\tm_node.addBridgeIdentifier(curMacAddress);\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\tlog\r\n\t\t\t\t\t\t\t\t\t\t\t.debug(\"storeSnmpCollection: found bridge identifier \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" for VLAN \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ snmpVlanColl.getVlanIndex()\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" and bridge port \"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ fdbport);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_INVALID) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has INVALID status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_MGMT) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has MGMT status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (curfdbstatus == SNMP_DOT1D_FDB_STATUS_OTHER) {\r\n\t\t\t\t\t\t\t\t\tif (log.isDebugEnabled())\r\n\t\t\t\t\t\t\t\t\t\tlog.debug(\"storeSnmpCollection: macaddress \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ curMacAddress\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" has OTHER status on port \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ fdbport + \" . Skipping\");\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//now adding bridge identifier mac addresses of switch from snmpinterface\r\n\t\t\t\t\t\tsetBridgeIdentifierFromSnmpInterface(dbConn);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tupdate(dbConn, now);\r\n\t\t\r\n\t}","commit_id":"48ba4871a75515fa56c88d0996231782339e9204","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\r\n    protected void onResume() {\r\n        Gdx.app = this;\r\n        Gdx.input = this.getInput();\r\n        Gdx.audio = this.getAudio();\r\n        Gdx.files = this.getFiles();\r\n        Gdx.graphics = this.getGraphics();\r\n\r\n        ((AndroidInput)getInput()).registerSensorListeners();\r\n        \r\n        if (graphics != null && graphics.view != null) {\r\n            if (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake) graphics.view).onResume();\r\n            if (graphics.view instanceof android.opengl.GLSurfaceView)\r\n                ((android.opengl.GLSurfaceView) graphics.view).onResume();\r\n        }\r\n\r\n        if (audio != null) audio.resume();\r\n        if (!firstResume)\r\n            graphics.resume();\r\n        else\r\n            firstResume = false;\r\n        super.onResume();\r\n    }","id":76970,"modified_method":"@Override\r\n    protected void onResume() {\r\n   \t if(wakeLock != null) wakeLock.acquire();   \t \r\n        Gdx.app = this;\r\n        Gdx.input = this.getInput();\r\n        Gdx.audio = this.getAudio();\r\n        Gdx.files = this.getFiles();\r\n        Gdx.graphics = this.getGraphics();\r\n\r\n        ((AndroidInput)getInput()).registerSensorListeners();\r\n        \r\n        if (graphics != null && graphics.view != null) {\r\n            if (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake) graphics.view).onResume();\r\n            if (graphics.view instanceof android.opengl.GLSurfaceView)\r\n                ((android.opengl.GLSurfaceView) graphics.view).onResume();\r\n        }\r\n\r\n        if (audio != null) audio.resume();\r\n        if (!firstResume)\r\n            graphics.resume();\r\n        else\r\n            firstResume = false;\r\n        super.onResume();\r\n    }","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n     * This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get\r\n     * input, render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0\r\n     * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be\r\n     * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the\r\n     * {@link Graphics#isGL20Available()} method. Sleep time in touch event handler is 0, so no sleeping is performed.\r\n     *\r\n     * @param listener          the {@link ApplicationListener} implementing the program logic\r\n     * @param useGL2IfAvailable whether to use OpenGL ES 2.0 if its available.\r\n     */\r\n    public void initialize(ApplicationListener listener, boolean useGL2IfAvailable) {\r\n        initialize(listener, useGL2IfAvailable, new FillResolutionStrategy(), 0);\r\n    }","id":76971,"modified_method":"/**\r\n     * This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get\r\n     * input, render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0\r\n     * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be\r\n     * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the\r\n     * {@link Graphics#isGL20Available()} method. Uses a default {@link AndroidApplicationConfiguration}.\r\n     *\r\n     * @param listener          the {@link ApplicationListener} implementing the program logic\r\n     * @param useGL2IfAvailable whether to use OpenGL ES 2.0 if its available.\r\n     */\r\n    public void initialize(ApplicationListener listener, boolean useGL2IfAvailable) {\r\n   \t AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();\r\n   \t config.useGL20 = useGL2IfAvailable;\r\n       initialize(listener, config);\r\n    }","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n    protected void onPause() {\r\n        graphics.pause();\r\n        \r\n        if (audio != null) audio.pause();\r\n        \r\n        input.unregisterSensorListeners();\r\n        \r\n        if (isFinishing()) {      \t\r\n           graphics.clearManagedCaches();\r\n           graphics.destroy();           \r\n        }\r\n        \r\n        if (graphics != null && graphics.view != null) {\r\n            if (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake) graphics.view).onPause();\r\n            if (graphics.view instanceof android.opengl.GLSurfaceView)\r\n                ((android.opengl.GLSurfaceView) graphics.view).onPause();\r\n        }        \r\n        \r\n        super.onPause();\r\n    }","id":76972,"modified_method":"@Override\r\n    protected void onPause() {\r\n   \t if(wakeLock != null) wakeLock.release();\r\n        graphics.pause();\r\n        \r\n        if (audio != null) audio.pause();\r\n        \r\n        input.unregisterSensorListeners();\r\n        \r\n        if (isFinishing()) {      \t\r\n           graphics.clearManagedCaches();\r\n           graphics.destroy();           \r\n        }\r\n        \r\n        if (graphics != null && graphics.view != null) {\r\n            if (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake) graphics.view).onPause();\r\n            if (graphics.view instanceof android.opengl.GLSurfaceView)\r\n                ((android.opengl.GLSurfaceView) graphics.view).onPause();\r\n        }        \r\n        \r\n        super.onPause();\r\n    }","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n     * This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get\r\n     * input, render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0\r\n     * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be\r\n     * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the\r\n     * {@link Graphics#isGL20Available()} method. sleepTime specifies the number of milliseconds to sleep in the touch event\r\n     * handler. This may be used on <= 1.6 Android devices. Note that it will not solve the CPU usage problem of the event handler\r\n     * of the Android system. Things will still slow down.\r\n     * <p/>\r\n     * Note: you have to add the returned view to your layout!\r\n     *\r\n     * @param listener          the {@link ApplicationListener} implementing the program logic\r\n     * @param useGL2IfAvailable whether to use OpenGL ES 2.0 if its available.\r\n     * @param resolutionStrategy will position and size the GLSurfaceView by the given strategy\r\n     * @param sleepTime         specifies the number of milliseconds to sleep in the touch event handler\r\n     * @return the GLSurfaceView of the application\r\n     */\r\n    public View initializeForView(ApplicationListener listener, boolean useGL2IfAvailable, ResolutionStrategy resolutionStrategy, int sleepTime) {\r\n        graphics = new AndroidGraphics(this, useGL2IfAvailable, resolutionStrategy);\r\n        input = new AndroidInput(this, graphics.view, sleepTime);\r\n        audio = new AndroidAudio(this);\r\n        files = new AndroidFiles(this.getAssets());\r\n        this.listener = listener;\r\n        this.handler = new Handler();\r\n\r\n        Gdx.app = this;\r\n        Gdx.input = this.getInput();\r\n        Gdx.audio = this.getAudio();\r\n        Gdx.files = this.getFiles();\r\n        Gdx.graphics = this.getGraphics();\r\n\r\n        return graphics.getView();\r\n    }","id":76973,"modified_method":"/**\r\n     * This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get\r\n     * input, render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0\r\n     * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be\r\n     * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the\r\n     * {@link Graphics#isGL20Available()} method. Uses a default {@link AndroidApplicationConfiguration}.\r\n     * <p/>\r\n     * Note: you have to add the returned view to your layout!\r\n     *\r\n     * @param listener          the {@link ApplicationListener} implementing the program logic\r\n     * @param useGL2IfAvailable whether to use OpenGL ES 2.0 if its available.\r\n     * @return the GLSurfaceView of the application\r\n     */\r\n    public View initializeForView(ApplicationListener listener, boolean useGL2IfAvailable) {\r\n   \t AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();\r\n   \t config.useGL20 = useGL2IfAvailable;\r\n       return initializeForView(listener, config);\r\n    }","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"void registerSensorListeners() {\t\t\r\n\t\tmanager = (SensorManager)app.getSystemService(Context.SENSOR_SERVICE);\r\n\t\tif (manager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() == 0) {\r\n\t\t\taccelerometerAvailable = false;\r\n\t\t} else {\r\n\t\t\tSensor accelerometer = manager.getSensorList(Sensor.TYPE_ACCELEROMETER).get(0);\r\n\t\t\taccelerometerAvailable = manager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_GAME);\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tSensor sensor = manager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\r\n\t\tif(sensor != null) {\r\n\t\t\tcompassAvailable = accelerometerAvailable;\r\n\t\t\tif(compassAvailable) {\r\n\t\t\t\tcompassAvailable = manager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_GAME);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcompassAvailable = false;\r\n\t\t}\r\n\t\tGdx.app.log(\"AndroidInput\", \"sensor listener setup\");\r\n\t}","id":76974,"modified_method":"void registerSensorListeners() {\t\t\r\n\t\tif(config.useAccelerometer) {\r\n\t\t\tmanager = (SensorManager)app.getSystemService(Context.SENSOR_SERVICE);\r\n\t\t\tif (manager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() == 0) {\r\n\t\t\t\taccelerometerAvailable = false;\r\n\t\t\t} else {\r\n\t\t\t\tSensor accelerometer = manager.getSensorList(Sensor.TYPE_ACCELEROMETER).get(0);\r\n\t\t\t\taccelerometerAvailable = manager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_GAME);\t\t\t\t\r\n\t\t\t}\r\n\t\t} else accelerometerAvailable = false;\r\n\t\t\r\n\t\tif(config.useCompass) {\r\n\t\t\tif(manager == null) manager = (SensorManager)app.getSystemService(Context.SENSOR_SERVICE);\r\n\t\t\tSensor sensor = manager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\r\n\t\t\tif(sensor != null) {\r\n\t\t\t\tcompassAvailable = accelerometerAvailable;\r\n\t\t\t\tif(compassAvailable) {\r\n\t\t\t\t\tcompassAvailable = manager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_GAME);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcompassAvailable = false;\r\n\t\t\t}\r\n\t\t} else compassAvailable = false;\r\n\t\tGdx.app.log(\"AndroidInput\", \"sensor listener setup\");\r\n\t}","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"void unregisterSensorListeners() {\t\t\r\n\t\tmanager.unregisterListener(this);\r\n\t\tmanager = null;\r\n\t\tGdx.app.log(\"AndroidInput\", \"sensor listener tear down\");\r\n\t}","id":76975,"modified_method":"void unregisterSensorListeners() {\t\r\n\t\tif(manager != null) {\r\n\t\t\tmanager.unregisterListener(this);\r\n\t\t\tmanager = null;\r\n\t\t}\r\n\t\tGdx.app.log(\"AndroidInput\", \"sensor listener tear down\");\r\n\t}","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"public AndroidInput (AndroidApplication activity, View view, int sleepTime) {\r\n\t\tview.setOnKeyListener(this);\r\n\t\tview.setOnTouchListener(this);\r\n\t\tview.setFocusable(true);\r\n\t\tview.setFocusableInTouchMode(true);\r\n\t\tview.requestFocus();\r\n\t\tview.requestFocusFromTouch();\r\n\t\t\r\n\t\thandle = new Handler();\r\n\t\tthis.app = activity;\r\n\t\tthis.sleepTime = sleepTime;\r\n\t\tint sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);\r\n\t\tif (sdkVersion >= 5)\r\n\t\t\ttouchHandler = new AndroidMultiTouchHandler();\r\n\t\telse\r\n\t\t\ttouchHandler = new AndroidSingleTouchHandler();\r\n\t\thasMultitouch = touchHandler instanceof AndroidMultiTouchHandler\r\n\t\t\t&& ((AndroidMultiTouchHandler)touchHandler).supportsMultitouch(activity);\r\n\r\n\t\tvibrator = (Vibrator)activity.getSystemService(Context.VIBRATOR_SERVICE);\t\t\t\t\t\r\n\t}","id":76976,"modified_method":"public AndroidInput (AndroidApplication activity, View view, AndroidApplicationConfiguration config) {\r\n\t\tview.setOnKeyListener(this);\r\n\t\tview.setOnTouchListener(this);\r\n\t\tview.setFocusable(true);\r\n\t\tview.setFocusableInTouchMode(true);\r\n\t\tview.requestFocus();\r\n\t\tview.requestFocusFromTouch();\r\n\t\tthis.config = config;\r\n\t\t\r\n\t\thandle = new Handler();\r\n\t\tthis.app = activity;\r\n\t\tthis.sleepTime = config.touchSleepTime;\r\n\t\tint sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);\r\n\t\tif (sdkVersion >= 5)\r\n\t\t\ttouchHandler = new AndroidMultiTouchHandler();\r\n\t\telse\r\n\t\t\ttouchHandler = new AndroidSingleTouchHandler();\r\n\t\thasMultitouch = touchHandler instanceof AndroidMultiTouchHandler\r\n\t\t\t&& ((AndroidMultiTouchHandler)touchHandler).supportsMultitouch(activity);\r\n\r\n\t\tvibrator = (Vibrator)activity.getSystemService(Context.VIBRATOR_SERVICE);\t\t\t\t\t\r\n\t}","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Called when the activity is first created. */\n\t@Override public void onCreate (Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tinitialize(new Bouncy(), false, new FillResolutionStrategy(), 16);\n\t}","id":76977,"modified_method":"/** Called when the activity is first created. */\n\t@Override public void onCreate (Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tinitialize(new Bouncy(), false);\n\t}","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Called when the activity is first created. */\n\t@Override public void onCreate (Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\tinitialize(new GdxInvaders(),false, new FillResolutionStrategy(), 20);\t\t\n\t}","id":76978,"modified_method":"/** Called when the activity is first created. */\n\t@Override public void onCreate (Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\tAndroidApplicationConfiguration config = new AndroidApplicationConfiguration();\n\t\tconfig.useWakelock = true;\t\t\n\t\tinitialize(new GdxInvaders(),config);\t\t\n\t}","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void onCreate (Bundle bundle) {\r\n\t\tsuper.onCreate(bundle);\r\n\r\n\t\tBundle extras = getIntent().getExtras();\r\n\t\tString testName = (String)extras.get(\"test\");\r\n\r\n\t\tGdxTest test = GdxTests.newTest(testName);\r\n\t\tinitialize(test, test.needsGL20());\r\n\t}","id":76979,"modified_method":"public void onCreate (Bundle bundle) {\r\n\t\tsuper.onCreate(bundle);\r\n\r\n\t\tBundle extras = getIntent().getExtras();\r\n\t\tString testName = (String)extras.get(\"test\");\r\n\r\n\t\tGdxTest test = GdxTests.newTest(testName);\r\n\t\tAndroidApplicationConfiguration config = new AndroidApplicationConfiguration();\r\n\t\tconfig.useGL20 = test.needsGL20();\t\t\r\n\t\tinitialize(test, config);\r\n\t}","commit_id":"842e645b9e863dc2f4f310afb34142a7b1214355","url":"https://github.com/libgdx/libgdx"},{"original_method":"@FXML\n    @Override\n    protected void initialize() {\n        super.initialize();\n        assert imageBorder != null : \"fx:id=\\\"imageAnchor\\\" was not injected: check your FXML file 'DrawableTile.fxml'.\";\n        assert imageView != null : \"fx:id=\\\"imageView\\\" was not injected: check your FXML file 'DrawableTile.fxml'.\";\n        assert nameLabel != null : \"fx:id=\\\"nameLabel\\\" was not injected: check your FXML file 'DrawableTile.fxml'.\";\n\n        //set up properties and binding\n        setCache(true);\n        setCacheHint(CacheHint.SPEED);\n        nameLabel.prefWidthProperty().bind(imageView.fitWidthProperty());\n\n        imageView.fitHeightProperty().bind(Toolbar.getDefault().sizeSliderValue());\n        imageView.fitWidthProperty().bind(Toolbar.getDefault().sizeSliderValue());\n\n        globalSelectionModel.lastSelectedProperty().addListener((observable, oldValue, newValue) -> {\n            try {\n                setEffect(Objects.equals(newValue, fileID) ? LAST_SELECTED_EFFECT : null);\n            } catch (java.lang.IllegalStateException ex) {\n                Logger.getLogger(DrawableTile.class.getName()).log(Level.WARNING, \"Error displaying tile\");\n            }\n        });\n    }","id":76980,"modified_method":"@FXML\n    @Override\n    protected void initialize() {\n        super.initialize();\n        assert imageBorder != null : \"fx:id=\\\"imageAnchor\\\" was not injected: check your FXML file 'DrawableTile.fxml'.\";\n        assert imageView != null : \"fx:id=\\\"imageView\\\" was not injected: check your FXML file 'DrawableTile.fxml'.\";\n        assert nameLabel != null : \"fx:id=\\\"nameLabel\\\" was not injected: check your FXML file 'DrawableTile.fxml'.\";\n\n        //set up properties and binding\n        setCache(true);\n        setCacheHint(CacheHint.SPEED);\n        nameLabel.prefWidthProperty().bind(imageView.fitWidthProperty());\n\n        imageView.fitHeightProperty().bind(Toolbar.getDefault().sizeSliderValue());\n        imageView.fitWidthProperty().bind(Toolbar.getDefault().sizeSliderValue());\n\n        globalSelectionModel.lastSelectedProperty().addListener((observable, oldValue, newValue) -> {\n            try {\n                setEffect(Objects.equals(newValue, getFileID()) ? LAST_SELECTED_EFFECT : null);\n            } catch (java.lang.IllegalStateException ex) {\n                Logger.getLogger(DrawableTile.class.getName()).log(Level.WARNING, \"Error displaying tile\");\n            }\n        });\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public DrawableTile(GroupPane gp) {\n        super();\n        FXMLConstructor.construct(this, \"DrawableTile.fxml\");\n        groupPane = gp;\n    }","id":76981,"modified_method":"public DrawableTile(GroupPane gp) {\n        super(gp);\n        FXMLConstructor.construct(this, \"DrawableTile.fxml\");\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    protected Runnable getContentUpdateRunnable() {\n        Image image = file.getThumbnail();\n\n        return () -> {\n            imageView.setImage(image);\n        };\n    }","id":76982,"modified_method":"@Override\n    protected Runnable getContentUpdateRunnable() {\n        Image image = getFile().getThumbnail();\n\n        return () -> {\n            imageView.setImage(image);\n        };\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    @ThreadConfined(type = ThreadType.UI)\n    protected String getLabelText() {\n        return file.getName();\n    }","id":76983,"modified_method":"@Override\n    protected String getTextForLabel() {\n        return getFile().getName();\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * {@inheritDoc }\n     */\n    @Override\n    protected void updateSelectionState() {\n        super.updateSelectionState();\n        final boolean lastSelected = Objects.equals(globalSelectionModel.lastSelectedProperty().get(), fileID);\n        Platform.runLater(() -> {\n            setEffect(lastSelected ? LAST_SELECTED_EFFECT : null);\n        });\n    }","id":76984,"modified_method":"/**\n     * {@inheritDoc }\n     */\n    @Override\n    protected void updateSelectionState() {\n        super.updateSelectionState();\n        final boolean lastSelected = Objects.equals(globalSelectionModel.lastSelectedProperty().get(), getFileID());\n        Platform.runLater(() -> {\n            setEffect(lastSelected ? LAST_SELECTED_EFFECT : null);\n        });\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * update the visual representation of the selection state of this\n     * DrawableView\n     */\n    protected void updateSelectionState() {\n        final boolean selected = globalSelectionModel.isSelected(fileID);\n        Platform.runLater(() -> {\n            setBorder(selected ? SELECTED_BORDER : UNSELECTED_BORDER);\n        });\n    }","id":76985,"modified_method":"/**\n     * update the visual representation of the selection state of this\n     * DrawableView\n     */\n    synchronized protected void updateSelectionState() {\n        final boolean selected = globalSelectionModel.isSelected(getFileID());\n        Platform.runLater(() -> {\n            setBorder(selected ? SELECTED_BORDER : UNSELECTED_BORDER);\n        });\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void setFile(final Long fileID) {\n        if (Objects.equals(fileID, this.fileID) == false) {\n            this.fileID = fileID;\n            disposeContent();\n\n            if (this.fileID == null || Case.isCaseOpen() == false) {\n                ImageGalleryController.getDefault().getCategoryManager().unregisterListener(this);\n                TagUtils.unregisterListener(this);\n                file = null;\n                Platform.runLater(() -> {\n                    clearContent();\n                });\n            } else {\n                ImageGalleryController.getDefault().getCategoryManager().registerListener(this);\n                TagUtils.registerListener(this);\n\n                getFile();\n                updateSelectionState();\n                updateCategoryBorder();\n                updateFollowUpIcon();\n                final String text = getLabelText();\n                final boolean isVideo = file.isVideo();\n                final boolean hasHashSetHits = hasHashHit();\n                Platform.runLater(() -> {\n                    updateUI(isVideo, hasHashSetHits, text);\n                });\n                Platform.runLater(getContentUpdateRunnable());\n            }\n        }\n    }","id":76986,"modified_method":"@Override\n    synchronized public void setFile(final Long fileID) {\n        if (Objects.equals(fileID, this.fileID) == false) {\n            this.fileID = fileID;\n            disposeContent();\n\n            if (this.fileID == null || Case.isCaseOpen() == false) {\n                if (registered == true) {\n                    ImageGalleryController.getDefault().getCategoryManager().unregisterListener(this);\n                    TagUtils.unregisterListener(this);\n                    registered = false;\n                }\n                file = null;\n                Platform.runLater(() -> {\n                    clearContent();\n                });\n            } else {\n                if (registered == false) {\n                    ImageGalleryController.getDefault().getCategoryManager().registerListener(this);\n                    TagUtils.registerListener(this);\n                    registered = true;\n                }\n                file = null;\n                getFile();\n                updateSelectionState();\n                updateCategoryBorder();\n                updateFollowUpIcon();\n                updateUI();\n                Platform.runLater(getContentUpdateRunnable());\n            }\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    protected void initialize() {\n        followUpToggle.setOnAction((ActionEvent t) -> {\n            if (followUpToggle.isSelected() == true) {\n                globalSelectionModel.clearAndSelect(fileID);\n                try {\n                    AddDrawableTagAction.getInstance().addTag(TagUtils.getFollowUpTagName(), \"\");\n                } catch (TskCoreException ex) {\n                    LOGGER.log(Level.SEVERE, \"Failed to add follow up tag.  Could not load TagName.\", ex);\n                }\n            } else {\n                //TODO: convert this to an action!\n                final ImageGalleryController controller = ImageGalleryController.getDefault();\n                try {\n                    // remove file from old category group\n                    controller.getGroupManager().removeFromGroup(new GroupKey<TagName>(DrawableAttribute.TAGS, TagUtils.getFollowUpTagName()), fileID);\n\n                    List<ContentTag> contentTagsByContent = Case.getCurrentCase().getServices().getTagsManager().getContentTagsByContent(getFile());\n                    for (ContentTag ct : contentTagsByContent) {\n                        if (ct.getName().getDisplayName().equals(TagUtils.getFollowUpTagName().getDisplayName())) {\n                            Case.getCurrentCase().getServices().getTagsManager().deleteContentTag(ct);\n                        }\n                    }\n                    IngestServices.getInstance().fireModuleDataEvent(new ModuleDataEvent(\"TagAction\", BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_FILE)); //NON-NLS\n                    controller.getGroupManager().handleFileUpdate(FileUpdateEvent.newUpdateEvent(Collections.singleton(fileID), DrawableAttribute.TAGS));\n                } catch (TskCoreException ex) {\n                    LOGGER.log(Level.SEVERE, \"Failed to delete follow up tag.\", ex);\n                }\n            }\n        });\n    }","id":76987,"modified_method":"@SuppressWarnings(\"deprecation\")\n    protected void initialize() {\n        followUpToggle.setOnAction((ActionEvent t) -> {\n\n            if (followUpToggle.isSelected() == true) {\n                globalSelectionModel.clearAndSelect(fileID);\n                try {\n                    AddDrawableTagAction.getInstance().addTag(TagUtils.getFollowUpTagName(), \"\");\n                } catch (TskCoreException ex) {\n                    LOGGER.log(Level.SEVERE, \"Failed to add follow up tag.  Could not load TagName.\", ex);\n                }\n            } else {\n                //TODO: convert this to an action!\n                final ImageGalleryController controller = ImageGalleryController.getDefault();\n                try {\n                    // remove file from old category group\n                    controller.getGroupManager().removeFromGroup(new GroupKey<TagName>(DrawableAttribute.TAGS, TagUtils.getFollowUpTagName()), fileID);\n\n                    List<ContentTag> contentTagsByContent = Case.getCurrentCase().getServices().getTagsManager().getContentTagsByContent(file);\n                    for (ContentTag ct : contentTagsByContent) {\n                        if (ct.getName().getDisplayName().equals(TagUtils.getFollowUpTagName().getDisplayName())) {\n                            Case.getCurrentCase().getServices().getTagsManager().deleteContentTag(ct);\n                        }\n                    }\n                    IngestServices.getInstance().fireModuleDataEvent(new ModuleDataEvent(\"TagAction\", BlackboardArtifact.ARTIFACT_TYPE.TSK_TAG_FILE)); //NON-NLS\n                    controller.getGroupManager().handleFileUpdate(FileUpdateEvent.newUpdateEvent(Collections.singleton(fileID), DrawableAttribute.TAGS));\n                } catch (TskCoreException ex) {\n                    LOGGER.log(Level.SEVERE, \"Failed to delete follow up tag.\", ex);\n                }\n            }\n\n        });\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    @Override\n    public void handleCategoryChanged(CategoryChangeEvent evt) {\n        if (evt.getIds().contains(fileID)) {\n            updateCategoryBorder();\n        }\n    }","id":76988,"modified_method":"@Subscribe\n    @Override\n    synchronized public void handleCategoryChanged(CategoryChangeEvent evt) {\n        if (evt.getIds().contains(getFileID())) {\n            updateCategoryBorder();\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"protected void updateFollowUpIcon() {\n        if (file != null) {\n            try {\n                boolean hasFollowUp = hasFollowUp();\n                Platform.runLater(() -> {\n                    followUpImageView.setImage(hasFollowUp ? followUpIcon : followUpGray);\n                    followUpToggle.setSelected(hasFollowUp);\n                });\n            } catch (TskCoreException ex) {\n                Exceptions.printStackTrace(ex);\n            }\n        }\n    }","id":76989,"modified_method":"synchronized protected void updateFollowUpIcon() {\n        if (file != null) {\n            try {\n                boolean hasFollowUp = hasFollowUp();\n                Platform.runLater(() -> {\n                    followUpImageView.setImage(hasFollowUp ? followUpIcon : followUpGray);\n                    followUpToggle.setSelected(hasFollowUp);\n                });\n            } catch (TskCoreException ex) {\n                LOGGER.log(Level.SEVERE, \"Failed to get follow up status for file.\", ex);\n            }\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"protected abstract String getLabelText();","id":76990,"modified_method":"protected abstract String getTextForLabel();","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"protected DrawableViewBase() {\n\n        globalSelectionModel.getSelected().addListener((Observable observable) -> {\n            updateSelectionState();\n        });\n\n        //set up mouse listener\n        //TODO: split this between DrawableTile and SingleDrawableViewBase\n        addEventFilter(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {\n\n            @Override\n            public void handle(MouseEvent t) {\n\n                switch (t.getButton()) {\n                    case PRIMARY:\n                        if (t.getClickCount() == 1) {\n                            if (t.isControlDown()) {\n                                globalSelectionModel.toggleSelection(fileID);\n                            } else {\n                                groupPane.makeSelection(t.isShiftDown(), fileID);\n                            }\n                        } else if (t.getClickCount() > 1) {\n                            groupPane.activateSlideShowViewer(fileID);\n                        }\n                        break;\n                    case SECONDARY:\n\n                        if (t.getClickCount() == 1) {\n                            if (globalSelectionModel.isSelected(fileID) == false) {\n                                groupPane.makeSelection(false, fileID);\n                            }\n                        }\n\n                        if (contextMenu != null) {\n                            contextMenu.hide();\n                        }\n                        final ContextMenu groupContextMenu = groupPane.getContextMenu();\n                        if (groupContextMenu != null) {\n                            groupContextMenu.hide();\n                        }\n                        contextMenu = buildContextMenu();\n                        contextMenu.show(DrawableViewBase.this, t.getScreenX(), t.getScreenY());\n\n                        break;\n                }\n                t.consume();\n            }\n\n            private ContextMenu buildContextMenu() {\n                final ArrayList<MenuItem> menuItems = new ArrayList<>();\n\n                menuItems.add(CategorizeAction.getPopupMenu());\n\n                menuItems.add(AddDrawableTagAction.getInstance().getPopupMenu());\n\n                final MenuItem extractMenuItem = new MenuItem(\"Extract File(s)\");\n                extractMenuItem.setOnAction((ActionEvent t) -> {\n                    SwingUtilities.invokeLater(() -> {\n                        TopComponent etc = WindowManager.getDefault().findTopComponent(ImageGalleryTopComponent.PREFERRED_ID);\n                        ExtractAction.getInstance().actionPerformed(new java.awt.event.ActionEvent(etc, 0, null));\n                    });\n                });\n                menuItems.add(extractMenuItem);\n\n                MenuItem contentViewer = new MenuItem(\"Show Content Viewer\");\n                contentViewer.setOnAction((ActionEvent t) -> {\n                    SwingUtilities.invokeLater(() -> {\n                        new NewWindowViewAction(\"Show Content Viewer\", new FileNode(getFile().getAbstractFile())).actionPerformed(null);\n                    });\n                });\n                menuItems.add(contentViewer);\n\n                MenuItem externalViewer = new MenuItem(\"Open in External Viewer\");\n                final ExternalViewerAction externalViewerAction = new ExternalViewerAction(\"Open in External Viewer\", new FileNode(getFile().getAbstractFile()));\n\n                externalViewer.setDisable(externalViewerAction.isEnabled() == false);\n                externalViewer.setOnAction((ActionEvent t) -> {\n                    SwingUtilities.invokeLater(() -> {\n                        externalViewerAction.actionPerformed(null);\n                    });\n                });\n                menuItems.add(externalViewer);\n\n                Collection<? extends ContextMenuActionsProvider> menuProviders = Lookup.getDefault().lookupAll(ContextMenuActionsProvider.class);\n\n                for (ContextMenuActionsProvider provider : menuProviders) {\n                    for (final Action act : provider.getActions()) {\n                        if (act instanceof Presenter.Popup) {\n                            Presenter.Popup aact = (Presenter.Popup) act;\n                            menuItems.add(SwingMenuItemAdapter.create(aact.getPopupPresenter()));\n                        }\n                    }\n                }\n\n                ContextMenu contextMenu = new ContextMenu(menuItems.toArray(new MenuItem[]{}));\n                contextMenu.setAutoHide(true);\n                return contextMenu;\n            }\n        });\n    }","id":76991,"modified_method":"protected DrawableViewBase(GroupPane groupPane) {\n        this.groupPane = groupPane;\n        globalSelectionModel.getSelected().addListener((Observable observable) -> {\n            updateSelectionState();\n        });\n\n        //set up mouse listener\n        //TODO: split this between DrawableTile and SingleDrawableViewBase\n        addEventFilter(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {\n\n            @Override\n            public void handle(MouseEvent t) {\n\n                switch (t.getButton()) {\n                    case PRIMARY:\n                        if (t.getClickCount() == 1) {\n                            if (t.isControlDown()) {\n                                globalSelectionModel.toggleSelection(fileID);\n                            } else {\n                                groupPane.makeSelection(t.isShiftDown(), fileID);\n                            }\n                        } else if (t.getClickCount() > 1) {\n                            groupPane.activateSlideShowViewer(fileID);\n                        }\n                        break;\n                    case SECONDARY:\n\n                        if (t.getClickCount() == 1) {\n                            if (globalSelectionModel.isSelected(fileID) == false) {\n                                groupPane.makeSelection(false, fileID);\n                            }\n                        }\n\n                        if (contextMenu != null) {\n                            contextMenu.hide();\n                        }\n                        final ContextMenu groupContextMenu = groupPane.getContextMenu();\n                        if (groupContextMenu != null) {\n                            groupContextMenu.hide();\n                        }\n                        contextMenu = buildContextMenu();\n                        contextMenu.show(DrawableViewBase.this, t.getScreenX(), t.getScreenY());\n\n                        break;\n                }\n                t.consume();\n            }\n\n            private ContextMenu buildContextMenu() {\n                final ArrayList<MenuItem> menuItems = new ArrayList<>();\n\n                menuItems.add(CategorizeAction.getPopupMenu());\n\n                menuItems.add(AddDrawableTagAction.getInstance().getPopupMenu());\n\n                final MenuItem extractMenuItem = new MenuItem(\"Extract File(s)\");\n                extractMenuItem.setOnAction((ActionEvent t) -> {\n                    SwingUtilities.invokeLater(() -> {\n                        TopComponent etc = WindowManager.getDefault().findTopComponent(ImageGalleryTopComponent.PREFERRED_ID);\n                        ExtractAction.getInstance().actionPerformed(new java.awt.event.ActionEvent(etc, 0, null));\n                    });\n                });\n                menuItems.add(extractMenuItem);\n\n                MenuItem contentViewer = new MenuItem(\"Show Content Viewer\");\n                contentViewer.setOnAction((ActionEvent t) -> {\n                    SwingUtilities.invokeLater(() -> {\n                        new NewWindowViewAction(\"Show Content Viewer\", new FileNode(getFile().getAbstractFile())).actionPerformed(null);\n                    });\n                });\n                menuItems.add(contentViewer);\n\n                MenuItem externalViewer = new MenuItem(\"Open in External Viewer\");\n                final ExternalViewerAction externalViewerAction = new ExternalViewerAction(\"Open in External Viewer\", new FileNode(getFile().getAbstractFile()));\n\n                externalViewer.setDisable(externalViewerAction.isEnabled() == false);\n                externalViewer.setOnAction((ActionEvent t) -> {\n                    SwingUtilities.invokeLater(() -> {\n                        externalViewerAction.actionPerformed(null);\n                    });\n                });\n                menuItems.add(externalViewer);\n\n                Collection<? extends ContextMenuActionsProvider> menuProviders = Lookup.getDefault().lookupAll(ContextMenuActionsProvider.class);\n\n                for (ContextMenuActionsProvider provider : menuProviders) {\n                    for (final Action act : provider.getActions()) {\n                        if (act instanceof Presenter.Popup) {\n                            Presenter.Popup aact = (Presenter.Popup) act;\n                            menuItems.add(SwingMenuItemAdapter.create(aact.getPopupPresenter()));\n                        }\n                    }\n                }\n\n                ContextMenu contextMenu = new ContextMenu(menuItems.toArray(new MenuItem[]{}));\n                contextMenu.setAutoHide(true);\n                return contextMenu;\n            }\n        });\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void activateTileViewer() {\n\n        groupViewMode.set(GroupViewMode.TILE);\n        setCenter(gridView);\n        gridView.requestFocus();\n        if (slideShowPane != null) {\n            slideShowPane.disposeContent();\n        }\n        this.scrollToFileID(globalSelectionModel.lastSelectedProperty().get());\n    }","id":76992,"modified_method":"public void activateTileViewer() {\n\n        groupViewMode.set(GroupViewMode.TILE);\n        setCenter(gridView);\n        gridView.requestFocus();\n        if (slideShowPane != null) {\n            slideShowPane.disposeContent();\n        }\n        slideShowPane = null;\n        this.scrollToFileID(globalSelectionModel.lastSelectedProperty().get());\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void activateSlideShowViewer(Long slideShowFileId) {\n        groupViewMode.set(GroupViewMode.SLIDE_SHOW);\n\n        //make a new slideShowPane if necessary\n        if (slideShowPane == null) {\n            slideShowPane = new SlideShowView(this);\n        }\n\n        //assign last selected file or if none first file in group\n        if (slideShowFileId == null || grouping.get().fileIds().contains(slideShowFileId) == false) {\n            slideShowPane.setFile(grouping.get().fileIds().get(0));\n        } else {\n            slideShowPane.setFile(slideShowFileId);\n        }\n        setCenter(slideShowPane);\n        slideShowPane.requestFocus();\n    }","id":76993,"modified_method":"@ThreadConfined(type = ThreadType.JFX)\n    public void activateSlideShowViewer(Long slideShowFileID) {\n        groupViewMode.set(GroupViewMode.SLIDE_SHOW);\n\n        //make a new slideShowPane if necessary\n        if (slideShowPane == null) {\n            slideShowPane = new SlideShowView(this);\n        }\n\n        //assign last selected file or if none first file in group\n        if (slideShowFileID == null || getGrouping().fileIds().contains(slideShowFileID) == false) {\n            slideShowPane.setFile(getGrouping().fileIds().get(0));\n        } else {\n            slideShowPane.setFile(slideShowFileID);\n        }\n        setCenter(slideShowPane);\n        slideShowPane.requestFocus();\n\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * assigns a grouping for this pane to represent and initializes grouping\n     * specific properties and listeners\n     *\n     * @param grouping the new grouping assigned to this group\n     */\n    void setViewState(GroupViewState viewState) {\n        if (nonNull(getGrouping())) {\n            getGrouping().fileIds().removeListener(filesSyncListener);\n        }\n\n        if (isNull(viewState) || isNull(viewState.getGroup())) {\n            this.grouping.set(null);\n            final List<Long> fileIds = Collections.emptyList();\n            final String header = \"\";\n            Platform.runLater(() -> {\n                setCenter(null);\n                gridView.getItems().setAll(fileIds);\n                groupLabel.setText(header);\n                resetScrollBar();\n                if (false == Case.isCaseOpen()) {\n                    cellMap.values().stream().forEach(DrawableCell::resetItem);\n                }\n            });\n\n        } else {\n            if (this.grouping.get() != viewState.getGroup()) {\n                this.grouping.set(viewState.getGroup());\n\n                this.getGrouping().fileIds().addListener(filesSyncListener);\n\n                final String header = getHeaderString();\n                final ObservableList<Long> fileIds = getGrouping().fileIds();\n                Platform.runLater(() -> {\n                    gridView.getItems().setAll(fileIds);\n                    groupLabel.setText(header);\n                    resetScrollBar();\n                    if (viewState.getMode() == GroupViewMode.TILE) {\n                        activateTileViewer();\n                    } else {\n                        activateSlideShowViewer(viewState.getSlideShowfileID().orElse(null));\n                    }\n                });\n            }\n        }\n    }","id":76994,"modified_method":"/**\n     * assigns a grouping for this pane to represent and initializes grouping\n     * specific properties and listeners\n     *\n     * @param grouping the new grouping assigned to this group\n     */\n    void setViewState(GroupViewState viewState) {\n        if (nonNull(getGrouping())) {\n            getGrouping().fileIds().removeListener(filesSyncListener);\n        }\n\n        if (isNull(viewState) || isNull(viewState.getGroup())) {\n            this.grouping.set(null);\n            gridView.getItems().setAll(Collections.emptyList());\n            Platform.runLater(() -> {\n                setCenter(null);\n\n                groupLabel.setText(\"\");\n                resetScrollBar();\n                if (false == Case.isCaseOpen()) {\n                    cellMap.values().stream().forEach(DrawableCell::resetItem);\n                    cellMap.clear();\n                }\n            });\n\n        } else {\n            if (this.grouping.get() != viewState.getGroup()) {\n                this.grouping.set(viewState.getGroup());\n\n                this.getGrouping().fileIds().addListener(filesSyncListener);\n\n                final String header = getHeaderString();\n\n                gridView.getItems().setAll(getGrouping().fileIds());\n                Platform.runLater(() -> {\n                    groupLabel.setText(header);\n                    resetScrollBar();\n                    if (viewState.getMode() == GroupViewMode.TILE) {\n                        activateTileViewer();\n                    } else {\n                        activateSlideShowViewer(viewState.getSlideShowfileID().orElse(null));\n                    }\n                });\n            }\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * called automatically during constructor by FXMLConstructor.\n     *\n     * checks that FXML loading went ok and performs additional setup\n     */\n    @FXML\n    void initialize() {\n        assert gridView != null : \"fx:id=\\\"tilePane\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\n        assert grpCatSplitMenu != null : \"fx:id=\\\"grpCatSplitMenu\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert grpTagSplitMenu != null : \"fx:id=\\\"grpTagSplitMenu\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert headerToolBar != null : \"fx:id=\\\"headerToolBar\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert segButton != null : \"fx:id=\\\"previewList\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert slideShowToggle != null : \"fx:id=\\\"segButton\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert tileToggle != null : \"fx:id=\\\"tileToggle\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n\n        //configure flashing glow animation on next unseen group button\n        flashAnimation.setCycleCount(Timeline.INDEFINITE);\n        flashAnimation.setAutoReverse(true);\n\n        //configure gridView cell properties\n        gridView.cellHeightProperty().bind(Toolbar.getDefault().sizeSliderValue().add(75));\n        gridView.cellWidthProperty().bind(Toolbar.getDefault().sizeSliderValue().add(75));\n        gridView.setCellFactory((GridView<Long> param) -> new DrawableCell());\n\n        //configure toolbar properties\n        HBox.setHgrow(spacer, Priority.ALWAYS);\n        spacer.setMinWidth(Region.USE_PREF_SIZE);\n\n        ArrayList<MenuItem> grpTagMenues = new ArrayList<>();\n        for (final TagName tn : TagUtils.getNonCategoryTagNames()) {\n            MenuItem menuItem = createGrpTagMenuItem(tn);\n            grpTagMenues.add(menuItem);\n        }\n        try {\n            grpTagSplitMenu.setText(TagUtils.getFollowUpTagName().getDisplayName());\n            grpTagSplitMenu.setOnAction(createGrpTagMenuItem(TagUtils.getFollowUpTagName()).getOnAction());\n        } catch (TskCoreException tskCoreException) {\n            LOGGER.log(Level.WARNING, \"failed to load FollowUpTagName\", tskCoreException);\n        }\n        grpTagSplitMenu.setGraphic(new ImageView(DrawableAttribute.TAGS.getIcon()));\n        grpTagSplitMenu.getItems().setAll(grpTagMenues);\n\n        ArrayList<MenuItem> grpCategoryMenues = new ArrayList<>();\n        for (final Category cat : Category.values()) {\n            MenuItem menuItem = createGrpCatMenuItem(cat);\n            grpCategoryMenues.add(menuItem);\n        }\n        grpCatSplitMenu.setText(Category.FIVE.getDisplayName());\n        grpCatSplitMenu.setGraphic(new ImageView(DrawableAttribute.CATEGORY.getIcon()));\n        grpCatSplitMenu.getItems().setAll(grpCategoryMenues);\n        grpCatSplitMenu.setOnAction(createGrpCatMenuItem(Category.FIVE).getOnAction());\n\n        Runnable syncMode = () -> {\n            switch (groupViewMode.get()) {\n                case SLIDE_SHOW:\n                    slideShowToggle.setSelected(true);\n                    break;\n                case TILE:\n                    tileToggle.setSelected(true);\n                    break;\n            }\n        };\n        syncMode.run();\n        //make togle states match view state\n        groupViewMode.addListener((o) -> {\n            syncMode.run();\n        });\n\n        slideShowToggle.toggleGroupProperty().addListener((o) -> {\n            slideShowToggle.getToggleGroup().selectedToggleProperty().addListener((observable, oldToggle, newToggle) -> {\n                if (newToggle == null) {\n                    oldToggle.setSelected(true);\n                }\n            });\n        });\n\n        //listen to toggles and update view state\n        slideShowToggle.setOnAction((ActionEvent t) -> {\n            activateSlideShowViewer(globalSelectionModel.lastSelectedProperty().get());\n        });\n\n        tileToggle.setOnAction((ActionEvent t) -> {\n            activateTileViewer();\n        });\n\n        controller.viewState().addListener((ObservableValue<? extends GroupViewState> observable, GroupViewState oldValue, GroupViewState newValue) -> {\n            setViewState(newValue);\n        });\n\n        addEventFilter(KeyEvent.KEY_PRESSED, tileKeyboardNavigationHandler);\n        gridView.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {\n\n            private ContextMenu buildContextMenu() {\n                ArrayList<MenuItem> menuItems = new ArrayList<>();\n\n                menuItems.add(CategorizeAction.getPopupMenu());\n\n                menuItems.add(AddDrawableTagAction.getInstance().getPopupMenu());\n\n                Collection<? extends ContextMenuActionsProvider> menuProviders = Lookup.getDefault().lookupAll(ContextMenuActionsProvider.class);\n\n                for (ContextMenuActionsProvider provider : menuProviders) {\n\n                    for (final Action act : provider.getActions()) {\n\n                        if (act instanceof Presenter.Popup) {\n                            Presenter.Popup aact = (Presenter.Popup) act;\n\n                            menuItems.add(SwingMenuItemAdapter.create(aact.getPopupPresenter()));\n                        }\n                    }\n                }\n                final MenuItem extractMenuItem = new MenuItem(\"Extract File(s)\");\n                extractMenuItem.setOnAction((ActionEvent t) -> {\n                    SwingUtilities.invokeLater(() -> {\n                        TopComponent etc = WindowManager.getDefault().findTopComponent(ImageGalleryTopComponent.PREFERRED_ID);\n                        ExtractAction.getInstance().actionPerformed(new java.awt.event.ActionEvent(etc, 0, null));\n                    });\n                });\n                menuItems.add(extractMenuItem);\n\n                ContextMenu contextMenu = new ContextMenu(menuItems.toArray(new MenuItem[]{}));\n                contextMenu.setAutoHide(true);\n                return contextMenu;\n            }\n\n            @Override\n            public void handle(MouseEvent t) {\n                switch (t.getButton()) {\n                    case PRIMARY:\n                        if (t.getClickCount() == 1) {\n                            globalSelectionModel.clearSelection();\n                            if (contextMenu != null) {\n                                contextMenu.hide();\n                            }\n                        }\n                        t.consume();\n                        break;\n                    case SECONDARY:\n                        if (t.getClickCount() == 1) {\n                            selectAllFiles();\n                        }\n                        if (contextMenu == null) {\n                            contextMenu = buildContextMenu();\n                        }\n\n                        contextMenu.hide();\n                        contextMenu.show(GroupPane.this, t.getScreenX(), t.getScreenY());\n                        t.consume();\n                        break;\n                }\n            }\n        });\n\n        ActionUtils.configureButton(nextGroupAction, nextButton);\n        final EventHandler<ActionEvent> onAction = nextButton.getOnAction();\n        nextButton.setOnAction((ActionEvent event) -> {\n            flashAnimation.stop();\n            nextButton.setEffect(null);\n            onAction.handle(event);\n        });\n\n        ActionUtils.configureButton(forwardAction, forwardButton);\n        ActionUtils.configureButton(backAction, backButton);\n\n        nextGroupAction.disabledProperty().addListener((ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) -> {\n            nextButton.setEffect(newValue ? null : DROP_SHADOW);\n            if (newValue == false) {\n                flashAnimation.play();\n            } else {\n                flashAnimation.stop();\n            }\n        });\n\n        //listen to tile selection and make sure it is visible in scroll area\n        //TODO: make sure we are testing complete visability not just bounds intersection\n        globalSelectionModel.lastSelectedProperty().addListener((observable, oldFileID, newFileId) -> {\n            if (groupViewMode.get() == GroupViewMode.SLIDE_SHOW) {\n                slideShowPane.setFile(newFileId);\n            } else {\n\n                scrollToFileID(newFileId);\n            }\n        });\n\n        setViewState(controller.viewState().get());\n    }","id":76995,"modified_method":"/**\n     * called automatically during constructor by FXMLConstructor.\n     *\n     * checks that FXML loading went ok and performs additional setup\n     */\n    @FXML\n    void initialize() {\n        assert gridView != null : \"fx:id=\\\"tilePane\\\" was not injected: check your FXML file 'GroupPane.fxml'.\";\n        assert grpCatSplitMenu != null : \"fx:id=\\\"grpCatSplitMenu\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert grpTagSplitMenu != null : \"fx:id=\\\"grpTagSplitMenu\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert headerToolBar != null : \"fx:id=\\\"headerToolBar\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert segButton != null : \"fx:id=\\\"previewList\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert slideShowToggle != null : \"fx:id=\\\"segButton\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n        assert tileToggle != null : \"fx:id=\\\"tileToggle\\\" was not injected: check your FXML file 'GroupHeader.fxml'.\";\n\n        //configure flashing glow animation on next unseen group button\n        flashAnimation.setCycleCount(Timeline.INDEFINITE);\n        flashAnimation.setAutoReverse(true);\n\n        //configure gridView cell properties\n        gridView.cellHeightProperty().bind(Toolbar.getDefault().sizeSliderValue().add(75));\n        gridView.cellWidthProperty().bind(Toolbar.getDefault().sizeSliderValue().add(75));\n        gridView.setCellFactory((GridView<Long> param) -> new DrawableCell());\n\n        //configure toolbar properties\n        HBox.setHgrow(spacer, Priority.ALWAYS);\n        spacer.setMinWidth(Region.USE_PREF_SIZE);\n\n        ArrayList<MenuItem> grpTagMenues = new ArrayList<>();\n        for (final TagName tn : TagUtils.getNonCategoryTagNames()) {\n            MenuItem menuItem = createGrpTagMenuItem(tn);\n            grpTagMenues.add(menuItem);\n        }\n        try {\n            grpTagSplitMenu.setText(TagUtils.getFollowUpTagName().getDisplayName());\n            grpTagSplitMenu.setOnAction(createGrpTagMenuItem(TagUtils.getFollowUpTagName()).getOnAction());\n        } catch (TskCoreException tskCoreException) {\n            LOGGER.log(Level.WARNING, \"failed to load FollowUpTagName\", tskCoreException);\n        }\n        grpTagSplitMenu.setGraphic(new ImageView(DrawableAttribute.TAGS.getIcon()));\n        grpTagSplitMenu.getItems().setAll(grpTagMenues);\n\n        ArrayList<MenuItem> grpCategoryMenues = new ArrayList<>();\n        for (final Category cat : Category.values()) {\n            MenuItem menuItem = createGrpCatMenuItem(cat);\n            grpCategoryMenues.add(menuItem);\n        }\n        grpCatSplitMenu.setText(Category.FIVE.getDisplayName());\n        grpCatSplitMenu.setGraphic(new ImageView(DrawableAttribute.CATEGORY.getIcon()));\n        grpCatSplitMenu.getItems().setAll(grpCategoryMenues);\n        grpCatSplitMenu.setOnAction(createGrpCatMenuItem(Category.FIVE).getOnAction());\n\n        Runnable syncMode = () -> {\n            switch (groupViewMode.get()) {\n                case SLIDE_SHOW:\n                    slideShowToggle.setSelected(true);\n                    break;\n                case TILE:\n                    tileToggle.setSelected(true);\n                    break;\n            }\n        };\n        syncMode.run();\n        //make togle states match view state\n        groupViewMode.addListener((o) -> {\n            syncMode.run();\n        });\n\n        slideShowToggle.toggleGroupProperty().addListener((o) -> {\n            slideShowToggle.getToggleGroup().selectedToggleProperty().addListener((observable, oldToggle, newToggle) -> {\n                if (newToggle == null) {\n                    oldToggle.setSelected(true);\n                }\n            });\n        });\n\n        //listen to toggles and update view state\n        slideShowToggle.setOnAction((ActionEvent t) -> {\n            activateSlideShowViewer(globalSelectionModel.lastSelectedProperty().get());\n        });\n\n        tileToggle.setOnAction((ActionEvent t) -> {\n            activateTileViewer();\n        });\n\n        controller.viewState().addListener((ObservableValue<? extends GroupViewState> observable, GroupViewState oldValue, GroupViewState newValue) -> {\n            setViewState(newValue);\n        });\n\n        addEventFilter(KeyEvent.KEY_PRESSED, tileKeyboardNavigationHandler);\n        gridView.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {\n\n            private ContextMenu buildContextMenu() {\n                ArrayList<MenuItem> menuItems = new ArrayList<>();\n\n                menuItems.add(CategorizeAction.getPopupMenu());\n\n                menuItems.add(AddDrawableTagAction.getInstance().getPopupMenu());\n\n                Collection<? extends ContextMenuActionsProvider> menuProviders = Lookup.getDefault().lookupAll(ContextMenuActionsProvider.class);\n\n                for (ContextMenuActionsProvider provider : menuProviders) {\n\n                    for (final Action act : provider.getActions()) {\n\n                        if (act instanceof Presenter.Popup) {\n                            Presenter.Popup aact = (Presenter.Popup) act;\n\n                            menuItems.add(SwingMenuItemAdapter.create(aact.getPopupPresenter()));\n                        }\n                    }\n                }\n                final MenuItem extractMenuItem = new MenuItem(\"Extract File(s)\");\n                extractMenuItem.setOnAction((ActionEvent t) -> {\n                    SwingUtilities.invokeLater(() -> {\n                        TopComponent etc = WindowManager.getDefault().findTopComponent(ImageGalleryTopComponent.PREFERRED_ID);\n                        ExtractAction.getInstance().actionPerformed(new java.awt.event.ActionEvent(etc, 0, null));\n                    });\n                });\n                menuItems.add(extractMenuItem);\n\n                ContextMenu contextMenu = new ContextMenu(menuItems.toArray(new MenuItem[]{}));\n                contextMenu.setAutoHide(true);\n                return contextMenu;\n            }\n\n            @Override\n            public void handle(MouseEvent t) {\n                switch (t.getButton()) {\n                    case PRIMARY:\n                        if (t.getClickCount() == 1) {\n                            globalSelectionModel.clearSelection();\n                            if (contextMenu != null) {\n                                contextMenu.hide();\n                            }\n                        }\n                        t.consume();\n                        break;\n                    case SECONDARY:\n                        if (t.getClickCount() == 1) {\n                            selectAllFiles();\n                        }\n                        if (globalSelectionModel.getSelected().isEmpty() == false) {\n                            if (contextMenu == null) {\n                                contextMenu = buildContextMenu();\n                            }\n\n                            contextMenu.hide();\n                            contextMenu.show(GroupPane.this, t.getScreenX(), t.getScreenY());\n                        }\n                        t.consume();\n                        break;\n                }\n            }\n        });\n\n        ActionUtils.configureButton(nextGroupAction, nextButton);\n        final EventHandler<ActionEvent> onAction = nextButton.getOnAction();\n        nextButton.setOnAction((ActionEvent event) -> {\n            flashAnimation.stop();\n            nextButton.setEffect(null);\n            onAction.handle(event);\n        });\n\n        ActionUtils.configureButton(forwardAction, forwardButton);\n        ActionUtils.configureButton(backAction, backButton);\n\n        nextGroupAction.disabledProperty().addListener((ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) -> {\n            nextButton.setEffect(newValue ? null : DROP_SHADOW);\n            if (newValue == false) {\n                flashAnimation.play();\n            } else {\n                flashAnimation.stop();\n            }\n        });\n\n        //listen to tile selection and make sure it is visible in scroll area\n        //TODO: make sure we are testing complete visability not just bounds intersection\n        globalSelectionModel.lastSelectedProperty().addListener((observable, oldFileID, newFileId) -> {\n            if (groupViewMode.get() == GroupViewMode.SLIDE_SHOW) {\n                slideShowPane.setFile(newFileId);\n            } else {\n\n                scrollToFileID(newFileId);\n            }\n        });\n\n        setViewState(controller.viewState().get());\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void resetItem() {\n            updateItem(null, true);\n            tile.setFile(null);\n        }","id":76996,"modified_method":"void resetItem() {\n//            updateItem(null, true);\n            tile.setFile(null);\n        }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void setFile(Long fileID) {\n        this.fileID = fileID;\n\n        if (fileID == null) {\n\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                tableView.getItems().clear();\n                getBorderable().setBorder(null);\n\n            });\n        } else {\n            try {\n                file = controller.getFileFromId(fileID);\n                updateUI();\n            } catch (TskCoreException ex) {\n                LOGGER.log(Level.WARNING, \"Failed to get drawable file from ID\", ex);\n            }\n        }\n    }","id":76997,"modified_method":"@Override\n    public void setFile(Long fileID) {\n        this.fileID = fileID;\n\n        if (fileID == null) {\n\n            Platform.runLater(() -> {\n                imageView.setImage(null);\n                tableView.getItems().clear();\n                getCategoryBorderRegion().setBorder(null);\n\n            });\n        } else {\n            try {\n                file = controller.getFileFromId(fileID);\n                updateUI();\n            } catch (TskCoreException ex) {\n                LOGGER.log(Level.WARNING, \"Failed to get drawable file from ID\", ex);\n            }\n        }\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"SlideShowView(GroupPane gp) {\n        super();\n        groupPane = gp;\n        FXMLConstructor.construct(this, \"SlideShow.fxml\");\n\n    }","id":76998,"modified_method":"SlideShowView(GroupPane gp) {\n        super(gp);\n        FXMLConstructor.construct(this, \"SlideShow.fxml\");\n\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    protected String getLabelText() {\n        return file.getName() + \" \" + getSupplementalText();\n    }","id":76999,"modified_method":"@Override\n    protected String getTextForLabel() {\n        return getFile().getName() + \" \" + getSupplementalText();\n    }","commit_id":"f4f568bff131f6bb5e1a6a40beb2dc96f971fab4","url":"https://github.com/sleuthkit/autopsy"}]